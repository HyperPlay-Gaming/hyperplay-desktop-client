LavaPack.loadBundle([
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\function-bind\\implementation.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\function-bind\implementation.js
      return function (require, module, exports) {
'use strict';

/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var slice = Array.prototype.slice;
var toStr = Object.prototype.toString;
var funcType = '[object Function]';

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                args.concat(slice.call(arguments))
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        } else {
            return target.apply(
                that,
                args.concat(slice.call(arguments))
            );
        }
    };

    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs.push('$' + i);
    }

    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};

      };
    };
  }
}, {package:"mocha>object.assign>function-bind",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\function-bind\\index.js", {"./implementation":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\function-bind\\implementation.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\function-bind\index.js
      return function (require, module, exports) {
'use strict';

var implementation = require('./implementation');

module.exports = Function.prototype.bind || implementation;

      };
    };
  }
}, {package:"mocha>object.assign>function-bind",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\functions-have-names\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\functions-have-names\index.js
      return function (require, module, exports) {
'use strict';

var functionsHaveNames = function functionsHaveNames() {
	return typeof function f() {}.name === 'string';
};

var gOPD = Object.getOwnPropertyDescriptor;
if (gOPD) {
	try {
		gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		gOPD = null;
	}
}

functionsHaveNames.functionsHaveConfigurableNames = function functionsHaveConfigurableNames() {
	if (!functionsHaveNames() || !gOPD) {
		return false;
	}
	var desc = gOPD(function () {}, 'name');
	return !!desc && !!desc.configurable;
};

var $bind = Function.prototype.bind;

functionsHaveNames.boundFunctionsHaveNames = function boundFunctionsHaveNames() {
	return functionsHaveNames() && typeof $bind === 'function' && function f() {}.bind().name !== '';
};

module.exports = functionsHaveNames;

      };
    };
  }
}, {package:"enzyme>function.prototype.name>functions-have-names",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\fuse.js\\dist\\fuse.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\fuse.js\dist\fuse.js
      return function (require, module, exports) {
/*!
 * Fuse.js v3.6.1 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("Fuse",[],t):"object"==typeof exports?exports.Fuse=t():e.Fuse=t()}(this,function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){function n(e){return(n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var i=r(1),a=r(7),s=a.get,c=(a.deepValue,a.isArray),h=function(){function e(t,r){var n=r.location,o=void 0===n?0:n,i=r.distance,a=void 0===i?100:i,c=r.threshold,h=void 0===c?.6:c,l=r.maxPatternLength,u=void 0===l?32:l,f=r.caseSensitive,v=void 0!==f&&f,p=r.tokenSeparator,d=void 0===p?/ +/g:p,g=r.findAllMatches,y=void 0!==g&&g,m=r.minMatchCharLength,k=void 0===m?1:m,b=r.id,S=void 0===b?null:b,x=r.keys,M=void 0===x?[]:x,_=r.shouldSort,w=void 0===_||_,L=r.getFn,A=void 0===L?s:L,O=r.sortFn,C=void 0===O?function(e,t){return e.score-t.score}:O,j=r.tokenize,P=void 0!==j&&j,I=r.matchAllTokens,F=void 0!==I&&I,T=r.includeMatches,N=void 0!==T&&T,z=r.includeScore,E=void 0!==z&&z,W=r.verbose,K=void 0!==W&&W;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:a,threshold:h,maxPatternLength:u,isCaseSensitive:v,tokenSeparator:d,findAllMatches:y,minMatchCharLength:k,id:S,keys:M,includeMatches:N,includeScore:E,shouldSort:w,getFn:A,sortFn:C,verbose:K,tokenize:P,matchAllTokens:F},this.setCollection(t),this._processKeys(M)}var t,r,a;return t=e,(r=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"_processKeys",value:function(e){if(this._keyWeights={},this._keyNames=[],e.length&&"string"==typeof e[0])for(var t=0,r=e.length;t<r;t+=1){var n=e[t];this._keyWeights[n]=1,this._keyNames.push(n)}else{for(var o=null,i=null,a=0,s=0,c=e.length;s<c;s+=1){var h=e[s];if(!h.hasOwnProperty("name"))throw new Error('Missing "name" property in key object');var l=h.name;if(this._keyNames.push(l),!h.hasOwnProperty("weight"))throw new Error('Missing "weight" property in key object');var u=h.weight;if(u<0||u>1)throw new Error('"weight" property in key must bein the range of [0, 1)');i=null==i?u:Math.max(i,u),o=null==o?u:Math.min(o,u),this._keyWeights[l]=u,a+=u}if(a>1)throw new Error("Total of weights cannot exceed 1")}}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var r=this._prepareSearchers(e),n=r.tokenSearchers,o=r.fullSearcher,i=this._search(n,o);return this._computeScore(i),this.options.shouldSort&&this._sort(i),t.limit&&"number"==typeof t.limit&&(i=i.slice(0,t.limit)),this._format(i)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize)for(var r=e.split(this.options.tokenSeparator),n=0,o=r.length;n<o;n+=1)t.push(new i(r[n],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,r=this.list,n={},o=[];if("string"==typeof r[0]){for(var i=0,a=r.length;i<a;i+=1)this._analyze({key:"",value:r[i],record:i,index:i},{resultMap:n,results:o,tokenSearchers:e,fullSearcher:t});return o}for(var s=0,c=r.length;s<c;s+=1)for(var h=r[s],l=0,u=this._keyNames.length;l<u;l+=1){var f=this._keyNames[l];this._analyze({key:f,value:this.options.getFn(h,f),record:h,index:s},{resultMap:n,results:o,tokenSearchers:e,fullSearcher:t})}return o}},{key:"_analyze",value:function(e,t){var r=this,n=e.key,o=e.arrayIndex,i=void 0===o?-1:o,a=e.value,s=e.record,h=e.index,l=t.tokenSearchers,u=void 0===l?[]:l,f=t.fullSearcher,v=t.resultMap,p=void 0===v?{}:v,d=t.results,g=void 0===d?[]:d;!function e(t,o,i,a){if(null!=o)if("string"==typeof o){var s=!1,h=-1,l=0;r._log("\nKey: ".concat(""===n?"--":n));var v=f.search(o);if(r._log('Full text: "'.concat(o,'", score: ').concat(v.score)),r.options.tokenize){for(var d=o.split(r.options.tokenSeparator),y=d.length,m=[],k=0,b=u.length;k<b;k+=1){var S=u[k];r._log('\nPattern: "'.concat(S.pattern,'"'));for(var x=!1,M=0;M<y;M+=1){var _=d[M],w=S.search(_),L={};w.isMatch?(L[_]=w.score,s=!0,x=!0,m.push(w.score)):(L[_]=1,r.options.matchAllTokens||m.push(1)),r._log('Token: "'.concat(_,'", score: ').concat(L[_]))}x&&(l+=1)}h=m[0];for(var A=m.length,O=1;O<A;O+=1)h+=m[O];h/=A,r._log("Token score average:",h)}var C=v.score;h>-1&&(C=(C+h)/2),r._log("Score average:",C);var j=!r.options.tokenize||!r.options.matchAllTokens||l>=u.length;if(r._log("\nCheck Matches: ".concat(j)),(s||v.isMatch)&&j){var P={key:n,arrayIndex:t,value:o,score:C};r.options.includeMatches&&(P.matchedIndices=v.matchedIndices);var I=p[a];I?I.output.push(P):(p[a]={item:i,output:[P]},g.push(p[a]))}}else if(c(o))for(var F=0,T=o.length;F<T;F+=1)e(F,o[F],i,a)}(i,a,s,h)}},{key:"_computeScore",value:function(e){this._log("\n\nComputing score:\n");for(var t=this._keyWeights,r=!!Object.keys(t).length,n=0,o=e.length;n<o;n+=1){for(var i=e[n],a=i.output,s=a.length,c=1,h=0;h<s;h+=1){var l=a[h],u=l.key,f=r?t[u]:1,v=0===l.score&&t&&t[u]>0?Number.EPSILON:l.score;c*=Math.pow(v,f)}i.score=c,this._log(i)}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn)}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var r=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===n(t)&&null!==t){if(-1!==r.indexOf(t))return;r.push(t)}return t},2)),r=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var r=e.output;t.matches=[];for(var n=0,o=r.length;n<o;n+=1){var i=r[n];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,r),a&&o(t,a),e}();e.exports=h},function(e,t,r){function n(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=r(2),i=r(3),a=r(6),s=function(){function e(t,r){var n=r.location,o=void 0===n?0:n,i=r.distance,s=void 0===i?100:i,c=r.threshold,h=void 0===c?.6:c,l=r.maxPatternLength,u=void 0===l?32:l,f=r.isCaseSensitive,v=void 0!==f&&f,p=r.tokenSeparator,d=void 0===p?/ +/g:p,g=r.findAllMatches,y=void 0!==g&&g,m=r.minMatchCharLength,k=void 0===m?1:m,b=r.includeMatches,S=void 0!==b&&b;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:v,tokenSeparator:d,findAllMatches:y,includeMatches:S,minMatchCharLength:k},this.pattern=v?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,r,s;return t=e,(r=[{key:"search",value:function(e){var t=this.options,r=t.isCaseSensitive,n=t.includeMatches;if(r||(e=e.toLowerCase()),this.pattern===e){var a={isMatch:!0,score:0};return n&&(a.matchedIndices=[[0,e.length-1]]),a}var s=this.options,c=s.maxPatternLength,h=s.tokenSeparator;if(this.pattern.length>c)return o(e,this.pattern,h);var l=this.options,u=l.location,f=l.distance,v=l.threshold,p=l.findAllMatches,d=l.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:u,distance:f,threshold:v,findAllMatches:p,minMatchCharLength:d,includeMatches:n})}}])&&n(t.prototype,r),s&&n(t,s),e}();e.exports=s},function(e,t){var r=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(r,"\\$&").replace(n,"|")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,r){var n=r(4),o=r(5);e.exports=function(e,t,r,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,v=void 0!==f&&f,p=i.minMatchCharLength,d=void 0===p?1:p,g=i.includeMatches,y=void 0!==g&&g,m=s,k=e.length,b=u,S=e.indexOf(t,m),x=t.length,M=[],_=0;_<k;_+=1)M[_]=0;if(-1!==S){var w=n(t,{errors:0,currentLocation:S,expectedLocation:m,distance:h});if(b=Math.min(w,b),-1!==(S=e.lastIndexOf(t,m+x))){var L=n(t,{errors:0,currentLocation:S,expectedLocation:m,distance:h});b=Math.min(L,b)}}S=-1;for(var A=[],O=1,C=x+k,j=1<<(x<=31?x-1:30),P=0;P<x;P+=1){for(var I=0,F=C;I<F;){n(t,{errors:P,currentLocation:m+F,expectedLocation:m,distance:h})<=b?I=F:C=F,F=Math.floor((C-I)/2+I)}C=F;var T=Math.max(1,m-F+1),N=v?k:Math.min(m+F,k)+x,z=Array(N+2);z[N+1]=(1<<P)-1;for(var E=N;E>=T;E-=1){var W=E-1,K=r[e.charAt(W)];if(K&&(M[W]=1),z[E]=(z[E+1]<<1|1)&K,0!==P&&(z[E]|=(A[E+1]|A[E])<<1|1|A[E+1]),z[E]&j&&(O=n(t,{errors:P,currentLocation:W,expectedLocation:m,distance:h}))<=b){if(b=O,(S=W)<=m)break;T=Math.max(1,2*m-S)}}if(n(t,{errors:P+1,currentLocation:m,expectedLocation:m,distance:h})>b)break;A=z}var $={isMatch:S>=0,score:0===O?.001:O};return y&&($.matchedIndices=o(M,d)),$}},function(e,t){e.exports=function(e,t){var r=t.errors,n=void 0===r?0:r,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=n/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,r=[],n=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===n?n=i:s||-1===n||((o=i-1)-n+1>=t&&r.push([n,o]),n=-1)}return e[i-1]&&i-n>=t&&r.push([n,i-1]),r}},function(e,t){e.exports=function(e){for(var t={},r=e.length,n=0;n<r;n+=1)t[e.charAt(n)]=0;for(var o=0;o<r;o+=1)t[e.charAt(o)]|=1<<r-o-1;return t}},function(e,t){var r=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)},n=function(e){return null==e?"":function(e){if("string"==typeof e)return e;var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}(e)},o=function(e){return"string"==typeof e},i=function(e){return"number"==typeof e};e.exports={get:function(e,t){var a=[];return function e(t,s){if(s){var c=s.indexOf("."),h=s,l=null;-1!==c&&(h=s.slice(0,c),l=s.slice(c+1));var u=t[h];if(null!=u)if(l||!o(u)&&!i(u))if(r(u))for(var f=0,v=u.length;f<v;f+=1)e(u[f],l);else l&&e(u,l);else a.push(n(u))}else a.push(t)}(e,t),a},isArray:r,isString:o,isNum:i,toString:n}}])});
      };
    };
  }
}, {package:"fuse.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\get-intrinsic\\index.js", {"function-bind":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\function-bind\\index.js","has":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has\\src\\index.js","has-symbols":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-symbols\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\get-intrinsic\index.js
      return function (require, module, exports) {
'use strict';

var undefined;

var $SyntaxError = SyntaxError;
var $Function = Function;
var $TypeError = TypeError;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = Object.getOwnPropertyDescriptor;
if ($gOPD) {
	try {
		$gOPD({}, '');
	} catch (e) {
		$gOPD = null; // this is IE 8, which has a broken gOPD
	}
}

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = require('has-symbols')();

var getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': EvalError,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': Object,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': RangeError,
	'%ReferenceError%': ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet
};

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = require('function-bind');
var hasOwn = require('has');
var $concat = bind.call(Function.call, Array.prototype.concat);
var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
var $replace = bind.call(Function.call, String.prototype.replace);
var $strSlice = bind.call(Function.call, String.prototype.slice);
var $exec = bind.call(Function.call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};

      };
    };
  }
}, {package:"string.prototype.matchall>get-intrinsic",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\get-params\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\get-params\index.js
      return function (require, module, exports) {
/* global window */
var GetParams = function (func) {
	'use strict';

	if (typeof func !== 'function') {
		return [];
	}

	var patternComments = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
	var patternArguments = /([^\s,]+)/g;

	var funcString = func
		.toString()
		.replace(patternComments, '');

	var result = funcString
		.slice(
			funcString.indexOf('(') + 1,
			funcString.indexOf(')')
		)
		.match(patternArguments);

	if (result === null) {
		return [];
	}

	return result;
};

if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
	module.exports = GetParams;
}

if (typeof window !== 'undefined') {
	window.GetParams = GetParams;
}

      };
    };
  }
}, {package:"remote-redux-devtools>redux-devtools-core>get-params",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-mat4\\identity.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gl-mat4\identity.js
      return function (require, module, exports) {
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
      };
    };
  }
}, {package:"@metamask/logo>gl-mat4",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-mat4\\invert.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gl-mat4\invert.js
      return function (require, module, exports) {
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
      };
    };
  }
}, {package:"@metamask/logo>gl-mat4",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-mat4\\lookAt.js", {"./identity":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-mat4\\identity.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gl-mat4\lookAt.js
      return function (require, module, exports) {
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
      };
    };
  }
}, {package:"@metamask/logo>gl-mat4",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-mat4\\multiply.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gl-mat4\multiply.js
      return function (require, module, exports) {
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
      };
    };
  }
}, {package:"@metamask/logo>gl-mat4",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-mat4\\perspective.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gl-mat4\perspective.js
      return function (require, module, exports) {
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
      };
    };
  }
}, {package:"@metamask/logo>gl-mat4",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-mat4\\rotate.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gl-mat4\rotate.js
      return function (require, module, exports) {
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
      };
    };
  }
}, {package:"@metamask/logo>gl-mat4",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gl-vec3\\transformMat4.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gl-vec3\transformMat4.js
      return function (require, module, exports) {
module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}
      };
    };
  }
}, {package:"@metamask/logo>gl-vec3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gud\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\gud\index.js
      return function (require, module, exports) {
// @flow
'use strict';

var key = '__global_unique_id__';

module.exports = function() {
  return global[key] = (global[key] || 0) + 1;
};

      };
    };
  }
}, {package:"react-router-dom>react-router>mini-create-react-context>gud",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-property-descriptors\\index.js", {"get-intrinsic":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\get-intrinsic\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\has-property-descriptors\index.js
      return function (require, module, exports) {
'use strict';

var GetIntrinsic = require('get-intrinsic');

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasPropertyDescriptors = function hasPropertyDescriptors() {
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
			return true;
		} catch (e) {
			// IE 8 has a broken defineProperty
			return false;
		}
	}
	return false;
};

hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
	// node v0.6 has a bug where array lengths can be Set but not Defined
	if (!hasPropertyDescriptors()) {
		return null;
	}
	try {
		return $defineProperty([], 'length', { value: 1 }).length !== 1;
	} catch (e) {
		// In Firefox 4-22, defining length on an array throws an exception.
		return true;
	}
};

module.exports = hasPropertyDescriptors;

      };
    };
  }
}, {package:"globalthis>define-properties>has-property-descriptors",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-symbols\\index.js", {"./shams":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-symbols\\shams.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\has-symbols\index.js
      return function (require, module, exports) {
'use strict';

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = require('./shams');

module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};

      };
    };
  }
}, {package:"string.prototype.matchall>has-symbols",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-symbols\\shams.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\has-symbols\shams.js
      return function (require, module, exports) {
'use strict';

/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};

      };
    };
  }
}, {package:"string.prototype.matchall>has-symbols",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-tostringtag\\shams.js", {"has-symbols/shams":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-symbols\\shams.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\has-tostringtag\shams.js
      return function (require, module, exports) {
'use strict';

var hasSymbols = require('has-symbols/shams');

module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};

      };
    };
  }
}, {package:"koa>is-generator-function>has-tostringtag",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has\\src\\index.js", {"function-bind":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\function-bind\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\has\src\index.js
      return function (require, module, exports) {
'use strict';

var bind = require('function-bind');

module.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);

      };
    };
  }
}, {package:"enzyme>has",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\header-case\\header-case.js", {"no-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\no-case.js","upper-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\upper-case\\upper-case.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\header-case\header-case.js
      return function (require, module, exports) {
var noCase = require('no-case')
var upperCase = require('upper-case')

/**
 * Header case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-').replace(/^.|-./g, function (m) {
    return upperCase(m, locale)
  })
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>header-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js", {"react-is":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-is\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\hoist-non-react-statics\dist\hoist-non-react-statics.cjs.js
      return function (require, module, exports) {
'use strict';

var reactIs = require('react-is');

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
  childContextTypes: true,
  contextType: true,
  contextTypes: true,
  defaultProps: true,
  displayName: true,
  getDefaultProps: true,
  getDerivedStateFromError: true,
  getDerivedStateFromProps: true,
  mixins: true,
  propTypes: true,
  type: true
};
var KNOWN_STATICS = {
  name: true,
  length: true,
  prototype: true,
  caller: true,
  callee: true,
  arguments: true,
  arity: true
};
var FORWARD_REF_STATICS = {
  '$$typeof': true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  '$$typeof': true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;

function getStatics(component) {
  // React v16.11 and below
  if (reactIs.isMemo(component)) {
    return MEMO_STATICS;
  } // React v16.12 and above


  return TYPE_STATICS[component['$$typeof']] || REACT_STATICS;
}

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = Object.prototype;
function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
  if (typeof sourceComponent !== 'string') {
    // don't hoist over string (html) components
    if (objectPrototype) {
      var inheritedComponent = getPrototypeOf(sourceComponent);

      if (inheritedComponent && inheritedComponent !== objectPrototype) {
        hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
      }
    }

    var keys = getOwnPropertyNames(sourceComponent);

    if (getOwnPropertySymbols) {
      keys = keys.concat(getOwnPropertySymbols(sourceComponent));
    }

    var targetStatics = getStatics(targetComponent);
    var sourceStatics = getStatics(sourceComponent);

    for (var i = 0; i < keys.length; ++i) {
      var key = keys[i];

      if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
        var descriptor = getOwnPropertyDescriptor(sourceComponent, key);

        try {
          // Avoid failures from read-only properties
          defineProperty(targetComponent, key, descriptor);
        } catch (e) {}
      }
    }
  }

  return targetComponent;
}

module.exports = hoistNonReactStatics;

      };
    };
  }
}, {package:"react-redux>hoist-non-react-statics",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\hyphenate-style-name\\index.cjs.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\hyphenate-style-name\index.cjs.js
      return function (require, module, exports) {
'use strict';

/* eslint-disable no-var, prefer-template */
var uppercasePattern = /[A-Z]/g;
var msPattern = /^ms-/;
var cache = {};

function toHyphenLower(match) {
  return '-' + match.toLowerCase()
}

function hyphenateStyleName(name) {
  if (cache.hasOwnProperty(name)) {
    return cache[name]
  }

  var hName = name.replace(uppercasePattern, toHyphenLower);
  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)
}

module.exports = hyphenateStyleName;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-camel-case>hyphenate-style-name",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\invariant\browser.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var invariant = function(condition, format, a, b, c, d, e, f) {
  if ("development" !== 'production') {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  }

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error(
        'Minified exception occurred; use the non-minified dev environment ' +
        'for the full error message and additional helpful warnings.'
      );
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(
        format.replace(/%s/g, function() { return args[argIndex++]; })
      );
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
};

module.exports = invariant;

      };
    };
  }
}, {package:"react-dnd>invariant",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-arguments\\index.js", {"call-bind/callBound":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\call-bind\\callBound.js","has-tostringtag/shams":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-arguments\index.js
      return function (require, module, exports) {
'use strict';

var hasToStringTag = require('has-tostringtag/shams')();
var callBound = require('call-bind/callBound');

var $toString = callBound('Object.prototype.toString');

var isStandardArguments = function isArguments(value) {
	if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
		return false;
	}
	return $toString(value) === '[object Arguments]';
};

var isLegacyArguments = function isArguments(value) {
	if (isStandardArguments(value)) {
		return true;
	}
	return value !== null &&
		typeof value === 'object' &&
		typeof value.length === 'number' &&
		value.length >= 0 &&
		$toString(value) !== '[object Array]' &&
		$toString(value.callee) === '[object Function]';
};

var supportsStandardArguments = (function () {
	return isStandardArguments(arguments);
}());

isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;

      };
    };
  }
}, {package:"@metamask/eth-token-tracker>deep-equal>is-arguments",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-date-object\\index.js", {"has-tostringtag/shams":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-date-object\index.js
      return function (require, module, exports) {
'use strict';

var getDay = Date.prototype.getDay;
var tryDateObject = function tryDateGetDayCall(value) {
	try {
		getDay.call(value);
		return true;
	} catch (e) {
		return false;
	}
};

var toStr = Object.prototype.toString;
var dateClass = '[object Date]';
var hasToStringTag = require('has-tostringtag/shams')();

module.exports = function isDateObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	return hasToStringTag ? tryDateObject(value) : toStr.call(value) === dateClass;
};

      };
    };
  }
}, {package:"@metamask/eth-token-tracker>deep-equal>is-date-object",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-dom\\index.js", {"is-object":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-object\\index.js","is-window":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-window\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-dom\index.js
      return function (require, module, exports) {
var isObject = require('is-object')
var isWindow = require('is-window')

function isNode (val) {
  if (!isObject(val) || !isWindow(window) || typeof window.Node !== 'function') {
    return false
  }

  return typeof val.nodeType === 'number' &&
    typeof val.nodeName === 'string'
}

module.exports = isNode

      };
    };
  }
}, {package:"react-inspector>is-dom",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-in-browser\\dist\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-in-browser\dist\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var isBrowser = exports.isBrowser = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && document.nodeType === 9;

exports.default = isBrowser;
      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss>is-in-browser",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-lower-case\\is-lower-case.js", {"lower-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-lower-case\is-lower-case.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

/**
 * Check if a string is lower case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return lowerCase(string, locale) === string
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>is-lower-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-object\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-object\index.js
      return function (require, module, exports) {
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

      };
    };
  }
}, {package:"proxyquire>fill-keys>is-object",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-regex\\index.js", {"call-bind/callBound":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\call-bind\\callBound.js","has-tostringtag/shams":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\has-tostringtag\\shams.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-regex\index.js
      return function (require, module, exports) {
'use strict';

var callBound = require('call-bind/callBound');
var hasToStringTag = require('has-tostringtag/shams')();
var has;
var $exec;
var isRegexMarker;
var badStringifier;

if (hasToStringTag) {
	has = callBound('Object.prototype.hasOwnProperty');
	$exec = callBound('RegExp.prototype.exec');
	isRegexMarker = {};

	var throwRegexMarker = function () {
		throw isRegexMarker;
	};
	badStringifier = {
		toString: throwRegexMarker,
		valueOf: throwRegexMarker
	};

	if (typeof Symbol.toPrimitive === 'symbol') {
		badStringifier[Symbol.toPrimitive] = throwRegexMarker;
	}
}

var $toString = callBound('Object.prototype.toString');
var gOPD = Object.getOwnPropertyDescriptor;
var regexClass = '[object RegExp]';

module.exports = hasToStringTag
	// eslint-disable-next-line consistent-return
	? function isRegex(value) {
		if (!value || typeof value !== 'object') {
			return false;
		}

		var descriptor = gOPD(value, 'lastIndex');
		var hasLastIndexDataProperty = descriptor && has(descriptor, 'value');
		if (!hasLastIndexDataProperty) {
			return false;
		}

		try {
			$exec(value, badStringifier);
		} catch (e) {
			return e === isRegexMarker;
		}
	}
	: function isRegex(value) {
		// In older browsers, typeof regex incorrectly returns 'function'
		if (!value || (typeof value !== 'object' && typeof value !== 'function')) {
			return false;
		}

		return $toString(value) === regexClass;
	};

      };
    };
  }
}, {package:"enzyme>is-regex",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-upper-case\\is-upper-case.js", {"upper-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\upper-case\\upper-case.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-upper-case\is-upper-case.js
      return function (require, module, exports) {
var upperCase = require('upper-case')

/**
 * Check if a string is upper case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return upperCase(string, locale) === string
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>is-upper-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-window\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\is-window\index.js
      return function (require, module, exports) {
'use strict';

module.exports = function (obj) {

  if (obj == null) {
    return false;
  }

  var o = Object(obj);

  return o === o.window;
};

      };
    };
  }
}, {package:"react-inspector>is-dom>is-window",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\index.js", {"./lib":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jsan\index.js
      return function (require, module, exports) {
module.exports = require('./lib');

      };
    };
  }
}, {package:"remote-redux-devtools>jsan",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\cycle.js", {"./path-getter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\path-getter.js","./utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jsan\lib\cycle.js
      return function (require, module, exports) {
var pathGetter = require('./path-getter');
var utils = require('./utils');

var WMap = typeof WeakMap !== 'undefined'?
  WeakMap:
  function() {
    var keys = [];
    var values = [];
    return {
      set: function(key, value) {
        keys.push(key);
        values.push(value);
      },
      get: function(key) {
        for (var i = 0; i < keys.length; i++) {
          if (keys[i] === key) {
            return values[i];
          }
        }
      }
    }
  };

// Based on https://github.com/douglascrockford/JSON-js/blob/master/cycle.js

exports.decycle = function decycle(object, options, replacer) {
  'use strict';

  var map = new WMap()

  var noCircularOption = !Object.prototype.hasOwnProperty.call(options, 'circular');
  var withRefs = options.refs !== false;

  return (function derez(_value, path, key) {

    // The derez recurses through the object, producing the deep copy.

    var i,        // The loop counter
      name,       // Property name
      nu;         // The new object or array

    // typeof null === 'object', so go on if this value is really an object but not
    // one of the weird builtin objects.

    var value = typeof replacer === 'function' ? replacer(key || '', _value) : _value;

    if (options.date && value instanceof Date) {
      return {$jsan: 'd' + value.getTime()};
    }
    if (options.regex && value instanceof RegExp) {
      return {$jsan: 'r' + utils.getRegexFlags(value) + ',' + value.source};
    }
    if (options['function'] && typeof value === 'function') {
      return {$jsan: 'f' + utils.stringifyFunction(value, options['function'])}
    }
    if (options['nan'] && typeof value === 'number' && isNaN(value)) {
      return {$jsan: 'n'}
    }
    if (options['infinity']) {
      if (Number.POSITIVE_INFINITY === value) return {$jsan: 'i'}
      if (Number.NEGATIVE_INFINITY === value) return {$jsan: 'y'}
    }
    if (options['undefined'] && value === undefined) {
      return {$jsan: 'u'}
    }
    if (options['error'] && value instanceof Error) {
      return {$jsan: 'e' + value.message}
    }
    if (options['symbol'] && typeof value === 'symbol') {
      var symbolKey = Symbol.keyFor(value)
      if (symbolKey !== undefined) {
        return {$jsan: 'g' + symbolKey}
      }

      // 'Symbol(foo)'.slice(7, -1) === 'foo'
      return {$jsan: 's' + value.toString().slice(7, -1)}
    }

    if (options['map'] && typeof Map === 'function' && value instanceof Map && typeof Array.from === 'function') {
      return {$jsan: 'm' + JSON.stringify(decycle(Array.from(value), options, replacer))}
    }

    if (options['set'] && typeof Set === 'function' && value instanceof Set && typeof Array.from === 'function') {
      return {$jsan: 'l' + JSON.stringify(decycle(Array.from(value), options, replacer))}
    }

    if (value && typeof value.toJSON === 'function') {
      try {
        value = value.toJSON(key);
      } catch (error) {
        var keyString = (key || '$');
        return "toJSON failed for '" + (map.get(value) || keyString) + "'";
      }
    }

    if (typeof value === 'object' && value !== null &&
      !(value instanceof Boolean) &&
      !(value instanceof Date)    &&
      !(value instanceof Number)  &&
      !(value instanceof RegExp)  &&
      !(value instanceof String)  &&
      !(typeof value === 'symbol')  &&
      !(value instanceof Error)) {

        // If the value is an object or array, look to see if we have already
        // encountered it. If so, return a $ref/path object.

      if (typeof value === 'object') {
        var foundPath = map.get(value);
        if (foundPath) {
          if (noCircularOption && withRefs) {
            return {$jsan: foundPath};
          }
          if (path.indexOf(foundPath) === 0) {
            if (!noCircularOption) {
              return typeof options.circular === 'function'?
              options.circular(value, path, foundPath):
              options.circular;
            }
            return {$jsan: foundPath};
          }
          if (withRefs) return {$jsan: foundPath};
        }
        map.set(value, path);
      }


      // If it is an array, replicate the array.

      if (Object.prototype.toString.apply(value) === '[object Array]') {
          nu = [];
          for (i = 0; i < value.length; i += 1) {
              nu[i] = derez(value[i], path + '[' + i + ']', i);
          }
      } else {

        // If it is an object, replicate the object.

        nu = {};
        for (name in value) {
          if (Object.prototype.hasOwnProperty.call(value, name)) {
            var nextPath = /^\w+$/.test(name) ?
              '.' + name :
              '[' + JSON.stringify(name) + ']';
            nu[name] = name === '$jsan' ? [derez(value[name], path + nextPath)] : derez(value[name], path + nextPath, name);
          }
        }
      }
      return nu;
    }
    return value;
  }(object, '$'));
};


exports.retrocycle = function retrocycle($) {
  'use strict';


  return (function rez(value) {

    // The rez function walks recursively through the object looking for $jsan
    // properties. When it finds one that has a value that is a path, then it
    // replaces the $jsan object with a reference to the value that is found by
    // the path.

    var i, item, name, path;

    if (value && typeof value === 'object') {
      if (Object.prototype.toString.apply(value) === '[object Array]') {
        for (i = 0; i < value.length; i += 1) {
          item = value[i];
          if (item && typeof item === 'object') {
            if (item.$jsan) {
              value[i] = utils.restore(item.$jsan, $);
            } else {
              rez(item);
            }
          }
        }
      } else {
        for (name in value) {
          // base case passed raw object
          if(typeof value[name] === 'string' && name === '$jsan'){
            return utils.restore(value.$jsan, $);
            break;
          }
          else {
            if (name === '$jsan') {
              value[name] = value[name][0];
            }
            if (typeof value[name] === 'object') {
              item = value[name];
              if (item && typeof item === 'object') {
                if (item.$jsan) {
                  value[name] = utils.restore(item.$jsan, $);
                } else {
                  rez(item);
                }
              }
            }
          }
        }
      }
    }
    return value;
  }($));
};

      };
    };
  }
}, {package:"remote-redux-devtools>jsan",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\index.js", {"./cycle":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\cycle.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jsan\lib\index.js
      return function (require, module, exports) {
var cycle = require('./cycle');

exports.stringify = function stringify(value, replacer, space, _options) {

  if (arguments.length < 4) {
    try {
      if (arguments.length === 1) {
        return JSON.stringify(value);
      } else {
        return JSON.stringify.apply(JSON, arguments);
      }
    } catch (e) {}
  }

  var options = _options || false;
  if (typeof options === 'boolean') {
    options = {
      'date': options,
      'function': options,
      'regex': options,
      'undefined': options,
      'error': options,
      'symbol': options,
      'map': options,
      'set': options,
      'nan': options,
      'infinity': options
    }
  }

  var decycled = cycle.decycle(value, options, replacer);
  if (arguments.length === 1) {
    return JSON.stringify(decycled);
  } else {
    // decycle already handles when replacer is a function.
    return JSON.stringify(decycled, Array.isArray(replacer) ? replacer : null, space);
  }
}

exports.parse = function parse(text, reviver) {
  var needsRetrocycle = /"\$jsan"/.test(text);
  var parsed;
  if (arguments.length === 1) {
    parsed = JSON.parse(text);
  } else {
    parsed = JSON.parse(text, reviver);
  }
  if (needsRetrocycle) {
    parsed = cycle.retrocycle(parsed);
  }
  return parsed;
}

      };
    };
  }
}, {package:"remote-redux-devtools>jsan",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\path-getter.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jsan\lib\path-getter.js
      return function (require, module, exports) {
module.exports = pathGetter;

function pathGetter(obj, path) {
  if (path !== '$') {
    var paths = getPaths(path);
    for (var i = 0; i < paths.length; i++) {
      path = paths[i].toString().replace(/\\"/g, '"');
      if (typeof obj[path] === 'undefined' && i !== paths.length - 1) continue;
      obj = obj[path];
    }
  }
  return obj;
}

function getPaths(pathString) {
  var regex = /(?:\.(\w+))|(?:\[(\d+)\])|(?:\["((?:[^\\"]|\\.)*)"\])/g;
  var matches = [];
  var match;
  while (match = regex.exec(pathString)) {
    matches.push( match[1] || match[2] || match[3] );
  }
  return matches;
}

      };
    };
  }
}, {package:"remote-redux-devtools>jsan",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\utils.js", {"./":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\index.js","./path-getter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jsan\\lib\\path-getter.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jsan\lib\utils.js
      return function (require, module, exports) {
var pathGetter = require('./path-getter');
var jsan = require('./');

exports.getRegexFlags = function getRegexFlags(regex) {
  var flags = '';
  if (regex.ignoreCase) flags += 'i';
  if (regex.global) flags += 'g';
  if (regex.multiline) flags += 'm';
  return flags;
};

exports.stringifyFunction = function stringifyFunction(fn, customToString) {
  if (typeof customToString === 'function') {
    return customToString(fn);
  }
  var str = fn.toString();
  var match = str.match(/^[^{]*{|^[^=]*=>/);
  var start = match ? match[0] : '<function> ';
  var end = str[str.length - 1] === '}' ? '}' : '';
  return start.replace(/\r\n|\n/g, ' ').replace(/\s+/g, ' ') + ' /* ... */ ' + end;
};

exports.restore = function restore(obj, root) {
  var type = obj[0];
  var rest = obj.slice(1);
  switch(type) {
    case '$':
      return pathGetter(root, obj);
    case 'r':
      var comma = rest.indexOf(',');
      var flags = rest.slice(0, comma);
      var source = rest.slice(comma + 1);
      return RegExp(source, flags);
    case 'd':
      return new Date(+rest);
    case 'f':
      var fn = function() { throw new Error("can't run jsan parsed function") };
      fn.toString = function() { return rest; };
      return fn;
    case 'u':
      return undefined;
    case 'e':
      var error = new Error(rest);
      error.stack = 'Stack is unavailable for jsan parsed errors';
      return error;
    case 's':
      return Symbol(rest);
    case 'g':
      return Symbol.for(rest);
    case 'm':
      return new Map(jsan.parse(rest));
    case 'l':
      return new Set(jsan.parse(rest));
    case 'n':
      return NaN;
    case 'i':
      return Infinity;
    case 'y':
      return -Infinity;
    default:
      console.warn('unknown type', obj);
      return obj;
  }
}

      };
    };
  }
}, {package:"remote-redux-devtools>jsan",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-pointer\\index.js", {"foreach":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\foreach\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\json-pointer\index.js
      return function (require, module, exports) {
'use strict';

var each = require('foreach');
module.exports = api;


/**
 * Convenience wrapper around the api.
 * Calls `.get` when called with an `object` and a `pointer`.
 * Calls `.set` when also called with `value`.
 * If only supplied `object`, returns a partially applied function, mapped to the object.
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 * @returns {*}
 */

function api (obj, pointer, value) {
    // .set()
    if (arguments.length === 3) {
        return api.set(obj, pointer, value);
    }
    // .get()
    if (arguments.length === 2) {
        return api.get(obj, pointer);
    }
    // Return a partially applied function on `obj`.
    var wrapped = api.bind(api, obj);

    // Support for oo style
    for (var name in api) {
        if (api.hasOwnProperty(name)) {
            wrapped[name] = api[name].bind(wrapped, obj);
        }
    }
    return wrapped;
}


/**
 * Lookup a json pointer in an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @returns {*}
 */
api.get = function get (obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);

    for (var i = 0; i < refTokens.length; ++i) {
        var tok = refTokens[i];
        if (!(typeof obj == 'object' && tok in obj)) {
            throw new Error('Invalid reference token: ' + tok);
        }
        obj = obj[tok];
    }
    return obj;
};

/**
 * Sets a value on an object
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 * @param value
 */
api.set = function set (obj, pointer, value) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),
      nextTok = refTokens[0];

    if (refTokens.length === 0) {
      throw Error('Can not set the root object');
    }

    for (var i = 0; i < refTokens.length - 1; ++i) {
        var tok = refTokens[i];
        if (tok === "__proto__" || tok === "constructor" || tok === "prototype") {
            continue
        }
        if (tok === '-' && Array.isArray(obj)) {
          tok = obj.length;
        }
        nextTok = refTokens[i + 1];

        if (!(tok in obj)) {
            if (nextTok.match(/^(\d+|-)$/)) {
                obj[tok] = [];
            } else {
                obj[tok] = {};
            }
        }
        obj = obj[tok];
    }
    if (nextTok === '-' && Array.isArray(obj)) {
      nextTok = obj.length;
    }
    obj[nextTok] = value;
    return this;
};

/**
 * Removes an attribute
 *
 * @param {Object} obj
 * @param {String|Array} pointer
 */
api.remove = function (obj, pointer) {
    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);
    var finalToken = refTokens[refTokens.length -1];
    if (finalToken === undefined) {
        throw new Error('Invalid JSON pointer for remove: "' + pointer + '"');
    }

    var parent = api.get(obj, refTokens.slice(0, -1));
    if (Array.isArray(parent)) {
      var index = +finalToken;
      if (finalToken === '' && isNaN(index)) {
        throw new Error('Invalid array index: "' + finalToken + '"');
      }

      Array.prototype.splice.call(parent, index, 1);
    } else {
      delete parent[finalToken];
    }
};

/**
 * Returns a (pointer -> value) dictionary for an object
 *
 * @param obj
 * @param {function} descend
 * @returns {}
 */
api.dict = function dict (obj, descend) {
    var results = {};
    api.walk(obj, function (value, pointer) {
        results[pointer] = value;
    }, descend);
    return results;
};

/**
 * Iterates over an object
 * Iterator: function (value, pointer) {}
 *
 * @param obj
 * @param {function} iterator
 * @param {function} descend
 */
api.walk = function walk (obj, iterator, descend) {
    var refTokens = [];

    descend = descend || function (value) {
        var type = Object.prototype.toString.call(value);
        return type === '[object Object]' || type === '[object Array]';
    };

    (function next (cur) {
        each(cur, function (value, key) {
            refTokens.push(String(key));
            if (descend(value)) {
                next(value);
            } else {
                iterator(value, api.compile(refTokens));
            }
            refTokens.pop();
        });
    }(obj));
};

/**
 * Tests if an object has a value for a json pointer
 *
 * @param obj
 * @param pointer
 * @returns {boolean}
 */
api.has = function has (obj, pointer) {
    try {
        api.get(obj, pointer);
    } catch (e) {
        return false;
    }
    return true;
};

/**
 * Escapes a reference token
 *
 * @param str
 * @returns {string}
 */
api.escape = function escape (str) {
    return str.toString().replace(/~/g, '~0').replace(/\//g, '~1');
};

/**
 * Unescapes a reference token
 *
 * @param str
 * @returns {string}
 */
api.unescape = function unescape (str) {
    return str.replace(/~1/g, '/').replace(/~0/g, '~');
};

/**
 * Converts a json pointer into a array of reference tokens
 *
 * @param pointer
 * @returns {Array}
 */
api.parse = function parse (pointer) {
    if (pointer === '') { return []; }
    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }
    return pointer.substring(1).split(/\//).map(api.unescape);
};

/**
 * Builds a json pointer from a array of reference tokens
 *
 * @param refTokens
 * @returns {string}
 */
api.compile = function compile (refTokens) {
    if (refTokens.length === 0) { return ''; }
    return '/' + refTokens.map(api.escape).join('/');
};

      };
    };
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>json-pointer",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss-plugin-camel-case\\dist\\jss-plugin-camel-case.cjs.js", {"hyphenate-style-name":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\hyphenate-style-name\\index.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss-plugin-camel-case\dist\jss-plugin-camel-case.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var hyphenate = _interopDefault(require('hyphenate-style-name'));

/**
 * Convert camel cased property names to dash separated.
 *
 * @param {Object} style
 * @return {Object}
 */

function convertCase(style) {
  var converted = {};

  for (var prop in style) {
    var key = prop.indexOf('--') === 0 ? prop : hyphenate(prop);
    converted[key] = style[prop];
  }

  if (style.fallbacks) {
    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);
  }

  return converted;
}
/**
 * Allow camel cased property names by converting them back to dasherized.
 *
 * @param {Rule} rule
 */


function camelCase() {
  function onProcessStyle(style) {
    if (Array.isArray(style)) {
      // Handle rules like @font-face, which can have multiple styles in an array
      for (var index = 0; index < style.length; index++) {
        style[index] = convertCase(style[index]);
      }

      return style;
    }

    return convertCase(style);
  }

  function onChangeValue(value, prop, rule) {
    if (prop.indexOf('--') === 0) {
      return value;
    }

    var hyphenatedProp = hyphenate(prop); // There was no camel case in place

    if (prop === hyphenatedProp) return value;
    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.

    return null;
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = camelCase;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-camel-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss-plugin-default-unit\\dist\\jss-plugin-default-unit.cjs.js", {"jss":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss-plugin-default-unit\dist\jss-plugin-default-unit.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jss = require('jss');

var px = jss.hasCSSTOMSupport && CSS ? CSS.px : 'px';
var ms = jss.hasCSSTOMSupport && CSS ? CSS.ms : 'ms';
var percent = jss.hasCSSTOMSupport && CSS ? CSS.percent : '%';
/**
 * Generated jss-plugin-default-unit CSS property units
 *
 * @type object
 */

var defaultUnits = {
  // Animation properties
  'animation-delay': ms,
  'animation-duration': ms,
  // Background properties
  'background-position': px,
  'background-position-x': px,
  'background-position-y': px,
  'background-size': px,
  // Border Properties
  border: px,
  'border-bottom': px,
  'border-bottom-left-radius': px,
  'border-bottom-right-radius': px,
  'border-bottom-width': px,
  'border-left': px,
  'border-left-width': px,
  'border-radius': px,
  'border-right': px,
  'border-right-width': px,
  'border-top': px,
  'border-top-left-radius': px,
  'border-top-right-radius': px,
  'border-top-width': px,
  'border-width': px,
  // Margin properties
  margin: px,
  'margin-bottom': px,
  'margin-left': px,
  'margin-right': px,
  'margin-top': px,
  // Padding properties
  padding: px,
  'padding-bottom': px,
  'padding-left': px,
  'padding-right': px,
  'padding-top': px,
  // Mask properties
  'mask-position-x': px,
  'mask-position-y': px,
  'mask-size': px,
  // Width and height properties
  height: px,
  width: px,
  'min-height': px,
  'max-height': px,
  'min-width': px,
  'max-width': px,
  // Position properties
  bottom: px,
  left: px,
  top: px,
  right: px,
  // Shadow properties
  'box-shadow': px,
  'text-shadow': px,
  // Column properties
  'column-gap': px,
  'column-rule': px,
  'column-rule-width': px,
  'column-width': px,
  // Font and text properties
  'font-size': px,
  'font-size-delta': px,
  'letter-spacing': px,
  'text-indent': px,
  'text-stroke': px,
  'text-stroke-width': px,
  'word-spacing': px,
  // Motion properties
  motion: px,
  'motion-offset': px,
  // Outline properties
  outline: px,
  'outline-offset': px,
  'outline-width': px,
  // Perspective properties
  perspective: px,
  'perspective-origin-x': percent,
  'perspective-origin-y': percent,
  // Transform properties
  'transform-origin': percent,
  'transform-origin-x': percent,
  'transform-origin-y': percent,
  'transform-origin-z': percent,
  // Transition properties
  'transition-delay': ms,
  'transition-duration': ms,
  // Alignment properties
  'vertical-align': px,
  'flex-basis': px,
  // Some random properties
  'shape-margin': px,
  size: px,
  // Grid properties
  grid: px,
  'grid-gap': px,
  'grid-row-gap': px,
  'grid-column-gap': px,
  'grid-template-rows': px,
  'grid-template-columns': px,
  'grid-auto-rows': px,
  'grid-auto-columns': px,
  // Not existing properties.
  // Used to avoid issues with jss-plugin-expand integration.
  'box-shadow-x': px,
  'box-shadow-y': px,
  'box-shadow-blur': px,
  'box-shadow-spread': px,
  'font-line-height': px,
  'text-shadow-x': px,
  'text-shadow-y': px,
  'text-shadow-blur': px
};

/**
 * Clones the object and adds a camel cased property version.
 */
function addCamelCasedVersion(obj) {
  var regExp = /(-[a-z])/g;

  var replace = function replace(str) {
    return str[1].toUpperCase();
  };

  var newObj = {};

  for (var _key in obj) {
    newObj[_key] = obj[_key];
    newObj[_key.replace(regExp, replace)] = obj[_key];
  }

  return newObj;
}

var units = addCamelCasedVersion(defaultUnits);
/**
 * Recursive deep style passing function
 */

function iterate(prop, value, options) {
  if (!value) return value;

  if (Array.isArray(value)) {
    for (var i = 0; i < value.length; i++) {
      value[i] = iterate(prop, value[i], options);
    }
  } else if (typeof value === 'object') {
    if (prop === 'fallbacks') {
      for (var innerProp in value) {
        value[innerProp] = iterate(innerProp, value[innerProp], options);
      }
    } else {
      for (var _innerProp in value) {
        value[_innerProp] = iterate(prop + "-" + _innerProp, value[_innerProp], options);
      }
    }
  } else if (typeof value === 'number') {
    var unit = options[prop] || units[prop];

    if (unit) {
      return typeof unit === 'function' ? unit(value).toString() : "" + value + unit;
    }

    return value.toString();
  }

  return value;
}
/**
 * Add unit to numeric values.
 */


function defaultUnit(options) {
  if (options === void 0) {
    options = {};
  }

  var camelCasedOptions = addCamelCasedVersion(options);

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;

    for (var prop in style) {
      style[prop] = iterate(prop, style[prop], camelCasedOptions);
    }

    return style;
  }

  function onChangeValue(value, prop) {
    return iterate(prop, value, camelCasedOptions);
  }

  return {
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = defaultUnit;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-default-unit",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss-plugin-global\\dist\\jss-plugin-global.cjs.js", {"@babel/runtime/helpers/extends":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\extends.js","jss":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss-plugin-global\dist\jss-plugin-global.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var jss = require('jss');

var at = '@global';
var atPrefix = '@global ';

var GlobalContainerRule =
/*#__PURE__*/
function () {
  function GlobalContainerRule(key, styles, options) {
    this.type = 'global';
    this.at = at;
    this.rules = void 0;
    this.options = void 0;
    this.key = void 0;
    this.isProcessed = false;
    this.key = key;
    this.options = options;
    this.rules = new jss.RuleList(_extends({}, options, {
      parent: this
    }));

    for (var selector in styles) {
      this.rules.add(selector, styles[selector]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = GlobalContainerRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString() {
    return this.rules.toString();
  };

  return GlobalContainerRule;
}();

var GlobalPrefixedRule =
/*#__PURE__*/
function () {
  function GlobalPrefixedRule(key, style, options) {
    this.type = 'global';
    this.at = at;
    this.options = void 0;
    this.rule = void 0;
    this.isProcessed = false;
    this.key = void 0;
    this.key = key;
    this.options = options;
    var selector = key.substr(atPrefix.length);
    this.rule = options.jss.createRule(selector, style, _extends({}, options, {
      parent: this
    }));
  }

  var _proto2 = GlobalPrefixedRule.prototype;

  _proto2.toString = function toString(options) {
    return this.rule ? this.rule.toString(options) : '';
  };

  return GlobalPrefixedRule;
}();

var separatorRegExp = /\s*,\s*/g;

function addScope(selector, scope) {
  var parts = selector.split(separatorRegExp);
  var scoped = '';

  for (var i = 0; i < parts.length; i++) {
    scoped += scope + " " + parts[i].trim();
    if (parts[i + 1]) scoped += ', ';
  }

  return scoped;
}

function handleNestedGlobalContainerRule(rule) {
  var options = rule.options,
      style = rule.style;
  var rules = style ? style[at] : null;
  if (!rules) return;

  for (var name in rules) {
    options.sheet.addRule(name, rules[name], _extends({}, options, {
      selector: addScope(name, rule.selector)
    }));
  }

  delete style[at];
}

function handlePrefixedGlobalRule(rule) {
  var options = rule.options,
      style = rule.style;

  for (var prop in style) {
    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;
    var selector = addScope(prop.substr(at.length), rule.selector);
    options.sheet.addRule(selector, style[prop], _extends({}, options, {
      selector: selector
    }));
    delete style[prop];
  }
}
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */


function jssGlobal() {
  function onCreateRule(name, styles, options) {
    if (!name) return null;

    if (name === at) {
      return new GlobalContainerRule(name, styles, options);
    }

    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {
      return new GlobalPrefixedRule(name, styles, options);
    }

    var parent = options.parent;

    if (parent) {
      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {
        options.scoped = false;
      }
    }

    if (options.scoped === false) {
      options.selector = name;
    }

    return null;
  }

  function onProcessRule(rule) {
    if (rule.type !== 'style') return;
    handleNestedGlobalContainerRule(rule);
    handlePrefixedGlobalRule(rule);
  }

  return {
    onCreateRule: onCreateRule,
    onProcessRule: onProcessRule
  };
}

exports.default = jssGlobal;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-global",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss-plugin-nested\\dist\\jss-plugin-nested.cjs.js", {"@babel/runtime/helpers/extends":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\extends.js","tiny-warning":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss-plugin-nested\dist\jss-plugin-nested.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var warning = _interopDefault(require('tiny-warning'));

var separatorRegExp = /\s*,\s*/g;
var parentRegExp = /&/g;
var refRegExp = /\$([\w-]+)/g;
/**
 * Convert nested rules to separate, remove them from original styles.
 *
 * @param {Rule} rule
 * @api public
 */

function jssNested() {
  // Get a function to be used for $ref replacement.
  function getReplaceRef(container, sheet) {
    return function (match, key) {
      var rule = container.getRule(key) || sheet && sheet.getRule(key);

      if (rule) {
        rule = rule;
        return rule.selector;
      }

      "development" !== "production" ? warning(false, "[JSS] Could not find the referenced rule \"" + key + "\" in \"" + (container.options.meta || container.toString()) + "\".") : void 0;
      return key;
    };
  }

  function replaceParentRefs(nestedProp, parentProp) {
    var parentSelectors = parentProp.split(separatorRegExp);
    var nestedSelectors = nestedProp.split(separatorRegExp);
    var result = '';

    for (var i = 0; i < parentSelectors.length; i++) {
      var parent = parentSelectors[i];

      for (var j = 0; j < nestedSelectors.length; j++) {
        var nested = nestedSelectors[j];
        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.

        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + " " + nested;
      }
    }

    return result;
  }

  function getOptions(rule, container, prevOptions) {
    // Options has been already created, now we only increase index.
    if (prevOptions) return _extends({}, prevOptions, {
      index: prevOptions.index + 1
    });
    var nestingLevel = rule.options.nestingLevel;
    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;

    var options = _extends({}, rule.options, {
      nestingLevel: nestingLevel,
      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.

    });

    delete options.name;
    return options;
  }

  function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style') return style;
    var styleRule = rule;
    var container = styleRule.options.parent;
    var options;
    var replaceRef;

    for (var prop in style) {
      var isNested = prop.indexOf('&') !== -1;
      var isNestedConditional = prop[0] === '@';
      if (!isNested && !isNestedConditional) continue;
      options = getOptions(styleRule, container, options);

      if (isNested) {
        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for
        // all nested rules within the sheet.

        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.

        selector = selector.replace(refRegExp, replaceRef);
        container.addRule(selector, style[prop], _extends({}, options, {
          selector: selector
        }));
      } else if (isNestedConditional) {
        // Place conditional right after the parent rule to ensure right ordering.
        container.addRule(prop, {}, options) // Flow expects more options but they aren't required
        // And flow doesn't know this will always be a StyleRule which has the addRule method
        // $FlowFixMe
        .addRule(styleRule.key, style[prop], {
          selector: styleRule.selector
        });
      }

      delete style[prop];
    }

    return style;
  }

  return {
    onProcessStyle: onProcessStyle
  };
}

exports.default = jssNested;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-nested",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss-plugin-props-sort\\dist\\jss-plugin-props-sort.cjs.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss-plugin-props-sort\dist\jss-plugin-props-sort.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/**
 * Sort props by length.
 */
function jssPropsSort() {
  var sort = function sort(prop0, prop1) {
    if (prop0.length === prop1.length) {
      return prop0 > prop1 ? 1 : -1;
    }

    return prop0.length - prop1.length;
  };

  return {
    onProcessStyle: function onProcessStyle(style, rule) {
      if (rule.type !== 'style') return style;
      var newStyle = {};
      var props = Object.keys(style).sort(sort);

      for (var i = 0; i < props.length; i++) {
        newStyle[props[i]] = style[props[i]];
      }

      return newStyle;
    }
  };
}

exports.default = jssPropsSort;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-props-sort",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss-plugin-rule-value-function\\dist\\jss-plugin-rule-value-function.cjs.js", {"jss":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js","tiny-warning":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss-plugin-rule-value-function\dist\jss-plugin-rule-value-function.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var warning = _interopDefault(require('tiny-warning'));
var jss = require('jss');

var now = Date.now();
var fnValuesNs = "fnValues" + now;
var fnRuleNs = "fnStyle" + ++now;
function functionPlugin() {
  return {
    onCreateRule: function onCreateRule(name, decl, options) {
      if (typeof decl !== 'function') return null;
      var rule = jss.createRule(name, {}, options);
      rule[fnRuleNs] = decl;
      return rule;
    },
    onProcessStyle: function onProcessStyle(style, rule) {
      // We need to extract function values from the declaration, so that we can keep core unaware of them.
      // We need to do that only once.
      // We don't need to extract functions on each style update, since this can happen only once.
      // We don't support function values inside of function rules.
      if (fnValuesNs in rule || fnRuleNs in rule) return style;
      var fnValues = {};

      for (var prop in style) {
        var value = style[prop];
        if (typeof value !== 'function') continue;
        delete style[prop];
        fnValues[prop] = value;
      } // $FlowFixMe


      rule[fnValuesNs] = fnValues;
      return style;
    },
    onUpdate: function onUpdate(data, rule, sheet, options) {
      var styleRule = rule;
      var fnRule = styleRule[fnRuleNs]; // If we have a style function, the entire rule is dynamic and style object
      // will be returned from that function.

      if (fnRule) {
        // Empty object will remove all currently defined props
        // in case function rule returns a falsy value.
        styleRule.style = fnRule(data) || {};

        if ("development" === 'development') {
          for (var prop in styleRule.style) {
            if (typeof styleRule.style[prop] === 'function') {
              "development" !== "production" ? warning(false, '[JSS] Function values inside function rules are not supported.') : void 0;
              break;
            }
          }
        }
      }

      var fnValues = styleRule[fnValuesNs]; // If we have a fn values map, it is a rule with function values.

      if (fnValues) {
        for (var _prop in fnValues) {
          styleRule.prop(_prop, fnValues[_prop](data), options);
        }
      }
    }
  };
}

exports.default = functionPlugin;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-rule-value-function",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss-plugin-vendor-prefixer\\dist\\jss-plugin-vendor-prefixer.cjs.js", {"css-vendor":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\css-vendor\\dist\\css-vendor.cjs.js","jss":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss-plugin-vendor-prefixer\dist\jss-plugin-vendor-prefixer.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var vendor = require('css-vendor');
var jss = require('jss');

/**
 * Add vendor prefix to a property name when needed.
 *
 * @api public
 */

function jssVendorPrefixer() {
  function onProcessRule(rule) {
    if (rule.type === 'keyframes') {
      var atRule = rule;
      atRule.at = vendor.supportedKeyframes(atRule.at);
    }
  }

  function prefixStyle(style) {
    for (var prop in style) {
      var value = style[prop];

      if (prop === 'fallbacks' && Array.isArray(value)) {
        style[prop] = value.map(prefixStyle);
        continue;
      }

      var changeProp = false;
      var supportedProp = vendor.supportedProperty(prop);
      if (supportedProp && supportedProp !== prop) changeProp = true;
      var changeValue = false;
      var supportedValue = vendor.supportedValue(supportedProp, jss.toCssValue(value));
      if (supportedValue && supportedValue !== value) changeValue = true;

      if (changeProp || changeValue) {
        if (changeProp) delete style[prop];
        style[supportedProp || prop] = supportedValue || value;
      }
    }

    return style;
  }

  function onProcessStyle(style, rule) {
    if (rule.type !== 'style') return style;
    return prefixStyle(style);
  }

  function onChangeValue(value, prop) {
    return vendor.supportedValue(prop, jss.toCssValue(value)) || value;
  }

  return {
    onProcessRule: onProcessRule,
    onProcessStyle: onProcessStyle,
    onChangeValue: onChangeValue
  };
}

exports.default = jssVendorPrefixer;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss-plugin-vendor-prefixer",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\jss\\dist\\jss.cjs.js", {"@babel/runtime/helpers/assertThisInitialized":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\assertThisInitialized.js","@babel/runtime/helpers/createClass":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\createClass.js","@babel/runtime/helpers/extends":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\extends.js","@babel/runtime/helpers/inheritsLoose":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","@babel/runtime/helpers/objectWithoutPropertiesLoose":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\objectWithoutPropertiesLoose.js","is-in-browser":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-in-browser\\dist\\index.js","tiny-warning":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\jss\dist\jss.cjs.js
      return function (require, module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var isInBrowser = _interopDefault(require('is-in-browser'));
var warning = _interopDefault(require('tiny-warning'));
var _createClass = _interopDefault(require('@babel/runtime/helpers/createClass'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var _assertThisInitialized = _interopDefault(require('@babel/runtime/helpers/assertThisInitialized'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));

var plainObjectConstrurctor = {}.constructor;
function cloneStyle(style) {
  if (style == null || typeof style !== 'object') return style;
  if (Array.isArray(style)) return style.map(cloneStyle);
  if (style.constructor !== plainObjectConstrurctor) return style;
  var newStyle = {};

  for (var name in style) {
    newStyle[name] = cloneStyle(style[name]);
  }

  return newStyle;
}

/**
 * Create a rule instance.
 */

function createRule(name, decl, options) {
  if (name === void 0) {
    name = 'unnamed';
  }

  var jss = options.jss;
  var declCopy = cloneStyle(decl);
  var rule = jss.plugins.onCreateRule(name, declCopy, options);
  if (rule) return rule; // It is an at-rule and it has no instance.

  if (name[0] === '@') {
    "development" !== "production" ? warning(false, "[JSS] Unknown rule " + name) : void 0;
  }

  return null;
}

var join = function join(value, by) {
  var result = '';

  for (var i = 0; i < value.length; i++) {
    // Remove !important from the value, it will be readded later.
    if (value[i] === '!important') break;
    if (result) result += by;
    result += value[i];
  }

  return result;
};
/**
 * Converts array values to string.
 *
 * `margin: [['5px', '10px']]` > `margin: 5px 10px;`
 * `border: ['1px', '2px']` > `border: 1px, 2px;`
 * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`
 * `color: ['red', !important]` > `color: red !important;`
 */


function toCssValue(value, ignoreImportant) {
  if (ignoreImportant === void 0) {
    ignoreImportant = false;
  }

  if (!Array.isArray(value)) return value;
  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.

  if (Array.isArray(value[0])) {
    for (var i = 0; i < value.length; i++) {
      if (value[i] === '!important') break;
      if (cssValue) cssValue += ', ';
      cssValue += join(value[i], ' ');
    }
  } else cssValue = join(value, ', '); // Add !important, because it was ignored.


  if (!ignoreImportant && value[value.length - 1] === '!important') {
    cssValue += ' !important';
  }

  return cssValue;
}

/**
 * Indent a string.
 * http://jsperf.com/array-join-vs-for
 */
function indentStr(str, indent) {
  var result = '';

  for (var index = 0; index < indent; index++) {
    result += '  ';
  }

  return result + str;
}
/**
 * Converts a Rule to CSS string.
 */


function toCss(selector, style, options) {
  if (options === void 0) {
    options = {};
  }

  var result = '';
  if (!style) return result;
  var _options = options,
      _options$indent = _options.indent,
      indent = _options$indent === void 0 ? 0 : _options$indent;
  var fallbacks = style.fallbacks;
  if (selector) indent++; // Apply fallbacks first.

  if (fallbacks) {
    // Array syntax {fallbacks: [{prop: value}]}
    if (Array.isArray(fallbacks)) {
      for (var index = 0; index < fallbacks.length; index++) {
        var fallback = fallbacks[index];

        for (var prop in fallback) {
          var value = fallback[prop];

          if (value != null) {
            if (result) result += '\n';
            result += "" + indentStr(prop + ": " + toCssValue(value) + ";", indent);
          }
        }
      }
    } else {
      // Object syntax {fallbacks: {prop: value}}
      for (var _prop in fallbacks) {
        var _value = fallbacks[_prop];

        if (_value != null) {
          if (result) result += '\n';
          result += "" + indentStr(_prop + ": " + toCssValue(_value) + ";", indent);
        }
      }
    }
  }

  for (var _prop2 in style) {
    var _value2 = style[_prop2];

    if (_value2 != null && _prop2 !== 'fallbacks') {
      if (result) result += '\n';
      result += "" + indentStr(_prop2 + ": " + toCssValue(_value2) + ";", indent);
    }
  } // Allow empty style in this case, because properties will be added dynamically.


  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.

  if (!selector) return result;
  indent--;
  if (result) result = "\n" + result + "\n";
  return indentStr(selector + " {" + result, indent) + indentStr('}', indent);
}

var escapeRegex = /([[\].#*$><+~=|^:(),"'`\s])/g;
var nativeEscape = typeof CSS !== 'undefined' && CSS.escape;
var escape = (function (str) {
  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\$1');
});

var BaseStyleRule =
/*#__PURE__*/
function () {
  function BaseStyleRule(key, style, options) {
    this.type = 'style';
    this.key = void 0;
    this.isProcessed = false;
    this.style = void 0;
    this.renderer = void 0;
    this.renderable = void 0;
    this.options = void 0;
    var sheet = options.sheet,
        Renderer = options.Renderer;
    this.key = key;
    this.options = options;
    this.style = style;
    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();
  }
  /**
   * Get or set a style property.
   */


  var _proto = BaseStyleRule.prototype;

  _proto.prop = function prop(name, value, options) {
    // It's a getter.
    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.

    var force = options ? options.force : false;
    if (!force && this.style[name] === value) return this;
    var newValue = value;

    if (!options || options.process !== false) {
      newValue = this.options.jss.plugins.onChangeValue(value, name, this);
    }

    var isEmpty = newValue == null || newValue === false;
    var isDefined = name in this.style; // Value is empty and wasn't defined before.

    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.

    var remove = isEmpty && isDefined;
    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.

    if (this.renderable && this.renderer) {
      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);
      return this;
    }

    var sheet = this.options.sheet;

    if (sheet && sheet.attached) {
      "development" !== "production" ? warning(false, '[JSS] Rule is not linked. Missing sheet option "link: true".') : void 0;
    }

    return this;
  };

  return BaseStyleRule;
}();
var StyleRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(StyleRule, _BaseStyleRule);

  function StyleRule(key, style, options) {
    var _this;

    _this = _BaseStyleRule.call(this, key, style, options) || this;
    _this.selectorText = void 0;
    _this.id = void 0;
    _this.renderable = void 0;
    var selector = options.selector,
        scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;

    if (selector) {
      _this.selectorText = selector;
    } else if (scoped !== false) {
      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);
      _this.selectorText = "." + escape(_this.id);
    }

    return _this;
  }
  /**
   * Set selector string.
   * Attention: use this with caution. Most browsers didn't implement
   * selectorText setter, so this may result in rerendering of entire Style Sheet.
   */


  var _proto2 = StyleRule.prototype;

  /**
   * Apply rule to an element inline.
   */
  _proto2.applyTo = function applyTo(renderable) {
    var renderer = this.renderer;

    if (renderer) {
      var json = this.toJSON();

      for (var prop in json) {
        renderer.setProperty(renderable, prop, json[prop]);
      }
    }

    return this;
  }
  /**
   * Returns JSON representation of the rule.
   * Fallbacks are not supported.
   * Useful for inline styles.
   */
  ;

  _proto2.toJSON = function toJSON() {
    var json = {};

    for (var prop in this.style) {
      var value = this.style[prop];
      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);
    }

    return json;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto2.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.selectorText, this.style, opts);
  };

  _createClass(StyleRule, [{
    key: "selector",
    set: function set(selector) {
      if (selector === this.selectorText) return;
      this.selectorText = selector;
      var renderer = this.renderer,
          renderable = this.renderable;
      if (!renderable || !renderer) return;
      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.

      if (!hasChanged) {
        renderer.replaceRule(renderable, this);
      }
    }
    /**
     * Get selector string.
     */
    ,
    get: function get() {
      return this.selectorText;
    }
  }]);

  return StyleRule;
}(BaseStyleRule);
var pluginStyleRule = {
  onCreateRule: function onCreateRule(name, style, options) {
    if (name[0] === '@' || options.parent && options.parent.type === 'keyframes') {
      return null;
    }

    return new StyleRule(name, style, options);
  }
};

var defaultToStringOptions = {
  indent: 1,
  children: true
};
var atRegExp = /@([\w-]+)/;
/**
 * Conditional rule for @media, @supports
 */

var ConditionalRule =
/*#__PURE__*/
function () {
  function ConditionalRule(key, styles, options) {
    this.type = 'conditional';
    this.at = void 0;
    this.key = void 0;
    this.query = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key; // Key might contain a unique suffix in case the `name` passed by user was duplicate.

    this.query = options.name;
    var atMatch = key.match(atRegExp);
    this.at = atMatch ? atMatch[1] : 'unknown';
    this.options = options;
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Get a rule.
   */


  var _proto = ConditionalRule.prototype;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Create and register rule, run plugins.
   */
  ;

  _proto.addRule = function addRule(name, style, options) {
    var rule = this.rules.add(name, style, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Generates a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions;
    }

    if (options.indent == null) options.indent = defaultToStringOptions.indent;
    if (options.children == null) options.children = defaultToStringOptions.children;

    if (options.children === false) {
      return this.query + " {}";
    }

    var children = this.rules.toString(options);
    return children ? this.query + " {\n" + children + "\n}" : '';
  };

  return ConditionalRule;
}();
var keyRegExp = /@media|@supports\s+/;
var pluginConditionalRule = {
  onCreateRule: function onCreateRule(key, styles, options) {
    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;
  }
};

var defaultToStringOptions$1 = {
  indent: 1,
  children: true
};
var nameRegExp = /@keyframes\s+([\w-]+)/;
/**
 * Rule for @keyframes
 */

var KeyframesRule =
/*#__PURE__*/
function () {
  function KeyframesRule(key, frames, options) {
    this.type = 'keyframes';
    this.at = '@keyframes';
    this.key = void 0;
    this.name = void 0;
    this.id = void 0;
    this.rules = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    var nameMatch = key.match(nameRegExp);

    if (nameMatch && nameMatch[1]) {
      this.name = nameMatch[1];
    } else {
      this.name = 'noname';
      "development" !== "production" ? warning(false, "[JSS] Bad keyframes name " + key) : void 0;
    }

    this.key = this.type + "-" + this.name;
    this.options = options;
    var scoped = options.scoped,
        sheet = options.sheet,
        generateId = options.generateId;
    this.id = scoped === false ? this.name : escape(generateId(this, sheet));
    this.rules = new RuleList(_extends({}, options, {
      parent: this
    }));

    for (var name in frames) {
      this.rules.add(name, frames[name], _extends({}, options, {
        parent: this
      }));
    }

    this.rules.process();
  }
  /**
   * Generates a CSS string.
   */


  var _proto = KeyframesRule.prototype;

  _proto.toString = function toString(options) {
    if (options === void 0) {
      options = defaultToStringOptions$1;
    }

    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;
    if (options.children == null) options.children = defaultToStringOptions$1.children;

    if (options.children === false) {
      return this.at + " " + this.id + " {}";
    }

    var children = this.rules.toString(options);
    if (children) children = "\n" + children + "\n";
    return this.at + " " + this.id + " {" + children + "}";
  };

  return KeyframesRule;
}();
var keyRegExp$1 = /@keyframes\s+/;
var refRegExp = /\$([\w-]+)/g;

var findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {
  if (typeof val === 'string') {
    return val.replace(refRegExp, function (match, name) {
      if (name in keyframes) {
        return keyframes[name];
      }

      "development" !== "production" ? warning(false, "[JSS] Referenced keyframes rule \"" + name + "\" is not defined.") : void 0;
      return match;
    });
  }

  return val;
};
/**
 * Replace the reference for a animation name.
 */


var replaceRef = function replaceRef(style, prop, keyframes) {
  var value = style[prop];
  var refKeyframe = findReferencedKeyframe(value, keyframes);

  if (refKeyframe !== value) {
    style[prop] = refKeyframe;
  }
};

var plugin = {
  onCreateRule: function onCreateRule(key, frames, options) {
    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;
  },
  // Animation name ref replacer.
  onProcessStyle: function onProcessStyle(style, rule, sheet) {
    if (rule.type !== 'style' || !sheet) return style;
    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);
    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);
    return style;
  },
  onChangeValue: function onChangeValue(val, prop, rule) {
    var sheet = rule.options.sheet;

    if (!sheet) {
      return val;
    }

    switch (prop) {
      case 'animation':
        return findReferencedKeyframe(val, sheet.keyframes);

      case 'animation-name':
        return findReferencedKeyframe(val, sheet.keyframes);

      default:
        return val;
    }
  }
};

var KeyframeRule =
/*#__PURE__*/
function (_BaseStyleRule) {
  _inheritsLoose(KeyframeRule, _BaseStyleRule);

  function KeyframeRule() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _BaseStyleRule.call.apply(_BaseStyleRule, [this].concat(args)) || this;
    _this.renderable = void 0;
    return _this;
  }

  var _proto = KeyframeRule.prototype;

  /**
   * Generates a CSS string.
   */
  _proto.toString = function toString(options) {
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;
    var opts = link ? _extends({}, options, {
      allowEmpty: true
    }) : options;
    return toCss(this.key, this.style, opts);
  };

  return KeyframeRule;
}(BaseStyleRule);
var pluginKeyframeRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    if (options.parent && options.parent.type === 'keyframes') {
      return new KeyframeRule(key, style, options);
    }

    return null;
  }
};

var FontFaceRule =
/*#__PURE__*/
function () {
  function FontFaceRule(key, style, options) {
    this.type = 'font-face';
    this.at = '@font-face';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = FontFaceRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.style)) {
      var str = '';

      for (var index = 0; index < this.style.length; index++) {
        str += toCss(this.at, this.style[index]);
        if (this.style[index + 1]) str += '\n';
      }

      return str;
    }

    return toCss(this.at, this.style, options);
  };

  return FontFaceRule;
}();
var keyRegExp$2 = /@font-face/;
var pluginFontFaceRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;
  }
};

var ViewportRule =
/*#__PURE__*/
function () {
  function ViewportRule(key, style, options) {
    this.type = 'viewport';
    this.at = '@viewport';
    this.key = void 0;
    this.style = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.style = style;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */


  var _proto = ViewportRule.prototype;

  _proto.toString = function toString(options) {
    return toCss(this.key, this.style, options);
  };

  return ViewportRule;
}();
var pluginViewportRule = {
  onCreateRule: function onCreateRule(key, style, options) {
    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;
  }
};

var SimpleRule =
/*#__PURE__*/
function () {
  function SimpleRule(key, value, options) {
    this.type = 'simple';
    this.key = void 0;
    this.value = void 0;
    this.options = void 0;
    this.isProcessed = false;
    this.renderable = void 0;
    this.key = key;
    this.value = value;
    this.options = options;
  }
  /**
   * Generates a CSS string.
   */
  // eslint-disable-next-line no-unused-vars


  var _proto = SimpleRule.prototype;

  _proto.toString = function toString(options) {
    if (Array.isArray(this.value)) {
      var str = '';

      for (var index = 0; index < this.value.length; index++) {
        str += this.key + " " + this.value[index] + ";";
        if (this.value[index + 1]) str += '\n';
      }

      return str;
    }

    return this.key + " " + this.value + ";";
  };

  return SimpleRule;
}();
var keysMap = {
  '@charset': true,
  '@import': true,
  '@namespace': true
};
var pluginSimpleRule = {
  onCreateRule: function onCreateRule(key, value, options) {
    return key in keysMap ? new SimpleRule(key, value, options) : null;
  }
};

var plugins = [pluginStyleRule, pluginConditionalRule, plugin, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];

var defaultUpdateOptions = {
  process: true
};
var forceUpdateOptions = {
  force: true,
  process: true
  /**
   * Contains rules objects and allows adding/removing etc.
   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.
   */

};

var RuleList =
/*#__PURE__*/
function () {
  // Rules registry for access by .get() method.
  // It contains the same rule registered by name and by selector.
  // Original styles object.
  // Used to ensure correct rules order.
  function RuleList(options) {
    this.map = {};
    this.raw = {};
    this.index = [];
    this.counter = 0;
    this.options = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.options = options;
    this.classes = options.classes;
    this.keyframes = options.keyframes;
  }
  /**
   * Create and register rule.
   *
   * Will not render after Style Sheet was rendered the first time.
   */


  var _proto = RuleList.prototype;

  _proto.add = function add(name, decl, ruleOptions) {
    var _this$options = this.options,
        parent = _this$options.parent,
        sheet = _this$options.sheet,
        jss = _this$options.jss,
        Renderer = _this$options.Renderer,
        generateId = _this$options.generateId,
        scoped = _this$options.scoped;

    var options = _extends({
      classes: this.classes,
      parent: parent,
      sheet: sheet,
      jss: jss,
      Renderer: Renderer,
      generateId: generateId,
      scoped: scoped,
      name: name
    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but
    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens
    // we need to make the key unique within this RuleList instance scope.


    var key = name;

    if (name in this.raw) {
      key = name + "-d" + this.counter++;
    } // We need to save the original decl before creating the rule
    // because cache plugin needs to use it as a key to return a cached rule.


    this.raw[key] = decl;

    if (key in this.classes) {
      // E.g. rules inside of @media container
      options.selector = "." + escape(this.classes[key]);
    }

    var rule = createRule(key, decl, options);
    if (!rule) return null;
    this.register(rule);
    var index = options.index === undefined ? this.index.length : options.index;
    this.index.splice(index, 0, rule);
    return rule;
  }
  /**
   * Get a rule.
   */
  ;

  _proto.get = function get(name) {
    return this.map[name];
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.remove = function remove(rule) {
    this.unregister(rule);
    delete this.raw[rule.key];
    this.index.splice(this.index.indexOf(rule), 1);
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.index.indexOf(rule);
  }
  /**
   * Run `onProcessRule()` plugins on every rule.
   */
  ;

  _proto.process = function process() {
    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop
    // we end up with very hard-to-track-down side effects.

    this.index.slice(0).forEach(plugins.onProcessRule, plugins);
  }
  /**
   * Register a rule in `.map`, `.classes` and `.keyframes` maps.
   */
  ;

  _proto.register = function register(rule) {
    this.map[rule.key] = rule;

    if (rule instanceof StyleRule) {
      this.map[rule.selector] = rule;
      if (rule.id) this.classes[rule.key] = rule.id;
    } else if (rule instanceof KeyframesRule && this.keyframes) {
      this.keyframes[rule.name] = rule.id;
    }
  }
  /**
   * Unregister a rule.
   */
  ;

  _proto.unregister = function unregister(rule) {
    delete this.map[rule.key];

    if (rule instanceof StyleRule) {
      delete this.map[rule.selector];
      delete this.classes[rule.key];
    } else if (rule instanceof KeyframesRule) {
      delete this.keyframes[rule.name];
    }
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var name;
    var data;
    var options;

    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {
      name = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe

      data = arguments.length <= 1 ? undefined : arguments[1]; // $FlowFixMe

      options = arguments.length <= 2 ? undefined : arguments[2];
    } else {
      data = arguments.length <= 0 ? undefined : arguments[0]; // $FlowFixMe

      options = arguments.length <= 1 ? undefined : arguments[1];
      name = null;
    }

    if (name) {
      this.updateOne(this.map[name], data, options);
    } else {
      for (var index = 0; index < this.index.length; index++) {
        this.updateOne(this.index[index], data, options);
      }
    }
  }
  /**
   * Execute plugins, update rule props.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    if (options === void 0) {
      options = defaultUpdateOptions;
    }

    var _this$options2 = this.options,
        plugins = _this$options2.jss.plugins,
        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.

    if (rule.rules instanceof RuleList) {
      rule.rules.update(data, options);
      return;
    }

    var styleRule = rule;
    var style = styleRule.style;
    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.

    if (options.process && style && style !== styleRule.style) {
      // We need to run the plugins in case new `style` relies on syntax plugins.
      plugins.onProcessStyle(styleRule.style, styleRule, sheet); // Update and add props.

      for (var prop in styleRule.style) {
        var nextValue = styleRule.style[prop];
        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (nextValue !== prevValue) {
          styleRule.prop(prop, nextValue, forceUpdateOptions);
        }
      } // Remove props.


      for (var _prop in style) {
        var _nextValue = styleRule.style[_prop];
        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.
        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.

        if (_nextValue == null && _nextValue !== _prevValue) {
          styleRule.prop(_prop, null, forceUpdateOptions);
        }
      }
    }
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    var str = '';
    var sheet = this.options.sheet;
    var link = sheet ? sheet.options.link : false;

    for (var index = 0; index < this.index.length; index++) {
      var rule = this.index[index];
      var css = rule.toString(options); // No need to render an empty rule.

      if (!css && !link) continue;
      if (str) str += '\n';
      str += css;
    }

    return str;
  };

  return RuleList;
}();

var StyleSheet =
/*#__PURE__*/
function () {
  function StyleSheet(styles, options) {
    this.options = void 0;
    this.deployed = void 0;
    this.attached = void 0;
    this.rules = void 0;
    this.renderer = void 0;
    this.classes = void 0;
    this.keyframes = void 0;
    this.queue = void 0;
    this.attached = false;
    this.deployed = false;
    this.classes = {};
    this.keyframes = {};
    this.options = _extends({}, options, {
      sheet: this,
      parent: this,
      classes: this.classes,
      keyframes: this.keyframes
    });

    if (options.Renderer) {
      this.renderer = new options.Renderer(this);
    }

    this.rules = new RuleList(this.options);

    for (var name in styles) {
      this.rules.add(name, styles[name]);
    }

    this.rules.process();
  }
  /**
   * Attach renderable to the render tree.
   */


  var _proto = StyleSheet.prototype;

  _proto.attach = function attach() {
    if (this.attached) return this;
    if (this.renderer) this.renderer.attach();
    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.

    if (!this.deployed) this.deploy();
    return this;
  }
  /**
   * Remove renderable from render tree.
   */
  ;

  _proto.detach = function detach() {
    if (!this.attached) return this;
    if (this.renderer) this.renderer.detach();
    this.attached = false;
    return this;
  }
  /**
   * Add a rule to the current stylesheet.
   * Will insert a rule also after the stylesheet has been rendered first time.
   */
  ;

  _proto.addRule = function addRule(name, decl, options) {
    var queue = this.queue; // Plugins can create rules.
    // In order to preserve the right order, we need to queue all `.addRule` calls,
    // which happen after the first `rules.add()` call.

    if (this.attached && !queue) this.queue = [];
    var rule = this.rules.add(name, decl, options);
    if (!rule) return null;
    this.options.jss.plugins.onProcessRule(rule);

    if (this.attached) {
      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.
      // It will be inserted all together when .attach is called.

      if (queue) queue.push(rule);else {
        this.insertRule(rule);

        if (this.queue) {
          this.queue.forEach(this.insertRule, this);
          this.queue = undefined;
        }
      }
      return rule;
    } // We can't add rules to a detached style node.
    // We will redeploy the sheet once user will attach it.


    this.deployed = false;
    return rule;
  }
  /**
   * Insert rule into the StyleSheet
   */
  ;

  _proto.insertRule = function insertRule(rule) {
    if (this.renderer) {
      this.renderer.insertRule(rule);
    }
  }
  /**
   * Create and add rules.
   * Will render also after Style Sheet was rendered the first time.
   */
  ;

  _proto.addRules = function addRules(styles, options) {
    var added = [];

    for (var name in styles) {
      var rule = this.addRule(name, styles[name], options);
      if (rule) added.push(rule);
    }

    return added;
  }
  /**
   * Get a rule by name.
   */
  ;

  _proto.getRule = function getRule(name) {
    return this.rules.get(name);
  }
  /**
   * Delete a rule by name.
   * Returns `true`: if rule has been deleted from the DOM.
   */
  ;

  _proto.deleteRule = function deleteRule(name) {
    var rule = typeof name === 'object' ? name : this.rules.get(name);
    if (!rule) return false;
    this.rules.remove(rule);

    if (this.attached && rule.renderable && this.renderer) {
      return this.renderer.deleteRule(rule.renderable);
    }

    return true;
  }
  /**
   * Get index of a rule.
   */
  ;

  _proto.indexOf = function indexOf(rule) {
    return this.rules.indexOf(rule);
  }
  /**
   * Deploy pure CSS string to a renderable.
   */
  ;

  _proto.deploy = function deploy() {
    if (this.renderer) this.renderer.deploy();
    this.deployed = true;
    return this;
  }
  /**
   * Update the function values with a new data.
   */
  ;

  _proto.update = function update() {
    var _this$rules;

    (_this$rules = this.rules).update.apply(_this$rules, arguments);

    return this;
  }
  /**
   * Updates a single rule.
   */
  ;

  _proto.updateOne = function updateOne(rule, data, options) {
    this.rules.updateOne(rule, data, options);
    return this;
  }
  /**
   * Convert rules to a CSS string.
   */
  ;

  _proto.toString = function toString(options) {
    return this.rules.toString(options);
  };

  return StyleSheet;
}();

var PluginsRegistry =
/*#__PURE__*/
function () {
  function PluginsRegistry() {
    this.plugins = {
      internal: [],
      external: []
    };
    this.registry = void 0;
  }

  var _proto = PluginsRegistry.prototype;

  /**
   * Call `onCreateRule` hooks and return an object if returned by a hook.
   */
  _proto.onCreateRule = function onCreateRule(name, decl, options) {
    for (var i = 0; i < this.registry.onCreateRule.length; i++) {
      var rule = this.registry.onCreateRule[i](name, decl, options);
      if (rule) return rule;
    }

    return null;
  }
  /**
   * Call `onProcessRule` hooks.
   */
  ;

  _proto.onProcessRule = function onProcessRule(rule) {
    if (rule.isProcessed) return;
    var sheet = rule.options.sheet;

    for (var i = 0; i < this.registry.onProcessRule.length; i++) {
      this.registry.onProcessRule[i](rule, sheet);
    }

    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);
    rule.isProcessed = true;
  }
  /**
   * Call `onProcessStyle` hooks.
   */
  ;

  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {
    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {
      // $FlowFixMe
      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);
    }
  }
  /**
   * Call `onProcessSheet` hooks.
   */
  ;

  _proto.onProcessSheet = function onProcessSheet(sheet) {
    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {
      this.registry.onProcessSheet[i](sheet);
    }
  }
  /**
   * Call `onUpdate` hooks.
   */
  ;

  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {
    for (var i = 0; i < this.registry.onUpdate.length; i++) {
      this.registry.onUpdate[i](data, rule, sheet, options);
    }
  }
  /**
   * Call `onChangeValue` hooks.
   */
  ;

  _proto.onChangeValue = function onChangeValue(value, prop, rule) {
    var processedValue = value;

    for (var i = 0; i < this.registry.onChangeValue.length; i++) {
      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);
    }

    return processedValue;
  }
  /**
   * Register a plugin.
   */
  ;

  _proto.use = function use(newPlugin, options) {
    if (options === void 0) {
      options = {
        queue: 'external'
      };
    }

    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.

    if (plugins.indexOf(newPlugin) !== -1) {
      return;
    }

    plugins.push(newPlugin);
    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {
      for (var name in plugin) {
        if (name in registry) {
          registry[name].push(plugin[name]);
        } else {
          "development" !== "production" ? warning(false, "[JSS] Unknown hook \"" + name + "\".") : void 0;
        }
      }

      return registry;
    }, {
      onCreateRule: [],
      onProcessRule: [],
      onProcessStyle: [],
      onProcessSheet: [],
      onChangeValue: [],
      onUpdate: []
    });
  };

  return PluginsRegistry;
}();

/**
 * Sheets registry to access them all at one place.
 */
var SheetsRegistry =
/*#__PURE__*/
function () {
  function SheetsRegistry() {
    this.registry = [];
  }

  var _proto = SheetsRegistry.prototype;

  /**
   * Register a Style Sheet.
   */
  _proto.add = function add(sheet) {
    var registry = this.registry;
    var index = sheet.options.index;
    if (registry.indexOf(sheet) !== -1) return;

    if (registry.length === 0 || index >= this.index) {
      registry.push(sheet);
      return;
    } // Find a position.


    for (var i = 0; i < registry.length; i++) {
      if (registry[i].options.index > index) {
        registry.splice(i, 0, sheet);
        return;
      }
    }
  }
  /**
   * Reset the registry.
   */
  ;

  _proto.reset = function reset() {
    this.registry = [];
  }
  /**
   * Remove a Style Sheet.
   */
  ;

  _proto.remove = function remove(sheet) {
    var index = this.registry.indexOf(sheet);
    this.registry.splice(index, 1);
  }
  /**
   * Convert all attached sheets to a CSS string.
   */
  ;

  _proto.toString = function toString(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        attached = _ref.attached,
        options = _objectWithoutPropertiesLoose(_ref, ["attached"]);

    var css = '';

    for (var i = 0; i < this.registry.length; i++) {
      var sheet = this.registry[i];

      if (attached != null && sheet.attached !== attached) {
        continue;
      }

      if (css) css += '\n';
      css += sheet.toString(options);
    }

    return css;
  };

  _createClass(SheetsRegistry, [{
    key: "index",

    /**
     * Current highest index number.
     */
    get: function get() {
      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;
    }
  }]);

  return SheetsRegistry;
}();

/**
 * This is a global sheets registry. Only DomRenderer will add sheets to it.
 * On the server one should use an own SheetsRegistry instance and add the
 * sheets to it, because you need to make sure to create a new registry for
 * each request in order to not leak sheets across requests.
 */

var sheets = new SheetsRegistry();

/* eslint-disable */
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var globalThis = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();

var ns = '2f1acc6c3a606b082e5eef5e54414ffb';
if (globalThis[ns] == null) globalThis[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify
// the current version with just one short number and use it for classes generation
// we use a counter. Also it is more accurate, because user can manually reevaluate
// the module.

var moduleId = globalThis[ns]++;

var maxRules = 1e10;

/**
 * Returns a function which generates unique class names based on counters.
 * When new generator function is created, rule counter is reseted.
 * We need to reset the rule counter for SSR for each request.
 */
var createGenerateId = function createGenerateId(options) {
  if (options === void 0) {
    options = {};
  }

  var ruleCounter = 0;
  return function (rule, sheet) {
    ruleCounter += 1;

    if (ruleCounter > maxRules) {
      "development" !== "production" ? warning(false, "[JSS] You might have a memory leak. Rule counter is at " + ruleCounter + ".") : void 0;
    }

    var jssId = '';
    var prefix = '';

    if (sheet) {
      if (sheet.options.classNamePrefix) {
        prefix = sheet.options.classNamePrefix;
      }

      if (sheet.options.jss.id != null) {
        jssId = String(sheet.options.jss.id);
      }
    }

    if (options.minify) {
      // Using "c" because a number can't be the first char in a class name.
      return "" + (prefix || 'c') + moduleId + jssId + ruleCounter;
    }

    return prefix + rule.key + "-" + moduleId + (jssId ? "-" + jssId : '') + "-" + ruleCounter;
  };
};

/**
 * Cache the value from the first time a function is called.
 */
var memoize = function memoize(fn) {
  var value;
  return function () {
    if (!value) value = fn();
    return value;
  };
};
/**
 * Get a style property value.
 */


function getPropertyValue(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      return cssRule.attributeStyleMap.get(prop);
    }

    return cssRule.style.getPropertyValue(prop);
  } catch (err) {
    // IE may throw if property is unknown.
    return '';
  }
}
/**
 * Set a style property.
 */


function setProperty(cssRule, prop, value) {
  try {
    var cssValue = value;

    if (Array.isArray(value)) {
      cssValue = toCssValue(value, true);

      if (value[value.length - 1] === '!important') {
        cssRule.style.setProperty(prop, cssValue, 'important');
        return true;
      }
    } // Support CSSTOM.


    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.set(prop, cssValue);
    } else {
      cssRule.style.setProperty(prop, cssValue);
    }
  } catch (err) {
    // IE may throw if property is unknown.
    return false;
  }

  return true;
}
/**
 * Remove a style property.
 */


function removeProperty(cssRule, prop) {
  try {
    // Support CSSTOM.
    if (cssRule.attributeStyleMap) {
      cssRule.attributeStyleMap.delete(prop);
    } else {
      cssRule.style.removeProperty(prop);
    }
  } catch (err) {
    "development" !== "production" ? warning(false, "[JSS] DOMException \"" + err.message + "\" was thrown. Tried to remove property \"" + prop + "\".") : void 0;
  }
}
/**
 * Set the selector.
 */


function setSelector(cssRule, selectorText) {
  cssRule.selectorText = selectorText; // Return false if setter was not successful.
  // Currently works in chrome only.

  return cssRule.selectorText === selectorText;
}
/**
 * Gets the `head` element upon the first call and caches it.
 * We assume it can't be null.
 */


var getHead = memoize(function () {
  return document.querySelector('head');
});
/**
 * Find attached sheet with an index higher than the passed one.
 */

function findHigherSheet(registry, options) {
  for (var i = 0; i < registry.length; i++) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find attached sheet with the highest index.
 */


function findHighestSheet(registry, options) {
  for (var i = registry.length - 1; i >= 0; i--) {
    var sheet = registry[i];

    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {
      return sheet;
    }
  }

  return null;
}
/**
 * Find a comment with "jss" inside.
 */


function findCommentNode(text) {
  var head = getHead();

  for (var i = 0; i < head.childNodes.length; i++) {
    var node = head.childNodes[i];

    if (node.nodeType === 8 && node.nodeValue.trim() === text) {
      return node;
    }
  }

  return null;
}

/**
 * Find a node before which we can insert the sheet.
 */
function findPrevNode(options) {
  var registry = sheets.registry;

  if (registry.length > 0) {
    // Try to insert before the next higher sheet.
    var sheet = findHigherSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element
      };
    } // Otherwise insert after the last attached.


    sheet = findHighestSheet(registry, options);

    if (sheet && sheet.renderer) {
      return {
        parent: sheet.renderer.element.parentNode,
        node: sheet.renderer.element.nextSibling
      };
    }
  } // Try to find a comment placeholder if registry is empty.


  var insertionPoint = options.insertionPoint;

  if (insertionPoint && typeof insertionPoint === 'string') {
    var comment = findCommentNode(insertionPoint);

    if (comment) {
      return {
        parent: comment.parentNode,
        node: comment.nextSibling
      };
    } // If user specifies an insertion point and it can't be found in the document -
    // bad specificity issues may appear.


    "development" !== "production" ? warning(false, "[JSS] Insertion point \"" + insertionPoint + "\" not found.") : void 0;
  }

  return false;
}
/**
 * Insert style element into the DOM.
 */


function insertStyle(style, options) {
  var insertionPoint = options.insertionPoint;
  var nextNode = findPrevNode(options);

  if (nextNode !== false && nextNode.parent) {
    nextNode.parent.insertBefore(style, nextNode.node);
    return;
  } // Works with iframes and any node types.


  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {
    // https://stackoverflow.com/questions/41328728/force-casting-in-flow
    var insertionPointElement = insertionPoint;
    var parentNode = insertionPointElement.parentNode;
    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else "development" !== "production" ? warning(false, '[JSS] Insertion point is not in the DOM.') : void 0;
    return;
  }

  getHead().appendChild(style);
}
/**
 * Read jss nonce setting from the page if the user has set it.
 */


var getNonce = memoize(function () {
  var node = document.querySelector('meta[property="csp-nonce"]');
  return node ? node.getAttribute('content') : null;
});

var _insertRule = function insertRule(container, rule, index) {
  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong

  if (index === undefined || index > maxIndex) {
    // eslint-disable-next-line no-param-reassign
    index = maxIndex;
  }

  try {
    if ('insertRule' in container) {
      var c = container;
      c.insertRule(rule, index);
    } // Keyframes rule.
    else if ('appendRule' in container) {
        var _c = container;

        _c.appendRule(rule);
      }
  } catch (err) {
    "development" !== "production" ? warning(false, "[JSS] " + err.message) : void 0;
    return false;
  }

  return container.cssRules[index];
};

var createStyle = function createStyle() {
  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we
  // insert rules after we insert the style tag.
  // It seems to kick-off the source order specificity algorithm.

  el.textContent = '\n';
  return el;
};

var DomRenderer =
/*#__PURE__*/
function () {
  // HTMLStyleElement needs fixing https://github.com/facebook/flow/issues/2696
  function DomRenderer(sheet) {
    this.getPropertyValue = getPropertyValue;
    this.setProperty = setProperty;
    this.removeProperty = removeProperty;
    this.setSelector = setSelector;
    this.element = void 0;
    this.sheet = void 0;
    this.hasInsertedRules = false;
    // There is no sheet when the renderer is used from a standalone StyleRule.
    if (sheet) sheets.add(sheet);
    this.sheet = sheet;

    var _ref = this.sheet ? this.sheet.options : {},
        media = _ref.media,
        meta = _ref.meta,
        element = _ref.element;

    this.element = element || createStyle();
    this.element.setAttribute('data-jss', '');
    if (media) this.element.setAttribute('media', media);
    if (meta) this.element.setAttribute('data-meta', meta);
    var nonce = getNonce();
    if (nonce) this.element.setAttribute('nonce', nonce);
  }
  /**
   * Insert style element into render tree.
   */


  var _proto = DomRenderer.prototype;

  _proto.attach = function attach() {
    // In the case the element node is external and it is already in the DOM.
    if (this.element.parentNode || !this.sheet) return;
    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`
    // most browsers create a new CSSStyleSheet, except of all IEs.

    var deployed = Boolean(this.sheet && this.sheet.deployed);

    if (this.hasInsertedRules && deployed) {
      this.hasInsertedRules = false;
      this.deploy();
    }
  }
  /**
   * Remove style element from render tree.
   */
  ;

  _proto.detach = function detach() {
    var parentNode = this.element.parentNode;
    if (parentNode) parentNode.removeChild(this.element);
  }
  /**
   * Inject CSS string into element.
   */
  ;

  _proto.deploy = function deploy() {
    var sheet = this.sheet;
    if (!sheet) return;

    if (sheet.options.link) {
      this.insertRules(sheet.rules);
      return;
    }

    this.element.textContent = "\n" + sheet.toString() + "\n";
  }
  /**
   * Insert RuleList into an element.
   */
  ;

  _proto.insertRules = function insertRules(rules, nativeParent) {
    for (var i = 0; i < rules.index.length; i++) {
      this.insertRule(rules.index[i], i, nativeParent);
    }
  }
  /**
   * Insert a rule into element.
   */
  ;

  _proto.insertRule = function insertRule(rule, index, nativeParent) {
    if (nativeParent === void 0) {
      nativeParent = this.element.sheet;
    }

    if (rule.rules) {
      var parent = rule;
      var latestNativeParent = nativeParent;

      if (rule.type === 'conditional' || rule.type === 'keyframes') {
        // We need to render the container without children first.
        latestNativeParent = _insertRule(nativeParent, parent.toString({
          children: false
        }), index);

        if (latestNativeParent === false) {
          return false;
        }
      }

      this.insertRules(parent.rules, latestNativeParent);
      return latestNativeParent;
    } // IE keeps the CSSStyleSheet after style node has been reattached,
    // so we need to check if the `renderable` reference the right style sheet and not
    // rerender those rules.


    if (rule.renderable && rule.renderable.parentStyleSheet === this.element.sheet) {
      return rule.renderable;
    }

    var ruleStr = rule.toString();
    if (!ruleStr) return false;

    var nativeRule = _insertRule(nativeParent, ruleStr, index);

    if (nativeRule === false) {
      return false;
    }

    this.hasInsertedRules = true;
    rule.renderable = nativeRule;
    return nativeRule;
  }
  /**
   * Delete a rule.
   */
  ;

  _proto.deleteRule = function deleteRule(cssRule) {
    var sheet = this.element.sheet;
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    sheet.deleteRule(index);
    return true;
  }
  /**
   * Get index of a CSS Rule.
   */
  ;

  _proto.indexOf = function indexOf(cssRule) {
    var cssRules = this.element.sheet.cssRules;

    for (var index = 0; index < cssRules.length; index++) {
      if (cssRule === cssRules[index]) return index;
    }

    return -1;
  }
  /**
   * Generate a new CSS rule and replace the existing one.
   *
   * Only used for some old browsers because they can't set a selector.
   */
  ;

  _proto.replaceRule = function replaceRule(cssRule, rule) {
    var index = this.indexOf(cssRule);
    if (index === -1) return false;
    this.element.sheet.deleteRule(index);
    return this.insertRule(rule, index);
  }
  /**
   * Get all rules elements.
   */
  ;

  _proto.getRules = function getRules() {
    return this.element.sheet.cssRules;
  };

  return DomRenderer;
}();

var instanceCounter = 0;

var Jss =
/*#__PURE__*/
function () {
  function Jss(options) {
    this.id = instanceCounter++;
    this.version = "10.3.0";
    this.plugins = new PluginsRegistry();
    this.options = {
      id: {
        minify: false
      },
      createGenerateId: createGenerateId,
      Renderer: isInBrowser ? DomRenderer : null,
      plugins: []
    };
    this.generateId = createGenerateId({
      minify: false
    });

    for (var i = 0; i < plugins.length; i++) {
      this.plugins.use(plugins[i], {
        queue: 'internal'
      });
    }

    this.setup(options);
  }
  /**
   * Prepares various options, applies plugins.
   * Should not be used twice on the same instance, because there is no plugins
   * deduplication logic.
   */


  var _proto = Jss.prototype;

  _proto.setup = function setup(options) {
    if (options === void 0) {
      options = {};
    }

    if (options.createGenerateId) {
      this.options.createGenerateId = options.createGenerateId;
    }

    if (options.id) {
      this.options.id = _extends({}, this.options.id, options.id);
    }

    if (options.createGenerateId || options.id) {
      this.generateId = this.options.createGenerateId(this.options.id);
    }

    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;

    if ('Renderer' in options) {
      this.options.Renderer = options.Renderer;
    } // eslint-disable-next-line prefer-spread


    if (options.plugins) this.use.apply(this, options.plugins);
    return this;
  }
  /**
   * Create a Style Sheet.
   */
  ;

  _proto.createStyleSheet = function createStyleSheet(styles, options) {
    if (options === void 0) {
      options = {};
    }

    var _options = options,
        index = _options.index;

    if (typeof index !== 'number') {
      index = sheets.index === 0 ? 0 : sheets.index + 1;
    }

    var sheet = new StyleSheet(styles, _extends({}, options, {
      jss: this,
      generateId: options.generateId || this.generateId,
      insertionPoint: this.options.insertionPoint,
      Renderer: this.options.Renderer,
      index: index
    }));
    this.plugins.onProcessSheet(sheet);
    return sheet;
  }
  /**
   * Detach the Style Sheet and remove it from the registry.
   */
  ;

  _proto.removeStyleSheet = function removeStyleSheet(sheet) {
    sheet.detach();
    sheets.remove(sheet);
    return this;
  }
  /**
   * Create a rule without a Style Sheet.
   * [Deprecated] will be removed in the next major version.
   */
  ;

  _proto.createRule = function createRule$1(name, style, options) {
    if (style === void 0) {
      style = {};
    }

    if (options === void 0) {
      options = {};
    }

    // Enable rule without name for inline styles.
    if (typeof name === 'object') {
      return this.createRule(undefined, name, style);
    }

    var ruleOptions = _extends({}, options, {
      name: name,
      jss: this,
      Renderer: this.options.Renderer
    });

    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;
    if (!ruleOptions.classes) ruleOptions.classes = {};
    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};

    var rule = createRule(name, style, ruleOptions);

    if (rule) this.plugins.onProcessRule(rule);
    return rule;
  }
  /**
   * Register plugin. Passed function will be invoked with a rule instance.
   */
  ;

  _proto.use = function use() {
    var _this = this;

    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins[_key] = arguments[_key];
    }

    plugins.forEach(function (plugin) {
      _this.plugins.use(plugin);
    });
    return this;
  };

  return Jss;
}();

/**
 * Extracts a styles object with only props that contain function values.
 */
function getDynamicStyles(styles) {
  var to = null;

  for (var key in styles) {
    var value = styles[key];
    var type = typeof value;

    if (type === 'function') {
      if (!to) to = {};
      to[key] = value;
    } else if (type === 'object' && value !== null && !Array.isArray(value)) {
      var extracted = getDynamicStyles(value);

      if (extracted) {
        if (!to) to = {};
        to[key] = extracted;
      }
    }
  }

  return to;
}

/**
 * SheetsManager is like a WeakMap which is designed to count StyleSheet
 * instances and attach/detach automatically.
 */
var SheetsManager =
/*#__PURE__*/
function () {
  function SheetsManager() {
    this.length = 0;
    this.sheets = new WeakMap();
  }

  var _proto = SheetsManager.prototype;

  _proto.get = function get(key) {
    var entry = this.sheets.get(key);
    return entry && entry.sheet;
  };

  _proto.add = function add(key, sheet) {
    if (this.sheets.has(key)) return;
    this.length++;
    this.sheets.set(key, {
      sheet: sheet,
      refs: 0
    });
  };

  _proto.manage = function manage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs === 0) {
        entry.sheet.attach();
      }

      entry.refs++;
      return entry.sheet;
    }

    warning(false, "[JSS] SheetsManager: can't find sheet to manage");
    return undefined;
  };

  _proto.unmanage = function unmanage(key) {
    var entry = this.sheets.get(key);

    if (entry) {
      if (entry.refs > 0) {
        entry.refs--;
        if (entry.refs === 0) entry.sheet.detach();
      }
    } else {
      warning(false, "SheetsManager: can't find sheet to unmanage");
    }
  };

  _createClass(SheetsManager, [{
    key: "size",
    get: function get() {
      return this.length;
    }
  }]);

  return SheetsManager;
}();

/**
 * A better abstraction over CSS.
 *
 * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present
 * @website https://github.com/cssinjs/jss
 * @license MIT
 */

/**
 * Export a constant indicating if this browser has CSSTOM support.
 * https://developers.google.com/web/updates/2018/03/cssom
 */
var hasCSSTOMSupport = typeof CSS !== 'undefined' && CSS && 'number' in CSS;
/**
 * Creates a new instance of Jss.
 */

var create = function create(options) {
  return new Jss(options);
};
/**
 * A global Jss instance.
 */

var index = create();

exports.RuleList = RuleList;
exports.SheetsManager = SheetsManager;
exports.SheetsRegistry = SheetsRegistry;
exports.create = create;
exports.createGenerateId = createGenerateId;
exports.createRule = createRule;
exports.default = index;
exports.getDynamicStyles = getDynamicStyles;
exports.hasCSSTOMSupport = hasCSSTOMSupport;
exports.sheets = sheets;
exports.toCssValue = toCssValue;

      };
    };
  }
}, {package:"@material-ui/core>@material-ui/styles>jss",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\linked-list\\_source\\linked-list.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\linked-list\_source\linked-list.js
      return function (require, module, exports) {
'use strict';

/**
 * Constants.
 */

var errorMessage;

errorMessage = 'An argument without append, prepend, ' +
    'or detach methods was given to `List';

/**
 * Creates a new List: A linked list is a bit like an Array, but
 * knows nothing about how many items are in it, and knows only about its
 * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,
 * &c.) knows which item comes before or after it (its more like the
 * implementation of the DOM in JavaScript).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of List.
 */

function List(/*items...*/) {
    if (arguments.length) {
        return List.from(arguments);
    }
}

var ListPrototype;

ListPrototype = List.prototype;

/**
 * Creates a new list from the arguments (each a list item) passed in.
 * @name List.of
 * @param {...ListItem} [items] - Zero or more items to attach.
 * @returns {list} - A new instance of List.
 */

List.of = function (/*items...*/) {
    return List.from.call(this, arguments);
};

/**
 * Creates a new list from the given array-like object (each a list item)
 * passed in.
 * @name List.from
 * @param {ListItem[]} [items] - The items to append.
 * @returns {list} - A new instance of List.
 */
List.from = function (items) {
    var list = new this(), length, iterator, item;

    if (items && (length = items.length)) {
        iterator = -1;

        while (++iterator < length) {
            item = items[iterator];

            if (item !== null && item !== undefined) {
                list.append(item);
            }
        }
    }

    return list;
};

/**
 * List#head
 * Default to `null`.
 */
ListPrototype.head = null;

/**
 * List#tail
 * Default to `null`.
 */
ListPrototype.tail = null;

/**
 * Returns the list's items as an array. This does *not* detach the items.
 * @name List#toArray
 * @returns {ListItem[]} - An array of (still attached) ListItems.
 */
ListPrototype.toArray = function () {
    var item = this.head,
        result = [];

    while (item) {
        result.push(item);
        item = item.next;
    }

    return result;
};

/**
 * Prepends the given item to the list: Item will be the new first item
 * (`head`).
 * @name List#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */
ListPrototype.prepend = function (item) {
    if (!item) {
        return false;
    }

    if (!item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + '#prepend`.');
    }

    var self, head;

    // Cache self.
    self = this;

    // If self has a first item, defer prepend to the first items prepend
    // method, and return the result.
    head = self.head;

    if (head) {
        return head.prepend(item);
    }

    // ...otherwise, there is no `head` (or `tail`) item yet.

    // Detach the prependee.
    item.detach();

    // Set the prependees parent list to reference self.
    item.list = self;

    // Set self's first item to the prependee, and return the item.
    self.head = item;

    return item;
};

/**
 * Appends the given item to the list: Item will be the new last item (`tail`)
 * if the list had a first item, and its first item (`head`) otherwise.
 * @name List#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - An instance of ListItem (the given item).
 */

ListPrototype.append = function (item) {
    if (!item) {
        return false;
    }

    if (!item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + '#append`.');
    }

    var self, head, tail;

    // Cache self.
    self = this;

    // If self has a last item, defer appending to the last items append
    // method, and return the result.
    tail = self.tail;

    if (tail) {
        return tail.append(item);
    }

    // If self has a first item, defer appending to the first items append
    // method, and return the result.
    head = self.head;

    if (head) {
        return head.append(item);
    }

    // ...otherwise, there is no `tail` or `head` item yet.

    // Detach the appendee.
    item.detach();

    // Set the appendees parent list to reference self.
    item.list = self;

    // Set self's first item to the appendee, and return the item.
    self.head = item;

    return item;
};

/**
 * Creates a new ListItem: A linked list item is a bit like DOM node:
 * It knows only about its "parent" (`list`), the item before it (`prev`),
 * and the item after it (`next`).
 * @global
 * @private
 * @constructor
 * @class Represents an instance of ListItem.
 */

function ListItem() {}

List.Item = ListItem;

var ListItemPrototype = ListItem.prototype;

ListItemPrototype.next = null;

ListItemPrototype.prev = null;

ListItemPrototype.list = null;

/**
 * Detaches the item operated on from its parent list.
 * @name ListItem#detach
 * @returns {ListItem} - The item operated on.
 */
ListItemPrototype.detach = function () {
    // Cache self, the parent list, and the previous and next items.
    var self = this,
        list = self.list,
        prev = self.prev,
        next = self.next;

    // If the item is already detached, return self.
    if (!list) {
        return self;
    }

    // If self is the last item in the parent list, link the lists last item
    // to the previous item.
    if (list.tail === self) {
        list.tail = prev;
    }

    // If self is the first item in the parent list, link the lists first item
    // to the next item.
    if (list.head === self) {
        list.head = next;
    }

    // If both the last and first items in the parent list are the same,
    // remove the link to the last item.
    if (list.tail === list.head) {
        list.tail = null;
    }

    // If a previous item exists, link its next item to selfs next item.
    if (prev) {
        prev.next = next;
    }

    // If a next item exists, link its previous item to selfs previous item.
    if (next) {
        next.prev = prev;
    }

    // Remove links from self to both the next and previous items, and to the
    // parent list.
    self.prev = self.next = self.list = null;

    // Return self.
    return self;
};

/**
 * Prepends the given item *before* the item operated on.
 * @name ListItem#prepend
 * @param {ListItem} item - The item to prepend.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */
ListItemPrototype.prepend = function (item) {
    if (!item || !item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + 'Item#prepend`.');
    }

    // Cache self, the parent list, and the previous item.
    var self = this,
        list = self.list,
        prev = self.prev;

    // If self is detached, return false.
    if (!list) {
        return false;
    }

    // Detach the prependee.
    item.detach();

    // If self has a previous item...
    if (prev) {
        // ...link the prependees previous item, to selfs previous item.
        item.prev = prev;

        // ...link the previous items next item, to self.
        prev.next = item;
    }

    // Set the prependees next item to self.
    item.next = self;

    // Set the prependees parent list to selfs parent list.
    item.list = list;

    // Set the previous item of self to the prependee.
    self.prev = item;

    // If self is the first item in the parent list, link the lists first item
    // to the prependee.
    if (self === list.head) {
        list.head = item;
    }

    // If the the parent list has no last item, link the lists last item to
    // self.
    if (!list.tail) {
        list.tail = self;
    }

    // Return the prependee.
    return item;
};

/**
 * Appends the given item *after* the item operated on.
 * @name ListItem#append
 * @param {ListItem} item - The item to append.
 * @returns {ListItem} - The item operated on, or false when that item is not
 * attached.
 */
ListItemPrototype.append = function (item) {
    // If item is falsey, return false.
    if (!item || !item.append || !item.prepend || !item.detach) {
        throw new Error(errorMessage + 'Item#append`.');
    }

    // Cache self, the parent list, and the next item.
    var self = this,
        list = self.list,
        next = self.next;

    // If self is detached, return false.
    if (!list) {
        return false;
    }

    // Detach the appendee.
    item.detach();

    // If self has a next item...
    if (next) {
        // ...link the appendees next item, to selfs next item.
        item.next = next;

        // ...link the next items previous item, to the appendee.
        next.prev = item;
    }

    // Set the appendees previous item to self.
    item.prev = self;

    // Set the appendees parent list to selfs parent list.
    item.list = list;

    // Set the next item of self to the appendee.
    self.next = item;

    // If the the parent list has no last item or if self is the parent lists
    // last item, link the lists last item to the appendee.
    if (self === list.tail || !list.tail) {
        list.tail = item;
    }

    // Return the appendee.
    return item;
};

/**
 * Expose `List`.
 */

module.exports = List;

      };
    };
  }
}, {package:"remote-redux-devtools>socketcluster-client>linked-list",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\linked-list\\index.js", {"./_source/linked-list.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\linked-list\\_source\\linked-list.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\linked-list\index.js
      return function (require, module, exports) {
'use strict';

module.exports = require('./_source/linked-list.js');

      };
    };
  }
}, {package:"remote-redux-devtools>socketcluster-client>linked-list",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash.clonedeep\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash.clonedeep\index.js
      return function (require, module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/**
 * Adds the key-value `pair` to `map`.
 *
 * @private
 * @param {Object} map The map to modify.
 * @param {Array} pair The key-value pair to add.
 * @returns {Object} Returns `map`.
 */
function addMapEntry(map, pair) {
  // Don't return `map.set` because it's not chainable in IE 11.
  map.set(pair[0], pair[1]);
  return map;
}

/**
 * Adds `value` to `set`.
 *
 * @private
 * @param {Object} set The set to modify.
 * @param {*} value The value to add.
 * @returns {Object} Returns `set`.
 */
function addSetEntry(set, value) {
  // Don't return `set.add` because it's not chainable in IE 11.
  set.add(value);
  return set;
}

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array ? array.length : 0;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    objectCreate = Object.create,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
    nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    object[key] = value;
  }
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @param {boolean} [isFull] Specify a clone including symbols.
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
  var result;
  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      if (isHostObject(value)) {
        return object ? value : {};
      }
      result = initCloneObject(isFunc ? {} : value);
      if (!isDeep) {
        return copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, baseClone, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (!isArr) {
    var props = isFull ? getAllKeys(value) : keys(value);
  }
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
  });
  return result;
}

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var result = new buffer.constructor(buffer.length);
  buffer.copy(result);
  return result;
}

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/**
 * Creates a clone of `map`.
 *
 * @private
 * @param {Object} map The map to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned map.
 */
function cloneMap(map, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
  return arrayReduce(array, addMapEntry, new map.constructor);
}

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/**
 * Creates a clone of `set`.
 *
 * @private
 * @param {Object} set The set to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned set.
 */
function cloneSet(set, isDeep, cloneFunc) {
  var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
  return arrayReduce(array, addSetEntry, new set.constructor);
}

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    assignValue(object, key, newValue === undefined ? source[key] : newValue);
  }
  return object;
}

/**
 * Copies own symbol properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {Function} cloneFunc The function to clone values.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, cloneFunc, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return cloneMap(object, isDeep, cloneFunc);

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return cloneSet(object, isDeep, cloneFunc);

    case symbolTag:
      return cloneSymbol(object);
  }
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, true, true);
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = cloneDeep;

      };
    };
  }
}, {package:"gulp-dart-sass>lodash.clonedeep",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash.escaperegexp\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash.escaperegexp\index.js
      return function (require, module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Built-in value references. */
var Symbol = root.Symbol;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
}

module.exports = escapeRegExp;

      };
    };
  }
}, {package:"@truffle/codec>lodash.escaperegexp",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash.partition\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash.partition\index.js
      return function (require, module, exports) {
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used to compose bitmasks for comparison styles. */
var UNORDERED_COMPARE_FLAG = 1,
    PARTIAL_COMPARE_FLAG = 2;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    return freeProcess && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol = root.Symbol,
    Uint8Array = root.Uint8Array,
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView'),
    Map = getNative(root, 'Map'),
    Promise = getNative(root, 'Promise'),
    Set = getNative(root, 'Set'),
    WeakMap = getNative(root, 'WeakMap'),
    nativeCreate = getNative(Object, 'create');

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  this.__data__ = new ListCache(entries);
}

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  return this.__data__['delete'](key);
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var cache = this.__data__;
  if (cache instanceof ListCache) {
    var pairs = cache.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      return this;
    }
    cache = this.__data__ = new MapCache(pairs);
  }
  cache.set(key, value);
  return this;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  baseEach(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = isKey(path, object) ? [path] : castPath(path);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `getTag`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  return objectToString.call(value);
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {boolean} [bitmask] The bitmask of comparison flags.
 *  The bitmask may be composed of the following flags:
 *     1 - Unordered comparison
 *     2 - Partial comparison
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, bitmask, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = getTag(object);
    objTag = objTag == argsTag ? objectTag : objTag;
  }
  if (!othIsArr) {
    othTag = getTag(other);
    othTag = othTag == argsTag ? objectTag : othTag;
  }
  var objIsObj = objTag == objectTag && !isHostObject(object),
      othIsObj = othTag == objectTag && !isHostObject(other),
      isSameTag = objTag == othTag;

  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, equalFunc, customizer, bitmask, stack)
      : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
  }
  if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
}

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
}

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray(value) ? value : stringToPath(value);
}

/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray(collection) ? arrayAggregator : baseAggregator,
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);
  };
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & UNORDERED_COMPARE_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!seen.has(othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, customizer, bitmask, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= UNORDERED_COMPARE_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} customizer The function to customize comparisons.
 * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`
 *  for more details.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
  var isPartial = bitmask & PARTIAL_COMPARE_FLAG,
      objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11,
// for data views in Edge < 14, and promises in Node.js.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = objectToString.call(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : undefined;

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates an array of elements split into two groups, the first of which
 * contains elements `predicate` returns truthy for, the second of which
 * contains elements `predicate` returns falsey for. The predicate is
 * invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the array of grouped elements.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': false },
 *   { 'user': 'fred',    'age': 40, 'active': true },
 *   { 'user': 'pebbles', 'age': 1,  'active': false }
 * ];
 *
 * _.partition(users, function(o) { return o.active; });
 * // => objects for [['fred'], ['barney', 'pebbles']]
 *
 * // The `_.matches` iteratee shorthand.
 * _.partition(users, { 'age': 1, 'active': false });
 * // => objects for [['pebbles'], ['barney', 'fred']]
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.partition(users, ['active', false]);
 * // => objects for [['barney', 'pebbles'], ['fred']]
 *
 * // The `_.property` iteratee shorthand.
 * _.partition(users, 'active');
 * // => objects for [['fred'], ['barney', 'pebbles']]
 */
var partition = createAggregator(function(result, value, key) {
  result[key ? 0 : 1].push(value);
}, function() { return [[], []]; });

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = partition;

      };
    };
  }
}, {package:"@truffle/codec>lodash.partition",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash.sum\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash.sum\index.js
      return function (require, module, exports) {
/**
 * lodash 4.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `_.sum` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum(array) {
  return (array && array.length)
    ? baseSum(array, identity)
    : 0;
}

module.exports = sum;

      };
    };
  }
}, {package:"@truffle/codec>lodash.sum",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_apply.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_apply.js
      return function (require, module, exports) {
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludes.js", {"./_baseIndexOf":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIndexOf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_arrayIncludes.js
      return function (require, module, exports) {
var baseIndexOf = require('./_baseIndexOf');

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludesWith.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_arrayIncludesWith.js
      return function (require, module, exports) {
/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseDifference.js", {"./_SetCache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_SetCache.js","./_arrayIncludes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludes.js","./_arrayIncludesWith":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludesWith.js","./_arrayMap":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayMap.js","./_baseUnary":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseUnary.js","./_cacheHas":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cacheHas.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseDifference.js
      return function (require, module, exports) {
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

module.exports = baseDifference;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseFindIndex.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseFindIndex.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseFlatten.js", {"./_arrayPush":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayPush.js","./_isFlattenable":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_isFlattenable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseFlatten.js
      return function (require, module, exports) {
var arrayPush = require('./_arrayPush'),
    isFlattenable = require('./_isFlattenable');

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIndexOf.js", {"./_baseFindIndex":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseFindIndex.js","./_baseIsNaN":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIsNaN.js","./_strictIndexOf":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_strictIndexOf.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseIndexOf.js
      return function (require, module, exports) {
var baseFindIndex = require('./_baseFindIndex'),
    baseIsNaN = require('./_baseIsNaN'),
    strictIndexOf = require('./_strictIndexOf');

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIntersection.js", {"./_SetCache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_SetCache.js","./_arrayIncludes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludes.js","./_arrayIncludesWith":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludesWith.js","./_arrayMap":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayMap.js","./_baseUnary":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseUnary.js","./_cacheHas":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cacheHas.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseIntersection.js
      return function (require, module, exports) {
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    arrayMap = require('./_arrayMap'),
    baseUnary = require('./_baseUnary'),
    cacheHas = require('./_cacheHas');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * The base implementation of methods like `_.intersection`, without support
 * for iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of shared values.
 */
function baseIntersection(arrays, iteratee, comparator) {
  var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];

  while (othIndex--) {
    var array = arrays[othIndex];
    if (othIndex && iteratee) {
      array = arrayMap(array, baseUnary(iteratee));
    }
    maxLength = nativeMin(array.length, maxLength);
    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
      ? new SetCache(othIndex && array)
      : undefined;
  }
  array = arrays[0];

  var index = -1,
      seen = caches[0];

  outer:
  while (++index < length && result.length < maxLength) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (!(seen
          ? cacheHas(seen, computed)
          : includes(result, computed, comparator)
        )) {
      othIndex = othLength;
      while (--othIndex) {
        var cache = caches[othIndex];
        if (!(cache
              ? cacheHas(cache, computed)
              : includes(arrays[othIndex], computed, comparator))
            ) {
          continue outer;
        }
      }
      if (seen) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseIntersection;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIsNaN.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseIsNaN.js
      return function (require, module, exports) {
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseRest.js", {"./_overRest":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_overRest.js","./_setToString":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_setToString.js","./identity":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\identity.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseRest.js
      return function (require, module, exports) {
var identity = require('./identity'),
    overRest = require('./_overRest'),
    setToString = require('./_setToString');

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseSetToString.js", {"./_defineProperty":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_defineProperty.js","./constant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\constant.js","./identity":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\identity.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseSetToString.js
      return function (require, module, exports) {
var constant = require('./constant'),
    defineProperty = require('./_defineProperty'),
    identity = require('./identity');

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseUniq.js", {"./_SetCache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_SetCache.js","./_arrayIncludes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludes.js","./_arrayIncludesWith":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayIncludesWith.js","./_cacheHas":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_cacheHas.js","./_createSet":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_createSet.js","./_setToArray":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_setToArray.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseUniq.js
      return function (require, module, exports) {
var SetCache = require('./_SetCache'),
    arrayIncludes = require('./_arrayIncludes'),
    arrayIncludesWith = require('./_arrayIncludesWith'),
    cacheHas = require('./_cacheHas'),
    createSet = require('./_createSet'),
    setToArray = require('./_setToArray');

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseXor.js", {"./_baseDifference":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseDifference.js","./_baseFlatten":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseFlatten.js","./_baseUniq":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseUniq.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_baseXor.js
      return function (require, module, exports) {
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseUniq = require('./_baseUniq');

/**
 * The base implementation of methods like `_.xor`, without support for
 * iteratee shorthands, that accepts an array of arrays to inspect.
 *
 * @private
 * @param {Array} arrays The arrays to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of values.
 */
function baseXor(arrays, iteratee, comparator) {
  var length = arrays.length;
  if (length < 2) {
    return length ? baseUniq(arrays[0]) : [];
  }
  var index = -1,
      result = Array(length);

  while (++index < length) {
    var array = arrays[index],
        othIndex = -1;

    while (++othIndex < length) {
      if (othIndex != index) {
        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
      }
    }
  }
  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
}

module.exports = baseXor;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_castArrayLikeObject.js", {"./isArrayLikeObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_castArrayLikeObject.js
      return function (require, module, exports) {
var isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Casts `value` to an empty array if it's not an array like object.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array|Object} Returns the cast array-like object.
 */
function castArrayLikeObject(value) {
  return isArrayLikeObject(value) ? value : [];
}

module.exports = castArrayLikeObject;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_createSet.js", {"./_Set":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_Set.js","./_setToArray":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_setToArray.js","./noop":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\noop.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_createSet.js
      return function (require, module, exports) {
var Set = require('./_Set'),
    noop = require('./noop'),
    setToArray = require('./_setToArray');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_isFlattenable.js", {"./_Symbol":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_Symbol.js","./isArguments":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArguments.js","./isArray":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArray.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_isFlattenable.js
      return function (require, module, exports) {
var Symbol = require('./_Symbol'),
    isArguments = require('./isArguments'),
    isArray = require('./isArray');

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_overRest.js", {"./_apply":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_apply.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_overRest.js
      return function (require, module, exports) {
var apply = require('./_apply');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_setToString.js", {"./_baseSetToString":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseSetToString.js","./_shortOut":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_shortOut.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_setToString.js
      return function (require, module, exports) {
var baseSetToString = require('./_baseSetToString'),
    shortOut = require('./_shortOut');

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_shortOut.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_shortOut.js
      return function (require, module, exports) {
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_strictIndexOf.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\_strictIndexOf.js
      return function (require, module, exports) {
/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\constant.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\constant.js
      return function (require, module, exports) {
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\difference.js", {"./_baseDifference":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseDifference.js","./_baseFlatten":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseFlatten.js","./_baseRest":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseRest.js","./isArrayLikeObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\difference.js
      return function (require, module, exports) {
var baseDifference = require('./_baseDifference'),
    baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
    : [];
});

module.exports = difference;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\intersection.js", {"./_arrayMap":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayMap.js","./_baseIntersection":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIntersection.js","./_baseRest":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseRest.js","./_castArrayLikeObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_castArrayLikeObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\intersection.js
      return function (require, module, exports) {
var arrayMap = require('./_arrayMap'),
    baseIntersection = require('./_baseIntersection'),
    baseRest = require('./_baseRest'),
    castArrayLikeObject = require('./_castArrayLikeObject');

/**
 * Creates an array of unique values that are included in all given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of intersecting values.
 * @example
 *
 * _.intersection([2, 1], [2, 3]);
 * // => [2]
 */
var intersection = baseRest(function(arrays) {
  var mapped = arrayMap(arrays, castArrayLikeObject);
  return (mapped.length && mapped[0] === arrays[0])
    ? baseIntersection(mapped)
    : [];
});

module.exports = intersection;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js", {"./isArrayLike":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLike.js","./isObjectLike":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\isArrayLikeObject.js
      return function (require, module, exports) {
var isArrayLike = require('./isArrayLike'),
    isObjectLike = require('./isObjectLike');

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isEqual.js", {"./_baseIsEqual":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseIsEqual.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\isEqual.js
      return function (require, module, exports) {
var baseIsEqual = require('./_baseIsEqual');

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isPlainObject.js", {"./_baseGetTag":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseGetTag.js","./_getPrototype":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_getPrototype.js","./isObjectLike":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isObjectLike.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\isPlainObject.js
      return function (require, module, exports) {
var baseGetTag = require('./_baseGetTag'),
    getPrototype = require('./_getPrototype'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\union.js", {"./_baseFlatten":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseFlatten.js","./_baseRest":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseRest.js","./_baseUniq":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseUniq.js","./isArrayLikeObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\union.js
      return function (require, module, exports) {
var baseFlatten = require('./_baseFlatten'),
    baseRest = require('./_baseRest'),
    baseUniq = require('./_baseUniq'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\without.js", {"./_baseDifference":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseDifference.js","./_baseRest":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseRest.js","./isArrayLikeObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\without.js
      return function (require, module, exports) {
var baseDifference = require('./_baseDifference'),
    baseRest = require('./_baseRest'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array excluding all given values using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * **Note:** Unlike `_.pull`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...*} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.xor
 * @example
 *
 * _.without([2, 1, 2, 3], 1, 2);
 * // => [3]
 */
var without = baseRest(function(array, values) {
  return isArrayLikeObject(array)
    ? baseDifference(array, values)
    : [];
});

module.exports = without;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\xor.js", {"./_arrayFilter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_arrayFilter.js","./_baseRest":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseRest.js","./_baseXor":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\_baseXor.js","./isArrayLikeObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArrayLikeObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lodash\xor.js
      return function (require, module, exports) {
var arrayFilter = require('./_arrayFilter'),
    baseRest = require('./_baseRest'),
    baseXor = require('./_baseXor'),
    isArrayLikeObject = require('./isArrayLikeObject');

/**
 * Creates an array of unique values that is the
 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
 * of the given arrays. The order of result values is determined by the order
 * they occur in the arrays.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.difference, _.without
 * @example
 *
 * _.xor([2, 1], [2, 3]);
 * // => [1, 3]
 */
var xor = baseRest(function(arrays) {
  return baseXor(arrayFilter(arrays, isArrayLikeObject));
});

module.exports = xor;

      };
    };
  }
}, {package:"lodash",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lower-case-first\\lower-case-first.js", {"lower-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lower-case-first\lower-case-first.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

/**
 * Lower case the first character of a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  if (str == null) {
    return ''
  }

  str = String(str)

  return lowerCase(str.charAt(0), locale) + str.substr(1)
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>lower-case-first",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lower-case\\lower-case.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\lower-case\lower-case.js
      return function (require, module, exports) {
/**
 * Special language-specific overrides.
 *
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 *
 * @type {Object}
 */
var LANGUAGES = {
  tr: {
    regexp: /\u0130|\u0049|\u0049\u0307/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  az: {
    regexp: /[\u0130]/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  lt: {
    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
    map: {
      '\u0049': '\u0069\u0307',
      '\u004A': '\u006A\u0307',
      '\u012E': '\u012F\u0307',
      '\u00CC': '\u0069\u0307\u0300',
      '\u00CD': '\u0069\u0307\u0301',
      '\u0128': '\u0069\u0307\u0303'
    }
  }
}

/**
 * Lowercase a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  var lang = LANGUAGES[locale]

  str = str == null ? '' : String(str)

  if (lang) {
    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
  }

  return str.toLowerCase()
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>lower-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\mersenne-twister\\src\\mersenne-twister.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\mersenne-twister\src\mersenne-twister.js
      return function (require, module, exports) {
/*
  https://github.com/banksean wrapped Makoto Matsumoto and Takuji Nishimura's code in a namespace
  so it's better encapsulated. Now you can have multiple random number generators
  and they won't stomp all over eachother's state.

  If you want to use this as a substitute for Math.random(), use the random()
  method like so:

  var m = new MersenneTwister();
  var randomNumber = m.random();

  You can also call the other genrand_{foo}() methods on the instance.

  If you want to use a specific seed in order to get a repeatable random
  sequence, pass an integer into the constructor:

  var m = new MersenneTwister(123);

  and that will always produce the same random sequence.

  Sean McCullough (banksean@gmail.com)
*/

/*
   A C-program for MT19937, with initialization improved 2002/1/26.
   Coded by Takuji Nishimura and Makoto Matsumoto.

   Before using, initialize the state by using init_seed(seed)
   or init_by_array(init_key, key_length).

   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,
   All rights reserved.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions
   are met:

     1. Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.

     2. Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the
        documentation and/or other materials provided with the distribution.

     3. The names of its contributors may not be used to endorse or promote
        products derived from this software without specific prior written
        permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


   Any feedback is very welcome.
   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html
   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)
*/

var MersenneTwister = function(seed) {
	if (seed == undefined) {
		seed = new Date().getTime();
	}

	/* Period parameters */
	this.N = 624;
	this.M = 397;
	this.MATRIX_A = 0x9908b0df;   /* constant vector a */
	this.UPPER_MASK = 0x80000000; /* most significant w-r bits */
	this.LOWER_MASK = 0x7fffffff; /* least significant r bits */

	this.mt = new Array(this.N); /* the array for the state vector */
	this.mti=this.N+1; /* mti==N+1 means mt[N] is not initialized */

	if (seed.constructor == Array) {
		this.init_by_array(seed, seed.length);
	}
	else {
		this.init_seed(seed);
	}
}

/* initializes mt[N] with a seed */
/* origin name init_genrand */
MersenneTwister.prototype.init_seed = function(s) {
	this.mt[0] = s >>> 0;
	for (this.mti=1; this.mti<this.N; this.mti++) {
		var s = this.mt[this.mti-1] ^ (this.mt[this.mti-1] >>> 30);
		this.mt[this.mti] = (((((s & 0xffff0000) >>> 16) * 1812433253) << 16) + (s & 0x0000ffff) * 1812433253)
		+ this.mti;
		/* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
		/* In the previous versions, MSBs of the seed affect   */
		/* only MSBs of the array mt[].                        */
		/* 2002/01/09 modified by Makoto Matsumoto             */
		this.mt[this.mti] >>>= 0;
		/* for >32 bit machines */
	}
}

/* initialize by an array with array-length */
/* init_key is the array for initializing keys */
/* key_length is its length */
/* slight change for C++, 2004/2/26 */
MersenneTwister.prototype.init_by_array = function(init_key, key_length) {
	var i, j, k;
	this.init_seed(19650218);
	i=1; j=0;
	k = (this.N>key_length ? this.N : key_length);
	for (; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30)
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1664525) << 16) + ((s & 0x0000ffff) * 1664525)))
		+ init_key[j] + j; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++; j++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
		if (j>=key_length) j=0;
	}
	for (k=this.N-1; k; k--) {
		var s = this.mt[i-1] ^ (this.mt[i-1] >>> 30);
		this.mt[i] = (this.mt[i] ^ (((((s & 0xffff0000) >>> 16) * 1566083941) << 16) + (s & 0x0000ffff) * 1566083941))
		- i; /* non linear */
		this.mt[i] >>>= 0; /* for WORDSIZE > 32 machines */
		i++;
		if (i>=this.N) { this.mt[0] = this.mt[this.N-1]; i=1; }
	}

	this.mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */
}

/* generates a random number on [0,0xffffffff]-interval */
/* origin name genrand_int32 */
MersenneTwister.prototype.random_int = function() {
	var y;
	var mag01 = new Array(0x0, this.MATRIX_A);
	/* mag01[x] = x * MATRIX_A  for x=0,1 */

	if (this.mti >= this.N) { /* generate N words at one time */
		var kk;

		if (this.mti == this.N+1)  /* if init_seed() has not been called, */
			this.init_seed(5489);  /* a default initial seed is used */

		for (kk=0;kk<this.N-this.M;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+this.M] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		for (;kk<this.N-1;kk++) {
			y = (this.mt[kk]&this.UPPER_MASK)|(this.mt[kk+1]&this.LOWER_MASK);
			this.mt[kk] = this.mt[kk+(this.M-this.N)] ^ (y >>> 1) ^ mag01[y & 0x1];
		}
		y = (this.mt[this.N-1]&this.UPPER_MASK)|(this.mt[0]&this.LOWER_MASK);
		this.mt[this.N-1] = this.mt[this.M-1] ^ (y >>> 1) ^ mag01[y & 0x1];

		this.mti = 0;
	}

	y = this.mt[this.mti++];

	/* Tempering */
	y ^= (y >>> 11);
	y ^= (y << 7) & 0x9d2c5680;
	y ^= (y << 15) & 0xefc60000;
	y ^= (y >>> 18);

	return y >>> 0;
}

/* generates a random number on [0,0x7fffffff]-interval */
/* origin name genrand_int31 */
MersenneTwister.prototype.random_int31 = function() {
	return (this.random_int()>>>1);
}

/* generates a random number on [0,1]-real-interval */
/* origin name genrand_real1 */
MersenneTwister.prototype.random_incl = function() {
	return this.random_int()*(1.0/4294967295.0);
	/* divided by 2^32-1 */
}

/* generates a random number on [0,1)-real-interval */
MersenneTwister.prototype.random = function() {
	return this.random_int()*(1.0/4294967296.0);
	/* divided by 2^32 */
}

/* generates a random number on (0,1)-real-interval */
/* origin name genrand_real3 */
MersenneTwister.prototype.random_excl = function() {
	return (this.random_int() + 0.5)*(1.0/4294967296.0);
	/* divided by 2^32 */
}

/* generates a random number on [0,1) with 53-bit resolution*/
/* origin name genrand_res53 */
MersenneTwister.prototype.random_long = function() {
	var a=this.random_int()>>>5, b=this.random_int()>>>6;
	return(a*67108864.0+b)*(1.0/9007199254740992.0);
}

/* These real versions are due to Isaku Wada, 2002/01/09 added */

module.exports = MersenneTwister;

      };
    };
  }
}, {package:"@metamask/jazzicon>mersenne-twister",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\mini-create-react-context\\dist\\cjs\\index.js", {"@babel/runtime/helpers/inheritsLoose":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@babel\\runtime\\helpers\\inheritsLoose.js","gud":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\gud\\index.js","prop-types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\index.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js","tiny-warning":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\tiny-warning\\dist\\tiny-warning.cjs.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\mini-create-react-context\dist\cjs\index.js
      return function (require, module, exports) {
'use strict';function _interopDefault(e){return(e&&(typeof e==='object')&&'default'in e)?e['default']:e}var React=require('react'),React__default=_interopDefault(React),_inheritsLoose=_interopDefault(require('@babel/runtime/helpers/inheritsLoose')),PropTypes=_interopDefault(require('prop-types')),gud=_interopDefault(require('gud')),warning=_interopDefault(require('tiny-warning'));var MAX_SIGNED_31_BIT_INT = 1073741823;

function objectIs(x, y) {
  if (x === y) {
    return x !== 0 || 1 / x === 1 / y;
  } else {
    return x !== x && y !== y;
  }
}

function createEventEmitter(value) {
  var handlers = [];
  return {
    on: function on(handler) {
      handlers.push(handler);
    },
    off: function off(handler) {
      handlers = handlers.filter(function (h) {
        return h !== handler;
      });
    },
    get: function get() {
      return value;
    },
    set: function set(newValue, changedBits) {
      value = newValue;
      handlers.forEach(function (handler) {
        return handler(value, changedBits);
      });
    }
  };
}

function onlyChild(children) {
  return Array.isArray(children) ? children[0] : children;
}

function createReactContext(defaultValue, calculateChangedBits) {
  var _Provider$childContex, _Consumer$contextType;

  var contextProp = '__create-react-context-' + gud() + '__';

  var Provider =
  /*#__PURE__*/
  function (_Component) {
    _inheritsLoose(Provider, _Component);

    function Provider() {
      var _this;

      _this = _Component.apply(this, arguments) || this;
      _this.emitter = createEventEmitter(_this.props.value);
      return _this;
    }

    var _proto = Provider.prototype;

    _proto.getChildContext = function getChildContext() {
      var _ref;

      return _ref = {}, _ref[contextProp] = this.emitter, _ref;
    };

    _proto.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      if (this.props.value !== nextProps.value) {
        var oldValue = this.props.value;
        var newValue = nextProps.value;
        var changedBits;

        if (objectIs(oldValue, newValue)) {
          changedBits = 0;
        } else {
          changedBits = typeof calculateChangedBits === 'function' ? calculateChangedBits(oldValue, newValue) : MAX_SIGNED_31_BIT_INT;

          if ("development" !== 'production') {
            warning((changedBits & MAX_SIGNED_31_BIT_INT) === changedBits, 'calculateChangedBits: Expected the return value to be a ' + '31-bit integer. Instead received: ' + changedBits);
          }

          changedBits |= 0;

          if (changedBits !== 0) {
            this.emitter.set(nextProps.value, changedBits);
          }
        }
      }
    };

    _proto.render = function render() {
      return this.props.children;
    };

    return Provider;
  }(React.Component);

  Provider.childContextTypes = (_Provider$childContex = {}, _Provider$childContex[contextProp] = PropTypes.object.isRequired, _Provider$childContex);

  var Consumer =
  /*#__PURE__*/
  function (_Component2) {
    _inheritsLoose(Consumer, _Component2);

    function Consumer() {
      var _this2;

      _this2 = _Component2.apply(this, arguments) || this;
      _this2.state = {
        value: _this2.getValue()
      };

      _this2.onUpdate = function (newValue, changedBits) {
        var observedBits = _this2.observedBits | 0;

        if ((observedBits & changedBits) !== 0) {
          _this2.setState({
            value: _this2.getValue()
          });
        }
      };

      return _this2;
    }

    var _proto2 = Consumer.prototype;

    _proto2.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
      var observedBits = nextProps.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentDidMount = function componentDidMount() {
      if (this.context[contextProp]) {
        this.context[contextProp].on(this.onUpdate);
      }

      var observedBits = this.props.observedBits;
      this.observedBits = observedBits === undefined || observedBits === null ? MAX_SIGNED_31_BIT_INT : observedBits;
    };

    _proto2.componentWillUnmount = function componentWillUnmount() {
      if (this.context[contextProp]) {
        this.context[contextProp].off(this.onUpdate);
      }
    };

    _proto2.getValue = function getValue() {
      if (this.context[contextProp]) {
        return this.context[contextProp].get();
      } else {
        return defaultValue;
      }
    };

    _proto2.render = function render() {
      return onlyChild(this.props.children)(this.state.value);
    };

    return Consumer;
  }(React.Component);

  Consumer.contextTypes = (_Consumer$contextType = {}, _Consumer$contextType[contextProp] = PropTypes.object, _Consumer$contextType);
  return {
    Provider: Provider,
    Consumer: Consumer
  };
}var index = React__default.createContext || createReactContext;module.exports=index;
      };
    };
  }
}, {package:"react-router-dom>react-router>mini-create-react-context",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\nanoid\\non-secure\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\nanoid\non-secure\index.js
      return function (require, module, exports) {
// This alphabet uses a-z A-Z 0-9 _- symbols.
// Symbols are generated for smaller size.
// -_zyxwvutsrqponmlkjihgfedcba9876543210ZYXWVUTSRQPONMLKJIHGFEDCBA
var url = '-_'
// Loop from 36 to 0 (from z to a and 9 to 0 in Base36).
var i = 36
while (i--) {
  // 36 is radix. Number.prototype.toString(36) returns number
  // in Base36 representation. Base36 is like hex, but it uses 09 and a-z.
  url += i.toString(36)
}
// Loop from 36 to 10 (from Z to A in Base36).
i = 36
while (i-- - 10) {
  url += i.toString(36).toUpperCase()
}

/**
 * Generate URL-friendly unique ID. This method use non-secure predictable
 * random generator with bigger collision probability.
 *
 * @param {number} [size=21] The number of symbols in ID.
 *
 * @return {string} Random string.
 *
 * @example
 * const nanoid = require('nanoid/non-secure')
 * model.id = nanoid() //=> "Uakgb_J5m9g-0JDMbcJqL"
 *
 * @name nonSecure
 * @function
 */
module.exports = function (size) {
  var id = ''
  i = size || 21
  // Compact alternative for `for (var i = 0; i < size; i++)`
  while (i--) {
    // `| 0` is compact and faster alternative for `Math.floor()`
    id += url[Math.random() * 64 | 0]
  }
  return id
}

      };
    };
  }
}, {package:"nanoid",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\no-case.js", {"./vendor/camel-case-regexp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-regexp.js","./vendor/camel-case-upper-regexp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-upper-regexp.js","./vendor/non-word-regexp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\vendor\\non-word-regexp.js","lower-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lower-case\\lower-case.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\no-case\no-case.js
      return function (require, module, exports) {
var lowerCase = require('lower-case')

var NON_WORD_REGEXP = require('./vendor/non-word-regexp')
var CAMEL_CASE_REGEXP = require('./vendor/camel-case-regexp')
var CAMEL_CASE_UPPER_REGEXP = require('./vendor/camel-case-upper-regexp')

/**
 * Sentence case a string.
 *
 * @param  {string} str
 * @param  {string} locale
 * @param  {string} replacement
 * @return {string}
 */
module.exports = function (str, locale, replacement) {
  if (str == null) {
    return ''
  }

  replacement = typeof replacement !== 'string' ? ' ' : replacement

  function replace (match, index, value) {
    if (index === 0 || index === (value.length - match.length)) {
      return ''
    }

    return replacement
  }

  str = String(str)
    // Support camel case ("camelCase" -> "camel Case").
    .replace(CAMEL_CASE_REGEXP, '$1 $2')
    // Support odd camel case ("CAMELCase" -> "CAMEL Case").
    .replace(CAMEL_CASE_UPPER_REGEXP, '$1 $2')
    // Remove all non-word characters and replace with a single space.
    .replace(NON_WORD_REGEXP, replace)

  // Lower case the entire string.
  return lowerCase(str, locale)
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-regexp.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\no-case\vendor\camel-case-regexp.js
      return function (require, module, exports) {
module.exports = /([a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])/g

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\vendor\\camel-case-upper-regexp.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\no-case\vendor\camel-case-upper-regexp.js
      return function (require, module, exports) {
module.exports = /([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A][a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])/g

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\vendor\\non-word-regexp.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\no-case\vendor\non-word-regexp.js
      return function (require, module, exports) {
module.exports = /[^A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>no-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\node-interval-tree\\lib\\index.js", {"shallowequal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\shallowequal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\node-interval-tree\lib\index.js
      return function (require, module, exports) {
"use strict";
// An augmented AVL Tree where each node maintains a list of records and their search intervals.
// Record is composed of an interval and its underlying data, sent by a client. This allows the
// interval tree to have the same interval inserted multiple times, as long its data is different.
// Both insertion and deletion require O(log n) time. Searching requires O(k*logn) time, where `k`
// is the number of intervals in the output list.
Object.defineProperty(exports, "__esModule", { value: true });
var isSame = require("shallowequal");
function height(node) {
    if (node === undefined) {
        return -1;
    }
    else {
        return node.height;
    }
}
var Node = /** @class */ (function () {
    function Node(intervalTree, record) {
        this.intervalTree = intervalTree;
        this.records = [];
        this.height = 0;
        this.key = record.low;
        this.max = record.high;
        // Save the array of all records with the same key for this node
        this.records.push(record);
    }
    // Gets the highest record.high value for this node
    Node.prototype.getNodeHigh = function () {
        var high = this.records[0].high;
        for (var i = 1; i < this.records.length; i++) {
            if (this.records[i].high > high) {
                high = this.records[i].high;
            }
        }
        return high;
    };
    // Updates height value of the node. Called during insertion, rebalance, removal
    Node.prototype.updateHeight = function () {
        this.height = Math.max(height(this.left), height(this.right)) + 1;
    };
    // Updates the max value of all the parents after inserting into already existing node, as well as
    // removing the node completely or removing the record of an already existing node. Starts with
    // the parent of an affected node and bubbles up to root
    Node.prototype.updateMaxOfParents = function () {
        if (this === undefined) {
            return;
        }
        var thisHigh = this.getNodeHigh();
        if (this.left !== undefined && this.right !== undefined) {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(this.left.max, thisHigh);
        }
        else if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(this.right.max, thisHigh);
        }
        else {
            this.max = thisHigh;
        }
        if (this.parent) {
            this.parent.updateMaxOfParents();
        }
    };
    /*
    Left-Left case:
  
           z                                      y
          / \                                   /   \
         y   T4      Right Rotate (z)          x     z
        / \          - - - - - - - - ->       / \   / \
       x   T3                                T1 T2 T3 T4
      / \
    T1   T2
  
    Left-Right case:
  
         z                               z                           x
        / \                             / \                        /   \
       y   T4  Left Rotate (y)         x  T4  Right Rotate(z)     y     z
      / \      - - - - - - - - ->     / \      - - - - - - - ->  / \   / \
    T1   x                           y  T3                      T1 T2 T3 T4
        / \                         / \
      T2   T3                      T1 T2
    */
    // Handles Left-Left case and Left-Right case after rebalancing AVL tree
    Node.prototype._updateMaxAfterRightRotate = function () {
        var parent = this.parent;
        var left = parent.left;
        // Update max of left sibling (x in first case, y in second)
        var thisParentLeftHigh = left.getNodeHigh();
        if (left.left === undefined && left.right !== undefined) {
            left.max = Math.max(thisParentLeftHigh, left.right.max);
        }
        else if (left.left !== undefined && left.right === undefined) {
            left.max = Math.max(thisParentLeftHigh, left.left.max);
        }
        else if (left.left === undefined && left.right === undefined) {
            left.max = thisParentLeftHigh;
        }
        else {
            left.max = Math.max(Math.max(left.left.max, left.right.max), thisParentLeftHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, parent.right.max), parent.getNodeHigh());
    };
    /*
    Right-Right case:
  
      z                               y
     / \                            /   \
    T1  y     Left Rotate(z)       z     x
       / \   - - - - - - - ->     / \   / \
      T2  x                      T1 T2 T3 T4
         / \
        T3 T4
  
    Right-Left case:
  
       z                            z                            x
      / \                          / \                         /   \
     T1  y   Right Rotate (y)     T1  x      Left Rotate(z)   z     y
        / \  - - - - - - - - ->      / \   - - - - - - - ->  / \   / \
       x  T4                        T2  y                   T1 T2 T3 T4
      / \                              / \
    T2   T3                           T3 T4
    */
    // Handles Right-Right case and Right-Left case in rebalancing AVL tree
    Node.prototype._updateMaxAfterLeftRotate = function () {
        var parent = this.parent;
        var right = parent.right;
        // Update max of right sibling (x in first case, y in second)
        var thisParentRightHigh = right.getNodeHigh();
        if (right.left === undefined && right.right !== undefined) {
            right.max = Math.max(thisParentRightHigh, right.right.max);
        }
        else if (right.left !== undefined && right.right === undefined) {
            right.max = Math.max(thisParentRightHigh, right.left.max);
        }
        else if (right.left === undefined && right.right === undefined) {
            right.max = thisParentRightHigh;
        }
        else {
            right.max = Math.max(Math.max(right.left.max, right.right.max), thisParentRightHigh);
        }
        // Update max of itself (z)
        var thisHigh = this.getNodeHigh();
        if (this.left === undefined && this.right !== undefined) {
            this.max = Math.max(thisHigh, this.right.max);
        }
        else if (this.left !== undefined && this.right === undefined) {
            this.max = Math.max(thisHigh, this.left.max);
        }
        else if (this.left === undefined && this.right === undefined) {
            this.max = thisHigh;
        }
        else {
            this.max = Math.max(Math.max(this.left.max, this.right.max), thisHigh);
        }
        // Update max of parent (y in first case, x in second)
        parent.max = Math.max(Math.max(parent.left.max, right.max), parent.getNodeHigh());
    };
    Node.prototype._leftRotate = function () {
        var rightChild = this.right;
        rightChild.parent = this.parent;
        if (rightChild.parent === undefined) {
            this.intervalTree.root = rightChild;
        }
        else {
            if (rightChild.parent.left === this) {
                rightChild.parent.left = rightChild;
            }
            else if (rightChild.parent.right === this) {
                rightChild.parent.right = rightChild;
            }
        }
        this.right = rightChild.left;
        if (this.right !== undefined) {
            this.right.parent = this;
        }
        rightChild.left = this;
        this.parent = rightChild;
        this.updateHeight();
        rightChild.updateHeight();
    };
    Node.prototype._rightRotate = function () {
        var leftChild = this.left;
        leftChild.parent = this.parent;
        if (leftChild.parent === undefined) {
            this.intervalTree.root = leftChild;
        }
        else {
            if (leftChild.parent.left === this) {
                leftChild.parent.left = leftChild;
            }
            else if (leftChild.parent.right === this) {
                leftChild.parent.right = leftChild;
            }
        }
        this.left = leftChild.right;
        if (this.left !== undefined) {
            this.left.parent = this;
        }
        leftChild.right = this;
        this.parent = leftChild;
        this.updateHeight();
        leftChild.updateHeight();
    };
    // Rebalances the tree if the height value between two nodes of the same parent is greater than
    // two. There are 4 cases that can happen which are outlined in the graphics above
    Node.prototype._rebalance = function () {
        if (height(this.left) >= 2 + height(this.right)) {
            var left = this.left;
            if (height(left.left) >= height(left.right)) {
                // Left-Left case
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
            else {
                // Left-Right case
                left._leftRotate();
                this._rightRotate();
                this._updateMaxAfterRightRotate();
            }
        }
        else if (height(this.right) >= 2 + height(this.left)) {
            var right = this.right;
            if (height(right.right) >= height(right.left)) {
                // Right-Right case
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
            else {
                // Right-Left case
                right._rightRotate();
                this._leftRotate();
                this._updateMaxAfterLeftRotate();
            }
        }
    };
    Node.prototype.insert = function (record) {
        if (record.low < this.key) {
            // Insert into left subtree
            if (this.left === undefined) {
                this.left = new Node(this.intervalTree, record);
                this.left.parent = this;
            }
            else {
                this.left.insert(record);
            }
        }
        else {
            // Insert into right subtree
            if (this.right === undefined) {
                this.right = new Node(this.intervalTree, record);
                this.right.parent = this;
            }
            else {
                this.right.insert(record);
            }
        }
        // Update the max value of this ancestor if needed
        if (this.max < record.high) {
            this.max = record.high;
        }
        // Update height of each node
        this.updateHeight();
        // Rebalance the tree to ensure all operations are executed in O(logn) time. This is especially
        // important in searching, as the tree has a high chance of degenerating without the rebalancing
        this._rebalance();
    };
    Node.prototype._getOverlappingRecords = function (currentNode, low, high) {
        if (currentNode.key <= high && low <= currentNode.getNodeHigh()) {
            // Nodes are overlapping, check if individual records in the node are overlapping
            var tempResults = [];
            for (var i = 0; i < currentNode.records.length; i++) {
                if (currentNode.records[i].high >= low) {
                    tempResults.push(currentNode.records[i]);
                }
            }
            return tempResults;
        }
        return [];
    };
    Node.prototype.search = function (low, high) {
        // Don't search nodes that don't exist
        if (this === undefined) {
            return [];
        }
        var leftSearch = [];
        var ownSearch = [];
        var rightSearch = [];
        // If interval is to the right of the rightmost point of any interval in this node and all its
        // children, there won't be any matches
        if (low > this.max) {
            return [];
        }
        // Search left children
        if (this.left !== undefined && this.left.max >= low) {
            leftSearch = this.left.search(low, high);
        }
        // Check this node
        ownSearch = this._getOverlappingRecords(this, low, high);
        // If interval is to the left of the start of this interval, then it can't be in any child to
        // the right
        if (high < this.key) {
            return leftSearch.concat(ownSearch);
        }
        // Otherwise, search right children
        if (this.right !== undefined) {
            rightSearch = this.right.search(low, high);
        }
        // Return accumulated results, if any
        return leftSearch.concat(ownSearch, rightSearch);
    };
    // Searches for a node by a `key` value
    Node.prototype.searchExisting = function (low) {
        if (this === undefined) {
            return undefined;
        }
        if (this.key === low) {
            return this;
        }
        else if (low < this.key) {
            if (this.left !== undefined) {
                return this.left.searchExisting(low);
            }
        }
        else {
            if (this.right !== undefined) {
                return this.right.searchExisting(low);
            }
        }
        return undefined;
    };
    // Returns the smallest node of the subtree
    Node.prototype._minValue = function () {
        if (this.left === undefined) {
            return this;
        }
        else {
            return this.left._minValue();
        }
    };
    Node.prototype.remove = function (node) {
        var parent = this.parent;
        if (node.key < this.key) {
            // Node to be removed is on the left side
            if (this.left !== undefined) {
                return this.left.remove(node);
            }
            else {
                return undefined;
            }
        }
        else if (node.key > this.key) {
            // Node to be removed is on the right side
            if (this.right !== undefined) {
                return this.right.remove(node);
            }
            else {
                return undefined;
            }
        }
        else {
            if (this.left !== undefined && this.right !== undefined) {
                // Node has two children
                var minValue = this.right._minValue();
                this.key = minValue.key;
                this.records = minValue.records;
                return this.right.remove(this);
            }
            else if (parent.left === this) {
                // One child or no child case on left side
                if (this.right !== undefined) {
                    parent.left = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.left = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
            else if (parent.right === this) {
                // One child or no child case on right side
                if (this.right !== undefined) {
                    parent.right = this.right;
                    this.right.parent = parent;
                }
                else {
                    parent.right = this.left;
                    if (this.left !== undefined) {
                        this.left.parent = parent;
                    }
                }
                parent.updateMaxOfParents();
                parent.updateHeight();
                parent._rebalance();
                return this;
            }
        }
    };
    return Node;
}());
exports.Node = Node;
var IntervalTree = /** @class */ (function () {
    function IntervalTree() {
        this.count = 0;
    }
    IntervalTree.prototype.insert = function (record) {
        if (record.low > record.high) {
            throw new Error('`low` value must be lower or equal to `high` value');
        }
        if (this.root === undefined) {
            // Base case: Tree is empty, new node becomes root
            this.root = new Node(this, record);
            this.count++;
            return true;
        }
        else {
            // Otherwise, check if node already exists with the same key
            var node = this.root.searchExisting(record.low);
            if (node !== undefined) {
                // Check the records in this node if there already is the one with same low, high, data
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        // This record is same as the one we're trying to insert; return false to indicate
                        // nothing has been inserted
                        return false;
                    }
                }
                // Add the record to the node
                node.records.push(record);
                // Update max of the node and its parents if necessary
                if (record.high > node.max) {
                    node.max = record.high;
                    if (node.parent) {
                        node.parent.updateMaxOfParents();
                    }
                }
                this.count++;
                return true;
            }
            else {
                // Node with this key doesn't already exist. Call insert function on root's node
                this.root.insert(record);
                this.count++;
                return true;
            }
        }
    };
    IntervalTree.prototype.search = function (low, high) {
        if (this.root === undefined) {
            // Tree is empty; return empty array
            return [];
        }
        else {
            return this.root.search(low, high);
        }
    };
    IntervalTree.prototype.remove = function (record) {
        if (this.root === undefined) {
            // Tree is empty; nothing to remove
            return false;
        }
        else {
            var node = this.root.searchExisting(record.low);
            if (node === undefined) {
                return false;
            }
            else if (node.records.length > 1) {
                var removedRecord = void 0;
                // Node with this key has 2 or more records. Find the one we need and remove it
                for (var i = 0; i < node.records.length; i++) {
                    if (isSame(node.records[i], record)) {
                        removedRecord = node.records[i];
                        node.records.splice(i, 1);
                        break;
                    }
                }
                if (removedRecord) {
                    removedRecord = undefined;
                    // Update max of that node and its parents if necessary
                    if (record.high === node.max) {
                        var nodeHigh = node.getNodeHigh();
                        if (node.left !== undefined && node.right !== undefined) {
                            node.max = Math.max(Math.max(node.left.max, node.right.max), nodeHigh);
                        }
                        else if (node.left !== undefined && node.right === undefined) {
                            node.max = Math.max(node.left.max, nodeHigh);
                        }
                        else if (node.left === undefined && node.right !== undefined) {
                            node.max = Math.max(node.right.max, nodeHigh);
                        }
                        else {
                            node.max = nodeHigh;
                        }
                        if (node.parent) {
                            node.parent.updateMaxOfParents();
                        }
                    }
                    this.count--;
                    return true;
                }
                else {
                    return false;
                }
            }
            else if (node.records.length === 1) {
                // Node with this key has only 1 record. Check if the remaining record in this node is
                // actually the one we want to remove
                if (isSame(node.records[0], record)) {
                    // The remaining record is the one we want to remove. Remove the whole node from the tree
                    if (this.root.key === node.key) {
                        // We're removing the root element. Create a dummy node that will temporarily take
                        // root's parent role
                        var rootParent = new Node(this, { low: record.low, high: record.low });
                        rootParent.left = this.root;
                        this.root.parent = rootParent;
                        var removedNode = this.root.remove(node);
                        this.root = rootParent.left;
                        if (this.root !== undefined) {
                            this.root.parent = undefined;
                        }
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                    else {
                        var removedNode = this.root.remove(node);
                        if (removedNode) {
                            removedNode = undefined;
                            this.count--;
                            return true;
                        }
                        else {
                            return false;
                        }
                    }
                }
                else {
                    // The remaining record is not the one we want to remove
                    return false;
                }
            }
            else {
                // No records at all in this node?! Shouldn't happen
                return false;
            }
        }
    };
    IntervalTree.prototype.inOrder = function () {
        return new InOrder(this.root);
    };
    IntervalTree.prototype.preOrder = function () {
        return new PreOrder(this.root);
    };
    return IntervalTree;
}());
exports.IntervalTree = IntervalTree;
var DataIntervalTree = /** @class */ (function () {
    function DataIntervalTree() {
        this.tree = new IntervalTree();
    }
    DataIntervalTree.prototype.insert = function (low, high, data) {
        return this.tree.insert({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.remove = function (low, high, data) {
        return this.tree.remove({ low: low, high: high, data: data });
    };
    DataIntervalTree.prototype.search = function (low, high) {
        return this.tree.search(low, high).map(function (v) { return v.data; });
    };
    DataIntervalTree.prototype.inOrder = function () {
        return this.tree.inOrder();
    };
    DataIntervalTree.prototype.preOrder = function () {
        return this.tree.preOrder();
    };
    Object.defineProperty(DataIntervalTree.prototype, "count", {
        get: function () {
            return this.tree.count;
        },
        enumerable: true,
        configurable: true
    });
    return DataIntervalTree;
}());
exports.default = DataIntervalTree;
var InOrder = /** @class */ (function () {
    function InOrder(startNode) {
        this.stack = [];
        if (startNode !== undefined) {
            this.push(startNode);
        }
    }
    InOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        else {
            // Might pop the last and set this.currentNode = undefined
            this.pop();
        }
        return this.next();
    };
    InOrder.prototype.push = function (node) {
        this.currentNode = node;
        this.i = 0;
        while (this.currentNode.left !== undefined) {
            this.stack.push(this.currentNode);
            this.currentNode = this.currentNode.left;
        }
    };
    InOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return InOrder;
}());
exports.InOrder = InOrder;
if (typeof Symbol === 'function') {
    InOrder.prototype[Symbol.iterator] = function () { return this; };
}
var PreOrder = /** @class */ (function () {
    function PreOrder(startNode) {
        this.stack = [];
        this.i = 0;
        this.currentNode = startNode;
    }
    PreOrder.prototype.next = function () {
        // Will only happen if stack is empty and pop is called,
        // which only happens if there is no right node (i.e we are done)
        if (this.currentNode === undefined) {
            return {
                done: true,
                value: undefined,
            };
        }
        // Process this node
        if (this.i < this.currentNode.records.length) {
            return {
                done: false,
                value: this.currentNode.records[this.i++],
            };
        }
        if (this.currentNode.right !== undefined) {
            this.push(this.currentNode.right);
        }
        if (this.currentNode.left !== undefined) {
            this.push(this.currentNode.left);
        }
        this.pop();
        return this.next();
    };
    PreOrder.prototype.push = function (node) {
        this.stack.push(node);
    };
    PreOrder.prototype.pop = function () {
        this.currentNode = this.stack.pop();
        this.i = 0;
    };
    return PreOrder;
}());
exports.PreOrder = PreOrder;
if (typeof Symbol === 'function') {
    PreOrder.prototype[Symbol.iterator] = function () { return this; };
}
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@truffle/decoder>@truffle/source-map-utils>node-interval-tree",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\nofilter\\lib\\index.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","stream":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\stream-browserify\\index.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\nofilter\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict'

const stream = require('stream')
const util = require('util')

/**
 * NoFilter stream.  Can be used to sink or source data to and from
 * other node streams.  Implemented as the "identity" Transform stream
 * (hence the name), but allows for inspecting data that is in-flight.
 *
 * Allows passing in source data (input, inputEncoding) at creation
 * time.  Source data can also be passed in the options object.
 *
 * @example <caption>source</caption>
 * const n = new NoFilter('Zm9v', 'base64');
 * n.pipe(process.stdout);
 *
 * @example <caption>sink</caption>
 * const n = new Nofilter();
 * // NOTE: 'finish' fires when the input is done writing
 * n.on('finish', function() { console.log(n.toString('base64')); });
 * process.stdin.pipe(n);
 */
class NoFilter extends stream.Transform {
  /**
   * Create an instance of NoFilter.
   *
   * @param {string|Buffer} [input] - Source data
   * @param {string} [inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {Object} [options={}] - Other options
   * @param {string|Buffer} [options.input=null] - Input source data
   * @param {string} [options.inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes
   *   to store in the internal buffer before ceasing to read from the
   *   underlying resource. Default=16kb, or 16 for objectMode streams
   * @param {string} [options.encoding=null] - If specified, then buffers will
   *   be decoded to strings using the specified encoding
   * @param {boolean} [options.objectMode=false] - Whether this stream should
   *   behave as a stream of objects. Meaning that stream.read(n) returns a
   *   single value instead of a Buffer of size n
   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode
   *   strings into Buffers before passing them to _write()
   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'
   *   events, setting this stream's objectMode based on the objectMode of the
   *   input stream
   * @param {boolean} [options.readError=false] - If true, when a read()
   *   underflows, throw an error.
   */
  constructor(input, inputEncoding, options) {
    if (options == null) {
      options = {}
    }
    let inp
    let inpE
    switch (typeof(input)) {
      case 'object':
        if (Buffer.isBuffer(input)) {
          inp = input
          if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
            options = inputEncoding
          }
        } else {
          options = input
        }
        break
      case 'string':
        inp = input
        if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
          options = inputEncoding
        } else {
          inpE = inputEncoding
        }
        break
    }

    if ((options == null)) {
      options = {}
    }
    if (inp == null) {
      inp = options.input
    }
    if (inpE == null) {
      inpE = options.inputEncoding
    }
    delete options.input
    delete options.inputEncoding
    const watchPipe = options.watchPipe != null ? options.watchPipe : true
    delete options.watchPipe
    const readError = !! options.readError
    delete options.readError
    super(options)

    this.readError = readError

    if (watchPipe) {
      this.on('pipe', readable => {
        const om = readable._readableState.objectMode
        if ((this.length > 0) && (om !== this._readableState.objectMode)) {
          throw new Error(
            'Do not switch objectMode in the middle of the stream')
        }

        this._readableState.objectMode = om
        return this._writableState.objectMode = om
      })
    }

    if (inp != null) {
      this.end(inp, inpE)
    }
  }

  /**
   * Is the given object a {NoFilter}?
   *
   * @param {Object} obj The object to test.
   * @returns {boolean} true if obj is a NoFilter
   */
  static isNoFilter(obj) {
    return obj instanceof this
  }

  /**
   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
   *
   * @param {NoFilter} nf1 - The first object to compare
   * @param {NoFilter} nf2 - The second object to compare
   * @returns {number} -1, 0, 1 for less, equal, greater
   *
   * @example
   * const arr = [new NoFilter('1234'), new NoFilter('0123')];
   * arr.sort(NoFilter.compare);
   */
  static compare(nf1, nf2) {
    if (!(nf1 instanceof this)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (nf1 === nf2) {
      return 0
    } else {
      return nf1.compare(nf2)
    }
  }

  /**
   * Returns a buffer which is the result of concatenating all the
   * NoFilters in the list together. If the list has no items, or if
   * the totalLength is 0, then it returns a zero-length buffer.
   *
   * If length is not provided, it is read from the buffers in the
   * list. However, this adds an additional loop to the function, so
   * it is faster to provide the length explicitly if you already know it.
   *
   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
   *   mode, or all not in object mode.
   * @param {number} [length=null] Number of bytes or objects to read
   * @returns {Buffer|Array} The concatenated values as an array if in object
   *   mode, otherwise a Buffer
   */
  static concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('list argument must be an Array of NoFilters')
    }
    if ((list.length === 0) || (length === 0)) {
      return Buffer.alloc(0)
    }
    if ((length == null)) {
      length = list.reduce((tot, nf) => {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError('list argument must be an Array of NoFilters')
        }
        return tot + nf.length
      }, 0)
    }
    let allBufs = true
    let allObjs = true
    const bufs = list.map(nf => {
      if (!(nf instanceof NoFilter)) {
        throw new TypeError('list argument must be an Array of NoFilters')
      }
      const buf = nf.slice()
      if (Buffer.isBuffer(buf)) {
        allObjs = false
      } else {
        allBufs = false
      }
      return buf
    })
    if (allBufs) {
      return Buffer.concat(bufs, length)
    }
    if (allObjs) {
      return [].concat(...bufs).slice(0, length)
    }
    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays
    // counting objects?  I can't imagine why that would be useful.
    throw new Error('Concatenating mixed object and byte streams not supported')
  }

  /**
   * @private
   */
  _transform(chunk, encoding, callback) {
    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, encoding)
    }
    this.push(chunk)
    callback()
  }

  /**
   * @private
   */
  _bufArray() {
    let bufs = this._readableState.buffer
    // HACK: replace with something else one day.  This is what I get for
    // relying on internals.
    if (!Array.isArray(bufs)) {
      let b = bufs.head
      bufs = []
      while (b != null) {
        bufs.push(b.data)
        b = b.next
      }
    }
    return bufs
  }

  /**
   * Pulls some data out of the internal buffer and returns it.
   * If there is no data available, then it will return null.
   *
   * If you pass in a size argument, then it will return that many bytes. If
   * size bytes are not available, then it will return null, unless we've
   * ended, in which case it will return the data remaining in the buffer.
   *
   * If you do not specify a size argument, then it will return all the data in
   * the internal buffer.
   *
   * @param {number} [size=null] - Number of bytes to read.
   * @returns {string|Buffer|null} If no data or not enough data, null.  If
   *   decoding output a string, otherwise a Buffer
   * @throws Error - if readError is true and there was underflow
   * @fires NoFilter#read
   */
  read(size) {
    const buf = super.read(size)
    if (buf != null) {
      /*
       * Read event. Fired whenever anything is read from the stream.
       *
       * @event NoFilter#read
       * @type {Buffer|string|Object}
       *
       */
      this.emit('read', buf)
      if (this.readError && (buf.length < size)) {
        throw new Error(`Read ${buf.length}, wanted ${size}`)
      }
    } else if (this.readError) {
      throw new Error(`No data available, wanted ${size}`)
    }
    return buf
  }

  /**
   * Return a promise fulfilled with the full contents, after the 'finish'
   * event fires.  Errors on the stream cause the promise to be rejected.
   *
   * @param {function} [cb=null] - finished/error callback used in *addition*
   *   to the promise
   * @returns {Promise<Buffer|String>} fulfilled when complete
   */
  promise(cb) {
    let done = false
    return new Promise((resolve, reject) => {
      this.on('finish', () => {
        const data = this.read()
        if ((cb != null) && !done) {
          done = true
          cb(null, data)
        }
        resolve(data)
      })
      this.on('error', (er) => {
        if ((cb != null) && !done) {
          done = true
          cb(er)
        }
        reject(er)
      })
    })
  }

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other NoFilter in sort order.
   *
   * @param {NoFilter} other - The other object to compare
   * @returns {Number} -1, 0, 1 for less, equal, greater
   */
  compare(other) {
    if (!(other instanceof NoFilter)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (this === other) {
      return 0
    } else {
      const buf1 = this.slice()
      const buf2 = other.slice()
      // these will both be buffers because of the check above.
      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
        return buf1.compare(buf2)
      }
      throw new Error('Cannot compare streams in object mode')
    }
  }

  /**
   * Do these NoFilter's contain the same bytes?  Doesn't work if either is
   * in object mode.
   *
   * @param {NoFilter} other
   * @returns {boolean} Equal?
   */
  equals(other) {
    return this.compare(other) === 0
  }

  /**
   * Read bytes or objects without consuming them.  Useful for diagnostics.
   * Note: as a side-effect, concatenates multiple writes together into what
   * looks like a single write, so that this concat doesn't have to happen
   * multiple times when you're futzing with the same NoFilter.
   *
   * @param {Number} [start=0] - beginning offset
   * @param {Number} [end=length] - ending offset
   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,
   *   concatenated array of contents.
   */
  slice(start, end) {
    if (this._readableState.objectMode) {
      return this._bufArray().slice(start, end)
    }
    const bufs = this._bufArray()
    switch (bufs.length) {
      case 0: return Buffer.alloc(0)
      case 1: return bufs[0].slice(start, end)
      default:
        const b = Buffer.concat(bufs)
        // TODO: store the concatented bufs back
        // @_readableState.buffer = [b]
        return b.slice(start, end)
    }
  }

  /**
    * Get a byte by offset.  I didn't want to get into metaprogramming
    * to give you the `NoFilter[0]` syntax.
    *
    * @param {Number} index - The byte to retrieve
    * @returns {Number} 0-255
    */
  get(index) {
    return this.slice()[index]
  }

  /**
   * Return an object compatible with Buffer's toJSON implementation, so
   * that round-tripping will produce a Buffer.
   *
   * @returns {Object}
   *
   * @example output for 'foo'
   *   { type: 'Buffer', data: [ 102, 111, 111 ] }
   */
  toJSON() {
    const b = this.slice()
    if (Buffer.isBuffer(b)) {
      return b.toJSON()
    } else {
      return b
    }
  }

  /**
   * Decodes and returns a string from buffer data encoded using the specified
   * character set encoding. If encoding is undefined or null, then encoding
   * defaults to 'utf8'. The start and end parameters default to 0 and
   * NoFilter.length when undefined.
   *
   * @param {String} [encoding='utf8'] - Which to use for decoding?
   * @param {Number} [start=0] - Start offset
   * @param {Number} [end=length] - End offset
   * @returns {String}
   */
  toString(encoding, start, end) {
    const buf = this.slice(start, end)
    if (!Buffer.isBuffer(buf)) {
      return JSON.stringify(buf)
    }
    if ((!encoding || (encoding === 'utf8')) && util.TextDecoder) {
      const td = new util.TextDecoder('utf8', {
        fatal: true,
        ignoreBOM: true
      })
      return td.decode(buf)
    }
    return buf.toString(encoding, start, end)
  }

  /**
   * @private
   * @deprecated
   */
  inspect(depth, options) {
    return this[util.inspect.custom](depth, options)
  }

  /**
   * @private
   */
  [util.inspect.custom](depth, options) {
    const bufs = this._bufArray()
    const hex = bufs.map((b) => {
      if (Buffer.isBuffer(b)) {
        if ((options != null ? options.stylize : undefined)) {
          return options.stylize(b.toString('hex'), 'string')
        } else {
          return b.toString('hex')
        }
      } else {
        return util.inspect(b, options)
      }
    }).join(', ')
    return `${this.constructor.name} [${hex}]`
  }

  /**
   * Current readable length, in bytes.
   *
   * @member {number}
   * @readonly
   */
  get length() {
    return this._readableState.length
  }

  /**
   * Write a JavaScript BigInt to the stream.  Negative numbers will be
   * written as their 2's complement version.
   *
   * @param {bigint} val - The value to write
   * @returns {boolean} true on success
   */
  writeBigInt(val) {
    let str = val.toString(16)
    if (val < 0) {
      // two's complement
      // Note: str always starts with '-' here.
      const sz = BigInt(Math.floor(str.length / 2))
      const mask = BigInt(1) << (sz * BigInt(8))
      val = mask + val
      str = val.toString(16)
    }
    if (str.length % 2) {
      str = '0' + str
    }
    return this.push(Buffer.from(str, 'hex'))
  }

  /**
   * Read a variable-sized JavaScript unsigned BigInt from the stream.
   *
   * @param {number}  [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readUBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return BigInt('0x' + b.toString('hex'))
  }

  /**
   * Read a variable-sized JavaScript signed BigInt from the stream in 2's
   * complement format.
   *
   * @param {number} [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    let ret = BigInt('0x' + b.toString('hex'))
    // negative?
    if (b[0] & 0x80) {
      // two's complement
      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))
      ret = ret - mask
    }
    return ret
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _read_gen(meth, len) {
  return function(val) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b[meth].call(b, 0, true)
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _write_gen(meth, len) {
  return function(val) {
    const b = Buffer.alloc(len)
    b[meth].call(b, val, 0, true)
    return this.push(b)
  }
}

Object.assign(NoFilter.prototype, {
  /**
   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
   *
   * @function writeUInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value - 0-255
   * @returns {boolean} true on success
   */
  writeUInt8: _write_gen('writeUInt8', 1),

  /**
   * Write a little-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16LE: _write_gen('writeUInt16LE', 2),

  /**
   * Write a big-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16BE: _write_gen('writeUInt16BE', 2),

  /**
   * Write a little-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32LE: _write_gen('writeUInt32LE', 4),

  /**
   * Write a big-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32BE: _write_gen('writeUInt32BE', 4),

  /**
   * Write a signed 8-bit integer to the stream.  Adds 1 byte.
   *
   * @function writeInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt8: _write_gen('writeInt8', 1),

  /**
   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16LE: _write_gen('writeInt16LE', 2),

  /**
   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16BE: _write_gen('writeInt16BE', 2),

  /**
   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32LE: _write_gen('writeInt32LE', 4),

  /**
   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32BE: _write_gen('writeInt32BE', 4),

  /**
   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatLE: _write_gen('writeFloatLE', 4),

  /**
   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatBE: _write_gen('writeFloatBE', 4),

  /**
   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleLE: _write_gen('writeDoubleLE', 8),

  /**
   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleBE: _write_gen('writeDoubleBE', 8),

  /**
   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @function readUInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt8: _read_gen('readUInt8', 1),

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16LE: _read_gen('readUInt16LE', 2),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16BE: _read_gen('readUInt16BE', 2),

  /**
   * Read a little-endian unsigned 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32LE: _read_gen('readUInt32LE', 4),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32BE: _read_gen('readUInt32BE', 4),

  /**
   * Read a signed 8-bit integer from the stream.
   * Consumes 1 byte.
   *
   * @function readInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt8: _read_gen('readInt8', 1),

  /**
   * Read a signed 16-bit little-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16LE: _read_gen('readInt16LE', 2),

  /**
   * Read a signed 16-bit big-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16BE: _read_gen('readInt16BE', 2),

  /**
   * Read a signed 32-bit little-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32LE: _read_gen('readInt32LE', 4),

  /**
   * Read a signed 32-bit big-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32BE: _read_gen('readInt32BE', 4),

  /**
   * Read a 32-bit little-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatLE: _read_gen('readFloatLE', 4),

  /**
   * Read a 32-bit big-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatBE: _read_gen('readFloatBE', 4),

  /**
   * Read a 64-bit little-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleLE: _read_gen('readDoubleLE', 8),

  /**
   * Read a 64-bit big-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleBE: _read_gen('readDoubleBE', 8)
})

module.exports = NoFilter

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@truffle/codec>cbor>nofilter",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\implementation.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\object-is\implementation.js
      return function (require, module, exports) {
'use strict';

var numberIsNaN = function (value) {
	return value !== value;
};

module.exports = function is(a, b) {
	if (a === 0 && b === 0) {
		return 1 / a === 1 / b;
	}
	if (a === b) {
		return true;
	}
	if (numberIsNaN(a) && numberIsNaN(b)) {
		return true;
	}
	return false;
};


      };
    };
  }
}, {package:"enzyme>object-is",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\index.js", {"./implementation":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\implementation.js","./polyfill":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\polyfill.js","./shim":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\shim.js","call-bind":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\call-bind\\index.js","define-properties":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\define-properties\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\object-is\index.js
      return function (require, module, exports) {
'use strict';

var define = require('define-properties');
var callBind = require('call-bind');

var implementation = require('./implementation');
var getPolyfill = require('./polyfill');
var shim = require('./shim');

var polyfill = callBind(getPolyfill(), Object);

define(polyfill, {
	getPolyfill: getPolyfill,
	implementation: implementation,
	shim: shim
});

module.exports = polyfill;

      };
    };
  }
}, {package:"enzyme>object-is",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\polyfill.js", {"./implementation":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\implementation.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\object-is\polyfill.js
      return function (require, module, exports) {
'use strict';

var implementation = require('./implementation');

module.exports = function getPolyfill() {
	return typeof Object.is === 'function' ? Object.is : implementation;
};

      };
    };
  }
}, {package:"enzyme>object-is",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\shim.js", {"./polyfill":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-is\\polyfill.js","define-properties":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\define-properties\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\object-is\shim.js
      return function (require, module, exports) {
'use strict';

var getPolyfill = require('./polyfill');
var define = require('define-properties');

module.exports = function shimObjectIs() {
	var polyfill = getPolyfill();
	define(Object, { is: polyfill }, {
		is: function testObjectIs() {
			return Object.is !== polyfill;
		}
	});
	return polyfill;
};

      };
    };
  }
}, {package:"enzyme>object-is",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-keys\\implementation.js", {"./isArguments":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-keys\\isArguments.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\object-keys\implementation.js
      return function (require, module, exports) {
'use strict';

var keysShim;
if (!Object.keys) {
	// modified from https://github.com/es-shims/es5-shim
	var has = Object.prototype.hasOwnProperty;
	var toStr = Object.prototype.toString;
	var isArgs = require('./isArguments'); // eslint-disable-line global-require
	var isEnumerable = Object.prototype.propertyIsEnumerable;
	var hasDontEnumBug = !isEnumerable.call({ toString: null }, 'toString');
	var hasProtoEnumBug = isEnumerable.call(function () {}, 'prototype');
	var dontEnums = [
		'toString',
		'toLocaleString',
		'valueOf',
		'hasOwnProperty',
		'isPrototypeOf',
		'propertyIsEnumerable',
		'constructor'
	];
	var equalsConstructorPrototype = function (o) {
		var ctor = o.constructor;
		return ctor && ctor.prototype === o;
	};
	var excludedKeys = {
		$applicationCache: true,
		$console: true,
		$external: true,
		$frame: true,
		$frameElement: true,
		$frames: true,
		$innerHeight: true,
		$innerWidth: true,
		$onmozfullscreenchange: true,
		$onmozfullscreenerror: true,
		$outerHeight: true,
		$outerWidth: true,
		$pageXOffset: true,
		$pageYOffset: true,
		$parent: true,
		$scrollLeft: true,
		$scrollTop: true,
		$scrollX: true,
		$scrollY: true,
		$self: true,
		$webkitIndexedDB: true,
		$webkitStorageInfo: true,
		$window: true
	};
	var hasAutomationEqualityBug = (function () {
		/* global window */
		if (typeof window === 'undefined') { return false; }
		for (var k in window) {
			try {
				if (!excludedKeys['$' + k] && has.call(window, k) && window[k] !== null && typeof window[k] === 'object') {
					try {
						equalsConstructorPrototype(window[k]);
					} catch (e) {
						return true;
					}
				}
			} catch (e) {
				return true;
			}
		}
		return false;
	}());
	var equalsConstructorPrototypeIfNotBuggy = function (o) {
		/* global window */
		if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
			return equalsConstructorPrototype(o);
		}
		try {
			return equalsConstructorPrototype(o);
		} catch (e) {
			return false;
		}
	};

	keysShim = function keys(object) {
		var isObject = object !== null && typeof object === 'object';
		var isFunction = toStr.call(object) === '[object Function]';
		var isArguments = isArgs(object);
		var isString = isObject && toStr.call(object) === '[object String]';
		var theKeys = [];

		if (!isObject && !isFunction && !isArguments) {
			throw new TypeError('Object.keys called on a non-object');
		}

		var skipProto = hasProtoEnumBug && isFunction;
		if (isString && object.length > 0 && !has.call(object, 0)) {
			for (var i = 0; i < object.length; ++i) {
				theKeys.push(String(i));
			}
		}

		if (isArguments && object.length > 0) {
			for (var j = 0; j < object.length; ++j) {
				theKeys.push(String(j));
			}
		} else {
			for (var name in object) {
				if (!(skipProto && name === 'prototype') && has.call(object, name)) {
					theKeys.push(String(name));
				}
			}
		}

		if (hasDontEnumBug) {
			var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);

			for (var k = 0; k < dontEnums.length; ++k) {
				if (!(skipConstructor && dontEnums[k] === 'constructor') && has.call(object, dontEnums[k])) {
					theKeys.push(dontEnums[k]);
				}
			}
		}
		return theKeys;
	};
}
module.exports = keysShim;

      };
    };
  }
}, {package:"mocha>object.assign>object-keys",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-keys\\index.js", {"./implementation":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-keys\\implementation.js","./isArguments":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-keys\\isArguments.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\object-keys\index.js
      return function (require, module, exports) {
'use strict';

var slice = Array.prototype.slice;
var isArgs = require('./isArguments');

var origKeys = Object.keys;
var keysShim = origKeys ? function keys(o) { return origKeys(o); } : require('./implementation');

var originalKeys = Object.keys;

keysShim.shim = function shimObjectKeys() {
	if (Object.keys) {
		var keysWorksWithArguments = (function () {
			// Safari 5.0 bug
			var args = Object.keys(arguments);
			return args && args.length === arguments.length;
		}(1, 2));
		if (!keysWorksWithArguments) {
			Object.keys = function keys(object) { // eslint-disable-line func-name-matching
				if (isArgs(object)) {
					return originalKeys(slice.call(object));
				}
				return originalKeys(object);
			};
		}
	} else {
		Object.keys = keysShim;
	}
	return Object.keys || keysShim;
};

module.exports = keysShim;

      };
    };
  }
}, {package:"mocha>object.assign>object-keys",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-keys\\isArguments.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\object-keys\isArguments.js
      return function (require, module, exports) {
'use strict';

var toStr = Object.prototype.toString;

module.exports = function isArguments(value) {
	var str = toStr.call(value);
	var isArgs = str === '[object Arguments]';
	if (!isArgs) {
		isArgs = str !== '[object Array]' &&
			value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			toStr.call(value.callee) === '[object Function]';
	}
	return isArgs;
};

      };
    };
  }
}, {package:"mocha>object.assign>object-keys",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\param-case\\param-case.js", {"no-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\no-case.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\param-case\param-case.js
      return function (require, module, exports) {
var noCase = require('no-case')

/**
 * Param case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-')
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>param-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pascal-case\\pascal-case.js", {"camel-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\camel-case\\camel-case.js","upper-case-first":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\upper-case-first\\upper-case-first.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pascal-case\pascal-case.js
      return function (require, module, exports) {
var camelCase = require('camel-case')
var upperCaseFirst = require('upper-case-first')

/**
 * Pascal case a string.
 *
 * @param  {string}  value
 * @param  {string}  [locale]
 * @param  {boolean} [mergeNumbers]
 * @return {string}
 */
module.exports = function (value, locale, mergeNumbers) {
  return upperCaseFirst(camelCase(value, locale, mergeNumbers), locale)
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>pascal-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\path-browserify\\index.js", {"_process":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\process\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\path-browserify\index.js
      return function (require, module, exports) {
(function (process){(function (){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this)}).call(this,require('_process'))

      };
    };
  }
}, {package:"browserify>path-browserify",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\path-case\\path-case.js", {"no-case":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\no-case\\no-case.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\path-case\path-case.js
      return function (require, module, exports) {
var noCase = require('no-case')

/**
 * Path case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '/')
}

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>change-case>path-case",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\path-to-regexp\\index.js", {"isarray":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\path-to-regexp\\node_modules\\isarray\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\path-to-regexp\index.js
      return function (require, module, exports) {
var isarray = require('isarray')

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp
module.exports.parse = parse
module.exports.compile = compile
module.exports.tokensToFunction = tokensToFunction
module.exports.tokensToRegExp = tokensToRegExp

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g')

/**
 * Parse a string for the raw tokens.
 *
 * @param  {string}  str
 * @param  {Object=} options
 * @return {!Array}
 */
function parse (str, options) {
  var tokens = []
  var key = 0
  var index = 0
  var path = ''
  var defaultDelimiter = options && options.delimiter || '/'
  var res

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0]
    var escaped = res[1]
    var offset = res.index
    path += str.slice(index, offset)
    index = offset + m.length

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1]
      continue
    }

    var next = str[index]
    var prefix = res[2]
    var name = res[3]
    var capture = res[4]
    var group = res[5]
    var modifier = res[6]
    var asterisk = res[7]

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path)
      path = ''
    }

    var partial = prefix != null && next != null && next !== prefix
    var repeat = modifier === '+' || modifier === '*'
    var optional = modifier === '?' || modifier === '*'
    var delimiter = res[2] || defaultDelimiter
    var pattern = capture || group

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      partial: partial,
      asterisk: !!asterisk,
      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')
    })
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index)
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path)
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {string}             str
 * @param  {Object=}            options
 * @return {!function(Object=, Object=)}
 */
function compile (str, options) {
  return tokensToFunction(parse(str, options))
}

/**
 * Prettier encoding of URI path segments.
 *
 * @param  {string}
 * @return {string}
 */
function encodeURIComponentPretty (str) {
  return encodeURI(str).replace(/[\/?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.
 *
 * @param  {string}
 * @return {string}
 */
function encodeAsterisk (str) {
  return encodeURI(str).replace(/[?#]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length)

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')
    }
  }

  return function (obj, opts) {
    var path = ''
    var data = obj || {}
    var options = opts || {}
    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i]

      if (typeof token === 'string') {
        path += token

        continue
      }

      var value = data[token.name]
      var segment

      if (value == null) {
        if (token.optional) {
          // Prepend partial segment prefixes.
          if (token.partial) {
            path += token.prefix
          }

          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received `' + JSON.stringify(value) + '`')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encode(value[j])

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received `' + JSON.stringify(segment) + '`')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment
        }

        continue
      }

      segment = token.asterisk ? encodeAsterisk(value) : encode(value)

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {string} str
 * @return {string}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/\\])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {string} group
 * @return {string}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {!RegExp} re
 * @param  {Array}   keys
 * @return {!RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {string}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {!RegExp} path
 * @param  {!Array}  keys
 * @return {!RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g)

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        partial: false,
        asterisk: false,
        pattern: null
      })
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {!Array}  path
 * @param  {Array}   keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = []

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source)
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {string}  path
 * @param  {!Array}  keys
 * @param  {!Object} options
 * @return {!RegExp}
 */
function stringToRegexp (path, keys, options) {
  return tokensToRegExp(parse(path, options), keys, options)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {!Array}          tokens
 * @param  {(Array|Object)=} keys
 * @param  {Object=}         options
 * @return {!RegExp}
 */
function tokensToRegExp (tokens, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  var strict = options.strict
  var end = options.end !== false
  var route = ''

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i]

    if (typeof token === 'string') {
      route += escapeString(token)
    } else {
      var prefix = escapeString(token.prefix)
      var capture = '(?:' + token.pattern + ')'

      keys.push(token)

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*'
      }

      if (token.optional) {
        if (!token.partial) {
          capture = '(?:' + prefix + '(' + capture + '))?'
        } else {
          capture = prefix + '(' + capture + ')?'
        }
      } else {
        capture = prefix + '(' + capture + ')'
      }

      route += capture
    }
  }

  var delimiter = escapeString(options.delimiter || '/')
  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'
  }

  if (end) {
    route += '$'
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys)
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(string|RegExp|Array)} path
 * @param  {(Array|Object)=}       keys
 * @param  {Object=}               options
 * @return {!RegExp}
 */
function pathToRegexp (path, keys, options) {
  if (!isarray(keys)) {
    options = /** @type {!Object} */ (keys || options)
    keys = []
  }

  options = options || {}

  if (path instanceof RegExp) {
    return regexpToRegexp(path, /** @type {!Array} */ (keys))
  }

  if (isarray(path)) {
    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)
  }

  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)
}

      };
    };
  }
}, {package:"sinon>nise>path-to-regexp",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\path-to-regexp\\node_modules\\isarray\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\path-to-regexp\node_modules\isarray\index.js
      return function (require, module, exports) {
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

      };
    };
  }
}, {package:"sinon>nise>path-to-regexp>isarray",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\popper.js\\dist\\umd\\popper.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\popper.js\dist\umd\popper.js
      return function (require, module, exports) {
/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1-lts
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.Popper = factory());
}(this, (function () { 'use strict';

var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }
  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }
    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;

/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/
var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */
function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}

/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */
function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  }
  // NOTE: 1 DOM access here
  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}

/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */
function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }
  return element.parentNode || element.host;
}

/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */
function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;
    case '#document':
      return element.body;
  }

  // Firefox want us to check `-x` and `-y` variations as well

  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}

/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */
function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);

/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */
function isIE(version) {
  if (version === 11) {
    return isIE11;
  }
  if (version === 10) {
    return isIE10;
  }
  return isIE11 || isIE10;
}

/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */
function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null;

  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent || null;
  // Skip hidden elements which don't have an offsetParent
  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  }

  // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...
  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }
  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}

/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */
function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}

/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */
function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  }

  // Here we make sure to give as "start" the element that comes first in the DOM
  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1;

  // Get common ancestor container
  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer;

  // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  }

  // one of the nodes is inside shadowDOM, find which one
  var element1root = getRoot(element1);
  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}

/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */
function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}

/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */
function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}

/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */

function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);

  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();





var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */
function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}

/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */
function getBoundingClientRect(element) {
  var rect = {};

  // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11
  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };

  // subtract scrollbar size from sizes
  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;

  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height;

  // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons
  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');

    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);

  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth);

  // In cases where the parent is fixed, we must ignore negative scroll in offset calc
  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }
  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0;

  // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.
  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);

    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft;

    // Attach marginTop and marginLeft because in some circumstances we may need them
    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);

  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;

  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };

  return getClientRect(offset);
}

/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */
function isFixed(element) {
  var nodeName = element.nodeName;
  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }
  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }
  var parentNode = getParentNode(element);
  if (!parentNode) {
    return false;
  }
  return isFixed(parentNode);
}

/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */

function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }
  var el = element.parentElement;
  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }
  return el || document.documentElement;
}

/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */
function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  // NOTE: 1 DOM access here

  var boundaries = { top: 0, left: 0 };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));

  // Handle viewport case
  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;
    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));
      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);

    // In case of HTML, we need a different computation
    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  }

  // Add paddings
  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;

  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;

  return width * height;
}

/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };

  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });

  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });

  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

  var variation = placement.split('-')[1];

  return computedPlacement + (variation ? '-' + variation : '');
}

/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */
function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */
function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}

/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */
function getOppositePlacement(placement) {
  var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}

/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */
function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0];

  // Get popper node sizes
  var popperRect = getOuterSizes(popper);

  // Add position, width and height to our offsets object
  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  };

  // depending by the popper placement we have to compute its offsets slightly differently
  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';

  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}

/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  }

  // use `filter` to obtain the same behavior of `find`
  return arr.filter(check)[0];
}

/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */
function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  }

  // use `find` + `indexOf` if `findIndex` isn't supported
  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}

/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */
function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));

  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }
    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);

      data = fn(data, modifier);
    }
  });

  return data;
}

/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */
function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  };

  // compute reference element offsets
  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

  // store the computed placement inside `originalPlacement`
  data.originalPlacement = data.placement;

  data.positionFixed = this.options.positionFixed;

  // compute the popper offsets
  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);

  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';

  // run the modifiers
  data = runModifiers(this.modifiers, data);

  // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback
  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}

/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */
function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}

/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */
function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;
    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }
  return null;
}

/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */
function destroy() {
  this.state.isDestroyed = true;

  // touch DOM only if `applyStyle` modifier is enabled
  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners();

  // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it
  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }
  return this;
}

/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */
function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, { passive: true });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }
  scrollParents.push(target);
}

/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

  // Scroll event listener on scroll parents
  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;

  return state;
}

/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */
function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}

/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */
function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound);

  // Remove scroll event listener on scroll parents
  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  });

  // Reset state
  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}

/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */
function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}

/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */
function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}

/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = '';
    // add unit if the value is numeric and is one of the following
    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }
    element.style[prop] = styles[prop] + unit;
  });
}

/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */
function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];
    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */
function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles);

  // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element
  setAttributes(data.instance.popper, data.attributes);

  // if arrowElement is defined and arrowStyles has some properties
  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}

/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */
function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);

  // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value
  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

  popper.setAttribute('x-placement', placement);

  // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations
  setStyles(popper, { position: options.positionFixed ? 'fixed' : 'absolute' });

  return options;
}

/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */
function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);

  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;

  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;

  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper;

  // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;
  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }
  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent);

  // Styles
  var styles = {
    position: popper.position
  };

  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);

  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right';

  // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed
  var prefixedProperty = getSupportedPropertyName('transform');

  // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.
  var left = void 0,
      top = void 0;
  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }
  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }
  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  }

  // Attributes
  var attributes = {
    'x-placement': data.placement
  };

  // Update `data` attributes, styles and arrowStyles
  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

  return data;
}

/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */
function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });

  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';
    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }
  return isRequired;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function arrow(data, options) {
  var _data$offsets$arrow;

  // arrow depends on keepTogether in order to work
  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element;

  // if arrowElement is a string, suppose it's a CSS selector
  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement);

    // if arrowElement is not found, don't run the modifier
    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isVertical = ['left', 'right'].indexOf(placement) !== -1;

  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len];

  //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //

  // top/left side
  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  }
  // bottom/right side
  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }
  data.offsets.popper = getClientRect(data.offsets.popper);

  // compute center of the popper
  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

  // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available
  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

  // prevent arrowElement from being placed not contiguously to its popper
  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

  return data;
}

/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */
function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }
  return variation;
}

/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */
var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

// Get rid of `auto` `auto-start` and `auto-end`
var validPlacements = placements.slice(3);

/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */
function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';

  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;
    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;
    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;
    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);

    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference;

    // using floor because the reference offsets may contain decimals we are not going to consider here
    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

    // flip the variation if required
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;

    // flips variation if reference element overflows boundaries
    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

    // flips variation if popper content overflows boundaries
    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);

    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : '');

      // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future
      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }
  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}

/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */
function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2];

  // If it's not a number it's an operator, I guess
  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;
    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;
      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;
    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }
    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}

/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */
function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0];

  // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one
  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

  // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  });

  // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space
  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  }

  // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.
  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

  // Convert the values with units to absolute pixels to allow our computations
  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op
    // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, [])
    // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  });

  // Loop trough the offsets arrays and execute the operations
  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */
function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var basePlacement = placement.split('-')[0];

  var offsets = void 0;
  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

  // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken
  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  }

  // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself
  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification
  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];

  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);

  // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed
  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;

  options.boundaries = boundaries;

  var order = options.priority;
  var popper = data.offsets.popper;

  var check = {
    primary: function primary(placement) {
      var value = popper[placement];
      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }
      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];
      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }
      return defineProperty({}, mainSide, value);
    }
  };

  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });

  data.offsets.popper = popper;

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1];

  // if shift shiftvariation is specified, run the modifier
  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;

    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };

    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}

/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */
function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;

  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);

  return data;
}

/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */
var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: offset,
    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries"  or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: preventOverflow,
    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],
    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: arrow,
    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: flip,
    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',
    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,
    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',
    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,
    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,
    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,
    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: computeStyle,
    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,
    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',
    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,
    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,
    /** @prop {ModifierFn} */
    fn: applyStyle,
    /** @prop {Function} */
    onLoad: applyStyleOnLoad,
    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};

/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */
var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};

/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */

// Utils
// Methods
var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    };

    // make update() debounced, so that it only runs at most once-per-tick
    this.update = debounce(this.update.bind(this));

    // with {} we create a new object with the options inside it
    this.options = _extends({}, Popper.Defaults, options);

    // init state
    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    };

    // get reference and popper elements (allow jQuery wrappers)
    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper;

    // Deep merge modifiers options
    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    });

    // Refactoring modifiers' list (Object => Array)
    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    })
    // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    });

    // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    });

    // fire the first update to position the popper in the right place
    this.update();

    var eventsEnabled = this.options.eventsEnabled;
    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  }

  // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }

    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */


    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();

/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;

return Popper;

})));
//# sourceMappingURL=popper.js.map

      };
    };
  }
}, {package:"@material-ui/core>popper.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\factoryWithThrowingShims.js", {"./lib/ReactPropTypesSecret":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\prop-types\factoryWithThrowingShims.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

      };
    };
  }
}, {package:"prop-types",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\factoryWithTypeCheckers.js", {"./checkPropTypes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\checkPropTypes.js","./lib/ReactPropTypesSecret":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\lib\\ReactPropTypesSecret.js","./lib/has":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\lib\\has.js","object-assign":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\object-assign\\index.js","react-is":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-is\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\prop-types\factoryWithTypeCheckers.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactIs = require('react-is');
var assign = require('object-assign');

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var has = require('./lib/has');
var checkPropTypes = require('./checkPropTypes');

var printWarning = function() {};

if ("development" !== 'production') {
  printWarning = function(text) {
    var message = 'Warning: ' + text;
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };
}

function emptyFunctionThatReturnsNull() {
  return null;
}

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bigint: createPrimitiveTypeChecker('bigint'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    elementType: createElementTypeTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message, data) {
    this.message = message;
    this.data = data && typeof data === 'object' ? data: {};
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if ("development" !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          var err = new Error(
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
          err.name = 'Invariant Violation';
          throw err;
        } else if ("development" !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            printWarning(
              'You are manually calling a React.PropTypes validation ' +
              'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.'
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError(
          'Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'),
          {expectedType: expectedType}
        );
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunctionThatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!ReactIs.isValidElementType(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      if ("development" !== 'production') {
        if (arguments.length > 1) {
          printWarning(
            'Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' +
            'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).'
          );
        } else {
          printWarning('Invalid argument supplied to oneOf, expected an array.');
        }
      }
      return emptyFunctionThatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
        var type = getPreciseType(value);
        if (type === 'symbol') {
          return String(value);
        }
        return value;
      });
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (has(propValue, key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      "development" !== 'production' ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunctionThatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        printWarning(
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.'
        );
        return emptyFunctionThatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      var expectedTypes = [];
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
        if (checkerResult == null) {
          return null;
        }
        if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
          expectedTypes.push(checkerResult.data.expectedType);
        }
      }
      var expectedTypesMessage = (expectedTypes.length > 0) ? ', expected one of type [' + expectedTypes.join(', ') + ']': '';
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function invalidValidatorError(componentName, location, propFullName, key, type) {
    return new PropTypeError(
      (componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' +
      'it must be a function, usually from the `prop-types` package, but received `' + type + '`.'
    );
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (has(shapeTypes, key) && typeof checker !== 'function') {
          return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
        }
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // falsy value can't be a Symbol
    if (!propValue) {
      return false;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

      };
    };
  }
}, {package:"prop-types",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\index.js", {"./factoryWithThrowingShims":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\factoryWithThrowingShims.js","./factoryWithTypeCheckers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\factoryWithTypeCheckers.js","react-is":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-is\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\prop-types\index.js
      return function (require, module, exports) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if ("development" !== 'production') {
  var ReactIs = require('react-is');

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

      };
    };
  }
}, {package:"prop-types",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pubnub\\dist\\web\\pubnub.min.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pubnub\dist\web\pubnub.min.js
      return function (require, module, exports) {
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.PubNub=t():e.PubNub=t()}(window,function(){return r={},i.m=n=[function(e,t,n){"use strict";e.exports={}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default={PNTimeOperation:"PNTimeOperation",PNHistoryOperation:"PNHistoryOperation",PNDeleteMessagesOperation:"PNDeleteMessagesOperation",PNFetchMessagesOperation:"PNFetchMessagesOperation",PNMessageCounts:"PNMessageCountsOperation",PNSubscribeOperation:"PNSubscribeOperation",PNUnsubscribeOperation:"PNUnsubscribeOperation",PNPublishOperation:"PNPublishOperation",PNSignalOperation:"PNSignalOperation",PNAddMessageActionOperation:"PNAddActionOperation",PNRemoveMessageActionOperation:"PNRemoveMessageActionOperation",PNGetMessageActionsOperation:"PNGetMessageActionsOperation",PNCreateUserOperation:"PNCreateUserOperation",PNUpdateUserOperation:"PNUpdateUserOperation",PNDeleteUserOperation:"PNDeleteUserOperation",PNGetUserOperation:"PNGetUsersOperation",PNGetUsersOperation:"PNGetUsersOperation",PNCreateSpaceOperation:"PNCreateSpaceOperation",PNUpdateSpaceOperation:"PNUpdateSpaceOperation",PNDeleteSpaceOperation:"PNDeleteSpaceOperation",PNGetSpaceOperation:"PNGetSpacesOperation",PNGetSpacesOperation:"PNGetSpacesOperation",PNGetMembersOperation:"PNGetMembersOperation",PNUpdateMembersOperation:"PNUpdateMembersOperation",PNGetMembershipsOperation:"PNGetMembershipsOperation",PNUpdateMembershipsOperation:"PNUpdateMembershipsOperation",PNPushNotificationEnabledChannelsOperation:"PNPushNotificationEnabledChannelsOperation",PNRemoveAllPushNotificationsOperation:"PNRemoveAllPushNotificationsOperation",PNWhereNowOperation:"PNWhereNowOperation",PNSetStateOperation:"PNSetStateOperation",PNHereNowOperation:"PNHereNowOperation",PNGetStateOperation:"PNGetStateOperation",PNHeartbeatOperation:"PNHeartbeatOperation",PNChannelGroupsOperation:"PNChannelGroupsOperation",PNRemoveGroupOperation:"PNRemoveGroupOperation",PNChannelsForGroupOperation:"PNChannelsForGroupOperation",PNAddChannelsToGroupOperation:"PNAddChannelsToGroupOperation",PNRemoveChannelsFromGroupOperation:"PNRemoveChannelsFromGroupOperation",PNAccessManagerGrant:"PNAccessManagerGrant",PNAccessManagerGrantToken:"PNAccessManagerGrantToken",PNAccessManagerAudit:"PNAccessManagerAudit"},e.exports=t.default},function(e,t,n){"use strict";function r(e){return encodeURIComponent(e).replace(/[!~*'()]/g,function(e){return"%".concat(e.charCodeAt(0).toString(16).toUpperCase())})}function i(e){return function(e){var t=[];return Object.keys(e).forEach(function(e){return t.push(e)}),t}(e).sort()}e.exports={signPamFromParams:function(t){return i(t).map(function(e){return"".concat(e,"=").concat(r(t[e]))}).join("&")},endsWith:function(e,t){return-1!==e.indexOf(t,this.length-t.length)},createPromise:function(){var n,r;return{promise:new Promise(function(e,t){n=e,r=t}),reject:r,fulfill:n}},encodeString:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r,i=(r=n(5))&&r.__esModule?r:{default:r};n(0);function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,c,f=(a=l,(u=[{key:"getAuthKey",value:function(){return this.authKey}},{key:"setAuthKey",value:function(e){return this.authKey=e,this}},{key:"setCipherKey",value:function(e){return this.cipherKey=e,this}},{key:"getUUID",value:function(){return this.UUID}},{key:"setUUID",value:function(e){return this._db&&this._db.set&&this._db.set("".concat(this.subscribeKey,"uuid"),e),this.UUID=e,this}},{key:"getFilterExpression",value:function(){return this.filterExpression}},{key:"setFilterExpression",value:function(e){return this.filterExpression=e,this}},{key:"getPresenceTimeout",value:function(){return this._presenceTimeout}},{key:"setPresenceTimeout",value:function(e){return 20<=e?this._presenceTimeout=e:(this._presenceTimeout=20,console.log("WARNING: Presence timeout is less than the minimum. Using minimum value: ",this._presenceTimeout)),this.setHeartbeatInterval(this._presenceTimeout/2-1),this}},{key:"setProxy",value:function(e){this.proxy=e}},{key:"getHeartbeatInterval",value:function(){return this._heartbeatInterval}},{key:"setHeartbeatInterval",value:function(e){return this._heartbeatInterval=e,this}},{key:"getSubscribeTimeout",value:function(){return this._subscribeRequestTimeout}},{key:"setSubscribeTimeout",value:function(e){return this._subscribeRequestTimeout=e,this}},{key:"getTransactionTimeout",value:function(){return this._transactionalRequestTimeout}},{key:"setTransactionTimeout",value:function(e){return this._transactionalRequestTimeout=e,this}},{key:"isSendBeaconEnabled",value:function(){return this._useSendBeacon}},{key:"setSendBeaconConfig",value:function(e){return this._useSendBeacon=e,this}},{key:"getVersion",value:function(){return"4.27.3"}},{key:"_addPnsdkSuffix",value:function(e,t){this._PNSDKSuffix[e]=t}},{key:"_getPnsdkSuffix",value:function(n){var r=this;return Object.keys(this._PNSDKSuffix).reduce(function(e,t){return e+n+r._PNSDKSuffix[t]},"")}},{key:"_decideUUID",value:function(e){return e||(this._db&&this._db.get&&this._db.get("".concat(this.subscribeKey,"uuid"))?this._db.get("".concat(this.subscribeKey,"uuid")):"pn-".concat(i.default.createUUID()))}}])&&o(a.prototype,u),void(c&&o(a,c)),l);function l(e){var t=e.setup,n=e.db;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_db",void 0),s(this,"subscribeKey",void 0),s(this,"publishKey",void 0),s(this,"secretKey",void 0),s(this,"cipherKey",void 0),s(this,"authKey",void 0),s(this,"UUID",void 0),s(this,"proxy",void 0),s(this,"instanceId",void 0),s(this,"sdkName",void 0),s(this,"sdkFamily",void 0),s(this,"partnerId",void 0),s(this,"filterExpression",void 0),s(this,"suppressLeaveEvents",void 0),s(this,"secure",void 0),s(this,"origin",void 0),s(this,"logVerbosity",void 0),s(this,"useInstanceId",void 0),s(this,"useRequestId",void 0),s(this,"keepAlive",void 0),s(this,"keepAliveSettings",void 0),s(this,"autoNetworkDetection",void 0),s(this,"announceSuccessfulHeartbeats",void 0),s(this,"announceFailedHeartbeats",void 0),s(this,"_presenceTimeout",void 0),s(this,"_heartbeatInterval",void 0),s(this,"_subscribeRequestTimeout",void 0),s(this,"_transactionalRequestTimeout",void 0),s(this,"_useSendBeacon",void 0),s(this,"_PNSDKSuffix",void 0),s(this,"requestMessageCountThreshold",void 0),s(this,"restore",void 0),s(this,"dedupeOnSubscribe",void 0),s(this,"maximumCacheSize",void 0),s(this,"customEncrypt",void 0),s(this,"customDecrypt",void 0),this._PNSDKSuffix={},this._db=n,this.instanceId="pn-".concat(i.default.createUUID()),this.secretKey=t.secretKey||t.secret_key,this.subscribeKey=t.subscribeKey||t.subscribe_key,this.publishKey=t.publishKey||t.publish_key,this.sdkName=t.sdkName,this.sdkFamily=t.sdkFamily,this.partnerId=t.partnerId,this.setAuthKey(t.authKey),this.setCipherKey(t.cipherKey),this.setFilterExpression(t.filterExpression),this.origin=t.origin||"ps.pndsn.com",this.secure=t.ssl||!1,this.restore=t.restore||!1,this.proxy=t.proxy,this.keepAlive=t.keepAlive,this.keepAliveSettings=t.keepAliveSettings,this.autoNetworkDetection=t.autoNetworkDetection||!1,this.dedupeOnSubscribe=t.dedupeOnSubscribe||!1,this.maximumCacheSize=t.maximumCacheSize||100,this.customEncrypt=t.customEncrypt,this.customDecrypt=t.customDecrypt,"undefined"!=typeof location&&"https:"===location.protocol&&(this.secure=!0),this.logVerbosity=t.logVerbosity||!1,this.suppressLeaveEvents=t.suppressLeaveEvents||!1,this.announceFailedHeartbeats=t.announceFailedHeartbeats||!0,this.announceSuccessfulHeartbeats=t.announceSuccessfulHeartbeats||!1,this.useInstanceId=t.useInstanceId||!1,this.useRequestId=t.useRequestId||!1,this.requestMessageCountThreshold=t.requestMessageCountThreshold,this.setTransactionTimeout(t.transactionalRequestTimeout||15e3),this.setSubscribeTimeout(t.subscribeRequestTimeout||31e4),this.setSendBeaconConfig(t.useSendBeacon||!0),t.presenceTimeout?this.setPresenceTimeout(t.presenceTimeout):this._presenceTimeout=300,null!=t.heartbeatInterval&&this.setHeartbeatInterval(t.heartbeatInterval),this.setUUID(this._decideUUID(t.uuid))}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default={PNNetworkUpCategory:"PNNetworkUpCategory",PNNetworkDownCategory:"PNNetworkDownCategory",PNNetworkIssuesCategory:"PNNetworkIssuesCategory",PNTimeoutCategory:"PNTimeoutCategory",PNBadRequestCategory:"PNBadRequestCategory",PNAccessDeniedCategory:"PNAccessDeniedCategory",PNUnknownCategory:"PNUnknownCategory",PNReconnectedCategory:"PNReconnectedCategory",PNConnectedCategory:"PNConnectedCategory",PNRequestMessageCountExceededCategory:"PNRequestMessageCountExceededCategory"},e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r,i=(r=n(13))&&r.__esModule?r:{default:r};var o={createUUID:function(){return i.default.uuid?i.default.uuid():(0,i.default)()}};t.default=o,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;r(n(3));var u=r(n(14));function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,c,f=(s=l,(a=[{key:"HMACSHA256",value:function(e){return u.default.HmacSHA256(e,this._config.secretKey).toString(u.default.enc.Base64)}},{key:"SHA256",value:function(e){return u.default.SHA256(e).toString(u.default.enc.Hex)}},{key:"_parseOptions",value:function(e){var t=e||{};return t.hasOwnProperty("encryptKey")||(t.encryptKey=this._defaultOptions.encryptKey),t.hasOwnProperty("keyEncoding")||(t.keyEncoding=this._defaultOptions.keyEncoding),t.hasOwnProperty("keyLength")||(t.keyLength=this._defaultOptions.keyLength),t.hasOwnProperty("mode")||(t.mode=this._defaultOptions.mode),-1===this._allowedKeyEncodings.indexOf(t.keyEncoding.toLowerCase())&&(t.keyEncoding=this._defaultOptions.keyEncoding),-1===this._allowedKeyLengths.indexOf(parseInt(t.keyLength,10))&&(t.keyLength=this._defaultOptions.keyLength),-1===this._allowedModes.indexOf(t.mode.toLowerCase())&&(t.mode=this._defaultOptions.mode),t}},{key:"_decodeKey",value:function(e,t){return"base64"===t.keyEncoding?u.default.enc.Base64.parse(e):"hex"===t.keyEncoding?u.default.enc.Hex.parse(e):e}},{key:"_getPaddedKey",value:function(e,t){return e=this._decodeKey(e,t),t.encryptKey?u.default.enc.Utf8.parse(this.SHA256(e).slice(0,32)):e}},{key:"_getMode",value:function(e){return"ecb"===e.mode?u.default.mode.ECB:u.default.mode.CBC}},{key:"_getIV",value:function(e){return"cbc"===e.mode?u.default.enc.Utf8.parse(this._iv):null}},{key:"encrypt",value:function(e,t,n){return this._config.customEncrypt?this._config.customEncrypt(e):this.pnEncrypt(e,t,n)}},{key:"decrypt",value:function(e,t,n){return this._config.customDecrypt?this._config.customDecrypt(e):this.pnDecrypt(e,t,n)}},{key:"pnEncrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);return u.default.AES.encrypt(e,o,{iv:r,mode:i}).ciphertext.toString(u.default.enc.Base64)||e}},{key:"pnDecrypt",value:function(e,t,n){if(!t&&!this._config.cipherKey)return e;n=this._parseOptions(n);var r=this._getIV(n),i=this._getMode(n),o=this._getPaddedKey(t||this._config.cipherKey,n);try{var s=u.default.enc.Base64.parse(e),a=u.default.AES.decrypt({ciphertext:s},o,{iv:r,mode:i}).toString(u.default.enc.Utf8);return JSON.parse(a)}catch(e){return null}}}])&&i(s.prototype,a),void(c&&i(s,c)),l);function l(e){var t=e.config;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),o(this,"_config",void 0),o(this,"_iv",void 0),o(this,"_allowedKeyEncodings",void 0),o(this,"_allowedKeyLengths",void 0),o(this,"_allowedModes",void 0),o(this,"_defaultOptions",void 0),this._config=t,this._iv="0123456789012345",this._allowedKeyEncodings=["hex","utf8","base64","binary"],this._allowedKeyLengths=[128,256],this._allowedModes=["ecb","cbc"],this._defaultOptions={encryptKey:!0,keyEncoding:"utf8",keyLength:256,mode:"cbc"}}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;n(0);var r,i=(r=n(4))&&r.__esModule?r:{default:r};function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var s,a,u,c=(s=f,(a=[{key:"addListener",value:function(e){this._listeners.push(e)}},{key:"removeListener",value:function(t){var n=[];this._listeners.forEach(function(e){e!==t&&n.push(e)}),this._listeners=n}},{key:"removeAllListeners",value:function(){this._listeners=[]}},{key:"announcePresence",value:function(t){this._listeners.forEach(function(e){e.presence&&e.presence(t)})}},{key:"announceStatus",value:function(t){this._listeners.forEach(function(e){e.status&&e.status(t)})}},{key:"announceMessage",value:function(t){this._listeners.forEach(function(e){e.message&&e.message(t)})}},{key:"announceSignal",value:function(t){this._listeners.forEach(function(e){e.signal&&e.signal(t)})}},{key:"announceMessageAction",value:function(t){this._listeners.forEach(function(e){e.messageAction&&e.messageAction(t)})}},{key:"announceUser",value:function(t){this._listeners.forEach(function(e){e.user&&e.user(t)})}},{key:"announceSpace",value:function(t){this._listeners.forEach(function(e){e.space&&e.space(t)})}},{key:"announceMembership",value:function(t){this._listeners.forEach(function(e){e.membership&&e.membership(t)})}},{key:"announceNetworkUp",value:function(){var e={};e.category=i.default.PNNetworkUpCategory,this.announceStatus(e)}},{key:"announceNetworkDown",value:function(){var e={};e.category=i.default.PNNetworkDownCategory,this.announceStatus(e)}}])&&o(s.prototype,a),void(u&&o(s,u)),f);function f(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),function(e,t,n){t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n}(this,"_listeners",void 0),this._listeners=[]}t.default=c,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNTimeOperation},t.getURL=function(){return"/time/0"},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(){return{}},t.isAuthSupported=function(){return!1},t.handleResponse=function(e,t){return{timetoken:t[0]}},t.validateParams=function(){};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,I,D){"use strict";(function(e){var r=D(71),o=D(72),s=D(73);function n(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function a(e,t){if(n()<t)throw new RangeError("Invalid typed array length");return l.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=l.prototype:(null===e&&(e=new l(t)),e.length=t),e}function l(e,t,n){if(!(l.TYPED_ARRAY_SUPPORT||this instanceof l))return new l(e,t,n);if("number"!=typeof e)return i(this,e,t,n);if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return c(this,e)}function i(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);l.TYPED_ARRAY_SUPPORT?(e=t).__proto__=l.prototype:e=f(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!l.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|p(t,n),i=(e=a(e,r)).write(t,n);i!==r&&(e=e.slice(0,i));return e}(e,t,n):function(e,t){if(l.isBuffer(t)){var n=0|h(t.length);return 0===(e=a(e,n)).length||t.copy(e,0,0,n),e}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||function(e){return e!=e}(t.length)?a(e,0):f(e,t);if("Buffer"===t.type&&s(t.data))return f(e,t.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function u(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function c(e,t){if(u(t),e=a(e,t<0?0:0|h(t)),!l.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function f(e,t){var n=t.length<0?0:0|h(t.length);e=a(e,n);for(var r=0;r<n;r+=1)e[r]=255&t[r];return e}function h(e){if(e>=n())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+n().toString(16)+" bytes");return 0|e}function p(e,t){if(l.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return x(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return U(e).length;default:if(r)return x(e).length;t=(""+t).toLowerCase(),r=!0}}function d(e,t,n){var r=e[t];e[t]=e[n],e[n]=r}function g(e,t,n,r,i){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):2147483647<n?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=i?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(i)return-1;n=e.length-1}else if(n<0){if(!i)return-1;n=0}if("string"==typeof t&&(t=l.from(t,r)),l.isBuffer(t))return 0===t.length?-1:y(e,t,n,r,i);if("number"==typeof t)return t&=255,l.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):y(e,[t],n,r,i);throw new TypeError("val must be string, number or Buffer")}function y(e,t,n,r,i){var o,s=1,a=e.length,u=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;a/=s=2,u/=2,n/=2}function c(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){var f=-1;for(o=n;o<a;o++)if(c(e,o)===c(t,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===u)return f*s}else-1!==f&&(o-=o-f),f=-1}else for(a<n+u&&(n=a-u),o=n;0<=o;o--){for(var l=!0,h=0;h<u;h++)if(c(e,o+h)!==c(t,h)){l=!1;break}if(l)return o}return-1}function v(e,t,n,r){n=Number(n)||0;var i=e.length-n;r?i<(r=Number(r))&&(r=i):r=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");o/2<r&&(r=o/2);for(var s=0;s<r;++s){var a=parseInt(t.substr(2*s,2),16);if(isNaN(a))return s;e[n+s]=a}return s}function b(e,t,n,r){return B(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function m(e,t,n){return 0===t&&n===e.length?r.fromByteArray(e):r.fromByteArray(e.slice(t,n))}function _(e,t,n){n=Math.min(e.length,n);for(var r=[],i=t;i<n;){var o,s,a,u,c=e[i],f=null,l=239<c?4:223<c?3:191<c?2:1;if(i+l<=n)switch(l){case 1:c<128&&(f=c);break;case 2:128==(192&(o=e[i+1]))&&127<(u=(31&c)<<6|63&o)&&(f=u);break;case 3:o=e[i+1],s=e[i+2],128==(192&o)&&128==(192&s)&&2047<(u=(15&c)<<12|(63&o)<<6|63&s)&&(u<55296||57343<u)&&(f=u);break;case 4:o=e[i+1],s=e[i+2],a=e[i+3],128==(192&o)&&128==(192&s)&&128==(192&a)&&65535<(u=(15&c)<<18|(63&o)<<12|(63&s)<<6|63&a)&&u<1114112&&(f=u)}null===f?(f=65533,l=1):65535<f&&(f-=65536,r.push(f>>>10&1023|55296),f=56320|1023&f),r.push(f),i+=l}return function(e){var t=e.length;if(t<=k)return String.fromCharCode.apply(String,e);var n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=k));return n}(r)}I.Buffer=l,I.SlowBuffer=function(e){+e!=e&&(e=0);return l.alloc(+e)},I.INSPECT_MAX_BYTES=50,l.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),I.kMaxLength=n(),l.poolSize=8192,l._augment=function(e){return e.__proto__=l.prototype,e},l.from=function(e,t,n){return i(null,e,t,n)},l.TYPED_ARRAY_SUPPORT&&(l.prototype.__proto__=Uint8Array.prototype,l.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&l[Symbol.species]===l&&Object.defineProperty(l,Symbol.species,{value:null,configurable:!0})),l.alloc=function(e,t,n){return function(e,t,n,r){return u(t),t<=0?a(e,t):void 0!==n?"string"==typeof r?a(e,t).fill(n,r):a(e,t).fill(n):a(e,t)}(null,e,t,n)},l.allocUnsafe=function(e){return c(null,e)},l.allocUnsafeSlow=function(e){return c(null,e)},l.isBuffer=function(e){return!(null==e||!e._isBuffer)},l.compare=function(e,t){if(!l.isBuffer(e)||!l.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,r=t.length,i=0,o=Math.min(n,r);i<o;++i)if(e[i]!==t[i]){n=e[i],r=t[i];break}return n<r?-1:r<n?1:0},l.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},l.concat=function(e,t){if(!s(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return l.alloc(0);var n;if(void 0===t)for(n=t=0;n<e.length;++n)t+=e[n].length;var r=l.allocUnsafe(t),i=0;for(n=0;n<e.length;++n){var o=e[n];if(!l.isBuffer(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(r,i),i+=o.length}return r},l.byteLength=p,l.prototype._isBuffer=!0,l.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)d(this,t,t+1);return this},l.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)d(this,t,t+3),d(this,t+1,t+2);return this},l.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)d(this,t,t+7),d(this,t+1,t+6),d(this,t+2,t+5),d(this,t+3,t+4);return this},l.prototype.toString=function(){var e=0|this.length;return 0==e?"":0===arguments.length?_(this,0,e):function(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e=e||"utf8";;)switch(e){case"hex":return T(this,t,n);case"utf8":case"utf-8":return _(this,t,n);case"ascii":return P(this,t,n);case"latin1":case"binary":return w(this,t,n);case"base64":return m(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}.apply(this,arguments)},l.prototype.equals=function(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===l.compare(this,e)},l.prototype.inspect=function(){var e="",t=I.INSPECT_MAX_BYTES;return 0<this.length&&(e=this.toString("hex",0,t).match(/.{2}/g).join(" "),this.length>t&&(e+=" ... ")),"<Buffer "+e+">"},l.prototype.compare=function(e,t,n,r,i){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===i&&(i=this.length),t<0||n>e.length||r<0||i>this.length)throw new RangeError("out of range index");if(i<=r&&n<=t)return 0;if(i<=r)return-1;if(n<=t)return 1;if(this===e)return 0;for(var o=(i>>>=0)-(r>>>=0),s=(n>>>=0)-(t>>>=0),a=Math.min(o,s),u=this.slice(r,i),c=e.slice(t,n),f=0;f<a;++f)if(u[f]!==c[f]){o=u[f],s=c[f];break}return o<s?-1:s<o?1:0},l.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},l.prototype.indexOf=function(e,t,n){return g(this,e,t,n,!0)},l.prototype.lastIndexOf=function(e,t,n){return g(this,e,t,n,!1)},l.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var i=this.length-t;if((void 0===n||i<n)&&(n=i),0<e.length&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r=r||"utf8";for(var o,s,a,u,c,f,l,h,p,d=!1;;)switch(r){case"hex":return v(this,e,t,n);case"utf8":case"utf-8":return h=t,p=n,B(x(e,(l=this).length-h),l,h,p);case"ascii":return b(this,e,t,n);case"latin1":case"binary":return b(this,e,t,n);case"base64":return u=this,c=t,f=n,B(U(e),u,c,f);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return s=t,a=n,B(function(e,t){for(var n,r,i,o=[],s=0;s<e.length&&!((t-=2)<0);++s)n=e.charCodeAt(s),r=n>>8,i=n%256,o.push(i),o.push(r);return o}(e,(o=this).length-s),o,s,a);default:if(d)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),d=!0}},l.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var k=4096;function P(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(127&e[i]);return r}function w(e,t,n){var r="";n=Math.min(e.length,n);for(var i=t;i<n;++i)r+=String.fromCharCode(e[i]);return r}function T(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||r<n)&&(n=r);for(var i="",o=t;o<n;++o)i+=N(e[o]);return i}function O(e,t,n){for(var r=e.slice(t,n),i="",o=0;o<r.length;o+=2)i+=String.fromCharCode(r[o]+256*r[o+1]);return i}function S(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(n<e+t)throw new RangeError("Trying to access beyond buffer length")}function M(e,t,n,r,i,o){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(i<t||t<o)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function E(e,t,n,r){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-n,2);i<o;++i)e[n+i]=(t&255<<8*(r?i:1-i))>>>8*(r?i:1-i)}function A(e,t,n,r){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-n,4);i<o;++i)e[n+i]=t>>>8*(r?i:3-i)&255}function C(e,t,n,r){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function R(e,t,n,r,i){return i||C(e,0,n,4),o.write(e,t,n,r,23,4),n+4}function j(e,t,n,r,i){return i||C(e,0,n,8),o.write(e,t,n,r,52,8),n+8}l.prototype.slice=function(e,t){var n,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):r<e&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):r<t&&(t=r),t<e&&(t=e),l.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=l.prototype;else{var i=t-e;n=new l(i,void 0);for(var o=0;o<i;++o)n[o]=this[o+e]}return n},l.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return r},l.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e+--t],i=1;0<t&&(i*=256);)r+=this[e+--t]*i;return r},l.prototype.readUInt8=function(e,t){return t||S(e,1,this.length),this[e]},l.prototype.readUInt16LE=function(e,t){return t||S(e,2,this.length),this[e]|this[e+1]<<8},l.prototype.readUInt16BE=function(e,t){return t||S(e,2,this.length),this[e]<<8|this[e+1]},l.prototype.readUInt32LE=function(e,t){return t||S(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},l.prototype.readUInt32BE=function(e,t){return t||S(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},l.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=this[e],i=1,o=0;++o<t&&(i*=256);)r+=this[e+o]*i;return(i*=128)<=r&&(r-=Math.pow(2,8*t)),r},l.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||S(e,t,this.length);for(var r=t,i=1,o=this[e+--r];0<r&&(i*=256);)o+=this[e+--r]*i;return(i*=128)<=o&&(o-=Math.pow(2,8*t)),o},l.prototype.readInt8=function(e,t){return t||S(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},l.prototype.readInt16LE=function(e,t){t||S(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt16BE=function(e,t){t||S(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},l.prototype.readInt32LE=function(e,t){return t||S(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},l.prototype.readInt32BE=function(e,t){return t||S(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},l.prototype.readFloatLE=function(e,t){return t||S(e,4,this.length),o.read(this,e,!0,23,4)},l.prototype.readFloatBE=function(e,t){return t||S(e,4,this.length),o.read(this,e,!1,23,4)},l.prototype.readDoubleLE=function(e,t){return t||S(e,8,this.length),o.read(this,e,!0,52,8)},l.prototype.readDoubleBE=function(e,t){return t||S(e,8,this.length),o.read(this,e,!1,52,8)},l.prototype.writeUIntLE=function(e,t,n,r){e=+e,t|=0,n|=0,r||M(this,e,t,n,Math.pow(2,8*n)-1,0);var i=1,o=0;for(this[t]=255&e;++o<n&&(i*=256);)this[t+o]=e/i&255;return t+n},l.prototype.writeUIntBE=function(e,t,n,r){e=+e,t|=0,n|=0,r||M(this,e,t,n,Math.pow(2,8*n)-1,0);var i=n-1,o=1;for(this[t+i]=255&e;0<=--i&&(o*=256);)this[t+i]=e/o&255;return t+n},l.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,1,255,0),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},l.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):E(this,e,t,!0),t+2},l.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,65535,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):E(this,e,t,!1),t+2},l.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):A(this,e,t,!0),t+4},l.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,4294967295,0),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):A(this,e,t,!1),t+4},l.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);M(this,e,t,n,i-1,-i)}var o=0,s=1,a=0;for(this[t]=255&e;++o<n&&(s*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},l.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var i=Math.pow(2,8*n-1);M(this,e,t,n,i-1,-i)}var o=n-1,s=1,a=0;for(this[t+o]=255&e;0<=--o&&(s*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+n},l.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,1,127,-128),l.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},l.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):E(this,e,t,!0),t+2},l.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,2,32767,-32768),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):E(this,e,t,!1),t+2},l.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,2147483647,-2147483648),l.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):A(this,e,t,!0),t+4},l.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||M(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),l.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):A(this,e,t,!1),t+4},l.prototype.writeFloatLE=function(e,t,n){return R(this,e,t,!0,n)},l.prototype.writeFloatBE=function(e,t,n){return R(this,e,t,!1,n)},l.prototype.writeDoubleLE=function(e,t,n){return j(this,e,t,!0,n)},l.prototype.writeDoubleBE=function(e,t,n){return j(this,e,t,!1,n)},l.prototype.copy=function(e,t,n,r){if(n=n||0,r||0===r||(r=this.length),t>=e.length&&(t=e.length),t=t||0,0<r&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var i,o=r-n;if(this===e&&n<t&&t<r)for(i=o-1;0<=i;--i)e[i+t]=this[i+n];else if(o<1e3||!l.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+o),t);return o},l.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!l.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var o;if(t>>>=0,n=void 0===n?this.length:n>>>0,"number"==typeof(e=e||0))for(o=t;o<n;++o)this[o]=e;else{var s=l.isBuffer(e)?e:x(new l(e,r).toString()),a=s.length;for(o=0;o<n-t;++o)this[o+t]=s[o%a]}return this};var t=/[^+\/0-9A-Za-z-_]/g;function N(e){return e<16?"0"+e.toString(16):e.toString(16)}function x(e,t){var n;t=t||1/0;for(var r=e.length,i=null,o=[],s=0;s<r;++s){if(55295<(n=e.charCodeAt(s))&&n<57344){if(!i){if(56319<n){-1<(t-=3)&&o.push(239,191,189);continue}if(s+1===r){-1<(t-=3)&&o.push(239,191,189);continue}i=n;continue}if(n<56320){-1<(t-=3)&&o.push(239,191,189),i=n;continue}n=65536+(i-55296<<10|n-56320)}else i&&-1<(t-=3)&&o.push(239,191,189);if(i=null,n<128){if((t-=1)<0)break;o.push(n)}else if(n<2048){if((t-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function U(e){return r.toByteArray(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(t,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function B(e,t,n,r){for(var i=0;i<r&&!(i+n>=t.length||i>=e.length);++i)t[i+n]=e[i];return i}}).call(this,D(70))},function(e,t,n){"use strict";e.exports=function(e){return null!==e&&"object"==typeof e}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r=u(n(12)),i=u(n(67)),o=u(n(68)),s=u(n(69)),a=n(75);n(0);function u(e){return e&&e.__esModule?e:{default:e}}function c(e){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function f(e,t){return!t||"object"!==c(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function l(e){return(l=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function h(e,t){return(h=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function p(e){if(!navigator||!navigator.sendBeacon)return!1;navigator.sendBeacon(e)}var d=(function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&h(e,t)}(g,r.default),g);function g(e){var t;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,g);var n=e.listenToBrowserNetworkEvents,r=void 0===n||n;return e.db=o.default,e.cbor=new s.default,e.sdkFamily="Web",e.networking=new i.default({del:a.del,get:a.get,post:a.post,patch:a.patch,sendBeacon:p}),t=f(this,l(g).call(this,e)),r&&(window.addEventListener("offline",function(){t.networkDownDetected()}),window.addEventListener("online",function(){t.networkUpDetected()})),t}t.default=d,e.exports=t.default},function(e,t,n){"use strict";function s(e){return(s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var y=f(n(3)),v=f(n(6)),b=f(n(15)),r=f(n(18)),m=f(n(7)),_=f(n(19)),k=f(n(20)),P=c(n(21)),w=c(n(22)),T=c(n(23)),O=c(n(24)),S=c(n(25)),M=c(n(26)),E=c(n(27)),A=c(n(28)),C=c(n(29)),R=c(n(30)),j=c(n(31)),N=c(n(32)),x=c(n(33)),U=c(n(34)),B=c(n(35)),I=c(n(36)),D=c(n(37)),K=c(n(38)),L=c(n(39)),F=c(n(40)),G=c(n(41)),H=c(n(42)),q=c(n(43)),z=c(n(44)),Y=c(n(45)),$=c(n(46)),W=c(n(47)),J=c(n(48)),X=c(n(49)),V=c(n(50)),Q=c(n(51)),Z=c(n(52)),ee=c(n(53)),te=c(n(54)),ne=c(n(55)),re=c(n(56)),ie=c(n(57)),oe=c(n(58)),se=c(n(59)),ae=c(n(60)),ue=c(n(61)),ce=c(n(62)),fe=c(n(63)),le=c(n(64)),he=c(n(65)),pe=c(n(8)),de=c(n(66)),i=f(n(1)),o=f(n(4)),a=(n(0),f(n(5)));function u(){if("function"!=typeof WeakMap)return null;var e=new WeakMap;return u=function(){return e},e}function c(e){if(e&&e.__esModule)return e;if(null===e||"object"!==s(e)&&"function"!=typeof e)return{default:e};var t=u();if(t&&t.has(e))return t.get(e);var n={},r=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var o=r?Object.getOwnPropertyDescriptor(e,i):null;o&&(o.get||o.set)?Object.defineProperty(n,i,o):n[i]=e[i]}return n.default=e,t&&t.set(e,n),n}function f(e){return e&&e.__esModule?e:{default:e}}function l(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function ge(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var h,p,d,g=(h=ye,d=[{key:"notificationPayload",value:function(e,t){return new r.default(e,t)}},{key:"generateUUID",value:function(){return a.default.createUUID()}}],(p=[{key:"getVersion",value:function(){return this._config.getVersion()}},{key:"_addPnsdkSuffix",value:function(e,t){this._config._addPnsdkSuffix(e,t)}},{key:"networkDownDetected",value:function(){this._listenerManager.announceNetworkDown(),this._config.restore?this.disconnect():this.destroy(!0)}},{key:"networkUpDetected",value:function(){this._listenerManager.announceNetworkUp(),this.reconnect()}}])&&l(h.prototype,p),void(d&&l(h,d)),ye);function ye(e){var n=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,ye),ge(this,"_config",void 0),ge(this,"_listenerManager",void 0),ge(this,"_tokenManager",void 0),ge(this,"time",void 0),ge(this,"publish",void 0),ge(this,"fire",void 0),ge(this,"history",void 0),ge(this,"deleteMessages",void 0),ge(this,"messageCounts",void 0),ge(this,"fetchMessages",void 0),ge(this,"channelGroups",void 0),ge(this,"push",void 0),ge(this,"hereNow",void 0),ge(this,"whereNow",void 0),ge(this,"getState",void 0),ge(this,"setState",void 0),ge(this,"grant",void 0),ge(this,"grantToken",void 0),ge(this,"audit",void 0),ge(this,"subscribe",void 0),ge(this,"signal",void 0),ge(this,"presence",void 0),ge(this,"unsubscribe",void 0),ge(this,"unsubscribeAll",void 0),ge(this,"addMessageAction",void 0),ge(this,"removeMessageAction",void 0),ge(this,"getMessageActions",void 0),ge(this,"createUser",void 0),ge(this,"updateUser",void 0),ge(this,"deleteUser",void 0),ge(this,"getUser",void 0),ge(this,"getUsers",void 0),ge(this,"createSpace",void 0),ge(this,"updateSpace",void 0),ge(this,"deleteSpace",void 0),ge(this,"getSpaces",void 0),ge(this,"getSpace",void 0),ge(this,"getMembers",void 0),ge(this,"addMembers",void 0),ge(this,"updateMembers",void 0),ge(this,"removeMembers",void 0),ge(this,"getMemberships",void 0),ge(this,"joinSpaces",void 0),ge(this,"updateMemberships",void 0),ge(this,"leaveSpaces",void 0),ge(this,"disconnect",void 0),ge(this,"reconnect",void 0),ge(this,"destroy",void 0),ge(this,"stop",void 0),ge(this,"getSubscribedChannels",void 0),ge(this,"getSubscribedChannelGroups",void 0),ge(this,"addListener",void 0),ge(this,"removeListener",void 0),ge(this,"removeAllListeners",void 0),ge(this,"parseToken",void 0),ge(this,"setToken",void 0),ge(this,"setTokens",void 0),ge(this,"getToken",void 0),ge(this,"getTokens",void 0),ge(this,"clearTokens",void 0),ge(this,"getAuthKey",void 0),ge(this,"setAuthKey",void 0),ge(this,"setCipherKey",void 0),ge(this,"setUUID",void 0),ge(this,"getUUID",void 0),ge(this,"getFilterExpression",void 0),ge(this,"setFilterExpression",void 0),ge(this,"setHeartbeatInterval",void 0),ge(this,"setProxy",void 0),ge(this,"encrypt",void 0),ge(this,"decrypt",void 0);var t=e.db,r=e.networking,i=e.cbor,o=this._config=new y.default({setup:e,db:t}),s=new v.default({config:o});r.init(o);var a=this._tokenManager=new _.default(o,i),u={config:o,networking:r,crypto:s,tokenManager:a},c=k.default.bind(this,u,pe),f=k.default.bind(this,u,R),l=k.default.bind(this,u,N),h=k.default.bind(this,u,U),p=k.default.bind(this,u,de),d=this._listenerManager=new m.default,g=new b.default({timeEndpoint:c,leaveEndpoint:f,heartbeatEndpoint:l,setStateEndpoint:h,subscribeEndpoint:p,crypto:u.crypto,config:u.config,listenerManager:d});this.addListener=d.addListener.bind(d),this.removeListener=d.removeListener.bind(d),this.removeAllListeners=d.removeAllListeners.bind(d),this.parseToken=a.parseToken.bind(a),this.setToken=a.setToken.bind(a),this.setTokens=a.setTokens.bind(a),this.getToken=a.getToken.bind(a),this.getTokens=a.getTokens.bind(a),this.clearTokens=a.clearTokens.bind(a),this.channelGroups={listGroups:k.default.bind(this,u,O),listChannels:k.default.bind(this,u,S),addChannels:k.default.bind(this,u,P),removeChannels:k.default.bind(this,u,w),deleteGroup:k.default.bind(this,u,T)},this.push={addChannels:k.default.bind(this,u,M),removeChannels:k.default.bind(this,u,E),deleteDevice:k.default.bind(this,u,C),listChannels:k.default.bind(this,u,A)},this.hereNow=k.default.bind(this,u,B),this.whereNow=k.default.bind(this,u,j),this.getState=k.default.bind(this,u,x),this.setState=g.adaptStateChange.bind(g),this.grant=k.default.bind(this,u,oe),this.grantToken=k.default.bind(this,u,se),this.audit=k.default.bind(this,u,ie),this.publish=k.default.bind(this,u,ae),this.fire=function(e,t){return e.replicate=!1,e.storeInHistory=!1,n.publish(e,t)},this.signal=k.default.bind(this,u,ue),this.history=k.default.bind(this,u,ce),this.deleteMessages=k.default.bind(this,u,fe),this.messageCounts=k.default.bind(this,u,le),this.fetchMessages=k.default.bind(this,u,he),this.addMessageAction=k.default.bind(this,u,I),this.removeMessageAction=k.default.bind(this,u,D),this.getMessageActions=k.default.bind(this,u,K),this.createUser=k.default.bind(this,u,L),this.updateUser=k.default.bind(this,u,F),this.deleteUser=k.default.bind(this,u,G),this.getUser=k.default.bind(this,u,H),this.getUsers=k.default.bind(this,u,q),this.createSpace=k.default.bind(this,u,z),this.updateSpace=k.default.bind(this,u,Y),this.deleteSpace=k.default.bind(this,u,$),this.getSpaces=k.default.bind(this,u,W),this.getSpace=k.default.bind(this,u,J),this.addMembers=k.default.bind(this,u,V),this.updateMembers=k.default.bind(this,u,Q),this.removeMembers=k.default.bind(this,u,Z),this.getMembers=k.default.bind(this,u,X),this.getMemberships=k.default.bind(this,u,ee),this.joinSpaces=k.default.bind(this,u,ne),this.updateMemberships=k.default.bind(this,u,te),this.leaveSpaces=k.default.bind(this,u,re),this.time=c,this.subscribe=g.adaptSubscribeChange.bind(g),this.presence=g.adaptPresenceChange.bind(g),this.unsubscribe=g.adaptUnsubscribeChange.bind(g),this.disconnect=g.disconnect.bind(g),this.reconnect=g.reconnect.bind(g),this.destroy=function(e){g.unsubscribeAll(e),g.disconnect()},this.stop=this.destroy,this.unsubscribeAll=g.unsubscribeAll.bind(g),this.getSubscribedChannels=g.getSubscribedChannels.bind(g),this.getSubscribedChannelGroups=g.getSubscribedChannelGroups.bind(g),this.encrypt=s.encrypt.bind(s),this.decrypt=s.decrypt.bind(s),this.getAuthKey=u.config.getAuthKey.bind(u.config),this.setAuthKey=u.config.setAuthKey.bind(u.config),this.setCipherKey=u.config.setCipherKey.bind(u.config),this.getUUID=u.config.getUUID.bind(u.config),this.setUUID=u.config.setUUID.bind(u.config),this.getFilterExpression=u.config.getFilterExpression.bind(u.config),this.setFilterExpression=u.config.setFilterExpression.bind(u.config),this.setHeartbeatInterval=u.config.setHeartbeatInterval.bind(u.config),r.hasModule("proxy")&&(this.setProxy=function(e){u.config.setProxy(e),n.reconnect()})}ge(t.default=g,"OPERATIONS",i.default),ge(g,"CATEGORIES",o.default),e.exports=t.default},function(e,t,n){var r,i,o;i=[t],void 0===(o="function"==typeof(r=function(e){var r={3:/^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,4:/^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,5:/^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,all:/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i};function t(){var e,t,n="";for(e=0;e<32;e++)t=16*Math.random()|0,8!==e&&12!==e&&16!==e&&20!==e||(n+="-"),n+=(12===e?4:16===e?3&t|8:t).toString(16);return n}function n(e,t){var n=r[t||"all"];return n&&n.test(e)||!1}t.isUUID=n,t.VERSION="0.1.0",e.uuid=t,e.isUUID=n})?r.apply(t,i):r)||(e.exports=o)},function(e,t,n){"use strict";var r,c,i,u,o,s,a,f,l,h,E=E||function(a){function n(){}var e={},t=e.lib={},r=t.Base={extend:function(e){n.prototype=this;var t=new n;return e&&t.mixIn(e),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments)}),(t.init.prototype=t).$super=this,t},create:function(){var e=this.extend();return e.init.apply(e,arguments),e},init:function(){},mixIn:function(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function(){return this.init.prototype.extend(this)}},u=t.WordArray=r.extend({init:function(e,t){e=this.words=e||[],this.sigBytes=null!=t?t:4*e.length},toString:function(e){return(e||o).stringify(this)},concat:function(e){var t=this.words,n=e.words,r=this.sigBytes;if(e=e.sigBytes,this.clamp(),r%4)for(var i=0;i<e;i++)t[r+i>>>2]|=(n[i>>>2]>>>24-i%4*8&255)<<24-(r+i)%4*8;else if(65535<n.length)for(i=0;i<e;i+=4)t[r+i>>>2]=n[i>>>2];else t.push.apply(t,n);return this.sigBytes+=e,this},clamp:function(){var e=this.words,t=this.sigBytes;e[t>>>2]&=4294967295<<32-t%4*8,e.length=a.ceil(t/4)},clone:function(){var e=r.clone.call(this);return e.words=this.words.slice(0),e},random:function(e){for(var t=[],n=0;n<e;n+=4)t.push(4294967296*a.random()|0);return new u.init(t,e)}}),i=e.enc={},o=i.Hex={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++){var i=t[r>>>2]>>>24-r%4*8&255;n.push((i>>>4).toString(16)),n.push((15&i).toString(16))}return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r+=2)n[r>>>3]|=parseInt(e.substr(r,2),16)<<24-r%8*4;return new u.init(n,t/2)}},s=i.Latin1={stringify:function(e){var t=e.words;e=e.sigBytes;for(var n=[],r=0;r<e;r++)n.push(String.fromCharCode(t[r>>>2]>>>24-r%4*8&255));return n.join("")},parse:function(e){for(var t=e.length,n=[],r=0;r<t;r++)n[r>>>2]|=(255&e.charCodeAt(r))<<24-r%4*8;return new u.init(n,t)}},c=i.Utf8={stringify:function(e){try{return decodeURIComponent(escape(s.stringify(e)))}catch(e){throw Error("Malformed UTF-8 data")}},parse:function(e){return s.parse(unescape(encodeURIComponent(e)))}},f=t.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new u.init,this._nDataBytes=0},_append:function(e){"string"==typeof e&&(e=c.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function(e){var t=this._data,n=t.words,r=t.sigBytes,i=this.blockSize,o=r/(4*i);if(e=(o=e?a.ceil(o):a.max((0|o)-this._minBufferSize,0))*i,r=a.min(4*e,r),e){for(var s=0;s<e;s+=i)this._doProcessBlock(n,s);s=n.splice(0,e),t.sigBytes-=r}return new u.init(s,r)},clone:function(){var e=r.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0});t.Hasher=f.extend({cfg:r.extend(),init:function(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function(){f.reset.call(this),this._doReset()},update:function(e){return this._append(e),this._process(),this},finalize:function(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function(n){return function(e,t){return new n.init(t).finalize(e)}},_createHmacHelper:function(n){return function(e,t){return new l.HMAC.init(n,t).finalize(e)}}});var l=e.algo={};return e}(Math);!function(i){for(var e=E,t=(r=e.lib).WordArray,n=r.Hasher,r=e.algo,o=[],d=[],s=function(e){return 4294967296*(e-(0|e))|0},a=2,u=0;u<64;){var c;e:{c=a;for(var f=i.sqrt(c),l=2;l<=f;l++)if(!(c%l)){c=!1;break e}c=!0}c&&(u<8&&(o[u]=s(i.pow(a,.5))),d[u]=s(i.pow(a,1/3)),u++),a++}var g=[];r=r.SHA256=n.extend({_doReset:function(){this._hash=new t.init(o.slice(0))},_doProcessBlock:function(e,t){for(var n=this._hash.words,r=n[0],i=n[1],o=n[2],s=n[3],a=n[4],u=n[5],c=n[6],f=n[7],l=0;l<64;l++){if(l<16)g[l]=0|e[t+l];else{var h=g[l-15],p=g[l-2];g[l]=((h<<25|h>>>7)^(h<<14|h>>>18)^h>>>3)+g[l-7]+((p<<15|p>>>17)^(p<<13|p>>>19)^p>>>10)+g[l-16]}h=f+((a<<26|a>>>6)^(a<<21|a>>>11)^(a<<7|a>>>25))+(a&u^~a&c)+d[l]+g[l],p=((r<<30|r>>>2)^(r<<19|r>>>13)^(r<<10|r>>>22))+(r&i^r&o^i&o),f=c,c=u,u=a,a=s+h|0,s=o,o=i,i=r,r=h+p|0}n[0]=n[0]+r|0,n[1]=n[1]+i|0,n[2]=n[2]+o|0,n[3]=n[3]+s|0,n[4]=n[4]+a|0,n[5]=n[5]+u|0,n[6]=n[6]+c|0,n[7]=n[7]+f|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;return t[r>>>5]|=128<<24-r%32,t[14+(64+r>>>9<<4)]=i.floor(n/4294967296),t[15+(64+r>>>9<<4)]=n,e.sigBytes=4*t.length,this._process(),this._hash},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}});e.SHA256=n._createHelper(r),e.HmacSHA256=n._createHmacHelper(r)}(Math),c=(r=E).enc.Utf8,r.algo.HMAC=r.lib.Base.extend({init:function(e,t){e=this._hasher=new e.init,"string"==typeof t&&(t=c.parse(t));var n=e.blockSize,r=4*n;t.sigBytes>r&&(t=e.finalize(t)),t.clamp();for(var i=this._oKey=t.clone(),o=this._iKey=t.clone(),s=i.words,a=o.words,u=0;u<n;u++)s[u]^=1549556828,a[u]^=909522486;i.sigBytes=o.sigBytes=r,this.reset()},reset:function(){var e=this._hasher;e.reset(),e.update(this._iKey)},update:function(e){return this._hasher.update(e),this},finalize:function(e){var t=this._hasher;return e=t.finalize(e),t.reset(),t.finalize(this._oKey.clone().concat(e))}}),u=(i=E).lib.WordArray,i.enc.Base64={stringify:function(e){var t=e.words,n=e.sigBytes,r=this._map;e.clamp(),e=[];for(var i=0;i<n;i+=3)for(var o=(t[i>>>2]>>>24-i%4*8&255)<<16|(t[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|t[i+2>>>2]>>>24-(i+2)%4*8&255,s=0;s<4&&i+.75*s<n;s++)e.push(r.charAt(o>>>6*(3-s)&63));if(t=r.charAt(64))for(;e.length%4;)e.push(t);return e.join("")},parse:function(e){var t=e.length,n=this._map;!(r=n.charAt(64))||-1!=(r=e.indexOf(r))&&(t=r);for(var r=[],i=0,o=0;o<t;o++)if(o%4){var s=n.indexOf(e.charAt(o-1))<<o%4*2,a=n.indexOf(e.charAt(o))>>>6-o%4*2;r[i>>>2]|=(s|a)<<24-i%4*8,i++}return u.create(r,i)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="},function(o){function w(e,t,n,r,i,o,s){return((e=e+(t&n|~t&r)+i+s)<<o|e>>>32-o)+t}function T(e,t,n,r,i,o,s){return((e=e+(t&r|n&~r)+i+s)<<o|e>>>32-o)+t}function O(e,t,n,r,i,o,s){return((e=e+(t^n^r)+i+s)<<o|e>>>32-o)+t}function S(e,t,n,r,i,o,s){return((e=e+(n^(t|~r))+i+s)<<o|e>>>32-o)+t}for(var e=E,t=(r=e.lib).WordArray,n=r.Hasher,r=e.algo,M=[],i=0;i<64;i++)M[i]=4294967296*o.abs(o.sin(i+1))|0;r=r.MD5=n.extend({_doReset:function(){this._hash=new t.init([1732584193,4023233417,2562383102,271733878])},_doProcessBlock:function(e,t){for(var n=0;n<16;n++){var r=e[s=t+n];e[s]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8)}n=this._hash.words;var i,o,s=e[t+0],a=(r=e[t+1],e[t+2]),u=e[t+3],c=e[t+4],f=e[t+5],l=e[t+6],h=e[t+7],p=e[t+8],d=e[t+9],g=e[t+10],y=e[t+11],v=e[t+12],b=e[t+13],m=e[t+14],_=e[t+15],k=n[0],P=S(P=S(P=S(P=S(P=O(P=O(P=O(P=O(P=T(P=T(P=T(P=T(P=w(P=w(P=w(P=w(P=n[1],o=w(o=n[2],i=w(i=n[3],k=w(k,P,o,i,s,7,M[0]),P,o,r,12,M[1]),k,P,a,17,M[2]),i,k,u,22,M[3]),o=w(o,i=w(i,k=w(k,P,o,i,c,7,M[4]),P,o,f,12,M[5]),k,P,l,17,M[6]),i,k,h,22,M[7]),o=w(o,i=w(i,k=w(k,P,o,i,p,7,M[8]),P,o,d,12,M[9]),k,P,g,17,M[10]),i,k,y,22,M[11]),o=w(o,i=w(i,k=w(k,P,o,i,v,7,M[12]),P,o,b,12,M[13]),k,P,m,17,M[14]),i,k,_,22,M[15]),o=T(o,i=T(i,k=T(k,P,o,i,r,5,M[16]),P,o,l,9,M[17]),k,P,y,14,M[18]),i,k,s,20,M[19]),o=T(o,i=T(i,k=T(k,P,o,i,f,5,M[20]),P,o,g,9,M[21]),k,P,_,14,M[22]),i,k,c,20,M[23]),o=T(o,i=T(i,k=T(k,P,o,i,d,5,M[24]),P,o,m,9,M[25]),k,P,u,14,M[26]),i,k,p,20,M[27]),o=T(o,i=T(i,k=T(k,P,o,i,b,5,M[28]),P,o,a,9,M[29]),k,P,h,14,M[30]),i,k,v,20,M[31]),o=O(o,i=O(i,k=O(k,P,o,i,f,4,M[32]),P,o,p,11,M[33]),k,P,y,16,M[34]),i,k,m,23,M[35]),o=O(o,i=O(i,k=O(k,P,o,i,r,4,M[36]),P,o,c,11,M[37]),k,P,h,16,M[38]),i,k,g,23,M[39]),o=O(o,i=O(i,k=O(k,P,o,i,b,4,M[40]),P,o,s,11,M[41]),k,P,u,16,M[42]),i,k,l,23,M[43]),o=O(o,i=O(i,k=O(k,P,o,i,d,4,M[44]),P,o,v,11,M[45]),k,P,_,16,M[46]),i,k,a,23,M[47]),o=S(o,i=S(i,k=S(k,P,o,i,s,6,M[48]),P,o,h,10,M[49]),k,P,m,15,M[50]),i,k,f,21,M[51]),o=S(o,i=S(i,k=S(k,P,o,i,v,6,M[52]),P,o,u,10,M[53]),k,P,g,15,M[54]),i,k,r,21,M[55]),o=S(o,i=S(i,k=S(k,P,o,i,p,6,M[56]),P,o,_,10,M[57]),k,P,l,15,M[58]),i,k,b,21,M[59]),o=S(o,i=S(i,k=S(k,P,o,i,c,6,M[60]),P,o,y,10,M[61]),k,P,a,15,M[62]),i,k,d,21,M[63]);n[0]=n[0]+k|0,n[1]=n[1]+P|0,n[2]=n[2]+o|0,n[3]=n[3]+i|0},_doFinalize:function(){var e=this._data,t=e.words,n=8*this._nDataBytes,r=8*e.sigBytes;t[r>>>5]|=128<<24-r%32;var i=o.floor(n/4294967296);for(t[15+(r+64>>>9<<4)]=16711935&(i<<8|i>>>24)|4278255360&(i<<24|i>>>8),t[14+(r+64>>>9<<4)]=16711935&(n<<8|n>>>24)|4278255360&(n<<24|n>>>8),e.sigBytes=4*(t.length+1),this._process(),t=(e=this._hash).words,n=0;n<4;n++)r=t[n],t[n]=16711935&(r<<8|r>>>24)|4278255360&(r<<24|r>>>8);return e},clone:function(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}}),e.MD5=n._createHelper(r),e.HmacMD5=n._createHmacHelper(r)}(Math),a=(o=(s=E).lib).Base,f=o.WordArray,l=(o=s.algo).EvpKDF=a.extend({cfg:a.extend({keySize:4,hasher:o.MD5,iterations:1}),init:function(e){this.cfg=this.cfg.extend(e)},compute:function(e,t){for(var n=(s=this.cfg).hasher.create(),r=f.create(),i=r.words,o=s.keySize,s=s.iterations;i.length<o;){a&&n.update(a);var a=n.update(e).finalize(t);n.reset();for(var u=1;u<s;u++)a=n.finalize(a),n.reset();r.concat(a)}return r.sigBytes=4*o,r}}),s.EvpKDF=function(e,t,n){return l.create(n).compute(e,t)},E.lib.Cipher||function(){var e=(h=E).lib,t=e.Base,s=e.WordArray,n=e.BufferedBlockAlgorithm,r=h.enc.Base64,i=h.algo.EvpKDF,o=e.Cipher=n.extend({cfg:t.extend(),createEncryptor:function(e,t){return this.create(this._ENC_XFORM_MODE,e,t)},createDecryptor:function(e,t){return this.create(this._DEC_XFORM_MODE,e,t)},init:function(e,t,n){this.cfg=this.cfg.extend(n),this._xformMode=e,this._key=t,this.reset()},reset:function(){n.reset.call(this),this._doReset()},process:function(e){return this._append(e),this._process()},finalize:function(e){return e&&this._append(e),this._doFinalize()},keySize:4,ivSize:4,_ENC_XFORM_MODE:1,_DEC_XFORM_MODE:2,_createHelper:function(r){return{encrypt:function(e,t,n){return("string"==typeof t?p:l).encrypt(r,e,t,n)},decrypt:function(e,t,n){return("string"==typeof t?p:l).decrypt(r,e,t,n)}}}});e.StreamCipher=o.extend({_doFinalize:function(){return this._process(!0)},blockSize:1});function a(e,t,n){var r=this._iv;r?this._iv=void 0:r=this._prevBlock;for(var i=0;i<n;i++)e[t+i]^=r[i]}var u=h.mode={},c=(e.BlockCipherMode=t.extend({createEncryptor:function(e,t){return this.Encryptor.create(e,t)},createDecryptor:function(e,t){return this.Decryptor.create(e,t)},init:function(e,t){this._cipher=e,this._iv=t}})).extend();c.Encryptor=c.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize;a.call(this,e,t,r),n.encryptBlock(e,t),this._prevBlock=e.slice(t,t+r)}}),c.Decryptor=c.extend({processBlock:function(e,t){var n=this._cipher,r=n.blockSize,i=e.slice(t,t+r);n.decryptBlock(e,t),a.call(this,e,t,r),this._prevBlock=i}}),u=u.CBC=c,c=(h.pad={}).Pkcs7={pad:function(e,t){for(var n,r=(n=(n=4*t)-e.sigBytes%n)<<24|n<<16|n<<8|n,i=[],o=0;o<n;o+=4)i.push(r);n=s.create(i,n),e.concat(n)},unpad:function(e){e.sigBytes-=255&e.words[e.sigBytes-1>>>2]}},e.BlockCipher=o.extend({cfg:o.cfg.extend({mode:u,padding:c}),reset:function(){o.reset.call(this);var e=(t=this.cfg).iv,t=t.mode;if(this._xformMode==this._ENC_XFORM_MODE)var n=t.createEncryptor;else n=t.createDecryptor,this._minBufferSize=1;this._mode=n.call(t,this,e&&e.words)},_doProcessBlock:function(e,t){this._mode.processBlock(e,t)},_doFinalize:function(){var e=this.cfg.padding;if(this._xformMode==this._ENC_XFORM_MODE){e.pad(this._data,this.blockSize);var t=this._process(!0)}else t=this._process(!0),e.unpad(t);return t},blockSize:4});var f=e.CipherParams=t.extend({init:function(e){this.mixIn(e)},toString:function(e){return(e||this.formatter).stringify(this)}}),l=(u=(h.format={}).OpenSSL={stringify:function(e){var t=e.ciphertext;return((e=e.salt)?s.create([1398893684,1701076831]).concat(e).concat(t):t).toString(r)},parse:function(e){var t=(e=r.parse(e)).words;if(1398893684==t[0]&&1701076831==t[1]){var n=s.create(t.slice(2,4));t.splice(0,4),e.sigBytes-=16}return f.create({ciphertext:e,salt:n})}},e.SerializableCipher=t.extend({cfg:t.extend({format:u}),encrypt:function(e,t,n,r){r=this.cfg.extend(r);var i=e.createEncryptor(n,r);return t=i.finalize(t),i=i.cfg,f.create({ciphertext:t,key:n,iv:i.iv,algorithm:e,mode:i.mode,padding:i.padding,blockSize:e.blockSize,formatter:r.format})},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),e.createDecryptor(n,r).finalize(t.ciphertext)},_parse:function(e,t){return"string"==typeof e?t.parse(e,this):e}})),h=(h.kdf={}).OpenSSL={execute:function(e,t,n,r){return r=r||s.random(8),e=i.create({keySize:t+n}).compute(e,r),n=s.create(e.words.slice(t),4*n),e.sigBytes=4*t,f.create({key:e,iv:n,salt:r})}},p=e.PasswordBasedCipher=l.extend({cfg:l.cfg.extend({kdf:h}),encrypt:function(e,t,n,r){return n=(r=this.cfg.extend(r)).kdf.execute(n,e.keySize,e.ivSize),r.iv=n.iv,(e=l.encrypt.call(this,e,t,n.key,r)).mixIn(n),e},decrypt:function(e,t,n,r){return r=this.cfg.extend(r),t=this._parse(t,r.format),n=r.kdf.execute(n,e.keySize,e.ivSize,t.salt),r.iv=n.iv,l.decrypt.call(this,e,t,n.key,r)}})}(),function(){for(var e=E,t=e.lib.BlockCipher,n=e.algo,s=[],r=[],i=[],o=[],a=[],u=[],c=[],f=[],l=[],h=[],p=[],d=0;d<256;d++)p[d]=d<128?d<<1:d<<1^283;var g=0,y=0;for(d=0;d<256;d++){var v=(v=y^y<<1^y<<2^y<<3^y<<4)>>>8^255&v^99;s[g]=v;var b=p[r[v]=g],m=p[b],_=p[m],k=257*p[v]^16843008*v;i[g]=k<<24|k>>>8,o[g]=k<<16|k>>>16,a[g]=k<<8|k>>>24,u[g]=k,k=16843009*_^65537*m^257*b^16843008*g,c[v]=k<<24|k>>>8,f[v]=k<<16|k>>>16,l[v]=k<<8|k>>>24,h[v]=k,g?(g=b^p[p[p[_^b]]],y^=p[p[y]]):g=y=1}var P=[0,1,2,4,8,16,32,64,128,27,54];n=n.AES=t.extend({_doReset:function(){for(var e=(n=this._key).words,t=n.sigBytes/4,n=4*((this._nRounds=t+6)+1),r=this._keySchedule=[],i=0;i<n;i++)if(i<t)r[i]=e[i];else{var o=r[i-1];i%t?6<t&&4==i%t&&(o=s[o>>>24]<<24|s[o>>>16&255]<<16|s[o>>>8&255]<<8|s[255&o]):(o=s[(o=o<<8|o>>>24)>>>24]<<24|s[o>>>16&255]<<16|s[o>>>8&255]<<8|s[255&o],o^=P[i/t|0]<<24),r[i]=r[i-t]^o}for(e=this._invKeySchedule=[],t=0;t<n;t++)i=n-t,o=t%4?r[i]:r[i-4],e[t]=t<4||i<=4?o:c[s[o>>>24]]^f[s[o>>>16&255]]^l[s[o>>>8&255]]^h[s[255&o]]},encryptBlock:function(e,t){this._doCryptBlock(e,t,this._keySchedule,i,o,a,u,s)},decryptBlock:function(e,t){var n=e[t+1];e[t+1]=e[t+3],e[t+3]=n,this._doCryptBlock(e,t,this._invKeySchedule,c,f,l,h,r),n=e[t+1],e[t+1]=e[t+3],e[t+3]=n},_doCryptBlock:function(e,t,n,r,i,o,s,a){for(var u=this._nRounds,c=e[t]^n[0],f=e[t+1]^n[1],l=e[t+2]^n[2],h=e[t+3]^n[3],p=4,d=1;d<u;d++){var g=r[c>>>24]^i[f>>>16&255]^o[l>>>8&255]^s[255&h]^n[p++],y=r[f>>>24]^i[l>>>16&255]^o[h>>>8&255]^s[255&c]^n[p++],v=r[l>>>24]^i[h>>>16&255]^o[c>>>8&255]^s[255&f]^n[p++];h=r[h>>>24]^i[c>>>16&255]^o[f>>>8&255]^s[255&l]^n[p++],c=g,f=y,l=v}g=(a[c>>>24]<<24|a[f>>>16&255]<<16|a[l>>>8&255]<<8|a[255&h])^n[p++],y=(a[f>>>24]<<24|a[l>>>16&255]<<16|a[h>>>8&255]<<8|a[255&c])^n[p++],v=(a[l>>>24]<<24|a[h>>>16&255]<<16|a[c>>>8&255]<<8|a[255&f])^n[p++],h=(a[h>>>24]<<24|a[c>>>16&255]<<16|a[f>>>8&255]<<8|a[255&l])^n[p++],e[t]=g,e[t+1]=y,e[t+2]=v,e[t+3]=h},keySize:8});e.AES=t._createHelper(n)}(),E.mode.ECB=((h=E.lib.BlockCipherMode.extend()).Encryptor=h.extend({processBlock:function(e,t){this._cipher.encryptBlock(e,t)}}),h.Decryptor=h.extend({processBlock:function(e,t){this._cipher.decryptBlock(e,t)}}),h),e.exports=E},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;r(n(6)),r(n(3)),r(n(7));var c=r(n(16)),f=r(n(17)),l=r(n(2)),a=(n(0),r(n(4)));function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function h(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var o,s,u,p=(o=d,(s=[{key:"adaptStateChange",value:function(e,t){var n=this,r=e.state,i=e.channels,o=void 0===i?[]:i,s=e.channelGroups,a=void 0===s?[]:s;return o.forEach(function(e){e in n._channels&&(n._channels[e].state=r)}),a.forEach(function(e){e in n._channelGroups&&(n._channelGroups[e].state=r)}),this._setStateEndpoint({state:r,channels:o,channelGroups:a},t)}},{key:"adaptPresenceChange",value:function(e){var t=this,n=e.connected,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o;n?(i.forEach(function(e){t._heartbeatChannels[e]={state:{}}}),s.forEach(function(e){t._heartbeatChannelGroups[e]={state:{}}})):(i.forEach(function(e){e in t._heartbeatChannels&&delete t._heartbeatChannels[e]}),s.forEach(function(e){e in t._heartbeatChannelGroups&&delete t._heartbeatChannelGroups[e]}),!1===this._config.suppressLeaveEvents&&this._leaveEndpoint({channels:i,channelGroups:s},function(e){t._listenerManager.announceStatus(e)})),this.reconnect()}},{key:"adaptSubscribeChange",value:function(e){var t=this,n=e.timetoken,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=e.withPresence,u=void 0!==a&&a,c=e.withHeartbeats,f=void 0!==c&&c;this._config.subscribeKey&&""!==this._config.subscribeKey?(n&&(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=n),"0"!==this._currentTimetoken&&0!==this._currentTimetoken&&(this._storedTimetoken=this._currentTimetoken,this._currentTimetoken=0),i.forEach(function(e){t._channels[e]={state:{}},u&&(t._presenceChannels[e]={}),(f||t._config.getHeartbeatInterval())&&(t._heartbeatChannels[e]={}),t._pendingChannelSubscriptions.push(e)}),s.forEach(function(e){t._channelGroups[e]={state:{}},u&&(t._presenceChannelGroups[e]={}),(f||t._config.getHeartbeatInterval())&&(t._heartbeatChannelGroups[e]={}),t._pendingChannelGroupSubscriptions.push(e)}),this._subscriptionStatusAnnounced=!1,this.reconnect()):console&&console.log&&console.log("subscribe key missing; aborting subscribe")}},{key:"adaptUnsubscribeChange",value:function(e,t){var n=this,r=e.channels,i=void 0===r?[]:r,o=e.channelGroups,s=void 0===o?[]:o,a=[],u=[];i.forEach(function(e){e in n._channels&&(delete n._channels[e],a.push(e),e in n._heartbeatChannels&&delete n._heartbeatChannels[e]),e in n._presenceChannels&&(delete n._presenceChannels[e],a.push(e))}),s.forEach(function(e){e in n._channelGroups&&(delete n._channelGroups[e],u.push(e),e in n._heartbeatChannelGroups&&delete n._heartbeatChannelGroups[e]),e in n._presenceChannelGroups&&(delete n._channelGroups[e],u.push(e))}),0===a.length&&0===u.length||(!1!==this._config.suppressLeaveEvents||t||this._leaveEndpoint({channels:a,channelGroups:u},function(e){e.affectedChannels=a,e.affectedChannelGroups=u,e.currentTimetoken=n._currentTimetoken,e.lastTimetoken=n._lastTimetoken,n._listenerManager.announceStatus(e)}),0===Object.keys(this._channels).length&&0===Object.keys(this._presenceChannels).length&&0===Object.keys(this._channelGroups).length&&0===Object.keys(this._presenceChannelGroups).length&&(this._lastTimetoken=0,this._currentTimetoken=0,this._storedTimetoken=null,this._region=null,this._reconnectionManager.stopPolling()),this.reconnect())}},{key:"unsubscribeAll",value:function(e){this.adaptUnsubscribeChange({channels:this.getSubscribedChannels(),channelGroups:this.getSubscribedChannelGroups()},e)}},{key:"getHeartbeatChannels",value:function(){return Object.keys(this._heartbeatChannels)}},{key:"getHeartbeatChannelGroups",value:function(){return Object.keys(this._heartbeatChannelGroups)}},{key:"getSubscribedChannels",value:function(){return Object.keys(this._channels)}},{key:"getSubscribedChannelGroups",value:function(){return Object.keys(this._channelGroups)}},{key:"reconnect",value:function(){this._startSubscribeLoop(),this._registerHeartbeatTimer()}},{key:"disconnect",value:function(){this._stopSubscribeLoop(),this._stopHeartbeatTimer(),this._reconnectionManager.stopPolling()}},{key:"_registerHeartbeatTimer",value:function(){this._stopHeartbeatTimer(),0!==this._config.getHeartbeatInterval()&&(this._performHeartbeatLoop(),this._heartbeatTimer=setInterval(this._performHeartbeatLoop.bind(this),1e3*this._config.getHeartbeatInterval()))}},{key:"_stopHeartbeatTimer",value:function(){this._heartbeatTimer&&(clearInterval(this._heartbeatTimer),this._heartbeatTimer=null)}},{key:"_performHeartbeatLoop",value:function(){var n=this,e=this.getHeartbeatChannels(),t=this.getHeartbeatChannelGroups(),r={};0===e.length&&0===t.length||(this.getSubscribedChannels().forEach(function(e){var t=n._channels[e].state;Object.keys(t).length&&(r[e]=t)}),this.getSubscribedChannelGroups().forEach(function(e){var t=n._channelGroups[e].state;Object.keys(t).length&&(r[e]=t)}),this._heartbeatEndpoint({channels:e,channelGroups:t,state:r},function(e){e.error&&n._config.announceFailedHeartbeats&&n._listenerManager.announceStatus(e),e.error&&n._config.autoNetworkDetection&&n._isOnline&&(n._isOnline=!1,n.disconnect(),n._listenerManager.announceNetworkDown(),n.reconnect()),!e.error&&n._config.announceSuccessfulHeartbeats&&n._listenerManager.announceStatus(e)}.bind(this)))}},{key:"_startSubscribeLoop",value:function(){var n=this;this._stopSubscribeLoop();var r={},i=[],o=[];if(Object.keys(this._channels).forEach(function(e){var t=n._channels[e].state;Object.keys(t).length&&(r[e]=t),i.push(e)}),Object.keys(this._presenceChannels).forEach(function(e){i.push("".concat(e,"-pnpres"))}),Object.keys(this._channelGroups).forEach(function(e){var t=n._channelGroups[e].state;Object.keys(t).length&&(r[e]=t),o.push(e)}),Object.keys(this._presenceChannelGroups).forEach(function(e){o.push("".concat(e,"-pnpres"))}),0!==i.length||0!==o.length){var e={channels:i,channelGroups:o,state:r,timetoken:this._currentTimetoken,filterExpression:this._config.filterExpression,region:this._region};this._subscribeCall=this._subscribeEndpoint(e,this._processSubscribeResponse.bind(this))}}},{key:"_processSubscribeResponse",value:function(t,e){var c=this;if(t.error)t.category===a.default.PNTimeoutCategory?this._startSubscribeLoop():(t.category===a.default.PNNetworkIssuesCategory?(this.disconnect(),t.error&&this._config.autoNetworkDetection&&this._isOnline&&(this._isOnline=!1,this._listenerManager.announceNetworkDown()),this._reconnectionManager.onReconnection(function(){c._config.autoNetworkDetection&&!c._isOnline&&(c._isOnline=!0,c._listenerManager.announceNetworkUp()),c.reconnect(),c._subscriptionStatusAnnounced=!0;var e={category:a.default.PNReconnectedCategory,operation:t.operation,lastTimetoken:c._lastTimetoken,currentTimetoken:c._currentTimetoken};c._listenerManager.announceStatus(e)}),this._reconnectionManager.startPolling()):t.category===a.default.PNBadRequestCategory&&this._stopHeartbeatTimer(),this._listenerManager.announceStatus(t));else{if(this._storedTimetoken?(this._currentTimetoken=this._storedTimetoken,this._storedTimetoken=null):(this._lastTimetoken=this._currentTimetoken,this._currentTimetoken=e.metadata.timetoken),!this._subscriptionStatusAnnounced){var n={};n.category=a.default.PNConnectedCategory,n.operation=t.operation,n.affectedChannels=this._pendingChannelSubscriptions,n.subscribedChannels=this.getSubscribedChannels(),n.affectedChannelGroups=this._pendingChannelGroupSubscriptions,n.lastTimetoken=this._lastTimetoken,n.currentTimetoken=this._currentTimetoken,this._subscriptionStatusAnnounced=!0,this._listenerManager.announceStatus(n),this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[]}var r=e.messages||[],i=this._config,o=i.requestMessageCountThreshold,f=i.dedupeOnSubscribe;if(o&&r.length>=o){var s={};s.category=a.default.PNRequestMessageCountExceededCategory,s.operation=t.operation,this._listenerManager.announceStatus(s)}r.forEach(function(e){var t=e.channel,n=e.subscriptionMatch,r=e.publishMetaData;if(t===n&&(n=null),f){if(c._dedupingManager.isDuplicate(e))return;c._dedupingManager.addEntry(e)}if(l.default.endsWith(e.channel,"-pnpres")){var i={channel:null,subscription:null};i.actualChannel=null!=n?t:null,i.subscribedChannel=null!=n?n:t,t&&(i.channel=t.substring(0,t.lastIndexOf("-pnpres"))),n&&(i.subscription=n.substring(0,n.lastIndexOf("-pnpres"))),i.action=e.payload.action,i.state=e.payload.data,i.timetoken=r.publishTimetoken,i.occupancy=e.payload.occupancy,i.uuid=e.payload.uuid,i.timestamp=e.payload.timestamp,e.payload.join&&(i.join=e.payload.join),e.payload.leave&&(i.leave=e.payload.leave),e.payload.timeout&&(i.timeout=e.payload.timeout),c._listenerManager.announcePresence(i)}else if(1===e.messageType){var o={channel:null,subscription:null};o.channel=t,o.subscription=n,o.timetoken=r.publishTimetoken,o.publisher=e.issuingClientId,e.userMetadata&&(o.userMetadata=e.userMetadata),o.message=e.payload,c._listenerManager.announceSignal(o)}else if(2===e.messageType){var s={channel:null,subscription:null};s.channel=t,s.subscription=n,s.timetoken=r.publishTimetoken,s.publisher=e.issuingClientId,e.userMetadata&&(s.userMetadata=e.userMetadata),s.message={event:e.payload.event,type:e.payload.type,data:e.payload.data},"user"===e.payload.type?c._listenerManager.announceUser(s):"space"===e.payload.type?c._listenerManager.announceSpace(s):"membership"===e.payload.type&&c._listenerManager.announceMembership(s)}else if(3===e.messageType){var a={};a.channel=t,a.subscription=n,a.timetoken=r.publishTimetoken,a.publisher=e.issuingClientId,a.data={messageTimetoken:e.payload.data.messageTimetoken,actionTimetoken:e.payload.data.actionTimetoken,type:e.payload.data.type,uuid:e.issuingClientId,value:e.payload.data.value},a.event=e.payload.event,c._listenerManager.announceMessageAction(a)}else{var u={channel:null,subscription:null};u.actualChannel=null!=n?t:null,u.subscribedChannel=null!=n?n:t,u.channel=t,u.subscription=n,u.timetoken=r.publishTimetoken,u.publisher=e.issuingClientId,e.userMetadata&&(u.userMetadata=e.userMetadata),c._config.cipherKey?u.message=c._crypto.decrypt(e.payload):u.message=e.payload,c._listenerManager.announceMessage(u)}}),this._region=e.metadata.region,this._startSubscribeLoop()}}},{key:"_stopSubscribeLoop",value:function(){this._subscribeCall&&("function"==typeof this._subscribeCall.abort&&this._subscribeCall.abort(),this._subscribeCall=null)}}])&&i(o.prototype,s),void(u&&i(o,u)),d);function d(e){var t=e.subscribeEndpoint,n=e.leaveEndpoint,r=e.heartbeatEndpoint,i=e.setStateEndpoint,o=e.timeEndpoint,s=e.config,a=e.crypto,u=e.listenerManager;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,d),h(this,"_crypto",void 0),h(this,"_config",void 0),h(this,"_listenerManager",void 0),h(this,"_reconnectionManager",void 0),h(this,"_leaveEndpoint",void 0),h(this,"_heartbeatEndpoint",void 0),h(this,"_setStateEndpoint",void 0),h(this,"_subscribeEndpoint",void 0),h(this,"_channels",void 0),h(this,"_presenceChannels",void 0),h(this,"_heartbeatChannels",void 0),h(this,"_heartbeatChannelGroups",void 0),h(this,"_channelGroups",void 0),h(this,"_presenceChannelGroups",void 0),h(this,"_currentTimetoken",void 0),h(this,"_lastTimetoken",void 0),h(this,"_storedTimetoken",void 0),h(this,"_region",void 0),h(this,"_subscribeCall",void 0),h(this,"_heartbeatTimer",void 0),h(this,"_subscriptionStatusAnnounced",void 0),h(this,"_autoNetworkDetection",void 0),h(this,"_isOnline",void 0),h(this,"_pendingChannelSubscriptions",void 0),h(this,"_pendingChannelGroupSubscriptions",void 0),h(this,"_dedupingManager",void 0),this._listenerManager=u,this._config=s,this._leaveEndpoint=n,this._heartbeatEndpoint=r,this._setStateEndpoint=i,this._subscribeEndpoint=t,this._crypto=a,this._channels={},this._presenceChannels={},this._heartbeatChannels={},this._heartbeatChannelGroups={},this._channelGroups={},this._presenceChannelGroups={},this._pendingChannelSubscriptions=[],this._pendingChannelGroupSubscriptions=[],this._currentTimetoken=0,this._lastTimetoken=0,this._storedTimetoken=null,this._subscriptionStatusAnnounced=!1,this._isOnline=!0,this._reconnectionManager=new c.default({timeEndpoint:o}),this._dedupingManager=new f.default({config:s})}t.default=p,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(8))&&r.__esModule,n(0);function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,u,c=(s=f,(a=[{key:"onReconnection",value:function(e){this._reconnectionCallback=e}},{key:"startPolling",value:function(){this._timeTimer=setInterval(this._performTimeLoop.bind(this),3e3)}},{key:"stopPolling",value:function(){clearInterval(this._timeTimer)}},{key:"_performTimeLoop",value:function(){var t=this;this._timeEndpoint(function(e){e.error||(clearInterval(t._timeTimer),t._reconnectionCallback())})}}])&&i(s.prototype,a),void(u&&i(s,u)),f);function f(e){var t=e.timeEndpoint;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),o(this,"_reconnectionCallback",void 0),o(this,"_timeEndpoint",void 0),o(this,"_timeTimer",void 0),this._timeEndpoint=t}t.default=c,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(3))&&r.__esModule,n(0);function i(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var s,a,u,c=(s=f,(a=[{key:"getKey",value:function(e){var t=function(e){var t=0;if(0===e.length)return t;for(var n=0;n<e.length;n+=1)t=(t<<5)-t+e.charCodeAt(n),t&=t;return t}(JSON.stringify(e.payload)).toString(),n=e.publishMetaData.publishTimetoken;return"".concat(n,"-").concat(t)}},{key:"isDuplicate",value:function(e){return this.hashHistory.includes(this.getKey(e))}},{key:"addEntry",value:function(e){this.hashHistory.length>=this._config.maximumCacheSize&&this.hashHistory.shift(),this.hashHistory.push(this.getKey(e))}},{key:"clearHistory",value:function(){this.hashHistory=[]}}])&&i(s.prototype,a),void(u&&i(s,u)),f);function f(e){var t=e.config;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),o(this,"_config",void 0),o(this,"hashHistory",void 0),this.hashHistory=[],this._config=t}t.default=c,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.FCMNotificationPayload=t.MPNSNotificationPayload=t.APNSNotificationPayload=void 0;n(0);function r(e){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function i(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],0<=t.indexOf(n)||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],0<=t.indexOf(n)||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter(function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable})),n.push.apply(n,r)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach(function(e){g(t,e,n[e])}):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach(function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))})}return t}function a(e,t){return!t||"object"!==r(t)&&"function"!=typeof t?c(e):t}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function f(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&l(e,t)}function l(e,t){return(l=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function h(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function p(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function d(e,t,n){return t&&p(e.prototype,t),n&&p(e,n),e}function g(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var y=(d(v,[{key:"payload",get:function(){return this._payload}},{key:"title",set:function(e){this._title=e}},{key:"subtitle",set:function(e){this._subtitle=e}},{key:"body",set:function(e){this._body=e}},{key:"badge",set:function(e){this._badge=e}},{key:"sound",set:function(e){this._sound=e}}]),d(v,[{key:"_setDefaultPayloadStructure",value:function(){}},{key:"toObject",value:function(){return{}}}]),v);function v(e,t,n){h(this,v),g(this,"_subtitle",void 0),g(this,"_payload",void 0),g(this,"_badge",void 0),g(this,"_sound",void 0),g(this,"_title",void 0),g(this,"_body",void 0),this._payload=e,this._setDefaultPayloadStructure(),this.title=t,this.body=n}var b=(f(m,y),d(m,[{key:"_setDefaultPayloadStructure",value:function(){this._payload.aps={alert:{}}}},{key:"toObject",value:function(){var t=this,e=s({},this._payload),n=e.aps,r=n.alert;if(this._isSilent&&(n["content-available"]=1),"apns2"===this._apnsPushType){if(!this._configurations||!this._configurations.length)throw new ReferenceError("APNS2 configuration is missing");var i=[];this._configurations.forEach(function(e){i.push(t._objectFromAPNS2Configuration(e))}),i.length&&(e.pn_push=i)}return r&&Object.keys(r).length||delete n.alert,this._isSilent&&(delete n.alert,delete n.badge,delete n.sound,r={}),this._isSilent||Object.keys(r).length?e:null}},{key:"_objectFromAPNS2Configuration",value:function(e){var t=this;if(!e.targets||!e.targets.length)throw new ReferenceError("At least one APNS2 target should be provided");var n=[];e.targets.forEach(function(e){n.push(t._objectFromAPNSTarget(e))});var r=e.collapseId,i=e.expirationDate,o={auth_method:"token",targets:n,version:"v2"};return r&&r.length&&(o.collapse_id=r),i&&(o.expiration=i.toISOString()),o}},{key:"_objectFromAPNSTarget",value:function(e){if(!e.topic||!e.topic.length)throw new TypeError("Target 'topic' undefined.");var t=e.topic,n=e.environment,r=void 0===n?"development":n,i=e.excludedDevices,o=void 0===i?[]:i,s={topic:t,environment:r};return o.length&&(s.excluded_devices=o),s}},{key:"configurations",set:function(e){e&&e.length&&(this._configurations=e)}},{key:"notification",get:function(){return this._payload.aps}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.aps.alert.title=e,this._title=e)}},{key:"subtitle",get:function(){return this._subtitle},set:function(e){e&&e.length&&(this._payload.aps.alert.subtitle=e,this._subtitle=e)}},{key:"body",get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.aps.alert.body=e,this._body=e)}},{key:"badge",get:function(){return this._badge},set:function(e){null!=e&&(this._payload.aps.badge=e,this._badge=e)}},{key:"sound",get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.aps.sound=e,this._sound=e)}},{key:"silent",set:function(e){this._isSilent=e}}]),m);function m(){var e,t;h(this,m);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(m)).call.apply(e,[this].concat(r)))),"_configurations",void 0),g(c(t),"_apnsPushType",void 0),g(c(t),"_isSilent",void 0),t}t.APNSNotificationPayload=b;var _=(f(k,y),d(k,[{key:"toObject",value:function(){return Object.keys(this._payload).length?s({},this._payload):null}},{key:"backContent",get:function(){return this._backContent},set:function(e){e&&e.length&&(this._payload.back_content=e,this._backContent=e)}},{key:"backTitle",get:function(){return this._backTitle},set:function(e){e&&e.length&&(this._payload.back_title=e,this._backTitle=e)}},{key:"count",get:function(){return this._count},set:function(e){null!=e&&(this._payload.count=e,this._count=e)}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.title=e,this._title=e)}},{key:"type",get:function(){return this._type},set:function(e){e&&e.length&&(this._payload.type=e,this._type=e)}},{key:"subtitle",get:function(){return this.backTitle},set:function(e){this.backTitle=e}},{key:"body",get:function(){return this.backContent},set:function(e){this.backContent=e}},{key:"badge",get:function(){return this.count},set:function(e){this.count=e}}]),k);function k(){var e,t;h(this,k);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(k)).call.apply(e,[this].concat(r)))),"_backContent",void 0),g(c(t),"_backTitle",void 0),g(c(t),"_count",void 0),g(c(t),"_type",void 0),t}t.MPNSNotificationPayload=_;var P=(f(w,y),d(w,[{key:"_setDefaultPayloadStructure",value:function(){this._payload.notification={},this._payload.data={}}},{key:"toObject",value:function(){var e=s({},this._payload.data),t=null,n={};if(2<Object.keys(this._payload).length){var r=this._payload;r.notification,r.data,e=s({},e,{},i(r,["notification","data"]))}return this._isSilent?e.notification=this._payload.notification:t=this._payload.notification,Object.keys(e).length&&(n.data=e),t&&Object.keys(t).length&&(n.notification=t),Object.keys(n).length?n:null}},{key:"notification",get:function(){return this._payload.notification}},{key:"data",get:function(){return this._payload.data}},{key:"title",get:function(){return this._title},set:function(e){e&&e.length&&(this._payload.notification.title=e,this._title=e)}},{key:"body",get:function(){return this._body},set:function(e){e&&e.length&&(this._payload.notification.body=e,this._body=e)}},{key:"sound",get:function(){return this._sound},set:function(e){e&&e.length&&(this._payload.notification.sound=e,this._sound=e)}},{key:"icon",get:function(){return this._icon},set:function(e){e&&e.length&&(this._payload.notification.icon=e,this._icon=e)}},{key:"tag",get:function(){return this._tag},set:function(e){e&&e.length&&(this._payload.notification.tag=e,this._tag=e)}},{key:"silent",set:function(e){this._isSilent=e}}]),w);function w(){var e,t;h(this,w);for(var n=arguments.length,r=new Array(n),i=0;i<n;i++)r[i]=arguments[i];return g(c(t=a(this,(e=u(w)).call.apply(e,[this].concat(r)))),"_isSilent",void 0),g(c(t),"_icon",void 0),g(c(t),"_tag",void 0),t}function T(e,t){h(this,T),g(this,"_payload",void 0),g(this,"_debugging",void 0),g(this,"_subtitle",void 0),g(this,"_badge",void 0),g(this,"_sound",void 0),g(this,"_title",void 0),g(this,"_body",void 0),g(this,"apns",void 0),g(this,"mpns",void 0),g(this,"fcm",void 0),this._payload={apns:{},mpns:{},fcm:{}},this._title=e,this._body=t,this.apns=new b(this._payload.apns,e,t),this.mpns=new _(this._payload.mpns,e,t),this.fcm=new P(this._payload.fcm,e,t)}t.FCMNotificationPayload=P;var O=(d(T,[{key:"debugging",set:function(e){this._debugging=e}},{key:"title",get:function(){return this._title}},{key:"body",get:function(){return this._body}},{key:"subtitle",get:function(){return this._subtitle},set:function(e){this._subtitle=e,this.apns.subtitle=e,this.mpns.subtitle=e,this.fcm.subtitle=e}},{key:"badge",get:function(){return this._badge},set:function(e){this._badge=e,this.apns.badge=e,this.mpns.badge=e,this.fcm.badge=e}},{key:"sound",get:function(){return this._sound},set:function(e){this._sound=e,this.apns.sound=e,this.mpns.sound=e,this.fcm.sound=e}}]),d(T,[{key:"buildPayload",value:function(e){var t={};if(e.includes("apns")||e.includes("apns2")){this.apns._apnsPushType=e.includes("apns")?"apns":"apns2";var n=this.apns.toObject();n&&Object.keys(n).length&&(t.pn_apns=n)}if(e.includes("mpns")){var r=this.mpns.toObject();r&&Object.keys(r).length&&(t.pn_mpns=r)}if(e.includes("fcm")){var i=this.fcm.toObject();i&&Object.keys(i).length&&(t.pn_gcm=i)}return Object.keys(t).length&&this._debugging&&(t.pn_debug=!0),t}}]),T);t.default=O},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r;(r=n(3))&&r.__esModule,n(0);function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,c,f=(a=l,(u=[{key:"_initializeTokens",value:function(){this._userTokens={},this._spaceTokens={},this._userToken=void 0,this._spaceToken=void 0}},{key:"_setToken",value:function(t){var n=this,e=this.parseToken(t);e&&e.resources&&(e.resources.users&&Object.keys(e.resources.users).forEach(function(e){n._userTokens[e]=t}),e.resources.spaces&&Object.keys(e.resources.spaces).forEach(function(e){n._spaceTokens[e]=t})),e&&e.patterns&&(e.patterns.users&&0<Object.keys(e.patterns.users).length&&(this._userToken=t),e.patterns.spaces&&0<Object.keys(e.patterns.spaces).length&&(this._spaceToken=t))}},{key:"setToken",value:function(e){e&&0<e.length&&this._setToken(e)}},{key:"setTokens",value:function(e){var t=this;e&&e.length&&"object"===i(e)&&e.forEach(function(e){t.setToken(e)})}},{key:"getTokens",value:function(e){var t=this,n={users:{},spaces:{}};return e?(e.user&&(n.user=this._userToken),e.space&&(n.space=this._spaceToken),e.users&&e.users.forEach(function(e){n.users[e]=t._userTokens[e]}),e.space&&e.spaces.forEach(function(e){n.spaces[e]=t._spaceTokens[e]})):(this._userToken&&(n.user=this._userToken),this._spaceToken&&(n.space=this._spaceToken),Object.keys(this._userTokens).forEach(function(e){n.users[e]=t._userTokens[e]}),Object.keys(this._spaceTokens).forEach(function(e){n.spaces[e]=t._spaceTokens[e]})),n}},{key:"getToken",value:function(e,t){var n;return t?"user"===e?n=this._userTokens[t]:"space"===e&&(n=this._spaceTokens[t]):"user"===e?n=this._userToken:"space"===e&&(n=this._spaceToken),n}},{key:"extractPermissions",value:function(e){var t={create:!1,read:!1,write:!1,manage:!1,delete:!1};return 16==(16&e)&&(t.create=!0),8==(8&e)&&(t.delete=!0),4==(4&e)&&(t.manage=!0),2==(2&e)&&(t.write=!0),1==(1&e)&&(t.read=!0),t}},{key:"parseToken",value:function(e){var t=this,n=this._cbor.decodeToken(e);if(void 0!==n){var r=Object.keys(n.res.usr),i=Object.keys(n.res.spc),o=Object.keys(n.pat.usr),s=Object.keys(n.pat.spc),a={version:n.v,timestamp:n.t,ttl:n.ttl},u=0<r.length,c=0<i.length;(u||c)&&(a.resources={},u&&(a.resources.users={},r.forEach(function(e){a.resources.users[e]=t.extractPermissions(n.res.usr[e])})),c&&(a.resources.spaces={},i.forEach(function(e){a.resources.spaces[e]=t.extractPermissions(n.res.spc[e])})));var f=0<o.length,l=0<s.length;return(f||l)&&(a.patterns={},f&&(a.patterns.users={},o.forEach(function(e){a.patterns.users[e]=t.extractPermissions(n.pat.usr[e])})),l&&(a.patterns.spaces={},s.forEach(function(e){a.patterns.spaces[e]=t.extractPermissions(n.pat.spc[e])}))),0<Object.keys(n.meta).length&&(a.meta=n.meta),a.signature=n.sig,a}}},{key:"clearTokens",value:function(){this._initializeTokens()}}])&&o(a.prototype,u),void(c&&o(a,c)),l);function l(e,t){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_config",void 0),s(this,"_cbor",void 0),s(this,"_userTokens",void 0),s(this,"_spaceTokens",void 0),s(this,"_userToken",void 0),s(this,"_spaceToken",void 0),this._config=e,this._cbor=t,this._initializeTokens()}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(r,i){var e=r.networking,t=r.config,o=null,s=null,a={};o=i.getOperation()===b.default.PNTimeOperation||i.getOperation()===b.default.PNChannelGroupsOperation?arguments.length<=2?void 0:arguments[2]:(a=arguments.length<=2?void 0:arguments[2],arguments.length<=3?void 0:arguments[3]);"undefined"==typeof Promise||o||(s=v.default.createPromise());var n=i.validateParams(r,a);if(n)return o?o(_(n)):s?(s.reject(new m("Validation failed, check status for details",_(n))),s.promise):void 0;var u,c=i.prepareParams(r,a),f=function(e,t,n){return e.usePost&&e.usePost(t,n)?e.postURL(t,n):e.usePatch&&e.usePatch(t,n)?e.patchURL(t,n):e.getURL(t,n)}(i,r,a),l={url:f,operation:i.getOperation(),timeout:i.getRequestTimeout(r),headers:i.getRequestHeaders?i.getRequestHeaders():{}};c.uuid=t.UUID,c.pnsdk=function(e){if(e.sdkName)return e.sdkName;var t="PubNub-JS-".concat(e.sdkFamily);e.partnerId&&(t+="-".concat(e.partnerId));t+="/".concat(e.getVersion());var n=e._getPnsdkSuffix(" ");0<n.length&&(t+=n);return t}(t),t.useInstanceId&&(c.instanceid=t.instanceId);t.useRequestId&&(c.requestid=y.default.createUUID());if(i.isAuthSupported()){var h=function(e,t,n){var r;e.getAuthToken&&(r=e.getAuthToken(t,n));return r}(i,r,a)||t.getAuthKey();h&&(c.auth=h)}t.secretKey&&function(e,t,n,r,i){var o=e.config,s=e.crypto,a=k(e,i,r);n.timestamp=Math.floor((new Date).getTime()/1e3);var u="".concat(a,"\n").concat(o.publishKey,"\n").concat(t,"\n").concat(v.default.signPamFromParams(n),"\n");if("POST"===a){var c=i.postPayload(e,r);u+="string"==typeof c?c:JSON.stringify(c)}else if("PATCH"===a){var f=i.patchPayload(e,r);u+="string"==typeof f?f:JSON.stringify(f)}var l="v2.".concat(s.HMACSHA256(u));l=(l=(l=l.replace(/\+/g,"-")).replace(/\//g,"_")).replace(/=+$/,""),n.signature=l}(r,f,c,a,i);function p(e,t){if(e.error)o?o(e):s&&s.reject(new m("PubNub call failed, check status for details",e));else{var n=i.handleResponse(r,t,a);o?o(e,n):s&&s.fulfill(n)}}if("POST"===k(r,i,a)){var d=i.postPayload(r,a);u=e.POST(c,d,l,p)}else if("PATCH"===k(r,i,a)){var g=i.patchPayload(r,a);u=e.PATCH(c,g,l,p)}else u="DELETE"===k(r,i,a)?e.DELETE(c,l,p):e.GET(c,l,p);if(i.getOperation()===b.default.PNSubscribeOperation)return u;if(s)return s.promise};var y=r(n(5)),v=(n(0),r(n(2))),b=(r(n(3)),r(n(1)));function r(e){return e&&e.__esModule?e:{default:e}}function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){return!t||"object"!==i(t)&&"function"!=typeof t?function(e){if(void 0!==e)return e;throw new ReferenceError("this hasn't been initialised - super() hasn't been called")}(e):t}function s(e){var n="function"==typeof Map?new Map:void 0;return(s=function(e){if(null===e||!function(e){return-1!==Function.toString.call(e).indexOf("[native code]")}(e))return e;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==n){if(n.has(e))return n.get(e);n.set(e,t)}function t(){return a(e,arguments,c(this).constructor)}return t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),u(t,e)})(e)}function a(e,t,n){return(a=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(e){return!1}}()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var i=new(Function.bind.apply(e,r));return n&&u(i,n.prototype),i}).apply(null,arguments)}function u(e,t){return(u=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function c(e){return(c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}var m=(function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&u(e,t)}(f,s(Error)),f);function f(e,t){var n;return function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,f),(n=o(this,c(f).call(this,e))).name=n.constructor.name,n.status=t,n.message=e,n}function _(e){return function(e,t){return e.type=t,e.error=!0,e}({message:e},"validationError")}function k(e,t,n){return t.usePost&&t.usePost(e,n)?"POST":t.usePatch&&t.usePatch(e,n)?"PATCH":t.useDelete&&t.useDelete(e,n)?"DELETE":"GET"}e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNAddChannelsToGroupOperation},t.validateParams=function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;if(!r)return"Missing Channel Group";if(!n||0===n.length)return"Missing Channels";if(!i.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channels;return{add:(void 0===n?[]:n).join(",")}},t.handleResponse=function(){return{}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNRemoveChannelsFromGroupOperation},t.validateParams=function(e,t){var n=t.channels,r=t.channelGroup,i=e.config;if(!r)return"Missing Channel Group";if(!n||0===n.length)return"Missing Channels";if(!i.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channels;return{remove:(void 0===n?[]:n).join(",")}},t.handleResponse=function(){return{}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNRemoveGroupOperation},t.validateParams=function(e,t){var n=t.channelGroup,r=e.config;if(!n)return"Missing Channel Group";if(!r.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n),"/remove")},t.isAuthSupported=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(){return{}},t.handleResponse=function(){return{}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNChannelGroupsOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e){var t=e.config;return"/v1/channel-registration/sub-key/".concat(t.subscribeKey,"/channel-group")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{groups:t.payload.groups}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNChannelsForGroupOperation},t.validateParams=function(e,t){var n=t.channelGroup,r=e.config;if(!n)return"Missing Channel Group";if(!r.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channelGroup,r=e.config;return"/v1/channel-registration/sub-key/".concat(r.subscribeKey,"/channel-group/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{channels:t.payload.channels}};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!o)return"Missing APNS2 topic";if(!i||0===i.length)return"Missing Channels";if(!s.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.channels,i=void 0===r?[]:r,o=t.environment,s=void 0===o?"development":o,a=t.topic,u={type:n,add:i.join(",")};"apns2"===n&&delete(u=Object.assign({},u,{environment:s,topic:a})).type;return u},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.channels,o=t.topic,s=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!o)return"Missing APNS2 topic";if(!i||0===i.length)return"Missing Channels";if(!s.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.channels,i=void 0===r?[]:r,o=t.environment,s=void 0===o?"development":o,a=t.topic,u={type:n,remove:i.join(",")};"apns2"===n&&delete(u=Object.assign({},u,{environment:s,topic:a})).type;return u},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNPushNotificationEnabledChannelsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!i)return"Missing APNS2 topic";if(!o.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.environment,i=void 0===r?"development":r,o=t.topic,s={type:n};"apns2"===n&&delete(s=Object.assign({},s,{environment:i,topic:o})).type;return s},t.handleResponse=function(e,t){return{channels:t}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNRemoveAllPushNotificationsOperation},t.validateParams=function(e,t){var n=t.device,r=t.pushGateway,i=t.topic,o=e.config;if(!n)return"Missing Device ID (device)";if(!r)return"Missing GW Type (pushGateway: gcm, apns or apns2)";if("apns2"===r&&!i)return"Missing APNS2 topic";if(!o.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.device,r=t.pushGateway,i=e.config;return"apns2"!==r?"/v1/push/sub-key/".concat(i.subscribeKey,"/devices/").concat(n,"/remove"):"/v2/push/sub-key/".concat(i.subscribeKey,"/devices-apns2/").concat(n,"/remove")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.pushGateway,r=t.environment,i=void 0===r?"development":r,o=t.topic,s={type:n};"apns2"===n&&delete(s=Object.assign({},s,{environment:i,topic:o})).type;return s},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNUnsubscribeOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/leave")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};0<r.length&&(i["channel-group"]=r.join(","));return i},t.handleResponse=function(){return{}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNWhereNowOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r;return"/v2/presence/sub-key/".concat(n.subscribeKey,"/uuid/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return t.payload?{channels:t.payload.channels}:{channels:[]}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHeartbeatOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/heartbeat")},t.isAuthSupported=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.state,o=void 0===i?{}:i,s=e.config,a={};0<r.length&&(a["channel-group"]=r.join(","));return a.state=JSON.stringify(o),a.heartbeat=s.getPresenceTimeout(),a},t.handleResponse=function(){return{}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNGetStateOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.uuid,i=void 0===r?n.UUID:r,o=t.channels,s=void 0===o?[]:o,a=0<s.length?s.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(u.default.encodeString(a),"/uuid/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i={};0<r.length&&(i["channel-group"]=r.join(","));return i},t.handleResponse=function(e,t,n){var r=n.channels,i=void 0===r?[]:r,o=n.channelGroups,s=void 0===o?[]:o,a={};1===i.length&&0===s.length?a[i[0]]=t.payload:a=t.payload;return{channels:a}};n(0);var r=i(n(1)),u=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSetStateOperation},t.validateParams=function(e,t){var n=e.config,r=t.state,i=t.channels,o=void 0===i?[]:i,s=t.channelGroups,a=void 0===s?[]:s;if(!r)return"Missing State";if(!n.subscribeKey)return"Missing Subscribe Key";if(0===o.length&&0===a.length)return"Please provide a list of channels and/or channel-groups"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/presence/sub-key/".concat(n.subscribeKey,"/channel/").concat(s.default.encodeString(o),"/uuid/").concat(n.UUID,"/data")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.state,r=t.channelGroups,i=void 0===r?[]:r,o={};o.state=JSON.stringify(n),0<i.length&&(o["channel-group"]=i.join(","));return o},t.handleResponse=function(e,t){return{state:t.payload}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHereNowOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=t.channelGroups,s=void 0===o?[]:o,a="/v2/presence/sub-key/".concat(n.subscribeKey);if(0<i.length||0<s.length){var u=0<i.length?i.join(","):",";a+="/channel/".concat(c.default.encodeString(u))}return a},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.channelGroups,r=void 0===n?[]:n,i=t.includeUUIDs,o=void 0===i||i,s=t.includeState,a=void 0!==s&&s,u={};o||(u.disable_uuids=1);a&&(u.state=1);0<r.length&&(u["channel-group"]=r.join(","));return u},t.handleResponse=function(e,i,t){var n,r=t.channels,o=void 0===r?[]:r,s=t.channelGroups,a=void 0===s?[]:s,u=t.includeUUIDs,c=void 0===u||u,f=t.includeState,l=void 0!==f&&f;n=1<o.length||0<a.length||0===a.length&&0===o.length?function(){var r={};return r.totalChannels=i.payload.total_channels,r.totalOccupancy=i.payload.total_occupancy,r.channels={},Object.keys(i.payload.channels).forEach(function(e){var t=i.payload.channels[e],n=[];return r.channels[e]={occupants:n,name:e,occupancy:t.occupancy},c&&t.uuids.forEach(function(e){l?n.push({state:e.state,uuid:e.uuid}):n.push({state:null,uuid:e})}),r}),r}():function(){var e={},t=[];return e.totalChannels=1,e.totalOccupancy=i.occupancy,e.channels={},e.channels[o[0]]={occupants:t,name:o[0],occupancy:i.occupancy},c&&i.uuids&&i.uuids.forEach(function(e){l?t.push({state:e.state,uuid:e.uuid}):t.push({state:null,uuid:e})}),e}();return n};n(0);var r=i(n(1)),c=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAddMessageActionOperation},t.validateParams=function(e,t){var n=e.config,r=t.action,i=t.channel;if(!t.messageTimetoken)return"Missing message timetoken";if(!n.subscribeKey)return"Missing Subscribe Key";if(!i)return"Missing message channel";if(!r)return"Missing Action";if(!r.value)return"Missing Action.value";if(!r.type)return"Missing Action.type";if(15<r.type.length)return"Action.type value exceed maximum length of 15"},t.usePost=function(){return!0},t.postURL=function(e,t){var n=e.config,r=t.channel,i=t.messageTimetoken;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r,"/message/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.getRequestHeaders=function(){return{"Content-Type":"application/json"}},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.postPayload=function(e,t){return t.action},t.handleResponse=function(e,t){return{data:t.data}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNRemoveMessageActionOperation},t.validateParams=function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken;if(!t.messageTimetoken)return"Missing message timetoken";if(!i)return"Missing action timetoken";if(!n.subscribeKey)return"Missing Subscribe Key";if(!r)return"Missing message channel"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.actionTimetoken,o=t.messageTimetoken;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r,"/message/").concat(o,"/action/").concat(i)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{data:t.data}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMessageActionsOperation},t.validateParams=function(e,t){var n=e.config,r=t.channel;if(!n.subscribeKey)return"Missing Subscribe Key";if(!r)return"Missing message channel"},t.getURL=function(e,t){var n=e.config,r=t.channel;return"/v1/message-actions/".concat(n.subscribeKey,"/channel/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.limit,r=t.start,i=t.end,o={};n&&(o.limit=n);r&&(o.start=r);i&&(o.end=i);return o},t.handleResponse=function(e,t){var n={data:t.data,start:null,end:null};n.data.length&&(n.end=n.data[n.data.length-1].actionTimetoken,n.start=n.data[0].actionTimetoken);return n};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNCreateUserOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing User.id";if(!i)return"Missing User.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePost=function(){return!0},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/users")},t.postURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.id)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.postPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateUserOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing User.id";if(!i)return"Missing User.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePatch=function(){return!0},t.getURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(r)},t.patchURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.id)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.patchPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNDeleteUserOperation},t.validateParams=function(e,t){var n=e.config;if(!t)return"Missing UserId";if(!n.subscribeKey)return"Missing Subscribe Key"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t)||e.tokenManager.getToken("user")},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetUserOperation},t.validateParams=function(e,t){if(!t.userId)return"Missing userId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetUsersOperation},t.validateParams=function(){},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e){return e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNCreateSpaceOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing Space.id";if(!i)return"Missing Space.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePost=function(){return!0},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/spaces")},t.postURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.id)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.postPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateSpaceOperation},t.validateParams=function(e,t){var n=e.config,r=t.id,i=t.name,o=t.custom;if(!r)return"Missing Space.id";if(!i)return"Missing Space.name";if(!n.subscribeKey)return"Missing Subscribe Key";if(o&&!Object.values(o).every(function(e){return"string"==typeof e||"number"==typeof e||"boolean"==typeof e}))return"Invalid custom type, only string, number and boolean values are allowed."},t.usePatch=function(){return!0},t.getURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(r)},t.patchURL=function(e,t){var n=e.config,r=t.id;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(r)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.id)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.patchPayload=function(e,t){return function(e,t){return t}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNDeleteSpaceOperation},t.validateParams=function(e,t){var n=e.config;if(!t)return"Missing SpaceId";if(!n.subscribeKey)return"Missing Subscribe Key"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t)||e.tokenManager.getToken("space")},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetSpacesOperation},t.validateParams=function(){},t.getURL=function(e){var t=e.config;return"/v1/objects/".concat(t.subscribeKey,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e){return e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetSpaceOperation},t.validateParams=function(e,t){if(!t.spaceId)return"Missing spaceId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r={};n?void 0===n.customFields&&(n.customFields=!0):n={customFields:!0};if(n){var i=[];n.customFields&&i.push("custom");var o=i.join(",");0<o.length&&(r.include=o)}return r},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMembersOperation},t.validateParams=function(e,t){if(!t.spaceId)return"Missing spaceId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.userFields&&s.push("user"),n.customUserFields&&s.push("user.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return"Missing spaceId";if(!r)return"Missing users"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.users,r={};n&&0<n.length&&(r.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),r.add.push(t)}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return"Missing spaceId";if(!r)return"Missing users"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.addMembers,r=t.updateMembers,i=t.removeMembers,o=t.users,s={};n&&0<n.length&&(s.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.add.push(t)}));r&&0<r.length&&(s.update=[],r.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));o&&0<o.length&&(s.update=s.update||[],o.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));i&&0<i.length&&(s.remove=[],i.forEach(function(e){s.remove.push({id:e})}));return s}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembersOperation},t.validateParams=function(e,t){var n=t.spaceId,r=t.users;if(!n)return"Missing spaceId";if(!r)return"Missing users"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/spaces/").concat(t.spaceId,"/users")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("space",t.spaceId)||e.tokenManager.getToken("space")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.users,r={};n&&0<n.length&&(r.remove=[],n.forEach(function(e){r.remove.push({id:e})}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNGetMembershipsOperation},t.validateParams=function(e,t){if(!t.userId)return"Missing userId"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return"Missing userId";if(!r)return"Missing spaces"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.addMemberships,r=t.updateMemberships,i=t.removeMemberships,o=t.spaces,s={};n&&0<n.length&&(s.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.add.push(t)}));r&&0<r.length&&(s.update=[],r.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));o&&0<o.length&&(s.update=s.update||[],o.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),s.update.push(t)}));i&&0<i.length&&(s.remove=[],i.forEach(function(e){s.remove.push({id:e})}));return s}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return"Missing userId";if(!r)return"Missing spaces"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.spaces,r={};n&&0<n.length&&(r.add=[],n.forEach(function(e){var t={id:e.id};e.custom&&(t.custom=e.custom),r.add.push(t)}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNUpdateMembershipsOperation},t.validateParams=function(e,t){var n=t.userId,r=t.spaces;if(!n)return"Missing userId";if(!r)return"Missing spaces"},t.getURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.patchURL=function(e,t){var n=e.config;return"/v1/objects/".concat(n.subscribeKey,"/users/").concat(t.userId,"/spaces")},t.usePatch=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.getAuthToken=function(e,t){return e.tokenManager.getToken("user",t.userId)||e.tokenManager.getToken("user")},t.prepareParams=function(e,t){var n=t.include,r=t.limit,i=t.page,o={};r&&(o.limit=r);if(n){var s=[];n.totalCount&&(o.count=!0),n.customFields&&s.push("custom"),n.spaceFields&&s.push("space"),n.customSpaceFields&&s.push("space.custom");var a=s.join(",");0<a.length&&(o.include=a)}i&&(i.next&&(o.start=i.next),i.prev&&(o.end=i.prev));return o},t.patchPayload=function(e,t){return function(e,t){var n=t.spaces,r={};n&&0<n.length&&(r.remove=[],n.forEach(function(e){r.remove.push({id:e})}));return r}(0,t)},t.handleResponse=function(e,t){return t};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerAudit},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e){var t=e.config;return"/v2/auth/audit/sub-key/".concat(t.subscribeKey)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!1},t.prepareParams=function(e,t){var n=t.channel,r=t.channelGroup,i=t.authKeys,o=void 0===i?[]:i,s={};n&&(s.channel=n);r&&(s["channel-group"]=r);0<o.length&&(s.auth=o.join(","));return s},t.handleResponse=function(e,t){return t.payload};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerGrant},t.validateParams=function(e){var t=e.config;if(!t.subscribeKey)return"Missing Subscribe Key";if(!t.publishKey)return"Missing Publish Key";if(!t.secretKey)return"Missing Secret Key"},t.getURL=function(e){var t=e.config;return"/v2/auth/grant/sub-key/".concat(t.subscribeKey)},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!1},t.prepareParams=function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.channelGroups,o=void 0===i?[]:i,s=t.ttl,a=t.read,u=void 0!==a&&a,c=t.write,f=void 0!==c&&c,l=t.manage,h=void 0!==l&&l,p=t.authKeys,d=void 0===p?[]:p,g={};g.r=u?"1":"0",g.w=f?"1":"0",g.m=h?"1":"0",0<r.length&&(g.channel=r.join(","));0<o.length&&(g["channel-group"]=o.join(","));0<d.length&&(g.auth=d.join(","));!s&&0!==s||(g.ttl=s);return g},t.handleResponse=function(){return{}};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return i.default.PNAccessManagerGrantToken},t.extractPermissions=l,t.validateParams=function(e,t){var n=e.config;if(!n.subscribeKey)return"Missing Subscribe Key";if(!n.publishKey)return"Missing Publish Key";if(!n.secretKey)return"Missing Secret Key";if(!t.resources&&!t.patterns)return"Missing either Resources or Patterns.";if(t.resources&&(!t.resources.users||0===Object.keys(t.resources.users).length)&&(!t.resources.spaces||0===Object.keys(t.resources.spaces).length)||t.patterns&&(!t.patterns.users||0===Object.keys(t.patterns.users).length)&&(!t.patterns.spaces||0===Object.keys(t.patterns.spaces).length))return"Missing values for either Resources or Patterns."},t.postURL=function(e){var t=e.config;return"/v3/pam/".concat(t.subscribeKey,"/grant")},t.usePost=function(){return!0},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!1},t.prepareParams=function(){return{}},t.postPayload=function(e,t){return function(e,t){var n=t.ttl,r=t.resources,i=t.patterns,o=t.meta,s={ttl:0,permissions:{resources:{channels:{},groups:{},users:{},spaces:{}},patterns:{channels:{},groups:{},users:{},spaces:{}},meta:{}}};if(r){var a=r.users,u=r.spaces;a&&Object.keys(a).forEach(function(e){s.permissions.resources.users[e]=l(a[e])}),u&&Object.keys(u).forEach(function(e){s.permissions.resources.spaces[e]=l(u[e])})}if(i){var c=i.users,f=i.spaces;c&&Object.keys(c).forEach(function(e){s.permissions.patterns.users[e]=l(c[e])}),f&&Object.keys(f).forEach(function(e){s.permissions.patterns.spaces[e]=l(f[e])})}!n&&0!==n||(s.ttl=n);o&&(s.permissions.meta=o);return s}(0,t)},t.handleResponse=function(e,t){return t.data.token};n(0);var r,i=(r=n(1))&&r.__esModule?r:{default:r};function l(e){var t=0;return e.create&&(t|=16),e.delete&&(t|=8),e.manage&&(t|=4),e.write&&(t|=2),e.read&&(t|=1),t}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNPublishOperation},t.validateParams=function(e,t){var n=e.config,r=t.message;if(!t.channel)return"Missing Channel";if(!r)return"Missing Message";if(!n.subscribeKey)return"Missing Subscribe Key"},t.usePost=function(e,t){var n=t.sendByPost;return void 0!==n&&n},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.message,o=a(e,i);return"/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0/").concat(s.default.encodeString(o))},t.postURL=function(e,t){var n=e.config,r=t.channel;return"/publish/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0")},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.postPayload=function(e,t){var n=t.message;return a(e,n)},t.prepareParams=function(e,t){var n=t.meta,r=t.replicate,i=void 0===r||r,o=t.storeInHistory,s=t.ttl,a={};null!=o&&(a.store=o?"1":"0");s&&(a.ttl=s);!1===i&&(a.norep="true");n&&"object"===u(n)&&(a.meta=JSON.stringify(n));return a},t.handleResponse=function(e,t){return{timetoken:t[2]}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}function u(e){return(u="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function a(e,t){var n=e.crypto,r=e.config,i=JSON.stringify(t);return r.cipherKey&&(i=n.encrypt(i),i=JSON.stringify(i)),i}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSignalOperation},t.validateParams=function(e,t){var n=e.config,r=t.message;if(!t.channel)return"Missing Channel";if(!r)return"Missing Message";if(!n.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channel,i=t.message,o=function(e,t){return JSON.stringify(t)}(0,i);return"/signal/".concat(n.publishKey,"/").concat(n.subscribeKey,"/0/").concat(s.default.encodeString(r),"/0/").concat(s.default.encodeString(o))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(){return{}},t.handleResponse=function(e,t){return{timetoken:t[2]}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNHistoryOperation},t.validateParams=function(e,t){var n=t.channel,r=e.config;if(!n)return"Missing channel";if(!r.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channel,r=e.config;return"/v2/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i=t.reverse,o=t.count,s=void 0===o?100:o,a=t.stringifiedTimeToken,u=void 0!==a&&a,c=t.includeMeta,f=void 0!==c&&c,l={include_token:"true"};l.count=s,n&&(l.start=n);r&&(l.end=r);u&&(l.string_message_token="true");null!=i&&(l.reverse=i.toString());f&&(l.include_meta="true");return l},t.handleResponse=function(n,e){var r={messages:[],startTimeToken:e[1],endTimeToken:e[2]};Array.isArray(e[0])&&e[0].forEach(function(e){var t={timetoken:e.timetoken,entry:function(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}(n,e.message)};e.meta&&(t.meta=e.meta),r.messages.push(t)});return r};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNDeleteMessagesOperation},t.validateParams=function(e,t){var n=t.channel,r=e.config;if(!n)return"Missing channel";if(!r.subscribeKey)return"Missing Subscribe Key"},t.useDelete=function(){return!0},t.getURL=function(e,t){var n=t.channel,r=e.config;return"/v3/history/sub-key/".concat(r.subscribeKey,"/channel/").concat(i.default.encodeString(n))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i={};n&&(i.start=n);r&&(i.end=r);return i},t.handleResponse=function(e,t){return t.payload};n(0);var r=o(n(1)),i=o(n(2));function o(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNMessageCounts},t.validateParams=function(e,t){var n=t.channels,r=t.timetoken,i=t.channelTimetokens,o=e.config;if(!n)return"Missing channel";if(r&&i)return"timetoken and channelTimetokens are incompatible together";if(r&&i&&1<i.length&&n.length!==i.length)return"Length of channelTimetokens and channels do not match";if(!o.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=t.channels,r=e.config,i=n.join(",");return"/v3/history/sub-key/".concat(r.subscribeKey,"/message-counts/").concat(o.default.encodeString(i))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.timetoken,r=t.channelTimetokens,i={};if(r&&1===r.length){var o=function(e,t){return function(e){if(Array.isArray(e))return e}(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var n=[],r=!0,i=!1,o=void 0;try{for(var s,a=e[Symbol.iterator]();!(r=(s=a.next()).done)&&(n.push(s.value),!t||n.length!==t);r=!0);}catch(e){i=!0,o=e}finally{try{r||null==a.return||a.return()}finally{if(i)throw o}}return n}(e,t)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}(r,1)[0];i.timetoken=o}else r?i.channelsTimetoken=r.join(","):n&&(i.timetoken=n);return i},t.handleResponse=function(e,t){return{channels:t.channels}};var r=i(n(1)),o=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNFetchMessagesOperation},t.validateParams=function(e,t){var n=t.channels,r=t.includeMessageActions,i=void 0!==r&&r,o=e.config;if(!n||0===n.length)return"Missing channels";if(!o.subscribeKey)return"Missing Subscribe Key";if(i&&1<n.length)throw new TypeError("History can return actions data for a single channel only. Either pass a single channel or disable the includeMessageActions flag.")},t.getURL=function(e,t){var n=t.channels,r=void 0===n?[]:n,i=t.includeMessageActions,o=void 0!==i&&i,s=e.config,a=o?"history-with-actions":"history",u=0<r.length?r.join(","):",";return"/v3/".concat(a,"/sub-key/").concat(s.subscribeKey,"/channel/").concat(c.default.encodeString(u))},t.getRequestTimeout=function(e){return e.config.getTransactionTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=t.start,r=t.end,i=t.count,o=t.stringifiedTimeToken,s=void 0!==o&&o,a=t.includeMeta,u=void 0!==a&&a,c={};i&&(c.max=i);n&&(c.start=n);r&&(c.end=r);s&&(c.string_message_token="true");u&&(c.include_meta="true");return c},t.handleResponse=function(r,e){var i={channels:{}};return Object.keys(e.channels||{}).forEach(function(n){i.channels[n]=[],(e.channels[n]||[]).forEach(function(e){var t={};t.channel=n,t.timetoken=e.timetoken,t.message=function(e,t){var n=e.config,r=e.crypto;if(!n.cipherKey)return t;try{return r.decrypt(t)}catch(e){return t}}(r,e.message),e.actions&&(t.actions=e.actions,t.data=e.actions),e.meta&&(t.meta=e.meta),i.channels[n].push(t)})}),i};n(0);var r=i(n(1)),c=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getOperation=function(){return r.default.PNSubscribeOperation},t.validateParams=function(e){if(!e.config.subscribeKey)return"Missing Subscribe Key"},t.getURL=function(e,t){var n=e.config,r=t.channels,i=void 0===r?[]:r,o=0<i.length?i.join(","):",";return"/v2/subscribe/".concat(n.subscribeKey,"/").concat(s.default.encodeString(o),"/0")},t.getRequestTimeout=function(e){return e.config.getSubscribeTimeout()},t.isAuthSupported=function(){return!0},t.prepareParams=function(e,t){var n=e.config,r=t.state,i=t.channelGroups,o=void 0===i?[]:i,s=t.timetoken,a=t.filterExpression,u=t.region,c={heartbeat:n.getPresenceTimeout()};0<o.length&&(c["channel-group"]=o.join(","));a&&0<a.length&&(c["filter-expr"]=a);Object.keys(r).length&&(c.state=JSON.stringify(r));s&&(c.tt=s);u&&(c.tr=u);return c},t.handleResponse=function(e,t){var r=[];t.m.forEach(function(e){var t={publishTimetoken:e.p.t,region:e.p.r},n={shard:parseInt(e.a,10),subscriptionMatch:e.b,channel:e.c,messageType:e.e,payload:e.d,flags:e.f,issuingClientId:e.i,subscribeKey:e.k,originationTimetoken:e.o,userMetadata:e.u,publishMetaData:t};r.push(n)});var n={timetoken:t.t.t,region:t.t.r};return{messages:r,metadata:n}};n(0);var r=i(n(1)),s=i(n(2));function i(e){return e&&e.__esModule?e:{default:e}}},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;i(n(3));var r=i(n(4));n(0);function i(e){return e&&e.__esModule?e:{default:e}}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var a,u,c,f=(a=l,(u=[{key:"init",value:function(e){this._config=e,this._maxSubDomain=20,this._currentSubDomain=Math.floor(Math.random()*this._maxSubDomain),this._providedFQDN=(this._config.secure?"https://":"http://")+this._config.origin,this._coreParams={},this.shiftStandardOrigin()}},{key:"nextOrigin",value:function(){return this._providedFQDN.match(/ps\.pndsn\.com$/i)?(this._currentSubDomain=this._currentSubDomain+1,this._currentSubDomain>=this._maxSubDomain&&(this._currentSubDomain=1),e=this._currentSubDomain.toString(),this._providedFQDN.replace("ps.pndsn.com","ps".concat(e,".pndsn.com"))):this._providedFQDN;var e}},{key:"hasModule",value:function(e){return e in this._modules}},{key:"shiftStandardOrigin",value:function(){return this._standardOrigin=this.nextOrigin(),this._standardOrigin}},{key:"getStandardOrigin",value:function(){return this._standardOrigin}},{key:"POST",value:function(e,t,n,r){return this._modules.post(e,t,n,r)}},{key:"PATCH",value:function(e,t,n,r){return this._modules.patch(e,t,n,r)}},{key:"GET",value:function(e,t,n){return this._modules.get(e,t,n)}},{key:"DELETE",value:function(e,t,n){return this._modules.del(e,t,n)}},{key:"_detectErrorCategory",value:function(e){if("ENOTFOUND"===e.code)return r.default.PNNetworkIssuesCategory;if("ECONNREFUSED"===e.code)return r.default.PNNetworkIssuesCategory;if("ECONNRESET"===e.code)return r.default.PNNetworkIssuesCategory;if("EAI_AGAIN"===e.code)return r.default.PNNetworkIssuesCategory;if(0===e.status||e.hasOwnProperty("status")&&void 0===e.status)return r.default.PNNetworkIssuesCategory;if(e.timeout)return r.default.PNTimeoutCategory;if("ETIMEDOUT"===e.code)return r.default.PNNetworkIssuesCategory;if(e.response){if(e.response.badRequest)return r.default.PNBadRequestCategory;if(e.response.forbidden)return r.default.PNAccessDeniedCategory}return r.default.PNUnknownCategory}}])&&o(a.prototype,u),void(c&&o(a,c)),l);function l(t){var n=this;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,l),s(this,"_modules",void 0),s(this,"_config",void 0),s(this,"_maxSubDomain",void 0),s(this,"_currentSubDomain",void 0),s(this,"_standardOrigin",void 0),s(this,"_subscribeOrigin",void 0),s(this,"_providedFQDN",void 0),s(this,"_requestTimeout",void 0),s(this,"_coreParams",void 0),this._modules={},Object.keys(t).forEach(function(e){n._modules[e]=t[e].bind(n)})}t.default=f,e.exports=t.default},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var r={get:function(e){try{return localStorage.getItem(e)}catch(e){return null}},set:function(e,t){try{return localStorage.setItem(e,t)}catch(e){return null}}};t.default=r,e.exports=t.default},function(f,l,h){"use strict";(function(i){Object.defineProperty(l,"__esModule",{value:!0}),l.default=void 0;var e,o=(e=h(74))&&e.__esModule?e:{default:e};function s(e){return(s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function t(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var n,r,a,u=(n=c,(r=[{key:"decodeToken",value:function(e){var t="";e.length%4==3?t="=":e.length%4==2&&(t="==");var n=e.replace("-","+").replace("_","/")+t,r=o.default.decode(new i.from(n,"base64"));if("object"===s(r))return r}}])&&t(n.prototype,r),void(a&&t(n,a)),c);function c(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,c)}l.default=u,f.exports=l.default}).call(this,h(9).Buffer)},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t,n){"use strict";t.byteLength=function(e){var t=l(e),n=t[0],r=t[1];return 3*(n+r)/4-r},t.toByteArray=function(e){var t,n,r=l(e),i=r[0],o=r[1],s=new f(function(e,t,n){return 3*(t+n)/4-n}(0,i,o)),a=0,u=0<o?i-4:i;for(n=0;n<u;n+=4)t=c[e.charCodeAt(n)]<<18|c[e.charCodeAt(n+1)]<<12|c[e.charCodeAt(n+2)]<<6|c[e.charCodeAt(n+3)],s[a++]=t>>16&255,s[a++]=t>>8&255,s[a++]=255&t;2===o&&(t=c[e.charCodeAt(n)]<<2|c[e.charCodeAt(n+1)]>>4,s[a++]=255&t);1===o&&(t=c[e.charCodeAt(n)]<<10|c[e.charCodeAt(n+1)]<<4|c[e.charCodeAt(n+2)]>>2,s[a++]=t>>8&255,s[a++]=255&t);return s},t.fromByteArray=function(e){for(var t,n=e.length,r=n%3,i=[],o=0,s=n-r;o<s;o+=16383)i.push(u(e,o,s<o+16383?s:o+16383));1==r?(t=e[n-1],i.push(a[t>>2]+a[t<<4&63]+"==")):2==r&&(t=(e[n-2]<<8)+e[n-1],i.push(a[t>>10]+a[t>>4&63]+a[t<<2&63]+"="));return i.join("")};for(var a=[],c=[],f="undefined"!=typeof Uint8Array?Uint8Array:Array,r="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",i=0,o=r.length;i<o;++i)a[i]=r[i],c[r.charCodeAt(i)]=i;function l(e){var t=e.length;if(0<t%4)throw new Error("Invalid string. Length must be a multiple of 4");var n=e.indexOf("=");return-1===n&&(n=t),[n,n===t?0:4-n%4]}function u(e,t,n){for(var r,i,o=[],s=t;s<n;s+=3)r=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(255&e[s+2]),o.push(a[(i=r)>>18&63]+a[i>>12&63]+a[i>>6&63]+a[63&i]);return o.join("")}c["-".charCodeAt(0)]=62,c["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,n,r,i){var o,s,a=8*i-r-1,u=(1<<a)-1,c=u>>1,f=-7,l=n?i-1:0,h=n?-1:1,p=e[t+l];for(l+=h,o=p&(1<<-f)-1,p>>=-f,f+=a;0<f;o=256*o+e[t+l],l+=h,f-=8);for(s=o&(1<<-f)-1,o>>=-f,f+=r;0<f;s=256*s+e[t+l],l+=h,f-=8);if(0===o)o=1-c;else{if(o===u)return s?NaN:1/0*(p?-1:1);s+=Math.pow(2,r),o-=c}return(p?-1:1)*s*Math.pow(2,o-r)},t.write=function(e,t,n,r,i,o){var s,a,u,c=8*o-i-1,f=(1<<c)-1,l=f>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=r?0:o-1,d=r?1:-1,g=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=f):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),2<=(t+=1<=s+l?h/u:h*Math.pow(2,1-l))*u&&(s++,u/=2),f<=s+l?(a=0,s=f):1<=s+l?(a=(t*u-1)*Math.pow(2,i),s+=l):(a=t*Math.pow(2,l-1)*Math.pow(2,i),s=0));8<=i;e[n+p]=255&a,p+=d,a/=256,i-=8);for(s=s<<i|a,c+=i;0<c;e[n+p]=255&s,p+=d,s/=256,c-=8);e[n+p-d]|=128*g}},function(e,t){var n={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==n.call(e)}},function(r,i,e){(function(b){var e,t,n;t=[],void 0===(n="function"==typeof(e=function(){var e=function(){function o(e){this.$hex=e}o.prototype={length:function(){return this.$hex.length/2},toString:function(e){if(!e||"hex"===e||16===e)return this.$hex;if("utf-8"===e){for(var t="",n=0;n<this.$hex.length;n+=2)t+="%"+this.$hex.substring(n,n+2);return decodeURIComponent(t)}if("latin"!==e)throw new Error("Unrecognised format: "+e);for(var t=[],n=0;n<this.$hex.length;n+=2)t.push(parseInt(this.$hex.substring(n,n+2),16));return String.fromCharCode.apply(String,t)}},o.fromLatinString=function(e){for(var t="",n=0;n<e.length;n++){var r=e.charCodeAt(n).toString(16);1===r.length&&(r="0"+r),t+=r}return new o(t)},o.fromUtf8String=function(e){for(var t=encodeURIComponent(e),n="",r=0;r<t.length;r++)if("%"===t.charAt(r))n+=t.substring(r+1,r+3),r+=2;else{var i=t.charCodeAt(r).toString(16);i.length<2&&(i="0"+i),n+=i}return new o(n)};var s=[],f={},r=function(e){return function(){throw new Error(e+" not implemented")}};function e(){}function t(){}function l(e,t){var n=e.value;return n<24?n:24==n?t.readByte():25==n?t.readUint16():26==n?t.readUint32():27==n?t.readUint64():31==n?null:void r("Additional info: "+n)()}function a(e,t,n){var r=e<<5;t<24?n.writeByte(r|t):t<256?(n.writeByte(24|r),n.writeByte(t)):t<65536?(n.writeByte(25|r),n.writeUint16(t)):t<4294967296?(n.writeByte(26|r),n.writeUint32(t)):(n.writeByte(27|r),n.writeUint64(t))}e.prototype={peekByte:r("peekByte"),readByte:r("readByte"),readChunk:r("readChunk"),readFloat16:function(){var e=this.readUint16(),t=(32767&e)>>10,n=1023&e,r=32768&e;if(31==t)return 0==n?r?-1/0:1/0:NaN;var i=t?Math.pow(2,t-25)*(1024+n):Math.pow(2,-24)*n;return r?-i:i},readFloat32:function(){var e=this.readUint32(),t=(2147483647&e)>>23,n=8388607&e,r=2147483648&e;if(255==t)return 0==n?r?-1/0:1/0:NaN;var i=t?Math.pow(2,t-23-127)*(8388608+n):Math.pow(2,-149)*n;return r?-i:i},readFloat64:function(){var e=this.readUint32(),t=this.readUint32(),n=e>>20&2047,r=4294967296*(1048575&e)+t,i=2147483648&e;if(2047==n)return 0===r?i?-1/0:1/0:NaN;var o=n?Math.pow(2,n-52-1023)*(4503599627370496+r):Math.pow(2,-1074)*r;return i?-o:o},readUint16:function(){return 256*this.readByte()+this.readByte()},readUint32:function(){return 65536*this.readUint16()+this.readUint16()},readUint64:function(){return 4294967296*this.readUint32()+this.readUint32()}},t.prototype={writeByte:r("writeByte"),result:r("result"),writeFloat16:r("writeFloat16"),writeFloat32:r("writeFloat32"),writeFloat64:r("writeFloat64"),writeUint16:function(e){this.writeByte(e>>8&255),this.writeByte(255&e)},writeUint32:function(e){this.writeUint16(e>>16&65535),this.writeUint16(65535&e)},writeUint64:function(e){if(9007199254740992<=e||e<=-9007199254740992)throw new Error("Cannot encode Uint64 of: "+e+" magnitude to big (floating point errors)");this.writeUint32(Math.floor(e/4294967296)),this.writeUint32(e%4294967296)},writeString:r("writeString"),canWriteBinary:function(e){return!1},writeBinary:r("writeChunk")};var h=new Error;function p(e){var t=function(e){var t=e.readByte();return{type:t>>5,value:31&t}}(e);switch(t.type){case 0:return l(t,e);case 1:return-1-l(t,e);case 2:return e.readChunk(l(t,e));case 3:var n=e.readChunk(l(t,e));return n.toString("utf-8");case 4:case 5:var r=l(t,e),i=[];if(null!==r){5===t.type&&(r*=2);for(var o=0;o<r;o++)i[o]=p(e)}else for(var s;(s=p(e))!==h;)i.push(s);if(5!==t.type)return i;for(var a={},o=0;o<i.length;o+=2)a[i[o]]=i[o+1];return a;case 6:var u=l(t,e),c=f[u],i=p(e);return c?c(i):i;case 7:if(25===t.value)return e.readFloat16();if(26===t.value)return e.readFloat32();if(27===t.value)return e.readFloat64();switch(l(t,e)){case 20:return!1;case 21:return!0;case 22:return null;case 23:return;case null:return h;default:throw new Error("Unknown fixed value: "+t.value)}default:throw new Error("Unsupported header: "+JSON.stringify(t))}throw new Error("not implemented yet")}function u(e,t){for(var n=0;n<s.length;n++){var r=s[n].fn(e);if(void 0!==r)return a(6,s[n].tag,t),u(r,t)}if(e&&"function"==typeof e.toCBOR&&(e=e.toCBOR()),!1===e)a(7,20,t);else if(!0===e)a(7,21,t);else if(null===e)a(7,22,t);else if(void 0===e)a(7,23,t);else if("number"==typeof e)Math.floor(e)===e&&e<9007199254740992&&-9007199254740992<e?e<0?a(1,-1-e,t):a(0,e,t):(function(e,t,n){n.writeByte(e<<5|t)}(7,27,t),t.writeFloat64(e));else if("string"==typeof e)t.writeString(e,function(e){a(3,e,t)});else if(t.canWriteBinary(e))t.writeBinary(e,function(e){a(2,e,t)});else{if("object"!=typeof e)throw new Error("CBOR encoding not supported: "+e);if(g.config.useToJSON&&"function"==typeof e.toJSON&&(e=e.toJSON()),Array.isArray(e)){a(4,e.length,t);for(var n=0;n<e.length;n++)u(e[n],t)}else{var i=Object.keys(e);a(5,i.length,t);for(var n=0;n<i.length;n++)u(i[n],t),u(e[i[n]],t)}}}var c=[],d=[],g={config:{useToJSON:!0},addWriter:function(t,n){"string"==typeof t?d.push(function(e){if(t===e)return n(e)}):d.push(t)},addReader:function(n,r){"string"==typeof n?c.push(function(e,t){if(n===t)return r(e,t)}):c.push(n)},encode:function(e,t){for(var n=0;n<d.length;n++){var r=d[n],i=r(t);if(i)return u(e,i),i.result()}throw new Error("Unsupported output format: "+t)},decode:function(e,t){for(var n=0;n<c.length;n++){var r=c[n],i=r(e,t);if(i)return p(i)}throw new Error("Unsupported input format: "+t)},addSemanticEncode:function(e,t){if("number"!=typeof e||e%1!=0||e<0)throw new Error("Tag must be a positive integer");return s.push({tag:e,fn:t}),this},addSemanticDecode:function(e,t){if("number"!=typeof e||e%1!=0||e<0)throw new Error("Tag must be a positive integer");return f[e]=t,this},Reader:e,Writer:t};function i(e){this.buffer=e,this.pos=0}function n(e){this.byteLength=0,this.defaultBufferLength=16384,this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0,this.completeBuffers=[],this.stringFormat=e}function y(e){this.hex=e,this.pos=0}function v(e){this.$hex="",this.finalFormat=e||"hex"}return(i.prototype=Object.create(e.prototype)).peekByte=function(){return this.buffer[this.pos]},i.prototype.readByte=function(){return this.buffer[this.pos++]},i.prototype.readUint16=function(){var e=this.buffer.readUInt16BE(this.pos);return this.pos+=2,e},i.prototype.readUint32=function(){var e=this.buffer.readUInt32BE(this.pos);return this.pos+=4,e},i.prototype.readFloat32=function(){var e=this.buffer.readFloatBE(this.pos);return this.pos+=4,e},i.prototype.readFloat64=function(){var e=this.buffer.readDoubleBE(this.pos);return this.pos+=8,e},i.prototype.readChunk=function(e){var t=b.alloc(e);return this.buffer.copy(t,0,this.pos,this.pos+=e),t},(n.prototype=Object.create(t.prototype)).writeByte=function(e){this.latestBuffer[this.latestBufferOffset++]=e,this.latestBufferOffset>=this.latestBuffer.length&&(this.completeBuffers.push(this.latestBuffer),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0),this.byteLength++},n.prototype.writeFloat32=function(e){var t=b.alloc(4);t.writeFloatBE(e,0),this.writeBuffer(t)},n.prototype.writeFloat64=function(e){var t=b.alloc(8);t.writeDoubleBE(e,0),this.writeBuffer(t)},n.prototype.writeString=function(e,t){var n=b.from(e,"utf-8");t(n.length),this.writeBuffer(n)},n.prototype.canWriteBinary=function(e){return e instanceof b},n.prototype.writeBinary=function(e,t){t(e.length),this.writeBuffer(e)},n.prototype.writeBuffer=function(e){if(!(e instanceof b))throw new TypeError("BufferWriter only accepts Buffers");this.latestBufferOffset?this.latestBuffer.length-this.latestBufferOffset>=e.length?(e.copy(this.latestBuffer,this.latestBufferOffset),this.latestBufferOffset+=e.length,this.latestBufferOffset>=this.latestBuffer.length&&(this.completeBuffers.push(this.latestBuffer),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0)):(this.completeBuffers.push(this.latestBuffer.slice(0,this.latestBufferOffset)),this.completeBuffers.push(e),this.latestBuffer=b.alloc(this.defaultBufferLength),this.latestBufferOffset=0):this.completeBuffers.push(e),this.byteLength+=e.length},n.prototype.result=function(){for(var e=b.alloc(this.byteLength),t=0,n=0;n<this.completeBuffers.length;n++){var r=this.completeBuffers[n];r.copy(e,t,0,r.length),t+=r.length}return this.latestBufferOffset&&this.latestBuffer.copy(e,t,0,this.latestBufferOffset),this.stringFormat?e.toString(this.stringFormat):e},"function"==typeof b&&(g.addReader(function(e,t){if(e instanceof b)return new i(e);if("hex"===t||"base64"===t){var n=b.from(e,t);return new i(n)}}),g.addWriter(function(e){return e&&"buffer"!==e?"hex"===e||"base64"===e?new n(e):void 0:new n})),(y.prototype=Object.create(e.prototype)).peekByte=function(){var e=this.hex.substring(this.pos,2);return parseInt(e,16)},y.prototype.readByte=function(){var e=this.hex.substring(this.pos,this.pos+2);return this.pos+=2,parseInt(e,16)},y.prototype.readChunk=function(e){var t=this.hex.substring(this.pos,this.pos+2*e);return this.pos+=2*e,"function"==typeof b?b.from(t,"hex"):new o(t)},(v.prototype=Object.create(t.prototype)).writeByte=function(e){if(e<0||255<e)throw new Error("Byte value out of range: "+e);var t=e.toString(16);1==t.length&&(t="0"+t),this.$hex+=t},v.prototype.canWriteBinary=function(e){return e instanceof o||"function"==typeof b&&e instanceof b},v.prototype.writeBinary=function(e,t){if(e instanceof o)t(e.length()),this.$hex+=e.$hex;else{if(!("function"==typeof b&&e instanceof b))throw new TypeError("HexWriter only accepts BinaryHex or Buffers");t(e.length),this.$hex+=e.toString("hex")}},v.prototype.result=function(){return"buffer"===this.finalFormat&&"function"==typeof b?b.from(this.$hex,"hex"):new o(this.$hex).toString(this.finalFormat)},v.prototype.writeString=function(e,t){var n=o.fromUtf8String(e);t(n.length()),this.$hex+=n.$hex},g.addReader(function(e,t){return e instanceof o||e.$hex?new y(e.$hex):"hex"===t?new y(e):void 0}),g.addWriter(function(e){if("hex"===e)return new v}),g}();return e.addSemanticEncode(0,function(e){if(e instanceof Date)return e.toISOString()}).addSemanticDecode(0,function(e){return new Date(e)}).addSemanticDecode(1,function(e){return new Date(e)}),e})?e.apply(i,t):e)||(r.exports=n)}).call(this,e(9).Buffer)},function(e,t,n){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.get=function(e,t,n){var r=o.default.get(this.getStandardOrigin()+t.url).set(t.headers).query(e);return s.call(this,r,t,n)},t.post=function(e,t,n,r){var i=o.default.post(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return s.call(this,i,n,r)},t.patch=function(e,t,n,r){var i=o.default.patch(this.getStandardOrigin()+n.url).query(e).set(n.headers).send(t);return s.call(this,i,n,r)},t.del=function(e,t,n){var r=o.default.delete(this.getStandardOrigin()+t.url).set(t.headers).query(e);return s.call(this,r,t,n)};var r,o=(r=n(76))&&r.__esModule?r:{default:r};n(0);function a(r){var i=(new Date).getTime(),e=(new Date).toISOString(),o=console&&console.log?console:window&&window.console&&window.console.log?window.console:console;o.log("<<<<<"),o.log("[".concat(e,"]"),"\n",r.url,"\n",r.qs),o.log("-----"),r.on("response",function(e){var t=(new Date).getTime()-i,n=(new Date).toISOString();o.log(">>>>>>"),o.log("[".concat(n," / ").concat(t,"]"),"\n",r.url,"\n",r.qs,"\n",e.text),o.log("-----")})}function s(e,i,o){var s=this;return this._config.logVerbosity&&(e=e.use(a)),this._config.proxy&&this._modules.proxy&&(e=this._modules.proxy.call(this,e)),this._config.keepAlive&&this._modules.keepAlive&&(e=this._modules.keepAlive(e)),e.timeout(i.timeout).end(function(t,n){var e,r={};if(r.error=null!==t,r.operation=i.operation,n&&n.status&&(r.statusCode=n.status),t){if(t.response&&t.response.text&&!s._config.logVerbosity)try{r.errorData=JSON.parse(t.response.text)}catch(e){r.errorData=t}else r.errorData=t;return r.category=s._detectErrorCategory(t),o(r,null)}try{e=JSON.parse(n.text)}catch(e){return r.errorData=n,r.error=!0,o(r,null)}return e.error&&1===e.error&&e.status&&e.message&&e.service?(r.errorData=e,r.statusCode=e.status,r.error=!0,r.category=s._detectErrorCategory(r),o(r,null)):(e.error&&e.error.message&&(r.errorData=e.error),o(r,e))})}},function(e,n,t){var r;r="undefined"!=typeof window?window:"undefined"!=typeof self?self:(console.warn("Using browser-only version of superagent in non-browser environment"),this);var i=t(77),o=t(78),s=t(10),a=t(79),u=t(81);function c(){}var f=n=e.exports=function(e,t){return"function"==typeof t?new n.Request("GET",e).end(t):1==arguments.length?new n.Request("GET",e):new n.Request(e,t)};n.Request=v,f.getXHR=function(){if(!(!r.XMLHttpRequest||r.location&&"file:"==r.location.protocol&&r.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(e){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(e){}throw Error("Browser-only version of superagent could not find XHR")};var l="".trim?function(e){return e.trim()}:function(e){return e.replace(/(^\s*|\s*$)/g,"")};function h(e){if(!s(e))return e;var t=[];for(var n in e)p(t,n,e[n]);return t.join("&")}function p(t,n,e){if(null!=e)if(Array.isArray(e))e.forEach(function(e){p(t,n,e)});else if(s(e))for(var r in e)p(t,n+"["+r+"]",e[r]);else t.push(encodeURIComponent(n)+"="+encodeURIComponent(e));else null===e&&t.push(encodeURIComponent(n))}function d(e){for(var t,n,r={},i=e.split("&"),o=0,s=i.length;o<s;++o)-1==(n=(t=i[o]).indexOf("="))?r[decodeURIComponent(t)]="":r[decodeURIComponent(t.slice(0,n))]=decodeURIComponent(t.slice(n+1));return r}function g(e){return/[\/+]json($|[^-\w])/.test(e)}function y(e){this.req=e,this.xhr=this.req.xhr,this.text="HEAD"!=this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var t=this.xhr.status;1223===t&&(t=204),this._setStatusProperties(t),this.header=this.headers=function(e){for(var t,n,r,i,o=e.split(/\r?\n/),s={},a=0,u=o.length;a<u;++a)-1!==(t=(n=o[a]).indexOf(":"))&&(r=n.slice(0,t).toLowerCase(),i=l(n.slice(t+1)),s[r]=i);return s}(this.xhr.getAllResponseHeaders()),this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),null===this.text&&e._responseType?this.body=this.xhr.response:this.body="HEAD"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null}function v(e,t){var r=this;this._query=this._query||[],this.method=e,this.url=t,this.header={},this._header={},this.on("end",function(){var t,n=null,e=null;try{e=new y(r)}catch(e){return(n=new Error("Parser is unable to parse the response")).parse=!0,n.original=e,r.xhr?(n.rawResponse=void 0===r.xhr.responseType?r.xhr.responseText:r.xhr.response,n.status=r.xhr.status?r.xhr.status:null,n.statusCode=n.status):(n.rawResponse=null,n.status=null),r.callback(n)}r.emit("response",e);try{r._isResponseOK(e)||(t=new Error(e.statusText||"Unsuccessful HTTP response"))}catch(e){t=e}t?(t.original=n,t.response=e,t.status=e.status,r.callback(t,e)):r.callback(null,e)})}function b(e,t,n){var r=f("DELETE",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}f.serializeObject=h,f.parseString=d,f.types={html:"text/html",json:"application/json",xml:"text/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},f.serialize={"application/x-www-form-urlencoded":h,"application/json":JSON.stringify},f.parse={"application/x-www-form-urlencoded":d,"application/json":JSON.parse},a(y.prototype),y.prototype._parseBody=function(e){var t=f.parse[this.type];return this.req._parser?this.req._parser(this,e):(!t&&g(this.type)&&(t=f.parse["application/json"]),t&&e&&(e.length||e instanceof Object)?t(e):null)},y.prototype.toError=function(){var e=this.req,t=e.method,n=e.url,r="cannot "+t+" "+n+" ("+this.status+")",i=new Error(r);return i.status=this.status,i.method=t,i.url=n,i},f.Response=y,i(v.prototype),o(v.prototype),v.prototype.type=function(e){return this.set("Content-Type",f.types[e]||e),this},v.prototype.accept=function(e){return this.set("Accept",f.types[e]||e),this},v.prototype.auth=function(e,t,n){1===arguments.length&&(t=""),"object"==typeof t&&null!==t&&(n=t,t=""),n=n||{type:"function"==typeof btoa?"basic":"auto"};return this._auth(e,t,n,function(e){if("function"==typeof btoa)return btoa(e);throw new Error("Cannot use basic auth, btoa is not a function")})},v.prototype.query=function(e){return"string"!=typeof e&&(e=h(e)),e&&this._query.push(e),this},v.prototype.attach=function(e,t,n){if(t){if(this._data)throw Error("superagent can't mix .send() and .attach()");this._getFormData().append(e,t,n||t.name)}return this},v.prototype._getFormData=function(){return this._formData||(this._formData=new r.FormData),this._formData},v.prototype.callback=function(e,t){if(this._shouldRetry(e,t))return this._retry();var n=this._callback;this.clearTimeout(),e&&(this._maxRetries&&(e.retries=this._retries-1),this.emit("error",e)),n(e,t)},v.prototype.crossDomainError=function(){var e=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");e.crossDomain=!0,e.status=this.status,e.method=this.method,e.url=this.url,this.callback(e)},v.prototype.buffer=v.prototype.ca=v.prototype.agent=function(){return console.warn("This is not supported in browser version of superagent"),this},v.prototype.pipe=v.prototype.write=function(){throw Error("Streaming is not supported in browser version of superagent")},v.prototype._isHost=function(e){return e&&"object"==typeof e&&!Array.isArray(e)&&"[object Object]"!==Object.prototype.toString.call(e)},v.prototype.end=function(e){return this._endCalled&&console.warn("Warning: .end() was called twice. This is not supported in superagent"),this._endCalled=!0,this._callback=e||c,this._finalizeQueryString(),this._end()},v.prototype._end=function(){var n=this,r=this.xhr=f.getXHR(),e=this._formData||this._data;this._setTimeouts(),r.onreadystatechange=function(){var e=r.readyState;if(2<=e&&n._responseTimeoutTimer&&clearTimeout(n._responseTimeoutTimer),4==e){var t;try{t=r.status}catch(e){t=0}if(!t){if(n.timedout||n._aborted)return;return n.crossDomainError()}n.emit("end")}};function t(e,t){0<t.total&&(t.percent=t.loaded/t.total*100),t.direction=e,n.emit("progress",t)}if(this.hasListeners("progress"))try{r.onprogress=t.bind(null,"download"),r.upload&&(r.upload.onprogress=t.bind(null,"upload"))}catch(e){}try{this.username&&this.password?r.open(this.method,this.url,!0,this.username,this.password):r.open(this.method,this.url,!0)}catch(e){return this.callback(e)}if(this._withCredentials&&(r.withCredentials=!0),!this._formData&&"GET"!=this.method&&"HEAD"!=this.method&&"string"!=typeof e&&!this._isHost(e)){var i=this._header["content-type"],o=this._serializer||f.serialize[i?i.split(";")[0]:""];!o&&g(i)&&(o=f.serialize["application/json"]),o&&(e=o(e))}for(var s in this.header)null!=this.header[s]&&this.header.hasOwnProperty(s)&&r.setRequestHeader(s,this.header[s]);return this._responseType&&(r.responseType=this._responseType),this.emit("request",this),r.send(void 0!==e?e:null),this},f.agent=function(){return new u},["GET","POST","OPTIONS","PATCH","PUT","DELETE"].forEach(function(r){u.prototype[r.toLowerCase()]=function(e,t){var n=new f.Request(r,e);return this._setDefaults(n),t&&n.end(t),n}}),u.prototype.del=u.prototype.delete,f.get=function(e,t,n){var r=f("GET",e);return"function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},f.head=function(e,t,n){var r=f("HEAD",e);return"function"==typeof t&&(n=t,t=null),t&&r.query(t),n&&r.end(n),r},f.options=function(e,t,n){var r=f("OPTIONS",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.del=b,f.delete=b,f.patch=function(e,t,n){var r=f("PATCH",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.post=function(e,t,n){var r=f("POST",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r},f.put=function(e,t,n){var r=f("PUT",e);return"function"==typeof t&&(n=t,t=null),t&&r.send(t),n&&r.end(n),r}},function(e,t,n){function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.on=r.prototype.addEventListener=function(e,t){return this._callbacks=this._callbacks||{},(this._callbacks["$"+e]=this._callbacks["$"+e]||[]).push(t),this},r.prototype.once=function(e,t){function n(){this.off(e,n),t.apply(this,arguments)}return n.fn=t,this.on(e,n),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(e,t){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var n,r=this._callbacks["$"+e];if(!r)return this;if(1==arguments.length)return delete this._callbacks["$"+e],this;for(var i=0;i<r.length;i++)if((n=r[i])===t||n.fn===t){r.splice(i,1);break}return 0===r.length&&delete this._callbacks["$"+e],this},r.prototype.emit=function(e){this._callbacks=this._callbacks||{};for(var t=new Array(arguments.length-1),n=this._callbacks["$"+e],r=1;r<arguments.length;r++)t[r-1]=arguments[r];if(n){r=0;for(var i=(n=n.slice(0)).length;r<i;++r)n[r].apply(this,t)}return this},r.prototype.listeners=function(e){return this._callbacks=this._callbacks||{},this._callbacks["$"+e]||[]},r.prototype.hasListeners=function(e){return!!this.listeners(e).length}},function(e,t,n){"use strict";var i=n(10);function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,this},r.prototype.parse=function(e){return this._parser=e,this},r.prototype.responseType=function(e){return this._responseType=e,this},r.prototype.serialize=function(e){return this._serializer=e,this},r.prototype.timeout=function(e){if(!e||"object"!=typeof e)return this._timeout=e,this._responseTimeout=0,this;for(var t in e)switch(t){case"deadline":this._timeout=e.deadline;break;case"response":this._responseTimeout=e.response;break;default:console.warn("Unknown timeout option",t)}return this},r.prototype.retry=function(e,t){return 0!==arguments.length&&!0!==e||(e=1),e<=0&&(e=0),this._maxRetries=e,this._retries=0,this._retryCallback=t,this};var o=["ECONNRESET","ETIMEDOUT","EADDRINFO","ESOCKETTIMEDOUT"];r.prototype._shouldRetry=function(e,t){if(!this._maxRetries||this._retries++>=this._maxRetries)return!1;if(this._retryCallback)try{var n=this._retryCallback(e,t);if(!0===n)return!0;if(!1===n)return!1}catch(e){console.error(e)}if(t&&t.status&&500<=t.status&&501!=t.status)return!0;if(e){if(e.code&&~o.indexOf(e.code))return!0;if(e.timeout&&"ECONNABORTED"==e.code)return!0;if(e.crossDomain)return!0}return!1},r.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this._end()},r.prototype.then=function(e,t){if(!this._fullfilledPromise){var i=this;this._endCalled&&console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"),this._fullfilledPromise=new Promise(function(n,r){i.end(function(e,t){e?r(e):n(t)})})}return this._fullfilledPromise.then(e,t)},r.prototype.catch=function(e){return this.then(void 0,e)},r.prototype.use=function(e){return e(this),this},r.prototype.ok=function(e){if("function"!=typeof e)throw Error("Callback required");return this._okCallback=e,this},r.prototype._isResponseOK=function(e){return!!e&&(this._okCallback?this._okCallback(e):200<=e.status&&e.status<300)},r.prototype.getHeader=r.prototype.get=function(e){return this._header[e.toLowerCase()]},r.prototype.set=function(e,t){if(i(e)){for(var n in e)this.set(n,e[n]);return this}return this._header[e.toLowerCase()]=t,this.header[e]=t,this},r.prototype.unset=function(e){return delete this._header[e.toLowerCase()],delete this.header[e],this},r.prototype.field=function(e,t){if(null==e)throw new Error(".field(name, val) name can not be empty");if(this._data&&console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"),i(e)){for(var n in e)this.field(n,e[n]);return this}if(Array.isArray(t)){for(var r in t)this.field(e,t[r]);return this}if(null==t)throw new Error(".field(name, val) val can not be empty");return"boolean"==typeof t&&(t=""+t),this._getFormData().append(e,t),this},r.prototype.abort=function(){return this._aborted||(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort")),this},r.prototype._auth=function(e,t,n,r){switch(n.type){case"basic":this.set("Authorization","Basic "+r(e+":"+t));break;case"auto":this.username=e,this.password=t;break;case"bearer":this.set("Authorization","Bearer "+e)}return this},r.prototype.withCredentials=function(e){return null==e&&(e=!0),this._withCredentials=e,this},r.prototype.redirects=function(e){return this._maxRedirects=e,this},r.prototype.maxResponseSize=function(e){if("number"!=typeof e)throw TypeError("Invalid argument");return this._maxResponseSize=e,this},r.prototype.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},r.prototype.send=function(e){var t=i(e),n=this._header["content-type"];if(this._formData&&console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"),t&&!this._data)Array.isArray(e)?this._data=[]:this._isHost(e)||(this._data={});else if(e&&this._data&&this._isHost(this._data))throw Error("Can't merge these send calls");if(t&&i(this._data))for(var r in e)this._data[r]=e[r];else"string"==typeof e?(n||this.type("form"),n=this._header["content-type"],this._data="application/x-www-form-urlencoded"==n?this._data?this._data+"&"+e:e:(this._data||"")+e):this._data=e;return!t||this._isHost(e)||n||this.type("json"),this},r.prototype.sortQuery=function(e){return this._sort=void 0===e||e,this},r.prototype._finalizeQueryString=function(){var e=this._query.join("&");if(e&&(this.url+=(0<=this.url.indexOf("?")?"&":"?")+e),this._query.length=0,this._sort){var t=this.url.indexOf("?");if(0<=t){var n=this.url.substring(t+1).split("&");"function"==typeof this._sort?n.sort(this._sort):n.sort(),this.url=this.url.substring(0,t)+"?"+n.join("&")}}},r.prototype._appendQueryString=function(){console.trace("Unsupported")},r.prototype._timeoutError=function(e,t,n){if(!this._aborted){var r=new Error(e+t+"ms exceeded");r.timeout=t,r.code="ECONNABORTED",r.errno=n,this.timedout=!0,this.abort(),this.callback(r)}},r.prototype._setTimeouts=function(){var e=this;this._timeout&&!this._timer&&(this._timer=setTimeout(function(){e._timeoutError("Timeout of ",e._timeout,"ETIME")},this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout(function(){e._timeoutError("Response timeout of ",e._responseTimeout,"ETIMEDOUT")},this._responseTimeout))}},function(e,t,n){"use strict";var i=n(80);function r(e){if(e)return function(e){for(var t in r.prototype)e[t]=r.prototype[t];return e}(e)}(e.exports=r).prototype.get=function(e){return this.header[e.toLowerCase()]},r.prototype._setHeaderProperties=function(e){var t=e["content-type"]||"";this.type=i.type(t);var n=i.params(t);for(var r in n)this[r]=n[r];this.links={};try{e.link&&(this.links=i.parseLinks(e.link))}catch(e){}},r.prototype._setStatusProperties=function(e){var t=e/100|0;this.status=this.statusCode=e,this.statusType=t,this.info=1==t,this.ok=2==t,this.redirect=3==t,this.clientError=4==t,this.serverError=5==t,this.error=(4==t||5==t)&&this.toError(),this.created=201==e,this.accepted=202==e,this.noContent=204==e,this.badRequest=400==e,this.unauthorized=401==e,this.notAcceptable=406==e,this.forbidden=403==e,this.notFound=404==e,this.unprocessableEntity=422==e}},function(e,t,n){"use strict";t.type=function(e){return e.split(/ *; */).shift()},t.params=function(e){return e.split(/ *; */).reduce(function(e,t){var n=t.split(/ *= */),r=n.shift(),i=n.shift();return r&&i&&(e[r]=i),e},{})},t.parseLinks=function(e){return e.split(/ *, */).reduce(function(e,t){var n=t.split(/ *; */),r=n[0].slice(1,-1);return e[n[1].split(/ *= */)[1].slice(1,-1)]=r,e},{})},t.cleanHeader=function(e,t){return delete e["content-type"],delete e["content-length"],delete e["transfer-encoding"],delete e.host,t&&(delete e.authorization,delete e.cookie),e}},function(e,t){function n(){this._defaults=[]}["use","on","once","set","query","type","accept","auth","withCredentials","sortQuery","retry","ok","redirects","timeout","buffer","serialize","parse","ca","key","pfx","cert"].forEach(function(e){n.prototype[e]=function(){return this._defaults.push({fn:e,arguments:arguments}),this}}),n.prototype._setDefaults=function(t){this._defaults.forEach(function(e){t[e.fn].apply(t,e.arguments)})},e.exports=n}],i.c=r,i.d=function(e,t,n){i.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},i.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},i.t=function(t,e){if(1&e&&(t=i(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(i.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var r in t)i.d(n,r,function(e){return t[e]}.bind(null,r));return n},i.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return i.d(t,"a",t),t},i.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},i.p="",i(i.s=11);function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}var n,r});
      };
    };
  }
}, {package:"pubnub",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js", {"./UnsafeUniformArrayIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\UniformArrayIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformArrayIntDistribution = void 0;
var UnsafeUniformArrayIntDistribution_1 = require("./UnsafeUniformArrayIntDistribution");
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformArrayIntDistribution = uniformArrayIntDistribution;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js", {"./UnsafeUniformBigIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\UniformBigIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformBigIntDistribution = void 0;
var UnsafeUniformBigIntDistribution_1 = require("./UnsafeUniformBigIntDistribution");
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformBigIntDistribution = uniformBigIntDistribution;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js", {"./UnsafeUniformIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\UniformIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.uniformIntDistribution = void 0;
var UnsafeUniformIntDistribution_1 = require("./UnsafeUniformIntDistribution");
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution(from, to, nextRng), nextRng];
    };
}
exports.uniformIntDistribution = uniformIntDistribution;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js", {"./internals/ArrayInt":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js","./internals/UnsafeUniformArrayIntDistributionInternal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\UnsafeUniformArrayIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformArrayIntDistribution = void 0;
var ArrayInt_1 = require("./internals/ArrayInt");
var UnsafeUniformArrayIntDistributionInternal_1 = require("./internals/UnsafeUniformArrayIntDistributionInternal");
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = ArrayInt_1.trimArrayIntInplace(ArrayInt_1.addOneToPositiveArrayInt(ArrayInt_1.substractArrayIntToNew(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal(emptyArrayIntData, rangeSize.data, rng);
    return ArrayInt_1.trimArrayIntInplace(ArrayInt_1.addArrayIntToNew({ sign: 1, data: g }, from));
}
exports.unsafeUniformArrayIntDistribution = unsafeUniformArrayIntDistribution;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\UnsafeUniformBigIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformBigIntDistribution = void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + BigInt(1);
    var MinRng = BigInt(rng.min());
    var NumValues = BigInt(rng.max() - rng.min() + 1);
    var FinalNumValues = NumValues;
    var NumIterations = BigInt(1);
    while (FinalNumValues < diff) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);
    while (true) {
        var value = BigInt(0);
        for (var num = BigInt(0); num !== NumIterations; ++num) {
            var out = rng.unsafeNext();
            value = NumValues * value + (BigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}
exports.unsafeUniformBigIntDistribution = unsafeUniformBigIntDistribution;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js", {"./internals/ArrayInt":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js","./internals/UnsafeUniformArrayIntDistributionInternal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js","./internals/UnsafeUniformIntDistributionInternal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\UnsafeUniformIntDistribution.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistribution = void 0;
var UnsafeUniformIntDistributionInternal_1 = require("./internals/UnsafeUniformIntDistributionInternal");
var ArrayInt_1 = require("./internals/ArrayInt");
var UnsafeUniformArrayIntDistributionInternal_1 = require("./internals/UnsafeUniformArrayIntDistributionInternal");
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= Number.MAX_SAFE_INTEGER
        ? ArrayInt_1.fromNumberToArrayInt64(sharedC, rangeSize)
        : ArrayInt_1.substractArrayInt64(sharedC, ArrayInt_1.fromNumberToArrayInt64(sharedA, to), ArrayInt_1.fromNumberToArrayInt64(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    }
    else {
        rangeSizeArrayIntValue.data[1] += 1;
    }
    UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}
exports.unsafeUniformIntDistribution = unsafeUniformIntDistribution;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\ArrayInt.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\internals\ArrayInt.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.substractArrayInt64 = exports.fromNumberToArrayInt64 = exports.trimArrayIntInplace = exports.substractArrayIntToNew = exports.addOneToPositiveArrayInt = exports.addArrayIntToNew = void 0;
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) {
        data.push(reminder);
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.addArrayIntToNew = addArrayIntToNew;
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for (var index = data.length - 1; index >= 0; --index) {
        if (data[index] === 0xffffffff) {
            data[index] = 0;
        }
        else {
            data[index] += 1;
            return arrayInt;
        }
    }
    data.unshift(1);
    return arrayInt;
}
exports.addOneToPositiveArrayInt = addOneToPositiveArrayInt;
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for (var index = 0; index < maxLength; ++index) {
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB)
            return true;
        if (vA > vB)
            return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.substractArrayIntToNew = substractArrayIntToNew;
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) { }
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [0];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
exports.trimArrayIntInplace = trimArrayIntInplace;
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    }
    else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
exports.fromNumberToArrayInt64 = fromNumberToArrayInt64;
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}
exports.substractArrayInt64 = substractArrayInt64;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformArrayIntDistributionInternal.js", {"./UnsafeUniformIntDistributionInternal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\internals\UnsafeUniformArrayIntDistributionInternal.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformArrayIntDistributionInternal = void 0;
var UnsafeUniformIntDistributionInternal_1 = require("./UnsafeUniformIntDistributionInternal");
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while (true) {
        for (var index = 0; index !== rangeLength; ++index) {
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal(indexRangeSize, rng);
            out[index] = g;
        }
        for (var index = 0; index !== rangeLength; ++index) {
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) {
                return out;
            }
            else if (current > currentInRange) {
                break;
            }
        }
    }
}
exports.unsafeUniformArrayIntDistributionInternal = unsafeUniformArrayIntDistributionInternal;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\internals\\UnsafeUniformIntDistributionInternal.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\distribution\internals\UnsafeUniformIntDistributionInternal.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistributionInternal = void 0;
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MinRng = rng.min();
    var NumValues = rng.max() - rng.min() + 1;
    if (rangeSize <= NumValues) {
        var nrng_1 = rng;
        var MaxAllowed = NumValues - (NumValues % rangeSize);
        while (true) {
            var out = nrng_1.unsafeNext();
            var deltaV = out - MinRng;
            if (deltaV < MaxAllowed) {
                return deltaV % rangeSize;
            }
        }
    }
    var FinalNumValues = NumValues * NumValues;
    var NumIterations = 2;
    while (FinalNumValues < rangeSize) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = rangeSize * Math.floor((1 * FinalNumValues) / rangeSize);
    var nrng = rng;
    while (true) {
        var value = 0;
        for (var num = 0; num !== NumIterations; ++num) {
            var out = nrng.unsafeNext();
            value = NumValues * value + (out - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value - rangeSize * Math.floor((1 * value) / rangeSize);
            return inDiff;
        }
    }
}
exports.unsafeUniformIntDistributionInternal = unsafeUniformIntDistributionInternal;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\generator\LinearCongruential.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.congruential32 = exports.congruential = void 0;
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function (seed) {
    return (seed * MULTIPLIER + INCREMENT) & MASK;
};
var computeValueFromNextSeed = function (nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential = (function () {
    function LinearCongruential(seed) {
        this.seed = seed;
    }
    LinearCongruential.prototype.min = function () {
        return LinearCongruential.min;
    };
    LinearCongruential.prototype.max = function () {
        return LinearCongruential.max;
    };
    LinearCongruential.prototype.clone = function () {
        return new LinearCongruential(this.seed);
    };
    LinearCongruential.prototype.next = function () {
        var nextRng = new LinearCongruential(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential.prototype.unsafeNext = function () {
        this.seed = computeNextSeed(this.seed);
        return computeValueFromNextSeed(this.seed);
    };
    LinearCongruential.min = 0;
    LinearCongruential.max = Math.pow(2, 15) - 1;
    return LinearCongruential;
}());
var LinearCongruential32 = (function () {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.min = function () {
        return LinearCongruential32.min;
    };
    LinearCongruential32.prototype.max = function () {
        return LinearCongruential32.max;
    };
    LinearCongruential32.prototype.clone = function () {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function () {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential32.prototype.unsafeNext = function () {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + ((v2 + (v1 << 15)) << 15);
        return ((vnext + 0x80000000) | 0) + 0x80000000;
    };
    LinearCongruential32.min = 0;
    LinearCongruential32.max = 0xffffffff;
    return LinearCongruential32;
}());
var congruential = function (seed) {
    return new LinearCongruential(seed);
};
exports.congruential = congruential;
var congruential32 = function (seed) {
    return new LinearCongruential32(seed);
};
exports.congruential32 = congruential32;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\generator\MersenneTwister.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
var MersenneTwister = (function () {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function (prev) {
        var mt = prev.slice();
        for (var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx) {
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ (y_1 >>> 1) ^ (-(y_1 & 1) & MersenneTwister.A);
        }
        for (var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx) {
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ (y_2 >>> 1) ^ (-(y_2 & 1) & MersenneTwister.A);
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ (y >>> 1) ^ (-(y & 1) & MersenneTwister.A);
        return mt;
    };
    MersenneTwister.seeded = function (seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for (var idx = 1; idx !== MersenneTwister.N; ++idx) {
            var xored = out[idx - 1] ^ (out[idx - 1] >>> 30);
            out[idx] = (Math.imul(MersenneTwister.F, xored) + idx) | 0;
        }
        return out;
    };
    MersenneTwister.from = function (seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.min = function () {
        return MersenneTwister.min;
    };
    MersenneTwister.prototype.max = function () {
        return MersenneTwister.max;
    };
    MersenneTwister.prototype.clone = function () {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function () {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    MersenneTwister.prototype.unsafeNext = function () {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= (y << MersenneTwister.S) & MersenneTwister.B;
        y ^= (y << MersenneTwister.T) & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y >>> 0;
    };
    MersenneTwister.min = 0;
    MersenneTwister.max = 0xffffffff;
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}());
function default_1(seed) {
    return MersenneTwister.from(seed);
}
exports["default"] = default_1;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\generator\RandomGenerator.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.skipN = exports.unsafeSkipN = exports.generateN = exports.unsafeGenerateN = void 0;
function unsafeGenerateN(rng, num) {
    var out = [];
    for (var idx = 0; idx != num; ++idx) {
        out.push(rng.unsafeNext());
    }
    return out;
}
exports.unsafeGenerateN = unsafeGenerateN;
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [out, nextRng];
}
exports.generateN = generateN;
function unsafeSkipN(rng, num) {
    for (var idx = 0; idx != num; ++idx) {
        rng.unsafeNext();
    }
}
exports.unsafeSkipN = unsafeSkipN;
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}
exports.skipN = skipN;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XorShift.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\generator\XorShift.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.xorshift128plus = void 0;
var XorShift128Plus = (function () {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XorShift128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XorShift128Plus.prototype.clone = function () {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XorShift128Plus.prototype.unsafeNext = function () {
        var a0 = this.s00 ^ (this.s00 << 23);
        var a1 = this.s01 ^ ((this.s01 << 23) | (this.s00 >>> 9));
        var b0 = a0 ^ this.s10 ^ ((a0 >>> 18) | (a1 << 14)) ^ ((this.s10 >>> 5) | (this.s11 << 27));
        var b1 = a1 ^ this.s11 ^ (a1 >>> 18) ^ (this.s11 >>> 5);
        var out = (this.s00 + this.s10) | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0x635d2dff, 0x8a5cd789, 0x5c472f96, 0x121fd215];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XorShift128Plus;
}());
var xorshift128plus = function (seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
};
exports.xorshift128plus = xorshift128plus;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XoroShiro.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\generator\XoroShiro.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.xoroshiro128plus = void 0;
var XoroShiro128Plus = (function () {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XoroShiro128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XoroShiro128Plus.prototype.clone = function () {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XoroShiro128Plus.prototype.unsafeNext = function () {
        var out = (this.s00 + this.s10) | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);
        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));
        this.s10 = (a1 << 5) ^ (a0 >>> 27);
        this.s11 = (a0 << 5) ^ (a1 >>> 27);
        return out;
    };
    XoroShiro128Plus.prototype.jump = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XoroShiro128Plus;
}());
var xoroshiro128plus = function (seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
};
exports.xoroshiro128plus = xoroshiro128plus;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand-default.js", {"./distribution/UniformArrayIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformArrayIntDistribution.js","./distribution/UniformBigIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformBigIntDistribution.js","./distribution/UniformIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UniformIntDistribution.js","./distribution/UnsafeUniformArrayIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformArrayIntDistribution.js","./distribution/UnsafeUniformBigIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformBigIntDistribution.js","./distribution/UnsafeUniformIntDistribution":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\distribution\\UnsafeUniformIntDistribution.js","./generator/LinearCongruential":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\LinearCongruential.js","./generator/MersenneTwister":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\MersenneTwister.js","./generator/RandomGenerator":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\RandomGenerator.js","./generator/XorShift":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XorShift.js","./generator/XoroShiro":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\generator\\XoroShiro.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\pure-rand-default.js
      return function (require, module, exports) {
"use strict";
exports.__esModule = true;
exports.unsafeUniformIntDistribution = exports.unsafeUniformBigIntDistribution = exports.unsafeUniformArrayIntDistribution = exports.uniformIntDistribution = exports.uniformBigIntDistribution = exports.uniformArrayIntDistribution = exports.xoroshiro128plus = exports.xorshift128plus = exports.mersenne = exports.congruential32 = exports.congruential = exports.unsafeSkipN = exports.unsafeGenerateN = exports.skipN = exports.generateN = exports.__commitHash = exports.__version = exports.__type = void 0;
var RandomGenerator_1 = require("./generator/RandomGenerator");
exports.generateN = RandomGenerator_1.generateN;
exports.skipN = RandomGenerator_1.skipN;
exports.unsafeGenerateN = RandomGenerator_1.unsafeGenerateN;
exports.unsafeSkipN = RandomGenerator_1.unsafeSkipN;
var LinearCongruential_1 = require("./generator/LinearCongruential");
exports.congruential = LinearCongruential_1.congruential;
exports.congruential32 = LinearCongruential_1.congruential32;
var MersenneTwister_1 = require("./generator/MersenneTwister");
exports.mersenne = MersenneTwister_1["default"];
var XorShift_1 = require("./generator/XorShift");
exports.xorshift128plus = XorShift_1.xorshift128plus;
var XoroShiro_1 = require("./generator/XoroShiro");
exports.xoroshiro128plus = XoroShiro_1.xoroshiro128plus;
var UniformArrayIntDistribution_1 = require("./distribution/UniformArrayIntDistribution");
exports.uniformArrayIntDistribution = UniformArrayIntDistribution_1.uniformArrayIntDistribution;
var UniformBigIntDistribution_1 = require("./distribution/UniformBigIntDistribution");
exports.uniformBigIntDistribution = UniformBigIntDistribution_1.uniformBigIntDistribution;
var UniformIntDistribution_1 = require("./distribution/UniformIntDistribution");
exports.uniformIntDistribution = UniformIntDistribution_1.uniformIntDistribution;
var UnsafeUniformArrayIntDistribution_1 = require("./distribution/UnsafeUniformArrayIntDistribution");
exports.unsafeUniformArrayIntDistribution = UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution;
var UnsafeUniformBigIntDistribution_1 = require("./distribution/UnsafeUniformBigIntDistribution");
exports.unsafeUniformBigIntDistribution = UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution;
var UnsafeUniformIntDistribution_1 = require("./distribution/UnsafeUniformIntDistribution");
exports.unsafeUniformIntDistribution = UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution;
var __type = 'commonjs';
exports.__type = __type;
var __version = '5.0.0';
exports.__version = __version;
var __commitHash = '744555855a01e1551ab1cf67a6ea973d14964661';
exports.__commitHash = __commitHash;

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand.js", {"./pure-rand-default":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\pure-rand\\lib\\pure-rand-default.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\pure-rand\lib\pure-rand.js
      return function (require, module, exports) {
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
exports.__esModule = true;
var prand = require("./pure-rand-default");
exports["default"] = prand;
__exportStar(require("./pure-rand-default"), exports);

      };
    };
  }
}, {package:"@truffle/codec>@truffle/abi-utils>fast-check>pure-rand",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\8BitByte.js", {"./mode":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\mode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\8BitByte.js
      return function (require, module, exports) {
var mode = require('./mode');

function QR8bitByte(data) {
	this.mode = mode.MODE_8BIT_BYTE;
	this.data = data;
}

QR8bitByte.prototype = {

	getLength : function(buffer) {
		return this.data.length;
	},
	
	write : function(buffer) {
		for (var i = 0; i < this.data.length; i++) {
			// not JIS ...
			buffer.put(this.data.charCodeAt(i), 8);
		}
	}
};

module.exports = QR8bitByte;


      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\BitBuffer.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\BitBuffer.js
      return function (require, module, exports) {
function QRBitBuffer() {
	this.buffer = new Array();
	this.length = 0;
}

QRBitBuffer.prototype = {

	get : function(index) {
		var bufIndex = Math.floor(index / 8);
		return ( (this.buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
	},
	
	put : function(num, length) {
		for (var i = 0; i < length; i++) {
			this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
		}
	},
	
	getLengthInBits : function() {
		return this.length;
	},
	
	putBit : function(bit) {
	
		var bufIndex = Math.floor(this.length / 8);
		if (this.buffer.length <= bufIndex) {
			this.buffer.push(0);
		}
	
		if (bit) {
			this.buffer[bufIndex] |= (0x80 >>> (this.length % 8) );
		}
	
		this.length++;
	}
};

module.exports = QRBitBuffer;

      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\ErrorCorrectLevel.js
      return function (require, module, exports) {
module.exports = {
	L : 1,
	M : 0,
	Q : 3,
	H : 2
};


      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\Polynomial.js", {"./math":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\math.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\Polynomial.js
      return function (require, module, exports) {
var math = require('./math');

function QRPolynomial(num, shift) {

	if (num.length == undefined) {
		throw new Error(num.length + "/" + shift);
	}

	var offset = 0;

	while (offset < num.length && num[offset] == 0) {
		offset++;
	}

	this.num = new Array(num.length - offset + shift);
	for (var i = 0; i < num.length - offset; i++) {
		this.num[i] = num[i + offset];
	}
}

QRPolynomial.prototype = {

	get : function(index) {
		return this.num[index];
	},
	
	getLength : function() {
		return this.num.length;
	},
	
	multiply : function(e) {
	
		var num = new Array(this.getLength() + e.getLength() - 1);
	
		for (var i = 0; i < this.getLength(); i++) {
			for (var j = 0; j < e.getLength(); j++) {
				num[i + j] ^= math.gexp(math.glog(this.get(i) ) + math.glog(e.get(j) ) );
			}
		}
	
		return new QRPolynomial(num, 0);
	},
	
	mod : function(e) {
	
		if (this.getLength() - e.getLength() < 0) {
			return this;
		}
	
		var ratio = math.glog(this.get(0) ) - math.glog(e.get(0) );
	
		var num = new Array(this.getLength() );
		
		for (var i = 0; i < this.getLength(); i++) {
			num[i] = this.get(i);
		}
		
		for (var i = 0; i < e.getLength(); i++) {
			num[i] ^= math.gexp(math.glog(e.get(i) ) + ratio);
		}
	
		// recursive call
		return new QRPolynomial(num, 0).mod(e);
	}
};

module.exports = QRPolynomial;

      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\QRCode.js", {"./8BitByte":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\8BitByte.js","./BitBuffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\BitBuffer.js","./Polynomial":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\Polynomial.js","./RSBlock":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\RSBlock.js","./util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\QRCode.js
      return function (require, module, exports) {
var BitByte = require('./8BitByte');
var RSBlock = require('./RSBlock');
var BitBuffer = require('./BitBuffer');
var util = require('./util');
var Polynomial = require('./Polynomial');

function QRCode(typeNumber, errorCorrectLevel) {
	this.typeNumber = typeNumber;
	this.errorCorrectLevel = errorCorrectLevel;
	this.modules = null;
	this.moduleCount = 0;
	this.dataCache = null;
	this.dataList = [];
}

// for client side minification
var proto = QRCode.prototype;

proto.addData = function(data) {
	var newData = new BitByte(data);
	this.dataList.push(newData);
	this.dataCache = null;
};

proto.isDark = function(row, col) {
	if (row < 0 || this.moduleCount <= row || col < 0 || this.moduleCount <= col) {
		throw new Error(row + "," + col);
	}
	return this.modules[row][col];
};

proto.getModuleCount = function() {
	return this.moduleCount;
};

proto.make = function() {
	// Calculate automatically typeNumber if provided is < 1
	if (this.typeNumber < 1 ){
		var typeNumber = 1;
		for (typeNumber = 1; typeNumber < 40; typeNumber++) {
			var rsBlocks = RSBlock.getRSBlocks(typeNumber, this.errorCorrectLevel);

			var buffer = new BitBuffer();
			var totalDataCount = 0;
			for (var i = 0; i < rsBlocks.length; i++) {
				totalDataCount += rsBlocks[i].dataCount;
			}

			for (var i = 0; i < this.dataList.length; i++) {
				var data = this.dataList[i];
				buffer.put(data.mode, 4);
				buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber) );
				data.write(buffer);
			}
			if (buffer.getLengthInBits() <= totalDataCount * 8)
				break;
		}
		this.typeNumber = typeNumber;
	}
	this.makeImpl(false, this.getBestMaskPattern() );
};

proto.makeImpl = function(test, maskPattern) {
	
	this.moduleCount = this.typeNumber * 4 + 17;
	this.modules = new Array(this.moduleCount);
	
	for (var row = 0; row < this.moduleCount; row++) {
		
		this.modules[row] = new Array(this.moduleCount);
		
		for (var col = 0; col < this.moduleCount; col++) {
			this.modules[row][col] = null;//(col + row) % 3;
		}
	}

	this.setupPositionProbePattern(0, 0);
	this.setupPositionProbePattern(this.moduleCount - 7, 0);
	this.setupPositionProbePattern(0, this.moduleCount - 7);
	this.setupPositionAdjustPattern();
	this.setupTimingPattern();
	this.setupTypeInfo(test, maskPattern);
	
	if (this.typeNumber >= 7) {
		this.setupTypeNumber(test);
	}

	if (this.dataCache == null) {
		this.dataCache = QRCode.createData(this.typeNumber, this.errorCorrectLevel, this.dataList);
	}

	this.mapData(this.dataCache, maskPattern);
};

proto.setupPositionProbePattern = function(row, col)  {
	
	for (var r = -1; r <= 7; r++) {
		
		if (row + r <= -1 || this.moduleCount <= row + r) continue;
		
		for (var c = -1; c <= 7; c++) {
			
			if (col + c <= -1 || this.moduleCount <= col + c) continue;
			
			if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
					|| (0 <= c && c <= 6 && (r == 0 || r == 6) )
					|| (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
				this.modules[row + r][col + c] = true;
			} else {
				this.modules[row + r][col + c] = false;
			}
		}		
	}		
};

proto.getBestMaskPattern = function() {

	var minLostPoint = 0;
	var pattern = 0;

	for (var i = 0; i < 8; i++) {
		
		this.makeImpl(true, i);

		var lostPoint = util.getLostPoint(this);

		if (i == 0 || minLostPoint >  lostPoint) {
			minLostPoint = lostPoint;
			pattern = i;
		}
	}

	return pattern;
};

proto.createMovieClip = function(target_mc, instance_name, depth) {

	var qr_mc = target_mc.createEmptyMovieClip(instance_name, depth);
	var cs = 1;

	this.make();

	for (var row = 0; row < this.modules.length; row++) {
		
		var y = row * cs;
		
		for (var col = 0; col < this.modules[row].length; col++) {

			var x = col * cs;
			var dark = this.modules[row][col];
		
			if (dark) {
				qr_mc.beginFill(0, 100);
				qr_mc.moveTo(x, y);
				qr_mc.lineTo(x + cs, y);
				qr_mc.lineTo(x + cs, y + cs);
				qr_mc.lineTo(x, y + cs);
				qr_mc.endFill();
			}
		}
	}
	
	return qr_mc;
};

proto.setupTimingPattern = function() {
	
	for (var r = 8; r < this.moduleCount - 8; r++) {
		if (this.modules[r][6] != null) {
			continue;
		}
		this.modules[r][6] = (r % 2 == 0);
	}

	for (var c = 8; c < this.moduleCount - 8; c++) {
		if (this.modules[6][c] != null) {
			continue;
		}
		this.modules[6][c] = (c % 2 == 0);
	}
};

proto.setupPositionAdjustPattern = function() {

	var pos = util.getPatternPosition(this.typeNumber);
	
	for (var i = 0; i < pos.length; i++) {
	
		for (var j = 0; j < pos.length; j++) {
		
			var row = pos[i];
			var col = pos[j];
			
			if (this.modules[row][col] != null) {
				continue;
			}
			
			for (var r = -2; r <= 2; r++) {
			
				for (var c = -2; c <= 2; c++) {
				
					if (r == -2 || r == 2 || c == -2 || c == 2
							|| (r == 0 && c == 0) ) {
						this.modules[row + r][col + c] = true;
					} else {
						this.modules[row + r][col + c] = false;
					}
				}
			}
		}
	}
};

proto.setupTypeNumber = function(test) {

	var bits = util.getBCHTypeNumber(this.typeNumber);

	for (var i = 0; i < 18; i++) {
		var mod = (!test && ( (bits >> i) & 1) == 1);
		this.modules[Math.floor(i / 3)][i % 3 + this.moduleCount - 8 - 3] = mod;
	}

	for (var i = 0; i < 18; i++) {
		var mod = (!test && ( (bits >> i) & 1) == 1);
		this.modules[i % 3 + this.moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
	}
};

proto.setupTypeInfo = function(test, maskPattern) {

	var data = (this.errorCorrectLevel << 3) | maskPattern;
	var bits = util.getBCHTypeInfo(data);

	// vertical		
	for (var i = 0; i < 15; i++) {

		var mod = (!test && ( (bits >> i) & 1) == 1);

		if (i < 6) {
			this.modules[i][8] = mod;
		} else if (i < 8) {
			this.modules[i + 1][8] = mod;
		} else {
			this.modules[this.moduleCount - 15 + i][8] = mod;
		}
	}

	// horizontal
	for (var i = 0; i < 15; i++) {

		var mod = (!test && ( (bits >> i) & 1) == 1);
		
		if (i < 8) {
			this.modules[8][this.moduleCount - i - 1] = mod;
		} else if (i < 9) {
			this.modules[8][15 - i - 1 + 1] = mod;
		} else {
			this.modules[8][15 - i - 1] = mod;
		}
	}

	// fixed module
	this.modules[this.moduleCount - 8][8] = (!test);
};

proto.mapData = function(data, maskPattern) {
	
	var inc = -1;
	var row = this.moduleCount - 1;
	var bitIndex = 7;
	var byteIndex = 0;
	
	for (var col = this.moduleCount - 1; col > 0; col -= 2) {

		if (col == 6) col--;

		while (true) {

			for (var c = 0; c < 2; c++) {
				
				if (this.modules[row][col - c] == null) {
					
					var dark = false;

					if (byteIndex < data.length) {
						dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
					}

					var mask = util.getMask(maskPattern, row, col - c);

					if (mask) {
						dark = !dark;
					}
					
					this.modules[row][col - c] = dark;
					bitIndex--;

					if (bitIndex == -1) {
						byteIndex++;
						bitIndex = 7;
					}
				}
			}
							
			row += inc;

			if (row < 0 || this.moduleCount <= row) {
				row -= inc;
				inc = -inc;
				break;
			}
		}
	}
};

QRCode.PAD0 = 0xEC;
QRCode.PAD1 = 0x11;

QRCode.createData = function(typeNumber, errorCorrectLevel, dataList) {
	
	var rsBlocks = RSBlock.getRSBlocks(typeNumber, errorCorrectLevel);
	
	var buffer = new BitBuffer();
	
	for (var i = 0; i < dataList.length; i++) {
		var data = dataList[i];
		buffer.put(data.mode, 4);
		buffer.put(data.getLength(), util.getLengthInBits(data.mode, typeNumber) );
		data.write(buffer);
	}

	// calc num max data.
	var totalDataCount = 0;
	for (var i = 0; i < rsBlocks.length; i++) {
		totalDataCount += rsBlocks[i].dataCount;
	}

	if (buffer.getLengthInBits() > totalDataCount * 8) {
		throw new Error("code length overflow. ("
			+ buffer.getLengthInBits()
			+ ">"
			+  totalDataCount * 8
			+ ")");
	}

	// end code
	if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
		buffer.put(0, 4);
	}

	// padding
	while (buffer.getLengthInBits() % 8 != 0) {
		buffer.putBit(false);
	}

	// padding
	while (true) {
		
		if (buffer.getLengthInBits() >= totalDataCount * 8) {
			break;
		}
		buffer.put(QRCode.PAD0, 8);
		
		if (buffer.getLengthInBits() >= totalDataCount * 8) {
			break;
		}
		buffer.put(QRCode.PAD1, 8);
	}

	return QRCode.createBytes(buffer, rsBlocks);
};

QRCode.createBytes = function(buffer, rsBlocks) {

	var offset = 0;
	
	var maxDcCount = 0;
	var maxEcCount = 0;
	
	var dcdata = new Array(rsBlocks.length);
	var ecdata = new Array(rsBlocks.length);
	
	for (var r = 0; r < rsBlocks.length; r++) {

		var dcCount = rsBlocks[r].dataCount;
		var ecCount = rsBlocks[r].totalCount - dcCount;

		maxDcCount = Math.max(maxDcCount, dcCount);
		maxEcCount = Math.max(maxEcCount, ecCount);
		
		dcdata[r] = new Array(dcCount);
		
		for (var i = 0; i < dcdata[r].length; i++) {
			dcdata[r][i] = 0xff & buffer.buffer[i + offset];
		}
		offset += dcCount;
		
		var rsPoly = util.getErrorCorrectPolynomial(ecCount);
		var rawPoly = new Polynomial(dcdata[r], rsPoly.getLength() - 1);

		var modPoly = rawPoly.mod(rsPoly);
		ecdata[r] = new Array(rsPoly.getLength() - 1);
		for (var i = 0; i < ecdata[r].length; i++) {
            var modIndex = i + modPoly.getLength() - ecdata[r].length;
			ecdata[r][i] = (modIndex >= 0)? modPoly.get(modIndex) : 0;
		}

	}
	
	var totalCodeCount = 0;
	for (var i = 0; i < rsBlocks.length; i++) {
		totalCodeCount += rsBlocks[i].totalCount;
	}

	var data = new Array(totalCodeCount);
	var index = 0;

	for (var i = 0; i < maxDcCount; i++) {
		for (var r = 0; r < rsBlocks.length; r++) {
			if (i < dcdata[r].length) {
				data[index++] = dcdata[r][i];
			}
		}
	}

	for (var i = 0; i < maxEcCount; i++) {
		for (var r = 0; r < rsBlocks.length; r++) {
			if (i < ecdata[r].length) {
				data[index++] = ecdata[r][i];
			}
		}
	}

	return data;
};

module.exports = QRCode;


      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\RSBlock.js", {"./ErrorCorrectLevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\RSBlock.js
      return function (require, module, exports) {
// ErrorCorrectLevel
var ECL = require('./ErrorCorrectLevel');

function QRRSBlock(totalCount, dataCount) {
	this.totalCount = totalCount;
	this.dataCount  = dataCount;
}

QRRSBlock.RS_BLOCK_TABLE = [

	// L
	// M
	// Q
	// H

	// 1
	[1, 26, 19],
	[1, 26, 16],
	[1, 26, 13],
	[1, 26, 9],
	
	// 2
	[1, 44, 34],
	[1, 44, 28],
	[1, 44, 22],
	[1, 44, 16],

	// 3
	[1, 70, 55],
	[1, 70, 44],
	[2, 35, 17],
	[2, 35, 13],

	// 4		
	[1, 100, 80],
	[2, 50, 32],
	[2, 50, 24],
	[4, 25, 9],
	
	// 5
	[1, 134, 108],
	[2, 67, 43],
	[2, 33, 15, 2, 34, 16],
	[2, 33, 11, 2, 34, 12],
	
	// 6
	[2, 86, 68],
	[4, 43, 27],
	[4, 43, 19],
	[4, 43, 15],
	
	// 7		
	[2, 98, 78],
	[4, 49, 31],
	[2, 32, 14, 4, 33, 15],
	[4, 39, 13, 1, 40, 14],
	
	// 8
	[2, 121, 97],
	[2, 60, 38, 2, 61, 39],
	[4, 40, 18, 2, 41, 19],
	[4, 40, 14, 2, 41, 15],
	
	// 9
	[2, 146, 116],
	[3, 58, 36, 2, 59, 37],
	[4, 36, 16, 4, 37, 17],
	[4, 36, 12, 4, 37, 13],
	
	// 10		
	[2, 86, 68, 2, 87, 69],
	[4, 69, 43, 1, 70, 44],
	[6, 43, 19, 2, 44, 20],
	[6, 43, 15, 2, 44, 16],

	// 11
	[4, 101, 81],
	[1, 80, 50, 4, 81, 51],
	[4, 50, 22, 4, 51, 23],
	[3, 36, 12, 8, 37, 13],

	// 12
	[2, 116, 92, 2, 117, 93],
	[6, 58, 36, 2, 59, 37],
	[4, 46, 20, 6, 47, 21],
	[7, 42, 14, 4, 43, 15],

	// 13
	[4, 133, 107],
	[8, 59, 37, 1, 60, 38],
	[8, 44, 20, 4, 45, 21],
	[12, 33, 11, 4, 34, 12],

	// 14
	[3, 145, 115, 1, 146, 116],
	[4, 64, 40, 5, 65, 41],
	[11, 36, 16, 5, 37, 17],
	[11, 36, 12, 5, 37, 13],

	// 15
	[5, 109, 87, 1, 110, 88],
	[5, 65, 41, 5, 66, 42],
	[5, 54, 24, 7, 55, 25],
	[11, 36, 12],

	// 16
	[5, 122, 98, 1, 123, 99],
	[7, 73, 45, 3, 74, 46],
	[15, 43, 19, 2, 44, 20],
	[3, 45, 15, 13, 46, 16],

	// 17
	[1, 135, 107, 5, 136, 108],
	[10, 74, 46, 1, 75, 47],
	[1, 50, 22, 15, 51, 23],
	[2, 42, 14, 17, 43, 15],

	// 18
	[5, 150, 120, 1, 151, 121],
	[9, 69, 43, 4, 70, 44],
	[17, 50, 22, 1, 51, 23],
	[2, 42, 14, 19, 43, 15],

	// 19
	[3, 141, 113, 4, 142, 114],
	[3, 70, 44, 11, 71, 45],
	[17, 47, 21, 4, 48, 22],
	[9, 39, 13, 16, 40, 14],

	// 20
	[3, 135, 107, 5, 136, 108],
	[3, 67, 41, 13, 68, 42],
	[15, 54, 24, 5, 55, 25],
	[15, 43, 15, 10, 44, 16],

	// 21
	[4, 144, 116, 4, 145, 117],
	[17, 68, 42],
	[17, 50, 22, 6, 51, 23],
	[19, 46, 16, 6, 47, 17],

	// 22
	[2, 139, 111, 7, 140, 112],
	[17, 74, 46],
	[7, 54, 24, 16, 55, 25],
	[34, 37, 13],

	// 23
	[4, 151, 121, 5, 152, 122],
	[4, 75, 47, 14, 76, 48],
	[11, 54, 24, 14, 55, 25],
	[16, 45, 15, 14, 46, 16],

	// 24
	[6, 147, 117, 4, 148, 118],
	[6, 73, 45, 14, 74, 46],
	[11, 54, 24, 16, 55, 25],
	[30, 46, 16, 2, 47, 17],

	// 25
	[8, 132, 106, 4, 133, 107],
	[8, 75, 47, 13, 76, 48],
	[7, 54, 24, 22, 55, 25],
	[22, 45, 15, 13, 46, 16],

	// 26
	[10, 142, 114, 2, 143, 115],
	[19, 74, 46, 4, 75, 47],
	[28, 50, 22, 6, 51, 23],
	[33, 46, 16, 4, 47, 17],

	// 27
	[8, 152, 122, 4, 153, 123],
	[22, 73, 45, 3, 74, 46],
	[8, 53, 23, 26, 54, 24],
	[12, 45, 15, 28, 46, 16],

	// 28
	[3, 147, 117, 10, 148, 118],
	[3, 73, 45, 23, 74, 46],
	[4, 54, 24, 31, 55, 25],
	[11, 45, 15, 31, 46, 16],

	// 29
	[7, 146, 116, 7, 147, 117],
	[21, 73, 45, 7, 74, 46],
	[1, 53, 23, 37, 54, 24],
	[19, 45, 15, 26, 46, 16],

	// 30
	[5, 145, 115, 10, 146, 116],
	[19, 75, 47, 10, 76, 48],
	[15, 54, 24, 25, 55, 25],
	[23, 45, 15, 25, 46, 16],

	// 31
	[13, 145, 115, 3, 146, 116],
	[2, 74, 46, 29, 75, 47],
	[42, 54, 24, 1, 55, 25],
	[23, 45, 15, 28, 46, 16],

	// 32
	[17, 145, 115],
	[10, 74, 46, 23, 75, 47],
	[10, 54, 24, 35, 55, 25],
	[19, 45, 15, 35, 46, 16],

	// 33
	[17, 145, 115, 1, 146, 116],
	[14, 74, 46, 21, 75, 47],
	[29, 54, 24, 19, 55, 25],
	[11, 45, 15, 46, 46, 16],

	// 34
	[13, 145, 115, 6, 146, 116],
	[14, 74, 46, 23, 75, 47],
	[44, 54, 24, 7, 55, 25],
	[59, 46, 16, 1, 47, 17],

	// 35
	[12, 151, 121, 7, 152, 122],
	[12, 75, 47, 26, 76, 48],
	[39, 54, 24, 14, 55, 25],
	[22, 45, 15, 41, 46, 16],

	// 36
	[6, 151, 121, 14, 152, 122],
	[6, 75, 47, 34, 76, 48],
	[46, 54, 24, 10, 55, 25],
	[2, 45, 15, 64, 46, 16],

	// 37
	[17, 152, 122, 4, 153, 123],
	[29, 74, 46, 14, 75, 47],
	[49, 54, 24, 10, 55, 25],
	[24, 45, 15, 46, 46, 16],

	// 38
	[4, 152, 122, 18, 153, 123],
	[13, 74, 46, 32, 75, 47],
	[48, 54, 24, 14, 55, 25],
	[42, 45, 15, 32, 46, 16],

	// 39
	[20, 147, 117, 4, 148, 118],
	[40, 75, 47, 7, 76, 48],
	[43, 54, 24, 22, 55, 25],
	[10, 45, 15, 67, 46, 16],

	// 40
	[19, 148, 118, 6, 149, 119],
	[18, 75, 47, 31, 76, 48],
	[34, 54, 24, 34, 55, 25],
	[20, 45, 15, 61, 46, 16]
];

QRRSBlock.getRSBlocks = function(typeNumber, errorCorrectLevel) {
	
	var rsBlock = QRRSBlock.getRsBlockTable(typeNumber, errorCorrectLevel);
	
	if (rsBlock == undefined) {
		throw new Error("bad rs block @ typeNumber:" + typeNumber + "/errorCorrectLevel:" + errorCorrectLevel);
	}

	var length = rsBlock.length / 3;
	
	var list = new Array();
	
	for (var i = 0; i < length; i++) {

		var count = rsBlock[i * 3 + 0];
		var totalCount = rsBlock[i * 3 + 1];
		var dataCount  = rsBlock[i * 3 + 2];

		for (var j = 0; j < count; j++) {
			list.push(new QRRSBlock(totalCount, dataCount) );	
		}
	}
	
	return list;
}

QRRSBlock.getRsBlockTable = function(typeNumber, errorCorrectLevel) {

	switch(errorCorrectLevel) {
	case ECL.L :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
	case ECL.M :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
	case ECL.Q :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
	case ECL.H :
		return QRRSBlock.RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
	default :
		return undefined;
	}
}

module.exports = QRRSBlock;

      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\math.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\math.js
      return function (require, module, exports) {
var QRMath = {

	glog : function(n) {
	
		if (n < 1) {
			throw new Error("glog(" + n + ")");
		}
		
		return QRMath.LOG_TABLE[n];
	},
	
	gexp : function(n) {
	
		while (n < 0) {
			n += 255;
		}
	
		while (n >= 256) {
			n -= 255;
		}
	
		return QRMath.EXP_TABLE[n];
	},
	
	EXP_TABLE : new Array(256),
	
	LOG_TABLE : new Array(256)

};
	
for (var i = 0; i < 8; i++) {
	QRMath.EXP_TABLE[i] = 1 << i;
}
for (var i = 8; i < 256; i++) {
	QRMath.EXP_TABLE[i] = QRMath.EXP_TABLE[i - 4]
		^ QRMath.EXP_TABLE[i - 5]
		^ QRMath.EXP_TABLE[i - 6]
		^ QRMath.EXP_TABLE[i - 8];
}
for (var i = 0; i < 255; i++) {
	QRMath.LOG_TABLE[QRMath.EXP_TABLE[i] ] = i;
}

module.exports = QRMath;

      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\mode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\mode.js
      return function (require, module, exports) {
module.exports = {
	MODE_NUMBER :		1 << 0,
	MODE_ALPHA_NUM : 	1 << 1,
	MODE_8BIT_BYTE : 	1 << 2,
	MODE_KANJI :		1 << 3
};

      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\util.js", {"./Polynomial":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\Polynomial.js","./math":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\math.js","./mode":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\mode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qr.js\lib\util.js
      return function (require, module, exports) {
var Mode = require('./mode');
var Polynomial = require('./Polynomial');
var math = require('./math');

var QRMaskPattern = {
	PATTERN000 : 0,
	PATTERN001 : 1,
	PATTERN010 : 2,
	PATTERN011 : 3,
	PATTERN100 : 4,
	PATTERN101 : 5,
	PATTERN110 : 6,
	PATTERN111 : 7
};

var QRUtil = {

    PATTERN_POSITION_TABLE : [
	    [],
	    [6, 18],
	    [6, 22],
	    [6, 26],
	    [6, 30],
	    [6, 34],
	    [6, 22, 38],
	    [6, 24, 42],
	    [6, 26, 46],
	    [6, 28, 50],
	    [6, 30, 54],		
	    [6, 32, 58],
	    [6, 34, 62],
	    [6, 26, 46, 66],
	    [6, 26, 48, 70],
	    [6, 26, 50, 74],
	    [6, 30, 54, 78],
	    [6, 30, 56, 82],
	    [6, 30, 58, 86],
	    [6, 34, 62, 90],
	    [6, 28, 50, 72, 94],
	    [6, 26, 50, 74, 98],
	    [6, 30, 54, 78, 102],
	    [6, 28, 54, 80, 106],
	    [6, 32, 58, 84, 110],
	    [6, 30, 58, 86, 114],
	    [6, 34, 62, 90, 118],
	    [6, 26, 50, 74, 98, 122],
	    [6, 30, 54, 78, 102, 126],
	    [6, 26, 52, 78, 104, 130],
	    [6, 30, 56, 82, 108, 134],
	    [6, 34, 60, 86, 112, 138],
	    [6, 30, 58, 86, 114, 142],
	    [6, 34, 62, 90, 118, 146],
	    [6, 30, 54, 78, 102, 126, 150],
	    [6, 24, 50, 76, 102, 128, 154],
	    [6, 28, 54, 80, 106, 132, 158],
	    [6, 32, 58, 84, 110, 136, 162],
	    [6, 26, 54, 82, 110, 138, 166],
	    [6, 30, 58, 86, 114, 142, 170]
    ],

    G15 : (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0),
    G18 : (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0),
    G15_MASK : (1 << 14) | (1 << 12) | (1 << 10)	| (1 << 4) | (1 << 1),

    getBCHTypeInfo : function(data) {
	    var d = data << 10;
	    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) >= 0) {
		    d ^= (QRUtil.G15 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G15) ) ); 	
	    }
	    return ( (data << 10) | d) ^ QRUtil.G15_MASK;
    },

    getBCHTypeNumber : function(data) {
	    var d = data << 12;
	    while (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) >= 0) {
		    d ^= (QRUtil.G18 << (QRUtil.getBCHDigit(d) - QRUtil.getBCHDigit(QRUtil.G18) ) ); 	
	    }
	    return (data << 12) | d;
    },

    getBCHDigit : function(data) {

	    var digit = 0;

	    while (data != 0) {
		    digit++;
		    data >>>= 1;
	    }

	    return digit;
    },

    getPatternPosition : function(typeNumber) {
	    return QRUtil.PATTERN_POSITION_TABLE[typeNumber - 1];
    },

    getMask : function(maskPattern, i, j) {
	    
	    switch (maskPattern) {
		    
	    case QRMaskPattern.PATTERN000 : return (i + j) % 2 == 0;
	    case QRMaskPattern.PATTERN001 : return i % 2 == 0;
	    case QRMaskPattern.PATTERN010 : return j % 3 == 0;
	    case QRMaskPattern.PATTERN011 : return (i + j) % 3 == 0;
	    case QRMaskPattern.PATTERN100 : return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0;
	    case QRMaskPattern.PATTERN101 : return (i * j) % 2 + (i * j) % 3 == 0;
	    case QRMaskPattern.PATTERN110 : return ( (i * j) % 2 + (i * j) % 3) % 2 == 0;
	    case QRMaskPattern.PATTERN111 : return ( (i * j) % 3 + (i + j) % 2) % 2 == 0;

	    default :
		    throw new Error("bad maskPattern:" + maskPattern);
	    }
    },

    getErrorCorrectPolynomial : function(errorCorrectLength) {

	    var a = new Polynomial([1], 0);

	    for (var i = 0; i < errorCorrectLength; i++) {
		    a = a.multiply(new Polynomial([1, math.gexp(i)], 0) );
	    }

	    return a;
    },

    getLengthInBits : function(mode, type) {

	    if (1 <= type && type < 10) {

		    // 1 - 9

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 10;
		    case Mode.MODE_ALPHA_NUM 	: return 9;
		    case Mode.MODE_8BIT_BYTE	: return 8;
		    case Mode.MODE_KANJI  	: return 8;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else if (type < 27) {

		    // 10 - 26

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 12;
		    case Mode.MODE_ALPHA_NUM 	: return 11;
		    case Mode.MODE_8BIT_BYTE	: return 16;
		    case Mode.MODE_KANJI  	: return 10;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else if (type < 41) {

		    // 27 - 40

		    switch(mode) {
		    case Mode.MODE_NUMBER 	: return 14;
		    case Mode.MODE_ALPHA_NUM	: return 13;
		    case Mode.MODE_8BIT_BYTE	: return 16;
		    case Mode.MODE_KANJI  	: return 12;
		    default :
			    throw new Error("mode:" + mode);
		    }

	    } else {
		    throw new Error("type:" + type);
	    }
    },

    getLostPoint : function(qrCode) {
	    
	    var moduleCount = qrCode.getModuleCount();
	    
	    var lostPoint = 0;
	    
	    // LEVEL1
	    
	    for (var row = 0; row < moduleCount; row++) {

		    for (var col = 0; col < moduleCount; col++) {

			    var sameCount = 0;
			    var dark = qrCode.isDark(row, col);

				for (var r = -1; r <= 1; r++) {

				    if (row + r < 0 || moduleCount <= row + r) {
					    continue;
				    }

				    for (var c = -1; c <= 1; c++) {

					    if (col + c < 0 || moduleCount <= col + c) {
						    continue;
					    }

					    if (r == 0 && c == 0) {
						    continue;
					    }

					    if (dark == qrCode.isDark(row + r, col + c) ) {
						    sameCount++;
					    }
				    }
			    }

			    if (sameCount > 5) {
				    lostPoint += (3 + sameCount - 5);
			    }
		    }
	    }

	    // LEVEL2

	    for (var row = 0; row < moduleCount - 1; row++) {
		    for (var col = 0; col < moduleCount - 1; col++) {
			    var count = 0;
			    if (qrCode.isDark(row,     col    ) ) count++;
			    if (qrCode.isDark(row + 1, col    ) ) count++;
			    if (qrCode.isDark(row,     col + 1) ) count++;
			    if (qrCode.isDark(row + 1, col + 1) ) count++;
			    if (count == 0 || count == 4) {
				    lostPoint += 3;
			    }
		    }
	    }

	    // LEVEL3

	    for (var row = 0; row < moduleCount; row++) {
		    for (var col = 0; col < moduleCount - 6; col++) {
			    if (qrCode.isDark(row, col)
					    && !qrCode.isDark(row, col + 1)
					    &&  qrCode.isDark(row, col + 2)
					    &&  qrCode.isDark(row, col + 3)
					    &&  qrCode.isDark(row, col + 4)
					    && !qrCode.isDark(row, col + 5)
					    &&  qrCode.isDark(row, col + 6) ) {
				    lostPoint += 40;
			    }
		    }
	    }

	    for (var col = 0; col < moduleCount; col++) {
		    for (var row = 0; row < moduleCount - 6; row++) {
			    if (qrCode.isDark(row, col)
					    && !qrCode.isDark(row + 1, col)
					    &&  qrCode.isDark(row + 2, col)
					    &&  qrCode.isDark(row + 3, col)
					    &&  qrCode.isDark(row + 4, col)
					    && !qrCode.isDark(row + 5, col)
					    &&  qrCode.isDark(row + 6, col) ) {
				    lostPoint += 40;
			    }
		    }
	    }

	    // LEVEL4
	    
	    var darkCount = 0;

	    for (var col = 0; col < moduleCount; col++) {
		    for (var row = 0; row < moduleCount; row++) {
			    if (qrCode.isDark(row, col) ) {
				    darkCount++;
			    }
		    }
	    }
	    
	    var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
	    lostPoint += ratio * 10;

	    return lostPoint;		
    }
};

module.exports = QRUtil;

      };
    };
  }
}, {package:"qrcode.react>qr.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qrcode-generator\\qrcode.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qrcode-generator\qrcode.js
      return function (require, module, exports) {
//---------------------------------------------------------------------
//
// QR Code Generator for JavaScript
//
// Copyright (c) 2009 Kazuhiko Arase
//
// URL: http://www.d-project.com/
//
// Licensed under the MIT license:
//  http://www.opensource.org/licenses/mit-license.php
//
// The word 'QR Code' is registered trademark of
// DENSO WAVE INCORPORATED
//  http://www.denso-wave.com/qrcode/faqpatent-e.html
//
//---------------------------------------------------------------------

var qrcode = function() {

  //---------------------------------------------------------------------
  // qrcode
  //---------------------------------------------------------------------

  /**
   * qrcode
   * @param typeNumber 1 to 40
   * @param errorCorrectionLevel 'L','M','Q','H'
   */
  var qrcode = function(typeNumber, errorCorrectionLevel) {

    var PAD0 = 0xEC;
    var PAD1 = 0x11;

    var _typeNumber = typeNumber;
    var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
    var _modules = null;
    var _moduleCount = 0;
    var _dataCache = null;
    var _dataList = [];

    var _this = {};

    var makeImpl = function(test, maskPattern) {

      _moduleCount = _typeNumber * 4 + 17;
      _modules = function(moduleCount) {
        var modules = new Array(moduleCount);
        for (var row = 0; row < moduleCount; row += 1) {
          modules[row] = new Array(moduleCount);
          for (var col = 0; col < moduleCount; col += 1) {
            modules[row][col] = null;
          }
        }
        return modules;
      }(_moduleCount);

      setupPositionProbePattern(0, 0);
      setupPositionProbePattern(_moduleCount - 7, 0);
      setupPositionProbePattern(0, _moduleCount - 7);
      setupPositionAdjustPattern();
      setupTimingPattern();
      setupTypeInfo(test, maskPattern);

      if (_typeNumber >= 7) {
        setupTypeNumber(test);
      }

      if (_dataCache == null) {
        _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
      }

      mapData(_dataCache, maskPattern);
    };

    var setupPositionProbePattern = function(row, col) {

      for (var r = -1; r <= 7; r += 1) {

        if (row + r <= -1 || _moduleCount <= row + r) continue;

        for (var c = -1; c <= 7; c += 1) {

          if (col + c <= -1 || _moduleCount <= col + c) continue;

          if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
              || (0 <= c && c <= 6 && (r == 0 || r == 6) )
              || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
            _modules[row + r][col + c] = true;
          } else {
            _modules[row + r][col + c] = false;
          }
        }
      }
    };

    var getBestMaskPattern = function() {

      var minLostPoint = 0;
      var pattern = 0;

      for (var i = 0; i < 8; i += 1) {

        makeImpl(true, i);

        var lostPoint = QRUtil.getLostPoint(_this);

        if (i == 0 || minLostPoint > lostPoint) {
          minLostPoint = lostPoint;
          pattern = i;
        }
      }

      return pattern;
    };

    var setupTimingPattern = function() {

      for (var r = 8; r < _moduleCount - 8; r += 1) {
        if (_modules[r][6] != null) {
          continue;
        }
        _modules[r][6] = (r % 2 == 0);
      }

      for (var c = 8; c < _moduleCount - 8; c += 1) {
        if (_modules[6][c] != null) {
          continue;
        }
        _modules[6][c] = (c % 2 == 0);
      }
    };

    var setupPositionAdjustPattern = function() {

      var pos = QRUtil.getPatternPosition(_typeNumber);

      for (var i = 0; i < pos.length; i += 1) {

        for (var j = 0; j < pos.length; j += 1) {

          var row = pos[i];
          var col = pos[j];

          if (_modules[row][col] != null) {
            continue;
          }

          for (var r = -2; r <= 2; r += 1) {

            for (var c = -2; c <= 2; c += 1) {

              if (r == -2 || r == 2 || c == -2 || c == 2
                  || (r == 0 && c == 0) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        }
      }
    };

    var setupTypeNumber = function(test) {

      var bits = QRUtil.getBCHTypeNumber(_typeNumber);

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
      }

      for (var i = 0; i < 18; i += 1) {
        var mod = (!test && ( (bits >> i) & 1) == 1);
        _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
      }
    };

    var setupTypeInfo = function(test, maskPattern) {

      var data = (_errorCorrectionLevel << 3) | maskPattern;
      var bits = QRUtil.getBCHTypeInfo(data);

      // vertical
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 6) {
          _modules[i][8] = mod;
        } else if (i < 8) {
          _modules[i + 1][8] = mod;
        } else {
          _modules[_moduleCount - 15 + i][8] = mod;
        }
      }

      // horizontal
      for (var i = 0; i < 15; i += 1) {

        var mod = (!test && ( (bits >> i) & 1) == 1);

        if (i < 8) {
          _modules[8][_moduleCount - i - 1] = mod;
        } else if (i < 9) {
          _modules[8][15 - i - 1 + 1] = mod;
        } else {
          _modules[8][15 - i - 1] = mod;
        }
      }

      // fixed module
      _modules[_moduleCount - 8][8] = (!test);
    };

    var mapData = function(data, maskPattern) {

      var inc = -1;
      var row = _moduleCount - 1;
      var bitIndex = 7;
      var byteIndex = 0;
      var maskFunc = QRUtil.getMaskFunction(maskPattern);

      for (var col = _moduleCount - 1; col > 0; col -= 2) {

        if (col == 6) col -= 1;

        while (true) {

          for (var c = 0; c < 2; c += 1) {

            if (_modules[row][col - c] == null) {

              var dark = false;

              if (byteIndex < data.length) {
                dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
              }

              var mask = maskFunc(row, col - c);

              if (mask) {
                dark = !dark;
              }

              _modules[row][col - c] = dark;
              bitIndex -= 1;

              if (bitIndex == -1) {
                byteIndex += 1;
                bitIndex = 7;
              }
            }
          }

          row += inc;

          if (row < 0 || _moduleCount <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    };

    var createBytes = function(buffer, rsBlocks) {

      var offset = 0;

      var maxDcCount = 0;
      var maxEcCount = 0;

      var dcdata = new Array(rsBlocks.length);
      var ecdata = new Array(rsBlocks.length);

      for (var r = 0; r < rsBlocks.length; r += 1) {

        var dcCount = rsBlocks[r].dataCount;
        var ecCount = rsBlocks[r].totalCount - dcCount;

        maxDcCount = Math.max(maxDcCount, dcCount);
        maxEcCount = Math.max(maxEcCount, ecCount);

        dcdata[r] = new Array(dcCount);

        for (var i = 0; i < dcdata[r].length; i += 1) {
          dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
        }
        offset += dcCount;

        var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
        var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);

        var modPoly = rawPoly.mod(rsPoly);
        ecdata[r] = new Array(rsPoly.getLength() - 1);
        for (var i = 0; i < ecdata[r].length; i += 1) {
          var modIndex = i + modPoly.getLength() - ecdata[r].length;
          ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
        }
      }

      var totalCodeCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalCodeCount += rsBlocks[i].totalCount;
      }

      var data = new Array(totalCodeCount);
      var index = 0;

      for (var i = 0; i < maxDcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < dcdata[r].length) {
            data[index] = dcdata[r][i];
            index += 1;
          }
        }
      }

      for (var i = 0; i < maxEcCount; i += 1) {
        for (var r = 0; r < rsBlocks.length; r += 1) {
          if (i < ecdata[r].length) {
            data[index] = ecdata[r][i];
            index += 1;
          }
        }
      }

      return data;
    };

    var createData = function(typeNumber, errorCorrectionLevel, dataList) {

      var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);

      var buffer = qrBitBuffer();

      for (var i = 0; i < dataList.length; i += 1) {
        var data = dataList[i];
        buffer.put(data.getMode(), 4);
        buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
        data.write(buffer);
      }

      // calc num max data.
      var totalDataCount = 0;
      for (var i = 0; i < rsBlocks.length; i += 1) {
        totalDataCount += rsBlocks[i].dataCount;
      }

      if (buffer.getLengthInBits() > totalDataCount * 8) {
        throw 'code length overflow. ('
          + buffer.getLengthInBits()
          + '>'
          + totalDataCount * 8
          + ')';
      }

      // end code
      if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
        buffer.put(0, 4);
      }

      // padding
      while (buffer.getLengthInBits() % 8 != 0) {
        buffer.putBit(false);
      }

      // padding
      while (true) {

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD0, 8);

        if (buffer.getLengthInBits() >= totalDataCount * 8) {
          break;
        }
        buffer.put(PAD1, 8);
      }

      return createBytes(buffer, rsBlocks);
    };

    _this.addData = function(data, mode) {

      mode = mode || 'Byte';

      var newData = null;

      switch(mode) {
      case 'Numeric' :
        newData = qrNumber(data);
        break;
      case 'Alphanumeric' :
        newData = qrAlphaNum(data);
        break;
      case 'Byte' :
        newData = qr8BitByte(data);
        break;
      case 'Kanji' :
        newData = qrKanji(data);
        break;
      default :
        throw 'mode:' + mode;
      }

      _dataList.push(newData);
      _dataCache = null;
    };

    _this.isDark = function(row, col) {
      if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
        throw row + ',' + col;
      }
      return _modules[row][col];
    };

    _this.getModuleCount = function() {
      return _moduleCount;
    };

    _this.make = function() {
      if (_typeNumber < 1) {
        var typeNumber = 1;

        for (; typeNumber < 40; typeNumber++) {
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
          var buffer = qrBitBuffer();

          for (var i = 0; i < _dataList.length; i++) {
            var data = _dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }

          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i++) {
            totalDataCount += rsBlocks[i].dataCount;
          }

          if (buffer.getLengthInBits() <= totalDataCount * 8) {
            break;
          }
        }

        _typeNumber = typeNumber;
      }

      makeImpl(false, getBestMaskPattern() );
    };

    _this.createTableTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var qrHtml = '';

      qrHtml += '<table style="';
      qrHtml += ' border-width: 0px; border-style: none;';
      qrHtml += ' border-collapse: collapse;';
      qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
      qrHtml += '">';
      qrHtml += '<tbody>';

      for (var r = 0; r < _this.getModuleCount(); r += 1) {

        qrHtml += '<tr>';

        for (var c = 0; c < _this.getModuleCount(); c += 1) {
          qrHtml += '<td style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: 0px;';
          qrHtml += ' width: ' + cellSize + 'px;';
          qrHtml += ' height: ' + cellSize + 'px;';
          qrHtml += ' background-color: ';
          qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
          qrHtml += ';';
          qrHtml += '"/>';
        }

        qrHtml += '</tr>';
      }

      qrHtml += '</tbody>';
      qrHtml += '</table>';

      return qrHtml;
    };

    _this.createSvgTag = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;
      var size = _this.getModuleCount() * cellSize + margin * 2;
      var c, mc, r, mr, qrSvg='', rect;

      rect = 'l' + cellSize + ',0 0,' + cellSize +
        ' -' + cellSize + ',0 0,-' + cellSize + 'z ';

      qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
      qrSvg += ' width="' + size + 'px"';
      qrSvg += ' height="' + size + 'px"';
      qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
      qrSvg += ' preserveAspectRatio="xMinYMin meet">';
      qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
      qrSvg += '<path d="';

      for (r = 0; r < _this.getModuleCount(); r += 1) {
        mr = r * cellSize + margin;
        for (c = 0; c < _this.getModuleCount(); c += 1) {
          if (_this.isDark(r, c) ) {
            mc = c*cellSize+margin;
            qrSvg += 'M' + mc + ',' + mr + rect;
          }
        }
      }

      qrSvg += '" stroke="transparent" fill="black"/>';
      qrSvg += '</svg>';

      return qrSvg;
    };

    _this.createDataURL = function(cellSize, margin) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      return createDataURL(size, size, function(x, y) {
        if (min <= x && x < max && min <= y && y < max) {
          var c = Math.floor( (x - min) / cellSize);
          var r = Math.floor( (y - min) / cellSize);
          return _this.isDark(r, c)? 0 : 1;
        } else {
          return 1;
        }
      } );
    };

    _this.createImgTag = function(cellSize, margin, alt) {

      cellSize = cellSize || 2;
      margin = (typeof margin == 'undefined')? cellSize * 4 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;

      var img = '';
      img += '<img';
      img += '\u0020src="';
      img += _this.createDataURL(cellSize, margin);
      img += '"';
      img += '\u0020width="';
      img += size;
      img += '"';
      img += '\u0020height="';
      img += size;
      img += '"';
      if (alt) {
        img += '\u0020alt="';
        img += alt;
        img += '"';
      }
      img += '/>';

      return img;
    };

    var _createHalfASCII = function(margin) {
      var cellSize = 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r1, r2, p;

      var blocks = {
        '': '',
        ' ': '',
        ' ': '',
        '  ': ' '
      };

      var ascii = '';
      for (y = 0; y < size; y += 2) {
        r1 = Math.floor((y - min) / cellSize);
        r2 = Math.floor((y + 1 - min) / cellSize);
        for (x = 0; x < size; x += 1) {
          p = '';

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
            p = ' ';
          }

          if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
            p += ' ';
          }
          else {
            p += '';
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          ascii += blocks[p];
        }

        ascii += '\n';
      }

      if (size % 2) {
        return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('');
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.createASCII = function(cellSize, margin) {
      cellSize = cellSize || 1;

      if (cellSize < 2) {
        return _createHalfASCII(margin);
      }

      cellSize -= 1;
      margin = (typeof margin == 'undefined')? cellSize * 2 : margin;

      var size = _this.getModuleCount() * cellSize + margin * 2;
      var min = margin;
      var max = size - margin;

      var y, x, r, p;

      var white = Array(cellSize+1).join('');
      var black = Array(cellSize+1).join('  ');

      var ascii = '';
      var line = '';
      for (y = 0; y < size; y += 1) {
        r = Math.floor( (y - min) / cellSize);
        line = '';
        for (x = 0; x < size; x += 1) {
          p = 1;

          if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
            p = 0;
          }

          // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
          line += p ? white : black;
        }

        for (r = 0; r < cellSize; r += 1) {
          ascii += line + '\n';
        }
      }

      return ascii.substring(0, ascii.length-1);
    };

    _this.renderTo2dContext = function(context, cellSize) {
      cellSize = cellSize || 2;
      var length = _this.getModuleCount();
      for (var row = 0; row < length; row++) {
        for (var col = 0; col < length; col++) {
          context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
          context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
        }
      }
    }

    return _this;
  };

  //---------------------------------------------------------------------
  // qrcode.stringToBytes
  //---------------------------------------------------------------------

  qrcode.stringToBytesFuncs = {
    'default' : function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        bytes.push(c & 0xff);
      }
      return bytes;
    }
  };

  qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];

  //---------------------------------------------------------------------
  // qrcode.createStringToBytes
  //---------------------------------------------------------------------

  /**
   * @param unicodeData base64 string of byte array.
   * [16bit Unicode],[16bit Bytes], ...
   * @param numChars
   */
  qrcode.createStringToBytes = function(unicodeData, numChars) {

    // create conversion map.

    var unicodeMap = function() {

      var bin = base64DecodeInputStream(unicodeData);
      var read = function() {
        var b = bin.read();
        if (b == -1) throw 'eof';
        return b;
      };

      var count = 0;
      var unicodeMap = {};
      while (true) {
        var b0 = bin.read();
        if (b0 == -1) break;
        var b1 = read();
        var b2 = read();
        var b3 = read();
        var k = String.fromCharCode( (b0 << 8) | b1);
        var v = (b2 << 8) | b3;
        unicodeMap[k] = v;
        count += 1;
      }
      if (count != numChars) {
        throw count + ' != ' + numChars;
      }

      return unicodeMap;
    }();

    var unknownChar = '?'.charCodeAt(0);

    return function(s) {
      var bytes = [];
      for (var i = 0; i < s.length; i += 1) {
        var c = s.charCodeAt(i);
        if (c < 128) {
          bytes.push(c);
        } else {
          var b = unicodeMap[s.charAt(i)];
          if (typeof b == 'number') {
            if ( (b & 0xff) == b) {
              // 1byte
              bytes.push(b);
            } else {
              // 2bytes
              bytes.push(b >>> 8);
              bytes.push(b & 0xff);
            }
          } else {
            bytes.push(unknownChar);
          }
        }
      }
      return bytes;
    };
  };

  //---------------------------------------------------------------------
  // QRMode
  //---------------------------------------------------------------------

  var QRMode = {
    MODE_NUMBER :    1 << 0,
    MODE_ALPHA_NUM : 1 << 1,
    MODE_8BIT_BYTE : 1 << 2,
    MODE_KANJI :     1 << 3
  };

  //---------------------------------------------------------------------
  // QRErrorCorrectionLevel
  //---------------------------------------------------------------------

  var QRErrorCorrectionLevel = {
    L : 1,
    M : 0,
    Q : 3,
    H : 2
  };

  //---------------------------------------------------------------------
  // QRMaskPattern
  //---------------------------------------------------------------------

  var QRMaskPattern = {
    PATTERN000 : 0,
    PATTERN001 : 1,
    PATTERN010 : 2,
    PATTERN011 : 3,
    PATTERN100 : 4,
    PATTERN101 : 5,
    PATTERN110 : 6,
    PATTERN111 : 7
  };

  //---------------------------------------------------------------------
  // QRUtil
  //---------------------------------------------------------------------

  var QRUtil = function() {

    var PATTERN_POSITION_TABLE = [
      [],
      [6, 18],
      [6, 22],
      [6, 26],
      [6, 30],
      [6, 34],
      [6, 22, 38],
      [6, 24, 42],
      [6, 26, 46],
      [6, 28, 50],
      [6, 30, 54],
      [6, 32, 58],
      [6, 34, 62],
      [6, 26, 46, 66],
      [6, 26, 48, 70],
      [6, 26, 50, 74],
      [6, 30, 54, 78],
      [6, 30, 56, 82],
      [6, 30, 58, 86],
      [6, 34, 62, 90],
      [6, 28, 50, 72, 94],
      [6, 26, 50, 74, 98],
      [6, 30, 54, 78, 102],
      [6, 28, 54, 80, 106],
      [6, 32, 58, 84, 110],
      [6, 30, 58, 86, 114],
      [6, 34, 62, 90, 118],
      [6, 26, 50, 74, 98, 122],
      [6, 30, 54, 78, 102, 126],
      [6, 26, 52, 78, 104, 130],
      [6, 30, 56, 82, 108, 134],
      [6, 34, 60, 86, 112, 138],
      [6, 30, 58, 86, 114, 142],
      [6, 34, 62, 90, 118, 146],
      [6, 30, 54, 78, 102, 126, 150],
      [6, 24, 50, 76, 102, 128, 154],
      [6, 28, 54, 80, 106, 132, 158],
      [6, 32, 58, 84, 110, 136, 162],
      [6, 26, 54, 82, 110, 138, 166],
      [6, 30, 58, 86, 114, 142, 170]
    ];
    var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
    var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
    var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);

    var _this = {};

    var getBCHDigit = function(data) {
      var digit = 0;
      while (data != 0) {
        digit += 1;
        data >>>= 1;
      }
      return digit;
    };

    _this.getBCHTypeInfo = function(data) {
      var d = data << 10;
      while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
        d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
      }
      return ( (data << 10) | d) ^ G15_MASK;
    };

    _this.getBCHTypeNumber = function(data) {
      var d = data << 12;
      while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
        d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
      }
      return (data << 12) | d;
    };

    _this.getPatternPosition = function(typeNumber) {
      return PATTERN_POSITION_TABLE[typeNumber - 1];
    };

    _this.getMaskFunction = function(maskPattern) {

      switch (maskPattern) {

      case QRMaskPattern.PATTERN000 :
        return function(i, j) { return (i + j) % 2 == 0; };
      case QRMaskPattern.PATTERN001 :
        return function(i, j) { return i % 2 == 0; };
      case QRMaskPattern.PATTERN010 :
        return function(i, j) { return j % 3 == 0; };
      case QRMaskPattern.PATTERN011 :
        return function(i, j) { return (i + j) % 3 == 0; };
      case QRMaskPattern.PATTERN100 :
        return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
      case QRMaskPattern.PATTERN101 :
        return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
      case QRMaskPattern.PATTERN110 :
        return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
      case QRMaskPattern.PATTERN111 :
        return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };

      default :
        throw 'bad maskPattern:' + maskPattern;
      }
    };

    _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
      var a = qrPolynomial([1], 0);
      for (var i = 0; i < errorCorrectLength; i += 1) {
        a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
      }
      return a;
    };

    _this.getLengthInBits = function(mode, type) {

      if (1 <= type && type < 10) {

        // 1 - 9

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 10;
        case QRMode.MODE_ALPHA_NUM : return 9;
        case QRMode.MODE_8BIT_BYTE : return 8;
        case QRMode.MODE_KANJI     : return 8;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 27) {

        // 10 - 26

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 12;
        case QRMode.MODE_ALPHA_NUM : return 11;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 10;
        default :
          throw 'mode:' + mode;
        }

      } else if (type < 41) {

        // 27 - 40

        switch(mode) {
        case QRMode.MODE_NUMBER    : return 14;
        case QRMode.MODE_ALPHA_NUM : return 13;
        case QRMode.MODE_8BIT_BYTE : return 16;
        case QRMode.MODE_KANJI     : return 12;
        default :
          throw 'mode:' + mode;
        }

      } else {
        throw 'type:' + type;
      }
    };

    _this.getLostPoint = function(qrcode) {

      var moduleCount = qrcode.getModuleCount();

      var lostPoint = 0;

      // LEVEL1

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount; col += 1) {

          var sameCount = 0;
          var dark = qrcode.isDark(row, col);

          for (var r = -1; r <= 1; r += 1) {

            if (row + r < 0 || moduleCount <= row + r) {
              continue;
            }

            for (var c = -1; c <= 1; c += 1) {

              if (col + c < 0 || moduleCount <= col + c) {
                continue;
              }

              if (r == 0 && c == 0) {
                continue;
              }

              if (dark == qrcode.isDark(row + r, col + c) ) {
                sameCount += 1;
              }
            }
          }

          if (sameCount > 5) {
            lostPoint += (3 + sameCount - 5);
          }
        }
      };

      // LEVEL2

      for (var row = 0; row < moduleCount - 1; row += 1) {
        for (var col = 0; col < moduleCount - 1; col += 1) {
          var count = 0;
          if (qrcode.isDark(row, col) ) count += 1;
          if (qrcode.isDark(row + 1, col) ) count += 1;
          if (qrcode.isDark(row, col + 1) ) count += 1;
          if (qrcode.isDark(row + 1, col + 1) ) count += 1;
          if (count == 0 || count == 4) {
            lostPoint += 3;
          }
        }
      }

      // LEVEL3

      for (var row = 0; row < moduleCount; row += 1) {
        for (var col = 0; col < moduleCount - 6; col += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row, col + 1)
              &&  qrcode.isDark(row, col + 2)
              &&  qrcode.isDark(row, col + 3)
              &&  qrcode.isDark(row, col + 4)
              && !qrcode.isDark(row, col + 5)
              &&  qrcode.isDark(row, col + 6) ) {
            lostPoint += 40;
          }
        }
      }

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount - 6; row += 1) {
          if (qrcode.isDark(row, col)
              && !qrcode.isDark(row + 1, col)
              &&  qrcode.isDark(row + 2, col)
              &&  qrcode.isDark(row + 3, col)
              &&  qrcode.isDark(row + 4, col)
              && !qrcode.isDark(row + 5, col)
              &&  qrcode.isDark(row + 6, col) ) {
            lostPoint += 40;
          }
        }
      }

      // LEVEL4

      var darkCount = 0;

      for (var col = 0; col < moduleCount; col += 1) {
        for (var row = 0; row < moduleCount; row += 1) {
          if (qrcode.isDark(row, col) ) {
            darkCount += 1;
          }
        }
      }

      var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
      lostPoint += ratio * 10;

      return lostPoint;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // QRMath
  //---------------------------------------------------------------------

  var QRMath = function() {

    var EXP_TABLE = new Array(256);
    var LOG_TABLE = new Array(256);

    // initialize tables
    for (var i = 0; i < 8; i += 1) {
      EXP_TABLE[i] = 1 << i;
    }
    for (var i = 8; i < 256; i += 1) {
      EXP_TABLE[i] = EXP_TABLE[i - 4]
        ^ EXP_TABLE[i - 5]
        ^ EXP_TABLE[i - 6]
        ^ EXP_TABLE[i - 8];
    }
    for (var i = 0; i < 255; i += 1) {
      LOG_TABLE[EXP_TABLE[i] ] = i;
    }

    var _this = {};

    _this.glog = function(n) {

      if (n < 1) {
        throw 'glog(' + n + ')';
      }

      return LOG_TABLE[n];
    };

    _this.gexp = function(n) {

      while (n < 0) {
        n += 255;
      }

      while (n >= 256) {
        n -= 255;
      }

      return EXP_TABLE[n];
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrPolynomial
  //---------------------------------------------------------------------

  function qrPolynomial(num, shift) {

    if (typeof num.length == 'undefined') {
      throw num.length + '/' + shift;
    }

    var _num = function() {
      var offset = 0;
      while (offset < num.length && num[offset] == 0) {
        offset += 1;
      }
      var _num = new Array(num.length - offset + shift);
      for (var i = 0; i < num.length - offset; i += 1) {
        _num[i] = num[i + offset];
      }
      return _num;
    }();

    var _this = {};

    _this.getAt = function(index) {
      return _num[index];
    };

    _this.getLength = function() {
      return _num.length;
    };

    _this.multiply = function(e) {

      var num = new Array(_this.getLength() + e.getLength() - 1);

      for (var i = 0; i < _this.getLength(); i += 1) {
        for (var j = 0; j < e.getLength(); j += 1) {
          num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
        }
      }

      return qrPolynomial(num, 0);
    };

    _this.mod = function(e) {

      if (_this.getLength() - e.getLength() < 0) {
        return _this;
      }

      var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );

      var num = new Array(_this.getLength() );
      for (var i = 0; i < _this.getLength(); i += 1) {
        num[i] = _this.getAt(i);
      }

      for (var i = 0; i < e.getLength(); i += 1) {
        num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
      }

      // recursive call
      return qrPolynomial(num, 0).mod(e);
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // QRRSBlock
  //---------------------------------------------------------------------

  var QRRSBlock = function() {

    var RS_BLOCK_TABLE = [

      // L
      // M
      // Q
      // H

      // 1
      [1, 26, 19],
      [1, 26, 16],
      [1, 26, 13],
      [1, 26, 9],

      // 2
      [1, 44, 34],
      [1, 44, 28],
      [1, 44, 22],
      [1, 44, 16],

      // 3
      [1, 70, 55],
      [1, 70, 44],
      [2, 35, 17],
      [2, 35, 13],

      // 4
      [1, 100, 80],
      [2, 50, 32],
      [2, 50, 24],
      [4, 25, 9],

      // 5
      [1, 134, 108],
      [2, 67, 43],
      [2, 33, 15, 2, 34, 16],
      [2, 33, 11, 2, 34, 12],

      // 6
      [2, 86, 68],
      [4, 43, 27],
      [4, 43, 19],
      [4, 43, 15],

      // 7
      [2, 98, 78],
      [4, 49, 31],
      [2, 32, 14, 4, 33, 15],
      [4, 39, 13, 1, 40, 14],

      // 8
      [2, 121, 97],
      [2, 60, 38, 2, 61, 39],
      [4, 40, 18, 2, 41, 19],
      [4, 40, 14, 2, 41, 15],

      // 9
      [2, 146, 116],
      [3, 58, 36, 2, 59, 37],
      [4, 36, 16, 4, 37, 17],
      [4, 36, 12, 4, 37, 13],

      // 10
      [2, 86, 68, 2, 87, 69],
      [4, 69, 43, 1, 70, 44],
      [6, 43, 19, 2, 44, 20],
      [6, 43, 15, 2, 44, 16],

      // 11
      [4, 101, 81],
      [1, 80, 50, 4, 81, 51],
      [4, 50, 22, 4, 51, 23],
      [3, 36, 12, 8, 37, 13],

      // 12
      [2, 116, 92, 2, 117, 93],
      [6, 58, 36, 2, 59, 37],
      [4, 46, 20, 6, 47, 21],
      [7, 42, 14, 4, 43, 15],

      // 13
      [4, 133, 107],
      [8, 59, 37, 1, 60, 38],
      [8, 44, 20, 4, 45, 21],
      [12, 33, 11, 4, 34, 12],

      // 14
      [3, 145, 115, 1, 146, 116],
      [4, 64, 40, 5, 65, 41],
      [11, 36, 16, 5, 37, 17],
      [11, 36, 12, 5, 37, 13],

      // 15
      [5, 109, 87, 1, 110, 88],
      [5, 65, 41, 5, 66, 42],
      [5, 54, 24, 7, 55, 25],
      [11, 36, 12, 7, 37, 13],

      // 16
      [5, 122, 98, 1, 123, 99],
      [7, 73, 45, 3, 74, 46],
      [15, 43, 19, 2, 44, 20],
      [3, 45, 15, 13, 46, 16],

      // 17
      [1, 135, 107, 5, 136, 108],
      [10, 74, 46, 1, 75, 47],
      [1, 50, 22, 15, 51, 23],
      [2, 42, 14, 17, 43, 15],

      // 18
      [5, 150, 120, 1, 151, 121],
      [9, 69, 43, 4, 70, 44],
      [17, 50, 22, 1, 51, 23],
      [2, 42, 14, 19, 43, 15],

      // 19
      [3, 141, 113, 4, 142, 114],
      [3, 70, 44, 11, 71, 45],
      [17, 47, 21, 4, 48, 22],
      [9, 39, 13, 16, 40, 14],

      // 20
      [3, 135, 107, 5, 136, 108],
      [3, 67, 41, 13, 68, 42],
      [15, 54, 24, 5, 55, 25],
      [15, 43, 15, 10, 44, 16],

      // 21
      [4, 144, 116, 4, 145, 117],
      [17, 68, 42],
      [17, 50, 22, 6, 51, 23],
      [19, 46, 16, 6, 47, 17],

      // 22
      [2, 139, 111, 7, 140, 112],
      [17, 74, 46],
      [7, 54, 24, 16, 55, 25],
      [34, 37, 13],

      // 23
      [4, 151, 121, 5, 152, 122],
      [4, 75, 47, 14, 76, 48],
      [11, 54, 24, 14, 55, 25],
      [16, 45, 15, 14, 46, 16],

      // 24
      [6, 147, 117, 4, 148, 118],
      [6, 73, 45, 14, 74, 46],
      [11, 54, 24, 16, 55, 25],
      [30, 46, 16, 2, 47, 17],

      // 25
      [8, 132, 106, 4, 133, 107],
      [8, 75, 47, 13, 76, 48],
      [7, 54, 24, 22, 55, 25],
      [22, 45, 15, 13, 46, 16],

      // 26
      [10, 142, 114, 2, 143, 115],
      [19, 74, 46, 4, 75, 47],
      [28, 50, 22, 6, 51, 23],
      [33, 46, 16, 4, 47, 17],

      // 27
      [8, 152, 122, 4, 153, 123],
      [22, 73, 45, 3, 74, 46],
      [8, 53, 23, 26, 54, 24],
      [12, 45, 15, 28, 46, 16],

      // 28
      [3, 147, 117, 10, 148, 118],
      [3, 73, 45, 23, 74, 46],
      [4, 54, 24, 31, 55, 25],
      [11, 45, 15, 31, 46, 16],

      // 29
      [7, 146, 116, 7, 147, 117],
      [21, 73, 45, 7, 74, 46],
      [1, 53, 23, 37, 54, 24],
      [19, 45, 15, 26, 46, 16],

      // 30
      [5, 145, 115, 10, 146, 116],
      [19, 75, 47, 10, 76, 48],
      [15, 54, 24, 25, 55, 25],
      [23, 45, 15, 25, 46, 16],

      // 31
      [13, 145, 115, 3, 146, 116],
      [2, 74, 46, 29, 75, 47],
      [42, 54, 24, 1, 55, 25],
      [23, 45, 15, 28, 46, 16],

      // 32
      [17, 145, 115],
      [10, 74, 46, 23, 75, 47],
      [10, 54, 24, 35, 55, 25],
      [19, 45, 15, 35, 46, 16],

      // 33
      [17, 145, 115, 1, 146, 116],
      [14, 74, 46, 21, 75, 47],
      [29, 54, 24, 19, 55, 25],
      [11, 45, 15, 46, 46, 16],

      // 34
      [13, 145, 115, 6, 146, 116],
      [14, 74, 46, 23, 75, 47],
      [44, 54, 24, 7, 55, 25],
      [59, 46, 16, 1, 47, 17],

      // 35
      [12, 151, 121, 7, 152, 122],
      [12, 75, 47, 26, 76, 48],
      [39, 54, 24, 14, 55, 25],
      [22, 45, 15, 41, 46, 16],

      // 36
      [6, 151, 121, 14, 152, 122],
      [6, 75, 47, 34, 76, 48],
      [46, 54, 24, 10, 55, 25],
      [2, 45, 15, 64, 46, 16],

      // 37
      [17, 152, 122, 4, 153, 123],
      [29, 74, 46, 14, 75, 47],
      [49, 54, 24, 10, 55, 25],
      [24, 45, 15, 46, 46, 16],

      // 38
      [4, 152, 122, 18, 153, 123],
      [13, 74, 46, 32, 75, 47],
      [48, 54, 24, 14, 55, 25],
      [42, 45, 15, 32, 46, 16],

      // 39
      [20, 147, 117, 4, 148, 118],
      [40, 75, 47, 7, 76, 48],
      [43, 54, 24, 22, 55, 25],
      [10, 45, 15, 67, 46, 16],

      // 40
      [19, 148, 118, 6, 149, 119],
      [18, 75, 47, 31, 76, 48],
      [34, 54, 24, 34, 55, 25],
      [20, 45, 15, 61, 46, 16]
    ];

    var qrRSBlock = function(totalCount, dataCount) {
      var _this = {};
      _this.totalCount = totalCount;
      _this.dataCount = dataCount;
      return _this;
    };

    var _this = {};

    var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {

      switch(errorCorrectionLevel) {
      case QRErrorCorrectionLevel.L :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
      case QRErrorCorrectionLevel.M :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
      case QRErrorCorrectionLevel.Q :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
      case QRErrorCorrectionLevel.H :
        return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
      default :
        return undefined;
      }
    };

    _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {

      var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);

      if (typeof rsBlock == 'undefined') {
        throw 'bad rs block @ typeNumber:' + typeNumber +
            '/errorCorrectionLevel:' + errorCorrectionLevel;
      }

      var length = rsBlock.length / 3;

      var list = [];

      for (var i = 0; i < length; i += 1) {

        var count = rsBlock[i * 3 + 0];
        var totalCount = rsBlock[i * 3 + 1];
        var dataCount = rsBlock[i * 3 + 2];

        for (var j = 0; j < count; j += 1) {
          list.push(qrRSBlock(totalCount, dataCount) );
        }
      }

      return list;
    };

    return _this;
  }();

  //---------------------------------------------------------------------
  // qrBitBuffer
  //---------------------------------------------------------------------

  var qrBitBuffer = function() {

    var _buffer = [];
    var _length = 0;

    var _this = {};

    _this.getBuffer = function() {
      return _buffer;
    };

    _this.getAt = function(index) {
      var bufIndex = Math.floor(index / 8);
      return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
    };

    _this.put = function(num, length) {
      for (var i = 0; i < length; i += 1) {
        _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
      }
    };

    _this.getLengthInBits = function() {
      return _length;
    };

    _this.putBit = function(bit) {

      var bufIndex = Math.floor(_length / 8);
      if (_buffer.length <= bufIndex) {
        _buffer.push(0);
      }

      if (bit) {
        _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
      }

      _length += 1;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrNumber
  //---------------------------------------------------------------------

  var qrNumber = function(data) {

    var _mode = QRMode.MODE_NUMBER;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var data = _data;

      var i = 0;

      while (i + 2 < data.length) {
        buffer.put(strToNum(data.substring(i, i + 3) ), 10);
        i += 3;
      }

      if (i < data.length) {
        if (data.length - i == 1) {
          buffer.put(strToNum(data.substring(i, i + 1) ), 4);
        } else if (data.length - i == 2) {
          buffer.put(strToNum(data.substring(i, i + 2) ), 7);
        }
      }
    };

    var strToNum = function(s) {
      var num = 0;
      for (var i = 0; i < s.length; i += 1) {
        num = num * 10 + chatToNum(s.charAt(i) );
      }
      return num;
    };

    var chatToNum = function(c) {
      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      }
      throw 'illegal char :' + c;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrAlphaNum
  //---------------------------------------------------------------------

  var qrAlphaNum = function(data) {

    var _mode = QRMode.MODE_ALPHA_NUM;
    var _data = data;

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _data.length;
    };

    _this.write = function(buffer) {

      var s = _data;

      var i = 0;

      while (i + 1 < s.length) {
        buffer.put(
          getCode(s.charAt(i) ) * 45 +
          getCode(s.charAt(i + 1) ), 11);
        i += 2;
      }

      if (i < s.length) {
        buffer.put(getCode(s.charAt(i) ), 6);
      }
    };

    var getCode = function(c) {

      if ('0' <= c && c <= '9') {
        return c.charCodeAt(0) - '0'.charCodeAt(0);
      } else if ('A' <= c && c <= 'Z') {
        return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
      } else {
        switch (c) {
        case ' ' : return 36;
        case '$' : return 37;
        case '%' : return 38;
        case '*' : return 39;
        case '+' : return 40;
        case '-' : return 41;
        case '.' : return 42;
        case '/' : return 43;
        case ':' : return 44;
        default :
          throw 'illegal char :' + c;
        }
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qr8BitByte
  //---------------------------------------------------------------------

  var qr8BitByte = function(data) {

    var _mode = QRMode.MODE_8BIT_BYTE;
    var _data = data;
    var _bytes = qrcode.stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return _bytes.length;
    };

    _this.write = function(buffer) {
      for (var i = 0; i < _bytes.length; i += 1) {
        buffer.put(_bytes[i], 8);
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // qrKanji
  //---------------------------------------------------------------------

  var qrKanji = function(data) {

    var _mode = QRMode.MODE_KANJI;
    var _data = data;

    var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
    if (!stringToBytes) {
      throw 'sjis not supported.';
    }
    !function(c, code) {
      // self test for sjis support.
      var test = stringToBytes(c);
      if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
        throw 'sjis not supported.';
      }
    }('\u53cb', 0x9746);

    var _bytes = stringToBytes(data);

    var _this = {};

    _this.getMode = function() {
      return _mode;
    };

    _this.getLength = function(buffer) {
      return ~~(_bytes.length / 2);
    };

    _this.write = function(buffer) {

      var data = _bytes;

      var i = 0;

      while (i + 1 < data.length) {

        var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);

        if (0x8140 <= c && c <= 0x9FFC) {
          c -= 0x8140;
        } else if (0xE040 <= c && c <= 0xEBBF) {
          c -= 0xC140;
        } else {
          throw 'illegal char at ' + (i + 1) + '/' + c;
        }

        c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);

        buffer.put(c, 13);

        i += 2;
      }

      if (i < data.length) {
        throw 'illegal char at ' + (i + 1);
      }
    };

    return _this;
  };

  //=====================================================================
  // GIF Support etc.
  //

  //---------------------------------------------------------------------
  // byteArrayOutputStream
  //---------------------------------------------------------------------

  var byteArrayOutputStream = function() {

    var _bytes = [];

    var _this = {};

    _this.writeByte = function(b) {
      _bytes.push(b & 0xff);
    };

    _this.writeShort = function(i) {
      _this.writeByte(i);
      _this.writeByte(i >>> 8);
    };

    _this.writeBytes = function(b, off, len) {
      off = off || 0;
      len = len || b.length;
      for (var i = 0; i < len; i += 1) {
        _this.writeByte(b[i + off]);
      }
    };

    _this.writeString = function(s) {
      for (var i = 0; i < s.length; i += 1) {
        _this.writeByte(s.charCodeAt(i) );
      }
    };

    _this.toByteArray = function() {
      return _bytes;
    };

    _this.toString = function() {
      var s = '';
      s += '[';
      for (var i = 0; i < _bytes.length; i += 1) {
        if (i > 0) {
          s += ',';
        }
        s += _bytes[i];
      }
      s += ']';
      return s;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64EncodeOutputStream
  //---------------------------------------------------------------------

  var base64EncodeOutputStream = function() {

    var _buffer = 0;
    var _buflen = 0;
    var _length = 0;
    var _base64 = '';

    var _this = {};

    var writeEncoded = function(b) {
      _base64 += String.fromCharCode(encode(b & 0x3f) );
    };

    var encode = function(n) {
      if (n < 0) {
        // error.
      } else if (n < 26) {
        return 0x41 + n;
      } else if (n < 52) {
        return 0x61 + (n - 26);
      } else if (n < 62) {
        return 0x30 + (n - 52);
      } else if (n == 62) {
        return 0x2b;
      } else if (n == 63) {
        return 0x2f;
      }
      throw 'n:' + n;
    };

    _this.writeByte = function(n) {

      _buffer = (_buffer << 8) | (n & 0xff);
      _buflen += 8;
      _length += 1;

      while (_buflen >= 6) {
        writeEncoded(_buffer >>> (_buflen - 6) );
        _buflen -= 6;
      }
    };

    _this.flush = function() {

      if (_buflen > 0) {
        writeEncoded(_buffer << (6 - _buflen) );
        _buffer = 0;
        _buflen = 0;
      }

      if (_length % 3 != 0) {
        // padding
        var padlen = 3 - _length % 3;
        for (var i = 0; i < padlen; i += 1) {
          _base64 += '=';
        }
      }
    };

    _this.toString = function() {
      return _base64;
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // base64DecodeInputStream
  //---------------------------------------------------------------------

  var base64DecodeInputStream = function(str) {

    var _str = str;
    var _pos = 0;
    var _buffer = 0;
    var _buflen = 0;

    var _this = {};

    _this.read = function() {

      while (_buflen < 8) {

        if (_pos >= _str.length) {
          if (_buflen == 0) {
            return -1;
          }
          throw 'unexpected end of file./' + _buflen;
        }

        var c = _str.charAt(_pos);
        _pos += 1;

        if (c == '=') {
          _buflen = 0;
          return -1;
        } else if (c.match(/^\s$/) ) {
          // ignore if whitespace.
          continue;
        }

        _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
        _buflen += 6;
      }

      var n = (_buffer >>> (_buflen - 8) ) & 0xff;
      _buflen -= 8;
      return n;
    };

    var decode = function(c) {
      if (0x41 <= c && c <= 0x5a) {
        return c - 0x41;
      } else if (0x61 <= c && c <= 0x7a) {
        return c - 0x61 + 26;
      } else if (0x30 <= c && c <= 0x39) {
        return c - 0x30 + 52;
      } else if (c == 0x2b) {
        return 62;
      } else if (c == 0x2f) {
        return 63;
      } else {
        throw 'c:' + c;
      }
    };

    return _this;
  };

  //---------------------------------------------------------------------
  // gifImage (B/W)
  //---------------------------------------------------------------------

  var gifImage = function(width, height) {

    var _width = width;
    var _height = height;
    var _data = new Array(width * height);

    var _this = {};

    _this.setPixel = function(x, y, pixel) {
      _data[y * _width + x] = pixel;
    };

    _this.write = function(out) {

      //---------------------------------
      // GIF Signature

      out.writeString('GIF87a');

      //---------------------------------
      // Screen Descriptor

      out.writeShort(_width);
      out.writeShort(_height);

      out.writeByte(0x80); // 2bit
      out.writeByte(0);
      out.writeByte(0);

      //---------------------------------
      // Global Color Map

      // black
      out.writeByte(0x00);
      out.writeByte(0x00);
      out.writeByte(0x00);

      // white
      out.writeByte(0xff);
      out.writeByte(0xff);
      out.writeByte(0xff);

      //---------------------------------
      // Image Descriptor

      out.writeString(',');
      out.writeShort(0);
      out.writeShort(0);
      out.writeShort(_width);
      out.writeShort(_height);
      out.writeByte(0);

      //---------------------------------
      // Local Color Map

      //---------------------------------
      // Raster Data

      var lzwMinCodeSize = 2;
      var raster = getLZWRaster(lzwMinCodeSize);

      out.writeByte(lzwMinCodeSize);

      var offset = 0;

      while (raster.length - offset > 255) {
        out.writeByte(255);
        out.writeBytes(raster, offset, 255);
        offset += 255;
      }

      out.writeByte(raster.length - offset);
      out.writeBytes(raster, offset, raster.length - offset);
      out.writeByte(0x00);

      //---------------------------------
      // GIF Terminator
      out.writeString(';');
    };

    var bitOutputStream = function(out) {

      var _out = out;
      var _bitLength = 0;
      var _bitBuffer = 0;

      var _this = {};

      _this.write = function(data, length) {

        if ( (data >>> length) != 0) {
          throw 'length over';
        }

        while (_bitLength + length >= 8) {
          _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
          length -= (8 - _bitLength);
          data >>>= (8 - _bitLength);
          _bitBuffer = 0;
          _bitLength = 0;
        }

        _bitBuffer = (data << _bitLength) | _bitBuffer;
        _bitLength = _bitLength + length;
      };

      _this.flush = function() {
        if (_bitLength > 0) {
          _out.writeByte(_bitBuffer);
        }
      };

      return _this;
    };

    var getLZWRaster = function(lzwMinCodeSize) {

      var clearCode = 1 << lzwMinCodeSize;
      var endCode = (1 << lzwMinCodeSize) + 1;
      var bitLength = lzwMinCodeSize + 1;

      // Setup LZWTable
      var table = lzwTable();

      for (var i = 0; i < clearCode; i += 1) {
        table.add(String.fromCharCode(i) );
      }
      table.add(String.fromCharCode(clearCode) );
      table.add(String.fromCharCode(endCode) );

      var byteOut = byteArrayOutputStream();
      var bitOut = bitOutputStream(byteOut);

      // clear code
      bitOut.write(clearCode, bitLength);

      var dataIndex = 0;

      var s = String.fromCharCode(_data[dataIndex]);
      dataIndex += 1;

      while (dataIndex < _data.length) {

        var c = String.fromCharCode(_data[dataIndex]);
        dataIndex += 1;

        if (table.contains(s + c) ) {

          s = s + c;

        } else {

          bitOut.write(table.indexOf(s), bitLength);

          if (table.size() < 0xfff) {

            if (table.size() == (1 << bitLength) ) {
              bitLength += 1;
            }

            table.add(s + c);
          }

          s = c;
        }
      }

      bitOut.write(table.indexOf(s), bitLength);

      // end code
      bitOut.write(endCode, bitLength);

      bitOut.flush();

      return byteOut.toByteArray();
    };

    var lzwTable = function() {

      var _map = {};
      var _size = 0;

      var _this = {};

      _this.add = function(key) {
        if (_this.contains(key) ) {
          throw 'dup key:' + key;
        }
        _map[key] = _size;
        _size += 1;
      };

      _this.size = function() {
        return _size;
      };

      _this.indexOf = function(key) {
        return _map[key];
      };

      _this.contains = function(key) {
        return typeof _map[key] != 'undefined';
      };

      return _this;
    };

    return _this;
  };

  var createDataURL = function(width, height, getPixel) {
    var gif = gifImage(width, height);
    for (var y = 0; y < height; y += 1) {
      for (var x = 0; x < width; x += 1) {
        gif.setPixel(x, y, getPixel(x, y) );
      }
    }

    var b = byteArrayOutputStream();
    gif.write(b);

    var base64 = base64EncodeOutputStream();
    var bytes = b.toByteArray();
    for (var i = 0; i < bytes.length; i += 1) {
      base64.writeByte(bytes[i]);
    }
    base64.flush();

    return 'data:image/gif;base64,' + base64;
  };

  //---------------------------------------------------------------------
  // returns qrcode function.

  return qrcode;
}();

// multibyte support
!function() {

  qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
    // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i=0; i < str.length; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 0x80) utf8.push(charcode);
        else if (charcode < 0x800) {
          utf8.push(0xc0 | (charcode >> 6),
              0x80 | (charcode & 0x3f));
        }
        else if (charcode < 0xd800 || charcode >= 0xe000) {
          utf8.push(0xe0 | (charcode >> 12),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
        // surrogate pair
        else {
          i++;
          // UTF-16 encodes 0x10000-0x10FFFF by
          // subtracting 0x10000 and splitting the
          // 20 bits of 0x0-0xFFFFF into two halves
          charcode = 0x10000 + (((charcode & 0x3ff)<<10)
            | (str.charCodeAt(i) & 0x3ff));
          utf8.push(0xf0 | (charcode >>18),
              0x80 | ((charcode>>12) & 0x3f),
              0x80 | ((charcode>>6) & 0x3f),
              0x80 | (charcode & 0x3f));
        }
      }
      return utf8;
    }
    return toUTF8Array(s);
  };

}();

(function (factory) {
  if (typeof define === 'function' && define.amd) {
      define([], factory);
  } else if (typeof exports === 'object') {
      module.exports = factory();
  }
}(function () {
    return qrcode;
}));

      };
    };
  }
}, {package:"qrcode-generator",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qrcode.react\\lib\\index.js", {"prop-types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\index.js","qr.js/lib/ErrorCorrectLevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\ErrorCorrectLevel.js","qr.js/lib/QRCode":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\qr.js\\lib\\QRCode.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\qrcode.react\lib\index.js
      return function (require, module, exports) {
'use strict';

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var React = require('react');

var PropTypes = require('prop-types'); // qr.js doesn't handle error level of zero (M) so we need to do it right,
// thus the deep require.


var QRCodeImpl = require('qr.js/lib/QRCode');

var ErrorCorrectLevel = require('qr.js/lib/ErrorCorrectLevel'); // TODO: pull this off of the QRCode class type so it matches.


// Convert from UTF-16, forcing the use of byte-mode encoding in our QR Code.
// This allows us to encode Hanji, Kanji, emoji, etc. Ideally we'd do more
// detection and not resort to byte-mode if possible, but we're trading off
// a smaller library for a smaller amount of data we can potentially encode.
// Based on http://jonisalonen.com/2012/from-utf-16-to-utf-8-in-javascript/
function convertStr(str) {
  var out = '';

  for (var i = 0; i < str.length; i++) {
    var charcode = str.charCodeAt(i);

    if (charcode < 0x0080) {
      out += String.fromCharCode(charcode);
    } else if (charcode < 0x0800) {
      out += String.fromCharCode(0xc0 | charcode >> 6);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    } else if (charcode < 0xd800 || charcode >= 0xe000) {
      out += String.fromCharCode(0xe0 | charcode >> 12);
      out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    } else {
      // This is a surrogate pair, so we'll reconsitute the pieces and work
      // from that
      i++;
      charcode = 0x10000 + ((charcode & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);
      out += String.fromCharCode(0xf0 | charcode >> 18);
      out += String.fromCharCode(0x80 | charcode >> 12 & 0x3f);
      out += String.fromCharCode(0x80 | charcode >> 6 & 0x3f);
      out += String.fromCharCode(0x80 | charcode & 0x3f);
    }
  }

  return out;
}

var DEFAULT_PROPS = {
  size: 128,
  level: 'L',
  bgColor: '#FFFFFF',
  fgColor: '#000000',
  includeMargin: false
};
var PROP_TYPES = "development" !== 'production' ? {
  value: PropTypes.string.isRequired,
  size: PropTypes.number,
  level: PropTypes.oneOf(['L', 'M', 'Q', 'H']),
  bgColor: PropTypes.string,
  fgColor: PropTypes.string,
  includeMargin: PropTypes.bool,
  imageSettings: PropTypes.shape({
    src: PropTypes.string.isRequired,
    height: PropTypes.number.isRequired,
    width: PropTypes.number.isRequired,
    excavate: PropTypes.bool,
    x: PropTypes.number,
    y: PropTypes.number
  })
} : {};
var MARGIN_SIZE = 4; // This is *very* rough estimate of max amount of QRCode allowed to be covered.
// It is "wrong" in a lot of ways (area is a terrible way to estimate, it
// really should be number of modules covered), but if for some reason we don't
// get an explicit height or width, I'd rather default to something than throw.

var DEFAULT_IMG_SCALE = 0.1;

function generatePath(modules) {
  var margin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var ops = [];
  modules.forEach(function (row, y) {
    var start = null;
    row.forEach(function (cell, x) {
      if (!cell && start !== null) {
        // M0 0h7v1H0z injects the space with the move and drops the comma,
        // saving a char per operation
        ops.push("M".concat(start + margin, " ").concat(y + margin, "h").concat(x - start, "v1H").concat(start + margin, "z"));
        start = null;
        return;
      } // end of row, clean up or skip


      if (x === row.length - 1) {
        if (!cell) {
          // We would have closed the op above already so this can only mean
          // 2+ light modules in a row.
          return;
        }

        if (start === null) {
          // Just a single dark module.
          ops.push("M".concat(x + margin, ",").concat(y + margin, " h1v1H").concat(x + margin, "z"));
        } else {
          // Otherwise finish the current line.
          ops.push("M".concat(start + margin, ",").concat(y + margin, " h").concat(x + 1 - start, "v1H").concat(start + margin, "z"));
        }

        return;
      }

      if (cell && start === null) {
        start = x;
      }
    });
  });
  return ops.join('');
} // We could just do this in generatePath, except that we want to support
// non-Path2D canvas, so we need to keep it an explicit step.


function excavateModules(modules, excavation) {
  return modules.slice().map(function (row, y) {
    if (y < excavation.y || y >= excavation.y + excavation.h) {
      return row;
    }

    return row.map(function (cell, x) {
      if (x < excavation.x || x >= excavation.x + excavation.w) {
        return cell;
      }

      return false;
    });
  });
}

function getImageSettings(props, cells) {
  var imageSettings = props.imageSettings,
      size = props.size,
      includeMargin = props.includeMargin;

  if (imageSettings == null) {
    return null;
  }

  var margin = includeMargin ? MARGIN_SIZE : 0;
  var numCells = cells.length + margin * 2;
  var defaultSize = Math.floor(size * DEFAULT_IMG_SCALE);
  var scale = numCells / size;
  var w = (imageSettings.width || defaultSize) * scale;
  var h = (imageSettings.height || defaultSize) * scale;
  var x = imageSettings.x == null ? cells.length / 2 - w / 2 : imageSettings.x * scale;
  var y = imageSettings.y == null ? cells.length / 2 - h / 2 : imageSettings.y * scale;
  var excavation = null;

  if (imageSettings.excavate) {
    var floorX = Math.floor(x);
    var floorY = Math.floor(y);
    var ceilW = Math.ceil(w + x - floorX);
    var ceilH = Math.ceil(h + y - floorY);
    excavation = {
      x: floorX,
      y: floorY,
      w: ceilW,
      h: ceilH
    };
  }

  return {
    x: x,
    y: y,
    h: h,
    w: w,
    excavation: excavation
  };
} // For canvas we're going to switch our drawing mode based on whether or not
// the environment supports Path2D. We only need the constructor to be
// supported, but Edge doesn't actually support the path (string) type
// argument. Luckily it also doesn't support the addPath() method. We can
// treat that as the same thing.


var SUPPORTS_PATH2D = function () {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e) {
    return false;
  }

  return true;
}();

var QRCodeCanvas =
/*#__PURE__*/
function (_React$PureComponent) {
  _inherits(QRCodeCanvas, _React$PureComponent);

  function QRCodeCanvas() {
    var _getPrototypeOf2;

    var _this;

    _classCallCheck(this, QRCodeCanvas);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(QRCodeCanvas)).call.apply(_getPrototypeOf2, [this].concat(args)));

    _defineProperty(_assertThisInitialized(_this), "_canvas", void 0);

    _defineProperty(_assertThisInitialized(_this), "_image", void 0);

    _defineProperty(_assertThisInitialized(_this), "state", {
      imgLoaded: false
    });

    _defineProperty(_assertThisInitialized(_this), "handleImageLoad", function () {
      _this.setState({
        imgLoaded: true
      });
    });

    return _this;
  }

  _createClass(QRCodeCanvas, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this._image && this._image.complete) {
        this.handleImageLoad();
      }

      this.update();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      var _this$props$imageSett, _nextProps$imageSetti;

      var currentSrc = (_this$props$imageSett = this.props.imageSettings) === null || _this$props$imageSett === void 0 ? void 0 : _this$props$imageSett.src;
      var nextSrc = (_nextProps$imageSetti = nextProps.imageSettings) === null || _nextProps$imageSetti === void 0 ? void 0 : _nextProps$imageSetti.src;

      if (currentSrc !== nextSrc) {
        this.setState({
          imgLoaded: false
        });
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.update();
    }
  }, {
    key: "update",
    value: function update() {
      var _this$props = this.props,
          value = _this$props.value,
          size = _this$props.size,
          level = _this$props.level,
          bgColor = _this$props.bgColor,
          fgColor = _this$props.fgColor,
          includeMargin = _this$props.includeMargin,
          imageSettings = _this$props.imageSettings; // We'll use type===-1 to force QRCode to automatically pick the best type

      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();

      if (this._canvas != null) {
        var canvas = this._canvas;
        var ctx = canvas.getContext('2d');

        if (!ctx) {
          return;
        }

        var cells = qrcode.modules;

        if (cells === null) {
          return;
        }

        var margin = includeMargin ? MARGIN_SIZE : 0;
        var numCells = cells.length + margin * 2;
        var calculatedImageSettings = getImageSettings(this.props, cells);

        if (imageSettings != null && calculatedImageSettings != null) {
          if (calculatedImageSettings.excavation != null) {
            cells = excavateModules(cells, calculatedImageSettings.excavation);
          }
        } // We're going to scale this so that the number of drawable units
        // matches the number of cells. This avoids rounding issues, but does
        // result in some potentially unwanted single pixel issues between
        // blocks, only in environments that don't support Path2D.


        var pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size * pixelRatio;
        var scale = size / numCells * pixelRatio;
        ctx.scale(scale, scale); // Draw solid background, only paint dark modules.

        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;

        if (SUPPORTS_PATH2D) {
          // $FlowFixMe: Path2D c'tor doesn't support args yet.
          ctx.fill(new Path2D(generatePath(cells, margin)));
        } else {
          cells.forEach(function (row, rdx) {
            row.forEach(function (cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }

        if (this.state.imgLoaded && this._image && calculatedImageSettings != null) {
          ctx.drawImage(this._image, calculatedImageSettings.x + margin, calculatedImageSettings.y + margin, calculatedImageSettings.w, calculatedImageSettings.h);
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      var _this$props2 = this.props,
          value = _this$props2.value,
          size = _this$props2.size,
          level = _this$props2.level,
          bgColor = _this$props2.bgColor,
          fgColor = _this$props2.fgColor,
          style = _this$props2.style,
          includeMargin = _this$props2.includeMargin,
          imageSettings = _this$props2.imageSettings,
          otherProps = _objectWithoutProperties(_this$props2, ["value", "size", "level", "bgColor", "fgColor", "style", "includeMargin", "imageSettings"]);

      var canvasStyle = _objectSpread({
        height: size,
        width: size
      }, style);

      var img = null;
      var imgSrc = imageSettings && imageSettings.src;

      if (imageSettings != null && imgSrc != null) {
        img = React.createElement("img", {
          src: imgSrc,
          style: {
            display: 'none'
          },
          onLoad: this.handleImageLoad,
          ref: function ref(_ref) {
            return _this2._image = _ref;
          }
        });
      }

      return React.createElement(React.Fragment, null, React.createElement("canvas", _extends({
        style: canvasStyle,
        height: size,
        width: size,
        ref: function ref(_ref2) {
          return _this2._canvas = _ref2;
        }
      }, otherProps)), img);
    }
  }]);

  return QRCodeCanvas;
}(React.PureComponent);

_defineProperty(QRCodeCanvas, "defaultProps", DEFAULT_PROPS);

if ("development" !== 'production') {
  QRCodeCanvas.propTypes = PROP_TYPES;
}

var QRCodeSVG =
/*#__PURE__*/
function (_React$PureComponent2) {
  _inherits(QRCodeSVG, _React$PureComponent2);

  function QRCodeSVG() {
    _classCallCheck(this, QRCodeSVG);

    return _possibleConstructorReturn(this, _getPrototypeOf(QRCodeSVG).apply(this, arguments));
  }

  _createClass(QRCodeSVG, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          value = _this$props3.value,
          size = _this$props3.size,
          level = _this$props3.level,
          bgColor = _this$props3.bgColor,
          fgColor = _this$props3.fgColor,
          includeMargin = _this$props3.includeMargin,
          imageSettings = _this$props3.imageSettings,
          otherProps = _objectWithoutProperties(_this$props3, ["value", "size", "level", "bgColor", "fgColor", "includeMargin", "imageSettings"]); // We'll use type===-1 to force QRCode to automatically pick the best type


      var qrcode = new QRCodeImpl(-1, ErrorCorrectLevel[level]);
      qrcode.addData(convertStr(value));
      qrcode.make();
      var cells = qrcode.modules;

      if (cells === null) {
        return null;
      }

      var margin = includeMargin ? MARGIN_SIZE : 0;
      var numCells = cells.length + margin * 2;
      var calculatedImageSettings = getImageSettings(this.props, cells);
      var image = null;

      if (imageSettings != null && calculatedImageSettings != null) {
        if (calculatedImageSettings.excavation != null) {
          cells = excavateModules(cells, calculatedImageSettings.excavation);
        }

        image = React.createElement("image", {
          xlinkHref: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none"
        });
      } // Drawing strategy: instead of a rect per module, we're going to create a
      // single path for the dark modules and layer that on top of a light rect,
      // for a total of 2 DOM nodes. We pay a bit more in string concat but that's
      // way faster than DOM ops.
      // For level 1, 441 nodes -> 2
      // For level 40, 31329 -> 2


      var fgPath = generatePath(cells, margin);
      return React.createElement("svg", _extends({
        shapeRendering: "crispEdges",
        height: size,
        width: size,
        viewBox: "0 0 ".concat(numCells, " ").concat(numCells)
      }, otherProps), React.createElement("path", {
        fill: bgColor,
        d: "M0,0 h".concat(numCells, "v").concat(numCells, "H0z")
      }), React.createElement("path", {
        fill: fgColor,
        d: fgPath
      }), image);
    }
  }]);

  return QRCodeSVG;
}(React.PureComponent);

_defineProperty(QRCodeSVG, "defaultProps", DEFAULT_PROPS);

if ("development" !== 'production') {
  QRCodeSVG.propTypes = PROP_TYPES;
}

var QRCode = function QRCode(props) {
  var renderAs = props.renderAs,
      otherProps = _objectWithoutProperties(props, ["renderAs"]);

  var Component = renderAs === 'svg' ? QRCodeSVG : QRCodeCanvas;
  return React.createElement(Component, otherProps);
};

QRCode.defaultProps = _objectSpread({
  renderAs: 'canvas'
}, DEFAULT_PROPS);
module.exports = QRCode;
      };
    };
  }
}, {package:"qrcode.react",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-devtools-core\\backend.js", {"./dist/backend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-devtools-core\\dist\\backend.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-devtools-core\backend.js
      return function (require, module, exports) {
module.exports = require('./dist/backend');

      };
    };
  }
}, {package:"react-devtools>react-devtools-core",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-devtools-core\\dist\\backend.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-devtools-core\dist\backend.js
      return function (require, module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["ReactDevToolsBackend"] = factory();
	else
		root["ReactDevToolsBackend"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 19);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(11);
} else {}

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

exports = module.exports = SemVer;
var debug;
/* istanbul ignore next */

if ((typeof process === "undefined" ? "undefined" : _typeof(process)) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function debug() {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function debug() {};
} // Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.


exports.SEMVER_SPEC_VERSION = '2.0.0';
var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

var re = exports.re = [];
var src = exports.src = [];
var t = exports.tokens = {};
var R = 0;

function tok(n) {
  t[n] = R++;
} // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.


tok('NUMERICIDENTIFIER');
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
tok('NUMERICIDENTIFIERLOOSE');
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER');
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION');
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
tok('MAINVERSIONLOOSE');
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER');
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
tok('PRERELEASEIDENTIFIERLOOSE');
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE');
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
tok('PRERELEASELOOSE');
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER');
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD');
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL');
tok('FULLPLAIN');
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

tok('LOOSEPLAIN');
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
tok('LOOSE');
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
tok('GTLT');
src[t.GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

tok('XRANGEIDENTIFIERLOOSE');
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
tok('XRANGEIDENTIFIER');
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
tok('XRANGEPLAIN');
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGEPLAINLOOSE');
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
tok('XRANGE');
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
tok('XRANGELOOSE');
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.
// Extract anything that could conceivably be a part of a valid semver

tok('COERCE');
src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
tok('COERCERTL');
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.
// Meaning is "reasonably at or greater than"

tok('LONETILDE');
src[t.LONETILDE] = '(?:~>?)';
tok('TILDETRIM');
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
var tildeTrimReplace = '$1~';
tok('TILDE');
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
tok('TILDELOOSE');
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.
// Meaning is "at least and backwards compatible with"

tok('LONECARET');
src[t.LONECARET] = '(?:\\^)';
tok('CARETTRIM');
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
var caretTrimReplace = '$1^';
tok('CARET');
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
tok('CARETLOOSE');
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

tok('COMPARATORLOOSE');
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
tok('COMPARATOR');
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

tok('COMPARATORTRIM');
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag

re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

tok('HYPHENRANGE');
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
tok('HYPHENRANGELOOSE');
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

tok('STAR');
src[t.STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.

for (var i = 0; i < R; i++) {
  debug(i, src[i]);

  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;

function parse(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version !== 'string') {
    return null;
  }

  if (version.length > MAX_LENGTH) {
    return null;
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL];

  if (!r.test(version)) {
    return null;
  }

  try {
    return new SemVer(version, options);
  } catch (er) {
    return null;
  }
}

exports.valid = valid;

function valid(version, options) {
  var v = parse(version, options);
  return v ? v.version : null;
}

exports.clean = clean;

function clean(version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null;
}

exports.SemVer = SemVer;

function SemVer(version, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version;
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version);
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options);
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;
  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version);
  }

  this.raw = version; // these are actually numbers

  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version');
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version');
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version');
  } // numberify any prerelease numeric ids


  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;

        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num;
        }
      }

      return id;
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;

  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }

  return this.version;
};

SemVer.prototype.toString = function () {
  return this.version;
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);

  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other);
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  } // NOT having a prerelease is > having one


  if (this.prerelease.length && !other.prerelease.length) {
    return -1;
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1;
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0;
  }

  var i = 0;

  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
};

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  var i = 0;

  do {
    var a = this.build[i];
    var b = other.build[i];
    debug('prerelease compare', i, a, b);

    if (a === undefined && b === undefined) {
      return 0;
    } else if (b === undefined) {
      return 1;
    } else if (a === undefined) {
      return -1;
    } else if (a === b) {
      continue;
    } else {
      return compareIdentifiers(a, b);
    }
  } while (++i);
}; // preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.


SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break;

    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break;

    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break;
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.

    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }

      this.inc('pre', identifier);
      break;

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
        this.major++;
      }

      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break;

    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }

      this.patch = 0;
      this.prerelease = [];
      break;

    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }

      this.prerelease = [];
      break;
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;

        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }

        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }

      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }

      break;

    default:
      throw new Error('invalid increment argument: ' + release);
  }

  this.format();
  this.raw = this.version;
  return this;
};

exports.inc = inc;

function inc(version, release, loose, identifier) {
  if (typeof loose === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version;
  } catch (er) {
    return null;
  }
}

exports.diff = diff;

function diff(version1, version2) {
  if (eq(version1, version2)) {
    return null;
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';

    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }

    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key;
        }
      }
    }

    return defaultResult; // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;
var numeric = /^[0-9]+$/;

function compareIdentifiers(a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
}

exports.rcompareIdentifiers = rcompareIdentifiers;

function rcompareIdentifiers(a, b) {
  return compareIdentifiers(b, a);
}

exports.major = major;

function major(a, loose) {
  return new SemVer(a, loose).major;
}

exports.minor = minor;

function minor(a, loose) {
  return new SemVer(a, loose).minor;
}

exports.patch = patch;

function patch(a, loose) {
  return new SemVer(a, loose).patch;
}

exports.compare = compare;

function compare(a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose));
}

exports.compareLoose = compareLoose;

function compareLoose(a, b) {
  return compare(a, b, true);
}

exports.compareBuild = compareBuild;

function compareBuild(a, b, loose) {
  var versionA = new SemVer(a, loose);
  var versionB = new SemVer(b, loose);
  return versionA.compare(versionB) || versionA.compareBuild(versionB);
}

exports.rcompare = rcompare;

function rcompare(a, b, loose) {
  return compare(b, a, loose);
}

exports.sort = sort;

function sort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose);
  });
}

exports.rsort = rsort;

function rsort(list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose);
  });
}

exports.gt = gt;

function gt(a, b, loose) {
  return compare(a, b, loose) > 0;
}

exports.lt = lt;

function lt(a, b, loose) {
  return compare(a, b, loose) < 0;
}

exports.eq = eq;

function eq(a, b, loose) {
  return compare(a, b, loose) === 0;
}

exports.neq = neq;

function neq(a, b, loose) {
  return compare(a, b, loose) !== 0;
}

exports.gte = gte;

function gte(a, b, loose) {
  return compare(a, b, loose) >= 0;
}

exports.lte = lte;

function lte(a, b, loose) {
  return compare(a, b, loose) <= 0;
}

exports.cmp = cmp;

function cmp(a, op, b, loose) {
  switch (op) {
    case '===':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a === b;

    case '!==':
      if (_typeof(a) === 'object') a = a.version;
      if (_typeof(b) === 'object') b = b.version;
      return a !== b;

    case '':
    case '=':
    case '==':
      return eq(a, b, loose);

    case '!=':
      return neq(a, b, loose);

    case '>':
      return gt(a, b, loose);

    case '>=':
      return gte(a, b, loose);

    case '<':
      return lt(a, b, loose);

    case '<=':
      return lte(a, b, loose);

    default:
      throw new TypeError('Invalid operator: ' + op);
  }
}

exports.Comparator = Comparator;

function Comparator(comp, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp;
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options);
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};

Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp);
  }

  this.operator = m[1] !== undefined ? m[1] : '';

  if (this.operator === '=') {
    this.operator = '';
  } // if it literally is just '>' or '' then allow anything.


  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value;
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY || version === ANY) {
    return true;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  return cmp(version, this.operator, this.semver, this.options);
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required');
  }

  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    if (this.value === '') {
      return true;
    }

    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options);
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true;
    }

    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options);
  }

  var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
  var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
  return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
};

exports.Range = Range;

function Range(range, options) {
  if (!options || _typeof(options) !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
      return range;
    } else {
      return new Range(range.raw, options);
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options);
  }

  if (!(this instanceof Range)) {
    return new Range(range, options);
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim());
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length;
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range);
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim();
  }).join('||').trim();
  return this.range;
};

Range.prototype.toString = function () {
  return this.range;
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

  range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

  range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces

  range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options);
  }, this).join(' ').split(/\s+/);

  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe);
    });
  }

  set = set.map(function (comp) {
    return new Comparator(comp, this.options);
  }, this);
  return set;
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required');
  }

  return this.set.some(function (thisComparators) {
    return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
      return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options);
        });
      });
    });
  });
}; // take a set of comparators and determine whether there
// exists a version which can satisfy it


function isSatisfiable(comparators, options) {
  var result = true;
  var remainingComparators = comparators.slice();
  var testComparator = remainingComparators.pop();

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options);
    });
    testComparator = remainingComparators.pop();
  }

  return result;
} // Mostly just for testing and legacy API reasons


exports.toComparators = toComparators;

function toComparators(range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value;
    }).join(' ').trim().split(' ');
  });
} // comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.


function parseComparator(comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp;
}

function isX(id) {
  return !id || id.toLowerCase() === 'x' || id === '*';
} // ~, ~> -- > * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x -- > >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x -- > >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x -- > >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 -- > >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 -- > >=1.2.0 <1.3.0


function replaceTildes(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options);
  }).join(' ');
}

function replaceTilde(comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret;
  });
} // ^ -- > * (any, kinda silly)
// ^2, ^2.x, ^2.x.x -- > >=2.0.0 <3.0.0
// ^2.0, ^2.0.x -- > >=2.0.0 <3.0.0
// ^1.2, ^1.2.x -- > >=1.2.0 <2.0.0
// ^1.2.3 -- > >=1.2.3 <2.0.0
// ^1.2.0 -- > >=1.2.0 <2.0.0


function replaceCarets(comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options);
  }).join(' ');
}

function replaceCaret(comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');

      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret;
  });
}

function replaceXRanges(comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options);
  }).join(' ');
}

function replaceXRange(comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    } // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value


    pr = options.includePrerelease ? '-0' : '';

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }

      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';

        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';

        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr;
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
    }

    debug('xRange return', ret);
    return ret;
  });
} // Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.


function replaceStars(comp, options) {
  debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

  return comp.trim().replace(re[t.STAR], '');
} // This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0


function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim();
} // if ANY of the sets match ALL of its comparators, then pass


Range.prototype.test = function (version) {
  if (!version) {
    return false;
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options);
    } catch (er) {
      return false;
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true;
    }
  }

  return false;
};

function testSet(set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false;
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);

      if (set[i].semver === ANY) {
        continue;
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;

        if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
          return true;
        }
      }
    } // Version has a -pre, but it's not one of the ones we like.


    return false;
  }

  return true;
}

exports.satisfies = satisfies;

function satisfies(version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false;
  }

  return range.test(version);
}

exports.maxSatisfying = maxSatisfying;

function maxSatisfying(versions, range, options) {
  var max = null;
  var maxSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max;
}

exports.minSatisfying = minSatisfying;

function minSatisfying(versions, range, options) {
  var min = null;
  var minSV = null;

  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null;
  }

  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min;
}

exports.minVersion = minVersion;

function minVersion(range, loose) {
  range = new Range(range, loose);
  var minver = new SemVer('0.0.0');

  if (range.test(minver)) {
    return minver;
  }

  minver = new SemVer('0.0.0-0');

  if (range.test(minver)) {
    return minver;
  }

  minver = null;

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);

      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }

          compver.raw = compver.format();

        /* fallthrough */

        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }

          break;

        case '<':
        case '<=':
          /* Ignore maximum versions */
          break;

        /* istanbul ignore next */

        default:
          throw new Error('Unexpected operation: ' + comparator.operator);
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver;
  }

  return null;
}

exports.validRange = validRange;

function validRange(range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*';
  } catch (er) {
    return null;
  }
} // Determine if version is less than all the versions possible in the range


exports.ltr = ltr;

function ltr(version, range, options) {
  return outside(version, range, '<', options);
} // Determine if version is greater than all the versions possible in the range.


exports.gtr = gtr;

function gtr(version, range, options) {
  return outside(version, range, '>', options);
}

exports.outside = outside;

function outside(version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);
  var gtfn, ltefn, ltfn, comp, ecomp;

  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break;

    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break;

    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"');
  } // If it satisifes the range it is not outside


  if (satisfies(version, range, options)) {
    return false;
  } // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.


  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];
    var high = null;
    var low = null;
    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }

      high = high || comparator;
      low = low || comparator;

      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    }); // If the edge version comparator has a operator then our version
    // isn't outside it

    if (high.operator === comp || high.operator === ecomp) {
      return false;
    } // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range


    if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
      return false;
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false;
    }
  }

  return true;
}

exports.prerelease = prerelease;

function prerelease(version, options) {
  var parsed = parse(version, options);
  return parsed && parsed.prerelease.length ? parsed.prerelease : null;
}

exports.intersects = intersects;

function intersects(r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2);
}

exports.coerce = coerce;

function coerce(version, options) {
  if (version instanceof SemVer) {
    return version;
  }

  if (typeof version === 'number') {
    version = String(version);
  }

  if (typeof version !== 'string') {
    return null;
  }

  options = options || {};
  var match = null;

  if (!options.rtl) {
    match = version.match(re[t.COERCE]);
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next;

    while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
      if (!match || next.index + next[0].length !== match.index + match[0].length) {
        match = next;
      }

      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
    } // leave it in a clean state


    re[t.COERCERTL].lastIndex = -1;
  }

  if (match === null) {
    return null;
  }

  return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(5)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';
/** Used as references for various `Number` constants. */

var NAN = 0 / 0;
/** `Object#toString` result references. */

var symbolTag = '[object Symbol]';
/** Used to match leading and trailing whitespace. */

var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */

var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */

var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */

var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */

var freeParseInt = parseInt;
/** Detect free variable `global` from Node.js. */

var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global && global.Object === Object && global;
/** Detect free variable `self`. */

var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */

var root = freeGlobal || freeSelf || Function('return this')();
/** Used for built-in method references. */

var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */

var objectToString = objectProto.toString;
/* Built-in method references for those with the same name as other `lodash` methods. */

var nativeMax = Math.max,
    nativeMin = Math.min;
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */

var now = function now() {
  return root.Date.now();
};
/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */


function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  wait = toNumber(wait) || 0;

  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;
    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time; // Start the timer for the trailing edge.

    timerId = setTimeout(timerExpired, wait); // Invoke the leading edge.

    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;
    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime; // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.

    return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }

  function timerExpired() {
    var time = now();

    if (shouldInvoke(time)) {
      return trailingEdge(time);
    } // Restart the timer.


    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined; // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.

    if (trailing && lastArgs) {
      return invokeFunc(time);
    }

    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }

    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }

      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }

    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }

    return result;
  }

  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */


function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }

  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */


function isObject(value) {
  var type = _typeof(value);

  return !!value && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */


function isObjectLike(value) {
  return !!value && _typeof(value) == 'object';
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */


function isSymbol(value) {
  return _typeof(value) == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */


function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }

  if (isSymbol(value)) {
    return NAN;
  }

  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? other + '' : other;
  }

  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }

  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}

module.exports = throttle;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))

/***/ }),
/* 4 */
/***/ (function(module, exports) {

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // A linked list to keep track of recently-used-ness

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Yallist = __webpack_require__(9);

var MAX = Symbol('max');
var LENGTH = Symbol('length');
var LENGTH_CALCULATOR = Symbol('lengthCalculator');
var ALLOW_STALE = Symbol('allowStale');
var MAX_AGE = Symbol('maxAge');
var DISPOSE = Symbol('dispose');
var NO_DISPOSE_ON_SET = Symbol('noDisposeOnSet');
var LRU_LIST = Symbol('lruList');
var CACHE = Symbol('cache');
var UPDATE_AGE_ON_GET = Symbol('updateAgeOnGet');

var naiveLength = function naiveLength() {
  return 1;
}; // lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.


var LRUCache = /*#__PURE__*/function () {
  function LRUCache(options) {
    _classCallCheck(this, LRUCache);

    if (typeof options === 'number') options = {
      max: options
    };
    if (!options) options = {};
    if (options.max && (typeof options.max !== 'number' || options.max < 0)) throw new TypeError('max must be a non-negative number'); // Kind of weird to have a default max of Infinity, but oh well.

    var max = this[MAX] = options.max || Infinity;
    var lc = options.length || naiveLength;
    this[LENGTH_CALCULATOR] = typeof lc !== 'function' ? naiveLength : lc;
    this[ALLOW_STALE] = options.stale || false;
    if (options.maxAge && typeof options.maxAge !== 'number') throw new TypeError('maxAge must be a number');
    this[MAX_AGE] = options.maxAge || 0;
    this[DISPOSE] = options.dispose;
    this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
    this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
    this.reset();
  } // resize the cache when the max changes.


  _createClass(LRUCache, [{
    key: "rforEach",
    value: function rforEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].tail; walker !== null;) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    }
  }, {
    key: "forEach",
    value: function forEach(fn, thisp) {
      thisp = thisp || this;

      for (var walker = this[LRU_LIST].head; walker !== null;) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    }
  }, {
    key: "keys",
    value: function keys() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.key;
      });
    }
  }, {
    key: "values",
    value: function values() {
      return this[LRU_LIST].toArray().map(function (k) {
        return k.value;
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      var _this = this;

      if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
        this[LRU_LIST].forEach(function (hit) {
          return _this[DISPOSE](hit.key, hit.value);
        });
      }

      this[CACHE] = new Map(); // hash of items by key

      this[LRU_LIST] = new Yallist(); // list of items in order of use recency

      this[LENGTH] = 0; // length of items in the list
    }
  }, {
    key: "dump",
    value: function dump() {
      var _this2 = this;

      return this[LRU_LIST].map(function (hit) {
        return isStale(_this2, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        };
      }).toArray().filter(function (h) {
        return h;
      });
    }
  }, {
    key: "dumpLru",
    value: function dumpLru() {
      return this[LRU_LIST];
    }
  }, {
    key: "set",
    value: function set(key, value, maxAge) {
      maxAge = maxAge || this[MAX_AGE];
      if (maxAge && typeof maxAge !== 'number') throw new TypeError('maxAge must be a number');
      var now = maxAge ? Date.now() : 0;
      var len = this[LENGTH_CALCULATOR](value, key);

      if (this[CACHE].has(key)) {
        if (len > this[MAX]) {
          _del(this, this[CACHE].get(key));

          return false;
        }

        var node = this[CACHE].get(key);
        var item = node.value; // dispose of the old one before overwriting
        // split out into 2 ifs for better coverage tracking

        if (this[DISPOSE]) {
          if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
        }

        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        this[LENGTH] += len - item.length;
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }

      var hit = new Entry(key, value, len, now, maxAge); // oversized objects fall out of cache automatically.

      if (hit.length > this[MAX]) {
        if (this[DISPOSE]) this[DISPOSE](key, value);
        return false;
      }

      this[LENGTH] += hit.length;
      this[LRU_LIST].unshift(hit);
      this[CACHE].set(key, this[LRU_LIST].head);
      trim(this);
      return true;
    }
  }, {
    key: "has",
    value: function has(key) {
      if (!this[CACHE].has(key)) return false;
      var hit = this[CACHE].get(key).value;
      return !isStale(this, hit);
    }
  }, {
    key: "get",
    value: function get(key) {
      return _get(this, key, true);
    }
  }, {
    key: "peek",
    value: function peek(key) {
      return _get(this, key, false);
    }
  }, {
    key: "pop",
    value: function pop() {
      var node = this[LRU_LIST].tail;
      if (!node) return null;

      _del(this, node);

      return node.value;
    }
  }, {
    key: "del",
    value: function del(key) {
      _del(this, this[CACHE].get(key));
    }
  }, {
    key: "load",
    value: function load(arr) {
      // reset the cache
      this.reset();
      var now = Date.now(); // A previous serialized cache has the most recent items first

      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) // the item was created without expiration in a non aged cache
          this.set(hit.k, hit.v);else {
          var maxAge = expiresAt - now; // dont add already expired items

          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    }
  }, {
    key: "prune",
    value: function prune() {
      var _this3 = this;

      this[CACHE].forEach(function (value, key) {
        return _get(_this3, key, false);
      });
    }
  }, {
    key: "max",
    set: function set(mL) {
      if (typeof mL !== 'number' || mL < 0) throw new TypeError('max must be a non-negative number');
      this[MAX] = mL || Infinity;
      trim(this);
    },
    get: function get() {
      return this[MAX];
    }
  }, {
    key: "allowStale",
    set: function set(allowStale) {
      this[ALLOW_STALE] = !!allowStale;
    },
    get: function get() {
      return this[ALLOW_STALE];
    }
  }, {
    key: "maxAge",
    set: function set(mA) {
      if (typeof mA !== 'number') throw new TypeError('maxAge must be a non-negative number');
      this[MAX_AGE] = mA;
      trim(this);
    },
    get: function get() {
      return this[MAX_AGE];
    } // resize the cache when the lengthCalculator changes.

  }, {
    key: "lengthCalculator",
    set: function set(lC) {
      var _this4 = this;

      if (typeof lC !== 'function') lC = naiveLength;

      if (lC !== this[LENGTH_CALCULATOR]) {
        this[LENGTH_CALCULATOR] = lC;
        this[LENGTH] = 0;
        this[LRU_LIST].forEach(function (hit) {
          hit.length = _this4[LENGTH_CALCULATOR](hit.value, hit.key);
          _this4[LENGTH] += hit.length;
        });
      }

      trim(this);
    },
    get: function get() {
      return this[LENGTH_CALCULATOR];
    }
  }, {
    key: "length",
    get: function get() {
      return this[LENGTH];
    }
  }, {
    key: "itemCount",
    get: function get() {
      return this[LRU_LIST].length;
    }
  }]);

  return LRUCache;
}();

var _get = function _get(self, key, doUse) {
  var node = self[CACHE].get(key);

  if (node) {
    var hit = node.value;

    if (isStale(self, hit)) {
      _del(self, node);

      if (!self[ALLOW_STALE]) return undefined;
    } else {
      if (doUse) {
        if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
        self[LRU_LIST].unshiftNode(node);
      }
    }

    return hit.value;
  }
};

var isStale = function isStale(self, hit) {
  if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
  var diff = Date.now() - hit.now;
  return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};

var trim = function trim(self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev;

      _del(self, walker);

      walker = prev;
    }
  }
};

var _del = function _del(self, node) {
  if (node) {
    var hit = node.value;
    if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
    self[LENGTH] -= hit.length;
    self[CACHE].delete(hit.key);
    self[LRU_LIST].removeNode(node);
  }
};

var Entry = function Entry(key, value, length, now, maxAge) {
  _classCallCheck(this, Entry);

  this.key = key;
  this.value = value;
  this.length = length;
  this.now = now;
  this.maxAge = maxAge || 0;
};

var forEachStep = function forEachStep(self, fn, node, thisp) {
  var hit = node.value;

  if (isStale(self, hit)) {
    _del(self, node);

    if (!self[ALLOW_STALE]) hit = undefined;
  }

  if (hit) fn.call(thisp, hit.value, hit.key, self);
};

module.exports = LRUCache;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(setImmediate) {function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

//  Import support https://stackoverflow.com/questions/13673346/supporting-both-commonjs-and-amd
(function (name, definition) {
  if (true) {
    module.exports = definition();
  } else {}
})("clipboard", function () {
  if (typeof document === 'undefined' || !document.addEventListener) {
    return null;
  }

  var clipboard = {};

  clipboard.copy = function () {
    var _intercept = false;
    var _data = null; // Map from data type (e.g. "text/html") to value.

    var _bogusSelection = false;

    function cleanup() {
      _intercept = false;
      _data = null;

      if (_bogusSelection) {
        window.getSelection().removeAllRanges();
      }

      _bogusSelection = false;
    }

    document.addEventListener("copy", function (e) {
      if (_intercept) {
        for (var key in _data) {
          e.clipboardData.setData(key, _data[key]);
        }

        e.preventDefault();
      }
    }); // Workaround for Safari: https://bugs.webkit.org/show_bug.cgi?id=156529

    function bogusSelect() {
      var sel = document.getSelection(); // If "nothing" is selected...

      if (!document.queryCommandEnabled("copy") && sel.isCollapsed) {
        // ... temporarily select the entire body.
        //
        // We select the entire body because:
        // - it's guaranteed to exist,
        // - it works (unlike, say, document.head, or phantom element that is
        //   not inserted into the DOM),
        // - it doesn't seem to flicker (due to the synchronous copy event), and
        // - it avoids modifying the DOM (can trigger mutation observers).
        //
        // Because we can't do proper feature detection (we already checked
        // document.queryCommandEnabled("copy") , which actually gives a false
        // negative for Blink when nothing is selected) and UA sniffing is not
        // reliable (a lot of UA strings contain "Safari"), this will also
        // happen for some browsers other than Safari. :-()
        var range = document.createRange();
        range.selectNodeContents(document.body);
        sel.removeAllRanges();
        sel.addRange(range);
        _bogusSelection = true;
      }
    }

    ;
    return function (data) {
      return new Promise(function (resolve, reject) {
        _intercept = true;

        if (typeof data === "string") {
          _data = {
            "text/plain": data
          };
        } else if (data instanceof Node) {
          _data = {
            "text/html": new XMLSerializer().serializeToString(data)
          };
        } else if (data instanceof Object) {
          _data = data;
        } else {
          reject("Invalid data type. Must be string, DOM node, or an object mapping MIME types to strings.");
        }

        function triggerCopy(tryBogusSelect) {
          try {
            if (document.execCommand("copy")) {
              // document.execCommand is synchronous: http://www.w3.org/TR/2015/WD-clipboard-apis-20150421/#integration-with-rich-text-editing-apis
              // So we can call resolve() back here.
              cleanup();
              resolve();
            } else {
              if (!tryBogusSelect) {
                bogusSelect();
                triggerCopy(true);
              } else {
                cleanup();
                throw new Error("Unable to copy. Perhaps it's not available in your browser?");
              }
            }
          } catch (e) {
            cleanup();
            reject(e);
          }
        }

        triggerCopy(false);
      });
    };
  }();

  clipboard.paste = function () {
    var _intercept = false;

    var _resolve;

    var _dataType;

    document.addEventListener("paste", function (e) {
      if (_intercept) {
        _intercept = false;
        e.preventDefault();
        var resolve = _resolve;
        _resolve = null;
        resolve(e.clipboardData.getData(_dataType));
      }
    });
    return function (dataType) {
      return new Promise(function (resolve, reject) {
        _intercept = true;
        _resolve = resolve;
        _dataType = dataType || "text/plain";

        try {
          if (!document.execCommand("paste")) {
            _intercept = false;
            reject(new Error("Unable to paste. Pasting only works in Internet Explorer at the moment."));
          }
        } catch (e) {
          _intercept = false;
          reject(new Error(e));
        }
      });
    };
  }(); // Handle IE behaviour.


  if (typeof ClipboardEvent === "undefined" && typeof window.clipboardData !== "undefined" && typeof window.clipboardData.setData !== "undefined") {
    /*! promise-polyfill 2.0.1 */
    (function (a) {
      function b(a, b) {
        return function () {
          a.apply(b, arguments);
        };
      }

      function c(a) {
        if ("object" != _typeof(this)) throw new TypeError("Promises must be constructed via new");
        if ("function" != typeof a) throw new TypeError("not a function");
        this._state = null, this._value = null, this._deferreds = [], i(a, b(e, this), b(f, this));
      }

      function d(a) {
        var b = this;
        return null === this._state ? void this._deferreds.push(a) : void j(function () {
          var c = b._state ? a.onFulfilled : a.onRejected;
          if (null === c) return void (b._state ? a.resolve : a.reject)(b._value);
          var d;

          try {
            d = c(b._value);
          } catch (e) {
            return void a.reject(e);
          }

          a.resolve(d);
        });
      }

      function e(a) {
        try {
          if (a === this) throw new TypeError("A promise cannot be resolved with itself.");

          if (a && ("object" == _typeof(a) || "function" == typeof a)) {
            var c = a.then;
            if ("function" == typeof c) return void i(b(c, a), b(e, this), b(f, this));
          }

          this._state = !0, this._value = a, g.call(this);
        } catch (d) {
          f.call(this, d);
        }
      }

      function f(a) {
        this._state = !1, this._value = a, g.call(this);
      }

      function g() {
        for (var a = 0, b = this._deferreds.length; b > a; a++) {
          d.call(this, this._deferreds[a]);
        }

        this._deferreds = null;
      }

      function h(a, b, c, d) {
        this.onFulfilled = "function" == typeof a ? a : null, this.onRejected = "function" == typeof b ? b : null, this.resolve = c, this.reject = d;
      }

      function i(a, b, c) {
        var d = !1;

        try {
          a(function (a) {
            d || (d = !0, b(a));
          }, function (a) {
            d || (d = !0, c(a));
          });
        } catch (e) {
          if (d) return;
          d = !0, c(e);
        }
      }

      var j = c.immediateFn || "function" == typeof setImmediate && setImmediate || function (a) {
        setTimeout(a, 1);
      },
          k = Array.isArray || function (a) {
        return "[object Array]" === Object.prototype.toString.call(a);
      };

      c.prototype["catch"] = function (a) {
        return this.then(null, a);
      }, c.prototype.then = function (a, b) {
        var e = this;
        return new c(function (c, f) {
          d.call(e, new h(a, b, c, f));
        });
      }, c.all = function () {
        var a = Array.prototype.slice.call(1 === arguments.length && k(arguments[0]) ? arguments[0] : arguments);
        return new c(function (b, c) {
          function d(f, g) {
            try {
              if (g && ("object" == _typeof(g) || "function" == typeof g)) {
                var h = g.then;
                if ("function" == typeof h) return void h.call(g, function (a) {
                  d(f, a);
                }, c);
              }

              a[f] = g, 0 === --e && b(a);
            } catch (i) {
              c(i);
            }
          }

          if (0 === a.length) return b([]);

          for (var e = a.length, f = 0; f < a.length; f++) {
            d(f, a[f]);
          }
        });
      }, c.resolve = function (a) {
        return a && "object" == _typeof(a) && a.constructor === c ? a : new c(function (b) {
          b(a);
        });
      }, c.reject = function (a) {
        return new c(function (b, c) {
          c(a);
        });
      }, c.race = function (a) {
        return new c(function (b, c) {
          for (var d = 0, e = a.length; e > d; d++) {
            a[d].then(b, c);
          }
        });
      },  true && module.exports ? module.exports = c : a.Promise || (a.Promise = c);
    })(this);

    clipboard.copy = function (data) {
      return new Promise(function (resolve, reject) {
        // IE supports string and URL types: https://msdn.microsoft.com/en-us/library/ms536744(v=vs.85).aspx
        // We only support the string type for now.
        if (typeof data !== "string" && !("text/plain" in data)) {
          throw new Error("You must provide a text/plain type.");
        }

        var strData = typeof data === "string" ? data : data["text/plain"];
        var copySucceeded = window.clipboardData.setData("Text", strData);

        if (copySucceeded) {
          resolve();
        } else {
          reject(new Error("Copying was rejected."));
        }
      });
    };

    clipboard.paste = function () {
      return new Promise(function (resolve, reject) {
        var strData = window.clipboardData.getData("Text");

        if (strData) {
          resolve(strData);
        } else {
          // The user rejected the paste request.
          reject(new Error("Pasting was rejected."));
        }
      });
    };
  }

  return clipboard;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12).setImmediate))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(14);
} else {}

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;

function Yallist(list) {
  var self = this;

  if (!(self instanceof Yallist)) {
    self = new Yallist();
  }

  self.tail = null;
  self.head = null;
  self.length = 0;

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item);
    });
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i]);
    }
  }

  return self;
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list');
  }

  var next = node.next;
  var prev = node.prev;

  if (next) {
    next.prev = prev;
  }

  if (prev) {
    prev.next = next;
  }

  if (node === this.head) {
    this.head = next;
  }

  if (node === this.tail) {
    this.tail = prev;
  }

  node.list.length--;
  node.next = null;
  node.prev = null;
  node.list = null;
  return next;
};

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var head = this.head;
  node.list = this;
  node.next = head;

  if (head) {
    head.prev = node;
  }

  this.head = node;

  if (!this.tail) {
    this.tail = node;
  }

  this.length++;
};

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return;
  }

  if (node.list) {
    node.list.removeNode(node);
  }

  var tail = this.tail;
  node.list = this;
  node.prev = tail;

  if (tail) {
    tail.next = node;
  }

  this.tail = node;

  if (!this.head) {
    this.head = node;
  }

  this.length++;
};

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i]);
  }

  return this.length;
};

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined;
  }

  var res = this.tail.value;
  this.tail = this.tail.prev;

  if (this.tail) {
    this.tail.next = null;
  } else {
    this.head = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined;
  }

  var res = this.head.value;
  this.head = this.head.next;

  if (this.head) {
    this.head.prev = null;
  } else {
    this.tail = null;
  }

  this.length--;
  return res;
};

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.next;
  }
};

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this;

  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this);
    walker = walker.prev;
  }
};

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev;
  }

  if (i === n && walker !== null) {
    return walker.value;
  }
};

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.next;
  }

  return res;
};

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this;
  var res = new Yallist();

  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this));
    walker = walker.prev;
  }

  return res;
};

Yallist.prototype.reduce = function (fn, initial) {
  var acc;
  var walker = this.head;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.head) {
    walker = this.head.next;
    acc = this.head.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i);
    walker = walker.next;
  }

  return acc;
};

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc;
  var walker = this.tail;

  if (arguments.length > 1) {
    acc = initial;
  } else if (this.tail) {
    walker = this.tail.prev;
    acc = this.tail.value;
  } else {
    throw new TypeError('Reduce of empty list with no initial value');
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i);
    walker = walker.prev;
  }

  return acc;
};

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.next;
  }

  return arr;
};

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length);

  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value;
    walker = walker.prev;
  }

  return arr;
};

Yallist.prototype.slice = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next;
  }

  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length;

  if (to < 0) {
    to += this.length;
  }

  from = from || 0;

  if (from < 0) {
    from += this.length;
  }

  var ret = new Yallist();

  if (to < from || to < 0) {
    return ret;
  }

  if (from < 0) {
    from = 0;
  }

  if (to > this.length) {
    to = this.length;
  }

  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev;
  }

  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value);
  }

  return ret;
};

Yallist.prototype.splice = function (start, deleteCount
/*, ...nodes */
) {
  if (start > this.length) {
    start = this.length - 1;
  }

  if (start < 0) {
    start = this.length + start;
  }

  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
    walker = walker.next;
  }

  var ret = [];

  for (var i = 0; walker && i < deleteCount; i++) {
    ret.push(walker.value);
    walker = this.removeNode(walker);
  }

  if (walker === null) {
    walker = this.tail;
  }

  if (walker !== this.head && walker !== this.tail) {
    walker = walker.prev;
  }

  for (var i = 2; i < arguments.length; i++) {
    walker = insert(this, walker, arguments[i]);
  }

  return ret;
};

Yallist.prototype.reverse = function () {
  var head = this.head;
  var tail = this.tail;

  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev;
    walker.prev = walker.next;
    walker.next = p;
  }

  this.head = tail;
  this.tail = head;
  return this;
};

function insert(self, node, value) {
  var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);

  if (inserted.next === null) {
    self.tail = inserted;
  }

  if (inserted.prev === null) {
    self.head = inserted;
  }

  self.length++;
  return inserted;
}

function push(self, item) {
  self.tail = new Node(item, self.tail, null, self);

  if (!self.head) {
    self.head = self.tail;
  }

  self.length++;
}

function unshift(self, item) {
  self.head = new Node(item, null, self.head, self);

  if (!self.tail) {
    self.tail = self.head;
  }

  self.length++;
}

function Node(value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list);
  }

  this.list = list;
  this.value = value;

  if (prev) {
    prev.next = this;
    this.prev = prev;
  } else {
    this.prev = null;
  }

  if (next) {
    next.prev = this;
    this.next = next;
  } else {
    this.next = null;
  }
}

try {
  // add if support for Symbol.iterator is present
  __webpack_require__(10)(Yallist);
} catch (er) {}

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (Yallist) {
  Yallist.prototype[Symbol.iterator] = /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
    var walker;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            walker = this.head;

          case 1:
            if (!walker) {
              _context.next = 7;
              break;
            }

            _context.next = 4;
            return walker.value;

          case 4:
            walker = walker.next;
            _context.next = 1;
            break;

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  });
};

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React vundefined
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var b = 60103,
    c = 60106,
    d = 60107,
    e = 60108,
    f = 60114,
    g = 60109,
    h = 60110,
    k = 60112,
    l = 60113,
    m = 60120,
    n = 60115,
    p = 60116,
    q = 60129,
    r = 60130,
    u = 60131,
    v = 60132;

if ("function" === typeof Symbol && Symbol.for) {
  var w = Symbol.for;
  b = w("react.element");
  c = w("react.portal");
  d = w("react.fragment");
  e = w("react.strict_mode");
  f = w("react.profiler");
  g = w("react.provider");
  h = w("react.context");
  k = w("react.forward_ref");
  l = w("react.suspense");
  m = w("react.suspense_list");
  n = w("react.memo");
  p = w("react.lazy");
  q = w("react.debug_trace_mode");
  r = w("react.offscreen");
  u = w("react.legacy_hidden");
  v = w("react.cache");
}

var x = 0;
"function" === typeof Symbol && (x = Symbol.for("react.module.reference"));

function y(a) {
  if ("object" === _typeof(a) && null !== a) {
    var t = a.$$typeof;

    switch (t) {
      case b:
        switch (a = a.type, a) {
          case d:
          case f:
          case e:
          case l:
          case m:
            return a;

          default:
            switch (a = a && a.$$typeof, a) {
              case h:
              case k:
              case p:
              case n:
              case g:
                return a;

              default:
                return t;
            }

        }

      case c:
        return t;
    }
  }
}

var z = g,
    A = b,
    B = k,
    C = d,
    D = p,
    E = n,
    F = c,
    G = f,
    H = e,
    I = l,
    J = m;
exports.ContextConsumer = h;
exports.ContextProvider = z;
exports.Element = A;
exports.ForwardRef = B;
exports.Fragment = C;
exports.Lazy = D;
exports.Memo = E;
exports.Portal = F;
exports.Profiler = G;
exports.StrictMode = H;
exports.Suspense = I;
exports.SuspenseList = J;

exports.isAsyncMode = function () {
  return !1;
};

exports.isConcurrentMode = function () {
  return !1;
};

exports.isContextConsumer = function (a) {
  return y(a) === h;
};

exports.isContextProvider = function (a) {
  return y(a) === g;
};

exports.isElement = function (a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === b;
};

exports.isForwardRef = function (a) {
  return y(a) === k;
};

exports.isFragment = function (a) {
  return y(a) === d;
};

exports.isLazy = function (a) {
  return y(a) === p;
};

exports.isMemo = function (a) {
  return y(a) === n;
};

exports.isPortal = function (a) {
  return y(a) === c;
};

exports.isProfiler = function (a) {
  return y(a) === f;
};

exports.isStrictMode = function (a) {
  return y(a) === e;
};

exports.isSuspense = function (a) {
  return y(a) === l;
};

exports.isSuspenseList = function (a) {
  return y(a) === m;
};

exports.isValidElementType = function (a) {
  return "string" === typeof a || "function" === typeof a || a === d || a === f || a === q || a === e || a === l || a === m || a === u || a === r || a === v || "object" === _typeof(a) && null !== a && (a.$$typeof === p || a.$$typeof === n || a.$$typeof === g || a.$$typeof === h || a.$$typeof === k || a.$$typeof === x || void 0 !== a.getModuleId) ? !0 : !1;
};

exports.typeOf = y;

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = typeof global !== "undefined" && global || typeof self !== "undefined" && self || window;
var apply = Function.prototype.apply; // DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};

exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};

exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}

Timeout.prototype.unref = Timeout.prototype.ref = function () {};

Timeout.prototype.close = function () {
  this._clearFn.call(scope, this._id);
}; // Does not start the time, just sets up the members needed.


exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);
  var msecs = item._idleTimeout;

  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
}; // setimmediate attaches itself to the global object


__webpack_require__(13); // On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.


exports.setImmediate = typeof self !== "undefined" && self.setImmediate || typeof global !== "undefined" && global.setImmediate || this && this.setImmediate;
exports.clearImmediate = typeof self !== "undefined" && self.clearImmediate || typeof global !== "undefined" && global.clearImmediate || this && this.clearImmediate;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
  "use strict";

  if (global.setImmediate) {
    return;
  }

  var nextHandle = 1; // Spec says greater than zero

  var tasksByHandle = {};
  var currentlyRunningATask = false;
  var doc = global.document;
  var registerImmediate;

  function setImmediate(callback) {
    // Callback can either be a function or a string
    if (typeof callback !== "function") {
      callback = new Function("" + callback);
    } // Copy function arguments


    var args = new Array(arguments.length - 1);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i + 1];
    } // Store and register the task


    var task = {
      callback: callback,
      args: args
    };
    tasksByHandle[nextHandle] = task;
    registerImmediate(nextHandle);
    return nextHandle++;
  }

  function clearImmediate(handle) {
    delete tasksByHandle[handle];
  }

  function run(task) {
    var callback = task.callback;
    var args = task.args;

    switch (args.length) {
      case 0:
        callback();
        break;

      case 1:
        callback(args[0]);
        break;

      case 2:
        callback(args[0], args[1]);
        break;

      case 3:
        callback(args[0], args[1], args[2]);
        break;

      default:
        callback.apply(undefined, args);
        break;
    }
  }

  function runIfPresent(handle) {
    // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
    // So if we're currently running a task, we'll need to delay this invocation.
    if (currentlyRunningATask) {
      // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
      // "too much recursion" error.
      setTimeout(runIfPresent, 0, handle);
    } else {
      var task = tasksByHandle[handle];

      if (task) {
        currentlyRunningATask = true;

        try {
          run(task);
        } finally {
          clearImmediate(handle);
          currentlyRunningATask = false;
        }
      }
    }
  }

  function installNextTickImplementation() {
    registerImmediate = function registerImmediate(handle) {
      process.nextTick(function () {
        runIfPresent(handle);
      });
    };
  }

  function canUsePostMessage() {
    // The test against `importScripts` prevents this implementation from being installed inside a web worker,
    // where `global.postMessage` means something completely different and can't be used for this purpose.
    if (global.postMessage && !global.importScripts) {
      var postMessageIsAsynchronous = true;
      var oldOnMessage = global.onmessage;

      global.onmessage = function () {
        postMessageIsAsynchronous = false;
      };

      global.postMessage("", "*");
      global.onmessage = oldOnMessage;
      return postMessageIsAsynchronous;
    }
  }

  function installPostMessageImplementation() {
    // Installs an event handler on `global` for the `message` event: see
    // * https://developer.mozilla.org/en/DOM/window.postMessage
    // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
    var messagePrefix = "setImmediate$" + Math.random() + "$";

    var onGlobalMessage = function onGlobalMessage(event) {
      if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
        runIfPresent(+event.data.slice(messagePrefix.length));
      }
    };

    if (global.addEventListener) {
      global.addEventListener("message", onGlobalMessage, false);
    } else {
      global.attachEvent("onmessage", onGlobalMessage);
    }

    registerImmediate = function registerImmediate(handle) {
      global.postMessage(messagePrefix + handle, "*");
    };
  }

  function installMessageChannelImplementation() {
    var channel = new MessageChannel();

    channel.port1.onmessage = function (event) {
      var handle = event.data;
      runIfPresent(handle);
    };

    registerImmediate = function registerImmediate(handle) {
      channel.port2.postMessage(handle);
    };
  }

  function installReadyStateChangeImplementation() {
    var html = doc.documentElement;

    registerImmediate = function registerImmediate(handle) {
      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
      var script = doc.createElement("script");

      script.onreadystatechange = function () {
        runIfPresent(handle);
        script.onreadystatechange = null;
        html.removeChild(script);
        script = null;
      };

      html.appendChild(script);
    };
  }

  function installSetTimeoutImplementation() {
    registerImmediate = function registerImmediate(handle) {
      setTimeout(runIfPresent, 0, handle);
    };
  } // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.


  var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
  attachTo = attachTo && attachTo.setTimeout ? attachTo : global; // Don't get fooled by e.g. browserify environments.

  if ({}.toString.call(global.process) === "[object process]") {
    // For Node.js before 0.9
    installNextTickImplementation();
  } else if (canUsePostMessage()) {
    // For non-IE10 modern browsers
    installPostMessageImplementation();
  } else if (global.MessageChannel) {
    // For web workers, where supported
    installMessageChannelImplementation();
  } else if (doc && "onreadystatechange" in doc.createElement("script")) {
    // For IE 68
    installReadyStateChangeImplementation();
  } else {
    // For older browsers
    installSetTimeoutImplementation();
  }

  attachTo.setImmediate = setImmediate;
  attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(4), __webpack_require__(5)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React vundefined
 * react-debug-tools.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var k = __webpack_require__(1),
    p = __webpack_require__(15);

function r(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, e = 1; e < arguments.length; e++) {
    b += "&args[]=" + encodeURIComponent(arguments[e]);
  }

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var w = __webpack_require__(17).__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
    x = 60128;

if ("function" === typeof Symbol && Symbol.for) {
  var y = Symbol.for;
  x = y("react.opaque.id");
}

var z = [],
    A = null,
    B = null;

function C() {
  if (null === A) {
    var a = new Map();

    try {
      D.useContext({
        _currentValue: null
      }), D.useState(null), D.useReducer(function (a) {
        return a;
      }, null), D.useRef(null), "function" === typeof D.useCacheRefresh && D.useCacheRefresh(), D.useLayoutEffect(function () {}), D.useEffect(function () {}), D.useImperativeHandle(void 0, function () {
        return null;
      }), D.useDebugValue(null), D.useCallback(function () {}), D.useMemo(function () {
        return null;
      });
    } finally {
      var b = z;
      z = [];
    }

    for (var e = 0; e < b.length; e++) {
      var f = b[e];
      a.set(f.primitive, p.parse(f.stackError));
    }

    A = a;
  }

  return A;
}

var E = null;

function F() {
  var a = E;
  null !== a && (E = a.next);
  return a;
}

var D = {
  getCacheForType: function getCacheForType() {
    throw Error(r(248));
  },
  readContext: function readContext(a) {
    return a._currentValue;
  },
  useCacheRefresh: function useCacheRefresh() {
    var a = F();
    z.push({
      primitive: "CacheRefresh",
      stackError: Error(),
      value: null !== a ? a.memoizedState : function () {}
    });
    return function () {};
  },
  useCallback: function useCallback(a) {
    var b = F();
    z.push({
      primitive: "Callback",
      stackError: Error(),
      value: null !== b ? b.memoizedState[0] : a
    });
    return a;
  },
  useContext: function useContext(a) {
    z.push({
      primitive: "Context",
      stackError: Error(),
      value: a._currentValue
    });
    return a._currentValue;
  },
  useEffect: function useEffect(a) {
    F();
    z.push({
      primitive: "Effect",
      stackError: Error(),
      value: a
    });
  },
  useImperativeHandle: function useImperativeHandle(a) {
    F();
    var b = void 0;
    null !== a && "object" === _typeof(a) && (b = a.current);
    z.push({
      primitive: "ImperativeHandle",
      stackError: Error(),
      value: b
    });
  },
  useDebugValue: function useDebugValue(a, b) {
    z.push({
      primitive: "DebugValue",
      stackError: Error(),
      value: "function" === typeof b ? b(a) : a
    });
  },
  useLayoutEffect: function useLayoutEffect(a) {
    F();
    z.push({
      primitive: "LayoutEffect",
      stackError: Error(),
      value: a
    });
  },
  useMemo: function useMemo(a) {
    var b = F();
    a = null !== b ? b.memoizedState[0] : a();
    z.push({
      primitive: "Memo",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useReducer: function useReducer(a, b, e) {
    a = F();
    b = null !== a ? a.memoizedState : void 0 !== e ? e(b) : b;
    z.push({
      primitive: "Reducer",
      stackError: Error(),
      value: b
    });
    return [b, function () {}];
  },
  useRef: function useRef(a) {
    var b = F();
    a = null !== b ? b.memoizedState : {
      current: a
    };
    z.push({
      primitive: "Ref",
      stackError: Error(),
      value: a.current
    });
    return a;
  },
  useState: function useState(a) {
    var b = F();
    a = null !== b ? b.memoizedState : "function" === typeof a ? a() : a;
    z.push({
      primitive: "State",
      stackError: Error(),
      value: a
    });
    return [a, function () {}];
  },
  useTransition: function useTransition() {
    F();
    F();
    z.push({
      primitive: "Transition",
      stackError: Error(),
      value: void 0
    });
    return [!1, function () {}];
  },
  useMutableSource: function useMutableSource(a, b) {
    F();
    F();
    F();
    F();
    a = b(a._source);
    z.push({
      primitive: "MutableSource",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useDeferredValue: function useDeferredValue(a) {
    F();
    F();
    z.push({
      primitive: "DeferredValue",
      stackError: Error(),
      value: a
    });
    return a;
  },
  useOpaqueIdentifier: function useOpaqueIdentifier() {
    var a = F();
    B && 0 === B.mode && F();
    (a = null === a ? void 0 : a.memoizedState) && a.$$typeof === x && (a = void 0);
    z.push({
      primitive: "OpaqueIdentifier",
      stackError: Error(),
      value: a
    });
    return a;
  }
},
    G = 0;

function H(a, b, e) {
  var f = b[e].source,
      c = 0;

  a: for (; c < a.length; c++) {
    if (a[c].source === f) {
      for (var l = e + 1, q = c + 1; l < b.length && q < a.length; l++, q++) {
        if (a[q].source !== b[l].source) continue a;
      }

      return c;
    }
  }

  return -1;
}

function I(a, b) {
  if (!a) return !1;
  b = "use" + b;
  return a.length < b.length ? !1 : a.lastIndexOf(b) === a.length - b.length;
}

function J(a, b, e) {
  for (var f = [], c = null, l = f, q = 0, t = [], v = 0; v < b.length; v++) {
    var u = b[v];
    var d = a;
    var h = p.parse(u.stackError);

    b: {
      var m = h,
          n = H(m, d, G);
      if (-1 !== n) d = n;else {
        for (var g = 0; g < d.length && 5 > g; g++) {
          if (n = H(m, d, g), -1 !== n) {
            G = g;
            d = n;
            break b;
          }
        }

        d = -1;
      }
    }

    b: {
      m = h;
      n = C().get(u.primitive);
      if (void 0 !== n) for (g = 0; g < n.length && g < m.length; g++) {
        if (n[g].source !== m[g].source) {
          g < m.length - 1 && I(m[g].functionName, u.primitive) && g++;
          g < m.length - 1 && I(m[g].functionName, u.primitive) && g++;
          m = g;
          break b;
        }
      }
      m = -1;
    }

    h = -1 === d || -1 === m || 2 > d - m ? null : h.slice(m, d - 1);

    if (null !== h) {
      d = 0;

      if (null !== c) {
        for (; d < h.length && d < c.length && h[h.length - d - 1].source === c[c.length - d - 1].source;) {
          d++;
        }

        for (c = c.length - 1; c > d; c--) {
          l = t.pop();
        }
      }

      for (c = h.length - d - 1; 1 <= c; c--) {
        d = [], m = h[c], (n = h[c - 1].functionName) ? (g = n.lastIndexOf("."), -1 === g && (g = 0), "use" === n.substr(g, 3) && (g += 3), n = n.substr(g)) : n = "", n = {
          id: null,
          isStateEditable: !1,
          name: n,
          value: void 0,
          subHooks: d
        }, e && (n.hookSource = {
          lineNumber: m.lineNumber,
          columnNumber: m.columnNumber,
          functionName: m.functionName,
          fileName: m.fileName
        }), l.push(n), t.push(l), l = d;
      }

      c = h;
    }

    d = u.primitive;
    u = {
      id: "Context" === d || "DebugValue" === d ? null : q++,
      isStateEditable: "Reducer" === d || "State" === d,
      name: d,
      value: u.value,
      subHooks: []
    };
    e && (d = {
      lineNumber: null,
      functionName: null,
      fileName: null,
      columnNumber: null
    }, h && 1 <= h.length && (h = h[0], d.lineNumber = h.lineNumber, d.functionName = h.functionName, d.fileName = h.fileName, d.columnNumber = h.columnNumber), u.hookSource = d);
    l.push(u);
  }

  K(f, null);
  return f;
}

function K(a, b) {
  for (var e = [], f = 0; f < a.length; f++) {
    var c = a[f];
    "DebugValue" === c.name && 0 === c.subHooks.length ? (a.splice(f, 1), f--, e.push(c)) : K(c.subHooks, c);
  }

  null !== b && (1 === e.length ? b.value = e[0].value : 1 < e.length && (b.value = e.map(function (a) {
    return a.value;
  })));
}

function L(a, b, e) {
  var f = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : !1;
  null == e && (e = w.ReactCurrentDispatcher);
  var c = e.current;
  e.current = D;

  try {
    var l = Error();
    a(b);
  } finally {
    var q = z;
    z = [];
    e.current = c;
  }

  c = p.parse(l);
  return J(c, q, f);
}

function M(a) {
  a.forEach(function (a, e) {
    return e._currentValue = a;
  });
}

exports.inspectHooks = L;

exports.inspectHooksOfFiber = function (a, b) {
  var e = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : !1;
  null == b && (b = w.ReactCurrentDispatcher);
  B = a;
  if (0 !== a.tag && 15 !== a.tag && 11 !== a.tag) throw Error("Unknown Fiber. Needs to be a function component to inspect hooks.");
  C();
  var f = a.type,
      c = a.memoizedProps;

  if (f !== a.elementType && f && f.defaultProps) {
    c = k({}, c);
    var l = f.defaultProps;

    for (q in l) {
      void 0 === c[q] && (c[q] = l[q]);
    }
  }

  E = a.memoizedState;
  var q = new Map();

  try {
    for (l = a; l;) {
      if (10 === l.tag) {
        var t = l.type._context;
        q.has(t) || (q.set(t, t._currentValue), t._currentValue = l.memoizedProps.value);
      }

      l = l.return;
    }

    if (11 === a.tag) {
      var v = f.render;
      f = c;
      var u = a.ref;
      t = b;
      var d = t.current;
      t.current = D;

      try {
        var h = Error();
        v(f, u);
      } finally {
        var m = z;
        z = [];
        t.current = d;
      }

      var n = p.parse(h);
      return J(n, m, e);
    }

    return L(f, c, b, e);
  } finally {
    E = null, M(q);
  }
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(16)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function ErrorStackParser(StackFrame) {
  'use strict';

  var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  var CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    /**
     * Given an Error object, extract the most information from it.
     *
     * @param {Error} error object
     * @return {Array} of StackFrames
     */
    parse: function ErrorStackParser$$parse(error) {
      if (typeof error.stacktrace !== 'undefined' || typeof error['opera#sourceloc'] !== 'undefined') {
        return this.parseOpera(error);
      } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error);
      } else if (error.stack) {
        return this.parseFFOrSafari(error);
      } else {
        throw new Error('Cannot parse given Error object');
      }
    },
    // Separate line and column numbers from a string of the form: (URI:Line:Column)
    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
      // Fail-fast but return locations like "(native)"
      if (urlLike.indexOf(':') === -1) {
        return [urlLike];
      }

      var regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
      var parts = regExp.exec(urlLike.replace(/[()]/g, ''));
      return [parts[1], parts[2] || undefined, parts[3] || undefined];
    },
    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
      }, this);
      return filtered.map(function (line) {
        if (line.indexOf('(eval ') > -1) {
          // Throw away eval information until we implement stacktrace.js/stackframe#8
          line = line.replace(/eval code/g, 'eval').replace(/(\(eval at [^()]*)|(\),.*$)/g, '');
        }

        var sanitizedLine = line.replace(/^\s+/, '').replace(/\(eval code/g, '('); // capture and preseve the parenthesized location "(/foo/my bar.js:12:87)" in
        // case it has spaces in it, as the string is split on \s+ later on

        var location = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/); // remove the parenthesized location from the line, if it was matched

        sanitizedLine = location ? sanitizedLine.replace(location[0], '') : sanitizedLine;
        var tokens = sanitizedLine.split(/\s+/).slice(1); // if a location was matched, pass it to extractLocation() otherwise pop the last token

        var locationParts = this.extractLocation(location ? location[1] : tokens.pop());
        var functionName = tokens.join(' ') || undefined;
        var fileName = ['eval', '<anonymous>'].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];
        return new StackFrame({
          functionName: functionName,
          fileName: fileName,
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    },
    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !line.match(SAFARI_NATIVE_CODE_REGEXP);
      }, this);
      return filtered.map(function (line) {
        // Throw away eval information until we implement stacktrace.js/stackframe#8
        if (line.indexOf(' > eval') > -1) {
          line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ':$1');
        }

        if (line.indexOf('@') === -1 && line.indexOf(':') === -1) {
          // Safari eval frames only have function names and nothing else
          return new StackFrame({
            functionName: line
          });
        } else {
          var functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
          var matches = line.match(functionNameRegex);
          var functionName = matches && matches[1] ? matches[1] : undefined;
          var locationParts = this.extractLocation(line.replace(functionNameRegex, ''));
          return new StackFrame({
            functionName: functionName,
            fileName: locationParts[0],
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            source: line
          });
        }
      }, this);
    },
    parseOpera: function ErrorStackParser$$parseOpera(e) {
      if (!e.stacktrace || e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
        return this.parseOpera9(e);
      } else if (!e.stack) {
        return this.parseOpera10(e);
      } else {
        return this.parseOpera11(e);
      }
    },
    parseOpera9: function ErrorStackParser$$parseOpera9(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
      var lines = e.message.split('\n');
      var result = [];

      for (var i = 2, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    parseOpera10: function ErrorStackParser$$parseOpera10(e) {
      var lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
      var lines = e.stacktrace.split('\n');
      var result = [];

      for (var i = 0, len = lines.length; i < len; i += 2) {
        var match = lineRE.exec(lines[i]);

        if (match) {
          result.push(new StackFrame({
            functionName: match[3] || undefined,
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          }));
        }
      }

      return result;
    },
    // Opera 10.65+ Error.stack very similar to FF/Safari
    parseOpera11: function ErrorStackParser$$parseOpera11(error) {
      var filtered = error.stack.split('\n').filter(function (line) {
        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
      }, this);
      return filtered.map(function (line) {
        var tokens = line.split('@');
        var locationParts = this.extractLocation(tokens.pop());
        var functionCall = tokens.shift() || '';
        var functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, '$2').replace(/\([^)]*\)/g, '') || undefined;
        var argsRaw;

        if (functionCall.match(/\(([^)]*)\)/)) {
          argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, '$1');
        }

        var args = argsRaw === undefined || argsRaw === '[arguments not available]' ? undefined : argsRaw.split(',');
        return new StackFrame({
          functionName: functionName,
          args: args,
          fileName: locationParts[0],
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        });
      }, this);
    }
  };
});

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

(function (root, factory) {
  'use strict'; // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.

  /* istanbul ignore next */

  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  'use strict';

  function _isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }

  function _capitalize(str) {
    return str.charAt(0).toUpperCase() + str.substring(1);
  }

  function _getter(p) {
    return function () {
      return this[p];
    };
  }

  var booleanProps = ['isConstructor', 'isEval', 'isNative', 'isToplevel'];
  var numericProps = ['columnNumber', 'lineNumber'];
  var stringProps = ['fileName', 'functionName', 'source'];
  var arrayProps = ['args'];
  var props = booleanProps.concat(numericProps, stringProps, arrayProps);

  function StackFrame(obj) {
    if (!obj) return;

    for (var i = 0; i < props.length; i++) {
      if (obj[props[i]] !== undefined) {
        this['set' + _capitalize(props[i])](obj[props[i]]);
      }
    }
  }

  StackFrame.prototype = {
    getArgs: function getArgs() {
      return this.args;
    },
    setArgs: function setArgs(v) {
      if (Object.prototype.toString.call(v) !== '[object Array]') {
        throw new TypeError('Args must be an Array');
      }

      this.args = v;
    },
    getEvalOrigin: function getEvalOrigin() {
      return this.evalOrigin;
    },
    setEvalOrigin: function setEvalOrigin(v) {
      if (v instanceof StackFrame) {
        this.evalOrigin = v;
      } else if (v instanceof Object) {
        this.evalOrigin = new StackFrame(v);
      } else {
        throw new TypeError('Eval Origin must be an Object or StackFrame');
      }
    },
    toString: function toString() {
      var fileName = this.getFileName() || '';
      var lineNumber = this.getLineNumber() || '';
      var columnNumber = this.getColumnNumber() || '';
      var functionName = this.getFunctionName() || '';

      if (this.getIsEval()) {
        if (fileName) {
          return '[eval] (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
        }

        return '[eval]:' + lineNumber + ':' + columnNumber;
      }

      if (functionName) {
        return functionName + ' (' + fileName + ':' + lineNumber + ':' + columnNumber + ')';
      }

      return fileName + ':' + lineNumber + ':' + columnNumber;
    }
  };

  StackFrame.fromString = function StackFrame$$fromString(str) {
    var argsStartIndex = str.indexOf('(');
    var argsEndIndex = str.lastIndexOf(')');
    var functionName = str.substring(0, argsStartIndex);
    var args = str.substring(argsStartIndex + 1, argsEndIndex).split(',');
    var locationString = str.substring(argsEndIndex + 1);

    if (locationString.indexOf('@') === 0) {
      var parts = /@(.+?)(?::(\d+))?(?::(\d+))?$/.exec(locationString, '');
      var fileName = parts[1];
      var lineNumber = parts[2];
      var columnNumber = parts[3];
    }

    return new StackFrame({
      functionName: functionName,
      args: args || undefined,
      fileName: fileName,
      lineNumber: lineNumber || undefined,
      columnNumber: columnNumber || undefined
    });
  };

  for (var i = 0; i < booleanProps.length; i++) {
    StackFrame.prototype['get' + _capitalize(booleanProps[i])] = _getter(booleanProps[i]);

    StackFrame.prototype['set' + _capitalize(booleanProps[i])] = function (p) {
      return function (v) {
        this[p] = Boolean(v);
      };
    }(booleanProps[i]);
  }

  for (var j = 0; j < numericProps.length; j++) {
    StackFrame.prototype['get' + _capitalize(numericProps[j])] = _getter(numericProps[j]);

    StackFrame.prototype['set' + _capitalize(numericProps[j])] = function (p) {
      return function (v) {
        if (!_isNumber(v)) {
          throw new TypeError(p + ' must be a Number');
        }

        this[p] = Number(v);
      };
    }(numericProps[j]);
  }

  for (var k = 0; k < stringProps.length; k++) {
    StackFrame.prototype['get' + _capitalize(stringProps[k])] = _getter(stringProps[k]);

    StackFrame.prototype['set' + _capitalize(stringProps[k])] = function (p) {
      return function (v) {
        this[p] = String(v);
      };
    }(stringProps[k]);
  }

  return StackFrame;
});

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (true) {
  module.exports = __webpack_require__(18);
} else {}

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React vundefined
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var l = __webpack_require__(1),
    m = 60103,
    p = 60106;

exports.Fragment = 60107;
exports.StrictMode = 60108;
exports.Profiler = 60114;
var q = 60109,
    r = 60110,
    t = 60112;
exports.Suspense = 60113;
exports.SuspenseList = 60120;
var u = 60115,
    v = 60116;
exports.unstable_DebugTracingMode = 60129;
exports.unstable_Offscreen = 60130;
exports.unstable_LegacyHidden = 60131;
exports.unstable_Cache = 60132;

if ("function" === typeof Symbol && Symbol.for) {
  var w = Symbol.for;
  m = w("react.element");
  p = w("react.portal");
  exports.Fragment = w("react.fragment");
  exports.StrictMode = w("react.strict_mode");
  exports.Profiler = w("react.profiler");
  q = w("react.provider");
  r = w("react.context");
  t = w("react.forward_ref");
  exports.Suspense = w("react.suspense");
  exports.SuspenseList = w("react.suspense_list");
  u = w("react.memo");
  v = w("react.lazy");
  exports.unstable_DebugTracingMode = w("react.debug_trace_mode");
  exports.unstable_Offscreen = w("react.offscreen");
  exports.unstable_LegacyHidden = w("react.legacy_hidden");
  exports.unstable_Cache = w("react.cache");
}

var x = "function" === typeof Symbol && Symbol.iterator;

function y(a) {
  if (null === a || "object" !== _typeof(a)) return null;
  a = x && a[x] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) {
    b += "&args[]=" + encodeURIComponent(arguments[c]);
  }

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var A = {
  isMounted: function isMounted() {
    return !1;
  },
  enqueueForceUpdate: function enqueueForceUpdate() {},
  enqueueReplaceState: function enqueueReplaceState() {},
  enqueueSetState: function enqueueSetState() {}
},
    B = {};

function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B;
  this.updater = c || A;
}

C.prototype.isReactComponent = {};

C.prototype.setState = function (a, b) {
  if ("object" !== _typeof(a) && "function" !== typeof a && null != a) throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};

C.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function D() {}

D.prototype = C.prototype;

function E(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B;
  this.updater = c || A;
}

var F = E.prototype = new D();
F.constructor = E;
l(F, C.prototype);
F.isPureReactComponent = !0;
var G = Array.isArray,
    H = Object.prototype.hasOwnProperty,
    I = {
  current: null
},
    J = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function K(a, b, c) {
  var e,
      d = {},
      k = null,
      h = null;
  if (null != b) for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) {
    H.call(b, e) && !J.hasOwnProperty(e) && (d[e] = b[e]);
  }
  var g = arguments.length - 2;
  if (1 === g) d.children = c;else if (1 < g) {
    for (var f = Array(g), n = 0; n < g; n++) {
      f[n] = arguments[n + 2];
    }

    d.children = f;
  }
  if (a && a.defaultProps) for (e in g = a.defaultProps, g) {
    void 0 === d[e] && (d[e] = g[e]);
  }
  return {
    $$typeof: m,
    type: a,
    key: k,
    ref: h,
    props: d,
    _owner: I.current
  };
}

function L(a, b) {
  return {
    $$typeof: m,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}

function M(a) {
  return "object" === _typeof(a) && null !== a && a.$$typeof === m;
}

function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}

var N = /\/+/g;

function O(a, b) {
  return "object" === _typeof(a) && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}

function P(a, b, c, e, d) {
  var k = _typeof(a);

  if ("undefined" === k || "boolean" === k) a = null;
  var h = !1;
  if (null === a) h = !0;else switch (k) {
    case "string":
    case "number":
      h = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case m:
        case p:
          h = !0;
      }

  }
  if (h) return h = a, d = d(h), a = "" === e ? "." + O(h, 0) : e, G(d) ? (c = "", null != a && (c = a.replace(N, "$&/") + "/"), P(d, b, c, "", function (a) {
    return a;
  })) : null != d && (M(d) && (d = L(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(N, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = "" === e ? "." : e + ":";
  if (G(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];
    var f = e + O(k, g);
    h += P(k, b, c, f, d);
  } else if (f = y(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) {
    k = k.value, f = e + O(k, g++), h += P(k, b, c, f, d);
  } else if ("object" === k) throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}

function Q(a, b, c) {
  if (null == a) return a;
  var e = [],
      d = 0;
  P(a, e, "", "", function (a) {
    return b.call(c, a, d++);
  });
  return e;
}

function R(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    b.then(function (b) {
      if (0 === a._status || -1 === a._status) a._status = 1, a._result = b;
    }, function (b) {
      if (0 === a._status || -1 === a._status) a._status = 2, a._result = b;
    });
    -1 === a._status && (a._status = 0, a._result = b);
  }

  if (1 === a._status) return a._result.default;
  throw a._result;
}

var S = {
  current: null
},
    T = {
  transition: 0
},
    U = {
  ReactCurrentDispatcher: S,
  ReactCurrentBatchConfig: T,
  ReactCurrentOwner: I,
  assign: l
};
exports.Children = {
  map: Q,
  forEach: function forEach(a, b, c) {
    Q(a, function () {
      b.apply(this, arguments);
    }, c);
  },
  count: function count(a) {
    var b = 0;
    Q(a, function () {
      b++;
    });
    return b;
  },
  toArray: function toArray(a) {
    return Q(a, function (a) {
      return a;
    }) || [];
  },
  only: function only(a) {
    if (!M(a)) throw Error(z(143));
    return a;
  }
};
exports.Component = C;
exports.PureComponent = E;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = U;

exports.cloneElement = function (a, b, c) {
  if (null === a || void 0 === a) throw Error(z(267, a));
  var e = l({}, a.props),
      d = a.key,
      k = a.ref,
      h = a._owner;

  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = I.current);
    void 0 !== b.key && (d = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;

    for (f in b) {
      H.call(b, f) && !J.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
    }
  }

  var f = arguments.length - 2;
  if (1 === f) e.children = c;else if (1 < f) {
    g = Array(f);

    for (var n = 0; n < f; n++) {
      g[n] = arguments[n + 2];
    }

    e.children = g;
  }
  return {
    $$typeof: m,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};

exports.createContext = function (a) {
  a = {
    $$typeof: r,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  a.Provider = {
    $$typeof: q,
    _context: a
  };
  return a.Consumer = a;
};

exports.createElement = K;

exports.createFactory = function (a) {
  var b = K.bind(null, a);
  b.type = a;
  return b;
};

exports.createRef = function () {
  return {
    current: null
  };
};

exports.forwardRef = function (a) {
  return {
    $$typeof: t,
    render: a
  };
};

exports.isValidElement = M;

exports.lazy = function (a) {
  return {
    $$typeof: v,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: R
  };
};

exports.memo = function (a, b) {
  return {
    $$typeof: u,
    type: a,
    compare: void 0 === b ? null : b
  };
};

exports.startTransition = function (a) {
  var b = T.transition;
  T.transition = 1;

  try {
    a();
  } finally {
    T.transition = b;
  }
};

exports.unstable_act = function () {
  throw Error(z(406));
};

exports.unstable_createMutableSource = function (a, b) {
  return {
    _getVersion: b,
    _source: a,
    _workInProgressVersionPrimary: null,
    _workInProgressVersionSecondary: null
  };
};

exports.unstable_getCacheForType = function (a) {
  return S.current.getCacheForType(a);
};

exports.unstable_useCacheRefresh = function () {
  return S.current.useCacheRefresh();
};

exports.unstable_useMutableSource = function (a, b, c) {
  return S.current.useMutableSource(a, b, c);
};

exports.unstable_useOpaqueIdentifier = function () {
  return S.current.useOpaqueIdentifier();
};

exports.useCallback = function (a, b) {
  return S.current.useCallback(a, b);
};

exports.useContext = function (a) {
  return S.current.useContext(a);
};

exports.useDebugValue = function () {};

exports.useDeferredValue = function (a) {
  return S.current.useDeferredValue(a);
};

exports.useEffect = function (a, b) {
  return S.current.useEffect(a, b);
};

exports.useImperativeHandle = function (a, b, c) {
  return S.current.useImperativeHandle(a, b, c);
};

exports.useLayoutEffect = function (a, b) {
  return S.current.useLayoutEffect(a, b);
};

exports.useMemo = function (a, b) {
  return S.current.useMemo(a, b);
};

exports.useReducer = function (a, b, c) {
  return S.current.useReducer(a, b, c);
};

exports.useRef = function (a) {
  return S.current.useRef(a);
};

exports.useState = function (a) {
  return S.current.useState(a);
};

exports.useTransition = function () {
  return S.current.useTransition();
};

exports.version = "18.0.0-experimental-f6ec4661d-20210816";

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "connectToDevTools", function() { return /* binding */ connectToDevTools; });

// CONCATENATED MODULE: ../react-devtools-shared/src/events.js
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var EventEmitter = /*#__PURE__*/function () {
  function EventEmitter() {
    _classCallCheck(this, EventEmitter);

    _defineProperty(this, "listenersMap", new Map());
  }

  _createClass(EventEmitter, [{
    key: "addListener",
    value: function addListener(event, listener) {
      var listeners = this.listenersMap.get(event);

      if (listeners === undefined) {
        this.listenersMap.set(event, [listener]);
      } else {
        var index = listeners.indexOf(listener);

        if (index < 0) {
          listeners.push(listener);
        }
      }
    }
  }, {
    key: "emit",
    value: function emit(event) {
      var listeners = this.listenersMap.get(event);

      if (listeners !== undefined) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        if (listeners.length === 1) {
          // No need to clone or try/catch
          var listener = listeners[0];
          listener.apply(null, args);
        } else {
          var didThrow = false;
          var caughtError = null;
          var clonedListeners = Array.from(listeners);

          for (var i = 0; i < clonedListeners.length; i++) {
            var _listener = clonedListeners[i];

            try {
              _listener.apply(null, args);
            } catch (error) {
              if (caughtError === null) {
                didThrow = true;
                caughtError = error;
              }
            }
          }

          if (didThrow) {
            throw caughtError;
          }
        }
      }
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners() {
      this.listenersMap.clear();
    }
  }, {
    key: "removeListener",
    value: function removeListener(event, listener) {
      var listeners = this.listenersMap.get(event);

      if (listeners !== undefined) {
        var index = listeners.indexOf(listener);

        if (index >= 0) {
          listeners.splice(index, 1);
        }
      }
    }
  }]);

  return EventEmitter;
}();


// EXTERNAL MODULE: /Users/luna/code/react/node_modules/lodash.throttle/index.js
var lodash_throttle = __webpack_require__(3);
var lodash_throttle_default = /*#__PURE__*/__webpack_require__.n(lodash_throttle);

// CONCATENATED MODULE: ../react-devtools-shared/src/constants.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Flip this flag to true to enable verbose console debug logging.
var __DEBUG__ = false;
var TREE_OPERATION_ADD = 1;
var TREE_OPERATION_REMOVE = 2;
var TREE_OPERATION_REORDER_CHILDREN = 3;
var TREE_OPERATION_UPDATE_TREE_BASE_DURATION = 4;
var TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS = 5;
var TREE_OPERATION_REMOVE_ROOT = 6;
var LOCAL_STORAGE_FILTER_PREFERENCES_KEY = 'React::DevTools::componentFilters';
var SESSION_STORAGE_LAST_SELECTION_KEY = 'React::DevTools::lastSelection';
var LOCAL_STORAGE_PARSE_HOOK_NAMES_KEY = 'React::DevTools::parseHookNames';
var SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY = 'React::DevTools::recordChangeDescriptions';
var SESSION_STORAGE_RELOAD_AND_PROFILE_KEY = 'React::DevTools::reloadAndProfile';
var LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS = 'React::DevTools::breakOnConsoleErrors';
var LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY = 'React::DevTools::appendComponentStack';
var LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY = 'React::DevTools::showInlineWarningsAndErrors';
var LOCAL_STORAGE_TRACE_UPDATES_ENABLED_KEY = 'React::DevTools::traceUpdatesEnabled';
var PROFILER_EXPORT_VERSION = 5;
var CHANGE_LOG_URL = 'https://github.com/facebook/react/blob/main/packages/react-devtools/CHANGELOG.md';
var UNSUPPORTED_VERSION_URL = 'https://reactjs.org/blog/2019/08/15/new-react-devtools.html#how-do-i-get-the-old-version-back';
var REACT_DEVTOOLS_WORKPLACE_URL = 'https://fburl.com/react-devtools-workplace-group';
var THEME_STYLES = {
  light: {
    '--color-attribute-name': '#ef6632',
    '--color-attribute-name-not-editable': '#23272f',
    '--color-attribute-name-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-attribute-value': '#1a1aa6',
    '--color-attribute-value-inverted': '#ffffff',
    '--color-attribute-editable-value': '#1a1aa6',
    '--color-background': '#ffffff',
    '--color-background-hover': 'rgba(0, 136, 250, 0.1)',
    '--color-background-inactive': '#e5e5e5',
    '--color-background-invalid': '#fff0f0',
    '--color-background-selected': '#0088fa',
    '--color-button-background': '#ffffff',
    '--color-button-background-focus': '#ededed',
    '--color-button': '#5f6673',
    '--color-button-disabled': '#cfd1d5',
    '--color-button-active': '#0088fa',
    '--color-button-focus': '#23272f',
    '--color-button-hover': '#23272f',
    '--color-border': '#eeeeee',
    '--color-commit-did-not-render-fill': '#cfd1d5',
    '--color-commit-did-not-render-fill-text': '#000000',
    '--color-commit-did-not-render-pattern': '#cfd1d5',
    '--color-commit-did-not-render-pattern-text': '#333333',
    '--color-commit-gradient-0': '#37afa9',
    '--color-commit-gradient-1': '#63b19e',
    '--color-commit-gradient-2': '#80b393',
    '--color-commit-gradient-3': '#97b488',
    '--color-commit-gradient-4': '#abb67d',
    '--color-commit-gradient-5': '#beb771',
    '--color-commit-gradient-6': '#cfb965',
    '--color-commit-gradient-7': '#dfba57',
    '--color-commit-gradient-8': '#efbb49',
    '--color-commit-gradient-9': '#febc38',
    '--color-commit-gradient-text': '#000000',
    '--color-component-name': '#6a51b2',
    '--color-component-name-inverted': '#ffffff',
    '--color-component-badge-background': 'rgba(0, 0, 0, 0.1)',
    '--color-component-badge-background-inverted': 'rgba(255, 255, 255, 0.25)',
    '--color-component-badge-count': '#777d88',
    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-console-error-badge-text': '#ffffff',
    '--color-console-error-background': '#fff0f0',
    '--color-console-error-border': '#ffd6d6',
    '--color-console-error-icon': '#eb3941',
    '--color-console-error-text': '#fe2e31',
    '--color-console-warning-badge-text': '#000000',
    '--color-console-warning-background': '#fffbe5',
    '--color-console-warning-border': '#fff5c1',
    '--color-console-warning-icon': '#f4bd00',
    '--color-console-warning-text': '#64460c',
    '--color-context-background': 'rgba(0,0,0,.9)',
    '--color-context-background-hover': 'rgba(255, 255, 255, 0.1)',
    '--color-context-background-selected': '#178fb9',
    '--color-context-border': '#3d424a',
    '--color-context-text': '#ffffff',
    '--color-context-text-selected': '#ffffff',
    '--color-dim': '#777d88',
    '--color-dimmer': '#cfd1d5',
    '--color-dimmest': '#eff0f1',
    '--color-error-background': 'hsl(0, 100%, 97%)',
    '--color-error-border': 'hsl(0, 100%, 92%)',
    '--color-error-text': '#ff0000',
    '--color-expand-collapse-toggle': '#777d88',
    '--color-link': '#0000ff',
    '--color-modal-background': 'rgba(255, 255, 255, 0.75)',
    '--color-bridge-version-npm-background': '#eff0f1',
    '--color-bridge-version-npm-text': '#000000',
    '--color-bridge-version-number': '#0088fa',
    '--color-primitive-hook-badge-background': '#e5e5e5',
    '--color-primitive-hook-badge-text': '#5f6673',
    '--color-record-active': '#fc3a4b',
    '--color-record-hover': '#3578e5',
    '--color-record-inactive': '#0088fa',
    '--color-resize-bar': '#eeeeee',
    '--color-resize-bar-active': '#dcdcdc',
    '--color-resize-bar-border': '#d1d1d1',
    '--color-resize-bar-dot': '#333333',
    '--color-scheduling-profiler-native-event': '#ccc',
    '--color-scheduling-profiler-native-event-hover': '#aaa',
    '--color-scheduling-profiler-priority-background': '#f6f6f6',
    '--color-scheduling-profiler-priority-border': '#eeeeee',
    '--color-scheduling-profiler-user-timing': '#c9cacd',
    '--color-scheduling-profiler-user-timing-hover': '#93959a',
    '--color-scheduling-profiler-react-idle': '#d3e5f6',
    '--color-scheduling-profiler-react-idle-hover': '#c3d9ef',
    '--color-scheduling-profiler-react-render': '#9fc3f3',
    '--color-scheduling-profiler-react-render-hover': '#83afe9',
    '--color-scheduling-profiler-react-render-text': '#11365e',
    '--color-scheduling-profiler-react-commit': '#c88ff0',
    '--color-scheduling-profiler-react-commit-hover': '#b281d6',
    '--color-scheduling-profiler-react-commit-text': '#3e2c4a',
    '--color-scheduling-profiler-react-layout-effects': '#b281d6',
    '--color-scheduling-profiler-react-layout-effects-hover': '#9d71bd',
    '--color-scheduling-profiler-react-layout-effects-text': '#3e2c4a',
    '--color-scheduling-profiler-react-passive-effects': '#b281d6',
    '--color-scheduling-profiler-react-passive-effects-hover': '#9d71bd',
    '--color-scheduling-profiler-react-passive-effects-text': '#3e2c4a',
    '--color-scheduling-profiler-react-schedule': '#9fc3f3',
    '--color-scheduling-profiler-react-schedule-hover': '#2683E2',
    '--color-scheduling-profiler-react-suspense-rejected': '#f1cc14',
    '--color-scheduling-profiler-react-suspense-rejected-hover': '#ffdf37',
    '--color-scheduling-profiler-react-suspense-resolved': '#a6e59f',
    '--color-scheduling-profiler-react-suspense-resolved-hover': '#89d281',
    '--color-scheduling-profiler-react-suspense-unresolved': '#c9cacd',
    '--color-scheduling-profiler-react-suspense-unresolved-hover': '#93959a',
    '--color-scheduling-profiler-text-color': '#000000',
    '--color-scheduling-profiler-text-dim-color': '#ccc',
    '--color-scheduling-profiler-react-work-border': '#ffffff',
    '--color-search-match': 'yellow',
    '--color-search-match-current': '#f7923b',
    '--color-selected-tree-highlight-active': 'rgba(0, 136, 250, 0.1)',
    '--color-selected-tree-highlight-inactive': 'rgba(0, 0, 0, 0.05)',
    '--color-scroll-caret': 'rgba(150, 150, 150, 0.5)',
    '--color-tab-selected-border': '#0088fa',
    '--color-text': '#000000',
    '--color-text-invalid': '#ff0000',
    '--color-text-selected': '#ffffff',
    '--color-toggle-background-invalid': '#fc3a4b',
    '--color-toggle-background-on': '#0088fa',
    '--color-toggle-background-off': '#cfd1d5',
    '--color-toggle-text': '#ffffff',
    '--color-warning-background': '#fb3655',
    '--color-warning-background-hover': '#f82042',
    '--color-warning-text-color': '#ffffff',
    '--color-warning-text-color-inverted': '#fd4d69',
    // The styles below should be kept in sync with 'root.css'
    // They are repeated there because they're used by e.g. tooltips or context menus
    // which get rendered outside of the DOM subtree (where normal theme/styles are written).
    '--color-scroll-thumb': '#c2c2c2',
    '--color-scroll-track': '#fafafa',
    '--color-tooltip-background': 'rgba(0, 0, 0, 0.9)',
    '--color-tooltip-text': '#ffffff'
  },
  dark: {
    '--color-attribute-name': '#9d87d2',
    '--color-attribute-name-not-editable': '#ededed',
    '--color-attribute-name-inverted': '#282828',
    '--color-attribute-value': '#cedae0',
    '--color-attribute-value-inverted': '#ffffff',
    '--color-attribute-editable-value': 'yellow',
    '--color-background': '#282c34',
    '--color-background-hover': 'rgba(255, 255, 255, 0.1)',
    '--color-background-inactive': '#3d424a',
    '--color-background-invalid': '#5c0000',
    '--color-background-selected': '#178fb9',
    '--color-button-background': '#282c34',
    '--color-button-background-focus': '#3d424a',
    '--color-button': '#afb3b9',
    '--color-button-active': '#61dafb',
    '--color-button-disabled': '#4f5766',
    '--color-button-focus': '#a2e9fc',
    '--color-button-hover': '#ededed',
    '--color-border': '#3d424a',
    '--color-commit-did-not-render-fill': '#777d88',
    '--color-commit-did-not-render-fill-text': '#000000',
    '--color-commit-did-not-render-pattern': '#666c77',
    '--color-commit-did-not-render-pattern-text': '#ffffff',
    '--color-commit-gradient-0': '#37afa9',
    '--color-commit-gradient-1': '#63b19e',
    '--color-commit-gradient-2': '#80b393',
    '--color-commit-gradient-3': '#97b488',
    '--color-commit-gradient-4': '#abb67d',
    '--color-commit-gradient-5': '#beb771',
    '--color-commit-gradient-6': '#cfb965',
    '--color-commit-gradient-7': '#dfba57',
    '--color-commit-gradient-8': '#efbb49',
    '--color-commit-gradient-9': '#febc38',
    '--color-commit-gradient-text': '#000000',
    '--color-component-name': '#61dafb',
    '--color-component-name-inverted': '#282828',
    '--color-component-badge-background': 'rgba(255, 255, 255, 0.25)',
    '--color-component-badge-background-inverted': 'rgba(0, 0, 0, 0.25)',
    '--color-component-badge-count': '#8f949d',
    '--color-component-badge-count-inverted': 'rgba(255, 255, 255, 0.7)',
    '--color-console-error-badge-text': '#000000',
    '--color-console-error-background': '#290000',
    '--color-console-error-border': '#5c0000',
    '--color-console-error-icon': '#eb3941',
    '--color-console-error-text': '#fc7f7f',
    '--color-console-warning-badge-text': '#000000',
    '--color-console-warning-background': '#332b00',
    '--color-console-warning-border': '#665500',
    '--color-console-warning-icon': '#f4bd00',
    '--color-console-warning-text': '#f5f2ed',
    '--color-context-background': 'rgba(255,255,255,.95)',
    '--color-context-background-hover': 'rgba(0, 136, 250, 0.1)',
    '--color-context-background-selected': '#0088fa',
    '--color-context-border': '#eeeeee',
    '--color-context-text': '#000000',
    '--color-context-text-selected': '#ffffff',
    '--color-dim': '#8f949d',
    '--color-dimmer': '#777d88',
    '--color-dimmest': '#4f5766',
    '--color-error-background': '#200',
    '--color-error-border': '#900',
    '--color-error-text': '#f55',
    '--color-expand-collapse-toggle': '#8f949d',
    '--color-link': '#61dafb',
    '--color-modal-background': 'rgba(0, 0, 0, 0.75)',
    '--color-bridge-version-npm-background': 'rgba(0, 0, 0, 0.25)',
    '--color-bridge-version-npm-text': '#ffffff',
    '--color-bridge-version-number': 'yellow',
    '--color-primitive-hook-badge-background': 'rgba(0, 0, 0, 0.25)',
    '--color-primitive-hook-badge-text': 'rgba(255, 255, 255, 0.7)',
    '--color-record-active': '#fc3a4b',
    '--color-record-hover': '#a2e9fc',
    '--color-record-inactive': '#61dafb',
    '--color-resize-bar': '#282c34',
    '--color-resize-bar-active': '#31363f',
    '--color-resize-bar-border': '#3d424a',
    '--color-resize-bar-dot': '#cfd1d5',
    '--color-scheduling-profiler-native-event': '#b2b2b2',
    '--color-scheduling-profiler-native-event-hover': '#949494',
    '--color-scheduling-profiler-priority-background': '#1d2129',
    '--color-scheduling-profiler-priority-border': '#282c34',
    '--color-scheduling-profiler-user-timing': '#c9cacd',
    '--color-scheduling-profiler-user-timing-hover': '#93959a',
    '--color-scheduling-profiler-react-idle': '#3d485b',
    '--color-scheduling-profiler-react-idle-hover': '#465269',
    '--color-scheduling-profiler-react-render': '#2683E2',
    '--color-scheduling-profiler-react-render-hover': '#1a76d4',
    '--color-scheduling-profiler-react-render-text': '#11365e',
    '--color-scheduling-profiler-react-commit': '#731fad',
    '--color-scheduling-profiler-react-commit-hover': '#611b94',
    '--color-scheduling-profiler-react-commit-text': '#e5c1ff',
    '--color-scheduling-profiler-react-layout-effects': '#611b94',
    '--color-scheduling-profiler-react-layout-effects-hover': '#51167a',
    '--color-scheduling-profiler-react-layout-effects-text': '#e5c1ff',
    '--color-scheduling-profiler-react-passive-effects': '#611b94',
    '--color-scheduling-profiler-react-passive-effects-hover': '#51167a',
    '--color-scheduling-profiler-react-passive-effects-text': '#e5c1ff',
    '--color-scheduling-profiler-react-schedule': '#2683E2',
    '--color-scheduling-profiler-react-schedule-hover': '#1a76d4',
    '--color-scheduling-profiler-react-suspense-rejected': '#f1cc14',
    '--color-scheduling-profiler-react-suspense-rejected-hover': '#e4c00f',
    '--color-scheduling-profiler-react-suspense-resolved': '#a6e59f',
    '--color-scheduling-profiler-react-suspense-resolved-hover': '#89d281',
    '--color-scheduling-profiler-react-suspense-unresolved': '#c9cacd',
    '--color-scheduling-profiler-react-suspense-unresolved-hover': '#93959a',
    '--color-scheduling-profiler-text-color': '#282c34',
    '--color-scheduling-profiler-text-dim-color': '#555b66',
    '--color-scheduling-profiler-react-work-border': '#ffffff',
    '--color-search-match': 'yellow',
    '--color-search-match-current': '#f7923b',
    '--color-selected-tree-highlight-active': 'rgba(23, 143, 185, 0.15)',
    '--color-selected-tree-highlight-inactive': 'rgba(255, 255, 255, 0.05)',
    '--color-scroll-caret': '#4f5766',
    '--color-shadow': 'rgba(0, 0, 0, 0.5)',
    '--color-tab-selected-border': '#178fb9',
    '--color-text': '#ffffff',
    '--color-text-invalid': '#ff8080',
    '--color-text-selected': '#ffffff',
    '--color-toggle-background-invalid': '#fc3a4b',
    '--color-toggle-background-on': '#178fb9',
    '--color-toggle-background-off': '#777d88',
    '--color-toggle-text': '#ffffff',
    '--color-warning-background': '#ee1638',
    '--color-warning-background-hover': '#da1030',
    '--color-warning-text-color': '#ffffff',
    '--color-warning-text-color-inverted': '#ee1638',
    // The styles below should be kept in sync with 'root.css'
    // They are repeated there because they're used by e.g. tooltips or context menus
    // which get rendered outside of the DOM subtree (where normal theme/styles are written).
    '--color-scroll-thumb': '#afb3b9',
    '--color-scroll-track': '#313640',
    '--color-tooltip-background': 'rgba(255, 255, 255, 0.95)',
    '--color-tooltip-text': '#000000'
  },
  compact: {
    '--font-size-monospace-small': '9px',
    '--font-size-monospace-normal': '11px',
    '--font-size-monospace-large': '15px',
    '--font-size-sans-small': '10px',
    '--font-size-sans-normal': '12px',
    '--font-size-sans-large': '14px',
    '--line-height-data': '18px'
  },
  comfortable: {
    '--font-size-monospace-small': '10px',
    '--font-size-monospace-normal': '13px',
    '--font-size-monospace-large': '17px',
    '--font-size-sans-small': '12px',
    '--font-size-sans-normal': '14px',
    '--font-size-sans-large': '16px',
    '--line-height-data': '22px'
  }
}; // HACK
//
// Sometimes the inline target is rendered before root styles are applied,
// which would result in e.g. NaN itemSize being passed to react-window list.

var COMFORTABLE_LINE_HEIGHT = parseInt(THEME_STYLES.comfortable['--line-height-data'], 10);
var COMPACT_LINE_HEIGHT = parseInt(THEME_STYLES.compact['--line-height-data'], 10);

// CONCATENATED MODULE: ../react-devtools-shared/src/storage.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function localStorageGetItem(key) {
  try {
    return localStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function localStorageRemoveItem(key) {
  try {
    localStorage.removeItem(key);
  } catch (error) {}
}
function localStorageSetItem(key, value) {
  try {
    return localStorage.setItem(key, value);
  } catch (error) {}
}
function sessionStorageGetItem(key) {
  try {
    return sessionStorage.getItem(key);
  } catch (error) {
    return null;
  }
}
function sessionStorageRemoveItem(key) {
  try {
    sessionStorage.removeItem(key);
  } catch (error) {}
}
function sessionStorageSetItem(key, value) {
  try {
    return sessionStorage.setItem(key, value);
  } catch (error) {}
}
// CONCATENATED MODULE: /Users/luna/code/react/node_modules/memoize-one/esm/index.js
var simpleIsEqual = function simpleIsEqual(a, b) {
  return a === b;
};

/* harmony default export */ var esm = (function (resultFn) {
  var isEqual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : simpleIsEqual;
  var lastThis = void 0;
  var lastArgs = [];
  var lastResult = void 0;
  var calledOnce = false;

  var isNewArgEqualToLast = function isNewArgEqualToLast(newArg, index) {
    return isEqual(newArg, lastArgs[index]);
  };

  var result = function result() {
    for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
      newArgs[_key] = arguments[_key];
    }

    if (calledOnce && lastThis === this && newArgs.length === lastArgs.length && newArgs.every(isNewArgEqualToLast)) {
      return lastResult;
    }

    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    lastResult = resultFn.apply(this, newArgs);
    return lastResult;
  };

  return result;
});
// EXTERNAL MODULE: /Users/luna/code/react/node_modules/object-assign/index.js
var object_assign = __webpack_require__(1);
var object_assign_default = /*#__PURE__*/__webpack_require__.n(object_assign);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// Get the window object for the document that a node belongs to,
// or return null if it cannot be found (node not attached to DOM,
// etc).
function getOwnerWindow(node) {
  if (!node.ownerDocument) {
    return null;
  }

  return node.ownerDocument.defaultView;
} // Get the iframe containing a node, or return null if it cannot
// be found (node not within iframe, etc).

function getOwnerIframe(node) {
  var nodeWindow = getOwnerWindow(node);

  if (nodeWindow) {
    return nodeWindow.frameElement;
  }

  return null;
} // Get a bounding client rect for a node, with an
// offset added to compensate for its border.

function getBoundingClientRectWithBorderOffset(node) {
  var dimensions = getElementDimensions(node);
  return mergeRectOffsets([node.getBoundingClientRect(), {
    top: dimensions.borderTop,
    left: dimensions.borderLeft,
    bottom: dimensions.borderBottom,
    right: dimensions.borderRight,
    // This width and height won't get used by mergeRectOffsets (since this
    // is not the first rect in the array), but we set them so that this
    // object typechecks as a ClientRect.
    width: 0,
    height: 0
  }]);
} // Add together the top, left, bottom, and right properties of
// each ClientRect, but keep the width and height of the first one.

function mergeRectOffsets(rects) {
  return rects.reduce(function (previousRect, rect) {
    if (previousRect == null) {
      return rect;
    }

    return {
      top: previousRect.top + rect.top,
      left: previousRect.left + rect.left,
      width: previousRect.width,
      height: previousRect.height,
      bottom: previousRect.bottom + rect.bottom,
      right: previousRect.right + rect.right
    };
  });
} // Calculate a boundingClientRect for a node relative to boundaryWindow,
// taking into account any offsets caused by intermediate iframes.

function getNestedBoundingClientRect(node, boundaryWindow) {
  var ownerIframe = getOwnerIframe(node);

  if (ownerIframe && ownerIframe !== boundaryWindow) {
    var rects = [node.getBoundingClientRect()];
    var currentIframe = ownerIframe;
    var onlyOneMore = false;

    while (currentIframe) {
      var rect = getBoundingClientRectWithBorderOffset(currentIframe);
      rects.push(rect);
      currentIframe = getOwnerIframe(currentIframe);

      if (onlyOneMore) {
        break;
      } // We don't want to calculate iframe offsets upwards beyond
      // the iframe containing the boundaryWindow, but we
      // need to calculate the offset relative to the boundaryWindow.


      if (currentIframe && getOwnerWindow(currentIframe) === boundaryWindow) {
        onlyOneMore = true;
      }
    }

    return mergeRectOffsets(rects);
  } else {
    return node.getBoundingClientRect();
  }
}
function getElementDimensions(domElement) {
  var calculatedStyle = window.getComputedStyle(domElement);
  return {
    borderLeft: parseInt(calculatedStyle.borderLeftWidth, 10),
    borderRight: parseInt(calculatedStyle.borderRightWidth, 10),
    borderTop: parseInt(calculatedStyle.borderTopWidth, 10),
    borderBottom: parseInt(calculatedStyle.borderBottomWidth, 10),
    marginLeft: parseInt(calculatedStyle.marginLeft, 10),
    marginRight: parseInt(calculatedStyle.marginRight, 10),
    marginTop: parseInt(calculatedStyle.marginTop, 10),
    marginBottom: parseInt(calculatedStyle.marginBottom, 10),
    paddingLeft: parseInt(calculatedStyle.paddingLeft, 10),
    paddingRight: parseInt(calculatedStyle.paddingRight, 10),
    paddingTop: parseInt(calculatedStyle.paddingTop, 10),
    paddingBottom: parseInt(calculatedStyle.paddingBottom, 10)
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Overlay.js
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function Overlay_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Overlay_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Overlay_createClass(Constructor, protoProps, staticProps) { if (protoProps) Overlay_defineProperties(Constructor.prototype, protoProps); if (staticProps) Overlay_defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// Note that the Overlay components are not affected by the active Theme,
// because they highlight elements in the main Chrome window (outside of devtools).
// The colors below were chosen to roughly match those used by Chrome devtools.
var Overlay_OverlayRect = /*#__PURE__*/function () {
  function OverlayRect(doc, container) {
    Overlay_classCallCheck(this, OverlayRect);

    this.node = doc.createElement('div');
    this.border = doc.createElement('div');
    this.padding = doc.createElement('div');
    this.content = doc.createElement('div');
    this.border.style.borderColor = overlayStyles.border;
    this.padding.style.borderColor = overlayStyles.padding;
    this.content.style.backgroundColor = overlayStyles.background;
    object_assign_default()(this.node.style, {
      borderColor: overlayStyles.margin,
      pointerEvents: 'none',
      position: 'fixed'
    });
    this.node.style.zIndex = '10000000';
    this.node.appendChild(this.border);
    this.border.appendChild(this.padding);
    this.padding.appendChild(this.content);
    container.appendChild(this.node);
  }

  Overlay_createClass(OverlayRect, [{
    key: "remove",
    value: function remove() {
      if (this.node.parentNode) {
        this.node.parentNode.removeChild(this.node);
      }
    }
  }, {
    key: "update",
    value: function update(box, dims) {
      boxWrap(dims, 'margin', this.node);
      boxWrap(dims, 'border', this.border);
      boxWrap(dims, 'padding', this.padding);
      object_assign_default()(this.content.style, {
        height: box.height - dims.borderTop - dims.borderBottom - dims.paddingTop - dims.paddingBottom + 'px',
        width: box.width - dims.borderLeft - dims.borderRight - dims.paddingLeft - dims.paddingRight + 'px'
      });
      object_assign_default()(this.node.style, {
        top: box.top - dims.marginTop + 'px',
        left: box.left - dims.marginLeft + 'px'
      });
    }
  }]);

  return OverlayRect;
}();

var Overlay_OverlayTip = /*#__PURE__*/function () {
  function OverlayTip(doc, container) {
    Overlay_classCallCheck(this, OverlayTip);

    this.tip = doc.createElement('div');
    object_assign_default()(this.tip.style, {
      display: 'flex',
      flexFlow: 'row nowrap',
      backgroundColor: '#333740',
      borderRadius: '2px',
      fontFamily: '"SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace',
      fontWeight: 'bold',
      padding: '3px 5px',
      pointerEvents: 'none',
      position: 'fixed',
      fontSize: '12px',
      whiteSpace: 'nowrap'
    });
    this.nameSpan = doc.createElement('span');
    this.tip.appendChild(this.nameSpan);
    object_assign_default()(this.nameSpan.style, {
      color: '#ee78e6',
      borderRight: '1px solid #aaaaaa',
      paddingRight: '0.5rem',
      marginRight: '0.5rem'
    });
    this.dimSpan = doc.createElement('span');
    this.tip.appendChild(this.dimSpan);
    object_assign_default()(this.dimSpan.style, {
      color: '#d7d7d7'
    });
    this.tip.style.zIndex = '10000000';
    container.appendChild(this.tip);
  }

  Overlay_createClass(OverlayTip, [{
    key: "remove",
    value: function remove() {
      if (this.tip.parentNode) {
        this.tip.parentNode.removeChild(this.tip);
      }
    }
  }, {
    key: "updateText",
    value: function updateText(name, width, height) {
      this.nameSpan.textContent = name;
      this.dimSpan.textContent = Math.round(width) + 'px  ' + Math.round(height) + 'px';
    }
  }, {
    key: "updatePosition",
    value: function updatePosition(dims, bounds) {
      var tipRect = this.tip.getBoundingClientRect();
      var tipPos = findTipPos(dims, bounds, {
        width: tipRect.width,
        height: tipRect.height
      });
      object_assign_default()(this.tip.style, tipPos.style);
    }
  }]);

  return OverlayTip;
}();

var Overlay_Overlay = /*#__PURE__*/function () {
  function Overlay() {
    Overlay_classCallCheck(this, Overlay);

    // Find the root window, because overlays are positioned relative to it.
    var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.window = currentWindow; // When opened in shells/dev, the tooltip should be bound by the app iframe, not by the topmost window.

    var tipBoundsWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
    this.tipBoundsWindow = tipBoundsWindow;
    var doc = currentWindow.document;
    this.container = doc.createElement('div');
    this.container.style.zIndex = '10000000';
    this.tip = new Overlay_OverlayTip(doc, this.container);
    this.rects = [];
    doc.body.appendChild(this.container);
  }

  Overlay_createClass(Overlay, [{
    key: "remove",
    value: function remove() {
      this.tip.remove();
      this.rects.forEach(function (rect) {
        rect.remove();
      });
      this.rects.length = 0;

      if (this.container.parentNode) {
        this.container.parentNode.removeChild(this.container);
      }
    }
  }, {
    key: "inspect",
    value: function inspect(nodes, name) {
      var _this = this;

      // We can't get the size of text nodes or comment nodes. React as of v15
      // heavily uses comment nodes to delimit text.
      var elements = nodes.filter(function (node) {
        return node.nodeType === Node.ELEMENT_NODE;
      });

      while (this.rects.length > elements.length) {
        var rect = this.rects.pop();
        rect.remove();
      }

      if (elements.length === 0) {
        return;
      }

      while (this.rects.length < elements.length) {
        this.rects.push(new Overlay_OverlayRect(this.window.document, this.container));
      }

      var outerBox = {
        top: Number.POSITIVE_INFINITY,
        right: Number.NEGATIVE_INFINITY,
        bottom: Number.NEGATIVE_INFINITY,
        left: Number.POSITIVE_INFINITY
      };
      elements.forEach(function (element, index) {
        var box = getNestedBoundingClientRect(element, _this.window);
        var dims = getElementDimensions(element);
        outerBox.top = Math.min(outerBox.top, box.top - dims.marginTop);
        outerBox.right = Math.max(outerBox.right, box.left + box.width + dims.marginRight);
        outerBox.bottom = Math.max(outerBox.bottom, box.top + box.height + dims.marginBottom);
        outerBox.left = Math.min(outerBox.left, box.left - dims.marginLeft);
        var rect = _this.rects[index];
        rect.update(box, dims);
      });

      if (!name) {
        name = elements[0].nodeName.toLowerCase();
        var node = elements[0];
        var hook = node.ownerDocument.defaultView.__REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook != null && hook.rendererInterfaces != null) {
          var ownerName = null; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

          var _iterator = _createForOfIteratorHelper(hook.rendererInterfaces.values()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var rendererInterface = _step.value;
              var id = rendererInterface.getFiberIDForNative(node, true);

              if (id !== null) {
                ownerName = rendererInterface.getDisplayNameForFiberID(id, true);
                break;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          if (ownerName) {
            name += ' (in ' + ownerName + ')';
          }
        }
      }

      this.tip.updateText(name, outerBox.right - outerBox.left, outerBox.bottom - outerBox.top);
      var tipBounds = getNestedBoundingClientRect(this.tipBoundsWindow.document.documentElement, this.window);
      this.tip.updatePosition({
        top: outerBox.top,
        left: outerBox.left,
        height: outerBox.bottom - outerBox.top,
        width: outerBox.right - outerBox.left
      }, {
        top: tipBounds.top + this.tipBoundsWindow.scrollY,
        left: tipBounds.left + this.tipBoundsWindow.scrollX,
        height: this.tipBoundsWindow.innerHeight,
        width: this.tipBoundsWindow.innerWidth
      });
    }
  }]);

  return Overlay;
}();



function findTipPos(dims, bounds, tipSize) {
  var tipHeight = Math.max(tipSize.height, 20);
  var tipWidth = Math.max(tipSize.width, 60);
  var margin = 5;
  var top;

  if (dims.top + dims.height + tipHeight <= bounds.top + bounds.height) {
    if (dims.top + dims.height < bounds.top + 0) {
      top = bounds.top + margin;
    } else {
      top = dims.top + dims.height + margin;
    }
  } else if (dims.top - tipHeight <= bounds.top + bounds.height) {
    if (dims.top - tipHeight - margin < bounds.top + margin) {
      top = bounds.top + margin;
    } else {
      top = dims.top - tipHeight - margin;
    }
  } else {
    top = bounds.top + bounds.height - tipHeight - margin;
  }

  var left = dims.left + margin;

  if (dims.left < bounds.left) {
    left = bounds.left + margin;
  }

  if (dims.left + tipWidth > bounds.left + bounds.width) {
    left = bounds.left + bounds.width - tipWidth - margin;
  }

  top += 'px';
  left += 'px';
  return {
    style: {
      top: top,
      left: left
    }
  };
}

function boxWrap(dims, what, node) {
  object_assign_default()(node.style, {
    borderTopWidth: dims[what + 'Top'] + 'px',
    borderLeftWidth: dims[what + 'Left'] + 'px',
    borderRightWidth: dims[what + 'Right'] + 'px',
    borderBottomWidth: dims[what + 'Bottom'] + 'px',
    borderStyle: 'solid'
  });
}

var overlayStyles = {
  background: 'rgba(120, 170, 210, 0.7)',
  padding: 'rgba(77, 200, 0, 0.3)',
  margin: 'rgba(255, 155, 0, 0.3)',
  border: 'rgba(255, 200, 50, 0.3)'
};
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/Highlighter.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var SHOW_DURATION = 2000;
var timeoutID = null;
var overlay = null;
function hideOverlay() {
  timeoutID = null;

  if (overlay !== null) {
    overlay.remove();
    overlay = null;
  }
}
function showOverlay(elements, componentName, hideAfterTimeout) {
  // TODO (npm-packages) Detect RN and support it somehow
  if (window.document == null) {
    return;
  }

  if (timeoutID !== null) {
    clearTimeout(timeoutID);
  }

  if (elements == null) {
    return;
  }

  if (overlay === null) {
    overlay = new Overlay_Overlay();
  }

  overlay.inspect(elements, componentName);

  if (hideAfterTimeout) {
    timeoutID = setTimeout(hideOverlay, SHOW_DURATION);
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/Highlighter/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */




// This plug-in provides in-page highlighting of the selected element.
// It is used by the browser extension and the standalone DevTools shell (when connected to a browser).
// It is not currently the mechanism used to highlight React Native views.
// That is done by the React Native Inspector component.
var iframesListeningTo = new Set();
function setupHighlighter(bridge, agent) {
  bridge.addListener('clearNativeElementHighlight', clearNativeElementHighlight);
  bridge.addListener('highlightNativeElement', highlightNativeElement);
  bridge.addListener('shutdown', stopInspectingNative);
  bridge.addListener('startInspectingNative', startInspectingNative);
  bridge.addListener('stopInspectingNative', stopInspectingNative);

  function startInspectingNative() {
    registerListenersOnWindow(window);
  }

  function registerListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.addEventListener === 'function') {
      window.addEventListener('click', onClick, true);
      window.addEventListener('mousedown', onMouseEvent, true);
      window.addEventListener('mouseover', onMouseEvent, true);
      window.addEventListener('mouseup', onMouseEvent, true);
      window.addEventListener('pointerdown', onPointerDown, true);
      window.addEventListener('pointerover', onPointerOver, true);
      window.addEventListener('pointerup', onPointerUp, true);
    }
  }

  function stopInspectingNative() {
    hideOverlay();
    removeListenersOnWindow(window);
    iframesListeningTo.forEach(function (frame) {
      try {
        removeListenersOnWindow(frame.contentWindow);
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    });
    iframesListeningTo = new Set();
  }

  function removeListenersOnWindow(window) {
    // This plug-in may run in non-DOM environments (e.g. React Native).
    if (window && typeof window.removeEventListener === 'function') {
      window.removeEventListener('click', onClick, true);
      window.removeEventListener('mousedown', onMouseEvent, true);
      window.removeEventListener('mouseover', onMouseEvent, true);
      window.removeEventListener('mouseup', onMouseEvent, true);
      window.removeEventListener('pointerdown', onPointerDown, true);
      window.removeEventListener('pointerover', onPointerOver, true);
      window.removeEventListener('pointerup', onPointerUp, true);
    }
  }

  function clearNativeElementHighlight() {
    hideOverlay();
  }

  function highlightNativeElement(_ref) {
    var displayName = _ref.displayName,
        hideAfterTimeout = _ref.hideAfterTimeout,
        id = _ref.id,
        openNativeElementsPanel = _ref.openNativeElementsPanel,
        rendererID = _ref.rendererID,
        scrollIntoView = _ref.scrollIntoView;
    var renderer = agent.rendererInterfaces[rendererID];

    if (renderer == null) {
      console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
    }

    var nodes = null;

    if (renderer != null) {
      nodes = renderer.findNativeNodesForFiberID(id);
    }

    if (nodes != null && nodes[0] != null) {
      var node = nodes[0];

      if (scrollIntoView && typeof node.scrollIntoView === 'function') {
        // If the node isn't visible show it before highlighting it.
        // We may want to reconsider this; it might be a little disruptive.
        // $FlowFixMe Flow only knows about 'start' | 'end'
        node.scrollIntoView({
          block: 'nearest',
          inline: 'nearest'
        });
      }

      showOverlay(nodes, displayName, hideAfterTimeout);

      if (openNativeElementsPanel) {
        window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0 = node;
        bridge.send('syncSelectionToNativeElementsPanel');
      }
    } else {
      hideOverlay();
    }
  }

  function onClick(event) {
    event.preventDefault();
    event.stopPropagation();
    stopInspectingNative();
    bridge.send('stopInspectingNative', true);
  }

  function onMouseEvent(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  function onPointerDown(event) {
    event.preventDefault();
    event.stopPropagation();
    selectFiberForNode(event.target);
  }

  function onPointerOver(event) {
    event.preventDefault();
    event.stopPropagation();
    var target = event.target;

    if (target.tagName === 'IFRAME') {
      var iframe = target;

      try {
        if (!iframesListeningTo.has(iframe)) {
          var _window = iframe.contentWindow;
          registerListenersOnWindow(_window);
          iframesListeningTo.add(iframe);
        }
      } catch (error) {// This can error when the iframe is on a cross-origin.
      }
    } // Don't pass the name explicitly.
    // It will be inferred from DOM tag and Fiber owner.


    showOverlay([target], null, false);
    selectFiberForNode(target);
  }

  function onPointerUp(event) {
    event.preventDefault();
    event.stopPropagation();
  }

  var selectFiberForNode = lodash_throttle_default()(esm(function (node) {
    var id = agent.getIDForNode(node);

    if (id !== null) {
      bridge.send('selectFiber', id);
    }
  }), 200, // Don't change the selection in the very first 200ms
  // because those are usually unintentional as you lift the cursor.
  {
    leading: false
  });
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/canvas.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var OUTLINE_COLOR = '#f0f0f0'; // Note these colors are in sync with DevTools Profiler chart colors.

var COLORS = ['#37afa9', '#63b19e', '#80b393', '#97b488', '#abb67d', '#beb771', '#cfb965', '#dfba57', '#efbb49', '#febc38'];
var canvas = null;
function draw(nodeToData) {
  if (canvas === null) {
    initialize();
  }

  var canvasFlow = canvas;
  canvasFlow.width = window.innerWidth;
  canvasFlow.height = window.innerHeight;
  var context = canvasFlow.getContext('2d');
  context.clearRect(0, 0, canvasFlow.width, canvasFlow.height);
  nodeToData.forEach(function (_ref) {
    var count = _ref.count,
        rect = _ref.rect;

    if (rect !== null) {
      var colorIndex = Math.min(COLORS.length - 1, count - 1);
      var color = COLORS[colorIndex];
      drawBorder(context, rect, color);
    }
  });
}

function drawBorder(context, rect, color) {
  var height = rect.height,
      left = rect.left,
      top = rect.top,
      width = rect.width; // outline

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left - 1, top - 1, width + 2, height + 2); // inset

  context.lineWidth = 1;
  context.strokeStyle = OUTLINE_COLOR;
  context.strokeRect(left + 1, top + 1, width - 1, height - 1);
  context.strokeStyle = color;
  context.setLineDash([0]); // border

  context.lineWidth = 1;
  context.strokeRect(left, top, width - 1, height - 1);
  context.setLineDash([0]);
}

function destroy() {
  if (canvas !== null) {
    if (canvas.parentNode != null) {
      canvas.parentNode.removeChild(canvas);
    }

    canvas = null;
  }
}

function initialize() {
  canvas = window.document.createElement('canvas');
  canvas.style.cssText = "\n    xx-background-color: red;\n    xx-opacity: 0.5;\n    bottom: 0;\n    left: 0;\n    pointer-events: none;\n    position: fixed;\n    right: 0;\n    top: 0;\n    z-index: 1000000000;\n  ";
  var root = window.document.documentElement;
  root.insertBefore(canvas, root.firstChild);
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/views/TraceUpdates/index.js
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



// How long the rect should be shown for?
var DISPLAY_DURATION = 250; // What's the longest we are willing to show the overlay for?
// This can be important if we're getting a flurry of events (e.g. scroll update).

var MAX_DISPLAY_DURATION = 3000; // How long should a rect be considered valid for?

var REMEASUREMENT_AFTER_DURATION = 250; // Some environments (e.g. React Native / Hermes) don't support the performance API yet.

var getCurrentTime = (typeof performance === "undefined" ? "undefined" : _typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var nodeToData = new Map();
var TraceUpdates_agent = null;
var drawAnimationFrameID = null;
var isEnabled = false;
var redrawTimeoutID = null;
function TraceUpdates_initialize(injectedAgent) {
  TraceUpdates_agent = injectedAgent;
  TraceUpdates_agent.addListener('traceUpdates', traceUpdates);
}
function toggleEnabled(value) {
  isEnabled = value;

  if (!isEnabled) {
    nodeToData.clear();

    if (drawAnimationFrameID !== null) {
      cancelAnimationFrame(drawAnimationFrameID);
      drawAnimationFrameID = null;
    }

    if (redrawTimeoutID !== null) {
      clearTimeout(redrawTimeoutID);
      redrawTimeoutID = null;
    }

    destroy();
  }
}

function traceUpdates(nodes) {
  if (!isEnabled) {
    return;
  }

  nodes.forEach(function (node) {
    var data = nodeToData.get(node);
    var now = getCurrentTime();
    var lastMeasuredAt = data != null ? data.lastMeasuredAt : 0;
    var rect = data != null ? data.rect : null;

    if (rect === null || lastMeasuredAt + REMEASUREMENT_AFTER_DURATION < now) {
      lastMeasuredAt = now;
      rect = measureNode(node);
    }

    nodeToData.set(node, {
      count: data != null ? data.count + 1 : 1,
      expirationTime: data != null ? Math.min(now + MAX_DISPLAY_DURATION, data.expirationTime + DISPLAY_DURATION) : now + DISPLAY_DURATION,
      lastMeasuredAt: lastMeasuredAt,
      rect: rect
    });
  });

  if (redrawTimeoutID !== null) {
    clearTimeout(redrawTimeoutID);
    redrawTimeoutID = null;
  }

  if (drawAnimationFrameID === null) {
    drawAnimationFrameID = requestAnimationFrame(prepareToDraw);
  }
}

function prepareToDraw() {
  drawAnimationFrameID = null;
  redrawTimeoutID = null;
  var now = getCurrentTime();
  var earliestExpiration = Number.MAX_VALUE; // Remove any items that have already expired.

  nodeToData.forEach(function (data, node) {
    if (data.expirationTime < now) {
      nodeToData.delete(node);
    } else {
      earliestExpiration = Math.min(earliestExpiration, data.expirationTime);
    }
  });
  draw(nodeToData);

  if (earliestExpiration !== Number.MAX_VALUE) {
    redrawTimeoutID = setTimeout(prepareToDraw, earliestExpiration - now);
  }
}

function measureNode(node) {
  if (!node || typeof node.getBoundingClientRect !== 'function') {
    return null;
  }

  var currentWindow = window.__REACT_DEVTOOLS_TARGET_WINDOW__ || window;
  return getNestedBoundingClientRect(node, currentWindow);
}
// EXTERNAL MODULE: ../react-devtools-shared/node_modules/semver/semver.js
var semver = __webpack_require__(2);

// CONCATENATED MODULE: ../react-devtools-shared/src/types.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new element types are added, use new numbers rather than re-ordering existing ones.
//
// Changing these types is also a backwards breaking change for the standalone shell,
// since the frontend and backend must share the same values-
// and the backend is embedded in certain environments (like React Native).
var ElementTypeClass = 1;
var ElementTypeContext = 2;
var ElementTypeFunction = 5;
var ElementTypeForwardRef = 6;
var ElementTypeHostComponent = 7;
var ElementTypeMemo = 8;
var ElementTypeOtherOrUnknown = 9;
var ElementTypeProfiler = 10;
var ElementTypeRoot = 11;
var ElementTypeSuspense = 12;
var ElementTypeSuspenseList = 13; // Different types of elements displayed in the Elements tree.
// These types may be used to visually distinguish types,
// or to enable/disable certain functionality.

// WARNING
// The values below are referenced by ComponentFilters (which are saved via localStorage).
// Do not change them or it will break previously saved user customizations.
// If new filter types are added, use new numbers rather than re-ordering existing ones.
var ComponentFilterElementType = 1;
var ComponentFilterDisplayName = 2;
var ComponentFilterLocation = 3;
var ComponentFilterHOC = 4;
// EXTERNAL MODULE: /Users/luna/code/react/node_modules/lru-cache/index.js
var lru_cache = __webpack_require__(6);
var lru_cache_default = /*#__PURE__*/__webpack_require__.n(lru_cache);

// EXTERNAL MODULE: /Users/luna/code/react/build/node_modules/react-is/index.js
var react_is = __webpack_require__(0);

// CONCATENATED MODULE: ../shared/ReactSymbols.js
function ReactSymbols_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { ReactSymbols_typeof = function _typeof(obj) { return typeof obj; }; } else { ReactSymbols_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return ReactSymbols_typeof(obj); }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// ATTENTION
// When adding new symbols to this file,
// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE = 0xeac7;
var REACT_PORTAL_TYPE = 0xeaca;
var REACT_FRAGMENT_TYPE = 0xeacb;
var REACT_STRICT_MODE_TYPE = 0xeacc;
var REACT_PROFILER_TYPE = 0xead2;
var REACT_PROVIDER_TYPE = 0xeacd;
var REACT_CONTEXT_TYPE = 0xeace;
var REACT_FORWARD_REF_TYPE = 0xead0;
var REACT_SUSPENSE_TYPE = 0xead1;
var REACT_SUSPENSE_LIST_TYPE = 0xead8;
var REACT_MEMO_TYPE = 0xead3;
var REACT_LAZY_TYPE = 0xead4;
var REACT_SCOPE_TYPE = 0xead7;
var REACT_OPAQUE_ID_TYPE = 0xeae0;
var REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;
var REACT_OFFSCREEN_TYPE = 0xeae2;
var REACT_LEGACY_HIDDEN_TYPE = 0xeae3;
var REACT_CACHE_TYPE = 0xeae4;

if (typeof Symbol === 'function' && Symbol.for) {
  var symbolFor = Symbol.for;
  REACT_ELEMENT_TYPE = symbolFor('react.element');
  REACT_PORTAL_TYPE = symbolFor('react.portal');
  REACT_FRAGMENT_TYPE = symbolFor('react.fragment');
  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');
  REACT_PROFILER_TYPE = symbolFor('react.profiler');
  REACT_PROVIDER_TYPE = symbolFor('react.provider');
  REACT_CONTEXT_TYPE = symbolFor('react.context');
  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');
  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');
  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');
  REACT_MEMO_TYPE = symbolFor('react.memo');
  REACT_LAZY_TYPE = symbolFor('react.lazy');
  REACT_SCOPE_TYPE = symbolFor('react.scope');
  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');
  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');
  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');
  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');
  REACT_CACHE_TYPE = symbolFor('react.cache');
}

var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator';
function getIteratorFn(maybeIterable) {
  if (maybeIterable === null || ReactSymbols_typeof(maybeIterable) !== 'object') {
    return null;
  }

  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

  if (typeof maybeIterator === 'function') {
    return maybeIterator;
  }

  return null;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/hydration.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { hydration_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function hydration_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var meta = {
  inspectable: Symbol('inspectable'),
  inspected: Symbol('inspected'),
  name: Symbol('name'),
  preview_long: Symbol('preview_long'),
  preview_short: Symbol('preview_short'),
  readonly: Symbol('readonly'),
  size: Symbol('size'),
  type: Symbol('type'),
  unserializable: Symbol('unserializable')
};
// This threshold determines the depth at which the bridge "dehydrates" nested data.
// Dehydration means that we don't serialize the data for e.g. postMessage or stringify,
// unless the frontend explicitly requests it (e.g. a user clicks to expand a props object).
//
// Reducing this threshold will improve the speed of initial component inspection,
// but may decrease the responsiveness of expanding objects/arrays to inspect further.
var LEVEL_THRESHOLD = 2;
/**
 * Generate the dehydrated metadata for complex object instances
 */

function createDehydrated(type, inspectable, data, cleaned, path) {
  cleaned.push(path);
  var dehydrated = {
    inspectable: inspectable,
    type: type,
    preview_long: formatDataForPreview(data, true),
    preview_short: formatDataForPreview(data, false),
    name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
  };

  if (type === 'array' || type === 'typed_array') {
    dehydrated.size = data.length;
  } else if (type === 'object') {
    dehydrated.size = Object.keys(data).length;
  }

  if (type === 'iterator' || type === 'typed_array') {
    dehydrated.readonly = true;
  }

  return dehydrated;
}
/**
 * Strip out complex data (instances, functions, and data nested > LEVEL_THRESHOLD levels deep).
 * The paths of the stripped out objects are appended to the `cleaned` list.
 * On the other side of the barrier, the cleaned list is used to "re-hydrate" the cleaned representation into
 * an object with symbols as attributes, so that a sanitized object can be distinguished from a normal object.
 *
 * Input: {"some": {"attr": fn()}, "other": AnInstance}
 * Output: {
 *   "some": {
 *     "attr": {"name": the fn.name, type: "function"}
 *   },
 *   "other": {
 *     "name": "AnInstance",
 *     "type": "object",
 *   },
 * }
 * and cleaned = [["some", "attr"], ["other"]]
 */


function dehydrate(data, cleaned, unserializable, path, isPathAllowed) {
  var level = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
  var type = getDataType(data);
  var isPathAllowedCheck;

  switch (type) {
    case 'html_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: data.tagName,
        type: type
      };

    case 'function':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: typeof data.name === 'function' || !data.name ? 'function' : data.name,
        type: type
      };

    case 'string':
      isPathAllowedCheck = isPathAllowed(path);

      if (isPathAllowedCheck) {
        return data;
      } else {
        return data.length <= 500 ? data : data.slice(0, 500) + '...';
      }

    case 'bigint':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: data.toString(),
        type: type
      };

    case 'symbol':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: data.toString(),
        type: type
      };
    // React Elements aren't very inspector-friendly,
    // and often contain private fields or circular references.

    case 'react_element':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: getDisplayNameForReactElement(data) || 'Unknown',
        type: type
      };
    // ArrayBuffers error if you try to inspect them.

    case 'array_buffer':
    case 'data_view':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: type === 'data_view' ? 'DataView' : 'ArrayBuffer',
        size: data.byteLength,
        type: type
      };

    case 'array':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      }

      return data.map(function (item, i) {
        return dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
      });

    case 'html_all_collection':
    case 'typed_array':
    case 'iterator':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        var unserializableValue = {
          unserializable: true,
          type: type,
          readonly: true,
          size: type === 'typed_array' ? data.length : undefined,
          preview_short: formatDataForPreview(data, false),
          preview_long: formatDataForPreview(data, true),
          name: !data.constructor || data.constructor.name === 'Object' ? '' : data.constructor.name
        }; // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.

        Array.from(data).forEach(function (item, i) {
          return unserializableValue[i] = dehydrate(item, cleaned, unserializable, path.concat([i]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        unserializable.push(path);
        return unserializableValue;
      }

    case 'opaque_iterator':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: data[Symbol.toStringTag],
        type: type
      };

    case 'date':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: data.toString(),
        type: type
      };

    case 'regexp':
      cleaned.push(path);
      return {
        inspectable: false,
        preview_short: formatDataForPreview(data, false),
        preview_long: formatDataForPreview(data, true),
        name: data.toString(),
        type: type
      };

    case 'object':
      isPathAllowedCheck = isPathAllowed(path);

      if (level >= LEVEL_THRESHOLD && !isPathAllowedCheck) {
        return createDehydrated(type, true, data, cleaned, path);
      } else {
        var object = {};
        getAllEnumerableKeys(data).forEach(function (key) {
          var name = key.toString();
          object[name] = dehydrate(data[key], cleaned, unserializable, path.concat([name]), isPathAllowed, isPathAllowedCheck ? 1 : level + 1);
        });
        return object;
      }

    case 'infinity':
    case 'nan':
    case 'undefined':
      // Some values are lossy when sent through a WebSocket.
      // We dehydrate+rehydrate them to preserve their type.
      cleaned.push(path);
      return {
        type: type
      };

    default:
      return data;
  }
}
function fillInPath(object, data, path, value) {
  var target = getInObject(object, path);

  if (target != null) {
    if (!target[meta.unserializable]) {
      delete target[meta.inspectable];
      delete target[meta.inspected];
      delete target[meta.name];
      delete target[meta.preview_long];
      delete target[meta.preview_short];
      delete target[meta.readonly];
      delete target[meta.size];
      delete target[meta.type];
    }
  }

  if (value !== null && data.unserializable.length > 0) {
    var unserializablePath = data.unserializable[0];
    var isMatch = unserializablePath.length === path.length;

    for (var i = 0; i < path.length; i++) {
      if (path[i] !== unserializablePath[i]) {
        isMatch = false;
        break;
      }
    }

    if (isMatch) {
      upgradeUnserializable(value, value);
    }
  }

  setInObject(object, path, value);
}
function hydrate(object, cleaned, unserializable) {
  cleaned.forEach(function (path) {
    var length = path.length;
    var last = path[length - 1];
    var parent = getInObject(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    var value = parent[last];

    if (!value) {
      return;
    } else if (value.type === 'infinity') {
      parent[last] = Infinity;
    } else if (value.type === 'nan') {
      parent[last] = NaN;
    } else if (value.type === 'undefined') {
      parent[last] = undefined;
    } else {
      // Replace the string keys with Symbols so they're non-enumerable.
      var replaced = {};
      replaced[meta.inspectable] = !!value.inspectable;
      replaced[meta.inspected] = false;
      replaced[meta.name] = value.name;
      replaced[meta.preview_long] = value.preview_long;
      replaced[meta.preview_short] = value.preview_short;
      replaced[meta.size] = value.size;
      replaced[meta.readonly] = !!value.readonly;
      replaced[meta.type] = value.type;
      parent[last] = replaced;
    }
  });
  unserializable.forEach(function (path) {
    var length = path.length;
    var last = path[length - 1];
    var parent = getInObject(object, path.slice(0, length - 1));

    if (!parent || !parent.hasOwnProperty(last)) {
      return;
    }

    var node = parent[last];

    var replacement = _objectSpread({}, node);

    upgradeUnserializable(replacement, node);
    parent[last] = replacement;
  });
  return object;
}

function upgradeUnserializable(destination, source) {
  var _Object$definePropert;

  Object.defineProperties(destination, (_Object$definePropert = {}, hydration_defineProperty(_Object$definePropert, meta.inspected, {
    configurable: true,
    enumerable: false,
    value: !!source.inspected
  }), hydration_defineProperty(_Object$definePropert, meta.name, {
    configurable: true,
    enumerable: false,
    value: source.name
  }), hydration_defineProperty(_Object$definePropert, meta.preview_long, {
    configurable: true,
    enumerable: false,
    value: source.preview_long
  }), hydration_defineProperty(_Object$definePropert, meta.preview_short, {
    configurable: true,
    enumerable: false,
    value: source.preview_short
  }), hydration_defineProperty(_Object$definePropert, meta.size, {
    configurable: true,
    enumerable: false,
    value: source.size
  }), hydration_defineProperty(_Object$definePropert, meta.readonly, {
    configurable: true,
    enumerable: false,
    value: !!source.readonly
  }), hydration_defineProperty(_Object$definePropert, meta.type, {
    configurable: true,
    enumerable: false,
    value: source.type
  }), hydration_defineProperty(_Object$definePropert, meta.unserializable, {
    configurable: true,
    enumerable: false,
    value: !!source.unserializable
  }), _Object$definePropert));
  delete destination.inspected;
  delete destination.name;
  delete destination.preview_long;
  delete destination.preview_short;
  delete destination.size;
  delete destination.readonly;
  delete destination.type;
  delete destination.unserializable;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/utils.js
function utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { utils_typeof = function _typeof(obj) { return typeof obj; }; } else { utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return utils_typeof(obj); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || utils_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function utils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return utils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return utils_arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return utils_arrayLikeToArray(arr); }

function utils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










var cachedDisplayNames = new WeakMap(); // On large trees, encoding takes significant time.
// Try to reuse the already encoded strings.

var encodedStringCache = new lru_cache_default.a({
  max: 1000
});
function alphaSortKeys(a, b) {
  if (a.toString() > b.toString()) {
    return 1;
  } else if (b.toString() > a.toString()) {
    return -1;
  } else {
    return 0;
  }
}
function getAllEnumerableKeys(obj) {
  var keys = new Set();
  var current = obj;

  var _loop = function _loop() {
    var currentKeys = [].concat(_toConsumableArray(Object.keys(current)), _toConsumableArray(Object.getOwnPropertySymbols(current)));
    var descriptors = Object.getOwnPropertyDescriptors(current);
    currentKeys.forEach(function (key) {
      // $FlowFixMe: key can be a Symbol https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor
      if (descriptors[key].enumerable) {
        keys.add(key);
      }
    });
    current = Object.getPrototypeOf(current);
  };

  while (current != null) {
    _loop();
  }

  return keys;
}
function getDisplayName(type) {
  var fallbackName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'Anonymous';
  var nameFromCache = cachedDisplayNames.get(type);

  if (nameFromCache != null) {
    return nameFromCache;
  }

  var displayName = fallbackName; // The displayName property is not guaranteed to be a string.
  // It's only safe to use for our purposes if it's a string.
  // github.com/facebook/react-devtools/issues/803

  if (typeof type.displayName === 'string') {
    displayName = type.displayName;
  } else if (typeof type.name === 'string' && type.name !== '') {
    displayName = type.name;
  }

  cachedDisplayNames.set(type, displayName);
  return displayName;
}
var utils_uidCounter = 0;
function getUID() {
  return ++utils_uidCounter;
}
function utfDecodeString(array) {
  return String.fromCodePoint.apply(String, _toConsumableArray(array));
}
function utfEncodeString(string) {
  var cached = encodedStringCache.get(string);

  if (cached !== undefined) {
    return cached;
  }

  var encoded = new Array(string.length);

  for (var i = 0; i < string.length; i++) {
    encoded[i] = string.codePointAt(i);
  }

  encodedStringCache.set(string, encoded);
  return encoded;
}
function printOperationsArray(operations) {
  // The first two values are always rendererID and rootID
  var rendererID = operations[0];
  var rootID = operations[1];
  var logs = ["operations for renderer:".concat(rendererID, " and root:").concat(rootID)];
  var i = 2; // Reassemble the string table.

  var stringTable = [null // ID = 0 corresponds to the null string.
  ];
  var stringTableSize = operations[i++];
  var stringTableEnd = i + stringTableSize;

  while (i < stringTableEnd) {
    var nextLength = operations[i++];
    var nextString = utfDecodeString(operations.slice(i, i + nextLength));
    stringTable.push(nextString);
    i += nextLength;
  }

  while (i < operations.length) {
    var operation = operations[i];

    switch (operation) {
      case TREE_OPERATION_ADD:
        {
          var _id = operations[i + 1];
          var type = operations[i + 2];
          i += 3;

          if (type === ElementTypeRoot) {
            logs.push("Add new root node ".concat(_id));
            i++; // supportsProfiling

            i++; // hasOwnerMetadata
          } else {
            var parentID = operations[i];
            i++;
            i++; // ownerID

            var displayNameStringID = operations[i];
            var displayName = stringTable[displayNameStringID];
            i++;
            i++; // key

            logs.push("Add node ".concat(_id, " (").concat(displayName || 'null', ") as child of ").concat(parentID));
          }

          break;
        }

      case TREE_OPERATION_REMOVE:
        {
          var removeLength = operations[i + 1];
          i += 2;

          for (var removeIndex = 0; removeIndex < removeLength; removeIndex++) {
            var _id2 = operations[i];
            i += 1;
            logs.push("Remove node ".concat(_id2));
          }

          break;
        }

      case TREE_OPERATION_REMOVE_ROOT:
        {
          i += 1;
          logs.push("Remove root ".concat(rootID));
          break;
        }

      case TREE_OPERATION_REORDER_CHILDREN:
        {
          var _id3 = operations[i + 1];
          var numChildren = operations[i + 2];
          i += 3;
          var children = operations.slice(i, i + numChildren);
          i += numChildren;
          logs.push("Re-order node ".concat(_id3, " children ").concat(children.join(',')));
          break;
        }

      case TREE_OPERATION_UPDATE_TREE_BASE_DURATION:
        // Base duration updates are only sent while profiling is in progress.
        // We can ignore them at this point.
        // The profiler UI uses them lazily in order to generate the tree.
        i += 3;
        break;

      case TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS:
        var id = operations[i + 1];
        var numErrors = operations[i + 2];
        var numWarnings = operations[i + 3];
        i += 4;
        logs.push("Node ".concat(id, " has ").concat(numErrors, " errors and ").concat(numWarnings, " warnings"));
        break;

      default:
        throw Error("Unsupported Bridge operation \"".concat(operation, "\""));
    }
  }

  console.log(logs.join('\n  '));
}
function getDefaultComponentFilters() {
  return [{
    type: ComponentFilterElementType,
    value: ElementTypeHostComponent,
    isEnabled: true
  }];
}
function getSavedComponentFilters() {
  try {
    var raw = localStorageGetItem(LOCAL_STORAGE_FILTER_PREFERENCES_KEY);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return getDefaultComponentFilters();
}
function saveComponentFilters(componentFilters) {
  localStorageSetItem(LOCAL_STORAGE_FILTER_PREFERENCES_KEY, JSON.stringify(componentFilters));
}
function getAppendComponentStack() {
  try {
    var raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return true;
}
function setAppendComponentStack(value) {
  localStorageSetItem(LOCAL_STORAGE_SHOULD_PATCH_CONSOLE_KEY, JSON.stringify(value));
}
function getBreakOnConsoleErrors() {
  try {
    var raw = localStorageGetItem(LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return false;
}
function setBreakOnConsoleErrors(value) {
  localStorageSetItem(LOCAL_STORAGE_SHOULD_BREAK_ON_CONSOLE_ERRORS, JSON.stringify(value));
}
function getShowInlineWarningsAndErrors() {
  try {
    var raw = localStorageGetItem(LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY);

    if (raw != null) {
      return JSON.parse(raw);
    }
  } catch (error) {}

  return true;
}
function setShowInlineWarningsAndErrors(value) {
  localStorageSetItem(LOCAL_STORAGE_SHOW_INLINE_WARNINGS_AND_ERRORS_KEY, JSON.stringify(value));
}
function separateDisplayNameAndHOCs(displayName, type) {
  if (displayName === null) {
    return [null, null];
  }

  var hocDisplayNames = null;

  switch (type) {
    case ElementTypeClass:
    case ElementTypeForwardRef:
    case ElementTypeFunction:
    case ElementTypeMemo:
      if (displayName.indexOf('(') >= 0) {
        var matches = displayName.match(/[^()]+/g);

        if (matches != null) {
          displayName = matches.pop();
          hocDisplayNames = matches;
        }
      }

      break;

    default:
      break;
  }

  if (type === ElementTypeMemo) {
    if (hocDisplayNames === null) {
      hocDisplayNames = ['Memo'];
    } else {
      hocDisplayNames.unshift('Memo');
    }
  } else if (type === ElementTypeForwardRef) {
    if (hocDisplayNames === null) {
      hocDisplayNames = ['ForwardRef'];
    } else {
      hocDisplayNames.unshift('ForwardRef');
    }
  }

  return [displayName, hocDisplayNames];
} // Pulled from react-compat
// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349

function shallowDiffers(prev, next) {
  for (var attribute in prev) {
    if (!(attribute in next)) {
      return true;
    }
  }

  for (var _attribute in next) {
    if (prev[_attribute] !== next[_attribute]) {
      return true;
    }
  }

  return false;
}
function getInObject(object, path) {
  return path.reduce(function (reduced, attr) {
    if (reduced) {
      if (hasOwnProperty.call(reduced, attr)) {
        return reduced[attr];
      }

      if (typeof reduced[Symbol.iterator] === 'function') {
        // Convert iterable to array and return array[index]
        //
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        return Array.from(reduced)[attr];
      }
    }

    return null;
  }, object);
}
function deletePathInObject(object, path) {
  var length = path.length;
  var last = path[length - 1];

  if (object != null) {
    var parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      if (Array.isArray(parent)) {
        parent.splice(last, 1);
      } else {
        delete parent[last];
      }
    }
  }
}
function renamePathInObject(object, oldPath, newPath) {
  var length = oldPath.length;

  if (object != null) {
    var parent = getInObject(object, oldPath.slice(0, length - 1));

    if (parent) {
      var lastOld = oldPath[length - 1];
      var lastNew = newPath[length - 1];
      parent[lastNew] = parent[lastOld];

      if (Array.isArray(parent)) {
        parent.splice(lastOld, 1);
      } else {
        delete parent[lastOld];
      }
    }
  }
}
function setInObject(object, path, value) {
  var length = path.length;
  var last = path[length - 1];

  if (object != null) {
    var parent = getInObject(object, path.slice(0, length - 1));

    if (parent) {
      parent[last] = value;
    }
  }
}

/**
 * Get a enhanced/artificial type string based on the object instance
 */
function getDataType(data) {
  if (data === null) {
    return 'null';
  } else if (data === undefined) {
    return 'undefined';
  }

  if (Object(react_is["isElement"])(data)) {
    return 'react_element';
  }

  if (typeof HTMLElement !== 'undefined' && data instanceof HTMLElement) {
    return 'html_element';
  }

  var type = utils_typeof(data);

  switch (type) {
    case 'bigint':
      return 'bigint';

    case 'boolean':
      return 'boolean';

    case 'function':
      return 'function';

    case 'number':
      if (Number.isNaN(data)) {
        return 'nan';
      } else if (!Number.isFinite(data)) {
        return 'infinity';
      } else {
        return 'number';
      }

    case 'object':
      if (Array.isArray(data)) {
        return 'array';
      } else if (ArrayBuffer.isView(data)) {
        return hasOwnProperty.call(data.constructor, 'BYTES_PER_ELEMENT') ? 'typed_array' : 'data_view';
      } else if (data.constructor && data.constructor.name === 'ArrayBuffer') {
        // HACK This ArrayBuffer check is gross; is there a better way?
        // We could try to create a new DataView with the value.
        // If it doesn't error, we know it's an ArrayBuffer,
        // but this seems kind of awkward and expensive.
        return 'array_buffer';
      } else if (typeof data[Symbol.iterator] === 'function') {
        var iterator = data[Symbol.iterator]();

        if (!iterator) {// Proxies might break assumptoins about iterators.
          // See github.com/facebook/react/issues/21654
        } else {
          return iterator === data ? 'opaque_iterator' : 'iterator';
        }
      } else if (data.constructor && data.constructor.name === 'RegExp') {
        return 'regexp';
      } else {
        var toStringValue = Object.prototype.toString.call(data);

        if (toStringValue === '[object Date]') {
          return 'date';
        } else if (toStringValue === '[object HTMLAllCollection]') {
          return 'html_all_collection';
        }
      }

      return 'object';

    case 'string':
      return 'string';

    case 'symbol':
      return 'symbol';

    case 'undefined':
      if (Object.prototype.toString.call(data) === '[object HTMLAllCollection]') {
        return 'html_all_collection';
      }

      return 'undefined';

    default:
      return 'unknown';
  }
}
function getDisplayNameForReactElement(element) {
  var elementType = Object(react_is["typeOf"])(element);

  switch (elementType) {
    case react_is["ContextConsumer"]:
      return 'ContextConsumer';

    case react_is["ContextProvider"]:
      return 'ContextProvider';

    case react_is["ForwardRef"]:
      return 'ForwardRef';

    case react_is["Fragment"]:
      return 'Fragment';

    case react_is["Lazy"]:
      return 'Lazy';

    case react_is["Memo"]:
      return 'Memo';

    case react_is["Portal"]:
      return 'Portal';

    case react_is["Profiler"]:
      return 'Profiler';

    case react_is["StrictMode"]:
      return 'StrictMode';

    case react_is["Suspense"]:
      return 'Suspense';

    case REACT_SUSPENSE_LIST_TYPE:
      return 'SuspenseList';

    default:
      var type = element.type;

      if (typeof type === 'string') {
        return type;
      } else if (typeof type === 'function') {
        return getDisplayName(type, 'Anonymous');
      } else if (type != null) {
        return 'NotImplementedInDevtools';
      } else {
        return 'Element';
      }

  }
}
var MAX_PREVIEW_STRING_LENGTH = 50;

function truncateForDisplay(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : MAX_PREVIEW_STRING_LENGTH;

  if (string.length > length) {
    return string.substr(0, length) + '';
  } else {
    return string;
  }
} // Attempts to mimic Chrome's inline preview for values.
// For example, the following value...
//   {
//      foo: 123,
//      bar: "abc",
//      baz: [true, false],
//      qux: { ab: 1, cd: 2 }
//   };
//
// Would show a preview of...
//   {foo: 123, bar: "abc", baz: Array(2), qux: {}}
//
// And the following value...
//   [
//     123,
//     "abc",
//     [true, false],
//     { foo: 123, bar: "abc" }
//   ];
//
// Would show a preview of...
//   [123, "abc", Array(2), {}]


function formatDataForPreview(data, showFormattedValue) {
  if (data != null && hasOwnProperty.call(data, meta.type)) {
    return showFormattedValue ? data[meta.preview_long] : data[meta.preview_short];
  }

  var type = getDataType(data);

  switch (type) {
    case 'html_element':
      return "<".concat(truncateForDisplay(data.tagName.toLowerCase()), " />");

    case 'function':
      return truncateForDisplay("\u0192 ".concat(typeof data.name === 'function' ? '' : data.name, "() {}"));

    case 'string':
      return "\"".concat(data, "\"");

    case 'bigint':
      return truncateForDisplay(data.toString() + 'n');

    case 'regexp':
      return truncateForDisplay(data.toString());

    case 'symbol':
      return truncateForDisplay(data.toString());

    case 'react_element':
      return "<".concat(truncateForDisplay(getDisplayNameForReactElement(data) || 'Unknown'), " />");

    case 'array_buffer':
      return "ArrayBuffer(".concat(data.byteLength, ")");

    case 'data_view':
      return "DataView(".concat(data.buffer.byteLength, ")");

    case 'array':
      if (showFormattedValue) {
        var formatted = '';

        for (var i = 0; i < data.length; i++) {
          if (i > 0) {
            formatted += ', ';
          }

          formatted += formatDataForPreview(data[i], false);

          if (formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "[".concat(truncateForDisplay(formatted), "]");
      } else {
        var length = hasOwnProperty.call(data, meta.size) ? data[meta.size] : data.length;
        return "Array(".concat(length, ")");
      }

    case 'typed_array':
      var shortName = "".concat(data.constructor.name, "(").concat(data.length, ")");

      if (showFormattedValue) {
        var _formatted = '';

        for (var _i = 0; _i < data.length; _i++) {
          if (_i > 0) {
            _formatted += ', ';
          }

          _formatted += data[_i];

          if (_formatted.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "".concat(shortName, " [").concat(truncateForDisplay(_formatted), "]");
      } else {
        return shortName;
      }

    case 'iterator':
      var name = data.constructor.name;

      if (showFormattedValue) {
        // TRICKY
        // Don't use [...spread] syntax for this purpose.
        // This project uses @babel/plugin-transform-spread in "loose" mode which only works with Array values.
        // Other types (e.g. typed arrays, Sets) will not spread correctly.
        var array = Array.from(data);
        var _formatted2 = '';

        for (var _i2 = 0; _i2 < array.length; _i2++) {
          var entryOrEntries = array[_i2];

          if (_i2 > 0) {
            _formatted2 += ', ';
          } // TRICKY
          // Browsers display Maps and Sets differently.
          // To mimic their behavior, detect if we've been given an entries tuple.
          //   Map(2) {"abc" => 123, "def" => 123}
          //   Set(2) {"abc", 123}


          if (Array.isArray(entryOrEntries)) {
            var key = formatDataForPreview(entryOrEntries[0], true);
            var value = formatDataForPreview(entryOrEntries[1], false);
            _formatted2 += "".concat(key, " => ").concat(value);
          } else {
            _formatted2 += formatDataForPreview(entryOrEntries, false);
          }

          if (_formatted2.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "".concat(name, "(").concat(data.size, ") {").concat(truncateForDisplay(_formatted2), "}");
      } else {
        return "".concat(name, "(").concat(data.size, ")");
      }

    case 'opaque_iterator':
      {
        return data[Symbol.toStringTag];
      }

    case 'date':
      return data.toString();

    case 'object':
      if (showFormattedValue) {
        var keys = Array.from(getAllEnumerableKeys(data)).sort(alphaSortKeys);
        var _formatted3 = '';

        for (var _i3 = 0; _i3 < keys.length; _i3++) {
          var _key = keys[_i3];

          if (_i3 > 0) {
            _formatted3 += ', ';
          }

          _formatted3 += "".concat(_key.toString(), ": ").concat(formatDataForPreview(data[_key], false));

          if (_formatted3.length > MAX_PREVIEW_STRING_LENGTH) {
            // Prevent doing a lot of unnecessary iteration...
            break;
          }
        }

        return "{".concat(truncateForDisplay(_formatted3), "}");
      } else {
        return '{}';
      }

    case 'boolean':
    case 'number':
    case 'infinity':
    case 'nan':
    case 'null':
    case 'undefined':
      return data;

    default:
      try {
        return truncateForDisplay('' + data);
      } catch (error) {
        return 'unserializable';
      }

  }
}
// EXTERNAL MODULE: /Users/luna/code/react/node_modules/clipboard-js/clipboard.js
var clipboard = __webpack_require__(7);

// CONCATENATED MODULE: ../shared/isArray.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare

function isArray(a) {
  return isArrayImpl(a);
}

/* harmony default export */ var shared_isArray = (isArray);
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/utils.js
function backend_utils_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { backend_utils_typeof = function _typeof(obj) { return typeof obj; }; } else { backend_utils_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return backend_utils_typeof(obj); }

function utils_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function utils_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { utils_ownKeys(Object(source), true).forEach(function (key) { utils_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { utils_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function utils_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function cleanForBridge(data, isPathAllowed) {
  var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  if (data !== null) {
    var cleanedPaths = [];
    var unserializablePaths = [];
    var cleanedData = dehydrate(data, cleanedPaths, unserializablePaths, path, isPathAllowed);
    return {
      data: cleanedData,
      cleaned: cleanedPaths,
      unserializable: unserializablePaths
    };
  } else {
    return null;
  }
}
function copyToClipboard(value) {
  var safeToCopy = serializeToString(value);
  var text = safeToCopy === undefined ? 'undefined' : safeToCopy;
  var clipboardCopyText = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.clipboardCopyText; // On Firefox navigator.clipboard.writeText has to be called from
  // the content script js code (because it requires the clipboardWrite
  // permission to be allowed out of a "user handling" callback),
  // clipboardCopyText is an helper injected into the page from.
  // injectGlobalHook.

  if (typeof clipboardCopyText === 'function') {
    clipboardCopyText(text).catch(function (err) {});
  } else {
    Object(clipboard["copy"])(text);
  }
}
function copyWithDelete(obj, path) {
  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var key = path[index];
  var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);

  if (index + 1 === path.length) {
    if (shared_isArray(updated)) {
      updated.splice(key, 1);
    } else {
      delete updated[key];
    }
  } else {
    // $FlowFixMe number or string is fine here
    updated[key] = copyWithDelete(obj[key], path, index + 1);
  }

  return updated;
} // This function expects paths to be the same except for the final value.
// e.g. ['path', 'to', 'foo'] and ['path', 'to', 'bar']

function copyWithRename(obj, oldPath, newPath) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  var oldKey = oldPath[index];
  var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj);

  if (index + 1 === oldPath.length) {
    var newKey = newPath[index]; // $FlowFixMe number or string is fine here

    updated[newKey] = updated[oldKey];

    if (shared_isArray(updated)) {
      updated.splice(oldKey, 1);
    } else {
      delete updated[oldKey];
    }
  } else {
    // $FlowFixMe number or string is fine here
    updated[oldKey] = copyWithRename(obj[oldKey], oldPath, newPath, index + 1);
  }

  return updated;
}
function copyWithSet(obj, path, value) {
  var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

  if (index >= path.length) {
    return value;
  }

  var key = path[index];
  var updated = shared_isArray(obj) ? obj.slice() : utils_objectSpread({}, obj); // $FlowFixMe number or string is fine here

  updated[key] = copyWithSet(obj[key], path, value, index + 1);
  return updated;
}
function getEffectDurations(root) {
  // Profiling durations are only available for certain builds.
  // If available, they'll be stored on the HostRoot.
  var effectDuration = null;
  var passiveEffectDuration = null;
  var hostRoot = root.current;

  if (hostRoot != null) {
    var stateNode = hostRoot.stateNode;

    if (stateNode != null) {
      effectDuration = stateNode.effectDuration != null ? stateNode.effectDuration : null;
      passiveEffectDuration = stateNode.passiveEffectDuration != null ? stateNode.passiveEffectDuration : null;
    }
  }

  return {
    effectDuration: effectDuration,
    passiveEffectDuration: passiveEffectDuration
  };
}
function serializeToString(data) {
  var cache = new Set(); // Use a custom replacer function to protect against circular references.

  return JSON.stringify(data, function (key, value) {
    if (backend_utils_typeof(value) === 'object' && value !== null) {
      if (cache.has(value)) {
        return;
      }

      cache.add(value);
    } // $FlowFixMe


    if (typeof value === 'bigint') {
      return value.toString() + 'n';
    }

    return value;
  });
} // based on https://github.com/tmpfs/format-util/blob/0e62d430efb0a1c51448709abd3e2406c14d8401/format.js#L1
// based on https://developer.mozilla.org/en-US/docs/Web/API/console#Using_string_substitutions
// Implements s, d, i and f placeholders

function format(maybeMessage) {
  for (var _len = arguments.length, inputArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    inputArgs[_key - 1] = arguments[_key];
  }

  var args = inputArgs.slice(); // Symbols cannot be concatenated with Strings.

  var formatted = backend_utils_typeof(maybeMessage) === 'symbol' ? maybeMessage.toString() : '' + maybeMessage; // If the first argument is a string, check for substitutions.

  if (typeof maybeMessage === 'string') {
    if (args.length) {
      var REGEXP = /(%?)(%([jds]))/g;
      formatted = formatted.replace(REGEXP, function (match, escaped, ptn, flag) {
        var arg = args.shift();

        switch (flag) {
          case 's':
            arg += '';
            break;

          case 'd':
          case 'i':
            arg = parseInt(arg, 10).toString();
            break;

          case 'f':
            arg = parseFloat(arg).toString();
            break;
        }

        if (!escaped) {
          return arg;
        }

        args.unshift(arg);
        return match;
      });
    }
  } // Arguments that remain after formatting.


  if (args.length) {
    for (var i = 0; i < args.length; i++) {
      var arg = args[i]; // Symbols cannot be concatenated with Strings.

      formatted += ' ' + (backend_utils_typeof(arg) === 'symbol' ? arg.toString() : arg);
    }
  } // Update escaped %% values.


  formatted = formatted.replace(/%{2,2}/g, '%');
  return '' + formatted;
}
function isSynchronousXHRSupported() {
  return !!(window.document && window.document.featurePolicy && window.document.featurePolicy.allowsFeature('sync-xhr'));
}
// EXTERNAL MODULE: /Users/luna/code/react/build/node_modules/react-debug-tools/index.js
var react_debug_tools = __webpack_require__(8);

// CONCATENATED MODULE: ../react-devtools-shared/src/backend/ReactSymbols.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This list should be kept updated to reflect additions to 'shared/ReactSymbols'.
// DevTools can't import symbols from 'shared/ReactSymbols' directly for two reasons:
// 1. DevTools requires symbols which may have been deleted in more recent versions (e.g. concurrent mode)
// 2. DevTools must support both Symbol and numeric forms of each symbol;
//    Since e.g. standalone DevTools runs in a separate process, it can't rely on its own ES capabilities.
var CONCURRENT_MODE_NUMBER = 0xeacf;
var CONCURRENT_MODE_SYMBOL_STRING = 'Symbol(react.concurrent_mode)';
var CONTEXT_NUMBER = 0xeace;
var CONTEXT_SYMBOL_STRING = 'Symbol(react.context)';
var DEPRECATED_ASYNC_MODE_SYMBOL_STRING = 'Symbol(react.async_mode)';
var ELEMENT_NUMBER = 0xeac7;
var ELEMENT_SYMBOL_STRING = 'Symbol(react.element)';
var DEBUG_TRACING_MODE_NUMBER = 0xeae1;
var DEBUG_TRACING_MODE_SYMBOL_STRING = 'Symbol(react.debug_trace_mode)';
var FORWARD_REF_NUMBER = 0xead0;
var FORWARD_REF_SYMBOL_STRING = 'Symbol(react.forward_ref)';
var FRAGMENT_NUMBER = 0xeacb;
var FRAGMENT_SYMBOL_STRING = 'Symbol(react.fragment)';
var LAZY_NUMBER = 0xead4;
var LAZY_SYMBOL_STRING = 'Symbol(react.lazy)';
var MEMO_NUMBER = 0xead3;
var MEMO_SYMBOL_STRING = 'Symbol(react.memo)';
var OPAQUE_ID_NUMBER = 0xeae0;
var OPAQUE_ID_SYMBOL_STRING = 'Symbol(react.opaque.id)';
var PORTAL_NUMBER = 0xeaca;
var PORTAL_SYMBOL_STRING = 'Symbol(react.portal)';
var PROFILER_NUMBER = 0xead2;
var PROFILER_SYMBOL_STRING = 'Symbol(react.profiler)';
var PROVIDER_NUMBER = 0xeacd;
var PROVIDER_SYMBOL_STRING = 'Symbol(react.provider)';
var SCOPE_NUMBER = 0xead7;
var SCOPE_SYMBOL_STRING = 'Symbol(react.scope)';
var STRICT_MODE_NUMBER = 0xeacc;
var STRICT_MODE_SYMBOL_STRING = 'Symbol(react.strict_mode)';
var SUSPENSE_NUMBER = 0xead1;
var SUSPENSE_SYMBOL_STRING = 'Symbol(react.suspense)';
var SUSPENSE_LIST_NUMBER = 0xead8;
var SUSPENSE_LIST_SYMBOL_STRING = 'Symbol(react.suspense_list)';
// CONCATENATED MODULE: ../react-devtools-shared/src/config/DevToolsFeatureFlags.default.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/************************************************************************
 * This file is forked between different DevTools implementations.
 * It should never be imported directly!
 * It should always be imported from "react-devtools-feature-flags".
 ************************************************************************/
var enableProfilerChangedHookIndices = false;
var isInternalFacebookBuild = false;
// CONCATENATED MODULE: ../shared/objectIs.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  ;
}

var objectIs = typeof Object.is === 'function' ? Object.is : is;
/* harmony default export */ var shared_objectIs = (objectIs);
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/renderer.js
function renderer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function renderer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { renderer_ownKeys(Object(source), true).forEach(function (key) { renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { renderer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || renderer_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function renderer_toConsumableArray(arr) { return renderer_arrayWithoutHoles(arr) || renderer_iterableToArray(arr) || renderer_unsupportedIterableToArray(arr) || renderer_nonIterableSpread(); }

function renderer_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function renderer_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function renderer_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return renderer_arrayLikeToArray(arr); }

function renderer_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = renderer_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function renderer_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return renderer_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return renderer_arrayLikeToArray(o, minLen); }

function renderer_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function renderer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return renderer_typeof(obj); }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */














function getFiberFlags(fiber) {
  // The name of this field changed from "effectTag" to "flags"
  return fiber.flags !== undefined ? fiber.flags : fiber.effectTag;
} // Some environments (e.g. React Native / Hermes) don't support the performance API yet.


var renderer_getCurrentTime = (typeof performance === "undefined" ? "undefined" : renderer_typeof(performance)) === 'object' && typeof performance.now === 'function' ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
function getInternalReactConstants(version) {
  var ReactTypeOfSideEffect = {
    DidCapture: 128,
    NoFlags: 0,
    PerformedWork: 1,
    Placement: 2,
    Incomplete: 8192
  }; // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // Technically these priority levels are invalid for versions before 16.9,
  // but 16.9 is the first version to report priority level to DevTools,
  // so we can avoid checking for earlier versions and support pre-16.9 canary releases in the process.

  var ReactPriorityLevels = {
    ImmediatePriority: 99,
    UserBlockingPriority: 98,
    NormalPriority: 97,
    LowPriority: 96,
    IdlePriority: 95,
    NoPriority: 90
  };

  if (Object(semver["gt"])(version, '17.0.2')) {
    ReactPriorityLevels = {
      ImmediatePriority: 1,
      UserBlockingPriority: 2,
      NormalPriority: 3,
      LowPriority: 4,
      IdlePriority: 5,
      NoPriority: 0
    };
  }

  var ReactTypeOfWork = null; // **********************************************************
  // The section below is copied from files in React repo.
  // Keep it in sync, and add version guards if it changes.
  //
  // TODO Update the gt() check below to be gte() whichever the next version number is.
  // Currently the version in Git is 17.0.2 (but that version has not been/may not end up being released).

  if (Object(semver["gt"])(version, '17.0.1')) {
    ReactTypeOfWork = {
      CacheComponent: 24,
      // Experimental
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 23,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 22,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      YieldComponent: -1 // Removed

    };
  } else if (Object(semver["gte"])(version, '17.0.0-alpha')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: 24,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: 23,
      // Experimental
      Profiler: 12,
      ScopeComponent: 21,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      YieldComponent: -1 // Removed

    };
  } else if (Object(semver["gte"])(version, '16.6.0-beta.0')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 1,
      ContextConsumer: 9,
      ContextProvider: 10,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: 18,
      // Behind a flag
      ForwardRef: 11,
      Fragment: 7,
      FunctionComponent: 0,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: 17,
      IndeterminateComponent: 2,
      LazyComponent: 16,
      LegacyHiddenComponent: -1,
      MemoComponent: 14,
      Mode: 8,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 12,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: 15,
      SuspenseComponent: 13,
      SuspenseListComponent: 19,
      // Experimental
      YieldComponent: -1 // Removed

    };
  } else if (Object(semver["gte"])(version, '16.4.3-alpha')) {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 2,
      ContextConsumer: 11,
      ContextProvider: 12,
      CoroutineComponent: -1,
      // Removed
      CoroutineHandlerPhase: -1,
      // Removed
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 13,
      Fragment: 9,
      FunctionComponent: 0,
      HostComponent: 7,
      HostPortal: 6,
      HostRoot: 5,
      HostText: 8,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 4,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 10,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      YieldComponent: -1 // Removed

    };
  } else {
    ReactTypeOfWork = {
      CacheComponent: -1,
      // Doesn't exist yet
      ClassComponent: 2,
      ContextConsumer: 12,
      ContextProvider: 13,
      CoroutineComponent: 7,
      CoroutineHandlerPhase: 8,
      DehydratedSuspenseComponent: -1,
      // Doesn't exist yet
      ForwardRef: 14,
      Fragment: 10,
      FunctionComponent: 1,
      HostComponent: 5,
      HostPortal: 4,
      HostRoot: 3,
      HostText: 6,
      IncompleteClassComponent: -1,
      // Doesn't exist yet
      IndeterminateComponent: 0,
      LazyComponent: -1,
      // Doesn't exist yet
      LegacyHiddenComponent: -1,
      MemoComponent: -1,
      // Doesn't exist yet
      Mode: 11,
      OffscreenComponent: -1,
      // Experimental
      Profiler: 15,
      ScopeComponent: -1,
      // Experimental
      SimpleMemoComponent: -1,
      // Doesn't exist yet
      SuspenseComponent: 16,
      SuspenseListComponent: -1,
      // Doesn't exist yet
      YieldComponent: 9
    };
  } // **********************************************************
  // End of copied code.
  // **********************************************************


  function getTypeSymbol(type) {
    var symbolOrNumber = renderer_typeof(type) === 'object' && type !== null ? type.$$typeof : type; // $FlowFixMe Flow doesn't know about typeof "symbol"

    return renderer_typeof(symbolOrNumber) === 'symbol' ? symbolOrNumber.toString() : symbolOrNumber;
  }

  var _ReactTypeOfWork = ReactTypeOfWork,
      CacheComponent = _ReactTypeOfWork.CacheComponent,
      ClassComponent = _ReactTypeOfWork.ClassComponent,
      IncompleteClassComponent = _ReactTypeOfWork.IncompleteClassComponent,
      FunctionComponent = _ReactTypeOfWork.FunctionComponent,
      IndeterminateComponent = _ReactTypeOfWork.IndeterminateComponent,
      ForwardRef = _ReactTypeOfWork.ForwardRef,
      HostRoot = _ReactTypeOfWork.HostRoot,
      HostComponent = _ReactTypeOfWork.HostComponent,
      HostPortal = _ReactTypeOfWork.HostPortal,
      HostText = _ReactTypeOfWork.HostText,
      Fragment = _ReactTypeOfWork.Fragment,
      LazyComponent = _ReactTypeOfWork.LazyComponent,
      LegacyHiddenComponent = _ReactTypeOfWork.LegacyHiddenComponent,
      MemoComponent = _ReactTypeOfWork.MemoComponent,
      OffscreenComponent = _ReactTypeOfWork.OffscreenComponent,
      Profiler = _ReactTypeOfWork.Profiler,
      ScopeComponent = _ReactTypeOfWork.ScopeComponent,
      SimpleMemoComponent = _ReactTypeOfWork.SimpleMemoComponent,
      SuspenseComponent = _ReactTypeOfWork.SuspenseComponent,
      SuspenseListComponent = _ReactTypeOfWork.SuspenseListComponent;

  function resolveFiberType(type) {
    var typeSymbol = getTypeSymbol(type);

    switch (typeSymbol) {
      case MEMO_NUMBER:
      case MEMO_SYMBOL_STRING:
        // recursively resolving memo type in case of memo(forwardRef(Component))
        return resolveFiberType(type.type);

      case FORWARD_REF_NUMBER:
      case FORWARD_REF_SYMBOL_STRING:
        return type.render;

      default:
        return type;
    }
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getDisplayNameForFiber(fiber) {
    var elementType = fiber.elementType,
        type = fiber.type,
        tag = fiber.tag;
    var resolvedType = type;

    if (renderer_typeof(type) === 'object' && type !== null) {
      resolvedType = resolveFiberType(type);
    }

    var resolvedContext = null;

    switch (tag) {
      case CacheComponent:
        return 'Cache';

      case ClassComponent:
      case IncompleteClassComponent:
        return getDisplayName(resolvedType);

      case FunctionComponent:
      case IndeterminateComponent:
        return getDisplayName(resolvedType);

      case ForwardRef:
        // Mirror https://github.com/facebook/react/blob/7c21bf72ace77094fd1910cc350a548287ef8350/packages/shared/getComponentName.js#L27-L37
        return type && type.displayName || getDisplayName(resolvedType, 'Anonymous');

      case HostRoot:
        return null;

      case HostComponent:
        return type;

      case HostPortal:
      case HostText:
      case Fragment:
        return null;

      case LazyComponent:
        // This display name will not be user visible.
        // Once a Lazy component loads its inner component, React replaces the tag and type.
        // This display name will only show up in console logs when DevTools DEBUG mode is on.
        return 'Lazy';

      case MemoComponent:
      case SimpleMemoComponent:
        return elementType && elementType.displayName || type && type.displayName || getDisplayName(resolvedType, 'Anonymous');

      case SuspenseComponent:
        return 'Suspense';

      case LegacyHiddenComponent:
        return 'LegacyHidden';

      case OffscreenComponent:
        return 'Offscreen';

      case ScopeComponent:
        return 'Scope';

      case SuspenseListComponent:
        return 'SuspenseList';

      case Profiler:
        return 'Profiler';

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case CONCURRENT_MODE_NUMBER:
          case CONCURRENT_MODE_SYMBOL_STRING:
          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
            return null;

          case PROVIDER_NUMBER:
          case PROVIDER_SYMBOL_STRING:
            // 16.3.0 exposed the context object as "context"
            // PR #12501 changed it to "_context" for 16.3.1+
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type.context;
            return "".concat(resolvedContext.displayName || 'Context', ".Provider");

          case CONTEXT_NUMBER:
          case CONTEXT_SYMBOL_STRING:
            // 16.3-16.5 read from "type" because the Consumer is the actual context object.
            // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
            // NOTE Keep in sync with inspectElementRaw()
            resolvedContext = fiber.type._context || fiber.type; // NOTE: TraceUpdatesBackendManager depends on the name ending in '.Consumer'
            // If you change the name, figure out a more resilient way to detect it.

            return "".concat(resolvedContext.displayName || 'Context', ".Consumer");

          case STRICT_MODE_NUMBER:
          case STRICT_MODE_SYMBOL_STRING:
            return null;

          case PROFILER_NUMBER:
          case PROFILER_SYMBOL_STRING:
            return "Profiler(".concat(fiber.memoizedProps.id, ")");

          case SCOPE_NUMBER:
          case SCOPE_SYMBOL_STRING:
            return 'Scope';

          default:
            // Unknown element type.
            // This may mean a new element type that has not yet been added to DevTools.
            return null;
        }

    }
  }

  return {
    getDisplayNameForFiber: getDisplayNameForFiber,
    getTypeSymbol: getTypeSymbol,
    ReactPriorityLevels: ReactPriorityLevels,
    ReactTypeOfWork: ReactTypeOfWork,
    ReactTypeOfSideEffect: ReactTypeOfSideEffect
  };
}
function renderer_attach(hook, rendererID, renderer, global) {
  // Newer versions of the reconciler package also specific reconciler version.
  // If that version number is present, use it.
  // Third party renderer versions may not match the reconciler version,
  // and the latter is what's important in terms of tags and symbols.
  var version = renderer.reconcilerVersion || renderer.version;

  var _getInternalReactCons = getInternalReactConstants(version),
      getDisplayNameForFiber = _getInternalReactCons.getDisplayNameForFiber,
      getTypeSymbol = _getInternalReactCons.getTypeSymbol,
      ReactPriorityLevels = _getInternalReactCons.ReactPriorityLevels,
      ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork,
      ReactTypeOfSideEffect = _getInternalReactCons.ReactTypeOfSideEffect;

  var DidCapture = ReactTypeOfSideEffect.DidCapture,
      Incomplete = ReactTypeOfSideEffect.Incomplete,
      NoFlags = ReactTypeOfSideEffect.NoFlags,
      PerformedWork = ReactTypeOfSideEffect.PerformedWork,
      Placement = ReactTypeOfSideEffect.Placement;
  var CacheComponent = ReactTypeOfWork.CacheComponent,
      ClassComponent = ReactTypeOfWork.ClassComponent,
      ContextConsumer = ReactTypeOfWork.ContextConsumer,
      DehydratedSuspenseComponent = ReactTypeOfWork.DehydratedSuspenseComponent,
      ForwardRef = ReactTypeOfWork.ForwardRef,
      Fragment = ReactTypeOfWork.Fragment,
      FunctionComponent = ReactTypeOfWork.FunctionComponent,
      HostRoot = ReactTypeOfWork.HostRoot,
      HostPortal = ReactTypeOfWork.HostPortal,
      HostComponent = ReactTypeOfWork.HostComponent,
      HostText = ReactTypeOfWork.HostText,
      IncompleteClassComponent = ReactTypeOfWork.IncompleteClassComponent,
      IndeterminateComponent = ReactTypeOfWork.IndeterminateComponent,
      LegacyHiddenComponent = ReactTypeOfWork.LegacyHiddenComponent,
      MemoComponent = ReactTypeOfWork.MemoComponent,
      OffscreenComponent = ReactTypeOfWork.OffscreenComponent,
      SimpleMemoComponent = ReactTypeOfWork.SimpleMemoComponent,
      SuspenseComponent = ReactTypeOfWork.SuspenseComponent,
      SuspenseListComponent = ReactTypeOfWork.SuspenseListComponent;
  var ImmediatePriority = ReactPriorityLevels.ImmediatePriority,
      UserBlockingPriority = ReactPriorityLevels.UserBlockingPriority,
      NormalPriority = ReactPriorityLevels.NormalPriority,
      LowPriority = ReactPriorityLevels.LowPriority,
      IdlePriority = ReactPriorityLevels.IdlePriority,
      NoPriority = ReactPriorityLevels.NoPriority;
  var overrideHookState = renderer.overrideHookState,
      overrideHookStateDeletePath = renderer.overrideHookStateDeletePath,
      overrideHookStateRenamePath = renderer.overrideHookStateRenamePath,
      overrideProps = renderer.overrideProps,
      overridePropsDeletePath = renderer.overridePropsDeletePath,
      overridePropsRenamePath = renderer.overridePropsRenamePath,
      scheduleRefresh = renderer.scheduleRefresh,
      setErrorHandler = renderer.setErrorHandler,
      setSuspenseHandler = renderer.setSuspenseHandler,
      scheduleUpdate = renderer.scheduleUpdate;
  var supportsTogglingError = typeof setErrorHandler === 'function' && typeof scheduleUpdate === 'function';
  var supportsTogglingSuspense = typeof setSuspenseHandler === 'function' && typeof scheduleUpdate === 'function';

  if (typeof scheduleRefresh === 'function') {
    // When Fast Refresh updates a component, the frontend may need to purge cached information.
    // For example, ASTs cached for the component (for named hooks) may no longer be valid.
    // Send a signal to the frontend to purge this cached information.
    // The "fastRefreshScheduled" dispatched is global (not Fiber or even Renderer specific).
    // This is less effecient since it means the front-end will need to purge the entire cache,
    // but this is probably an okay trade off in order to reduce coupling between the DevTools and Fast Refresh.
    renderer.scheduleRefresh = function () {
      try {
        hook.emit('fastRefreshScheduled');
      } finally {
        return scheduleRefresh.apply(void 0, arguments);
      }
    };
  } // Tracks Fibers with recently changed number of error/warning messages.
  // These collections store the Fiber rather than the ID,
  // in order to avoid generating an ID for Fibers that never get mounted
  // (due to e.g. Suspense or error boundaries).
  // onErrorOrWarning() adds Fibers and recordPendingErrorsAndWarnings() later clears them.


  var fibersWithChangedErrorOrWarningCounts = new Set();
  var pendingFiberToErrorsMap = new Map();
  var pendingFiberToWarningsMap = new Map(); // Mapping of fiber IDs to error/warning messages and counts.

  var fiberIDToErrorsMap = new Map();
  var fiberIDToWarningsMap = new Map();

  function clearErrorsAndWarnings() {
    // eslint-disable-next-line no-for-of-loops/no-for-of-loops
    var _iterator = renderer_createForOfIteratorHelper(fiberIDToErrorsMap.keys()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var id = _step.value;

        var _fiber = idToArbitraryFiberMap.get(id);

        if (_fiber != null) {
          fibersWithChangedErrorOrWarningCounts.add(_fiber);
          updateMostRecentlyInspectedElementIfNecessary(id);
        }
      } // eslint-disable-next-line no-for-of-loops/no-for-of-loops

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    var _iterator2 = renderer_createForOfIteratorHelper(fiberIDToWarningsMap.keys()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _id = _step2.value;

        var _fiber2 = idToArbitraryFiberMap.get(_id);

        if (_fiber2 != null) {
          fibersWithChangedErrorOrWarningCounts.add(_fiber2);
          updateMostRecentlyInspectedElementIfNecessary(_id);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    fiberIDToErrorsMap.clear();
    fiberIDToWarningsMap.clear();
    flushPendingEvents();
  }

  function clearMessageCountHelper(fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
    var fiber = idToArbitraryFiberMap.get(fiberID);

    if (fiber != null) {
      // Throw out any pending changes.
      pendingFiberToErrorsMap.delete(fiber);

      if (fiberIDToMessageCountMap.has(fiberID)) {
        fiberIDToMessageCountMap.delete(fiberID); // If previous flushed counts have changed, schedule an update too.

        fibersWithChangedErrorOrWarningCounts.add(fiber);
        flushPendingEvents();
        updateMostRecentlyInspectedElementIfNecessary(fiberID);
      } else {
        fibersWithChangedErrorOrWarningCounts.delete(fiber);
      }
    }
  }

  function clearErrorsForFiberID(fiberID) {
    clearMessageCountHelper(fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
  }

  function clearWarningsForFiberID(fiberID) {
    clearMessageCountHelper(fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
  }

  function updateMostRecentlyInspectedElementIfNecessary(fiberID) {
    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === fiberID) {
      hasElementUpdatedSinceLastInspected = true;
    }
  } // Called when an error or warning is logged during render, commit, or passive (including unmount functions).


  function onErrorOrWarning(fiber, type, args) {
    if (type === 'error') {
      var maybeID = getFiberIDUnsafe(fiber); // if this is an error simulated by us to trigger error boundary, ignore

      if (maybeID != null && forceErrorForFiberIDs.get(maybeID) === true) {
        return;
      }
    }

    var message = format.apply(void 0, renderer_toConsumableArray(args));

    if (__DEBUG__) {
      debug('onErrorOrWarning', fiber, null, "".concat(type, ": \"").concat(message, "\""));
    } // Mark this Fiber as needed its warning/error count updated during the next flush.


    fibersWithChangedErrorOrWarningCounts.add(fiber); // Track the warning/error for later.

    var fiberMap = type === 'error' ? pendingFiberToErrorsMap : pendingFiberToWarningsMap;
    var messageMap = fiberMap.get(fiber);

    if (messageMap != null) {
      var count = messageMap.get(message) || 0;
      messageMap.set(message, count + 1);
    } else {
      fiberMap.set(fiber, new Map([[message, 1]]));
    } // Passive effects may trigger errors or warnings too;
    // In this case, we should wait until the rest of the passive effects have run,
    // but we shouldn't wait until the next commit because that might be a long time.
    // This would also cause "tearing" between an inspected Component and the tree view.
    // Then again we don't want to flush too soon because this could be an error during async rendering.
    // Use a debounce technique to ensure that we'll eventually flush.


    flushPendingErrorsAndWarningsAfterDelay();
  } // Patching the console enables DevTools to do a few useful things:
  // * Append component stacks to warnings and error messages
  // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)
  //
  // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.


  if (true) {
    registerRenderer(renderer, onErrorOrWarning); // The renderer interface can't read these preferences directly,
    // because it is stored in localStorage within the context of the extension.
    // It relies on the extension to pass the preference through via the global.

    var appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ !== false;
    var breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ === true;
    var showInlineWarningsAndErrors = window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ !== false;

    if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {
      patch({
        appendComponentStack: appendComponentStack,
        breakOnConsoleErrors: breakOnConsoleErrors,
        showInlineWarningsAndErrors: showInlineWarningsAndErrors
      });
    }
  }

  var debug = function debug(name, fiber, parentFiber) {
    var extraString = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';

    if (__DEBUG__) {
      var displayName = fiber.tag + ':' + (getDisplayNameForFiber(fiber) || 'null');
      var maybeID = getFiberIDUnsafe(fiber) || '<no id>';
      var parentDisplayName = parentFiber ? parentFiber.tag + ':' + (getDisplayNameForFiber(parentFiber) || 'null') : '';
      var maybeParentID = parentFiber ? getFiberIDUnsafe(parentFiber) || '<no-id>' : '';
      console.groupCollapsed("[renderer] %c".concat(name, " %c").concat(displayName, " (").concat(maybeID, ") %c").concat(parentFiber ? "".concat(parentDisplayName, " (").concat(maybeParentID, ")") : '', " %c").concat(extraString), 'color: red; font-weight: bold;', 'color: blue;', 'color: purple;', 'color: black;');
      console.log(new Error().stack.split('\n').slice(1).join('\n'));
      console.groupEnd();
    }
  }; // Configurable Components tree filters.


  var hideElementsWithDisplayNames = new Set();
  var hideElementsWithPaths = new Set();
  var hideElementsWithTypes = new Set(); // Highlight updates

  var traceUpdatesEnabled = false;
  var traceUpdatesForNodes = new Set();

  function applyComponentFilters(componentFilters) {
    hideElementsWithTypes.clear();
    hideElementsWithDisplayNames.clear();
    hideElementsWithPaths.clear();
    componentFilters.forEach(function (componentFilter) {
      if (!componentFilter.isEnabled) {
        return;
      }

      switch (componentFilter.type) {
        case ComponentFilterDisplayName:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithDisplayNames.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case ComponentFilterElementType:
          hideElementsWithTypes.add(componentFilter.value);
          break;

        case ComponentFilterLocation:
          if (componentFilter.isValid && componentFilter.value !== '') {
            hideElementsWithPaths.add(new RegExp(componentFilter.value, 'i'));
          }

          break;

        case ComponentFilterHOC:
          hideElementsWithDisplayNames.add(new RegExp('\\('));
          break;

        default:
          console.warn("Invalid component filter type \"".concat(componentFilter.type, "\""));
          break;
      }
    });
  } // The renderer interface can't read saved component filters directly,
  // because they are stored in localStorage within the context of the extension.
  // Instead it relies on the extension to pass filters through.


  if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ != null) {
    applyComponentFilters(window.__REACT_DEVTOOLS_COMPONENT_FILTERS__);
  } else {
    // Unfortunately this feature is not expected to work for React Native for now.
    // It would be annoying for us to spam YellowBox warnings with unactionable stuff,
    // so for now just skip this message...
    //console.warn(' DevTools: Could not locate saved component filters');
    // Fallback to assuming the default filters in this case.
    applyComponentFilters(getDefaultComponentFilters());
  } // If necessary, we can revisit optimizing this operation.
  // For example, we could add a new recursive unmount tree operation.
  // The unmount operations are already significantly smaller than mount operations though.
  // This is something to keep in mind for later.


  function updateComponentFilters(componentFilters) {
    if (isProfiling) {
      // Re-mounting a tree while profiling is in progress might break a lot of assumptions.
      // If necessary, we could support this- but it doesn't seem like a necessary use case.
      throw Error('Cannot modify filter preferences while profiling');
    } // Recursively unmount all roots.


    hook.getFiberRoots(rendererID).forEach(function (root) {
      currentRootID = getOrGenerateFiberID(root.current); // The TREE_OPERATION_REMOVE_ROOT operation serves two purposes:
      // 1. It avoids sending unnecessary bridge traffic to clear a root.
      // 2. It preserves Fiber IDs when remounting (below) which in turn ID to error/warning mapping.

      pushOperation(TREE_OPERATION_REMOVE_ROOT);
      flushPendingEvents(root);
      currentRootID = -1;
    });
    applyComponentFilters(componentFilters); // Reset pseudo counters so that new path selections will be persisted.

    rootDisplayNameCounter.clear(); // Recursively re-mount all roots with new filter criteria applied.

    hook.getFiberRoots(rendererID).forEach(function (root) {
      currentRootID = getOrGenerateFiberID(root.current);
      setRootPseudoKey(currentRootID, root.current);
      mountFiberRecursively(root.current, null, false, false);
      flushPendingEvents(root);
      currentRootID = -1;
    }); // Also re-evaluate all error and warning counts given the new filters.

    reevaluateErrorsAndWarnings();
    flushPendingEvents();
  } // NOTICE Keep in sync with get*ForFiber methods


  function shouldFilterFiber(fiber) {
    var _debugSource = fiber._debugSource,
        tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case DehydratedSuspenseComponent:
        // TODO: ideally we would show dehydrated Suspense immediately.
        // However, it has some special behavior (like disconnecting
        // an alternate and turning into real Suspense) which breaks DevTools.
        // For now, ignore it, and only show it once it gets hydrated.
        // https://github.com/bvaughn/react-devtools-experimental/issues/197
        return true;

      case HostPortal:
      case HostText:
      case Fragment:
      case LegacyHiddenComponent:
      case OffscreenComponent:
        return true;

      case HostRoot:
        // It is never valid to filter the root element.
        return false;

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case CONCURRENT_MODE_NUMBER:
          case CONCURRENT_MODE_SYMBOL_STRING:
          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
          case STRICT_MODE_NUMBER:
          case STRICT_MODE_SYMBOL_STRING:
            return true;

          default:
            break;
        }

    }

    var elementType = getElementTypeForFiber(fiber);

    if (hideElementsWithTypes.has(elementType)) {
      return true;
    }

    if (hideElementsWithDisplayNames.size > 0) {
      var displayName = getDisplayNameForFiber(fiber);

      if (displayName != null) {
        // eslint-disable-next-line no-for-of-loops/no-for-of-loops
        var _iterator3 = renderer_createForOfIteratorHelper(hideElementsWithDisplayNames),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var displayNameRegExp = _step3.value;

            if (displayNameRegExp.test(displayName)) {
              return true;
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      }
    }

    if (_debugSource != null && hideElementsWithPaths.size > 0) {
      var fileName = _debugSource.fileName; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

      var _iterator4 = renderer_createForOfIteratorHelper(hideElementsWithPaths),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var pathRegExp = _step4.value;

          if (pathRegExp.test(fileName)) {
            return true;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }

    return false;
  } // NOTICE Keep in sync with shouldFilterFiber() and other get*ForFiber methods


  function getElementTypeForFiber(fiber) {
    var type = fiber.type,
        tag = fiber.tag;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        return ElementTypeClass;

      case FunctionComponent:
      case IndeterminateComponent:
        return ElementTypeFunction;

      case ForwardRef:
        return ElementTypeForwardRef;

      case HostRoot:
        return ElementTypeRoot;

      case HostComponent:
        return ElementTypeHostComponent;

      case HostPortal:
      case HostText:
      case Fragment:
        return ElementTypeOtherOrUnknown;

      case MemoComponent:
      case SimpleMemoComponent:
        return ElementTypeMemo;

      case SuspenseComponent:
        return ElementTypeSuspense;

      case SuspenseListComponent:
        return ElementTypeSuspenseList;

      default:
        var typeSymbol = getTypeSymbol(type);

        switch (typeSymbol) {
          case CONCURRENT_MODE_NUMBER:
          case CONCURRENT_MODE_SYMBOL_STRING:
          case DEPRECATED_ASYNC_MODE_SYMBOL_STRING:
            return ElementTypeOtherOrUnknown;

          case PROVIDER_NUMBER:
          case PROVIDER_SYMBOL_STRING:
            return ElementTypeContext;

          case CONTEXT_NUMBER:
          case CONTEXT_SYMBOL_STRING:
            return ElementTypeContext;

          case STRICT_MODE_NUMBER:
          case STRICT_MODE_SYMBOL_STRING:
            return ElementTypeOtherOrUnknown;

          case PROFILER_NUMBER:
          case PROFILER_SYMBOL_STRING:
            return ElementTypeProfiler;

          default:
            return ElementTypeOtherOrUnknown;
        }

    }
  } // Map of one or more Fibers in a pair to their unique id number.
  // We track both Fibers to support Fast Refresh,
  // which may forcefully replace one of the pair as part of hot reloading.
  // In that case it's still important to be able to locate the previous ID during subsequent renders.


  var fiberToIDMap = new Map(); // Map of id to one (arbitrary) Fiber in a pair.
  // This Map is used to e.g. get the display name for a Fiber or schedule an update,
  // operations that should be the same whether the current and work-in-progress Fiber is used.

  var idToArbitraryFiberMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This is so that we can quickly capture a snapshot of those values if profiling starts.
  // If we didn't store these values, we'd have to crawl the tree when profiling started,
  // and use a slow path to find each of the current Fibers.

  var idToTreeBaseDurationMap = new Map(); // When profiling is supported, we store the latest tree base durations for each Fiber.
  // This map enables us to filter these times by root when sending them to the frontend.

  var idToRootMap = new Map(); // When a mount or update is in progress, this value tracks the root that is being operated on.

  var currentRootID = -1; // Returns the unique ID for a Fiber or generates and caches a new one if the Fiber hasn't been seen before.
  // Once this method has been called for a Fiber, untrackFiberID() should always be called later to avoid leaking.

  function getOrGenerateFiberID(fiber) {
    var id = null;

    if (fiberToIDMap.has(fiber)) {
      id = fiberToIDMap.get(fiber);
    } else {
      var _alternate = fiber.alternate;

      if (_alternate !== null && fiberToIDMap.has(_alternate)) {
        id = fiberToIDMap.get(_alternate);
      }
    }

    var didGenerateID = false;

    if (id === null) {
      didGenerateID = true;
      id = getUID();
    } // This refinement is for Flow purposes only.


    var refinedID = id; // Make sure we're tracking this Fiber
    // e.g. if it just mounted or an error was logged during initial render.

    if (!fiberToIDMap.has(fiber)) {
      fiberToIDMap.set(fiber, refinedID);
      idToArbitraryFiberMap.set(refinedID, fiber);
    } // Also make sure we're tracking its alternate,
    // e.g. in case this is the first update after mount.


    var alternate = fiber.alternate;

    if (alternate !== null) {
      if (!fiberToIDMap.has(alternate)) {
        fiberToIDMap.set(alternate, refinedID);
      }
    }

    if (__DEBUG__) {
      if (didGenerateID) {
        debug('getOrGenerateFiberID()', fiber, fiber.return, 'Generated a new UID');
      }
    }

    return refinedID;
  } // Returns an ID if one has already been generated for the Fiber or throws.


  function getFiberIDThrows(fiber) {
    var maybeID = getFiberIDUnsafe(fiber);

    if (maybeID !== null) {
      return maybeID;
    }

    throw Error("Could not find ID for Fiber \"".concat(getDisplayNameForFiber(fiber) || '', "\""));
  } // Returns an ID if one has already been generated for the Fiber or null if one has not been generated.
  // Use this method while e.g. logging to avoid over-retaining Fibers.


  function getFiberIDUnsafe(fiber) {
    if (fiberToIDMap.has(fiber)) {
      return fiberToIDMap.get(fiber);
    } else {
      var alternate = fiber.alternate;

      if (alternate !== null && fiberToIDMap.has(alternate)) {
        return fiberToIDMap.get(alternate);
      }
    }

    return null;
  } // Removes a Fiber (and its alternate) from the Maps used to track their id.
  // This method should always be called when a Fiber is unmounting.


  function untrackFiberID(fiber) {
    if (__DEBUG__) {
      debug('untrackFiberID()', fiber, fiber.return, 'schedule after delay');
    } // Untrack Fibers after a slight delay in order to support a Fast Refresh edge case:
    // 1. Component type is updated and Fast Refresh schedules an update+remount.
    // 2. flushPendingErrorsAndWarningsAfterDelay() runs, sees the old Fiber is no longer mounted
    //    (it's been disconnected by Fast Refresh), and calls untrackFiberID() to clear it from the Map.
    // 3. React flushes pending passive effects before it runs the next render,
    //    which logs an error or warning, which causes a new ID to be generated for this Fiber.
    // 4. DevTools now tries to unmount the old Component with the new ID.
    //
    // The underlying problem here is the premature clearing of the Fiber ID,
    // but DevTools has no way to detect that a given Fiber has been scheduled for Fast Refresh.
    // (The "_debugNeedsRemount" flag won't necessarily be set.)
    //
    // The best we can do is to delay untracking by a small amount,
    // and give React time to process the Fast Refresh delay.


    untrackFibersSet.add(fiber);

    if (untrackFibersTimeoutID === null) {
      untrackFibersTimeoutID = setTimeout(untrackFibers, 1000);
    }
  }

  var untrackFibersSet = new Set();
  var untrackFibersTimeoutID = null;

  function untrackFibers() {
    if (untrackFibersTimeoutID !== null) {
      clearTimeout(untrackFibersTimeoutID);
      untrackFibersTimeoutID = null;
    }

    untrackFibersSet.forEach(function (fiber) {
      var fiberID = getFiberIDUnsafe(fiber);

      if (fiberID !== null) {
        idToArbitraryFiberMap.delete(fiberID); // Also clear any errors/warnings associated with this fiber.

        clearErrorsForFiberID(fiberID);
        clearWarningsForFiberID(fiberID);
      }

      fiberToIDMap.delete(fiber);
      var alternate = fiber.alternate;

      if (alternate !== null) {
        fiberToIDMap.delete(alternate);
      }

      if (forceErrorForFiberIDs.has(fiberID)) {
        forceErrorForFiberIDs.delete(fiberID);

        if (forceErrorForFiberIDs.size === 0 && setErrorHandler != null) {
          setErrorHandler(shouldErrorFiberAlwaysNull);
        }
      }
    });
    untrackFibersSet.clear();
  }

  function getChangeDescription(prevFiber, nextFiber) {
    switch (getElementTypeForFiber(nextFiber)) {
      case ElementTypeClass:
      case ElementTypeFunction:
      case ElementTypeMemo:
      case ElementTypeForwardRef:
        if (prevFiber === null) {
          return {
            context: null,
            didHooksChange: false,
            isFirstMount: true,
            props: null,
            state: null
          };
        } else {
          var data = {
            context: getContextChangedKeys(nextFiber),
            didHooksChange: false,
            isFirstMount: false,
            props: getChangedKeys(prevFiber.memoizedProps, nextFiber.memoizedProps),
            state: getChangedKeys(prevFiber.memoizedState, nextFiber.memoizedState)
          }; // Only traverse the hooks list once, depending on what info we're returning.

          if (enableProfilerChangedHookIndices) {
            var indices = getChangedHooksIndices(prevFiber.memoizedState, nextFiber.memoizedState);
            data.hooks = indices;
            data.didHooksChange = indices !== null && indices.length > 0;
          } else {
            data.didHooksChange = didHooksChange(prevFiber.memoizedState, nextFiber.memoizedState);
          }

          return data;
        }

      default:
        return null;
    }
  }

  function updateContextsForFiber(fiber) {
    switch (getElementTypeForFiber(fiber)) {
      case ElementTypeFunction:
      case ElementTypeClass:
        if (idToContextsMap !== null) {
          var id = getFiberIDThrows(fiber);
          var contexts = getContextsForFiber(fiber);

          if (contexts !== null) {
            idToContextsMap.set(id, contexts);
          }
        }

        break;

      default:
        break;
    }
  } // Differentiates between a null context value and no context.


  var NO_CONTEXT = {};

  function getContextsForFiber(fiber) {
    var legacyContext = NO_CONTEXT;
    var modernContext = NO_CONTEXT;

    switch (getElementTypeForFiber(fiber)) {
      case ElementTypeClass:
        var instance = fiber.stateNode;

        if (instance != null) {
          if (instance.constructor && instance.constructor.contextType != null) {
            modernContext = instance.context;
          } else {
            legacyContext = instance.context;

            if (legacyContext && Object.keys(legacyContext).length === 0) {
              legacyContext = NO_CONTEXT;
            }
          }
        }

        return [legacyContext, modernContext];

      case ElementTypeFunction:
        var dependencies = fiber.dependencies;

        if (dependencies && dependencies.firstContext) {
          modernContext = dependencies.firstContext;
        }

        return [legacyContext, modernContext];

      default:
        return null;
    }
  } // Record all contexts at the time profiling is started.
  // Fibers only store the current context value,
  // so we need to track them separately in order to determine changed keys.


  function crawlToInitializeContextsMap(fiber) {
    updateContextsForFiber(fiber);
    var current = fiber.child;

    while (current !== null) {
      crawlToInitializeContextsMap(current);
      current = current.sibling;
    }
  }

  function getContextChangedKeys(fiber) {
    if (idToContextsMap !== null) {
      var id = getFiberIDThrows(fiber);
      var prevContexts = idToContextsMap.has(id) ? idToContextsMap.get(id) : null;
      var nextContexts = getContextsForFiber(fiber);

      if (prevContexts == null || nextContexts == null) {
        return null;
      }

      var _prevContexts = _slicedToArray(prevContexts, 2),
          prevLegacyContext = _prevContexts[0],
          prevModernContext = _prevContexts[1];

      var _nextContexts = _slicedToArray(nextContexts, 2),
          nextLegacyContext = _nextContexts[0],
          nextModernContext = _nextContexts[1];

      switch (getElementTypeForFiber(fiber)) {
        case ElementTypeClass:
          if (prevContexts && nextContexts) {
            if (nextLegacyContext !== NO_CONTEXT) {
              return getChangedKeys(prevLegacyContext, nextLegacyContext);
            } else if (nextModernContext !== NO_CONTEXT) {
              return prevModernContext !== nextModernContext;
            }
          }

          break;

        case ElementTypeFunction:
          if (nextModernContext !== NO_CONTEXT) {
            var prevContext = prevModernContext;
            var nextContext = nextModernContext;

            while (prevContext && nextContext) {
              if (!shared_objectIs(prevContext.memoizedValue, nextContext.memoizedValue)) {
                return true;
              }

              prevContext = prevContext.next;
              nextContext = nextContext.next;
            }

            return false;
          }

          break;

        default:
          break;
      }
    }

    return null;
  }

  function areHookInputsEqual(nextDeps, prevDeps) {
    if (prevDeps === null) {
      return false;
    }

    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
      if (shared_objectIs(nextDeps[i], prevDeps[i])) {
        continue;
      }

      return false;
    }

    return true;
  }

  function isEffect(memoizedState) {
    if (memoizedState === null || renderer_typeof(memoizedState) !== 'object') {
      return false;
    }

    var deps = memoizedState.deps;
    var hasOwnProperty = Object.prototype.hasOwnProperty.bind(memoizedState);
    return hasOwnProperty('create') && hasOwnProperty('destroy') && hasOwnProperty('deps') && hasOwnProperty('next') && hasOwnProperty('tag') && (deps === null || shared_isArray(deps));
  }

  function didHookChange(prev, next) {
    var prevMemoizedState = prev.memoizedState;
    var nextMemoizedState = next.memoizedState;

    if (isEffect(prevMemoizedState) && isEffect(nextMemoizedState)) {
      return prevMemoizedState !== nextMemoizedState && !areHookInputsEqual(nextMemoizedState.deps, prevMemoizedState.deps);
    }

    return nextMemoizedState !== prevMemoizedState;
  }

  function didHooksChange(prev, next) {
    if (prev == null || next == null) {
      return false;
    } // We can't report anything meaningful for hooks changes.


    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      while (next !== null) {
        if (didHookChange(prev, next)) {
          return true;
        } else {
          next = next.next;
          prev = prev.next;
        }
      }
    }

    return false;
  }

  function getChangedHooksIndices(prev, next) {
    if (enableProfilerChangedHookIndices) {
      if (prev == null || next == null) {
        return null;
      }

      var indices = [];
      var index = 0;

      if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
        while (next !== null) {
          if (didHookChange(prev, next)) {
            indices.push(index);
          }

          next = next.next;
          prev = prev.next;
          index++;
        }
      }

      return indices;
    }

    return null;
  }

  function getChangedKeys(prev, next) {
    if (prev == null || next == null) {
      return null;
    } // We can't report anything meaningful for hooks changes.


    if (next.hasOwnProperty('baseState') && next.hasOwnProperty('memoizedState') && next.hasOwnProperty('next') && next.hasOwnProperty('queue')) {
      return null;
    }

    var keys = new Set([].concat(renderer_toConsumableArray(Object.keys(prev)), renderer_toConsumableArray(Object.keys(next))));
    var changedKeys = []; // eslint-disable-next-line no-for-of-loops/no-for-of-loops

    var _iterator5 = renderer_createForOfIteratorHelper(keys),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var key = _step5.value;

        if (prev[key] !== next[key]) {
          changedKeys.push(key);
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    return changedKeys;
  } // eslint-disable-next-line no-unused-vars


  function didFiberRender(prevFiber, nextFiber) {
    switch (nextFiber.tag) {
      case ClassComponent:
      case FunctionComponent:
      case ContextConsumer:
      case MemoComponent:
      case SimpleMemoComponent:
        // For types that execute user code, we check PerformedWork effect.
        // We don't reflect bailouts (either referential or sCU) in DevTools.
        // eslint-disable-next-line no-bitwise
        return (getFiberFlags(nextFiber) & PerformedWork) === PerformedWork;
      // Note: ContextConsumer only gets PerformedWork effect in 16.3.3+
      // so it won't get highlighted with React 16.3.0 to 16.3.2.

      default:
        // For host components and other types, we compare inputs
        // to determine whether something is an update.
        return prevFiber.memoizedProps !== nextFiber.memoizedProps || prevFiber.memoizedState !== nextFiber.memoizedState || prevFiber.ref !== nextFiber.ref;
    }
  }

  var pendingOperations = [];
  var pendingRealUnmountedIDs = [];
  var pendingSimulatedUnmountedIDs = [];
  var pendingOperationsQueue = [];
  var pendingStringTable = new Map();
  var pendingStringTableLength = 0;
  var pendingUnmountedRootID = null;

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function flushOrQueueOperations(operations) {
    if (pendingOperationsQueue !== null) {
      pendingOperationsQueue.push(operations);
    } else {
      hook.emit('operations', operations);
    }
  }

  var flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;

  function clearPendingErrorsAndWarningsAfterDelay() {
    if (flushPendingErrorsAndWarningsAfterDelayTimeoutID !== null) {
      clearTimeout(flushPendingErrorsAndWarningsAfterDelayTimeoutID);
      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;
    }
  }

  function flushPendingErrorsAndWarningsAfterDelay() {
    clearPendingErrorsAndWarningsAfterDelay();
    flushPendingErrorsAndWarningsAfterDelayTimeoutID = setTimeout(function () {
      flushPendingErrorsAndWarningsAfterDelayTimeoutID = null;

      if (pendingOperations.length > 0) {
        // On the off chance that something else has pushed pending operations,
        // we should bail on warnings; it's probably not safe to push midway.
        return;
      }

      recordPendingErrorsAndWarnings();

      if (pendingOperations.length === 0) {
        // No warnings or errors to flush; we can bail out early here too.
        return;
      } // We can create a smaller operations array than flushPendingEvents()
      // because we only need to flush warning and error counts.
      // Only a few pieces of fixed information are required up front.


      var operations = new Array(3 + pendingOperations.length);
      operations[0] = rendererID;
      operations[1] = currentRootID;
      operations[2] = 0; // String table size

      for (var j = 0; j < pendingOperations.length; j++) {
        operations[3 + j] = pendingOperations[j];
      }

      flushOrQueueOperations(operations);
      pendingOperations.length = 0;
    }, 1000);
  }

  function reevaluateErrorsAndWarnings() {
    fibersWithChangedErrorOrWarningCounts.clear();
    fiberIDToErrorsMap.forEach(function (countMap, fiberID) {
      var fiber = idToArbitraryFiberMap.get(fiberID);

      if (fiber != null) {
        fibersWithChangedErrorOrWarningCounts.add(fiber);
      }
    });
    fiberIDToWarningsMap.forEach(function (countMap, fiberID) {
      var fiber = idToArbitraryFiberMap.get(fiberID);

      if (fiber != null) {
        fibersWithChangedErrorOrWarningCounts.add(fiber);
      }
    });
    recordPendingErrorsAndWarnings();
  }

  function mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToMessageCountMap, fiberIDToMessageCountMap) {
    var newCount = 0;
    var messageCountMap = fiberIDToMessageCountMap.get(fiberID);
    var pendingMessageCountMap = pendingFiberToMessageCountMap.get(fiber);

    if (pendingMessageCountMap != null) {
      if (messageCountMap == null) {
        messageCountMap = pendingMessageCountMap;
        fiberIDToMessageCountMap.set(fiberID, pendingMessageCountMap);
      } else {
        // This Flow refinement should not be necessary and yet...
        var refinedMessageCountMap = messageCountMap;
        pendingMessageCountMap.forEach(function (pendingCount, message) {
          var previousCount = refinedMessageCountMap.get(message) || 0;
          refinedMessageCountMap.set(message, previousCount + pendingCount);
        });
      }
    }

    if (!shouldFilterFiber(fiber)) {
      if (messageCountMap != null) {
        messageCountMap.forEach(function (count) {
          newCount += count;
        });
      }
    }

    pendingFiberToMessageCountMap.delete(fiber);
    return newCount;
  }

  function recordPendingErrorsAndWarnings() {
    clearPendingErrorsAndWarningsAfterDelay();
    fibersWithChangedErrorOrWarningCounts.forEach(function (fiber) {
      var fiberID = getFiberIDUnsafe(fiber);

      if (fiberID === null) {// Don't send updates for Fibers that didn't mount due to e.g. Suspense or an error boundary.
      } else {
        var errorCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToErrorsMap, fiberIDToErrorsMap);
        var warningCount = mergeMapsAndGetCountHelper(fiber, fiberID, pendingFiberToWarningsMap, fiberIDToWarningsMap);
        pushOperation(TREE_OPERATION_UPDATE_ERRORS_OR_WARNINGS);
        pushOperation(fiberID);
        pushOperation(errorCount);
        pushOperation(warningCount);
      } // Always clean up so that we don't leak.


      pendingFiberToErrorsMap.delete(fiber);
      pendingFiberToWarningsMap.delete(fiber);
    });
    fibersWithChangedErrorOrWarningCounts.clear();
  }

  function flushPendingEvents(root) {
    // Add any pending errors and warnings to the operations array.
    // We do this just before flushing, so we can ignore errors for no-longer-mounted Fibers.
    recordPendingErrorsAndWarnings();

    if (pendingOperations.length === 0 && pendingRealUnmountedIDs.length === 0 && pendingSimulatedUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
      // If we aren't profiling, we can just bail out here.
      // No use sending an empty update over the bridge.
      //
      // The Profiler stores metadata for each commit and reconstructs the app tree per commit using:
      // (1) an initial tree snapshot and
      // (2) the operations array for each commit
      // Because of this, it's important that the operations and metadata arrays align,
      // So it's important not to omit even empty operations while profiling is active.
      if (!isProfiling) {
        return;
      }
    }

    var numUnmountIDs = pendingRealUnmountedIDs.length + pendingSimulatedUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    var operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Regular operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber props, states, and hooks to be inspected.

    var i = 0;
    operations[i++] = rendererID;
    operations[i++] = currentRootID; // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach(function (value, key) {
      operations[i++] = key.length;
      var encodedKey = utfEncodeString(key);

      for (var j = 0; j < encodedKey.length; j++) {
        operations[i + j] = encodedKey[j];
      }

      i += key.length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = TREE_OPERATION_REMOVE; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the real unmounts in the reverse order.
      // They were inserted parents-first by React, but we want children-first.
      // So we traverse our array backwards.

      for (var j = pendingRealUnmountedIDs.length - 1; j >= 0; j--) {
        operations[i++] = pendingRealUnmountedIDs[j];
      } // Fill in the simulated unmounts (hidden Suspense subtrees) in their order.
      // (We want children to go before parents.)
      // They go *after* the real unmounts because we know for sure they won't be
      // children of already pushed "real" IDs. If they were, we wouldn't be able
      // to discover them during the traversal, as they would have been deleted.


      for (var _j = 0; _j < pendingSimulatedUnmountedIDs.length; _j++) {
        operations[i + _j] = pendingSimulatedUnmountedIDs[_j];
      }

      i += pendingSimulatedUnmountedIDs.length; // The root ID should always be unmounted last.

      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (var _j2 = 0; _j2 < pendingOperations.length; _j2++) {
      operations[i + _j2] = pendingOperations[_j2];
    }

    i += pendingOperations.length; // Let the frontend know about tree operations.

    flushOrQueueOperations(operations); // Reset all of the pending state now that we've told the frontend about it.

    pendingOperations.length = 0;
    pendingRealUnmountedIDs.length = 0;
    pendingSimulatedUnmountedIDs.length = 0;
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function getStringID(str) {
    if (str === null) {
      return 0;
    }

    var existingID = pendingStringTable.get(str);

    if (existingID !== undefined) {
      return existingID;
    }

    var stringID = pendingStringTable.size + 1;
    pendingStringTable.set(str, stringID); // The string table total length needs to account
    // both for the string length, and for the array item
    // that contains the length itself. Hence + 1.

    pendingStringTableLength += str.length + 1;
    return stringID;
  }

  function recordMount(fiber, parentFiber) {
    var isRoot = fiber.tag === HostRoot;
    var id = getOrGenerateFiberID(fiber);

    if (__DEBUG__) {
      debug('recordMount()', fiber, parentFiber);
    }

    var hasOwnerMetadata = fiber.hasOwnProperty('_debugOwner');
    var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');

    if (isRoot) {
      pushOperation(TREE_OPERATION_ADD);
      pushOperation(id);
      pushOperation(ElementTypeRoot);
      pushOperation(isProfilingSupported ? 1 : 0);
      pushOperation(hasOwnerMetadata ? 1 : 0);

      if (isProfiling) {
        if (displayNamesByRootID !== null) {
          displayNamesByRootID.set(id, getDisplayNameForRoot(fiber));
        }
      }
    } else {
      var key = fiber.key;
      var displayName = getDisplayNameForFiber(fiber);
      var elementType = getElementTypeForFiber(fiber);
      var _debugOwner = fiber._debugOwner; // Ideally we should call getFiberIDThrows() for _debugOwner,
      // since owners are almost always higher in the tree (and so have already been processed),
      // but in some (rare) instances reported in open source, a descendant mounts before an owner.
      // Since this is a DEV only field it's probably okay to also just lazily generate and ID here if needed.
      // See https://github.com/facebook/react/issues/21445

      var ownerID = _debugOwner != null ? getOrGenerateFiberID(_debugOwner) : 0;
      var parentID = parentFiber ? getFiberIDThrows(parentFiber) : 0;
      var displayNameStringID = getStringID(displayName); // This check is a guard to handle a React element that has been modified
      // in such a way as to bypass the default stringification of the "key" property.

      var keyString = key === null ? null : '' + key;
      var keyStringID = getStringID(keyString);
      pushOperation(TREE_OPERATION_ADD);
      pushOperation(id);
      pushOperation(elementType);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID);
    }

    if (isProfilingSupported) {
      idToRootMap.set(id, currentRootID);
      recordProfilingDurations(fiber);
    }
  }

  function recordUnmount(fiber, isSimulated) {
    if (__DEBUG__) {
      debug('recordUnmount()', fiber, null, isSimulated ? 'unmount is simulated' : '');
    }

    if (trackedPathMatchFiber !== null) {
      // We're in the process of trying to restore previous selection.
      // If this fiber matched but is being unmounted, there's no use trying.
      // Reset the state so we don't keep holding onto it.
      if (fiber === trackedPathMatchFiber || fiber === trackedPathMatchFiber.alternate) {
        setTrackedPath(null);
      }
    }

    var unsafeID = getFiberIDUnsafe(fiber);

    if (unsafeID === null) {
      // If we've never seen this Fiber, it might be inside of a legacy render Suspense fragment (so the store is not even aware of it).
      // In that case we can just ignore it or it will cause errors later on.
      // One example of this is a Lazy component that never resolves before being unmounted.
      //
      // This also might indicate a Fast Refresh force-remount scenario.
      //
      // TODO: This is fragile and can obscure actual bugs.
      return;
    } // Flow refinement.


    var id = unsafeID;
    var isRoot = fiber.tag === HostRoot;

    if (isRoot) {
      // Roots must be removed only after all children (pending and simulated) have been removed.
      // So we track it separately.
      pendingUnmountedRootID = id;
    } else if (!shouldFilterFiber(fiber)) {
      // To maintain child-first ordering,
      // we'll push it into one of these queues,
      // and later arrange them in the correct order.
      if (isSimulated) {
        pendingSimulatedUnmountedIDs.push(id);
      } else {
        pendingRealUnmountedIDs.push(id);
      }
    }

    if (!fiber._debugNeedsRemount) {
      untrackFiberID(fiber);
      var isProfilingSupported = fiber.hasOwnProperty('treeBaseDuration');

      if (isProfilingSupported) {
        idToRootMap.delete(id);
        idToTreeBaseDurationMap.delete(id);
      }
    }
  }

  function mountFiberRecursively(firstChild, parentFiber, traverseSiblings, traceNearestHostComponentUpdate) {
    // Iterate over siblings rather than recursing.
    // This reduces the chance of stack overflow for wide trees (e.g. lists with many items).
    var fiber = firstChild;

    while (fiber !== null) {
      // Generate an ID even for filtered Fibers, in case it's needed later (e.g. for Profiling).
      getOrGenerateFiberID(fiber);

      if (__DEBUG__) {
        debug('mountFiberRecursively()', fiber, parentFiber);
      } // If we have the tree selection from previous reload, try to match this Fiber.
      // Also remember whether to do the same for siblings.


      var mightSiblingsBeOnTrackedPath = updateTrackedPathStateBeforeMount(fiber);
      var shouldIncludeInTree = !shouldFilterFiber(fiber);

      if (shouldIncludeInTree) {
        recordMount(fiber, parentFiber);
      }

      if (traceUpdatesEnabled) {
        if (traceNearestHostComponentUpdate) {
          var elementType = getElementTypeForFiber(fiber); // If an ancestor updated, we should mark the nearest host nodes for highlighting.

          if (elementType === ElementTypeHostComponent) {
            traceUpdatesForNodes.add(fiber.stateNode);
            traceNearestHostComponentUpdate = false;
          }
        } // We intentionally do not re-enable the traceNearestHostComponentUpdate flag in this branch,
        // because we don't want to highlight every host node inside of a newly mounted subtree.

      }

      var isSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent;

      if (isSuspense) {
        var isTimedOut = fiber.memoizedState !== null;

        if (isTimedOut) {
          // Special case: if Suspense mounts in a timed-out state,
          // get the fallback child from the inner fragment and mount
          // it as if it was our own child. Updates handle this too.
          var primaryChildFragment = fiber.child;
          var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
          var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

          if (fallbackChild !== null) {
            mountFiberRecursively(fallbackChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
          }
        } else {
          var primaryChild = null;
          var areSuspenseChildrenConditionallyWrapped = OffscreenComponent === -1;

          if (areSuspenseChildrenConditionallyWrapped) {
            primaryChild = fiber.child;
          } else if (fiber.child !== null) {
            primaryChild = fiber.child.child;
          }

          if (primaryChild !== null) {
            mountFiberRecursively(primaryChild, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
          }
        }
      } else {
        if (fiber.child !== null) {
          mountFiberRecursively(fiber.child, shouldIncludeInTree ? fiber : parentFiber, true, traceNearestHostComponentUpdate);
        }
      } // We're exiting this Fiber now, and entering its siblings.
      // If we have selection to restore, we might need to re-activate tracking.


      updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath);
      fiber = traverseSiblings ? fiber.sibling : null;
    }
  } // We use this to simulate unmounting for Suspense trees
  // when we switch from primary to fallback.


  function unmountFiberChildrenRecursively(fiber) {
    if (__DEBUG__) {
      debug('unmountFiberChildrenRecursively()', fiber);
    } // We might meet a nested Suspense on our way.


    var isTimedOutSuspense = fiber.tag === ReactTypeOfWork.SuspenseComponent && fiber.memoizedState !== null;
    var child = fiber.child;

    if (isTimedOutSuspense) {
      // If it's showing fallback tree, let's traverse it instead.
      var primaryChildFragment = fiber.child;
      var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null; // Skip over to the real Fiber child.

      child = fallbackChildFragment ? fallbackChildFragment.child : null;
    }

    while (child !== null) {
      // Record simulated unmounts children-first.
      // We skip nodes without return because those are real unmounts.
      if (child.return !== null) {
        unmountFiberChildrenRecursively(child);
        recordUnmount(child, true);
      }

      child = child.sibling;
    }
  }

  function recordProfilingDurations(fiber) {
    var id = getFiberIDThrows(fiber);
    var actualDuration = fiber.actualDuration,
        treeBaseDuration = fiber.treeBaseDuration;
    idToTreeBaseDurationMap.set(id, treeBaseDuration || 0);

    if (isProfiling) {
      var alternate = fiber.alternate; // It's important to update treeBaseDuration even if the current Fiber did not render,
      // because it's possible that one of its descendants did.

      if (alternate == null || treeBaseDuration !== alternate.treeBaseDuration) {
        // Tree base duration updates are included in the operations typed array.
        // So we have to convert them from milliseconds to microseconds so we can send them as ints.
        var convertedTreeBaseDuration = Math.floor((treeBaseDuration || 0) * 1000);
        pushOperation(TREE_OPERATION_UPDATE_TREE_BASE_DURATION);
        pushOperation(id);
        pushOperation(convertedTreeBaseDuration);
      }

      if (alternate == null || didFiberRender(alternate, fiber)) {
        if (actualDuration != null) {
          // The actual duration reported by React includes time spent working on children.
          // This is useful information, but it's also useful to be able to exclude child durations.
          // The frontend can't compute this, since the immediate children may have been filtered out.
          // So we need to do this on the backend.
          // Note that this calculated self duration is not the same thing as the base duration.
          // The two are calculated differently (tree duration does not accumulate).
          var selfDuration = actualDuration;
          var child = fiber.child;

          while (child !== null) {
            selfDuration -= child.actualDuration || 0;
            child = child.sibling;
          } // If profiling is active, store durations for elements that were rendered during the commit.
          // Note that we should do this for any fiber we performed work on, regardless of its actualDuration value.
          // In some cases actualDuration might be 0 for fibers we worked on (particularly if we're using Date.now)
          // In other cases (e.g. Memo) actualDuration might be greater than 0 even if we "bailed out".


          var metadata = currentCommitProfilingMetadata;
          metadata.durations.push(id, actualDuration, selfDuration);
          metadata.maxActualDuration = Math.max(metadata.maxActualDuration, actualDuration);

          if (recordChangeDescriptions) {
            var changeDescription = getChangeDescription(alternate, fiber);

            if (changeDescription !== null) {
              if (metadata.changeDescriptions !== null) {
                metadata.changeDescriptions.set(id, changeDescription);
              }
            }

            updateContextsForFiber(fiber);
          }
        }
      }
    }
  }

  function recordResetChildren(fiber, childSet) {
    if (__DEBUG__) {
      debug('recordResetChildren()', childSet, fiber);
    } // The frontend only really cares about the displayName, key, and children.
    // The first two don't really change, so we are only concerned with the order of children here.
    // This is trickier than a simple comparison though, since certain types of fibers are filtered.


    var nextChildren = []; // This is a naive implementation that shallowly recourses children.
    // We might want to revisit this if it proves to be too inefficient.

    var child = childSet;

    while (child !== null) {
      findReorderedChildrenRecursively(child, nextChildren);
      child = child.sibling;
    }

    var numChildren = nextChildren.length;

    if (numChildren < 2) {
      // No need to reorder.
      return;
    }

    pushOperation(TREE_OPERATION_REORDER_CHILDREN);
    pushOperation(getFiberIDThrows(fiber));
    pushOperation(numChildren);

    for (var i = 0; i < nextChildren.length; i++) {
      pushOperation(nextChildren[i]);
    }
  }

  function findReorderedChildrenRecursively(fiber, nextChildren) {
    if (!shouldFilterFiber(fiber)) {
      nextChildren.push(getFiberIDThrows(fiber));
    } else {
      var child = fiber.child;
      var isTimedOutSuspense = fiber.tag === SuspenseComponent && fiber.memoizedState !== null;

      if (isTimedOutSuspense) {
        // Special case: if Suspense mounts in a timed-out state,
        // get the fallback child from the inner fragment,
        // and skip over the primary child.
        var primaryChildFragment = fiber.child;
        var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;
        var fallbackChild = fallbackChildFragment ? fallbackChildFragment.child : null;

        if (fallbackChild !== null) {
          child = fallbackChild;
        }
      }

      while (child !== null) {
        findReorderedChildrenRecursively(child, nextChildren);
        child = child.sibling;
      }
    }
  } // Returns whether closest unfiltered fiber parent needs to reset its child list.


  function updateFiberRecursively(nextFiber, prevFiber, parentFiber, traceNearestHostComponentUpdate) {
    var id = getOrGenerateFiberID(nextFiber);

    if (__DEBUG__) {
      debug('updateFiberRecursively()', nextFiber, parentFiber);
    }

    if (traceUpdatesEnabled) {
      var elementType = getElementTypeForFiber(nextFiber);

      if (traceNearestHostComponentUpdate) {
        // If an ancestor updated, we should mark the nearest host nodes for highlighting.
        if (elementType === ElementTypeHostComponent) {
          traceUpdatesForNodes.add(nextFiber.stateNode);
          traceNearestHostComponentUpdate = false;
        }
      } else {
        if (elementType === ElementTypeFunction || elementType === ElementTypeClass || elementType === ElementTypeContext || elementType === ElementTypeMemo || elementType === ElementTypeForwardRef) {
          // Otherwise if this is a traced ancestor, flag for the nearest host descendant(s).
          traceNearestHostComponentUpdate = didFiberRender(prevFiber, nextFiber);
        }
      }
    }

    if (mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id && didFiberRender(prevFiber, nextFiber)) {
      // If this Fiber has updated, clear cached inspected data.
      // If it is inspected again, it may need to be re-run to obtain updated hooks values.
      hasElementUpdatedSinceLastInspected = true;
    }

    var shouldIncludeInTree = !shouldFilterFiber(nextFiber);
    var isSuspense = nextFiber.tag === SuspenseComponent;
    var shouldResetChildren = false; // The behavior of timed-out Suspense trees is unique.
    // Rather than unmount the timed out content (and possibly lose important state),
    // React re-parents this content within a hidden Fragment while the fallback is showing.
    // This behavior doesn't need to be observable in the DevTools though.
    // It might even result in a bad user experience for e.g. node selection in the Elements panel.
    // The easiest fix is to strip out the intermediate Fragment fibers,
    // so the Elements panel and Profiler don't need to special case them.
    // Suspense components only have a non-null memoizedState if they're timed-out.

    var prevDidTimeout = isSuspense && prevFiber.memoizedState !== null;
    var nextDidTimeOut = isSuspense && nextFiber.memoizedState !== null; // The logic below is inspired by the code paths in updateSuspenseComponent()
    // inside ReactFiberBeginWork in the React source code.

    if (prevDidTimeout && nextDidTimeOut) {
      // Fallback -> Fallback:
      // 1. Reconcile fallback set.
      var nextFiberChild = nextFiber.child;
      var nextFallbackChildSet = nextFiberChild ? nextFiberChild.sibling : null; // Note: We can't use nextFiber.child.sibling.alternate
      // because the set is special and alternate may not exist.

      var prevFiberChild = prevFiber.child;
      var prevFallbackChildSet = prevFiberChild ? prevFiberChild.sibling : null;

      if (nextFallbackChildSet != null && prevFallbackChildSet != null && updateFiberRecursively(nextFallbackChildSet, prevFallbackChildSet, nextFiber, traceNearestHostComponentUpdate)) {
        shouldResetChildren = true;
      }
    } else if (prevDidTimeout && !nextDidTimeOut) {
      // Fallback -> Primary:
      // 1. Unmount fallback set
      // Note: don't emulate fallback unmount because React actually did it.
      // 2. Mount primary set
      var nextPrimaryChildSet = nextFiber.child;

      if (nextPrimaryChildSet !== null) {
        mountFiberRecursively(nextPrimaryChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
      }

      shouldResetChildren = true;
    } else if (!prevDidTimeout && nextDidTimeOut) {
      // Primary -> Fallback:
      // 1. Hide primary set
      // This is not a real unmount, so it won't get reported by React.
      // We need to manually walk the previous tree and record unmounts.
      unmountFiberChildrenRecursively(prevFiber); // 2. Mount fallback set

      var _nextFiberChild = nextFiber.child;

      var _nextFallbackChildSet = _nextFiberChild ? _nextFiberChild.sibling : null;

      if (_nextFallbackChildSet != null) {
        mountFiberRecursively(_nextFallbackChildSet, shouldIncludeInTree ? nextFiber : parentFiber, true, traceNearestHostComponentUpdate);
        shouldResetChildren = true;
      }
    } else {
      // Common case: Primary -> Primary.
      // This is the same code path as for non-Suspense fibers.
      if (nextFiber.child !== prevFiber.child) {
        // If the first child is different, we need to traverse them.
        // Each next child will be either a new child (mount) or an alternate (update).
        var nextChild = nextFiber.child;
        var prevChildAtSameIndex = prevFiber.child;

        while (nextChild) {
          // We already know children will be referentially different because
          // they are either new mounts or alternates of previous children.
          // Schedule updates and mounts depending on whether alternates exist.
          // We don't track deletions here because they are reported separately.
          if (nextChild.alternate) {
            var prevChild = nextChild.alternate;

            if (updateFiberRecursively(nextChild, prevChild, shouldIncludeInTree ? nextFiber : parentFiber, traceNearestHostComponentUpdate)) {
              // If a nested tree child order changed but it can't handle its own
              // child order invalidation (e.g. because it's filtered out like host nodes),
              // propagate the need to reset child order upwards to this Fiber.
              shouldResetChildren = true;
            } // However we also keep track if the order of the children matches
            // the previous order. They are always different referentially, but
            // if the instances line up conceptually we'll want to know that.


            if (prevChild !== prevChildAtSameIndex) {
              shouldResetChildren = true;
            }
          } else {
            mountFiberRecursively(nextChild, shouldIncludeInTree ? nextFiber : parentFiber, false, traceNearestHostComponentUpdate);
            shouldResetChildren = true;
          } // Try the next child.


          nextChild = nextChild.sibling; // Advance the pointer in the previous list so that we can
          // keep comparing if they line up.

          if (!shouldResetChildren && prevChildAtSameIndex !== null) {
            prevChildAtSameIndex = prevChildAtSameIndex.sibling;
          }
        } // If we have no more children, but used to, they don't line up.


        if (prevChildAtSameIndex !== null) {
          shouldResetChildren = true;
        }
      } else {
        if (traceUpdatesEnabled) {
          // If we're tracing updates and we've bailed out before reaching a host node,
          // we should fall back to recursively marking the nearest host descendants for highlight.
          if (traceNearestHostComponentUpdate) {
            var hostFibers = findAllCurrentHostFibers(getFiberIDThrows(nextFiber));
            hostFibers.forEach(function (hostFiber) {
              traceUpdatesForNodes.add(hostFiber.stateNode);
            });
          }
        }
      }
    }

    if (shouldIncludeInTree) {
      var isProfilingSupported = nextFiber.hasOwnProperty('treeBaseDuration');

      if (isProfilingSupported) {
        recordProfilingDurations(nextFiber);
      }
    }

    if (shouldResetChildren) {
      // We need to crawl the subtree for closest non-filtered Fibers
      // so that we can display them in a flat children set.
      if (shouldIncludeInTree) {
        // Normally, search for children from the rendered child.
        var nextChildSet = nextFiber.child;

        if (nextDidTimeOut) {
          // Special case: timed-out Suspense renders the fallback set.
          var _nextFiberChild2 = nextFiber.child;
          nextChildSet = _nextFiberChild2 ? _nextFiberChild2.sibling : null;
        }

        if (nextChildSet != null) {
          recordResetChildren(nextFiber, nextChildSet);
        } // We've handled the child order change for this Fiber.
        // Since it's included, there's no need to invalidate parent child order.


        return false;
      } else {
        // Let the closest unfiltered parent Fiber reset its child order instead.
        return true;
      }
    } else {
      return false;
    }
  }

  function cleanup() {// We don't patch any methods so there is no cleanup.
  }

  function rootSupportsProfiling(root) {
    if (root.memoizedInteractions != null) {
      // v16 builds include this field for the scheduler/tracing API.
      return true;
    } else if (root.current != null && root.current.hasOwnProperty('treeBaseDuration')) {
      // The scheduler/tracing API was removed in v17 though
      // so we need to check a non-root Fiber.
      return true;
    } else {
      return false;
    }
  }

  function flushInitialOperations() {
    var localPendingOperationsQueue = pendingOperationsQueue;
    pendingOperationsQueue = null;

    if (localPendingOperationsQueue !== null && localPendingOperationsQueue.length > 0) {
      // We may have already queued up some operations before the frontend connected
      // If so, let the frontend know about them.
      localPendingOperationsQueue.forEach(function (operations) {
        hook.emit('operations', operations);
      });
    } else {
      // Before the traversals, remember to start tracking
      // our path in case we have selection to restore.
      if (trackedPath !== null) {
        mightBeOnTrackedPath = true;
      } // If we have not been profiling, then we can just walk the tree and build up its current state as-is.


      hook.getFiberRoots(rendererID).forEach(function (root) {
        currentRootID = getOrGenerateFiberID(root.current);
        setRootPseudoKey(currentRootID, root.current); // Handle multi-renderer edge-case where only some v16 renderers support profiling.

        if (isProfiling && rootSupportsProfiling(root)) {
          // If profiling is active, store commit time and duration.
          // The frontend may request this information after profiling has stopped.
          currentCommitProfilingMetadata = {
            changeDescriptions: recordChangeDescriptions ? new Map() : null,
            durations: [],
            commitTime: renderer_getCurrentTime() - profilingStartTime,
            maxActualDuration: 0,
            priorityLevel: null,
            updaters: getUpdatersList(root),
            effectDuration: null,
            passiveEffectDuration: null
          };
        }

        mountFiberRecursively(root.current, null, false, false);
        flushPendingEvents(root);
        currentRootID = -1;
      });
    }
  }

  function getUpdatersList(root) {
    return root.memoizedUpdaters != null ? Array.from(root.memoizedUpdaters).map(fiberToSerializedElement) : null;
  }

  function handleCommitFiberUnmount(fiber) {
    // This is not recursive.
    // We can't traverse fibers after unmounting so instead
    // we rely on React telling us about each unmount.
    recordUnmount(fiber, false);
  }

  function handlePostCommitFiberRoot(root) {
    if (isProfiling && rootSupportsProfiling(root)) {
      if (currentCommitProfilingMetadata !== null) {
        var _getEffectDurations = getEffectDurations(root),
            effectDuration = _getEffectDurations.effectDuration,
            passiveEffectDuration = _getEffectDurations.passiveEffectDuration;

        currentCommitProfilingMetadata.effectDuration = effectDuration;
        currentCommitProfilingMetadata.passiveEffectDuration = passiveEffectDuration;
      }
    }
  }

  function handleCommitFiberRoot(root, priorityLevel) {
    var current = root.current;
    var alternate = current.alternate; // Flush any pending Fibers that we are untracking before processing the new commit.
    // If we don't do this, we might end up double-deleting Fibers in some cases (like Legacy Suspense).

    untrackFibers();
    currentRootID = getOrGenerateFiberID(current); // Before the traversals, remember to start tracking
    // our path in case we have selection to restore.

    if (trackedPath !== null) {
      mightBeOnTrackedPath = true;
    }

    if (traceUpdatesEnabled) {
      traceUpdatesForNodes.clear();
    } // Handle multi-renderer edge-case where only some v16 renderers support profiling.


    var isProfilingSupported = rootSupportsProfiling(root);

    if (isProfiling && isProfilingSupported) {
      // If profiling is active, store commit time and duration.
      // The frontend may request this information after profiling has stopped.
      currentCommitProfilingMetadata = {
        changeDescriptions: recordChangeDescriptions ? new Map() : null,
        durations: [],
        commitTime: renderer_getCurrentTime() - profilingStartTime,
        maxActualDuration: 0,
        priorityLevel: priorityLevel == null ? null : formatPriorityLevel(priorityLevel),
        updaters: getUpdatersList(root),
        // Initialize to null; if new enough React version is running,
        // these values will be read during separate handlePostCommitFiberRoot() call.
        effectDuration: null,
        passiveEffectDuration: null
      };
    }

    if (alternate) {
      // TODO: relying on this seems a bit fishy.
      var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
      var isMounted = current.memoizedState != null && current.memoizedState.element != null;

      if (!wasMounted && isMounted) {
        // Mount a new root.
        setRootPseudoKey(currentRootID, current);
        mountFiberRecursively(current, null, false, false);
      } else if (wasMounted && isMounted) {
        // Update an existing root.
        updateFiberRecursively(current, alternate, null, false);
      } else if (wasMounted && !isMounted) {
        // Unmount an existing root.
        removeRootPseudoKey(currentRootID);
        recordUnmount(current, false);
      }
    } else {
      // Mount a new root.
      setRootPseudoKey(currentRootID, current);
      mountFiberRecursively(current, null, false, false);
    }

    if (isProfiling && isProfilingSupported) {
      var commitProfilingMetadata = rootToCommitProfilingMetadataMap.get(currentRootID);

      if (commitProfilingMetadata != null) {
        commitProfilingMetadata.push(currentCommitProfilingMetadata);
      } else {
        rootToCommitProfilingMetadataMap.set(currentRootID, [currentCommitProfilingMetadata]);
      }
    } // We're done here.


    flushPendingEvents(root);

    if (traceUpdatesEnabled) {
      hook.emit('traceUpdates', traceUpdatesForNodes);
    }

    currentRootID = -1;
  }

  function findAllCurrentHostFibers(id) {
    var fibers = [];
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (!fiber) {
      return fibers;
    } // Next we'll drill down this component to find all HostComponent/Text.


    var node = fiber;

    while (true) {
      if (node.tag === HostComponent || node.tag === HostText) {
        fibers.push(node);
      } else if (node.child) {
        node.child.return = node;
        node = node.child;
        continue;
      }

      if (node === fiber) {
        return fibers;
      }

      while (!node.sibling) {
        if (!node.return || node.return === fiber) {
          return fibers;
        }

        node = node.return;
      }

      node.sibling.return = node.return;
      node = node.sibling;
    } // Flow needs the return here, but ESLint complains about it.
    // eslint-disable-next-line no-unreachable


    return fibers;
  }

  function findNativeNodesForFiberID(id) {
    try {
      var _fiber3 = findCurrentFiberUsingSlowPathById(id);

      if (_fiber3 === null) {
        return null;
      } // Special case for a timed-out Suspense.


      var isTimedOutSuspense = _fiber3.tag === SuspenseComponent && _fiber3.memoizedState !== null;

      if (isTimedOutSuspense) {
        // A timed-out Suspense's findDOMNode is useless.
        // Try our best to find the fallback directly.
        var maybeFallbackFiber = _fiber3.child && _fiber3.child.sibling;

        if (maybeFallbackFiber != null) {
          _fiber3 = maybeFallbackFiber;
        }
      }

      var hostFibers = findAllCurrentHostFibers(id);
      return hostFibers.map(function (hostFiber) {
        return hostFiber.stateNode;
      }).filter(Boolean);
    } catch (err) {
      // The fiber might have unmounted by now.
      return null;
    }
  }

  function getDisplayNameForFiberID(id) {
    var fiber = idToArbitraryFiberMap.get(id);
    return fiber != null ? getDisplayNameForFiber(fiber) : null;
  }

  function getFiberIDForNative(hostInstance) {
    var findNearestUnfilteredAncestor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var fiber = renderer.findFiberByHostInstance(hostInstance);

    if (fiber != null) {
      if (findNearestUnfilteredAncestor) {
        while (fiber !== null && shouldFilterFiber(fiber)) {
          fiber = fiber.return;
        }
      }

      return getFiberIDThrows(fiber);
    }

    return null;
  }

  var MOUNTING = 1;
  var MOUNTED = 2;
  var UNMOUNTED = 3; // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js

  function isFiberMountedImpl(fiber) {
    var node = fiber;
    var prevNode = null;

    if (!fiber.alternate) {
      // If there is no alternate, this might be a new tree that isn't inserted
      // yet. If it is, then it will have a pending insertion effect on it.
      if ((getFiberFlags(node) & Placement) !== NoFlags) {
        return MOUNTING;
      } // This indicates an error during render.


      if ((getFiberFlags(node) & Incomplete) !== NoFlags) {
        return UNMOUNTED;
      }

      while (node.return) {
        prevNode = node;
        node = node.return;

        if ((getFiberFlags(node) & Placement) !== NoFlags) {
          return MOUNTING;
        } // This indicates an error during render.


        if ((getFiberFlags(node) & Incomplete) !== NoFlags) {
          return UNMOUNTED;
        } // If this node is inside of a timed out suspense subtree, we should also ignore errors/warnings.


        var isTimedOutSuspense = node.tag === SuspenseComponent && node.memoizedState !== null;

        if (isTimedOutSuspense) {
          // Note that this does not include errors/warnings in the Fallback tree though!
          var primaryChildFragment = node.child;
          var fallbackChildFragment = primaryChildFragment ? primaryChildFragment.sibling : null;

          if (prevNode !== fallbackChildFragment) {
            return UNMOUNTED;
          }
        }
      }
    } else {
      while (node.return) {
        node = node.return;
      }
    }

    if (node.tag === HostRoot) {
      // TODO: Check if this was a nested HostRoot when used with
      // renderContainerIntoSubtree.
      return MOUNTED;
    } // If we didn't hit the root, that means that we're in an disconnected tree
    // that has been unmounted.


    return UNMOUNTED;
  } // This function is copied from React and should be kept in sync:
  // https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberTreeReflection.js
  // It would be nice if we updated React to inject this function directly (vs just indirectly via findDOMNode).
  // BEGIN copied code


  function findCurrentFiberUsingSlowPathById(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return null;
    }

    var alternate = fiber.alternate;

    if (!alternate) {
      // If there is no alternate, then we only need to check if it is mounted.
      var state = isFiberMountedImpl(fiber);

      if (state === UNMOUNTED) {
        throw Error('Unable to find node on an unmounted component.');
      }

      if (state === MOUNTING) {
        return null;
      }

      return fiber;
    } // If we have two possible branches, we'll walk backwards up to the root
    // to see what path the root points to. On the way we may hit one of the
    // special cases and we'll deal with them.


    var a = fiber;
    var b = alternate;

    while (true) {
      var parentA = a.return;

      if (parentA === null) {
        // We're at the root.
        break;
      }

      var parentB = parentA.alternate;

      if (parentB === null) {
        // There is no alternate. This is an unusual case. Currently, it only
        // happens when a Suspense component is hidden. An extra fragment fiber
        // is inserted in between the Suspense fiber and its children. Skip
        // over this extra fragment fiber and proceed to the next parent.
        var nextParent = parentA.return;

        if (nextParent !== null) {
          a = b = nextParent;
          continue;
        } // If there's no parent, we're at the root.


        break;
      } // If both copies of the parent fiber point to the same child, we can
      // assume that the child is current. This happens when we bailout on low
      // priority: the bailed out fiber's child reuses the current child.


      if (parentA.child === parentB.child) {
        var child = parentA.child;

        while (child) {
          if (child === a) {
            // We've determined that A is the current branch.
            if (isFiberMountedImpl(parentA) !== MOUNTED) {
              throw Error('Unable to find node on an unmounted component.');
            }

            return fiber;
          }

          if (child === b) {
            // We've determined that B is the current branch.
            if (isFiberMountedImpl(parentA) !== MOUNTED) {
              throw Error('Unable to find node on an unmounted component.');
            }

            return alternate;
          }

          child = child.sibling;
        } // We should never have an alternate for any mounting node. So the only
        // way this could possibly happen is if this was unmounted, if at all.


        throw Error('Unable to find node on an unmounted component.');
      }

      if (a.return !== b.return) {
        // The return pointer of A and the return pointer of B point to different
        // fibers. We assume that return pointers never criss-cross, so A must
        // belong to the child set of A.return, and B must belong to the child
        // set of B.return.
        a = parentA;
        b = parentB;
      } else {
        // The return pointers point to the same fiber. We'll have to use the
        // default, slow path: scan the child sets of each parent alternate to see
        // which child belongs to which set.
        //
        // Search parent A's child set
        var didFindChild = false;
        var _child = parentA.child;

        while (_child) {
          if (_child === a) {
            didFindChild = true;
            a = parentA;
            b = parentB;
            break;
          }

          if (_child === b) {
            didFindChild = true;
            b = parentA;
            a = parentB;
            break;
          }

          _child = _child.sibling;
        }

        if (!didFindChild) {
          // Search parent B's child set
          _child = parentB.child;

          while (_child) {
            if (_child === a) {
              didFindChild = true;
              a = parentB;
              b = parentA;
              break;
            }

            if (_child === b) {
              didFindChild = true;
              b = parentB;
              a = parentA;
              break;
            }

            _child = _child.sibling;
          }

          if (!didFindChild) {
            throw Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');
          }
        }
      }

      if (a.alternate !== b) {
        throw Error("Return fibers should always be each others' alternates. " + 'This error is likely caused by a bug in React. Please file an issue.');
      }
    } // If the root is not a host container, we're in a disconnected tree. I.e.
    // unmounted.


    if (a.tag !== HostRoot) {
      throw Error('Unable to find node on an unmounted component.');
    }

    if (a.stateNode.current === a) {
      // We've determined that A is the current branch.
      return fiber;
    } // Otherwise B has to be current branch.


    return alternate;
  } // END copied code


  function prepareViewAttributeSource(id, path) {
    if (isMostRecentlyInspectedElement(id)) {
      window.$attribute = getInObject(mostRecentlyInspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var elementType = fiber.elementType,
        tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
      case FunctionComponent:
        global.$type = type;
        break;

      case ForwardRef:
        global.$type = type.render;
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$type = elementType != null && elementType.type != null ? elementType.type : type;
        break;

      default:
        global.$type = null;
        break;
    }
  }

  function fiberToSerializedElement(fiber) {
    return {
      displayName: getDisplayNameForFiber(fiber) || 'Anonymous',
      id: getFiberIDThrows(fiber),
      key: fiber.key,
      type: getElementTypeForFiber(fiber)
    };
  }

  function getOwnersList(id) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    var _debugOwner = fiber._debugOwner;
    var owners = [fiberToSerializedElement(fiber)];

    if (_debugOwner) {
      var owner = _debugOwner;

      while (owner !== null) {
        owners.unshift(fiberToSerializedElement(owner));
        owner = owner._debugOwner || null;
      }
    }

    return owners;
  } // Fast path props lookup for React Native style editor.
  // Could use inspectElementRaw() but that would require shallow rendering hooks components,
  // and could also mess with memoization.


  function getInstanceAndStyle(id) {
    var instance = null;
    var style = null;
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      instance = fiber.stateNode;

      if (fiber.memoizedProps !== null) {
        style = fiber.memoizedProps.style;
      }
    }

    return {
      instance: instance,
      style: style
    };
  }

  function isErrorBoundary(fiber) {
    var tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
        var instance = fiber.stateNode;
        return typeof type.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function';

      default:
        return false;
    }
  }

  function getNearestErrorBoundaryID(fiber) {
    var parent = fiber.return;

    while (parent !== null) {
      if (isErrorBoundary(parent)) {
        return getFiberIDUnsafe(parent);
      }

      parent = parent.return;
    }

    return null;
  }

  function inspectElementRaw(id) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber == null) {
      return null;
    }

    var _debugOwner = fiber._debugOwner,
        _debugSource = fiber._debugSource,
        stateNode = fiber.stateNode,
        key = fiber.key,
        memoizedProps = fiber.memoizedProps,
        memoizedState = fiber.memoizedState,
        dependencies = fiber.dependencies,
        tag = fiber.tag,
        type = fiber.type;
    var elementType = getElementTypeForFiber(fiber);
    var usesHooks = (tag === FunctionComponent || tag === SimpleMemoComponent || tag === ForwardRef) && (!!memoizedState || !!dependencies); // TODO Show custom UI for Cache like we do for Suspense
    // For now, just hide state data entirely since it's not meant to be inspected.

    var showState = !usesHooks && tag !== CacheComponent;
    var typeSymbol = getTypeSymbol(type);
    var canViewSource = false;
    var context = null;

    if (tag === ClassComponent || tag === FunctionComponent || tag === IncompleteClassComponent || tag === IndeterminateComponent || tag === MemoComponent || tag === ForwardRef || tag === SimpleMemoComponent) {
      canViewSource = true;

      if (stateNode && stateNode.context != null) {
        // Don't show an empty context object for class components that don't use the context API.
        var shouldHideContext = elementType === ElementTypeClass && !(type.contextTypes || type.contextType);

        if (!shouldHideContext) {
          context = stateNode.context;
        }
      }
    } else if (typeSymbol === CONTEXT_NUMBER || typeSymbol === CONTEXT_SYMBOL_STRING) {
      // 16.3-16.5 read from "type" because the Consumer is the actual context object.
      // 16.6+ should read from "type._context" because Consumer can be different (in DEV).
      // NOTE Keep in sync with getDisplayNameForFiber()
      var consumerResolvedContext = type._context || type; // Global context value.

      context = consumerResolvedContext._currentValue || null; // Look for overridden value.

      var _current = fiber.return;

      while (_current !== null) {
        var currentType = _current.type;
        var currentTypeSymbol = getTypeSymbol(currentType);

        if (currentTypeSymbol === PROVIDER_NUMBER || currentTypeSymbol === PROVIDER_SYMBOL_STRING) {
          // 16.3.0 exposed the context object as "context"
          // PR #12501 changed it to "_context" for 16.3.1+
          // NOTE Keep in sync with getDisplayNameForFiber()
          var providerResolvedContext = currentType._context || currentType.context;

          if (providerResolvedContext === consumerResolvedContext) {
            context = _current.memoizedProps.value;
            break;
          }
        }

        _current = _current.return;
      }
    }

    var hasLegacyContext = false;

    if (context !== null) {
      hasLegacyContext = !!type.contextTypes; // To simplify hydration and display logic for context, wrap in a value object.
      // Otherwise simple values (e.g. strings, booleans) become harder to handle.

      context = {
        value: context
      };
    }

    var owners = null;

    if (_debugOwner) {
      owners = [];
      var owner = _debugOwner;

      while (owner !== null) {
        owners.push(fiberToSerializedElement(owner));
        owner = owner._debugOwner || null;
      }
    }

    var isTimedOutSuspense = tag === SuspenseComponent && memoizedState !== null;
    var hooks = null;

    if (usesHooks) {
      var originalConsoleMethods = {}; // Temporarily disable all console logging before re-running the hook.

      for (var method in console) {
        try {
          originalConsoleMethods[method] = console[method]; // $FlowFixMe property error|warn is not writable.

          console[method] = function () {};
        } catch (error) {}
      }

      try {
        hooks = Object(react_debug_tools["inspectHooksOfFiber"])(fiber, renderer.currentDispatcherRef, true // Include source location info for hooks
        );
      } finally {
        // Restore original console functionality.
        for (var _method in originalConsoleMethods) {
          try {
            // $FlowFixMe property error|warn is not writable.
            console[_method] = originalConsoleMethods[_method];
          } catch (error) {}
        }
      }
    }

    var rootType = null;
    var current = fiber;

    while (current.return !== null) {
      current = current.return;
    }

    var fiberRoot = current.stateNode;

    if (fiberRoot != null && fiberRoot._debugRootType !== null) {
      rootType = fiberRoot._debugRootType;
    }

    var errors = fiberIDToErrorsMap.get(id) || new Map();
    var warnings = fiberIDToWarningsMap.get(id) || new Map();
    var isErrored = (fiber.flags & DidCapture) !== NoFlags || forceErrorForFiberIDs.get(id) === true;
    var targetErrorBoundaryID;

    if (isErrorBoundary(fiber)) {
      // if the current inspected element is an error boundary,
      // either that we want to use it to toggle off error state
      // or that we allow to force error state on it if it's within another
      // error boundary
      targetErrorBoundaryID = isErrored ? id : getNearestErrorBoundaryID(fiber);
    } else {
      targetErrorBoundaryID = getNearestErrorBoundaryID(fiber);
    }

    return {
      id: id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: typeof overrideHookState === 'function',
      canEditFunctionProps: typeof overrideProps === 'function',
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: typeof overrideHookStateDeletePath === 'function',
      canEditHooksAndRenamePaths: typeof overrideHookStateRenamePath === 'function',
      canEditFunctionPropsDeletePaths: typeof overridePropsDeletePath === 'function',
      canEditFunctionPropsRenamePaths: typeof overridePropsRenamePath === 'function',
      canToggleError: supportsTogglingError && targetErrorBoundaryID != null,
      // Is this error boundary in error state.
      isErrored: isErrored,
      targetErrorBoundaryID: targetErrorBoundaryID,
      canToggleSuspense: supportsTogglingSuspense && ( // If it's showing the real content, we can always flip fallback.
      !isTimedOutSuspense || // If it's showing fallback because we previously forced it to,
      // allow toggling it back to remove the fallback override.
      forceFallbackForSuspenseIDs.has(id)),
      // Can view component source location.
      canViewSource: canViewSource,
      // Does the component have legacy context attached to it.
      hasLegacyContext: hasLegacyContext,
      key: key != null ? key : null,
      displayName: getDisplayNameForFiber(fiber),
      type: elementType,
      // Inspectable properties.
      // TODO Review sanitization approach for the below inspectable values.
      context: context,
      hooks: hooks,
      props: memoizedProps,
      state: showState ? memoizedState : null,
      errors: Array.from(errors.entries()),
      warnings: Array.from(warnings.entries()),
      // List of owners
      owners: owners,
      // Location of component in source code.
      source: _debugSource || null,
      rootType: rootType,
      rendererPackageName: renderer.rendererPackageName,
      rendererVersion: renderer.version
    };
  }

  var mostRecentlyInspectedElement = null;
  var hasElementUpdatedSinceLastInspected = false;
  var currentlyInspectedPaths = {};

  function isMostRecentlyInspectedElement(id) {
    return mostRecentlyInspectedElement !== null && mostRecentlyInspectedElement.id === id;
  }

  function isMostRecentlyInspectedElementCurrent(id) {
    return isMostRecentlyInspectedElement(id) && !hasElementUpdatedSinceLastInspected;
  } // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.


  function mergeInspectedPaths(path) {
    var current = currentlyInspectedPaths;
    path.forEach(function (key) {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key, secondaryCategory) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      switch (secondaryCategory) {
        case 'hooks':
          if (path.length === 1) {
            // Never dehydrate the "hooks" object at the top levels.
            return true;
          }

          if (path[path.length - 2] === 'hookSource' && path[path.length - 1] === 'fileName') {
            // It's important to preserve the full file name (URL) for hook sources
            // in case the user has enabled the named hooks feature.
            // Otherwise the frontend may end up with a partial URL which it can't load.
            return true;
          }

          if (path[path.length - 1] === 'subHooks' || path[path.length - 2] === 'subHooks') {
            // Dehydrating the 'subHooks' property makes the HooksTree UI a lot more complicated,
            // so it's easiest for now if we just don't break on this boundary.
            // We can always dehydrate a level deeper (in the value object).
            return true;
          }

          break;

        default:
          break;
      }

      var current = key === null ? currentlyInspectedPaths : currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (var i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  }

  function updateSelectedElement(inspectedElement) {
    var hooks = inspectedElement.hooks,
        id = inspectedElement.id,
        props = inspectedElement.props;
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var elementType = fiber.elementType,
        stateNode = fiber.stateNode,
        tag = fiber.tag,
        type = fiber.type;

    switch (tag) {
      case ClassComponent:
      case IncompleteClassComponent:
      case IndeterminateComponent:
        global.$r = stateNode;
        break;

      case FunctionComponent:
        global.$r = {
          hooks: hooks,
          props: props,
          type: type
        };
        break;

      case ForwardRef:
        global.$r = {
          hooks: hooks,
          props: props,
          type: type.render
        };
        break;

      case MemoComponent:
      case SimpleMemoComponent:
        global.$r = {
          hooks: hooks,
          props: props,
          type: elementType != null && elementType.type != null ? elementType.type : type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    if (isMostRecentlyInspectedElement(id)) {
      var value = getInObject(mostRecentlyInspectedElement, path);
      var key = "$reactTemp".concat(count);
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function copyElementPath(id, path) {
    if (isMostRecentlyInspectedElement(id)) {
      copyToClipboard(getInObject(mostRecentlyInspectedElement, path));
    }
  }

  function inspectElement(requestID, id, path) {
    if (path !== null) {
      mergeInspectedPaths(path);
    }

    if (isMostRecentlyInspectedElement(id)) {
      if (!hasElementUpdatedSinceLastInspected) {
        if (path !== null) {
          var secondaryCategory = null;

          if (path[0] === 'hooks') {
            secondaryCategory = 'hooks';
          } // If this element has not been updated since it was last inspected,
          // we can just return the subset of data in the newly-inspected path.


          return {
            id: id,
            responseID: requestID,
            type: 'hydrated-path',
            path: path,
            value: cleanForBridge(getInObject(mostRecentlyInspectedElement, path), createIsPathAllowed(null, secondaryCategory), path)
          };
        } else {
          // If this element has not been updated since it was last inspected, we don't need to return it.
          // Instead we can just return the ID to indicate that it has not changed.
          return {
            id: id,
            responseID: requestID,
            type: 'no-change'
          };
        }
      }
    } else {
      currentlyInspectedPaths = {};
    }

    hasElementUpdatedSinceLastInspected = false;
    mostRecentlyInspectedElement = inspectElementRaw(id);

    if (mostRecentlyInspectedElement === null) {
      return {
        id: id,
        responseID: requestID,
        type: 'not-found'
      };
    } // Any time an inspected element has an update,
    // we should update the selected $r value as wel.
    // Do this before dehydration (cleanForBridge).


    updateSelectedElement(mostRecentlyInspectedElement); // Clone before cleaning so that we preserve the full data.
    // This will enable us to send patches without re-inspecting if hydrated paths are requested.
    // (Reducing how often we shallow-render is a better DX for function components that use hooks.)

    var cleanedInspectedElement = renderer_objectSpread({}, mostRecentlyInspectedElement);

    cleanedInspectedElement.context = cleanForBridge(cleanedInspectedElement.context, createIsPathAllowed('context', null));
    cleanedInspectedElement.hooks = cleanForBridge(cleanedInspectedElement.hooks, createIsPathAllowed('hooks', 'hooks'));
    cleanedInspectedElement.props = cleanForBridge(cleanedInspectedElement.props, createIsPathAllowed('props', null));
    cleanedInspectedElement.state = cleanForBridge(cleanedInspectedElement.state, createIsPathAllowed('state', null));
    return {
      id: id,
      responseID: requestID,
      type: 'full-data',
      value: cleanedInspectedElement
    };
  }

  function logElementToConsole(id) {
    var result = isMostRecentlyInspectedElementCurrent(id) ? mostRecentlyInspectedElement : inspectElementRaw(id);

    if (result === null) {
      console.warn("Could not find Fiber with id \"".concat(id, "\""));
      return;
    }

    var supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed("[Click to expand] %c<".concat(result.displayName || 'Component', " />"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.hooks !== null) {
      console.log('Hooks:', result.hooks);
    }

    var nativeNodes = findNativeNodesForFiberID(id);

    if (nativeNodes !== null) {
      console.log('Nodes:', nativeNodes);
    }

    if (result.source !== null) {
      console.log('Location:', result.source);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function deletePath(type, id, hookID, path) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {// Simple context value (noop)
              } else {
                deletePathInObject(instance.context, path);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateDeletePath === 'function') {
            overrideHookStateDeletePath(fiber, hookID, path);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsDeletePath === 'function') {
              overridePropsDeletePath(fiber, path);
            }
          } else {
            fiber.pendingProps = copyWithDelete(instance.props, path);
            instance.forceUpdate();
          }

          break;

        case 'state':
          deletePathInObject(instance.state, path);
          instance.forceUpdate();
          break;
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          oldPath = oldPath.slice(1);
          newPath = newPath.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (oldPath.length === 0) {// Simple context value (noop)
              } else {
                renamePathInObject(instance.context, oldPath, newPath);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookStateRenamePath === 'function') {
            overrideHookStateRenamePath(fiber, hookID, oldPath, newPath);
          }

          break;

        case 'props':
          if (instance === null) {
            if (typeof overridePropsRenamePath === 'function') {
              overridePropsRenamePath(fiber, oldPath, newPath);
            }
          } else {
            fiber.pendingProps = copyWithRename(instance.props, oldPath, newPath);
            instance.forceUpdate();
          }

          break;

        case 'state':
          renamePathInObject(instance.state, oldPath, newPath);
          instance.forceUpdate();
          break;
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    var fiber = findCurrentFiberUsingSlowPathById(id);

    if (fiber !== null) {
      var instance = fiber.stateNode;

      switch (type) {
        case 'context':
          // To simplify hydration and display of primitive context values (e.g. number, string)
          // the inspectElement() method wraps context in a {value: ...} object.
          // We need to remove the first part of the path (the "value") before continuing.
          path = path.slice(1);

          switch (fiber.tag) {
            case ClassComponent:
              if (path.length === 0) {
                // Simple context value
                instance.context = value;
              } else {
                setInObject(instance.context, path, value);
              }

              instance.forceUpdate();
              break;

            case FunctionComponent:
              // Function components using legacy context are not editable
              // because there's no instance on which to create a cloned, mutated context.
              break;
          }

          break;

        case 'hooks':
          if (typeof overrideHookState === 'function') {
            overrideHookState(fiber, hookID, path, value);
          }

          break;

        case 'props':
          switch (fiber.tag) {
            case ClassComponent:
              fiber.pendingProps = copyWithSet(instance.props, path, value);
              instance.forceUpdate();
              break;

            default:
              if (typeof overrideProps === 'function') {
                overrideProps(fiber, path, value);
              }

              break;
          }

          break;

        case 'state':
          switch (fiber.tag) {
            case ClassComponent:
              setInObject(instance.state, path, value);
              instance.forceUpdate();
              break;
          }

          break;
      }
    }
  }

  var currentCommitProfilingMetadata = null;
  var displayNamesByRootID = null;
  var idToContextsMap = null;
  var initialTreeBaseDurationsMap = null;
  var initialIDToRootMap = null;
  var isProfiling = false;
  var profilingStartTime = 0;
  var recordChangeDescriptions = false;
  var rootToCommitProfilingMetadataMap = null;

  function getProfilingData() {
    var dataForRoots = [];

    if (rootToCommitProfilingMetadataMap === null) {
      throw Error('getProfilingData() called before any profiling data was recorded');
    }

    rootToCommitProfilingMetadataMap.forEach(function (commitProfilingMetadata, rootID) {
      var commitData = [];
      var initialTreeBaseDurations = [];
      var displayName = displayNamesByRootID !== null && displayNamesByRootID.get(rootID) || 'Unknown';

      if (initialTreeBaseDurationsMap != null) {
        initialTreeBaseDurationsMap.forEach(function (treeBaseDuration, id) {
          if (initialIDToRootMap != null && initialIDToRootMap.get(id) === rootID) {
            // We don't need to convert milliseconds to microseconds in this case,
            // because the profiling summary is JSON serialized.
            initialTreeBaseDurations.push([id, treeBaseDuration]);
          }
        });
      }

      commitProfilingMetadata.forEach(function (commitProfilingData, commitIndex) {
        var changeDescriptions = commitProfilingData.changeDescriptions,
            durations = commitProfilingData.durations,
            effectDuration = commitProfilingData.effectDuration,
            maxActualDuration = commitProfilingData.maxActualDuration,
            passiveEffectDuration = commitProfilingData.passiveEffectDuration,
            priorityLevel = commitProfilingData.priorityLevel,
            commitTime = commitProfilingData.commitTime,
            updaters = commitProfilingData.updaters;
        var fiberActualDurations = [];
        var fiberSelfDurations = [];

        for (var i = 0; i < durations.length; i += 3) {
          var fiberID = durations[i];
          fiberActualDurations.push([fiberID, durations[i + 1]]);
          fiberSelfDurations.push([fiberID, durations[i + 2]]);
        }

        commitData.push({
          changeDescriptions: changeDescriptions !== null ? Array.from(changeDescriptions.entries()) : null,
          duration: maxActualDuration,
          effectDuration: effectDuration,
          fiberActualDurations: fiberActualDurations,
          fiberSelfDurations: fiberSelfDurations,
          passiveEffectDuration: passiveEffectDuration,
          priorityLevel: priorityLevel,
          timestamp: commitTime,
          updaters: updaters
        });
      });
      dataForRoots.push({
        commitData: commitData,
        displayName: displayName,
        initialTreeBaseDurations: initialTreeBaseDurations,
        rootID: rootID
      });
    });
    return {
      dataForRoots: dataForRoots,
      rendererID: rendererID
    };
  }

  function startProfiling(shouldRecordChangeDescriptions) {
    if (isProfiling) {
      return;
    }

    recordChangeDescriptions = shouldRecordChangeDescriptions; // Capture initial values as of the time profiling starts.
    // It's important we snapshot both the durations and the id-to-root map,
    // since either of these may change during the profiling session
    // (e.g. when a fiber is re-rendered or when a fiber gets removed).

    displayNamesByRootID = new Map();
    initialTreeBaseDurationsMap = new Map(idToTreeBaseDurationMap);
    initialIDToRootMap = new Map(idToRootMap);
    idToContextsMap = new Map();
    hook.getFiberRoots(rendererID).forEach(function (root) {
      var rootID = getFiberIDThrows(root.current);
      displayNamesByRootID.set(rootID, getDisplayNameForRoot(root.current));

      if (shouldRecordChangeDescriptions) {
        // Record all contexts at the time profiling is started.
        // Fibers only store the current context value,
        // so we need to track them separately in order to determine changed keys.
        crawlToInitializeContextsMap(root.current);
      }
    });
    isProfiling = true;
    profilingStartTime = renderer_getCurrentTime();
    rootToCommitProfilingMetadataMap = new Map();
  }

  function stopProfiling() {
    isProfiling = false;
    recordChangeDescriptions = false;
  } // Automatically start profiling so that we don't miss timing info from initial "mount".


  if (sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === 'true') {
    startProfiling(sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true');
  } // React will switch between these implementations depending on whether
  // we have any manually suspended/errored-out Fibers or not.


  function shouldErrorFiberAlwaysNull() {
    return null;
  } // Map of id and its force error status: true (error), false (toggled off),
  // null (do nothing)


  var forceErrorForFiberIDs = new Map();

  function shouldErrorFiberAccordingToMap(fiber) {
    if (typeof setErrorHandler !== 'function') {
      throw new Error('Expected overrideError() to not get called for earlier React versions.');
    }

    var id = getFiberIDUnsafe(fiber);

    if (id === null) {
      return null;
    }

    var status = null;

    if (forceErrorForFiberIDs.has(id)) {
      status = forceErrorForFiberIDs.get(id);

      if (status === false) {
        // TRICKY overrideError adds entries to this Map,
        // so ideally it would be the method that clears them too,
        // but that would break the functionality of the feature,
        // since DevTools needs to tell React to act differently than it normally would
        // (don't just re-render the failed boundary, but reset its errored state too).
        // So we can only clear it after telling React to reset the state.
        // Technically this is premature and we should schedule it for later,
        // since the render could always fail without committing the updated error boundary,
        // but since this is a DEV-only feature, the simplicity is worth the trade off.
        forceErrorForFiberIDs.delete(id);

        if (forceErrorForFiberIDs.size === 0) {
          // Last override is gone. Switch React back to fast path.
          setErrorHandler(shouldErrorFiberAlwaysNull);
        }
      }
    }

    return status;
  }

  function overrideError(id, forceError) {
    if (typeof setErrorHandler !== 'function' || typeof scheduleUpdate !== 'function') {
      throw new Error('Expected overrideError() to not get called for earlier React versions.');
    }

    forceErrorForFiberIDs.set(id, forceError);

    if (forceErrorForFiberIDs.size === 1) {
      // First override is added. Switch React to slower path.
      setErrorHandler(shouldErrorFiberAccordingToMap);
    }

    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber != null) {
      scheduleUpdate(fiber);
    }
  }

  function shouldSuspendFiberAlwaysFalse() {
    return false;
  }

  var forceFallbackForSuspenseIDs = new Set();

  function shouldSuspendFiberAccordingToSet(fiber) {
    var maybeID = getFiberIDUnsafe(fiber);
    return maybeID !== null && forceFallbackForSuspenseIDs.has(maybeID);
  }

  function overrideSuspense(id, forceFallback) {
    if (typeof setSuspenseHandler !== 'function' || typeof scheduleUpdate !== 'function') {
      throw new Error('Expected overrideSuspense() to not get called for earlier React versions.');
    }

    if (forceFallback) {
      forceFallbackForSuspenseIDs.add(id);

      if (forceFallbackForSuspenseIDs.size === 1) {
        // First override is added. Switch React to slower path.
        setSuspenseHandler(shouldSuspendFiberAccordingToSet);
      }
    } else {
      forceFallbackForSuspenseIDs.delete(id);

      if (forceFallbackForSuspenseIDs.size === 0) {
        // Last override is gone. Switch React back to fast path.
        setSuspenseHandler(shouldSuspendFiberAlwaysFalse);
      }
    }

    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber != null) {
      scheduleUpdate(fiber);
    }
  } // Remember if we're trying to restore the selection after reload.
  // In that case, we'll do some extra checks for matching mounts.


  var trackedPath = null;
  var trackedPathMatchFiber = null;
  var trackedPathMatchDepth = -1;
  var mightBeOnTrackedPath = false;

  function setTrackedPath(path) {
    if (path === null) {
      trackedPathMatchFiber = null;
      trackedPathMatchDepth = -1;
      mightBeOnTrackedPath = false;
    }

    trackedPath = path;
  } // We call this before traversing a new mount.
  // It remembers whether this Fiber is the next best match for tracked path.
  // The return value signals whether we should keep matching siblings or not.


  function updateTrackedPathStateBeforeMount(fiber) {
    if (trackedPath === null || !mightBeOnTrackedPath) {
      // Fast path: there's nothing to track so do nothing and ignore siblings.
      return false;
    }

    var returnFiber = fiber.return;
    var returnAlternate = returnFiber !== null ? returnFiber.alternate : null; // By now we know there's some selection to restore, and this is a new Fiber.
    // Is this newly mounted Fiber a direct child of the current best match?
    // (This will also be true for new roots if we haven't matched anything yet.)

    if (trackedPathMatchFiber === returnFiber || trackedPathMatchFiber === returnAlternate && returnAlternate !== null) {
      // Is this the next Fiber we should select? Let's compare the frames.
      var actualFrame = getPathFrame(fiber);
      var expectedFrame = trackedPath[trackedPathMatchDepth + 1];

      if (expectedFrame === undefined) {
        throw new Error('Expected to see a frame at the next depth.');
      }

      if (actualFrame.index === expectedFrame.index && actualFrame.key === expectedFrame.key && actualFrame.displayName === expectedFrame.displayName) {
        // We have our next match.
        trackedPathMatchFiber = fiber;
        trackedPathMatchDepth++; // Are we out of frames to match?

        if (trackedPathMatchDepth === trackedPath.length - 1) {
          // There's nothing that can possibly match afterwards.
          // Don't check the children.
          mightBeOnTrackedPath = false;
        } else {
          // Check the children, as they might reveal the next match.
          mightBeOnTrackedPath = true;
        } // In either case, since we have a match, we don't need
        // to check the siblings. They'll never match.


        return false;
      }
    } // This Fiber's parent is on the path, but this Fiber itself isn't.
    // There's no need to check its children--they won't be on the path either.


    mightBeOnTrackedPath = false; // However, one of its siblings may be on the path so keep searching.

    return true;
  }

  function updateTrackedPathStateAfterMount(mightSiblingsBeOnTrackedPath) {
    // updateTrackedPathStateBeforeMount() told us whether to match siblings.
    // Now that we're entering siblings, let's use that information.
    mightBeOnTrackedPath = mightSiblingsBeOnTrackedPath;
  } // Roots don't have a real persistent identity.
  // A root's "pseudo key" is "childDisplayName:indexWithThatName".
  // For example, "App:0" or, in case of similar roots, "Story:0", "Story:1", etc.
  // We will use this to try to disambiguate roots when restoring selection between reloads.


  var rootPseudoKeys = new Map();
  var rootDisplayNameCounter = new Map();

  function setRootPseudoKey(id, fiber) {
    var name = getDisplayNameForRoot(fiber);
    var counter = rootDisplayNameCounter.get(name) || 0;
    rootDisplayNameCounter.set(name, counter + 1);
    var pseudoKey = "".concat(name, ":").concat(counter);
    rootPseudoKeys.set(id, pseudoKey);
  }

  function removeRootPseudoKey(id) {
    var pseudoKey = rootPseudoKeys.get(id);

    if (pseudoKey === undefined) {
      throw new Error('Expected root pseudo key to be known.');
    }

    var name = pseudoKey.substring(0, pseudoKey.lastIndexOf(':'));
    var counter = rootDisplayNameCounter.get(name);

    if (counter === undefined) {
      throw new Error('Expected counter to be known.');
    }

    if (counter > 1) {
      rootDisplayNameCounter.set(name, counter - 1);
    } else {
      rootDisplayNameCounter.delete(name);
    }

    rootPseudoKeys.delete(id);
  }

  function getDisplayNameForRoot(fiber) {
    var preferredDisplayName = null;
    var fallbackDisplayName = null;
    var child = fiber.child; // Go at most three levels deep into direct children
    // while searching for a child that has a displayName.

    for (var i = 0; i < 3; i++) {
      if (child === null) {
        break;
      }

      var displayName = getDisplayNameForFiber(child);

      if (displayName !== null) {
        // Prefer display names that we get from user-defined components.
        // We want to avoid using e.g. 'Suspense' unless we find nothing else.
        if (typeof child.type === 'function') {
          // There's a few user-defined tags, but we'll prefer the ones
          // that are usually explicitly named (function or class components).
          preferredDisplayName = displayName;
        } else if (fallbackDisplayName === null) {
          fallbackDisplayName = displayName;
        }
      }

      if (preferredDisplayName !== null) {
        break;
      }

      child = child.child;
    }

    return preferredDisplayName || fallbackDisplayName || 'Anonymous';
  }

  function getPathFrame(fiber) {
    var key = fiber.key;
    var displayName = getDisplayNameForFiber(fiber);
    var index = fiber.index;

    switch (fiber.tag) {
      case HostRoot:
        // Roots don't have a real displayName, index, or key.
        // Instead, we'll use the pseudo key (childDisplayName:indexWithThatName).
        var id = getFiberIDThrows(fiber);
        var pseudoKey = rootPseudoKeys.get(id);

        if (pseudoKey === undefined) {
          throw new Error('Expected mounted root to have known pseudo key.');
        }

        displayName = pseudoKey;
        break;

      case HostComponent:
        displayName = fiber.type;
        break;

      default:
        break;
    }

    return {
      displayName: displayName,
      key: key,
      index: index
    };
  } // Produces a serializable representation that does a best effort
  // of identifying a particular Fiber between page reloads.
  // The return path will contain Fibers that are "invisible" to the store
  // because their keys and indexes are important to restoring the selection.


  function getPathForElement(id) {
    var fiber = idToArbitraryFiberMap.get(id);

    if (fiber == null) {
      return null;
    }

    var keyPath = [];

    while (fiber !== null) {
      keyPath.push(getPathFrame(fiber));
      fiber = fiber.return;
    }

    keyPath.reverse();
    return keyPath;
  }

  function getBestMatchForTrackedPath() {
    if (trackedPath === null) {
      // Nothing to match.
      return null;
    }

    if (trackedPathMatchFiber === null) {
      // We didn't find anything.
      return null;
    } // Find the closest Fiber store is aware of.


    var fiber = trackedPathMatchFiber;

    while (fiber !== null && shouldFilterFiber(fiber)) {
      fiber = fiber.return;
    }

    if (fiber === null) {
      return null;
    }

    return {
      id: getFiberIDThrows(fiber),
      isFullMatch: trackedPathMatchDepth === trackedPath.length - 1
    };
  }

  var formatPriorityLevel = function formatPriorityLevel(priorityLevel) {
    if (priorityLevel == null) {
      return 'Unknown';
    }

    switch (priorityLevel) {
      case ImmediatePriority:
        return 'Immediate';

      case UserBlockingPriority:
        return 'User-Blocking';

      case NormalPriority:
        return 'Normal';

      case LowPriority:
        return 'Low';

      case IdlePriority:
        return 'Idle';

      case NoPriority:
      default:
        return 'Unknown';
    }
  };

  function setTraceUpdatesEnabled(isEnabled) {
    traceUpdatesEnabled = isEnabled;
  }

  return {
    cleanup: cleanup,
    clearErrorsAndWarnings: clearErrorsAndWarnings,
    clearErrorsForFiberID: clearErrorsForFiberID,
    clearWarningsForFiberID: clearWarningsForFiberID,
    copyElementPath: copyElementPath,
    deletePath: deletePath,
    findNativeNodesForFiberID: findNativeNodesForFiberID,
    flushInitialOperations: flushInitialOperations,
    getBestMatchForTrackedPath: getBestMatchForTrackedPath,
    getDisplayNameForFiberID: getDisplayNameForFiberID,
    getFiberIDForNative: getFiberIDForNative,
    getInstanceAndStyle: getInstanceAndStyle,
    getOwnersList: getOwnersList,
    getPathForElement: getPathForElement,
    getProfilingData: getProfilingData,
    handleCommitFiberRoot: handleCommitFiberRoot,
    handleCommitFiberUnmount: handleCommitFiberUnmount,
    handlePostCommitFiberRoot: handlePostCommitFiberRoot,
    inspectElement: inspectElement,
    logElementToConsole: logElementToConsole,
    prepareViewAttributeSource: prepareViewAttributeSource,
    prepareViewElementSource: prepareViewElementSource,
    overrideError: overrideError,
    overrideSuspense: overrideSuspense,
    overrideValueAtPath: overrideValueAtPath,
    renamePath: renamePath,
    renderer: renderer,
    setTraceUpdatesEnabled: setTraceUpdatesEnabled,
    setTrackedPath: setTrackedPath,
    startProfiling: startProfiling,
    stopProfiling: stopProfiling,
    storeAsGlobal: storeAsGlobal,
    updateComponentFilters: updateComponentFilters
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsConsolePatching.js
function DevToolsConsolePatching_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function DevToolsConsolePatching_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { DevToolsConsolePatching_ownKeys(Object(source), true).forEach(function (key) { DevToolsConsolePatching_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { DevToolsConsolePatching_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function DevToolsConsolePatching_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of shared/ConsolePatchingDev.
// The shared console patching code is DEV-only.
// We can't use it since DevTools only ships production builds.
// Helpers to patch console.logs to avoid logging during side-effect free
// replaying on render function. This currently only patches the object
// lazily which won't cover if the log function was extracted eagerly.
// We could also eagerly patch the method.
var disabledDepth = 0;
var prevLog;
var prevInfo;
var prevWarn;
var prevError;
var prevGroup;
var prevGroupCollapsed;
var prevGroupEnd;

function disabledLog() {}

disabledLog.__reactDisabledLog = true;
function disableLogs() {
  if (disabledDepth === 0) {
    /* eslint-disable react-internal/no-production-logging */
    prevLog = console.log;
    prevInfo = console.info;
    prevWarn = console.warn;
    prevError = console.error;
    prevGroup = console.group;
    prevGroupCollapsed = console.groupCollapsed;
    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099

    var props = {
      configurable: true,
      enumerable: true,
      value: disabledLog,
      writable: true
    }; // $FlowFixMe Flow thinks console is immutable.

    Object.defineProperties(console, {
      info: props,
      log: props,
      warn: props,
      error: props,
      group: props,
      groupCollapsed: props,
      groupEnd: props
    });
    /* eslint-enable react-internal/no-production-logging */
  }

  disabledDepth++;
}
function reenableLogs() {
  disabledDepth--;

  if (disabledDepth === 0) {
    /* eslint-disable react-internal/no-production-logging */
    var props = {
      configurable: true,
      enumerable: true,
      writable: true
    }; // $FlowFixMe Flow thinks console is immutable.

    Object.defineProperties(console, {
      log: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
        value: prevLog
      }),
      info: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
        value: prevInfo
      }),
      warn: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
        value: prevWarn
      }),
      error: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
        value: prevError
      }),
      group: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
        value: prevGroup
      }),
      groupCollapsed: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
        value: prevGroupCollapsed
      }),
      groupEnd: DevToolsConsolePatching_objectSpread(DevToolsConsolePatching_objectSpread({}, props), {}, {
        value: prevGroupEnd
      })
    });
    /* eslint-enable react-internal/no-production-logging */
  }

  if (disabledDepth < 0) {
    console.error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsComponentStackFrame.js
function DevToolsComponentStackFrame_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { DevToolsComponentStackFrame_typeof = function _typeof(obj) { return typeof obj; }; } else { DevToolsComponentStackFrame_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return DevToolsComponentStackFrame_typeof(obj); }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactComponentStackFrame.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).
 // The shared console patching code is DEV-only.
// We can't use it since DevTools only ships production builds.


var prefix;
function describeBuiltInComponentFrame(name, source, ownerFn) {
  if (prefix === undefined) {
    // Extract the VM specific prefix used by each line.
    try {
      throw Error();
    } catch (x) {
      var match = x.stack.trim().match(/\n( *(at )?)/);
      prefix = match && match[1] || '';
    }
  } // We use the prefix to ensure our stacks line up with native stack frames.


  return '\n' + prefix + name;
}
var reentry = false;
var componentFrameCache;

if (false) { var PossiblyWeakMap; }

function describeNativeComponentFrame(fn, construct, currentDispatcherRef) {
  // If something asked for a stack inside a fake render, it should get ignored.
  if (!fn || reentry) {
    return '';
  }

  if (false) { var frame; }

  var control;
  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.

  Error.prepareStackTrace = undefined;
  reentry = true; // Override the dispatcher so effects scheduled by this shallow render are thrown away.
  //
  // Note that unlike the code this was forked from (in ReactComponentStackFrame)
  // DevTools should override the dispatcher even when DevTools is compiled in production mode,
  // because the app itself may be in development mode and log errors/warnings.

  var previousDispatcher = currentDispatcherRef.current;
  currentDispatcherRef.current = null;
  disableLogs();

  try {
    // This should throw.
    if (construct) {
      // Something should be setting the props in the constructor.
      var Fake = function Fake() {
        throw Error();
      }; // $FlowFixMe


      Object.defineProperty(Fake.prototype, 'props', {
        set: function set() {
          // We use a throwing setter instead of frozen or non-writable props
          // because that won't throw in a non-strict mode function.
          throw Error();
        }
      });

      if ((typeof Reflect === "undefined" ? "undefined" : DevToolsComponentStackFrame_typeof(Reflect)) === 'object' && Reflect.construct) {
        // We construct a different control for this case to include any extra
        // frames added by the construct call.
        try {
          Reflect.construct(Fake, []);
        } catch (x) {
          control = x;
        }

        Reflect.construct(fn, [], Fake);
      } else {
        try {
          Fake.call();
        } catch (x) {
          control = x;
        }

        fn.call(Fake.prototype);
      }
    } else {
      try {
        throw Error();
      } catch (x) {
        control = x;
      }

      fn();
    }
  } catch (sample) {
    // This is inlined manually because closure doesn't do it for us.
    if (sample && control && typeof sample.stack === 'string') {
      // This extracts the first frame from the sample that isn't also in the control.
      // Skipping one frame that we assume is the frame that calls the two.
      var sampleLines = sample.stack.split('\n');
      var controlLines = control.stack.split('\n');
      var s = sampleLines.length - 1;
      var c = controlLines.length - 1;

      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
        // We expect at least one stack frame to be shared.
        // Typically this will be the root most one. However, stack frames may be
        // cut off due to maximum stack limits. In this case, one maybe cut off
        // earlier than the other. We assume that the sample is longer or the same
        // and there for cut off earlier. So we should find the root most frame in
        // the sample somewhere in the control.
        c--;
      }

      for (; s >= 1 && c >= 0; s--, c--) {
        // Next we find the first one that isn't the same which should be the
        // frame that called our sample function and the control.
        if (sampleLines[s] !== controlLines[c]) {
          // In V8, the first line is describing the message but other VMs don't.
          // If we're about to return the first line, and the control is also on the same
          // line, that's a pretty good indicator that our sample threw at same line as
          // the control. I.e. before we entered the sample frame. So we ignore this result.
          // This can happen if you passed a class to function component, or non-function.
          if (s !== 1 || c !== 1) {
            do {
              s--;
              c--; // We may still have similar intermediate frames from the construct call.
              // The next one that isn't the same should be our match though.

              if (c < 0 || sampleLines[s] !== controlLines[c]) {
                // V8 adds a "new" prefix for native classes. Let's remove it to make it prettier.
                var _frame = '\n' + sampleLines[s].replace(' at new ', ' at ');

                if (false) {} // Return the line we found.


                return _frame;
              }
            } while (s >= 1 && c >= 0);
          }

          break;
        }
      }
    }
  } finally {
    reentry = false;
    Error.prepareStackTrace = previousPrepareStackTrace;
    currentDispatcherRef.current = previousDispatcher;
    reenableLogs();
  } // Fallback to just using the name if we couldn't make it throw.


  var name = fn ? fn.displayName || fn.name : '';
  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';

  if (false) {}

  return syntheticFrame;
}
function describeClassComponentFrame(ctor, source, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(ctor, true, currentDispatcherRef);
}
function describeFunctionComponentFrame(fn, source, ownerFn, currentDispatcherRef) {
  return describeNativeComponentFrame(fn, false, currentDispatcherRef);
}

function shouldConstruct(Component) {
  var prototype = Component.prototype;
  return !!(prototype && prototype.isReactComponent);
}

function describeUnknownElementTypeFrameInDEV(type, source, ownerFn, currentDispatcherRef) {
  if (true) {
    return '';
  }

  if (type == null) {
    return '';
  }

  if (typeof type === 'function') {
    return describeNativeComponentFrame(type, shouldConstruct(type), currentDispatcherRef);
  }

  if (typeof type === 'string') {
    return describeBuiltInComponentFrame(type, source, ownerFn);
  }

  switch (type) {
    case SUSPENSE_NUMBER:
    case SUSPENSE_SYMBOL_STRING:
      return describeBuiltInComponentFrame('Suspense', source, ownerFn);

    case SUSPENSE_LIST_NUMBER:
    case SUSPENSE_LIST_SYMBOL_STRING:
      return describeBuiltInComponentFrame('SuspenseList', source, ownerFn);
  }

  if (DevToolsComponentStackFrame_typeof(type) === 'object') {
    switch (type.$$typeof) {
      case FORWARD_REF_NUMBER:
      case FORWARD_REF_SYMBOL_STRING:
        return describeFunctionComponentFrame(type.render, source, ownerFn, currentDispatcherRef);

      case MEMO_NUMBER:
      case MEMO_SYMBOL_STRING:
        // Memo may contain any component type so we recursively resolve it.
        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn, currentDispatcherRef);

      case LAZY_NUMBER:
      case LAZY_SYMBOL_STRING:
        {
          var lazyComponent = type;
          var payload = lazyComponent._payload;
          var init = lazyComponent._init;

          try {
            // Lazy may contain any component type so we recursively resolve it.
            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn, currentDispatcherRef);
          } catch (x) {}
        }
    }
  }

  return '';
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/DevToolsFiberComponentStack.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
// This is a DevTools fork of ReactFiberComponentStack.
// This fork enables DevTools to use the same "native" component stack format,
// while still maintaining support for multiple renderer versions
// (which use different values for ReactTypeOfWork).


function describeFiber(workTagMap, workInProgress, currentDispatcherRef) {
  var HostComponent = workTagMap.HostComponent,
      LazyComponent = workTagMap.LazyComponent,
      SuspenseComponent = workTagMap.SuspenseComponent,
      SuspenseListComponent = workTagMap.SuspenseListComponent,
      FunctionComponent = workTagMap.FunctionComponent,
      IndeterminateComponent = workTagMap.IndeterminateComponent,
      SimpleMemoComponent = workTagMap.SimpleMemoComponent,
      ForwardRef = workTagMap.ForwardRef,
      ClassComponent = workTagMap.ClassComponent;
  var owner =  false ? undefined : null;
  var source =  false ? undefined : null;

  switch (workInProgress.tag) {
    case HostComponent:
      return describeBuiltInComponentFrame(workInProgress.type, source, owner);

    case LazyComponent:
      return describeBuiltInComponentFrame('Lazy', source, owner);

    case SuspenseComponent:
      return describeBuiltInComponentFrame('Suspense', source, owner);

    case SuspenseListComponent:
      return describeBuiltInComponentFrame('SuspenseList', source, owner);

    case FunctionComponent:
    case IndeterminateComponent:
    case SimpleMemoComponent:
      return describeFunctionComponentFrame(workInProgress.type, source, owner, currentDispatcherRef);

    case ForwardRef:
      return describeFunctionComponentFrame(workInProgress.type.render, source, owner, currentDispatcherRef);

    case ClassComponent:
      return describeClassComponentFrame(workInProgress.type, source, owner, currentDispatcherRef);

    default:
      return '';
  }
}

function getStackByFiberInDevAndProd(workTagMap, workInProgress, currentDispatcherRef) {
  try {
    var info = '';
    var node = workInProgress;

    do {
      info += describeFiber(workTagMap, node, currentDispatcherRef);
      node = node.return;
    } while (node);

    return info;
  } catch (x) {
    return '\nError generating stack: ' + x.message + '\n' + x.stack;
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/console.js
function console_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = console_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function console_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return console_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return console_arrayLikeToArray(o, minLen); }

function console_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


var APPEND_STACK_TO_METHODS = ['error', 'trace', 'warn']; // React's custom built component stack strings match "\s{4}in"
// Chrome's prefix matches "\s{4}at"

var PREFIX_REGEX = /\s{4}(in|at)\s{1}/; // Firefox and Safari have no prefix ("")
// but we can fallback to looking for location info (e.g. "foo.js:12:345")

var ROW_COLUMN_NUMBER_REGEX = /:\d+:\d+(\n|$)/;
function isStringComponentStack(text) {
  return PREFIX_REGEX.test(text) || ROW_COLUMN_NUMBER_REGEX.test(text);
}
var injectedRenderers = new Map();
var targetConsole = console;
var targetConsoleMethods = {};

for (var console_method in console) {
  targetConsoleMethods[console_method] = console[console_method];
}

var unpatchFn = null; // Enables e.g. Jest tests to inject a mock console object.

function dangerous_setTargetConsoleForTesting(targetConsoleForTesting) {
  targetConsole = targetConsoleForTesting;
  targetConsoleMethods = {};

  for (var _method in targetConsole) {
    targetConsoleMethods[_method] = console[_method];
  }
} // v16 renderers should use this method to inject internals necessary to generate a component stack.
// These internals will be used if the console is patched.
// Injecting them separately allows the console to easily be patched or un-patched later (at runtime).

function registerRenderer(renderer, onErrorOrWarning) {
  var currentDispatcherRef = renderer.currentDispatcherRef,
      getCurrentFiber = renderer.getCurrentFiber,
      findFiberByHostInstance = renderer.findFiberByHostInstance,
      version = renderer.version; // Ignore React v15 and older because they don't expose a component stack anyway.

  if (typeof findFiberByHostInstance !== 'function') {
    return;
  } // currentDispatcherRef gets injected for v16.8+ to support hooks inspection.
  // getCurrentFiber gets injected for v16.9+.


  if (currentDispatcherRef != null && typeof getCurrentFiber === 'function') {
    var _getInternalReactCons = getInternalReactConstants(version),
        ReactTypeOfWork = _getInternalReactCons.ReactTypeOfWork;

    injectedRenderers.set(renderer, {
      currentDispatcherRef: currentDispatcherRef,
      getCurrentFiber: getCurrentFiber,
      workTagMap: ReactTypeOfWork,
      onErrorOrWarning: onErrorOrWarning
    });
  }
}
var consoleSettingsRef = {
  appendComponentStack: false,
  breakOnConsoleErrors: false,
  showInlineWarningsAndErrors: false
}; // Patches console methods to append component stack for the current fiber.
// Call unpatch() to remove the injected behavior.

function patch(_ref) {
  var appendComponentStack = _ref.appendComponentStack,
      breakOnConsoleErrors = _ref.breakOnConsoleErrors,
      showInlineWarningsAndErrors = _ref.showInlineWarningsAndErrors;
  // Settings may change after we've patched the console.
  // Using a shared ref allows the patch function to read the latest values.
  consoleSettingsRef.appendComponentStack = appendComponentStack;
  consoleSettingsRef.breakOnConsoleErrors = breakOnConsoleErrors;
  consoleSettingsRef.showInlineWarningsAndErrors = showInlineWarningsAndErrors;

  if (unpatchFn !== null) {
    // Don't patch twice.
    return;
  }

  var originalConsoleMethods = {};

  unpatchFn = function unpatchFn() {
    for (var _method2 in originalConsoleMethods) {
      try {
        // $FlowFixMe property error|warn is not writable.
        targetConsole[_method2] = originalConsoleMethods[_method2];
      } catch (error) {}
    }
  };

  APPEND_STACK_TO_METHODS.forEach(function (method) {
    try {
      var originalMethod = originalConsoleMethods[method] = targetConsole[method];

      var overrideMethod = function overrideMethod() {
        var shouldAppendWarningStack = false;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        if (consoleSettingsRef.appendComponentStack) {
          var lastArg = args.length > 0 ? args[args.length - 1] : null;
          var alreadyHasComponentStack = typeof lastArg === 'string' && isStringComponentStack(lastArg); // If we are ever called with a string that already has a component stack,
          // e.g. a React error/warning, don't append a second stack.

          shouldAppendWarningStack = !alreadyHasComponentStack;
        }

        var shouldShowInlineWarningsAndErrors = consoleSettingsRef.showInlineWarningsAndErrors && (method === 'error' || method === 'warn');

        if (shouldAppendWarningStack || shouldShowInlineWarningsAndErrors) {
          // Search for the first renderer that has a current Fiber.
          // We don't handle the edge case of stacks for more than one (e.g. interleaved renderers?)
          // eslint-disable-next-line no-for-of-loops/no-for-of-loops
          var _iterator = console_createForOfIteratorHelper(injectedRenderers.values()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _step.value,
                  currentDispatcherRef = _step$value.currentDispatcherRef,
                  getCurrentFiber = _step$value.getCurrentFiber,
                  onErrorOrWarning = _step$value.onErrorOrWarning,
                  workTagMap = _step$value.workTagMap;
              var current = getCurrentFiber();

              if (current != null) {
                try {
                  if (shouldShowInlineWarningsAndErrors) {
                    // patch() is called by two places: (1) the hook and (2) the renderer backend.
                    // The backend is what implements a message queue, so it's the only one that injects onErrorOrWarning.
                    if (typeof onErrorOrWarning === 'function') {
                      onErrorOrWarning(current, method, // Copy args before we mutate them (e.g. adding the component stack)
                      args.slice());
                    }
                  }

                  if (shouldAppendWarningStack) {
                    var componentStack = getStackByFiberInDevAndProd(workTagMap, current, currentDispatcherRef);

                    if (componentStack !== '') {
                      args.push(componentStack);
                    }
                  }
                } catch (error) {// Don't let a DevTools or React internal error interfere with logging.
                } finally {
                  break;
                }
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        if (consoleSettingsRef.breakOnConsoleErrors) {
          // --- Welcome to debugging with React DevTools ---
          // This debugger statement means that you've enabled the "break on warnings" feature.
          // Use the browser's Call Stack panel to step out of this override function-
          // to where the original warning or error was logged.
          // eslint-disable-next-line no-debugger
          debugger;
        }

        originalMethod.apply(void 0, args);
      };

      overrideMethod.__REACT_DEVTOOLS_ORIGINAL_METHOD__ = originalMethod;
      originalMethod.__REACT_DEVTOOLS_OVERRIDE_METHOD__ = overrideMethod; // $FlowFixMe property error|warn is not writable.

      targetConsole[method] = overrideMethod;
    } catch (error) {}
  });
} // Removed component stack patch from console methods.

function unpatch() {
  if (unpatchFn !== null) {
    unpatchFn();
    unpatchFn = null;
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/bridge.js
function bridge_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { bridge_typeof = function _typeof(obj) { return typeof obj; }; } else { bridge_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return bridge_typeof(obj); }

function bridge_toConsumableArray(arr) { return bridge_arrayWithoutHoles(arr) || bridge_iterableToArray(arr) || bridge_unsupportedIterableToArray(arr) || bridge_nonIterableSpread(); }

function bridge_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function bridge_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return bridge_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return bridge_arrayLikeToArray(o, minLen); }

function bridge_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function bridge_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return bridge_arrayLikeToArray(arr); }

function bridge_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function bridge_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function bridge_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function bridge_createClass(Constructor, protoProps, staticProps) { if (protoProps) bridge_defineProperties(Constructor.prototype, protoProps); if (staticProps) bridge_defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (bridge_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function bridge_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var BATCH_DURATION = 100; // This message specifies the version of the DevTools protocol currently supported by the backend,
// as well as the earliest NPM version (e.g. "4.13.0") that protocol is supported by on the frontend.
// This enables an older frontend to display an upgrade message to users for a newer, unsupported backend.

// Bump protocol version whenever a backwards breaking change is made
// in the messages sent between BackendBridge and FrontendBridge.
// This mapping is embedded in both frontend and backend builds.
//
// The backend protocol will always be the latest entry in the BRIDGE_PROTOCOL array.
//
// When an older frontend connects to a newer backend,
// the backend can send the minNpmVersion and the frontend can display an NPM upgrade prompt.
//
// When a newer frontend connects with an older protocol version,
// the frontend can use the embedded minNpmVersion/maxNpmVersion values to display a downgrade prompt.
var BRIDGE_PROTOCOL = [// This version technically never existed,
// but a backwards breaking change was added in 4.11,
// so the safest guess to downgrade the frontend would be to version 4.10.
{
  version: 0,
  minNpmVersion: '"<4.11.0"',
  maxNpmVersion: '"<4.11.0"'
}, {
  version: 1,
  minNpmVersion: '4.13.0',
  maxNpmVersion: null
}];
var currentBridgeProtocol = BRIDGE_PROTOCOL[BRIDGE_PROTOCOL.length - 1];

var Bridge = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Bridge, _EventEmitter);

  var _super = _createSuper(Bridge);

  function Bridge(wall) {
    var _this;

    bridge_classCallCheck(this, Bridge);

    _this = _super.call(this);

    bridge_defineProperty(_assertThisInitialized(_this), "_isShutdown", false);

    bridge_defineProperty(_assertThisInitialized(_this), "_messageQueue", []);

    bridge_defineProperty(_assertThisInitialized(_this), "_timeoutID", null);

    bridge_defineProperty(_assertThisInitialized(_this), "_wallUnlisten", null);

    bridge_defineProperty(_assertThisInitialized(_this), "_flush", function () {
      // This method is used after the bridge is marked as destroyed in shutdown sequence,
      // so we do not bail out if the bridge marked as destroyed.
      // It is a private method that the bridge ensures is only called at the right times.
      if (_this._timeoutID !== null) {
        clearTimeout(_this._timeoutID);
        _this._timeoutID = null;
      }

      if (_this._messageQueue.length) {
        for (var i = 0; i < _this._messageQueue.length; i += 2) {
          var _this$_wall;

          (_this$_wall = _this._wall).send.apply(_this$_wall, [_this._messageQueue[i]].concat(bridge_toConsumableArray(_this._messageQueue[i + 1])));
        }

        _this._messageQueue.length = 0; // Check again for queued messages in BATCH_DURATION ms. This will keep
        // flushing in a loop as long as messages continue to be added. Once no
        // more are, the timer expires.

        _this._timeoutID = setTimeout(_this._flush, BATCH_DURATION);
      }
    });

    bridge_defineProperty(_assertThisInitialized(_this), "overrideValueAtPath", function (_ref) {
      var id = _ref.id,
          path = _ref.path,
          rendererID = _ref.rendererID,
          type = _ref.type,
          value = _ref.value;

      switch (type) {
        case 'context':
          _this.send('overrideContext', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'hooks':
          _this.send('overrideHookState', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'props':
          _this.send('overrideProps', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;

        case 'state':
          _this.send('overrideState', {
            id: id,
            path: path,
            rendererID: rendererID,
            wasForwarded: true,
            value: value
          });

          break;
      }
    });

    _this._wall = wall;
    _this._wallUnlisten = wall.listen(function (message) {
      _assertThisInitialized(_this).emit(message.event, message.payload);
    }) || null; // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    _this.addListener('overrideValueAtPath', _this.overrideValueAtPath);

    return _this;
  } // Listening directly to the wall isn't advised.
  // It can be used to listen for legacy (v3) messages (since they use a different format).


  bridge_createClass(Bridge, [{
    key: "send",
    value: function send(event) {
      if (this._isShutdown) {
        console.warn("Cannot send message \"".concat(event, "\" through a Bridge that has been shutdown."));
        return;
      } // When we receive a message:
      // - we add it to our queue of messages to be sent
      // - if there hasn't been a message recently, we set a timer for 0 ms in
      //   the future, allowing all messages created in the same tick to be sent
      //   together
      // - if there *has* been a message flushed in the last BATCH_DURATION ms
      //   (or we're waiting for our setTimeout-0 to fire), then _timeoutID will
      //   be set, and we'll simply add to the queue and wait for that


      for (var _len = arguments.length, payload = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        payload[_key - 1] = arguments[_key];
      }

      this._messageQueue.push(event, payload);

      if (!this._timeoutID) {
        this._timeoutID = setTimeout(this._flush, 0);
      }
    }
  }, {
    key: "shutdown",
    value: function shutdown() {
      if (this._isShutdown) {
        console.warn('Bridge was already shutdown.');
        return;
      } // Queue the shutdown outgoing message for subscribers.


      this.send('shutdown'); // Mark this bridge as destroyed, i.e. disable its public API.

      this._isShutdown = true; // Disable the API inherited from EventEmitter that can add more listeners and send more messages.
      // $FlowFixMe This property is not writable.

      this.addListener = function () {}; // $FlowFixMe This property is not writable.


      this.emit = function () {}; // NOTE: There's also EventEmitter API like `on` and `prependListener` that we didn't add to our Flow type of EventEmitter.
      // Unsubscribe this bridge incoming message listeners to be sure, and so they don't have to do that.


      this.removeAllListeners(); // Stop accepting and emitting incoming messages from the wall.

      var wallUnlisten = this._wallUnlisten;

      if (wallUnlisten) {
        wallUnlisten();
      } // Synchronously flush all queued outgoing messages.
      // At this step the subscribers' code may run in this call stack.


      do {
        this._flush();
      } while (this._messageQueue.length); // Make sure once again that there is no dangling timer.


      if (this._timeoutID !== null) {
        clearTimeout(this._timeoutID);
        this._timeoutID = null;
      }
    }
  }, {
    key: "wall",
    get: function get() {
      return this._wall;
    }
  }]);

  return Bridge;
}(EventEmitter);

/* harmony default export */ var src_bridge = (Bridge);
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/agent.js
function agent_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { agent_typeof = function _typeof(obj) { return typeof obj; }; } else { agent_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return agent_typeof(obj); }

function agent_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function agent_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function agent_createClass(Constructor, protoProps, staticProps) { if (protoProps) agent_defineProperties(Constructor.prototype, protoProps); if (staticProps) agent_defineProperties(Constructor, staticProps); return Constructor; }

function agent_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) agent_setPrototypeOf(subClass, superClass); }

function agent_setPrototypeOf(o, p) { agent_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return agent_setPrototypeOf(o, p); }

function agent_createSuper(Derived) { var hasNativeReflectConstruct = agent_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = agent_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = agent_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return agent_possibleConstructorReturn(this, result); }; }

function agent_possibleConstructorReturn(self, call) { if (call && (agent_typeof(call) === "object" || typeof call === "function")) { return call; } return agent_assertThisInitialized(self); }

function agent_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function agent_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function agent_getPrototypeOf(o) { agent_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return agent_getPrototypeOf(o); }

function agent_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */










var agent_debug = function debug(methodName) {
  if (__DEBUG__) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["%cAgent %c".concat(methodName), 'color: purple; font-weight: bold;', 'font-weight: bold;'].concat(args));
  }
};

var agent_Agent = /*#__PURE__*/function (_EventEmitter) {
  agent_inherits(Agent, _EventEmitter);

  var _super = agent_createSuper(Agent);

  function Agent(bridge) {
    var _this;

    agent_classCallCheck(this, Agent);

    _this = _super.call(this);

    agent_defineProperty(agent_assertThisInitialized(_this), "_isProfiling", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "_recordChangeDescriptions", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "_rendererInterfaces", {});

    agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelection", null);

    agent_defineProperty(agent_assertThisInitialized(_this), "_persistedSelectionMatch", null);

    agent_defineProperty(agent_assertThisInitialized(_this), "_traceUpdatesEnabled", false);

    agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsAndWarnings", function (_ref) {
      var rendererID = _ref.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearErrorsAndWarnings();
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "clearErrorsForFiberID", function (_ref2) {
      var id = _ref2.id,
          rendererID = _ref2.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearErrorsForFiberID(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "clearWarningsForFiberID", function (_ref3) {
      var id = _ref3.id,
          rendererID = _ref3.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      } else {
        renderer.clearWarningsForFiberID(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "copyElementPath", function (_ref4) {
      var id = _ref4.id,
          path = _ref4.path,
          rendererID = _ref4.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.copyElementPath(id, path);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "deletePath", function (_ref5) {
      var hookID = _ref5.hookID,
          id = _ref5.id,
          path = _ref5.path,
          rendererID = _ref5.rendererID,
          type = _ref5.type;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.deletePath(type, id, hookID, path);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getBridgeProtocol", function () {
      _this._bridge.send('bridgeProtocol', currentBridgeProtocol);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingData", function (_ref6) {
      var rendererID = _ref6.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
      }

      _this._bridge.send('profilingData', renderer.getProfilingData());
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getProfilingStatus", function () {
      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "getOwnersList", function (_ref7) {
      var id = _ref7.id,
          rendererID = _ref7.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        var owners = renderer.getOwnersList(id);

        _this._bridge.send('ownersList', {
          id: id,
          owners: owners
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "inspectElement", function (_ref8) {
      var id = _ref8.id,
          path = _ref8.path,
          rendererID = _ref8.rendererID,
          requestID = _ref8.requestID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        _this._bridge.send('inspectedElement', renderer.inspectElement(requestID, id, path)); // When user selects an element, stop trying to restore the selection,
        // and instead remember the current selection for the next reload.


        if (_this._persistedSelectionMatch === null || _this._persistedSelectionMatch.id !== id) {
          _this._persistedSelection = null;
          _this._persistedSelectionMatch = null;
          renderer.setTrackedPath(null);

          _this._throttledPersistSelection(rendererID, id);
        } // TODO: If there was a way to change the selected DOM element
        // in native Elements tab without forcing a switch to it, we'd do it here.
        // For now, it doesn't seem like there is a way to do that:
        // https://github.com/bvaughn/react-devtools-experimental/issues/102
        // (Setting $0 doesn't work, and calling inspect() switches the tab.)

      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "logElementToConsole", function (_ref9) {
      var id = _ref9.id,
          rendererID = _ref9.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.logElementToConsole(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideError", function (_ref10) {
      var id = _ref10.id,
          rendererID = _ref10.rendererID,
          forceError = _ref10.forceError;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideError(id, forceError);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideSuspense", function (_ref11) {
      var id = _ref11.id,
          rendererID = _ref11.rendererID,
          forceFallback = _ref11.forceFallback;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideSuspense(id, forceFallback);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideValueAtPath", function (_ref12) {
      var hookID = _ref12.hookID,
          id = _ref12.id,
          path = _ref12.path,
          rendererID = _ref12.rendererID,
          type = _ref12.type,
          value = _ref12.value;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.overrideValueAtPath(type, id, hookID, path, value);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideContext", function (_ref13) {
      var id = _ref13.id,
          path = _ref13.path,
          rendererID = _ref13.rendererID,
          wasForwarded = _ref13.wasForwarded,
          value = _ref13.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'context',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideHookState", function (_ref14) {
      var id = _ref14.id,
          hookID = _ref14.hookID,
          path = _ref14.path,
          rendererID = _ref14.rendererID,
          wasForwarded = _ref14.wasForwarded,
          value = _ref14.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'hooks',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideProps", function (_ref15) {
      var id = _ref15.id,
          path = _ref15.path,
          rendererID = _ref15.rendererID,
          wasForwarded = _ref15.wasForwarded,
          value = _ref15.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'props',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "overrideState", function (_ref16) {
      var id = _ref16.id,
          path = _ref16.path,
          rendererID = _ref16.rendererID,
          wasForwarded = _ref16.wasForwarded,
          value = _ref16.value;

      // Don't forward a message that's already been forwarded by the front-end Bridge.
      // We only need to process the override command once!
      if (!wasForwarded) {
        _this.overrideValueAtPath({
          id: id,
          path: path,
          rendererID: rendererID,
          type: 'state',
          value: value
        });
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "reloadAndProfile", function (recordChangeDescriptions) {
      sessionStorageSetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY, 'true');
      sessionStorageSetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY, recordChangeDescriptions ? 'true' : 'false'); // This code path should only be hit if the shell has explicitly told the Store that it supports profiling.
      // In that case, the shell must also listen for this specific message to know when it needs to reload the app.
      // The agent can't do this in a way that is renderer agnostic.

      _this._bridge.send('reloadAppForProfiling');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "renamePath", function (_ref17) {
      var hookID = _ref17.hookID,
          id = _ref17.id,
          newPath = _ref17.newPath,
          oldPath = _ref17.oldPath,
          rendererID = _ref17.rendererID,
          type = _ref17.type;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.renamePath(type, id, hookID, oldPath, newPath);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "setTraceUpdatesEnabled", function (traceUpdatesEnabled) {
      _this._traceUpdatesEnabled = traceUpdatesEnabled;
      toggleEnabled(traceUpdatesEnabled);

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.setTraceUpdatesEnabled(traceUpdatesEnabled);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "syncSelectionFromNativeElementsPanel", function () {
      var target = window.__REACT_DEVTOOLS_GLOBAL_HOOK__.$0;

      if (target == null) {
        return;
      }

      _this.selectNode(target);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "shutdown", function () {
      // Clean up the overlay if visible, and associated events.
      _this.emit('shutdown');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "startProfiling", function (recordChangeDescriptions) {
      _this._recordChangeDescriptions = recordChangeDescriptions;
      _this._isProfiling = true;

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.startProfiling(recordChangeDescriptions);
      }

      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "stopProfiling", function () {
      _this._isProfiling = false;
      _this._recordChangeDescriptions = false;

      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.stopProfiling();
      }

      _this._bridge.send('profilingStatus', _this._isProfiling);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "storeAsGlobal", function (_ref18) {
      var count = _ref18.count,
          id = _ref18.id,
          path = _ref18.path,
          rendererID = _ref18.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.storeAsGlobal(id, path, count);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "updateConsolePatchSettings", function (_ref19) {
      var appendComponentStack = _ref19.appendComponentStack,
          breakOnConsoleErrors = _ref19.breakOnConsoleErrors,
          showInlineWarningsAndErrors = _ref19.showInlineWarningsAndErrors;

      // If the frontend preference has change,
      // or in the case of React Native- if the backend is just finding out the preference-
      // then install or uninstall the console overrides.
      // It's safe to call these methods multiple times, so we don't need to worry about that.
      if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {
        patch({
          appendComponentStack: appendComponentStack,
          breakOnConsoleErrors: breakOnConsoleErrors,
          showInlineWarningsAndErrors: showInlineWarningsAndErrors
        });
      } else {
        unpatch();
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "updateComponentFilters", function (componentFilters) {
      for (var rendererID in _this._rendererInterfaces) {
        var renderer = _this._rendererInterfaces[rendererID];
        renderer.updateComponentFilters(componentFilters);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "viewAttributeSource", function (_ref20) {
      var id = _ref20.id,
          path = _ref20.path,
          rendererID = _ref20.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.prepareViewAttributeSource(id, path);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "viewElementSource", function (_ref21) {
      var id = _ref21.id,
          rendererID = _ref21.rendererID;
      var renderer = _this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\" for element \"").concat(id, "\""));
      } else {
        renderer.prepareViewElementSource(id);
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onTraceUpdates", function (nodes) {
      _this.emit('traceUpdates', nodes);
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onFastRefreshScheduled", function () {
      if (__DEBUG__) {
        agent_debug('onFastRefreshScheduled');
      }

      _this._bridge.send('fastRefreshScheduled');
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "onHookOperations", function (operations) {
      if (__DEBUG__) {
        agent_debug('onHookOperations', "(".concat(operations.length, ") [").concat(operations.join(', '), "]"));
      } // TODO:
      // The chrome.runtime does not currently support transferables; it forces JSON serialization.
      // See bug https://bugs.chromium.org/p/chromium/issues/detail?id=927134
      //
      // Regarding transferables, the postMessage doc states:
      // If the ownership of an object is transferred, it becomes unusable (neutered)
      // in the context it was sent from and becomes available only to the worker it was sent to.
      //
      // Even though Chrome is eventually JSON serializing the array buffer,
      // using the transferable approach also sometimes causes it to throw:
      //   DOMException: Failed to execute 'postMessage' on 'Window': ArrayBuffer at index 0 is already neutered.
      //
      // See bug https://github.com/bvaughn/react-devtools-experimental/issues/25
      //
      // The Store has a fallback in place that parses the message as JSON if the type isn't an array.
      // For now the simplest fix seems to be to not transfer the array.
      // This will negatively impact performance on Firefox so it's unfortunate,
      // but until we're able to fix the Chrome error mentioned above, it seems necessary.
      //
      // this._bridge.send('operations', operations, [operations.buffer]);


      _this._bridge.send('operations', operations);

      if (_this._persistedSelection !== null) {
        var rendererID = operations[0];

        if (_this._persistedSelection.rendererID === rendererID) {
          // Check if we can select a deeper match for the persisted selection.
          var renderer = _this._rendererInterfaces[rendererID];

          if (renderer == null) {
            console.warn("Invalid renderer id \"".concat(rendererID, "\""));
          } else {
            var prevMatch = _this._persistedSelectionMatch;
            var nextMatch = renderer.getBestMatchForTrackedPath();
            _this._persistedSelectionMatch = nextMatch;
            var prevMatchID = prevMatch !== null ? prevMatch.id : null;
            var nextMatchID = nextMatch !== null ? nextMatch.id : null;

            if (prevMatchID !== nextMatchID) {
              if (nextMatchID !== null) {
                // We moved forward, unlocking a deeper node.
                _this._bridge.send('selectFiber', nextMatchID);
              }
            }

            if (nextMatch !== null && nextMatch.isFullMatch) {
              // We've just unlocked the innermost selected node.
              // There's no point tracking it further.
              _this._persistedSelection = null;
              _this._persistedSelectionMatch = null;
              renderer.setTrackedPath(null);
            }
          }
        }
      }
    });

    agent_defineProperty(agent_assertThisInitialized(_this), "_throttledPersistSelection", lodash_throttle_default()(function (rendererID, id) {
      // This is throttled, so both renderer and selected ID
      // might not be available by the time we read them.
      // This is why we need the defensive checks here.
      var renderer = _this._rendererInterfaces[rendererID];
      var path = renderer != null ? renderer.getPathForElement(id) : null;

      if (path !== null) {
        sessionStorageSetItem(SESSION_STORAGE_LAST_SELECTION_KEY, JSON.stringify({
          rendererID: rendererID,
          path: path
        }));
      } else {
        sessionStorageRemoveItem(SESSION_STORAGE_LAST_SELECTION_KEY);
      }
    }, 1000));

    if (sessionStorageGetItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY) === 'true') {
      _this._recordChangeDescriptions = sessionStorageGetItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY) === 'true';
      _this._isProfiling = true;
      sessionStorageRemoveItem(SESSION_STORAGE_RECORD_CHANGE_DESCRIPTIONS_KEY);
      sessionStorageRemoveItem(SESSION_STORAGE_RELOAD_AND_PROFILE_KEY);
    }

    var persistedSelectionString = sessionStorageGetItem(SESSION_STORAGE_LAST_SELECTION_KEY);

    if (persistedSelectionString != null) {
      _this._persistedSelection = JSON.parse(persistedSelectionString);
    }

    _this._bridge = bridge;
    bridge.addListener('clearErrorsAndWarnings', _this.clearErrorsAndWarnings);
    bridge.addListener('clearErrorsForFiberID', _this.clearErrorsForFiberID);
    bridge.addListener('clearWarningsForFiberID', _this.clearWarningsForFiberID);
    bridge.addListener('copyElementPath', _this.copyElementPath);
    bridge.addListener('deletePath', _this.deletePath);
    bridge.addListener('getBridgeProtocol', _this.getBridgeProtocol);
    bridge.addListener('getProfilingData', _this.getProfilingData);
    bridge.addListener('getProfilingStatus', _this.getProfilingStatus);
    bridge.addListener('getOwnersList', _this.getOwnersList);
    bridge.addListener('inspectElement', _this.inspectElement);
    bridge.addListener('logElementToConsole', _this.logElementToConsole);
    bridge.addListener('overrideError', _this.overrideError);
    bridge.addListener('overrideSuspense', _this.overrideSuspense);
    bridge.addListener('overrideValueAtPath', _this.overrideValueAtPath);
    bridge.addListener('reloadAndProfile', _this.reloadAndProfile);
    bridge.addListener('renamePath', _this.renamePath);
    bridge.addListener('setTraceUpdatesEnabled', _this.setTraceUpdatesEnabled);
    bridge.addListener('startProfiling', _this.startProfiling);
    bridge.addListener('stopProfiling', _this.stopProfiling);
    bridge.addListener('storeAsGlobal', _this.storeAsGlobal);
    bridge.addListener('syncSelectionFromNativeElementsPanel', _this.syncSelectionFromNativeElementsPanel);
    bridge.addListener('shutdown', _this.shutdown);
    bridge.addListener('updateConsolePatchSettings', _this.updateConsolePatchSettings);
    bridge.addListener('updateComponentFilters', _this.updateComponentFilters);
    bridge.addListener('viewAttributeSource', _this.viewAttributeSource);
    bridge.addListener('viewElementSource', _this.viewElementSource); // Temporarily support older standalone front-ends sending commands to newer embedded backends.
    // We do this because React Native embeds the React DevTools backend,
    // but cannot control which version of the frontend users use.

    bridge.addListener('overrideContext', _this.overrideContext);
    bridge.addListener('overrideHookState', _this.overrideHookState);
    bridge.addListener('overrideProps', _this.overrideProps);
    bridge.addListener('overrideState', _this.overrideState);

    if (_this._isProfiling) {
      bridge.send('profilingStatus', true);
    } // Notify the frontend if the backend supports the Storage API (e.g. localStorage).
    // If not, features like reload-and-profile will not work correctly and must be disabled.


    var isBackendStorageAPISupported = false;

    try {
      localStorage.getItem('test');
      isBackendStorageAPISupported = true;
    } catch (error) {}

    bridge.send('isBackendStorageAPISupported', isBackendStorageAPISupported);
    bridge.send('isSynchronousXHRSupported', isSynchronousXHRSupported());
    setupHighlighter(bridge, agent_assertThisInitialized(_this));
    TraceUpdates_initialize(agent_assertThisInitialized(_this));
    return _this;
  }

  agent_createClass(Agent, [{
    key: "getInstanceAndStyle",
    value: function getInstanceAndStyle(_ref22) {
      var id = _ref22.id,
          rendererID = _ref22.rendererID;
      var renderer = this._rendererInterfaces[rendererID];

      if (renderer == null) {
        console.warn("Invalid renderer id \"".concat(rendererID, "\""));
        return null;
      }

      return renderer.getInstanceAndStyle(id);
    }
  }, {
    key: "getIDForNode",
    value: function getIDForNode(node) {
      for (var rendererID in this._rendererInterfaces) {
        var renderer = this._rendererInterfaces[rendererID];

        try {
          var id = renderer.getFiberIDForNative(node, true);

          if (id !== null) {
            return id;
          }
        } catch (error) {// Some old React versions might throw if they can't find a match.
          // If so we should ignore it...
        }
      }

      return null;
    }
  }, {
    key: "selectNode",
    value: function selectNode(target) {
      var id = this.getIDForNode(target);

      if (id !== null) {
        this._bridge.send('selectFiber', id);
      }
    }
  }, {
    key: "setRendererInterface",
    value: function setRendererInterface(rendererID, rendererInterface) {
      this._rendererInterfaces[rendererID] = rendererInterface;

      if (this._isProfiling) {
        rendererInterface.startProfiling(this._recordChangeDescriptions);
      }

      rendererInterface.setTraceUpdatesEnabled(this._traceUpdatesEnabled); // When the renderer is attached, we need to tell it whether
      // we remember the previous selection that we'd like to restore.
      // It'll start tracking mounts for matches to the last selection path.

      var selection = this._persistedSelection;

      if (selection !== null && selection.rendererID === rendererID) {
        rendererInterface.setTrackedPath(selection.path);
      }
    }
  }, {
    key: "onUnsupportedRenderer",
    value: function onUnsupportedRenderer(rendererID) {
      this._bridge.send('unsupportedRendererVersion', rendererID);
    }
  }, {
    key: "rendererInterfaces",
    get: function get() {
      return this._rendererInterfaces;
    }
  }]);

  return Agent;
}(EventEmitter);


// CONCATENATED MODULE: ../react-devtools-shared/src/hook.js
/**
 * Install the hook on window, which is an event emitter.
 * Note because Chrome content scripts cannot directly modify the window object,
 * we are evaling this function by inserting a script tag.
 * That's why we have to inline the whole event emitter implementation here.
 *
 * 
 */

function installHook(target) {
  if (target.hasOwnProperty('__REACT_DEVTOOLS_GLOBAL_HOOK__')) {
    return null;
  }

  function detectReactBuildType(renderer) {
    try {
      if (typeof renderer.version === 'string') {
        // React DOM Fiber (16+)
        if (renderer.bundleType > 0) {
          // This is not a production build.
          // We are currently only using 0 (PROD) and 1 (DEV)
          // but might add 2 (PROFILE) in the future.
          return 'development';
        } // React 16 uses flat bundles. If we report the bundle as production
        // version, it means we also minified and envified it ourselves.


        return 'production'; // Note: There is still a risk that the CommonJS entry point has not
        // been envified or uglified. In this case the user would have *both*
        // development and production bundle, but only the prod one would run.
        // This would be really bad. We have a separate check for this because
        // it happens *outside* of the renderer injection. See `checkDCE` below.
      }

      var _toString = Function.prototype.toString;

      if (renderer.Mount && renderer.Mount._renderNewRootComponent) {
        // React DOM Stack
        var renderRootCode = _toString.call(renderer.Mount._renderNewRootComponent); // Filter out bad results (if that is even possible):


        if (renderRootCode.indexOf('function') !== 0) {
          // Hope for the best if we're not sure.
          return 'production';
        } // Check for React DOM Stack < 15.1.0 in development.
        // If it contains "storedMeasure" call, it's wrapped in ReactPerf (DEV only).
        // This would be true even if it's minified, as method name still matches.


        if (renderRootCode.indexOf('storedMeasure') !== -1) {
          return 'development';
        } // For other versions (and configurations) it's not so easy.
        // Let's quickly exclude proper production builds.
        // If it contains a warning message, it's either a DEV build,
        // or an PROD build without proper dead code elimination.


        if (renderRootCode.indexOf('should be a pure function') !== -1) {
          // Now how do we tell a DEV build from a bad PROD build?
          // If we see NODE_ENV, we're going to assume this is a dev build
          // because most likely it is referring to an empty shim.
          if (renderRootCode.indexOf('NODE_ENV') !== -1) {
            return 'development';
          } // If we see "development", we're dealing with an envified DEV build
          // (such as the official React DEV UMD).


          if (renderRootCode.indexOf('development') !== -1) {
            return 'development';
          } // I've seen process.env.NODE_ENV !== 'production' being smartly
          // replaced by `true` in DEV by Webpack. I don't know how that
          // works but we can safely guard against it because `true` was
          // never used in the function source since it was written.


          if (renderRootCode.indexOf('true') !== -1) {
            return 'development';
          } // By now either it is a production build that has not been minified,
          // or (worse) this is a minified development build using non-standard
          // environment (e.g. "staging"). We're going to look at whether
          // the function argument name is mangled:


          if ( // 0.13 to 15
          renderRootCode.indexOf('nextElement') !== -1 || // 0.12
          renderRootCode.indexOf('nextComponent') !== -1) {
            // We can't be certain whether this is a development build or not,
            // but it is definitely unminified.
            return 'unminified';
          } else {
            // This is likely a minified development build.
            return 'development';
          }
        } // By now we know that it's envified and dead code elimination worked,
        // but what if it's still not minified? (Is this even possible?)
        // Let's check matches for the first argument name.


        if ( // 0.13 to 15
        renderRootCode.indexOf('nextElement') !== -1 || // 0.12
        renderRootCode.indexOf('nextComponent') !== -1) {
          return 'unminified';
        } // Seems like we're using the production version.
        // However, the branch above is Stack-only so this is 15 or earlier.


        return 'outdated';
      }
    } catch (err) {// Weird environments may exist.
      // This code needs a higher fault tolerance
      // because it runs even with closed DevTools.
      // TODO: should we catch errors in all injected code, and not just this part?
    }

    return 'production';
  }

  function checkDCE(fn) {
    // This runs for production versions of React.
    // Needs to be super safe.
    try {
      var _toString2 = Function.prototype.toString;

      var code = _toString2.call(fn); // This is a string embedded in the passed function under DEV-only
      // condition. However the function executes only in PROD. Therefore,
      // if we see it, dead code elimination did not work.


      if (code.indexOf('^_^') > -1) {
        // Remember to report during next injection.
        hasDetectedBadDCE = true; // Bonus: throw an exception hoping that it gets picked up by a reporting system.
        // Not synchronously so that it doesn't break the calling code.

        setTimeout(function () {
          throw new Error('React is running in production mode, but dead code ' + 'elimination has not been applied. Read how to correctly ' + 'configure React for production: ' + 'https://reactjs.org/link/perf-use-production-build');
        });
      }
    } catch (err) {}
  }

  var uidCounter = 0;

  function inject(renderer) {
    var id = ++uidCounter;
    renderers.set(id, renderer);
    var reactBuildType = hasDetectedBadDCE ? 'deadcode' : detectReactBuildType(renderer); // Patching the console enables DevTools to do a few useful things:
    // * Append component stacks to warnings and error messages
    // * Disable logging during re-renders to inspect hooks (see inspectHooksOfFiber)
    //
    // For React Native, we intentionally patch early (during injection).
    // This provides React Native developers with components stacks even if they don't run DevTools.
    // This won't work for DOM though, since this entire file is eval'ed and inserted as a script tag.
    // In that case, we'll patch later (when the frontend attaches).
    //
    // Don't patch in test environments because we don't want to interfere with Jest's own console overrides.
    //
    // Note that because this function is inlined, this conditional check must only use static booleans.
    // Otherwise the extension will throw with an undefined error.
    // (See comments in the try/catch below for more context on inlining.)

    if (true) {
      try {
        var appendComponentStack = window.__REACT_DEVTOOLS_APPEND_COMPONENT_STACK__ !== false;
        var breakOnConsoleErrors = window.__REACT_DEVTOOLS_BREAK_ON_CONSOLE_ERRORS__ === true;
        var showInlineWarningsAndErrors = window.__REACT_DEVTOOLS_SHOW_INLINE_WARNINGS_AND_ERRORS__ !== false; // The installHook() function is injected by being stringified in the browser,
        // so imports outside of this function do not get included.
        //
        // Normally we could check "typeof patchConsole === 'function'",
        // but Webpack wraps imports with an object (e.g. _backend_console__WEBPACK_IMPORTED_MODULE_0__)
        // and the object itself will be undefined as well for the reasons mentioned above,
        // so we use try/catch instead.

        if (appendComponentStack || breakOnConsoleErrors || showInlineWarningsAndErrors) {
          registerRenderer(renderer);
          patch({
            appendComponentStack: appendComponentStack,
            breakOnConsoleErrors: breakOnConsoleErrors,
            showInlineWarningsAndErrors: showInlineWarningsAndErrors
          });
        }
      } catch (error) {}
    } // If we have just reloaded to profile, we need to inject the renderer interface before the app loads.
    // Otherwise the renderer won't yet exist and we can skip this step.


    var attach = target.__REACT_DEVTOOLS_ATTACH__;

    if (typeof attach === 'function') {
      var rendererInterface = attach(hook, id, renderer, target);
      hook.rendererInterfaces.set(id, rendererInterface);
    }

    hook.emit('renderer', {
      id: id,
      renderer: renderer,
      reactBuildType: reactBuildType
    });
    return id;
  }

  var hasDetectedBadDCE = false;

  function sub(event, fn) {
    hook.on(event, fn);
    return function () {
      return hook.off(event, fn);
    };
  }

  function on(event, fn) {
    if (!listeners[event]) {
      listeners[event] = [];
    }

    listeners[event].push(fn);
  }

  function off(event, fn) {
    if (!listeners[event]) {
      return;
    }

    var index = listeners[event].indexOf(fn);

    if (index !== -1) {
      listeners[event].splice(index, 1);
    }

    if (!listeners[event].length) {
      delete listeners[event];
    }
  }

  function emit(event, data) {
    if (listeners[event]) {
      listeners[event].map(function (fn) {
        return fn(data);
      });
    }
  }

  function getFiberRoots(rendererID) {
    var roots = fiberRoots;

    if (!roots[rendererID]) {
      roots[rendererID] = new Set();
    }

    return roots[rendererID];
  }

  function onCommitFiberUnmount(rendererID, fiber) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberUnmount(fiber);
    }
  }

  function onCommitFiberRoot(rendererID, root, priorityLevel) {
    var mountedRoots = hook.getFiberRoots(rendererID);
    var current = root.current;
    var isKnownRoot = mountedRoots.has(root);
    var isUnmounting = current.memoizedState == null || current.memoizedState.element == null; // Keep track of mounted roots so we can hydrate when DevTools connect.

    if (!isKnownRoot && !isUnmounting) {
      mountedRoots.add(root);
    } else if (isKnownRoot && isUnmounting) {
      mountedRoots.delete(root);
    }

    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handleCommitFiberRoot(root, priorityLevel);
    }
  }

  function onPostCommitFiberRoot(rendererID, root) {
    var rendererInterface = rendererInterfaces.get(rendererID);

    if (rendererInterface != null) {
      rendererInterface.handlePostCommitFiberRoot(root);
    }
  } // TODO: More meaningful names for "rendererInterfaces" and "renderers".


  var fiberRoots = {};
  var rendererInterfaces = new Map();
  var listeners = {};
  var renderers = new Map();
  var hook = {
    rendererInterfaces: rendererInterfaces,
    listeners: listeners,
    // Fast Refresh for web relies on this.
    renderers: renderers,
    emit: emit,
    getFiberRoots: getFiberRoots,
    inject: inject,
    on: on,
    off: off,
    sub: sub,
    // This is a legacy flag.
    // React v16 checks the hook for this to ensure DevTools is new enough.
    supportsFiber: true,
    // React calls these methods.
    checkDCE: checkDCE,
    onCommitFiberUnmount: onCommitFiberUnmount,
    onCommitFiberRoot: onCommitFiberRoot,
    onPostCommitFiberRoot: onPostCommitFiberRoot
  };
  Object.defineProperty(target, '__REACT_DEVTOOLS_GLOBAL_HOOK__', {
    // This property needs to be configurable for the test environment,
    // else we won't be able to delete and recreate it between tests.
    configurable: false,
    enumerable: false,
    get: function get() {
      return hook;
    }
  });
  return hook;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/utils.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */
function decorate(object, attr, fn) {
  var old = object[attr];

  object[attr] = function (instance) {
    return fn.call(this, old, arguments);
  };

  return old;
}
function decorateMany(source, fns) {
  var olds = {};

  for (var name in fns) {
    olds[name] = decorate(source, name, fns[name]);
  }

  return olds;
}
function restoreMany(source, olds) {
  for (var name in olds) {
    source[name] = olds[name];
  }
}
function forceUpdate(instance) {
  if (typeof instance.forceUpdate === 'function') {
    instance.forceUpdate();
  } else if (instance.updater != null && typeof instance.updater.enqueueForceUpdate === 'function') {
    instance.updater.enqueueForceUpdate(this, function () {}, 'forceUpdate');
  }
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/legacy/renderer.js
function legacy_renderer_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function legacy_renderer_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { legacy_renderer_ownKeys(Object(source), true).forEach(function (key) { legacy_renderer_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { legacy_renderer_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function legacy_renderer_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function legacy_renderer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { legacy_renderer_typeof = function _typeof(obj) { return typeof obj; }; } else { legacy_renderer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return legacy_renderer_typeof(obj); }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







function getData(internalInstance) {
  var displayName = null;
  var key = null; // != used deliberately here to catch undefined and null

  if (internalInstance._currentElement != null) {
    if (internalInstance._currentElement.key) {
      key = '' + internalInstance._currentElement.key;
    }

    var elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'string') {
      displayName = elementType;
    } else if (typeof elementType === 'function') {
      displayName = getDisplayName(elementType);
    }
  }

  return {
    displayName: displayName,
    key: key
  };
}

function getElementType(internalInstance) {
  // != used deliberately here to catch undefined and null
  if (internalInstance._currentElement != null) {
    var elementType = internalInstance._currentElement.type;

    if (typeof elementType === 'function') {
      var publicInstance = internalInstance.getPublicInstance();

      if (publicInstance !== null) {
        return ElementTypeClass;
      } else {
        return ElementTypeFunction;
      }
    } else if (typeof elementType === 'string') {
      return ElementTypeHostComponent;
    }
  }

  return ElementTypeOtherOrUnknown;
}

function getChildren(internalInstance) {
  var children = []; // If the parent is a native node without rendered children, but with
  // multiple string children, then the `element` that gets passed in here is
  // a plain value -- a string or number.

  if (legacy_renderer_typeof(internalInstance) !== 'object') {// No children
  } else if (internalInstance._currentElement === null || internalInstance._currentElement === false) {// No children
  } else if (internalInstance._renderedComponent) {
    var child = internalInstance._renderedComponent;

    if (getElementType(child) !== ElementTypeOtherOrUnknown) {
      children.push(child);
    }
  } else if (internalInstance._renderedChildren) {
    var renderedChildren = internalInstance._renderedChildren;

    for (var name in renderedChildren) {
      var _child = renderedChildren[name];

      if (getElementType(_child) !== ElementTypeOtherOrUnknown) {
        children.push(_child);
      }
    }
  } // Note: we skip the case where children are just strings or numbers
  // because the new DevTools skips over host text nodes anyway.


  return children;
}

function legacy_renderer_attach(hook, rendererID, renderer, global) {
  var idToInternalInstanceMap = new Map();
  var internalInstanceToIDMap = new WeakMap();
  var internalInstanceToRootIDMap = new WeakMap();
  var getInternalIDForNative = null;
  var findNativeNodeForInternalID;

  if (renderer.ComponentTree) {
    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {
      var internalInstance = renderer.ComponentTree.getClosestInstanceFromNode(node);
      return internalInstanceToIDMap.get(internalInstance) || null;
    };

    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {
      var internalInstance = idToInternalInstanceMap.get(id);
      return renderer.ComponentTree.getNodeFromInstance(internalInstance);
    };
  } else if (renderer.Mount.getID && renderer.Mount.getNode) {
    getInternalIDForNative = function getInternalIDForNative(node, findNearestUnfilteredAncestor) {
      // Not implemented.
      return null;
    };

    findNativeNodeForInternalID = function findNativeNodeForInternalID(id) {
      // Not implemented.
      return null;
    };
  }

  function getDisplayNameForFiberID(id) {
    var internalInstance = idToInternalInstanceMap.get(id);
    return internalInstance ? getData(internalInstance).displayName : null;
  }

  function getID(internalInstance) {
    if (legacy_renderer_typeof(internalInstance) !== 'object' || internalInstance === null) {
      throw new Error('Invalid internal instance: ' + internalInstance);
    }

    if (!internalInstanceToIDMap.has(internalInstance)) {
      var _id = getUID();

      internalInstanceToIDMap.set(internalInstance, _id);
      idToInternalInstanceMap.set(_id, internalInstance);
    }

    return internalInstanceToIDMap.get(internalInstance);
  }

  function areEqualArrays(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }

    return true;
  } // This is shared mutable state that lets us keep track of where we are.


  var parentIDStack = [];
  var oldReconcilerMethods = null;

  if (renderer.Reconciler) {
    // React 15
    oldReconcilerMethods = decorateMany(renderer.Reconciler, {
      mountComponent: function mountComponent(fn, args) {
        var internalInstance = args[0];
        var hostContainerInfo = args[3];

        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
          return fn.apply(this, args);
        }

        if (hostContainerInfo._topLevelWrapper === undefined) {
          // SSR
          return fn.apply(this, args);
        }

        var id = getID(internalInstance); // Push the operation.

        var parentID = parentIDStack.length > 0 ? parentIDStack[parentIDStack.length - 1] : 0;
        recordMount(internalInstance, id, parentID);
        parentIDStack.push(id); // Remember the root.

        internalInstanceToRootIDMap.set(internalInstance, getID(hostContainerInfo._topLevelWrapper));

        try {
          var result = fn.apply(this, args);
          parentIDStack.pop();
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      performUpdateIfNecessary: function performUpdateIfNecessary(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);
        var prevChildren = getChildren(internalInstance);

        try {
          var result = fn.apply(this, args);
          var nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      receiveComponent: function receiveComponent(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);
        var prevChildren = getChildren(internalInstance);

        try {
          var result = fn.apply(this, args);
          var nextChildren = getChildren(internalInstance);

          if (!areEqualArrays(prevChildren, nextChildren)) {
            // Push the operation
            recordReorder(internalInstance, id, nextChildren);
          }

          parentIDStack.pop();
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      },
      unmountComponent: function unmountComponent(fn, args) {
        var internalInstance = args[0];

        if (getElementType(internalInstance) === ElementTypeOtherOrUnknown) {
          return fn.apply(this, args);
        }

        var id = getID(internalInstance);
        parentIDStack.push(id);

        try {
          var result = fn.apply(this, args);
          parentIDStack.pop(); // Push the operation.

          recordUnmount(internalInstance, id);
          return result;
        } catch (err) {
          parentIDStack = [];
          throw err;
        } finally {
          if (parentIDStack.length === 0) {
            var rootID = internalInstanceToRootIDMap.get(internalInstance);

            if (rootID === undefined) {
              throw new Error('Expected to find root ID.');
            }

            flushPendingEvents(rootID);
          }
        }
      }
    });
  }

  function cleanup() {
    if (oldReconcilerMethods !== null) {
      if (renderer.Component) {
        restoreMany(renderer.Component.Mixin, oldReconcilerMethods);
      } else {
        restoreMany(renderer.Reconciler, oldReconcilerMethods);
      }
    }

    oldReconcilerMethods = null;
  }

  function recordMount(internalInstance, id, parentID) {
    var isRoot = parentID === 0;

    if (__DEBUG__) {
      console.log('%crecordMount()', 'color: green; font-weight: bold;', id, getData(internalInstance).displayName);
    }

    if (isRoot) {
      // TODO Is this right? For all versions?
      var hasOwnerMetadata = internalInstance._currentElement != null && internalInstance._currentElement._owner != null;
      pushOperation(TREE_OPERATION_ADD);
      pushOperation(id);
      pushOperation(ElementTypeRoot);
      pushOperation(0); // isProfilingSupported?

      pushOperation(hasOwnerMetadata ? 1 : 0);
    } else {
      var type = getElementType(internalInstance);

      var _getData = getData(internalInstance),
          displayName = _getData.displayName,
          key = _getData.key;

      var ownerID = internalInstance._currentElement != null && internalInstance._currentElement._owner != null ? getID(internalInstance._currentElement._owner) : 0;
      var displayNameStringID = getStringID(displayName);
      var keyStringID = getStringID(key);
      pushOperation(TREE_OPERATION_ADD);
      pushOperation(id);
      pushOperation(type);
      pushOperation(parentID);
      pushOperation(ownerID);
      pushOperation(displayNameStringID);
      pushOperation(keyStringID);
    }
  }

  function recordReorder(internalInstance, id, nextChildren) {
    pushOperation(TREE_OPERATION_REORDER_CHILDREN);
    pushOperation(id);
    var nextChildIDs = nextChildren.map(getID);
    pushOperation(nextChildIDs.length);

    for (var i = 0; i < nextChildIDs.length; i++) {
      pushOperation(nextChildIDs[i]);
    }
  }

  function recordUnmount(internalInstance, id) {
    pendingUnmountedIDs.push(id);
    idToInternalInstanceMap.delete(id);
  }

  function crawlAndRecordInitialMounts(id, parentID, rootID) {
    if (__DEBUG__) {
      console.group('crawlAndRecordInitialMounts() id:', id);
    }

    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      internalInstanceToRootIDMap.set(internalInstance, rootID);
      recordMount(internalInstance, id, parentID);
      getChildren(internalInstance).forEach(function (child) {
        return crawlAndRecordInitialMounts(getID(child), id, rootID);
      });
    }

    if (__DEBUG__) {
      console.groupEnd();
    }
  }

  function flushInitialOperations() {
    // Crawl roots though and register any nodes that mounted before we were injected.
    var roots = renderer.Mount._instancesByReactRootID || renderer.Mount._instancesByContainerID;

    for (var key in roots) {
      var internalInstance = roots[key];

      var _id2 = getID(internalInstance);

      crawlAndRecordInitialMounts(_id2, 0, _id2);
      flushPendingEvents(_id2);
    }
  }

  var pendingOperations = [];
  var pendingStringTable = new Map();
  var pendingUnmountedIDs = [];
  var pendingStringTableLength = 0;
  var pendingUnmountedRootID = null;

  function flushPendingEvents(rootID) {
    if (pendingOperations.length === 0 && pendingUnmountedIDs.length === 0 && pendingUnmountedRootID === null) {
      return;
    }

    var numUnmountIDs = pendingUnmountedIDs.length + (pendingUnmountedRootID === null ? 0 : 1);
    var operations = new Array( // Identify which renderer this update is coming from.
    2 + // [rendererID, rootFiberID]
    // How big is the string table?
    1 + // [stringTableLength]
    // Then goes the actual string table.
    pendingStringTableLength + ( // All unmounts are batched in a single message.
    // [TREE_OPERATION_REMOVE, removedIDLength, ...ids]
    numUnmountIDs > 0 ? 2 + numUnmountIDs : 0) + // Mount operations
    pendingOperations.length); // Identify which renderer this update is coming from.
    // This enables roots to be mapped to renderers,
    // Which in turn enables fiber properations, states, and hooks to be inspected.

    var i = 0;
    operations[i++] = rendererID;
    operations[i++] = rootID; // Now fill in the string table.
    // [stringTableLength, str1Length, ...str1, str2Length, ...str2, ...]

    operations[i++] = pendingStringTableLength;
    pendingStringTable.forEach(function (value, key) {
      operations[i++] = key.length;
      var encodedKey = utfEncodeString(key);

      for (var j = 0; j < encodedKey.length; j++) {
        operations[i + j] = encodedKey[j];
      }

      i += key.length;
    });

    if (numUnmountIDs > 0) {
      // All unmounts except roots are batched in a single message.
      operations[i++] = TREE_OPERATION_REMOVE; // The first number is how many unmounted IDs we're gonna send.

      operations[i++] = numUnmountIDs; // Fill in the unmounts

      for (var j = 0; j < pendingUnmountedIDs.length; j++) {
        operations[i++] = pendingUnmountedIDs[j];
      } // The root ID should always be unmounted last.


      if (pendingUnmountedRootID !== null) {
        operations[i] = pendingUnmountedRootID;
        i++;
      }
    } // Fill in the rest of the operations.


    for (var _j = 0; _j < pendingOperations.length; _j++) {
      operations[i + _j] = pendingOperations[_j];
    }

    i += pendingOperations.length;

    if (__DEBUG__) {
      printOperationsArray(operations);
    } // If we've already connected to the frontend, just pass the operations through.


    hook.emit('operations', operations);
    pendingOperations.length = 0;
    pendingUnmountedIDs = [];
    pendingUnmountedRootID = null;
    pendingStringTable.clear();
    pendingStringTableLength = 0;
  }

  function pushOperation(op) {
    if (false) {}

    pendingOperations.push(op);
  }

  function getStringID(str) {
    if (str === null) {
      return 0;
    }

    var existingID = pendingStringTable.get(str);

    if (existingID !== undefined) {
      return existingID;
    }

    var stringID = pendingStringTable.size + 1;
    pendingStringTable.set(str, stringID); // The string table total length needs to account
    // both for the string length, and for the array item
    // that contains the length itself. Hence + 1.

    pendingStringTableLength += str.length + 1;
    return stringID;
  }

  var currentlyInspectedElementID = null;
  var currentlyInspectedPaths = {}; // Track the intersection of currently inspected paths,
  // so that we can send their data along if the element is re-rendered.

  function mergeInspectedPaths(path) {
    var current = currentlyInspectedPaths;
    path.forEach(function (key) {
      if (!current[key]) {
        current[key] = {};
      }

      current = current[key];
    });
  }

  function createIsPathAllowed(key) {
    // This function helps prevent previously-inspected paths from being dehydrated in updates.
    // This is important to avoid a bad user experience where expanded toggles collapse on update.
    return function isPathAllowed(path) {
      var current = currentlyInspectedPaths[key];

      if (!current) {
        return false;
      }

      for (var i = 0; i < path.length; i++) {
        current = current[path[i]];

        if (!current) {
          return false;
        }
      }

      return true;
    };
  } // Fast path props lookup for React Native style editor.


  function getInstanceAndStyle(id) {
    var instance = null;
    var style = null;
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      instance = internalInstance._instance || null;
      var element = internalInstance._currentElement;

      if (element != null && element.props != null) {
        style = element.props.style || null;
      }
    }

    return {
      instance: instance,
      style: style
    };
  }

  function updateSelectedElement(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn("Could not find instance with id \"".concat(id, "\""));
      return;
    }

    switch (getElementType(internalInstance)) {
      case ElementTypeClass:
        global.$r = internalInstance._instance;
        break;

      case ElementTypeFunction:
        var element = internalInstance._currentElement;

        if (element == null) {
          console.warn("Could not find element with id \"".concat(id, "\""));
          return;
        }

        global.$r = {
          props: element.props,
          type: element.type
        };
        break;

      default:
        global.$r = null;
        break;
    }
  }

  function storeAsGlobal(id, path, count) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      var value = getInObject(inspectedElement, path);
      var key = "$reactTemp".concat(count);
      window[key] = value;
      console.log(key);
      console.log(value);
    }
  }

  function copyElementPath(id, path) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      copyToClipboard(getInObject(inspectedElement, path));
    }
  }

  function inspectElement(requestID, id, path) {
    if (currentlyInspectedElementID !== id) {
      currentlyInspectedElementID = id;
      currentlyInspectedPaths = {};
    }

    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement === null) {
      return {
        id: id,
        responseID: requestID,
        type: 'not-found'
      };
    }

    if (path !== null) {
      mergeInspectedPaths(path);
    } // Any time an inspected element has an update,
    // we should update the selected $r value as wel.
    // Do this before dehyration (cleanForBridge).


    updateSelectedElement(id);
    inspectedElement.context = cleanForBridge(inspectedElement.context, createIsPathAllowed('context'));
    inspectedElement.props = cleanForBridge(inspectedElement.props, createIsPathAllowed('props'));
    inspectedElement.state = cleanForBridge(inspectedElement.state, createIsPathAllowed('state'));
    return {
      id: id,
      responseID: requestID,
      type: 'full-data',
      value: inspectedElement
    };
  }

  function inspectElementRaw(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      return null;
    }

    var _getData2 = getData(internalInstance),
        displayName = _getData2.displayName,
        key = _getData2.key;

    var type = getElementType(internalInstance);
    var context = null;
    var owners = null;
    var props = null;
    var state = null;
    var source = null;
    var element = internalInstance._currentElement;

    if (element !== null) {
      props = element.props;
      source = element._source != null ? element._source : null;
      var owner = element._owner;

      if (owner) {
        owners = [];

        while (owner != null) {
          owners.push({
            displayName: getData(owner).displayName || 'Unknown',
            id: getID(owner),
            key: element.key,
            type: getElementType(owner)
          });

          if (owner._currentElement) {
            owner = owner._currentElement._owner;
          }
        }
      }
    }

    var publicInstance = internalInstance._instance;

    if (publicInstance != null) {
      context = publicInstance.context || null;
      state = publicInstance.state || null;
    } // Not implemented


    var errors = [];
    var warnings = [];
    return {
      id: id,
      // Does the current renderer support editable hooks and function props?
      canEditHooks: false,
      canEditFunctionProps: false,
      // Does the current renderer support advanced editing interface?
      canEditHooksAndDeletePaths: false,
      canEditHooksAndRenamePaths: false,
      canEditFunctionPropsDeletePaths: false,
      canEditFunctionPropsRenamePaths: false,
      // Toggle error boundary did not exist in legacy versions
      canToggleError: false,
      isErrored: false,
      targetErrorBoundaryID: null,
      // Suspense did not exist in legacy versions
      canToggleSuspense: false,
      // Can view component source location.
      canViewSource: type === ElementTypeClass || type === ElementTypeFunction,
      // Only legacy context exists in legacy versions.
      hasLegacyContext: true,
      displayName: displayName,
      type: type,
      key: key != null ? key : null,
      // Inspectable properties.
      context: context,
      hooks: null,
      props: props,
      state: state,
      errors: errors,
      warnings: warnings,
      // List of owners
      owners: owners,
      // Location of component in source code.
      source: source,
      rootType: null,
      rendererPackageName: null,
      rendererVersion: null
    };
  }

  function logElementToConsole(id) {
    var result = inspectElementRaw(id);

    if (result === null) {
      console.warn("Could not find element with id \"".concat(id, "\""));
      return;
    }

    var supportsGroup = typeof console.groupCollapsed === 'function';

    if (supportsGroup) {
      console.groupCollapsed("[Click to expand] %c<".concat(result.displayName || 'Component', " />"), // --dom-tag-name-color is the CSS variable Chrome styles HTML elements with in the console.
      'color: var(--dom-tag-name-color); font-weight: normal;');
    }

    if (result.props !== null) {
      console.log('Props:', result.props);
    }

    if (result.state !== null) {
      console.log('State:', result.state);
    }

    if (result.context !== null) {
      console.log('Context:', result.context);
    }

    var nativeNode = findNativeNodeForInternalID(id);

    if (nativeNode !== null) {
      console.log('Node:', nativeNode);
    }

    if (window.chrome || /firefox/i.test(navigator.userAgent)) {
      console.log('Right-click any value to save it as a global variable for further inspection.');
    }

    if (supportsGroup) {
      console.groupEnd();
    }
  }

  function prepareViewAttributeSource(id, path) {
    var inspectedElement = inspectElementRaw(id);

    if (inspectedElement !== null) {
      window.$attribute = getInObject(inspectedElement, path);
    }
  }

  function prepareViewElementSource(id) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance == null) {
      console.warn("Could not find instance with id \"".concat(id, "\""));
      return;
    }

    var element = internalInstance._currentElement;

    if (element == null) {
      console.warn("Could not find element with id \"".concat(id, "\""));
      return;
    }

    global.$type = element.type;
  }

  function deletePath(type, id, hookID, path) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            deletePathInObject(publicInstance.context, path);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
              props: copyWithDelete(element.props, path)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            deletePathInObject(publicInstance.state, path);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function renamePath(type, id, hookID, oldPath, newPath) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            renamePathInObject(publicInstance.context, oldPath, newPath);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
              props: copyWithRename(element.props, oldPath, newPath)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            renamePathInObject(publicInstance.state, oldPath, newPath);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  }

  function overrideValueAtPath(type, id, hookID, path, value) {
    var internalInstance = idToInternalInstanceMap.get(id);

    if (internalInstance != null) {
      var publicInstance = internalInstance._instance;

      if (publicInstance != null) {
        switch (type) {
          case 'context':
            setInObject(publicInstance.context, path, value);
            forceUpdate(publicInstance);
            break;

          case 'hooks':
            throw new Error('Hooks not supported by this renderer');

          case 'props':
            var element = internalInstance._currentElement;
            internalInstance._currentElement = legacy_renderer_objectSpread(legacy_renderer_objectSpread({}, element), {}, {
              props: copyWithSet(element.props, path, value)
            });
            forceUpdate(publicInstance);
            break;

          case 'state':
            setInObject(publicInstance.state, path, value);
            forceUpdate(publicInstance);
            break;
        }
      }
    }
  } // v16+ only features


  var getProfilingData = function getProfilingData() {
    throw new Error('getProfilingData not supported by this renderer');
  };

  var handleCommitFiberRoot = function handleCommitFiberRoot() {
    throw new Error('handleCommitFiberRoot not supported by this renderer');
  };

  var handleCommitFiberUnmount = function handleCommitFiberUnmount() {
    throw new Error('handleCommitFiberUnmount not supported by this renderer');
  };

  var handlePostCommitFiberRoot = function handlePostCommitFiberRoot() {
    throw new Error('handlePostCommitFiberRoot not supported by this renderer');
  };

  var overrideError = function overrideError() {
    throw new Error('overrideError not supported by this renderer');
  };

  var overrideSuspense = function overrideSuspense() {
    throw new Error('overrideSuspense not supported by this renderer');
  };

  var startProfiling = function startProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  var stopProfiling = function stopProfiling() {// Do not throw, since this would break a multi-root scenario where v15 and v16 were both present.
  };

  function getBestMatchForTrackedPath() {
    // Not implemented.
    return null;
  }

  function getPathForElement(id) {
    // Not implemented.
    return null;
  }

  function updateComponentFilters(componentFilters) {// Not implemented.
  }

  function setTraceUpdatesEnabled(enabled) {// Not implemented.
  }

  function setTrackedPath(path) {// Not implemented.
  }

  function getOwnersList(id) {
    // Not implemented.
    return null;
  }

  function clearErrorsAndWarnings() {// Not implemented
  }

  function clearErrorsForFiberID(id) {// Not implemented
  }

  function clearWarningsForFiberID(id) {// Not implemented
  }

  return {
    clearErrorsAndWarnings: clearErrorsAndWarnings,
    clearErrorsForFiberID: clearErrorsForFiberID,
    clearWarningsForFiberID: clearWarningsForFiberID,
    cleanup: cleanup,
    copyElementPath: copyElementPath,
    deletePath: deletePath,
    flushInitialOperations: flushInitialOperations,
    getBestMatchForTrackedPath: getBestMatchForTrackedPath,
    getDisplayNameForFiberID: getDisplayNameForFiberID,
    getFiberIDForNative: getInternalIDForNative,
    getInstanceAndStyle: getInstanceAndStyle,
    findNativeNodesForFiberID: function findNativeNodesForFiberID(id) {
      var nativeNode = findNativeNodeForInternalID(id);
      return nativeNode == null ? null : [nativeNode];
    },
    getOwnersList: getOwnersList,
    getPathForElement: getPathForElement,
    getProfilingData: getProfilingData,
    handleCommitFiberRoot: handleCommitFiberRoot,
    handleCommitFiberUnmount: handleCommitFiberUnmount,
    handlePostCommitFiberRoot: handlePostCommitFiberRoot,
    inspectElement: inspectElement,
    logElementToConsole: logElementToConsole,
    overrideError: overrideError,
    overrideSuspense: overrideSuspense,
    overrideValueAtPath: overrideValueAtPath,
    renamePath: renamePath,
    prepareViewAttributeSource: prepareViewAttributeSource,
    prepareViewElementSource: prepareViewElementSource,
    renderer: renderer,
    setTraceUpdatesEnabled: setTraceUpdatesEnabled,
    setTrackedPath: setTrackedPath,
    startProfiling: startProfiling,
    stopProfiling: stopProfiling,
    storeAsGlobal: storeAsGlobal,
    updateComponentFilters: updateComponentFilters
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/index.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */



function initBackend(hook, agent, global) {
  if (hook == null) {
    // DevTools didn't get injected into this page (maybe b'c of the contentType).
    return function () {};
  }

  var subs = [hook.sub('renderer-attached', function (_ref) {
    var id = _ref.id,
        renderer = _ref.renderer,
        rendererInterface = _ref.rendererInterface;
    agent.setRendererInterface(id, rendererInterface); // Now that the Store and the renderer interface are connected,
    // it's time to flush the pending operation codes to the frontend.

    rendererInterface.flushInitialOperations();
  }), hook.sub('unsupported-renderer-version', function (id) {
    agent.onUnsupportedRenderer(id);
  }), hook.sub('fastRefreshScheduled', agent.onFastRefreshScheduled), hook.sub('operations', agent.onHookOperations), hook.sub('traceUpdates', agent.onTraceUpdates) // TODO Add additional subscriptions required for profiling mode
  ];

  var attachRenderer = function attachRenderer(id, renderer) {
    var rendererInterface = hook.rendererInterfaces.get(id); // Inject any not-yet-injected renderers (if we didn't reload-and-profile)

    if (rendererInterface == null) {
      if (typeof renderer.findFiberByHostInstance === 'function') {
        // react-reconciler v16+
        rendererInterface = renderer_attach(hook, id, renderer, global);
      } else if (renderer.ComponentTree) {
        // react-dom v15
        rendererInterface = legacy_renderer_attach(hook, id, renderer, global);
      } else {// Older react-dom or other unsupported renderer version
      }

      if (rendererInterface != null) {
        hook.rendererInterfaces.set(id, rendererInterface);
      }
    } // Notify the DevTools frontend about new renderers.
    // This includes any that were attached early (via __REACT_DEVTOOLS_ATTACH__).


    if (rendererInterface != null) {
      hook.emit('renderer-attached', {
        id: id,
        renderer: renderer,
        rendererInterface: rendererInterface
      });
    } else {
      hook.emit('unsupported-renderer-version', id);
    }
  }; // Connect renderers that have already injected themselves.


  hook.renderers.forEach(function (renderer, id) {
    attachRenderer(id, renderer);
  }); // Connect any new renderers that injected themselves.

  subs.push(hook.sub('renderer', function (_ref2) {
    var id = _ref2.id,
        renderer = _ref2.renderer;
    attachRenderer(id, renderer);
  }));
  hook.emit('react-devtools', agent);
  hook.reactDevtoolsAgent = agent;

  var onAgentShutdown = function onAgentShutdown() {
    subs.forEach(function (fn) {
      return fn();
    });
    hook.rendererInterfaces.forEach(function (rendererInterface) {
      rendererInterface.cleanup();
    });
    hook.reactDevtoolsAgent = null;
  };

  agent.addListener('shutdown', onAgentShutdown);
  subs.push(function () {
    agent.removeListener('shutdown', onAgentShutdown);
  });
  return function () {
    subs.forEach(function (fn) {
      return fn();
    });
  };
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/resolveBoxStyle.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

/**
 * This mirrors react-native/Libraries/Inspector/resolveBoxStyle.js (but without RTL support).
 *
 * Resolve a style property into it's component parts, e.g.
 *
 * resolveBoxStyle('margin', {margin: 5, marginBottom: 10})
 * -> {top: 5, left: 5, right: 5, bottom: 10}
 */
function resolveBoxStyle(prefix, style) {
  var hasParts = false;
  var result = {
    bottom: 0,
    left: 0,
    right: 0,
    top: 0
  };
  var styleForAll = style[prefix];

  if (styleForAll != null) {
    // eslint-disable-next-line no-for-of-loops/no-for-of-loops
    for (var _i = 0, _Object$keys = Object.keys(result); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      result[key] = styleForAll;
    }

    hasParts = true;
  }

  var styleForHorizontal = style[prefix + 'Horizontal'];

  if (styleForHorizontal != null) {
    result.left = styleForHorizontal;
    result.right = styleForHorizontal;
    hasParts = true;
  } else {
    var styleForLeft = style[prefix + 'Left'];

    if (styleForLeft != null) {
      result.left = styleForLeft;
      hasParts = true;
    }

    var styleForRight = style[prefix + 'Right'];

    if (styleForRight != null) {
      result.right = styleForRight;
      hasParts = true;
    }

    var styleForEnd = style[prefix + 'End'];

    if (styleForEnd != null) {
      // TODO RTL support
      result.right = styleForEnd;
      hasParts = true;
    }

    var styleForStart = style[prefix + 'Start'];

    if (styleForStart != null) {
      // TODO RTL support
      result.left = styleForStart;
      hasParts = true;
    }
  }

  var styleForVertical = style[prefix + 'Vertical'];

  if (styleForVertical != null) {
    result.bottom = styleForVertical;
    result.top = styleForVertical;
    hasParts = true;
  } else {
    var styleForBottom = style[prefix + 'Bottom'];

    if (styleForBottom != null) {
      result.bottom = styleForBottom;
      hasParts = true;
    }

    var styleForTop = style[prefix + 'Top'];

    if (styleForTop != null) {
      result.top = styleForTop;
      hasParts = true;
    }
  }

  return hasParts ? result : null;
}
// CONCATENATED MODULE: ../react-devtools-shared/src/backend/NativeStyleEditor/setupNativeStyleEditor.js
function setupNativeStyleEditor_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { setupNativeStyleEditor_typeof = function _typeof(obj) { return typeof obj; }; } else { setupNativeStyleEditor_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return setupNativeStyleEditor_typeof(obj); }

function setupNativeStyleEditor_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */


function setupNativeStyleEditor(bridge, agent, resolveNativeStyle, validAttributes) {
  bridge.addListener('NativeStyleEditor_measure', function (_ref) {
    var id = _ref.id,
        rendererID = _ref.rendererID;
    measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
  });
  bridge.addListener('NativeStyleEditor_renameAttribute', function (_ref2) {
    var id = _ref2.id,
        rendererID = _ref2.rendererID,
        oldName = _ref2.oldName,
        newName = _ref2.newName,
        value = _ref2.value;
    renameStyle(agent, id, rendererID, oldName, newName, value);
    setTimeout(function () {
      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
    });
  });
  bridge.addListener('NativeStyleEditor_setValue', function (_ref3) {
    var id = _ref3.id,
        rendererID = _ref3.rendererID,
        name = _ref3.name,
        value = _ref3.value;
    setStyle(agent, id, rendererID, name, value);
    setTimeout(function () {
      return measureStyle(agent, bridge, resolveNativeStyle, id, rendererID);
    });
  });
  bridge.send('isNativeStyleEditorSupported', {
    isSupported: true,
    validAttributes: validAttributes
  });
}
var EMPTY_BOX_STYLE = {
  top: 0,
  left: 0,
  right: 0,
  bottom: 0
};
var componentIDToStyleOverrides = new Map();

function measureStyle(agent, bridge, resolveNativeStyle, id, rendererID) {
  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: null,
      style: null
    });
    return;
  }

  var instance = data.instance,
      style = data.style;
  var resolvedStyle = resolveNativeStyle(style); // If it's a host component we edited before, amend styles.

  var styleOverrides = componentIDToStyleOverrides.get(id);

  if (styleOverrides != null) {
    resolvedStyle = Object.assign({}, resolvedStyle, styleOverrides);
  }

  if (!instance || typeof instance.measure !== 'function') {
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: null,
      style: resolvedStyle || null
    });
    return;
  } // $FlowFixMe the parameter types of an unknown function are unknown


  instance.measure(function (x, y, width, height, left, top) {
    // RN Android sometimes returns undefined here. Don't send measurements in this case.
    // https://github.com/jhen0409/react-native-debugger/issues/84#issuecomment-304611817
    if (typeof x !== 'number') {
      bridge.send('NativeStyleEditor_styleAndLayout', {
        id: id,
        layout: null,
        style: resolvedStyle || null
      });
      return;
    }

    var margin = resolvedStyle != null && resolveBoxStyle('margin', resolvedStyle) || EMPTY_BOX_STYLE;
    var padding = resolvedStyle != null && resolveBoxStyle('padding', resolvedStyle) || EMPTY_BOX_STYLE;
    bridge.send('NativeStyleEditor_styleAndLayout', {
      id: id,
      layout: {
        x: x,
        y: y,
        width: width,
        height: height,
        left: left,
        top: top,
        margin: margin,
        padding: padding
      },
      style: resolvedStyle || null
    });
  });
}

function shallowClone(object) {
  var cloned = {};

  for (var n in object) {
    cloned[n] = object[n];
  }

  return cloned;
}

function renameStyle(agent, id, rendererID, oldName, newName, value) {
  var _ref4;

  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    return;
  }

  var instance = data.instance,
      style = data.style;
  var newStyle = newName ? (_ref4 = {}, setupNativeStyleEditor_defineProperty(_ref4, oldName, undefined), setupNativeStyleEditor_defineProperty(_ref4, newName, value), _ref4) : setupNativeStyleEditor_defineProperty({}, oldName, undefined);
  var customStyle; // TODO It would be nice if the renderer interface abstracted this away somehow.

  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    var styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Array.isArray(style)) {
    var lastIndex = style.length - 1;

    if (setupNativeStyleEditor_typeof(style[lastIndex]) === 'object' && !Array.isArray(style[lastIndex])) {
      customStyle = shallowClone(style[lastIndex]);
      delete customStyle[oldName];

      if (newName) {
        customStyle[newName] = value;
      } else {
        customStyle[oldName] = undefined;
      }

      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style', lastIndex],
        value: customStyle
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else if (setupNativeStyleEditor_typeof(style) === 'object') {
    customStyle = shallowClone(style);
    delete customStyle[oldName];

    if (newName) {
      customStyle[newName] = value;
    } else {
      customStyle[oldName] = undefined;
    }

    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: customStyle
    });
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}

function setStyle(agent, id, rendererID, name, value) {
  var data = agent.getInstanceAndStyle({
    id: id,
    rendererID: rendererID
  });

  if (!data || !data.style) {
    return;
  }

  var instance = data.instance,
      style = data.style;

  var newStyle = setupNativeStyleEditor_defineProperty({}, name, value); // TODO It would be nice if the renderer interface abstracted this away somehow.


  if (instance !== null && typeof instance.setNativeProps === 'function') {
    // In the case of a host component, we need to use setNativeProps().
    // Remember to "correct" resolved styles when we read them next time.
    var styleOverrides = componentIDToStyleOverrides.get(id);

    if (!styleOverrides) {
      componentIDToStyleOverrides.set(id, newStyle);
    } else {
      Object.assign(styleOverrides, newStyle);
    } // TODO Fabric does not support setNativeProps; chat with Sebastian or Eli


    instance.setNativeProps({
      style: newStyle
    });
  } else if (Array.isArray(style)) {
    var lastLength = style.length - 1;

    if (setupNativeStyleEditor_typeof(style[lastLength]) === 'object' && !Array.isArray(style[lastLength])) {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style', lastLength, name],
        value: value
      });
    } else {
      agent.overrideValueAtPath({
        type: 'props',
        id: id,
        rendererID: rendererID,
        path: ['style'],
        value: style.concat([newStyle])
      });
    }
  } else {
    agent.overrideValueAtPath({
      type: 'props',
      id: id,
      rendererID: rendererID,
      path: ['style'],
      value: [style, newStyle]
    });
  }

  agent.emit('hideNativeHighlight');
}
// CONCATENATED MODULE: ./src/backend.js
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */







installHook(window);
var backend_hook = window.__REACT_DEVTOOLS_GLOBAL_HOOK__;
var savedComponentFilters = getDefaultComponentFilters();

function backend_debug(methodName) {
  if (__DEBUG__) {
    var _console;

    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    (_console = console).log.apply(_console, ["%c[core/backend] %c".concat(methodName), 'color: teal; font-weight: bold;', 'font-weight: bold;'].concat(args));
  }
}

function connectToDevTools(options) {
  if (backend_hook == null) {
    // DevTools didn't get injected into this page (maybe b'c of the contentType).
    return;
  }

  var _ref = options || {},
      _ref$host = _ref.host,
      host = _ref$host === void 0 ? 'localhost' : _ref$host,
      nativeStyleEditorValidAttributes = _ref.nativeStyleEditorValidAttributes,
      _ref$useHttps = _ref.useHttps,
      useHttps = _ref$useHttps === void 0 ? false : _ref$useHttps,
      _ref$port = _ref.port,
      port = _ref$port === void 0 ? 8097 : _ref$port,
      websocket = _ref.websocket,
      _ref$resolveRNStyle = _ref.resolveRNStyle,
      resolveRNStyle = _ref$resolveRNStyle === void 0 ? null : _ref$resolveRNStyle,
      _ref$retryConnectionD = _ref.retryConnectionDelay,
      retryConnectionDelay = _ref$retryConnectionD === void 0 ? 2000 : _ref$retryConnectionD,
      _ref$isAppActive = _ref.isAppActive,
      isAppActive = _ref$isAppActive === void 0 ? function () {
    return true;
  } : _ref$isAppActive;

  var protocol = useHttps ? 'wss' : 'ws';
  var retryTimeoutID = null;

  function scheduleRetry() {
    if (retryTimeoutID === null) {
      // Two seconds because RN had issues with quick retries.
      retryTimeoutID = setTimeout(function () {
        return connectToDevTools(options);
      }, retryConnectionDelay);
    }
  }

  if (!isAppActive()) {
    // If the app is in background, maybe retry later.
    // Don't actually attempt to connect until we're in foreground.
    scheduleRetry();
    return;
  }

  var bridge = null;
  var messageListeners = [];
  var uri = protocol + '://' + host + ':' + port; // If existing websocket is passed, use it.
  // This is necessary to support our custom integrations.
  // See D6251744.

  var ws = websocket ? websocket : new window.WebSocket(uri);
  ws.onclose = handleClose;
  ws.onerror = handleFailed;
  ws.onmessage = handleMessage;

  ws.onopen = function () {
    bridge = new src_bridge({
      listen: function listen(fn) {
        messageListeners.push(fn);
        return function () {
          var index = messageListeners.indexOf(fn);

          if (index >= 0) {
            messageListeners.splice(index, 1);
          }
        };
      },
      send: function send(event, payload, transferable) {
        if (ws.readyState === ws.OPEN) {
          if (__DEBUG__) {
            backend_debug('wall.send()', event, payload);
          }

          ws.send(JSON.stringify({
            event: event,
            payload: payload
          }));
        } else {
          if (__DEBUG__) {
            backend_debug('wall.send()', 'Shutting down bridge because of closed WebSocket connection');
          }

          if (bridge !== null) {
            bridge.shutdown();
          }

          scheduleRetry();
        }
      }
    });
    bridge.addListener('inspectElement', function (_ref2) {
      var id = _ref2.id,
          rendererID = _ref2.rendererID;
      var renderer = agent.rendererInterfaces[rendererID];

      if (renderer != null) {
        // Send event for RN to highlight.
        var nodes = renderer.findNativeNodesForFiberID(id);

        if (nodes != null && nodes[0] != null) {
          agent.emit('showNativeHighlight', nodes[0]);
        }
      }
    });
    bridge.addListener('updateComponentFilters', function (componentFilters) {
      // Save filter changes in memory, in case DevTools is reloaded.
      // In that case, the renderer will already be using the updated values.
      // We'll lose these in between backend reloads but that can't be helped.
      savedComponentFilters = componentFilters;
    }); // The renderer interface doesn't read saved component filters directly,
    // because they are generally stored in localStorage within the context of the extension.
    // Because of this it relies on the extension to pass filters.
    // In the case of the standalone DevTools being used with a website,
    // saved filters are injected along with the backend script tag so we shouldn't override them here.
    // This injection strategy doesn't work for React Native though.
    // Ideally the backend would save the filters itself, but RN doesn't provide a sync storage solution.
    // So for now we just fall back to using the default filters...

    if (window.__REACT_DEVTOOLS_COMPONENT_FILTERS__ == null) {
      bridge.send('overrideComponentFilters', savedComponentFilters);
    } // TODO (npm-packages) Warn if "isBackendStorageAPISupported"


    var agent = new agent_Agent(bridge);
    agent.addListener('shutdown', function () {
      // If we received 'shutdown' from `agent`, we assume the `bridge` is already shutting down,
      // and that caused the 'shutdown' event on the `agent`, so we don't need to call `bridge.shutdown()` here.
      backend_hook.emit('shutdown');
    });
    initBackend(backend_hook, agent, window); // Setup React Native style editor if the environment supports it.

    if (resolveRNStyle != null || backend_hook.resolveRNStyle != null) {
      setupNativeStyleEditor(bridge, agent, resolveRNStyle || backend_hook.resolveRNStyle, nativeStyleEditorValidAttributes || backend_hook.nativeStyleEditorValidAttributes || null);
    } else {
      // Otherwise listen to detect if the environment later supports it.
      // For example, Flipper does not eagerly inject these values.
      // Instead it relies on the React Native Inspector to lazily inject them.
      var lazyResolveRNStyle;
      var lazyNativeStyleEditorValidAttributes;

      var initAfterTick = function initAfterTick() {
        if (bridge !== null) {
          setupNativeStyleEditor(bridge, agent, lazyResolveRNStyle, lazyNativeStyleEditorValidAttributes);
        }
      };

      if (!backend_hook.hasOwnProperty('resolveRNStyle')) {
        Object.defineProperty(backend_hook, 'resolveRNStyle', {
          enumerable: false,
          get: function get() {
            return lazyResolveRNStyle;
          },
          set: function set(value) {
            lazyResolveRNStyle = value;
            initAfterTick();
          }
        });
      }

      if (!backend_hook.hasOwnProperty('nativeStyleEditorValidAttributes')) {
        Object.defineProperty(backend_hook, 'nativeStyleEditorValidAttributes', {
          enumerable: false,
          get: function get() {
            return lazyNativeStyleEditorValidAttributes;
          },
          set: function set(value) {
            lazyNativeStyleEditorValidAttributes = value;
            initAfterTick();
          }
        });
      }
    }
  };

  function handleClose() {
    if (__DEBUG__) {
      backend_debug('WebSocket.onclose');
    }

    if (bridge !== null) {
      bridge.emit('shutdown');
    }

    scheduleRetry();
  }

  function handleFailed() {
    if (__DEBUG__) {
      backend_debug('WebSocket.onerror');
    }

    scheduleRetry();
  }

  function handleMessage(event) {
    var data;

    try {
      if (typeof event.data === 'string') {
        data = JSON.parse(event.data);

        if (__DEBUG__) {
          backend_debug('WebSocket.onmessage', data);
        }
      } else {
        throw Error();
      }
    } catch (e) {
      console.error('[React DevTools] Failed to parse JSON: ' + event.data);
      return;
    }

    messageListeners.forEach(function (fn) {
      try {
        fn(data);
      } catch (error) {
        // jsc doesn't play so well with tracebacks that go into eval'd code,
        // so the stack trace here will stop at the `(0,eval)()` call. Getting the
        // message that caused the error is the best we can do for now.
        console.log('[React DevTools] Error calling listener', data);
        console.log('error:', error);
        throw error;
      }
    });
  }
}

/***/ })
/******/ ]);
});
//# sourceMappingURL=backend.js.map
      };
    };
  }
}, {package:"react-devtools>react-devtools-core",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-devtools\\index.js", {"react-devtools-core/backend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-devtools-core\\backend.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-devtools\index.js
      return function (require, module, exports) {
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow
 */

const {connectToDevTools} = require('react-devtools-core/backend');

// Connect immediately with default options.
// If you need more control, use `react-devtools-core` directly instead of `react-devtools`.
connectToDevTools();

      };
    };
  }
}, {package:"react-devtools",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\BrowserDetector.js", {"./utils/discount_lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\utils\\discount_lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\BrowserDetector.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var discount_lodash_1 = require("./utils/discount_lodash");
exports.isFirefox = discount_lodash_1.memoize(function () {
    return /firefox/i.test(navigator.userAgent);
});
exports.isSafari = discount_lodash_1.memoize(function () { return Boolean(window.safari); });

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\EnterLeaveCounter.js", {"./utils/discount_lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\utils\\discount_lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\EnterLeaveCounter.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var discount_lodash_1 = require("./utils/discount_lodash");
var EnterLeaveCounter = /** @class */ (function () {
    function EnterLeaveCounter(isNodeInDocument) {
        this.entered = [];
        this.isNodeInDocument = isNodeInDocument;
    }
    EnterLeaveCounter.prototype.enter = function (enteringNode) {
        var _this = this;
        var previousLength = this.entered.length;
        var isNodeEntered = function (node) {
            return _this.isNodeInDocument(node) &&
                (!node.contains || node.contains(enteringNode));
        };
        this.entered = discount_lodash_1.union(this.entered.filter(isNodeEntered), [enteringNode]);
        return previousLength === 0 && this.entered.length > 0;
    };
    EnterLeaveCounter.prototype.leave = function (leavingNode) {
        var previousLength = this.entered.length;
        this.entered = discount_lodash_1.without(this.entered.filter(this.isNodeInDocument), leavingNode);
        return previousLength > 0 && this.entered.length === 0;
    };
    EnterLeaveCounter.prototype.reset = function () {
        this.entered = [];
    };
    return EnterLeaveCounter;
}());
exports.default = EnterLeaveCounter;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\HTML5Backend.js", {"./BrowserDetector":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\BrowserDetector.js","./EnterLeaveCounter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\EnterLeaveCounter.js","./NativeDragSources":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\index.js","./NativeTypes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeTypes.js","./OffsetUtils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\OffsetUtils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\HTML5Backend.js
      return function (require, module, exports) {
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var EnterLeaveCounter_1 = require("./EnterLeaveCounter");
var BrowserDetector_1 = require("./BrowserDetector");
var OffsetUtils_1 = require("./OffsetUtils");
var NativeDragSources_1 = require("./NativeDragSources");
var NativeTypes = require("./NativeTypes");
var HTML5Backend = /** @class */ (function () {
    function HTML5Backend(manager) {
        var _this = this;
        this.sourcePreviewNodes = new Map();
        this.sourcePreviewNodeOptions = new Map();
        this.sourceNodes = new Map();
        this.sourceNodeOptions = new Map();
        this.dragStartSourceIds = null;
        this.dropTargetIds = [];
        this.dragEnterTargetIds = [];
        this.currentNativeSource = null;
        this.currentNativeHandle = null;
        this.currentDragSourceNode = null;
        this.altKeyPressed = false;
        this.mouseMoveTimeoutTimer = null;
        this.asyncEndDragFrameId = null;
        this.dragOverTargetIds = null;
        this.getSourceClientOffset = function (sourceId) {
            return OffsetUtils_1.getNodeClientOffset(_this.sourceNodes.get(sourceId));
        };
        this.endDragNativeItem = function () {
            if (!_this.isDraggingNativeItem()) {
                return;
            }
            _this.actions.endDrag();
            _this.registry.removeSource(_this.currentNativeHandle);
            _this.currentNativeHandle = null;
            _this.currentNativeSource = null;
        };
        this.isNodeInDocument = function (node) {
            // Check the node either in the main document or in the current context
            return ((!!document && document.body.contains(node)) ||
                (!!_this.window && _this.window.document.body.contains(node)));
        };
        this.endDragIfSourceWasRemovedFromDOM = function () {
            var node = _this.currentDragSourceNode;
            if (_this.isNodeInDocument(node)) {
                return;
            }
            if (_this.clearCurrentDragSourceNode()) {
                _this.actions.endDrag();
            }
        };
        this.handleTopDragStartCapture = function () {
            _this.clearCurrentDragSourceNode();
            _this.dragStartSourceIds = [];
        };
        this.handleTopDragStart = function (e) {
            var dragStartSourceIds = _this.dragStartSourceIds;
            _this.dragStartSourceIds = null;
            var clientOffset = OffsetUtils_1.getEventClientOffset(e);
            // Avoid crashing if we missed a drop event or our previous drag died
            if (_this.monitor.isDragging()) {
                _this.actions.endDrag();
            }
            // Don't publish the source just yet (see why below)
            _this.actions.beginDrag(dragStartSourceIds || [], {
                publishSource: false,
                getSourceClientOffset: _this.getSourceClientOffset,
                clientOffset: clientOffset,
            });
            var dataTransfer = e.dataTransfer;
            var nativeType = NativeDragSources_1.matchNativeItemType(dataTransfer);
            if (_this.monitor.isDragging()) {
                if (dataTransfer && typeof dataTransfer.setDragImage === 'function') {
                    // Use custom drag image if user specifies it.
                    // If child drag source refuses drag but parent agrees,
                    // use parent's node as drag image. Neither works in IE though.
                    var sourceId = _this.monitor.getSourceId();
                    var sourceNode = _this.sourceNodes.get(sourceId);
                    var dragPreview = _this.sourcePreviewNodes.get(sourceId) || sourceNode;
                    if (dragPreview) {
                        var _a = _this.getCurrentSourcePreviewNodeOptions(), anchorX = _a.anchorX, anchorY = _a.anchorY, offsetX = _a.offsetX, offsetY = _a.offsetY;
                        var anchorPoint = { anchorX: anchorX, anchorY: anchorY };
                        var offsetPoint = { offsetX: offsetX, offsetY: offsetY };
                        var dragPreviewOffset = OffsetUtils_1.getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
                        dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
                    }
                }
                try {
                    // Firefox won't drag without setting data
                    dataTransfer.setData('application/json', {});
                }
                catch (err) {
                    // IE doesn't support MIME types in setData
                }
                // Store drag source node so we can check whether
                // it is removed from DOM and trigger endDrag manually.
                _this.setCurrentDragSourceNode(e.target);
                // Now we are ready to publish the drag source.. or are we not?
                var captureDraggingState = _this.getCurrentSourcePreviewNodeOptions().captureDraggingState;
                if (!captureDraggingState) {
                    // Usually we want to publish it in the next tick so that browser
                    // is able to screenshot the current (not yet dragging) state.
                    //
                    // It also neatly avoids a situation where render() returns null
                    // in the same tick for the source element, and browser freaks out.
                    setTimeout(function () { return _this.actions.publishDragSource(); }, 0);
                }
                else {
                    // In some cases the user may want to override this behavior, e.g.
                    // to work around IE not supporting custom drag previews.
                    //
                    // When using a custom drag layer, the only way to prevent
                    // the default drag preview from drawing in IE is to screenshot
                    // the dragging state in which the node itself has zero opacity
                    // and height. In this case, though, returning null from render()
                    // will abruptly end the dragging, which is not obvious.
                    //
                    // This is the reason such behavior is strictly opt-in.
                    _this.actions.publishDragSource();
                }
            }
            else if (nativeType) {
                // A native item (such as URL) dragged from inside the document
                _this.beginDragNativeItem(nativeType);
            }
            else if (dataTransfer &&
                !dataTransfer.types &&
                ((e.target && !e.target.hasAttribute) ||
                    !e.target.hasAttribute('draggable'))) {
                // Looks like a Safari bug: dataTransfer.types is null, but there was no draggable.
                // Just let it drag. It's a native type (URL or text) and will be picked up in
                // dragenter handler.
                return;
            }
            else {
                // If by this time no drag source reacted, tell browser not to drag.
                e.preventDefault();
            }
        };
        this.handleTopDragEndCapture = function () {
            if (_this.clearCurrentDragSourceNode()) {
                // Firefox can dispatch this event in an infinite loop
                // if dragend handler does something like showing an alert.
                // Only proceed if we have not handled it already.
                _this.actions.endDrag();
            }
        };
        this.handleTopDragEnterCapture = function (e) {
            _this.dragEnterTargetIds = [];
            var isFirstEnter = _this.enterLeaveCounter.enter(e.target);
            if (!isFirstEnter || _this.monitor.isDragging()) {
                return;
            }
            var dataTransfer = e.dataTransfer;
            var nativeType = NativeDragSources_1.matchNativeItemType(dataTransfer);
            if (nativeType) {
                // A native item (such as file or URL) dragged from outside the document
                _this.beginDragNativeItem(nativeType);
            }
        };
        this.handleTopDragEnter = function (e) {
            var dragEnterTargetIds = _this.dragEnterTargetIds;
            _this.dragEnterTargetIds = [];
            if (!_this.monitor.isDragging()) {
                // This is probably a native item type we don't understand.
                return;
            }
            _this.altKeyPressed = e.altKey;
            if (!BrowserDetector_1.isFirefox()) {
                // Don't emit hover in `dragenter` on Firefox due to an edge case.
                // If the target changes position as the result of `dragenter`, Firefox
                // will still happily dispatch `dragover` despite target being no longer
                // there. The easy solution is to only fire `hover` in `dragover` on FF.
                _this.actions.hover(dragEnterTargetIds, {
                    clientOffset: OffsetUtils_1.getEventClientOffset(e),
                });
            }
            var canDrop = dragEnterTargetIds.some(function (targetId) {
                return _this.monitor.canDropOnTarget(targetId);
            });
            if (canDrop) {
                // IE requires this to fire dragover events
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = _this.getCurrentDropEffect();
                }
            }
        };
        this.handleTopDragOverCapture = function () {
            _this.dragOverTargetIds = [];
        };
        this.handleTopDragOver = function (e) {
            var dragOverTargetIds = _this.dragOverTargetIds;
            _this.dragOverTargetIds = [];
            if (!_this.monitor.isDragging()) {
                // This is probably a native item type we don't understand.
                // Prevent default "drop and blow away the whole document" action.
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'none';
                }
                return;
            }
            _this.altKeyPressed = e.altKey;
            _this.actions.hover(dragOverTargetIds || [], {
                clientOffset: OffsetUtils_1.getEventClientOffset(e),
            });
            var canDrop = (dragOverTargetIds || []).some(function (targetId) {
                return _this.monitor.canDropOnTarget(targetId);
            });
            if (canDrop) {
                // Show user-specified drop effect.
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = _this.getCurrentDropEffect();
                }
            }
            else if (_this.isDraggingNativeItem()) {
                // Don't show a nice cursor but still prevent default
                // "drop and blow away the whole document" action.
                e.preventDefault();
            }
            else {
                e.preventDefault();
                if (e.dataTransfer) {
                    e.dataTransfer.dropEffect = 'none';
                }
            }
        };
        this.handleTopDragLeaveCapture = function (e) {
            if (_this.isDraggingNativeItem()) {
                e.preventDefault();
            }
            var isLastLeave = _this.enterLeaveCounter.leave(e.target);
            if (!isLastLeave) {
                return;
            }
            if (_this.isDraggingNativeItem()) {
                _this.endDragNativeItem();
            }
        };
        this.handleTopDropCapture = function (e) {
            _this.dropTargetIds = [];
            e.preventDefault();
            if (_this.isDraggingNativeItem()) {
                _this.currentNativeSource.mutateItemByReadingDataTransfer(e.dataTransfer);
            }
            _this.enterLeaveCounter.reset();
        };
        this.handleTopDrop = function (e) {
            var dropTargetIds = _this.dropTargetIds;
            _this.dropTargetIds = [];
            _this.actions.hover(dropTargetIds, {
                clientOffset: OffsetUtils_1.getEventClientOffset(e),
            });
            _this.actions.drop({ dropEffect: _this.getCurrentDropEffect() });
            if (_this.isDraggingNativeItem()) {
                _this.endDragNativeItem();
            }
            else {
                _this.endDragIfSourceWasRemovedFromDOM();
            }
        };
        this.handleSelectStart = function (e) {
            var target = e.target;
            // Only IE requires us to explicitly say
            // we want drag drop operation to start
            if (typeof target.dragDrop !== 'function') {
                return;
            }
            // Inputs and textareas should be selectable
            if (target.tagName === 'INPUT' ||
                target.tagName === 'SELECT' ||
                target.tagName === 'TEXTAREA' ||
                target.isContentEditable) {
                return;
            }
            // For other targets, ask IE
            // to enable drag and drop
            e.preventDefault();
            target.dragDrop();
        };
        this.actions = manager.getActions();
        this.monitor = manager.getMonitor();
        this.registry = manager.getRegistry();
        this.context = manager.getContext();
        this.enterLeaveCounter = new EnterLeaveCounter_1.default(this.isNodeInDocument);
    }
    Object.defineProperty(HTML5Backend.prototype, "window", {
        // public for test
        get: function () {
            if (this.context && this.context.window) {
                return this.context.window;
            }
            else if (typeof window !== 'undefined') {
                return window;
            }
            return undefined;
        },
        enumerable: true,
        configurable: true
    });
    HTML5Backend.prototype.setup = function () {
        if (this.window === undefined) {
            return;
        }
        if (this.window.__isReactDndBackendSetUp) {
            throw new Error('Cannot have two HTML5 backends at the same time.');
        }
        this.window.__isReactDndBackendSetUp = true;
        this.addEventListeners(this.window);
    };
    HTML5Backend.prototype.teardown = function () {
        if (this.window === undefined) {
            return;
        }
        this.window.__isReactDndBackendSetUp = false;
        this.removeEventListeners(this.window);
        this.clearCurrentDragSourceNode();
        if (this.asyncEndDragFrameId) {
            this.window.cancelAnimationFrame(this.asyncEndDragFrameId);
        }
    };
    HTML5Backend.prototype.connectDragPreview = function (sourceId, node, options) {
        var _this = this;
        this.sourcePreviewNodeOptions.set(sourceId, options);
        this.sourcePreviewNodes.set(sourceId, node);
        return function () {
            _this.sourcePreviewNodes.delete(sourceId);
            _this.sourcePreviewNodeOptions.delete(sourceId);
        };
    };
    HTML5Backend.prototype.connectDragSource = function (sourceId, node, options) {
        var _this = this;
        this.sourceNodes.set(sourceId, node);
        this.sourceNodeOptions.set(sourceId, options);
        var handleDragStart = function (e) { return _this.handleDragStart(e, sourceId); };
        var handleSelectStart = function (e) { return _this.handleSelectStart(e); };
        node.setAttribute('draggable', 'true');
        node.addEventListener('dragstart', handleDragStart);
        node.addEventListener('selectstart', handleSelectStart);
        return function () {
            _this.sourceNodes.delete(sourceId);
            _this.sourceNodeOptions.delete(sourceId);
            node.removeEventListener('dragstart', handleDragStart);
            node.removeEventListener('selectstart', handleSelectStart);
            node.setAttribute('draggable', 'false');
        };
    };
    HTML5Backend.prototype.connectDropTarget = function (targetId, node) {
        var _this = this;
        var handleDragEnter = function (e) { return _this.handleDragEnter(e, targetId); };
        var handleDragOver = function (e) { return _this.handleDragOver(e, targetId); };
        var handleDrop = function (e) { return _this.handleDrop(e, targetId); };
        node.addEventListener('dragenter', handleDragEnter);
        node.addEventListener('dragover', handleDragOver);
        node.addEventListener('drop', handleDrop);
        return function () {
            node.removeEventListener('dragenter', handleDragEnter);
            node.removeEventListener('dragover', handleDragOver);
            node.removeEventListener('drop', handleDrop);
        };
    };
    HTML5Backend.prototype.addEventListeners = function (target) {
        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
        if (!target.addEventListener) {
            return;
        }
        target.addEventListener('dragstart', this
            .handleTopDragStart);
        target.addEventListener('dragstart', this.handleTopDragStartCapture, true);
        target.addEventListener('dragend', this.handleTopDragEndCapture, true);
        target.addEventListener('dragenter', this
            .handleTopDragEnter);
        target.addEventListener('dragenter', this.handleTopDragEnterCapture, true);
        target.addEventListener('dragleave', this.handleTopDragLeaveCapture, true);
        target.addEventListener('dragover', this.handleTopDragOver);
        target.addEventListener('dragover', this.handleTopDragOverCapture, true);
        target.addEventListener('drop', this.handleTopDrop);
        target.addEventListener('drop', this.handleTopDropCapture, true);
    };
    HTML5Backend.prototype.removeEventListeners = function (target) {
        // SSR Fix (https://github.com/react-dnd/react-dnd/pull/813
        if (!target.removeEventListener) {
            return;
        }
        target.removeEventListener('dragstart', this.handleTopDragStart);
        target.removeEventListener('dragstart', this.handleTopDragStartCapture, true);
        target.removeEventListener('dragend', this.handleTopDragEndCapture, true);
        target.removeEventListener('dragenter', this
            .handleTopDragEnter);
        target.removeEventListener('dragenter', this.handleTopDragEnterCapture, true);
        target.removeEventListener('dragleave', this.handleTopDragLeaveCapture, true);
        target.removeEventListener('dragover', this
            .handleTopDragOver);
        target.removeEventListener('dragover', this.handleTopDragOverCapture, true);
        target.removeEventListener('drop', this.handleTopDrop);
        target.removeEventListener('drop', this.handleTopDropCapture, true);
    };
    HTML5Backend.prototype.getCurrentSourceNodeOptions = function () {
        var sourceId = this.monitor.getSourceId();
        var sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
        return __assign({ dropEffect: this.altKeyPressed ? 'copy' : 'move' }, (sourceNodeOptions || {}));
    };
    HTML5Backend.prototype.getCurrentDropEffect = function () {
        if (this.isDraggingNativeItem()) {
            // It makes more sense to default to 'copy' for native resources
            return 'copy';
        }
        return this.getCurrentSourceNodeOptions().dropEffect;
    };
    HTML5Backend.prototype.getCurrentSourcePreviewNodeOptions = function () {
        var sourceId = this.monitor.getSourceId();
        var sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
        return __assign({ anchorX: 0.5, anchorY: 0.5, captureDraggingState: false }, (sourcePreviewNodeOptions || {}));
    };
    HTML5Backend.prototype.isDraggingNativeItem = function () {
        var itemType = this.monitor.getItemType();
        return Object.keys(NativeTypes).some(function (key) { return NativeTypes[key] === itemType; });
    };
    HTML5Backend.prototype.beginDragNativeItem = function (type) {
        this.clearCurrentDragSourceNode();
        this.currentNativeSource = NativeDragSources_1.createNativeDragSource(type);
        this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
        this.actions.beginDrag([this.currentNativeHandle]);
    };
    HTML5Backend.prototype.setCurrentDragSourceNode = function (node) {
        var _this = this;
        this.clearCurrentDragSourceNode();
        this.currentDragSourceNode = node;
        // A timeout of > 0 is necessary to resolve Firefox issue referenced
        // See:
        //   * https://github.com/react-dnd/react-dnd/pull/928
        //   * https://github.com/react-dnd/react-dnd/issues/869
        var MOUSE_MOVE_TIMEOUT = 1000;
        // Receiving a mouse event in the middle of a dragging operation
        // means it has ended and the drag source node disappeared from DOM,
        // so the browser didn't dispatch the dragend event.
        //
        // We need to wait before we start listening for mousemove events.
        // This is needed because the drag preview needs to be drawn or else it fires an 'mousemove' event
        // immediately in some browsers.
        //
        // See:
        //   * https://github.com/react-dnd/react-dnd/pull/928
        //   * https://github.com/react-dnd/react-dnd/issues/869
        //
        this.mouseMoveTimeoutTimer = setTimeout(function () {
            return (_this.window &&
                _this.window.addEventListener('mousemove', _this.endDragIfSourceWasRemovedFromDOM, true));
        }, MOUSE_MOVE_TIMEOUT);
    };
    HTML5Backend.prototype.clearCurrentDragSourceNode = function () {
        if (this.currentDragSourceNode) {
            this.currentDragSourceNode = null;
            if (this.window) {
                this.window.clearTimeout(this.mouseMoveTimeoutTimer || undefined);
                this.window.removeEventListener('mousemove', this.endDragIfSourceWasRemovedFromDOM, true);
            }
            this.mouseMoveTimeoutTimer = null;
            return true;
        }
        return false;
    };
    HTML5Backend.prototype.handleDragStart = function (e, sourceId) {
        if (!this.dragStartSourceIds) {
            this.dragStartSourceIds = [];
        }
        this.dragStartSourceIds.unshift(sourceId);
    };
    HTML5Backend.prototype.handleDragEnter = function (e, targetId) {
        this.dragEnterTargetIds.unshift(targetId);
    };
    HTML5Backend.prototype.handleDragOver = function (e, targetId) {
        if (this.dragOverTargetIds === null) {
            this.dragOverTargetIds = [];
        }
        this.dragOverTargetIds.unshift(targetId);
    };
    HTML5Backend.prototype.handleDrop = function (e, targetId) {
        this.dropTargetIds.unshift(targetId);
    };
    return HTML5Backend;
}());
exports.default = HTML5Backend;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\MonotonicInterpolant.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\MonotonicInterpolant.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MonotonicInterpolant = /** @class */ (function () {
    function MonotonicInterpolant(xs, ys) {
        var length = xs.length;
        // Rearrange xs and ys so that xs is sorted
        var indexes = [];
        for (var i = 0; i < length; i++) {
            indexes.push(i);
        }
        indexes.sort(function (a, b) { return (xs[a] < xs[b] ? -1 : 1); });
        // Get consecutive differences and slopes
        var dys = [];
        var dxs = [];
        var ms = [];
        var dx;
        var dy;
        for (var i = 0; i < length - 1; i++) {
            dx = xs[i + 1] - xs[i];
            dy = ys[i + 1] - ys[i];
            dxs.push(dx);
            dys.push(dy);
            ms.push(dy / dx);
        }
        // Get degree-1 coefficients
        var c1s = [ms[0]];
        for (var i = 0; i < dxs.length - 1; i++) {
            var m2 = ms[i];
            var mNext = ms[i + 1];
            if (m2 * mNext <= 0) {
                c1s.push(0);
            }
            else {
                dx = dxs[i];
                var dxNext = dxs[i + 1];
                var common = dx + dxNext;
                c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));
            }
        }
        c1s.push(ms[ms.length - 1]);
        // Get degree-2 and degree-3 coefficients
        var c2s = [];
        var c3s = [];
        var m;
        for (var i = 0; i < c1s.length - 1; i++) {
            m = ms[i];
            var c1 = c1s[i];
            var invDx = 1 / dxs[i];
            var common = c1 + c1s[i + 1] - m - m;
            c2s.push((m - c1 - common) * invDx);
            c3s.push(common * invDx * invDx);
        }
        this.xs = xs;
        this.ys = ys;
        this.c1s = c1s;
        this.c2s = c2s;
        this.c3s = c3s;
    }
    MonotonicInterpolant.prototype.interpolate = function (x) {
        var _a = this, xs = _a.xs, ys = _a.ys, c1s = _a.c1s, c2s = _a.c2s, c3s = _a.c3s;
        // The rightmost point in the dataset should give an exact result
        var i = xs.length - 1;
        if (x === xs[i]) {
            return ys[i];
        }
        // Search for the interval x is in, returning the corresponding y if x is one of the original xs
        var low = 0;
        var high = c3s.length - 1;
        var mid;
        while (low <= high) {
            mid = Math.floor(0.5 * (low + high));
            var xHere = xs[mid];
            if (xHere < x) {
                low = mid + 1;
            }
            else if (xHere > x) {
                high = mid - 1;
            }
            else {
                return ys[mid];
            }
        }
        i = Math.max(0, high);
        // Interpolate
        var diff = x - xs[i];
        var diffSq = diff * diff;
        return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;
    };
    return MonotonicInterpolant;
}());
exports.default = MonotonicInterpolant;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\NativeDragSource.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\NativeDragSources\NativeDragSource.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var NativeDragSource = /** @class */ (function () {
    function NativeDragSource(config) {
        var _this = this;
        this.config = config;
        this.item = {};
        Object.keys(this.config.exposeProperties).forEach(function (property) {
            Object.defineProperty(_this.item, property, {
                configurable: true,
                enumerable: true,
                get: function () {
                    // tslint:disable-next-line no-console
                    console.warn("Browser doesn't allow reading \"" + property + "\" until the drop event.");
                    return null;
                },
            });
        });
    }
    NativeDragSource.prototype.mutateItemByReadingDataTransfer = function (dataTransfer) {
        var _this = this;
        var newProperties = {};
        if (dataTransfer) {
            Object.keys(this.config.exposeProperties).forEach(function (property) {
                newProperties[property] = {
                    value: _this.config.exposeProperties[property](dataTransfer, _this.config.matchesTypes),
                };
            });
        }
        Object.defineProperties(this.item, newProperties);
    };
    NativeDragSource.prototype.canDrag = function () {
        return true;
    };
    NativeDragSource.prototype.beginDrag = function () {
        return this.item;
    };
    NativeDragSource.prototype.isDragging = function (monitor, handle) {
        return handle === monitor.getSourceId();
    };
    NativeDragSource.prototype.endDrag = function () {
        // empty
    };
    return NativeDragSource;
}());
exports.NativeDragSource = NativeDragSource;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\getDataFromDataTransfer.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\NativeDragSources\getDataFromDataTransfer.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
    var result = typesToTry.reduce(function (resultSoFar, typeToTry) { return resultSoFar || dataTransfer.getData(typeToTry); }, '');
    return result != null ? result : defaultValue;
}
exports.getDataFromDataTransfer = getDataFromDataTransfer;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\index.js", {"./NativeDragSource":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\NativeDragSource.js","./nativeTypesConfig":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\nativeTypesConfig.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\NativeDragSources\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nativeTypesConfig_1 = require("./nativeTypesConfig");
var NativeDragSource_1 = require("./NativeDragSource");
function createNativeDragSource(type) {
    return new NativeDragSource_1.NativeDragSource(nativeTypesConfig_1.nativeTypesConfig[type]);
}
exports.createNativeDragSource = createNativeDragSource;
function matchNativeItemType(dataTransfer) {
    if (!dataTransfer) {
        return null;
    }
    var dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
    return (Object.keys(nativeTypesConfig_1.nativeTypesConfig).filter(function (nativeItemType) {
        var matchesTypes = nativeTypesConfig_1.nativeTypesConfig[nativeItemType].matchesTypes;
        return matchesTypes.some(function (t) { return dataTransferTypes.indexOf(t) > -1; });
    })[0] || null);
}
exports.matchNativeItemType = matchNativeItemType;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\nativeTypesConfig.js", {"../NativeTypes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeTypes.js","./getDataFromDataTransfer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeDragSources\\getDataFromDataTransfer.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\NativeDragSources\nativeTypesConfig.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _a;
var NativeTypes = require("../NativeTypes");
var getDataFromDataTransfer_1 = require("./getDataFromDataTransfer");
exports.nativeTypesConfig = (_a = {},
    _a[NativeTypes.FILE] = {
        exposeProperties: {
            files: function (dataTransfer) {
                return Array.prototype.slice.call(dataTransfer.files);
            },
            items: function (dataTransfer) { return dataTransfer.items; },
        },
        matchesTypes: ['Files'],
    },
    _a[NativeTypes.URL] = {
        exposeProperties: {
            urls: function (dataTransfer, matchesTypes) {
                return getDataFromDataTransfer_1.getDataFromDataTransfer(dataTransfer, matchesTypes, '').split('\n');
            },
        },
        matchesTypes: ['Url', 'text/uri-list'],
    },
    _a[NativeTypes.TEXT] = {
        exposeProperties: {
            text: function (dataTransfer, matchesTypes) {
                return getDataFromDataTransfer_1.getDataFromDataTransfer(dataTransfer, matchesTypes, '');
            },
        },
        matchesTypes: ['Text', 'text/plain'],
    },
    _a);

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeTypes.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\NativeTypes.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FILE = '__NATIVE_FILE__';
exports.URL = '__NATIVE_URL__';
exports.TEXT = '__NATIVE_TEXT__';

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\OffsetUtils.js", {"./BrowserDetector":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\BrowserDetector.js","./MonotonicInterpolant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\MonotonicInterpolant.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\OffsetUtils.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var BrowserDetector_1 = require("./BrowserDetector");
var MonotonicInterpolant_1 = require("./MonotonicInterpolant");
var ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
    var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
    if (!el) {
        return null;
    }
    var _a = el.getBoundingClientRect(), top = _a.top, left = _a.left;
    return { x: left, y: top };
}
exports.getNodeClientOffset = getNodeClientOffset;
function getEventClientOffset(e) {
    return {
        x: e.clientX,
        y: e.clientY,
    };
}
exports.getEventClientOffset = getEventClientOffset;
function isImageNode(node) {
    return (node.nodeName === 'IMG' &&
        (BrowserDetector_1.isFirefox() || !document.documentElement.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
    var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
    var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
    // Work around @2x coordinate discrepancies in browsers
    if (BrowserDetector_1.isSafari() && isImage) {
        dragPreviewHeight /= window.devicePixelRatio;
        dragPreviewWidth /= window.devicePixelRatio;
    }
    return { dragPreviewWidth: dragPreviewWidth, dragPreviewHeight: dragPreviewHeight };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
    // The browsers will use the image intrinsic size under different conditions.
    // Firefox only cares if it's an image, but WebKit also wants it to be detached.
    var isImage = isImageNode(dragPreview);
    var dragPreviewNode = isImage ? sourceNode : dragPreview;
    var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
    var offsetFromDragPreview = {
        x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
        y: clientOffset.y - dragPreviewNodeOffsetFromClient.y,
    };
    var sourceWidth = sourceNode.offsetWidth, sourceHeight = sourceNode.offsetHeight;
    var anchorX = anchorPoint.anchorX, anchorY = anchorPoint.anchorY;
    var _a = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight), dragPreviewWidth = _a.dragPreviewWidth, dragPreviewHeight = _a.dragPreviewHeight;
    var calculateYOffset = function () {
        var interpolantY = new MonotonicInterpolant_1.default([0, 0.5, 1], [
            // Dock to the top
            offsetFromDragPreview.y,
            // Align at the center
            (offsetFromDragPreview.y / sourceHeight) * dragPreviewHeight,
            // Dock to the bottom
            offsetFromDragPreview.y + dragPreviewHeight - sourceHeight,
        ]);
        var y = interpolantY.interpolate(anchorY);
        // Work around Safari 8 positioning bug
        if (BrowserDetector_1.isSafari() && isImage) {
            // We'll have to wait for @3x to see if this is entirely correct
            y += (window.devicePixelRatio - 1) * dragPreviewHeight;
        }
        return y;
    };
    var calculateXOffset = function () {
        // Interpolate coordinates depending on anchor point
        // If you know a simpler way to do this, let me know
        var interpolantX = new MonotonicInterpolant_1.default([0, 0.5, 1], [
            // Dock to the left
            offsetFromDragPreview.x,
            // Align at the center
            (offsetFromDragPreview.x / sourceWidth) * dragPreviewWidth,
            // Dock to the right
            offsetFromDragPreview.x + dragPreviewWidth - sourceWidth,
        ]);
        return interpolantX.interpolate(anchorX);
    };
    // Force offsets if specified in the options.
    var offsetX = offsetPoint.offsetX, offsetY = offsetPoint.offsetY;
    var isManualOffsetX = offsetX === 0 || offsetX;
    var isManualOffsetY = offsetY === 0 || offsetY;
    return {
        x: isManualOffsetX ? offsetX : calculateXOffset(),
        y: isManualOffsetY ? offsetY : calculateYOffset(),
    };
}
exports.getDragPreviewOffset = getDragPreviewOffset;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\getEmptyImage.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\getEmptyImage.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var emptyImage;
function getEmptyImage() {
    if (!emptyImage) {
        emptyImage = new Image();
        emptyImage.src =
            'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
    }
    return emptyImage;
}
exports.default = getEmptyImage;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\index.js", {"./HTML5Backend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\HTML5Backend.js","./NativeTypes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\NativeTypes.js","./getEmptyImage":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\getEmptyImage.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var HTML5Backend_1 = require("./HTML5Backend");
var getEmptyImage_1 = require("./getEmptyImage");
exports.getEmptyImage = getEmptyImage_1.default;
var NativeTypes = require("./NativeTypes");
exports.NativeTypes = NativeTypes;
function createHTML5Backend(manager) {
    return new HTML5Backend_1.default(manager);
}
exports.default = createHTML5Backend;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd-html5-backend\\lib\\cjs\\utils\\discount_lodash.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd-html5-backend\lib\cjs\utils\discount_lodash.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function memoize(fn) {
    var result = null;
    var memoized = function () {
        if (result == null) {
            result = fn();
        }
        return result;
    };
    return memoized;
}
exports.memoize = memoize;
/**
 * drop-in replacement for _.without
 */
function without(items, item) {
    return items.filter(function (i) { return i !== item; });
}
exports.without = without;
function union(itemsA, itemsB) {
    var set = new Set();
    var insertItem = function (item) { return set.add(item); };
    itemsA.forEach(insertItem);
    itemsB.forEach(insertItem);
    var result = [];
    set.forEach(function (key) { return result.push(key); });
    return result;
}
exports.union = union;

      };
    };
  }
}, {package:"react-dnd-html5-backend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragDropContext.js", {"./utils/checkDecoratorArguments":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\checkDecoratorArguments.js","dnd-core":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\dnd-core\\lib\\index.js","hoist-non-react-statics":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js","invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","prop-types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\index.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\DragDropContext.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var dnd_core_1 = require("dnd-core");
var invariant_1 = __importDefault(require("invariant"));
var hoist_non_react_statics_1 = __importDefault(require("hoist-non-react-statics"));
var checkDecoratorArguments_1 = __importDefault(require("./utils/checkDecoratorArguments"));
exports.CHILD_CONTEXT_TYPES = {
    dragDropManager: prop_types_1.default.object.isRequired,
};
function createChildContext(backend, context) {
    return {
        dragDropManager: dnd_core_1.createDragDropManager(backend, context),
    };
}
exports.createChildContext = createChildContext;
function DragDropContext(backendFactory, context) {
    checkDecoratorArguments_1.default('DragDropContext', 'backend', backendFactory); // eslint-disable-line prefer-rest-params
    var childContext = createChildContext(backendFactory, context);
    return function decorateContext(DecoratedComponent) {
        var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';
        var DragDropContextContainer = /** @class */ (function (_super) {
            __extends(DragDropContextContainer, _super);
            function DragDropContextContainer() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DragDropContextContainer.prototype.getDecoratedComponentInstance = function () {
                invariant_1.default(this.child, 'In order to access an instance of the decorated component it can not be a stateless component.');
                return this.child;
            };
            DragDropContextContainer.prototype.getManager = function () {
                return childContext.dragDropManager;
            };
            DragDropContextContainer.prototype.getChildContext = function () {
                return childContext;
            };
            DragDropContextContainer.prototype.render = function () {
                var _this = this;
                return (react_1.default.createElement(DecoratedComponent, __assign({}, this.props, { ref: function (child) { return (_this.child = child); } })));
            };
            DragDropContextContainer.DecoratedComponent = DecoratedComponent;
            DragDropContextContainer.displayName = "DragDropContext(" + displayName + ")";
            DragDropContextContainer.childContextTypes = exports.CHILD_CONTEXT_TYPES;
            return DragDropContextContainer;
        }(react_1.default.Component));
        return hoist_non_react_statics_1.default(DragDropContextContainer, DecoratedComponent);
    };
}
exports.default = DragDropContext;
//# sourceMappingURL=DragDropContext.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragDropContextProvider.js", {"./DragDropContext":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragDropContext.js","prop-types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\index.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\DragDropContextProvider.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var prop_types_1 = __importDefault(require("prop-types"));
var DragDropContext_1 = require("./DragDropContext");
var DragDropContextProviderImpl = /** @class */ (function (_super) {
    __extends(DragDropContextProviderImpl, _super);
    function DragDropContextProviderImpl(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this.backend = props.backend;
        _this.childContext = DragDropContext_1.createChildContext(_this.backend, _this.props.context);
        return _this;
    }
    DragDropContextProviderImpl.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.backend !== this.props.backend ||
            nextProps.context !== this.props.context) {
            throw new Error('DragDropContextProvider backend and context props must not change.');
        }
    };
    DragDropContextProviderImpl.prototype.getChildContext = function () {
        return this.childContext;
    };
    DragDropContextProviderImpl.prototype.render = function () {
        return react_1.Children.only(this.props.children);
    };
    DragDropContextProviderImpl.propTypes = {
        backend: prop_types_1.default.oneOfType([prop_types_1.default.func, prop_types_1.default.object]).isRequired,
        children: prop_types_1.default.element.isRequired,
        context: prop_types_1.default.object,
    };
    DragDropContextProviderImpl.defaultProps = {
        context: undefined,
    };
    DragDropContextProviderImpl.childContextTypes = DragDropContext_1.CHILD_CONTEXT_TYPES;
    DragDropContextProviderImpl.displayName = 'DragDropContextProvider';
    return DragDropContextProviderImpl;
}(react_1.Component));
exports.default = DragDropContextProviderImpl;
//# sourceMappingURL=DragDropContextProvider.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragLayer.js", {"./utils/checkDecoratorArguments":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\checkDecoratorArguments.js","hoist-non-react-statics":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js","invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","lodash/isPlainObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isPlainObject.js","prop-types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\index.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js","shallowequal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\shallowequal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\DragLayer.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = __importDefault(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var hoist_non_react_statics_1 = __importDefault(require("hoist-non-react-statics"));
var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var invariant_1 = __importDefault(require("invariant"));
var checkDecoratorArguments_1 = __importDefault(require("./utils/checkDecoratorArguments"));
var shallowEqual = require('shallowequal');
function DragLayer(collect, options) {
    if (options === void 0) { options = {}; }
    checkDecoratorArguments_1.default('DragLayer', 'collect[, options]', collect, options); // eslint-disable-line prefer-rest-params
    invariant_1.default(typeof collect === 'function', 'Expected "collect" provided as the first argument to DragLayer to be a function that collects props to inject into the component. ', 'Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', collect);
    invariant_1.default(isPlainObject_1.default(options), 'Expected "options" provided as the second argument to DragLayer to be a plain object when specified. ' +
        'Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs-drag-layer.html', options);
    return function decorateLayer(DecoratedComponent) {
        var _a = options.arePropsEqual, arePropsEqual = _a === void 0 ? shallowEqual : _a;
        var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';
        var DragLayerContainer = /** @class */ (function (_super) {
            __extends(DragLayerContainer, _super);
            function DragLayerContainer(props, context) {
                var _this = _super.call(this, props) || this;
                _this.isCurrentlyMounted = false;
                _this.handleChange = _this.handleChange.bind(_this);
                _this.manager = context.dragDropManager;
                invariant_1.default(typeof _this.manager === 'object', 'Could not find the drag and drop manager in the context of %s. ' +
                    'Make sure to wrap the top-level component of your app with DragDropContext. ' +
                    'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);
                _this.state = _this.getCurrentState();
                return _this;
            }
            Object.defineProperty(DragLayerContainer.prototype, "DecoratedComponent", {
                get: function () {
                    return DecoratedComponent;
                },
                enumerable: true,
                configurable: true
            });
            DragLayerContainer.prototype.getDecoratedComponentInstance = function () {
                invariant_1.default(this.child, 'In order to access an instance of the decorated component it can not be a stateless component.');
                return this.child;
            };
            DragLayerContainer.prototype.shouldComponentUpdate = function (nextProps, nextState) {
                return (!arePropsEqual(nextProps, this.props) ||
                    !shallowEqual(nextState, this.state));
            };
            DragLayerContainer.prototype.componentDidMount = function () {
                this.isCurrentlyMounted = true;
                var monitor = this.manager.getMonitor();
                this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(this.handleChange);
                this.unsubscribeFromStateChange = monitor.subscribeToStateChange(this.handleChange);
                this.handleChange();
            };
            DragLayerContainer.prototype.componentWillUnmount = function () {
                this.isCurrentlyMounted = false;
                if (this.unsubscribeFromOffsetChange) {
                    this.unsubscribeFromOffsetChange();
                    this.unsubscribeFromOffsetChange = undefined;
                }
                if (this.unsubscribeFromStateChange) {
                    this.unsubscribeFromStateChange();
                    this.unsubscribeFromStateChange = undefined;
                }
            };
            DragLayerContainer.prototype.render = function () {
                var _this = this;
                return (react_1.default.createElement(DecoratedComponent, __assign({}, this.props, this.state, { ref: function (child) {
                        _this.child = child;
                    } })));
            };
            DragLayerContainer.prototype.handleChange = function () {
                if (!this.isCurrentlyMounted) {
                    return;
                }
                var nextState = this.getCurrentState();
                if (!shallowEqual(nextState, this.state)) {
                    this.setState(nextState);
                }
            };
            DragLayerContainer.prototype.getCurrentState = function () {
                var monitor = this.manager.getMonitor();
                return collect(monitor, this.props);
            };
            DragLayerContainer.displayName = "DragLayer(" + displayName + ")";
            DragLayerContainer.contextTypes = {
                dragDropManager: prop_types_1.default.object.isRequired,
            };
            return DragLayerContainer;
        }(react_1.default.Component));
        return hoist_non_react_statics_1.default(DragLayerContainer, DecoratedComponent);
    };
}
exports.default = DragLayer;
//# sourceMappingURL=DragLayer.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragSource.js", {"./createSourceConnector":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createSourceConnector.js","./createSourceFactory":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createSourceFactory.js","./createSourceMonitor":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createSourceMonitor.js","./decorateHandler":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\decorateHandler.js","./registerSource":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\registerSource.js","./utils/checkDecoratorArguments":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\checkDecoratorArguments.js","./utils/isValidType":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\isValidType.js","invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","lodash/isPlainObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isPlainObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\DragSource.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var checkDecoratorArguments_1 = __importDefault(require("./utils/checkDecoratorArguments"));
var decorateHandler_1 = __importDefault(require("./decorateHandler"));
var registerSource_1 = __importDefault(require("./registerSource"));
var createSourceFactory_1 = __importDefault(require("./createSourceFactory"));
var createSourceMonitor_1 = __importDefault(require("./createSourceMonitor"));
var createSourceConnector_1 = __importDefault(require("./createSourceConnector"));
var isValidType_1 = __importDefault(require("./utils/isValidType"));
/**
 * Decorates a component as a dragsource
 * @param type The dragsource type
 * @param spec The drag source specification
 * @param collect The props collector function
 * @param options DnD optinos
 */
function DragSource(type, spec, collect, options) {
    if (options === void 0) { options = {}; }
    checkDecoratorArguments_1.default('DragSource', 'type, spec, collect[, options]', type, spec, collect, options);
    var getType = type;
    if (typeof type !== 'function') {
        invariant_1.default(isValidType_1.default(type), 'Expected "type" provided as the first argument to DragSource to be ' +
            'a string, or a function that returns a string given the current props. ' +
            'Instead, received %s. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', type);
        getType = function () { return type; };
    }
    invariant_1.default(isPlainObject_1.default(spec), 'Expected "spec" provided as the second argument to DragSource to be ' +
        'a plain object. Instead, received %s. ' +
        'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', spec);
    var createSource = createSourceFactory_1.default(spec);
    invariant_1.default(typeof collect === 'function', 'Expected "collect" provided as the third argument to DragSource to be ' +
        'a function that returns a plain object of props to inject. ' +
        'Instead, received %s. ' +
        'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);
    invariant_1.default(isPlainObject_1.default(options), 'Expected "options" provided as the fourth argument to DragSource to be ' +
        'a plain object when specified. ' +
        'Instead, received %s. ' +
        'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', collect);
    return function decorateSource(DecoratedComponent) {
        return decorateHandler_1.default({
            containerDisplayName: 'DragSource',
            createHandler: createSource,
            registerHandler: registerSource_1.default,
            createMonitor: createSourceMonitor_1.default,
            createConnector: createSourceConnector_1.default,
            DecoratedComponent: DecoratedComponent,
            getType: getType,
            collect: collect,
            options: options,
        });
    };
}
exports.default = DragSource;
//# sourceMappingURL=DragSource.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DropTarget.js", {"./createTargetConnector":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createTargetConnector.js","./createTargetFactory":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createTargetFactory.js","./createTargetMonitor":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createTargetMonitor.js","./decorateHandler":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\decorateHandler.js","./registerTarget":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\registerTarget.js","./utils/checkDecoratorArguments":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\checkDecoratorArguments.js","./utils/isValidType":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\isValidType.js","invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","lodash/isPlainObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isPlainObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\DropTarget.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var checkDecoratorArguments_1 = __importDefault(require("./utils/checkDecoratorArguments"));
var decorateHandler_1 = __importDefault(require("./decorateHandler"));
var registerTarget_1 = __importDefault(require("./registerTarget"));
var createTargetFactory_1 = __importDefault(require("./createTargetFactory"));
var createTargetMonitor_1 = __importDefault(require("./createTargetMonitor"));
var createTargetConnector_1 = __importDefault(require("./createTargetConnector"));
var isValidType_1 = __importDefault(require("./utils/isValidType"));
function DropTarget(type, spec, collect, options) {
    if (options === void 0) { options = {}; }
    checkDecoratorArguments_1.default('DropTarget', 'type, spec, collect[, options]', type, spec, collect, options);
    var getType = type;
    if (typeof type !== 'function') {
        invariant_1.default(isValidType_1.default(type, true), 'Expected "type" provided as the first argument to DropTarget to be ' +
            'a string, an array of strings, or a function that returns either given ' +
            'the current props. Instead, received %s. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', type);
        getType = function () { return type; };
    }
    invariant_1.default(isPlainObject_1.default(spec), 'Expected "spec" provided as the second argument to DropTarget to be ' +
        'a plain object. Instead, received %s. ' +
        'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', spec);
    var createTarget = createTargetFactory_1.default(spec);
    invariant_1.default(typeof collect === 'function', 'Expected "collect" provided as the third argument to DropTarget to be ' +
        'a function that returns a plain object of props to inject. ' +
        'Instead, received %s. ' +
        'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);
    invariant_1.default(isPlainObject_1.default(options), 'Expected "options" provided as the fourth argument to DropTarget to be ' +
        'a plain object when specified. ' +
        'Instead, received %s. ' +
        'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', collect);
    return function decorateTarget(DecoratedComponent) {
        return decorateHandler_1.default({
            containerDisplayName: 'DropTarget',
            createHandler: createTarget,
            registerHandler: registerTarget_1.default,
            createMonitor: createTargetMonitor_1.default,
            createConnector: createTargetConnector_1.default,
            DecoratedComponent: DecoratedComponent,
            getType: getType,
            collect: collect,
            options: options,
        });
    };
}
exports.default = DropTarget;
//# sourceMappingURL=DropTarget.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createSourceConnector.js", {"./wrapConnectorHooks":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\wrapConnectorHooks.js","shallowequal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\shallowequal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\createSourceConnector.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var wrapConnectorHooks_1 = __importDefault(require("./wrapConnectorHooks"));
var shallowEqual = require('shallowequal');
function createSourceConnector(backend) {
    var currentHandlerId;
    var currentDragSourceNode;
    var currentDragSourceOptions;
    var disconnectCurrentDragSource;
    var currentDragPreviewNode;
    var currentDragPreviewOptions;
    var disconnectCurrentDragPreview;
    function reconnectDragSource() {
        if (disconnectCurrentDragSource) {
            disconnectCurrentDragSource();
            disconnectCurrentDragSource = undefined;
        }
        if (currentHandlerId && currentDragSourceNode) {
            disconnectCurrentDragSource = backend.connectDragSource(currentHandlerId, currentDragSourceNode, currentDragSourceOptions);
        }
    }
    function reconnectDragPreview() {
        if (disconnectCurrentDragPreview) {
            disconnectCurrentDragPreview();
            disconnectCurrentDragPreview = undefined;
        }
        if (currentHandlerId && currentDragPreviewNode) {
            disconnectCurrentDragPreview = backend.connectDragPreview(currentHandlerId, currentDragPreviewNode, currentDragPreviewOptions);
        }
    }
    function receiveHandlerId(handlerId) {
        if (handlerId === currentHandlerId) {
            return;
        }
        currentHandlerId = handlerId;
        reconnectDragSource();
        reconnectDragPreview();
    }
    var hooks = wrapConnectorHooks_1.default({
        dragSource: function connectDragSource(node, options) {
            if (node === currentDragSourceNode &&
                shallowEqual(options, currentDragSourceOptions)) {
                return;
            }
            currentDragSourceNode = node;
            currentDragSourceOptions = options;
            reconnectDragSource();
        },
        dragPreview: function connectDragPreview(node, options) {
            if (node === currentDragPreviewNode &&
                shallowEqual(options, currentDragPreviewOptions)) {
                return;
            }
            currentDragPreviewNode = node;
            currentDragPreviewOptions = options;
            reconnectDragPreview();
        },
    });
    return {
        receiveHandlerId: receiveHandlerId,
        hooks: hooks,
    };
}
exports.default = createSourceConnector;
//# sourceMappingURL=createSourceConnector.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createSourceFactory.js", {"invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","lodash/isPlainObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isPlainObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\createSourceFactory.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var ALLOWED_SPEC_METHODS = ['canDrag', 'beginDrag', 'isDragging', 'endDrag'];
var REQUIRED_SPEC_METHODS = ['beginDrag'];
function createSourceFactory(spec) {
    Object.keys(spec).forEach(function (key) {
        invariant_1.default(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drag source specification to only have ' +
            'some of the following keys: %s. ' +
            'Instead received a specification with an unexpected "%s" key. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', ALLOWED_SPEC_METHODS.join(', '), key);
        invariant_1.default(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' +
            'Instead received a specification with %s: %s. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
    });
    REQUIRED_SPEC_METHODS.forEach(function (key) {
        invariant_1.default(typeof spec[key] === 'function', 'Expected %s in the drag source specification to be a function. ' +
            'Instead received a specification with %s: %s. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', key, key, spec[key]);
    });
    var SourceImpl = /** @class */ (function () {
        function SourceImpl(monitor) {
            this.monitor = monitor;
        }
        SourceImpl.prototype.receiveProps = function (props) {
            this.props = props;
        };
        SourceImpl.prototype.receiveComponent = function (component) {
            this.component = component;
        };
        SourceImpl.prototype.canDrag = function () {
            if (!this.props) {
                return false;
            }
            if (!spec.canDrag) {
                return true;
            }
            return spec.canDrag(this.props, this.monitor);
        };
        SourceImpl.prototype.isDragging = function (globalMonitor, sourceId) {
            if (!this.props) {
                return false;
            }
            if (!spec.isDragging) {
                return sourceId === globalMonitor.getSourceId();
            }
            return spec.isDragging(this.props, this.monitor);
        };
        SourceImpl.prototype.beginDrag = function () {
            if (!this.props || !this.component) {
                return;
            }
            var item = spec.beginDrag(this.props, this.monitor, this.component);
            if ("development" !== 'production') {
                invariant_1.default(isPlainObject_1.default(item), 'beginDrag() must return a plain object that represents the dragged item. ' +
                    'Instead received %s. ' +
                    'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source.html', item);
            }
            return item;
        };
        SourceImpl.prototype.endDrag = function () {
            if (!this.props || !this.component) {
                return;
            }
            if (!spec.endDrag) {
                return;
            }
            spec.endDrag(this.props, this.monitor, this.component);
        };
        return SourceImpl;
    }());
    return function createSource(monitor) {
        return new SourceImpl(monitor);
    };
}
exports.default = createSourceFactory;
//# sourceMappingURL=createSourceFactory.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createSourceMonitor.js", {"invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\createSourceMonitor.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var isCallingCanDrag = false;
var isCallingIsDragging = false;
var SourceMonitor = /** @class */ (function () {
    function SourceMonitor(manager) {
        this.internalMonitor = manager.getMonitor();
    }
    SourceMonitor.prototype.receiveHandlerId = function (sourceId) {
        this.sourceId = sourceId;
    };
    SourceMonitor.prototype.canDrag = function () {
        invariant_1.default(!isCallingCanDrag, 'You may not call monitor.canDrag() inside your canDrag() implementation. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');
        try {
            isCallingCanDrag = true;
            return this.internalMonitor.canDragSource(this.sourceId);
        }
        finally {
            isCallingCanDrag = false;
        }
    };
    SourceMonitor.prototype.isDragging = function () {
        invariant_1.default(!isCallingIsDragging, 'You may not call monitor.isDragging() inside your isDragging() implementation. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drag-source-monitor.html');
        try {
            isCallingIsDragging = true;
            return this.internalMonitor.isDraggingSource(this.sourceId);
        }
        finally {
            isCallingIsDragging = false;
        }
    };
    SourceMonitor.prototype.subscribeToStateChange = function (listener, options) {
        return this.internalMonitor.subscribeToStateChange(listener, options);
    };
    SourceMonitor.prototype.isDraggingSource = function (sourceId) {
        return this.internalMonitor.isDraggingSource(sourceId);
    };
    SourceMonitor.prototype.isOverTarget = function (targetId, options) {
        return this.internalMonitor.isOverTarget(targetId, options);
    };
    SourceMonitor.prototype.getTargetIds = function () {
        return this.internalMonitor.getTargetIds();
    };
    SourceMonitor.prototype.isSourcePublic = function () {
        return this.internalMonitor.isSourcePublic();
    };
    SourceMonitor.prototype.getSourceId = function () {
        return this.internalMonitor.getSourceId();
    };
    SourceMonitor.prototype.subscribeToOffsetChange = function (listener) {
        return this.internalMonitor.subscribeToOffsetChange(listener);
    };
    SourceMonitor.prototype.canDragSource = function (sourceId) {
        return this.internalMonitor.canDragSource(sourceId);
    };
    SourceMonitor.prototype.canDropOnTarget = function (targetId) {
        return this.internalMonitor.canDropOnTarget(targetId);
    };
    SourceMonitor.prototype.getItemType = function () {
        return this.internalMonitor.getItemType();
    };
    SourceMonitor.prototype.getItem = function () {
        return this.internalMonitor.getItem();
    };
    SourceMonitor.prototype.getDropResult = function () {
        return this.internalMonitor.getDropResult();
    };
    SourceMonitor.prototype.didDrop = function () {
        return this.internalMonitor.didDrop();
    };
    SourceMonitor.prototype.getInitialClientOffset = function () {
        return this.internalMonitor.getInitialClientOffset();
    };
    SourceMonitor.prototype.getInitialSourceClientOffset = function () {
        return this.internalMonitor.getInitialSourceClientOffset();
    };
    SourceMonitor.prototype.getSourceClientOffset = function () {
        return this.internalMonitor.getSourceClientOffset();
    };
    SourceMonitor.prototype.getClientOffset = function () {
        return this.internalMonitor.getClientOffset();
    };
    SourceMonitor.prototype.getDifferenceFromInitialOffset = function () {
        return this.internalMonitor.getDifferenceFromInitialOffset();
    };
    return SourceMonitor;
}());
function createSourceMonitor(manager) {
    return new SourceMonitor(manager);
}
exports.default = createSourceMonitor;
//# sourceMappingURL=createSourceMonitor.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createTargetConnector.js", {"./wrapConnectorHooks":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\wrapConnectorHooks.js","shallowequal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\shallowequal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\createTargetConnector.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var wrapConnectorHooks_1 = __importDefault(require("./wrapConnectorHooks"));
var shallowEqual = require('shallowequal');
function createTargetConnector(backend) {
    var currentHandlerId;
    var currentDropTargetNode;
    var currentDropTargetOptions;
    var disconnectCurrentDropTarget;
    function reconnectDropTarget() {
        if (disconnectCurrentDropTarget) {
            disconnectCurrentDropTarget();
            disconnectCurrentDropTarget = undefined;
        }
        if (currentHandlerId && currentDropTargetNode) {
            disconnectCurrentDropTarget = backend.connectDropTarget(currentHandlerId, currentDropTargetNode, currentDropTargetOptions);
        }
    }
    function receiveHandlerId(handlerId) {
        if (handlerId === currentHandlerId) {
            return;
        }
        currentHandlerId = handlerId;
        reconnectDropTarget();
    }
    var hooks = wrapConnectorHooks_1.default({
        dropTarget: function connectDropTarget(node, options) {
            if (node === currentDropTargetNode &&
                shallowEqual(options, currentDropTargetOptions)) {
                return;
            }
            currentDropTargetNode = node;
            currentDropTargetOptions = options;
            reconnectDropTarget();
        },
    });
    return {
        receiveHandlerId: receiveHandlerId,
        hooks: hooks,
    };
}
exports.default = createTargetConnector;
//# sourceMappingURL=createTargetConnector.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createTargetFactory.js", {"invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","lodash/isPlainObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isPlainObject.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\createTargetFactory.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var ALLOWED_SPEC_METHODS = ['canDrop', 'hover', 'drop'];
function createTargetFactory(spec) {
    Object.keys(spec).forEach(function (key) {
        invariant_1.default(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drop target specification to only have ' +
            'some of the following keys: %s. ' +
            'Instead received a specification with an unexpected "%s" key. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', ALLOWED_SPEC_METHODS.join(', '), key);
        invariant_1.default(typeof spec[key] === 'function', 'Expected %s in the drop target specification to be a function. ' +
            'Instead received a specification with %s: %s. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', key, key, spec[key]);
    });
    var TargetImpl = /** @class */ (function () {
        function TargetImpl(monitor) {
            this.monitor = monitor;
            this.props = null;
            this.component = null;
        }
        TargetImpl.prototype.receiveProps = function (props) {
            this.props = props;
        };
        TargetImpl.prototype.receiveMonitor = function (monitor) {
            this.monitor = monitor;
        };
        TargetImpl.prototype.receiveComponent = function (component) {
            this.component = component;
        };
        TargetImpl.prototype.canDrop = function () {
            if (!spec.canDrop) {
                return true;
            }
            return spec.canDrop(this.props, this.monitor);
        };
        TargetImpl.prototype.hover = function () {
            if (!spec.hover) {
                return;
            }
            spec.hover(this.props, this.monitor, this.component);
        };
        TargetImpl.prototype.drop = function () {
            if (!spec.drop) {
                return undefined;
            }
            var dropResult = spec.drop(this.props, this.monitor, this.component);
            if ("development" !== 'production') {
                invariant_1.default(typeof dropResult === 'undefined' || isPlainObject_1.default(dropResult), 'drop() must either return undefined, or an object that represents the drop result. ' +
                    'Instead received %s. ' +
                    'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target.html', dropResult);
            }
            return dropResult;
        };
        return TargetImpl;
    }());
    return function createTarget(monitor) {
        return new TargetImpl(monitor);
    };
}
exports.default = createTargetFactory;
//# sourceMappingURL=createTargetFactory.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\createTargetMonitor.js", {"invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\createTargetMonitor.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var isCallingCanDrop = false;
var TargetMonitor = /** @class */ (function () {
    function TargetMonitor(manager) {
        this.internalMonitor = manager.getMonitor();
    }
    TargetMonitor.prototype.receiveHandlerId = function (targetId) {
        this.targetId = targetId;
    };
    TargetMonitor.prototype.canDrop = function () {
        invariant_1.default(!isCallingCanDrop, 'You may not call monitor.canDrop() inside your canDrop() implementation. ' +
            'Read more: http://react-dnd.github.io/react-dnd/docs-drop-target-monitor.html');
        try {
            isCallingCanDrop = true;
            return this.internalMonitor.canDropOnTarget(this.targetId);
        }
        finally {
            isCallingCanDrop = false;
        }
    };
    TargetMonitor.prototype.isOver = function (options) {
        return this.internalMonitor.isOverTarget(this.targetId, options);
    };
    TargetMonitor.prototype.getItemType = function () {
        return this.internalMonitor.getItemType();
    };
    TargetMonitor.prototype.getItem = function () {
        return this.internalMonitor.getItem();
    };
    TargetMonitor.prototype.getDropResult = function () {
        return this.internalMonitor.getDropResult();
    };
    TargetMonitor.prototype.didDrop = function () {
        return this.internalMonitor.didDrop();
    };
    TargetMonitor.prototype.getInitialClientOffset = function () {
        return this.internalMonitor.getInitialClientOffset();
    };
    TargetMonitor.prototype.getInitialSourceClientOffset = function () {
        return this.internalMonitor.getInitialSourceClientOffset();
    };
    TargetMonitor.prototype.getSourceClientOffset = function () {
        return this.internalMonitor.getSourceClientOffset();
    };
    TargetMonitor.prototype.getClientOffset = function () {
        return this.internalMonitor.getClientOffset();
    };
    TargetMonitor.prototype.getDifferenceFromInitialOffset = function () {
        return this.internalMonitor.getDifferenceFromInitialOffset();
    };
    return TargetMonitor;
}());
exports.TargetMonitor = TargetMonitor;
function createTargetMonitor(manager) {
    return new TargetMonitor(manager);
}
exports.default = createTargetMonitor;
//# sourceMappingURL=createTargetMonitor.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\decorateHandler.js", {"disposables":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\disposables\\modules\\index.js","hoist-non-react-statics":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js","invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","lodash/isPlainObject":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isPlainObject.js","prop-types":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\prop-types\\index.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js","shallowequal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\shallowequal\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\decorateHandler.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var React = __importStar(require("react"));
var prop_types_1 = __importDefault(require("prop-types"));
var isPlainObject_1 = __importDefault(require("lodash/isPlainObject"));
var invariant_1 = __importDefault(require("invariant"));
var hoist_non_react_statics_1 = __importDefault(require("hoist-non-react-statics"));
var shallowEqual = require('shallowequal');
var _a = require('disposables'), Disposable = _a.Disposable, CompositeDisposable = _a.CompositeDisposable, SerialDisposable = _a.SerialDisposable;
var isClassComponent = function (Comp) {
    return (!!Comp && !!Comp.prototype && typeof Comp.prototype.render === 'function');
};
function decorateHandler(_a) {
    var DecoratedComponent = _a.DecoratedComponent, createHandler = _a.createHandler, createMonitor = _a.createMonitor, createConnector = _a.createConnector, registerHandler = _a.registerHandler, containerDisplayName = _a.containerDisplayName, getType = _a.getType, collect = _a.collect, options = _a.options;
    var _b = options.arePropsEqual, arePropsEqual = _b === void 0 ? shallowEqual : _b;
    var displayName = DecoratedComponent.displayName || DecoratedComponent.name || 'Component';
    var DragDropContainer = /** @class */ (function (_super) {
        __extends(DragDropContainer, _super);
        function DragDropContainer(props, context) {
            var _this = _super.call(this, props, context) || this;
            _this.isCurrentlyMounted = false;
            _this.handleChange = _this.handleChange.bind(_this);
            _this.handleChildRef = _this.handleChildRef.bind(_this);
            invariant_1.default(typeof _this.context.dragDropManager === 'object', 'Could not find the drag and drop manager in the context of %s. ' +
                'Make sure to wrap the top-level component of your app with DragDropContext. ' +
                'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#could-not-find-the-drag-and-drop-manager-in-the-context', displayName, displayName);
            _this.manager = _this.context.dragDropManager;
            _this.handlerMonitor = createMonitor(_this.manager);
            _this.handlerConnector = createConnector(_this.manager.getBackend());
            _this.handler = createHandler(_this.handlerMonitor);
            _this.disposable = new SerialDisposable();
            _this.receiveProps(props);
            _this.state = _this.getCurrentState();
            _this.dispose();
            return _this;
        }
        DragDropContainer.prototype.getHandlerId = function () {
            return this.handlerId;
        };
        DragDropContainer.prototype.getDecoratedComponentInstance = function () {
            return this.decoratedComponentInstance;
        };
        DragDropContainer.prototype.shouldComponentUpdate = function (nextProps, nextState) {
            return (!arePropsEqual(nextProps, this.props) ||
                !shallowEqual(nextState, this.state));
        };
        DragDropContainer.prototype.componentDidMount = function () {
            this.isCurrentlyMounted = true;
            this.disposable = new SerialDisposable();
            this.currentType = undefined;
            this.receiveProps(this.props);
            this.handleChange();
        };
        DragDropContainer.prototype.componentWillReceiveProps = function (nextProps) {
            if (!arePropsEqual(nextProps, this.props)) {
                this.receiveProps(nextProps);
                this.handleChange();
            }
        };
        DragDropContainer.prototype.componentWillUnmount = function () {
            this.dispose();
            this.isCurrentlyMounted = false;
        };
        DragDropContainer.prototype.receiveProps = function (props) {
            this.handler.receiveProps(props);
            this.receiveType(getType(props));
        };
        DragDropContainer.prototype.receiveType = function (type) {
            if (type === this.currentType) {
                return;
            }
            this.currentType = type;
            var _a = registerHandler(type, this.handler, this.manager), handlerId = _a.handlerId, unregister = _a.unregister;
            this.handlerId = handlerId;
            this.handlerMonitor.receiveHandlerId(handlerId);
            this.handlerConnector.receiveHandlerId(handlerId);
            var globalMonitor = this.manager.getMonitor();
            var unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, { handlerIds: [handlerId] });
            this.disposable.setDisposable(new CompositeDisposable(new Disposable(unsubscribe), new Disposable(unregister)));
        };
        DragDropContainer.prototype.handleChange = function () {
            if (!this.isCurrentlyMounted) {
                return;
            }
            var nextState = this.getCurrentState();
            if (!shallowEqual(nextState, this.state)) {
                this.setState(nextState);
            }
        };
        DragDropContainer.prototype.dispose = function () {
            this.disposable.dispose();
            this.handlerConnector.receiveHandlerId(null);
        };
        DragDropContainer.prototype.handleChildRef = function (component) {
            this.decoratedComponentInstance = component;
            this.handler.receiveComponent(component);
        };
        DragDropContainer.prototype.getCurrentState = function () {
            var nextState = collect(this.handlerConnector.hooks, this.handlerMonitor);
            if ("development" !== 'production') {
                invariant_1.default(isPlainObject_1.default(nextState), 'Expected `collect` specified as the second argument to ' +
                    '%s for %s to return a plain object of props to inject. ' +
                    'Instead, received %s.', containerDisplayName, displayName, nextState);
            }
            return nextState;
        };
        DragDropContainer.prototype.render = function () {
            return (React.createElement(DecoratedComponent, __assign({}, this.props, this.state, { ref: isClassComponent(DecoratedComponent) ? this.handleChildRef : null })));
        };
        DragDropContainer.DecoratedComponent = DecoratedComponent;
        DragDropContainer.displayName = containerDisplayName + "(" + displayName + ")";
        DragDropContainer.contextTypes = {
            dragDropManager: prop_types_1.default.object.isRequired,
        };
        return DragDropContainer;
    }(React.Component));
    return hoist_non_react_statics_1.default(DragDropContainer, DecoratedComponent);
}
exports.default = decorateHandler;
//# sourceMappingURL=decorateHandler.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\index.js", {"./DragDropContext":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragDropContext.js","./DragDropContextProvider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragDropContextProvider.js","./DragLayer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragLayer.js","./DragSource":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DragSource.js","./DropTarget":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\DropTarget.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\index.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DragDropContext_1 = require("./DragDropContext");
exports.DragDropContext = DragDropContext_1.default;
var DragDropContextProvider_1 = require("./DragDropContextProvider");
exports.DragDropContextProvider = DragDropContextProvider_1.default;
var DragLayer_1 = require("./DragLayer");
exports.DragLayer = DragLayer_1.default;
var DragSource_1 = require("./DragSource");
exports.DragSource = DragSource_1.default;
var DropTarget_1 = require("./DropTarget");
exports.DropTarget = DropTarget_1.default;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\registerSource.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\registerSource.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function registerSource(type, source, manager) {
    var registry = manager.getRegistry();
    var sourceId = registry.addSource(type, source);
    function unregisterSource() {
        registry.removeSource(sourceId);
    }
    return {
        handlerId: sourceId,
        unregister: unregisterSource,
    };
}
exports.default = registerSource;
//# sourceMappingURL=registerSource.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\registerTarget.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\registerTarget.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function registerTarget(type, target, manager) {
    var registry = manager.getRegistry();
    var targetId = registry.addTarget(type, target);
    function unregisterTarget() {
        registry.removeTarget(targetId);
    }
    return {
        handlerId: targetId,
        unregister: unregisterTarget,
    };
}
exports.default = registerTarget;
//# sourceMappingURL=registerTarget.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\checkDecoratorArguments.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\utils\checkDecoratorArguments.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function checkDecoratorArguments(functionName, signature) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    if ("development" !== 'production') {
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var arg = args_1[_a];
            if (arg && arg.prototype && arg.prototype.render) {
                // tslint:disable-next-line no-console
                console.error('You seem to be applying the arguments in the wrong order. ' +
                    ("It should be " + functionName + "(" + signature + ")(Component), not the other way around. ") +
                    'Read more: http://react-dnd.github.io/react-dnd/docs-troubleshooting.html#you-seem-to-be-applying-the-arguments-in-the-wrong-order');
                return;
            }
        }
    }
}
exports.default = checkDecoratorArguments;
//# sourceMappingURL=checkDecoratorArguments.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\cloneWithRef.js", {"invariant":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\invariant\\browser.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\utils\cloneWithRef.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __importDefault(require("invariant"));
var react_1 = require("react");
function cloneWithRef(element, newRef) {
    var previousRef = element.ref;
    invariant_1.default(typeof previousRef !== 'string', 'Cannot connect React DnD to an element with an existing string ref. ' +
        'Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. ' +
        'Read more: https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute');
    if (!previousRef) {
        // When there is no ref on the element, use the new ref directly
        return react_1.cloneElement(element, {
            ref: newRef,
        });
    }
    return react_1.cloneElement(element, {
        ref: function (node) {
            newRef(node);
            if (previousRef) {
                previousRef(node);
            }
        },
    });
}
exports.default = cloneWithRef;
//# sourceMappingURL=cloneWithRef.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\isValidType.js", {"lodash/isArray":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\isArray.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\utils\isValidType.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var isArray_1 = __importDefault(require("lodash/isArray"));
function isValidType(type, allowArray) {
    return (typeof type === 'string' ||
        typeof type === 'symbol' ||
        (!!allowArray && isArray_1.default(type) && type.every(function (t) { return isValidType(t, false); })));
}
exports.default = isValidType;
//# sourceMappingURL=isValidType.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\wrapConnectorHooks.js", {"./utils/cloneWithRef":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\lib\\utils\\cloneWithRef.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\lib\wrapConnectorHooks.js
      return function (require, module, exports) {
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var cloneWithRef_1 = __importDefault(require("./utils/cloneWithRef"));
function throwIfCompositeComponentElement(element) {
    // Custom components can no longer be wrapped directly in React DnD 2.0
    // so that we don't need to depend on findDOMNode() from react-dom.
    if (typeof element.type === 'string') {
        return;
    }
    var displayName = element.type.displayName || element.type.name || 'the component';
    throw new Error('Only native element nodes can now be passed to React DnD connectors.' +
        ("You can either wrap " + displayName + " into a <div>, or turn it into a ") +
        'drag source or a drop target itself.');
}
function wrapHookToRecognizeElement(hook) {
    return function (elementOrNode, options) {
        if (elementOrNode === void 0) { elementOrNode = null; }
        if (options === void 0) { options = null; }
        // When passed a node, call the hook straight away.
        if (!react_1.isValidElement(elementOrNode)) {
            var node = elementOrNode;
            hook(node, options);
            return undefined;
        }
        // If passed a ReactElement, clone it and attach this function as a ref.
        // This helps us achieve a neat API where user doesn't even know that refs
        // are being used under the hood.
        var element = elementOrNode;
        throwIfCompositeComponentElement(element);
        // When no options are passed, use the hook directly
        var ref = options ? function (node) { return hook(node, options); } : hook;
        return cloneWithRef_1.default(element, ref);
    };
}
function wrapConnectorHooks(hooks) {
    var wrappedHooks = {};
    Object.keys(hooks).forEach(function (key) {
        var hook = hooks[key];
        var wrappedHook = wrapHookToRecognizeElement(hook);
        wrappedHooks[key] = function () { return wrappedHook; };
    });
    return wrappedHooks;
}
exports.default = wrapConnectorHooks;
//# sourceMappingURL=wrapConnectorHooks.js.map
      };
    };
  }
}, {package:"react-dnd",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react-dnd\\node_modules\\hoist-non-react-statics\\dist\\hoist-non-react-statics.cjs.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\react-dnd\node_modules\hoist-non-react-statics\dist\hoist-non-react-statics.cjs.js
      return function (require, module, exports) {
'use strict';

/**
 * Copyright 2015, Yahoo! Inc.
 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
 */
var REACT_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    getDerivedStateFromProps: true,
    mixins: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    callee: true,
    arguments: true,
    arity: true
};

var defineProperty = Object.defineProperty;
var getOwnPropertyNames = Object.getOwnPropertyNames;
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var getPrototypeOf = Object.getPrototypeOf;
var objectPrototype = getPrototypeOf && getPrototypeOf(Object);

function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components

        if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
                hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
        }

        var keys = getOwnPropertyNames(sourceComponent);

        if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!REACT_STATICS[key] && !KNOWN_STATICS[key] && (!blacklist || !blacklist[key])) {
                var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
                try { // Avoid failures from read-only properties
                    defineProperty(targetComponent, key, descriptor);
                } catch (e) {}
            }
        }

        return targetComponent;
    }

    return targetComponent;
}

module.exports = hoistNonReactStatics;

      };
    };
  }
}, {package:"react-dnd>hoist-non-react-statics",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9mdW5jdGlvbi1iaW5kL2ltcGxlbWVudGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnVuY3Rpb25zLWhhdmUtbmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZnVzZS5qcy9kaXN0L2Z1c2UuanMiLCJub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9nZXQtcGFyYW1zL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaWRlbnRpdHkuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9sb29rQXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3BlcnNwZWN0aXZlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtTWF0NC5qcyIsIm5vZGVfbW9kdWxlcy9ndWQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaGFzLXByb3BlcnR5LWRlc2NyaXB0b3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzIiwibm9kZV9tb2R1bGVzL2hhcy10b3N0cmluZ3RhZy9zaGFtcy5qcyIsIm5vZGVfbW9kdWxlcy9oYXMvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2hlYWRlci1jYXNlL2hlYWRlci1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzL2Rpc3QvaG9pc3Qtbm9uLXJlYWN0LXN0YXRpY3MuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9pbnZhcmlhbnQvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9pcy1hcmd1bWVudHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZGF0ZS1vYmplY3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXMtZG9tL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLWluLWJyb3dzZXIvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1sb3dlci1jYXNlL2lzLWxvd2VyLWNhc2UuanMiLCJub2RlX21vZHVsZXMvaXMtb2JqZWN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXJlZ2V4L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2lzLXVwcGVyLWNhc2UvaXMtdXBwZXItY2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9pcy13aW5kb3cvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNhbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc2FuL2xpYi9jeWNsZS5qcyIsIm5vZGVfbW9kdWxlcy9qc2FuL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc2FuL2xpYi9wYXRoLWdldHRlci5qcyIsIm5vZGVfbW9kdWxlcy9qc2FuL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9qc29uLXBvaW50ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNzLXBsdWdpbi1jYW1lbC1jYXNlL2Rpc3QvanNzLXBsdWdpbi1jYW1lbC1jYXNlLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWRlZmF1bHQtdW5pdC9kaXN0L2pzcy1wbHVnaW4tZGVmYXVsdC11bml0LmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLWdsb2JhbC9kaXN0L2pzcy1wbHVnaW4tZ2xvYmFsLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLW5lc3RlZC9kaXN0L2pzcy1wbHVnaW4tbmVzdGVkLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9qc3MtcGx1Z2luLXByb3BzLXNvcnQvZGlzdC9qc3MtcGx1Z2luLXByb3BzLXNvcnQuY2pzLmpzIiwibm9kZV9tb2R1bGVzL2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1mdW5jdGlvbi9kaXN0L2pzcy1wbHVnaW4tcnVsZS12YWx1ZS1mdW5jdGlvbi5janMuanMiLCJub2RlX21vZHVsZXMvanNzLXBsdWdpbi12ZW5kb3ItcHJlZml4ZXIvZGlzdC9qc3MtcGx1Z2luLXZlbmRvci1wcmVmaXhlci5janMuanMiLCJub2RlX21vZHVsZXMvanNzL2Rpc3QvanNzLmNqcy5qcyIsIm5vZGVfbW9kdWxlcy9saW5rZWQtbGlzdC9fc291cmNlL2xpbmtlZC1saXN0LmpzIiwibm9kZV9tb2R1bGVzL2xpbmtlZC1saXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5jbG9uZWRlZXAvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoLmVzY2FwZXJlZ2V4cC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gucGFydGl0aW9uL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC5zdW0vaW5kZXguanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcHBseS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheUluY2x1ZGVzV2l0aC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VEaWZmZXJlbmNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGbGF0dGVuLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW50ZXJzZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmFOLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlc3QuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVW5pcS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VYb3IuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0QXJyYXlMaWtlT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlU2V0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9faXNGbGF0dGVuYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX292ZXJSZXN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9TdHJpbmcuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2NvbnN0YW50LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9kaWZmZXJlbmNlLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pbnRlcnNlY3Rpb24uanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2lzQXJyYXlMaWtlT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc0VxdWFsLmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwibm9kZV9tb2R1bGVzL2xvZGFzaC91bmlvbi5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gvd2l0aG91dC5qcyIsIm5vZGVfbW9kdWxlcy9sb2Rhc2gveG9yLmpzIiwibm9kZV9tb2R1bGVzL2xvd2VyLWNhc2UtZmlyc3QvbG93ZXItY2FzZS1maXJzdC5qcyIsIm5vZGVfbW9kdWxlcy9sb3dlci1jYXNlL2xvd2VyLWNhc2UuanMiLCJub2RlX21vZHVsZXMvbWVyc2VubmUtdHdpc3Rlci9zcmMvbWVyc2VubmUtdHdpc3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9taW5pLWNyZWF0ZS1yZWFjdC1jb250ZXh0L2Rpc3QvY2pzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL25vLWNhc2Uvbm8tY2FzZS5qcyIsIm5vZGVfbW9kdWxlcy9uby1jYXNlL3ZlbmRvci9jYW1lbC1jYXNlLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9uby1jYXNlL3ZlbmRvci9jYW1lbC1jYXNlLXVwcGVyLXJlZ2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9uby1jYXNlL3ZlbmRvci9ub24td29yZC1yZWdleHAuanMiLCJub2RlX21vZHVsZXMvbm9kZS1pbnRlcnZhbC10cmVlL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9ub2ZpbHRlci9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWlzL2ltcGxlbWVudGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL29iamVjdC1pcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtaXMvcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWlzL3NoaW0uanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW1wbGVtZW50YXRpb24uanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2JqZWN0LWtleXMvaXNBcmd1bWVudHMuanMiLCJub2RlX21vZHVsZXMvcGFyYW0tY2FzZS9wYXJhbS1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL3Bhc2NhbC1jYXNlL3Bhc2NhbC1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wYXRoLWNhc2UvcGF0aC1jYXNlLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtdG8tcmVnZXhwL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3BvcHBlci5qcy9kaXN0L3VtZC9wb3BwZXIuanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3B1Ym51Yi9kaXN0L3dlYi9wdWJudWIubWluLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1VuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1VuaWZvcm1JbnREaXN0cmlidXRpb24uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24uanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2Rpc3RyaWJ1dGlvbi9pbnRlcm5hbHMvQXJyYXlJbnQuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9kaXN0cmlidXRpb24vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZGlzdHJpYnV0aW9uL2ludGVybmFscy9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWwuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvTGluZWFyQ29uZ3J1ZW50aWFsLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvZ2VuZXJhdG9yL01lcnNlbm5lVHdpc3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9wdXJlLXJhbmQvbGliL2dlbmVyYXRvci9SYW5kb21HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvWG9yU2hpZnQuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9nZW5lcmF0b3IvWG9yb1NoaXJvLmpzIiwibm9kZV9tb2R1bGVzL3B1cmUtcmFuZC9saWIvcHVyZS1yYW5kLWRlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvcHVyZS1yYW5kL2xpYi9wdXJlLXJhbmQuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliLzhCaXRCeXRlLmpzIiwibm9kZV9tb2R1bGVzL3FyLmpzL2xpYi9CaXRCdWZmZXIuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL0Vycm9yQ29ycmVjdExldmVsLmpzIiwibm9kZV9tb2R1bGVzL3FyLmpzL2xpYi9Qb2x5bm9taWFsLmpzIiwibm9kZV9tb2R1bGVzL3FyLmpzL2xpYi9RUkNvZGUuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL1JTQmxvY2suanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL21hdGguanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL21vZGUuanMiLCJub2RlX21vZHVsZXMvcXIuanMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvcXJjb2RlLWdlbmVyYXRvci9xcmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXJjb2RlLnJlYWN0L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kZXZ0b29scy1jb3JlL2JhY2tlbmQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZGV2dG9vbHMtY29yZS9kaXN0L2JhY2tlbmQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZGV2dG9vbHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kLWh0bWw1LWJhY2tlbmQvbGliL2Nqcy9Ccm93c2VyRGV0ZWN0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kLWh0bWw1LWJhY2tlbmQvbGliL2Nqcy9FbnRlckxlYXZlQ291bnRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQtaHRtbDUtYmFja2VuZC9saWIvY2pzL0hUTUw1QmFja2VuZC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQtaHRtbDUtYmFja2VuZC9saWIvY2pzL01vbm90b25pY0ludGVycG9sYW50LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC1odG1sNS1iYWNrZW5kL2xpYi9janMvTmF0aXZlRHJhZ1NvdXJjZXMvTmF0aXZlRHJhZ1NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQtaHRtbDUtYmFja2VuZC9saWIvY2pzL05hdGl2ZURyYWdTb3VyY2VzL2dldERhdGFGcm9tRGF0YVRyYW5zZmVyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC1odG1sNS1iYWNrZW5kL2xpYi9janMvTmF0aXZlRHJhZ1NvdXJjZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kLWh0bWw1LWJhY2tlbmQvbGliL2Nqcy9OYXRpdmVEcmFnU291cmNlcy9uYXRpdmVUeXBlc0NvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQtaHRtbDUtYmFja2VuZC9saWIvY2pzL05hdGl2ZVR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC1odG1sNS1iYWNrZW5kL2xpYi9janMvT2Zmc2V0VXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kLWh0bWw1LWJhY2tlbmQvbGliL2Nqcy9nZXRFbXB0eUltYWdlLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC1odG1sNS1iYWNrZW5kL2xpYi9janMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kLWh0bWw1LWJhY2tlbmQvbGliL2Nqcy91dGlscy9kaXNjb3VudF9sb2Rhc2guanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9EcmFnRHJvcENvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9EcmFnRHJvcENvbnRleHRQcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0RyYWdMYXllci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL0RyYWdTb3VyY2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9Ecm9wVGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlU291cmNlQ29ubmVjdG9yLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlU291cmNlRmFjdG9yeS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2NyZWF0ZVNvdXJjZU1vbml0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVUYXJnZXRDb25uZWN0b3IuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9jcmVhdGVUYXJnZXRGYWN0b3J5LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvY3JlYXRlVGFyZ2V0TW9uaXRvci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2RlY29yYXRlSGFuZGxlci5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvcmVnaXN0ZXJTb3VyY2UuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi9yZWdpc3RlclRhcmdldC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFjdC1kbmQvbGliL3V0aWxzL2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvdXRpbHMvY2xvbmVXaXRoUmVmLmpzIiwibm9kZV9tb2R1bGVzL3JlYWN0LWRuZC9saWIvdXRpbHMvaXNWYWxpZFR5cGUuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL2xpYi93cmFwQ29ubmVjdG9ySG9va3MuanMiLCJub2RlX21vZHVsZXMvcmVhY3QtZG5kL25vZGVfbW9kdWxlcy9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9kaXN0L2hvaXN0LW5vbi1yZWFjdC1zdGF0aWNzLmNqcy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNXJFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDejBFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3hDQTtBQUNBOzs7Ozs7Ozs7OztBQ0RBO0FBQ0E7Ozs7Ozs7Ozs7O0FDREE7QUFDQTs7Ozs7Ozs7Ozs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ25zQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdDFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzFIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMWFBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoa0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsbUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBOzs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0YkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN2c0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlmQTtBQUNBOzs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNXVmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9lQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJ1aS0zLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQgbm8taW52YWxpZC10aGlzOiAxICovXG5cbnZhciBFUlJPUl9NRVNTQUdFID0gJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJztcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgZnVuY1R5cGUgPSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xuICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgIGlmICh0eXBlb2YgdGFyZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHRvU3RyLmNhbGwodGFyZ2V0KSAhPT0gZnVuY1R5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB2YXIgYm91bmQ7XG4gICAgdmFyIGJpbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYm91bmRMZW5ndGg7IGkrKykge1xuICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICB9XG5cbiAgICBib3VuZCA9IEZ1bmN0aW9uKCdiaW5kZXInLCAncmV0dXJuIGZ1bmN0aW9uICgnICsgYm91bmRBcmdzLmpvaW4oJywnKSArICcpeyByZXR1cm4gYmluZGVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICB2YXIgRW1wdHkgPSBmdW5jdGlvbiBFbXB0eSgpIHt9O1xuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgRW1wdHkucHJvdG90eXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gYm91bmQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgfHwgaW1wbGVtZW50YXRpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSBmdW5jdGlvbiBmdW5jdGlvbnNIYXZlTmFtZXMoKSB7XG5cdHJldHVybiB0eXBlb2YgZnVuY3Rpb24gZigpIHt9Lm5hbWUgPT09ICdzdHJpbmcnO1xufTtcblxudmFyIGdPUEQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuaWYgKGdPUEQpIHtcblx0dHJ5IHtcblx0XHRnT1BEKFtdLCAnbGVuZ3RoJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQvLyBJRSA4IGhhcyBhIGJyb2tlbiBnT1BEXG5cdFx0Z09QRCA9IG51bGw7XG5cdH1cbn1cblxuZnVuY3Rpb25zSGF2ZU5hbWVzLmZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcyA9IGZ1bmN0aW9uIGZ1bmN0aW9uc0hhdmVDb25maWd1cmFibGVOYW1lcygpIHtcblx0aWYgKCFmdW5jdGlvbnNIYXZlTmFtZXMoKSB8fCAhZ09QRCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHR2YXIgZGVzYyA9IGdPUEQoZnVuY3Rpb24gKCkge30sICduYW1lJyk7XG5cdHJldHVybiAhIWRlc2MgJiYgISFkZXNjLmNvbmZpZ3VyYWJsZTtcbn07XG5cbnZhciAkYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kO1xuXG5mdW5jdGlvbnNIYXZlTmFtZXMuYm91bmRGdW5jdGlvbnNIYXZlTmFtZXMgPSBmdW5jdGlvbiBib3VuZEZ1bmN0aW9uc0hhdmVOYW1lcygpIHtcblx0cmV0dXJuIGZ1bmN0aW9uc0hhdmVOYW1lcygpICYmIHR5cGVvZiAkYmluZCA9PT0gJ2Z1bmN0aW9uJyAmJiBmdW5jdGlvbiBmKCkge30uYmluZCgpLm5hbWUgIT09ICcnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbnNIYXZlTmFtZXM7XG4iLCIvKiFcbiAqIEZ1c2UuanMgdjMuNi4xIC0gTGlnaHR3ZWlnaHQgZnV6enktc2VhcmNoIChodHRwOi8vZnVzZWpzLmlvKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNyBLaXJvbGxvcyBSaXNrIChodHRwOi8va2lyby5tZSlcbiAqIEFsbCBSaWdodHMgUmVzZXJ2ZWQuIEFwYWNoZSBTb2Z0d2FyZSBMaWNlbnNlIDIuMFxuICogXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqL1xuIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoXCJGdXNlXCIsW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5GdXNlPXQoKTplLkZ1c2U9dCgpfSh0aGlzLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciB0PXt9O2Z1bmN0aW9uIHIobil7aWYodFtuXSlyZXR1cm4gdFtuXS5leHBvcnRzO3ZhciBvPXRbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHIpLG8ubD0hMCxvLmV4cG9ydHN9cmV0dXJuIHIubT1lLHIuYz10LHIuZD1mdW5jdGlvbihlLHQsbil7ci5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2VudW1lcmFibGU6ITAsZ2V0Om59KX0sci5yPWZ1bmN0aW9uKGUpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIudD1mdW5jdGlvbihlLHQpe2lmKDEmdCYmKGU9cihlKSksOCZ0KXJldHVybiBlO2lmKDQmdCYmXCJvYmplY3RcIj09dHlwZW9mIGUmJmUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTplfSksMiZ0JiZcInN0cmluZ1wiIT10eXBlb2YgZSlmb3IodmFyIG8gaW4gZSlyLmQobixvLGZ1bmN0aW9uKHQpe3JldHVybiBlW3RdfS5iaW5kKG51bGwsbykpO3JldHVybiBufSxyLm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHIuZCh0LFwiYVwiLHQpLHR9LHIubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sci5wPVwiXCIscihyLnM9MCl9KFtmdW5jdGlvbihlLHQscil7ZnVuY3Rpb24gbihlKXtyZXR1cm4obj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9ZnVuY3Rpb24gbyhlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19dmFyIGk9cigxKSxhPXIoNykscz1hLmdldCxjPShhLmRlZXBWYWx1ZSxhLmlzQXJyYXkpLGg9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQscil7dmFyIG49ci5sb2NhdGlvbixvPXZvaWQgMD09PW4/MDpuLGk9ci5kaXN0YW5jZSxhPXZvaWQgMD09PWk/MTAwOmksYz1yLnRocmVzaG9sZCxoPXZvaWQgMD09PWM/LjY6YyxsPXIubWF4UGF0dGVybkxlbmd0aCx1PXZvaWQgMD09PWw/MzI6bCxmPXIuY2FzZVNlbnNpdGl2ZSx2PXZvaWQgMCE9PWYmJmYscD1yLnRva2VuU2VwYXJhdG9yLGQ9dm9pZCAwPT09cD8vICsvZzpwLGc9ci5maW5kQWxsTWF0Y2hlcyx5PXZvaWQgMCE9PWcmJmcsbT1yLm1pbk1hdGNoQ2hhckxlbmd0aCxrPXZvaWQgMD09PW0/MTptLGI9ci5pZCxTPXZvaWQgMD09PWI/bnVsbDpiLHg9ci5rZXlzLE09dm9pZCAwPT09eD9bXTp4LF89ci5zaG91bGRTb3J0LHc9dm9pZCAwPT09X3x8XyxMPXIuZ2V0Rm4sQT12b2lkIDA9PT1MP3M6TCxPPXIuc29ydEZuLEM9dm9pZCAwPT09Tz9mdW5jdGlvbihlLHQpe3JldHVybiBlLnNjb3JlLXQuc2NvcmV9Ok8saj1yLnRva2VuaXplLFA9dm9pZCAwIT09aiYmaixJPXIubWF0Y2hBbGxUb2tlbnMsRj12b2lkIDAhPT1JJiZJLFQ9ci5pbmNsdWRlTWF0Y2hlcyxOPXZvaWQgMCE9PVQmJlQsej1yLmluY2x1ZGVTY29yZSxFPXZvaWQgMCE9PXomJnosVz1yLnZlcmJvc2UsSz12b2lkIDAhPT1XJiZXOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZSksdGhpcy5vcHRpb25zPXtsb2NhdGlvbjpvLGRpc3RhbmNlOmEsdGhyZXNob2xkOmgsbWF4UGF0dGVybkxlbmd0aDp1LGlzQ2FzZVNlbnNpdGl2ZTp2LHRva2VuU2VwYXJhdG9yOmQsZmluZEFsbE1hdGNoZXM6eSxtaW5NYXRjaENoYXJMZW5ndGg6ayxpZDpTLGtleXM6TSxpbmNsdWRlTWF0Y2hlczpOLGluY2x1ZGVTY29yZTpFLHNob3VsZFNvcnQ6dyxnZXRGbjpBLHNvcnRGbjpDLHZlcmJvc2U6Syx0b2tlbml6ZTpQLG1hdGNoQWxsVG9rZW5zOkZ9LHRoaXMuc2V0Q29sbGVjdGlvbih0KSx0aGlzLl9wcm9jZXNzS2V5cyhNKX12YXIgdCxyLGE7cmV0dXJuIHQ9ZSwocj1be2tleTpcInNldENvbGxlY3Rpb25cIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5saXN0PWUsZX19LHtrZXk6XCJfcHJvY2Vzc0tleXNcIix2YWx1ZTpmdW5jdGlvbihlKXtpZih0aGlzLl9rZXlXZWlnaHRzPXt9LHRoaXMuX2tleU5hbWVzPVtdLGUubGVuZ3RoJiZcInN0cmluZ1wiPT10eXBlb2YgZVswXSlmb3IodmFyIHQ9MCxyPWUubGVuZ3RoO3Q8cjt0Kz0xKXt2YXIgbj1lW3RdO3RoaXMuX2tleVdlaWdodHNbbl09MSx0aGlzLl9rZXlOYW1lcy5wdXNoKG4pfWVsc2V7Zm9yKHZhciBvPW51bGwsaT1udWxsLGE9MCxzPTAsYz1lLmxlbmd0aDtzPGM7cys9MSl7dmFyIGg9ZVtzXTtpZighaC5oYXNPd25Qcm9wZXJ0eShcIm5hbWVcIikpdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwibmFtZVwiIHByb3BlcnR5IGluIGtleSBvYmplY3QnKTt2YXIgbD1oLm5hbWU7aWYodGhpcy5fa2V5TmFtZXMucHVzaChsKSwhaC5oYXNPd25Qcm9wZXJ0eShcIndlaWdodFwiKSl0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJ3ZWlnaHRcIiBwcm9wZXJ0eSBpbiBrZXkgb2JqZWN0Jyk7dmFyIHU9aC53ZWlnaHQ7aWYodTwwfHx1PjEpdGhyb3cgbmV3IEVycm9yKCdcIndlaWdodFwiIHByb3BlcnR5IGluIGtleSBtdXN0IGJlaW4gdGhlIHJhbmdlIG9mIFswLCAxKScpO2k9bnVsbD09aT91Ok1hdGgubWF4KGksdSksbz1udWxsPT1vP3U6TWF0aC5taW4obyx1KSx0aGlzLl9rZXlXZWlnaHRzW2xdPXUsYSs9dX1pZihhPjEpdGhyb3cgbmV3IEVycm9yKFwiVG90YWwgb2Ygd2VpZ2h0cyBjYW5ub3QgZXhjZWVkIDFcIil9fX0se2tleTpcInNlYXJjaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp7bGltaXQ6ITF9O3RoaXMuX2xvZygnLS0tLS0tLS0tXFxuU2VhcmNoIHBhdHRlcm46IFwiJy5jb25jYXQoZSwnXCInKSk7dmFyIHI9dGhpcy5fcHJlcGFyZVNlYXJjaGVycyhlKSxuPXIudG9rZW5TZWFyY2hlcnMsbz1yLmZ1bGxTZWFyY2hlcixpPXRoaXMuX3NlYXJjaChuLG8pO3JldHVybiB0aGlzLl9jb21wdXRlU2NvcmUoaSksdGhpcy5vcHRpb25zLnNob3VsZFNvcnQmJnRoaXMuX3NvcnQoaSksdC5saW1pdCYmXCJudW1iZXJcIj09dHlwZW9mIHQubGltaXQmJihpPWkuc2xpY2UoMCx0LmxpbWl0KSksdGhpcy5fZm9ybWF0KGkpfX0se2tleTpcIl9wcmVwYXJlU2VhcmNoZXJzXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06XCJcIix0PVtdO2lmKHRoaXMub3B0aW9ucy50b2tlbml6ZSlmb3IodmFyIHI9ZS5zcGxpdCh0aGlzLm9wdGlvbnMudG9rZW5TZXBhcmF0b3IpLG49MCxvPXIubGVuZ3RoO248bztuKz0xKXQucHVzaChuZXcgaShyW25dLHRoaXMub3B0aW9ucykpO3JldHVybnt0b2tlblNlYXJjaGVyczp0LGZ1bGxTZWFyY2hlcjpuZXcgaShlLHRoaXMub3B0aW9ucyl9fX0se2tleTpcIl9zZWFyY2hcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MCYmdm9pZCAwIT09YXJndW1lbnRzWzBdP2FyZ3VtZW50c1swXTpbXSx0PWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLHI9dGhpcy5saXN0LG49e30sbz1bXTtpZihcInN0cmluZ1wiPT10eXBlb2YgclswXSl7Zm9yKHZhciBpPTAsYT1yLmxlbmd0aDtpPGE7aSs9MSl0aGlzLl9hbmFseXplKHtrZXk6XCJcIix2YWx1ZTpyW2ldLHJlY29yZDppLGluZGV4Oml9LHtyZXN1bHRNYXA6bixyZXN1bHRzOm8sdG9rZW5TZWFyY2hlcnM6ZSxmdWxsU2VhcmNoZXI6dH0pO3JldHVybiBvfWZvcih2YXIgcz0wLGM9ci5sZW5ndGg7czxjO3MrPTEpZm9yKHZhciBoPXJbc10sbD0wLHU9dGhpcy5fa2V5TmFtZXMubGVuZ3RoO2w8dTtsKz0xKXt2YXIgZj10aGlzLl9rZXlOYW1lc1tsXTt0aGlzLl9hbmFseXplKHtrZXk6Zix2YWx1ZTp0aGlzLm9wdGlvbnMuZ2V0Rm4oaCxmKSxyZWNvcmQ6aCxpbmRleDpzfSx7cmVzdWx0TWFwOm4scmVzdWx0czpvLHRva2VuU2VhcmNoZXJzOmUsZnVsbFNlYXJjaGVyOnR9KX1yZXR1cm4gb319LHtrZXk6XCJfYW5hbHl6ZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcyxuPWUua2V5LG89ZS5hcnJheUluZGV4LGk9dm9pZCAwPT09bz8tMTpvLGE9ZS52YWx1ZSxzPWUucmVjb3JkLGg9ZS5pbmRleCxsPXQudG9rZW5TZWFyY2hlcnMsdT12b2lkIDA9PT1sP1tdOmwsZj10LmZ1bGxTZWFyY2hlcix2PXQucmVzdWx0TWFwLHA9dm9pZCAwPT09dj97fTp2LGQ9dC5yZXN1bHRzLGc9dm9pZCAwPT09ZD9bXTpkOyFmdW5jdGlvbiBlKHQsbyxpLGEpe2lmKG51bGwhPW8paWYoXCJzdHJpbmdcIj09dHlwZW9mIG8pe3ZhciBzPSExLGg9LTEsbD0wO3IuX2xvZyhcIlxcbktleTogXCIuY29uY2F0KFwiXCI9PT1uP1wiLS1cIjpuKSk7dmFyIHY9Zi5zZWFyY2gobyk7aWYoci5fbG9nKCdGdWxsIHRleHQ6IFwiJy5jb25jYXQobywnXCIsIHNjb3JlOiAnKS5jb25jYXQodi5zY29yZSkpLHIub3B0aW9ucy50b2tlbml6ZSl7Zm9yKHZhciBkPW8uc3BsaXQoci5vcHRpb25zLnRva2VuU2VwYXJhdG9yKSx5PWQubGVuZ3RoLG09W10saz0wLGI9dS5sZW5ndGg7azxiO2srPTEpe3ZhciBTPXVba107ci5fbG9nKCdcXG5QYXR0ZXJuOiBcIicuY29uY2F0KFMucGF0dGVybiwnXCInKSk7Zm9yKHZhciB4PSExLE09MDtNPHk7TSs9MSl7dmFyIF89ZFtNXSx3PVMuc2VhcmNoKF8pLEw9e307dy5pc01hdGNoPyhMW19dPXcuc2NvcmUscz0hMCx4PSEwLG0ucHVzaCh3LnNjb3JlKSk6KExbX109MSxyLm9wdGlvbnMubWF0Y2hBbGxUb2tlbnN8fG0ucHVzaCgxKSksci5fbG9nKCdUb2tlbjogXCInLmNvbmNhdChfLCdcIiwgc2NvcmU6ICcpLmNvbmNhdChMW19dKSl9eCYmKGwrPTEpfWg9bVswXTtmb3IodmFyIEE9bS5sZW5ndGgsTz0xO088QTtPKz0xKWgrPW1bT107aC89QSxyLl9sb2coXCJUb2tlbiBzY29yZSBhdmVyYWdlOlwiLGgpfXZhciBDPXYuc2NvcmU7aD4tMSYmKEM9KEMraCkvMiksci5fbG9nKFwiU2NvcmUgYXZlcmFnZTpcIixDKTt2YXIgaj0hci5vcHRpb25zLnRva2VuaXplfHwhci5vcHRpb25zLm1hdGNoQWxsVG9rZW5zfHxsPj11Lmxlbmd0aDtpZihyLl9sb2coXCJcXG5DaGVjayBNYXRjaGVzOiBcIi5jb25jYXQoaikpLChzfHx2LmlzTWF0Y2gpJiZqKXt2YXIgUD17a2V5Om4sYXJyYXlJbmRleDp0LHZhbHVlOm8sc2NvcmU6Q307ci5vcHRpb25zLmluY2x1ZGVNYXRjaGVzJiYoUC5tYXRjaGVkSW5kaWNlcz12Lm1hdGNoZWRJbmRpY2VzKTt2YXIgST1wW2FdO0k/SS5vdXRwdXQucHVzaChQKToocFthXT17aXRlbTppLG91dHB1dDpbUF19LGcucHVzaChwW2FdKSl9fWVsc2UgaWYoYyhvKSlmb3IodmFyIEY9MCxUPW8ubGVuZ3RoO0Y8VDtGKz0xKWUoRixvW0ZdLGksYSl9KGksYSxzLGgpfX0se2tleTpcIl9jb21wdXRlU2NvcmVcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9sb2coXCJcXG5cXG5Db21wdXRpbmcgc2NvcmU6XFxuXCIpO2Zvcih2YXIgdD10aGlzLl9rZXlXZWlnaHRzLHI9ISFPYmplY3Qua2V5cyh0KS5sZW5ndGgsbj0wLG89ZS5sZW5ndGg7bjxvO24rPTEpe2Zvcih2YXIgaT1lW25dLGE9aS5vdXRwdXQscz1hLmxlbmd0aCxjPTEsaD0wO2g8cztoKz0xKXt2YXIgbD1hW2hdLHU9bC5rZXksZj1yP3RbdV06MSx2PTA9PT1sLnNjb3JlJiZ0JiZ0W3VdPjA/TnVtYmVyLkVQU0lMT046bC5zY29yZTtjKj1NYXRoLnBvdyh2LGYpfWkuc2NvcmU9Yyx0aGlzLl9sb2coaSl9fX0se2tleTpcIl9zb3J0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fbG9nKFwiXFxuXFxuU29ydGluZy4uLi5cIiksZS5zb3J0KHRoaXMub3B0aW9ucy5zb3J0Rm4pfX0se2tleTpcIl9mb3JtYXRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1bXTtpZih0aGlzLm9wdGlvbnMudmVyYm9zZSl7dmFyIHI9W107dGhpcy5fbG9nKFwiXFxuXFxuT3V0cHV0OlxcblxcblwiLEpTT04uc3RyaW5naWZ5KGUsZnVuY3Rpb24oZSx0KXtpZihcIm9iamVjdFwiPT09bih0KSYmbnVsbCE9PXQpe2lmKC0xIT09ci5pbmRleE9mKHQpKXJldHVybjtyLnB1c2godCl9cmV0dXJuIHR9LDIpKSxyPW51bGx9dmFyIG89W107dGhpcy5vcHRpb25zLmluY2x1ZGVNYXRjaGVzJiZvLnB1c2goZnVuY3Rpb24oZSx0KXt2YXIgcj1lLm91dHB1dDt0Lm1hdGNoZXM9W107Zm9yKHZhciBuPTAsbz1yLmxlbmd0aDtuPG87bis9MSl7dmFyIGk9cltuXTtpZigwIT09aS5tYXRjaGVkSW5kaWNlcy5sZW5ndGgpe3ZhciBhPXtpbmRpY2VzOmkubWF0Y2hlZEluZGljZXMsdmFsdWU6aS52YWx1ZX07aS5rZXkmJihhLmtleT1pLmtleSksaS5oYXNPd25Qcm9wZXJ0eShcImFycmF5SW5kZXhcIikmJmkuYXJyYXlJbmRleD4tMSYmKGEuYXJyYXlJbmRleD1pLmFycmF5SW5kZXgpLHQubWF0Y2hlcy5wdXNoKGEpfX19KSx0aGlzLm9wdGlvbnMuaW5jbHVkZVNjb3JlJiZvLnB1c2goZnVuY3Rpb24oZSx0KXt0LnNjb3JlPWUuc2NvcmV9KTtmb3IodmFyIGk9MCxhPWUubGVuZ3RoO2k8YTtpKz0xKXt2YXIgcz1lW2ldO2lmKHRoaXMub3B0aW9ucy5pZCYmKHMuaXRlbT10aGlzLm9wdGlvbnMuZ2V0Rm4ocy5pdGVtLHRoaXMub3B0aW9ucy5pZClbMF0pLG8ubGVuZ3RoKXtmb3IodmFyIGM9e2l0ZW06cy5pdGVtfSxoPTAsbD1vLmxlbmd0aDtoPGw7aCs9MSlvW2hdKHMsYyk7dC5wdXNoKGMpfWVsc2UgdC5wdXNoKHMuaXRlbSl9cmV0dXJuIHR9fSx7a2V5OlwiX2xvZ1wiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIGU7dGhpcy5vcHRpb25zLnZlcmJvc2UmJihlPWNvbnNvbGUpLmxvZy5hcHBseShlLGFyZ3VtZW50cyl9fV0pJiZvKHQucHJvdG90eXBlLHIpLGEmJm8odCxhKSxlfSgpO2UuZXhwb3J0cz1ofSxmdW5jdGlvbihlLHQscil7ZnVuY3Rpb24gbihlLHQpe2Zvcih2YXIgcj0wO3I8dC5sZW5ndGg7cisrKXt2YXIgbj10W3JdO24uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX19dmFyIG89cigyKSxpPXIoMyksYT1yKDYpLHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQscil7dmFyIG49ci5sb2NhdGlvbixvPXZvaWQgMD09PW4/MDpuLGk9ci5kaXN0YW5jZSxzPXZvaWQgMD09PWk/MTAwOmksYz1yLnRocmVzaG9sZCxoPXZvaWQgMD09PWM/LjY6YyxsPXIubWF4UGF0dGVybkxlbmd0aCx1PXZvaWQgMD09PWw/MzI6bCxmPXIuaXNDYXNlU2Vuc2l0aXZlLHY9dm9pZCAwIT09ZiYmZixwPXIudG9rZW5TZXBhcmF0b3IsZD12b2lkIDA9PT1wPy8gKy9nOnAsZz1yLmZpbmRBbGxNYXRjaGVzLHk9dm9pZCAwIT09ZyYmZyxtPXIubWluTWF0Y2hDaGFyTGVuZ3RoLGs9dm9pZCAwPT09bT8xOm0sYj1yLmluY2x1ZGVNYXRjaGVzLFM9dm9pZCAwIT09YiYmYjshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGUpLHRoaXMub3B0aW9ucz17bG9jYXRpb246byxkaXN0YW5jZTpzLHRocmVzaG9sZDpoLG1heFBhdHRlcm5MZW5ndGg6dSxpc0Nhc2VTZW5zaXRpdmU6dix0b2tlblNlcGFyYXRvcjpkLGZpbmRBbGxNYXRjaGVzOnksaW5jbHVkZU1hdGNoZXM6UyxtaW5NYXRjaENoYXJMZW5ndGg6a30sdGhpcy5wYXR0ZXJuPXY/dDp0LnRvTG93ZXJDYXNlKCksdGhpcy5wYXR0ZXJuLmxlbmd0aDw9dSYmKHRoaXMucGF0dGVybkFscGhhYmV0PWEodGhpcy5wYXR0ZXJuKSl9dmFyIHQscixzO3JldHVybiB0PWUsKHI9W3trZXk6XCJzZWFyY2hcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzLm9wdGlvbnMscj10LmlzQ2FzZVNlbnNpdGl2ZSxuPXQuaW5jbHVkZU1hdGNoZXM7aWYocnx8KGU9ZS50b0xvd2VyQ2FzZSgpKSx0aGlzLnBhdHRlcm49PT1lKXt2YXIgYT17aXNNYXRjaDohMCxzY29yZTowfTtyZXR1cm4gbiYmKGEubWF0Y2hlZEluZGljZXM9W1swLGUubGVuZ3RoLTFdXSksYX12YXIgcz10aGlzLm9wdGlvbnMsYz1zLm1heFBhdHRlcm5MZW5ndGgsaD1zLnRva2VuU2VwYXJhdG9yO2lmKHRoaXMucGF0dGVybi5sZW5ndGg+YylyZXR1cm4gbyhlLHRoaXMucGF0dGVybixoKTt2YXIgbD10aGlzLm9wdGlvbnMsdT1sLmxvY2F0aW9uLGY9bC5kaXN0YW5jZSx2PWwudGhyZXNob2xkLHA9bC5maW5kQWxsTWF0Y2hlcyxkPWwubWluTWF0Y2hDaGFyTGVuZ3RoO3JldHVybiBpKGUsdGhpcy5wYXR0ZXJuLHRoaXMucGF0dGVybkFscGhhYmV0LHtsb2NhdGlvbjp1LGRpc3RhbmNlOmYsdGhyZXNob2xkOnYsZmluZEFsbE1hdGNoZXM6cCxtaW5NYXRjaENoYXJMZW5ndGg6ZCxpbmNsdWRlTWF0Y2hlczpufSl9fV0pJiZuKHQucHJvdG90eXBlLHIpLHMmJm4odCxzKSxlfSgpO2UuZXhwb3J0cz1zfSxmdW5jdGlvbihlLHQpe3ZhciByPS9bXFwtXFxbXFxdXFwvXFx7XFx9XFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcXlxcJFxcfF0vZztlLmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjImJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06LyArL2csbz1uZXcgUmVnRXhwKHQucmVwbGFjZShyLFwiXFxcXCQmXCIpLnJlcGxhY2UobixcInxcIikpLGk9ZS5tYXRjaChvKSxhPSEhaSxzPVtdO2lmKGEpZm9yKHZhciBjPTAsaD1pLmxlbmd0aDtjPGg7Yys9MSl7dmFyIGw9aVtjXTtzLnB1c2goW2UuaW5kZXhPZihsKSxsLmxlbmd0aC0xXSl9cmV0dXJue3Njb3JlOmE/LjU6MSxpc01hdGNoOmEsbWF0Y2hlZEluZGljZXM6c319fSxmdW5jdGlvbihlLHQscil7dmFyIG49cig0KSxvPXIoNSk7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCxyLGkpe2Zvcih2YXIgYT1pLmxvY2F0aW9uLHM9dm9pZCAwPT09YT8wOmEsYz1pLmRpc3RhbmNlLGg9dm9pZCAwPT09Yz8xMDA6YyxsPWkudGhyZXNob2xkLHU9dm9pZCAwPT09bD8uNjpsLGY9aS5maW5kQWxsTWF0Y2hlcyx2PXZvaWQgMCE9PWYmJmYscD1pLm1pbk1hdGNoQ2hhckxlbmd0aCxkPXZvaWQgMD09PXA/MTpwLGc9aS5pbmNsdWRlTWF0Y2hlcyx5PXZvaWQgMCE9PWcmJmcsbT1zLGs9ZS5sZW5ndGgsYj11LFM9ZS5pbmRleE9mKHQsbSkseD10Lmxlbmd0aCxNPVtdLF89MDtfPGs7Xys9MSlNW19dPTA7aWYoLTEhPT1TKXt2YXIgdz1uKHQse2Vycm9yczowLGN1cnJlbnRMb2NhdGlvbjpTLGV4cGVjdGVkTG9jYXRpb246bSxkaXN0YW5jZTpofSk7aWYoYj1NYXRoLm1pbih3LGIpLC0xIT09KFM9ZS5sYXN0SW5kZXhPZih0LG0reCkpKXt2YXIgTD1uKHQse2Vycm9yczowLGN1cnJlbnRMb2NhdGlvbjpTLGV4cGVjdGVkTG9jYXRpb246bSxkaXN0YW5jZTpofSk7Yj1NYXRoLm1pbihMLGIpfX1TPS0xO2Zvcih2YXIgQT1bXSxPPTEsQz14K2ssaj0xPDwoeDw9MzE/eC0xOjMwKSxQPTA7UDx4O1ArPTEpe2Zvcih2YXIgST0wLEY9QztJPEY7KXtuKHQse2Vycm9yczpQLGN1cnJlbnRMb2NhdGlvbjptK0YsZXhwZWN0ZWRMb2NhdGlvbjptLGRpc3RhbmNlOmh9KTw9Yj9JPUY6Qz1GLEY9TWF0aC5mbG9vcigoQy1JKS8yK0kpfUM9Rjt2YXIgVD1NYXRoLm1heCgxLG0tRisxKSxOPXY/azpNYXRoLm1pbihtK0YsaykreCx6PUFycmF5KE4rMik7eltOKzFdPSgxPDxQKS0xO2Zvcih2YXIgRT1OO0U+PVQ7RS09MSl7dmFyIFc9RS0xLEs9cltlLmNoYXJBdChXKV07aWYoSyYmKE1bV109MSkseltFXT0oeltFKzFdPDwxfDEpJkssMCE9PVAmJih6W0VdfD0oQVtFKzFdfEFbRV0pPDwxfDF8QVtFKzFdKSx6W0VdJmomJihPPW4odCx7ZXJyb3JzOlAsY3VycmVudExvY2F0aW9uOlcsZXhwZWN0ZWRMb2NhdGlvbjptLGRpc3RhbmNlOmh9KSk8PWIpe2lmKGI9TywoUz1XKTw9bSlicmVhaztUPU1hdGgubWF4KDEsMiptLVMpfX1pZihuKHQse2Vycm9yczpQKzEsY3VycmVudExvY2F0aW9uOm0sZXhwZWN0ZWRMb2NhdGlvbjptLGRpc3RhbmNlOmh9KT5iKWJyZWFrO0E9en12YXIgJD17aXNNYXRjaDpTPj0wLHNjb3JlOjA9PT1PPy4wMDE6T307cmV0dXJuIHkmJigkLm1hdGNoZWRJbmRpY2VzPW8oTSxkKSksJH19LGZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5lcnJvcnMsbj12b2lkIDA9PT1yPzA6cixvPXQuY3VycmVudExvY2F0aW9uLGk9dm9pZCAwPT09bz8wOm8sYT10LmV4cGVjdGVkTG9jYXRpb24scz12b2lkIDA9PT1hPzA6YSxjPXQuZGlzdGFuY2UsaD12b2lkIDA9PT1jPzEwMDpjLGw9bi9lLmxlbmd0aCx1PU1hdGguYWJzKHMtaSk7cmV0dXJuIGg/bCt1L2g6dT8xOmx9fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1mdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoPjAmJnZvaWQgMCE9PWFyZ3VtZW50c1swXT9hcmd1bWVudHNbMF06W10sdD1hcmd1bWVudHMubGVuZ3RoPjEmJnZvaWQgMCE9PWFyZ3VtZW50c1sxXT9hcmd1bWVudHNbMV06MSxyPVtdLG49LTEsbz0tMSxpPTAsYT1lLmxlbmd0aDtpPGE7aSs9MSl7dmFyIHM9ZVtpXTtzJiYtMT09PW4/bj1pOnN8fC0xPT09bnx8KChvPWktMSktbisxPj10JiZyLnB1c2goW24sb10pLG49LTEpfXJldHVybiBlW2ktMV0mJmktbj49dCYmci5wdXNoKFtuLGktMV0pLHJ9fSxmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1mdW5jdGlvbihlKXtmb3IodmFyIHQ9e30scj1lLmxlbmd0aCxuPTA7bjxyO24rPTEpdFtlLmNoYXJBdChuKV09MDtmb3IodmFyIG89MDtvPHI7bys9MSl0W2UuY2hhckF0KG8pXXw9MTw8ci1vLTE7cmV0dXJuIHR9fSxmdW5jdGlvbihlLHQpe3ZhciByPWZ1bmN0aW9uKGUpe3JldHVybiBBcnJheS5pc0FycmF5P0FycmF5LmlzQXJyYXkoZSk6XCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpfSxuPWZ1bmN0aW9uKGUpe3JldHVybiBudWxsPT1lP1wiXCI6ZnVuY3Rpb24oZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGU7dmFyIHQ9ZStcIlwiO3JldHVyblwiMFwiPT10JiYxL2U9PS0xLzA/XCItMFwiOnR9KGUpfSxvPWZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfSxpPWZ1bmN0aW9uKGUpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiBlfTtlLmV4cG9ydHM9e2dldDpmdW5jdGlvbihlLHQpe3ZhciBhPVtdO3JldHVybiBmdW5jdGlvbiBlKHQscyl7aWYocyl7dmFyIGM9cy5pbmRleE9mKFwiLlwiKSxoPXMsbD1udWxsOy0xIT09YyYmKGg9cy5zbGljZSgwLGMpLGw9cy5zbGljZShjKzEpKTt2YXIgdT10W2hdO2lmKG51bGwhPXUpaWYobHx8IW8odSkmJiFpKHUpKWlmKHIodSkpZm9yKHZhciBmPTAsdj11Lmxlbmd0aDtmPHY7Zis9MSllKHVbZl0sbCk7ZWxzZSBsJiZlKHUsbCk7ZWxzZSBhLnB1c2gobih1KSl9ZWxzZSBhLnB1c2godCl9KGUsdCksYX0saXNBcnJheTpyLGlzU3RyaW5nOm8saXNOdW06aSx0b1N0cmluZzpufX1dKX0pOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHVuZGVmaW5lZDtcblxudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxudmFyIGdldEV2YWxsZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChleHByZXNzaW9uU3ludGF4KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuICRGdW5jdGlvbignXCJ1c2Ugc3RyaWN0XCI7IHJldHVybiAoJyArIGV4cHJlc3Npb25TeW50YXggKyAnKS5jb25zdHJ1Y3RvcjsnKSgpO1xuXHR9IGNhdGNoIChlKSB7fVxufTtcblxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmlmICgkZ09QRCkge1xuXHR0cnkge1xuXHRcdCRnT1BEKHt9LCAnJyk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHQkZ09QRCA9IG51bGw7IC8vIHRoaXMgaXMgSUUgOCwgd2hpY2ggaGFzIGEgYnJva2VuIGdPUERcblx0fVxufVxuXG52YXIgdGhyb3dUeXBlRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XG59O1xudmFyIFRocm93VHlwZUVycm9yID0gJGdPUERcblx0PyAoZnVuY3Rpb24gKCkge1xuXHRcdHRyeSB7XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zLCBuby1jYWxsZXIsIG5vLXJlc3RyaWN0ZWQtcHJvcGVydGllc1xuXHRcdFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXG5cdFx0XHRyZXR1cm4gdGhyb3dUeXBlRXJyb3I7XG5cdFx0fSBjYXRjaCAoY2FsbGVlVGhyb3dzKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHQvLyBJRSA4IHRocm93cyBvbiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFyZ3VtZW50cywgJycpXG5cdFx0XHRcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XG5cdFx0XHR9IGNhdGNoIChnT1BEdGhyb3dzKSB7XG5cdFx0XHRcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0oKSlcblx0OiB0aHJvd1R5cGVFcnJvcjtcblxudmFyIGhhc1N5bWJvbHMgPSByZXF1aXJlKCdoYXMtc3ltYm9scycpKCk7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5fX3Byb3RvX187IH07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cblxudmFyIG5lZWRzRXZhbCA9IHt9O1xuXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xuXG52YXIgSU5UUklOU0lDUyA9IHtcblx0JyVBZ2dyZWdhdGVFcnJvciUnOiB0eXBlb2YgQWdncmVnYXRlRXJyb3IgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQWdncmVnYXRlRXJyb3IsXG5cdCclQXJyYXklJzogQXJyYXksXG5cdCclQXJyYXlCdWZmZXIlJzogdHlwZW9mIEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFycmF5QnVmZmVyLFxuXHQnJUFycmF5SXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKFtdW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcblx0JyVBc3luY0Z1bmN0aW9uJSc6IG5lZWRzRXZhbCxcblx0JyVBc3luY0dlbmVyYXRvciUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXG5cdCclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnOiBuZWVkc0V2YWwsXG5cdCclQXRvbWljcyUnOiB0eXBlb2YgQXRvbWljcyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBBdG9taWNzLFxuXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcblx0JyVCb29sZWFuJSc6IEJvb2xlYW4sXG5cdCclRGF0YVZpZXclJzogdHlwZW9mIERhdGFWaWV3ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IERhdGFWaWV3LFxuXHQnJURhdGUlJzogRGF0ZSxcblx0JyVkZWNvZGVVUkklJzogZGVjb2RlVVJJLFxuXHQnJWRlY29kZVVSSUNvbXBvbmVudCUnOiBkZWNvZGVVUklDb21wb25lbnQsXG5cdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcblx0JyVlbmNvZGVVUklDb21wb25lbnQlJzogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHQnJUVycm9yJSc6IEVycm9yLFxuXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG5cdCclRXZhbEVycm9yJSc6IEV2YWxFcnJvcixcblx0JyVGbG9hdDMyQXJyYXklJzogdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGbG9hdDMyQXJyYXksXG5cdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxuXHQnJUZpbmFsaXphdGlvblJlZ2lzdHJ5JSc6IHR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBGaW5hbGl6YXRpb25SZWdpc3RyeSxcblx0JyVGdW5jdGlvbiUnOiAkRnVuY3Rpb24sXG5cdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxuXHQnJUludDhBcnJheSUnOiB0eXBlb2YgSW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDhBcnJheSxcblx0JyVJbnQxNkFycmF5JSc6IHR5cGVvZiBJbnQxNkFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEludDE2QXJyYXksXG5cdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxuXHQnJWlzRmluaXRlJSc6IGlzRmluaXRlLFxuXHQnJWlzTmFOJSc6IGlzTmFOLFxuXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcblx0JyVKU09OJSc6IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiB1bmRlZmluZWQsXG5cdCclTWFwJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogTWFwLFxuXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclTWF0aCUnOiBNYXRoLFxuXHQnJU51bWJlciUnOiBOdW1iZXIsXG5cdCclT2JqZWN0JSc6IE9iamVjdCxcblx0JyVwYXJzZUZsb2F0JSc6IHBhcnNlRmxvYXQsXG5cdCclcGFyc2VJbnQlJzogcGFyc2VJbnQsXG5cdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxuXHQnJVByb3h5JSc6IHR5cGVvZiBQcm94eSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm94eSxcblx0JyVSYW5nZUVycm9yJSc6IFJhbmdlRXJyb3IsXG5cdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXG5cdCclUmVmbGVjdCUnOiB0eXBlb2YgUmVmbGVjdCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBSZWZsZWN0LFxuXHQnJVJlZ0V4cCUnOiBSZWdFeHAsXG5cdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxuXHQnJVNldEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IFNldCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXG5cdCclU2hhcmVkQXJyYXlCdWZmZXIlJzogdHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFNoYXJlZEFycmF5QnVmZmVyLFxuXHQnJVN0cmluZyUnOiBTdHJpbmcsXG5cdCclU3RyaW5nSXRlcmF0b3JQcm90b3R5cGUlJzogaGFzU3ltYm9scyA/IGdldFByb3RvKCcnW1N5bWJvbC5pdGVyYXRvcl0oKSkgOiB1bmRlZmluZWQsXG5cdCclU3ltYm9sJSc6IGhhc1N5bWJvbHMgPyBTeW1ib2wgOiB1bmRlZmluZWQsXG5cdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxuXHQnJVRocm93VHlwZUVycm9yJSc6IFRocm93VHlwZUVycm9yLFxuXHQnJVR5cGVkQXJyYXklJzogVHlwZWRBcnJheSxcblx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcblx0JyVVaW50OEFycmF5JSc6IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4QXJyYXksXG5cdCclVWludDhDbGFtcGVkQXJyYXklJzogdHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFVpbnQ4Q2xhbXBlZEFycmF5LFxuXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcblx0JyVVaW50MzJBcnJheSUnOiB0eXBlb2YgVWludDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDMyQXJyYXksXG5cdCclVVJJRXJyb3IlJzogVVJJRXJyb3IsXG5cdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxuXHQnJVdlYWtSZWYlJzogdHlwZW9mIFdlYWtSZWYgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogV2Vha1JlZixcblx0JyVXZWFrU2V0JSc6IHR5cGVvZiBXZWFrU2V0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFdlYWtTZXRcbn07XG5cbnZhciBkb0V2YWwgPSBmdW5jdGlvbiBkb0V2YWwobmFtZSkge1xuXHR2YXIgdmFsdWU7XG5cdGlmIChuYW1lID09PSAnJUFzeW5jRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiAoKSB7fScpO1xuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xuXHRcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcblx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yJScpIHtcblx0XHR2YXIgZm4gPSBkb0V2YWwoJyVBc3luY0dlbmVyYXRvckZ1bmN0aW9uJScpO1xuXHRcdGlmIChmbikge1xuXHRcdFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNJdGVyYXRvclByb3RvdHlwZSUnKSB7XG5cdFx0dmFyIGdlbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yJScpO1xuXHRcdGlmIChnZW4pIHtcblx0XHRcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XG5cdFx0fVxuXHR9XG5cblx0SU5UUklOU0lDU1tuYW1lXSA9IHZhbHVlO1xuXG5cdHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBMRUdBQ1lfQUxJQVNFUyA9IHtcblx0JyVBcnJheUJ1ZmZlclByb3RvdHlwZSUnOiBbJ0FycmF5QnVmZmVyJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclQXJyYXlQcm90b19lbnRyaWVzJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2VudHJpZXMnXSxcblx0JyVBcnJheVByb3RvX2ZvckVhY2glJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZm9yRWFjaCddLFxuXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXG5cdCclQXJyYXlQcm90b192YWx1ZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAndmFsdWVzJ10sXG5cdCclQXN5bmNGdW5jdGlvblByb3RvdHlwZSUnOiBbJ0FzeW5jRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxuXHQnJUFzeW5jR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnQXN5bmNHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnLCAncHJvdG90eXBlJ10sXG5cdCclQm9vbGVhblByb3RvdHlwZSUnOiBbJ0Jvb2xlYW4nLCAncHJvdG90eXBlJ10sXG5cdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcblx0JyVEYXRlUHJvdG90eXBlJSc6IFsnRGF0ZScsICdwcm90b3R5cGUnXSxcblx0JyVFcnJvclByb3RvdHlwZSUnOiBbJ0Vycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVGbG9hdDMyQXJyYXlQcm90b3R5cGUlJzogWydGbG9hdDMyQXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclRmxvYXQ2NEFycmF5UHJvdG90eXBlJSc6IFsnRmxvYXQ2NEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXG5cdCclR2VuZXJhdG9yUHJvdG90eXBlJSc6IFsnR2VuZXJhdG9yRnVuY3Rpb24nLCAncHJvdG90eXBlJywgJ3Byb3RvdHlwZSddLFxuXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnSW50MTZBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVJbnQzMkFycmF5UHJvdG90eXBlJSc6IFsnSW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXG5cdCclSlNPTlN0cmluZ2lmeSUnOiBbJ0pTT04nLCAnc3RyaW5naWZ5J10sXG5cdCclTWFwUHJvdG90eXBlJSc6IFsnTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcblx0JyVPYmplY3RQcm90b3R5cGUlJzogWydPYmplY3QnLCAncHJvdG90eXBlJ10sXG5cdCclT2JqUHJvdG9fdG9TdHJpbmclJzogWydPYmplY3QnLCAncHJvdG90eXBlJywgJ3RvU3RyaW5nJ10sXG5cdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxuXHQnJVByb21pc2VQcm90b3R5cGUlJzogWydQcm9taXNlJywgJ3Byb3RvdHlwZSddLFxuXHQnJVByb21pc2VQcm90b190aGVuJSc6IFsnUHJvbWlzZScsICdwcm90b3R5cGUnLCAndGhlbiddLFxuXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcblx0JyVQcm9taXNlX3JlamVjdCUnOiBbJ1Byb21pc2UnLCAncmVqZWN0J10sXG5cdCclUHJvbWlzZV9yZXNvbHZlJSc6IFsnUHJvbWlzZScsICdyZXNvbHZlJ10sXG5cdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXG5cdCclUmVmZXJlbmNlRXJyb3JQcm90b3R5cGUlJzogWydSZWZlcmVuY2VFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVSZWdFeHBQcm90b3R5cGUlJzogWydSZWdFeHAnLCAncHJvdG90eXBlJ10sXG5cdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxuXHQnJVNoYXJlZEFycmF5QnVmZmVyUHJvdG90eXBlJSc6IFsnU2hhcmVkQXJyYXlCdWZmZXInLCAncHJvdG90eXBlJ10sXG5cdCclU3RyaW5nUHJvdG90eXBlJSc6IFsnU3RyaW5nJywgJ3Byb3RvdHlwZSddLFxuXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcblx0JyVTeW50YXhFcnJvclByb3RvdHlwZSUnOiBbJ1N5bnRheEVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVkQXJyYXlQcm90b3R5cGUlJzogWydUeXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OEFycmF5UHJvdG90eXBlJSc6IFsnVWludDhBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ3Byb3RvdHlwZSddLFxuXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXG5cdCclVWludDMyQXJyYXlQcm90b3R5cGUlJzogWydVaW50MzJBcnJheScsICdwcm90b3R5cGUnXSxcblx0JyVVUklFcnJvclByb3RvdHlwZSUnOiBbJ1VSSUVycm9yJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxuXHQnJVdlYWtTZXRQcm90b3R5cGUlJzogWydXZWFrU2V0JywgJ3Byb3RvdHlwZSddXG59O1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJ2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBoYXNPd24gPSByZXF1aXJlKCdoYXMnKTtcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xudmFyICRzcGxpY2VBcHBseSA9IGJpbmQuY2FsbChGdW5jdGlvbi5hcHBseSwgQXJyYXkucHJvdG90eXBlLnNwbGljZSk7XG52YXIgJHJlcGxhY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XG52YXIgJGV4ZWMgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgUmVnRXhwLnByb3RvdHlwZS5leGVjKTtcblxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xudmFyIHJlUHJvcE5hbWUgPSAvW14lLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCUkKSkvZztcbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG52YXIgc3RyaW5nVG9QYXRoID0gZnVuY3Rpb24gc3RyaW5nVG9QYXRoKHN0cmluZykge1xuXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcblx0dmFyIGxhc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAtMSk7XG5cdGlmIChmaXJzdCA9PT0gJyUnICYmIGxhc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgY2xvc2luZyBgJWAnKTtcblx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xuXHRcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcblx0fVxuXHR2YXIgcmVzdWx0ID0gW107XG5cdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcblx0XHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcblx0fSk7XG5cdHJldHVybiByZXN1bHQ7XG59O1xuLyogZW5kIGFkYXB0YXRpb24gKi9cblxudmFyIGdldEJhc2VJbnRyaW5zaWMgPSBmdW5jdGlvbiBnZXRCYXNlSW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHR2YXIgaW50cmluc2ljTmFtZSA9IG5hbWU7XG5cdHZhciBhbGlhcztcblx0aWYgKGhhc093bihMRUdBQ1lfQUxJQVNFUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHRhbGlhcyA9IExFR0FDWV9BTElBU0VTW2ludHJpbnNpY05hbWVdO1xuXHRcdGludHJpbnNpY05hbWUgPSAnJScgKyBhbGlhc1swXSArICclJztcblx0fVxuXG5cdGlmIChoYXNPd24oSU5UUklOU0lDUywgaW50cmluc2ljTmFtZSkpIHtcblx0XHR2YXIgdmFsdWUgPSBJTlRSSU5TSUNTW2ludHJpbnNpY05hbWVdO1xuXHRcdGlmICh2YWx1ZSA9PT0gbmVlZHNFdmFsKSB7XG5cdFx0XHR2YWx1ZSA9IGRvRXZhbChpbnRyaW5zaWNOYW1lKTtcblx0XHR9XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgJiYgIWFsbG93TWlzc2luZykge1xuXHRcdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFsaWFzOiBhbGlhcyxcblx0XHRcdG5hbWU6IGludHJpbnNpY05hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9O1xuXHR9XG5cblx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xuXHRpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnIHx8IG5hbWUubGVuZ3RoID09PSAwKSB7XG5cdFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nJyk7XG5cdH1cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xuXHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcImFsbG93TWlzc2luZ1wiIGFyZ3VtZW50IG11c3QgYmUgYSBib29sZWFuJyk7XG5cdH1cblxuXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcblx0XHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XG5cdH1cblx0dmFyIHBhcnRzID0gc3RyaW5nVG9QYXRoKG5hbWUpO1xuXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcblxuXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcblx0dmFyIGludHJpbnNpY1JlYWxOYW1lID0gaW50cmluc2ljLm5hbWU7XG5cdHZhciB2YWx1ZSA9IGludHJpbnNpYy52YWx1ZTtcblx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xuXG5cdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcblx0aWYgKGFsaWFzKSB7XG5cdFx0aW50cmluc2ljQmFzZU5hbWUgPSBhbGlhc1swXTtcblx0XHQkc3BsaWNlQXBwbHkocGFydHMsICRjb25jYXQoWzAsIDFdLCBhbGlhcykpO1xuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDEsIGlzT3duID0gdHJ1ZTsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAxKSB7XG5cdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXTtcblx0XHR2YXIgZmlyc3QgPSAkc3RyU2xpY2UocGFydCwgMCwgMSk7XG5cdFx0dmFyIGxhc3QgPSAkc3RyU2xpY2UocGFydCwgLTEpO1xuXHRcdGlmIChcblx0XHRcdChcblx0XHRcdFx0KGZpcnN0ID09PSAnXCInIHx8IGZpcnN0ID09PSBcIidcIiB8fCBmaXJzdCA9PT0gJ2AnKVxuXHRcdFx0XHR8fCAobGFzdCA9PT0gJ1wiJyB8fCBsYXN0ID09PSBcIidcIiB8fCBsYXN0ID09PSAnYCcpXG5cdFx0XHQpXG5cdFx0XHQmJiBmaXJzdCAhPT0gbGFzdFxuXHRcdCkge1xuXHRcdFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xuXHRcdH1cblx0XHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcblx0XHRcdHNraXBGdXJ0aGVyQ2FjaGluZyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aW50cmluc2ljQmFzZU5hbWUgKz0gJy4nICsgcGFydDtcblx0XHRpbnRyaW5zaWNSZWFsTmFtZSA9ICclJyArIGludHJpbnNpY0Jhc2VOYW1lICsgJyUnO1xuXG5cdFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcblx0XHRcdHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNSZWFsTmFtZV07XG5cdFx0fSBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoIShwYXJ0IGluIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAoIWFsbG93TWlzc2luZykge1xuXHRcdFx0XHRcdHRocm93IG5ldyAkVHlwZUVycm9yKCdiYXNlIGludHJpbnNpYyBmb3IgJyArIG5hbWUgKyAnIGV4aXN0cywgYnV0IHRoZSBwcm9wZXJ0eSBpcyBub3QgYXZhaWxhYmxlLicpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2b2lkIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdGlmICgkZ09QRCAmJiAoaSArIDEpID49IHBhcnRzLmxlbmd0aCkge1xuXHRcdFx0XHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcblx0XHRcdFx0aXNPd24gPSAhIWRlc2M7XG5cblx0XHRcdFx0Ly8gQnkgY29udmVudGlvbiwgd2hlbiBhIGRhdGEgcHJvcGVydHkgaXMgY29udmVydGVkIHRvIGFuIGFjY2Vzc29yXG5cdFx0XHRcdC8vIHByb3BlcnR5IHRvIGVtdWxhdGUgYSBkYXRhIHByb3BlcnR5IHRoYXQgZG9lcyBub3Qgc3VmZmVyIGZyb21cblx0XHRcdFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcblx0XHRcdFx0Ly8gYW4gYG9yaWdpbmFsVmFsdWVgIHByb3BlcnR5LiBIZXJlLCB3aGVuIHdlIGRldGVjdCB0aGlzLCB3ZVxuXHRcdFx0XHQvLyB1cGhvbGQgdGhlIGlsbHVzaW9uIGJ5IHByZXRlbmRpbmcgdG8gc2VlIHRoYXQgb3JpZ2luYWwgZGF0YVxuXHRcdFx0XHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXG5cdFx0XHRcdC8vIGl0c2VsZi5cblx0XHRcdFx0aWYgKGlzT3duICYmICdnZXQnIGluIGRlc2MgJiYgISgnb3JpZ2luYWxWYWx1ZScgaW4gZGVzYy5nZXQpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBkZXNjLmdldDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpc093biA9IGhhc093bih2YWx1ZSwgcGFydCk7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWVbcGFydF07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChpc093biAmJiAhc2tpcEZ1cnRoZXJDYWNoaW5nKSB7XG5cdFx0XHRcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHJldHVybiB2YWx1ZTtcbn07XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG52YXIgR2V0UGFyYW1zID0gZnVuY3Rpb24gKGZ1bmMpIHtcblx0J3VzZSBzdHJpY3QnO1xuXG5cdGlmICh0eXBlb2YgZnVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdHJldHVybiBbXTtcblx0fVxuXG5cdHZhciBwYXR0ZXJuQ29tbWVudHMgPSAvKChcXC9cXC8uKiQpfChcXC9cXCpbXFxzXFxTXSo/XFwqXFwvKSkvbWc7XG5cdHZhciBwYXR0ZXJuQXJndW1lbnRzID0gLyhbXlxccyxdKykvZztcblxuXHR2YXIgZnVuY1N0cmluZyA9IGZ1bmNcblx0XHQudG9TdHJpbmcoKVxuXHRcdC5yZXBsYWNlKHBhdHRlcm5Db21tZW50cywgJycpO1xuXG5cdHZhciByZXN1bHQgPSBmdW5jU3RyaW5nXG5cdFx0LnNsaWNlKFxuXHRcdFx0ZnVuY1N0cmluZy5pbmRleE9mKCcoJykgKyAxLFxuXHRcdFx0ZnVuY1N0cmluZy5pbmRleE9mKCcpJylcblx0XHQpXG5cdFx0Lm1hdGNoKHBhdHRlcm5Bcmd1bWVudHMpO1xuXG5cdGlmIChyZXN1bHQgPT09IG51bGwpIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBHZXRQYXJhbXM7XG59XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuXHR3aW5kb3cuR2V0UGFyYW1zID0gR2V0UGFyYW1zO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpZGVudGl0eTtcblxuLyoqXG4gKiBTZXQgYSBtYXQ0IHRvIHRoZSBpZGVudGl0eSBtYXRyaXhcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJ0O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb2tBdDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmU7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGU7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdDQgYnkgdGhlIGdpdmVuIGFuZ2xlXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZShvdXQsIGEsIHJhZCwgYXhpcykge1xuICAgIHZhciB4ID0gYXhpc1swXSwgeSA9IGF4aXNbMV0sIHogPSBheGlzWzJdLFxuICAgICAgICBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KSxcbiAgICAgICAgcywgYywgdCxcbiAgICAgICAgYTAwLCBhMDEsIGEwMiwgYTAzLFxuICAgICAgICBhMTAsIGExMSwgYTEyLCBhMTMsXG4gICAgICAgIGEyMCwgYTIxLCBhMjIsIGEyMyxcbiAgICAgICAgYjAwLCBiMDEsIGIwMixcbiAgICAgICAgYjEwLCBiMTEsIGIxMixcbiAgICAgICAgYjIwLCBiMjEsIGIyMjtcblxuICAgIGlmIChNYXRoLmFicyhsZW4pIDwgMC4wMDAwMDEpIHsgcmV0dXJuIG51bGw7IH1cbiAgICBcbiAgICBsZW4gPSAxIC8gbGVuO1xuICAgIHggKj0gbGVuO1xuICAgIHkgKj0gbGVuO1xuICAgIHogKj0gbGVuO1xuXG4gICAgcyA9IE1hdGguc2luKHJhZCk7XG4gICAgYyA9IE1hdGguY29zKHJhZCk7XG4gICAgdCA9IDEgLSBjO1xuXG4gICAgYTAwID0gYVswXTsgYTAxID0gYVsxXTsgYTAyID0gYVsyXTsgYTAzID0gYVszXTtcbiAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgIC8vIENvbnN0cnVjdCB0aGUgZWxlbWVudHMgb2YgdGhlIHJvdGF0aW9uIG1hdHJpeFxuICAgIGIwMCA9IHggKiB4ICogdCArIGM7IGIwMSA9IHkgKiB4ICogdCArIHogKiBzOyBiMDIgPSB6ICogeCAqIHQgLSB5ICogcztcbiAgICBiMTAgPSB4ICogeSAqIHQgLSB6ICogczsgYjExID0geSAqIHkgKiB0ICsgYzsgYjEyID0geiAqIHkgKiB0ICsgeCAqIHM7XG4gICAgYjIwID0geCAqIHogKiB0ICsgeSAqIHM7IGIyMSA9IHkgKiB6ICogdCAtIHggKiBzOyBiMjIgPSB6ICogeiAqIHQgKyBjO1xuXG4gICAgLy8gUGVyZm9ybSByb3RhdGlvbi1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBiMDAgKyBhMTAgKiBiMDEgKyBhMjAgKiBiMDI7XG4gICAgb3V0WzFdID0gYTAxICogYjAwICsgYTExICogYjAxICsgYTIxICogYjAyO1xuICAgIG91dFsyXSA9IGEwMiAqIGIwMCArIGExMiAqIGIwMSArIGEyMiAqIGIwMjtcbiAgICBvdXRbM10gPSBhMDMgKiBiMDAgKyBhMTMgKiBiMDEgKyBhMjMgKiBiMDI7XG4gICAgb3V0WzRdID0gYTAwICogYjEwICsgYTEwICogYjExICsgYTIwICogYjEyO1xuICAgIG91dFs1XSA9IGEwMSAqIGIxMCArIGExMSAqIGIxMSArIGEyMSAqIGIxMjtcbiAgICBvdXRbNl0gPSBhMDIgKiBiMTAgKyBhMTIgKiBiMTEgKyBhMjIgKiBiMTI7XG4gICAgb3V0WzddID0gYTAzICogYjEwICsgYTEzICogYjExICsgYTIzICogYjEyO1xuICAgIG91dFs4XSA9IGEwMCAqIGIyMCArIGExMCAqIGIyMSArIGEyMCAqIGIyMjtcbiAgICBvdXRbOV0gPSBhMDEgKiBiMjAgKyBhMTEgKiBiMjEgKyBhMjEgKiBiMjI7XG4gICAgb3V0WzEwXSA9IGEwMiAqIGIyMCArIGExMiAqIGIyMSArIGEyMiAqIGIyMjtcbiAgICBvdXRbMTFdID0gYTAzICogYjIwICsgYTEzICogYjIxICsgYTIzICogYjIyO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV1cbiAgICB3ID0gdyB8fCAxLjBcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gd1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3XG4gICAgcmV0dXJuIG91dFxufSIsIi8vIEBmbG93XG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXkgPSAnX19nbG9iYWxfdW5pcXVlX2lkX18nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gZ2xvYmFsW2tleV0gPSAoZ2xvYmFsW2tleV0gfHwgMCkgKyAxO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEdldEludHJpbnNpYyA9IHJlcXVpcmUoJ2dldC1pbnRyaW5zaWMnKTtcblxudmFyICRkZWZpbmVQcm9wZXJ0eSA9IEdldEludHJpbnNpYygnJU9iamVjdC5kZWZpbmVQcm9wZXJ0eSUnLCB0cnVlKTtcblxudmFyIGhhc1Byb3BlcnR5RGVzY3JpcHRvcnMgPSBmdW5jdGlvbiBoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkge1xuXHRpZiAoJGRlZmluZVByb3BlcnR5KSB7XG5cdFx0dHJ5IHtcblx0XHRcdCRkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7IHZhbHVlOiAxIH0pO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuaGFzUHJvcGVydHlEZXNjcmlwdG9ycy5oYXNBcnJheUxlbmd0aERlZmluZUJ1ZyA9IGZ1bmN0aW9uIGhhc0FycmF5TGVuZ3RoRGVmaW5lQnVnKCkge1xuXHQvLyBub2RlIHYwLjYgaGFzIGEgYnVnIHdoZXJlIGFycmF5IGxlbmd0aHMgY2FuIGJlIFNldCBidXQgbm90IERlZmluZWRcblx0aWYgKCFoYXNQcm9wZXJ0eURlc2NyaXB0b3JzKCkpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXHR0cnkge1xuXHRcdHJldHVybiAkZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHZhbHVlOiAxIH0pLmxlbmd0aCAhPT0gMTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdC8vIEluIEZpcmVmb3ggNC0yMiwgZGVmaW5pbmcgbGVuZ3RoIG9uIGFuIGFycmF5IHRocm93cyBhbiBleGNlcHRpb24uXG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUHJvcGVydHlEZXNjcmlwdG9ycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XG52YXIgaGFzU3ltYm9sU2hhbSA9IHJlcXVpcmUoJy4vc2hhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNOYXRpdmVTeW1ib2xzKCkge1xuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2wgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIG9yaWdTeW1ib2woJ2ZvbycpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKHR5cGVvZiBTeW1ib2woJ2JhcicpICE9PSAnc3ltYm9sJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRyZXR1cm4gaGFzU3ltYm9sU2hhbSgpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc1N5bWJvbHMoKSB7XG5cdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxuXHRpZiAodHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHsgcmV0dXJuIHRydWU7IH1cblxuXHR2YXIgb2JqID0ge307XG5cdHZhciBzeW0gPSBTeW1ib2woJ3Rlc3QnKTtcblx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xuXHRpZiAodHlwZW9mIHN5bSA9PT0gJ3N0cmluZycpIHsgcmV0dXJuIGZhbHNlOyB9XG5cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW0pICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzeW1PYmopICE9PSAnW29iamVjdCBTeW1ib2xdJykgeyByZXR1cm4gZmFsc2U7IH1cblxuXHQvLyB0ZW1wIGRpc2FibGVkIHBlciBodHRwczovL2dpdGh1Yi5jb20vbGpoYXJiL29iamVjdC5hc3NpZ24vaXNzdWVzLzE3XG5cdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XG5cdC8vIHRlbXAgZGlzYWJsZWQgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9XZWJSZWZsZWN0aW9uL2dldC1vd24tcHJvcGVydHktc3ltYm9scy9pc3N1ZXMvNFxuXHQvLyBpZiAoIShzeW1PYmogaW5zdGFuY2VvZiBTeW1ib2wpKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdC8vIGlmICh0eXBlb2YgU3ltYm9sLnByb3RvdHlwZS50b1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykgeyByZXR1cm4gZmFsc2U7IH1cblx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHR2YXIgc3ltVmFsID0gNDI7XG5cdG9ialtzeW1dID0gc3ltVmFsO1xuXHRmb3IgKHN5bSBpbiBvYmopIHsgcmV0dXJuIGZhbHNlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLXVucmVhY2hhYmxlLWxvb3Bcblx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xuXHRpZiAoc3ltcy5sZW5ndGggIT09IDEgfHwgc3ltc1swXSAhPT0gc3ltKSB7IHJldHVybiBmYWxzZTsgfVxuXG5cdGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwgc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cblxuXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPT09ICdmdW5jdGlvbicpIHtcblx0XHR2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBzeW0pO1xuXHRcdGlmIChkZXNjcmlwdG9yLnZhbHVlICE9PSBzeW1WYWwgfHwgZGVzY3JpcHRvci5lbnVtZXJhYmxlICE9PSB0cnVlKSB7IHJldHVybiBmYWxzZTsgfVxuXHR9XG5cblx0cmV0dXJuIHRydWU7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzU3ltYm9scyA9IHJlcXVpcmUoJ2hhcy1zeW1ib2xzL3NoYW1zJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFzVG9TdHJpbmdUYWdTaGFtcygpIHtcblx0cmV0dXJuIGhhc1N5bWJvbHMoKSAmJiAhIVN5bWJvbC50b1N0cmluZ1RhZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnZnVuY3Rpb24tYmluZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5KTtcbiIsInZhciBub0Nhc2UgPSByZXF1aXJlKCduby1jYXNlJylcbnZhciB1cHBlckNhc2UgPSByZXF1aXJlKCd1cHBlci1jYXNlJylcblxuLyoqXG4gKiBIZWFkZXIgY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtsb2NhbGVdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5vQ2FzZSh2YWx1ZSwgbG9jYWxlLCAnLScpLnJlcGxhY2UoL14ufC0uL2csIGZ1bmN0aW9uIChtKSB7XG4gICAgcmV0dXJuIHVwcGVyQ2FzZShtLCBsb2NhbGUpXG4gIH0pXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xudmFyIFJFQUNUX1NUQVRJQ1MgPSB7XG4gIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICBjb250ZXh0VHlwZTogdHJ1ZSxcbiAgY29udGV4dFR5cGVzOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBnZXREZWZhdWx0UHJvcHM6IHRydWUsXG4gIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjogdHJ1ZSxcbiAgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzOiB0cnVlLFxuICBtaXhpbnM6IHRydWUsXG4gIHByb3BUeXBlczogdHJ1ZSxcbiAgdHlwZTogdHJ1ZVxufTtcbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICBuYW1lOiB0cnVlLFxuICBsZW5ndGg6IHRydWUsXG4gIHByb3RvdHlwZTogdHJ1ZSxcbiAgY2FsbGVyOiB0cnVlLFxuICBjYWxsZWU6IHRydWUsXG4gIGFyZ3VtZW50czogdHJ1ZSxcbiAgYXJpdHk6IHRydWVcbn07XG52YXIgRk9SV0FSRF9SRUZfU1RBVElDUyA9IHtcbiAgJyQkdHlwZW9mJzogdHJ1ZSxcbiAgcmVuZGVyOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWVcbn07XG52YXIgTUVNT19TVEFUSUNTID0ge1xuICAnJCR0eXBlb2YnOiB0cnVlLFxuICBjb21wYXJlOiB0cnVlLFxuICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gIGRpc3BsYXlOYW1lOiB0cnVlLFxuICBwcm9wVHlwZXM6IHRydWUsXG4gIHR5cGU6IHRydWVcbn07XG52YXIgVFlQRV9TVEFUSUNTID0ge307XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5Gb3J3YXJkUmVmXSA9IEZPUldBUkRfUkVGX1NUQVRJQ1M7XG5UWVBFX1NUQVRJQ1NbcmVhY3RJcy5NZW1vXSA9IE1FTU9fU1RBVElDUztcblxuZnVuY3Rpb24gZ2V0U3RhdGljcyhjb21wb25lbnQpIHtcbiAgLy8gUmVhY3QgdjE2LjExIGFuZCBiZWxvd1xuICBpZiAocmVhY3RJcy5pc01lbW8oY29tcG9uZW50KSkge1xuICAgIHJldHVybiBNRU1PX1NUQVRJQ1M7XG4gIH0gLy8gUmVhY3QgdjE2LjEyIGFuZCBhYm92ZVxuXG5cbiAgcmV0dXJuIFRZUEVfU1RBVElDU1tjb21wb25lbnRbJyQkdHlwZW9mJ11dIHx8IFJFQUNUX1NUQVRJQ1M7XG59XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIG9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgYmxhY2tsaXN0KSB7XG4gIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykge1xuICAgIC8vIGRvbid0IGhvaXN0IG92ZXIgc3RyaW5nIChodG1sKSBjb21wb25lbnRzXG4gICAgaWYgKG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgdmFyIGluaGVyaXRlZENvbXBvbmVudCA9IGdldFByb3RvdHlwZU9mKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgIGlmIChpbmhlcml0ZWRDb21wb25lbnQgJiYgaW5oZXJpdGVkQ29tcG9uZW50ICE9PSBvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBpbmhlcml0ZWRDb21wb25lbnQsIGJsYWNrbGlzdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBrZXlzID0ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZUNvbXBvbmVudCkpO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRTdGF0aWNzID0gZ2V0U3RhdGljcyh0YXJnZXRDb21wb25lbnQpO1xuICAgIHZhciBzb3VyY2VTdGF0aWNzID0gZ2V0U3RhdGljcyhzb3VyY2VDb21wb25lbnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFLTk9XTl9TVEFUSUNTW2tleV0gJiYgIShibGFja2xpc3QgJiYgYmxhY2tsaXN0W2tleV0pICYmICEoc291cmNlU3RhdGljcyAmJiBzb3VyY2VTdGF0aWNzW2tleV0pICYmICEodGFyZ2V0U3RhdGljcyAmJiB0YXJnZXRTdGF0aWNzW2tleV0pKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZUNvbXBvbmVudCwga2V5KTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEF2b2lkIGZhaWx1cmVzIGZyb20gcmVhZC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiIsIid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyLCBwcmVmZXItdGVtcGxhdGUgKi9cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gL1tBLVpdL2c7XG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xudmFyIGNhY2hlID0ge307XG5cbmZ1bmN0aW9uIHRvSHlwaGVuTG93ZXIobWF0Y2gpIHtcbiAgcmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGNhY2hlW25hbWVdXG4gIH1cblxuICB2YXIgaE5hbWUgPSBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgdG9IeXBoZW5Mb3dlcik7XG4gIHJldHVybiAoY2FjaGVbbmFtZV0gPSBtc1BhdHRlcm4udGVzdChoTmFtZSkgPyAnLScgKyBoTmFtZSA6IGhOYW1lKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgK1xuICAgICAgICAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJnc1thcmdJbmRleCsrXTsgfSlcbiAgICAgICk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbnZhcmlhbnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBoYXNUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJ2hhcy10b3N0cmluZ3RhZy9zaGFtcycpKCk7XG52YXIgY2FsbEJvdW5kID0gcmVxdWlyZSgnY2FsbC1iaW5kL2NhbGxCb3VuZCcpO1xuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG5cbnZhciBpc1N0YW5kYXJkQXJndW1lbnRzID0gZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcblx0aWYgKGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnIGluIHZhbHVlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdHJldHVybiAkdG9TdHJpbmcodmFsdWUpID09PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbnZhciBpc0xlZ2FjeUFyZ3VtZW50cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdGlmIChpc1N0YW5kYXJkQXJndW1lbnRzKHZhbHVlKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cdHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcblx0XHR0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJyAmJlxuXHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0JHRvU3RyaW5nKHZhbHVlKSAhPT0gJ1tvYmplY3QgQXJyYXldJyAmJlxuXHRcdCR0b1N0cmluZyh2YWx1ZS5jYWxsZWUpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudmFyIHN1cHBvcnRzU3RhbmRhcmRBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gaXNTdGFuZGFyZEFyZ3VtZW50cyhhcmd1bWVudHMpO1xufSgpKTtcblxuaXNTdGFuZGFyZEFyZ3VtZW50cy5pc0xlZ2FjeUFyZ3VtZW50cyA9IGlzTGVnYWN5QXJndW1lbnRzOyAvLyBmb3IgdGVzdHNcblxubW9kdWxlLmV4cG9ydHMgPSBzdXBwb3J0c1N0YW5kYXJkQXJndW1lbnRzID8gaXNTdGFuZGFyZEFyZ3VtZW50cyA6IGlzTGVnYWN5QXJndW1lbnRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0RGF5ID0gRGF0ZS5wcm90b3R5cGUuZ2V0RGF5O1xudmFyIHRyeURhdGVPYmplY3QgPSBmdW5jdGlvbiB0cnlEYXRlR2V0RGF5Q2FsbCh2YWx1ZSkge1xuXHR0cnkge1xuXHRcdGdldERheS5jYWxsKHZhbHVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcblxudmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBkYXRlQ2xhc3MgPSAnW29iamVjdCBEYXRlXSc7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRGF0ZU9iamVjdCh2YWx1ZSkge1xuXHRpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRyZXR1cm4gaGFzVG9TdHJpbmdUYWcgPyB0cnlEYXRlT2JqZWN0KHZhbHVlKSA6IHRvU3RyLmNhbGwodmFsdWUpID09PSBkYXRlQ2xhc3M7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnaXMtb2JqZWN0JylcbnZhciBpc1dpbmRvdyA9IHJlcXVpcmUoJ2lzLXdpbmRvdycpXG5cbmZ1bmN0aW9uIGlzTm9kZSAodmFsKSB7XG4gIGlmICghaXNPYmplY3QodmFsKSB8fCAhaXNXaW5kb3cod2luZG93KSB8fCB0eXBlb2Ygd2luZG93Lk5vZGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHJldHVybiB0eXBlb2YgdmFsLm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiB2YWwubm9kZU5hbWUgPT09ICdzdHJpbmcnXG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBpc0Jyb3dzZXIgPSBleHBvcnRzLmlzQnJvd3NlciA9ICh0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2Yod2luZG93KSkgPT09IFwib2JqZWN0XCIgJiYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09ICdvYmplY3QnICYmIGRvY3VtZW50Lm5vZGVUeXBlID09PSA5O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBpc0Jyb3dzZXI7IiwidmFyIGxvd2VyQ2FzZSA9IHJlcXVpcmUoJ2xvd2VyLWNhc2UnKVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3RyaW5nIGlzIGxvd2VyIGNhc2UuXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSAgc3RyaW5nXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICBbbG9jYWxlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nLCBsb2NhbGUpIHtcbiAgcmV0dXJuIGxvd2VyQ2FzZShzdHJpbmcsIGxvY2FsZSkgPT09IHN0cmluZ1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuXHRyZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjYWxsQm91bmQgPSByZXF1aXJlKCdjYWxsLWJpbmQvY2FsbEJvdW5kJyk7XG52YXIgaGFzVG9TdHJpbmdUYWcgPSByZXF1aXJlKCdoYXMtdG9zdHJpbmd0YWcvc2hhbXMnKSgpO1xudmFyIGhhcztcbnZhciAkZXhlYztcbnZhciBpc1JlZ2V4TWFya2VyO1xudmFyIGJhZFN0cmluZ2lmaWVyO1xuXG5pZiAoaGFzVG9TdHJpbmdUYWcpIHtcblx0aGFzID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5Jyk7XG5cdCRleGVjID0gY2FsbEJvdW5kKCdSZWdFeHAucHJvdG90eXBlLmV4ZWMnKTtcblx0aXNSZWdleE1hcmtlciA9IHt9O1xuXG5cdHZhciB0aHJvd1JlZ2V4TWFya2VyID0gZnVuY3Rpb24gKCkge1xuXHRcdHRocm93IGlzUmVnZXhNYXJrZXI7XG5cdH07XG5cdGJhZFN0cmluZ2lmaWVyID0ge1xuXHRcdHRvU3RyaW5nOiB0aHJvd1JlZ2V4TWFya2VyLFxuXHRcdHZhbHVlT2Y6IHRocm93UmVnZXhNYXJrZXJcblx0fTtcblxuXHRpZiAodHlwZW9mIFN5bWJvbC50b1ByaW1pdGl2ZSA9PT0gJ3N5bWJvbCcpIHtcblx0XHRiYWRTdHJpbmdpZmllcltTeW1ib2wudG9QcmltaXRpdmVdID0gdGhyb3dSZWdleE1hcmtlcjtcblx0fVxufVxuXG52YXIgJHRvU3RyaW5nID0gY2FsbEJvdW5kKCdPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nJyk7XG52YXIgZ09QRCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgcmVnZXhDbGFzcyA9ICdbb2JqZWN0IFJlZ0V4cF0nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1RvU3RyaW5nVGFnXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuXHQ/IGZ1bmN0aW9uIGlzUmVnZXgodmFsdWUpIHtcblx0XHRpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgZGVzY3JpcHRvciA9IGdPUEQodmFsdWUsICdsYXN0SW5kZXgnKTtcblx0XHR2YXIgaGFzTGFzdEluZGV4RGF0YVByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBoYXMoZGVzY3JpcHRvciwgJ3ZhbHVlJyk7XG5cdFx0aWYgKCFoYXNMYXN0SW5kZXhEYXRhUHJvcGVydHkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0JGV4ZWModmFsdWUsIGJhZFN0cmluZ2lmaWVyKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZSA9PT0gaXNSZWdleE1hcmtlcjtcblx0XHR9XG5cdH1cblx0OiBmdW5jdGlvbiBpc1JlZ2V4KHZhbHVlKSB7XG5cdFx0Ly8gSW4gb2xkZXIgYnJvd3NlcnMsIHR5cGVvZiByZWdleCBpbmNvcnJlY3RseSByZXR1cm5zICdmdW5jdGlvbidcblx0XHRpZiAoIXZhbHVlIHx8ICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJykpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gJHRvU3RyaW5nKHZhbHVlKSA9PT0gcmVnZXhDbGFzcztcblx0fTtcbiIsInZhciB1cHBlckNhc2UgPSByZXF1aXJlKCd1cHBlci1jYXNlJylcblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0cmluZyBpcyB1cHBlciBjYXNlLlxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gIHN0cmluZ1xuICogQHBhcmFtICB7U3RyaW5nfSAgW2xvY2FsZV1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cmluZywgbG9jYWxlKSB7XG4gIHJldHVybiB1cHBlckNhc2Uoc3RyaW5nLCBsb2NhbGUpID09PSBzdHJpbmdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG5cbiAgaWYgKG9iaiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIG8gPSBPYmplY3Qob2JqKTtcblxuICByZXR1cm4gbyA9PT0gby53aW5kb3c7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYicpO1xuIiwidmFyIHBhdGhHZXR0ZXIgPSByZXF1aXJlKCcuL3BhdGgtZ2V0dGVyJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbnZhciBXTWFwID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnP1xuICBXZWFrTWFwOlxuICBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICB2YWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgZ2V0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGtleXNbaV0gPT09IGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9kb3VnbGFzY3JvY2tmb3JkL0pTT04tanMvYmxvYi9tYXN0ZXIvY3ljbGUuanNcblxuZXhwb3J0cy5kZWN5Y2xlID0gZnVuY3Rpb24gZGVjeWNsZShvYmplY3QsIG9wdGlvbnMsIHJlcGxhY2VyKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgbWFwID0gbmV3IFdNYXAoKVxuXG4gIHZhciBub0NpcmN1bGFyT3B0aW9uID0gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAnY2lyY3VsYXInKTtcbiAgdmFyIHdpdGhSZWZzID0gb3B0aW9ucy5yZWZzICE9PSBmYWxzZTtcblxuICByZXR1cm4gKGZ1bmN0aW9uIGRlcmV6KF92YWx1ZSwgcGF0aCwga2V5KSB7XG5cbiAgICAvLyBUaGUgZGVyZXogcmVjdXJzZXMgdGhyb3VnaCB0aGUgb2JqZWN0LCBwcm9kdWNpbmcgdGhlIGRlZXAgY29weS5cblxuICAgIHZhciBpLCAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlclxuICAgICAgbmFtZSwgICAgICAgLy8gUHJvcGVydHkgbmFtZVxuICAgICAgbnU7ICAgICAgICAgLy8gVGhlIG5ldyBvYmplY3Qgb3IgYXJyYXlcblxuICAgIC8vIHR5cGVvZiBudWxsID09PSAnb2JqZWN0Jywgc28gZ28gb24gaWYgdGhpcyB2YWx1ZSBpcyByZWFsbHkgYW4gb2JqZWN0IGJ1dCBub3RcbiAgICAvLyBvbmUgb2YgdGhlIHdlaXJkIGJ1aWx0aW4gb2JqZWN0cy5cblxuICAgIHZhciB2YWx1ZSA9IHR5cGVvZiByZXBsYWNlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlcGxhY2VyKGtleSB8fCAnJywgX3ZhbHVlKSA6IF92YWx1ZTtcblxuICAgIGlmIChvcHRpb25zLmRhdGUgJiYgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4geyRqc2FuOiAnZCcgKyB2YWx1ZS5nZXRUaW1lKCl9O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZWdleCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHskanNhbjogJ3InICsgdXRpbHMuZ2V0UmVnZXhGbGFncyh2YWx1ZSkgKyAnLCcgKyB2YWx1ZS5zb3VyY2V9O1xuICAgIH1cbiAgICBpZiAob3B0aW9uc1snZnVuY3Rpb24nXSAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICdmJyArIHV0aWxzLnN0cmluZ2lmeUZ1bmN0aW9uKHZhbHVlLCBvcHRpb25zWydmdW5jdGlvbiddKX1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ25hbiddICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm4geyRqc2FuOiAnbid9XG4gICAgfVxuICAgIGlmIChvcHRpb25zWydpbmZpbml0eSddKSB7XG4gICAgICBpZiAoTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZID09PSB2YWx1ZSkgcmV0dXJuIHskanNhbjogJ2knfVxuICAgICAgaWYgKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA9PT0gdmFsdWUpIHJldHVybiB7JGpzYW46ICd5J31cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ3VuZGVmaW5lZCddICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB7JGpzYW46ICd1J31cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ2Vycm9yJ10gJiYgdmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHskanNhbjogJ2UnICsgdmFsdWUubWVzc2FnZX1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnNbJ3N5bWJvbCddICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHZhciBzeW1ib2xLZXkgPSBTeW1ib2wua2V5Rm9yKHZhbHVlKVxuICAgICAgaWYgKHN5bWJvbEtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7JGpzYW46ICdnJyArIHN5bWJvbEtleX1cbiAgICAgIH1cblxuICAgICAgLy8gJ1N5bWJvbChmb28pJy5zbGljZSg3LCAtMSkgPT09ICdmb28nXG4gICAgICByZXR1cm4geyRqc2FuOiAncycgKyB2YWx1ZS50b1N0cmluZygpLnNsaWNlKDcsIC0xKX1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1snbWFwJ10gJiYgdHlwZW9mIE1hcCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCAmJiB0eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHskanNhbjogJ20nICsgSlNPTi5zdHJpbmdpZnkoZGVjeWNsZShBcnJheS5mcm9tKHZhbHVlKSwgb3B0aW9ucywgcmVwbGFjZXIpKX1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9uc1snc2V0J10gJiYgdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCAmJiB0eXBlb2YgQXJyYXkuZnJvbSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHskanNhbjogJ2wnICsgSlNPTi5zdHJpbmdpZnkoZGVjeWNsZShBcnJheS5mcm9tKHZhbHVlKSwgb3B0aW9ucywgcmVwbGFjZXIpKX1cbiAgICB9XG5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oa2V5KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHZhciBrZXlTdHJpbmcgPSAoa2V5IHx8ICckJyk7XG4gICAgICAgIHJldHVybiBcInRvSlNPTiBmYWlsZWQgZm9yICdcIiArIChtYXAuZ2V0KHZhbHVlKSB8fCBrZXlTdHJpbmcpICsgXCInXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBCb29sZWFuKSAmJlxuICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpICAgICYmXG4gICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSAgJiZcbiAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApICAmJlxuICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykgICYmXG4gICAgICAhKHR5cGVvZiB2YWx1ZSA9PT0gJ3N5bWJvbCcpICAmJlxuICAgICAgISh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSkge1xuXG4gICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBvYmplY3Qgb3IgYXJyYXksIGxvb2sgdG8gc2VlIGlmIHdlIGhhdmUgYWxyZWFkeVxuICAgICAgICAvLyBlbmNvdW50ZXJlZCBpdC4gSWYgc28sIHJldHVybiBhICRyZWYvcGF0aCBvYmplY3QuXG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBmb3VuZFBhdGggPSBtYXAuZ2V0KHZhbHVlKTtcbiAgICAgICAgaWYgKGZvdW5kUGF0aCkge1xuICAgICAgICAgIGlmIChub0NpcmN1bGFyT3B0aW9uICYmIHdpdGhSZWZzKSB7XG4gICAgICAgICAgICByZXR1cm4geyRqc2FuOiBmb3VuZFBhdGh9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKGZvdW5kUGF0aCkgPT09IDApIHtcbiAgICAgICAgICAgIGlmICghbm9DaXJjdWxhck9wdGlvbikge1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIG9wdGlvbnMuY2lyY3VsYXIgPT09ICdmdW5jdGlvbic/XG4gICAgICAgICAgICAgIG9wdGlvbnMuY2lyY3VsYXIodmFsdWUsIHBhdGgsIGZvdW5kUGF0aCk6XG4gICAgICAgICAgICAgIG9wdGlvbnMuY2lyY3VsYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyRqc2FuOiBmb3VuZFBhdGh9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2l0aFJlZnMpIHJldHVybiB7JGpzYW46IGZvdW5kUGF0aH07XG4gICAgICAgIH1cbiAgICAgICAgbWFwLnNldCh2YWx1ZSwgcGF0aCk7XG4gICAgICB9XG5cblxuICAgICAgLy8gSWYgaXQgaXMgYW4gYXJyYXksIHJlcGxpY2F0ZSB0aGUgYXJyYXkuXG5cbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgIG51ID0gW107XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgIG51W2ldID0gZGVyZXoodmFsdWVbaV0sIHBhdGggKyAnWycgKyBpICsgJ10nLCBpKTtcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIElmIGl0IGlzIGFuIG9iamVjdCwgcmVwbGljYXRlIHRoZSBvYmplY3QuXG5cbiAgICAgICAgbnUgPSB7fTtcbiAgICAgICAgZm9yIChuYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgbmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBuZXh0UGF0aCA9IC9eXFx3KyQvLnRlc3QobmFtZSkgP1xuICAgICAgICAgICAgICAnLicgKyBuYW1lIDpcbiAgICAgICAgICAgICAgJ1snICsgSlNPTi5zdHJpbmdpZnkobmFtZSkgKyAnXSc7XG4gICAgICAgICAgICBudVtuYW1lXSA9IG5hbWUgPT09ICckanNhbicgPyBbZGVyZXoodmFsdWVbbmFtZV0sIHBhdGggKyBuZXh0UGF0aCldIDogZGVyZXoodmFsdWVbbmFtZV0sIHBhdGggKyBuZXh0UGF0aCwgbmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfShvYmplY3QsICckJykpO1xufTtcblxuXG5leHBvcnRzLnJldHJvY3ljbGUgPSBmdW5jdGlvbiByZXRyb2N5Y2xlKCQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG5cbiAgcmV0dXJuIChmdW5jdGlvbiByZXoodmFsdWUpIHtcblxuICAgIC8vIFRoZSByZXogZnVuY3Rpb24gd2Fsa3MgcmVjdXJzaXZlbHkgdGhyb3VnaCB0aGUgb2JqZWN0IGxvb2tpbmcgZm9yICRqc2FuXG4gICAgLy8gcHJvcGVydGllcy4gV2hlbiBpdCBmaW5kcyBvbmUgdGhhdCBoYXMgYSB2YWx1ZSB0aGF0IGlzIGEgcGF0aCwgdGhlbiBpdFxuICAgIC8vIHJlcGxhY2VzIHRoZSAkanNhbiBvYmplY3Qgd2l0aCBhIHJlZmVyZW5jZSB0byB0aGUgdmFsdWUgdGhhdCBpcyBmb3VuZCBieVxuICAgIC8vIHRoZSBwYXRoLlxuXG4gICAgdmFyIGksIGl0ZW0sIG5hbWUsIHBhdGg7XG5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGl0ZW0gPSB2YWx1ZVtpXTtcbiAgICAgICAgICBpZiAoaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlmIChpdGVtLiRqc2FuKSB7XG4gICAgICAgICAgICAgIHZhbHVlW2ldID0gdXRpbHMucmVzdG9yZShpdGVtLiRqc2FuLCAkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJleihpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgIC8vIGJhc2UgY2FzZSBwYXNzZWQgcmF3IG9iamVjdFxuICAgICAgICAgIGlmKHR5cGVvZiB2YWx1ZVtuYW1lXSA9PT0gJ3N0cmluZycgJiYgbmFtZSA9PT0gJyRqc2FuJyl7XG4gICAgICAgICAgICByZXR1cm4gdXRpbHMucmVzdG9yZSh2YWx1ZS4kanNhbiwgJCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gJyRqc2FuJykge1xuICAgICAgICAgICAgICB2YWx1ZVtuYW1lXSA9IHZhbHVlW25hbWVdWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZVtuYW1lXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgaXRlbSA9IHZhbHVlW25hbWVdO1xuICAgICAgICAgICAgICBpZiAoaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS4kanNhbikge1xuICAgICAgICAgICAgICAgICAgdmFsdWVbbmFtZV0gPSB1dGlscy5yZXN0b3JlKGl0ZW0uJGpzYW4sICQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXooaXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSgkKSk7XG59O1xuIiwidmFyIGN5Y2xlID0gcmVxdWlyZSgnLi9jeWNsZScpO1xuXG5leHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBfb3B0aW9ucykge1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgNCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5LmFwcGx5KEpTT04sIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuXG4gIHZhciBvcHRpb25zID0gX29wdGlvbnMgfHwgZmFsc2U7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICdkYXRlJzogb3B0aW9ucyxcbiAgICAgICdmdW5jdGlvbic6IG9wdGlvbnMsXG4gICAgICAncmVnZXgnOiBvcHRpb25zLFxuICAgICAgJ3VuZGVmaW5lZCc6IG9wdGlvbnMsXG4gICAgICAnZXJyb3InOiBvcHRpb25zLFxuICAgICAgJ3N5bWJvbCc6IG9wdGlvbnMsXG4gICAgICAnbWFwJzogb3B0aW9ucyxcbiAgICAgICdzZXQnOiBvcHRpb25zLFxuICAgICAgJ25hbic6IG9wdGlvbnMsXG4gICAgICAnaW5maW5pdHknOiBvcHRpb25zXG4gICAgfVxuICB9XG5cbiAgdmFyIGRlY3ljbGVkID0gY3ljbGUuZGVjeWNsZSh2YWx1ZSwgb3B0aW9ucywgcmVwbGFjZXIpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWN5Y2xlZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVjeWNsZSBhbHJlYWR5IGhhbmRsZXMgd2hlbiByZXBsYWNlciBpcyBhIGZ1bmN0aW9uLlxuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkZWN5Y2xlZCwgQXJyYXkuaXNBcnJheShyZXBsYWNlcikgPyByZXBsYWNlciA6IG51bGwsIHNwYWNlKTtcbiAgfVxufVxuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UodGV4dCwgcmV2aXZlcikge1xuICB2YXIgbmVlZHNSZXRyb2N5Y2xlID0gL1wiXFwkanNhblwiLy50ZXN0KHRleHQpO1xuICB2YXIgcGFyc2VkO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkID0gSlNPTi5wYXJzZSh0ZXh0LCByZXZpdmVyKTtcbiAgfVxuICBpZiAobmVlZHNSZXRyb2N5Y2xlKSB7XG4gICAgcGFyc2VkID0gY3ljbGUucmV0cm9jeWNsZShwYXJzZWQpO1xuICB9XG4gIHJldHVybiBwYXJzZWQ7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHBhdGhHZXR0ZXI7XG5cbmZ1bmN0aW9uIHBhdGhHZXR0ZXIob2JqLCBwYXRoKSB7XG4gIGlmIChwYXRoICE9PSAnJCcpIHtcbiAgICB2YXIgcGF0aHMgPSBnZXRQYXRocyhwYXRoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwYXRoID0gcGF0aHNbaV0udG9TdHJpbmcoKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG4gICAgICBpZiAodHlwZW9mIG9ialtwYXRoXSA9PT0gJ3VuZGVmaW5lZCcgJiYgaSAhPT0gcGF0aHMubGVuZ3RoIC0gMSkgY29udGludWU7XG4gICAgICBvYmogPSBvYmpbcGF0aF07XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIGdldFBhdGhzKHBhdGhTdHJpbmcpIHtcbiAgdmFyIHJlZ2V4ID0gLyg/OlxcLihcXHcrKSl8KD86XFxbKFxcZCspXFxdKXwoPzpcXFtcIigoPzpbXlxcXFxcIl18XFxcXC4pKilcIlxcXSkvZztcbiAgdmFyIG1hdGNoZXMgPSBbXTtcbiAgdmFyIG1hdGNoO1xuICB3aGlsZSAobWF0Y2ggPSByZWdleC5leGVjKHBhdGhTdHJpbmcpKSB7XG4gICAgbWF0Y2hlcy5wdXNoKCBtYXRjaFsxXSB8fCBtYXRjaFsyXSB8fCBtYXRjaFszXSApO1xuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuIiwidmFyIHBhdGhHZXR0ZXIgPSByZXF1aXJlKCcuL3BhdGgtZ2V0dGVyJyk7XG52YXIganNhbiA9IHJlcXVpcmUoJy4vJyk7XG5cbmV4cG9ydHMuZ2V0UmVnZXhGbGFncyA9IGZ1bmN0aW9uIGdldFJlZ2V4RmxhZ3MocmVnZXgpIHtcbiAgdmFyIGZsYWdzID0gJyc7XG4gIGlmIChyZWdleC5pZ25vcmVDYXNlKSBmbGFncyArPSAnaSc7XG4gIGlmIChyZWdleC5nbG9iYWwpIGZsYWdzICs9ICdnJztcbiAgaWYgKHJlZ2V4Lm11bHRpbGluZSkgZmxhZ3MgKz0gJ20nO1xuICByZXR1cm4gZmxhZ3M7XG59O1xuXG5leHBvcnRzLnN0cmluZ2lmeUZ1bmN0aW9uID0gZnVuY3Rpb24gc3RyaW5naWZ5RnVuY3Rpb24oZm4sIGN1c3RvbVRvU3RyaW5nKSB7XG4gIGlmICh0eXBlb2YgY3VzdG9tVG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gY3VzdG9tVG9TdHJpbmcoZm4pO1xuICB9XG4gIHZhciBzdHIgPSBmbi50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goL15bXntdKnt8XltePV0qPT4vKTtcbiAgdmFyIHN0YXJ0ID0gbWF0Y2ggPyBtYXRjaFswXSA6ICc8ZnVuY3Rpb24+ICc7XG4gIHZhciBlbmQgPSBzdHJbc3RyLmxlbmd0aCAtIDFdID09PSAnfScgPyAnfScgOiAnJztcbiAgcmV0dXJuIHN0YXJ0LnJlcGxhY2UoL1xcclxcbnxcXG4vZywgJyAnKS5yZXBsYWNlKC9cXHMrL2csICcgJykgKyAnIC8qIC4uLiAqLyAnICsgZW5kO1xufTtcblxuZXhwb3J0cy5yZXN0b3JlID0gZnVuY3Rpb24gcmVzdG9yZShvYmosIHJvb3QpIHtcbiAgdmFyIHR5cGUgPSBvYmpbMF07XG4gIHZhciByZXN0ID0gb2JqLnNsaWNlKDEpO1xuICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgJyQnOlxuICAgICAgcmV0dXJuIHBhdGhHZXR0ZXIocm9vdCwgb2JqKTtcbiAgICBjYXNlICdyJzpcbiAgICAgIHZhciBjb21tYSA9IHJlc3QuaW5kZXhPZignLCcpO1xuICAgICAgdmFyIGZsYWdzID0gcmVzdC5zbGljZSgwLCBjb21tYSk7XG4gICAgICB2YXIgc291cmNlID0gcmVzdC5zbGljZShjb21tYSArIDEpO1xuICAgICAgcmV0dXJuIFJlZ0V4cChzb3VyY2UsIGZsYWdzKTtcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgrcmVzdCk7XG4gICAgY2FzZSAnZic6XG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHsgdGhyb3cgbmV3IEVycm9yKFwiY2FuJ3QgcnVuIGpzYW4gcGFyc2VkIGZ1bmN0aW9uXCIpIH07XG4gICAgICBmbi50b1N0cmluZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVzdDsgfTtcbiAgICAgIHJldHVybiBmbjtcbiAgICBjYXNlICd1JzpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgY2FzZSAnZSc6XG4gICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IocmVzdCk7XG4gICAgICBlcnJvci5zdGFjayA9ICdTdGFjayBpcyB1bmF2YWlsYWJsZSBmb3IganNhbiBwYXJzZWQgZXJyb3JzJztcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBTeW1ib2wocmVzdCk7XG4gICAgY2FzZSAnZyc6XG4gICAgICByZXR1cm4gU3ltYm9sLmZvcihyZXN0KTtcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuZXcgTWFwKGpzYW4ucGFyc2UocmVzdCkpO1xuICAgIGNhc2UgJ2wnOlxuICAgICAgcmV0dXJuIG5ldyBTZXQoanNhbi5wYXJzZShyZXN0KSk7XG4gICAgY2FzZSAnbic6XG4gICAgICByZXR1cm4gTmFOO1xuICAgIGNhc2UgJ2knOlxuICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIC1JbmZpbml0eTtcbiAgICBkZWZhdWx0OlxuICAgICAgY29uc29sZS53YXJuKCd1bmtub3duIHR5cGUnLCBvYmopO1xuICAgICAgcmV0dXJuIG9iajtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWFjaCA9IHJlcXVpcmUoJ2ZvcmVhY2gnKTtcbm1vZHVsZS5leHBvcnRzID0gYXBpO1xuXG5cbi8qKlxuICogQ29udmVuaWVuY2Ugd3JhcHBlciBhcm91bmQgdGhlIGFwaS5cbiAqIENhbGxzIGAuZ2V0YCB3aGVuIGNhbGxlZCB3aXRoIGFuIGBvYmplY3RgIGFuZCBhIGBwb2ludGVyYC5cbiAqIENhbGxzIGAuc2V0YCB3aGVuIGFsc28gY2FsbGVkIHdpdGggYHZhbHVlYC5cbiAqIElmIG9ubHkgc3VwcGxpZWQgYG9iamVjdGAsIHJldHVybnMgYSBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbiwgbWFwcGVkIHRvIHRoZSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBvaW50ZXJcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMgeyp9XG4gKi9cblxuZnVuY3Rpb24gYXBpIChvYmosIHBvaW50ZXIsIHZhbHVlKSB7XG4gICAgLy8gLnNldCgpXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgICAgcmV0dXJuIGFwaS5zZXQob2JqLCBwb2ludGVyLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIC5nZXQoKVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiBhcGkuZ2V0KG9iaiwgcG9pbnRlcik7XG4gICAgfVxuICAgIC8vIFJldHVybiBhIHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uIG9uIGBvYmpgLlxuICAgIHZhciB3cmFwcGVkID0gYXBpLmJpbmQoYXBpLCBvYmopO1xuXG4gICAgLy8gU3VwcG9ydCBmb3Igb28gc3R5bGVcbiAgICBmb3IgKHZhciBuYW1lIGluIGFwaSkge1xuICAgICAgICBpZiAoYXBpLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICB3cmFwcGVkW25hbWVdID0gYXBpW25hbWVdLmJpbmQod3JhcHBlZCwgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd3JhcHBlZDtcbn1cblxuXG4vKipcbiAqIExvb2t1cCBhIGpzb24gcG9pbnRlciBpbiBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcG9pbnRlclxuICogQHJldHVybnMgeyp9XG4gKi9cbmFwaS5nZXQgPSBmdW5jdGlvbiBnZXQgKG9iaiwgcG9pbnRlcikge1xuICAgIHZhciByZWZUb2tlbnMgPSBBcnJheS5pc0FycmF5KHBvaW50ZXIpID8gcG9pbnRlciA6IGFwaS5wYXJzZShwb2ludGVyKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVmVG9rZW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0b2sgPSByZWZUb2tlbnNbaV07XG4gICAgICAgIGlmICghKHR5cGVvZiBvYmogPT0gJ29iamVjdCcgJiYgdG9rIGluIG9iaikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWZlcmVuY2UgdG9rZW46ICcgKyB0b2spO1xuICAgICAgICB9XG4gICAgICAgIG9iaiA9IG9ialt0b2tdO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgdmFsdWUgb24gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBvaW50ZXJcbiAqIEBwYXJhbSB2YWx1ZVxuICovXG5hcGkuc2V0ID0gZnVuY3Rpb24gc2V0IChvYmosIHBvaW50ZXIsIHZhbHVlKSB7XG4gICAgdmFyIHJlZlRva2VucyA9IEFycmF5LmlzQXJyYXkocG9pbnRlcikgPyBwb2ludGVyIDogYXBpLnBhcnNlKHBvaW50ZXIpLFxuICAgICAgbmV4dFRvayA9IHJlZlRva2Vuc1swXTtcblxuICAgIGlmIChyZWZUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBFcnJvcignQ2FuIG5vdCBzZXQgdGhlIHJvb3Qgb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWZUb2tlbnMubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIHZhciB0b2sgPSByZWZUb2tlbnNbaV07XG4gICAgICAgIGlmICh0b2sgPT09IFwiX19wcm90b19fXCIgfHwgdG9rID09PSBcImNvbnN0cnVjdG9yXCIgfHwgdG9rID09PSBcInByb3RvdHlwZVwiKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0b2sgPT09ICctJyAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgICB0b2sgPSBvYmoubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIG5leHRUb2sgPSByZWZUb2tlbnNbaSArIDFdO1xuXG4gICAgICAgIGlmICghKHRvayBpbiBvYmopKSB7XG4gICAgICAgICAgICBpZiAobmV4dFRvay5tYXRjaCgvXihcXGQrfC0pJC8pKSB7XG4gICAgICAgICAgICAgICAgb2JqW3Rva10gPSBbXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2JqW3Rva10gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvYmogPSBvYmpbdG9rXTtcbiAgICB9XG4gICAgaWYgKG5leHRUb2sgPT09ICctJyAmJiBBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIG5leHRUb2sgPSBvYmoubGVuZ3RoO1xuICAgIH1cbiAgICBvYmpbbmV4dFRva10gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcG9pbnRlclxuICovXG5hcGkucmVtb3ZlID0gZnVuY3Rpb24gKG9iaiwgcG9pbnRlcikge1xuICAgIHZhciByZWZUb2tlbnMgPSBBcnJheS5pc0FycmF5KHBvaW50ZXIpID8gcG9pbnRlciA6IGFwaS5wYXJzZShwb2ludGVyKTtcbiAgICB2YXIgZmluYWxUb2tlbiA9IHJlZlRva2Vuc1tyZWZUb2tlbnMubGVuZ3RoIC0xXTtcbiAgICBpZiAoZmluYWxUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXIgZm9yIHJlbW92ZTogXCInICsgcG9pbnRlciArICdcIicpO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnQgPSBhcGkuZ2V0KG9iaiwgcmVmVG9rZW5zLnNsaWNlKDAsIC0xKSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFyZW50KSkge1xuICAgICAgdmFyIGluZGV4ID0gK2ZpbmFsVG9rZW47XG4gICAgICBpZiAoZmluYWxUb2tlbiA9PT0gJycgJiYgaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcnJheSBpbmRleDogXCInICsgZmluYWxUb2tlbiArICdcIicpO1xuICAgICAgfVxuXG4gICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwocGFyZW50LCBpbmRleCwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBwYXJlbnRbZmluYWxUb2tlbl07XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgKHBvaW50ZXIgLT4gdmFsdWUpIGRpY3Rpb25hcnkgZm9yIGFuIG9iamVjdFxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRlc2NlbmRcbiAqIEByZXR1cm5zIHt9XG4gKi9cbmFwaS5kaWN0ID0gZnVuY3Rpb24gZGljdCAob2JqLCBkZXNjZW5kKSB7XG4gICAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgICBhcGkud2FsayhvYmosIGZ1bmN0aW9uICh2YWx1ZSwgcG9pbnRlcikge1xuICAgICAgICByZXN1bHRzW3BvaW50ZXJdID0gdmFsdWU7XG4gICAgfSwgZGVzY2VuZCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgYW4gb2JqZWN0XG4gKiBJdGVyYXRvcjogZnVuY3Rpb24gKHZhbHVlLCBwb2ludGVyKSB7fVxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZXNjZW5kXG4gKi9cbmFwaS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqLCBpdGVyYXRvciwgZGVzY2VuZCkge1xuICAgIHZhciByZWZUb2tlbnMgPSBbXTtcblxuICAgIGRlc2NlbmQgPSBkZXNjZW5kIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnW29iamVjdCBPYmplY3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBBcnJheV0nO1xuICAgIH07XG5cbiAgICAoZnVuY3Rpb24gbmV4dCAoY3VyKSB7XG4gICAgICAgIGVhY2goY3VyLCBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICAgICAgcmVmVG9rZW5zLnB1c2goU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgaWYgKGRlc2NlbmQodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGl0ZXJhdG9yKHZhbHVlLCBhcGkuY29tcGlsZShyZWZUb2tlbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlZlRva2Vucy5wb3AoKTtcbiAgICAgICAgfSk7XG4gICAgfShvYmopKTtcbn07XG5cbi8qKlxuICogVGVzdHMgaWYgYW4gb2JqZWN0IGhhcyBhIHZhbHVlIGZvciBhIGpzb24gcG9pbnRlclxuICpcbiAqIEBwYXJhbSBvYmpcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuYXBpLmhhcyA9IGZ1bmN0aW9uIGhhcyAob2JqLCBwb2ludGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYXBpLmdldChvYmosIHBvaW50ZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogRXNjYXBlcyBhIHJlZmVyZW5jZSB0b2tlblxuICpcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFwaS5lc2NhcGUgPSBmdW5jdGlvbiBlc2NhcGUgKHN0cikge1xuICAgIHJldHVybiBzdHIudG9TdHJpbmcoKS5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn07XG5cbi8qKlxuICogVW5lc2NhcGVzIGEgcmVmZXJlbmNlIHRva2VuXG4gKlxuICogQHBhcmFtIHN0clxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuYXBpLnVuZXNjYXBlID0gZnVuY3Rpb24gdW5lc2NhcGUgKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgJy8nKS5yZXBsYWNlKC9+MC9nLCAnficpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGpzb24gcG9pbnRlciBpbnRvIGEgYXJyYXkgb2YgcmVmZXJlbmNlIHRva2Vuc1xuICpcbiAqIEBwYXJhbSBwb2ludGVyXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmFwaS5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChwb2ludGVyKSB7XG4gICAgaWYgKHBvaW50ZXIgPT09ICcnKSB7IHJldHVybiBbXTsgfVxuICAgIGlmIChwb2ludGVyLmNoYXJBdCgwKSAhPT0gJy8nKSB7IHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIHBvaW50ZXI6ICcgKyBwb2ludGVyKTsgfVxuICAgIHJldHVybiBwb2ludGVyLnN1YnN0cmluZygxKS5zcGxpdCgvXFwvLykubWFwKGFwaS51bmVzY2FwZSk7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhIGpzb24gcG9pbnRlciBmcm9tIGEgYXJyYXkgb2YgcmVmZXJlbmNlIHRva2Vuc1xuICpcbiAqIEBwYXJhbSByZWZUb2tlbnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmFwaS5jb21waWxlID0gZnVuY3Rpb24gY29tcGlsZSAocmVmVG9rZW5zKSB7XG4gICAgaWYgKHJlZlRva2Vucy5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XG4gICAgcmV0dXJuICcvJyArIHJlZlRva2Vucy5tYXAoYXBpLmVzY2FwZSkuam9pbignLycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBoeXBoZW5hdGUgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaHlwaGVuYXRlLXN0eWxlLW5hbWUnKSk7XG5cbi8qKlxuICogQ29udmVydCBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBkYXNoIHNlcGFyYXRlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5mdW5jdGlvbiBjb252ZXJ0Q2FzZShzdHlsZSkge1xuICB2YXIgY29udmVydGVkID0ge307XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgIHZhciBrZXkgPSBwcm9wLmluZGV4T2YoJy0tJykgPT09IDAgPyBwcm9wIDogaHlwaGVuYXRlKHByb3ApO1xuICAgIGNvbnZlcnRlZFtrZXldID0gc3R5bGVbcHJvcF07XG4gIH1cblxuICBpZiAoc3R5bGUuZmFsbGJhY2tzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUuZmFsbGJhY2tzKSkgY29udmVydGVkLmZhbGxiYWNrcyA9IHN0eWxlLmZhbGxiYWNrcy5tYXAoY29udmVydENhc2UpO2Vsc2UgY29udmVydGVkLmZhbGxiYWNrcyA9IGNvbnZlcnRDYXNlKHN0eWxlLmZhbGxiYWNrcyk7XG4gIH1cblxuICByZXR1cm4gY29udmVydGVkO1xufVxuLyoqXG4gKiBBbGxvdyBjYW1lbCBjYXNlZCBwcm9wZXJ0eSBuYW1lcyBieSBjb252ZXJ0aW5nIHRoZW0gYmFjayB0byBkYXNoZXJpemVkLlxuICpcbiAqIEBwYXJhbSB7UnVsZX0gcnVsZVxuICovXG5cblxuZnVuY3Rpb24gY2FtZWxDYXNlKCkge1xuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkge1xuICAgICAgLy8gSGFuZGxlIHJ1bGVzIGxpa2UgQGZvbnQtZmFjZSwgd2hpY2ggY2FuIGhhdmUgbXVsdGlwbGUgc3R5bGVzIGluIGFuIGFycmF5XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0eWxlW2luZGV4XSA9IGNvbnZlcnRDYXNlKHN0eWxlW2luZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29udmVydENhc2Uoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCwgcnVsZSkge1xuICAgIGlmIChwcm9wLmluZGV4T2YoJy0tJykgPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgaHlwaGVuYXRlZFByb3AgPSBoeXBoZW5hdGUocHJvcCk7IC8vIFRoZXJlIHdhcyBubyBjYW1lbCBjYXNlIGluIHBsYWNlXG5cbiAgICBpZiAocHJvcCA9PT0gaHlwaGVuYXRlZFByb3ApIHJldHVybiB2YWx1ZTtcbiAgICBydWxlLnByb3AoaHlwaGVuYXRlZFByb3AsIHZhbHVlKTsgLy8gQ29yZSB3aWxsIGlnbm9yZSB0aGF0IHByb3BlcnR5IHZhbHVlIHdlIHNldCB0aGUgcHJvcGVyIG9uZSBhYm92ZS5cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBjYW1lbENhc2U7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBqc3MgPSByZXF1aXJlKCdqc3MnKTtcblxudmFyIHB4ID0ganNzLmhhc0NTU1RPTVN1cHBvcnQgJiYgQ1NTID8gQ1NTLnB4IDogJ3B4JztcbnZhciBtcyA9IGpzcy5oYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5tcyA6ICdtcyc7XG52YXIgcGVyY2VudCA9IGpzcy5oYXNDU1NUT01TdXBwb3J0ICYmIENTUyA/IENTUy5wZXJjZW50IDogJyUnO1xuLyoqXG4gKiBHZW5lcmF0ZWQganNzLXBsdWdpbi1kZWZhdWx0LXVuaXQgQ1NTIHByb3BlcnR5IHVuaXRzXG4gKlxuICogQHR5cGUgb2JqZWN0XG4gKi9cblxudmFyIGRlZmF1bHRVbml0cyA9IHtcbiAgLy8gQW5pbWF0aW9uIHByb3BlcnRpZXNcbiAgJ2FuaW1hdGlvbi1kZWxheSc6IG1zLFxuICAnYW5pbWF0aW9uLWR1cmF0aW9uJzogbXMsXG4gIC8vIEJhY2tncm91bmQgcHJvcGVydGllc1xuICAnYmFja2dyb3VuZC1wb3NpdGlvbic6IHB4LFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbi14JzogcHgsXG4gICdiYWNrZ3JvdW5kLXBvc2l0aW9uLXknOiBweCxcbiAgJ2JhY2tncm91bmQtc2l6ZSc6IHB4LFxuICAvLyBCb3JkZXIgUHJvcGVydGllc1xuICBib3JkZXI6IHB4LFxuICAnYm9yZGVyLWJvdHRvbSc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLWJvdHRvbS1yaWdodC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci1ib3R0b20td2lkdGgnOiBweCxcbiAgJ2JvcmRlci1sZWZ0JzogcHgsXG4gICdib3JkZXItbGVmdC13aWR0aCc6IHB4LFxuICAnYm9yZGVyLXJhZGl1cyc6IHB4LFxuICAnYm9yZGVyLXJpZ2h0JzogcHgsXG4gICdib3JkZXItcmlnaHQtd2lkdGgnOiBweCxcbiAgJ2JvcmRlci10b3AnOiBweCxcbiAgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnOiBweCxcbiAgJ2JvcmRlci10b3AtcmlnaHQtcmFkaXVzJzogcHgsXG4gICdib3JkZXItdG9wLXdpZHRoJzogcHgsXG4gICdib3JkZXItd2lkdGgnOiBweCxcbiAgLy8gTWFyZ2luIHByb3BlcnRpZXNcbiAgbWFyZ2luOiBweCxcbiAgJ21hcmdpbi1ib3R0b20nOiBweCxcbiAgJ21hcmdpbi1sZWZ0JzogcHgsXG4gICdtYXJnaW4tcmlnaHQnOiBweCxcbiAgJ21hcmdpbi10b3AnOiBweCxcbiAgLy8gUGFkZGluZyBwcm9wZXJ0aWVzXG4gIHBhZGRpbmc6IHB4LFxuICAncGFkZGluZy1ib3R0b20nOiBweCxcbiAgJ3BhZGRpbmctbGVmdCc6IHB4LFxuICAncGFkZGluZy1yaWdodCc6IHB4LFxuICAncGFkZGluZy10b3AnOiBweCxcbiAgLy8gTWFzayBwcm9wZXJ0aWVzXG4gICdtYXNrLXBvc2l0aW9uLXgnOiBweCxcbiAgJ21hc2stcG9zaXRpb24teSc6IHB4LFxuICAnbWFzay1zaXplJzogcHgsXG4gIC8vIFdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICBoZWlnaHQ6IHB4LFxuICB3aWR0aDogcHgsXG4gICdtaW4taGVpZ2h0JzogcHgsXG4gICdtYXgtaGVpZ2h0JzogcHgsXG4gICdtaW4td2lkdGgnOiBweCxcbiAgJ21heC13aWR0aCc6IHB4LFxuICAvLyBQb3NpdGlvbiBwcm9wZXJ0aWVzXG4gIGJvdHRvbTogcHgsXG4gIGxlZnQ6IHB4LFxuICB0b3A6IHB4LFxuICByaWdodDogcHgsXG4gIC8vIFNoYWRvdyBwcm9wZXJ0aWVzXG4gICdib3gtc2hhZG93JzogcHgsXG4gICd0ZXh0LXNoYWRvdyc6IHB4LFxuICAvLyBDb2x1bW4gcHJvcGVydGllc1xuICAnY29sdW1uLWdhcCc6IHB4LFxuICAnY29sdW1uLXJ1bGUnOiBweCxcbiAgJ2NvbHVtbi1ydWxlLXdpZHRoJzogcHgsXG4gICdjb2x1bW4td2lkdGgnOiBweCxcbiAgLy8gRm9udCBhbmQgdGV4dCBwcm9wZXJ0aWVzXG4gICdmb250LXNpemUnOiBweCxcbiAgJ2ZvbnQtc2l6ZS1kZWx0YSc6IHB4LFxuICAnbGV0dGVyLXNwYWNpbmcnOiBweCxcbiAgJ3RleHQtaW5kZW50JzogcHgsXG4gICd0ZXh0LXN0cm9rZSc6IHB4LFxuICAndGV4dC1zdHJva2Utd2lkdGgnOiBweCxcbiAgJ3dvcmQtc3BhY2luZyc6IHB4LFxuICAvLyBNb3Rpb24gcHJvcGVydGllc1xuICBtb3Rpb246IHB4LFxuICAnbW90aW9uLW9mZnNldCc6IHB4LFxuICAvLyBPdXRsaW5lIHByb3BlcnRpZXNcbiAgb3V0bGluZTogcHgsXG4gICdvdXRsaW5lLW9mZnNldCc6IHB4LFxuICAnb3V0bGluZS13aWR0aCc6IHB4LFxuICAvLyBQZXJzcGVjdGl2ZSBwcm9wZXJ0aWVzXG4gIHBlcnNwZWN0aXZlOiBweCxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi14JzogcGVyY2VudCxcbiAgJ3BlcnNwZWN0aXZlLW9yaWdpbi15JzogcGVyY2VudCxcbiAgLy8gVHJhbnNmb3JtIHByb3BlcnRpZXNcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nOiBwZXJjZW50LFxuICAndHJhbnNmb3JtLW9yaWdpbi14JzogcGVyY2VudCxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4teSc6IHBlcmNlbnQsXG4gICd0cmFuc2Zvcm0tb3JpZ2luLXonOiBwZXJjZW50LFxuICAvLyBUcmFuc2l0aW9uIHByb3BlcnRpZXNcbiAgJ3RyYW5zaXRpb24tZGVsYXknOiBtcyxcbiAgJ3RyYW5zaXRpb24tZHVyYXRpb24nOiBtcyxcbiAgLy8gQWxpZ25tZW50IHByb3BlcnRpZXNcbiAgJ3ZlcnRpY2FsLWFsaWduJzogcHgsXG4gICdmbGV4LWJhc2lzJzogcHgsXG4gIC8vIFNvbWUgcmFuZG9tIHByb3BlcnRpZXNcbiAgJ3NoYXBlLW1hcmdpbic6IHB4LFxuICBzaXplOiBweCxcbiAgLy8gR3JpZCBwcm9wZXJ0aWVzXG4gIGdyaWQ6IHB4LFxuICAnZ3JpZC1nYXAnOiBweCxcbiAgJ2dyaWQtcm93LWdhcCc6IHB4LFxuICAnZ3JpZC1jb2x1bW4tZ2FwJzogcHgsXG4gICdncmlkLXRlbXBsYXRlLXJvd3MnOiBweCxcbiAgJ2dyaWQtdGVtcGxhdGUtY29sdW1ucyc6IHB4LFxuICAnZ3JpZC1hdXRvLXJvd3MnOiBweCxcbiAgJ2dyaWQtYXV0by1jb2x1bW5zJzogcHgsXG4gIC8vIE5vdCBleGlzdGluZyBwcm9wZXJ0aWVzLlxuICAvLyBVc2VkIHRvIGF2b2lkIGlzc3VlcyB3aXRoIGpzcy1wbHVnaW4tZXhwYW5kIGludGVncmF0aW9uLlxuICAnYm94LXNoYWRvdy14JzogcHgsXG4gICdib3gtc2hhZG93LXknOiBweCxcbiAgJ2JveC1zaGFkb3ctYmx1cic6IHB4LFxuICAnYm94LXNoYWRvdy1zcHJlYWQnOiBweCxcbiAgJ2ZvbnQtbGluZS1oZWlnaHQnOiBweCxcbiAgJ3RleHQtc2hhZG93LXgnOiBweCxcbiAgJ3RleHQtc2hhZG93LXknOiBweCxcbiAgJ3RleHQtc2hhZG93LWJsdXInOiBweFxufTtcblxuLyoqXG4gKiBDbG9uZXMgdGhlIG9iamVjdCBhbmQgYWRkcyBhIGNhbWVsIGNhc2VkIHByb3BlcnR5IHZlcnNpb24uXG4gKi9cbmZ1bmN0aW9uIGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9iaikge1xuICB2YXIgcmVnRXhwID0gLygtW2Etel0pL2c7XG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHN0cikge1xuICAgIHJldHVybiBzdHJbMV0udG9VcHBlckNhc2UoKTtcbiAgfTtcblxuICB2YXIgbmV3T2JqID0ge307XG5cbiAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICBuZXdPYmpbX2tleV0gPSBvYmpbX2tleV07XG4gICAgbmV3T2JqW19rZXkucmVwbGFjZShyZWdFeHAsIHJlcGxhY2UpXSA9IG9ialtfa2V5XTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbnZhciB1bml0cyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKGRlZmF1bHRVbml0cyk7XG4vKipcbiAqIFJlY3Vyc2l2ZSBkZWVwIHN0eWxlIHBhc3NpbmcgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBpdGVyYXRlKHByb3AsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICghdmFsdWUpIHJldHVybiB2YWx1ZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZVtpXSA9IGl0ZXJhdGUocHJvcCwgdmFsdWVbaV0sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3AgPT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBmb3IgKHZhciBpbm5lclByb3AgaW4gdmFsdWUpIHtcbiAgICAgICAgdmFsdWVbaW5uZXJQcm9wXSA9IGl0ZXJhdGUoaW5uZXJQcm9wLCB2YWx1ZVtpbm5lclByb3BdLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgX2lubmVyUHJvcCBpbiB2YWx1ZSkge1xuICAgICAgICB2YWx1ZVtfaW5uZXJQcm9wXSA9IGl0ZXJhdGUocHJvcCArIFwiLVwiICsgX2lubmVyUHJvcCwgdmFsdWVbX2lubmVyUHJvcF0sIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdmFyIHVuaXQgPSBvcHRpb25zW3Byb3BdIHx8IHVuaXRzW3Byb3BdO1xuXG4gICAgaWYgKHVuaXQpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdW5pdCA9PT0gJ2Z1bmN0aW9uJyA/IHVuaXQodmFsdWUpLnRvU3RyaW5nKCkgOiBcIlwiICsgdmFsdWUgKyB1bml0O1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBBZGQgdW5pdCB0byBudW1lcmljIHZhbHVlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlZmF1bHRVbml0KG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBjYW1lbENhc2VkT3B0aW9ucyA9IGFkZENhbWVsQ2FzZWRWZXJzaW9uKG9wdGlvbnMpO1xuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJykgcmV0dXJuIHN0eWxlO1xuXG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgc3R5bGVbcHJvcF0gPSBpdGVyYXRlKHByb3AsIHN0eWxlW3Byb3BdLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiBpdGVyYXRlKHByb3AsIHZhbHVlLCBjYW1lbENhc2VkT3B0aW9ucyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIG9uUHJvY2Vzc1N0eWxlOiBvblByb2Nlc3NTdHlsZSxcbiAgICBvbkNoYW5nZVZhbHVlOiBvbkNoYW5nZVZhbHVlXG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRVbml0O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHQgKGV4KSB7IHJldHVybiAoZXggJiYgKHR5cGVvZiBleCA9PT0gJ29iamVjdCcpICYmICdkZWZhdWx0JyBpbiBleCkgPyBleFsnZGVmYXVsdCddIDogZXg7IH1cblxudmFyIF9leHRlbmRzID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXh0ZW5kcycpKTtcbnZhciBqc3MgPSByZXF1aXJlKCdqc3MnKTtcblxudmFyIGF0ID0gJ0BnbG9iYWwnO1xudmFyIGF0UHJlZml4ID0gJ0BnbG9iYWwgJztcblxudmFyIEdsb2JhbENvbnRhaW5lclJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxDb250YWluZXJSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2dsb2JhbCc7XG4gICAgdGhpcy5hdCA9IGF0O1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnVsZXMgPSBuZXcganNzLlJ1bGVMaXN0KF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBwYXJlbnQ6IHRoaXNcbiAgICB9KSk7XG5cbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKHNlbGVjdG9yLCBzdHlsZXNbc2VsZWN0b3JdKTtcbiAgICB9XG5cbiAgICB0aGlzLnJ1bGVzLnByb2Nlc3MoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IGEgcnVsZS5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gR2xvYmFsQ29udGFpbmVyUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgcmVnaXN0ZXIgcnVsZSwgcnVuIHBsdWdpbnMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZFJ1bGUgPSBmdW5jdGlvbiBhZGRSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgdmFyIHJ1bGUgPSB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnJ1bGVzLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIEdsb2JhbENvbnRhaW5lclJ1bGU7XG59KCk7XG5cbnZhciBHbG9iYWxQcmVmaXhlZFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHbG9iYWxQcmVmaXhlZFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdnbG9iYWwnO1xuICAgIHRoaXMuYXQgPSBhdDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHZhciBzZWxlY3RvciA9IGtleS5zdWJzdHIoYXRQcmVmaXgubGVuZ3RoKTtcbiAgICB0aGlzLnJ1bGUgPSBvcHRpb25zLmpzcy5jcmVhdGVSdWxlKHNlbGVjdG9yLCBzdHlsZSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8yID0gR2xvYmFsUHJlZml4ZWRSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8yLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnJ1bGUgPyB0aGlzLnJ1bGUudG9TdHJpbmcob3B0aW9ucykgOiAnJztcbiAgfTtcblxuICByZXR1cm4gR2xvYmFsUHJlZml4ZWRSdWxlO1xufSgpO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xuXG5mdW5jdGlvbiBhZGRTY29wZShzZWxlY3Rvciwgc2NvcGUpIHtcbiAgdmFyIHBhcnRzID0gc2VsZWN0b3Iuc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgdmFyIHNjb3BlZCA9ICcnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBzY29wZWQgKz0gc2NvcGUgKyBcIiBcIiArIHBhcnRzW2ldLnRyaW0oKTtcbiAgICBpZiAocGFydHNbaSArIDFdKSBzY29wZWQgKz0gJywgJztcbiAgfVxuXG4gIHJldHVybiBzY29wZWQ7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZU5lc3RlZEdsb2JhbENvbnRhaW5lclJ1bGUocnVsZSkge1xuICB2YXIgb3B0aW9ucyA9IHJ1bGUub3B0aW9ucyxcbiAgICAgIHN0eWxlID0gcnVsZS5zdHlsZTtcbiAgdmFyIHJ1bGVzID0gc3R5bGUgPyBzdHlsZVthdF0gOiBudWxsO1xuICBpZiAoIXJ1bGVzKSByZXR1cm47XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBydWxlcykge1xuICAgIG9wdGlvbnMuc2hlZXQuYWRkUnVsZShuYW1lLCBydWxlc1tuYW1lXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNlbGVjdG9yOiBhZGRTY29wZShuYW1lLCBydWxlLnNlbGVjdG9yKVxuICAgIH0pKTtcbiAgfVxuXG4gIGRlbGV0ZSBzdHlsZVthdF07XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlKSB7XG4gIHZhciBvcHRpb25zID0gcnVsZS5vcHRpb25zLFxuICAgICAgc3R5bGUgPSBydWxlLnN0eWxlO1xuXG4gIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICBpZiAocHJvcFswXSAhPT0gJ0AnIHx8IHByb3Auc3Vic3RyKDAsIGF0Lmxlbmd0aCkgIT09IGF0KSBjb250aW51ZTtcbiAgICB2YXIgc2VsZWN0b3IgPSBhZGRTY29wZShwcm9wLnN1YnN0cihhdC5sZW5ndGgpLCBydWxlLnNlbGVjdG9yKTtcbiAgICBvcHRpb25zLnNoZWV0LmFkZFJ1bGUoc2VsZWN0b3IsIHN0eWxlW3Byb3BdLCBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yXG4gICAgfSkpO1xuICAgIGRlbGV0ZSBzdHlsZVtwcm9wXTtcbiAgfVxufVxuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24ganNzR2xvYmFsKCkge1xuICBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFuYW1lKSByZXR1cm4gbnVsbDtcblxuICAgIGlmIChuYW1lID09PSBhdCkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxDb250YWluZXJSdWxlKG5hbWUsIHN0eWxlcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVbMF0gPT09ICdAJyAmJiBuYW1lLnN1YnN0cigwLCBhdFByZWZpeC5sZW5ndGgpID09PSBhdFByZWZpeCkge1xuICAgICAgcmV0dXJuIG5ldyBHbG9iYWxQcmVmaXhlZFJ1bGUobmFtZSwgc3R5bGVzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAocGFyZW50LnR5cGUgPT09ICdnbG9iYWwnIHx8IHBhcmVudC5vcHRpb25zLnBhcmVudCAmJiBwYXJlbnQub3B0aW9ucy5wYXJlbnQudHlwZSA9PT0gJ2dsb2JhbCcpIHtcbiAgICAgICAgb3B0aW9ucy5zY29wZWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zY29wZWQgPT09IGZhbHNlKSB7XG4gICAgICBvcHRpb25zLnNlbGVjdG9yID0gbmFtZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUHJvY2Vzc1J1bGUocnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybjtcbiAgICBoYW5kbGVOZXN0ZWRHbG9iYWxDb250YWluZXJSdWxlKHJ1bGUpO1xuICAgIGhhbmRsZVByZWZpeGVkR2xvYmFsUnVsZShydWxlKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBvbkNyZWF0ZVJ1bGUsXG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NHbG9iYWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgX2V4dGVuZHMgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJykpO1xudmFyIHdhcm5pbmcgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgndGlueS13YXJuaW5nJykpO1xuXG52YXIgc2VwYXJhdG9yUmVnRXhwID0gL1xccyosXFxzKi9nO1xudmFyIHBhcmVudFJlZ0V4cCA9IC8mL2c7XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuLyoqXG4gKiBDb252ZXJ0IG5lc3RlZCBydWxlcyB0byBzZXBhcmF0ZSwgcmVtb3ZlIHRoZW0gZnJvbSBvcmlnaW5hbCBzdHlsZXMuXG4gKlxuICogQHBhcmFtIHtSdWxlfSBydWxlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGpzc05lc3RlZCgpIHtcbiAgLy8gR2V0IGEgZnVuY3Rpb24gdG8gYmUgdXNlZCBmb3IgJHJlZiByZXBsYWNlbWVudC5cbiAgZnVuY3Rpb24gZ2V0UmVwbGFjZVJlZihjb250YWluZXIsIHNoZWV0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtYXRjaCwga2V5KSB7XG4gICAgICB2YXIgcnVsZSA9IGNvbnRhaW5lci5nZXRSdWxlKGtleSkgfHwgc2hlZXQgJiYgc2hlZXQuZ2V0UnVsZShrZXkpO1xuXG4gICAgICBpZiAocnVsZSkge1xuICAgICAgICBydWxlID0gcnVsZTtcbiAgICAgICAgcmV0dXJuIHJ1bGUuc2VsZWN0b3I7XG4gICAgICB9XG5cbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIENvdWxkIG5vdCBmaW5kIHRoZSByZWZlcmVuY2VkIHJ1bGUgXFxcIlwiICsga2V5ICsgXCJcXFwiIGluIFxcXCJcIiArIChjb250YWluZXIub3B0aW9ucy5tZXRhIHx8IGNvbnRhaW5lci50b1N0cmluZygpKSArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUGFyZW50UmVmcyhuZXN0ZWRQcm9wLCBwYXJlbnRQcm9wKSB7XG4gICAgdmFyIHBhcmVudFNlbGVjdG9ycyA9IHBhcmVudFByb3Auc3BsaXQoc2VwYXJhdG9yUmVnRXhwKTtcbiAgICB2YXIgbmVzdGVkU2VsZWN0b3JzID0gbmVzdGVkUHJvcC5zcGxpdChzZXBhcmF0b3JSZWdFeHApO1xuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyZW50U2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFyZW50ID0gcGFyZW50U2VsZWN0b3JzW2ldO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG5lc3RlZFNlbGVjdG9ycy5sZW5ndGg7IGorKykge1xuICAgICAgICB2YXIgbmVzdGVkID0gbmVzdGVkU2VsZWN0b3JzW2pdO1xuICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJywgJzsgLy8gUmVwbGFjZSBhbGwgJiBieSB0aGUgcGFyZW50IG9yIHByZWZpeCAmIHdpdGggdGhlIHBhcmVudC5cblxuICAgICAgICByZXN1bHQgKz0gbmVzdGVkLmluZGV4T2YoJyYnKSAhPT0gLTEgPyBuZXN0ZWQucmVwbGFjZShwYXJlbnRSZWdFeHAsIHBhcmVudCkgOiBwYXJlbnQgKyBcIiBcIiArIG5lc3RlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0T3B0aW9ucyhydWxlLCBjb250YWluZXIsIHByZXZPcHRpb25zKSB7XG4gICAgLy8gT3B0aW9ucyBoYXMgYmVlbiBhbHJlYWR5IGNyZWF0ZWQsIG5vdyB3ZSBvbmx5IGluY3JlYXNlIGluZGV4LlxuICAgIGlmIChwcmV2T3B0aW9ucykgcmV0dXJuIF9leHRlbmRzKHt9LCBwcmV2T3B0aW9ucywge1xuICAgICAgaW5kZXg6IHByZXZPcHRpb25zLmluZGV4ICsgMVxuICAgIH0pO1xuICAgIHZhciBuZXN0aW5nTGV2ZWwgPSBydWxlLm9wdGlvbnMubmVzdGluZ0xldmVsO1xuICAgIG5lc3RpbmdMZXZlbCA9IG5lc3RpbmdMZXZlbCA9PT0gdW5kZWZpbmVkID8gMSA6IG5lc3RpbmdMZXZlbCArIDE7XG5cbiAgICB2YXIgb3B0aW9ucyA9IF9leHRlbmRzKHt9LCBydWxlLm9wdGlvbnMsIHtcbiAgICAgIG5lc3RpbmdMZXZlbDogbmVzdGluZ0xldmVsLFxuICAgICAgaW5kZXg6IGNvbnRhaW5lci5pbmRleE9mKHJ1bGUpICsgMSAvLyBXZSBkb24ndCBuZWVkIHRoZSBwYXJlbnQgbmFtZSB0byBiZSBzZXQgb3B0aW9ucyBmb3IgY2hsaWQuXG5cbiAgICB9KTtcblxuICAgIGRlbGV0ZSBvcHRpb25zLm5hbWU7XG4gICAgcmV0dXJuIG9wdGlvbnM7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSwgc2hlZXQpIHtcbiAgICBpZiAocnVsZS50eXBlICE9PSAnc3R5bGUnKSByZXR1cm4gc3R5bGU7XG4gICAgdmFyIHN0eWxlUnVsZSA9IHJ1bGU7XG4gICAgdmFyIGNvbnRhaW5lciA9IHN0eWxlUnVsZS5vcHRpb25zLnBhcmVudDtcbiAgICB2YXIgb3B0aW9ucztcbiAgICB2YXIgcmVwbGFjZVJlZjtcblxuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHZhciBpc05lc3RlZCA9IHByb3AuaW5kZXhPZignJicpICE9PSAtMTtcbiAgICAgIHZhciBpc05lc3RlZENvbmRpdGlvbmFsID0gcHJvcFswXSA9PT0gJ0AnO1xuICAgICAgaWYgKCFpc05lc3RlZCAmJiAhaXNOZXN0ZWRDb25kaXRpb25hbCkgY29udGludWU7XG4gICAgICBvcHRpb25zID0gZ2V0T3B0aW9ucyhzdHlsZVJ1bGUsIGNvbnRhaW5lciwgb3B0aW9ucyk7XG5cbiAgICAgIGlmIChpc05lc3RlZCkge1xuICAgICAgICB2YXIgc2VsZWN0b3IgPSByZXBsYWNlUGFyZW50UmVmcyhwcm9wLCBzdHlsZVJ1bGUuc2VsZWN0b3IpOyAvLyBMYXppbHkgY3JlYXRlIHRoZSByZWYgcmVwbGFjZXIgZnVuY3Rpb24ganVzdCBvbmNlIGZvclxuICAgICAgICAvLyBhbGwgbmVzdGVkIHJ1bGVzIHdpdGhpbiB0aGUgc2hlZXQuXG5cbiAgICAgICAgaWYgKCFyZXBsYWNlUmVmKSByZXBsYWNlUmVmID0gZ2V0UmVwbGFjZVJlZihjb250YWluZXIsIHNoZWV0KTsgLy8gUmVwbGFjZSBhbGwgJHJlZnMuXG5cbiAgICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKHJlZlJlZ0V4cCwgcmVwbGFjZVJlZik7XG4gICAgICAgIGNvbnRhaW5lci5hZGRSdWxlKHNlbGVjdG9yLCBzdHlsZVtwcm9wXSwgX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgICAgICBzZWxlY3Rvcjogc2VsZWN0b3JcbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmIChpc05lc3RlZENvbmRpdGlvbmFsKSB7XG4gICAgICAgIC8vIFBsYWNlIGNvbmRpdGlvbmFsIHJpZ2h0IGFmdGVyIHRoZSBwYXJlbnQgcnVsZSB0byBlbnN1cmUgcmlnaHQgb3JkZXJpbmcuXG4gICAgICAgIGNvbnRhaW5lci5hZGRSdWxlKHByb3AsIHt9LCBvcHRpb25zKSAvLyBGbG93IGV4cGVjdHMgbW9yZSBvcHRpb25zIGJ1dCB0aGV5IGFyZW4ndCByZXF1aXJlZFxuICAgICAgICAvLyBBbmQgZmxvdyBkb2Vzbid0IGtub3cgdGhpcyB3aWxsIGFsd2F5cyBiZSBhIFN0eWxlUnVsZSB3aGljaCBoYXMgdGhlIGFkZFJ1bGUgbWV0aG9kXG4gICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgLmFkZFJ1bGUoc3R5bGVSdWxlLmtleSwgc3R5bGVbcHJvcF0sIHtcbiAgICAgICAgICBzZWxlY3Rvcjogc3R5bGVSdWxlLnNlbGVjdG9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGVcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0ganNzTmVzdGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFNvcnQgcHJvcHMgYnkgbGVuZ3RoLlxuICovXG5mdW5jdGlvbiBqc3NQcm9wc1NvcnQoKSB7XG4gIHZhciBzb3J0ID0gZnVuY3Rpb24gc29ydChwcm9wMCwgcHJvcDEpIHtcbiAgICBpZiAocHJvcDAubGVuZ3RoID09PSBwcm9wMS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwcm9wMCA+IHByb3AxID8gMSA6IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9wMC5sZW5ndGggLSBwcm9wMS5sZW5ndGg7XG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICAgIHZhciBuZXdTdHlsZSA9IHt9O1xuICAgICAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoc3R5bGUpLnNvcnQoc29ydCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbmV3U3R5bGVbcHJvcHNbaV1dID0gc3R5bGVbcHJvcHNbaV1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3U3R5bGU7XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NQcm9wc1NvcnQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZXgpIHsgcmV0dXJuIChleCAmJiAodHlwZW9mIGV4ID09PSAnb2JqZWN0JykgJiYgJ2RlZmF1bHQnIGluIGV4KSA/IGV4WydkZWZhdWx0J10gOiBleDsgfVxuXG52YXIgd2FybmluZyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCd0aW55LXdhcm5pbmcnKSk7XG52YXIganNzID0gcmVxdWlyZSgnanNzJyk7XG5cbnZhciBub3cgPSBEYXRlLm5vdygpO1xudmFyIGZuVmFsdWVzTnMgPSBcImZuVmFsdWVzXCIgKyBub3c7XG52YXIgZm5SdWxlTnMgPSBcImZuU3R5bGVcIiArICsrbm93O1xuZnVuY3Rpb24gZnVuY3Rpb25QbHVnaW4oKSB7XG4gIHJldHVybiB7XG4gICAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgICAgaWYgKHR5cGVvZiBkZWNsICE9PSAnZnVuY3Rpb24nKSByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBydWxlID0ganNzLmNyZWF0ZVJ1bGUobmFtZSwge30sIG9wdGlvbnMpO1xuICAgICAgcnVsZVtmblJ1bGVOc10gPSBkZWNsO1xuICAgICAgcmV0dXJuIHJ1bGU7XG4gICAgfSxcbiAgICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZXh0cmFjdCBmdW5jdGlvbiB2YWx1ZXMgZnJvbSB0aGUgZGVjbGFyYXRpb24sIHNvIHRoYXQgd2UgY2FuIGtlZXAgY29yZSB1bmF3YXJlIG9mIHRoZW0uXG4gICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoYXQgb25seSBvbmNlLlxuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBleHRyYWN0IGZ1bmN0aW9ucyBvbiBlYWNoIHN0eWxlIHVwZGF0ZSwgc2luY2UgdGhpcyBjYW4gaGFwcGVuIG9ubHkgb25jZS5cbiAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgZnVuY3Rpb24gdmFsdWVzIGluc2lkZSBvZiBmdW5jdGlvbiBydWxlcy5cbiAgICAgIGlmIChmblZhbHVlc05zIGluIHJ1bGUgfHwgZm5SdWxlTnMgaW4gcnVsZSkgcmV0dXJuIHN0eWxlO1xuICAgICAgdmFyIGZuVmFsdWVzID0ge307XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdmdW5jdGlvbicpIGNvbnRpbnVlO1xuICAgICAgICBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIGZuVmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gICAgICB9IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBydWxlW2ZuVmFsdWVzTnNdID0gZm5WYWx1ZXM7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfSxcbiAgICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoZGF0YSwgcnVsZSwgc2hlZXQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgICAgdmFyIGZuUnVsZSA9IHN0eWxlUnVsZVtmblJ1bGVOc107IC8vIElmIHdlIGhhdmUgYSBzdHlsZSBmdW5jdGlvbiwgdGhlIGVudGlyZSBydWxlIGlzIGR5bmFtaWMgYW5kIHN0eWxlIG9iamVjdFxuICAgICAgLy8gd2lsbCBiZSByZXR1cm5lZCBmcm9tIHRoYXQgZnVuY3Rpb24uXG5cbiAgICAgIGlmIChmblJ1bGUpIHtcbiAgICAgICAgLy8gRW1wdHkgb2JqZWN0IHdpbGwgcmVtb3ZlIGFsbCBjdXJyZW50bHkgZGVmaW5lZCBwcm9wc1xuICAgICAgICAvLyBpbiBjYXNlIGZ1bmN0aW9uIHJ1bGUgcmV0dXJucyBhIGZhbHN5IHZhbHVlLlxuICAgICAgICBzdHlsZVJ1bGUuc3R5bGUgPSBmblJ1bGUoZGF0YSkgfHwge307XG5cbiAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0eWxlUnVsZS5zdHlsZVtwcm9wXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIEZ1bmN0aW9uIHZhbHVlcyBpbnNpZGUgZnVuY3Rpb24gcnVsZXMgYXJlIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZm5WYWx1ZXMgPSBzdHlsZVJ1bGVbZm5WYWx1ZXNOc107IC8vIElmIHdlIGhhdmUgYSBmbiB2YWx1ZXMgbWFwLCBpdCBpcyBhIHJ1bGUgd2l0aCBmdW5jdGlvbiB2YWx1ZXMuXG5cbiAgICAgIGlmIChmblZhbHVlcykge1xuICAgICAgICBmb3IgKHZhciBfcHJvcCBpbiBmblZhbHVlcykge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKF9wcm9wLCBmblZhbHVlc1tfcHJvcF0oZGF0YSksIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBmdW5jdGlvblBsdWdpbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIHZlbmRvciA9IHJlcXVpcmUoJ2Nzcy12ZW5kb3InKTtcbnZhciBqc3MgPSByZXF1aXJlKCdqc3MnKTtcblxuLyoqXG4gKiBBZGQgdmVuZG9yIHByZWZpeCB0byBhIHByb3BlcnR5IG5hbWUgd2hlbiBuZWVkZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBqc3NWZW5kb3JQcmVmaXhlcigpIHtcbiAgZnVuY3Rpb24gb25Qcm9jZXNzUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgIHZhciBhdFJ1bGUgPSBydWxlO1xuICAgICAgYXRSdWxlLmF0ID0gdmVuZG9yLnN1cHBvcnRlZEtleWZyYW1lcyhhdFJ1bGUuYXQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZWZpeFN0eWxlKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBzdHlsZSkge1xuICAgICAgdmFyIHZhbHVlID0gc3R5bGVbcHJvcF07XG5cbiAgICAgIGlmIChwcm9wID09PSAnZmFsbGJhY2tzJyAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBzdHlsZVtwcm9wXSA9IHZhbHVlLm1hcChwcmVmaXhTdHlsZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlUHJvcCA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFByb3AgPSB2ZW5kb3Iuc3VwcG9ydGVkUHJvcGVydHkocHJvcCk7XG4gICAgICBpZiAoc3VwcG9ydGVkUHJvcCAmJiBzdXBwb3J0ZWRQcm9wICE9PSBwcm9wKSBjaGFuZ2VQcm9wID0gdHJ1ZTtcbiAgICAgIHZhciBjaGFuZ2VWYWx1ZSA9IGZhbHNlO1xuICAgICAgdmFyIHN1cHBvcnRlZFZhbHVlID0gdmVuZG9yLnN1cHBvcnRlZFZhbHVlKHN1cHBvcnRlZFByb3AsIGpzcy50b0Nzc1ZhbHVlKHZhbHVlKSk7XG4gICAgICBpZiAoc3VwcG9ydGVkVmFsdWUgJiYgc3VwcG9ydGVkVmFsdWUgIT09IHZhbHVlKSBjaGFuZ2VWYWx1ZSA9IHRydWU7XG5cbiAgICAgIGlmIChjaGFuZ2VQcm9wIHx8IGNoYW5nZVZhbHVlKSB7XG4gICAgICAgIGlmIChjaGFuZ2VQcm9wKSBkZWxldGUgc3R5bGVbcHJvcF07XG4gICAgICAgIHN0eWxlW3N1cHBvcnRlZFByb3AgfHwgcHJvcF0gPSBzdXBwb3J0ZWRWYWx1ZSB8fCB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICBmdW5jdGlvbiBvblByb2Nlc3NTdHlsZShzdHlsZSwgcnVsZSkge1xuICAgIGlmIChydWxlLnR5cGUgIT09ICdzdHlsZScpIHJldHVybiBzdHlsZTtcbiAgICByZXR1cm4gcHJlZml4U3R5bGUoc3R5bGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWx1ZSwgcHJvcCkge1xuICAgIHJldHVybiB2ZW5kb3Iuc3VwcG9ydGVkVmFsdWUocHJvcCwganNzLnRvQ3NzVmFsdWUodmFsdWUpKSB8fCB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgb25Qcm9jZXNzUnVsZTogb25Qcm9jZXNzUnVsZSxcbiAgICBvblByb2Nlc3NTdHlsZTogb25Qcm9jZXNzU3R5bGUsXG4gICAgb25DaGFuZ2VWYWx1ZTogb25DaGFuZ2VWYWx1ZVxuICB9O1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBqc3NWZW5kb3JQcmVmaXhlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0IChleCkgeyByZXR1cm4gKGV4ICYmICh0eXBlb2YgZXggPT09ICdvYmplY3QnKSAmJiAnZGVmYXVsdCcgaW4gZXgpID8gZXhbJ2RlZmF1bHQnXSA6IGV4OyB9XG5cbnZhciBfZXh0ZW5kcyA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2V4dGVuZHMnKSk7XG52YXIgaXNJbkJyb3dzZXIgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnaXMtaW4tYnJvd3NlcicpKTtcbnZhciB3YXJuaW5nID0gX2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3Rpbnktd2FybmluZycpKTtcbnZhciBfY3JlYXRlQ2xhc3MgPSBfaW50ZXJvcERlZmF1bHQocmVxdWlyZSgnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcycpKTtcbnZhciBfaW5oZXJpdHNMb29zZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnKSk7XG52YXIgX2Fzc2VydFRoaXNJbml0aWFsaXplZCA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2Fzc2VydFRoaXNJbml0aWFsaXplZCcpKTtcbnZhciBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSA9IF9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdAYmFiZWwvcnVudGltZS9oZWxwZXJzL29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UnKSk7XG5cbnZhciBwbGFpbk9iamVjdENvbnN0cnVyY3RvciA9IHt9LmNvbnN0cnVjdG9yO1xuZnVuY3Rpb24gY2xvbmVTdHlsZShzdHlsZSkge1xuICBpZiAoc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2Ygc3R5bGUgIT09ICdvYmplY3QnKSByZXR1cm4gc3R5bGU7XG4gIGlmIChBcnJheS5pc0FycmF5KHN0eWxlKSkgcmV0dXJuIHN0eWxlLm1hcChjbG9uZVN0eWxlKTtcbiAgaWYgKHN0eWxlLmNvbnN0cnVjdG9yICE9PSBwbGFpbk9iamVjdENvbnN0cnVyY3RvcikgcmV0dXJuIHN0eWxlO1xuICB2YXIgbmV3U3R5bGUgPSB7fTtcblxuICBmb3IgKHZhciBuYW1lIGluIHN0eWxlKSB7XG4gICAgbmV3U3R5bGVbbmFtZV0gPSBjbG9uZVN0eWxlKHN0eWxlW25hbWVdKTtcbiAgfVxuXG4gIHJldHVybiBuZXdTdHlsZTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBydWxlIGluc3RhbmNlLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICBpZiAobmFtZSA9PT0gdm9pZCAwKSB7XG4gICAgbmFtZSA9ICd1bm5hbWVkJztcbiAgfVxuXG4gIHZhciBqc3MgPSBvcHRpb25zLmpzcztcbiAgdmFyIGRlY2xDb3B5ID0gY2xvbmVTdHlsZShkZWNsKTtcbiAgdmFyIHJ1bGUgPSBqc3MucGx1Z2lucy5vbkNyZWF0ZVJ1bGUobmFtZSwgZGVjbENvcHksIG9wdGlvbnMpO1xuICBpZiAocnVsZSkgcmV0dXJuIHJ1bGU7IC8vIEl0IGlzIGFuIGF0LXJ1bGUgYW5kIGl0IGhhcyBubyBpbnN0YW5jZS5cblxuICBpZiAobmFtZVswXSA9PT0gJ0AnKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gVW5rbm93biBydWxlIFwiICsgbmFtZSkgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGpvaW4gPSBmdW5jdGlvbiBqb2luKHZhbHVlLCBieSkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIC8vIFJlbW92ZSAhaW1wb3J0YW50IGZyb20gdGhlIHZhbHVlLCBpdCB3aWxsIGJlIHJlYWRkZWQgbGF0ZXIuXG4gICAgaWYgKHZhbHVlW2ldID09PSAnIWltcG9ydGFudCcpIGJyZWFrO1xuICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSBieTtcbiAgICByZXN1bHQgKz0gdmFsdWVbaV07XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICogQ29udmVydHMgYXJyYXkgdmFsdWVzIHRvIHN0cmluZy5cbiAqXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddXWAgPiBgbWFyZ2luOiA1cHggMTBweDtgXG4gKiBgYm9yZGVyOiBbJzFweCcsICcycHgnXWAgPiBgYm9yZGVyOiAxcHgsIDJweDtgXG4gKiBgbWFyZ2luOiBbWyc1cHgnLCAnMTBweCddLCAnIWltcG9ydGFudCddYCA+IGBtYXJnaW46IDVweCAxMHB4ICFpbXBvcnRhbnQ7YFxuICogYGNvbG9yOiBbJ3JlZCcsICFpbXBvcnRhbnRdYCA+IGBjb2xvcjogcmVkICFpbXBvcnRhbnQ7YFxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3NWYWx1ZSh2YWx1ZSwgaWdub3JlSW1wb3J0YW50KSB7XG4gIGlmIChpZ25vcmVJbXBvcnRhbnQgPT09IHZvaWQgMCkge1xuICAgIGlnbm9yZUltcG9ydGFudCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICB2YXIgY3NzVmFsdWUgPSAnJzsgLy8gU3VwcG9ydCBzcGFjZSBzZXBhcmF0ZWQgdmFsdWVzIHZpYSBgW1snNXB4JywgJzEwcHgnXV1gLlxuXG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlWzBdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZVtpXSA9PT0gJyFpbXBvcnRhbnQnKSBicmVhaztcbiAgICAgIGlmIChjc3NWYWx1ZSkgY3NzVmFsdWUgKz0gJywgJztcbiAgICAgIGNzc1ZhbHVlICs9IGpvaW4odmFsdWVbaV0sICcgJyk7XG4gICAgfVxuICB9IGVsc2UgY3NzVmFsdWUgPSBqb2luKHZhbHVlLCAnLCAnKTsgLy8gQWRkICFpbXBvcnRhbnQsIGJlY2F1c2UgaXQgd2FzIGlnbm9yZWQuXG5cblxuICBpZiAoIWlnbm9yZUltcG9ydGFudCAmJiB2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSA9PT0gJyFpbXBvcnRhbnQnKSB7XG4gICAgY3NzVmFsdWUgKz0gJyAhaW1wb3J0YW50JztcbiAgfVxuXG4gIHJldHVybiBjc3NWYWx1ZTtcbn1cblxuLyoqXG4gKiBJbmRlbnQgYSBzdHJpbmcuXG4gKiBodHRwOi8vanNwZXJmLmNvbS9hcnJheS1qb2luLXZzLWZvclxuICovXG5mdW5jdGlvbiBpbmRlbnRTdHIoc3RyLCBpbmRlbnQpIHtcbiAgdmFyIHJlc3VsdCA9ICcnO1xuXG4gIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBpbmRlbnQ7IGluZGV4KyspIHtcbiAgICByZXN1bHQgKz0gJyAgJztcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgKyBzdHI7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgUnVsZSB0byBDU1Mgc3RyaW5nLlxuICovXG5cblxuZnVuY3Rpb24gdG9Dc3Moc2VsZWN0b3IsIHN0eWxlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICghc3R5bGUpIHJldHVybiByZXN1bHQ7XG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRpbmRlbnQgPSBfb3B0aW9ucy5pbmRlbnQsXG4gICAgICBpbmRlbnQgPSBfb3B0aW9ucyRpbmRlbnQgPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRpbmRlbnQ7XG4gIHZhciBmYWxsYmFja3MgPSBzdHlsZS5mYWxsYmFja3M7XG4gIGlmIChzZWxlY3RvcikgaW5kZW50Kys7IC8vIEFwcGx5IGZhbGxiYWNrcyBmaXJzdC5cblxuICBpZiAoZmFsbGJhY2tzKSB7XG4gICAgLy8gQXJyYXkgc3ludGF4IHtmYWxsYmFja3M6IFt7cHJvcDogdmFsdWV9XX1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShmYWxsYmFja3MpKSB7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgZmFsbGJhY2tzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgZmFsbGJhY2sgPSBmYWxsYmFja3NbaW5kZXhdO1xuXG4gICAgICAgIGZvciAodmFyIHByb3AgaW4gZmFsbGJhY2spIHtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBmYWxsYmFja1twcm9wXTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihwcm9wICsgXCI6IFwiICsgdG9Dc3NWYWx1ZSh2YWx1ZSkgKyBcIjtcIiwgaW5kZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT2JqZWN0IHN5bnRheCB7ZmFsbGJhY2tzOiB7cHJvcDogdmFsdWV9fVxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gZmFsbGJhY2tzKSB7XG4gICAgICAgIHZhciBfdmFsdWUgPSBmYWxsYmFja3NbX3Byb3BdO1xuXG4gICAgICAgIGlmIChfdmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXN1bHQpIHJlc3VsdCArPSAnXFxuJztcbiAgICAgICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihfcHJvcCArIFwiOiBcIiArIHRvQ3NzVmFsdWUoX3ZhbHVlKSArIFwiO1wiLCBpbmRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgX3Byb3AyIGluIHN0eWxlKSB7XG4gICAgdmFyIF92YWx1ZTIgPSBzdHlsZVtfcHJvcDJdO1xuXG4gICAgaWYgKF92YWx1ZTIgIT0gbnVsbCAmJiBfcHJvcDIgIT09ICdmYWxsYmFja3MnKSB7XG4gICAgICBpZiAocmVzdWx0KSByZXN1bHQgKz0gJ1xcbic7XG4gICAgICByZXN1bHQgKz0gXCJcIiArIGluZGVudFN0cihfcHJvcDIgKyBcIjogXCIgKyB0b0Nzc1ZhbHVlKF92YWx1ZTIpICsgXCI7XCIsIGluZGVudCk7XG4gICAgfVxuICB9IC8vIEFsbG93IGVtcHR5IHN0eWxlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYWRkZWQgZHluYW1pY2FsbHkuXG5cblxuICBpZiAoIXJlc3VsdCAmJiAhb3B0aW9ucy5hbGxvd0VtcHR5KSByZXR1cm4gcmVzdWx0OyAvLyBXaGVuIHJ1bGUgaXMgYmVpbmcgc3RyaW5naWZpZWQgYmVmb3JlIHNlbGVjdG9yIHdhcyBkZWZpbmVkLlxuXG4gIGlmICghc2VsZWN0b3IpIHJldHVybiByZXN1bHQ7XG4gIGluZGVudC0tO1xuICBpZiAocmVzdWx0KSByZXN1bHQgPSBcIlxcblwiICsgcmVzdWx0ICsgXCJcXG5cIjtcbiAgcmV0dXJuIGluZGVudFN0cihzZWxlY3RvciArIFwiIHtcIiArIHJlc3VsdCwgaW5kZW50KSArIGluZGVudFN0cignfScsIGluZGVudCk7XG59XG5cbnZhciBlc2NhcGVSZWdleCA9IC8oW1tcXF0uIyokPjwrfj18XjooKSxcIidgXFxzXSkvZztcbnZhciBuYXRpdmVFc2NhcGUgPSB0eXBlb2YgQ1NTICE9PSAndW5kZWZpbmVkJyAmJiBDU1MuZXNjYXBlO1xudmFyIGVzY2FwZSA9IChmdW5jdGlvbiAoc3RyKSB7XG4gIHJldHVybiBuYXRpdmVFc2NhcGUgPyBuYXRpdmVFc2NhcGUoc3RyKSA6IHN0ci5yZXBsYWNlKGVzY2FwZVJlZ2V4LCAnXFxcXCQxJyk7XG59KTtcblxudmFyIEJhc2VTdHlsZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnN0eWxlID0gdm9pZCAwO1xuICAgIHRoaXMucmVuZGVyZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5yZW5kZXJhYmxlID0gdm9pZCAwO1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB2YXIgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBSZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgaWYgKHNoZWV0KSB0aGlzLnJlbmRlcmVyID0gc2hlZXQucmVuZGVyZXI7ZWxzZSBpZiAoUmVuZGVyZXIpIHRoaXMucmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IG9yIHNldCBhIHN0eWxlIHByb3BlcnR5LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBCYXNlU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8ucHJvcCA9IGZ1bmN0aW9uIHByb3AobmFtZSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICAvLyBJdCdzIGEgZ2V0dGVyLlxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5zdHlsZVtuYW1lXTsgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cblxuICAgIHZhciBmb3JjZSA9IG9wdGlvbnMgPyBvcHRpb25zLmZvcmNlIDogZmFsc2U7XG4gICAgaWYgKCFmb3JjZSAmJiB0aGlzLnN0eWxlW25hbWVdID09PSB2YWx1ZSkgcmV0dXJuIHRoaXM7XG4gICAgdmFyIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICBpZiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5wcm9jZXNzICE9PSBmYWxzZSkge1xuICAgICAgbmV3VmFsdWUgPSB0aGlzLm9wdGlvbnMuanNzLnBsdWdpbnMub25DaGFuZ2VWYWx1ZSh2YWx1ZSwgbmFtZSwgdGhpcyk7XG4gICAgfVxuXG4gICAgdmFyIGlzRW1wdHkgPSBuZXdWYWx1ZSA9PSBudWxsIHx8IG5ld1ZhbHVlID09PSBmYWxzZTtcbiAgICB2YXIgaXNEZWZpbmVkID0gbmFtZSBpbiB0aGlzLnN0eWxlOyAvLyBWYWx1ZSBpcyBlbXB0eSBhbmQgd2Fzbid0IGRlZmluZWQgYmVmb3JlLlxuXG4gICAgaWYgKGlzRW1wdHkgJiYgIWlzRGVmaW5lZCAmJiAhZm9yY2UpIHJldHVybiB0aGlzOyAvLyBXZSBhcmUgZ29pbmcgdG8gcmVtb3ZlIHRoaXMgdmFsdWUuXG5cbiAgICB2YXIgcmVtb3ZlID0gaXNFbXB0eSAmJiBpc0RlZmluZWQ7XG4gICAgaWYgKHJlbW92ZSkgZGVsZXRlIHRoaXMuc3R5bGVbbmFtZV07ZWxzZSB0aGlzLnN0eWxlW25hbWVdID0gbmV3VmFsdWU7IC8vIFJlbmRlcmFibGUgaXMgZGVmaW5lZCBpZiBTdHlsZVNoZWV0IG9wdGlvbiBgbGlua2AgaXMgdHJ1ZS5cblxuICAgIGlmICh0aGlzLnJlbmRlcmFibGUgJiYgdGhpcy5yZW5kZXJlcikge1xuICAgICAgaWYgKHJlbW92ZSkgdGhpcy5yZW5kZXJlci5yZW1vdmVQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUpO2Vsc2UgdGhpcy5yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLnJlbmRlcmFibGUsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcblxuICAgIGlmIChzaGVldCAmJiBzaGVldC5hdHRhY2hlZCkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsICdbSlNTXSBSdWxlIGlzIG5vdCBsaW5rZWQuIE1pc3Npbmcgc2hlZXQgb3B0aW9uIFwibGluazogdHJ1ZVwiLicpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBCYXNlU3R5bGVSdWxlO1xufSgpO1xudmFyIFN0eWxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2VTdHlsZVJ1bGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoU3R5bGVSdWxlLCBfQmFzZVN0eWxlUnVsZSk7XG5cbiAgZnVuY3Rpb24gU3R5bGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlU3R5bGVSdWxlLmNhbGwodGhpcywga2V5LCBzdHlsZSwgb3B0aW9ucykgfHwgdGhpcztcbiAgICBfdGhpcy5zZWxlY3RvclRleHQgPSB2b2lkIDA7XG4gICAgX3RoaXMuaWQgPSB2b2lkIDA7XG4gICAgX3RoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB2YXIgc2VsZWN0b3IgPSBvcHRpb25zLnNlbGVjdG9yLFxuICAgICAgICBzY29wZWQgPSBvcHRpb25zLnNjb3BlZCxcbiAgICAgICAgc2hlZXQgPSBvcHRpb25zLnNoZWV0LFxuICAgICAgICBnZW5lcmF0ZUlkID0gb3B0aW9ucy5nZW5lcmF0ZUlkO1xuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBfdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICB9IGVsc2UgaWYgKHNjb3BlZCAhPT0gZmFsc2UpIHtcbiAgICAgIF90aGlzLmlkID0gZ2VuZXJhdGVJZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKSwgc2hlZXQpO1xuICAgICAgX3RoaXMuc2VsZWN0b3JUZXh0ID0gXCIuXCIgKyBlc2NhcGUoX3RoaXMuaWQpO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogU2V0IHNlbGVjdG9yIHN0cmluZy5cbiAgICogQXR0ZW50aW9uOiB1c2UgdGhpcyB3aXRoIGNhdXRpb24uIE1vc3QgYnJvd3NlcnMgZGlkbid0IGltcGxlbWVudFxuICAgKiBzZWxlY3RvclRleHQgc2V0dGVyLCBzbyB0aGlzIG1heSByZXN1bHQgaW4gcmVyZW5kZXJpbmcgb2YgZW50aXJlIFN0eWxlIFNoZWV0LlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8yID0gU3R5bGVSdWxlLnByb3RvdHlwZTtcblxuICAvKipcbiAgICogQXBwbHkgcnVsZSB0byBhbiBlbGVtZW50IGlubGluZS5cbiAgICovXG4gIF9wcm90bzIuYXBwbHlUbyA9IGZ1bmN0aW9uIGFwcGx5VG8ocmVuZGVyYWJsZSkge1xuICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXI7XG5cbiAgICBpZiAocmVuZGVyZXIpIHtcbiAgICAgIHZhciBqc29uID0gdGhpcy50b0pTT04oKTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBqc29uKSB7XG4gICAgICAgIHJlbmRlcmVyLnNldFByb3BlcnR5KHJlbmRlcmFibGUsIHByb3AsIGpzb25bcHJvcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIHJ1bGUuXG4gICAqIEZhbGxiYWNrcyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgICogVXNlZnVsIGZvciBpbmxpbmUgc3R5bGVzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90bzIudG9KU09OID0gZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHZhciBqc29uID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMuc3R5bGUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuc3R5bGVbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JykganNvbltwcm9wXSA9IHZhbHVlO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBqc29uW3Byb3BdID0gdG9Dc3NWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGpzb247XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvMi50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKG9wdGlvbnMpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLm9wdGlvbnMuc2hlZXQ7XG4gICAgdmFyIGxpbmsgPSBzaGVldCA/IHNoZWV0Lm9wdGlvbnMubGluayA6IGZhbHNlO1xuICAgIHZhciBvcHRzID0gbGluayA/IF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBhbGxvd0VtcHR5OiB0cnVlXG4gICAgfSkgOiBvcHRpb25zO1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLnNlbGVjdG9yVGV4dCwgdGhpcy5zdHlsZSwgb3B0cyk7XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFN0eWxlUnVsZSwgW3tcbiAgICBrZXk6IFwic2VsZWN0b3JcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChzZWxlY3Rvcikge1xuICAgICAgaWYgKHNlbGVjdG9yID09PSB0aGlzLnNlbGVjdG9yVGV4dCkgcmV0dXJuO1xuICAgICAgdGhpcy5zZWxlY3RvclRleHQgPSBzZWxlY3RvcjtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMucmVuZGVyZXIsXG4gICAgICAgICAgcmVuZGVyYWJsZSA9IHRoaXMucmVuZGVyYWJsZTtcbiAgICAgIGlmICghcmVuZGVyYWJsZSB8fCAhcmVuZGVyZXIpIHJldHVybjtcbiAgICAgIHZhciBoYXNDaGFuZ2VkID0gcmVuZGVyZXIuc2V0U2VsZWN0b3IocmVuZGVyYWJsZSwgc2VsZWN0b3IpOyAvLyBJZiBzZWxlY3RvciBzZXR0ZXIgaXMgbm90IGltcGxlbWVudGVkLCByZXJlbmRlciB0aGUgcnVsZS5cblxuICAgICAgaWYgKCFoYXNDaGFuZ2VkKSB7XG4gICAgICAgIHJlbmRlcmVyLnJlcGxhY2VSdWxlKHJlbmRlcmFibGUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgc2VsZWN0b3Igc3RyaW5nLlxuICAgICAqL1xuICAgICxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnNlbGVjdG9yVGV4dDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3R5bGVSdWxlO1xufShCYXNlU3R5bGVSdWxlKTtcbnZhciBwbHVnaW5TdHlsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKG5hbWUsIHN0eWxlLCBvcHRpb25zKSB7XG4gICAgaWYgKG5hbWVbMF0gPT09ICdAJyB8fCBvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBTdHlsZVJ1bGUobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICB9XG59O1xuXG52YXIgZGVmYXVsdFRvU3RyaW5nT3B0aW9ucyA9IHtcbiAgaW5kZW50OiAxLFxuICBjaGlsZHJlbjogdHJ1ZVxufTtcbnZhciBhdFJlZ0V4cCA9IC9AKFtcXHctXSspLztcbi8qKlxuICogQ29uZGl0aW9uYWwgcnVsZSBmb3IgQG1lZGlhLCBAc3VwcG9ydHNcbiAqL1xuXG52YXIgQ29uZGl0aW9uYWxSdWxlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgdGhpcy50eXBlID0gJ2NvbmRpdGlvbmFsJztcbiAgICB0aGlzLmF0ID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMucXVlcnkgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTsgLy8gS2V5IG1pZ2h0IGNvbnRhaW4gYSB1bmlxdWUgc3VmZml4IGluIGNhc2UgdGhlIGBuYW1lYCBwYXNzZWQgYnkgdXNlciB3YXMgZHVwbGljYXRlLlxuXG4gICAgdGhpcy5xdWVyeSA9IG9wdGlvbnMubmFtZTtcbiAgICB2YXIgYXRNYXRjaCA9IGtleS5tYXRjaChhdFJlZ0V4cCk7XG4gICAgdGhpcy5hdCA9IGF0TWF0Y2ggPyBhdE1hdGNoWzFdIDogJ3Vua25vd24nO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5ydWxlcyA9IG5ldyBSdWxlTGlzdChfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgcGFyZW50OiB0aGlzXG4gICAgfSkpO1xuXG4gICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZXMpIHtcbiAgICAgIHRoaXMucnVsZXMuYWRkKG5hbWUsIHN0eWxlc1tuYW1lXSk7XG4gICAgfVxuXG4gICAgdGhpcy5ydWxlcy5wcm9jZXNzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IENvbmRpdGlvbmFsUnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUsIHJ1biBwbHVnaW5zLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5hZGRSdWxlID0gZnVuY3Rpb24gYWRkUnVsZShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHZhciBydWxlID0gdGhpcy5ydWxlcy5hZGQobmFtZSwgc3R5bGUsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmluZGVudCA9PSBudWxsKSBvcHRpb25zLmluZGVudCA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zLmNoaWxkcmVuO1xuXG4gICAgaWYgKG9wdGlvbnMuY2hpbGRyZW4gPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeSArIFwiIHt9XCI7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5ydWxlcy50b1N0cmluZyhvcHRpb25zKTtcbiAgICByZXR1cm4gY2hpbGRyZW4gPyB0aGlzLnF1ZXJ5ICsgXCIge1xcblwiICsgY2hpbGRyZW4gKyBcIlxcbn1cIiA6ICcnO1xuICB9O1xuXG4gIHJldHVybiBDb25kaXRpb25hbFJ1bGU7XG59KCk7XG52YXIga2V5UmVnRXhwID0gL0BtZWRpYXxAc3VwcG9ydHNcXHMrLztcbnZhciBwbHVnaW5Db25kaXRpb25hbFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGtleVJlZ0V4cC50ZXN0KGtleSkgPyBuZXcgQ29uZGl0aW9uYWxSdWxlKGtleSwgc3R5bGVzLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEgPSB7XG4gIGluZGVudDogMSxcbiAgY2hpbGRyZW46IHRydWVcbn07XG52YXIgbmFtZVJlZ0V4cCA9IC9Aa2V5ZnJhbWVzXFxzKyhbXFx3LV0rKS87XG4vKipcbiAqIFJ1bGUgZm9yIEBrZXlmcmFtZXNcbiAqL1xuXG52YXIgS2V5ZnJhbWVzUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnR5cGUgPSAna2V5ZnJhbWVzJztcbiAgICB0aGlzLmF0ID0gJ0BrZXlmcmFtZXMnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlkID0gdm9pZCAwO1xuICAgIHRoaXMucnVsZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdmFyIG5hbWVNYXRjaCA9IGtleS5tYXRjaChuYW1lUmVnRXhwKTtcblxuICAgIGlmIChuYW1lTWF0Y2ggJiYgbmFtZU1hdGNoWzFdKSB7XG4gICAgICB0aGlzLm5hbWUgPSBuYW1lTWF0Y2hbMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmFtZSA9ICdub25hbWUnO1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gQmFkIGtleWZyYW1lcyBuYW1lIFwiICsga2V5KSA6IHZvaWQgMDtcbiAgICB9XG5cbiAgICB0aGlzLmtleSA9IHRoaXMudHlwZSArIFwiLVwiICsgdGhpcy5uYW1lO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIHNjb3BlZCA9IG9wdGlvbnMuc2NvcGVkLFxuICAgICAgICBzaGVldCA9IG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBvcHRpb25zLmdlbmVyYXRlSWQ7XG4gICAgdGhpcy5pZCA9IHNjb3BlZCA9PT0gZmFsc2UgPyB0aGlzLm5hbWUgOiBlc2NhcGUoZ2VuZXJhdGVJZCh0aGlzLCBzaGVldCkpO1xuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogdGhpc1xuICAgIH0pKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gZnJhbWVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBmcmFtZXNbbmFtZV0sIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHBhcmVudDogdGhpc1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBDU1Mgc3RyaW5nLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBLZXlmcmFtZXNSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRUb1N0cmluZ09wdGlvbnMkMTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5pbmRlbnQgPT0gbnVsbCkgb3B0aW9ucy5pbmRlbnQgPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuaW5kZW50O1xuICAgIGlmIChvcHRpb25zLmNoaWxkcmVuID09IG51bGwpIG9wdGlvbnMuY2hpbGRyZW4gPSBkZWZhdWx0VG9TdHJpbmdPcHRpb25zJDEuY2hpbGRyZW47XG5cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge31cIjtcbiAgICB9XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnJ1bGVzLnRvU3RyaW5nKG9wdGlvbnMpO1xuICAgIGlmIChjaGlsZHJlbikgY2hpbGRyZW4gPSBcIlxcblwiICsgY2hpbGRyZW4gKyBcIlxcblwiO1xuICAgIHJldHVybiB0aGlzLmF0ICsgXCIgXCIgKyB0aGlzLmlkICsgXCIge1wiICsgY2hpbGRyZW4gKyBcIn1cIjtcbiAgfTtcblxuICByZXR1cm4gS2V5ZnJhbWVzUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMSA9IC9Aa2V5ZnJhbWVzXFxzKy87XG52YXIgcmVmUmVnRXhwID0gL1xcJChbXFx3LV0rKS9nO1xuXG52YXIgZmluZFJlZmVyZW5jZWRLZXlmcmFtZSA9IGZ1bmN0aW9uIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBrZXlmcmFtZXMpIHtcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbC5yZXBsYWNlKHJlZlJlZ0V4cCwgZnVuY3Rpb24gKG1hdGNoLCBuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiBrZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lc1tuYW1lXTtcbiAgICAgIH1cblxuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gUmVmZXJlbmNlZCBrZXlmcmFtZXMgcnVsZSBcXFwiXCIgKyBuYW1lICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkLlwiKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59O1xuLyoqXG4gKiBSZXBsYWNlIHRoZSByZWZlcmVuY2UgZm9yIGEgYW5pbWF0aW9uIG5hbWUuXG4gKi9cblxuXG52YXIgcmVwbGFjZVJlZiA9IGZ1bmN0aW9uIHJlcGxhY2VSZWYoc3R5bGUsIHByb3AsIGtleWZyYW1lcykge1xuICB2YXIgdmFsdWUgPSBzdHlsZVtwcm9wXTtcbiAgdmFyIHJlZktleWZyYW1lID0gZmluZFJlZmVyZW5jZWRLZXlmcmFtZSh2YWx1ZSwga2V5ZnJhbWVzKTtcblxuICBpZiAocmVmS2V5ZnJhbWUgIT09IHZhbHVlKSB7XG4gICAgc3R5bGVbcHJvcF0gPSByZWZLZXlmcmFtZTtcbiAgfVxufTtcblxudmFyIHBsdWdpbiA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYga2V5UmVnRXhwJDEudGVzdChrZXkpID8gbmV3IEtleWZyYW1lc1J1bGUoa2V5LCBmcmFtZXMsIG9wdGlvbnMpIDogbnVsbDtcbiAgfSxcbiAgLy8gQW5pbWF0aW9uIG5hbWUgcmVmIHJlcGxhY2VyLlxuICBvblByb2Nlc3NTdHlsZTogZnVuY3Rpb24gb25Qcm9jZXNzU3R5bGUoc3R5bGUsIHJ1bGUsIHNoZWV0KSB7XG4gICAgaWYgKHJ1bGUudHlwZSAhPT0gJ3N0eWxlJyB8fCAhc2hlZXQpIHJldHVybiBzdHlsZTtcbiAgICBpZiAoJ2FuaW1hdGlvbi1uYW1lJyBpbiBzdHlsZSkgcmVwbGFjZVJlZihzdHlsZSwgJ2FuaW1hdGlvbi1uYW1lJywgc2hlZXQua2V5ZnJhbWVzKTtcbiAgICBpZiAoJ2FuaW1hdGlvbicgaW4gc3R5bGUpIHJlcGxhY2VSZWYoc3R5bGUsICdhbmltYXRpb24nLCBzaGVldC5rZXlmcmFtZXMpO1xuICAgIHJldHVybiBzdHlsZTtcbiAgfSxcbiAgb25DaGFuZ2VWYWx1ZTogZnVuY3Rpb24gb25DaGFuZ2VWYWx1ZSh2YWwsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgc2hlZXQgPSBydWxlLm9wdGlvbnMuc2hlZXQ7XG5cbiAgICBpZiAoIXNoZWV0KSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cblxuICAgIHN3aXRjaCAocHJvcCkge1xuICAgICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICAgICAgcmV0dXJuIGZpbmRSZWZlcmVuY2VkS2V5ZnJhbWUodmFsLCBzaGVldC5rZXlmcmFtZXMpO1xuXG4gICAgICBjYXNlICdhbmltYXRpb24tbmFtZSc6XG4gICAgICAgIHJldHVybiBmaW5kUmVmZXJlbmNlZEtleWZyYW1lKHZhbCwgc2hlZXQua2V5ZnJhbWVzKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBLZXlmcmFtZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlU3R5bGVSdWxlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEtleWZyYW1lUnVsZSwgX0Jhc2VTdHlsZVJ1bGUpO1xuXG4gIGZ1bmN0aW9uIEtleWZyYW1lUnVsZSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgX3RoaXMgPSBfQmFzZVN0eWxlUnVsZS5jYWxsLmFwcGx5KF9CYXNlU3R5bGVSdWxlLCBbdGhpc10uY29uY2F0KGFyZ3MpKSB8fCB0aGlzO1xuICAgIF90aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEtleWZyYW1lUnVsZS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHNoZWV0ID0gdGhpcy5vcHRpb25zLnNoZWV0O1xuICAgIHZhciBsaW5rID0gc2hlZXQgPyBzaGVldC5vcHRpb25zLmxpbmsgOiBmYWxzZTtcbiAgICB2YXIgb3B0cyA9IGxpbmsgPyBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgYWxsb3dFbXB0eTogdHJ1ZVxuICAgIH0pIDogb3B0aW9ucztcbiAgICByZXR1cm4gdG9Dc3ModGhpcy5rZXksIHRoaXMuc3R5bGUsIG9wdHMpO1xuICB9O1xuXG4gIHJldHVybiBLZXlmcmFtZVJ1bGU7XG59KEJhc2VTdHlsZVJ1bGUpO1xudmFyIHBsdWdpbktleWZyYW1lUnVsZSA9IHtcbiAgb25DcmVhdGVSdWxlOiBmdW5jdGlvbiBvbkNyZWF0ZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnBhcmVudCAmJiBvcHRpb25zLnBhcmVudC50eXBlID09PSAna2V5ZnJhbWVzJykge1xuICAgICAgcmV0dXJuIG5ldyBLZXlmcmFtZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbnZhciBGb250RmFjZVJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZVJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdmb250LWZhY2UnO1xuICAgIHRoaXMuYXQgPSAnQGZvbnQtZmFjZSc7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdHlsZSA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1Byb2Nlc3NlZCA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyYWJsZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGU7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIGEgQ1NTIHN0cmluZy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gRm9udEZhY2VSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5zdHlsZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3R5bGUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0b0Nzcyh0aGlzLmF0LCB0aGlzLnN0eWxlW2luZGV4XSk7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlW2luZGV4ICsgMV0pIHN0ciArPSAnXFxuJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG5cbiAgICByZXR1cm4gdG9Dc3ModGhpcy5hdCwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIEZvbnRGYWNlUnVsZTtcbn0oKTtcbnZhciBrZXlSZWdFeHAkMiA9IC9AZm9udC1mYWNlLztcbnZhciBwbHVnaW5Gb250RmFjZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5UmVnRXhwJDIudGVzdChrZXkpID8gbmV3IEZvbnRGYWNlUnVsZShrZXksIHN0eWxlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBWaWV3cG9ydFJ1bGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICd2aWV3cG9ydCc7XG4gICAgdGhpcy5hdCA9ICdAdmlld3BvcnQnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3R5bGUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFZpZXdwb3J0UnVsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiB0b0Nzcyh0aGlzLmtleSwgdGhpcy5zdHlsZSwgb3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFZpZXdwb3J0UnVsZTtcbn0oKTtcbnZhciBwbHVnaW5WaWV3cG9ydFJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgc3R5bGUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5ID09PSAnQHZpZXdwb3J0JyB8fCBrZXkgPT09ICdALW1zLXZpZXdwb3J0JyA/IG5ldyBWaWV3cG9ydFJ1bGUoa2V5LCBzdHlsZSwgb3B0aW9ucykgOiBudWxsO1xuICB9XG59O1xuXG52YXIgU2ltcGxlUnVsZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZVJ1bGUoa2V5LCB2YWx1ZSwgb3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9ICdzaW1wbGUnO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaXNQcm9jZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmFibGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIENTUyBzdHJpbmcuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcblxuXG4gIHZhciBfcHJvdG8gPSBTaW1wbGVSdWxlLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy52YWx1ZSkpIHtcbiAgICAgIHZhciBzdHIgPSAnJztcblxuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMudmFsdWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHN0ciArPSB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZVtpbmRleF0gKyBcIjtcIjtcbiAgICAgICAgaWYgKHRoaXMudmFsdWVbaW5kZXggKyAxXSkgc3RyICs9ICdcXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmtleSArIFwiIFwiICsgdGhpcy52YWx1ZSArIFwiO1wiO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVSdWxlO1xufSgpO1xudmFyIGtleXNNYXAgPSB7XG4gICdAY2hhcnNldCc6IHRydWUsXG4gICdAaW1wb3J0JzogdHJ1ZSxcbiAgJ0BuYW1lc3BhY2UnOiB0cnVlXG59O1xudmFyIHBsdWdpblNpbXBsZVJ1bGUgPSB7XG4gIG9uQ3JlYXRlUnVsZTogZnVuY3Rpb24gb25DcmVhdGVSdWxlKGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4ga2V5IGluIGtleXNNYXAgPyBuZXcgU2ltcGxlUnVsZShrZXksIHZhbHVlLCBvcHRpb25zKSA6IG51bGw7XG4gIH1cbn07XG5cbnZhciBwbHVnaW5zID0gW3BsdWdpblN0eWxlUnVsZSwgcGx1Z2luQ29uZGl0aW9uYWxSdWxlLCBwbHVnaW4sIHBsdWdpbktleWZyYW1lUnVsZSwgcGx1Z2luRm9udEZhY2VSdWxlLCBwbHVnaW5WaWV3cG9ydFJ1bGUsIHBsdWdpblNpbXBsZVJ1bGVdO1xuXG52YXIgZGVmYXVsdFVwZGF0ZU9wdGlvbnMgPSB7XG4gIHByb2Nlc3M6IHRydWVcbn07XG52YXIgZm9yY2VVcGRhdGVPcHRpb25zID0ge1xuICBmb3JjZTogdHJ1ZSxcbiAgcHJvY2VzczogdHJ1ZVxuICAvKipcbiAgICogQ29udGFpbnMgcnVsZXMgb2JqZWN0cyBhbmQgYWxsb3dzIGFkZGluZy9yZW1vdmluZyBldGMuXG4gICAqIElzIHVzZWQgZm9yIGUuZy4gYnkgYFN0eWxlU2hlZXRgIG9yIGBDb25kaXRpb25hbFJ1bGVgLlxuICAgKi9cblxufTtcblxudmFyIFJ1bGVMaXN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgLy8gUnVsZXMgcmVnaXN0cnkgZm9yIGFjY2VzcyBieSAuZ2V0KCkgbWV0aG9kLlxuICAvLyBJdCBjb250YWlucyB0aGUgc2FtZSBydWxlIHJlZ2lzdGVyZWQgYnkgbmFtZSBhbmQgYnkgc2VsZWN0b3IuXG4gIC8vIE9yaWdpbmFsIHN0eWxlcyBvYmplY3QuXG4gIC8vIFVzZWQgdG8gZW5zdXJlIGNvcnJlY3QgcnVsZXMgb3JkZXIuXG4gIGZ1bmN0aW9uIFJ1bGVMaXN0KG9wdGlvbnMpIHtcbiAgICB0aGlzLm1hcCA9IHt9O1xuICAgIHRoaXMucmF3ID0ge307XG4gICAgdGhpcy5pbmRleCA9IFtdO1xuICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgdGhpcy5vcHRpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHZvaWQgMDtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuY2xhc3NlcyA9IG9wdGlvbnMuY2xhc3NlcztcbiAgICB0aGlzLmtleWZyYW1lcyA9IG9wdGlvbnMua2V5ZnJhbWVzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW5kIHJlZ2lzdGVyIHJ1bGUuXG4gICAqXG4gICAqIFdpbGwgbm90IHJlbmRlciBhZnRlciBTdHlsZSBTaGVldCB3YXMgcmVuZGVyZWQgdGhlIGZpcnN0IHRpbWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFJ1bGVMaXN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkID0gZnVuY3Rpb24gYWRkKG5hbWUsIGRlY2wsIHJ1bGVPcHRpb25zKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXG4gICAgICAgIHBhcmVudCA9IF90aGlzJG9wdGlvbnMucGFyZW50LFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMuc2hlZXQsXG4gICAgICAgIGpzcyA9IF90aGlzJG9wdGlvbnMuanNzLFxuICAgICAgICBSZW5kZXJlciA9IF90aGlzJG9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICAgIGdlbmVyYXRlSWQgPSBfdGhpcyRvcHRpb25zLmdlbmVyYXRlSWQsXG4gICAgICAgIHNjb3BlZCA9IF90aGlzJG9wdGlvbnMuc2NvcGVkO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBfZXh0ZW5kcyh7XG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICAgIHNoZWV0OiBzaGVldCxcbiAgICAgIGpzczoganNzLFxuICAgICAgUmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZCxcbiAgICAgIHNjb3BlZDogc2NvcGVkLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0sIHJ1bGVPcHRpb25zKTsgLy8gV2hlbiB1c2VyIHVzZXMgLmNyZWF0ZVN0eWxlU2hlZXQoKSwgZHVwbGljYXRlIG5hbWVzIGFyZSBub3QgcG9zc2libGUsIGJ1dFxuICAgIC8vIGBzaGVldC5hZGRSdWxlKClgIG9wZW5zIHRoZSBkb29yIGZvciBhbnkgZHVwbGljYXRlIHJ1bGUgbmFtZS4gV2hlbiB0aGlzIGhhcHBlbnNcbiAgICAvLyB3ZSBuZWVkIHRvIG1ha2UgdGhlIGtleSB1bmlxdWUgd2l0aGluIHRoaXMgUnVsZUxpc3QgaW5zdGFuY2Ugc2NvcGUuXG5cblxuICAgIHZhciBrZXkgPSBuYW1lO1xuXG4gICAgaWYgKG5hbWUgaW4gdGhpcy5yYXcpIHtcbiAgICAgIGtleSA9IG5hbWUgKyBcIi1kXCIgKyB0aGlzLmNvdW50ZXIrKztcbiAgICB9IC8vIFdlIG5lZWQgdG8gc2F2ZSB0aGUgb3JpZ2luYWwgZGVjbCBiZWZvcmUgY3JlYXRpbmcgdGhlIHJ1bGVcbiAgICAvLyBiZWNhdXNlIGNhY2hlIHBsdWdpbiBuZWVkcyB0byB1c2UgaXQgYXMgYSBrZXkgdG8gcmV0dXJuIGEgY2FjaGVkIHJ1bGUuXG5cblxuICAgIHRoaXMucmF3W2tleV0gPSBkZWNsO1xuXG4gICAgaWYgKGtleSBpbiB0aGlzLmNsYXNzZXMpIHtcbiAgICAgIC8vIEUuZy4gcnVsZXMgaW5zaWRlIG9mIEBtZWRpYSBjb250YWluZXJcbiAgICAgIG9wdGlvbnMuc2VsZWN0b3IgPSBcIi5cIiArIGVzY2FwZSh0aGlzLmNsYXNzZXNba2V5XSk7XG4gICAgfVxuXG4gICAgdmFyIHJ1bGUgPSBjcmVhdGVSdWxlKGtleSwgZGVjbCwgb3B0aW9ucyk7XG4gICAgaWYgKCFydWxlKSByZXR1cm4gbnVsbDtcbiAgICB0aGlzLnJlZ2lzdGVyKHJ1bGUpO1xuICAgIHZhciBpbmRleCA9IG9wdGlvbnMuaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMuaW5kZXgubGVuZ3RoIDogb3B0aW9ucy5pbmRleDtcbiAgICB0aGlzLmluZGV4LnNwbGljZShpbmRleCwgMCwgcnVsZSk7XG4gICAgcmV0dXJuIHJ1bGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMubWFwW25hbWVdO1xuICB9XG4gIC8qKlxuICAgKiBEZWxldGUgYSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUocnVsZSkge1xuICAgIHRoaXMudW5yZWdpc3RlcihydWxlKTtcbiAgICBkZWxldGUgdGhpcy5yYXdbcnVsZS5rZXldO1xuICAgIHRoaXMuaW5kZXguc3BsaWNlKHRoaXMuaW5kZXguaW5kZXhPZihydWxlKSwgMSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleC5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBSdW4gYG9uUHJvY2Vzc1J1bGUoKWAgcGx1Z2lucyBvbiBldmVyeSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5wcm9jZXNzID0gZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICB2YXIgcGx1Z2lucyA9IHRoaXMub3B0aW9ucy5qc3MucGx1Z2luczsgLy8gV2UgbmVlZCB0byBjbG9uZSBhcnJheSBiZWNhdXNlIGlmIHdlIG1vZGlmeSB0aGUgaW5kZXggc29tZXdoZXJlIGVsc2UgZHVyaW5nIGEgbG9vcFxuICAgIC8vIHdlIGVuZCB1cCB3aXRoIHZlcnkgaGFyZC10by10cmFjay1kb3duIHNpZGUgZWZmZWN0cy5cblxuICAgIHRoaXMuaW5kZXguc2xpY2UoMCkuZm9yRWFjaChwbHVnaW5zLm9uUHJvY2Vzc1J1bGUsIHBsdWdpbnMpO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHJ1bGUgaW4gYC5tYXBgLCBgLmNsYXNzZXNgIGFuZCBgLmtleWZyYW1lc2AgbWFwcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVnaXN0ZXIgPSBmdW5jdGlvbiByZWdpc3RlcihydWxlKSB7XG4gICAgdGhpcy5tYXBbcnVsZS5rZXldID0gcnVsZTtcblxuICAgIGlmIChydWxlIGluc3RhbmNlb2YgU3R5bGVSdWxlKSB7XG4gICAgICB0aGlzLm1hcFtydWxlLnNlbGVjdG9yXSA9IHJ1bGU7XG4gICAgICBpZiAocnVsZS5pZCkgdGhpcy5jbGFzc2VzW3J1bGUua2V5XSA9IHJ1bGUuaWQ7XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSAmJiB0aGlzLmtleWZyYW1lcykge1xuICAgICAgdGhpcy5rZXlmcmFtZXNbcnVsZS5uYW1lXSA9IHJ1bGUuaWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udW5yZWdpc3RlciA9IGZ1bmN0aW9uIHVucmVnaXN0ZXIocnVsZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtydWxlLmtleV07XG5cbiAgICBpZiAocnVsZSBpbnN0YW5jZW9mIFN0eWxlUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMubWFwW3J1bGUuc2VsZWN0b3JdO1xuICAgICAgZGVsZXRlIHRoaXMuY2xhc3Nlc1tydWxlLmtleV07XG4gICAgfSBlbHNlIGlmIChydWxlIGluc3RhbmNlb2YgS2V5ZnJhbWVzUnVsZSkge1xuICAgICAgZGVsZXRlIHRoaXMua2V5ZnJhbWVzW3J1bGUubmFtZV07XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgbmFtZTtcbiAgICB2YXIgZGF0YTtcbiAgICB2YXIgb3B0aW9ucztcblxuICAgIGlmICh0eXBlb2YgKGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzBdOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICAgIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07IC8vICRGbG93Rml4TWVcblxuICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICAgICAgbmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMubWFwW25hbWVdLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuaW5kZXgubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHRoaXMudXBkYXRlT25lKHRoaXMuaW5kZXhbaW5kZXhdLCBkYXRhLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEV4ZWN1dGUgcGx1Z2lucywgdXBkYXRlIHJ1bGUgcHJvcHMuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZU9uZSA9IGZ1bmN0aW9uIHVwZGF0ZU9uZShydWxlLCBkYXRhLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRVcGRhdGVPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBfdGhpcyRvcHRpb25zMiA9IHRoaXMub3B0aW9ucyxcbiAgICAgICAgcGx1Z2lucyA9IF90aGlzJG9wdGlvbnMyLmpzcy5wbHVnaW5zLFxuICAgICAgICBzaGVldCA9IF90aGlzJG9wdGlvbnMyLnNoZWV0OyAvLyBJdCBpcyBhIHJ1bGVzIGNvbnRhaW5lciBsaWtlIGZvciBlLmcuIENvbmRpdGlvbmFsUnVsZS5cblxuICAgIGlmIChydWxlLnJ1bGVzIGluc3RhbmNlb2YgUnVsZUxpc3QpIHtcbiAgICAgIHJ1bGUucnVsZXMudXBkYXRlKGRhdGEsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdHlsZVJ1bGUgPSBydWxlO1xuICAgIHZhciBzdHlsZSA9IHN0eWxlUnVsZS5zdHlsZTtcbiAgICBwbHVnaW5zLm9uVXBkYXRlKGRhdGEsIHJ1bGUsIHNoZWV0LCBvcHRpb25zKTsgLy8gV2UgcmVseSBvbiBhIG5ldyBgc3R5bGVgIHJlZiBpbiBjYXNlIGl0IHdhcyBtdXRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLlxuXG4gICAgaWYgKG9wdGlvbnMucHJvY2VzcyAmJiBzdHlsZSAmJiBzdHlsZSAhPT0gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIHJ1biB0aGUgcGx1Z2lucyBpbiBjYXNlIG5ldyBgc3R5bGVgIHJlbGllcyBvbiBzeW50YXggcGx1Z2lucy5cbiAgICAgIHBsdWdpbnMub25Qcm9jZXNzU3R5bGUoc3R5bGVSdWxlLnN0eWxlLCBzdHlsZVJ1bGUsIHNoZWV0KTsgLy8gVXBkYXRlIGFuZCBhZGQgcHJvcHMuXG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVSdWxlLnN0eWxlKSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBzdHlsZVJ1bGUuc3R5bGVbcHJvcF07XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBzdHlsZVtwcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChuZXh0VmFsdWUgIT09IHByZXZWYWx1ZSkge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKHByb3AsIG5leHRWYWx1ZSwgZm9yY2VVcGRhdGVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBSZW1vdmUgcHJvcHMuXG5cblxuICAgICAgZm9yICh2YXIgX3Byb3AgaW4gc3R5bGUpIHtcbiAgICAgICAgdmFyIF9uZXh0VmFsdWUgPSBzdHlsZVJ1bGUuc3R5bGVbX3Byb3BdO1xuICAgICAgICB2YXIgX3ByZXZWYWx1ZSA9IHN0eWxlW19wcm9wXTsgLy8gV2UgbmVlZCB0byB1c2UgYGZvcmNlOiB0cnVlYCBiZWNhdXNlIGBydWxlLnN0eWxlYCBoYXMgYmVlbiB1cGRhdGVkIGR1cmluZyBvblVwZGF0ZSBob29rLCBzbyBgcnVsZS5wcm9wKClgIHdpbGwgbm90IHVwZGF0ZSB0aGUgQ1NTT00gcnVsZS5cbiAgICAgICAgLy8gV2UgZG8gdGhpcyBjb21wYXJpc29uIHRvIGF2b2lkIHVubmVlZGVkIGBydWxlLnByb3AoKWAgY2FsbHMsIHNpbmNlIHdlIGhhdmUgdGhlIG9sZCBgc3R5bGVgIG9iamVjdCBoZXJlLlxuXG4gICAgICAgIGlmIChfbmV4dFZhbHVlID09IG51bGwgJiYgX25leHRWYWx1ZSAhPT0gX3ByZXZWYWx1ZSkge1xuICAgICAgICAgIHN0eWxlUnVsZS5wcm9wKF9wcm9wLCBudWxsLCBmb3JjZVVwZGF0ZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIHZhciBzaGVldCA9IHRoaXMub3B0aW9ucy5zaGVldDtcbiAgICB2YXIgbGluayA9IHNoZWV0ID8gc2hlZXQub3B0aW9ucy5saW5rIDogZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbmRleC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBydWxlID0gdGhpcy5pbmRleFtpbmRleF07XG4gICAgICB2YXIgY3NzID0gcnVsZS50b1N0cmluZyhvcHRpb25zKTsgLy8gTm8gbmVlZCB0byByZW5kZXIgYW4gZW1wdHkgcnVsZS5cblxuICAgICAgaWYgKCFjc3MgJiYgIWxpbmspIGNvbnRpbnVlO1xuICAgICAgaWYgKHN0cikgc3RyICs9ICdcXG4nO1xuICAgICAgc3RyICs9IGNzcztcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyO1xuICB9O1xuXG4gIHJldHVybiBSdWxlTGlzdDtcbn0oKTtcblxudmFyIFN0eWxlU2hlZXQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHlsZVNoZWV0KHN0eWxlcywgb3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcGxveWVkID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB2b2lkIDA7XG4gICAgdGhpcy5ydWxlcyA9IHZvaWQgMDtcbiAgICB0aGlzLnJlbmRlcmVyID0gdm9pZCAwO1xuICAgIHRoaXMuY2xhc3NlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleWZyYW1lcyA9IHZvaWQgMDtcbiAgICB0aGlzLnF1ZXVlID0gdm9pZCAwO1xuICAgIHRoaXMuYXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlcGxveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jbGFzc2VzID0ge307XG4gICAgdGhpcy5rZXlmcmFtZXMgPSB7fTtcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgc2hlZXQ6IHRoaXMsXG4gICAgICBwYXJlbnQ6IHRoaXMsXG4gICAgICBjbGFzc2VzOiB0aGlzLmNsYXNzZXMsXG4gICAgICBrZXlmcmFtZXM6IHRoaXMua2V5ZnJhbWVzXG4gICAgfSk7XG5cbiAgICBpZiAob3B0aW9ucy5SZW5kZXJlcikge1xuICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBvcHRpb25zLlJlbmRlcmVyKHRoaXMpO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMgPSBuZXcgUnVsZUxpc3QodGhpcy5vcHRpb25zKTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB0aGlzLnJ1bGVzLmFkZChuYW1lLCBzdHlsZXNbbmFtZV0pO1xuICAgIH1cblxuICAgIHRoaXMucnVsZXMucHJvY2VzcygpO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2ggcmVuZGVyYWJsZSB0byB0aGUgcmVuZGVyIHRyZWUuXG4gICAqL1xuXG5cbiAgdmFyIF9wcm90byA9IFN0eWxlU2hlZXQucHJvdG90eXBlO1xuXG4gIF9wcm90by5hdHRhY2ggPSBmdW5jdGlvbiBhdHRhY2goKSB7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWQpIHJldHVybiB0aGlzO1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmF0dGFjaCgpO1xuICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlOyAvLyBPcmRlciBpcyBpbXBvcnRhbnQsIGJlY2F1c2Ugd2UgY2FuJ3QgdXNlIGluc2VydFJ1bGUgQVBJIGlmIHN0eWxlIGVsZW1lbnQgaXMgbm90IGF0dGFjaGVkLlxuXG4gICAgaWYgKCF0aGlzLmRlcGxveWVkKSB0aGlzLmRlcGxveSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgcmVuZGVyYWJsZSBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAodGhpcy5yZW5kZXJlcikgdGhpcy5yZW5kZXJlci5kZXRhY2goKTtcbiAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhIHJ1bGUgdG8gdGhlIGN1cnJlbnQgc3R5bGVzaGVldC5cbiAgICogV2lsbCBpbnNlcnQgYSBydWxlIGFsc28gYWZ0ZXIgdGhlIHN0eWxlc2hlZXQgaGFzIGJlZW4gcmVuZGVyZWQgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZSA9IGZ1bmN0aW9uIGFkZFJ1bGUobmFtZSwgZGVjbCwgb3B0aW9ucykge1xuICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7IC8vIFBsdWdpbnMgY2FuIGNyZWF0ZSBydWxlcy5cbiAgICAvLyBJbiBvcmRlciB0byBwcmVzZXJ2ZSB0aGUgcmlnaHQgb3JkZXIsIHdlIG5lZWQgdG8gcXVldWUgYWxsIGAuYWRkUnVsZWAgY2FsbHMsXG4gICAgLy8gd2hpY2ggaGFwcGVuIGFmdGVyIHRoZSBmaXJzdCBgcnVsZXMuYWRkKClgIGNhbGwuXG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCAmJiAhcXVldWUpIHRoaXMucXVldWUgPSBbXTtcbiAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXMuYWRkKG5hbWUsIGRlY2wsIG9wdGlvbnMpO1xuICAgIGlmICghcnVsZSkgcmV0dXJuIG51bGw7XG4gICAgdGhpcy5vcHRpb25zLmpzcy5wbHVnaW5zLm9uUHJvY2Vzc1J1bGUocnVsZSk7XG5cbiAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgaWYgKCF0aGlzLmRlcGxveWVkKSByZXR1cm4gcnVsZTsgLy8gRG9uJ3QgaW5zZXJ0IHJ1bGUgZGlyZWN0bHkgaWYgdGhlcmUgaXMgbm8gc3RyaW5naWZpZWQgdmVyc2lvbiB5ZXQuXG4gICAgICAvLyBJdCB3aWxsIGJlIGluc2VydGVkIGFsbCB0b2dldGhlciB3aGVuIC5hdHRhY2ggaXMgY2FsbGVkLlxuXG4gICAgICBpZiAocXVldWUpIHF1ZXVlLnB1c2gocnVsZSk7ZWxzZSB7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICBpZiAodGhpcy5xdWV1ZSkge1xuICAgICAgICAgIHRoaXMucXVldWUuZm9yRWFjaCh0aGlzLmluc2VydFJ1bGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMucXVldWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBydWxlO1xuICAgIH0gLy8gV2UgY2FuJ3QgYWRkIHJ1bGVzIHRvIGEgZGV0YWNoZWQgc3R5bGUgbm9kZS5cbiAgICAvLyBXZSB3aWxsIHJlZGVwbG95IHRoZSBzaGVldCBvbmNlIHVzZXIgd2lsbCBhdHRhY2ggaXQuXG5cblxuICAgIHRoaXMuZGVwbG95ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IHJ1bGUgaW50byB0aGUgU3R5bGVTaGVldFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnNlcnRSdWxlID0gZnVuY3Rpb24gaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyZXIuaW5zZXJ0UnVsZShydWxlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhbmQgYWRkIHJ1bGVzLlxuICAgKiBXaWxsIHJlbmRlciBhbHNvIGFmdGVyIFN0eWxlIFNoZWV0IHdhcyByZW5kZXJlZCB0aGUgZmlyc3QgdGltZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uYWRkUnVsZXMgPSBmdW5jdGlvbiBhZGRSdWxlcyhzdHlsZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgYWRkZWQgPSBbXTtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICB2YXIgcnVsZSA9IHRoaXMuYWRkUnVsZShuYW1lLCBzdHlsZXNbbmFtZV0sIG9wdGlvbnMpO1xuICAgICAgaWYgKHJ1bGUpIGFkZGVkLnB1c2gocnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBydWxlIGJ5IG5hbWUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJ1bGUgPSBmdW5jdGlvbiBnZXRSdWxlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5nZXQobmFtZSk7XG4gIH1cbiAgLyoqXG4gICAqIERlbGV0ZSBhIHJ1bGUgYnkgbmFtZS5cbiAgICogUmV0dXJucyBgdHJ1ZWA6IGlmIHJ1bGUgaGFzIGJlZW4gZGVsZXRlZCBmcm9tIHRoZSBET00uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlbGV0ZVJ1bGUgPSBmdW5jdGlvbiBkZWxldGVSdWxlKG5hbWUpIHtcbiAgICB2YXIgcnVsZSA9IHR5cGVvZiBuYW1lID09PSAnb2JqZWN0JyA/IG5hbWUgOiB0aGlzLnJ1bGVzLmdldChuYW1lKTtcbiAgICBpZiAoIXJ1bGUpIHJldHVybiBmYWxzZTtcbiAgICB0aGlzLnJ1bGVzLnJlbW92ZShydWxlKTtcblxuICAgIGlmICh0aGlzLmF0dGFjaGVkICYmIHJ1bGUucmVuZGVyYWJsZSAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJlci5kZWxldGVSdWxlKHJ1bGUucmVuZGVyYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBpbmRleCBvZiBhIHJ1bGUuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mKHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5ydWxlcy5pbmRleE9mKHJ1bGUpO1xuICB9XG4gIC8qKlxuICAgKiBEZXBsb3kgcHVyZSBDU1Mgc3RyaW5nIHRvIGEgcmVuZGVyYWJsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVwbG95ID0gZnVuY3Rpb24gZGVwbG95KCkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVyKSB0aGlzLnJlbmRlcmVyLmRlcGxveSgpO1xuICAgIHRoaXMuZGVwbG95ZWQgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGZ1bmN0aW9uIHZhbHVlcyB3aXRoIGEgbmV3IGRhdGEuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkcnVsZXM7XG5cbiAgICAoX3RoaXMkcnVsZXMgPSB0aGlzLnJ1bGVzKS51cGRhdGUuYXBwbHkoX3RoaXMkcnVsZXMsIGFyZ3VtZW50cyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogVXBkYXRlcyBhIHNpbmdsZSBydWxlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGVPbmUgPSBmdW5jdGlvbiB1cGRhdGVPbmUocnVsZSwgZGF0YSwgb3B0aW9ucykge1xuICAgIHRoaXMucnVsZXMudXBkYXRlT25lKHJ1bGUsIGRhdGEsIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZXJ0IHJ1bGVzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMudG9TdHJpbmcob3B0aW9ucyk7XG4gIH07XG5cbiAgcmV0dXJuIFN0eWxlU2hlZXQ7XG59KCk7XG5cbnZhciBQbHVnaW5zUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQbHVnaW5zUmVnaXN0cnkoKSB7XG4gICAgdGhpcy5wbHVnaW5zID0ge1xuICAgICAgaW50ZXJuYWw6IFtdLFxuICAgICAgZXh0ZXJuYWw6IFtdXG4gICAgfTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gdm9pZCAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsdWdpbnNSZWdpc3RyeS5wcm90b3R5cGU7XG5cbiAgLyoqXG4gICAqIENhbGwgYG9uQ3JlYXRlUnVsZWAgaG9va3MgYW5kIHJldHVybiBhbiBvYmplY3QgaWYgcmV0dXJuZWQgYnkgYSBob29rLlxuICAgKi9cbiAgX3Byb3RvLm9uQ3JlYXRlUnVsZSA9IGZ1bmN0aW9uIG9uQ3JlYXRlUnVsZShuYW1lLCBkZWNsLCBvcHRpb25zKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJ1bGUgPSB0aGlzLnJlZ2lzdHJ5Lm9uQ3JlYXRlUnVsZVtpXShuYW1lLCBkZWNsLCBvcHRpb25zKTtcbiAgICAgIGlmIChydWxlKSByZXR1cm4gcnVsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzUnVsZWAgaG9va3MuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLm9uUHJvY2Vzc1J1bGUgPSBmdW5jdGlvbiBvblByb2Nlc3NSdWxlKHJ1bGUpIHtcbiAgICBpZiAocnVsZS5pc1Byb2Nlc3NlZCkgcmV0dXJuO1xuICAgIHZhciBzaGVldCA9IHJ1bGUub3B0aW9ucy5zaGVldDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NSdWxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1J1bGVbaV0ocnVsZSwgc2hlZXQpO1xuICAgIH1cblxuICAgIGlmIChydWxlLnN0eWxlKSB0aGlzLm9uUHJvY2Vzc1N0eWxlKHJ1bGUuc3R5bGUsIHJ1bGUsIHNoZWV0KTtcbiAgICBydWxlLmlzUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU3R5bGVgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTdHlsZSA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1N0eWxlKHN0eWxlLCBydWxlLCBzaGVldCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblByb2Nlc3NTdHlsZS5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgcnVsZS5zdHlsZSA9IHRoaXMucmVnaXN0cnkub25Qcm9jZXNzU3R5bGVbaV0ocnVsZS5zdHlsZSwgcnVsZSwgc2hlZXQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQ2FsbCBgb25Qcm9jZXNzU2hlZXRgIGhvb2tzLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5vblByb2Nlc3NTaGVldCA9IGZ1bmN0aW9uIG9uUHJvY2Vzc1NoZWV0KHNoZWV0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLnJlZ2lzdHJ5Lm9uUHJvY2Vzc1NoZWV0W2ldKHNoZWV0KTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENhbGwgYG9uVXBkYXRlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZWdpc3RyeS5vblVwZGF0ZVtpXShkYXRhLCBydWxlLCBzaGVldCwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDYWxsIGBvbkNoYW5nZVZhbHVlYCBob29rcy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ub25DaGFuZ2VWYWx1ZSA9IGZ1bmN0aW9uIG9uQ2hhbmdlVmFsdWUodmFsdWUsIHByb3AsIHJ1bGUpIHtcbiAgICB2YXIgcHJvY2Vzc2VkVmFsdWUgPSB2YWx1ZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5vbkNoYW5nZVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm9jZXNzZWRWYWx1ZSA9IHRoaXMucmVnaXN0cnkub25DaGFuZ2VWYWx1ZVtpXShwcm9jZXNzZWRWYWx1ZSwgcHJvcCwgcnVsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZFZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIHBsdWdpbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udXNlID0gZnVuY3Rpb24gdXNlKG5ld1BsdWdpbiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgIHF1ZXVlOiAnZXh0ZXJuYWwnXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBwbHVnaW5zID0gdGhpcy5wbHVnaW5zW29wdGlvbnMucXVldWVdOyAvLyBBdm9pZHMgYXBwbHlpbmcgc2FtZSBwbHVnaW4gdHdpY2UsIGF0IGxlYXN0IGJhc2VkIG9uIHJlZi5cblxuICAgIGlmIChwbHVnaW5zLmluZGV4T2YobmV3UGx1Z2luKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwbHVnaW5zLnB1c2gobmV3UGx1Z2luKTtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW10uY29uY2F0KHRoaXMucGx1Z2lucy5leHRlcm5hbCwgdGhpcy5wbHVnaW5zLmludGVybmFsKS5yZWR1Y2UoZnVuY3Rpb24gKHJlZ2lzdHJ5LCBwbHVnaW4pIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gcGx1Z2luKSB7XG4gICAgICAgIGlmIChuYW1lIGluIHJlZ2lzdHJ5KSB7XG4gICAgICAgICAgcmVnaXN0cnlbbmFtZV0ucHVzaChwbHVnaW5bbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFVua25vd24gaG9vayBcXFwiXCIgKyBuYW1lICsgXCJcXFwiLlwiKSA6IHZvaWQgMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVnaXN0cnk7XG4gICAgfSwge1xuICAgICAgb25DcmVhdGVSdWxlOiBbXSxcbiAgICAgIG9uUHJvY2Vzc1J1bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU3R5bGU6IFtdLFxuICAgICAgb25Qcm9jZXNzU2hlZXQ6IFtdLFxuICAgICAgb25DaGFuZ2VWYWx1ZTogW10sXG4gICAgICBvblVwZGF0ZTogW11cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGx1Z2luc1JlZ2lzdHJ5O1xufSgpO1xuXG4vKipcbiAqIFNoZWV0cyByZWdpc3RyeSB0byBhY2Nlc3MgdGhlbSBhbGwgYXQgb25lIHBsYWNlLlxuICovXG52YXIgU2hlZXRzUmVnaXN0cnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaGVldHNSZWdpc3RyeSgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2hlZXRzUmVnaXN0cnkucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgX3Byb3RvLmFkZCA9IGZ1bmN0aW9uIGFkZChzaGVldCkge1xuICAgIHZhciByZWdpc3RyeSA9IHRoaXMucmVnaXN0cnk7XG4gICAgdmFyIGluZGV4ID0gc2hlZXQub3B0aW9ucy5pbmRleDtcbiAgICBpZiAocmVnaXN0cnkuaW5kZXhPZihzaGVldCkgIT09IC0xKSByZXR1cm47XG5cbiAgICBpZiAocmVnaXN0cnkubGVuZ3RoID09PSAwIHx8IGluZGV4ID49IHRoaXMuaW5kZXgpIHtcbiAgICAgIHJlZ2lzdHJ5LnB1c2goc2hlZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRmluZCBhIHBvc2l0aW9uLlxuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlZ2lzdHJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVnaXN0cnlbaV0ub3B0aW9ucy5pbmRleCA+IGluZGV4KSB7XG4gICAgICAgIHJlZ2lzdHJ5LnNwbGljZShpLCAwLCBzaGVldCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnJlZ2lzdHJ5ID0gW107XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhIFN0eWxlIFNoZWV0LlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoc2hlZXQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnJlZ2lzdHJ5LmluZGV4T2Yoc2hlZXQpO1xuICAgIHRoaXMucmVnaXN0cnkuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVydCBhbGwgYXR0YWNoZWQgc2hlZXRzIHRvIGEgQ1NTIHN0cmluZy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8udG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhfdGVtcCkge1xuICAgIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICAgIGF0dGFjaGVkID0gX3JlZi5hdHRhY2hlZCxcbiAgICAgICAgb3B0aW9ucyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKF9yZWYsIFtcImF0dGFjaGVkXCJdKTtcblxuICAgIHZhciBjc3MgPSAnJztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5yZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNoZWV0ID0gdGhpcy5yZWdpc3RyeVtpXTtcblxuICAgICAgaWYgKGF0dGFjaGVkICE9IG51bGwgJiYgc2hlZXQuYXR0YWNoZWQgIT09IGF0dGFjaGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3NzKSBjc3MgKz0gJ1xcbic7XG4gICAgICBjc3MgKz0gc2hlZXQudG9TdHJpbmcob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNzcztcbiAgfTtcblxuICBfY3JlYXRlQ2xhc3MoU2hlZXRzUmVnaXN0cnksIFt7XG4gICAga2V5OiBcImluZGV4XCIsXG5cbiAgICAvKipcbiAgICAgKiBDdXJyZW50IGhpZ2hlc3QgaW5kZXggbnVtYmVyLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnkubGVuZ3RoID09PSAwID8gMCA6IHRoaXMucmVnaXN0cnlbdGhpcy5yZWdpc3RyeS5sZW5ndGggLSAxXS5vcHRpb25zLmluZGV4O1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTaGVldHNSZWdpc3RyeTtcbn0oKTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgZ2xvYmFsIHNoZWV0cyByZWdpc3RyeS4gT25seSBEb21SZW5kZXJlciB3aWxsIGFkZCBzaGVldHMgdG8gaXQuXG4gKiBPbiB0aGUgc2VydmVyIG9uZSBzaG91bGQgdXNlIGFuIG93biBTaGVldHNSZWdpc3RyeSBpbnN0YW5jZSBhbmQgYWRkIHRoZVxuICogc2hlZXRzIHRvIGl0LCBiZWNhdXNlIHlvdSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBjcmVhdGUgYSBuZXcgcmVnaXN0cnkgZm9yXG4gKiBlYWNoIHJlcXVlc3QgaW4gb3JkZXIgdG8gbm90IGxlYWsgc2hlZXRzIGFjcm9zcyByZXF1ZXN0cy5cbiAqL1xuXG52YXIgc2hlZXRzID0gbmV3IFNoZWV0c1JlZ2lzdHJ5KCk7XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbFRoaXMgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnICYmIHdpbmRvdy5NYXRoID09IE1hdGggPyB3aW5kb3cgOiB0eXBlb2Ygc2VsZiAhPSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT0gTWF0aCA/IHNlbGYgOiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG52YXIgbnMgPSAnMmYxYWNjNmMzYTYwNmIwODJlNWVlZjVlNTQ0MTRmZmInO1xuaWYgKGdsb2JhbFRoaXNbbnNdID09IG51bGwpIGdsb2JhbFRoaXNbbnNdID0gMDsgLy8gQnVuZGxlIG1heSBjb250YWluIG11bHRpcGxlIEpTUyB2ZXJzaW9ucyBhdCB0aGUgc2FtZSB0aW1lLiBJbiBvcmRlciB0byBpZGVudGlmeVxuLy8gdGhlIGN1cnJlbnQgdmVyc2lvbiB3aXRoIGp1c3Qgb25lIHNob3J0IG51bWJlciBhbmQgdXNlIGl0IGZvciBjbGFzc2VzIGdlbmVyYXRpb25cbi8vIHdlIHVzZSBhIGNvdW50ZXIuIEFsc28gaXQgaXMgbW9yZSBhY2N1cmF0ZSwgYmVjYXVzZSB1c2VyIGNhbiBtYW51YWxseSByZWV2YWx1YXRlXG4vLyB0aGUgbW9kdWxlLlxuXG52YXIgbW9kdWxlSWQgPSBnbG9iYWxUaGlzW25zXSsrO1xuXG52YXIgbWF4UnVsZXMgPSAxZTEwO1xuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB3aGljaCBnZW5lcmF0ZXMgdW5pcXVlIGNsYXNzIG5hbWVzIGJhc2VkIG9uIGNvdW50ZXJzLlxuICogV2hlbiBuZXcgZ2VuZXJhdG9yIGZ1bmN0aW9uIGlzIGNyZWF0ZWQsIHJ1bGUgY291bnRlciBpcyByZXNldGVkLlxuICogV2UgbmVlZCB0byByZXNldCB0aGUgcnVsZSBjb3VudGVyIGZvciBTU1IgZm9yIGVhY2ggcmVxdWVzdC5cbiAqL1xudmFyIGNyZWF0ZUdlbmVyYXRlSWQgPSBmdW5jdGlvbiBjcmVhdGVHZW5lcmF0ZUlkKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBydWxlQ291bnRlciA9IDA7XG4gIHJldHVybiBmdW5jdGlvbiAocnVsZSwgc2hlZXQpIHtcbiAgICBydWxlQ291bnRlciArPSAxO1xuXG4gICAgaWYgKHJ1bGVDb3VudGVyID4gbWF4UnVsZXMpIHtcbiAgICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIFlvdSBtaWdodCBoYXZlIGEgbWVtb3J5IGxlYWsuIFJ1bGUgY291bnRlciBpcyBhdCBcIiArIHJ1bGVDb3VudGVyICsgXCIuXCIpIDogdm9pZCAwO1xuICAgIH1cblxuICAgIHZhciBqc3NJZCA9ICcnO1xuICAgIHZhciBwcmVmaXggPSAnJztcblxuICAgIGlmIChzaGVldCkge1xuICAgICAgaWYgKHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4KSB7XG4gICAgICAgIHByZWZpeCA9IHNoZWV0Lm9wdGlvbnMuY2xhc3NOYW1lUHJlZml4O1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hlZXQub3B0aW9ucy5qc3MuaWQgIT0gbnVsbCkge1xuICAgICAgICBqc3NJZCA9IFN0cmluZyhzaGVldC5vcHRpb25zLmpzcy5pZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubWluaWZ5KSB7XG4gICAgICAvLyBVc2luZyBcImNcIiBiZWNhdXNlIGEgbnVtYmVyIGNhbid0IGJlIHRoZSBmaXJzdCBjaGFyIGluIGEgY2xhc3MgbmFtZS5cbiAgICAgIHJldHVybiBcIlwiICsgKHByZWZpeCB8fCAnYycpICsgbW9kdWxlSWQgKyBqc3NJZCArIHJ1bGVDb3VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiBwcmVmaXggKyBydWxlLmtleSArIFwiLVwiICsgbW9kdWxlSWQgKyAoanNzSWQgPyBcIi1cIiArIGpzc0lkIDogJycpICsgXCItXCIgKyBydWxlQ291bnRlcjtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FjaGUgdGhlIHZhbHVlIGZyb20gdGhlIGZpcnN0IHRpbWUgYSBmdW5jdGlvbiBpcyBjYWxsZWQuXG4gKi9cbnZhciBtZW1vaXplID0gZnVuY3Rpb24gbWVtb2l6ZShmbikge1xuICB2YXIgdmFsdWU7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF2YWx1ZSkgdmFsdWUgPSBmbigpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn07XG4vKipcbiAqIEdldCBhIHN0eWxlIHByb3BlcnR5IHZhbHVlLlxuICovXG5cblxuZnVuY3Rpb24gZ2V0UHJvcGVydHlWYWx1ZShjc3NSdWxlLCBwcm9wKSB7XG4gIHRyeSB7XG4gICAgLy8gU3VwcG9ydCBDU1NUT00uXG4gICAgaWYgKGNzc1J1bGUuYXR0cmlidXRlU3R5bGVNYXApIHtcbiAgICAgIHJldHVybiBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmdldChwcm9wKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3NzUnVsZS5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBJRSBtYXkgdGhyb3cgaWYgcHJvcGVydHkgaXMgdW5rbm93bi5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogU2V0IGEgc3R5bGUgcHJvcGVydHkuXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRQcm9wZXJ0eShjc3NSdWxlLCBwcm9wLCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHZhciBjc3NWYWx1ZSA9IHZhbHVlO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBjc3NWYWx1ZSA9IHRvQ3NzVmFsdWUodmFsdWUsIHRydWUpO1xuXG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09ICchaW1wb3J0YW50Jykge1xuICAgICAgICBjc3NSdWxlLnN0eWxlLnNldFByb3BlcnR5KHByb3AsIGNzc1ZhbHVlLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gU3VwcG9ydCBDU1NUT00uXG5cblxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLnNldChwcm9wLCBjc3NWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNzc1J1bGUuc3R5bGUuc2V0UHJvcGVydHkocHJvcCwgY3NzVmFsdWUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSUUgbWF5IHRocm93IGlmIHByb3BlcnR5IGlzIHVua25vd24uXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFJlbW92ZSBhIHN0eWxlIHByb3BlcnR5LlxuICovXG5cblxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydHkoY3NzUnVsZSwgcHJvcCkge1xuICB0cnkge1xuICAgIC8vIFN1cHBvcnQgQ1NTVE9NLlxuICAgIGlmIChjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwKSB7XG4gICAgICBjc3NSdWxlLmF0dHJpYnV0ZVN0eWxlTWFwLmRlbGV0ZShwcm9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3NzUnVsZS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwcm9wKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIFwiZGV2ZWxvcG1lbnRcIiAhPT0gXCJwcm9kdWN0aW9uXCIgPyB3YXJuaW5nKGZhbHNlLCBcIltKU1NdIERPTUV4Y2VwdGlvbiBcXFwiXCIgKyBlcnIubWVzc2FnZSArIFwiXFxcIiB3YXMgdGhyb3duLiBUcmllZCB0byByZW1vdmUgcHJvcGVydHkgXFxcIlwiICsgcHJvcCArIFwiXFxcIi5cIikgOiB2b2lkIDA7XG4gIH1cbn1cbi8qKlxuICogU2V0IHRoZSBzZWxlY3Rvci5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNldFNlbGVjdG9yKGNzc1J1bGUsIHNlbGVjdG9yVGV4dCkge1xuICBjc3NSdWxlLnNlbGVjdG9yVGV4dCA9IHNlbGVjdG9yVGV4dDsgLy8gUmV0dXJuIGZhbHNlIGlmIHNldHRlciB3YXMgbm90IHN1Y2Nlc3NmdWwuXG4gIC8vIEN1cnJlbnRseSB3b3JrcyBpbiBjaHJvbWUgb25seS5cblxuICByZXR1cm4gY3NzUnVsZS5zZWxlY3RvclRleHQgPT09IHNlbGVjdG9yVGV4dDtcbn1cbi8qKlxuICogR2V0cyB0aGUgYGhlYWRgIGVsZW1lbnQgdXBvbiB0aGUgZmlyc3QgY2FsbCBhbmQgY2FjaGVzIGl0LlxuICogV2UgYXNzdW1lIGl0IGNhbid0IGJlIG51bGwuXG4gKi9cblxuXG52YXIgZ2V0SGVhZCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaGVhZCcpO1xufSk7XG4vKipcbiAqIEZpbmQgYXR0YWNoZWQgc2hlZXQgd2l0aCBhbiBpbmRleCBoaWdoZXIgdGhhbiB0aGUgcGFzc2VkIG9uZS5cbiAqL1xuXG5mdW5jdGlvbiBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWdpc3RyeS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzaGVldCA9IHJlZ2lzdHJ5W2ldO1xuXG4gICAgaWYgKHNoZWV0LmF0dGFjaGVkICYmIHNoZWV0Lm9wdGlvbnMuaW5kZXggPiBvcHRpb25zLmluZGV4ICYmIHNoZWV0Lm9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgPT09IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQpIHtcbiAgICAgIHJldHVybiBzaGVldDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuICogRmluZCBhdHRhY2hlZCBzaGVldCB3aXRoIHRoZSBoaWdoZXN0IGluZGV4LlxuICovXG5cblxuZnVuY3Rpb24gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gcmVnaXN0cnkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgc2hlZXQgPSByZWdpc3RyeVtpXTtcblxuICAgIGlmIChzaGVldC5hdHRhY2hlZCAmJiBzaGVldC5vcHRpb25zLmluc2VydGlvblBvaW50ID09PSBvcHRpb25zLmluc2VydGlvblBvaW50KSB7XG4gICAgICByZXR1cm4gc2hlZXQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEZpbmQgYSBjb21tZW50IHdpdGggXCJqc3NcIiBpbnNpZGUuXG4gKi9cblxuXG5mdW5jdGlvbiBmaW5kQ29tbWVudE5vZGUodGV4dCkge1xuICB2YXIgaGVhZCA9IGdldEhlYWQoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBub2RlID0gaGVhZC5jaGlsZE5vZGVzW2ldO1xuXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggJiYgbm9kZS5ub2RlVmFsdWUudHJpbSgpID09PSB0ZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBGaW5kIGEgbm9kZSBiZWZvcmUgd2hpY2ggd2UgY2FuIGluc2VydCB0aGUgc2hlZXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRQcmV2Tm9kZShvcHRpb25zKSB7XG4gIHZhciByZWdpc3RyeSA9IHNoZWV0cy5yZWdpc3RyeTtcblxuICBpZiAocmVnaXN0cnkubGVuZ3RoID4gMCkge1xuICAgIC8vIFRyeSB0byBpbnNlcnQgYmVmb3JlIHRoZSBuZXh0IGhpZ2hlciBzaGVldC5cbiAgICB2YXIgc2hlZXQgPSBmaW5kSGlnaGVyU2hlZXQocmVnaXN0cnksIG9wdGlvbnMpO1xuXG4gICAgaWYgKHNoZWV0ICYmIHNoZWV0LnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwYXJlbnQ6IHNoZWV0LnJlbmRlcmVyLmVsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgbm9kZTogc2hlZXQucmVuZGVyZXIuZWxlbWVudFxuICAgICAgfTtcbiAgICB9IC8vIE90aGVyd2lzZSBpbnNlcnQgYWZ0ZXIgdGhlIGxhc3QgYXR0YWNoZWQuXG5cblxuICAgIHNoZWV0ID0gZmluZEhpZ2hlc3RTaGVldChyZWdpc3RyeSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoc2hlZXQgJiYgc2hlZXQucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogc2hlZXQucmVuZGVyZXIuZWxlbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBzaGVldC5yZW5kZXJlci5lbGVtZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH1cbiAgfSAvLyBUcnkgdG8gZmluZCBhIGNvbW1lbnQgcGxhY2Vob2xkZXIgaWYgcmVnaXN0cnkgaXMgZW1wdHkuXG5cblxuICB2YXIgaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuXG4gIGlmIChpbnNlcnRpb25Qb2ludCAmJiB0eXBlb2YgaW5zZXJ0aW9uUG9pbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIGNvbW1lbnQgPSBmaW5kQ29tbWVudE5vZGUoaW5zZXJ0aW9uUG9pbnQpO1xuXG4gICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhcmVudDogY29tbWVudC5wYXJlbnROb2RlLFxuICAgICAgICBub2RlOiBjb21tZW50Lm5leHRTaWJsaW5nXG4gICAgICB9O1xuICAgIH0gLy8gSWYgdXNlciBzcGVjaWZpZXMgYW4gaW5zZXJ0aW9uIHBvaW50IGFuZCBpdCBjYW4ndCBiZSBmb3VuZCBpbiB0aGUgZG9jdW1lbnQgLVxuICAgIC8vIGJhZCBzcGVjaWZpY2l0eSBpc3N1ZXMgbWF5IGFwcGVhci5cblxuXG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gSW5zZXJ0aW9uIHBvaW50IFxcXCJcIiArIGluc2VydGlvblBvaW50ICsgXCJcXFwiIG5vdCBmb3VuZC5cIikgOiB2b2lkIDA7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIEluc2VydCBzdHlsZSBlbGVtZW50IGludG8gdGhlIERPTS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluc2VydFN0eWxlKHN0eWxlLCBvcHRpb25zKSB7XG4gIHZhciBpbnNlcnRpb25Qb2ludCA9IG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQ7XG4gIHZhciBuZXh0Tm9kZSA9IGZpbmRQcmV2Tm9kZShvcHRpb25zKTtcblxuICBpZiAobmV4dE5vZGUgIT09IGZhbHNlICYmIG5leHROb2RlLnBhcmVudCkge1xuICAgIG5leHROb2RlLnBhcmVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHROb2RlLm5vZGUpO1xuICAgIHJldHVybjtcbiAgfSAvLyBXb3JrcyB3aXRoIGlmcmFtZXMgYW5kIGFueSBub2RlIHR5cGVzLlxuXG5cbiAgaWYgKGluc2VydGlvblBvaW50ICYmIHR5cGVvZiBpbnNlcnRpb25Qb2ludC5ub2RlVHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy80MTMyODcyOC9mb3JjZS1jYXN0aW5nLWluLWZsb3dcbiAgICB2YXIgaW5zZXJ0aW9uUG9pbnRFbGVtZW50ID0gaW5zZXJ0aW9uUG9pbnQ7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBpbnNlcnRpb25Qb2ludEVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIGluc2VydGlvblBvaW50RWxlbWVudC5uZXh0U2libGluZyk7ZWxzZSBcImRldmVsb3BtZW50XCIgIT09IFwicHJvZHVjdGlvblwiID8gd2FybmluZyhmYWxzZSwgJ1tKU1NdIEluc2VydGlvbiBwb2ludCBpcyBub3QgaW4gdGhlIERPTS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm47XG4gIH1cblxuICBnZXRIZWFkKCkuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxuLyoqXG4gKiBSZWFkIGpzcyBub25jZSBzZXR0aW5nIGZyb20gdGhlIHBhZ2UgaWYgdGhlIHVzZXIgaGFzIHNldCBpdC5cbiAqL1xuXG5cbnZhciBnZXROb25jZSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICB2YXIgbm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJjc3Atbm9uY2VcIl0nKTtcbiAgcmV0dXJuIG5vZGUgPyBub2RlLmdldEF0dHJpYnV0ZSgnY29udGVudCcpIDogbnVsbDtcbn0pO1xuXG52YXIgX2luc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKGNvbnRhaW5lciwgcnVsZSwgaW5kZXgpIHtcbiAgdmFyIG1heEluZGV4ID0gY29udGFpbmVyLmNzc1J1bGVzLmxlbmd0aDsgLy8gSW4gY2FzZSBwcmV2aW91cyBpbnNlcnRpb24gZmFpbHMsIHBhc3NlZCBpbmRleCBtaWdodCBiZSB3cm9uZ1xuXG4gIGlmIChpbmRleCA9PT0gdW5kZWZpbmVkIHx8IGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBpbmRleCA9IG1heEluZGV4O1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoJ2luc2VydFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgdmFyIGMgPSBjb250YWluZXI7XG4gICAgICBjLmluc2VydFJ1bGUocnVsZSwgaW5kZXgpO1xuICAgIH0gLy8gS2V5ZnJhbWVzIHJ1bGUuXG4gICAgZWxzZSBpZiAoJ2FwcGVuZFJ1bGUnIGluIGNvbnRhaW5lcikge1xuICAgICAgICB2YXIgX2MgPSBjb250YWluZXI7XG5cbiAgICAgICAgX2MuYXBwZW5kUnVsZShydWxlKTtcbiAgICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgXCJkZXZlbG9wbWVudFwiICE9PSBcInByb2R1Y3Rpb25cIiA/IHdhcm5pbmcoZmFsc2UsIFwiW0pTU10gXCIgKyBlcnIubWVzc2FnZSkgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRhaW5lci5jc3NSdWxlc1tpbmRleF07XG59O1xuXG52YXIgY3JlYXRlU3R5bGUgPSBmdW5jdGlvbiBjcmVhdGVTdHlsZSgpIHtcbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTsgLy8gV2l0aG91dCBpdCwgSUUgd2lsbCBoYXZlIGEgYnJva2VuIHNvdXJjZSBvcmRlciBzcGVjaWZpY2l0eSBpZiB3ZVxuICAvLyBpbnNlcnQgcnVsZXMgYWZ0ZXIgd2UgaW5zZXJ0IHRoZSBzdHlsZSB0YWcuXG4gIC8vIEl0IHNlZW1zIHRvIGtpY2stb2ZmIHRoZSBzb3VyY2Ugb3JkZXIgc3BlY2lmaWNpdHkgYWxnb3JpdGhtLlxuXG4gIGVsLnRleHRDb250ZW50ID0gJ1xcbic7XG4gIHJldHVybiBlbDtcbn07XG5cbnZhciBEb21SZW5kZXJlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIC8vIEhUTUxTdHlsZUVsZW1lbnQgbmVlZHMgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8yNjk2XG4gIGZ1bmN0aW9uIERvbVJlbmRlcmVyKHNoZWV0KSB7XG4gICAgdGhpcy5nZXRQcm9wZXJ0eVZhbHVlID0gZ2V0UHJvcGVydHlWYWx1ZTtcbiAgICB0aGlzLnNldFByb3BlcnR5ID0gc2V0UHJvcGVydHk7XG4gICAgdGhpcy5yZW1vdmVQcm9wZXJ0eSA9IHJlbW92ZVByb3BlcnR5O1xuICAgIHRoaXMuc2V0U2VsZWN0b3IgPSBzZXRTZWxlY3RvcjtcbiAgICB0aGlzLmVsZW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5zaGVldCA9IHZvaWQgMDtcbiAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAvLyBUaGVyZSBpcyBubyBzaGVldCB3aGVuIHRoZSByZW5kZXJlciBpcyB1c2VkIGZyb20gYSBzdGFuZGFsb25lIFN0eWxlUnVsZS5cbiAgICBpZiAoc2hlZXQpIHNoZWV0cy5hZGQoc2hlZXQpO1xuICAgIHRoaXMuc2hlZXQgPSBzaGVldDtcblxuICAgIHZhciBfcmVmID0gdGhpcy5zaGVldCA/IHRoaXMuc2hlZXQub3B0aW9ucyA6IHt9LFxuICAgICAgICBtZWRpYSA9IF9yZWYubWVkaWEsXG4gICAgICAgIG1ldGEgPSBfcmVmLm1ldGEsXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50IHx8IGNyZWF0ZVN0eWxlKCk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1qc3MnLCAnJyk7XG4gICAgaWYgKG1lZGlhKSB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdtZWRpYScsIG1lZGlhKTtcbiAgICBpZiAobWV0YSkgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXRhJywgbWV0YSk7XG4gICAgdmFyIG5vbmNlID0gZ2V0Tm9uY2UoKTtcbiAgICBpZiAobm9uY2UpIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgbm9uY2UpO1xuICB9XG4gIC8qKlxuICAgKiBJbnNlcnQgc3R5bGUgZWxlbWVudCBpbnRvIHJlbmRlciB0cmVlLlxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBEb21SZW5kZXJlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmF0dGFjaCA9IGZ1bmN0aW9uIGF0dGFjaCgpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSB0aGUgZWxlbWVudCBub2RlIGlzIGV4dGVybmFsIGFuZCBpdCBpcyBhbHJlYWR5IGluIHRoZSBET00uXG4gICAgaWYgKHRoaXMuZWxlbWVudC5wYXJlbnROb2RlIHx8ICF0aGlzLnNoZWV0KSByZXR1cm47XG4gICAgaW5zZXJ0U3R5bGUodGhpcy5lbGVtZW50LCB0aGlzLnNoZWV0Lm9wdGlvbnMpOyAvLyBXaGVuIHJ1bGVzIGFyZSBpbnNlcnRlZCB1c2luZyBgaW5zZXJ0UnVsZWAgQVBJLCBhZnRlciBgc2hlZXQuZGV0YWNoKCkuYXR0YWNoKClgXG4gICAgLy8gbW9zdCBicm93c2VycyBjcmVhdGUgYSBuZXcgQ1NTU3R5bGVTaGVldCwgZXhjZXB0IG9mIGFsbCBJRXMuXG5cbiAgICB2YXIgZGVwbG95ZWQgPSBCb29sZWFuKHRoaXMuc2hlZXQgJiYgdGhpcy5zaGVldC5kZXBsb3llZCk7XG5cbiAgICBpZiAodGhpcy5oYXNJbnNlcnRlZFJ1bGVzICYmIGRlcGxveWVkKSB7XG4gICAgICB0aGlzLmhhc0luc2VydGVkUnVsZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVwbG95KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZW1vdmUgc3R5bGUgZWxlbWVudCBmcm9tIHJlbmRlciB0cmVlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kZXRhY2ggPSBmdW5jdGlvbiBkZXRhY2goKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmVsZW1lbnQpO1xuICB9XG4gIC8qKlxuICAgKiBJbmplY3QgQ1NTIHN0cmluZyBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmRlcGxveSA9IGZ1bmN0aW9uIGRlcGxveSgpIHtcbiAgICB2YXIgc2hlZXQgPSB0aGlzLnNoZWV0O1xuICAgIGlmICghc2hlZXQpIHJldHVybjtcblxuICAgIGlmIChzaGVldC5vcHRpb25zLmxpbmspIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZXMoc2hlZXQucnVsZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuZWxlbWVudC50ZXh0Q29udGVudCA9IFwiXFxuXCIgKyBzaGVldC50b1N0cmluZygpICsgXCJcXG5cIjtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IFJ1bGVMaXN0IGludG8gYW4gZWxlbWVudC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5zZXJ0UnVsZXMgPSBmdW5jdGlvbiBpbnNlcnRSdWxlcyhydWxlcywgbmF0aXZlUGFyZW50KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5pbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5pbnNlcnRSdWxlKHJ1bGVzLmluZGV4W2ldLCBpLCBuYXRpdmVQYXJlbnQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgcnVsZSBpbnRvIGVsZW1lbnQuXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmluc2VydFJ1bGUgPSBmdW5jdGlvbiBpbnNlcnRSdWxlKHJ1bGUsIGluZGV4LCBuYXRpdmVQYXJlbnQpIHtcbiAgICBpZiAobmF0aXZlUGFyZW50ID09PSB2b2lkIDApIHtcbiAgICAgIG5hdGl2ZVBhcmVudCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB9XG5cbiAgICBpZiAocnVsZS5ydWxlcykge1xuICAgICAgdmFyIHBhcmVudCA9IHJ1bGU7XG4gICAgICB2YXIgbGF0ZXN0TmF0aXZlUGFyZW50ID0gbmF0aXZlUGFyZW50O1xuXG4gICAgICBpZiAocnVsZS50eXBlID09PSAnY29uZGl0aW9uYWwnIHx8IHJ1bGUudHlwZSA9PT0gJ2tleWZyYW1lcycpIHtcbiAgICAgICAgLy8gV2UgbmVlZCB0byByZW5kZXIgdGhlIGNvbnRhaW5lciB3aXRob3V0IGNoaWxkcmVuIGZpcnN0LlxuICAgICAgICBsYXRlc3ROYXRpdmVQYXJlbnQgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHBhcmVudC50b1N0cmluZyh7XG4gICAgICAgICAgY2hpbGRyZW46IGZhbHNlXG4gICAgICAgIH0pLCBpbmRleCk7XG5cbiAgICAgICAgaWYgKGxhdGVzdE5hdGl2ZVBhcmVudCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRSdWxlcyhwYXJlbnQucnVsZXMsIGxhdGVzdE5hdGl2ZVBhcmVudCk7XG4gICAgICByZXR1cm4gbGF0ZXN0TmF0aXZlUGFyZW50O1xuICAgIH0gLy8gSUUga2VlcHMgdGhlIENTU1N0eWxlU2hlZXQgYWZ0ZXIgc3R5bGUgbm9kZSBoYXMgYmVlbiByZWF0dGFjaGVkLFxuICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGByZW5kZXJhYmxlYCByZWZlcmVuY2UgdGhlIHJpZ2h0IHN0eWxlIHNoZWV0IGFuZCBub3RcbiAgICAvLyByZXJlbmRlciB0aG9zZSBydWxlcy5cblxuXG4gICAgaWYgKHJ1bGUucmVuZGVyYWJsZSAmJiBydWxlLnJlbmRlcmFibGUucGFyZW50U3R5bGVTaGVldCA9PT0gdGhpcy5lbGVtZW50LnNoZWV0KSB7XG4gICAgICByZXR1cm4gcnVsZS5yZW5kZXJhYmxlO1xuICAgIH1cblxuICAgIHZhciBydWxlU3RyID0gcnVsZS50b1N0cmluZygpO1xuICAgIGlmICghcnVsZVN0cikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIG5hdGl2ZVJ1bGUgPSBfaW5zZXJ0UnVsZShuYXRpdmVQYXJlbnQsIHJ1bGVTdHIsIGluZGV4KTtcblxuICAgIGlmIChuYXRpdmVSdWxlID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuaGFzSW5zZXJ0ZWRSdWxlcyA9IHRydWU7XG4gICAgcnVsZS5yZW5kZXJhYmxlID0gbmF0aXZlUnVsZTtcbiAgICByZXR1cm4gbmF0aXZlUnVsZTtcbiAgfVxuICAvKipcbiAgICogRGVsZXRlIGEgcnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVsZXRlUnVsZSA9IGZ1bmN0aW9uIGRlbGV0ZVJ1bGUoY3NzUnVsZSkge1xuICAgIHZhciBzaGVldCA9IHRoaXMuZWxlbWVudC5zaGVldDtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHNoZWV0LmRlbGV0ZVJ1bGUoaW5kZXgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgaW5kZXggb2YgYSBDU1MgUnVsZS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YoY3NzUnVsZSkge1xuICAgIHZhciBjc3NSdWxlcyA9IHRoaXMuZWxlbWVudC5zaGVldC5jc3NSdWxlcztcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjc3NSdWxlcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGlmIChjc3NSdWxlID09PSBjc3NSdWxlc1tpbmRleF0pIHJldHVybiBpbmRleDtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgbmV3IENTUyBydWxlIGFuZCByZXBsYWNlIHRoZSBleGlzdGluZyBvbmUuXG4gICAqXG4gICAqIE9ubHkgdXNlZCBmb3Igc29tZSBvbGQgYnJvd3NlcnMgYmVjYXVzZSB0aGV5IGNhbid0IHNldCBhIHNlbGVjdG9yLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXBsYWNlUnVsZSA9IGZ1bmN0aW9uIHJlcGxhY2VSdWxlKGNzc1J1bGUsIHJ1bGUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoY3NzUnVsZSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgIHRoaXMuZWxlbWVudC5zaGVldC5kZWxldGVSdWxlKGluZGV4KTtcbiAgICByZXR1cm4gdGhpcy5pbnNlcnRSdWxlKHJ1bGUsIGluZGV4KTtcbiAgfVxuICAvKipcbiAgICogR2V0IGFsbCBydWxlcyBlbGVtZW50cy5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0UnVsZXMgPSBmdW5jdGlvbiBnZXRSdWxlcygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNoZWV0LmNzc1J1bGVzO1xuICB9O1xuXG4gIHJldHVybiBEb21SZW5kZXJlcjtcbn0oKTtcblxudmFyIGluc3RhbmNlQ291bnRlciA9IDA7XG5cbnZhciBKc3MgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBKc3Mob3B0aW9ucykge1xuICAgIHRoaXMuaWQgPSBpbnN0YW5jZUNvdW50ZXIrKztcbiAgICB0aGlzLnZlcnNpb24gPSBcIjEwLjMuMFwiO1xuICAgIHRoaXMucGx1Z2lucyA9IG5ldyBQbHVnaW5zUmVnaXN0cnkoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBpZDoge1xuICAgICAgICBtaW5pZnk6IGZhbHNlXG4gICAgICB9LFxuICAgICAgY3JlYXRlR2VuZXJhdGVJZDogY3JlYXRlR2VuZXJhdGVJZCxcbiAgICAgIFJlbmRlcmVyOiBpc0luQnJvd3NlciA/IERvbVJlbmRlcmVyIDogbnVsbCxcbiAgICAgIHBsdWdpbnM6IFtdXG4gICAgfTtcbiAgICB0aGlzLmdlbmVyYXRlSWQgPSBjcmVhdGVHZW5lcmF0ZUlkKHtcbiAgICAgIG1pbmlmeTogZmFsc2VcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5wbHVnaW5zLnVzZShwbHVnaW5zW2ldLCB7XG4gICAgICAgIHF1ZXVlOiAnaW50ZXJuYWwnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnNldHVwKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlcyB2YXJpb3VzIG9wdGlvbnMsIGFwcGxpZXMgcGx1Z2lucy5cbiAgICogU2hvdWxkIG5vdCBiZSB1c2VkIHR3aWNlIG9uIHRoZSBzYW1lIGluc3RhbmNlLCBiZWNhdXNlIHRoZXJlIGlzIG5vIHBsdWdpbnNcbiAgICogZGVkdXBsaWNhdGlvbiBsb2dpYy5cbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gSnNzLnByb3RvdHlwZTtcblxuICBfcHJvdG8uc2V0dXAgPSBmdW5jdGlvbiBzZXR1cChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmNyZWF0ZUdlbmVyYXRlSWQpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkID0gb3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuaWQgPSBfZXh0ZW5kcyh7fSwgdGhpcy5vcHRpb25zLmlkLCBvcHRpb25zLmlkKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkIHx8IG9wdGlvbnMuaWQpIHtcbiAgICAgIHRoaXMuZ2VuZXJhdGVJZCA9IHRoaXMub3B0aW9ucy5jcmVhdGVHZW5lcmF0ZUlkKHRoaXMub3B0aW9ucy5pZCk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaW5zZXJ0aW9uUG9pbnQgIT0gbnVsbCkgdGhpcy5vcHRpb25zLmluc2VydGlvblBvaW50ID0gb3B0aW9ucy5pbnNlcnRpb25Qb2ludDtcblxuICAgIGlmICgnUmVuZGVyZXInIGluIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5SZW5kZXJlciA9IG9wdGlvbnMuUmVuZGVyZXI7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuXG5cbiAgICBpZiAob3B0aW9ucy5wbHVnaW5zKSB0aGlzLnVzZS5hcHBseSh0aGlzLCBvcHRpb25zLnBsdWdpbnMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBTdHlsZSBTaGVldC5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIGNyZWF0ZVN0eWxlU2hlZXQoc3R5bGVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICAgIGluZGV4ID0gX29wdGlvbnMuaW5kZXg7XG5cbiAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykge1xuICAgICAgaW5kZXggPSBzaGVldHMuaW5kZXggPT09IDAgPyAwIDogc2hlZXRzLmluZGV4ICsgMTtcbiAgICB9XG5cbiAgICB2YXIgc2hlZXQgPSBuZXcgU3R5bGVTaGVldChzdHlsZXMsIF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgICBqc3M6IHRoaXMsXG4gICAgICBnZW5lcmF0ZUlkOiBvcHRpb25zLmdlbmVyYXRlSWQgfHwgdGhpcy5nZW5lcmF0ZUlkLFxuICAgICAgaW5zZXJ0aW9uUG9pbnQ6IHRoaXMub3B0aW9ucy5pbnNlcnRpb25Qb2ludCxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXIsXG4gICAgICBpbmRleDogaW5kZXhcbiAgICB9KSk7XG4gICAgdGhpcy5wbHVnaW5zLm9uUHJvY2Vzc1NoZWV0KHNoZWV0KTtcbiAgICByZXR1cm4gc2hlZXQ7XG4gIH1cbiAgLyoqXG4gICAqIERldGFjaCB0aGUgU3R5bGUgU2hlZXQgYW5kIHJlbW92ZSBpdCBmcm9tIHRoZSByZWdpc3RyeS5cbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlU3R5bGVTaGVldCA9IGZ1bmN0aW9uIHJlbW92ZVN0eWxlU2hlZXQoc2hlZXQpIHtcbiAgICBzaGVldC5kZXRhY2goKTtcbiAgICBzaGVldHMucmVtb3ZlKHNoZWV0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgcnVsZSB3aXRob3V0IGEgU3R5bGUgU2hlZXQuXG4gICAqIFtEZXByZWNhdGVkXSB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlUnVsZSA9IGZ1bmN0aW9uIGNyZWF0ZVJ1bGUkMShuYW1lLCBzdHlsZSwgb3B0aW9ucykge1xuICAgIGlmIChzdHlsZSA9PT0gdm9pZCAwKSB7XG4gICAgICBzdHlsZSA9IHt9O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBFbmFibGUgcnVsZSB3aXRob3V0IG5hbWUgZm9yIGlubGluZSBzdHlsZXMuXG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUnVsZSh1bmRlZmluZWQsIG5hbWUsIHN0eWxlKTtcbiAgICB9XG5cbiAgICB2YXIgcnVsZU9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIGpzczogdGhpcyxcbiAgICAgIFJlbmRlcmVyOiB0aGlzLm9wdGlvbnMuUmVuZGVyZXJcbiAgICB9KTtcblxuICAgIGlmICghcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCkgcnVsZU9wdGlvbnMuZ2VuZXJhdGVJZCA9IHRoaXMuZ2VuZXJhdGVJZDtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmNsYXNzZXMpIHJ1bGVPcHRpb25zLmNsYXNzZXMgPSB7fTtcbiAgICBpZiAoIXJ1bGVPcHRpb25zLmtleWZyYW1lcykgcnVsZU9wdGlvbnMua2V5ZnJhbWVzID0ge307XG5cbiAgICB2YXIgcnVsZSA9IGNyZWF0ZVJ1bGUobmFtZSwgc3R5bGUsIHJ1bGVPcHRpb25zKTtcblxuICAgIGlmIChydWxlKSB0aGlzLnBsdWdpbnMub25Qcm9jZXNzUnVsZShydWxlKTtcbiAgICByZXR1cm4gcnVsZTtcbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgcGx1Z2luLiBQYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIHdpdGggYSBydWxlIGluc3RhbmNlLlxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51c2UgPSBmdW5jdGlvbiB1c2UoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgcGx1Z2luc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgX3RoaXMucGx1Z2lucy51c2UocGx1Z2luKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gSnNzO1xufSgpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGEgc3R5bGVzIG9iamVjdCB3aXRoIG9ubHkgcHJvcHMgdGhhdCBjb250YWluIGZ1bmN0aW9uIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0RHluYW1pY1N0eWxlcyhzdHlsZXMpIHtcbiAgdmFyIHRvID0gbnVsbDtcblxuICBmb3IgKHZhciBrZXkgaW4gc3R5bGVzKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVzW2tleV07XG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKCF0bykgdG8gPSB7fTtcbiAgICAgIHRvW2tleV0gPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFyIGV4dHJhY3RlZCA9IGdldER5bmFtaWNTdHlsZXModmFsdWUpO1xuXG4gICAgICBpZiAoZXh0cmFjdGVkKSB7XG4gICAgICAgIGlmICghdG8pIHRvID0ge307XG4gICAgICAgIHRvW2tleV0gPSBleHRyYWN0ZWQ7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRvO1xufVxuXG4vKipcbiAqIFNoZWV0c01hbmFnZXIgaXMgbGlrZSBhIFdlYWtNYXAgd2hpY2ggaXMgZGVzaWduZWQgdG8gY291bnQgU3R5bGVTaGVldFxuICogaW5zdGFuY2VzIGFuZCBhdHRhY2gvZGV0YWNoIGF1dG9tYXRpY2FsbHkuXG4gKi9cbnZhciBTaGVldHNNYW5hZ2VyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2hlZXRzTWFuYWdlcigpIHtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5zaGVldHMgPSBuZXcgV2Vha01hcCgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNoZWV0c01hbmFnZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXQgPSBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG4gICAgcmV0dXJuIGVudHJ5ICYmIGVudHJ5LnNoZWV0O1xuICB9O1xuXG4gIF9wcm90by5hZGQgPSBmdW5jdGlvbiBhZGQoa2V5LCBzaGVldCkge1xuICAgIGlmICh0aGlzLnNoZWV0cy5oYXMoa2V5KSkgcmV0dXJuO1xuICAgIHRoaXMubGVuZ3RoKys7XG4gICAgdGhpcy5zaGVldHMuc2V0KGtleSwge1xuICAgICAgc2hlZXQ6IHNoZWV0LFxuICAgICAgcmVmczogMFxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5tYW5hZ2UgPSBmdW5jdGlvbiBtYW5hZ2Uoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5zaGVldHMuZ2V0KGtleSk7XG5cbiAgICBpZiAoZW50cnkpIHtcbiAgICAgIGlmIChlbnRyeS5yZWZzID09PSAwKSB7XG4gICAgICAgIGVudHJ5LnNoZWV0LmF0dGFjaCgpO1xuICAgICAgfVxuXG4gICAgICBlbnRyeS5yZWZzKys7XG4gICAgICByZXR1cm4gZW50cnkuc2hlZXQ7XG4gICAgfVxuXG4gICAgd2FybmluZyhmYWxzZSwgXCJbSlNTXSBTaGVldHNNYW5hZ2VyOiBjYW4ndCBmaW5kIHNoZWV0IHRvIG1hbmFnZVwiKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9O1xuXG4gIF9wcm90by51bm1hbmFnZSA9IGZ1bmN0aW9uIHVubWFuYWdlKGtleSkge1xuICAgIHZhciBlbnRyeSA9IHRoaXMuc2hlZXRzLmdldChrZXkpO1xuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBpZiAoZW50cnkucmVmcyA+IDApIHtcbiAgICAgICAgZW50cnkucmVmcy0tO1xuICAgICAgICBpZiAoZW50cnkucmVmcyA9PT0gMCkgZW50cnkuc2hlZXQuZGV0YWNoKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsIFwiU2hlZXRzTWFuYWdlcjogY2FuJ3QgZmluZCBzaGVldCB0byB1bm1hbmFnZVwiKTtcbiAgICB9XG4gIH07XG5cbiAgX2NyZWF0ZUNsYXNzKFNoZWV0c01hbmFnZXIsIFt7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2hlZXRzTWFuYWdlcjtcbn0oKTtcblxuLyoqXG4gKiBBIGJldHRlciBhYnN0cmFjdGlvbiBvdmVyIENTUy5cbiAqXG4gKiBAY29weXJpZ2h0IE9sZWcgSXNvbmVuIChTbG9ib2Rza29pKSAvIElzb25lbiAyMDE0LXByZXNlbnRcbiAqIEB3ZWJzaXRlIGh0dHBzOi8vZ2l0aHViLmNvbS9jc3NpbmpzL2pzc1xuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuLyoqXG4gKiBFeHBvcnQgYSBjb25zdGFudCBpbmRpY2F0aW5nIGlmIHRoaXMgYnJvd3NlciBoYXMgQ1NTVE9NIHN1cHBvcnQuXG4gKiBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS93ZWIvdXBkYXRlcy8yMDE4LzAzL2Nzc29tXG4gKi9cbnZhciBoYXNDU1NUT01TdXBwb3J0ID0gdHlwZW9mIENTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgQ1NTICYmICdudW1iZXInIGluIENTUztcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBKc3MuXG4gKi9cblxudmFyIGNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSnNzKG9wdGlvbnMpO1xufTtcbi8qKlxuICogQSBnbG9iYWwgSnNzIGluc3RhbmNlLlxuICovXG5cbnZhciBpbmRleCA9IGNyZWF0ZSgpO1xuXG5leHBvcnRzLlJ1bGVMaXN0ID0gUnVsZUxpc3Q7XG5leHBvcnRzLlNoZWV0c01hbmFnZXIgPSBTaGVldHNNYW5hZ2VyO1xuZXhwb3J0cy5TaGVldHNSZWdpc3RyeSA9IFNoZWV0c1JlZ2lzdHJ5O1xuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNyZWF0ZUdlbmVyYXRlSWQgPSBjcmVhdGVHZW5lcmF0ZUlkO1xuZXhwb3J0cy5jcmVhdGVSdWxlID0gY3JlYXRlUnVsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IGluZGV4O1xuZXhwb3J0cy5nZXREeW5hbWljU3R5bGVzID0gZ2V0RHluYW1pY1N0eWxlcztcbmV4cG9ydHMuaGFzQ1NTVE9NU3VwcG9ydCA9IGhhc0NTU1RPTVN1cHBvcnQ7XG5leHBvcnRzLnNoZWV0cyA9IHNoZWV0cztcbmV4cG9ydHMudG9Dc3NWYWx1ZSA9IHRvQ3NzVmFsdWU7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG5cbnZhciBlcnJvck1lc3NhZ2U7XG5cbmVycm9yTWVzc2FnZSA9ICdBbiBhcmd1bWVudCB3aXRob3V0IGFwcGVuZCwgcHJlcGVuZCwgJyArXG4gICAgJ29yIGRldGFjaCBtZXRob2RzIHdhcyBnaXZlbiB0byBgTGlzdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMaXN0OiBBIGxpbmtlZCBsaXN0IGlzIGEgYml0IGxpa2UgYW4gQXJyYXksIGJ1dFxuICoga25vd3Mgbm90aGluZyBhYm91dCBob3cgbWFueSBpdGVtcyBhcmUgaW4gaXQsIGFuZCBrbm93cyBvbmx5IGFib3V0IGl0c1xuICogZmlyc3QgKGBoZWFkYCkgYW5kIGxhc3QgKGB0YWlsYCkgaXRlbXMuIEVhY2ggaXRlbSAoZS5nLiBgaGVhZGAsIGB0YWlsYCxcbiAqICZjLikga25vd3Mgd2hpY2ggaXRlbSBjb21lcyBiZWZvcmUgb3IgYWZ0ZXIgaXQgKGl0cyBtb3JlIGxpa2UgdGhlXG4gKiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgRE9NIGluIEphdmFTY3JpcHQpLlxuICogQGdsb2JhbFxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQGNsYXNzIFJlcHJlc2VudHMgYW4gaW5zdGFuY2Ugb2YgTGlzdC5cbiAqL1xuXG5mdW5jdGlvbiBMaXN0KC8qaXRlbXMuLi4qLykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBMaXN0LmZyb20oYXJndW1lbnRzKTtcbiAgICB9XG59XG5cbnZhciBMaXN0UHJvdG90eXBlO1xuXG5MaXN0UHJvdG90eXBlID0gTGlzdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBsaXN0IGZyb20gdGhlIGFyZ3VtZW50cyAoZWFjaCBhIGxpc3QgaXRlbSkgcGFzc2VkIGluLlxuICogQG5hbWUgTGlzdC5vZlxuICogQHBhcmFtIHsuLi5MaXN0SXRlbX0gW2l0ZW1zXSAtIFplcm8gb3IgbW9yZSBpdGVtcyB0byBhdHRhY2guXG4gKiBAcmV0dXJucyB7bGlzdH0gLSBBIG5ldyBpbnN0YW5jZSBvZiBMaXN0LlxuICovXG5cbkxpc3Qub2YgPSBmdW5jdGlvbiAoLyppdGVtcy4uLiovKSB7XG4gICAgcmV0dXJuIExpc3QuZnJvbS5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbGlzdCBmcm9tIHRoZSBnaXZlbiBhcnJheS1saWtlIG9iamVjdCAoZWFjaCBhIGxpc3QgaXRlbSlcbiAqIHBhc3NlZCBpbi5cbiAqIEBuYW1lIExpc3QuZnJvbVxuICogQHBhcmFtIHtMaXN0SXRlbVtdfSBbaXRlbXNdIC0gVGhlIGl0ZW1zIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtsaXN0fSAtIEEgbmV3IGluc3RhbmNlIG9mIExpc3QuXG4gKi9cbkxpc3QuZnJvbSA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHZhciBsaXN0ID0gbmV3IHRoaXMoKSwgbGVuZ3RoLCBpdGVyYXRvciwgaXRlbTtcblxuICAgIGlmIChpdGVtcyAmJiAobGVuZ3RoID0gaXRlbXMubGVuZ3RoKSkge1xuICAgICAgICBpdGVyYXRvciA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJhdG9yIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpdGVtID0gaXRlbXNbaXRlcmF0b3JdO1xuXG4gICAgICAgICAgICBpZiAoaXRlbSAhPT0gbnVsbCAmJiBpdGVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBsaXN0LmFwcGVuZChpdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xufTtcblxuLyoqXG4gKiBMaXN0I2hlYWRcbiAqIERlZmF1bHQgdG8gYG51bGxgLlxuICovXG5MaXN0UHJvdG90eXBlLmhlYWQgPSBudWxsO1xuXG4vKipcbiAqIExpc3QjdGFpbFxuICogRGVmYXVsdCB0byBgbnVsbGAuXG4gKi9cbkxpc3RQcm90b3R5cGUudGFpbCA9IG51bGw7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGlzdCdzIGl0ZW1zIGFzIGFuIGFycmF5LiBUaGlzIGRvZXMgKm5vdCogZGV0YWNoIHRoZSBpdGVtcy5cbiAqIEBuYW1lIExpc3QjdG9BcnJheVxuICogQHJldHVybnMge0xpc3RJdGVtW119IC0gQW4gYXJyYXkgb2YgKHN0aWxsIGF0dGFjaGVkKSBMaXN0SXRlbXMuXG4gKi9cbkxpc3RQcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaXRlbSA9IHRoaXMuaGVhZCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoaXRlbSkge1xuICAgICAgICByZXN1bHQucHVzaChpdGVtKTtcbiAgICAgICAgaXRlbSA9IGl0ZW0ubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQcmVwZW5kcyB0aGUgZ2l2ZW4gaXRlbSB0byB0aGUgbGlzdDogSXRlbSB3aWxsIGJlIHRoZSBuZXcgZmlyc3QgaXRlbVxuICogKGBoZWFkYCkuXG4gKiBAbmFtZSBMaXN0I3ByZXBlbmRcbiAqIEBwYXJhbSB7TGlzdEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBwcmVwZW5kLlxuICogQHJldHVybnMge0xpc3RJdGVtfSAtIEFuIGluc3RhbmNlIG9mIExpc3RJdGVtICh0aGUgZ2l2ZW4gaXRlbSkuXG4gKi9cbkxpc3RQcm90b3R5cGUucHJlcGVuZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnI3ByZXBlbmRgLicpO1xuICAgIH1cblxuICAgIHZhciBzZWxmLCBoZWFkO1xuXG4gICAgLy8gQ2FjaGUgc2VsZi5cbiAgICBzZWxmID0gdGhpcztcblxuICAgIC8vIElmIHNlbGYgaGFzIGEgZmlyc3QgaXRlbSwgZGVmZXIgcHJlcGVuZCB0byB0aGUgZmlyc3QgaXRlbXMgcHJlcGVuZFxuICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgIGhlYWQgPSBzZWxmLmhlYWQ7XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgICByZXR1cm4gaGVhZC5wcmVwZW5kKGl0ZW0pO1xuICAgIH1cblxuICAgIC8vIC4uLm90aGVyd2lzZSwgdGhlcmUgaXMgbm8gYGhlYWRgIChvciBgdGFpbGApIGl0ZW0geWV0LlxuXG4gICAgLy8gRGV0YWNoIHRoZSBwcmVwZW5kZWUuXG4gICAgaXRlbS5kZXRhY2goKTtcblxuICAgIC8vIFNldCB0aGUgcHJlcGVuZGVlcyBwYXJlbnQgbGlzdCB0byByZWZlcmVuY2Ugc2VsZi5cbiAgICBpdGVtLmxpc3QgPSBzZWxmO1xuXG4gICAgLy8gU2V0IHNlbGYncyBmaXJzdCBpdGVtIHRvIHRoZSBwcmVwZW5kZWUsIGFuZCByZXR1cm4gdGhlIGl0ZW0uXG4gICAgc2VsZi5oZWFkID0gaXRlbTtcblxuICAgIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBpdGVtIHRvIHRoZSBsaXN0OiBJdGVtIHdpbGwgYmUgdGhlIG5ldyBsYXN0IGl0ZW0gKGB0YWlsYClcbiAqIGlmIHRoZSBsaXN0IGhhZCBhIGZpcnN0IGl0ZW0sIGFuZCBpdHMgZmlyc3QgaXRlbSAoYGhlYWRgKSBvdGhlcndpc2UuXG4gKiBAbmFtZSBMaXN0I2FwcGVuZFxuICogQHBhcmFtIHtMaXN0SXRlbX0gaXRlbSAtIFRoZSBpdGVtIHRvIGFwcGVuZC5cbiAqIEByZXR1cm5zIHtMaXN0SXRlbX0gLSBBbiBpbnN0YW5jZSBvZiBMaXN0SXRlbSAodGhlIGdpdmVuIGl0ZW0pLlxuICovXG5cbkxpc3RQcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmICghaXRlbS5hcHBlbmQgfHwgIWl0ZW0ucHJlcGVuZCB8fCAhaXRlbS5kZXRhY2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSArICcjYXBwZW5kYC4nKTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiwgaGVhZCwgdGFpbDtcblxuICAgIC8vIENhY2hlIHNlbGYuXG4gICAgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBJZiBzZWxmIGhhcyBhIGxhc3QgaXRlbSwgZGVmZXIgYXBwZW5kaW5nIHRvIHRoZSBsYXN0IGl0ZW1zIGFwcGVuZFxuICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgIHRhaWwgPSBzZWxmLnRhaWw7XG5cbiAgICBpZiAodGFpbCkge1xuICAgICAgICByZXR1cm4gdGFpbC5hcHBlbmQoaXRlbSk7XG4gICAgfVxuXG4gICAgLy8gSWYgc2VsZiBoYXMgYSBmaXJzdCBpdGVtLCBkZWZlciBhcHBlbmRpbmcgdG8gdGhlIGZpcnN0IGl0ZW1zIGFwcGVuZFxuICAgIC8vIG1ldGhvZCwgYW5kIHJldHVybiB0aGUgcmVzdWx0LlxuICAgIGhlYWQgPSBzZWxmLmhlYWQ7XG5cbiAgICBpZiAoaGVhZCkge1xuICAgICAgICByZXR1cm4gaGVhZC5hcHBlbmQoaXRlbSk7XG4gICAgfVxuXG4gICAgLy8gLi4ub3RoZXJ3aXNlLCB0aGVyZSBpcyBubyBgdGFpbGAgb3IgYGhlYWRgIGl0ZW0geWV0LlxuXG4gICAgLy8gRGV0YWNoIHRoZSBhcHBlbmRlZS5cbiAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgLy8gU2V0IHRoZSBhcHBlbmRlZXMgcGFyZW50IGxpc3QgdG8gcmVmZXJlbmNlIHNlbGYuXG4gICAgaXRlbS5saXN0ID0gc2VsZjtcblxuICAgIC8vIFNldCBzZWxmJ3MgZmlyc3QgaXRlbSB0byB0aGUgYXBwZW5kZWUsIGFuZCByZXR1cm4gdGhlIGl0ZW0uXG4gICAgc2VsZi5oZWFkID0gaXRlbTtcblxuICAgIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExpc3RJdGVtOiBBIGxpbmtlZCBsaXN0IGl0ZW0gaXMgYSBiaXQgbGlrZSBET00gbm9kZTpcbiAqIEl0IGtub3dzIG9ubHkgYWJvdXQgaXRzIFwicGFyZW50XCIgKGBsaXN0YCksIHRoZSBpdGVtIGJlZm9yZSBpdCAoYHByZXZgKSxcbiAqIGFuZCB0aGUgaXRlbSBhZnRlciBpdCAoYG5leHRgKS5cbiAqIEBnbG9iYWxcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBjbGFzcyBSZXByZXNlbnRzIGFuIGluc3RhbmNlIG9mIExpc3RJdGVtLlxuICovXG5cbmZ1bmN0aW9uIExpc3RJdGVtKCkge31cblxuTGlzdC5JdGVtID0gTGlzdEl0ZW07XG5cbnZhciBMaXN0SXRlbVByb3RvdHlwZSA9IExpc3RJdGVtLnByb3RvdHlwZTtcblxuTGlzdEl0ZW1Qcm90b3R5cGUubmV4dCA9IG51bGw7XG5cbkxpc3RJdGVtUHJvdG90eXBlLnByZXYgPSBudWxsO1xuXG5MaXN0SXRlbVByb3RvdHlwZS5saXN0ID0gbnVsbDtcblxuLyoqXG4gKiBEZXRhY2hlcyB0aGUgaXRlbSBvcGVyYXRlZCBvbiBmcm9tIGl0cyBwYXJlbnQgbGlzdC5cbiAqIEBuYW1lIExpc3RJdGVtI2RldGFjaFxuICogQHJldHVybnMge0xpc3RJdGVtfSAtIFRoZSBpdGVtIG9wZXJhdGVkIG9uLlxuICovXG5MaXN0SXRlbVByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2FjaGUgc2VsZiwgdGhlIHBhcmVudCBsaXN0LCBhbmQgdGhlIHByZXZpb3VzIGFuZCBuZXh0IGl0ZW1zLlxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgICAgcHJldiA9IHNlbGYucHJldixcbiAgICAgICAgbmV4dCA9IHNlbGYubmV4dDtcblxuICAgIC8vIElmIHRoZSBpdGVtIGlzIGFscmVhZHkgZGV0YWNoZWQsIHJldHVybiBzZWxmLlxuICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICAvLyBJZiBzZWxmIGlzIHRoZSBsYXN0IGl0ZW0gaW4gdGhlIHBhcmVudCBsaXN0LCBsaW5rIHRoZSBsaXN0cyBsYXN0IGl0ZW1cbiAgICAvLyB0byB0aGUgcHJldmlvdXMgaXRlbS5cbiAgICBpZiAobGlzdC50YWlsID09PSBzZWxmKSB7XG4gICAgICAgIGxpc3QudGFpbCA9IHByZXY7XG4gICAgfVxuXG4gICAgLy8gSWYgc2VsZiBpcyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgcGFyZW50IGxpc3QsIGxpbmsgdGhlIGxpc3RzIGZpcnN0IGl0ZW1cbiAgICAvLyB0byB0aGUgbmV4dCBpdGVtLlxuICAgIGlmIChsaXN0LmhlYWQgPT09IHNlbGYpIHtcbiAgICAgICAgbGlzdC5oZWFkID0gbmV4dDtcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIHRoZSBsYXN0IGFuZCBmaXJzdCBpdGVtcyBpbiB0aGUgcGFyZW50IGxpc3QgYXJlIHRoZSBzYW1lLFxuICAgIC8vIHJlbW92ZSB0aGUgbGluayB0byB0aGUgbGFzdCBpdGVtLlxuICAgIGlmIChsaXN0LnRhaWwgPT09IGxpc3QuaGVhZCkge1xuICAgICAgICBsaXN0LnRhaWwgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIGEgcHJldmlvdXMgaXRlbSBleGlzdHMsIGxpbmsgaXRzIG5leHQgaXRlbSB0byBzZWxmcyBuZXh0IGl0ZW0uXG4gICAgaWYgKHByZXYpIHtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICB9XG5cbiAgICAvLyBJZiBhIG5leHQgaXRlbSBleGlzdHMsIGxpbmsgaXRzIHByZXZpb3VzIGl0ZW0gdG8gc2VsZnMgcHJldmlvdXMgaXRlbS5cbiAgICBpZiAobmV4dCkge1xuICAgICAgICBuZXh0LnByZXYgPSBwcmV2O1xuICAgIH1cblxuICAgIC8vIFJlbW92ZSBsaW5rcyBmcm9tIHNlbGYgdG8gYm90aCB0aGUgbmV4dCBhbmQgcHJldmlvdXMgaXRlbXMsIGFuZCB0byB0aGVcbiAgICAvLyBwYXJlbnQgbGlzdC5cbiAgICBzZWxmLnByZXYgPSBzZWxmLm5leHQgPSBzZWxmLmxpc3QgPSBudWxsO1xuXG4gICAgLy8gUmV0dXJuIHNlbGYuXG4gICAgcmV0dXJuIHNlbGY7XG59O1xuXG4vKipcbiAqIFByZXBlbmRzIHRoZSBnaXZlbiBpdGVtICpiZWZvcmUqIHRoZSBpdGVtIG9wZXJhdGVkIG9uLlxuICogQG5hbWUgTGlzdEl0ZW0jcHJlcGVuZFxuICogQHBhcmFtIHtMaXN0SXRlbX0gaXRlbSAtIFRoZSBpdGVtIHRvIHByZXBlbmQuXG4gKiBAcmV0dXJucyB7TGlzdEl0ZW19IC0gVGhlIGl0ZW0gb3BlcmF0ZWQgb24sIG9yIGZhbHNlIHdoZW4gdGhhdCBpdGVtIGlzIG5vdFxuICogYXR0YWNoZWQuXG4gKi9cbkxpc3RJdGVtUHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGlmICghaXRlbSB8fCAhaXRlbS5hcHBlbmQgfHwgIWl0ZW0ucHJlcGVuZCB8fCAhaXRlbS5kZXRhY2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSArICdJdGVtI3ByZXBlbmRgLicpO1xuICAgIH1cblxuICAgIC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBwcmV2aW91cyBpdGVtLlxuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgbGlzdCA9IHNlbGYubGlzdCxcbiAgICAgICAgcHJldiA9IHNlbGYucHJldjtcblxuICAgIC8vIElmIHNlbGYgaXMgZGV0YWNoZWQsIHJldHVybiBmYWxzZS5cbiAgICBpZiAoIWxpc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIERldGFjaCB0aGUgcHJlcGVuZGVlLlxuICAgIGl0ZW0uZGV0YWNoKCk7XG5cbiAgICAvLyBJZiBzZWxmIGhhcyBhIHByZXZpb3VzIGl0ZW0uLi5cbiAgICBpZiAocHJldikge1xuICAgICAgICAvLyAuLi5saW5rIHRoZSBwcmVwZW5kZWVzIHByZXZpb3VzIGl0ZW0sIHRvIHNlbGZzIHByZXZpb3VzIGl0ZW0uXG4gICAgICAgIGl0ZW0ucHJldiA9IHByZXY7XG5cbiAgICAgICAgLy8gLi4ubGluayB0aGUgcHJldmlvdXMgaXRlbXMgbmV4dCBpdGVtLCB0byBzZWxmLlxuICAgICAgICBwcmV2Lm5leHQgPSBpdGVtO1xuICAgIH1cblxuICAgIC8vIFNldCB0aGUgcHJlcGVuZGVlcyBuZXh0IGl0ZW0gdG8gc2VsZi5cbiAgICBpdGVtLm5leHQgPSBzZWxmO1xuXG4gICAgLy8gU2V0IHRoZSBwcmVwZW5kZWVzIHBhcmVudCBsaXN0IHRvIHNlbGZzIHBhcmVudCBsaXN0LlxuICAgIGl0ZW0ubGlzdCA9IGxpc3Q7XG5cbiAgICAvLyBTZXQgdGhlIHByZXZpb3VzIGl0ZW0gb2Ygc2VsZiB0byB0aGUgcHJlcGVuZGVlLlxuICAgIHNlbGYucHJldiA9IGl0ZW07XG5cbiAgICAvLyBJZiBzZWxmIGlzIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBwYXJlbnQgbGlzdCwgbGluayB0aGUgbGlzdHMgZmlyc3QgaXRlbVxuICAgIC8vIHRvIHRoZSBwcmVwZW5kZWUuXG4gICAgaWYgKHNlbGYgPT09IGxpc3QuaGVhZCkge1xuICAgICAgICBsaXN0LmhlYWQgPSBpdGVtO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB0aGUgcGFyZW50IGxpc3QgaGFzIG5vIGxhc3QgaXRlbSwgbGluayB0aGUgbGlzdHMgbGFzdCBpdGVtIHRvXG4gICAgLy8gc2VsZi5cbiAgICBpZiAoIWxpc3QudGFpbCkge1xuICAgICAgICBsaXN0LnRhaWwgPSBzZWxmO1xuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgcHJlcGVuZGVlLlxuICAgIHJldHVybiBpdGVtO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIHRoZSBnaXZlbiBpdGVtICphZnRlciogdGhlIGl0ZW0gb3BlcmF0ZWQgb24uXG4gKiBAbmFtZSBMaXN0SXRlbSNhcHBlbmRcbiAqIEBwYXJhbSB7TGlzdEl0ZW19IGl0ZW0gLSBUaGUgaXRlbSB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7TGlzdEl0ZW19IC0gVGhlIGl0ZW0gb3BlcmF0ZWQgb24sIG9yIGZhbHNlIHdoZW4gdGhhdCBpdGVtIGlzIG5vdFxuICogYXR0YWNoZWQuXG4gKi9cbkxpc3RJdGVtUHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgLy8gSWYgaXRlbSBpcyBmYWxzZXksIHJldHVybiBmYWxzZS5cbiAgICBpZiAoIWl0ZW0gfHwgIWl0ZW0uYXBwZW5kIHx8ICFpdGVtLnByZXBlbmQgfHwgIWl0ZW0uZGV0YWNoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UgKyAnSXRlbSNhcHBlbmRgLicpO1xuICAgIH1cblxuICAgIC8vIENhY2hlIHNlbGYsIHRoZSBwYXJlbnQgbGlzdCwgYW5kIHRoZSBuZXh0IGl0ZW0uXG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBsaXN0ID0gc2VsZi5saXN0LFxuICAgICAgICBuZXh0ID0gc2VsZi5uZXh0O1xuXG4gICAgLy8gSWYgc2VsZiBpcyBkZXRhY2hlZCwgcmV0dXJuIGZhbHNlLlxuICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gRGV0YWNoIHRoZSBhcHBlbmRlZS5cbiAgICBpdGVtLmRldGFjaCgpO1xuXG4gICAgLy8gSWYgc2VsZiBoYXMgYSBuZXh0IGl0ZW0uLi5cbiAgICBpZiAobmV4dCkge1xuICAgICAgICAvLyAuLi5saW5rIHRoZSBhcHBlbmRlZXMgbmV4dCBpdGVtLCB0byBzZWxmcyBuZXh0IGl0ZW0uXG4gICAgICAgIGl0ZW0ubmV4dCA9IG5leHQ7XG5cbiAgICAgICAgLy8gLi4ubGluayB0aGUgbmV4dCBpdGVtcyBwcmV2aW91cyBpdGVtLCB0byB0aGUgYXBwZW5kZWUuXG4gICAgICAgIG5leHQucHJldiA9IGl0ZW07XG4gICAgfVxuXG4gICAgLy8gU2V0IHRoZSBhcHBlbmRlZXMgcHJldmlvdXMgaXRlbSB0byBzZWxmLlxuICAgIGl0ZW0ucHJldiA9IHNlbGY7XG5cbiAgICAvLyBTZXQgdGhlIGFwcGVuZGVlcyBwYXJlbnQgbGlzdCB0byBzZWxmcyBwYXJlbnQgbGlzdC5cbiAgICBpdGVtLmxpc3QgPSBsaXN0O1xuXG4gICAgLy8gU2V0IHRoZSBuZXh0IGl0ZW0gb2Ygc2VsZiB0byB0aGUgYXBwZW5kZWUuXG4gICAgc2VsZi5uZXh0ID0gaXRlbTtcblxuICAgIC8vIElmIHRoZSB0aGUgcGFyZW50IGxpc3QgaGFzIG5vIGxhc3QgaXRlbSBvciBpZiBzZWxmIGlzIHRoZSBwYXJlbnQgbGlzdHNcbiAgICAvLyBsYXN0IGl0ZW0sIGxpbmsgdGhlIGxpc3RzIGxhc3QgaXRlbSB0byB0aGUgYXBwZW5kZWUuXG4gICAgaWYgKHNlbGYgPT09IGxpc3QudGFpbCB8fCAhbGlzdC50YWlsKSB7XG4gICAgICAgIGxpc3QudGFpbCA9IGl0ZW07XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoZSBhcHBlbmRlZS5cbiAgICByZXR1cm4gaXRlbTtcbn07XG5cbi8qKlxuICogRXhwb3NlIGBMaXN0YC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9fc291cmNlL2xpbmtlZC1saXN0LmpzJyk7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogVXNlZCB0byBtYXRjaCBgUmVnRXhwYFxuICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gKi9cbnZhciByZVJlZ0V4cENoYXIgPSAvW1xcXFxeJC4qKz8oKVtcXF17fXxdL2c7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG52YXIgcmVJc0hvc3RDdG9yID0gL15cXFtvYmplY3QgLis/Q29uc3RydWN0b3JcXF0kLztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKipcbiAqIEFkZHMgdGhlIGtleS12YWx1ZSBgcGFpcmAgdG8gYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwYWlyIFRoZSBrZXktdmFsdWUgcGFpciB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBtYXBgLlxuICovXG5mdW5jdGlvbiBhZGRNYXBFbnRyeShtYXAsIHBhaXIpIHtcbiAgLy8gRG9uJ3QgcmV0dXJuIGBtYXAuc2V0YCBiZWNhdXNlIGl0J3Mgbm90IGNoYWluYWJsZSBpbiBJRSAxMS5cbiAgbWFwLnNldChwYWlyWzBdLCBwYWlyWzFdKTtcbiAgcmV0dXJuIG1hcDtcbn1cblxuLyoqXG4gKiBBZGRzIGB2YWx1ZWAgdG8gYHNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBtb2RpZnkuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhZGQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBzZXRgLlxuICovXG5mdW5jdGlvbiBhZGRTZXRFbnRyeShzZXQsIHZhbHVlKSB7XG4gIC8vIERvbid0IHJldHVybiBgc2V0LmFkZGAgYmVjYXVzZSBpdCdzIG5vdCBjaGFpbmFibGUgaW4gSUUgMTEuXG4gIHNldC5hZGQodmFsdWUpO1xuICByZXR1cm4gc2V0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG4vKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlSZWR1Y2UoYXJyYXksIGl0ZXJhdGVlLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIGlmIChpbml0QWNjdW0gJiYgbGVuZ3RoKSB7XG4gICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlKG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QgaW4gSUUgPCA5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgaG9zdCBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNIb3N0T2JqZWN0KHZhbHVlKSB7XG4gIC8vIE1hbnkgaG9zdCBvYmplY3RzIGFyZSBgT2JqZWN0YCBvYmplY3RzIHRoYXQgY2FuIGNvZXJjZSB0byBzdHJpbmdzXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXG4gIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgaWYgKHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgcmVzdWx0ID0gISEodmFsdWUgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBrZXktdmFsdWUgcGFpcnMuXG4gKi9cbmZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobWFwLnNpemUpO1xuXG4gIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSBba2V5LCB2YWx1ZV07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc2V0YCB0byBhbiBhcnJheSBvZiBpdHMgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBzZXRUb0FycmF5KHNldCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICBzZXQuZm9yRWFjaChmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGUsXG4gICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG92ZXJyZWFjaGluZyBjb3JlLWpzIHNoaW1zLiAqL1xudmFyIGNvcmVKc0RhdGEgPSByb290WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbnZhciBtYXNrU3JjS2V5ID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdWlkID0gL1teLl0rJC8uZXhlYyhjb3JlSnNEYXRhICYmIGNvcmVKc0RhdGEua2V5cyAmJiBjb3JlSnNEYXRhLmtleXMuSUVfUFJPVE8gfHwgJycpO1xuICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG59KCkpO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZS4gKi9cbnZhciByZUlzTmF0aXZlID0gUmVnRXhwKCdeJyArXG4gIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gIC5yZXBsYWNlKC9oYXNPd25Qcm9wZXJ0eXwoZnVuY3Rpb24pLio/KD89XFxcXFxcKCl8IGZvciAuKz8oPz1cXFxcXFxdKS9nLCAnJDEuKj8nKSArICckJ1xuKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgIFN5bWJvbCA9IHJvb3QuU3ltYm9sLFxuICAgIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXksXG4gICAgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCksXG4gICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlLFxuICAgIHNwbGljZSA9IGFycmF5UHJvdG8uc3BsaWNlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShyb290LCAnRGF0YVZpZXcnKSxcbiAgICBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpLFxuICAgIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKSxcbiAgICBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpLFxuICAgIFdlYWtNYXAgPSBnZXROYXRpdmUocm9vdCwgJ1dlYWtNYXAnKSxcbiAgICBuYXRpdmVDcmVhdGUgPSBnZXROYXRpdmUoT2JqZWN0LCAnY3JlYXRlJyk7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFZhbHVlT2YgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnZhbHVlT2YgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBTdGFja1xuICovXG5mdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tEZWxldGUoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fWydkZWxldGUnXShrZXkpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHN0YWNrIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBzdGFja0dldChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uZ2V0KGtleSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc3RhY2sgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrU2V0KGtleSwgdmFsdWUpIHtcbiAgdmFyIGNhY2hlID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGNhY2hlIGluc3RhbmNlb2YgTGlzdENhY2hlKSB7XG4gICAgdmFyIHBhaXJzID0gY2FjaGUuX19kYXRhX187XG4gICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgcGFpcnMucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNhY2hlID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gIH1cbiAgY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICAvLyBTYWZhcmkgOSBtYWtlcyBgYXJndW1lbnRzLmxlbmd0aGAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgdmFyIHJlc3VsdCA9IChpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkpXG4gICAgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpXG4gICAgOiBbXTtcblxuICB2YXIgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aCxcbiAgICAgIHNraXBJbmRleGVzID0gISFsZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoa2V5ID09ICdsZW5ndGgnIHx8IGlzSW5kZXgoa2V5LCBsZW5ndGgpKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSBrZXkgVGhlIGtleSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYXNzb2NJbmRleE9mKGFycmF5LCBrZXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgaWYgKGVxKGFycmF5W2xlbmd0aF1bMF0sIGtleSkpIHtcbiAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hc3NpZ25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ24ob2JqZWN0LCBzb3VyY2UpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsb25lYCBhbmQgYF8uY2xvbmVEZWVwYCB3aGljaCB0cmFja3NcbiAqIHRyYXZlcnNlZCBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0Z1bGxdIFNwZWNpZnkgYSBjbG9uZSBpbmNsdWRpbmcgc3ltYm9scy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2tleV0gVGhlIGtleSBvZiBgdmFsdWVgLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIG9iamVjdHMgYW5kIHRoZWlyIGNsb25lIGNvdW50ZXJwYXJ0cy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBjbG9uZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGJhc2VDbG9uZSh2YWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICBpZiAoaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGluaXRDbG9uZU9iamVjdChpc0Z1bmMgPyB7fSA6IHZhbHVlKTtcbiAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgIHJldHVybiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgYmFzZUNsb25lLCBpc0RlZXApO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyBhbmQgcmV0dXJuIGl0cyBjb3JyZXNwb25kaW5nIGNsb25lLlxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gIGlmIChzdGFja2VkKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQ7XG4gIH1cbiAgc3RhY2suc2V0KHZhbHVlLCByZXN1bHQpO1xuXG4gIGlmICghaXNBcnIpIHtcbiAgICB2YXIgcHJvcHMgPSBpc0Z1bGwgPyBnZXRBbGxLZXlzKHZhbHVlKSA6IGtleXModmFsdWUpO1xuICB9XG4gIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgIGlmIChwcm9wcykge1xuICAgICAga2V5ID0gc3ViVmFsdWU7XG4gICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IHBvcHVsYXRlIGNsb25lIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgaXNEZWVwLCBpc0Z1bGwsIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNyZWF0ZWAgd2l0aG91dCBzdXBwb3J0IGZvciBhc3NpZ25pbmdcbiAqIHByb3BlcnRpZXMgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZUNyZWF0ZShwcm90bykge1xuICByZXR1cm4gaXNPYmplY3QocHJvdG8pID8gb2JqZWN0Q3JlYXRlKHByb3RvKSA6IHt9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNOYXRpdmVgIHdpdGhvdXQgYmFkIHNoaW0gY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbmF0aXZlIGZ1bmN0aW9uLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTmF0aXZlKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgcGF0dGVybiA9IChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBpc0hvc3RPYmplY3QodmFsdWUpKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUJ1ZmZlcihidWZmZXIsIGlzRGVlcCkge1xuICBpZiAoaXNEZWVwKSB7XG4gICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGJ1ZmZlci5sZW5ndGgpO1xuICBidWZmZXIuY29weShyZXN1bHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgYXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBhcnJheUJ1ZmZlciBUaGUgYXJyYXkgYnVmZmVyIHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5QnVmZmVyfSBSZXR1cm5zIHRoZSBjbG9uZWQgYXJyYXkgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBjbG9uZUFycmF5QnVmZmVyKGFycmF5QnVmZmVyKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgYXJyYXlCdWZmZXIuY29uc3RydWN0b3IoYXJyYXlCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBkYXRhVmlld2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhVmlldyBUaGUgZGF0YSB2aWV3IHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGF0YVZpZXcoZGF0YVZpZXcsIGlzRGVlcCkge1xuICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICByZXR1cm4gbmV3IGRhdGFWaWV3LmNvbnN0cnVjdG9yKGJ1ZmZlciwgZGF0YVZpZXcuYnl0ZU9mZnNldCwgZGF0YVZpZXcuYnl0ZUxlbmd0aCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9uZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNsb25lIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgbWFwLlxuICovXG5mdW5jdGlvbiBjbG9uZU1hcChtYXAsIGlzRGVlcCwgY2xvbmVGdW5jKSB7XG4gIHZhciBhcnJheSA9IGlzRGVlcCA/IGNsb25lRnVuYyhtYXBUb0FycmF5KG1hcCksIHRydWUpIDogbWFwVG9BcnJheShtYXApO1xuICByZXR1cm4gYXJyYXlSZWR1Y2UoYXJyYXksIGFkZE1hcEVudHJ5LCBuZXcgbWFwLmNvbnN0cnVjdG9yKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgc2V0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNsb25lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvbmVGdW5jIFRoZSBmdW5jdGlvbiB0byBjbG9uZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHNldC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTZXQoc2V0LCBpc0RlZXAsIGNsb25lRnVuYykge1xuICB2YXIgYXJyYXkgPSBpc0RlZXAgPyBjbG9uZUZ1bmMoc2V0VG9BcnJheShzZXQpLCB0cnVlKSA6IHNldFRvQXJyYXkoc2V0KTtcbiAgcmV0dXJuIGFycmF5UmVkdWNlKGFycmF5LCBhZGRTZXRFbnRyeSwgbmV3IHNldC5jb25zdHJ1Y3Rvcik7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgc3ltYm9sIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gIHJldHVybiBzeW1ib2xWYWx1ZU9mID8gT2JqZWN0KHN5bWJvbFZhbHVlT2YuY2FsbChzeW1ib2wpKSA6IHt9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgdHlwZWRBcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlZEFycmF5IFRoZSB0eXBlZCBhcnJheSB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNsb25lVHlwZWRBcnJheSh0eXBlZEFycmF5LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gIHJldHVybiBuZXcgdHlwZWRBcnJheS5jb25zdHJ1Y3RvcihidWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlID09PSB1bmRlZmluZWQgPyBzb3VyY2Vba2V5XSA6IG5ld1ZhbHVlKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG4vKipcbiAqIENvcGllcyBvd24gc3ltYm9sIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0PXt9XSBUaGUgb2JqZWN0IHRvIGNvcHkgc3ltYm9scyB0by5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlTeW1ib2xzKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXMsIGdldFN5bWJvbHMpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEgZm9yIGBtYXBgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwIFRoZSBtYXAgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1hcCBkYXRhLlxuICovXG5mdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gIHZhciBkYXRhID0gbWFwLl9fZGF0YV9fO1xuICByZXR1cm4gaXNLZXlhYmxlKGtleSlcbiAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgIDogZGF0YS5tYXA7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9sIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHMgPSBuYXRpdmVHZXRTeW1ib2xzID8gb3ZlckFyZyhuYXRpdmVHZXRTeW1ib2xzLCBPYmplY3QpIDogc3R1YkFycmF5O1xuXG4vKipcbiAqIEdldHMgdGhlIGB0b1N0cmluZ1RhZ2Agb2YgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG52YXIgZ2V0VGFnID0gYmFzZUdldFRhZztcblxuLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEsXG4vLyBmb3IgZGF0YSB2aWV3cyBpbiBFZGdlIDwgMTQsIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzLlxuaWYgKChEYXRhVmlldyAmJiBnZXRUYWcobmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcigxKSkpICE9IGRhdGFWaWV3VGFnKSB8fFxuICAgIChNYXAgJiYgZ2V0VGFnKG5ldyBNYXApICE9IG1hcFRhZykgfHxcbiAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgKFNldCAmJiBnZXRUYWcobmV3IFNldCkgIT0gc2V0VGFnKSB8fFxuICAgIChXZWFrTWFwICYmIGdldFRhZyhuZXcgV2Vha01hcCkgIT0gd2Vha01hcFRhZykpIHtcbiAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSksXG4gICAgICAgIEN0b3IgPSByZXN1bHQgPT0gb2JqZWN0VGFnID8gdmFsdWUuY29uc3RydWN0b3IgOiB1bmRlZmluZWQsXG4gICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gYXJyYXkgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUFycmF5KGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBvYmplY3QgY2xvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVPYmplY3Qob2JqZWN0KSB7XG4gIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgID8gYmFzZUNyZWF0ZShnZXRQcm90b3R5cGUob2JqZWN0KSlcbiAgICA6IHt9O1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZSBiYXNlZCBvbiBpdHMgYHRvU3RyaW5nVGFnYC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNsb25pbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdCB0byBjbG9uZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNsb25lRnVuYyBUaGUgZnVuY3Rpb24gdG8gY2xvbmUgdmFsdWVzLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICovXG5mdW5jdGlvbiBpbml0Q2xvbmVCeVRhZyhvYmplY3QsIHRhZywgY2xvbmVGdW5jLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBjbG9uZU1hcChvYmplY3QsIGlzRGVlcCwgY2xvbmVGdW5jKTtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gY2xvbmVTZXQob2JqZWN0LCBpc0RlZXAsIGNsb25lRnVuYyk7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyB8fCByZUlzVWludC50ZXN0KHZhbHVlKSkgJiZcbiAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgc3VpdGFibGUgZm9yIHVzZSBhcyB1bmlxdWUgb2JqZWN0IGtleS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleWFibGUodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgPyAodmFsdWUgIT09ICdfX3Byb3RvX18nKVxuICAgIDogKHZhbHVlID09PSBudWxsKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGZ1bmNgIGlzIG1hc2tlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gIHJldHVybiAhIW1hc2tTcmNLZXkgJiYgKG1hc2tTcmNLZXkgaW4gZnVuYyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMS4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBkZWVwIGNsb25lZCB2YWx1ZS5cbiAqIEBzZWUgXy5jbG9uZVxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgZGVlcCA9IF8uY2xvbmVEZWVwKG9iamVjdHMpO1xuICogY29uc29sZS5sb2coZGVlcFswXSA9PT0gb2JqZWN0c1swXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FyZ3VtZW50cyh2YWx1ZSkge1xuICAvLyBTYWZhcmkgOC4xIG1ha2VzIGBhcmd1bWVudHMuY2FsbGVlYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICghcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpIHx8IG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IGFyZ3NUYWcpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5cyk7XG4gKiAvLyA9PiBbW10sIFtdXVxuICpcbiAqIGNvbnNvbGUubG9nKGFycmF5c1swXSA9PT0gYXJyYXlzWzFdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIHN0dWJBcnJheSgpIHtcbiAgcmV0dXJuIFtdO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVEZWVwO1xuIiwiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZyxcbiAgICByZUhhc1JlZ0V4cENoYXIgPSBSZWdFeHAocmVSZWdFeHBDaGFyLnNvdXJjZSk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNi4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAqIGFuZCBgdW5kZWZpbmVkYCB2YWx1ZXMuIFRoZSBzaWduIG9mIGAtMGAgaXMgcHJlc2VydmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG4vKipcbiAqIEVzY2FwZXMgdGhlIGBSZWdFeHBgIHNwZWNpYWwgY2hhcmFjdGVycyBcIl5cIiwgXCIkXCIsIFwiXFxcIiwgXCIuXCIsIFwiKlwiLCBcIitcIixcbiAqIFwiP1wiLCBcIihcIiwgXCIpXCIsIFwiW1wiLCBcIl1cIiwgXCJ7XCIsIFwifVwiLCBhbmQgXCJ8XCIgaW4gYHN0cmluZ2AuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IFN0cmluZ1xuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZXNjYXBlLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICogLy8gPT4gJ1xcW2xvZGFzaFxcXVxcKGh0dHBzOi8vbG9kYXNoXFwuY29tL1xcKSdcbiAqL1xuZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICByZXR1cm4gKHN0cmluZyAmJiByZUhhc1JlZ0V4cENoYXIudGVzdChzdHJpbmcpKVxuICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVSZWdFeHA7XG4iLCIvKipcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIEJ1aWxkOiBgbG9kYXNoIG1vZHVsYXJpemUgZXhwb3J0cz1cIm5wbVwiIC1vIC4vYFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKiBCYXNlZCBvbiBVbmRlcnNjb3JlLmpzIDEuOC4zIDxodHRwOi8vdW5kZXJzY29yZWpzLm9yZy9MSUNFTlNFPlxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4gKi9cblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqIFVzZWQgYXMgdGhlIGBUeXBlRXJyb3JgIG1lc3NhZ2UgZm9yIFwiRnVuY3Rpb25zXCIgbWV0aG9kcy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbnZhciBIQVNIX1VOREVGSU5FRCA9ICdfX2xvZGFzaF9oYXNoX3VuZGVmaW5lZF9fJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY29tcGFyaXNvbiBzdHlsZXMuICovXG52YXIgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyA9IDEsXG4gICAgUEFSVElBTF9DT01QQVJFX0ZMQUcgPSAyO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBJTkZJTklUWSA9IDEgLyAwLFxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcHJvbWlzZVRhZyA9ICdbb2JqZWN0IFByb21pc2VdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvLFxuICAgIHJlTGVhZGluZ0RvdCA9IC9eXFwuLyxcbiAgICByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKipcbiAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAqIFtzeW50YXggY2hhcmFjdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcGF0dGVybnMpLlxuICovXG52YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VBZ2dyZWdhdG9yYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICovXG5mdW5jdGlvbiBhcnJheUFnZ3JlZ2F0b3IoYXJyYXksIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIHNldHRlcihhY2N1bXVsYXRvciwgdmFsdWUsIGl0ZXJhdGVlKHZhbHVlKSwgYXJyYXkpO1xuICB9XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHJvcGVydHlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5KGtleSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gIH07XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCBpbiBJRSA8IDkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0hvc3RPYmplY3QodmFsdWUpIHtcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcbiAgLy8gZGVzcGl0ZSBoYXZpbmcgaW1wcm9wZXJseSBkZWZpbmVkIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSAhISh2YWx1ZSArICcnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBzZXRgIHRvIGFuIGFycmF5IG9mIGl0cyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXQgVGhlIHNldCB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHNldFRvQXJyYXkoc2V0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbnZhciBmdW5jVG9TdHJpbmcgPSBmdW5jUHJvdG8udG9TdHJpbmc7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbCxcbiAgICBVaW50OEFycmF5ID0gcm9vdC5VaW50OEFycmF5LFxuICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpLFxuICAgIE1hcCA9IGdldE5hdGl2ZShyb290LCAnTWFwJyksXG4gICAgUHJvbWlzZSA9IGdldE5hdGl2ZShyb290LCAnUHJvbWlzZScpLFxuICAgIFNldCA9IGdldE5hdGl2ZShyb290LCAnU2V0JyksXG4gICAgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpLFxuICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG1hcHMsIHNldHMsIGFuZCB3ZWFrbWFwcy4gKi9cbnZhciBkYXRhVmlld0N0b3JTdHJpbmcgPSB0b1NvdXJjZShEYXRhVmlldyksXG4gICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgcHJvbWlzZUN0b3JTdHJpbmcgPSB0b1NvdXJjZShQcm9taXNlKSxcbiAgICBzZXRDdG9yU3RyaW5nID0gdG9Tb3VyY2UoU2V0KSxcbiAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udG9TdHJpbmcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBoYXNoLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge09iamVjdH0gaGFzaCBUaGUgaGFzaCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaERlbGV0ZShrZXkpIHtcbiAgcmV0dXJuIHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBoYXNoIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgSGFzaFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKG5hdGl2ZUNyZWF0ZSkge1xuICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgcmV0dXJuIHJlc3VsdCA9PT0gSEFTSF9VTkRFRklORUQgPyB1bmRlZmluZWQgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoSGFzKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHJldHVybiBuYXRpdmVDcmVhdGUgPyBkYXRhW2tleV0gIT09IHVuZGVmaW5lZCA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaGFzaCBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG5IYXNoLnByb3RvdHlwZS5jbGVhciA9IGhhc2hDbGVhcjtcbkhhc2gucHJvdG90eXBlWydkZWxldGUnXSA9IGhhc2hEZWxldGU7XG5IYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuSGFzaC5wcm90b3R5cGUuaGFzID0gaGFzaEhhcztcbkhhc2gucHJvdG90eXBlLnNldCA9IGhhc2hTZXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBsaXN0IGNhY2hlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTGlzdENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID8gZW50cmllcy5sZW5ndGggOiAwO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuX19kYXRhX18gPSBbXTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGxhc3RJbmRleCA9IGRhdGEubGVuZ3RoIC0gMTtcbiAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgIGRhdGEucG9wKCk7XG4gIH0gZWxzZSB7XG4gICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbGlzdENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBsaXN0IGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICBpbmRleCA9IGFzc29jSW5kZXhPZihkYXRhLCBrZXkpO1xuXG4gIGlmIChpbmRleCA8IDApIHtcbiAgICBkYXRhLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhW2luZGV4XVsxXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTGlzdENhY2hlYC5cbkxpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbkxpc3RDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbGlzdENhY2hlRGVsZXRlO1xuTGlzdENhY2hlLnByb3RvdHlwZS5nZXQgPSBsaXN0Q2FjaGVHZXQ7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbkxpc3RDYWNoZS5wcm90b3R5cGUuc2V0ID0gbGlzdENhY2hlU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAqL1xuZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGVudHJpZXMgPyBlbnRyaWVzLmxlbmd0aCA6IDA7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IHtcbiAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICdtYXAnOiBuZXcgKE1hcCB8fCBMaXN0Q2FjaGUpLFxuICAgICdzdHJpbmcnOiBuZXcgSGFzaFxuICB9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHJlbW92ZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVEZWxldGUoa2V5KSB7XG4gIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBtYXAgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5oYXMoa2V5KTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBtYXAgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbWFwIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIGdldE1hcERhdGEodGhpcywga2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgTWFwQ2FjaGVgLlxuTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbk1hcENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBtYXBDYWNoZURlbGV0ZTtcbk1hcENhY2hlLnByb3RvdHlwZS5nZXQgPSBtYXBDYWNoZUdldDtcbk1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbk1hcENhY2hlLnByb3RvdHlwZS5zZXQgPSBtYXBDYWNoZVNldDtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPyB2YWx1ZXMubGVuZ3RoIDogMDtcblxuICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHRoaXMuYWRkKHZhbHVlc1tpbmRleF0pO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiB0aGUgYXJyYXkgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFNldENhY2hlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUhhcyh2YWx1ZSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXModmFsdWUpO1xufVxuXG4vLyBBZGQgbWV0aG9kcyB0byBgU2V0Q2FjaGVgLlxuU2V0Q2FjaGUucHJvdG90eXBlLmFkZCA9IFNldENhY2hlLnByb3RvdHlwZS5wdXNoID0gc2V0Q2FjaGVBZGQ7XG5TZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YWNrIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKGVudHJpZXMpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfX1snZGVsZXRlJ10oa2V5KTtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzdGFjayB2YWx1ZSBmb3IgYGtleWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGdldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmdldChrZXkpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YWNrIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyhrZXkpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBjYWNoZSA9IHRoaXMuX19kYXRhX187XG4gIGlmIChjYWNoZSBpbnN0YW5jZW9mIExpc3RDYWNoZSkge1xuICAgIHZhciBwYWlycyA9IGNhY2hlLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjYWNoZSA9IHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGUocGFpcnMpO1xuICB9XG4gIGNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG5TdGFjay5wcm90b3R5cGUuY2xlYXIgPSBzdGFja0NsZWFyO1xuU3RhY2sucHJvdG90eXBlWydkZWxldGUnXSA9IHN0YWNrRGVsZXRlO1xuU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuU3RhY2sucHJvdG90eXBlLmhhcyA9IHN0YWNrSGFzO1xuU3RhY2sucHJvdG90eXBlLnNldCA9IHN0YWNrU2V0O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgLy8gU2FmYXJpIDkgbWFrZXMgYGFyZ3VtZW50cy5sZW5ndGhgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHZhciByZXN1bHQgPSAoaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKVxuICAgID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKVxuICAgIDogW107XG5cbiAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGgsXG4gICAgICBza2lwSW5kZXhlcyA9ICEhbGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKGtleSA9PSAnbGVuZ3RoJyB8fCBpc0luZGV4KGtleSwgbGVuZ3RoKSkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGluZGV4IGF0IHdoaWNoIHRoZSBga2V5YCBpcyBmb3VuZCBpbiBgYXJyYXlgIG9mIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IGtleSBUaGUga2V5IHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBhc3NvY0luZGV4T2YoYXJyYXksIGtleSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICBpZiAoZXEoYXJyYXlbbGVuZ3RoXVswXSwga2V5KSkge1xuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gKiBieSBgaXRlcmF0ZWVgIGFuZCB2YWx1ZXMgc2V0IGJ5IGBzZXR0ZXJgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBgYWNjdW11bGF0b3JgIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBhZ2dyZWdhdGVkIG9iamVjdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgYWNjdW11bGF0b3JgLlxuICovXG5mdW5jdGlvbiBiYXNlQWdncmVnYXRvcihjb2xsZWN0aW9uLCBzZXR0ZXIsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JFYWNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAqL1xudmFyIGJhc2VFYWNoID0gY3JlYXRlQmFzZUVhY2goYmFzZUZvck93bik7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mb3JPd25gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBiYXNlRm9yT3duKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICB2YXIgaW5kZXggPSAwLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG5cbiAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgb2JqZWN0ID0gb2JqZWN0W3RvS2V5KHBhdGhbaW5kZXgrK10pXTtcbiAgfVxuICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtiaXRtYXNrXSBUaGUgYml0bWFzayBvZiBjb21wYXJpc29uIGZsYWdzLlxuICogIFRoZSBiaXRtYXNrIG1heSBiZSBjb21wb3NlZCBvZiB0aGUgZm9sbG93aW5nIGZsYWdzOlxuICogICAgIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogICAgIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgYHZhbHVlYCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICBpZiAodmFsdWUgPT09IG90aGVyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwgfHwgb3RoZXIgPT0gbnVsbCB8fCAoIWlzT2JqZWN0KHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYmFzZUlzRXF1YWwsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gKiBkZWVwIGNvbXBhcmlzb25zIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gKiByZWZlcmVuY2VzIHRvIGJlIGNvbXBhcmVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYml0bWFza10gVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0VxdWFsRGVlcChvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgIG90aElzQXJyID0gaXNBcnJheShvdGhlciksXG4gICAgICBvYmpUYWcgPSBhcnJheVRhZyxcbiAgICAgIG90aFRhZyA9IGFycmF5VGFnO1xuXG4gIGlmICghb2JqSXNBcnIpIHtcbiAgICBvYmpUYWcgPSBnZXRUYWcob2JqZWN0KTtcbiAgICBvYmpUYWcgPSBvYmpUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG9ialRhZztcbiAgfVxuICBpZiAoIW90aElzQXJyKSB7XG4gICAgb3RoVGFnID0gZ2V0VGFnKG90aGVyKTtcbiAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcbiAgfVxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnICYmICFpc0hvc3RPYmplY3Qob2JqZWN0KSxcbiAgICAgIG90aElzT2JqID0gb3RoVGFnID09IG9iamVjdFRhZyAmJiAhaXNIb3N0T2JqZWN0KG90aGVyKSxcbiAgICAgIGlzU2FtZVRhZyA9IG9ialRhZyA9PSBvdGhUYWc7XG5cbiAgaWYgKGlzU2FtZVRhZyAmJiAhb2JqSXNPYmopIHtcbiAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICA/IGVxdWFsQXJyYXlzKG9iamVjdCwgb3RoZXIsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spXG4gICAgICA6IGVxdWFsQnlUYWcob2JqZWN0LCBvdGhlciwgb2JqVGFnLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgfVxuICBpZiAoIShiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcpKSB7XG4gICAgdmFyIG9iaklzV3JhcHBlZCA9IG9iaklzT2JqICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnX193cmFwcGVkX18nKSxcbiAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICBpZiAob2JqSXNXcmFwcGVkIHx8IG90aElzV3JhcHBlZCkge1xuICAgICAgdmFyIG9ialVud3JhcHBlZCA9IG9iaklzV3JhcHBlZCA/IG9iamVjdC52YWx1ZSgpIDogb2JqZWN0LFxuICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgIHJldHVybiBlcXVhbEZ1bmMob2JqVW53cmFwcGVkLCBvdGhVbndyYXBwZWQsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFpc1NhbWVUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7QXJyYXl9IG1hdGNoRGF0YSBUaGUgcHJvcGVydHkgbmFtZXMsIHZhbHVlcywgYW5kIGNvbXBhcmUgZmxhZ3MgdG8gbWF0Y2guXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBpcyBhIG1hdGNoLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGluZGV4ID0gbWF0Y2hEYXRhLmxlbmd0aCxcbiAgICAgIGxlbmd0aCA9IGluZGV4LFxuICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuICFsZW5ndGg7XG4gIH1cbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIGlmICgobm9DdXN0b21pemVyICYmIGRhdGFbMl0pXG4gICAgICAgICAgPyBkYXRhWzFdICE9PSBvYmplY3RbZGF0YVswXV1cbiAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgIHZhciBrZXkgPSBkYXRhWzBdLFxuICAgICAgICBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICBpZiAobm9DdXN0b21pemVyICYmIGRhdGFbMl0pIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkICYmICEoa2V5IGluIG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UsIHN0YWNrKTtcbiAgICAgIH1cbiAgICAgIGlmICghKHJlc3VsdCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgY3VzdG9taXplciwgVU5PUkRFUkVEX0NPTVBBUkVfRkxBRyB8IFBBUlRJQUxfQ09NUEFSRV9GTEFHLCBzdGFjaylcbiAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSAoaXNGdW5jdGlvbih2YWx1ZSkgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkgPyByZUlzTmF0aXZlIDogcmVJc0hvc3RDdG9yO1xuICByZXR1cm4gcGF0dGVybi50ZXN0KHRvU291cmNlKHZhbHVlKSk7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWF0Y2hlc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VNYXRjaGVzKHNvdXJjZSkge1xuICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gIGlmIChtYXRjaERhdGEubGVuZ3RoID09IDEgJiYgbWF0Y2hEYXRhWzBdWzJdKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKG1hdGNoRGF0YVswXVswXSwgbWF0Y2hEYXRhWzBdWzFdKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlTWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gIGlmIChpc0tleShwYXRoKSAmJiBpc1N0cmljdENvbXBhcmFibGUoc3JjVmFsdWUpKSB7XG4gICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgIHJldHVybiAob2JqVmFsdWUgPT09IHVuZGVmaW5lZCAmJiBvYmpWYWx1ZSA9PT0gc3JjVmFsdWUpXG4gICAgICA/IGhhc0luKG9iamVjdCwgcGF0aClcbiAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCB1bmRlZmluZWQsIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcgfCBQQVJUSUFMX0NPTVBBUkVfRkxBRyk7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gYmFzZUdldChvYmplY3QsIHBhdGgpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gY2FzdFBhdGgodmFsdWUpIHtcbiAgcmV0dXJuIGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBzdHJpbmdUb1BhdGgodmFsdWUpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmdyb3VwQnlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXIgVGhlIGZ1bmN0aW9uIHRvIHNldCBhY2N1bXVsYXRvciB2YWx1ZXMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaW5pdGlhbGl6ZXJdIFRoZSBhY2N1bXVsYXRvciBvYmplY3QgaW5pdGlhbGl6ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdG9yKHNldHRlciwgaW5pdGlhbGl6ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlBZ2dyZWdhdG9yIDogYmFzZUFnZ3JlZ2F0b3IsXG4gICAgICAgIGFjY3VtdWxhdG9yID0gaW5pdGlhbGl6ZXIgPyBpbml0aWFsaXplcigpIDoge307XG5cbiAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMiksIGFjY3VtdWxhdG9yKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0LCBpdGVyYXRlZSwga2V5c0Z1bmMpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgcHJvcHMgPSBrZXlzRnVuYyhvYmplY3QpLFxuICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wc1tmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XTtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtrZXldLCBrZXksIGl0ZXJhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH07XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBhcnJheXMgd2l0aCBzdXBwb3J0IGZvclxuICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7QXJyYXl9IG90aGVyIFRoZSBvdGhlciBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYGFycmF5YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBhcnJheXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxBcnJheXMoYXJyYXksIG90aGVyLCBlcXVhbEZ1bmMsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgUEFSVElBTF9DT01QQVJFX0ZMQUcsXG4gICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBvdGhMZW5ndGggPSBvdGhlci5sZW5ndGg7XG5cbiAgaWYgKGFyckxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIShpc1BhcnRpYWwgJiYgb3RoTGVuZ3RoID4gYXJyTGVuZ3RoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gIHZhciBzdGFja2VkID0gc3RhY2suZ2V0KGFycmF5KTtcbiAgaWYgKHN0YWNrZWQgJiYgc3RhY2suZ2V0KG90aGVyKSkge1xuICAgIHJldHVybiBzdGFja2VkID09IG90aGVyO1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIFVOT1JERVJFRF9DT01QQVJFX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghc2Vlbi5oYXMob3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLmFkZChvdGhJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShcbiAgICAgICAgICBhcnJWYWx1ZSA9PT0gb3RoVmFsdWUgfHxcbiAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGN1c3RvbWl6ZXIsIGJpdG1hc2ssIHN0YWNrKVxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICBzdGFja1snZGVsZXRlJ10ob3RoZXIpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3IgY29tcGFyaW5nIG9iamVjdHMgb2ZcbiAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gKlxuICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjb21wYXJpbmcgdmFsdWVzIHdpdGggdGFncyBvZlxuICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgVGhlIGB0b1N0cmluZ1RhZ2Agb2YgdGhlIG9iamVjdHMgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIG9mIGNvbXBhcmlzb24gZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgXG4gKiAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBQQVJUSUFMX0NPTVBBUkVfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IFVOT1JERVJFRF9DT01QQVJFX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGVxdWFsRnVuYywgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgb2YgY29tcGFyaXNvbiBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGBcbiAqICBmb3IgbW9yZSBkZXRhaWxzLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgb2JqZWN0cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgZXF1YWxGdW5jLCBjdXN0b21pemVyLCBiaXRtYXNrLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIFBBUlRJQUxfQ09NUEFSRV9GTEFHLFxuICAgICAgb2JqUHJvcHMgPSBrZXlzKG9iamVjdCksXG4gICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICBvdGhQcm9wcyA9IGtleXMob3RoZXIpLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoUHJvcHMubGVuZ3RoO1xuXG4gIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICB3aGlsZSAoaW5kZXgtLSkge1xuICAgIHZhciBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLy8gQXNzdW1lIGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICBpZiAoc3RhY2tlZCAmJiBzdGFjay5nZXQob3RoZXIpKSB7XG4gICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IHRydWU7XG4gIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gIHZhciBza2lwQ3RvciA9IGlzUGFydGlhbDtcbiAgd2hpbGUgKCsraW5kZXggPCBvYmpMZW5ndGgpIHtcbiAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIG90aFZhbHVlID0gb3RoZXJba2V5XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBvYmpWYWx1ZSwga2V5LCBvdGhlciwgb2JqZWN0LCBzdGFjaylcbiAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChvYmpWYWx1ZSA9PT0gb3RoVmFsdWUgfHwgZXF1YWxGdW5jKG9ialZhbHVlLCBvdGhWYWx1ZSwgY3VzdG9taXplciwgYml0bWFzaywgc3RhY2spKVxuICAgICAgICAgIDogY29tcGFyZWRcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgc2tpcEN0b3IgfHwgKHNraXBDdG9yID0ga2V5ID09ICdjb25zdHJ1Y3RvcicpO1xuICB9XG4gIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgdmFyIG9iakN0b3IgPSBvYmplY3QuY29uc3RydWN0b3IsXG4gICAgICAgIG90aEN0b3IgPSBvdGhlci5jb25zdHJ1Y3RvcjtcblxuICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgIGlmIChvYmpDdG9yICE9IG90aEN0b3IgJiZcbiAgICAgICAgKCdjb25zdHJ1Y3RvcicgaW4gb2JqZWN0ICYmICdjb25zdHJ1Y3RvcicgaW4gb3RoZXIpICYmXG4gICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgIHR5cGVvZiBvdGhDdG9yID09ICdmdW5jdGlvbicgJiYgb3RoQ3RvciBpbnN0YW5jZW9mIG90aEN0b3IpKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmF0aXZlIGZ1bmN0aW9uIGF0IGBrZXlgIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGhvZCB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZShvYmplY3QsIGtleSkge1xuICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gIHJldHVybiBiYXNlSXNOYXRpdmUodmFsdWUpID8gdmFsdWUgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbnZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4vLyBGYWxsYmFjayBmb3IgZGF0YSB2aWV3cywgbWFwcywgc2V0cywgYW5kIHdlYWsgbWFwcyBpbiBJRSAxMSxcbi8vIGZvciBkYXRhIHZpZXdzIGluIEVkZ2UgPCAxNCwgYW5kIHByb21pc2VzIGluIE5vZGUuanMuXG5pZiAoKERhdGFWaWV3ICYmIGdldFRhZyhuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDEpKSkgIT0gZGF0YVZpZXdUYWcpIHx8XG4gICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgIChQcm9taXNlICYmIGdldFRhZyhQcm9taXNlLnJlc29sdmUoKSkgIT0gcHJvbWlzZVRhZykgfHxcbiAgICAoU2V0ICYmIGdldFRhZyhuZXcgU2V0KSAhPSBzZXRUYWcpIHx8XG4gICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICBnZXRUYWcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgY3RvclN0cmluZyA9IEN0b3IgPyB0b1NvdXJjZShDdG9yKSA6IHVuZGVmaW5lZDtcblxuICAgIGlmIChjdG9yU3RyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGN0b3JTdHJpbmcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgY2FzZSBtYXBDdG9yU3RyaW5nOiByZXR1cm4gbWFwVGFnO1xuICAgICAgICBjYXNlIHByb21pc2VDdG9yU3RyaW5nOiByZXR1cm4gcHJvbWlzZVRhZztcbiAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICBjYXNlIHdlYWtNYXBDdG9yU3RyaW5nOiByZXR1cm4gd2Vha01hcFRhZztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGlzS2V5KHBhdGgsIG9iamVjdCkgPyBbcGF0aF0gOiBjYXN0UGF0aChwYXRoKTtcblxuICB2YXIgcmVzdWx0LFxuICAgICAgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0KSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICB2YXIgbGVuZ3RoID0gb2JqZWN0ID8gb2JqZWN0Lmxlbmd0aCA6IDA7XG4gIHJldHVybiAhIWxlbmd0aCAmJiBpc0xlbmd0aChsZW5ndGgpICYmIGlzSW5kZXgoa2V5LCBsZW5ndGgpICYmXG4gICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0tleSh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgdmFsdWUgPT0gbnVsbCB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gcmVJc1BsYWluUHJvcC50ZXN0KHZhbHVlKSB8fCAhcmVJc0RlZXBQcm9wLnRlc3QodmFsdWUpIHx8XG4gICAgKG9iamVjdCAhPSBudWxsICYmIHZhbHVlIGluIE9iamVjdChvYmplY3QpKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGl0cyBzb3VyY2UgbWFza2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2VkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzTWFza2VkKGZ1bmMpIHtcbiAgcmV0dXJuICEhbWFza1NyY0tleSAmJiAobWFza1NyY0tleSBpbiBmdW5jKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZShmdW5jdGlvbihzdHJpbmcpIHtcbiAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcblxuICB2YXIgcmVzdWx0ID0gW107XG4gIGlmIChyZUxlYWRpbmdEb3QudGVzdChzdHJpbmcpKSB7XG4gICAgcmVzdWx0LnB1c2goJycpO1xuICB9XG4gIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdHJpbmcpIHtcbiAgICByZXN1bHQucHVzaChxdW90ZSA/IHN0cmluZy5yZXBsYWNlKHJlRXNjYXBlQ2hhciwgJyQxJykgOiAobnVtYmVyIHx8IG1hdGNoKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGBmdW5jYCB0byBpdHMgc291cmNlIGNvZGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAqL1xuZnVuY3Rpb24gdG9Tb3VyY2UoZnVuYykge1xuICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmdW5jVG9TdHJpbmcuY2FsbChmdW5jKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gKGZ1bmMgKyAnJyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cyBzcGxpdCBpbnRvIHR3byBncm91cHMsIHRoZSBmaXJzdCBvZiB3aGljaFxuICogY29udGFpbnMgZWxlbWVudHMgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLCB0aGUgc2Vjb25kIG9mIHdoaWNoXG4gKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAqIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnBhcnRpdGlvbih1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IGZhbHNlIH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1sncGViYmxlcyddLCBbJ2Jhcm5leScsICdmcmVkJ11dXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5wYXJ0aXRpb24odXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2ZyZWQnXSwgWydiYXJuZXknLCAncGViYmxlcyddXVxuICovXG52YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgcmVzdWx0W2tleSA/IDAgOiAxXS5wdXNoKHZhbHVlKTtcbn0sIGZ1bmN0aW9uKCkgeyByZXR1cm4gW1tdLCBbXV07IH0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgJiYgdHlwZW9mIHJlc29sdmVyICE9ICdmdW5jdGlvbicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICB9XG4gIHZhciBtZW1vaXplZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBrZXkgPSByZXNvbHZlciA/IHJlc29sdmVyLmFwcGx5KHRoaXMsIGFyZ3MpIDogYXJnc1swXSxcbiAgICAgICAgY2FjaGUgPSBtZW1vaXplZC5jYWNoZTtcblxuICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgcmV0dXJuIGNhY2hlLmdldChrZXkpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBtZW1vaXplZC5jYWNoZSA9IGNhY2hlLnNldChrZXksIHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgbWVtb2l6ZWQuY2FjaGUgPSBuZXcgKG1lbW9pemUuQ2FjaGUgfHwgTWFwQ2FjaGUpO1xuICByZXR1cm4gbWVtb2l6ZWQ7XG59XG5cbi8vIEFzc2lnbiBjYWNoZSB0byBgXy5tZW1vaXplYC5cbm1lbW9pemUuQ2FjaGUgPSBNYXBDYWNoZTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIGVxdWl2YWxlbnQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxIH07XG4gKiB2YXIgb3RoZXIgPSB7ICdhJzogMSB9O1xuICpcbiAqIF8uZXEob2JqZWN0LCBvYmplY3QpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoJ2EnLCAnYScpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uZXEoJ2EnLCBPYmplY3QoJ2EnKSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uZXEoTmFOLCBOYU4pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBlcSh2YWx1ZSwgb3RoZXIpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBvdGhlciB8fCAodmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgKCFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgfHwgb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc1RhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gKiBpcyBhbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXktbGlrZSBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaXNBcnJheUxpa2UodmFsdWUpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDgtOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheSBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gaXNPYmplY3QodmFsdWUpID8gb2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSkgOiAnJztcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICEhdmFsdWUgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3ltYm9sJyB8fFxuICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGBvYmplY3RgLiBJZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaXNcbiAqIGB1bmRlZmluZWRgLCB0aGUgYGRlZmF1bHRWYWx1ZWAgaXMgcmV0dXJuZWQgaW4gaXRzIHBsYWNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy43LjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSByZXR1cm5lZCBmb3IgYHVuZGVmaW5lZGAgcmVzb2x2ZWQgdmFsdWVzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICpcbiAqIF8uZ2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5nZXQob2JqZWN0LCAnYS5iLmMnLCAnZGVmYXVsdCcpO1xuICogLy8gPT4gJ2RlZmF1bHQnXG4gKi9cbmZ1bmN0aW9uIGdldChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IG9yIGluaGVyaXRlZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5oYXNJbihvYmplY3QsICdiJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBoYXNJbihvYmplY3QsIHBhdGgpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBpdCByZWNlaXZlcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBBbnkgdmFsdWUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqXG4gKiBjb25zb2xlLmxvZyhfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhcnRpdGlvbjtcbiIsIi8qKlxuICogbG9kYXNoIDQuMC4yIChDdXN0b20gQnVpbGQpIDxodHRwczovL2xvZGFzaC5jb20vPlxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVwibnBtXCIgLW8gLi9gXG4gKiBDb3B5cmlnaHQgMjAxMi0yMDE2IFRoZSBEb2pvIEZvdW5kYXRpb24gPGh0dHA6Ly9kb2pvZm91bmRhdGlvbi5vcmcvPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCAyMDA5LTIwMTYgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqIEF2YWlsYWJsZSB1bmRlciBNSVQgbGljZW5zZSA8aHR0cHM6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zdW1gIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gKi9cbmZ1bmN0aW9uIGJhc2VTdW0oYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciByZXN1bHQsXG4gICAgICBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgIGlmIChjdXJyZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gY3VycmVudCA6IChyZXN1bHQgKyBjdXJyZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBwcm92aWRlZCB0byBpdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgYHZhbHVlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ3VzZXInOiAnZnJlZCcgfTtcbiAqXG4gKiBfLmlkZW50aXR5KG9iamVjdCkgPT09IG9iamVjdDtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBzdW0gb2YgdGhlIHZhbHVlcyBpbiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zdW0oWzQsIDIsIDgsIDZdKTtcbiAqIC8vID0+IDIwXG4gKi9cbmZ1bmN0aW9uIHN1bShhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgIDogMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdW07XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCJ2YXIgYmFzZUluZGV4T2YgPSByZXF1aXJlKCcuL19iYXNlSW5kZXhPZicpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmNsdWRlc2AgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gKiBzcGVjaWZ5aW5nIGFuIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCAwKSA+IC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXM7XG4iLCIvKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXJyYXlJbmNsdWRlc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUluY2x1ZGVzV2l0aChhcnJheSwgdmFsdWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChjb21wYXJhdG9yKHZhbHVlLCBhcnJheVtpbmRleF0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIG1ldGhvZHMgbGlrZSBgXy5kaWZmZXJlbmNlYCB3aXRob3V0IHN1cHBvcnRcbiAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChpdGVyYXRlZSkge1xuICAgIHZhbHVlcyA9IGFycmF5TWFwKHZhbHVlcywgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gIH1cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXNXaXRoO1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gIH1cbiAgZWxzZSBpZiAodmFsdWVzLmxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIHZhbHVlcyA9IG5ldyBTZXRDYWNoZSh2YWx1ZXMpO1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA9PSBudWxsID8gdmFsdWUgOiBpdGVyYXRlZSh2YWx1ZSk7XG5cbiAgICB2YWx1ZSA9IChjb21wYXJhdG9yIHx8IHZhbHVlICE9PSAwKSA/IHZhbHVlIDogMDtcbiAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdmFsdWVzSW5kZXggPSB2YWx1ZXNMZW5ndGg7XG4gICAgICB3aGlsZSAodmFsdWVzSW5kZXgtLSkge1xuICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRGlmZmVyZW5jZTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmluZEluZGV4YCBhbmQgYF8uZmluZExhc3RJbmRleGAgd2l0aG91dFxuICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpbmRleCA9IGZyb21JbmRleCArIChmcm9tUmlnaHQgPyAxIDogLTEpO1xuXG4gIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgaWYgKHByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaW5kSW5kZXg7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNGbGF0dGVuYWJsZSA9IHJlcXVpcmUoJy4vX2lzRmxhdHRlbmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mbGF0dGVuYCB3aXRoIHN1cHBvcnQgZm9yIHJlc3RyaWN0aW5nIGZsYXR0ZW5pbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHBhcmFtIHtudW1iZXJ9IGRlcHRoIFRoZSBtYXhpbXVtIHJlY3Vyc2lvbiBkZXB0aC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNTdHJpY3RdIFJlc3RyaWN0IHRvIHZhbHVlcyB0aGF0IHBhc3MgYHByZWRpY2F0ZWAgY2hlY2tzLlxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdD1bXV0gVGhlIGluaXRpYWwgcmVzdWx0IHZhbHVlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlRmxhdHRlbihhcnJheSwgZGVwdGgsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBwcmVkaWNhdGUgfHwgKHByZWRpY2F0ZSA9IGlzRmxhdHRlbmFibGUpO1xuICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgIGlmIChkZXB0aCA+IDEpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgZmxhdHRlbiBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1N0cmljdCkge1xuICAgICAgcmVzdWx0W3Jlc3VsdC5sZW5ndGhdID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZsYXR0ZW47XG4iLCJ2YXIgYmFzZUZpbmRJbmRleCA9IHJlcXVpcmUoJy4vX2Jhc2VGaW5kSW5kZXgnKSxcbiAgICBiYXNlSXNOYU4gPSByZXF1aXJlKCcuL19iYXNlSXNOYU4nKSxcbiAgICBzdHJpY3RJbmRleE9mID0gcmVxdWlyZSgnLi9fc3RyaWN0SW5kZXhPZicpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmluZGV4T2ZgIHdpdGhvdXQgYGZyb21JbmRleGAgYm91bmRzIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICovXG5mdW5jdGlvbiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlXG4gICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBmcm9tSW5kZXgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbmRleE9mO1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheUluY2x1ZGVzID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlcycpLFxuICAgIGFycmF5SW5jbHVkZXNXaXRoID0gcmVxdWlyZSgnLi9fYXJyYXlJbmNsdWRlc1dpdGgnKSxcbiAgICBhcnJheU1hcCA9IHJlcXVpcmUoJy4vX2FycmF5TWFwJyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmludGVyc2VjdGlvbmAsIHdpdGhvdXQgc3VwcG9ydFxuICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbnRlcnNlY3Rpb24oYXJyYXlzLCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgbGVuZ3RoID0gYXJyYXlzWzBdLmxlbmd0aCxcbiAgICAgIG90aExlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgIGNhY2hlcyA9IEFycmF5KG90aExlbmd0aCksXG4gICAgICBtYXhMZW5ndGggPSBJbmZpbml0eSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChvdGhJbmRleC0tKSB7XG4gICAgdmFyIGFycmF5ID0gYXJyYXlzW290aEluZGV4XTtcbiAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgIGFycmF5ID0gYXJyYXlNYXAoYXJyYXksIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICAgIH1cbiAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgIGNhY2hlc1tvdGhJbmRleF0gPSAhY29tcGFyYXRvciAmJiAoaXRlcmF0ZWUgfHwgKGxlbmd0aCA+PSAxMjAgJiYgYXJyYXkubGVuZ3RoID49IDEyMCkpXG4gICAgICA/IG5ldyBTZXRDYWNoZShvdGhJbmRleCAmJiBhcnJheSlcbiAgICAgIDogdW5kZWZpbmVkO1xuICB9XG4gIGFycmF5ID0gYXJyYXlzWzBdO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgc2VlbiA9IGNhY2hlc1swXTtcblxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKCEoc2VlblxuICAgICAgICAgID8gY2FjaGVIYXMoc2VlbiwgY29tcHV0ZWQpXG4gICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICApKSB7XG4gICAgICBvdGhJbmRleCA9IG90aExlbmd0aDtcbiAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgIHZhciBjYWNoZSA9IGNhY2hlc1tvdGhJbmRleF07XG4gICAgICAgIGlmICghKGNhY2hlXG4gICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICA6IGluY2x1ZGVzKGFycmF5c1tvdGhJbmRleF0sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc2Vlbikge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJbnRlcnNlY3Rpb247XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBjb25zdGFudCA9IHJlcXVpcmUoJy4vY29uc3RhbnQnKSxcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2RlZmluZVByb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYHNldFRvU3RyaW5nYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAqL1xudmFyIGJhc2VTZXRUb1N0cmluZyA9ICFkZWZpbmVQcm9wZXJ0eSA/IGlkZW50aXR5IDogZnVuY3Rpb24oZnVuYywgc3RyaW5nKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgJ2NvbmZpZ3VyYWJsZSc6IHRydWUsXG4gICAgJ2VudW1lcmFibGUnOiBmYWxzZSxcbiAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICd3cml0YWJsZSc6IHRydWVcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VTZXRUb1N0cmluZztcbiIsInZhciBTZXRDYWNoZSA9IHJlcXVpcmUoJy4vX1NldENhY2hlJyksXG4gICAgYXJyYXlJbmNsdWRlcyA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXMnKSxcbiAgICBhcnJheUluY2x1ZGVzV2l0aCA9IHJlcXVpcmUoJy4vX2FycmF5SW5jbHVkZXNXaXRoJyksXG4gICAgY2FjaGVIYXMgPSByZXF1aXJlKCcuL19jYWNoZUhhcycpLFxuICAgIGNyZWF0ZVNldCA9IHJlcXVpcmUoJy4vX2NyZWF0ZVNldCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xudmFyIExBUkdFX0FSUkFZX1NJWkUgPSAyMDA7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5pcUJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZHVwbGljYXRlIGZyZWUgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGlzQ29tbW9uID0gdHJ1ZSxcbiAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICBpZiAoY29tcGFyYXRvcikge1xuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgfVxuICBlbHNlIGlmIChsZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgIGlmIChzZXQpIHtcbiAgICAgIHJldHVybiBzZXRUb0FycmF5KHNldCk7XG4gICAgfVxuICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICB9XG4gIGVsc2Uge1xuICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICB9XG4gIG91dGVyOlxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHNlZW5JbmRleCA9IHNlZW4ubGVuZ3RoO1xuICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgIGlmIChzZWVuW3NlZW5JbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaW5jbHVkZXMoc2VlbiwgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICBpZiAoc2VlbiAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVVuaXE7XG4iLCJ2YXIgYmFzZURpZmZlcmVuY2UgPSByZXF1aXJlKCcuL19iYXNlRGlmZmVyZW5jZScpLFxuICAgIGJhc2VGbGF0dGVuID0gcmVxdWlyZSgnLi9fYmFzZUZsYXR0ZW4nKSxcbiAgICBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLnhvcmAsIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVhvcihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoIDwgMikge1xuICAgIHJldHVybiBsZW5ndGggPyBiYXNlVW5pcShhcnJheXNbMF0pIDogW107XG4gIH1cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGFycmF5ID0gYXJyYXlzW2luZGV4XSxcbiAgICAgICAgb3RoSW5kZXggPSAtMTtcblxuICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAob3RoSW5kZXggIT0gaW5kZXgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGJhc2VEaWZmZXJlbmNlKHJlc3VsdFtpbmRleF0gfHwgYXJyYXksIGFycmF5c1tvdGhJbmRleF0sIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlWG9yO1xuIiwidmFyIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpO1xuXG4vKipcbiAqIENhc3RzIGB2YWx1ZWAgdG8gYW4gZW1wdHkgYXJyYXkgaWYgaXQncyBub3QgYW4gYXJyYXkgbGlrZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjYXN0QXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhc3RBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgU2V0ID0gcmVxdWlyZSgnLi9fU2V0JyksXG4gICAgbm9vcCA9IHJlcXVpcmUoJy4vbm9vcCcpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IHNldC5cbiAqL1xudmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBTZXQodmFsdWVzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlU2V0O1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ByZWFkYWJsZVN5bWJvbCA9IFN5bWJvbCA/IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZmxhdHRlbmFibGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpIHx8XG4gICAgISEoc3ByZWFkYWJsZVN5bWJvbCAmJiB2YWx1ZSAmJiB2YWx1ZVtzcHJlYWRhYmxlU3ltYm9sXSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGbGF0dGVuYWJsZTtcbiIsInZhciBhcHBseSA9IHJlcXVpcmUoJy4vX2FwcGx5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VSZXN0YCB3aGljaCB0cmFuc2Zvcm1zIHRoZSByZXN0IGFycmF5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSByZXN0IGFycmF5IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyUmVzdChmdW5jLCBzdGFydCwgdHJhbnNmb3JtKSB7XG4gIHN0YXJ0ID0gbmF0aXZlTWF4KHN0YXJ0ID09PSB1bmRlZmluZWQgPyAoZnVuYy5sZW5ndGggLSAxKSA6IHN0YXJ0LCAwKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgIGFycmF5ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgIH1cbiAgICBpbmRleCA9IC0xO1xuICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgIHdoaWxlICgrK2luZGV4IDwgc3RhcnQpIHtcbiAgICAgIG90aGVyQXJnc1tpbmRleF0gPSBhcmdzW2luZGV4XTtcbiAgICB9XG4gICAgb3RoZXJBcmdzW3N0YXJ0XSA9IHRyYW5zZm9ybShhcnJheSk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb3ZlclJlc3Q7XG4iLCJ2YXIgYmFzZVNldFRvU3RyaW5nID0gcmVxdWlyZSgnLi9fYmFzZVNldFRvU3RyaW5nJyksXG4gICAgc2hvcnRPdXQgPSByZXF1aXJlKCcuL19zaG9ydE91dCcpO1xuXG4vKipcbiAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgc2V0VG9TdHJpbmcgPSBzaG9ydE91dChiYXNlU2V0VG9TdHJpbmcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNldFRvU3RyaW5nO1xuIiwiLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xudmFyIEhPVF9DT1VOVCA9IDgwMCxcbiAgICBIT1RfU1BBTiA9IDE2O1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTm93ID0gRGF0ZS5ub3c7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQnbGwgc2hvcnQgb3V0IGFuZCBpbnZva2UgYGlkZW50aXR5YCBpbnN0ZWFkXG4gKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAqIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzaG9ydGFibGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHNob3J0T3V0KGZ1bmMpIHtcbiAgdmFyIGNvdW50ID0gMCxcbiAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc3RhbXAgPSBuYXRpdmVOb3coKSxcbiAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgIGxhc3RDYWxsZWQgPSBzdGFtcDtcbiAgICBpZiAocmVtYWluaW5nID4gMCkge1xuICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgIHJldHVybiBhcmd1bWVudHNbMF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvdW50ID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3J0T3V0O1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gKiBjb21wYXJpc29ucyBvZiB2YWx1ZXMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gc3RyaWN0SW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggLSAxLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0cmljdEluZGV4T2Y7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHZhbHVlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcmV0dXJuIGZyb20gdGhlIG5ldyBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNvbnN0YW50IGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IF8udGltZXMoMiwgXy5jb25zdGFudCh7ICdhJzogMSB9KSk7XG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0cyk7XG4gKiAvLyA9PiBbeyAnYSc6IDEgfSwgeyAnYSc6IDEgfV1cbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzWzBdID09PSBvYmplY3RzWzFdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY29uc3RhbnQodmFsdWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zdGFudDtcbiIsInZhciBiYXNlRGlmZmVyZW5jZSA9IHJlcXVpcmUoJy4vX2Jhc2VEaWZmZXJlbmNlJyksXG4gICAgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0FycmF5TGlrZU9iamVjdCA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2VPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIGBhcnJheWAgdmFsdWVzIG5vdCBpbmNsdWRlZCBpbiB0aGUgb3RoZXIgZ2l2ZW4gYXJyYXlzXG4gKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICpcbiAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICogLy8gPT4gWzFdXG4gKi9cbnZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpXG4gICAgOiBbXTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpZmZlcmVuY2U7XG4iLCJ2YXIgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGJhc2VJbnRlcnNlY3Rpb24gPSByZXF1aXJlKCcuL19iYXNlSW50ZXJzZWN0aW9uJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGNhc3RBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL19jYXN0QXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGFsbCBnaXZlbiBhcnJheXNcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBpbnRlcnNlY3RpbmcgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmludGVyc2VjdGlvbihbMiwgMV0sIFsyLCAzXSk7XG4gKiAvLyA9PiBbMl1cbiAqL1xudmFyIGludGVyc2VjdGlvbiA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgcmV0dXJuIChtYXBwZWQubGVuZ3RoICYmIG1hcHBlZFswXSA9PT0gYXJyYXlzWzBdKVxuICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQpXG4gICAgOiBbXTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludGVyc2VjdGlvbjtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheUxpa2VPYmplY3Q7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmVcbiAqIGVxdWl2YWxlbnQuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIGNvbXBhcmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLFxuICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICogc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkIGFycmF5cy4gYE9iamVjdGAgb2JqZWN0cyBhcmUgY29tcGFyZWRcbiAqIGJ5IHRoZWlyIG93biwgbm90IGluaGVyaXRlZCwgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLiBGdW5jdGlvbnMgYW5kIERPTVxuICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5pc0VxdWFsKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIG9iamVjdCA9PT0gb3RoZXI7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0VxdWFsKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0VxdWFsO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAqIC8vID0+IFsyLCAxXVxuICovXG52YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaW9uO1xuIiwidmFyIGJhc2VEaWZmZXJlbmNlID0gcmVxdWlyZSgnLi9fYmFzZURpZmZlcmVuY2UnKSxcbiAgICBiYXNlUmVzdCA9IHJlcXVpcmUoJy4vX2Jhc2VSZXN0JyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiAqKk5vdGU6KiogVW5saWtlIGBfLnB1bGxgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLnhvclxuICogQGV4YW1wbGVcbiAqXG4gKiBfLndpdGhvdXQoWzIsIDEsIDIsIDNdLCAxLCAyKTtcbiAqIC8vID0+IFszXVxuICovXG52YXIgd2l0aG91dCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICA6IFtdO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gd2l0aG91dDtcbiIsInZhciBhcnJheUZpbHRlciA9IHJlcXVpcmUoJy4vX2FycmF5RmlsdGVyJyksXG4gICAgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGJhc2VYb3IgPSByZXF1aXJlKCcuL19iYXNlWG9yJyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzIHRoYXQgaXMgdGhlXG4gKiBbc3ltbWV0cmljIGRpZmZlcmVuY2VdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N5bW1ldHJpY19kaWZmZXJlbmNlKVxuICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAqIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAqIEBleGFtcGxlXG4gKlxuICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICogLy8gPT4gWzEsIDNdXG4gKi9cbnZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgcmV0dXJuIGJhc2VYb3IoYXJyYXlGaWx0ZXIoYXJyYXlzLCBpc0FycmF5TGlrZU9iamVjdCkpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0geG9yO1xuIiwidmFyIGxvd2VyQ2FzZSA9IHJlcXVpcmUoJ2xvd2VyLWNhc2UnKVxuXG4vKipcbiAqIExvd2VyIGNhc2UgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIGxvY2FsZSkge1xuICBpZiAoc3RyID09IG51bGwpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIHN0ciA9IFN0cmluZyhzdHIpXG5cbiAgcmV0dXJuIGxvd2VyQ2FzZShzdHIuY2hhckF0KDApLCBsb2NhbGUpICsgc3RyLnN1YnN0cigxKVxufVxuIiwiLyoqXG4gKiBTcGVjaWFsIGxhbmd1YWdlLXNwZWNpZmljIG92ZXJyaWRlcy5cbiAqXG4gKiBTb3VyY2U6IGZ0cDovL2Z0cC51bmljb2RlLm9yZy9QdWJsaWMvVUNEL2xhdGVzdC91Y2QvU3BlY2lhbENhc2luZy50eHRcbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgTEFOR1VBR0VTID0ge1xuICB0cjoge1xuICAgIHJlZ2V4cDogL1xcdTAxMzB8XFx1MDA0OXxcXHUwMDQ5XFx1MDMwNy9nLFxuICAgIG1hcDoge1xuICAgICAgJ1xcdTAxMzAnOiAnXFx1MDA2OScsXG4gICAgICAnXFx1MDA0OSc6ICdcXHUwMTMxJyxcbiAgICAgICdcXHUwMDQ5XFx1MDMwNyc6ICdcXHUwMDY5J1xuICAgIH1cbiAgfSxcbiAgYXo6IHtcbiAgICByZWdleHA6IC9bXFx1MDEzMF0vZyxcbiAgICBtYXA6IHtcbiAgICAgICdcXHUwMTMwJzogJ1xcdTAwNjknLFxuICAgICAgJ1xcdTAwNDknOiAnXFx1MDEzMScsXG4gICAgICAnXFx1MDA0OVxcdTAzMDcnOiAnXFx1MDA2OSdcbiAgICB9XG4gIH0sXG4gIGx0OiB7XG4gICAgcmVnZXhwOiAvW1xcdTAwNDlcXHUwMDRBXFx1MDEyRVxcdTAwQ0NcXHUwMENEXFx1MDEyOF0vZyxcbiAgICBtYXA6IHtcbiAgICAgICdcXHUwMDQ5JzogJ1xcdTAwNjlcXHUwMzA3JyxcbiAgICAgICdcXHUwMDRBJzogJ1xcdTAwNkFcXHUwMzA3JyxcbiAgICAgICdcXHUwMTJFJzogJ1xcdTAxMkZcXHUwMzA3JyxcbiAgICAgICdcXHUwMENDJzogJ1xcdTAwNjlcXHUwMzA3XFx1MDMwMCcsXG4gICAgICAnXFx1MDBDRCc6ICdcXHUwMDY5XFx1MDMwN1xcdTAzMDEnLFxuICAgICAgJ1xcdTAxMjgnOiAnXFx1MDA2OVxcdTAzMDdcXHUwMzAzJ1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIExvd2VyY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIsIGxvY2FsZSkge1xuICB2YXIgbGFuZyA9IExBTkdVQUdFU1tsb2NhbGVdXG5cbiAgc3RyID0gc3RyID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHIpXG5cbiAgaWYgKGxhbmcpIHtcbiAgICBzdHIgPSBzdHIucmVwbGFjZShsYW5nLnJlZ2V4cCwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIGxhbmcubWFwW21dIH0pXG4gIH1cblxuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKClcbn1cbiIsIi8qXG4gIGh0dHBzOi8vZ2l0aHViLmNvbS9iYW5rc2VhbiB3cmFwcGVkIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEncyBjb2RlIGluIGEgbmFtZXNwYWNlXG4gIHNvIGl0J3MgYmV0dGVyIGVuY2Fwc3VsYXRlZC4gTm93IHlvdSBjYW4gaGF2ZSBtdWx0aXBsZSByYW5kb20gbnVtYmVyIGdlbmVyYXRvcnNcbiAgYW5kIHRoZXkgd29uJ3Qgc3RvbXAgYWxsIG92ZXIgZWFjaG90aGVyJ3Mgc3RhdGUuXG5cbiAgSWYgeW91IHdhbnQgdG8gdXNlIHRoaXMgYXMgYSBzdWJzdGl0dXRlIGZvciBNYXRoLnJhbmRvbSgpLCB1c2UgdGhlIHJhbmRvbSgpXG4gIG1ldGhvZCBsaWtlIHNvOlxuXG4gIHZhciBtID0gbmV3IE1lcnNlbm5lVHdpc3RlcigpO1xuICB2YXIgcmFuZG9tTnVtYmVyID0gbS5yYW5kb20oKTtcblxuICBZb3UgY2FuIGFsc28gY2FsbCB0aGUgb3RoZXIgZ2VucmFuZF97Zm9vfSgpIG1ldGhvZHMgb24gdGhlIGluc3RhbmNlLlxuXG4gIElmIHlvdSB3YW50IHRvIHVzZSBhIHNwZWNpZmljIHNlZWQgaW4gb3JkZXIgdG8gZ2V0IGEgcmVwZWF0YWJsZSByYW5kb21cbiAgc2VxdWVuY2UsIHBhc3MgYW4gaW50ZWdlciBpbnRvIHRoZSBjb25zdHJ1Y3RvcjpcblxuICB2YXIgbSA9IG5ldyBNZXJzZW5uZVR3aXN0ZXIoMTIzKTtcblxuICBhbmQgdGhhdCB3aWxsIGFsd2F5cyBwcm9kdWNlIHRoZSBzYW1lIHJhbmRvbSBzZXF1ZW5jZS5cblxuICBTZWFuIE1jQ3VsbG91Z2ggKGJhbmtzZWFuQGdtYWlsLmNvbSlcbiovXG5cbi8qXG4gICBBIEMtcHJvZ3JhbSBmb3IgTVQxOTkzNywgd2l0aCBpbml0aWFsaXphdGlvbiBpbXByb3ZlZCAyMDAyLzEvMjYuXG4gICBDb2RlZCBieSBUYWt1amkgTmlzaGltdXJhIGFuZCBNYWtvdG8gTWF0c3Vtb3RvLlxuXG4gICBCZWZvcmUgdXNpbmcsIGluaXRpYWxpemUgdGhlIHN0YXRlIGJ5IHVzaW5nIGluaXRfc2VlZChzZWVkKVxuICAgb3IgaW5pdF9ieV9hcnJheShpbml0X2tleSwga2V5X2xlbmd0aCkuXG5cbiAgIENvcHlyaWdodCAoQykgMTk5NyAtIDIwMDIsIE1ha290byBNYXRzdW1vdG8gYW5kIFRha3VqaSBOaXNoaW11cmEsXG4gICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICAgYXJlIG1ldDpcblxuICAgICAxLiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgICAgMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAgICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICAgIDMuIFRoZSBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGVcbiAgICAgICAgcHJvZHVjdHMgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuXG4gICAgICAgIHBlcm1pc3Npb24uXG5cbiAgIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbiAgIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1RcbiAgIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuICAgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuICBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXG4gICBDT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCxcbiAgIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTyxcbiAgIFBST0NVUkVNRU5UIE9GIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUlxuICAgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRlxuICAgTElBQklMSVRZLCBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkdcbiAgIE5FR0xJR0VOQ0UgT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJU1xuICAgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG5cblxuICAgQW55IGZlZWRiYWNrIGlzIHZlcnkgd2VsY29tZS5cbiAgIGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL2VtdC5odG1sXG4gICBlbWFpbDogbS1tYXQgQCBtYXRoLnNjaS5oaXJvc2hpbWEtdS5hYy5qcCAocmVtb3ZlIHNwYWNlKVxuKi9cblxudmFyIE1lcnNlbm5lVHdpc3RlciA9IGZ1bmN0aW9uKHNlZWQpIHtcblx0aWYgKHNlZWQgPT0gdW5kZWZpbmVkKSB7XG5cdFx0c2VlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9XG5cblx0LyogUGVyaW9kIHBhcmFtZXRlcnMgKi9cblx0dGhpcy5OID0gNjI0O1xuXHR0aGlzLk0gPSAzOTc7XG5cdHRoaXMuTUFUUklYX0EgPSAweDk5MDhiMGRmOyAgIC8qIGNvbnN0YW50IHZlY3RvciBhICovXG5cdHRoaXMuVVBQRVJfTUFTSyA9IDB4ODAwMDAwMDA7IC8qIG1vc3Qgc2lnbmlmaWNhbnQgdy1yIGJpdHMgKi9cblx0dGhpcy5MT1dFUl9NQVNLID0gMHg3ZmZmZmZmZjsgLyogbGVhc3Qgc2lnbmlmaWNhbnQgciBiaXRzICovXG5cblx0dGhpcy5tdCA9IG5ldyBBcnJheSh0aGlzLk4pOyAvKiB0aGUgYXJyYXkgZm9yIHRoZSBzdGF0ZSB2ZWN0b3IgKi9cblx0dGhpcy5tdGk9dGhpcy5OKzE7IC8qIG10aT09TisxIG1lYW5zIG10W05dIGlzIG5vdCBpbml0aWFsaXplZCAqL1xuXG5cdGlmIChzZWVkLmNvbnN0cnVjdG9yID09IEFycmF5KSB7XG5cdFx0dGhpcy5pbml0X2J5X2FycmF5KHNlZWQsIHNlZWQubGVuZ3RoKTtcblx0fVxuXHRlbHNlIHtcblx0XHR0aGlzLmluaXRfc2VlZChzZWVkKTtcblx0fVxufVxuXG4vKiBpbml0aWFsaXplcyBtdFtOXSB3aXRoIGEgc2VlZCAqL1xuLyogb3JpZ2luIG5hbWUgaW5pdF9nZW5yYW5kICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLmluaXRfc2VlZCA9IGZ1bmN0aW9uKHMpIHtcblx0dGhpcy5tdFswXSA9IHMgPj4+IDA7XG5cdGZvciAodGhpcy5tdGk9MTsgdGhpcy5tdGk8dGhpcy5OOyB0aGlzLm10aSsrKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm10W3RoaXMubXRpLTFdIF4gKHRoaXMubXRbdGhpcy5tdGktMV0gPj4+IDMwKTtcblx0XHR0aGlzLm10W3RoaXMubXRpXSA9ICgoKCgocyAmIDB4ZmZmZjAwMDApID4+PiAxNikgKiAxODEyNDMzMjUzKSA8PCAxNikgKyAocyAmIDB4MDAwMGZmZmYpICogMTgxMjQzMzI1Mylcblx0XHQrIHRoaXMubXRpO1xuXHRcdC8qIFNlZSBLbnV0aCBUQU9DUCBWb2wyLiAzcmQgRWQuIFAuMTA2IGZvciBtdWx0aXBsaWVyLiAqL1xuXHRcdC8qIEluIHRoZSBwcmV2aW91cyB2ZXJzaW9ucywgTVNCcyBvZiB0aGUgc2VlZCBhZmZlY3QgICAqL1xuXHRcdC8qIG9ubHkgTVNCcyBvZiB0aGUgYXJyYXkgbXRbXS4gICAgICAgICAgICAgICAgICAgICAgICAqL1xuXHRcdC8qIDIwMDIvMDEvMDkgbW9kaWZpZWQgYnkgTWFrb3RvIE1hdHN1bW90byAgICAgICAgICAgICAqL1xuXHRcdHRoaXMubXRbdGhpcy5tdGldID4+Pj0gMDtcblx0XHQvKiBmb3IgPjMyIGJpdCBtYWNoaW5lcyAqL1xuXHR9XG59XG5cbi8qIGluaXRpYWxpemUgYnkgYW4gYXJyYXkgd2l0aCBhcnJheS1sZW5ndGggKi9cbi8qIGluaXRfa2V5IGlzIHRoZSBhcnJheSBmb3IgaW5pdGlhbGl6aW5nIGtleXMgKi9cbi8qIGtleV9sZW5ndGggaXMgaXRzIGxlbmd0aCAqL1xuLyogc2xpZ2h0IGNoYW5nZSBmb3IgQysrLCAyMDA0LzIvMjYgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUuaW5pdF9ieV9hcnJheSA9IGZ1bmN0aW9uKGluaXRfa2V5LCBrZXlfbGVuZ3RoKSB7XG5cdHZhciBpLCBqLCBrO1xuXHR0aGlzLmluaXRfc2VlZCgxOTY1MDIxOCk7XG5cdGk9MTsgaj0wO1xuXHRrID0gKHRoaXMuTj5rZXlfbGVuZ3RoID8gdGhpcy5OIDoga2V5X2xlbmd0aCk7XG5cdGZvciAoOyBrOyBrLS0pIHtcblx0XHR2YXIgcyA9IHRoaXMubXRbaS0xXSBeICh0aGlzLm10W2ktMV0gPj4+IDMwKVxuXHRcdHRoaXMubXRbaV0gPSAodGhpcy5tdFtpXSBeICgoKCgocyAmIDB4ZmZmZjAwMDApID4+PiAxNikgKiAxNjY0NTI1KSA8PCAxNikgKyAoKHMgJiAweDAwMDBmZmZmKSAqIDE2NjQ1MjUpKSlcblx0XHQrIGluaXRfa2V5W2pdICsgajsgLyogbm9uIGxpbmVhciAqL1xuXHRcdHRoaXMubXRbaV0gPj4+PSAwOyAvKiBmb3IgV09SRFNJWkUgPiAzMiBtYWNoaW5lcyAqL1xuXHRcdGkrKzsgaisrO1xuXHRcdGlmIChpPj10aGlzLk4pIHsgdGhpcy5tdFswXSA9IHRoaXMubXRbdGhpcy5OLTFdOyBpPTE7IH1cblx0XHRpZiAoaj49a2V5X2xlbmd0aCkgaj0wO1xuXHR9XG5cdGZvciAoaz10aGlzLk4tMTsgazsgay0tKSB7XG5cdFx0dmFyIHMgPSB0aGlzLm10W2ktMV0gXiAodGhpcy5tdFtpLTFdID4+PiAzMCk7XG5cdFx0dGhpcy5tdFtpXSA9ICh0aGlzLm10W2ldIF4gKCgoKChzICYgMHhmZmZmMDAwMCkgPj4+IDE2KSAqIDE1NjYwODM5NDEpIDw8IDE2KSArIChzICYgMHgwMDAwZmZmZikgKiAxNTY2MDgzOTQxKSlcblx0XHQtIGk7IC8qIG5vbiBsaW5lYXIgKi9cblx0XHR0aGlzLm10W2ldID4+Pj0gMDsgLyogZm9yIFdPUkRTSVpFID4gMzIgbWFjaGluZXMgKi9cblx0XHRpKys7XG5cdFx0aWYgKGk+PXRoaXMuTikgeyB0aGlzLm10WzBdID0gdGhpcy5tdFt0aGlzLk4tMV07IGk9MTsgfVxuXHR9XG5cblx0dGhpcy5tdFswXSA9IDB4ODAwMDAwMDA7IC8qIE1TQiBpcyAxOyBhc3N1cmluZyBub24temVybyBpbml0aWFsIGFycmF5ICovXG59XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHhmZmZmZmZmZl0taW50ZXJ2YWwgKi9cbi8qIG9yaWdpbiBuYW1lIGdlbnJhbmRfaW50MzIgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tX2ludCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgeTtcblx0dmFyIG1hZzAxID0gbmV3IEFycmF5KDB4MCwgdGhpcy5NQVRSSVhfQSk7XG5cdC8qIG1hZzAxW3hdID0geCAqIE1BVFJJWF9BICBmb3IgeD0wLDEgKi9cblxuXHRpZiAodGhpcy5tdGkgPj0gdGhpcy5OKSB7IC8qIGdlbmVyYXRlIE4gd29yZHMgYXQgb25lIHRpbWUgKi9cblx0XHR2YXIga2s7XG5cblx0XHRpZiAodGhpcy5tdGkgPT0gdGhpcy5OKzEpICAvKiBpZiBpbml0X3NlZWQoKSBoYXMgbm90IGJlZW4gY2FsbGVkLCAqL1xuXHRcdFx0dGhpcy5pbml0X3NlZWQoNTQ4OSk7ICAvKiBhIGRlZmF1bHQgaW5pdGlhbCBzZWVkIGlzIHVzZWQgKi9cblxuXHRcdGZvciAoa2s9MDtrazx0aGlzLk4tdGhpcy5NO2trKyspIHtcblx0XHRcdHkgPSAodGhpcy5tdFtra10mdGhpcy5VUFBFUl9NQVNLKXwodGhpcy5tdFtraysxXSZ0aGlzLkxPV0VSX01BU0spO1xuXHRcdFx0dGhpcy5tdFtra10gPSB0aGlzLm10W2trK3RoaXMuTV0gXiAoeSA+Pj4gMSkgXiBtYWcwMVt5ICYgMHgxXTtcblx0XHR9XG5cdFx0Zm9yICg7a2s8dGhpcy5OLTE7a2srKykge1xuXHRcdFx0eSA9ICh0aGlzLm10W2trXSZ0aGlzLlVQUEVSX01BU0spfCh0aGlzLm10W2trKzFdJnRoaXMuTE9XRVJfTUFTSyk7XG5cdFx0XHR0aGlzLm10W2trXSA9IHRoaXMubXRba2srKHRoaXMuTS10aGlzLk4pXSBeICh5ID4+PiAxKSBeIG1hZzAxW3kgJiAweDFdO1xuXHRcdH1cblx0XHR5ID0gKHRoaXMubXRbdGhpcy5OLTFdJnRoaXMuVVBQRVJfTUFTSyl8KHRoaXMubXRbMF0mdGhpcy5MT1dFUl9NQVNLKTtcblx0XHR0aGlzLm10W3RoaXMuTi0xXSA9IHRoaXMubXRbdGhpcy5NLTFdIF4gKHkgPj4+IDEpIF4gbWFnMDFbeSAmIDB4MV07XG5cblx0XHR0aGlzLm10aSA9IDA7XG5cdH1cblxuXHR5ID0gdGhpcy5tdFt0aGlzLm10aSsrXTtcblxuXHQvKiBUZW1wZXJpbmcgKi9cblx0eSBePSAoeSA+Pj4gMTEpO1xuXHR5IF49ICh5IDw8IDcpICYgMHg5ZDJjNTY4MDtcblx0eSBePSAoeSA8PCAxNSkgJiAweGVmYzYwMDAwO1xuXHR5IF49ICh5ID4+PiAxOCk7XG5cblx0cmV0dXJuIHkgPj4+IDA7XG59XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMHg3ZmZmZmZmZl0taW50ZXJ2YWwgKi9cbi8qIG9yaWdpbiBuYW1lIGdlbnJhbmRfaW50MzEgKi9cbk1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUucmFuZG9tX2ludDMxID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiAodGhpcy5yYW5kb21faW50KCk+Pj4xKTtcbn1cblxuLyogZ2VuZXJhdGVzIGEgcmFuZG9tIG51bWJlciBvbiBbMCwxXS1yZWFsLWludGVydmFsICovXG4vKiBvcmlnaW4gbmFtZSBnZW5yYW5kX3JlYWwxICovXG5NZXJzZW5uZVR3aXN0ZXIucHJvdG90eXBlLnJhbmRvbV9pbmNsID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzLnJhbmRvbV9pbnQoKSooMS4wLzQyOTQ5NjcyOTUuMCk7XG5cdC8qIGRpdmlkZWQgYnkgMl4zMi0xICovXG59XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gWzAsMSktcmVhbC1pbnRlcnZhbCAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5yYW5kb20gPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMucmFuZG9tX2ludCgpKigxLjAvNDI5NDk2NzI5Ni4wKTtcblx0LyogZGl2aWRlZCBieSAyXjMyICovXG59XG5cbi8qIGdlbmVyYXRlcyBhIHJhbmRvbSBudW1iZXIgb24gKDAsMSktcmVhbC1pbnRlcnZhbCAqL1xuLyogb3JpZ2luIG5hbWUgZ2VucmFuZF9yZWFsMyAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5yYW5kb21fZXhjbCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gKHRoaXMucmFuZG9tX2ludCgpICsgMC41KSooMS4wLzQyOTQ5NjcyOTYuMCk7XG5cdC8qIGRpdmlkZWQgYnkgMl4zMiAqL1xufVxuXG4vKiBnZW5lcmF0ZXMgYSByYW5kb20gbnVtYmVyIG9uIFswLDEpIHdpdGggNTMtYml0IHJlc29sdXRpb24qL1xuLyogb3JpZ2luIG5hbWUgZ2VucmFuZF9yZXM1MyAqL1xuTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5yYW5kb21fbG9uZyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgYT10aGlzLnJhbmRvbV9pbnQoKT4+PjUsIGI9dGhpcy5yYW5kb21faW50KCk+Pj42O1xuXHRyZXR1cm4oYSo2NzEwODg2NC4wK2IpKigxLjAvOTAwNzE5OTI1NDc0MDk5Mi4wKTtcbn1cblxuLyogVGhlc2UgcmVhbCB2ZXJzaW9ucyBhcmUgZHVlIHRvIElzYWt1IFdhZGEsIDIwMDIvMDEvMDkgYWRkZWQgKi9cblxubW9kdWxlLmV4cG9ydHMgPSBNZXJzZW5uZVR3aXN0ZXI7XG4iLCIndXNlIHN0cmljdCc7ZnVuY3Rpb24gX2ludGVyb3BEZWZhdWx0KGUpe3JldHVybihlJiYodHlwZW9mIGU9PT0nb2JqZWN0JykmJidkZWZhdWx0J2luIGUpP2VbJ2RlZmF1bHQnXTplfXZhciBSZWFjdD1yZXF1aXJlKCdyZWFjdCcpLFJlYWN0X19kZWZhdWx0PV9pbnRlcm9wRGVmYXVsdChSZWFjdCksX2luaGVyaXRzTG9vc2U9X2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNMb29zZScpKSxQcm9wVHlwZXM9X2ludGVyb3BEZWZhdWx0KHJlcXVpcmUoJ3Byb3AtdHlwZXMnKSksZ3VkPV9pbnRlcm9wRGVmYXVsdChyZXF1aXJlKCdndWQnKSksd2FybmluZz1faW50ZXJvcERlZmF1bHQocmVxdWlyZSgndGlueS13YXJuaW5nJykpO3ZhciBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgPSAxMDczNzQxODIzO1xuXG5mdW5jdGlvbiBvYmplY3RJcyh4LCB5KSB7XG4gIGlmICh4ID09PSB5KSB7XG4gICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnRFbWl0dGVyKHZhbHVlKSB7XG4gIHZhciBoYW5kbGVycyA9IFtdO1xuICByZXR1cm4ge1xuICAgIG9uOiBmdW5jdGlvbiBvbihoYW5kbGVyKSB7XG4gICAgICBoYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xuICAgIH0sXG4gICAgb2ZmOiBmdW5jdGlvbiBvZmYoaGFuZGxlcikge1xuICAgICAgaGFuZGxlcnMgPSBoYW5kbGVycy5maWx0ZXIoZnVuY3Rpb24gKGgpIHtcbiAgICAgICAgcmV0dXJuIGggIT09IGhhbmRsZXI7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQobmV3VmFsdWUsIGNoYW5nZWRCaXRzKSB7XG4gICAgICB2YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgaGFuZGxlcnMuZm9yRWFjaChmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gaGFuZGxlcih2YWx1ZSwgY2hhbmdlZEJpdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pID8gY2hpbGRyZW5bMF0gOiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVhY3RDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY2FsY3VsYXRlQ2hhbmdlZEJpdHMpIHtcbiAgdmFyIF9Qcm92aWRlciRjaGlsZENvbnRleCwgX0NvbnN1bWVyJGNvbnRleHRUeXBlO1xuXG4gIHZhciBjb250ZXh0UHJvcCA9ICdfX2NyZWF0ZS1yZWFjdC1jb250ZXh0LScgKyBndWQoKSArICdfXyc7XG5cbiAgdmFyIFByb3ZpZGVyID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudCkge1xuICAgIF9pbmhlcml0c0xvb3NlKFByb3ZpZGVyLCBfQ29tcG9uZW50KTtcblxuICAgIGZ1bmN0aW9uIFByb3ZpZGVyKCkge1xuICAgICAgdmFyIF90aGlzO1xuXG4gICAgICBfdGhpcyA9IF9Db21wb25lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgX3RoaXMuZW1pdHRlciA9IGNyZWF0ZUV2ZW50RW1pdHRlcihfdGhpcy5wcm9wcy52YWx1ZSk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFByb3ZpZGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiBnZXRDaGlsZENvbnRleHQoKSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgcmV0dXJuIF9yZWYgPSB7fSwgX3JlZltjb250ZXh0UHJvcF0gPSB0aGlzLmVtaXR0ZXIsIF9yZWY7XG4gICAgfTtcblxuICAgIF9wcm90by5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICAgIGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBuZXh0UHJvcHMudmFsdWUpIHtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5wcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gbmV4dFByb3BzLnZhbHVlO1xuICAgICAgICB2YXIgY2hhbmdlZEJpdHM7XG5cbiAgICAgICAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgICBjaGFuZ2VkQml0cyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlZEJpdHMgPSB0eXBlb2YgY2FsY3VsYXRlQ2hhbmdlZEJpdHMgPT09ICdmdW5jdGlvbicgPyBjYWxjdWxhdGVDaGFuZ2VkQml0cyhvbGRWYWx1ZSwgbmV3VmFsdWUpIDogTUFYX1NJR05FRF8zMV9CSVRfSU5UO1xuXG4gICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICB3YXJuaW5nKChjaGFuZ2VkQml0cyAmIE1BWF9TSUdORURfMzFfQklUX0lOVCkgPT09IGNoYW5nZWRCaXRzLCAnY2FsY3VsYXRlQ2hhbmdlZEJpdHM6IEV4cGVjdGVkIHRoZSByZXR1cm4gdmFsdWUgdG8gYmUgYSAnICsgJzMxLWJpdCBpbnRlZ2VyLiBJbnN0ZWFkIHJlY2VpdmVkOiAnICsgY2hhbmdlZEJpdHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoYW5nZWRCaXRzIHw9IDA7XG5cbiAgICAgICAgICBpZiAoY2hhbmdlZEJpdHMgIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci5zZXQobmV4dFByb3BzLnZhbHVlLCBjaGFuZ2VkQml0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFByb3ZpZGVyO1xuICB9KFJlYWN0LkNvbXBvbmVudCk7XG5cbiAgUHJvdmlkZXIuY2hpbGRDb250ZXh0VHlwZXMgPSAoX1Byb3ZpZGVyJGNoaWxkQ29udGV4ID0ge30sIF9Qcm92aWRlciRjaGlsZENvbnRleFtjb250ZXh0UHJvcF0gPSBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsIF9Qcm92aWRlciRjaGlsZENvbnRleCk7XG5cbiAgdmFyIENvbnN1bWVyID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0NvbXBvbmVudDIpIHtcbiAgICBfaW5oZXJpdHNMb29zZShDb25zdW1lciwgX0NvbXBvbmVudDIpO1xuXG4gICAgZnVuY3Rpb24gQ29uc3VtZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyO1xuXG4gICAgICBfdGhpczIgPSBfQ29tcG9uZW50Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICBfdGhpczIuc3RhdGUgPSB7XG4gICAgICAgIHZhbHVlOiBfdGhpczIuZ2V0VmFsdWUoKVxuICAgICAgfTtcblxuICAgICAgX3RoaXMyLm9uVXBkYXRlID0gZnVuY3Rpb24gKG5ld1ZhbHVlLCBjaGFuZ2VkQml0cykge1xuICAgICAgICB2YXIgb2JzZXJ2ZWRCaXRzID0gX3RoaXMyLm9ic2VydmVkQml0cyB8IDA7XG5cbiAgICAgICAgaWYgKChvYnNlcnZlZEJpdHMgJiBjaGFuZ2VkQml0cykgIT09IDApIHtcbiAgICAgICAgICBfdGhpczIuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdmFsdWU6IF90aGlzMi5nZXRWYWx1ZSgpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHJldHVybiBfdGhpczI7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzIgPSBDb25zdW1lci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8yLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IG5leHRQcm9wcy5vYnNlcnZlZEJpdHM7XG4gICAgICB0aGlzLm9ic2VydmVkQml0cyA9IG9ic2VydmVkQml0cyA9PT0gdW5kZWZpbmVkIHx8IG9ic2VydmVkQml0cyA9PT0gbnVsbCA/IE1BWF9TSUdORURfMzFfQklUX0lOVCA6IG9ic2VydmVkQml0cztcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgICAgaWYgKHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5vbih0aGlzLm9uVXBkYXRlKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG9ic2VydmVkQml0cyA9IHRoaXMucHJvcHMub2JzZXJ2ZWRCaXRzO1xuICAgICAgdGhpcy5vYnNlcnZlZEJpdHMgPSBvYnNlcnZlZEJpdHMgPT09IHVuZGVmaW5lZCB8fCBvYnNlcnZlZEJpdHMgPT09IG51bGwgPyBNQVhfU0lHTkVEXzMxX0JJVF9JTlQgOiBvYnNlcnZlZEJpdHM7XG4gICAgfTtcblxuICAgIF9wcm90bzIuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnRXaWxsVW5tb3VudCgpIHtcbiAgICAgIGlmICh0aGlzLmNvbnRleHRbY29udGV4dFByb3BdKSB7XG4gICAgICAgIHRoaXMuY29udGV4dFtjb250ZXh0UHJvcF0ub2ZmKHRoaXMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8yLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0W2NvbnRleHRQcm9wXS5nZXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90bzIucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIG9ubHlDaGlsZCh0aGlzLnByb3BzLmNoaWxkcmVuKSh0aGlzLnN0YXRlLnZhbHVlKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIENvbnN1bWVyO1xuICB9KFJlYWN0LkNvbXBvbmVudCk7XG5cbiAgQ29uc3VtZXIuY29udGV4dFR5cGVzID0gKF9Db25zdW1lciRjb250ZXh0VHlwZSA9IHt9LCBfQ29uc3VtZXIkY29udGV4dFR5cGVbY29udGV4dFByb3BdID0gUHJvcFR5cGVzLm9iamVjdCwgX0NvbnN1bWVyJGNvbnRleHRUeXBlKTtcbiAgcmV0dXJuIHtcbiAgICBQcm92aWRlcjogUHJvdmlkZXIsXG4gICAgQ29uc3VtZXI6IENvbnN1bWVyXG4gIH07XG59dmFyIGluZGV4ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCB8fCBjcmVhdGVSZWFjdENvbnRleHQ7bW9kdWxlLmV4cG9ydHM9aW5kZXg7IiwiLy8gVGhpcyBhbHBoYWJldCB1c2VzIGEteiBBLVogMC05IF8tIHN5bWJvbHMuXG4vLyBTeW1ib2xzIGFyZSBnZW5lcmF0ZWQgZm9yIHNtYWxsZXIgc2l6ZS5cbi8vIC1fenl4d3Z1dHNycXBvbm1sa2ppaGdmZWRjYmE5ODc2NTQzMjEwWllYV1ZVVFNSUVBPTk1MS0pJSEdGRURDQkFcbnZhciB1cmwgPSAnLV8nXG4vLyBMb29wIGZyb20gMzYgdG8gMCAoZnJvbSB6IHRvIGEgYW5kIDkgdG8gMCBpbiBCYXNlMzYpLlxudmFyIGkgPSAzNlxud2hpbGUgKGktLSkge1xuICAvLyAzNiBpcyByYWRpeC4gTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZygzNikgcmV0dXJucyBudW1iZXJcbiAgLy8gaW4gQmFzZTM2IHJlcHJlc2VudGF0aW9uLiBCYXNlMzYgaXMgbGlrZSBoZXgsIGJ1dCBpdCB1c2VzIDDigJM5IGFuZCBhLXouXG4gIHVybCArPSBpLnRvU3RyaW5nKDM2KVxufVxuLy8gTG9vcCBmcm9tIDM2IHRvIDEwIChmcm9tIFogdG8gQSBpbiBCYXNlMzYpLlxuaSA9IDM2XG53aGlsZSAoaS0tIC0gMTApIHtcbiAgdXJsICs9IGkudG9TdHJpbmcoMzYpLnRvVXBwZXJDYXNlKClcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBVUkwtZnJpZW5kbHkgdW5pcXVlIElELiBUaGlzIG1ldGhvZCB1c2Ugbm9uLXNlY3VyZSBwcmVkaWN0YWJsZVxuICogcmFuZG9tIGdlbmVyYXRvciB3aXRoIGJpZ2dlciBjb2xsaXNpb24gcHJvYmFiaWxpdHkuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPTIxXSBUaGUgbnVtYmVyIG9mIHN5bWJvbHMgaW4gSUQuXG4gKlxuICogQHJldHVybiB7c3RyaW5nfSBSYW5kb20gc3RyaW5nLlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCBuYW5vaWQgPSByZXF1aXJlKCduYW5vaWQvbm9uLXNlY3VyZScpXG4gKiBtb2RlbC5pZCA9IG5hbm9pZCgpIC8vPT4gXCJVYWtnYl9KNW05Zy0wSkRNYmNKcUxcIlxuICpcbiAqIEBuYW1lIG5vblNlY3VyZVxuICogQGZ1bmN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgdmFyIGlkID0gJydcbiAgaSA9IHNpemUgfHwgMjFcbiAgLy8gQ29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKWBcbiAgd2hpbGUgKGktLSkge1xuICAgIC8vIGB8IDBgIGlzIGNvbXBhY3QgYW5kIGZhc3RlciBhbHRlcm5hdGl2ZSBmb3IgYE1hdGguZmxvb3IoKWBcbiAgICBpZCArPSB1cmxbTWF0aC5yYW5kb20oKSAqIDY0IHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbiIsInZhciBsb3dlckNhc2UgPSByZXF1aXJlKCdsb3dlci1jYXNlJylcblxudmFyIE5PTl9XT1JEX1JFR0VYUCA9IHJlcXVpcmUoJy4vdmVuZG9yL25vbi13b3JkLXJlZ2V4cCcpXG52YXIgQ0FNRUxfQ0FTRV9SRUdFWFAgPSByZXF1aXJlKCcuL3ZlbmRvci9jYW1lbC1jYXNlLXJlZ2V4cCcpXG52YXIgQ0FNRUxfQ0FTRV9VUFBFUl9SRUdFWFAgPSByZXF1aXJlKCcuL3ZlbmRvci9jYW1lbC1jYXNlLXVwcGVyLXJlZ2V4cCcpXG5cbi8qKlxuICogU2VudGVuY2UgY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHN0clxuICogQHBhcmFtICB7c3RyaW5nfSBsb2NhbGVcbiAqIEBwYXJhbSAge3N0cmluZ30gcmVwbGFjZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBsb2NhbGUsIHJlcGxhY2VtZW50KSB7XG4gIGlmIChzdHIgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgcmVwbGFjZW1lbnQgPSB0eXBlb2YgcmVwbGFjZW1lbnQgIT09ICdzdHJpbmcnID8gJyAnIDogcmVwbGFjZW1lbnRcblxuICBmdW5jdGlvbiByZXBsYWNlIChtYXRjaCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ID09PSAwIHx8IGluZGV4ID09PSAodmFsdWUubGVuZ3RoIC0gbWF0Y2gubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcGxhY2VtZW50XG4gIH1cblxuICBzdHIgPSBTdHJpbmcoc3RyKVxuICAgIC8vIFN1cHBvcnQgY2FtZWwgY2FzZSAoXCJjYW1lbENhc2VcIiAtPiBcImNhbWVsIENhc2VcIikuXG4gICAgLnJlcGxhY2UoQ0FNRUxfQ0FTRV9SRUdFWFAsICckMSAkMicpXG4gICAgLy8gU3VwcG9ydCBvZGQgY2FtZWwgY2FzZSAoXCJDQU1FTENhc2VcIiAtPiBcIkNBTUVMIENhc2VcIikuXG4gICAgLnJlcGxhY2UoQ0FNRUxfQ0FTRV9VUFBFUl9SRUdFWFAsICckMSAkMicpXG4gICAgLy8gUmVtb3ZlIGFsbCBub24td29yZCBjaGFyYWN0ZXJzIGFuZCByZXBsYWNlIHdpdGggYSBzaW5nbGUgc3BhY2UuXG4gICAgLnJlcGxhY2UoTk9OX1dPUkRfUkVHRVhQLCByZXBsYWNlKVxuXG4gIC8vIExvd2VyIGNhc2UgdGhlIGVudGlyZSBzdHJpbmcuXG4gIHJldHVybiBsb3dlckNhc2Uoc3RyLCBsb2NhbGUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IC8oW2EtelxceEI1XFx4REYtXFx4RjZcXHhGOC1cXHhGRlxcdTAxMDFcXHUwMTAzXFx1MDEwNVxcdTAxMDdcXHUwMTA5XFx1MDEwQlxcdTAxMERcXHUwMTBGXFx1MDExMVxcdTAxMTNcXHUwMTE1XFx1MDExN1xcdTAxMTlcXHUwMTFCXFx1MDExRFxcdTAxMUZcXHUwMTIxXFx1MDEyM1xcdTAxMjVcXHUwMTI3XFx1MDEyOVxcdTAxMkJcXHUwMTJEXFx1MDEyRlxcdTAxMzFcXHUwMTMzXFx1MDEzNVxcdTAxMzdcXHUwMTM4XFx1MDEzQVxcdTAxM0NcXHUwMTNFXFx1MDE0MFxcdTAxNDJcXHUwMTQ0XFx1MDE0NlxcdTAxNDhcXHUwMTQ5XFx1MDE0QlxcdTAxNERcXHUwMTRGXFx1MDE1MVxcdTAxNTNcXHUwMTU1XFx1MDE1N1xcdTAxNTlcXHUwMTVCXFx1MDE1RFxcdTAxNUZcXHUwMTYxXFx1MDE2M1xcdTAxNjVcXHUwMTY3XFx1MDE2OVxcdTAxNkJcXHUwMTZEXFx1MDE2RlxcdTAxNzFcXHUwMTczXFx1MDE3NVxcdTAxNzdcXHUwMTdBXFx1MDE3Q1xcdTAxN0UtXFx1MDE4MFxcdTAxODNcXHUwMTg1XFx1MDE4OFxcdTAxOENcXHUwMThEXFx1MDE5MlxcdTAxOTVcXHUwMTk5LVxcdTAxOUJcXHUwMTlFXFx1MDFBMVxcdTAxQTNcXHUwMUE1XFx1MDFBOFxcdTAxQUFcXHUwMUFCXFx1MDFBRFxcdTAxQjBcXHUwMUI0XFx1MDFCNlxcdTAxQjlcXHUwMUJBXFx1MDFCRC1cXHUwMUJGXFx1MDFDNlxcdTAxQzlcXHUwMUNDXFx1MDFDRVxcdTAxRDBcXHUwMUQyXFx1MDFENFxcdTAxRDZcXHUwMUQ4XFx1MDFEQVxcdTAxRENcXHUwMUREXFx1MDFERlxcdTAxRTFcXHUwMUUzXFx1MDFFNVxcdTAxRTdcXHUwMUU5XFx1MDFFQlxcdTAxRURcXHUwMUVGXFx1MDFGMFxcdTAxRjNcXHUwMUY1XFx1MDFGOVxcdTAxRkJcXHUwMUZEXFx1MDFGRlxcdTAyMDFcXHUwMjAzXFx1MDIwNVxcdTAyMDdcXHUwMjA5XFx1MDIwQlxcdTAyMERcXHUwMjBGXFx1MDIxMVxcdTAyMTNcXHUwMjE1XFx1MDIxN1xcdTAyMTlcXHUwMjFCXFx1MDIxRFxcdTAyMUZcXHUwMjIxXFx1MDIyM1xcdTAyMjVcXHUwMjI3XFx1MDIyOVxcdTAyMkJcXHUwMjJEXFx1MDIyRlxcdTAyMzFcXHUwMjMzLVxcdTAyMzlcXHUwMjNDXFx1MDIzRlxcdTAyNDBcXHUwMjQyXFx1MDI0N1xcdTAyNDlcXHUwMjRCXFx1MDI0RFxcdTAyNEYtXFx1MDI5M1xcdTAyOTUtXFx1MDJBRlxcdTAzNzFcXHUwMzczXFx1MDM3N1xcdTAzN0ItXFx1MDM3RFxcdTAzOTBcXHUwM0FDLVxcdTAzQ0VcXHUwM0QwXFx1MDNEMVxcdTAzRDUtXFx1MDNEN1xcdTAzRDlcXHUwM0RCXFx1MDNERFxcdTAzREZcXHUwM0UxXFx1MDNFM1xcdTAzRTVcXHUwM0U3XFx1MDNFOVxcdTAzRUJcXHUwM0VEXFx1MDNFRi1cXHUwM0YzXFx1MDNGNVxcdTAzRjhcXHUwM0ZCXFx1MDNGQ1xcdTA0MzAtXFx1MDQ1RlxcdTA0NjFcXHUwNDYzXFx1MDQ2NVxcdTA0NjdcXHUwNDY5XFx1MDQ2QlxcdTA0NkRcXHUwNDZGXFx1MDQ3MVxcdTA0NzNcXHUwNDc1XFx1MDQ3N1xcdTA0NzlcXHUwNDdCXFx1MDQ3RFxcdTA0N0ZcXHUwNDgxXFx1MDQ4QlxcdTA0OERcXHUwNDhGXFx1MDQ5MVxcdTA0OTNcXHUwNDk1XFx1MDQ5N1xcdTA0OTlcXHUwNDlCXFx1MDQ5RFxcdTA0OUZcXHUwNEExXFx1MDRBM1xcdTA0QTVcXHUwNEE3XFx1MDRBOVxcdTA0QUJcXHUwNEFEXFx1MDRBRlxcdTA0QjFcXHUwNEIzXFx1MDRCNVxcdTA0QjdcXHUwNEI5XFx1MDRCQlxcdTA0QkRcXHUwNEJGXFx1MDRDMlxcdTA0QzRcXHUwNEM2XFx1MDRDOFxcdTA0Q0FcXHUwNENDXFx1MDRDRVxcdTA0Q0ZcXHUwNEQxXFx1MDREM1xcdTA0RDVcXHUwNEQ3XFx1MDREOVxcdTA0REJcXHUwNEREXFx1MDRERlxcdTA0RTFcXHUwNEUzXFx1MDRFNVxcdTA0RTdcXHUwNEU5XFx1MDRFQlxcdTA0RURcXHUwNEVGXFx1MDRGMVxcdTA0RjNcXHUwNEY1XFx1MDRGN1xcdTA0RjlcXHUwNEZCXFx1MDRGRFxcdTA0RkZcXHUwNTAxXFx1MDUwM1xcdTA1MDVcXHUwNTA3XFx1MDUwOVxcdTA1MEJcXHUwNTBEXFx1MDUwRlxcdTA1MTFcXHUwNTEzXFx1MDUxNVxcdTA1MTdcXHUwNTE5XFx1MDUxQlxcdTA1MURcXHUwNTFGXFx1MDUyMVxcdTA1MjNcXHUwNTI1XFx1MDUyN1xcdTA1MjlcXHUwNTJCXFx1MDUyRFxcdTA1MkZcXHUwNTYxLVxcdTA1ODdcXHUxM0Y4LVxcdTEzRkRcXHUxRDAwLVxcdTFEMkJcXHUxRDZCLVxcdTFENzdcXHUxRDc5LVxcdTFEOUFcXHUxRTAxXFx1MUUwM1xcdTFFMDVcXHUxRTA3XFx1MUUwOVxcdTFFMEJcXHUxRTBEXFx1MUUwRlxcdTFFMTFcXHUxRTEzXFx1MUUxNVxcdTFFMTdcXHUxRTE5XFx1MUUxQlxcdTFFMURcXHUxRTFGXFx1MUUyMVxcdTFFMjNcXHUxRTI1XFx1MUUyN1xcdTFFMjlcXHUxRTJCXFx1MUUyRFxcdTFFMkZcXHUxRTMxXFx1MUUzM1xcdTFFMzVcXHUxRTM3XFx1MUUzOVxcdTFFM0JcXHUxRTNEXFx1MUUzRlxcdTFFNDFcXHUxRTQzXFx1MUU0NVxcdTFFNDdcXHUxRTQ5XFx1MUU0QlxcdTFFNERcXHUxRTRGXFx1MUU1MVxcdTFFNTNcXHUxRTU1XFx1MUU1N1xcdTFFNTlcXHUxRTVCXFx1MUU1RFxcdTFFNUZcXHUxRTYxXFx1MUU2M1xcdTFFNjVcXHUxRTY3XFx1MUU2OVxcdTFFNkJcXHUxRTZEXFx1MUU2RlxcdTFFNzFcXHUxRTczXFx1MUU3NVxcdTFFNzdcXHUxRTc5XFx1MUU3QlxcdTFFN0RcXHUxRTdGXFx1MUU4MVxcdTFFODNcXHUxRTg1XFx1MUU4N1xcdTFFODlcXHUxRThCXFx1MUU4RFxcdTFFOEZcXHUxRTkxXFx1MUU5M1xcdTFFOTUtXFx1MUU5RFxcdTFFOUZcXHUxRUExXFx1MUVBM1xcdTFFQTVcXHUxRUE3XFx1MUVBOVxcdTFFQUJcXHUxRUFEXFx1MUVBRlxcdTFFQjFcXHUxRUIzXFx1MUVCNVxcdTFFQjdcXHUxRUI5XFx1MUVCQlxcdTFFQkRcXHUxRUJGXFx1MUVDMVxcdTFFQzNcXHUxRUM1XFx1MUVDN1xcdTFFQzlcXHUxRUNCXFx1MUVDRFxcdTFFQ0ZcXHUxRUQxXFx1MUVEM1xcdTFFRDVcXHUxRUQ3XFx1MUVEOVxcdTFFREJcXHUxRUREXFx1MUVERlxcdTFFRTFcXHUxRUUzXFx1MUVFNVxcdTFFRTdcXHUxRUU5XFx1MUVFQlxcdTFFRURcXHUxRUVGXFx1MUVGMVxcdTFFRjNcXHUxRUY1XFx1MUVGN1xcdTFFRjlcXHUxRUZCXFx1MUVGRFxcdTFFRkYtXFx1MUYwN1xcdTFGMTAtXFx1MUYxNVxcdTFGMjAtXFx1MUYyN1xcdTFGMzAtXFx1MUYzN1xcdTFGNDAtXFx1MUY0NVxcdTFGNTAtXFx1MUY1N1xcdTFGNjAtXFx1MUY2N1xcdTFGNzAtXFx1MUY3RFxcdTFGODAtXFx1MUY4N1xcdTFGOTAtXFx1MUY5N1xcdTFGQTAtXFx1MUZBN1xcdTFGQjAtXFx1MUZCNFxcdTFGQjZcXHUxRkI3XFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzZcXHUxRkM3XFx1MUZEMC1cXHUxRkQzXFx1MUZENlxcdTFGRDdcXHUxRkUwLVxcdTFGRTdcXHUxRkYyLVxcdTFGRjRcXHUxRkY2XFx1MUZGN1xcdTIxMEFcXHUyMTBFXFx1MjEwRlxcdTIxMTNcXHUyMTJGXFx1MjEzNFxcdTIxMzlcXHUyMTNDXFx1MjEzRFxcdTIxNDYtXFx1MjE0OVxcdTIxNEVcXHUyMTg0XFx1MkMzMC1cXHUyQzVFXFx1MkM2MVxcdTJDNjVcXHUyQzY2XFx1MkM2OFxcdTJDNkFcXHUyQzZDXFx1MkM3MVxcdTJDNzNcXHUyQzc0XFx1MkM3Ni1cXHUyQzdCXFx1MkM4MVxcdTJDODNcXHUyQzg1XFx1MkM4N1xcdTJDODlcXHUyQzhCXFx1MkM4RFxcdTJDOEZcXHUyQzkxXFx1MkM5M1xcdTJDOTVcXHUyQzk3XFx1MkM5OVxcdTJDOUJcXHUyQzlEXFx1MkM5RlxcdTJDQTFcXHUyQ0EzXFx1MkNBNVxcdTJDQTdcXHUyQ0E5XFx1MkNBQlxcdTJDQURcXHUyQ0FGXFx1MkNCMVxcdTJDQjNcXHUyQ0I1XFx1MkNCN1xcdTJDQjlcXHUyQ0JCXFx1MkNCRFxcdTJDQkZcXHUyQ0MxXFx1MkNDM1xcdTJDQzVcXHUyQ0M3XFx1MkNDOVxcdTJDQ0JcXHUyQ0NEXFx1MkNDRlxcdTJDRDFcXHUyQ0QzXFx1MkNENVxcdTJDRDdcXHUyQ0Q5XFx1MkNEQlxcdTJDRERcXHUyQ0RGXFx1MkNFMVxcdTJDRTNcXHUyQ0U0XFx1MkNFQ1xcdTJDRUVcXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHVBNjQxXFx1QTY0M1xcdUE2NDVcXHVBNjQ3XFx1QTY0OVxcdUE2NEJcXHVBNjREXFx1QTY0RlxcdUE2NTFcXHVBNjUzXFx1QTY1NVxcdUE2NTdcXHVBNjU5XFx1QTY1QlxcdUE2NURcXHVBNjVGXFx1QTY2MVxcdUE2NjNcXHVBNjY1XFx1QTY2N1xcdUE2NjlcXHVBNjZCXFx1QTY2RFxcdUE2ODFcXHVBNjgzXFx1QTY4NVxcdUE2ODdcXHVBNjg5XFx1QTY4QlxcdUE2OERcXHVBNjhGXFx1QTY5MVxcdUE2OTNcXHVBNjk1XFx1QTY5N1xcdUE2OTlcXHVBNjlCXFx1QTcyM1xcdUE3MjVcXHVBNzI3XFx1QTcyOVxcdUE3MkJcXHVBNzJEXFx1QTcyRi1cXHVBNzMxXFx1QTczM1xcdUE3MzVcXHVBNzM3XFx1QTczOVxcdUE3M0JcXHVBNzNEXFx1QTczRlxcdUE3NDFcXHVBNzQzXFx1QTc0NVxcdUE3NDdcXHVBNzQ5XFx1QTc0QlxcdUE3NERcXHVBNzRGXFx1QTc1MVxcdUE3NTNcXHVBNzU1XFx1QTc1N1xcdUE3NTlcXHVBNzVCXFx1QTc1RFxcdUE3NUZcXHVBNzYxXFx1QTc2M1xcdUE3NjVcXHVBNzY3XFx1QTc2OVxcdUE3NkJcXHVBNzZEXFx1QTc2RlxcdUE3NzEtXFx1QTc3OFxcdUE3N0FcXHVBNzdDXFx1QTc3RlxcdUE3ODFcXHVBNzgzXFx1QTc4NVxcdUE3ODdcXHVBNzhDXFx1QTc4RVxcdUE3OTFcXHVBNzkzLVxcdUE3OTVcXHVBNzk3XFx1QTc5OVxcdUE3OUJcXHVBNzlEXFx1QTc5RlxcdUE3QTFcXHVBN0EzXFx1QTdBNVxcdUE3QTdcXHVBN0E5XFx1QTdCNVxcdUE3QjdcXHVBN0ZBXFx1QUIzMC1cXHVBQjVBXFx1QUI2MC1cXHVBQjY1XFx1QUI3MC1cXHVBQkJGXFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkY0MS1cXHVGRjVBMC05XFx4QjJcXHhCM1xceEI5XFx4QkMtXFx4QkVcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcXHUwN0MwLVxcdTA3QzlcXHUwOTY2LVxcdTA5NkZcXHUwOUU2LVxcdTA5RUZcXHUwOUY0LVxcdTA5RjlcXHUwQTY2LVxcdTBBNkZcXHUwQUU2LVxcdTBBRUZcXHUwQjY2LVxcdTBCNkZcXHUwQjcyLVxcdTBCNzdcXHUwQkU2LVxcdTBCRjJcXHUwQzY2LVxcdTBDNkZcXHUwQzc4LVxcdTBDN0VcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENzVcXHUwREU2LVxcdTBERUZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMzNcXHUxMDQwLVxcdTEwNDlcXHUxMDkwLVxcdTEwOTlcXHUxMzY5LVxcdTEzN0NcXHUxNkVFLVxcdTE2RjBcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxOTQ2LVxcdTE5NEZcXHUxOUQwLVxcdTE5REFcXHUxQTgwLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQjUwLVxcdTFCNTlcXHUxQkIwLVxcdTFCQjlcXHUxQzQwLVxcdTFDNDlcXHUxQzUwLVxcdTFDNTlcXHUyMDcwXFx1MjA3NC1cXHUyMDc5XFx1MjA4MC1cXHUyMDg5XFx1MjE1MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg5XFx1MjQ2MC1cXHUyNDlCXFx1MjRFQS1cXHUyNEZGXFx1Mjc3Ni1cXHUyNzkzXFx1MkNGRFxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0FcXHUzMTkyLVxcdTMxOTVcXHUzMjIwLVxcdTMyMjlcXHUzMjQ4LVxcdTMyNEZcXHUzMjUxLVxcdTMyNUZcXHUzMjgwLVxcdTMyODlcXHUzMkIxLVxcdTMyQkZcXHVBNjIwLVxcdUE2MjlcXHVBNkU2LVxcdUE2RUZcXHVBODMwLVxcdUE4MzVcXHVBOEQwLVxcdUE4RDlcXHVBOTAwLVxcdUE5MDlcXHVBOUQwLVxcdUE5RDlcXHVBOUYwLVxcdUE5RjlcXHVBQTUwLVxcdUFBNTlcXHVBQkYwLVxcdUFCRjlcXHVGRjEwLVxcdUZGMTldKShbQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE4M1xcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FEXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQV0pL2dcbiIsIm1vZHVsZS5leHBvcnRzID0gLyhbQS1aXFx4QzAtXFx4RDZcXHhEOC1cXHhERVxcdTAxMDBcXHUwMTAyXFx1MDEwNFxcdTAxMDZcXHUwMTA4XFx1MDEwQVxcdTAxMENcXHUwMTBFXFx1MDExMFxcdTAxMTJcXHUwMTE0XFx1MDExNlxcdTAxMThcXHUwMTFBXFx1MDExQ1xcdTAxMUVcXHUwMTIwXFx1MDEyMlxcdTAxMjRcXHUwMTI2XFx1MDEyOFxcdTAxMkFcXHUwMTJDXFx1MDEyRVxcdTAxMzBcXHUwMTMyXFx1MDEzNFxcdTAxMzZcXHUwMTM5XFx1MDEzQlxcdTAxM0RcXHUwMTNGXFx1MDE0MVxcdTAxNDNcXHUwMTQ1XFx1MDE0N1xcdTAxNEFcXHUwMTRDXFx1MDE0RVxcdTAxNTBcXHUwMTUyXFx1MDE1NFxcdTAxNTZcXHUwMTU4XFx1MDE1QVxcdTAxNUNcXHUwMTVFXFx1MDE2MFxcdTAxNjJcXHUwMTY0XFx1MDE2NlxcdTAxNjhcXHUwMTZBXFx1MDE2Q1xcdTAxNkVcXHUwMTcwXFx1MDE3MlxcdTAxNzRcXHUwMTc2XFx1MDE3OFxcdTAxNzlcXHUwMTdCXFx1MDE3RFxcdTAxODFcXHUwMTgyXFx1MDE4NFxcdTAxODZcXHUwMTg3XFx1MDE4OS1cXHUwMThCXFx1MDE4RS1cXHUwMTkxXFx1MDE5M1xcdTAxOTRcXHUwMTk2LVxcdTAxOThcXHUwMTlDXFx1MDE5RFxcdTAxOUZcXHUwMUEwXFx1MDFBMlxcdTAxQTRcXHUwMUE2XFx1MDFBN1xcdTAxQTlcXHUwMUFDXFx1MDFBRVxcdTAxQUZcXHUwMUIxLVxcdTAxQjNcXHUwMUI1XFx1MDFCN1xcdTAxQjhcXHUwMUJDXFx1MDFDNFxcdTAxQzdcXHUwMUNBXFx1MDFDRFxcdTAxQ0ZcXHUwMUQxXFx1MDFEM1xcdTAxRDVcXHUwMUQ3XFx1MDFEOVxcdTAxREJcXHUwMURFXFx1MDFFMFxcdTAxRTJcXHUwMUU0XFx1MDFFNlxcdTAxRThcXHUwMUVBXFx1MDFFQ1xcdTAxRUVcXHUwMUYxXFx1MDFGNFxcdTAxRjYtXFx1MDFGOFxcdTAxRkFcXHUwMUZDXFx1MDFGRVxcdTAyMDBcXHUwMjAyXFx1MDIwNFxcdTAyMDZcXHUwMjA4XFx1MDIwQVxcdTAyMENcXHUwMjBFXFx1MDIxMFxcdTAyMTJcXHUwMjE0XFx1MDIxNlxcdTAyMThcXHUwMjFBXFx1MDIxQ1xcdTAyMUVcXHUwMjIwXFx1MDIyMlxcdTAyMjRcXHUwMjI2XFx1MDIyOFxcdTAyMkFcXHUwMjJDXFx1MDIyRVxcdTAyMzBcXHUwMjMyXFx1MDIzQVxcdTAyM0JcXHUwMjNEXFx1MDIzRVxcdTAyNDFcXHUwMjQzLVxcdTAyNDZcXHUwMjQ4XFx1MDI0QVxcdTAyNENcXHUwMjRFXFx1MDM3MFxcdTAzNzJcXHUwMzc2XFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RVxcdTAzOEZcXHUwMzkxLVxcdTAzQTFcXHUwM0EzLVxcdTAzQUJcXHUwM0NGXFx1MDNEMi1cXHUwM0Q0XFx1MDNEOFxcdTAzREFcXHUwM0RDXFx1MDNERVxcdTAzRTBcXHUwM0UyXFx1MDNFNFxcdTAzRTZcXHUwM0U4XFx1MDNFQVxcdTAzRUNcXHUwM0VFXFx1MDNGNFxcdTAzRjdcXHUwM0Y5XFx1MDNGQVxcdTAzRkQtXFx1MDQyRlxcdTA0NjBcXHUwNDYyXFx1MDQ2NFxcdTA0NjZcXHUwNDY4XFx1MDQ2QVxcdTA0NkNcXHUwNDZFXFx1MDQ3MFxcdTA0NzJcXHUwNDc0XFx1MDQ3NlxcdTA0NzhcXHUwNDdBXFx1MDQ3Q1xcdTA0N0VcXHUwNDgwXFx1MDQ4QVxcdTA0OENcXHUwNDhFXFx1MDQ5MFxcdTA0OTJcXHUwNDk0XFx1MDQ5NlxcdTA0OThcXHUwNDlBXFx1MDQ5Q1xcdTA0OUVcXHUwNEEwXFx1MDRBMlxcdTA0QTRcXHUwNEE2XFx1MDRBOFxcdTA0QUFcXHUwNEFDXFx1MDRBRVxcdTA0QjBcXHUwNEIyXFx1MDRCNFxcdTA0QjZcXHUwNEI4XFx1MDRCQVxcdTA0QkNcXHUwNEJFXFx1MDRDMFxcdTA0QzFcXHUwNEMzXFx1MDRDNVxcdTA0QzdcXHUwNEM5XFx1MDRDQlxcdTA0Q0RcXHUwNEQwXFx1MDREMlxcdTA0RDRcXHUwNEQ2XFx1MDREOFxcdTA0REFcXHUwNERDXFx1MDRERVxcdTA0RTBcXHUwNEUyXFx1MDRFNFxcdTA0RTZcXHUwNEU4XFx1MDRFQVxcdTA0RUNcXHUwNEVFXFx1MDRGMFxcdTA0RjJcXHUwNEY0XFx1MDRGNlxcdTA0RjhcXHUwNEZBXFx1MDRGQ1xcdTA0RkVcXHUwNTAwXFx1MDUwMlxcdTA1MDRcXHUwNTA2XFx1MDUwOFxcdTA1MEFcXHUwNTBDXFx1MDUwRVxcdTA1MTBcXHUwNTEyXFx1MDUxNFxcdTA1MTZcXHUwNTE4XFx1MDUxQVxcdTA1MUNcXHUwNTFFXFx1MDUyMFxcdTA1MjJcXHUwNTI0XFx1MDUyNlxcdTA1MjhcXHUwNTJBXFx1MDUyQ1xcdTA1MkVcXHUwNTMxLVxcdTA1NTZcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEzQTAtXFx1MTNGNVxcdTFFMDBcXHUxRTAyXFx1MUUwNFxcdTFFMDZcXHUxRTA4XFx1MUUwQVxcdTFFMENcXHUxRTBFXFx1MUUxMFxcdTFFMTJcXHUxRTE0XFx1MUUxNlxcdTFFMThcXHUxRTFBXFx1MUUxQ1xcdTFFMUVcXHUxRTIwXFx1MUUyMlxcdTFFMjRcXHUxRTI2XFx1MUUyOFxcdTFFMkFcXHUxRTJDXFx1MUUyRVxcdTFFMzBcXHUxRTMyXFx1MUUzNFxcdTFFMzZcXHUxRTM4XFx1MUUzQVxcdTFFM0NcXHUxRTNFXFx1MUU0MFxcdTFFNDJcXHUxRTQ0XFx1MUU0NlxcdTFFNDhcXHUxRTRBXFx1MUU0Q1xcdTFFNEVcXHUxRTUwXFx1MUU1MlxcdTFFNTRcXHUxRTU2XFx1MUU1OFxcdTFFNUFcXHUxRTVDXFx1MUU1RVxcdTFFNjBcXHUxRTYyXFx1MUU2NFxcdTFFNjZcXHUxRTY4XFx1MUU2QVxcdTFFNkNcXHUxRTZFXFx1MUU3MFxcdTFFNzJcXHUxRTc0XFx1MUU3NlxcdTFFNzhcXHUxRTdBXFx1MUU3Q1xcdTFFN0VcXHUxRTgwXFx1MUU4MlxcdTFFODRcXHUxRTg2XFx1MUU4OFxcdTFFOEFcXHUxRThDXFx1MUU4RVxcdTFFOTBcXHUxRTkyXFx1MUU5NFxcdTFFOUVcXHUxRUEwXFx1MUVBMlxcdTFFQTRcXHUxRUE2XFx1MUVBOFxcdTFFQUFcXHUxRUFDXFx1MUVBRVxcdTFFQjBcXHUxRUIyXFx1MUVCNFxcdTFFQjZcXHUxRUI4XFx1MUVCQVxcdTFFQkNcXHUxRUJFXFx1MUVDMFxcdTFFQzJcXHUxRUM0XFx1MUVDNlxcdTFFQzhcXHUxRUNBXFx1MUVDQ1xcdTFFQ0VcXHUxRUQwXFx1MUVEMlxcdTFFRDRcXHUxRUQ2XFx1MUVEOFxcdTFFREFcXHUxRURDXFx1MUVERVxcdTFFRTBcXHUxRUUyXFx1MUVFNFxcdTFFRTZcXHUxRUU4XFx1MUVFQVxcdTFFRUNcXHUxRUVFXFx1MUVGMFxcdTFFRjJcXHUxRUY0XFx1MUVGNlxcdTFFRjhcXHUxRUZBXFx1MUVGQ1xcdTFFRkVcXHUxRjA4LVxcdTFGMEZcXHUxRjE4LVxcdTFGMURcXHUxRjI4LVxcdTFGMkZcXHUxRjM4LVxcdTFGM0ZcXHUxRjQ4LVxcdTFGNERcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGXFx1MUY2OC1cXHUxRjZGXFx1MUZCOC1cXHUxRkJCXFx1MUZDOC1cXHUxRkNCXFx1MUZEOC1cXHUxRkRCXFx1MUZFOC1cXHUxRkVDXFx1MUZGOC1cXHUxRkZCXFx1MjEwMlxcdTIxMDdcXHUyMTBCLVxcdTIxMERcXHUyMTEwLVxcdTIxMTJcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEzMC1cXHUyMTMzXFx1MjEzRVxcdTIxM0ZcXHUyMTQ1XFx1MjE4M1xcdTJDMDAtXFx1MkMyRVxcdTJDNjBcXHUyQzYyLVxcdTJDNjRcXHUyQzY3XFx1MkM2OVxcdTJDNkJcXHUyQzZELVxcdTJDNzBcXHUyQzcyXFx1MkM3NVxcdTJDN0UtXFx1MkM4MFxcdTJDODJcXHUyQzg0XFx1MkM4NlxcdTJDODhcXHUyQzhBXFx1MkM4Q1xcdTJDOEVcXHUyQzkwXFx1MkM5MlxcdTJDOTRcXHUyQzk2XFx1MkM5OFxcdTJDOUFcXHUyQzlDXFx1MkM5RVxcdTJDQTBcXHUyQ0EyXFx1MkNBNFxcdTJDQTZcXHUyQ0E4XFx1MkNBQVxcdTJDQUNcXHUyQ0FFXFx1MkNCMFxcdTJDQjJcXHUyQ0I0XFx1MkNCNlxcdTJDQjhcXHUyQ0JBXFx1MkNCQ1xcdTJDQkVcXHUyQ0MwXFx1MkNDMlxcdTJDQzRcXHUyQ0M2XFx1MkNDOFxcdTJDQ0FcXHUyQ0NDXFx1MkNDRVxcdTJDRDBcXHUyQ0QyXFx1MkNENFxcdTJDRDZcXHUyQ0Q4XFx1MkNEQVxcdTJDRENcXHUyQ0RFXFx1MkNFMFxcdTJDRTJcXHUyQ0VCXFx1MkNFRFxcdTJDRjJcXHVBNjQwXFx1QTY0MlxcdUE2NDRcXHVBNjQ2XFx1QTY0OFxcdUE2NEFcXHVBNjRDXFx1QTY0RVxcdUE2NTBcXHVBNjUyXFx1QTY1NFxcdUE2NTZcXHVBNjU4XFx1QTY1QVxcdUE2NUNcXHVBNjVFXFx1QTY2MFxcdUE2NjJcXHVBNjY0XFx1QTY2NlxcdUE2NjhcXHVBNjZBXFx1QTY2Q1xcdUE2ODBcXHVBNjgyXFx1QTY4NFxcdUE2ODZcXHVBNjg4XFx1QTY4QVxcdUE2OENcXHVBNjhFXFx1QTY5MFxcdUE2OTJcXHVBNjk0XFx1QTY5NlxcdUE2OThcXHVBNjlBXFx1QTcyMlxcdUE3MjRcXHVBNzI2XFx1QTcyOFxcdUE3MkFcXHVBNzJDXFx1QTcyRVxcdUE3MzJcXHVBNzM0XFx1QTczNlxcdUE3MzhcXHVBNzNBXFx1QTczQ1xcdUE3M0VcXHVBNzQwXFx1QTc0MlxcdUE3NDRcXHVBNzQ2XFx1QTc0OFxcdUE3NEFcXHVBNzRDXFx1QTc0RVxcdUE3NTBcXHVBNzUyXFx1QTc1NFxcdUE3NTZcXHVBNzU4XFx1QTc1QVxcdUE3NUNcXHVBNzVFXFx1QTc2MFxcdUE3NjJcXHVBNzY0XFx1QTc2NlxcdUE3NjhcXHVBNzZBXFx1QTc2Q1xcdUE3NkVcXHVBNzc5XFx1QTc3QlxcdUE3N0RcXHVBNzdFXFx1QTc4MFxcdUE3ODJcXHVBNzg0XFx1QTc4NlxcdUE3OEJcXHVBNzhEXFx1QTc5MFxcdUE3OTJcXHVBNzk2XFx1QTc5OFxcdUE3OUFcXHVBNzlDXFx1QTc5RVxcdUE3QTBcXHVBN0EyXFx1QTdBNFxcdUE3QTZcXHVBN0E4XFx1QTdBQS1cXHVBN0FEXFx1QTdCMC1cXHVBN0I0XFx1QTdCNlxcdUZGMjEtXFx1RkYzQV0pKFtBLVpcXHhDMC1cXHhENlxceEQ4LVxceERFXFx1MDEwMFxcdTAxMDJcXHUwMTA0XFx1MDEwNlxcdTAxMDhcXHUwMTBBXFx1MDEwQ1xcdTAxMEVcXHUwMTEwXFx1MDExMlxcdTAxMTRcXHUwMTE2XFx1MDExOFxcdTAxMUFcXHUwMTFDXFx1MDExRVxcdTAxMjBcXHUwMTIyXFx1MDEyNFxcdTAxMjZcXHUwMTI4XFx1MDEyQVxcdTAxMkNcXHUwMTJFXFx1MDEzMFxcdTAxMzJcXHUwMTM0XFx1MDEzNlxcdTAxMzlcXHUwMTNCXFx1MDEzRFxcdTAxM0ZcXHUwMTQxXFx1MDE0M1xcdTAxNDVcXHUwMTQ3XFx1MDE0QVxcdTAxNENcXHUwMTRFXFx1MDE1MFxcdTAxNTJcXHUwMTU0XFx1MDE1NlxcdTAxNThcXHUwMTVBXFx1MDE1Q1xcdTAxNUVcXHUwMTYwXFx1MDE2MlxcdTAxNjRcXHUwMTY2XFx1MDE2OFxcdTAxNkFcXHUwMTZDXFx1MDE2RVxcdTAxNzBcXHUwMTcyXFx1MDE3NFxcdTAxNzZcXHUwMTc4XFx1MDE3OVxcdTAxN0JcXHUwMTdEXFx1MDE4MVxcdTAxODJcXHUwMTg0XFx1MDE4NlxcdTAxODdcXHUwMTg5LVxcdTAxOEJcXHUwMThFLVxcdTAxOTFcXHUwMTkzXFx1MDE5NFxcdTAxOTYtXFx1MDE5OFxcdTAxOUNcXHUwMTlEXFx1MDE5RlxcdTAxQTBcXHUwMUEyXFx1MDFBNFxcdTAxQTZcXHUwMUE3XFx1MDFBOVxcdTAxQUNcXHUwMUFFXFx1MDFBRlxcdTAxQjEtXFx1MDFCM1xcdTAxQjVcXHUwMUI3XFx1MDFCOFxcdTAxQkNcXHUwMUM0XFx1MDFDN1xcdTAxQ0FcXHUwMUNEXFx1MDFDRlxcdTAxRDFcXHUwMUQzXFx1MDFENVxcdTAxRDdcXHUwMUQ5XFx1MDFEQlxcdTAxREVcXHUwMUUwXFx1MDFFMlxcdTAxRTRcXHUwMUU2XFx1MDFFOFxcdTAxRUFcXHUwMUVDXFx1MDFFRVxcdTAxRjFcXHUwMUY0XFx1MDFGNi1cXHUwMUY4XFx1MDFGQVxcdTAxRkNcXHUwMUZFXFx1MDIwMFxcdTAyMDJcXHUwMjA0XFx1MDIwNlxcdTAyMDhcXHUwMjBBXFx1MDIwQ1xcdTAyMEVcXHUwMjEwXFx1MDIxMlxcdTAyMTRcXHUwMjE2XFx1MDIxOFxcdTAyMUFcXHUwMjFDXFx1MDIxRVxcdTAyMjBcXHUwMjIyXFx1MDIyNFxcdTAyMjZcXHUwMjI4XFx1MDIyQVxcdTAyMkNcXHUwMjJFXFx1MDIzMFxcdTAyMzJcXHUwMjNBXFx1MDIzQlxcdTAyM0RcXHUwMjNFXFx1MDI0MVxcdTAyNDMtXFx1MDI0NlxcdTAyNDhcXHUwMjRBXFx1MDI0Q1xcdTAyNEVcXHUwMzcwXFx1MDM3MlxcdTAzNzZcXHUwMzdGXFx1MDM4NlxcdTAzODgtXFx1MDM4QVxcdTAzOENcXHUwMzhFXFx1MDM4RlxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBQlxcdTAzQ0ZcXHUwM0QyLVxcdTAzRDRcXHUwM0Q4XFx1MDNEQVxcdTAzRENcXHUwM0RFXFx1MDNFMFxcdTAzRTJcXHUwM0U0XFx1MDNFNlxcdTAzRThcXHUwM0VBXFx1MDNFQ1xcdTAzRUVcXHUwM0Y0XFx1MDNGN1xcdTAzRjlcXHUwM0ZBXFx1MDNGRC1cXHUwNDJGXFx1MDQ2MFxcdTA0NjJcXHUwNDY0XFx1MDQ2NlxcdTA0NjhcXHUwNDZBXFx1MDQ2Q1xcdTA0NkVcXHUwNDcwXFx1MDQ3MlxcdTA0NzRcXHUwNDc2XFx1MDQ3OFxcdTA0N0FcXHUwNDdDXFx1MDQ3RVxcdTA0ODBcXHUwNDhBXFx1MDQ4Q1xcdTA0OEVcXHUwNDkwXFx1MDQ5MlxcdTA0OTRcXHUwNDk2XFx1MDQ5OFxcdTA0OUFcXHUwNDlDXFx1MDQ5RVxcdTA0QTBcXHUwNEEyXFx1MDRBNFxcdTA0QTZcXHUwNEE4XFx1MDRBQVxcdTA0QUNcXHUwNEFFXFx1MDRCMFxcdTA0QjJcXHUwNEI0XFx1MDRCNlxcdTA0QjhcXHUwNEJBXFx1MDRCQ1xcdTA0QkVcXHUwNEMwXFx1MDRDMVxcdTA0QzNcXHUwNEM1XFx1MDRDN1xcdTA0QzlcXHUwNENCXFx1MDRDRFxcdTA0RDBcXHUwNEQyXFx1MDRENFxcdTA0RDZcXHUwNEQ4XFx1MDREQVxcdTA0RENcXHUwNERFXFx1MDRFMFxcdTA0RTJcXHUwNEU0XFx1MDRFNlxcdTA0RThcXHUwNEVBXFx1MDRFQ1xcdTA0RUVcXHUwNEYwXFx1MDRGMlxcdTA0RjRcXHUwNEY2XFx1MDRGOFxcdTA0RkFcXHUwNEZDXFx1MDRGRVxcdTA1MDBcXHUwNTAyXFx1MDUwNFxcdTA1MDZcXHUwNTA4XFx1MDUwQVxcdTA1MENcXHUwNTBFXFx1MDUxMFxcdTA1MTJcXHUwNTE0XFx1MDUxNlxcdTA1MThcXHUwNTFBXFx1MDUxQ1xcdTA1MUVcXHUwNTIwXFx1MDUyMlxcdTA1MjRcXHUwNTI2XFx1MDUyOFxcdTA1MkFcXHUwNTJDXFx1MDUyRVxcdTA1MzEtXFx1MDU1NlxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTNBMC1cXHUxM0Y1XFx1MUUwMFxcdTFFMDJcXHUxRTA0XFx1MUUwNlxcdTFFMDhcXHUxRTBBXFx1MUUwQ1xcdTFFMEVcXHUxRTEwXFx1MUUxMlxcdTFFMTRcXHUxRTE2XFx1MUUxOFxcdTFFMUFcXHUxRTFDXFx1MUUxRVxcdTFFMjBcXHUxRTIyXFx1MUUyNFxcdTFFMjZcXHUxRTI4XFx1MUUyQVxcdTFFMkNcXHUxRTJFXFx1MUUzMFxcdTFFMzJcXHUxRTM0XFx1MUUzNlxcdTFFMzhcXHUxRTNBXFx1MUUzQ1xcdTFFM0VcXHUxRTQwXFx1MUU0MlxcdTFFNDRcXHUxRTQ2XFx1MUU0OFxcdTFFNEFcXHUxRTRDXFx1MUU0RVxcdTFFNTBcXHUxRTUyXFx1MUU1NFxcdTFFNTZcXHUxRTU4XFx1MUU1QVxcdTFFNUNcXHUxRTVFXFx1MUU2MFxcdTFFNjJcXHUxRTY0XFx1MUU2NlxcdTFFNjhcXHUxRTZBXFx1MUU2Q1xcdTFFNkVcXHUxRTcwXFx1MUU3MlxcdTFFNzRcXHUxRTc2XFx1MUU3OFxcdTFFN0FcXHUxRTdDXFx1MUU3RVxcdTFFODBcXHUxRTgyXFx1MUU4NFxcdTFFODZcXHUxRTg4XFx1MUU4QVxcdTFFOENcXHUxRThFXFx1MUU5MFxcdTFFOTJcXHUxRTk0XFx1MUU5RVxcdTFFQTBcXHUxRUEyXFx1MUVBNFxcdTFFQTZcXHUxRUE4XFx1MUVBQVxcdTFFQUNcXHUxRUFFXFx1MUVCMFxcdTFFQjJcXHUxRUI0XFx1MUVCNlxcdTFFQjhcXHUxRUJBXFx1MUVCQ1xcdTFFQkVcXHUxRUMwXFx1MUVDMlxcdTFFQzRcXHUxRUM2XFx1MUVDOFxcdTFFQ0FcXHUxRUNDXFx1MUVDRVxcdTFFRDBcXHUxRUQyXFx1MUVENFxcdTFFRDZcXHUxRUQ4XFx1MUVEQVxcdTFFRENcXHUxRURFXFx1MUVFMFxcdTFFRTJcXHUxRUU0XFx1MUVFNlxcdTFFRThcXHUxRUVBXFx1MUVFQ1xcdTFFRUVcXHUxRUYwXFx1MUVGMlxcdTFFRjRcXHUxRUY2XFx1MUVGOFxcdTFFRkFcXHUxRUZDXFx1MUVGRVxcdTFGMDgtXFx1MUYwRlxcdTFGMTgtXFx1MUYxRFxcdTFGMjgtXFx1MUYyRlxcdTFGMzgtXFx1MUYzRlxcdTFGNDgtXFx1MUY0RFxcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUZcXHUxRjY4LVxcdTFGNkZcXHUxRkI4LVxcdTFGQkJcXHUxRkM4LVxcdTFGQ0JcXHUxRkQ4LVxcdTFGREJcXHUxRkU4LVxcdTFGRUNcXHUxRkY4LVxcdTFGRkJcXHUyMTAyXFx1MjEwN1xcdTIxMEItXFx1MjEwRFxcdTIxMTAtXFx1MjExMlxcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTMwLVxcdTIxMzNcXHUyMTNFXFx1MjEzRlxcdTIxNDVcXHUyMTgzXFx1MkMwMC1cXHUyQzJFXFx1MkM2MFxcdTJDNjItXFx1MkM2NFxcdTJDNjdcXHUyQzY5XFx1MkM2QlxcdTJDNkQtXFx1MkM3MFxcdTJDNzJcXHUyQzc1XFx1MkM3RS1cXHUyQzgwXFx1MkM4MlxcdTJDODRcXHUyQzg2XFx1MkM4OFxcdTJDOEFcXHUyQzhDXFx1MkM4RVxcdTJDOTBcXHUyQzkyXFx1MkM5NFxcdTJDOTZcXHUyQzk4XFx1MkM5QVxcdTJDOUNcXHUyQzlFXFx1MkNBMFxcdTJDQTJcXHUyQ0E0XFx1MkNBNlxcdTJDQThcXHUyQ0FBXFx1MkNBQ1xcdTJDQUVcXHUyQ0IwXFx1MkNCMlxcdTJDQjRcXHUyQ0I2XFx1MkNCOFxcdTJDQkFcXHUyQ0JDXFx1MkNCRVxcdTJDQzBcXHUyQ0MyXFx1MkNDNFxcdTJDQzZcXHUyQ0M4XFx1MkNDQVxcdTJDQ0NcXHUyQ0NFXFx1MkNEMFxcdTJDRDJcXHUyQ0Q0XFx1MkNENlxcdTJDRDhcXHUyQ0RBXFx1MkNEQ1xcdTJDREVcXHUyQ0UwXFx1MkNFMlxcdTJDRUJcXHUyQ0VEXFx1MkNGMlxcdUE2NDBcXHVBNjQyXFx1QTY0NFxcdUE2NDZcXHVBNjQ4XFx1QTY0QVxcdUE2NENcXHVBNjRFXFx1QTY1MFxcdUE2NTJcXHVBNjU0XFx1QTY1NlxcdUE2NThcXHVBNjVBXFx1QTY1Q1xcdUE2NUVcXHVBNjYwXFx1QTY2MlxcdUE2NjRcXHVBNjY2XFx1QTY2OFxcdUE2NkFcXHVBNjZDXFx1QTY4MFxcdUE2ODJcXHVBNjg0XFx1QTY4NlxcdUE2ODhcXHVBNjhBXFx1QTY4Q1xcdUE2OEVcXHVBNjkwXFx1QTY5MlxcdUE2OTRcXHVBNjk2XFx1QTY5OFxcdUE2OUFcXHVBNzIyXFx1QTcyNFxcdUE3MjZcXHVBNzI4XFx1QTcyQVxcdUE3MkNcXHVBNzJFXFx1QTczMlxcdUE3MzRcXHVBNzM2XFx1QTczOFxcdUE3M0FcXHVBNzNDXFx1QTczRVxcdUE3NDBcXHVBNzQyXFx1QTc0NFxcdUE3NDZcXHVBNzQ4XFx1QTc0QVxcdUE3NENcXHVBNzRFXFx1QTc1MFxcdUE3NTJcXHVBNzU0XFx1QTc1NlxcdUE3NThcXHVBNzVBXFx1QTc1Q1xcdUE3NUVcXHVBNzYwXFx1QTc2MlxcdUE3NjRcXHVBNzY2XFx1QTc2OFxcdUE3NkFcXHVBNzZDXFx1QTc2RVxcdUE3NzlcXHVBNzdCXFx1QTc3RFxcdUE3N0VcXHVBNzgwXFx1QTc4MlxcdUE3ODRcXHVBNzg2XFx1QTc4QlxcdUE3OERcXHVBNzkwXFx1QTc5MlxcdUE3OTZcXHVBNzk4XFx1QTc5QVxcdUE3OUNcXHVBNzlFXFx1QTdBMFxcdUE3QTJcXHVBN0E0XFx1QTdBNlxcdUE3QThcXHVBN0FBLVxcdUE3QURcXHVBN0IwLVxcdUE3QjRcXHVBN0I2XFx1RkYyMS1cXHVGRjNBXVthLXpcXHhCNVxceERGLVxceEY2XFx4RjgtXFx4RkZcXHUwMTAxXFx1MDEwM1xcdTAxMDVcXHUwMTA3XFx1MDEwOVxcdTAxMEJcXHUwMTBEXFx1MDEwRlxcdTAxMTFcXHUwMTEzXFx1MDExNVxcdTAxMTdcXHUwMTE5XFx1MDExQlxcdTAxMURcXHUwMTFGXFx1MDEyMVxcdTAxMjNcXHUwMTI1XFx1MDEyN1xcdTAxMjlcXHUwMTJCXFx1MDEyRFxcdTAxMkZcXHUwMTMxXFx1MDEzM1xcdTAxMzVcXHUwMTM3XFx1MDEzOFxcdTAxM0FcXHUwMTNDXFx1MDEzRVxcdTAxNDBcXHUwMTQyXFx1MDE0NFxcdTAxNDZcXHUwMTQ4XFx1MDE0OVxcdTAxNEJcXHUwMTREXFx1MDE0RlxcdTAxNTFcXHUwMTUzXFx1MDE1NVxcdTAxNTdcXHUwMTU5XFx1MDE1QlxcdTAxNURcXHUwMTVGXFx1MDE2MVxcdTAxNjNcXHUwMTY1XFx1MDE2N1xcdTAxNjlcXHUwMTZCXFx1MDE2RFxcdTAxNkZcXHUwMTcxXFx1MDE3M1xcdTAxNzVcXHUwMTc3XFx1MDE3QVxcdTAxN0NcXHUwMTdFLVxcdTAxODBcXHUwMTgzXFx1MDE4NVxcdTAxODhcXHUwMThDXFx1MDE4RFxcdTAxOTJcXHUwMTk1XFx1MDE5OS1cXHUwMTlCXFx1MDE5RVxcdTAxQTFcXHUwMUEzXFx1MDFBNVxcdTAxQThcXHUwMUFBXFx1MDFBQlxcdTAxQURcXHUwMUIwXFx1MDFCNFxcdTAxQjZcXHUwMUI5XFx1MDFCQVxcdTAxQkQtXFx1MDFCRlxcdTAxQzZcXHUwMUM5XFx1MDFDQ1xcdTAxQ0VcXHUwMUQwXFx1MDFEMlxcdTAxRDRcXHUwMUQ2XFx1MDFEOFxcdTAxREFcXHUwMURDXFx1MDFERFxcdTAxREZcXHUwMUUxXFx1MDFFM1xcdTAxRTVcXHUwMUU3XFx1MDFFOVxcdTAxRUJcXHUwMUVEXFx1MDFFRlxcdTAxRjBcXHUwMUYzXFx1MDFGNVxcdTAxRjlcXHUwMUZCXFx1MDFGRFxcdTAxRkZcXHUwMjAxXFx1MDIwM1xcdTAyMDVcXHUwMjA3XFx1MDIwOVxcdTAyMEJcXHUwMjBEXFx1MDIwRlxcdTAyMTFcXHUwMjEzXFx1MDIxNVxcdTAyMTdcXHUwMjE5XFx1MDIxQlxcdTAyMURcXHUwMjFGXFx1MDIyMVxcdTAyMjNcXHUwMjI1XFx1MDIyN1xcdTAyMjlcXHUwMjJCXFx1MDIyRFxcdTAyMkZcXHUwMjMxXFx1MDIzMy1cXHUwMjM5XFx1MDIzQ1xcdTAyM0ZcXHUwMjQwXFx1MDI0MlxcdTAyNDdcXHUwMjQ5XFx1MDI0QlxcdTAyNERcXHUwMjRGLVxcdTAyOTNcXHUwMjk1LVxcdTAyQUZcXHUwMzcxXFx1MDM3M1xcdTAzNzdcXHUwMzdCLVxcdTAzN0RcXHUwMzkwXFx1MDNBQy1cXHUwM0NFXFx1MDNEMFxcdTAzRDFcXHUwM0Q1LVxcdTAzRDdcXHUwM0Q5XFx1MDNEQlxcdTAzRERcXHUwM0RGXFx1MDNFMVxcdTAzRTNcXHUwM0U1XFx1MDNFN1xcdTAzRTlcXHUwM0VCXFx1MDNFRFxcdTAzRUYtXFx1MDNGM1xcdTAzRjVcXHUwM0Y4XFx1MDNGQlxcdTAzRkNcXHUwNDMwLVxcdTA0NUZcXHUwNDYxXFx1MDQ2M1xcdTA0NjVcXHUwNDY3XFx1MDQ2OVxcdTA0NkJcXHUwNDZEXFx1MDQ2RlxcdTA0NzFcXHUwNDczXFx1MDQ3NVxcdTA0NzdcXHUwNDc5XFx1MDQ3QlxcdTA0N0RcXHUwNDdGXFx1MDQ4MVxcdTA0OEJcXHUwNDhEXFx1MDQ4RlxcdTA0OTFcXHUwNDkzXFx1MDQ5NVxcdTA0OTdcXHUwNDk5XFx1MDQ5QlxcdTA0OURcXHUwNDlGXFx1MDRBMVxcdTA0QTNcXHUwNEE1XFx1MDRBN1xcdTA0QTlcXHUwNEFCXFx1MDRBRFxcdTA0QUZcXHUwNEIxXFx1MDRCM1xcdTA0QjVcXHUwNEI3XFx1MDRCOVxcdTA0QkJcXHUwNEJEXFx1MDRCRlxcdTA0QzJcXHUwNEM0XFx1MDRDNlxcdTA0QzhcXHUwNENBXFx1MDRDQ1xcdTA0Q0VcXHUwNENGXFx1MDREMVxcdTA0RDNcXHUwNEQ1XFx1MDREN1xcdTA0RDlcXHUwNERCXFx1MDRERFxcdTA0REZcXHUwNEUxXFx1MDRFM1xcdTA0RTVcXHUwNEU3XFx1MDRFOVxcdTA0RUJcXHUwNEVEXFx1MDRFRlxcdTA0RjFcXHUwNEYzXFx1MDRGNVxcdTA0RjdcXHUwNEY5XFx1MDRGQlxcdTA0RkRcXHUwNEZGXFx1MDUwMVxcdTA1MDNcXHUwNTA1XFx1MDUwN1xcdTA1MDlcXHUwNTBCXFx1MDUwRFxcdTA1MEZcXHUwNTExXFx1MDUxM1xcdTA1MTVcXHUwNTE3XFx1MDUxOVxcdTA1MUJcXHUwNTFEXFx1MDUxRlxcdTA1MjFcXHUwNTIzXFx1MDUyNVxcdTA1MjdcXHUwNTI5XFx1MDUyQlxcdTA1MkRcXHUwNTJGXFx1MDU2MS1cXHUwNTg3XFx1MTNGOC1cXHUxM0ZEXFx1MUQwMC1cXHUxRDJCXFx1MUQ2Qi1cXHUxRDc3XFx1MUQ3OS1cXHUxRDlBXFx1MUUwMVxcdTFFMDNcXHUxRTA1XFx1MUUwN1xcdTFFMDlcXHUxRTBCXFx1MUUwRFxcdTFFMEZcXHUxRTExXFx1MUUxM1xcdTFFMTVcXHUxRTE3XFx1MUUxOVxcdTFFMUJcXHUxRTFEXFx1MUUxRlxcdTFFMjFcXHUxRTIzXFx1MUUyNVxcdTFFMjdcXHUxRTI5XFx1MUUyQlxcdTFFMkRcXHUxRTJGXFx1MUUzMVxcdTFFMzNcXHUxRTM1XFx1MUUzN1xcdTFFMzlcXHUxRTNCXFx1MUUzRFxcdTFFM0ZcXHUxRTQxXFx1MUU0M1xcdTFFNDVcXHUxRTQ3XFx1MUU0OVxcdTFFNEJcXHUxRTREXFx1MUU0RlxcdTFFNTFcXHUxRTUzXFx1MUU1NVxcdTFFNTdcXHUxRTU5XFx1MUU1QlxcdTFFNURcXHUxRTVGXFx1MUU2MVxcdTFFNjNcXHUxRTY1XFx1MUU2N1xcdTFFNjlcXHUxRTZCXFx1MUU2RFxcdTFFNkZcXHUxRTcxXFx1MUU3M1xcdTFFNzVcXHUxRTc3XFx1MUU3OVxcdTFFN0JcXHUxRTdEXFx1MUU3RlxcdTFFODFcXHUxRTgzXFx1MUU4NVxcdTFFODdcXHUxRTg5XFx1MUU4QlxcdTFFOERcXHUxRThGXFx1MUU5MVxcdTFFOTNcXHUxRTk1LVxcdTFFOURcXHUxRTlGXFx1MUVBMVxcdTFFQTNcXHUxRUE1XFx1MUVBN1xcdTFFQTlcXHUxRUFCXFx1MUVBRFxcdTFFQUZcXHUxRUIxXFx1MUVCM1xcdTFFQjVcXHUxRUI3XFx1MUVCOVxcdTFFQkJcXHUxRUJEXFx1MUVCRlxcdTFFQzFcXHUxRUMzXFx1MUVDNVxcdTFFQzdcXHUxRUM5XFx1MUVDQlxcdTFFQ0RcXHUxRUNGXFx1MUVEMVxcdTFFRDNcXHUxRUQ1XFx1MUVEN1xcdTFFRDlcXHUxRURCXFx1MUVERFxcdTFFREZcXHUxRUUxXFx1MUVFM1xcdTFFRTVcXHUxRUU3XFx1MUVFOVxcdTFFRUJcXHUxRUVEXFx1MUVFRlxcdTFFRjFcXHUxRUYzXFx1MUVGNVxcdTFFRjdcXHUxRUY5XFx1MUVGQlxcdTFFRkRcXHUxRUZGLVxcdTFGMDdcXHUxRjEwLVxcdTFGMTVcXHUxRjIwLVxcdTFGMjdcXHUxRjMwLVxcdTFGMzdcXHUxRjQwLVxcdTFGNDVcXHUxRjUwLVxcdTFGNTdcXHUxRjYwLVxcdTFGNjdcXHUxRjcwLVxcdTFGN0RcXHUxRjgwLVxcdTFGODdcXHUxRjkwLVxcdTFGOTdcXHUxRkEwLVxcdTFGQTdcXHUxRkIwLVxcdTFGQjRcXHUxRkI2XFx1MUZCN1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2XFx1MUZDN1xcdTFGRDAtXFx1MUZEM1xcdTFGRDZcXHUxRkQ3XFx1MUZFMC1cXHUxRkU3XFx1MUZGMi1cXHUxRkY0XFx1MUZGNlxcdTFGRjdcXHUyMTBBXFx1MjEwRVxcdTIxMEZcXHUyMTEzXFx1MjEyRlxcdTIxMzRcXHUyMTM5XFx1MjEzQ1xcdTIxM0RcXHUyMTQ2LVxcdTIxNDlcXHUyMTRFXFx1MjE4NFxcdTJDMzAtXFx1MkM1RVxcdTJDNjFcXHUyQzY1XFx1MkM2NlxcdTJDNjhcXHUyQzZBXFx1MkM2Q1xcdTJDNzFcXHUyQzczXFx1MkM3NFxcdTJDNzYtXFx1MkM3QlxcdTJDODFcXHUyQzgzXFx1MkM4NVxcdTJDODdcXHUyQzg5XFx1MkM4QlxcdTJDOERcXHUyQzhGXFx1MkM5MVxcdTJDOTNcXHUyQzk1XFx1MkM5N1xcdTJDOTlcXHUyQzlCXFx1MkM5RFxcdTJDOUZcXHUyQ0ExXFx1MkNBM1xcdTJDQTVcXHUyQ0E3XFx1MkNBOVxcdTJDQUJcXHUyQ0FEXFx1MkNBRlxcdTJDQjFcXHUyQ0IzXFx1MkNCNVxcdTJDQjdcXHUyQ0I5XFx1MkNCQlxcdTJDQkRcXHUyQ0JGXFx1MkNDMVxcdTJDQzNcXHUyQ0M1XFx1MkNDN1xcdTJDQzlcXHUyQ0NCXFx1MkNDRFxcdTJDQ0ZcXHUyQ0QxXFx1MkNEM1xcdTJDRDVcXHUyQ0Q3XFx1MkNEOVxcdTJDREJcXHUyQ0REXFx1MkNERlxcdTJDRTFcXHUyQ0UzXFx1MkNFNFxcdTJDRUNcXHUyQ0VFXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1QTY0MVxcdUE2NDNcXHVBNjQ1XFx1QTY0N1xcdUE2NDlcXHVBNjRCXFx1QTY0RFxcdUE2NEZcXHVBNjUxXFx1QTY1M1xcdUE2NTVcXHVBNjU3XFx1QTY1OVxcdUE2NUJcXHVBNjVEXFx1QTY1RlxcdUE2NjFcXHVBNjYzXFx1QTY2NVxcdUE2NjdcXHVBNjY5XFx1QTY2QlxcdUE2NkRcXHVBNjgxXFx1QTY4M1xcdUE2ODVcXHVBNjg3XFx1QTY4OVxcdUE2OEJcXHVBNjhEXFx1QTY4RlxcdUE2OTFcXHVBNjkzXFx1QTY5NVxcdUE2OTdcXHVBNjk5XFx1QTY5QlxcdUE3MjNcXHVBNzI1XFx1QTcyN1xcdUE3MjlcXHVBNzJCXFx1QTcyRFxcdUE3MkYtXFx1QTczMVxcdUE3MzNcXHVBNzM1XFx1QTczN1xcdUE3MzlcXHVBNzNCXFx1QTczRFxcdUE3M0ZcXHVBNzQxXFx1QTc0M1xcdUE3NDVcXHVBNzQ3XFx1QTc0OVxcdUE3NEJcXHVBNzREXFx1QTc0RlxcdUE3NTFcXHVBNzUzXFx1QTc1NVxcdUE3NTdcXHVBNzU5XFx1QTc1QlxcdUE3NURcXHVBNzVGXFx1QTc2MVxcdUE3NjNcXHVBNzY1XFx1QTc2N1xcdUE3NjlcXHVBNzZCXFx1QTc2RFxcdUE3NkZcXHVBNzcxLVxcdUE3NzhcXHVBNzdBXFx1QTc3Q1xcdUE3N0ZcXHVBNzgxXFx1QTc4M1xcdUE3ODVcXHVBNzg3XFx1QTc4Q1xcdUE3OEVcXHVBNzkxXFx1QTc5My1cXHVBNzk1XFx1QTc5N1xcdUE3OTlcXHVBNzlCXFx1QTc5RFxcdUE3OUZcXHVBN0ExXFx1QTdBM1xcdUE3QTVcXHVBN0E3XFx1QTdBOVxcdUE3QjVcXHVBN0I3XFx1QTdGQVxcdUFCMzAtXFx1QUI1QVxcdUFCNjAtXFx1QUI2NVxcdUFCNzAtXFx1QUJCRlxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZGNDEtXFx1RkY1QV0pL2dcbiIsIm1vZHVsZS5leHBvcnRzID0gL1teQS1aYS16XFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkRcXHUwQ0RFXFx1MENFMFxcdTBDRTFcXHUwQ0YxXFx1MENGMlxcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0RcXHUwRDRFXFx1MEQ1Ri1cXHUwRDYxXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBFMDEtXFx1MEUzMFxcdTBFMzJcXHUwRTMzXFx1MEU0MC1cXHUwRTQ2XFx1MEU4MVxcdTBFODJcXHUwRTg0XFx1MEU4N1xcdTBFODhcXHUwRThBXFx1MEU4RFxcdTBFOTQtXFx1MEU5N1xcdTBFOTktXFx1MEU5RlxcdTBFQTEtXFx1MEVBM1xcdTBFQTVcXHUwRUE3XFx1MEVBQVxcdTBFQUJcXHUwRUFELVxcdTBFQjBcXHUwRUIyXFx1MEVCM1xcdTBFQkRcXHUwRUMwLVxcdTBFQzRcXHUwRUM2XFx1MEVEQy1cXHUwRURGXFx1MEYwMFxcdTBGNDAtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGODgtXFx1MEY4Q1xcdTEwMDAtXFx1MTAyQVxcdTEwM0ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVBLVxcdTEwNURcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZFLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhFXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RjEtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3ODAtXFx1MTdCM1xcdTE3RDdcXHUxN0RDXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEE4XFx1MThBQVxcdTE4QjAtXFx1MThGNVxcdTE5MDAtXFx1MTkxRVxcdTE5NTAtXFx1MTk2RFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlBQlxcdTE5QjAtXFx1MTlDOVxcdTFBMDAtXFx1MUExNlxcdTFBMjAtXFx1MUE1NFxcdTFBQTdcXHUxQjA1LVxcdTFCMzNcXHUxQjQ1LVxcdTFCNEJcXHUxQjgzLVxcdTFCQTBcXHUxQkFFXFx1MUJBRlxcdTFCQkEtXFx1MUJFNVxcdTFDMDAtXFx1MUMyM1xcdTFDNEQtXFx1MUM0RlxcdTFDNUEtXFx1MUM3RFxcdTFDRTktXFx1MUNFQ1xcdTFDRUUtXFx1MUNGMVxcdTFDRjVcXHUxQ0Y2XFx1MUQwMC1cXHUxREJGXFx1MUUwMC1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwNzFcXHUyMDdGXFx1MjA5MC1cXHUyMDlDXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTJEXFx1MjEyRi1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxODNcXHUyMTg0XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNVxcdTMwMDZcXHUzMDMxLVxcdTMwMzVcXHUzMDNCXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUQtXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkU1XFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FEXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDMC05XFx4QjJcXHhCM1xceEI5XFx4QkMtXFx4QkVcXHUwNjYwLVxcdTA2NjlcXHUwNkYwLVxcdTA2RjlcXHUwN0MwLVxcdTA3QzlcXHUwOTY2LVxcdTA5NkZcXHUwOUU2LVxcdTA5RUZcXHUwOUY0LVxcdTA5RjlcXHUwQTY2LVxcdTBBNkZcXHUwQUU2LVxcdTBBRUZcXHUwQjY2LVxcdTBCNkZcXHUwQjcyLVxcdTBCNzdcXHUwQkU2LVxcdTBCRjJcXHUwQzY2LVxcdTBDNkZcXHUwQzc4LVxcdTBDN0VcXHUwQ0U2LVxcdTBDRUZcXHUwRDY2LVxcdTBENzVcXHUwREU2LVxcdTBERUZcXHUwRTUwLVxcdTBFNTlcXHUwRUQwLVxcdTBFRDlcXHUwRjIwLVxcdTBGMzNcXHUxMDQwLVxcdTEwNDlcXHUxMDkwLVxcdTEwOTlcXHUxMzY5LVxcdTEzN0NcXHUxNkVFLVxcdTE2RjBcXHUxN0UwLVxcdTE3RTlcXHUxN0YwLVxcdTE3RjlcXHUxODEwLVxcdTE4MTlcXHUxOTQ2LVxcdTE5NEZcXHUxOUQwLVxcdTE5REFcXHUxQTgwLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQjUwLVxcdTFCNTlcXHUxQkIwLVxcdTFCQjlcXHUxQzQwLVxcdTFDNDlcXHUxQzUwLVxcdTFDNTlcXHUyMDcwXFx1MjA3NC1cXHUyMDc5XFx1MjA4MC1cXHUyMDg5XFx1MjE1MC1cXHUyMTgyXFx1MjE4NS1cXHUyMTg5XFx1MjQ2MC1cXHUyNDlCXFx1MjRFQS1cXHUyNEZGXFx1Mjc3Ni1cXHUyNzkzXFx1MkNGRFxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDM4LVxcdTMwM0FcXHUzMTkyLVxcdTMxOTVcXHUzMjIwLVxcdTMyMjlcXHUzMjQ4LVxcdTMyNEZcXHUzMjUxLVxcdTMyNUZcXHUzMjgwLVxcdTMyODlcXHUzMkIxLVxcdTMyQkZcXHVBNjIwLVxcdUE2MjlcXHVBNkU2LVxcdUE2RUZcXHVBODMwLVxcdUE4MzVcXHVBOEQwLVxcdUE4RDlcXHVBOTAwLVxcdUE5MDlcXHVBOUQwLVxcdUE5RDlcXHVBOUYwLVxcdUE5RjlcXHVBQTUwLVxcdUFBNTlcXHVBQkYwLVxcdUFCRjlcXHVGRjEwLVxcdUZGMTldKy9nXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuLy8gQW4gYXVnbWVudGVkIEFWTCBUcmVlIHdoZXJlIGVhY2ggbm9kZSBtYWludGFpbnMgYSBsaXN0IG9mIHJlY29yZHMgYW5kIHRoZWlyIHNlYXJjaCBpbnRlcnZhbHMuXHJcbi8vIFJlY29yZCBpcyBjb21wb3NlZCBvZiBhbiBpbnRlcnZhbCBhbmQgaXRzIHVuZGVybHlpbmcgZGF0YSwgc2VudCBieSBhIGNsaWVudC4gVGhpcyBhbGxvd3MgdGhlXHJcbi8vIGludGVydmFsIHRyZWUgdG8gaGF2ZSB0aGUgc2FtZSBpbnRlcnZhbCBpbnNlcnRlZCBtdWx0aXBsZSB0aW1lcywgYXMgbG9uZyBpdHMgZGF0YSBpcyBkaWZmZXJlbnQuXHJcbi8vIEJvdGggaW5zZXJ0aW9uIGFuZCBkZWxldGlvbiByZXF1aXJlIE8obG9nIG4pIHRpbWUuIFNlYXJjaGluZyByZXF1aXJlcyBPKGsqbG9nbikgdGltZSwgd2hlcmUgYGtgXHJcbi8vIGlzIHRoZSBudW1iZXIgb2YgaW50ZXJ2YWxzIGluIHRoZSBvdXRwdXQgbGlzdC5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaXNTYW1lID0gcmVxdWlyZShcInNoYWxsb3dlcXVhbFwiKTtcclxuZnVuY3Rpb24gaGVpZ2h0KG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbm9kZS5oZWlnaHQ7XHJcbiAgICB9XHJcbn1cclxudmFyIE5vZGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBOb2RlKGludGVydmFsVHJlZSwgcmVjb3JkKSB7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUgPSBpbnRlcnZhbFRyZWU7XHJcbiAgICAgICAgdGhpcy5yZWNvcmRzID0gW107XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMua2V5ID0gcmVjb3JkLmxvdztcclxuICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIC8vIFNhdmUgdGhlIGFycmF5IG9mIGFsbCByZWNvcmRzIHdpdGggdGhlIHNhbWUga2V5IGZvciB0aGlzIG5vZGVcclxuICAgICAgICB0aGlzLnJlY29yZHMucHVzaChyZWNvcmQpO1xyXG4gICAgfVxyXG4gICAgLy8gR2V0cyB0aGUgaGlnaGVzdCByZWNvcmQuaGlnaCB2YWx1ZSBmb3IgdGhpcyBub2RlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5nZXROb2RlSGlnaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGlnaCA9IHRoaXMucmVjb3Jkc1swXS5oaWdoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5yZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJlY29yZHNbaV0uaGlnaCA+IGhpZ2gpIHtcclxuICAgICAgICAgICAgICAgIGhpZ2ggPSB0aGlzLnJlY29yZHNbaV0uaGlnaDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGlnaDtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIGhlaWdodCB2YWx1ZSBvZiB0aGUgbm9kZS4gQ2FsbGVkIGR1cmluZyBpbnNlcnRpb24sIHJlYmFsYW5jZSwgcmVtb3ZhbFxyXG4gICAgTm9kZS5wcm90b3R5cGUudXBkYXRlSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0KHRoaXMubGVmdCksIGhlaWdodCh0aGlzLnJpZ2h0KSkgKyAxO1xyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgdGhlIG1heCB2YWx1ZSBvZiBhbGwgdGhlIHBhcmVudHMgYWZ0ZXIgaW5zZXJ0aW5nIGludG8gYWxyZWFkeSBleGlzdGluZyBub2RlLCBhcyB3ZWxsIGFzXHJcbiAgICAvLyByZW1vdmluZyB0aGUgbm9kZSBjb21wbGV0ZWx5IG9yIHJlbW92aW5nIHRoZSByZWNvcmQgb2YgYW4gYWxyZWFkeSBleGlzdGluZyBub2RlLiBTdGFydHMgd2l0aFxyXG4gICAgLy8gdGhlIHBhcmVudCBvZiBhbiBhZmZlY3RlZCBub2RlIGFuZCBidWJibGVzIHVwIHRvIHJvb3RcclxuICAgIE5vZGUucHJvdG90eXBlLnVwZGF0ZU1heE9mUGFyZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gTWF0aC5tYXgodGhpcy5sZWZ0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLnJpZ2h0Lm1heCwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzSGlnaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LnVwZGF0ZU1heE9mUGFyZW50cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTGVmdC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeVxyXG4gICAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyAgIFxcXHJcbiAgICAgICAgIHkgICBUNCAgICAgIFJpZ2h0IFJvdGF0ZSAoeikgICAgICAgICAgeCAgICAgelxyXG4gICAgICAgIC8gXFwgICAgICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAgIC8gXFwgICAvIFxcXHJcbiAgICAgICB4ICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgIC8gXFxcclxuICAgIFQxICAgVDJcclxuICBcclxuICAgIExlZnQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFwgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgICAgIHkgICBUNCAgTGVmdCBSb3RhdGUgKHkpICAgICAgICAgeCAgVDQgIFJpZ2h0IFJvdGF0ZSh6KSAgICAgeSAgICAgelxyXG4gICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtIC0+ICAgICAvIFxcICAgICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgIFQxICAgeCAgICAgICAgICAgICAgICAgICAgICAgICAgIHkgIFQzICAgICAgICAgICAgICAgICAgICAgIFQxIFQyIFQzIFQ0XHJcbiAgICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcXHJcbiAgICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgVDEgVDJcclxuICAgICovXHJcbiAgICAvLyBIYW5kbGVzIExlZnQtTGVmdCBjYXNlIGFuZCBMZWZ0LVJpZ2h0IGNhc2UgYWZ0ZXIgcmViYWxhbmNpbmcgQVZMIHRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl91cGRhdGVNYXhBZnRlclJpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgbGVmdCA9IHBhcmVudC5sZWZ0O1xyXG4gICAgICAgIC8vIFVwZGF0ZSBtYXggb2YgbGVmdCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50TGVmdEhpZ2ggPSBsZWZ0LmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKGxlZnQubGVmdCA9PT0gdW5kZWZpbmVkICYmIGxlZnQucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KHRoaXNQYXJlbnRMZWZ0SGlnaCwgbGVmdC5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgIT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSBNYXRoLm1heCh0aGlzUGFyZW50TGVmdEhpZ2gsIGxlZnQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsZWZ0LmxlZnQgPT09IHVuZGVmaW5lZCAmJiBsZWZ0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdC5tYXggPSB0aGlzUGFyZW50TGVmdEhpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KGxlZnQubGVmdC5tYXgsIGxlZnQucmlnaHQubWF4KSwgdGhpc1BhcmVudExlZnRIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBpdHNlbGYgKHopXHJcbiAgICAgICAgdmFyIHRoaXNIaWdoID0gdGhpcy5nZXROb2RlSGlnaCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmxlZnQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5yaWdodC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzSGlnaCwgdGhpcy5sZWZ0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHRoaXNIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5tYXggPSBNYXRoLm1heChNYXRoLm1heCh0aGlzLmxlZnQubWF4LCB0aGlzLnJpZ2h0Lm1heCksIHRoaXNIaWdoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiBwYXJlbnQgKHkgaW4gZmlyc3QgY2FzZSwgeCBpbiBzZWNvbmQpXHJcbiAgICAgICAgcGFyZW50Lm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHBhcmVudC5sZWZ0Lm1heCwgcGFyZW50LnJpZ2h0Lm1heCksIHBhcmVudC5nZXROb2RlSGlnaCgpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmlnaHQtUmlnaHQgY2FzZTpcclxuICBcclxuICAgICAgeiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5XHJcbiAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAvICAgXFxcclxuICAgIFQxICB5ICAgICBMZWZ0IFJvdGF0ZSh6KSAgICAgICB6ICAgICB4XHJcbiAgICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgICAgLyBcXCAgIC8gXFxcclxuICAgICAgVDIgIHggICAgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgICAgLyBcXFxyXG4gICAgICAgIFQzIFQ0XHJcbiAgXHJcbiAgICBSaWdodC1MZWZ0IGNhc2U6XHJcbiAgXHJcbiAgICAgICB6ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHogICAgICAgICAgICAgICAgICAgICAgICAgICAgeFxyXG4gICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgICAvIFxcICAgICAgICAgICAgICAgICAgICAgICAgIC8gICBcXFxyXG4gICAgIFQxICB5ICAgUmlnaHQgUm90YXRlICh5KSAgICAgVDEgIHggICAgICBMZWZ0IFJvdGF0ZSh6KSAgIHogICAgIHlcclxuICAgICAgICAvIFxcICAtIC0gLSAtIC0gLSAtIC0gLT4gICAgICAvIFxcICAgLSAtIC0gLSAtIC0gLSAtPiAgLyBcXCAgIC8gXFxcclxuICAgICAgIHggIFQ0ICAgICAgICAgICAgICAgICAgICAgICAgVDIgIHkgICAgICAgICAgICAgICAgICAgVDEgVDIgVDMgVDRcclxuICAgICAgLyBcXCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8gXFxcclxuICAgIFQyICAgVDMgICAgICAgICAgICAgICAgICAgICAgICAgICBUMyBUNFxyXG4gICAgKi9cclxuICAgIC8vIEhhbmRsZXMgUmlnaHQtUmlnaHQgY2FzZSBhbmQgUmlnaHQtTGVmdCBjYXNlIGluIHJlYmFsYW5jaW5nIEFWTCB0cmVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5fdXBkYXRlTWF4QWZ0ZXJMZWZ0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB2YXIgcmlnaHQgPSBwYXJlbnQucmlnaHQ7XHJcbiAgICAgICAgLy8gVXBkYXRlIG1heCBvZiByaWdodCBzaWJsaW5nICh4IGluIGZpcnN0IGNhc2UsIHkgaW4gc2Vjb25kKVxyXG4gICAgICAgIHZhciB0aGlzUGFyZW50UmlnaHRIaWdoID0gcmlnaHQuZ2V0Tm9kZUhpZ2goKTtcclxuICAgICAgICBpZiAocmlnaHQubGVmdCA9PT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQucmlnaHQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmlnaHQubGVmdCAhPT0gdW5kZWZpbmVkICYmIHJpZ2h0LnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgodGhpc1BhcmVudFJpZ2h0SGlnaCwgcmlnaHQubGVmdC5tYXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChyaWdodC5sZWZ0ID09PSB1bmRlZmluZWQgJiYgcmlnaHQucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodC5tYXggPSB0aGlzUGFyZW50UmlnaHRIaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmlnaHQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocmlnaHQubGVmdC5tYXgsIHJpZ2h0LnJpZ2h0Lm1heCksIHRoaXNQYXJlbnRSaWdodEhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIGl0c2VsZiAoeilcclxuICAgICAgICB2YXIgdGhpc0hpZ2ggPSB0aGlzLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLnJpZ2h0Lm1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmlnaHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KHRoaXNIaWdoLCB0aGlzLmxlZnQubWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpc0hpZ2g7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KE1hdGgubWF4KHRoaXMubGVmdC5tYXgsIHRoaXMucmlnaHQubWF4KSwgdGhpc0hpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHBhcmVudCAoeSBpbiBmaXJzdCBjYXNlLCB4IGluIHNlY29uZClcclxuICAgICAgICBwYXJlbnQubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgocGFyZW50LmxlZnQubWF4LCByaWdodC5tYXgpLCBwYXJlbnQuZ2V0Tm9kZUhpZ2goKSk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX2xlZnRSb3RhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJpZ2h0Q2hpbGQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKHJpZ2h0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAocmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9PT0gdGhpcykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDaGlsZC5wYXJlbnQubGVmdCA9IHJpZ2h0Q2hpbGQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRDaGlsZC5wYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q2hpbGQucGFyZW50LnJpZ2h0ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHRDaGlsZC5sZWZ0O1xyXG4gICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5yaWdodC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByaWdodENoaWxkLmxlZnQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucGFyZW50ID0gcmlnaHRDaGlsZDtcclxuICAgICAgICB0aGlzLnVwZGF0ZUhlaWdodCgpO1xyXG4gICAgICAgIHJpZ2h0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgTm9kZS5wcm90b3R5cGUuX3JpZ2h0Um90YXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsZWZ0Q2hpbGQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgbGVmdENoaWxkLnBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbFRyZWUucm9vdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0Q2hpbGQucGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDaGlsZC5wYXJlbnQubGVmdCA9IGxlZnRDaGlsZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q2hpbGQucGFyZW50LnJpZ2h0ID0gbGVmdENoaWxkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnRDaGlsZC5yaWdodDtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0LnBhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxlZnRDaGlsZC5yaWdodCA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBsZWZ0Q2hpbGQ7XHJcbiAgICAgICAgdGhpcy51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICBsZWZ0Q2hpbGQudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmViYWxhbmNlcyB0aGUgdHJlZSBpZiB0aGUgaGVpZ2h0IHZhbHVlIGJldHdlZW4gdHdvIG5vZGVzIG9mIHRoZSBzYW1lIHBhcmVudCBpcyBncmVhdGVyIHRoYW5cclxuICAgIC8vIHR3by4gVGhlcmUgYXJlIDQgY2FzZXMgdGhhdCBjYW4gaGFwcGVuIHdoaWNoIGFyZSBvdXRsaW5lZCBpbiB0aGUgZ3JhcGhpY3MgYWJvdmVcclxuICAgIE5vZGUucHJvdG90eXBlLl9yZWJhbGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGhlaWdodCh0aGlzLmxlZnQpID49IDIgKyBoZWlnaHQodGhpcy5yaWdodCkpIHtcclxuICAgICAgICAgICAgdmFyIGxlZnQgPSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgIGlmIChoZWlnaHQobGVmdC5sZWZ0KSA+PSBoZWlnaHQobGVmdC5yaWdodCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIExlZnQtTGVmdCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gTGVmdC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICBsZWZ0Ll9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlTWF4QWZ0ZXJSaWdodFJvdGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGhlaWdodCh0aGlzLnJpZ2h0KSA+PSAyICsgaGVpZ2h0KHRoaXMubGVmdCkpIHtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgaWYgKGhlaWdodChyaWdodC5yaWdodCkgPj0gaGVpZ2h0KHJpZ2h0LmxlZnQpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSaWdodC1SaWdodCBjYXNlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFJpZ2h0LUxlZnQgY2FzZVxyXG4gICAgICAgICAgICAgICAgcmlnaHQuX3JpZ2h0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWZ0Um90YXRlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVNYXhBZnRlckxlZnRSb3RhdGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAocmVjb3JkKSB7XHJcbiAgICAgICAgaWYgKHJlY29yZC5sb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byBsZWZ0IHN1YnRyZWVcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxlZnQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubGVmdC5wYXJlbnQgPSB0aGlzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sZWZ0Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgaW50byByaWdodCBzdWJ0cmVlXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPSBuZXcgTm9kZSh0aGlzLmludGVydmFsVHJlZSwgcmVjb3JkKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQuaW5zZXJ0KHJlY29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBtYXggdmFsdWUgb2YgdGhpcyBhbmNlc3RvciBpZiBuZWVkZWRcclxuICAgICAgICBpZiAodGhpcy5tYXggPCByZWNvcmQuaGlnaCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heCA9IHJlY29yZC5oaWdoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgaGVpZ2h0IG9mIGVhY2ggbm9kZVxyXG4gICAgICAgIHRoaXMudXBkYXRlSGVpZ2h0KCk7XHJcbiAgICAgICAgLy8gUmViYWxhbmNlIHRoZSB0cmVlIHRvIGVuc3VyZSBhbGwgb3BlcmF0aW9ucyBhcmUgZXhlY3V0ZWQgaW4gTyhsb2duKSB0aW1lLiBUaGlzIGlzIGVzcGVjaWFsbHlcclxuICAgICAgICAvLyBpbXBvcnRhbnQgaW4gc2VhcmNoaW5nLCBhcyB0aGUgdHJlZSBoYXMgYSBoaWdoIGNoYW5jZSBvZiBkZWdlbmVyYXRpbmcgd2l0aG91dCB0aGUgcmViYWxhbmNpbmdcclxuICAgICAgICB0aGlzLl9yZWJhbGFuY2UoKTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5fZ2V0T3ZlcmxhcHBpbmdSZWNvcmRzID0gZnVuY3Rpb24gKGN1cnJlbnROb2RlLCBsb3csIGhpZ2gpIHtcclxuICAgICAgICBpZiAoY3VycmVudE5vZGUua2V5IDw9IGhpZ2ggJiYgbG93IDw9IGN1cnJlbnROb2RlLmdldE5vZGVIaWdoKCkpIHtcclxuICAgICAgICAgICAgLy8gTm9kZXMgYXJlIG92ZXJsYXBwaW5nLCBjaGVjayBpZiBpbmRpdmlkdWFsIHJlY29yZHMgaW4gdGhlIG5vZGUgYXJlIG92ZXJsYXBwaW5nXHJcbiAgICAgICAgICAgIHZhciB0ZW1wUmVzdWx0cyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGN1cnJlbnROb2RlLnJlY29yZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldLmhpZ2ggPj0gbG93KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcFJlc3VsdHMucHVzaChjdXJyZW50Tm9kZS5yZWNvcmRzW2ldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGVtcFJlc3VsdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgLy8gRG9uJ3Qgc2VhcmNoIG5vZGVzIHRoYXQgZG9uJ3QgZXhpc3RcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlZnRTZWFyY2ggPSBbXTtcclxuICAgICAgICB2YXIgb3duU2VhcmNoID0gW107XHJcbiAgICAgICAgdmFyIHJpZ2h0U2VhcmNoID0gW107XHJcbiAgICAgICAgLy8gSWYgaW50ZXJ2YWwgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoZSByaWdodG1vc3QgcG9pbnQgb2YgYW55IGludGVydmFsIGluIHRoaXMgbm9kZSBhbmQgYWxsIGl0c1xyXG4gICAgICAgIC8vIGNoaWxkcmVuLCB0aGVyZSB3b24ndCBiZSBhbnkgbWF0Y2hlc1xyXG4gICAgICAgIGlmIChsb3cgPiB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNlYXJjaCBsZWZ0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMubGVmdCAhPT0gdW5kZWZpbmVkICYmIHRoaXMubGVmdC5tYXggPj0gbG93KSB7XHJcbiAgICAgICAgICAgIGxlZnRTZWFyY2ggPSB0aGlzLmxlZnQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENoZWNrIHRoaXMgbm9kZVxyXG4gICAgICAgIG93blNlYXJjaCA9IHRoaXMuX2dldE92ZXJsYXBwaW5nUmVjb3Jkcyh0aGlzLCBsb3csIGhpZ2gpO1xyXG4gICAgICAgIC8vIElmIGludGVydmFsIGlzIHRvIHRoZSBsZWZ0IG9mIHRoZSBzdGFydCBvZiB0aGlzIGludGVydmFsLCB0aGVuIGl0IGNhbid0IGJlIGluIGFueSBjaGlsZCB0b1xyXG4gICAgICAgIC8vIHRoZSByaWdodFxyXG4gICAgICAgIGlmIChoaWdoIDwgdGhpcy5rZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGxlZnRTZWFyY2guY29uY2F0KG93blNlYXJjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgc2VhcmNoIHJpZ2h0IGNoaWxkcmVuXHJcbiAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByaWdodFNlYXJjaCA9IHRoaXMucmlnaHQuc2VhcmNoKGxvdywgaGlnaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJldHVybiBhY2N1bXVsYXRlZCByZXN1bHRzLCBpZiBhbnlcclxuICAgICAgICByZXR1cm4gbGVmdFNlYXJjaC5jb25jYXQob3duU2VhcmNoLCByaWdodFNlYXJjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2VhcmNoZXMgZm9yIGEgbm9kZSBieSBhIGBrZXlgIHZhbHVlXHJcbiAgICBOb2RlLnByb3RvdHlwZS5zZWFyY2hFeGlzdGluZyA9IGZ1bmN0aW9uIChsb3cpIHtcclxuICAgICAgICBpZiAodGhpcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmtleSA9PT0gbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsb3cgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHQuc2VhcmNoRXhpc3RpbmcobG93KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgdGhlIHNtYWxsZXN0IG5vZGUgb2YgdGhlIHN1YnRyZWVcclxuICAgIE5vZGUucHJvdG90eXBlLl9taW5WYWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5sZWZ0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZWZ0Ll9taW5WYWx1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBOb2RlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAobm9kZS5rZXkgPCB0aGlzLmtleSkge1xyXG4gICAgICAgICAgICAvLyBOb2RlIHRvIGJlIHJlbW92ZWQgaXMgb24gdGhlIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChub2RlLmtleSA+IHRoaXMua2V5KSB7XHJcbiAgICAgICAgICAgIC8vIE5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBvbiB0aGUgcmlnaHQgc2lkZVxyXG4gICAgICAgICAgICBpZiAodGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgdGhpcy5yaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIGhhcyB0d28gY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIHZhciBtaW5WYWx1ZSA9IHRoaXMucmlnaHQuX21pblZhbHVlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmtleSA9IG1pblZhbHVlLmtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3JkcyA9IG1pblZhbHVlLnJlY29yZHM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yaWdodC5yZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocGFyZW50LmxlZnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIGxlZnQgc2lkZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0LnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5sZWZ0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChwYXJlbnQucmlnaHQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgICAgIC8vIE9uZSBjaGlsZCBvciBubyBjaGlsZCBjYXNlIG9uIHJpZ2h0IHNpZGVcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQucmlnaHQgPSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmlnaHQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50LnJpZ2h0ID0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnQucGFyZW50ID0gcGFyZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC51cGRhdGVIZWlnaHQoKTtcclxuICAgICAgICAgICAgICAgIHBhcmVudC5fcmViYWxhbmNlKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTm9kZTtcclxufSgpKTtcclxuZXhwb3J0cy5Ob2RlID0gTm9kZTtcclxudmFyIEludGVydmFsVHJlZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLmNvdW50ID0gMDtcclxuICAgIH1cclxuICAgIEludGVydmFsVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gKHJlY29yZCkge1xyXG4gICAgICAgIGlmIChyZWNvcmQubG93ID4gcmVjb3JkLmhpZ2gpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdgbG93YCB2YWx1ZSBtdXN0IGJlIGxvd2VyIG9yIGVxdWFsIHRvIGBoaWdoYCB2YWx1ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gQmFzZSBjYXNlOiBUcmVlIGlzIGVtcHR5LCBuZXcgbm9kZSBiZWNvbWVzIHJvb3RcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbmV3IE5vZGUodGhpcywgcmVjb3JkKTtcclxuICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY2hlY2sgaWYgbm9kZSBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoZSBzYW1lIGtleVxyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucm9vdC5zZWFyY2hFeGlzdGluZyhyZWNvcmQubG93KTtcclxuICAgICAgICAgICAgaWYgKG5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJlY29yZHMgaW4gdGhpcyBub2RlIGlmIHRoZXJlIGFscmVhZHkgaXMgdGhlIG9uZSB3aXRoIHNhbWUgbG93LCBoaWdoLCBkYXRhXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgcmVjb3JkIGlzIHNhbWUgYXMgdGhlIG9uZSB3ZSdyZSB0cnlpbmcgdG8gaW5zZXJ0OyByZXR1cm4gZmFsc2UgdG8gaW5kaWNhdGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm90aGluZyBoYXMgYmVlbiBpbnNlcnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSByZWNvcmQgdG8gdGhlIG5vZGVcclxuICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5wdXNoKHJlY29yZCk7XHJcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoZSBub2RlIGFuZCBpdHMgcGFyZW50cyBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuaGlnaCA+IG5vZGUubWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXggPSByZWNvcmQuaGlnaDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQudXBkYXRlTWF4T2ZQYXJlbnRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgZG9lc24ndCBhbHJlYWR5IGV4aXN0LiBDYWxsIGluc2VydCBmdW5jdGlvbiBvbiByb290J3Mgbm9kZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290Lmluc2VydChyZWNvcmQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb3VudCsrO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFRyZWUgaXMgZW1wdHk7IHJldHVybiBlbXB0eSBhcnJheVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNlYXJjaChsb3csIGhpZ2gpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChyZWNvcmQpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgLy8gVHJlZSBpcyBlbXB0eTsgbm90aGluZyB0byByZW1vdmVcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnJvb3Quc2VhcmNoRXhpc3RpbmcocmVjb3JkLmxvdyk7XHJcbiAgICAgICAgICAgIGlmIChub2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLnJlY29yZHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlbW92ZWRSZWNvcmQgPSB2b2lkIDA7XHJcbiAgICAgICAgICAgICAgICAvLyBOb2RlIHdpdGggdGhpcyBrZXkgaGFzIDIgb3IgbW9yZSByZWNvcmRzLiBGaW5kIHRoZSBvbmUgd2UgbmVlZCBhbmQgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUucmVjb3Jkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzW2ldLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWRSZWNvcmQgPSBub2RlLnJlY29yZHNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVjb3Jkcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZW1vdmVkUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZFJlY29yZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbWF4IG9mIHRoYXQgbm9kZSBhbmQgaXRzIHBhcmVudHMgaWYgbmVjZXNzYXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5oaWdoID09PSBub2RlLm1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZUhpZ2ggPSBub2RlLmdldE5vZGVIaWdoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmxlZnQgIT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgoTWF0aC5tYXgobm9kZS5sZWZ0Lm1heCwgbm9kZS5yaWdodC5tYXgpLCBub2RlSGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5sZWZ0ICE9PSB1bmRlZmluZWQgJiYgbm9kZS5yaWdodCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1heCA9IE1hdGgubWF4KG5vZGUubGVmdC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmxlZnQgPT09IHVuZGVmaW5lZCAmJiBub2RlLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gTWF0aC5tYXgobm9kZS5yaWdodC5tYXgsIG5vZGVIaWdoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUubWF4ID0gbm9kZUhpZ2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudC51cGRhdGVNYXhPZlBhcmVudHMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5yZWNvcmRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTm9kZSB3aXRoIHRoaXMga2V5IGhhcyBvbmx5IDEgcmVjb3JkLiBDaGVjayBpZiB0aGUgcmVtYWluaW5nIHJlY29yZCBpbiB0aGlzIG5vZGUgaXNcclxuICAgICAgICAgICAgICAgIC8vIGFjdHVhbGx5IHRoZSBvbmUgd2Ugd2FudCB0byByZW1vdmVcclxuICAgICAgICAgICAgICAgIGlmIChpc1NhbWUobm9kZS5yZWNvcmRzWzBdLCByZWNvcmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyByZWNvcmQgaXMgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZS4gUmVtb3ZlIHRoZSB3aG9sZSBub2RlIGZyb20gdGhlIHRyZWVcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290LmtleSA9PT0gbm9kZS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgcmVtb3ZpbmcgdGhlIHJvb3QgZWxlbWVudC4gQ3JlYXRlIGEgZHVtbXkgbm9kZSB0aGF0IHdpbGwgdGVtcG9yYXJpbHkgdGFrZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByb290J3MgcGFyZW50IHJvbGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RQYXJlbnQgPSBuZXcgTm9kZSh0aGlzLCB7IGxvdzogcmVjb3JkLmxvdywgaGlnaDogcmVjb3JkLmxvdyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcm9vdFBhcmVudC5sZWZ0ID0gdGhpcy5yb290O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QucGFyZW50ID0gcm9vdFBhcmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbW92ZWROb2RlID0gdGhpcy5yb290LnJlbW92ZShub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290ID0gcm9vdFBhcmVudC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yb290ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlZE5vZGUgPSB0aGlzLnJvb3QucmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlZE5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWROb2RlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVtYWluaW5nIHJlY29yZCBpcyBub3QgdGhlIG9uZSB3ZSB3YW50IHRvIHJlbW92ZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIE5vIHJlY29yZHMgYXQgYWxsIGluIHRoaXMgbm9kZT8hIFNob3VsZG4ndCBoYXBwZW5cclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbnRlcnZhbFRyZWUucHJvdG90eXBlLmluT3JkZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBJbk9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByZU9yZGVyKHRoaXMucm9vdCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEludGVydmFsVHJlZTtcclxufSgpKTtcclxuZXhwb3J0cy5JbnRlcnZhbFRyZWUgPSBJbnRlcnZhbFRyZWU7XHJcbnZhciBEYXRhSW50ZXJ2YWxUcmVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRGF0YUludGVydmFsVHJlZSgpIHtcclxuICAgICAgICB0aGlzLnRyZWUgPSBuZXcgSW50ZXJ2YWxUcmVlKCk7XHJcbiAgICB9XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5pbnNlcnQoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAobG93LCBoaWdoLCBkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5yZW1vdmUoeyBsb3c6IGxvdywgaGlnaDogaGlnaCwgZGF0YTogZGF0YSB9KTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5zZWFyY2ggPSBmdW5jdGlvbiAobG93LCBoaWdoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5zZWFyY2gobG93LCBoaWdoKS5tYXAoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYuZGF0YTsgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0YUludGVydmFsVHJlZS5wcm90b3R5cGUuaW5PcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLmluT3JkZXIoKTtcclxuICAgIH07XHJcbiAgICBEYXRhSW50ZXJ2YWxUcmVlLnByb3RvdHlwZS5wcmVPcmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmVlLnByZU9yZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERhdGFJbnRlcnZhbFRyZWUucHJvdG90eXBlLCBcImNvdW50XCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZS5jb3VudDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEYXRhSW50ZXJ2YWxUcmVlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXRhSW50ZXJ2YWxUcmVlO1xyXG52YXIgSW5PcmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEluT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIGlmIChzdGFydE5vZGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2goc3RhcnROb2RlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWRcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNaWdodCBwb3AgdGhlIGxhc3QgYW5kIHNldCB0aGlzLmN1cnJlbnROb2RlID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcclxuICAgIH07XHJcbiAgICBJbk9yZGVyLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG5vZGUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gbm9kZTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5jdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLmN1cnJlbnROb2RlLmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEluT3JkZXIucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnROb2RlID0gdGhpcy5zdGFjay5wb3AoKTtcclxuICAgICAgICB0aGlzLmkgPSAwO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbk9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLkluT3JkZXIgPSBJbk9yZGVyO1xyXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgSW5PcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxudmFyIFByZU9yZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gUHJlT3JkZXIoc3RhcnROb2RlKSB7XHJcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IHN0YXJ0Tm9kZTtcclxuICAgIH1cclxuICAgIFByZU9yZGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIFdpbGwgb25seSBoYXBwZW4gaWYgc3RhY2sgaXMgZW1wdHkgYW5kIHBvcCBpcyBjYWxsZWQsXHJcbiAgICAgICAgLy8gd2hpY2ggb25seSBoYXBwZW5zIGlmIHRoZXJlIGlzIG5vIHJpZ2h0IG5vZGUgKGkuZSB3ZSBhcmUgZG9uZSlcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50Tm9kZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkb25lOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUHJvY2VzcyB0aGlzIG5vZGVcclxuICAgICAgICBpZiAodGhpcy5pIDwgdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgZG9uZTogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5jdXJyZW50Tm9kZS5yZWNvcmRzW3RoaXMuaSsrXSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE5vZGUucmlnaHQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnROb2RlLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnB1c2godGhpcy5jdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3AoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCk7XHJcbiAgICB9O1xyXG4gICAgUHJlT3JkZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAobm9kZSkge1xyXG4gICAgICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcclxuICAgIH07XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudE5vZGUgPSB0aGlzLnN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHRoaXMuaSA9IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFByZU9yZGVyO1xyXG59KCkpO1xyXG5leHBvcnRzLlByZU9yZGVyID0gUHJlT3JkZXI7XHJcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICBQcmVPcmRlci5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpXG5cbi8qKlxuICogTm9GaWx0ZXIgc3RyZWFtLiAgQ2FuIGJlIHVzZWQgdG8gc2luayBvciBzb3VyY2UgZGF0YSB0byBhbmQgZnJvbVxuICogb3RoZXIgbm9kZSBzdHJlYW1zLiAgSW1wbGVtZW50ZWQgYXMgdGhlIFwiaWRlbnRpdHlcIiBUcmFuc2Zvcm0gc3RyZWFtXG4gKiAoaGVuY2UgdGhlIG5hbWUpLCBidXQgYWxsb3dzIGZvciBpbnNwZWN0aW5nIGRhdGEgdGhhdCBpcyBpbi1mbGlnaHQuXG4gKlxuICogQWxsb3dzIHBhc3NpbmcgaW4gc291cmNlIGRhdGEgKGlucHV0LCBpbnB1dEVuY29kaW5nKSBhdCBjcmVhdGlvblxuICogdGltZS4gIFNvdXJjZSBkYXRhIGNhbiBhbHNvIGJlIHBhc3NlZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QuXG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+c291cmNlPC9jYXB0aW9uPlxuICogY29uc3QgbiA9IG5ldyBOb0ZpbHRlcignWm05dicsICdiYXNlNjQnKTtcbiAqIG4ucGlwZShwcm9jZXNzLnN0ZG91dCk7XG4gKlxuICogQGV4YW1wbGUgPGNhcHRpb24+c2luazwvY2FwdGlvbj5cbiAqIGNvbnN0IG4gPSBuZXcgTm9maWx0ZXIoKTtcbiAqIC8vIE5PVEU6ICdmaW5pc2gnIGZpcmVzIHdoZW4gdGhlIGlucHV0IGlzIGRvbmUgd3JpdGluZ1xuICogbi5vbignZmluaXNoJywgZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nKG4udG9TdHJpbmcoJ2Jhc2U2NCcpKTsgfSk7XG4gKiBwcm9jZXNzLnN0ZGluLnBpcGUobik7XG4gKi9cbmNsYXNzIE5vRmlsdGVyIGV4dGVuZHMgc3RyZWFtLlRyYW5zZm9ybSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgTm9GaWx0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gW2lucHV0XSAtIFNvdXJjZSBkYXRhXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXRFbmNvZGluZz1udWxsXSAtIEVuY29kaW5nIG5hbWUgZm9yIGlucHV0LFxuICAgKiAgIGlnbm9yZWQgaWYgaW5wdXQgaXMgbm90IGEgU3RyaW5nXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPdGhlciBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gW29wdGlvbnMuaW5wdXQ9bnVsbF0gLSBJbnB1dCBzb3VyY2UgZGF0YVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaW5wdXRFbmNvZGluZz1udWxsXSAtIEVuY29kaW5nIG5hbWUgZm9yIGlucHV0LFxuICAgKiAgIGlnbm9yZWQgaWYgaW5wdXQgaXMgbm90IGEgU3RyaW5nXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5oaWdoV2F0ZXJNYXJrPTE2Mzg0XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBieXRlc1xuICAgKiAgIHRvIHN0b3JlIGluIHRoZSBpbnRlcm5hbCBidWZmZXIgYmVmb3JlIGNlYXNpbmcgdG8gcmVhZCBmcm9tIHRoZVxuICAgKiAgIHVuZGVybHlpbmcgcmVzb3VyY2UuIERlZmF1bHQ9MTZrYiwgb3IgMTYgZm9yIG9iamVjdE1vZGUgc3RyZWFtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZW5jb2Rpbmc9bnVsbF0gLSBJZiBzcGVjaWZpZWQsIHRoZW4gYnVmZmVycyB3aWxsXG4gICAqICAgYmUgZGVjb2RlZCB0byBzdHJpbmdzIHVzaW5nIHRoZSBzcGVjaWZpZWQgZW5jb2RpbmdcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5vYmplY3RNb2RlPWZhbHNlXSAtIFdoZXRoZXIgdGhpcyBzdHJlYW0gc2hvdWxkXG4gICAqICAgYmVoYXZlIGFzIGEgc3RyZWFtIG9mIG9iamVjdHMuIE1lYW5pbmcgdGhhdCBzdHJlYW0ucmVhZChuKSByZXR1cm5zIGFcbiAgICogICBzaW5nbGUgdmFsdWUgaW5zdGVhZCBvZiBhIEJ1ZmZlciBvZiBzaXplIG5cbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5kZWNvZGVTdHJpbmdzPXRydWVdIC0gV2hldGhlciBvciBub3QgdG8gZGVjb2RlXG4gICAqICAgc3RyaW5ncyBpbnRvIEJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdGhlbSB0byBfd3JpdGUoKVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLndhdGNoUGlwZT10cnVlXSAtIFdoZXRoZXIgdG8gd2F0Y2ggZm9yICdwaXBlJ1xuICAgKiAgIGV2ZW50cywgc2V0dGluZyB0aGlzIHN0cmVhbSdzIG9iamVjdE1vZGUgYmFzZWQgb24gdGhlIG9iamVjdE1vZGUgb2YgdGhlXG4gICAqICAgaW5wdXQgc3RyZWFtXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVhZEVycm9yPWZhbHNlXSAtIElmIHRydWUsIHdoZW4gYSByZWFkKClcbiAgICogICB1bmRlcmZsb3dzLCB0aHJvdyBhbiBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGlucHV0LCBpbnB1dEVuY29kaW5nLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICAgIGxldCBpbnBcbiAgICBsZXQgaW5wRVxuICAgIHN3aXRjaCAodHlwZW9mKGlucHV0KSkge1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihpbnB1dCkpIHtcbiAgICAgICAgICBpbnAgPSBpbnB1dFxuICAgICAgICAgIGlmICgoaW5wdXRFbmNvZGluZyAhPSBudWxsKSAmJiAodHlwZW9mKGlucHV0RW5jb2RpbmcpID09PSAnb2JqZWN0JykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBpbnB1dEVuY29kaW5nXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wdGlvbnMgPSBpbnB1dFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBpbnAgPSBpbnB1dFxuICAgICAgICBpZiAoKGlucHV0RW5jb2RpbmcgIT0gbnVsbCkgJiYgKHR5cGVvZihpbnB1dEVuY29kaW5nKSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgb3B0aW9ucyA9IGlucHV0RW5jb2RpbmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnBFID0gaW5wdXRFbmNvZGluZ1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuXG4gICAgaWYgKChvcHRpb25zID09IG51bGwpKSB7XG4gICAgICBvcHRpb25zID0ge31cbiAgICB9XG4gICAgaWYgKGlucCA9PSBudWxsKSB7XG4gICAgICBpbnAgPSBvcHRpb25zLmlucHV0XG4gICAgfVxuICAgIGlmIChpbnBFID09IG51bGwpIHtcbiAgICAgIGlucEUgPSBvcHRpb25zLmlucHV0RW5jb2RpbmdcbiAgICB9XG4gICAgZGVsZXRlIG9wdGlvbnMuaW5wdXRcbiAgICBkZWxldGUgb3B0aW9ucy5pbnB1dEVuY29kaW5nXG4gICAgY29uc3Qgd2F0Y2hQaXBlID0gb3B0aW9ucy53YXRjaFBpcGUgIT0gbnVsbCA/IG9wdGlvbnMud2F0Y2hQaXBlIDogdHJ1ZVxuICAgIGRlbGV0ZSBvcHRpb25zLndhdGNoUGlwZVxuICAgIGNvbnN0IHJlYWRFcnJvciA9ICEhIG9wdGlvbnMucmVhZEVycm9yXG4gICAgZGVsZXRlIG9wdGlvbnMucmVhZEVycm9yXG4gICAgc3VwZXIob3B0aW9ucylcblxuICAgIHRoaXMucmVhZEVycm9yID0gcmVhZEVycm9yXG5cbiAgICBpZiAod2F0Y2hQaXBlKSB7XG4gICAgICB0aGlzLm9uKCdwaXBlJywgcmVhZGFibGUgPT4ge1xuICAgICAgICBjb25zdCBvbSA9IHJlYWRhYmxlLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGVcbiAgICAgICAgaWYgKCh0aGlzLmxlbmd0aCA+IDApICYmIChvbSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdEbyBub3Qgc3dpdGNoIG9iamVjdE1vZGUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgc3RyZWFtJylcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSA9IG9tXG4gICAgICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLm9iamVjdE1vZGUgPSBvbVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAoaW5wICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZW5kKGlucCwgaW5wRSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGdpdmVuIG9iamVjdCBhIHtOb0ZpbHRlcn0/XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byB0ZXN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBvYmogaXMgYSBOb0ZpbHRlclxuICAgKi9cbiAgc3RhdGljIGlzTm9GaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHRoaXNcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc2FtZSBhcyBuZjEuY29tcGFyZShuZjIpLiBVc2VmdWwgZm9yIHNvcnRpbmcgYW4gQXJyYXkgb2YgTm9GaWx0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge05vRmlsdGVyfSBuZjEgLSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmVcbiAgICogQHBhcmFtIHtOb0ZpbHRlcn0gbmYyIC0gVGhlIHNlY29uZCBvYmplY3QgdG8gY29tcGFyZVxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtMSwgMCwgMSBmb3IgbGVzcywgZXF1YWwsIGdyZWF0ZXJcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgYXJyID0gW25ldyBOb0ZpbHRlcignMTIzNCcpLCBuZXcgTm9GaWx0ZXIoJzAxMjMnKV07XG4gICAqIGFyci5zb3J0KE5vRmlsdGVyLmNvbXBhcmUpO1xuICAgKi9cbiAgc3RhdGljIGNvbXBhcmUobmYxLCBuZjIpIHtcbiAgICBpZiAoIShuZjEgaW5zdGFuY2VvZiB0aGlzKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgTm9GaWx0ZXJzJylcbiAgICB9XG4gICAgaWYgKG5mMSA9PT0gbmYyKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmYxLmNvbXBhcmUobmYyKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgYnVmZmVyIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyBhbGwgdGhlXG4gICAqIE5vRmlsdGVycyBpbiB0aGUgbGlzdCB0b2dldGhlci4gSWYgdGhlIGxpc3QgaGFzIG5vIGl0ZW1zLCBvciBpZlxuICAgKiB0aGUgdG90YWxMZW5ndGggaXMgMCwgdGhlbiBpdCByZXR1cm5zIGEgemVyby1sZW5ndGggYnVmZmVyLlxuICAgKlxuICAgKiBJZiBsZW5ndGggaXMgbm90IHByb3ZpZGVkLCBpdCBpcyByZWFkIGZyb20gdGhlIGJ1ZmZlcnMgaW4gdGhlXG4gICAqIGxpc3QuIEhvd2V2ZXIsIHRoaXMgYWRkcyBhbiBhZGRpdGlvbmFsIGxvb3AgdG8gdGhlIGZ1bmN0aW9uLCBzb1xuICAgKiBpdCBpcyBmYXN0ZXIgdG8gcHJvdmlkZSB0aGUgbGVuZ3RoIGV4cGxpY2l0bHkgaWYgeW91IGFscmVhZHkga25vdyBpdC5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxOb0ZpbHRlcj59IGxpc3QgSW5wdXRzLiAgTXVzdCBub3QgYmUgYWxsIGVpdGhlciBpbiBvYmplY3RcbiAgICogICBtb2RlLCBvciBhbGwgbm90IGluIG9iamVjdCBtb2RlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1udWxsXSBOdW1iZXIgb2YgYnl0ZXMgb3Igb2JqZWN0cyB0byByZWFkXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ8QXJyYXl9IFRoZSBjb25jYXRlbmF0ZWQgdmFsdWVzIGFzIGFuIGFycmF5IGlmIGluIG9iamVjdFxuICAgKiAgIG1vZGUsIG90aGVyd2lzZSBhIEJ1ZmZlclxuICAgKi9cbiAgc3RhdGljIGNvbmNhdChsaXN0LCBsZW5ndGgpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xpc3QgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBOb0ZpbHRlcnMnKVxuICAgIH1cbiAgICBpZiAoKGxpc3QubGVuZ3RoID09PSAwKSB8fCAobGVuZ3RoID09PSAwKSkge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICAgIH1cbiAgICBpZiAoKGxlbmd0aCA9PSBudWxsKSkge1xuICAgICAgbGVuZ3RoID0gbGlzdC5yZWR1Y2UoKHRvdCwgbmYpID0+IHtcbiAgICAgICAgaWYgKCEobmYgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsaXN0IGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgTm9GaWx0ZXJzJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90ICsgbmYubGVuZ3RoXG4gICAgICB9LCAwKVxuICAgIH1cbiAgICBsZXQgYWxsQnVmcyA9IHRydWVcbiAgICBsZXQgYWxsT2JqcyA9IHRydWVcbiAgICBjb25zdCBidWZzID0gbGlzdC5tYXAobmYgPT4ge1xuICAgICAgaWYgKCEobmYgaW5zdGFuY2VvZiBOb0ZpbHRlcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGlzdCBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIE5vRmlsdGVycycpXG4gICAgICB9XG4gICAgICBjb25zdCBidWYgPSBuZi5zbGljZSgpXG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgICAgYWxsT2JqcyA9IGZhbHNlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhbGxCdWZzID0gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBidWZcbiAgICB9KVxuICAgIGlmIChhbGxCdWZzKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChidWZzLCBsZW5ndGgpXG4gICAgfVxuICAgIGlmIChhbGxPYmpzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLmJ1ZnMpLnNsaWNlKDAsIGxlbmd0aClcbiAgICB9XG4gICAgLy8gVE9ETzogbWF5YmUgY29hbGVzY2UgYnVmZmVycywgY291bnRpbmcgYnl0ZXMsIGFuZCBmbGF0dGVuIGluIGFycmF5c1xuICAgIC8vIGNvdW50aW5nIG9iamVjdHM/ICBJIGNhbid0IGltYWdpbmUgd2h5IHRoYXQgd291bGQgYmUgdXNlZnVsLlxuICAgIHRocm93IG5ldyBFcnJvcignQ29uY2F0ZW5hdGluZyBtaXhlZCBvYmplY3QgYW5kIGJ5dGUgc3RyZWFtcyBub3Qgc3VwcG9ydGVkJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyYW5zZm9ybShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cbiAgICB0aGlzLnB1c2goY2h1bmspXG4gICAgY2FsbGJhY2soKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnVmQXJyYXkoKSB7XG4gICAgbGV0IGJ1ZnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlclxuICAgIC8vIEhBQ0s6IHJlcGxhY2Ugd2l0aCBzb21ldGhpbmcgZWxzZSBvbmUgZGF5LiAgVGhpcyBpcyB3aGF0IEkgZ2V0IGZvclxuICAgIC8vIHJlbHlpbmcgb24gaW50ZXJuYWxzLlxuICAgIGlmICghQXJyYXkuaXNBcnJheShidWZzKSkge1xuICAgICAgbGV0IGIgPSBidWZzLmhlYWRcbiAgICAgIGJ1ZnMgPSBbXVxuICAgICAgd2hpbGUgKGIgIT0gbnVsbCkge1xuICAgICAgICBidWZzLnB1c2goYi5kYXRhKVxuICAgICAgICBiID0gYi5uZXh0XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBidWZzXG4gIH1cblxuICAvKipcbiAgICogUHVsbHMgc29tZSBkYXRhIG91dCBvZiB0aGUgaW50ZXJuYWwgYnVmZmVyIGFuZCByZXR1cm5zIGl0LlxuICAgKiBJZiB0aGVyZSBpcyBubyBkYXRhIGF2YWlsYWJsZSwgdGhlbiBpdCB3aWxsIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBJZiB5b3UgcGFzcyBpbiBhIHNpemUgYXJndW1lbnQsIHRoZW4gaXQgd2lsbCByZXR1cm4gdGhhdCBtYW55IGJ5dGVzLiBJZlxuICAgKiBzaXplIGJ5dGVzIGFyZSBub3QgYXZhaWxhYmxlLCB0aGVuIGl0IHdpbGwgcmV0dXJuIG51bGwsIHVubGVzcyB3ZSd2ZVxuICAgKiBlbmRlZCwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIHJldHVybiB0aGUgZGF0YSByZW1haW5pbmcgaW4gdGhlIGJ1ZmZlci5cbiAgICpcbiAgICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGEgc2l6ZSBhcmd1bWVudCwgdGhlbiBpdCB3aWxsIHJldHVybiBhbGwgdGhlIGRhdGEgaW5cbiAgICogdGhlIGludGVybmFsIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPW51bGxdIC0gTnVtYmVyIG9mIGJ5dGVzIHRvIHJlYWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8QnVmZmVyfG51bGx9IElmIG5vIGRhdGEgb3Igbm90IGVub3VnaCBkYXRhLCBudWxsLiAgSWZcbiAgICogICBkZWNvZGluZyBvdXRwdXQgYSBzdHJpbmcsIG90aGVyd2lzZSBhIEJ1ZmZlclxuICAgKiBAdGhyb3dzIEVycm9yIC0gaWYgcmVhZEVycm9yIGlzIHRydWUgYW5kIHRoZXJlIHdhcyB1bmRlcmZsb3dcbiAgICogQGZpcmVzIE5vRmlsdGVyI3JlYWRcbiAgICovXG4gIHJlYWQoc2l6ZSkge1xuICAgIGNvbnN0IGJ1ZiA9IHN1cGVyLnJlYWQoc2l6ZSlcbiAgICBpZiAoYnVmICE9IG51bGwpIHtcbiAgICAgIC8qXG4gICAgICAgKiBSZWFkIGV2ZW50LiBGaXJlZCB3aGVuZXZlciBhbnl0aGluZyBpcyByZWFkIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgTm9GaWx0ZXIjcmVhZFxuICAgICAgICogQHR5cGUge0J1ZmZlcnxzdHJpbmd8T2JqZWN0fVxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgdGhpcy5lbWl0KCdyZWFkJywgYnVmKVxuICAgICAgaWYgKHRoaXMucmVhZEVycm9yICYmIChidWYubGVuZ3RoIDwgc2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWFkICR7YnVmLmxlbmd0aH0sIHdhbnRlZCAke3NpemV9YClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucmVhZEVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGRhdGEgYXZhaWxhYmxlLCB3YW50ZWQgJHtzaXplfWApXG4gICAgfVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHRoZSBmdWxsIGNvbnRlbnRzLCBhZnRlciB0aGUgJ2ZpbmlzaCdcbiAgICogZXZlbnQgZmlyZXMuICBFcnJvcnMgb24gdGhlIHN0cmVhbSBjYXVzZSB0aGUgcHJvbWlzZSB0byBiZSByZWplY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2NiPW51bGxdIC0gZmluaXNoZWQvZXJyb3IgY2FsbGJhY2sgdXNlZCBpbiAqYWRkaXRpb24qXG4gICAqICAgdG8gdGhlIHByb21pc2VcbiAgICogQHJldHVybnMge1Byb21pc2U8QnVmZmVyfFN0cmluZz59IGZ1bGZpbGxlZCB3aGVuIGNvbXBsZXRlXG4gICAqL1xuICBwcm9taXNlKGNiKSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZVxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLm9uKCdmaW5pc2gnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLnJlYWQoKVxuICAgICAgICBpZiAoKGNiICE9IG51bGwpICYmICFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgICBjYihudWxsLCBkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgIH0pXG4gICAgICB0aGlzLm9uKCdlcnJvcicsIChlcikgPT4ge1xuICAgICAgICBpZiAoKGNiICE9IG51bGwpICYmICFkb25lKSB7XG4gICAgICAgICAgZG9uZSA9IHRydWVcbiAgICAgICAgICBjYihlcilcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIG51bWJlciBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBjb21lcyBiZWZvcmUgb3IgYWZ0ZXIgb3IgaXMgdGhlXG4gICAqIHNhbWUgYXMgdGhlIG90aGVyIE5vRmlsdGVyIGluIHNvcnQgb3JkZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9GaWx0ZXJ9IG90aGVyIC0gVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0xLCAwLCAxIGZvciBsZXNzLCBlcXVhbCwgZ3JlYXRlclxuICAgKi9cbiAgY29tcGFyZShvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgTm9GaWx0ZXIpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBOb0ZpbHRlcnMnKVxuICAgIH1cbiAgICBpZiAodGhpcyA9PT0gb3RoZXIpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ1ZjEgPSB0aGlzLnNsaWNlKClcbiAgICAgIGNvbnN0IGJ1ZjIgPSBvdGhlci5zbGljZSgpXG4gICAgICAvLyB0aGVzZSB3aWxsIGJvdGggYmUgYnVmZmVycyBiZWNhdXNlIG9mIHRoZSBjaGVjayBhYm92ZS5cbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYnVmMSkgJiYgQnVmZmVyLmlzQnVmZmVyKGJ1ZjIpKSB7XG4gICAgICAgIHJldHVybiBidWYxLmNvbXBhcmUoYnVmMilcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbXBhcmUgc3RyZWFtcyBpbiBvYmplY3QgbW9kZScpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERvIHRoZXNlIE5vRmlsdGVyJ3MgY29udGFpbiB0aGUgc2FtZSBieXRlcz8gIERvZXNuJ3Qgd29yayBpZiBlaXRoZXIgaXNcbiAgICogaW4gb2JqZWN0IG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9GaWx0ZXJ9IG90aGVyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBFcXVhbD9cbiAgICovXG4gIGVxdWFscyhvdGhlcikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpID09PSAwXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBieXRlcyBvciBvYmplY3RzIHdpdGhvdXQgY29uc3VtaW5nIHRoZW0uICBVc2VmdWwgZm9yIGRpYWdub3N0aWNzLlxuICAgKiBOb3RlOiBhcyBhIHNpZGUtZWZmZWN0LCBjb25jYXRlbmF0ZXMgbXVsdGlwbGUgd3JpdGVzIHRvZ2V0aGVyIGludG8gd2hhdFxuICAgKiBsb29rcyBsaWtlIGEgc2luZ2xlIHdyaXRlLCBzbyB0aGF0IHRoaXMgY29uY2F0IGRvZXNuJ3QgaGF2ZSB0byBoYXBwZW5cbiAgICogbXVsdGlwbGUgdGltZXMgd2hlbiB5b3UncmUgZnV0emluZyB3aXRoIHRoZSBzYW1lIE5vRmlsdGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0PTBdIC0gYmVnaW5uaW5nIG9mZnNldFxuICAgKiBAcGFyYW0ge051bWJlcn0gW2VuZD1sZW5ndGhdIC0gZW5kaW5nIG9mZnNldFxuICAgKiBAcmV0dXJucyB7QnVmZmVyfEFycmF5fSBpZiBpbiBvYmplY3QgbW9kZSwgYW4gYXJyYXkgb2Ygb2JqZWN0cy4gIE90aGVyd2lzZSxcbiAgICogICBjb25jYXRlbmF0ZWQgYXJyYXkgb2YgY29udGVudHMuXG4gICAqL1xuICBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUub2JqZWN0TW9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZkFycmF5KCkuc2xpY2Uoc3RhcnQsIGVuZClcbiAgICB9XG4gICAgY29uc3QgYnVmcyA9IHRoaXMuX2J1ZkFycmF5KClcbiAgICBzd2l0Y2ggKGJ1ZnMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgICAgIGNhc2UgMTogcmV0dXJuIGJ1ZnNbMF0uc2xpY2Uoc3RhcnQsIGVuZClcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnN0IGIgPSBCdWZmZXIuY29uY2F0KGJ1ZnMpXG4gICAgICAgIC8vIFRPRE86IHN0b3JlIHRoZSBjb25jYXRlbnRlZCBidWZzIGJhY2tcbiAgICAgICAgLy8gQF9yZWFkYWJsZVN0YXRlLmJ1ZmZlciA9IFtiXVxuICAgICAgICByZXR1cm4gYi5zbGljZShzdGFydCwgZW5kKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgICogR2V0IGEgYnl0ZSBieSBvZmZzZXQuICBJIGRpZG4ndCB3YW50IHRvIGdldCBpbnRvIG1ldGFwcm9ncmFtbWluZ1xuICAgICogdG8gZ2l2ZSB5b3UgdGhlIGBOb0ZpbHRlclswXWAgc3ludGF4LlxuICAgICpcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbmRleCAtIFRoZSBieXRlIHRvIHJldHJpZXZlXG4gICAgKiBAcmV0dXJucyB7TnVtYmVyfSAwLTI1NVxuICAgICovXG4gIGdldChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLnNsaWNlKClbaW5kZXhdXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIG9iamVjdCBjb21wYXRpYmxlIHdpdGggQnVmZmVyJ3MgdG9KU09OIGltcGxlbWVudGF0aW9uLCBzb1xuICAgKiB0aGF0IHJvdW5kLXRyaXBwaW5nIHdpbGwgcHJvZHVjZSBhIEJ1ZmZlci5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICpcbiAgICogQGV4YW1wbGUgb3V0cHV0IGZvciAnZm9vJ1xuICAgKiAgIHsgdHlwZTogJ0J1ZmZlcicsIGRhdGE6IFsgMTAyLCAxMTEsIDExMSBdIH1cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICBjb25zdCBiID0gdGhpcy5zbGljZSgpXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGIudG9KU09OKClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlcyBhbmQgcmV0dXJucyBhIHN0cmluZyBmcm9tIGJ1ZmZlciBkYXRhIGVuY29kZWQgdXNpbmcgdGhlIHNwZWNpZmllZFxuICAgKiBjaGFyYWN0ZXIgc2V0IGVuY29kaW5nLiBJZiBlbmNvZGluZyBpcyB1bmRlZmluZWQgb3IgbnVsbCwgdGhlbiBlbmNvZGluZ1xuICAgKiBkZWZhdWx0cyB0byAndXRmOCcuIFRoZSBzdGFydCBhbmQgZW5kIHBhcmFtZXRlcnMgZGVmYXVsdCB0byAwIGFuZFxuICAgKiBOb0ZpbHRlci5sZW5ndGggd2hlbiB1bmRlZmluZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbZW5jb2Rpbmc9J3V0ZjgnXSAtIFdoaWNoIHRvIHVzZSBmb3IgZGVjb2Rpbmc/XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RhcnQ9MF0gLSBTdGFydCBvZmZzZXRcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtlbmQ9bGVuZ3RoXSAtIEVuZCBvZmZzZXRcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy5zbGljZShzdGFydCwgZW5kKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShidWYpXG4gICAgfVxuICAgIGlmICgoIWVuY29kaW5nIHx8IChlbmNvZGluZyA9PT0gJ3V0ZjgnKSkgJiYgdXRpbC5UZXh0RGVjb2Rlcikge1xuICAgICAgY29uc3QgdGQgPSBuZXcgdXRpbC5UZXh0RGVjb2RlcigndXRmOCcsIHtcbiAgICAgICAgZmF0YWw6IHRydWUsXG4gICAgICAgIGlnbm9yZUJPTTogdHJ1ZVxuICAgICAgfSlcbiAgICAgIHJldHVybiB0ZC5kZWNvZGUoYnVmKVxuICAgIH1cbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKGVuY29kaW5nLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbC5pbnNwZWN0LmN1c3RvbV0oZGVwdGgsIG9wdGlvbnMpXG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFt1dGlsLmluc3BlY3QuY3VzdG9tXShkZXB0aCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGJ1ZnMgPSB0aGlzLl9idWZBcnJheSgpXG4gICAgY29uc3QgaGV4ID0gYnVmcy5tYXAoKGIpID0+IHtcbiAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICAgICAgaWYgKChvcHRpb25zICE9IG51bGwgPyBvcHRpb25zLnN0eWxpemUgOiB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9wdGlvbnMuc3R5bGl6ZShiLnRvU3RyaW5nKCdoZXgnKSwgJ3N0cmluZycpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGIudG9TdHJpbmcoJ2hleCcpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1dGlsLmluc3BlY3QoYiwgb3B0aW9ucylcbiAgICAgIH1cbiAgICB9KS5qb2luKCcsICcpXG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0gWyR7aGV4fV1gXG4gIH1cblxuICAvKipcbiAgICogQ3VycmVudCByZWFkYWJsZSBsZW5ndGgsIGluIGJ5dGVzLlxuICAgKlxuICAgKiBAbWVtYmVyIHtudW1iZXJ9XG4gICAqIEByZWFkb25seVxuICAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIEphdmFTY3JpcHQgQmlnSW50IHRvIHRoZSBzdHJlYW0uICBOZWdhdGl2ZSBudW1iZXJzIHdpbGwgYmVcbiAgICogd3JpdHRlbiBhcyB0aGVpciAyJ3MgY29tcGxlbWVudCB2ZXJzaW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2JpZ2ludH0gdmFsIC0gVGhlIHZhbHVlIHRvIHdyaXRlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlQmlnSW50KHZhbCkge1xuICAgIGxldCBzdHIgPSB2YWwudG9TdHJpbmcoMTYpXG4gICAgaWYgKHZhbCA8IDApIHtcbiAgICAgIC8vIHR3bydzIGNvbXBsZW1lbnRcbiAgICAgIC8vIE5vdGU6IHN0ciBhbHdheXMgc3RhcnRzIHdpdGggJy0nIGhlcmUuXG4gICAgICBjb25zdCBzeiA9IEJpZ0ludChNYXRoLmZsb29yKHN0ci5sZW5ndGggLyAyKSlcbiAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMSkgPDwgKHN6ICogQmlnSW50KDgpKVxuICAgICAgdmFsID0gbWFzayArIHZhbFxuICAgICAgc3RyID0gdmFsLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgICBpZiAoc3RyLmxlbmd0aCAlIDIpIHtcbiAgICAgIHN0ciA9ICcwJyArIHN0clxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5wdXNoKEJ1ZmZlci5mcm9tKHN0ciwgJ2hleCcpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgYSB2YXJpYWJsZS1zaXplZCBKYXZhU2NyaXB0IHVuc2lnbmVkIEJpZ0ludCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgW2xlbj1udWxsXSAtIG51bWJlciBvZiBieXRlcyB0byByZWFkIG9yIGFsbCByZW1haW5pbmdcbiAgICogICBpZiBudWxsXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAqL1xuICByZWFkVUJpZ0ludChsZW4pIHtcbiAgICBjb25zdCBiID0gdGhpcy5yZWFkKGxlbilcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIEJpZ0ludCgnMHgnICsgYi50b1N0cmluZygnaGV4JykpXG4gIH1cblxuICAvKipcbiAgICogUmVhZCBhIHZhcmlhYmxlLXNpemVkIEphdmFTY3JpcHQgc2lnbmVkIEJpZ0ludCBmcm9tIHRoZSBzdHJlYW0gaW4gMidzXG4gICAqIGNvbXBsZW1lbnQgZm9ybWF0LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbj1udWxsXSAtIG51bWJlciBvZiBieXRlcyB0byByZWFkIG9yIGFsbCByZW1haW5pbmdcbiAgICogICBpZiBudWxsXG4gICAqIEByZXR1cm5zIHtiaWdpbnR9XG4gICAqL1xuICByZWFkQmlnSW50KGxlbikge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQobGVuKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBsZXQgcmV0ID0gQmlnSW50KCcweCcgKyBiLnRvU3RyaW5nKCdoZXgnKSlcbiAgICAvLyBuZWdhdGl2ZT9cbiAgICBpZiAoYlswXSAmIDB4ODApIHtcbiAgICAgIC8vIHR3bydzIGNvbXBsZW1lbnRcbiAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMSkgPDwgKEJpZ0ludChiLmxlbmd0aCkgKiBCaWdJbnQoOCkpXG4gICAgICByZXQgPSByZXQgLSBtYXNrXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXRoIC0gbWV0aG9kIHRvIGNhbGxcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gLSBudW1iZXIgb2YgYnl0ZXMgdG8gd3JpdGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIF9yZWFkX2dlbihtZXRoLCBsZW4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbCkge1xuICAgIGNvbnN0IGIgPSB0aGlzLnJlYWQobGVuKVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gYlttZXRoXS5jYWxsKGIsIDAsIHRydWUpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aCAtIG1ldGhvZCB0byBjYWxsXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuIC0gbnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBfd3JpdGVfZ2VuKG1ldGgsIGxlbikge1xuICByZXR1cm4gZnVuY3Rpb24odmFsKSB7XG4gICAgY29uc3QgYiA9IEJ1ZmZlci5hbGxvYyhsZW4pXG4gICAgYlttZXRoXS5jYWxsKGIsIHZhbCwgMCwgdHJ1ZSlcbiAgICByZXR1cm4gdGhpcy5wdXNoKGIpXG4gIH1cbn1cblxuT2JqZWN0LmFzc2lnbihOb0ZpbHRlci5wcm90b3R5cGUsIHtcbiAgLyoqXG4gICAqIFdyaXRlIGFuIDgtYml0IHVuc2lnbmVkIGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgMSBieXRlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVVSW50OFxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIDAtMjU1XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDg6IF93cml0ZV9nZW4oJ3dyaXRlVUludDgnLCAxKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDE2TEU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDE2TEUnLCAyKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBiaWctZW5kaWFuIDE2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDE2QkU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDE2QkUnLCAyKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDMyTEU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBiaWctZW5kaWFuIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzXG4gICAqIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlVUludDMyQkU6IF93cml0ZV9nZW4oJ3dyaXRlVUludDMyQkUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBzaWduZWQgOC1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyAxIGJ5dGUuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUludDhcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVJbnQ4OiBfd3JpdGVfZ2VuKCd3cml0ZUludDgnLCAxKSxcblxuICAvKipcbiAgICogV3JpdGUgYSBzaWduZWQgbGl0dGxlLWVuZGlhbiAxNi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlSW50MTZMRTogX3dyaXRlX2dlbignd3JpdGVJbnQxNkxFJywgMiksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgc2lnbmVkIGJpZy1lbmRpYW4gMTYtYml0IGludGVnZXIgdG8gdGhlIHN0cmVhbS4gIEFkZHMgMiBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlSW50MTZCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZUludDE2QkU6IF93cml0ZV9nZW4oJ3dyaXRlSW50MTZCRScsIDIpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIHNpZ25lZCBsaXR0bGUtZW5kaWFuIDMyLWJpdCBpbnRlZ2VyIHRvIHRoZSBzdHJlYW0uICBBZGRzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUludDMyTEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVJbnQzMkxFOiBfd3JpdGVfZ2VuKCd3cml0ZUludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBzaWduZWQgYmlnLWVuZGlhbiAzMi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtLiAgQWRkcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIG9uIHN1Y2Nlc3NcbiAgICovXG4gIHdyaXRlSW50MzJCRTogX3dyaXRlX2dlbignd3JpdGVJbnQzMkJFJywgNCksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgbGl0dGxlLWVuZGlhbiAzMi1iaXQgZmxvYXQgdG8gdGhlIHN0cmVhbS4gIEFkZHMgNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlRmxvYXRMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZUZsb2F0TEU6IF93cml0ZV9nZW4oJ3dyaXRlRmxvYXRMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBXcml0ZSBhIGJpZy1lbmRpYW4gMzItYml0IGZsb2F0IHRvIHRoZSBzdHJlYW0uICBBZGRzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiB3cml0ZUZsb2F0QkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVGbG9hdEJFOiBfd3JpdGVfZ2VuKCd3cml0ZUZsb2F0QkUnLCA0KSxcblxuICAvKipcbiAgICogV3JpdGUgYSBsaXR0bGUtZW5kaWFuIDY0LWJpdCBmbG9hdCB0byB0aGUgc3RyZWFtLiAgQWRkcyA4IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gd3JpdGVEb3VibGVMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBvbiBzdWNjZXNzXG4gICAqL1xuICB3cml0ZURvdWJsZUxFOiBfd3JpdGVfZ2VuKCd3cml0ZURvdWJsZUxFJywgOCksXG5cbiAgLyoqXG4gICAqIFdyaXRlIGEgYmlnLWVuZGlhbiA2NC1iaXQgZmxvYXQgdG8gdGhlIHN0cmVhbS4gIEFkZHMgOCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHdyaXRlRG91YmxlQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWVcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgb24gc3VjY2Vzc1xuICAgKi9cbiAgd3JpdGVEb3VibGVCRTogX3dyaXRlX2dlbignd3JpdGVEb3VibGVCRScsIDgpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGFuIHVuc2lnbmVkIDgtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLiAgQ29uc3VtZXMgMSBieXRlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQ4XG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50ODogX3JlYWRfZ2VuKCdyZWFkVUludDgnLCAxKSxcblxuICAvKipcbiAgICogUmVhZCBhIGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MTZMRTogX3JlYWRfZ2VuKCdyZWFkVUludDE2TEUnLCAyKSxcblxuICAvKipcbiAgICogUmVhZCBhIGJpZy1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyAyIGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQxNkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MTZCRTogX3JlYWRfZ2VuKCdyZWFkVUludDE2QkUnLCAyKSxcblxuICAvKipcbiAgICogUmVhZCBhIGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgMzItYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQzMkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MzJMRTogX3JlYWRfZ2VuKCdyZWFkVUludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIGJpZy1lbmRpYW4gdW5zaWduZWQgMTYtYml0IGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZFVJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRVSW50MzJCRTogX3JlYWRfZ2VuKCdyZWFkVUludDMyQkUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIHNpZ25lZCA4LWJpdCBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgMSBieXRlLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEludDhcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEludDg6IF9yZWFkX2dlbigncmVhZEludDgnLCAxKSxcblxuICAvKipcbiAgICogUmVhZCBhIHNpZ25lZCAxNi1iaXQgbGl0dGxlLWVuZGlhbiBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgMiBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWRJbnQxNkxFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRJbnQxNkxFOiBfcmVhZF9nZW4oJ3JlYWRJbnQxNkxFJywgMiksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSBzaWduZWQgMTYtYml0IGJpZy1lbmRpYW4gaW50ZWdlciBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDIgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkSW50MTZCRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkSW50MTZCRTogX3JlYWRfZ2VuKCdyZWFkSW50MTZCRScsIDIpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgc2lnbmVkIDMyLWJpdCBsaXR0bGUtZW5kaWFuIGludGVnZXIgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEludDMyTEVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEludDMyTEU6IF9yZWFkX2dlbigncmVhZEludDMyTEUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIHNpZ25lZCAzMi1iaXQgYmlnLWVuZGlhbiBpbnRlZ2VyIGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgNCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWRJbnQzMkJFXG4gICAqIEBtZW1iZXJPZiBOb0ZpbHRlclxuICAgKiBAaW5zdGFuY2VcbiAgICogQHJldHVybnMge051bWJlcn0gdmFsdWVcbiAgICovXG4gIHJlYWRJbnQzMkJFOiBfcmVhZF9nZW4oJ3JlYWRJbnQzMkJFJywgNCksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSAzMi1iaXQgbGl0dGxlLWVuZGlhbiBmbG9hdCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDQgYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkRmxvYXRMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkRmxvYXRMRTogX3JlYWRfZ2VuKCdyZWFkRmxvYXRMRScsIDQpLFxuXG4gIC8qKlxuICAgKiBSZWFkIGEgMzItYml0IGJpZy1lbmRpYW4gZmxvYXQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBDb25zdW1lcyA0IGJ5dGVzLlxuICAgKlxuICAgKiBAZnVuY3Rpb24gcmVhZEZsb2F0QkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZEZsb2F0QkU6IF9yZWFkX2dlbigncmVhZEZsb2F0QkUnLCA0KSxcblxuICAvKipcbiAgICogUmVhZCBhIDY0LWJpdCBsaXR0bGUtZW5kaWFuIGZsb2F0IGZyb20gdGhlIHN0cmVhbS5cbiAgICogQ29uc3VtZXMgOCBieXRlcy5cbiAgICpcbiAgICogQGZ1bmN0aW9uIHJlYWREb3VibGVMRVxuICAgKiBAbWVtYmVyT2YgTm9GaWx0ZXJcbiAgICogQGluc3RhbmNlXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IHZhbHVlXG4gICAqL1xuICByZWFkRG91YmxlTEU6IF9yZWFkX2dlbigncmVhZERvdWJsZUxFJywgOCksXG5cbiAgLyoqXG4gICAqIFJlYWQgYSA2NC1iaXQgYmlnLWVuZGlhbiBmbG9hdCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIENvbnN1bWVzIDggYnl0ZXMuXG4gICAqXG4gICAqIEBmdW5jdGlvbiByZWFkRG91YmxlQkVcbiAgICogQG1lbWJlck9mIE5vRmlsdGVyXG4gICAqIEBpbnN0YW5jZVxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgcmVhZERvdWJsZUJFOiBfcmVhZF9nZW4oJ3JlYWREb3VibGVCRScsIDgpXG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vRmlsdGVyXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBudW1iZXJJc05hTiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRyZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpcyhhLCBiKSB7XG5cdGlmIChhID09PSAwICYmIGIgPT09IDApIHtcblx0XHRyZXR1cm4gMSAvIGEgPT09IDEgLyBiO1xuXHR9XG5cdGlmIChhID09PSBiKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0aWYgKG51bWJlcklzTmFOKGEpICYmIG51bWJlcklzTmFOKGIpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0cmV0dXJuIGZhbHNlO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcbnZhciBjYWxsQmluZCA9IHJlcXVpcmUoJ2NhbGwtYmluZCcpO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgc2hpbSA9IHJlcXVpcmUoJy4vc2hpbScpO1xuXG52YXIgcG9seWZpbGwgPSBjYWxsQmluZChnZXRQb2x5ZmlsbCgpLCBPYmplY3QpO1xuXG5kZWZpbmUocG9seWZpbGwsIHtcblx0Z2V0UG9seWZpbGw6IGdldFBvbHlmaWxsLFxuXHRpbXBsZW1lbnRhdGlvbjogaW1wbGVtZW50YXRpb24sXG5cdHNoaW06IHNoaW1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBvbHlmaWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2ltcGxlbWVudGF0aW9uJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZ2V0UG9seWZpbGwoKSB7XG5cdHJldHVybiB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaW1wbGVtZW50YXRpb247XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2V0UG9seWZpbGwgPSByZXF1aXJlKCcuL3BvbHlmaWxsJyk7XG52YXIgZGVmaW5lID0gcmVxdWlyZSgnZGVmaW5lLXByb3BlcnRpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzaGltT2JqZWN0SXMoKSB7XG5cdHZhciBwb2x5ZmlsbCA9IGdldFBvbHlmaWxsKCk7XG5cdGRlZmluZShPYmplY3QsIHsgaXM6IHBvbHlmaWxsIH0sIHtcblx0XHRpczogZnVuY3Rpb24gdGVzdE9iamVjdElzKCkge1xuXHRcdFx0cmV0dXJuIE9iamVjdC5pcyAhPT0gcG9seWZpbGw7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHBvbHlmaWxsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGtleXNTaGltO1xuaWYgKCFPYmplY3Qua2V5cykge1xuXHQvLyBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9lcy1zaGltcy9lczUtc2hpbVxuXHR2YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblx0dmFyIHRvU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0dmFyIGlzQXJncyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBnbG9iYWwtcmVxdWlyZVxuXHR2YXIgaXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblx0dmFyIGhhc0RvbnRFbnVtQnVnID0gIWlzRW51bWVyYWJsZS5jYWxsKHsgdG9TdHJpbmc6IG51bGwgfSwgJ3RvU3RyaW5nJyk7XG5cdHZhciBoYXNQcm90b0VudW1CdWcgPSBpc0VudW1lcmFibGUuY2FsbChmdW5jdGlvbiAoKSB7fSwgJ3Byb3RvdHlwZScpO1xuXHR2YXIgZG9udEVudW1zID0gW1xuXHRcdCd0b1N0cmluZycsXG5cdFx0J3RvTG9jYWxlU3RyaW5nJyxcblx0XHQndmFsdWVPZicsXG5cdFx0J2hhc093blByb3BlcnR5Jyxcblx0XHQnaXNQcm90b3R5cGVPZicsXG5cdFx0J3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcblx0XHQnY29uc3RydWN0b3InXG5cdF07XG5cdHZhciBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSA9IGZ1bmN0aW9uIChvKSB7XG5cdFx0dmFyIGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuXHRcdHJldHVybiBjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBvO1xuXHR9O1xuXHR2YXIgZXhjbHVkZWRLZXlzID0ge1xuXHRcdCRhcHBsaWNhdGlvbkNhY2hlOiB0cnVlLFxuXHRcdCRjb25zb2xlOiB0cnVlLFxuXHRcdCRleHRlcm5hbDogdHJ1ZSxcblx0XHQkZnJhbWU6IHRydWUsXG5cdFx0JGZyYW1lRWxlbWVudDogdHJ1ZSxcblx0XHQkZnJhbWVzOiB0cnVlLFxuXHRcdCRpbm5lckhlaWdodDogdHJ1ZSxcblx0XHQkaW5uZXJXaWR0aDogdHJ1ZSxcblx0XHQkb25tb3pmdWxsc2NyZWVuY2hhbmdlOiB0cnVlLFxuXHRcdCRvbm1vemZ1bGxzY3JlZW5lcnJvcjogdHJ1ZSxcblx0XHQkb3V0ZXJIZWlnaHQ6IHRydWUsXG5cdFx0JG91dGVyV2lkdGg6IHRydWUsXG5cdFx0JHBhZ2VYT2Zmc2V0OiB0cnVlLFxuXHRcdCRwYWdlWU9mZnNldDogdHJ1ZSxcblx0XHQkcGFyZW50OiB0cnVlLFxuXHRcdCRzY3JvbGxMZWZ0OiB0cnVlLFxuXHRcdCRzY3JvbGxUb3A6IHRydWUsXG5cdFx0JHNjcm9sbFg6IHRydWUsXG5cdFx0JHNjcm9sbFk6IHRydWUsXG5cdFx0JHNlbGY6IHRydWUsXG5cdFx0JHdlYmtpdEluZGV4ZWREQjogdHJ1ZSxcblx0XHQkd2Via2l0U3RvcmFnZUluZm86IHRydWUsXG5cdFx0JHdpbmRvdzogdHJ1ZVxuXHR9O1xuXHR2YXIgaGFzQXV0b21hdGlvbkVxdWFsaXR5QnVnID0gKGZ1bmN0aW9uICgpIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBmYWxzZTsgfVxuXHRcdGZvciAodmFyIGsgaW4gd2luZG93KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAoIWV4Y2x1ZGVkS2V5c1snJCcgKyBrXSAmJiBoYXMuY2FsbCh3aW5kb3csIGspICYmIHdpbmRvd1trXSAhPT0gbnVsbCAmJiB0eXBlb2Ygd2luZG93W2tdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZSh3aW5kb3dba10pO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9KCkpO1xuXHR2YXIgZXF1YWxzQ29uc3RydWN0b3JQcm90b3R5cGVJZk5vdEJ1Z2d5ID0gZnVuY3Rpb24gKG8pIHtcblx0XHQvKiBnbG9iYWwgd2luZG93ICovXG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNBdXRvbWF0aW9uRXF1YWxpdHlCdWcpIHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBlcXVhbHNDb25zdHJ1Y3RvclByb3RvdHlwZShvKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9O1xuXG5cdGtleXNTaGltID0gZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcblx0XHR2YXIgaXNPYmplY3QgPSBvYmplY3QgIT09IG51bGwgJiYgdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCc7XG5cdFx0dmFyIGlzRnVuY3Rpb24gPSB0b1N0ci5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdFx0dmFyIGlzQXJndW1lbnRzID0gaXNBcmdzKG9iamVjdCk7XG5cdFx0dmFyIGlzU3RyaW5nID0gaXNPYmplY3QgJiYgdG9TdHIuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBTdHJpbmddJztcblx0XHR2YXIgdGhlS2V5cyA9IFtdO1xuXG5cdFx0aWYgKCFpc09iamVjdCAmJiAhaXNGdW5jdGlvbiAmJiAhaXNBcmd1bWVudHMpIHtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5rZXlzIGNhbGxlZCBvbiBhIG5vbi1vYmplY3QnKTtcblx0XHR9XG5cblx0XHR2YXIgc2tpcFByb3RvID0gaGFzUHJvdG9FbnVtQnVnICYmIGlzRnVuY3Rpb247XG5cdFx0aWYgKGlzU3RyaW5nICYmIG9iamVjdC5sZW5ndGggPiAwICYmICFoYXMuY2FsbChvYmplY3QsIDApKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7ICsraSkge1xuXHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKGkpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoaXNBcmd1bWVudHMgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgb2JqZWN0Lmxlbmd0aDsgKytqKSB7XG5cdFx0XHRcdHRoZUtleXMucHVzaChTdHJpbmcoaikpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIG9iamVjdCkge1xuXHRcdFx0XHRpZiAoIShza2lwUHJvdG8gJiYgbmFtZSA9PT0gJ3Byb3RvdHlwZScpICYmIGhhcy5jYWxsKG9iamVjdCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goU3RyaW5nKG5hbWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChoYXNEb250RW51bUJ1Zykge1xuXHRcdFx0dmFyIHNraXBDb25zdHJ1Y3RvciA9IGVxdWFsc0NvbnN0cnVjdG9yUHJvdG90eXBlSWZOb3RCdWdneShvYmplY3QpO1xuXG5cdFx0XHRmb3IgKHZhciBrID0gMDsgayA8IGRvbnRFbnVtcy5sZW5ndGg7ICsraykge1xuXHRcdFx0XHRpZiAoIShza2lwQ29uc3RydWN0b3IgJiYgZG9udEVudW1zW2tdID09PSAnY29uc3RydWN0b3InKSAmJiBoYXMuY2FsbChvYmplY3QsIGRvbnRFbnVtc1trXSkpIHtcblx0XHRcdFx0XHR0aGVLZXlzLnB1c2goZG9udEVudW1zW2tdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhlS2V5cztcblx0fTtcbn1cbm1vZHVsZS5leHBvcnRzID0ga2V5c1NoaW07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBpc0FyZ3MgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyk7XG5cbnZhciBvcmlnS2V5cyA9IE9iamVjdC5rZXlzO1xudmFyIGtleXNTaGltID0gb3JpZ0tleXMgPyBmdW5jdGlvbiBrZXlzKG8pIHsgcmV0dXJuIG9yaWdLZXlzKG8pOyB9IDogcmVxdWlyZSgnLi9pbXBsZW1lbnRhdGlvbicpO1xuXG52YXIgb3JpZ2luYWxLZXlzID0gT2JqZWN0LmtleXM7XG5cbmtleXNTaGltLnNoaW0gPSBmdW5jdGlvbiBzaGltT2JqZWN0S2V5cygpIHtcblx0aWYgKE9iamVjdC5rZXlzKSB7XG5cdFx0dmFyIGtleXNXb3Jrc1dpdGhBcmd1bWVudHMgPSAoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly8gU2FmYXJpIDUuMCBidWdcblx0XHRcdHZhciBhcmdzID0gT2JqZWN0LmtleXMoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBhcmdzICYmIGFyZ3MubGVuZ3RoID09PSBhcmd1bWVudHMubGVuZ3RoO1xuXHRcdH0oMSwgMikpO1xuXHRcdGlmICgha2V5c1dvcmtzV2l0aEFyZ3VtZW50cykge1xuXHRcdFx0T2JqZWN0LmtleXMgPSBmdW5jdGlvbiBrZXlzKG9iamVjdCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGZ1bmMtbmFtZS1tYXRjaGluZ1xuXHRcdFx0XHRpZiAoaXNBcmdzKG9iamVjdCkpIHtcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxLZXlzKHNsaWNlLmNhbGwob2JqZWN0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG9yaWdpbmFsS2V5cyhvYmplY3QpO1xuXHRcdFx0fTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0T2JqZWN0LmtleXMgPSBrZXlzU2hpbTtcblx0fVxuXHRyZXR1cm4gT2JqZWN0LmtleXMgfHwga2V5c1NoaW07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXNTaGltO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9TdHIgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQXJndW1lbnRzKHZhbHVlKSB7XG5cdHZhciBzdHIgPSB0b1N0ci5jYWxsKHZhbHVlKTtcblx0dmFyIGlzQXJncyA9IHN0ciA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cdGlmICghaXNBcmdzKSB7XG5cdFx0aXNBcmdzID0gc3RyICE9PSAnW29iamVjdCBBcnJheV0nICYmXG5cdFx0XHR2YWx1ZSAhPT0gbnVsbCAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuXHRcdFx0dHlwZW9mIHZhbHVlLmxlbmd0aCA9PT0gJ251bWJlcicgJiZcblx0XHRcdHZhbHVlLmxlbmd0aCA+PSAwICYmXG5cdFx0XHR0b1N0ci5jYWxsKHZhbHVlLmNhbGxlZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG5cdH1cblx0cmV0dXJuIGlzQXJncztcbn07XG4iLCJ2YXIgbm9DYXNlID0gcmVxdWlyZSgnbm8tY2FzZScpXG5cbi8qKlxuICogUGFyYW0gY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0gIHtzdHJpbmd9IFtsb2NhbGVdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBsb2NhbGUpIHtcbiAgcmV0dXJuIG5vQ2FzZSh2YWx1ZSwgbG9jYWxlLCAnLScpXG59XG4iLCJ2YXIgY2FtZWxDYXNlID0gcmVxdWlyZSgnY2FtZWwtY2FzZScpXG52YXIgdXBwZXJDYXNlRmlyc3QgPSByZXF1aXJlKCd1cHBlci1jYXNlLWZpcnN0JylcblxuLyoqXG4gKiBQYXNjYWwgY2FzZSBhIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB2YWx1ZVxuICogQHBhcmFtICB7c3RyaW5nfSAgW2xvY2FsZV1cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFttZXJnZU51bWJlcnNdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBsb2NhbGUsIG1lcmdlTnVtYmVycykge1xuICByZXR1cm4gdXBwZXJDYXNlRmlyc3QoY2FtZWxDYXNlKHZhbHVlLCBsb2NhbGUsIG1lcmdlTnVtYmVycyksIGxvY2FsZSlcbn1cbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCJ2YXIgbm9DYXNlID0gcmVxdWlyZSgnbm8tY2FzZScpXG5cbi8qKlxuICogUGF0aCBjYXNlIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSAge3N0cmluZ30gW2xvY2FsZV1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIGxvY2FsZSkge1xuICByZXR1cm4gbm9DYXNlKHZhbHVlLCBsb2NhbGUsICcvJylcbn1cbiIsInZhciBpc2FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbi8qKlxuICogRXhwb3NlIGBwYXRoVG9SZWdleHBgLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhUb1JlZ2V4cFxubW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZVxubW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9IGNvbXBpbGVcbm1vZHVsZS5leHBvcnRzLnRva2Vuc1RvRnVuY3Rpb24gPSB0b2tlbnNUb0Z1bmN0aW9uXG5tb2R1bGUuZXhwb3J0cy50b2tlbnNUb1JlZ0V4cCA9IHRva2Vuc1RvUmVnRXhwXG5cbi8qKlxuICogVGhlIG1haW4gcGF0aCBtYXRjaGluZyByZWdleHAgdXRpbGl0eS5cbiAqXG4gKiBAdHlwZSB7UmVnRXhwfVxuICovXG52YXIgUEFUSF9SRUdFWFAgPSBuZXcgUmVnRXhwKFtcbiAgLy8gTWF0Y2ggZXNjYXBlZCBjaGFyYWN0ZXJzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGFwcGVhciBpbiBmdXR1cmUgbWF0Y2hlcy5cbiAgLy8gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gZXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyB0aGF0IHdvbid0IHRyYW5zZm9ybS5cbiAgJyhcXFxcXFxcXC4pJyxcbiAgLy8gTWF0Y2ggRXhwcmVzcy1zdHlsZSBwYXJhbWV0ZXJzIGFuZCB1bi1uYW1lZCBwYXJhbWV0ZXJzIHdpdGggYSBwcmVmaXhcbiAgLy8gYW5kIG9wdGlvbmFsIHN1ZmZpeGVzLiBNYXRjaGVzIGFwcGVhciBhczpcbiAgLy9cbiAgLy8gXCIvOnRlc3QoXFxcXGQrKT9cIiA9PiBbXCIvXCIsIFwidGVzdFwiLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCBcIj9cIiwgdW5kZWZpbmVkXVxuICAvLyBcIi9yb3V0ZShcXFxcZCspXCIgID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIlxcZCtcIiwgdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gIC8vIFwiLypcIiAgICAgICAgICAgID0+IFtcIi9cIiwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBcIipcIl1cbiAgJyhbXFxcXC8uXSk/KD86KD86XFxcXDooXFxcXHcrKSg/OlxcXFwoKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKCldKSspXFxcXCkpP3xcXFxcKCgoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpXSkrKVxcXFwpKShbKyo/XSk/fChcXFxcKikpJ1xuXS5qb2luKCd8JyksICdnJylcblxuLyoqXG4gKiBQYXJzZSBhIHN0cmluZyBmb3IgdGhlIHJhdyB0b2tlbnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgc3RyXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSBvcHRpb25zXG4gKiBAcmV0dXJuIHshQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlIChzdHIsIG9wdGlvbnMpIHtcbiAgdmFyIHRva2VucyA9IFtdXG4gIHZhciBrZXkgPSAwXG4gIHZhciBpbmRleCA9IDBcbiAgdmFyIHBhdGggPSAnJ1xuICB2YXIgZGVmYXVsdERlbGltaXRlciA9IG9wdGlvbnMgJiYgb3B0aW9ucy5kZWxpbWl0ZXIgfHwgJy8nXG4gIHZhciByZXNcblxuICB3aGlsZSAoKHJlcyA9IFBBVEhfUkVHRVhQLmV4ZWMoc3RyKSkgIT0gbnVsbCkge1xuICAgIHZhciBtID0gcmVzWzBdXG4gICAgdmFyIGVzY2FwZWQgPSByZXNbMV1cbiAgICB2YXIgb2Zmc2V0ID0gcmVzLmluZGV4XG4gICAgcGF0aCArPSBzdHIuc2xpY2UoaW5kZXgsIG9mZnNldClcbiAgICBpbmRleCA9IG9mZnNldCArIG0ubGVuZ3RoXG5cbiAgICAvLyBJZ25vcmUgYWxyZWFkeSBlc2NhcGVkIHNlcXVlbmNlcy5cbiAgICBpZiAoZXNjYXBlZCkge1xuICAgICAgcGF0aCArPSBlc2NhcGVkWzFdXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHZhciBuZXh0ID0gc3RyW2luZGV4XVxuICAgIHZhciBwcmVmaXggPSByZXNbMl1cbiAgICB2YXIgbmFtZSA9IHJlc1szXVxuICAgIHZhciBjYXB0dXJlID0gcmVzWzRdXG4gICAgdmFyIGdyb3VwID0gcmVzWzVdXG4gICAgdmFyIG1vZGlmaWVyID0gcmVzWzZdXG4gICAgdmFyIGFzdGVyaXNrID0gcmVzWzddXG5cbiAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHBhdGggb250byB0aGUgdG9rZW5zLlxuICAgIGlmIChwYXRoKSB7XG4gICAgICB0b2tlbnMucHVzaChwYXRoKVxuICAgICAgcGF0aCA9ICcnXG4gICAgfVxuXG4gICAgdmFyIHBhcnRpYWwgPSBwcmVmaXggIT0gbnVsbCAmJiBuZXh0ICE9IG51bGwgJiYgbmV4dCAhPT0gcHJlZml4XG4gICAgdmFyIHJlcGVhdCA9IG1vZGlmaWVyID09PSAnKycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBvcHRpb25hbCA9IG1vZGlmaWVyID09PSAnPycgfHwgbW9kaWZpZXIgPT09ICcqJ1xuICAgIHZhciBkZWxpbWl0ZXIgPSByZXNbMl0gfHwgZGVmYXVsdERlbGltaXRlclxuICAgIHZhciBwYXR0ZXJuID0gY2FwdHVyZSB8fCBncm91cFxuXG4gICAgdG9rZW5zLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSB8fCBrZXkrKyxcbiAgICAgIHByZWZpeDogcHJlZml4IHx8ICcnLFxuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXIsXG4gICAgICBvcHRpb25hbDogb3B0aW9uYWwsXG4gICAgICByZXBlYXQ6IHJlcGVhdCxcbiAgICAgIHBhcnRpYWw6IHBhcnRpYWwsXG4gICAgICBhc3RlcmlzazogISFhc3RlcmlzayxcbiAgICAgIHBhdHRlcm46IHBhdHRlcm4gPyBlc2NhcGVHcm91cChwYXR0ZXJuKSA6IChhc3RlcmlzayA/ICcuKicgOiAnW14nICsgZXNjYXBlU3RyaW5nKGRlbGltaXRlcikgKyAnXSs/JylcbiAgICB9KVxuICB9XG5cbiAgLy8gTWF0Y2ggYW55IGNoYXJhY3RlcnMgc3RpbGwgcmVtYWluaW5nLlxuICBpZiAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgcGF0aCArPSBzdHIuc3Vic3RyKGluZGV4KVxuICB9XG5cbiAgLy8gSWYgdGhlIHBhdGggZXhpc3RzLCBwdXNoIGl0IG9udG8gdGhlIGVuZC5cbiAgaWYgKHBhdGgpIHtcbiAgICB0b2tlbnMucHVzaChwYXRoKVxuICB9XG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIENvbXBpbGUgYSBzdHJpbmcgdG8gYSB0ZW1wbGF0ZSBmdW5jdGlvbiBmb3IgdGhlIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICAgICBzdHJcbiAqIEBwYXJhbSAge09iamVjdD19ICAgICAgICAgICAgb3B0aW9uc1xuICogQHJldHVybiB7IWZ1bmN0aW9uKE9iamVjdD0sIE9iamVjdD0pfVxuICovXG5mdW5jdGlvbiBjb21waWxlIChzdHIsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvRnVuY3Rpb24ocGFyc2Uoc3RyLCBvcHRpb25zKSlcbn1cblxuLyoqXG4gKiBQcmV0dGllciBlbmNvZGluZyBvZiBVUkkgcGF0aCBzZWdtZW50cy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bXFwvPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEVuY29kZSB0aGUgYXN0ZXJpc2sgcGFyYW1ldGVyLiBTaW1pbGFyIHRvIGBwcmV0dHlgLCBidXQgYWxsb3dzIHNsYXNoZXMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlbmNvZGVBc3RlcmlzayAoc3RyKSB7XG4gIHJldHVybiBlbmNvZGVVUkkoc3RyKS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uIChjKSB7XG4gICAgcmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKVxuICB9KVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIG1ldGhvZCBmb3IgdHJhbnNmb3JtaW5nIHRva2VucyBpbnRvIHRoZSBwYXRoIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0b2tlbnNUb0Z1bmN0aW9uICh0b2tlbnMpIHtcbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHRva2VucyBpbnRvIHJlZ2V4cHMuXG4gIHZhciBtYXRjaGVzID0gbmV3IEFycmF5KHRva2Vucy5sZW5ndGgpXG5cbiAgLy8gQ29tcGlsZSBhbGwgdGhlIHBhdHRlcm5zIGJlZm9yZSBjb21waWxhdGlvbi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodHlwZW9mIHRva2Vuc1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG1hdGNoZXNbaV0gPSBuZXcgUmVnRXhwKCdeKD86JyArIHRva2Vuc1tpXS5wYXR0ZXJuICsgJykkJylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG9iaiwgb3B0cykge1xuICAgIHZhciBwYXRoID0gJydcbiAgICB2YXIgZGF0YSA9IG9iaiB8fCB7fVxuICAgIHZhciBvcHRpb25zID0gb3B0cyB8fCB7fVxuICAgIHZhciBlbmNvZGUgPSBvcHRpb25zLnByZXR0eSA/IGVuY29kZVVSSUNvbXBvbmVudFByZXR0eSA6IGVuY29kZVVSSUNvbXBvbmVudFxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXVxuXG4gICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXRoICs9IHRva2VuXG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gZGF0YVt0b2tlbi5uYW1lXVxuICAgICAgdmFyIHNlZ21lbnRcblxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgaWYgKHRva2VuLm9wdGlvbmFsKSB7XG4gICAgICAgICAgLy8gUHJlcGVuZCBwYXJ0aWFsIHNlZ21lbnQgcHJlZml4ZXMuXG4gICAgICAgICAgaWYgKHRva2VuLnBhcnRpYWwpIHtcbiAgICAgICAgICAgIHBhdGggKz0gdG9rZW4ucHJlZml4XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIGJlIGRlZmluZWQnKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc2FycmF5KHZhbHVlKSkge1xuICAgICAgICBpZiAoIXRva2VuLnJlcGVhdCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFwiJyArIHRva2VuLm5hbWUgKyAnXCIgdG8gbm90IHJlcGVhdCwgYnV0IHJlY2VpdmVkIGAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ2AnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGlmICh0b2tlbi5vcHRpb25hbCkge1xuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgXCInICsgdG9rZW4ubmFtZSArICdcIiB0byBub3QgYmUgZW1wdHknKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBzZWdtZW50ID0gZW5jb2RlKHZhbHVlW2pdKVxuXG4gICAgICAgICAgaWYgKCFtYXRjaGVzW2ldLnRlc3Qoc2VnbWVudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGFsbCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBgJyArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpICsgJ2AnKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhdGggKz0gKGogPT09IDAgPyB0b2tlbi5wcmVmaXggOiB0b2tlbi5kZWxpbWl0ZXIpICsgc2VnbWVudFxuICAgICAgICB9XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgc2VnbWVudCA9IHRva2VuLmFzdGVyaXNrID8gZW5jb2RlQXN0ZXJpc2sodmFsdWUpIDogZW5jb2RlKHZhbHVlKVxuXG4gICAgICBpZiAoIW1hdGNoZXNbaV0udGVzdChzZWdtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBcIicgKyB0b2tlbi5uYW1lICsgJ1wiIHRvIG1hdGNoIFwiJyArIHRva2VuLnBhdHRlcm4gKyAnXCIsIGJ1dCByZWNlaXZlZCBcIicgKyBzZWdtZW50ICsgJ1wiJylcbiAgICAgIH1cblxuICAgICAgcGF0aCArPSB0b2tlbi5wcmVmaXggKyBzZWdtZW50XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGhcbiAgfVxufVxuXG4vKipcbiAqIEVzY2FwZSBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBzdHJpbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZXNjYXBlU3RyaW5nIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oWy4rKj89XiE6JHt9KClbXFxdfFxcL1xcXFxdKS9nLCAnXFxcXCQxJylcbn1cblxuLyoqXG4gKiBFc2NhcGUgdGhlIGNhcHR1cmluZyBncm91cCBieSBlc2NhcGluZyBzcGVjaWFsIGNoYXJhY3RlcnMgYW5kIG1lYW5pbmcuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBncm91cFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGVHcm91cCAoZ3JvdXApIHtcbiAgcmV0dXJuIGdyb3VwLnJlcGxhY2UoLyhbPSE6JFxcLygpXSkvZywgJ1xcXFwkMScpXG59XG5cbi8qKlxuICogQXR0YWNoIHRoZSBrZXlzIGFzIGEgcHJvcGVydHkgb2YgdGhlIHJlZ2V4cC5cbiAqXG4gKiBAcGFyYW0gIHshUmVnRXhwfSByZVxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXR0YWNoS2V5cyAocmUsIGtleXMpIHtcbiAgcmUua2V5cyA9IGtleXNcbiAgcmV0dXJuIHJlXG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFncyBmb3IgYSByZWdleHAgZnJvbSB0aGUgb3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZmxhZ3MgKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMuc2Vuc2l0aXZlID8gJycgOiAnaSdcbn1cblxuLyoqXG4gKiBQdWxsIG91dCBrZXlzIGZyb20gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IVJlZ0V4cH0gcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gcmVnZXhwVG9SZWdleHAgKHBhdGgsIGtleXMpIHtcbiAgLy8gVXNlIGEgbmVnYXRpdmUgbG9va2FoZWFkIHRvIG1hdGNoIG9ubHkgY2FwdHVyaW5nIGdyb3Vwcy5cbiAgdmFyIGdyb3VwcyA9IHBhdGguc291cmNlLm1hdGNoKC9cXCgoPyFcXD8pL2cpXG5cbiAgaWYgKGdyb3Vwcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBuYW1lOiBpLFxuICAgICAgICBwcmVmaXg6IG51bGwsXG4gICAgICAgIGRlbGltaXRlcjogbnVsbCxcbiAgICAgICAgb3B0aW9uYWw6IGZhbHNlLFxuICAgICAgICByZXBlYXQ6IGZhbHNlLFxuICAgICAgICBwYXJ0aWFsOiBmYWxzZSxcbiAgICAgICAgYXN0ZXJpc2s6IGZhbHNlLFxuICAgICAgICBwYXR0ZXJuOiBudWxsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKHBhdGgsIGtleXMpXG59XG5cbi8qKlxuICogVHJhbnNmb3JtIGFuIGFycmF5IGludG8gYSByZWdleHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgcGF0aFxuICogQHBhcmFtICB7QXJyYXl9ICAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gYXJyYXlUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICB2YXIgcGFydHMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIHBhcnRzLnB1c2gocGF0aFRvUmVnZXhwKHBhdGhbaV0sIGtleXMsIG9wdGlvbnMpLnNvdXJjZSlcbiAgfVxuXG4gIHZhciByZWdleHAgPSBuZXcgUmVnRXhwKCcoPzonICsgcGFydHMuam9pbignfCcpICsgJyknLCBmbGFncyhvcHRpb25zKSlcblxuICByZXR1cm4gYXR0YWNoS2V5cyhyZWdleHAsIGtleXMpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcGF0aCByZWdleHAgZnJvbSBzdHJpbmcgaW5wdXQuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgcGF0aFxuICogQHBhcmFtICB7IUFycmF5fSAga2V5c1xuICogQHBhcmFtICB7IU9iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7IVJlZ0V4cH1cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9SZWdleHAgKHBhdGgsIGtleXMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRva2Vuc1RvUmVnRXhwKHBhcnNlKHBhdGgsIG9wdGlvbnMpLCBrZXlzLCBvcHRpb25zKVxufVxuXG4vKipcbiAqIEV4cG9zZSBhIGZ1bmN0aW9uIGZvciB0YWtpbmcgdG9rZW5zIGFuZCByZXR1cm5pbmcgYSBSZWdFeHAuXG4gKlxuICogQHBhcmFtICB7IUFycmF5fSAgICAgICAgICB0b2tlbnNcbiAqIEBwYXJhbSAgeyhBcnJheXxPYmplY3QpPX0ga2V5c1xuICogQHBhcmFtICB7T2JqZWN0PX0gICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJuIHshUmVnRXhwfVxuICovXG5mdW5jdGlvbiB0b2tlbnNUb1JlZ0V4cCAodG9rZW5zLCBrZXlzLCBvcHRpb25zKSB7XG4gIGlmICghaXNhcnJheShrZXlzKSkge1xuICAgIG9wdGlvbnMgPSAvKiogQHR5cGUgeyFPYmplY3R9ICovIChrZXlzIHx8IG9wdGlvbnMpXG4gICAga2V5cyA9IFtdXG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdFxuICB2YXIgZW5kID0gb3B0aW9ucy5lbmQgIT09IGZhbHNlXG4gIHZhciByb3V0ZSA9ICcnXG5cbiAgLy8gSXRlcmF0ZSBvdmVyIHRoZSB0b2tlbnMgYW5kIGNyZWF0ZSBvdXIgcmVnZXhwIHN0cmluZy5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV1cblxuICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICByb3V0ZSArPSBlc2NhcGVTdHJpbmcodG9rZW4pXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwcmVmaXggPSBlc2NhcGVTdHJpbmcodG9rZW4ucHJlZml4KVxuICAgICAgdmFyIGNhcHR1cmUgPSAnKD86JyArIHRva2VuLnBhdHRlcm4gKyAnKSdcblxuICAgICAga2V5cy5wdXNoKHRva2VuKVxuXG4gICAgICBpZiAodG9rZW4ucmVwZWF0KSB7XG4gICAgICAgIGNhcHR1cmUgKz0gJyg/OicgKyBwcmVmaXggKyBjYXB0dXJlICsgJykqJ1xuICAgICAgfVxuXG4gICAgICBpZiAodG9rZW4ub3B0aW9uYWwpIHtcbiAgICAgICAgaWYgKCF0b2tlbi5wYXJ0aWFsKSB7XG4gICAgICAgICAgY2FwdHVyZSA9ICcoPzonICsgcHJlZml4ICsgJygnICsgY2FwdHVyZSArICcpKT8nXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FwdHVyZSA9IHByZWZpeCArICcoJyArIGNhcHR1cmUgKyAnKT8nXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcHR1cmUgPSBwcmVmaXggKyAnKCcgKyBjYXB0dXJlICsgJyknXG4gICAgICB9XG5cbiAgICAgIHJvdXRlICs9IGNhcHR1cmVcbiAgICB9XG4gIH1cblxuICB2YXIgZGVsaW1pdGVyID0gZXNjYXBlU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVyIHx8ICcvJylcbiAgdmFyIGVuZHNXaXRoRGVsaW1pdGVyID0gcm91dGUuc2xpY2UoLWRlbGltaXRlci5sZW5ndGgpID09PSBkZWxpbWl0ZXJcblxuICAvLyBJbiBub24tc3RyaWN0IG1vZGUgd2UgYWxsb3cgYSBzbGFzaCBhdCB0aGUgZW5kIG9mIG1hdGNoLiBJZiB0aGUgcGF0aCB0b1xuICAvLyBtYXRjaCBhbHJlYWR5IGVuZHMgd2l0aCBhIHNsYXNoLCB3ZSByZW1vdmUgaXQgZm9yIGNvbnNpc3RlbmN5LiBUaGUgc2xhc2hcbiAgLy8gaXMgdmFsaWQgYXQgdGhlIGVuZCBvZiBhIHBhdGggbWF0Y2gsIG5vdCBpbiB0aGUgbWlkZGxlLiBUaGlzIGlzIGltcG9ydGFudFxuICAvLyBpbiBub24tZW5kaW5nIG1vZGUsIHdoZXJlIFwiL3Rlc3QvXCIgc2hvdWxkbid0IG1hdGNoIFwiL3Rlc3QvL3JvdXRlXCIuXG4gIGlmICghc3RyaWN0KSB7XG4gICAgcm91dGUgPSAoZW5kc1dpdGhEZWxpbWl0ZXIgPyByb3V0ZS5zbGljZSgwLCAtZGVsaW1pdGVyLmxlbmd0aCkgOiByb3V0ZSkgKyAnKD86JyArIGRlbGltaXRlciArICcoPz0kKSk/J1xuICB9XG5cbiAgaWYgKGVuZCkge1xuICAgIHJvdXRlICs9ICckJ1xuICB9IGVsc2Uge1xuICAgIC8vIEluIG5vbi1lbmRpbmcgbW9kZSwgd2UgbmVlZCB0aGUgY2FwdHVyaW5nIGdyb3VwcyB0byBtYXRjaCBhcyBtdWNoIGFzXG4gICAgLy8gcG9zc2libGUgYnkgdXNpbmcgYSBwb3NpdGl2ZSBsb29rYWhlYWQgdG8gdGhlIGVuZCBvciBuZXh0IHBhdGggc2VnbWVudC5cbiAgICByb3V0ZSArPSBzdHJpY3QgJiYgZW5kc1dpdGhEZWxpbWl0ZXIgPyAnJyA6ICcoPz0nICsgZGVsaW1pdGVyICsgJ3wkKSdcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hLZXlzKG5ldyBSZWdFeHAoJ14nICsgcm91dGUsIGZsYWdzKG9wdGlvbnMpKSwga2V5cylcbn1cblxuLyoqXG4gKiBOb3JtYWxpemUgdGhlIGdpdmVuIHBhdGggc3RyaW5nLCByZXR1cm5pbmcgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKlxuICogQW4gZW1wdHkgYXJyYXkgY2FuIGJlIHBhc3NlZCBpbiBmb3IgdGhlIGtleXMsIHdoaWNoIHdpbGwgaG9sZCB0aGVcbiAqIHBsYWNlaG9sZGVyIGtleSBkZXNjcmlwdGlvbnMuIEZvciBleGFtcGxlLCB1c2luZyBgL3VzZXIvOmlkYCwgYGtleXNgIHdpbGxcbiAqIGNvbnRhaW4gYFt7IG5hbWU6ICdpZCcsIGRlbGltaXRlcjogJy8nLCBvcHRpb25hbDogZmFsc2UsIHJlcGVhdDogZmFsc2UgfV1gLlxuICpcbiAqIEBwYXJhbSAgeyhzdHJpbmd8UmVnRXhwfEFycmF5KX0gcGF0aFxuICogQHBhcmFtICB7KEFycmF5fE9iamVjdCk9fSAgICAgICBrZXlzXG4gKiBAcGFyYW0gIHtPYmplY3Q9fSAgICAgICAgICAgICAgIG9wdGlvbnNcbiAqIEByZXR1cm4geyFSZWdFeHB9XG4gKi9cbmZ1bmN0aW9uIHBhdGhUb1JlZ2V4cCAocGF0aCwga2V5cywgb3B0aW9ucykge1xuICBpZiAoIWlzYXJyYXkoa2V5cykpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAoa2V5cyB8fCBvcHRpb25zKVxuICAgIGtleXMgPSBbXVxuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIHJldHVybiByZWdleHBUb1JlZ2V4cChwYXRoLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpKVxuICB9XG5cbiAgaWYgKGlzYXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gYXJyYXlUb1JlZ2V4cCgvKiogQHR5cGUgeyFBcnJheX0gKi8gKHBhdGgpLCAvKiogQHR5cGUgeyFBcnJheX0gKi8gKGtleXMpLCBvcHRpb25zKVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZ1RvUmVnZXhwKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAocGF0aCksIC8qKiBAdHlwZSB7IUFycmF5fSAqLyAoa2V5cyksIG9wdGlvbnMpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKiohXG4gKiBAZmlsZU92ZXJ2aWV3IEtpY2thc3MgbGlicmFyeSB0byBjcmVhdGUgYW5kIHBsYWNlIHBvcHBlcnMgbmVhciB0aGVpciByZWZlcmVuY2UgZWxlbWVudHMuXG4gKiBAdmVyc2lvbiAxLjE2LjEtbHRzXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLlBvcHBlciA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciB0aW1lb3V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBsb25nZXJUaW1lb3V0QnJvd3NlcnMgPSBbJ0VkZ2UnLCAnVHJpZGVudCcsICdGaXJlZm94J107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbG9uZ2VyVGltZW91dEJyb3dzZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGlzQnJvd3NlciAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YobG9uZ2VyVGltZW91dEJyb3dzZXJzW2ldKSA+PSAwKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDA7XG59KCk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBjc3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCBudWxsKTtcbiAgcmV0dXJuIHByb3BlcnR5ID8gY3NzW3Byb3BlcnR5XSA6IGNzcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXJlbnROb2RlIG9yIHRoZSBob3N0IG9mIHRoZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlIHx8IGVsZW1lbnQuaG9zdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY3JvbGxpbmcgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBzY3JvbGwgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFJldHVybiBib2R5LCBgZ2V0U2Nyb2xsYCB3aWxsIHRha2UgY2FyZSB0byBnZXQgdGhlIGNvcnJlY3QgYHNjcm9sbFRvcGAgZnJvbSBpdFxuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxuXG4gIHN3aXRjaCAoZWxlbWVudC5ub2RlTmFtZSkge1xuICAgIGNhc2UgJ0hUTUwnOlxuICAgIGNhc2UgJ0JPRFknOlxuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5ib2R5O1xuICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICByZXR1cm4gZWxlbWVudC5ib2R5O1xuICB9XG5cbiAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG5cbiAgdmFyIF9nZXRTdHlsZUNvbXB1dGVkUHJvcCA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KSxcbiAgICAgIG92ZXJmbG93ID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1k7XG5cbiAgaWYgKC8oYXV0b3xzY3JvbGx8b3ZlcmxheSkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlZmVyZW5jZSBub2RlIG9mIHRoZSByZWZlcmVuY2Ugb2JqZWN0LCBvciB0aGUgcmVmZXJlbmNlIG9iamVjdCBpdHNlbGYuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkge1xuICByZXR1cm4gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlID8gcmVmZXJlbmNlLnJlZmVyZW5jZU5vZGUgOiByZWZlcmVuY2U7XG59XG5cbnZhciBpc0lFMTEgPSBpc0Jyb3dzZXIgJiYgISEod2luZG93Lk1TSW5wdXRNZXRob2RDb250ZXh0ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG52YXIgaXNJRTEwID0gaXNCcm93c2VyICYmIC9NU0lFIDEwLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXQgRXhwbG9yZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7TnVtYmVyfSB2ZXJzaW9uIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRVxuICovXG5mdW5jdGlvbiBpc0lFKHZlcnNpb24pIHtcbiAgaWYgKHZlcnNpb24gPT09IDExKSB7XG4gICAgcmV0dXJuIGlzSUUxMTtcbiAgfVxuICBpZiAodmVyc2lvbiA9PT0gMTApIHtcbiAgICByZXR1cm4gaXNJRTEwO1xuICB9XG4gIHJldHVybiBpc0lFMTEgfHwgaXNJRTEwO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIHZhciBub09mZnNldFBhcmVudCA9IGlzSUUoMTApID8gZG9jdW1lbnQuYm9keSA6IG51bGw7XG5cbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50IHx8IG51bGw7XG4gIC8vIFNraXAgaGlkZGVuIGVsZW1lbnRzIHdoaWNoIGRvbid0IGhhdmUgYW4gb2Zmc2V0UGFyZW50XG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgPT09IG5vT2Zmc2V0UGFyZW50ICYmIGVsZW1lbnQubmV4dEVsZW1lbnRTaWJsaW5nKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gKGVsZW1lbnQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykub2Zmc2V0UGFyZW50O1xuICB9XG5cbiAgdmFyIG5vZGVOYW1lID0gb2Zmc2V0UGFyZW50ICYmIG9mZnNldFBhcmVudC5ub2RlTmFtZTtcblxuICBpZiAoIW5vZGVOYW1lIHx8IG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEgsIFREIG9yIFRBQkxFIGluIGNhc2VcbiAgLy8gbm8gb2Zmc2V0UGFyZW50IGlzIHByZXNlbnQsIEkgaGF0ZSB0aGlzIGpvYi4uLlxuICBpZiAoWydUSCcsICdURCcsICdUQUJMRSddLmluZGV4T2Yob2Zmc2V0UGFyZW50Lm5vZGVOYW1lKSAhPT0gLTEgJiYgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KG9mZnNldFBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnKSB7XG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudDtcbn1cblxuZnVuY3Rpb24gaXNPZmZzZXRDb250YWluZXIoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ0hUTUwnIHx8IGdldE9mZnNldFBhcmVudChlbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgcm9vdCBub2RlIChkb2N1bWVudCwgc2hhZG93RE9NIHJvb3QpIG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtFbGVtZW50fSByb290IG5vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdChub2RlKSB7XG4gIGlmIChub2RlLnBhcmVudE5vZGUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0Um9vdChub2RlLnBhcmVudE5vZGUpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG9mZnNldCBwYXJlbnQgY29tbW9uIHRvIHRoZSB0d28gcHJvdmlkZWQgbm9kZXNcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDFcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudDJcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBjb21tb24gb2Zmc2V0IHBhcmVudFxuICovXG5mdW5jdGlvbiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBlbGVtZW50Mikge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50MSB8fCAhZWxlbWVudDEubm9kZVR5cGUgfHwgIWVsZW1lbnQyIHx8ICFlbGVtZW50Mi5ub2RlVHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyBIZXJlIHdlIG1ha2Ugc3VyZSB0byBnaXZlIGFzIFwic3RhcnRcIiB0aGUgZWxlbWVudCB0aGF0IGNvbWVzIGZpcnN0IGluIHRoZSBET01cbiAgdmFyIG9yZGVyID0gZWxlbWVudDEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oZWxlbWVudDIpICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkc7XG4gIHZhciBzdGFydCA9IG9yZGVyID8gZWxlbWVudDEgOiBlbGVtZW50MjtcbiAgdmFyIGVuZCA9IG9yZGVyID8gZWxlbWVudDIgOiBlbGVtZW50MTtcblxuICAvLyBHZXQgY29tbW9uIGFuY2VzdG9yIGNvbnRhaW5lclxuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICByYW5nZS5zZXRTdGFydChzdGFydCwgMCk7XG4gIHJhbmdlLnNldEVuZChlbmQsIDApO1xuICB2YXIgY29tbW9uQW5jZXN0b3JDb250YWluZXIgPSByYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcjtcblxuICAvLyBCb3RoIG5vZGVzIGFyZSBpbnNpZGUgI2RvY3VtZW50XG5cbiAgaWYgKGVsZW1lbnQxICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciAmJiBlbGVtZW50MiAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgfHwgc3RhcnQuY29udGFpbnMoZW5kKSkge1xuICAgIGlmIChpc09mZnNldENvbnRhaW5lcihjb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgIHJldHVybiBjb21tb25BbmNlc3RvckNvbnRhaW5lcjtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKTtcbiAgfVxuXG4gIC8vIG9uZSBvZiB0aGUgbm9kZXMgaXMgaW5zaWRlIHNoYWRvd0RPTSwgZmluZCB3aGljaCBvbmVcbiAgdmFyIGVsZW1lbnQxcm9vdCA9IGdldFJvb3QoZWxlbWVudDEpO1xuICBpZiAoZWxlbWVudDFyb290Lmhvc3QpIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MXJvb3QuaG9zdCwgZWxlbWVudDIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxLCBnZXRSb290KGVsZW1lbnQyKS5ob3N0KTtcbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIHNjcm9sbCB2YWx1ZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBpbiB0aGUgZ2l2ZW4gc2lkZSAodG9wIGFuZCBsZWZ0KVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gc2lkZSBgdG9wYCBvciBgbGVmdGBcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFtb3VudCBvZiBzY3JvbGxlZCBwaXhlbHNcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsKGVsZW1lbnQpIHtcbiAgdmFyIHNpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICd0b3AnO1xuXG4gIHZhciB1cHBlclNpZGUgPSBzaWRlID09PSAndG9wJyA/ICdzY3JvbGxUb3AnIDogJ3Njcm9sbExlZnQnO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuc2Nyb2xsaW5nRWxlbWVudCB8fCBodG1sO1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50W3VwcGVyU2lkZV07XG4gIH1cblxuICByZXR1cm4gZWxlbWVudFt1cHBlclNpZGVdO1xufVxuXG4vKlxuICogU3VtIG9yIHN1YnRyYWN0IHRoZSBlbGVtZW50IHNjcm9sbCB2YWx1ZXMgKGxlZnQgYW5kIHRvcCkgZnJvbSBhIGdpdmVuIHJlY3Qgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCAtIFJlY3Qgb2JqZWN0IHlvdSB3YW50IHRvIGNoYW5nZVxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBlbGVtZW50IGZyb20gdGhlIGZ1bmN0aW9uIHJlYWRzIHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHN1YnRyYWN0IC0gc2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gc3VidHJhY3QgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEByZXR1cm4ge09iamVjdH0gcmVjdCAtIFRoZSBtb2RpZmllciByZWN0IG9iamVjdFxuICovXG5mdW5jdGlvbiBpbmNsdWRlU2Nyb2xsKHJlY3QsIGVsZW1lbnQpIHtcbiAgdmFyIHN1YnRyYWN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgdmFyIG1vZGlmaWVyID0gc3VidHJhY3QgPyAtMSA6IDE7XG4gIHJlY3QudG9wICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJldHVybiByZWN0O1xufVxuXG4vKlxuICogSGVscGVyIHRvIGRldGVjdCBib3JkZXJzIG9mIGEgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcbiAqIFJlc3VsdCBvZiBgZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5YCBvbiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IGF4aXMgLSBgeGAgb3IgYHlgXG4gKiBAcmV0dXJuIHtudW1iZXJ9IGJvcmRlcnMgLSBUaGUgYm9yZGVycyBzaXplIG9mIHRoZSBnaXZlbiBheGlzXG4gKi9cblxuZnVuY3Rpb24gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCBheGlzKSB7XG4gIHZhciBzaWRlQSA9IGF4aXMgPT09ICd4JyA/ICdMZWZ0JyA6ICdUb3AnO1xuICB2YXIgc2lkZUIgPSBzaWRlQSA9PT0gJ0xlZnQnID8gJ1JpZ2h0JyA6ICdCb3R0b20nO1xuXG4gIHJldHVybiBwYXJzZUZsb2F0KHN0eWxlc1snYm9yZGVyJyArIHNpZGVBICsgJ1dpZHRoJ10pICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2l6ZShheGlzLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSB7XG4gIHJldHVybiBNYXRoLm1heChib2R5WydvZmZzZXQnICsgYXhpc10sIGJvZHlbJ3Njcm9sbCcgKyBheGlzXSwgaHRtbFsnY2xpZW50JyArIGF4aXNdLCBodG1sWydvZmZzZXQnICsgYXhpc10sIGh0bWxbJ3Njcm9sbCcgKyBheGlzXSwgaXNJRSgxMCkgPyBwYXJzZUludChodG1sWydvZmZzZXQnICsgYXhpc10pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0pICsgcGFyc2VJbnQoY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdCb3R0b20nIDogJ1JpZ2h0JyldKSA6IDApO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTaXplcyhkb2N1bWVudCkge1xuICB2YXIgYm9keSA9IGRvY3VtZW50LmJvZHk7XG4gIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IGlzSUUoMTApICYmIGdldENvbXB1dGVkU3R5bGUoaHRtbCk7XG5cbiAgcmV0dXJuIHtcbiAgICBoZWlnaHQ6IGdldFNpemUoJ0hlaWdodCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpLFxuICAgIHdpZHRoOiBnZXRTaXplKCdXaWR0aCcsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpXG4gIH07XG59XG5cbnZhciBjbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cblxuXG5cblxudmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gKG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgdHJ5IHtcbiAgICBpZiAoaXNJRSgxMCkpIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICAgICAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5sZWZ0ICs9IHNjcm9sbExlZnQ7XG4gICAgICByZWN0LmJvdHRvbSArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge31cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoZWxlbWVudC5vd25lckRvY3VtZW50KSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC53aWR0aDtcbiAgdmFyIGhlaWdodCA9IHNpemVzLmhlaWdodCB8fCBlbGVtZW50LmNsaWVudEhlaWdodCB8fCByZXN1bHQuaGVpZ2h0O1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIGlzSUUxMCA9IGlzSUUoMTApO1xuICB2YXIgaXNIVE1MID0gcGFyZW50Lm5vZGVOYW1lID09PSAnSFRNTCc7XG4gIHZhciBjaGlsZHJlblJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2hpbGRyZW4pO1xuICB2YXIgcGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChwYXJlbnQpO1xuICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGNoaWxkcmVuKTtcblxuICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KHBhcmVudCk7XG4gIHZhciBib3JkZXJUb3BXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlclRvcFdpZHRoKTtcbiAgdmFyIGJvcmRlckxlZnRXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGVzLmJvcmRlckxlZnRXaWR0aCk7XG5cbiAgLy8gSW4gY2FzZXMgd2hlcmUgdGhlIHBhcmVudCBpcyBmaXhlZCwgd2UgbXVzdCBpZ25vcmUgbmVnYXRpdmUgc2Nyb2xsIGluIG9mZnNldCBjYWxjXG4gIGlmIChmaXhlZFBvc2l0aW9uICYmIGlzSFRNTCkge1xuICAgIHBhcmVudFJlY3QudG9wID0gTWF0aC5tYXgocGFyZW50UmVjdC50b3AsIDApO1xuICAgIHBhcmVudFJlY3QubGVmdCA9IE1hdGgubWF4KHBhcmVudFJlY3QubGVmdCwgMCk7XG4gIH1cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3ApO1xuICAgIHZhciBtYXJnaW5MZWZ0ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCk7XG5cbiAgICBvZmZzZXRzLnRvcCAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmJvdHRvbSAtPSBib3JkZXJUb3BXaWR0aCAtIG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLmxlZnQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcbiAgICBvZmZzZXRzLnJpZ2h0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG5cbiAgICAvLyBBdHRhY2ggbWFyZ2luVG9wIGFuZCBtYXJnaW5MZWZ0IGJlY2F1c2UgaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdlIG1heSBuZWVkIHRoZW1cbiAgICBvZmZzZXRzLm1hcmdpblRvcCA9IG1hcmdpblRvcDtcbiAgICBvZmZzZXRzLm1hcmdpbkxlZnQgPSBtYXJnaW5MZWZ0O1xuICB9XG5cbiAgaWYgKGlzSUUxMCAmJiAhZml4ZWRQb3NpdGlvbiA/IHBhcmVudC5jb250YWlucyhzY3JvbGxQYXJlbnQpIDogcGFyZW50ID09PSBzY3JvbGxQYXJlbnQgJiYgc2Nyb2xsUGFyZW50Lm5vZGVOYW1lICE9PSAnQk9EWScpIHtcbiAgICBvZmZzZXRzID0gaW5jbHVkZVNjcm9sbChvZmZzZXRzLCBwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldHM7XG59XG5cbmZ1bmN0aW9uIGdldFZpZXdwb3J0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcnRiaXRyYXJ5Tm9kZShlbGVtZW50KSB7XG4gIHZhciBleGNsdWRlU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaHRtbCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciByZWxhdGl2ZU9mZnNldCA9IGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShlbGVtZW50LCBodG1sKTtcbiAgdmFyIHdpZHRoID0gTWF0aC5tYXgoaHRtbC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gIHZhciBoZWlnaHQgPSBNYXRoLm1heChodG1sLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IDApO1xuXG4gIHZhciBzY3JvbGxUb3AgPSAhZXhjbHVkZVNjcm9sbCA/IGdldFNjcm9sbChodG1sKSA6IDA7XG4gIHZhciBzY3JvbGxMZWZ0ID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCwgJ2xlZnQnKSA6IDA7XG5cbiAgdmFyIG9mZnNldCA9IHtcbiAgICB0b3A6IHNjcm9sbFRvcCAtIHJlbGF0aXZlT2Zmc2V0LnRvcCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpblRvcCxcbiAgICBsZWZ0OiBzY3JvbGxMZWZ0IC0gcmVsYXRpdmVPZmZzZXQubGVmdCArIHJlbGF0aXZlT2Zmc2V0Lm1hcmdpbkxlZnQsXG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0XG4gIH07XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3Qob2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gZWxlbWVudCBpcyBmaXhlZCBvciBpcyBpbnNpZGUgYSBmaXhlZCBwYXJlbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBjdXN0b21Db250YWluZXJcbiAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gKi9cbmZ1bmN0aW9uIGlzRml4ZWQoZWxlbWVudCkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtZW50Lm5vZGVOYW1lO1xuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCwgJ3Bvc2l0aW9uJykgPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG4gIGlmICghcGFyZW50Tm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaXhlZChwYXJlbnROb2RlKTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgZmlyc3QgcGFyZW50IG9mIGFuIGVsZW1lbnQgdGhhdCBoYXMgYSB0cmFuc2Zvcm1lZCBwcm9wZXJ0eSBkZWZpbmVkXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBmaXJzdCB0cmFuc2Zvcm1lZCBwYXJlbnQgb3IgZG9jdW1lbnRFbGVtZW50XG4gKi9cblxuZnVuY3Rpb24gZ2V0Rml4ZWRQb3NpdGlvbk9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQucGFyZW50RWxlbWVudCB8fCBpc0lFKCkpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG4gIHZhciBlbCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbCwgJ3RyYW5zZm9ybScpID09PSAnbm9uZScpIHtcbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHJlZmVyZW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmdcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50IC0gRWxlbWVudCB1c2VkIHRvIGRlZmluZSB0aGUgYm91bmRhcmllc1xuICogQHBhcmFtIHtCb29sZWFufSBmaXhlZFBvc2l0aW9uIC0gSXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQ29vcmRpbmF0ZXMgb2YgdGhlIGJvdW5kYXJpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRhcmllcyhwb3BwZXIsIHJlZmVyZW5jZSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG5cbiAgdmFyIGJvdW5kYXJpZXMgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuICB2YXIgb2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMocG9wcGVyLm93bmVyRG9jdW1lbnQpLFxuICAgICAgICAgIGhlaWdodCA9IF9nZXRXaW5kb3dTaXplcy5oZWlnaHQsXG4gICAgICAgICAgd2lkdGggPSBfZ2V0V2luZG93U2l6ZXMud2lkdGg7XG5cbiAgICAgIGJvdW5kYXJpZXMudG9wICs9IG9mZnNldHMudG9wIC0gb2Zmc2V0cy5tYXJnaW5Ub3A7XG4gICAgICBib3VuZGFyaWVzLmJvdHRvbSA9IGhlaWdodCArIG9mZnNldHMudG9wO1xuICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IG9mZnNldHMubGVmdCAtIG9mZnNldHMubWFyZ2luTGVmdDtcbiAgICAgIGJvdW5kYXJpZXMucmlnaHQgPSB3aWR0aCArIG9mZnNldHMubGVmdDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGFsbCB0aGUgb3RoZXIgRE9NIGVsZW1lbnRzLCB0aGlzIG9uZSBpcyBnb29kXG4gICAgICBib3VuZGFyaWVzID0gb2Zmc2V0cztcbiAgICB9XG4gIH1cblxuICAvLyBBZGQgcGFkZGluZ3NcbiAgcGFkZGluZyA9IHBhZGRpbmcgfHwgMDtcbiAgdmFyIGlzUGFkZGluZ051bWJlciA9IHR5cGVvZiBwYWRkaW5nID09PSAnbnVtYmVyJztcbiAgYm91bmRhcmllcy5sZWZ0ICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmxlZnQgfHwgMDtcbiAgYm91bmRhcmllcy50b3AgKz0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcudG9wIHx8IDA7XG4gIGJvdW5kYXJpZXMucmlnaHQgLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcucmlnaHQgfHwgMDtcbiAgYm91bmRhcmllcy5ib3R0b20gLT0gaXNQYWRkaW5nTnVtYmVyID8gcGFkZGluZyA6IHBhZGRpbmcuYm90dG9tIHx8IDA7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGZpeGVkUG9zaXRpb24gLSBpcyBpbiBmaXhlZCBwb3NpdGlvbiBtb2RlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgZml4ZWRQb3NpdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZml4ZWRQb3NpdGlvbiA/IGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQocG9wcGVyKSA6IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCBnZXRSZWZlcmVuY2VOb2RlKHJlZmVyZW5jZSkpO1xuICByZXR1cm4gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKHJlZmVyZW5jZSwgY29tbW9uT2Zmc2V0UGFyZW50LCBmaXhlZFBvc2l0aW9uKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG91dGVyIHNpemVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChvZmZzZXQgc2l6ZSArIG1hcmdpbnMpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IG9iamVjdCBjb250YWluaW5nIHdpZHRoIGFuZCBoZWlnaHQgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBnZXRPdXRlclNpemVzKGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgdmFyIHN0eWxlcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkJvdHRvbSB8fCAwKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0IHx8IDApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQgfHwgMCk7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGggKyB5LFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4XG4gIH07XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICogQHJldHVybnMge1N0cmluZ30gZmxpcHBlZCBwbGFjZW1lbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb3NpdGlvbiAtIENTUyBwb3NpdGlvbiB0aGUgUG9wcGVyIHdpbGwgZ2V0IGFwcGxpZWRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHMgLSB0aGUgcmVmZXJlbmNlIG9mZnNldHMgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtTdHJpbmd9IHBsYWNlbWVudCAtIG9uZSBvZiB0aGUgdmFsaWQgcGxhY2VtZW50IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IHBvcHBlck9mZnNldHMgLSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRQb3BwZXJPZmZzZXRzKHBvcHBlciwgcmVmZXJlbmNlT2Zmc2V0cywgcGxhY2VtZW50KSB7XG4gIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuXG4gIC8vIEdldCBwb3BwZXIgbm9kZSBzaXplc1xuICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAvLyBBZGQgcG9zaXRpb24sIHdpZHRoIGFuZCBoZWlnaHQgdG8gb3VyIG9mZnNldHMgb2JqZWN0XG4gIHZhciBwb3BwZXJPZmZzZXRzID0ge1xuICAgIHdpZHRoOiBwb3BwZXJSZWN0LndpZHRoLFxuICAgIGhlaWdodDogcG9wcGVyUmVjdC5oZWlnaHRcbiAgfTtcblxuICAvLyBkZXBlbmRpbmcgYnkgdGhlIHBvcHBlciBwbGFjZW1lbnQgd2UgaGF2ZSB0byBjb21wdXRlIGl0cyBvZmZzZXRzIHNsaWdodGx5IGRpZmZlcmVudGx5XG4gIHZhciBpc0hvcml6ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIG1haW5TaWRlID0gaXNIb3JpeiA/ICd0b3AnIDogJ2xlZnQnO1xuICB2YXIgc2Vjb25kYXJ5U2lkZSA9IGlzSG9yaXogPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG1lYXN1cmVtZW50ID0gaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNlY29uZGFyeU1lYXN1cmVtZW50ID0gIWlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgcG9wcGVyT2Zmc2V0c1ttYWluU2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW21haW5TaWRlXSArIHJlZmVyZW5jZU9mZnNldHNbbWVhc3VyZW1lbnRdIC8gMiAtIHBvcHBlclJlY3RbbWVhc3VyZW1lbnRdIC8gMjtcbiAgaWYgKHBsYWNlbWVudCA9PT0gc2Vjb25kYXJ5U2lkZSkge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW3NlY29uZGFyeVNpZGVdIC0gcG9wcGVyUmVjdFtzZWNvbmRhcnlNZWFzdXJlbWVudF07XG4gIH0gZWxzZSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQoc2Vjb25kYXJ5U2lkZSldO1xuICB9XG5cbiAgcmV0dXJuIHBvcHBlck9mZnNldHM7XG59XG5cbi8qKlxuICogTWltaWNzIHRoZSBgZmluZGAgbWV0aG9kIG9mIEFycmF5XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmQoYXJyLCBjaGVjaykge1xuICAvLyB1c2UgbmF0aXZlIGZpbmQgaWYgc3VwcG9ydGVkXG4gIGlmIChBcnJheS5wcm90b3R5cGUuZmluZCkge1xuICAgIHJldHVybiBhcnIuZmluZChjaGVjayk7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgdG8gb2J0YWluIHRoZSBzYW1lIGJlaGF2aW9yIG9mIGBmaW5kYFxuICByZXR1cm4gYXJyLmZpbHRlcihjaGVjaylbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgb2JqZWN0XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0FycmF5fSBhcnJcbiAqIEBhcmd1bWVudCBwcm9wXG4gKiBAYXJndW1lbnQgdmFsdWVcbiAqIEByZXR1cm5zIGluZGV4IG9yIC0xXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZChhcnIsIGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqW3Byb3BdID09PSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBhcnIuaW5kZXhPZihtYXRjaCk7XG59XG5cbi8qKlxuICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlcixcbiAqIGVhY2ggb2YgdGhlbSB3aWxsIHRoZW4gZWRpdCB0aGUgZGF0YSBvYmplY3QuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IGVuZHMgLSBPcHRpb25hbCBtb2RpZmllciBuYW1lIHVzZWQgYXMgc3RvcHBlclxuICogQHJldHVybnMge2RhdGFPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bk1vZGlmaWVycyhtb2RpZmllcnMsIGRhdGEsIGVuZHMpIHtcbiAgdmFyIG1vZGlmaWVyc1RvUnVuID0gZW5kcyA9PT0gdW5kZWZpbmVkID8gbW9kaWZpZXJzIDogbW9kaWZpZXJzLnNsaWNlKDAsIGZpbmRJbmRleChtb2RpZmllcnMsICduYW1lJywgZW5kcykpO1xuXG4gIG1vZGlmaWVyc1RvUnVuLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKG1vZGlmaWVyWydmdW5jdGlvbiddKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgICAgY29uc29sZS53YXJuKCdgbW9kaWZpZXIuZnVuY3Rpb25gIGlzIGRlcHJlY2F0ZWQsIHVzZSBgbW9kaWZpZXIuZm5gIScpO1xuICAgIH1cbiAgICB2YXIgZm4gPSBtb2RpZmllclsnZnVuY3Rpb24nXSB8fCBtb2RpZmllci5mbjsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICBpZiAobW9kaWZpZXIuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKGZuKSkge1xuICAgICAgLy8gQWRkIHByb3BlcnRpZXMgdG8gb2Zmc2V0cyB0byBtYWtlIHRoZW0gYSBjb21wbGV0ZSBjbGllbnRSZWN0IG9iamVjdFxuICAgICAgLy8gd2UgZG8gdGhpcyBiZWZvcmUgZWFjaCBtb2RpZmllciB0byBtYWtlIHN1cmUgdGhlIHByZXZpb3VzIG9uZSBkb2Vzbid0XG4gICAgICAvLyBtZXNzIHdpdGggdGhlc2UgdmFsdWVzXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UpO1xuXG4gICAgICBkYXRhID0gZm4oZGF0YSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHBlciwgY29tcHV0aW5nIHRoZSBuZXcgb2Zmc2V0cyBhbmQgYXBwbHlpbmdcbiAqIHRoZSBuZXcgc3R5bGUuPGJyIC8+XG4gKiBQcmVmZXIgYHNjaGVkdWxlVXBkYXRlYCBvdmVyIGB1cGRhdGVgIGJlY2F1c2Ugb2YgcGVyZm9ybWFuY2UgcmVhc29ucy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gdXBkYXRlKCkge1xuICAvLyBpZiBwb3BwZXIgaXMgZGVzdHJveWVkLCBkb24ndCBwZXJmb3JtIGFueSBmdXJ0aGVyIHVwZGF0ZVxuICBpZiAodGhpcy5zdGF0ZS5pc0Rlc3Ryb3llZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBkYXRhID0ge1xuICAgIGluc3RhbmNlOiB0aGlzLFxuICAgIHN0eWxlczoge30sXG4gICAgYXJyb3dTdHlsZXM6IHt9LFxuICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgIGZsaXBwZWQ6IGZhbHNlLFxuICAgIG9mZnNldHM6IHt9XG4gIH07XG5cbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgPSBnZXRSZWZlcmVuY2VPZmZzZXRzKHRoaXMuc3RhdGUsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgZGF0YS5wb3NpdGlvbkZpeGVkID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uRml4ZWQgPyAnZml4ZWQnIDogJ2Fic29sdXRlJztcblxuICAvLyBydW4gdGhlIG1vZGlmaWVyc1xuICBkYXRhID0gcnVuTW9kaWZpZXJzKHRoaXMubW9kaWZpZXJzLCBkYXRhKTtcblxuICAvLyB0aGUgZmlyc3QgYHVwZGF0ZWAgd2lsbCBjYWxsIGBvbkNyZWF0ZWAgY2FsbGJhY2tcbiAgLy8gdGhlIG90aGVyIG9uZXMgd2lsbCBjYWxsIGBvblVwZGF0ZWAgY2FsbGJhY2tcbiAgaWYgKCF0aGlzLnN0YXRlLmlzQ3JlYXRlZCkge1xuICAgIHRoaXMuc3RhdGUuaXNDcmVhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLm9wdGlvbnMub25DcmVhdGUoZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5vcHRpb25zLm9uVXBkYXRlKGRhdGEpO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgaXMgZW5hYmxlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc01vZGlmaWVyRW5hYmxlZChtb2RpZmllcnMsIG1vZGlmaWVyTmFtZSkge1xuICByZXR1cm4gbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgZW5hYmxlZCA9IF9yZWYuZW5hYmxlZDtcbiAgICByZXR1cm4gZW5hYmxlZCAmJiBuYW1lID09PSBtb2RpZmllck5hbWU7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwcm9wZXJ0eSAoY2FtZWxDYXNlKVxuICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSBvciBQYXNjYWxDYXNlLCBkZXBlbmRpbmcgb24gdGhlIHZlbmRvciBwcmVmaXgpXG4gKi9cbmZ1bmN0aW9uIGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZShwcm9wZXJ0eSkge1xuICB2YXIgcHJlZml4ZXMgPSBbZmFsc2UsICdtcycsICdXZWJraXQnLCAnTW96JywgJ08nXTtcbiAgdmFyIHVwcGVyUHJvcCA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgdG9DaGVjayA9IHByZWZpeCA/ICcnICsgcHJlZml4ICsgdXBwZXJQcm9wIDogcHJvcGVydHk7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudC5ib2R5LnN0eWxlW3RvQ2hlY2tdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIERlc3Ryb3lzIHRoZSBwb3BwZXIuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5wb3NpdGlvbiA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmxlZnQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5yaWdodCA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLmJvdHRvbSA9ICcnO1xuICAgIHRoaXMucG9wcGVyLnN0eWxlLndpbGxDaGFuZ2UgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0bHkgYXNrZWQgZm9yIHRoZSBkZWxldGlvbiBvbiBkZXN0cm95XG4gIC8vIGRvIG5vdCB1c2UgYHJlbW92ZWAgYmVjYXVzZSBJRTExIGRvZXNuJ3Qgc3VwcG9ydCBpdFxuICBpZiAodGhpcy5vcHRpb25zLnJlbW92ZU9uRGVzdHJveSkge1xuICAgIHRoaXMucG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXIpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIEdldCB0aGUgd2luZG93IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudFxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7V2luZG93fVxuICovXG5mdW5jdGlvbiBnZXRXaW5kb3coZWxlbWVudCkge1xuICB2YXIgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogd2luZG93O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsUGFyZW50LCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpIHtcbiAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudC5ub2RlTmFtZSA9PT0gJ0JPRFknO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gc2Nyb2xsUGFyZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiBzY3JvbGxQYXJlbnQ7XG4gIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBjYWxsYmFjaywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIGlmICghaXNCb2R5KSB7XG4gICAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKGdldFNjcm9sbFBhcmVudCh0YXJnZXQucGFyZW50Tm9kZSksIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cyk7XG4gIH1cbiAgc2Nyb2xsUGFyZW50cy5wdXNoKHRhcmdldCk7XG59XG5cbi8qKlxuICogU2V0dXAgbmVlZGVkIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgb3B0aW9ucywgc3RhdGUsIHVwZGF0ZUJvdW5kKSB7XG4gIC8vIFJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgc3RhdGUudXBkYXRlQm91bmQgPSB1cGRhdGVCb3VuZDtcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICAvLyBTY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgdmFyIHNjcm9sbEVsZW1lbnQgPSBnZXRTY3JvbGxQYXJlbnQocmVmZXJlbmNlKTtcbiAgYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbEVsZW1lbnQsICdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCwgc3RhdGUuc2Nyb2xsUGFyZW50cyk7XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBzY3JvbGxFbGVtZW50O1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gdHJ1ZTtcblxuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCBhZGQgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHN0YXJ0IHJlY2FsY3VsYXRpbmdcbiAqIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIgZWxlbWVudCB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGlmICghdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgdGhpcy5zdGF0ZSA9IHNldHVwRXZlbnRMaXN0ZW5lcnModGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucywgdGhpcy5zdGF0ZSwgdGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXJzKHJlZmVyZW5jZSwgc3RhdGUpIHtcbiAgLy8gUmVtb3ZlIHJlc2l6ZSBldmVudCBsaXN0ZW5lciBvbiB3aW5kb3dcbiAgZ2V0V2luZG93KHJlZmVyZW5jZSkucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgc3RhdGUudXBkYXRlQm91bmQpO1xuXG4gIC8vIFJlbW92ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgb24gc2Nyb2xsIHBhcmVudHNcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQpO1xuICB9KTtcblxuICAvLyBSZXNldCBzdGF0ZVxuICBzdGF0ZS51cGRhdGVCb3VuZCA9IG51bGw7XG4gIHN0YXRlLnNjcm9sbFBhcmVudHMgPSBbXTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IG51bGw7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgcmVtb3ZlIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCB3b24ndCByZWNhbGN1bGF0ZSBwb3BwZXIgcG9zaXRpb25cbiAqIHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLiBJdCBhbHNvIHdvbid0IHRyaWdnZXIgYG9uVXBkYXRlYCBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFBvcHBlci5qcyBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGVPbkxvYWQocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgc3RhdGUpIHtcbiAgLy8gY29tcHV0ZSByZWZlcmVuY2UgZWxlbWVudCBvZmZzZXRzXG4gIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gY29tcHV0ZSBhdXRvIHBsYWNlbWVudCwgc3RvcmUgcGxhY2VtZW50IGluc2lkZSB0aGUgZGF0YSBvYmplY3QsXG4gIC8vIG1vZGlmaWVycyB3aWxsIGJlIGFibGUgdG8gZWRpdCBgcGxhY2VtZW50YCBpZiBuZWVkZWRcbiAgLy8gYW5kIHJlZmVyIHRvIG9yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gIHZhciBwbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudChvcHRpb25zLnBsYWNlbWVudCwgcmVmZXJlbmNlT2Zmc2V0cywgcG9wcGVyLCByZWZlcmVuY2UsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAuYm91bmRhcmllc0VsZW1lbnQsIG9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBwbGFjZW1lbnQpO1xuXG4gIC8vIEFwcGx5IGBwb3NpdGlvbmAgdG8gcG9wcGVyIGJlZm9yZSBhbnl0aGluZyBlbHNlIGJlY2F1c2VcbiAgLy8gd2l0aG91dCB0aGUgcG9zaXRpb24gYXBwbGllZCB3ZSBjYW4ndCBndWFyYW50ZWUgY29ycmVjdCBjb21wdXRhdGlvbnNcbiAgc2V0U3R5bGVzKHBvcHBlciwgeyBwb3NpdGlvbjogb3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZScgfSk7XG5cbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IHNob3VsZFJvdW5kIC0gSWYgdGhlIG9mZnNldHMgc2hvdWxkIGJlIHJvdW5kZWQgYXQgYWxsXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcG9wcGVyJ3MgcG9zaXRpb24gb2Zmc2V0cyByb3VuZGVkXG4gKlxuICogVGhlIHRhbGUgb2YgcGl4ZWwtcGVyZmVjdCBwb3NpdGlvbmluZy4gSXQncyBzdGlsbCBub3QgMTAwJSBwZXJmZWN0LCBidXQgYXNcbiAqIGdvb2QgYXMgaXQgY2FuIGJlIHdpdGhpbiByZWFzb24uXG4gKiBEaXNjdXNzaW9uIGhlcmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL3B1bGwvNzE1XG4gKlxuICogTG93IERQSSBzY3JlZW5zIGNhdXNlIGEgcG9wcGVyIHRvIGJlIGJsdXJyeSBpZiBub3QgdXNpbmcgZnVsbCBwaXhlbHMgKFNhZmFyaVxuICogYXMgd2VsbCBvbiBIaWdoIERQSSBzY3JlZW5zKS5cbiAqXG4gKiBGaXJlZm94IHByZWZlcnMgbm8gcm91bmRpbmcgZm9yIHBvc2l0aW9uaW5nIGFuZCBkb2VzIG5vdCBoYXZlIGJsdXJyaW5lc3Mgb25cbiAqIGhpZ2ggRFBJIHNjcmVlbnMuXG4gKlxuICogT25seSBob3Jpem9udGFsIHBsYWNlbWVudCBhbmQgbGVmdC9yaWdodCB2YWx1ZXMgbmVlZCB0byBiZSBjb25zaWRlcmVkLlxuICovXG5mdW5jdGlvbiBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCBzaG91bGRSb3VuZCkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQsXG4gICAgICBmbG9vciA9IE1hdGguZmxvb3I7XG5cbiAgdmFyIG5vUm91bmQgPSBmdW5jdGlvbiBub1JvdW5kKHYpIHtcbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICB2YXIgcmVmZXJlbmNlV2lkdGggPSByb3VuZChyZWZlcmVuY2Uud2lkdGgpO1xuICB2YXIgcG9wcGVyV2lkdGggPSByb3VuZChwb3BwZXIud2lkdGgpO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihkYXRhLnBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgaXNWYXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5pbmRleE9mKCctJykgIT09IC0xO1xuICB2YXIgc2FtZVdpZHRoUGFyaXR5ID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSBwb3BwZXJXaWR0aCAlIDI7XG4gIHZhciBib3RoT2RkV2lkdGggPSByZWZlcmVuY2VXaWR0aCAlIDIgPT09IDEgJiYgcG9wcGVyV2lkdGggJSAyID09PSAxO1xuXG4gIHZhciBob3Jpem9udGFsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IGlzVmVydGljYWwgfHwgaXNWYXJpYXRpb24gfHwgc2FtZVdpZHRoUGFyaXR5ID8gcm91bmQgOiBmbG9vcjtcbiAgdmFyIHZlcnRpY2FsVG9JbnRlZ2VyID0gIXNob3VsZFJvdW5kID8gbm9Sb3VuZCA6IHJvdW5kO1xuXG4gIHJldHVybiB7XG4gICAgbGVmdDogaG9yaXpvbnRhbFRvSW50ZWdlcihib3RoT2RkV2lkdGggJiYgIWlzVmFyaWF0aW9uICYmIHNob3VsZFJvdW5kID8gcG9wcGVyLmxlZnQgLSAxIDogcG9wcGVyLmxlZnQpLFxuICAgIHRvcDogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiB2ZXJ0aWNhbFRvSW50ZWdlcihwb3BwZXIuYm90dG9tKSxcbiAgICByaWdodDogaG9yaXpvbnRhbFRvSW50ZWdlcihwb3BwZXIucmlnaHQpXG4gIH07XG59XG5cbnZhciBpc0ZpcmVmb3ggPSBpc0Jyb3dzZXIgJiYgL0ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ2FwcGx5U3R5bGUnO1xuICB9KS5ncHVBY2NlbGVyYXRpb247XG4gIGlmIChsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGdwdUFjY2VsZXJhdGlvbmAgb3B0aW9uIG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyIGFuZCB3aWxsIG5vdCBiZSBzdXBwb3J0ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIFBvcHBlci5qcyEnKTtcbiAgfVxuICB2YXIgZ3B1QWNjZWxlcmF0aW9uID0gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQgPyBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gOiBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbjtcblxuICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcbiAgdmFyIG9mZnNldFBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAvLyBTdHlsZXNcbiAgdmFyIHN0eWxlcyA9IHtcbiAgICBwb3NpdGlvbjogcG9wcGVyLnBvc2l0aW9uXG4gIH07XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRSb3VuZGVkT2Zmc2V0cyhkYXRhLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA8IDIgfHwgIWlzRmlyZWZveCk7XG5cbiAgdmFyIHNpZGVBID0geCA9PT0gJ2JvdHRvbScgPyAndG9wJyA6ICdib3R0b20nO1xuICB2YXIgc2lkZUIgPSB5ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcblxuICAvLyBpZiBncHVBY2NlbGVyYXRpb24gaXMgc2V0IHRvIGB0cnVlYCBhbmQgdHJhbnNmb3JtIGlzIHN1cHBvcnRlZCxcbiAgLy8gIHdlIHVzZSBgdHJhbnNsYXRlM2RgIHRvIGFwcGx5IHRoZSBwb3NpdGlvbiB0byB0aGUgcG9wcGVyIHdlXG4gIC8vIGF1dG9tYXRpY2FsbHkgdXNlIHRoZSBzdXBwb3J0ZWQgcHJlZml4ZWQgdmVyc2lvbiBpZiBuZWVkZWRcbiAgdmFyIHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuXG4gIC8vIG5vdywgbGV0J3MgbWFrZSBhIHN0ZXAgYmFjayBhbmQgbG9vayBhdCB0aGlzIGNvZGUgY2xvc2VseSAod3RmPylcbiAgLy8gSWYgdGhlIGNvbnRlbnQgb2YgdGhlIHBvcHBlciBncm93cyBvbmNlIGl0J3MgYmVlbiBwb3NpdGlvbmVkLCBpdFxuICAvLyBtYXkgaGFwcGVuIHRoYXQgdGhlIHBvcHBlciBnZXRzIG1pc3BsYWNlZCBiZWNhdXNlIG9mIHRoZSBuZXcgY29udGVudFxuICAvLyBvdmVyZmxvd2luZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVG8gYXZvaWQgdGhpcyBwcm9ibGVtLCB3ZSBwcm92aWRlIHR3byBvcHRpb25zICh4IGFuZCB5KSwgd2hpY2ggYWxsb3dcbiAgLy8gdGhlIGNvbnN1bWVyIHRvIGRlZmluZSB0aGUgb2Zmc2V0IG9yaWdpbi5cbiAgLy8gSWYgd2UgcG9zaXRpb24gYSBwb3BwZXIgb24gdG9wIG9mIGEgcmVmZXJlbmNlIGVsZW1lbnQsIHdlIGNhbiBzZXRcbiAgLy8gYHhgIHRvIGB0b3BgIHRvIG1ha2UgdGhlIHBvcHBlciBncm93IHRvd2FyZHMgaXRzIHRvcCBpbnN0ZWFkIG9mXG4gIC8vIGl0cyBib3R0b20uXG4gIHZhciBsZWZ0ID0gdm9pZCAwLFxuICAgICAgdG9wID0gdm9pZCAwO1xuICBpZiAoc2lkZUEgPT09ICdib3R0b20nKSB7XG4gICAgLy8gd2hlbiBvZmZzZXRQYXJlbnQgaXMgPGh0bWw+IHRoZSBwb3NpdGlvbmluZyBpcyByZWxhdGl2ZSB0byB0aGUgYm90dG9tIG9mIHRoZSBzY3JlZW4gKGV4Y2x1ZGluZyB0aGUgc2Nyb2xsYmFyKVxuICAgIC8vIGFuZCBub3QgdGhlIGJvdHRvbSBvZiB0aGUgaHRtbCBlbGVtZW50XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCArIG9mZnNldHMuYm90dG9tO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gb2Zmc2V0cy50b3A7XG4gIH1cbiAgaWYgKHNpZGVCID09PSAncmlnaHQnKSB7XG4gICAgaWYgKG9mZnNldFBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudC5jbGllbnRXaWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSAtb2Zmc2V0UGFyZW50UmVjdC53aWR0aCArIG9mZnNldHMucmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kKG1vZGlmaWVycywgZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICByZXR1cm4gbmFtZSA9PT0gcmVxdWVzdGluZ05hbWU7XG4gIH0pO1xuXG4gIHZhciBpc1JlcXVpcmVkID0gISFyZXF1ZXN0aW5nICYmIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSByZXF1ZXN0ZWROYW1lICYmIG1vZGlmaWVyLmVuYWJsZWQgJiYgbW9kaWZpZXIub3JkZXIgPCByZXF1ZXN0aW5nLm9yZGVyO1xuICB9KTtcblxuICBpZiAoIWlzUmVxdWlyZWQpIHtcbiAgICB2YXIgX3JlcXVlc3RpbmcgPSAnYCcgKyByZXF1ZXN0aW5nTmFtZSArICdgJztcbiAgICB2YXIgcmVxdWVzdGVkID0gJ2AnICsgcmVxdWVzdGVkTmFtZSArICdgJztcbiAgICBjb25zb2xlLndhcm4ocmVxdWVzdGVkICsgJyBtb2RpZmllciBpcyByZXF1aXJlZCBieSAnICsgX3JlcXVlc3RpbmcgKyAnIG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgJyArIF9yZXF1ZXN0aW5nICsgJyEnKTtcbiAgfVxuICByZXR1cm4gaXNSZXF1aXJlZDtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGFycm93KGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMkYXJyb3c7XG5cbiAgLy8gYXJyb3cgZGVwZW5kcyBvbiBrZWVwVG9nZXRoZXIgaW4gb3JkZXIgdG8gd29ya1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2Fycm93JywgJ2tlZXBUb2dldGhlcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyb3dFbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBhIHN0cmluZywgc3VwcG9zZSBpdCdzIGEgQ1NTIHNlbGVjdG9yXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IGRhdGEuaW5zdGFuY2UucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcblxuICAgIC8vIGlmIGFycm93RWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGlmIHRoZSBhcnJvd0VsZW1lbnQgaXNuJ3QgYSBxdWVyeSBzZWxlY3RvciB3ZSBtdXN0IGNoZWNrIHRoYXQgdGhlXG4gICAgLy8gcHJvdmlkZWQgRE9NIG5vZGUgaXMgY2hpbGQgb2YgaXRzIHBvcHBlciBub2RlXG4gICAgaWYgKCFkYXRhLmluc3RhbmNlLnBvcHBlci5jb250YWlucyhhcnJvd0VsZW1lbnQpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvdy5lbGVtZW50YCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXIgZWxlbWVudCEnKTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzVmVydGljYWwgPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2lkZUNhcGl0YWxpemVkID0gaXNWZXJ0aWNhbCA/ICdUb3AnIDogJ0xlZnQnO1xuICB2YXIgc2lkZSA9IHNpZGVDYXBpdGFsaXplZC50b0xvd2VyQ2FzZSgpO1xuICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gIHZhciBhcnJvd0VsZW1lbnRTaXplID0gZ2V0T3V0ZXJTaXplcyhhcnJvd0VsZW1lbnQpW2xlbl07XG5cbiAgLy9cbiAgLy8gZXh0ZW5kcyBrZWVwVG9nZXRoZXIgYmVoYXZpb3IgbWFraW5nIHN1cmUgdGhlIHBvcHBlciBhbmQgaXRzXG4gIC8vIHJlZmVyZW5jZSBoYXZlIGVub3VnaCBwaXhlbHMgaW4gY29uanVuY3Rpb25cbiAgLy9cblxuICAvLyB0b3AvbGVmdCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUgPCBwb3BwZXJbc2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC09IHBvcHBlcltzaWRlXSAtIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93RWxlbWVudFNpemUpO1xuICB9XG4gIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplID4gcG9wcGVyW29wU2lkZV0pIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdICs9IHJlZmVyZW5jZVtzaWRlXSArIGFycm93RWxlbWVudFNpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgfVxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcblxuICAvLyBjb21wdXRlIGNlbnRlciBvZiB0aGUgcG9wcGVyXG4gIHZhciBjZW50ZXIgPSByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd0VsZW1lbnRTaXplIC8gMjtcblxuICAvLyBDb21wdXRlIHRoZSBzaWRlVmFsdWUgdXNpbmcgdGhlIHVwZGF0ZWQgcG9wcGVyIG9mZnNldHNcbiAgLy8gdGFrZSBwb3BwZXIgbWFyZ2luIGluIGFjY291bnQgYmVjYXVzZSB3ZSBkb24ndCBoYXZlIHRoaXMgaW5mbyBhdmFpbGFibGVcbiAgdmFyIGNzcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBwb3BwZXJNYXJnaW5TaWRlID0gcGFyc2VGbG9hdChjc3NbJ21hcmdpbicgKyBzaWRlQ2FwaXRhbGl6ZWRdKTtcbiAgdmFyIHBvcHBlckJvcmRlclNpZGUgPSBwYXJzZUZsb2F0KGNzc1snYm9yZGVyJyArIHNpZGVDYXBpdGFsaXplZCArICdXaWR0aCddKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tZW5kYCAob24gdGhlIHNpZGUgd2l0aCBtb3JlIHNwYWNlIGF2YWlsYWJsZSwgYWxpZ25tZW50IGRlcGVuZHMgYnkgcGxhY2VtZW50KVxuICpcbiAqIEBzdGF0aWNcbiAqIEB0eXBlIHtBcnJheX1cbiAqIEBlbnVtIHtTdHJpbmd9XG4gKiBAcmVhZG9ubHlcbiAqIEBtZXRob2QgcGxhY2VtZW50c1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgcGxhY2VtZW50cyA9IFsnYXV0by1zdGFydCcsICdhdXRvJywgJ2F1dG8tZW5kJywgJ3RvcC1zdGFydCcsICd0b3AnLCAndG9wLWVuZCcsICdyaWdodC1zdGFydCcsICdyaWdodCcsICdyaWdodC1lbmQnLCAnYm90dG9tLWVuZCcsICdib3R0b20nLCAnYm90dG9tLXN0YXJ0JywgJ2xlZnQtZW5kJywgJ2xlZnQnLCAnbGVmdC1zdGFydCddO1xuXG4vLyBHZXQgcmlkIG9mIGBhdXRvYCBgYXV0by1zdGFydGAgYW5kIGBhdXRvLWVuZGBcbnZhciB2YWxpZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLnNsaWNlKDMpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGluaXRpYWwgcGxhY2VtZW50LCByZXR1cm5zIGFsbCB0aGUgc3Vic2VxdWVudCBwbGFjZW1lbnRzXG4gKiBjbG9ja3dpc2UgKG9yIGNvdW50ZXItY2xvY2t3aXNlKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50IC0gQSB2YWxpZCBwbGFjZW1lbnQgKGl0IGFjY2VwdHMgdmFyaWF0aW9ucylcbiAqIEBhcmd1bWVudCB7Qm9vbGVhbn0gY291bnRlciAtIFNldCB0byB0cnVlIHRvIHdhbGsgdGhlIHBsYWNlbWVudHMgY291bnRlcmNsb2Nrd2lzZVxuICogQHJldHVybnMge0FycmF5fSBwbGFjZW1lbnRzIGluY2x1ZGluZyB0aGVpciB2YXJpYXRpb25zXG4gKi9cbmZ1bmN0aW9uIGNsb2Nrd2lzZShwbGFjZW1lbnQpIHtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gIHZhciBpbmRleCA9IHZhbGlkUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCk7XG4gIHZhciBhcnIgPSB2YWxpZFBsYWNlbWVudHMuc2xpY2UoaW5kZXggKyAxKS5jb25jYXQodmFsaWRQbGFjZW1lbnRzLnNsaWNlKDAsIGluZGV4KSk7XG4gIHJldHVybiBjb3VudGVyID8gYXJyLnJldmVyc2UoKSA6IGFycjtcbn1cblxudmFyIEJFSEFWSU9SUyA9IHtcbiAgRkxJUDogJ2ZsaXAnLFxuICBDTE9DS1dJU0U6ICdjbG9ja3dpc2UnLFxuICBDT1VOVEVSQ0xPQ0tXSVNFOiAnY291bnRlcmNsb2Nrd2lzZSdcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBmbGlwKGRhdGEsIG9wdGlvbnMpIHtcbiAgLy8gaWYgYGlubmVyYCBtb2RpZmllciBpcyBlbmFibGVkLCB3ZSBjYW4ndCB1c2UgdGhlIGBmbGlwYCBtb2RpZmllclxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdpbm5lcicpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICBpZiAoZGF0YS5mbGlwcGVkICYmIGRhdGEucGxhY2VtZW50ID09PSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgLy8gc2VlbXMgbGlrZSBmbGlwIGlzIHRyeWluZyB0byBsb29wLCBwcm9iYWJseSB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2Ugb24gYW55IG9mIHRoZSBmbGlwcGFibGUgc2lkZXNcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCwgZGF0YS5wb3NpdGlvbkZpeGVkKTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiByZWZlcmVuY2UgZWxlbWVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnMgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c0xlZnQgfHwgaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c1JpZ2h0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NUb3AgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NCb3R0b20pO1xuXG4gICAgLy8gZmxpcHMgdmFyaWF0aW9uIGlmIHBvcHBlciBjb250ZW50IG92ZXJmbG93cyBib3VuZGFyaWVzXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQgPSAhIW9wdGlvbnMuZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQgJiYgKGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1JpZ2h0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NMZWZ0IHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NCb3R0b20gfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NUb3ApO1xuXG4gICAgdmFyIGZsaXBwZWRWYXJpYXRpb24gPSBmbGlwcGVkVmFyaWF0aW9uQnlSZWYgfHwgZmxpcHBlZFZhcmlhdGlvbkJ5Q29udGVudDtcblxuICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzIHx8IGZsaXBwZWRWYXJpYXRpb24pIHtcbiAgICAgIC8vIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgZGF0YS5mbGlwcGVkID0gdHJ1ZTtcblxuICAgICAgaWYgKG92ZXJsYXBzUmVmIHx8IG92ZXJmbG93c0JvdW5kYXJpZXMpIHtcbiAgICAgICAgcGxhY2VtZW50ID0gZmxpcE9yZGVyW2luZGV4ICsgMV07XG4gICAgICB9XG5cbiAgICAgIGlmIChmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAgIHZhcmlhdGlvbiA9IGdldE9wcG9zaXRlVmFyaWF0aW9uKHZhcmlhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGRhdGEucGxhY2VtZW50ID0gcGxhY2VtZW50ICsgKHZhcmlhdGlvbiA/ICctJyArIHZhcmlhdGlvbiA6ICcnKTtcblxuICAgICAgLy8gdGhpcyBvYmplY3QgY29udGFpbnMgYHBvc2l0aW9uYCwgd2Ugd2FudCB0byBwcmVzZXJ2ZSBpdCBhbG9uZyB3aXRoXG4gICAgICAvLyBhbnkgYWRkaXRpb25hbCBwcm9wZXJ0eSB3ZSBtYXkgYWRkIGluIHRoZSBmdXR1cmVcbiAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLnBvcHBlciwgZ2V0UG9wcGVyT2Zmc2V0cyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5vZmZzZXRzLnJlZmVyZW5jZSwgZGF0YS5wbGFjZW1lbnQpKTtcblxuICAgICAgZGF0YSA9IHJ1bk1vZGlmaWVycyhkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZGF0YSwgJ2ZsaXAnKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGtlZXBUb2dldGhlcihkYXRhKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgdmFyIGlzVmVydGljYWwgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAncmlnaHQnIDogJ2JvdHRvbSc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgaWYgKHBvcHBlcltzaWRlXSA8IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtvcFNpZGVdKSAtIHBvcHBlclttZWFzdXJlbWVudF07XG4gIH1cbiAgaWYgKHBvcHBlcltvcFNpZGVdID4gZmxvb3IocmVmZXJlbmNlW3NpZGVdKSkge1xuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXJbb3BTaWRlXSA9IGZsb29yKHJlZmVyZW5jZVtzaWRlXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHN0cmluZyBjb250YWluaW5nIHZhbHVlICsgdW5pdCBpbnRvIGEgcHggdmFsdWUgbnVtYmVyXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gc3RyIC0gVmFsdWUgKyB1bml0IHN0cmluZ1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IG1lYXN1cmVtZW50IC0gYGhlaWdodGAgb3IgYHdpZHRoYFxuICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzXG4gKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ31cbiAqIFZhbHVlIGluIHBpeGVscywgb3Igb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHZhbHVlcyB3ZXJlIGV4dHJhY3RlZFxuICovXG5mdW5jdGlvbiB0b1ZhbHVlKHN0ciwgbWVhc3VyZW1lbnQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMpIHtcbiAgLy8gc2VwYXJhdGUgdmFsdWUgZnJvbSB1bml0XG4gIHZhciBzcGxpdCA9IHN0ci5tYXRjaCgvKCg/OlxcLXxcXCspP1xcZCpcXC4/XFxkKikoLiopLyk7XG4gIHZhciB2YWx1ZSA9ICtzcGxpdFsxXTtcbiAgdmFyIHVuaXQgPSBzcGxpdFsyXTtcblxuICAvLyBJZiBpdCdzIG5vdCBhIG51bWJlciBpdCdzIGFuIG9wZXJhdG9yLCBJIGd1ZXNzXG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgaWYgKHVuaXQuaW5kZXhPZignJScpID09PSAwKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB2b2lkIDA7XG4gICAgc3dpdGNoICh1bml0KSB7XG4gICAgICBjYXNlICclcCc6XG4gICAgICAgIGVsZW1lbnQgPSBwb3BwZXJPZmZzZXRzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJyUnOlxuICAgICAgY2FzZSAnJXInOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZWxlbWVudCA9IHJlZmVyZW5jZU9mZnNldHM7XG4gICAgfVxuXG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0KGVsZW1lbnQpO1xuICAgIHJldHVybiByZWN0W21lYXN1cmVtZW50XSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2UgaWYgKHVuaXQgPT09ICd2aCcgfHwgdW5pdCA9PT0gJ3Z3Jykge1xuICAgIC8vIGlmIGlzIGEgdmggb3IgdncsIHdlIGNhbGN1bGF0ZSB0aGUgc2l6ZSBiYXNlZCBvbiB0aGUgdmlld3BvcnRcbiAgICB2YXIgc2l6ZSA9IHZvaWQgMDtcbiAgICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2l6ZSA9IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCwgd2luZG93LmlubmVyV2lkdGggfHwgMCk7XG4gICAgfVxuICAgIHJldHVybiBzaXplIC8gMTAwICogdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgaXMgYW4gZXhwbGljaXQgcGl4ZWwgdW5pdCwgd2UgZ2V0IHJpZCBvZiB0aGUgdW5pdCBhbmQga2VlcCB0aGUgdmFsdWVcbiAgICAvLyBpZiBpcyBhbiBpbXBsaWNpdCB1bml0LCBpdCdzIHB4LCBhbmQgd2UgcmV0dXJuIGp1c3QgdGhlIHZhbHVlXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgYW4gYG9mZnNldGAgc3RyaW5nIHRvIGV4dHJhcG9sYXRlIGB4YCBhbmQgYHlgIG51bWVyaWMgb2Zmc2V0cy5cbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIHttb2RpZmllcnN+b2Zmc2V0fVxuICogQHByaXZhdGVcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBvZmZzZXRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IGJhc2VQbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtBcnJheX0gYSB0d28gY2VsbHMgYXJyYXkgd2l0aCB4IGFuZCB5IG9mZnNldHMgaW4gbnVtYmVyc1xuICovXG5mdW5jdGlvbiBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlck9mZnNldHMsIHJlZmVyZW5jZU9mZnNldHMsIGJhc2VQbGFjZW1lbnQpIHtcbiAgdmFyIG9mZnNldHMgPSBbMCwgMF07XG5cbiAgLy8gVXNlIGhlaWdodCBpZiBwbGFjZW1lbnQgaXMgbGVmdCBvciByaWdodCBhbmQgaW5kZXggaXMgMCBvdGhlcndpc2UgdXNlIHdpZHRoXG4gIC8vIGluIHRoaXMgd2F5IHRoZSBmaXJzdCBvZmZzZXQgd2lsbCB1c2UgYW4gYXhpcyBhbmQgdGhlIHNlY29uZCBvbmVcbiAgLy8gd2lsbCB1c2UgdGhlIG90aGVyIG9uZVxuICB2YXIgdXNlSGVpZ2h0ID0gWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgLy8gU3BsaXQgdGhlIG9mZnNldCBzdHJpbmcgdG8gb2J0YWluIGEgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzXG4gIC8vIFRoZSByZWdleCBhZGRyZXNzZXMgdmFsdWVzIHdpdGggdGhlIHBsdXMgb3IgbWludXMgc2lnbiBpbiBmcm9udCAoKzEwLCAtMjAsIGV0YylcbiAgdmFyIGZyYWdtZW50cyA9IG9mZnNldC5zcGxpdCgvKFxcK3xcXC0pLykubWFwKGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcudHJpbSgpO1xuICB9KTtcblxuICAvLyBEZXRlY3QgaWYgdGhlIG9mZnNldCBzdHJpbmcgY29udGFpbnMgYSBwYWlyIG9mIHZhbHVlcyBvciBhIHNpbmdsZSBvbmVcbiAgLy8gdGhleSBjb3VsZCBiZSBzZXBhcmF0ZWQgYnkgY29tbWEgb3Igc3BhY2VcbiAgdmFyIGRpdmlkZXIgPSBmcmFnbWVudHMuaW5kZXhPZihmaW5kKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc2V0cyB0aGUgcG9wcGVyJ3MgcG9zaXRpb24gc28gdGhhdCB0aGUgZG9jdW1lbnQgc2l6ZSBjYW4gYmUgY2FsY3VsYXRlZCBleGNsdWRpbmdcbiAgLy8gdGhlIHNpemUgb2YgdGhlIHBvcHBlciBlbGVtZW50IGl0c2VsZlxuICB2YXIgdHJhbnNmb3JtUHJvcCA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG4gIHZhciBwb3BwZXJTdHlsZXMgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5zdHlsZTsgLy8gYXNzaWdubWVudCB0byBoZWxwIG1pbmlmaWNhdGlvblxuICB2YXIgdG9wID0gcG9wcGVyU3R5bGVzLnRvcCxcbiAgICAgIGxlZnQgPSBwb3BwZXJTdHlsZXMubGVmdCxcbiAgICAgIHRyYW5zZm9ybSA9IHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXTtcblxuICBwb3BwZXJTdHlsZXMudG9wID0gJyc7XG4gIHBvcHBlclN0eWxlcy5sZWZ0ID0gJyc7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9ICcnO1xuXG4gIHZhciBib3VuZGFyaWVzID0gZ2V0Qm91bmRhcmllcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UsIG9wdGlvbnMucGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgLy8gTk9URTogRE9NIGFjY2VzcyBoZXJlXG4gIC8vIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBzdHlsZSBwcm9wZXJ0aWVzIGFmdGVyIHRoZSBvZmZzZXRzIGhhdmUgYmVlbiBjb21wdXRlZFxuICBwb3BwZXJTdHlsZXMudG9wID0gdG9wO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9IGxlZnQ7XG4gIHBvcHBlclN0eWxlc1t0cmFuc2Zvcm1Qcm9wXSA9IHRyYW5zZm9ybTtcblxuICBvcHRpb25zLmJvdW5kYXJpZXMgPSBib3VuZGFyaWVzO1xuXG4gIHZhciBvcmRlciA9IG9wdGlvbnMucHJpb3JpdHk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIHZhciBjaGVjayA9IHtcbiAgICBwcmltYXJ5OiBmdW5jdGlvbiBwcmltYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW3BsYWNlbWVudF07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPCBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KHBvcHBlcltwbGFjZW1lbnRdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBwbGFjZW1lbnQsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNlY29uZGFyeTogZnVuY3Rpb24gc2Vjb25kYXJ5KHBsYWNlbWVudCkge1xuICAgICAgdmFyIG1haW5TaWRlID0gcGxhY2VtZW50ID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbbWFpblNpZGVdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdID4gYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihwb3BwZXJbbWFpblNpZGVdLCBib3VuZGFyaWVzW3BsYWNlbWVudF0gLSAocGxhY2VtZW50ID09PSAncmlnaHQnID8gcG9wcGVyLndpZHRoIDogcG9wcGVyLmhlaWdodCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlZmluZVByb3BlcnR5KHt9LCBtYWluU2lkZSwgdmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICB2YXIgc2lkZSA9IFsnbGVmdCcsICd0b3AnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xID8gJ3ByaW1hcnknIDogJ3NlY29uZGFyeSc7XG4gICAgcG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgY2hlY2tbc2lkZV0ocGxhY2VtZW50KSk7XG4gIH0pO1xuXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBwb3BwZXI7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHNoaWZ0KGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgc2hpZnR2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAvLyBpZiBzaGlmdCBzaGlmdHZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgaWYgKHNoaWZ0dmFyaWF0aW9uKSB7XG4gICAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcjtcblxuICAgIHZhciBpc1ZlcnRpY2FsID0gWydib3R0b20nLCAndG9wJ10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSAhPT0gLTE7XG4gICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcblxuICAgIHZhciBzaGlmdE9mZnNldHMgPSB7XG4gICAgICBzdGFydDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSksXG4gICAgICBlbmQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0gKyByZWZlcmVuY2VbbWVhc3VyZW1lbnRdIC0gcG9wcGVyW21lYXN1cmVtZW50XSlcbiAgICB9O1xuXG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIHNoaWZ0T2Zmc2V0c1tzaGlmdHZhcmlhdGlvbl0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBoaWRlKGRhdGEpIHtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdoaWRlJywgJ3ByZXZlbnRPdmVyZmxvdycpKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgcmVmUmVjdCA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gIHZhciBib3VuZCA9IGZpbmQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAncHJldmVudE92ZXJmbG93JztcbiAgfSkuYm91bmRhcmllcztcblxuICBpZiAocmVmUmVjdC5ib3R0b20gPCBib3VuZC50b3AgfHwgcmVmUmVjdC5sZWZ0ID4gYm91bmQucmlnaHQgfHwgcmVmUmVjdC50b3AgPiBib3VuZC5ib3R0b20gfHwgcmVmUmVjdC5yaWdodCA8IGJvdW5kLmxlZnQpIHtcbiAgICAvLyBBdm9pZCB1bm5lY2Vzc2FyeSBET00gYWNjZXNzIGlmIHZpc2liaWxpdHkgaGFzbid0IGNoYW5nZWRcbiAgICBpZiAoZGF0YS5oaWRlID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSB0cnVlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gJyc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIGRhdGEuaGlkZSA9IGZhbHNlO1xuICAgIGRhdGEuYXR0cmlidXRlc1sneC1vdXQtb2YtYm91bmRhcmllcyddID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaW5uZXIoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNIb3JpeiA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIHZhciBzdWJ0cmFjdExlbmd0aCA9IFsndG9wJywgJ2xlZnQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID09PSAtMTtcblxuICBwb3BwZXJbaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnXSA9IHJlZmVyZW5jZVtiYXNlUGxhY2VtZW50XSAtIChzdWJ0cmFjdExlbmd0aCA/IHBvcHBlcltpc0hvcml6ID8gJ3dpZHRoJyA6ICdoZWlnaHQnXSA6IDApO1xuXG4gIGRhdGEucGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QocG9wcGVyKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNb2RpZmllciBmdW5jdGlvbiwgZWFjaCBtb2RpZmllciBjYW4gaGF2ZSBhIGZ1bmN0aW9uIG9mIHRoaXMgdHlwZSBhc3NpZ25lZFxuICogdG8gaXRzIGBmbmAgcHJvcGVydHkuPGJyIC8+XG4gKiBUaGVzZSBmdW5jdGlvbnMgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCB1cGRhdGUsIHRoaXMgbWVhbnMgdGhhdCB5b3UgbXVzdFxuICogbWFrZSBzdXJlIHRoZXkgYXJlIHBlcmZvcm1hbnQgZW5vdWdoIHRvIGF2b2lkIHBlcmZvcm1hbmNlIGJvdHRsZW5lY2tzLlxuICpcbiAqIEBmdW5jdGlvbiBNb2RpZmllckZuXG4gKiBAYXJndW1lbnQge2RhdGFPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge2RhdGFPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuXG4vKipcbiAqIE1vZGlmaWVycyBhcmUgcGx1Z2lucyB1c2VkIHRvIGFsdGVyIHRoZSBiZWhhdmlvciBvZiB5b3VyIHBvcHBlcnMuPGJyIC8+XG4gKiBQb3BwZXIuanMgdXNlcyBhIHNldCBvZiA5IG1vZGlmaWVycyB0byBwcm92aWRlIGFsbCB0aGUgYmFzaWMgZnVuY3Rpb25hbGl0aWVzXG4gKiBuZWVkZWQgYnkgdGhlIGxpYnJhcnkuXG4gKlxuICogVXN1YWxseSB5b3UgZG9uJ3Qgd2FudCB0byBvdmVycmlkZSB0aGUgYG9yZGVyYCwgYGZuYCBhbmQgYG9uTG9hZGAgcHJvcHMuXG4gKiBBbGwgdGhlIG90aGVyIHByb3BlcnRpZXMgYXJlIGNvbmZpZ3VyYXRpb25zIHRoYXQgY291bGQgYmUgdHdlYWtlZC5cbiAqIEBuYW1lc3BhY2UgbW9kaWZpZXJzXG4gKi9cbnZhciBtb2RpZmllcnMgPSB7XG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHN0YXJ0IG9yIGVuZCBvZiBpdHMgcmVmZXJlbmNlXG4gICAqIGVsZW1lbnQuPGJyIC8+XG4gICAqIEl0IHdpbGwgcmVhZCB0aGUgdmFyaWF0aW9uIG9mIHRoZSBgcGxhY2VtZW50YCBwcm9wZXJ0eS48YnIgLz5cbiAgICogSXQgY2FuIGJlIG9uZSBlaXRoZXIgYC1lbmRgIG9yIGAtc3RhcnRgLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgc2hpZnQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAxMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBzaGlmdFxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYG9mZnNldGAgbW9kaWZpZXIgY2FuIHNoaWZ0IHlvdXIgcG9wcGVyIG9uIGJvdGggaXRzIGF4aXMuXG4gICAqXG4gICAqIEl0IGFjY2VwdHMgdGhlIGZvbGxvd2luZyB1bml0czpcbiAgICogLSBgcHhgIG9yIHVuaXQtbGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgYGhlaWdodGAuXG4gICAqXG4gICAqIFlvdSBjYW4gcHJvdmlkZSBhIHNpbmdsZSB2YWx1ZSAoYXMgYE51bWJlcmAgb3IgYFN0cmluZ2ApLCBvciBhIHBhaXIgb2YgdmFsdWVzXG4gICAqIGFzIGBTdHJpbmdgIGRpdmlkZWQgYnkgYSBjb21tYSBvciBvbmUgKG9yIG1vcmUpIHdoaXRlIHNwYWNlcy48YnIgLz5cbiAgICogVGhlIGxhdHRlciBpcyBhIGRlcHJlY2F0ZWQgbWV0aG9kIGJlY2F1c2UgaXQgbGVhZHMgdG8gY29uZnVzaW9uIGFuZCB3aWxsIGJlXG4gICAqIHJlbW92ZWQgaW4gdjIuPGJyIC8+XG4gICAqIEFkZGl0aW9uYWxseSwgaXQgYWNjZXB0cyBhZGRpdGlvbnMgYW5kIHN1YnRyYWN0aW9ucyBiZXR3ZWVuIGRpZmZlcmVudCB1bml0cy5cbiAgICogTm90ZSB0aGF0IG11bHRpcGxpY2F0aW9ucyBhbmQgZGl2aXNpb25zIGFyZW4ndCBzdXBwb3J0ZWQuXG4gICAqXG4gICAqIFZhbGlkIGV4YW1wbGVzIGFyZTpcbiAgICogYGBgXG4gICAqIDEwXG4gICAqICcxMCUnXG4gICAqICcxMCwgMTAnXG4gICAqICcxMCUsIDEwJ1xuICAgKiAnMTAgKyAxMCUnXG4gICAqICcxMCAtIDV2aCArIDMlJ1xuICAgKiAnLTEwcHggKyA1dmgsIDVweCAtIDYlJ1xuICAgKiBgYGBcbiAgICogPiAqKk5CKio6IElmIHlvdSBkZXNpcmUgdG8gYXBwbHkgb2Zmc2V0cyB0byB5b3VyIHBvcHBlcnMgaW4gYSB3YXkgdGhhdCBtYXkgbWFrZSB0aGVtIG92ZXJsYXBcbiAgICogPiB3aXRoIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50LCB1bmZvcnR1bmF0ZWx5LCB5b3Ugd2lsbCBoYXZlIHRvIGRpc2FibGUgdGhlIGBmbGlwYCBtb2RpZmllci5cbiAgICogPiBZb3UgY2FuIHJlYWQgbW9yZSBvbiB0aGlzIGF0IHRoaXMgW2lzc3VlXShodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9pc3N1ZXMvMzczKS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIG9mZnNldDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0yMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDIwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IG9mZnNldCxcbiAgICAvKiogQHByb3Age051bWJlcnxTdHJpbmd9IG9mZnNldD0wXG4gICAgICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gICAgICovXG4gICAgb2Zmc2V0OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gcHJldmVudCB0aGUgcG9wcGVyIGZyb20gYmVpbmcgcG9zaXRpb25lZCBvdXRzaWRlIHRoZSBib3VuZGFyeS5cbiAgICpcbiAgICogQSBzY2VuYXJpbyBleGlzdHMgd2hlcmUgdGhlIHJlZmVyZW5jZSBpdHNlbGYgaXMgbm90IHdpdGhpbiB0aGUgYm91bmRhcmllcy48YnIgLz5cbiAgICogV2UgY2FuIHNheSBpdCBoYXMgXCJlc2NhcGVkIHRoZSBib3VuZGFyaWVzXCIg4oCUIG9yIGp1c3QgXCJlc2NhcGVkXCIuPGJyIC8+XG4gICAqIEluIHRoaXMgY2FzZSB3ZSBuZWVkIHRvIGRlY2lkZSB3aGV0aGVyIHRoZSBwb3BwZXIgc2hvdWxkIGVpdGhlcjpcbiAgICpcbiAgICogLSBkZXRhY2ggZnJvbSB0aGUgcmVmZXJlbmNlIGFuZCByZW1haW4gXCJ0cmFwcGVkXCIgaW4gdGhlIGJvdW5kYXJpZXMsIG9yXG4gICAqIC0gaWYgaXQgc2hvdWxkIGlnbm9yZSB0aGUgYm91bmRhcnkgYW5kIFwiZXNjYXBlIHdpdGggaXRzIHJlZmVyZW5jZVwiXG4gICAqXG4gICAqIFdoZW4gYGVzY2FwZVdpdGhSZWZlcmVuY2VgIGlzIHNldCB0b2B0cnVlYCBhbmQgcmVmZXJlbmNlIGlzIGNvbXBsZXRlbHlcbiAgICogb3V0c2lkZSBpdHMgYm91bmRhcmllcywgdGhlIHBvcHBlciB3aWxsIG92ZXJmbG93IChvciBjb21wbGV0ZWx5IGxlYXZlKVxuICAgKiB0aGUgYm91bmRhcmllcyBpbiBvcmRlciB0byByZW1haW4gYXR0YWNoZWQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHByZXZlbnRPdmVyZmxvdzoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj0zMDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDMwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7QXJyYXl9IFtwcmlvcml0eT1bJ2xlZnQnLCdyaWdodCcsJ3RvcCcsJ2JvdHRvbSddXVxuICAgICAqIFBvcHBlciB3aWxsIHRyeSB0byBwcmV2ZW50IG92ZXJmbG93IGZvbGxvd2luZyB0aGVzZSBwcmlvcml0aWVzIGJ5IGRlZmF1bHQsXG4gICAgICogdGhlbiwgaXQgY291bGQgb3ZlcmZsb3cgb24gdGhlIGxlZnQgYW5kIG9uIHRvcCBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHByaW9yaXR5OiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtudW1iZXJ9IHBhZGRpbmc9NVxuICAgICAqIEFtb3VudCBvZiBwaXhlbCB1c2VkIHRvIGRlZmluZSBhIG1pbmltdW0gZGlzdGFuY2UgYmV0d2VlbiB0aGUgYm91bmRhcmllc1xuICAgICAqIGFuZCB0aGUgcG9wcGVyLiBUaGlzIG1ha2VzIHN1cmUgdGhlIHBvcHBlciBhbHdheXMgaGFzIGEgbGl0dGxlIHBhZGRpbmdcbiAgICAgKiBiZXR3ZWVuIHRoZSBlZGdlcyBvZiBpdHMgY29udGFpbmVyXG4gICAgICovXG4gICAgcGFkZGluZzogNSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7U3RyaW5nfEhUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudD0nc2Nyb2xsUGFyZW50J1xuICAgICAqIEJvdW5kYXJpZXMgdXNlZCBieSB0aGUgbW9kaWZpZXIuIENhbiBiZSBgc2Nyb2xsUGFyZW50YCwgYHdpbmRvd2AsXG4gICAgICogYHZpZXdwb3J0YCBvciBhbnkgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICdzY3JvbGxQYXJlbnQnXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSByZWZlcmVuY2UgYW5kIGl0cyBwb3BwZXIgc3RheSBuZWFyIGVhY2ggb3RoZXJcbiAgICogd2l0aG91dCBsZWF2aW5nIGFueSBnYXAgYmV0d2VlbiB0aGUgdHdvLiBFc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIHRoZSBhcnJvdyBpc1xuICAgKiBlbmFibGVkIGFuZCB5b3Ugd2FudCB0byBlbnN1cmUgdGhhdCBpdCBwb2ludHMgdG8gaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBJdCBjYXJlcyBvbmx5IGFib3V0IHRoZSBmaXJzdCBheGlzLiBZb3UgY2FuIHN0aWxsIGhhdmUgcG9wcGVycyB3aXRoIG1hcmdpblxuICAgKiBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGtlZXBUb2dldGhlcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj00MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDQwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGtlZXBUb2dldGhlclxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1vZGlmaWVyIGlzIHVzZWQgdG8gbW92ZSB0aGUgYGFycm93RWxlbWVudGAgb2YgdGhlIHBvcHBlciB0byBtYWtlXG4gICAqIHN1cmUgaXQgaXMgcG9zaXRpb25lZCBiZXR3ZWVuIHRoZSByZWZlcmVuY2UgZWxlbWVudCBhbmQgaXRzIHBvcHBlciBlbGVtZW50LlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIG91dGVyIHNpemUgb2YgdGhlIGBhcnJvd0VsZW1lbnRgIG5vZGUgdG8gZGV0ZWN0IGhvdyBtYW55XG4gICAqIHBpeGVscyBvZiBjb25qdW5jdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpXG4gICAgICovXG4gICAgYmVoYXZpb3I6ICdmbGlwJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgZmxpcCBpZiBpdCBoaXRzIHRoZSBlZGdlcyBvZiB0aGUgYGJvdW5kYXJpZXNFbGVtZW50YFxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J1xuICAgICAqIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24uXG4gICAgICogVGhlIHBvcHBlciB3aWxsIG5ldmVyIGJlIHBsYWNlZCBvdXRzaWRlIG9mIHRoZSBkZWZpbmVkIGJvdW5kYXJpZXNcbiAgICAgKiAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICovXG4gICAgYm91bmRhcmllc0VsZW1lbnQ6ICd2aWV3cG9ydCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGZsaXBWYXJpYXRpb25zPWZhbHNlXG4gICAgICogVGhlIHBvcHBlciB3aWxsIHN3aXRjaCBwbGFjZW1lbnQgdmFyaWF0aW9uIGJldHdlZW4gYC1zdGFydGAgYW5kIGAtZW5kYCB3aGVuXG4gICAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50IG92ZXJsYXBzIGl0cyBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnM6IGZhbHNlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9uc0J5Q29udGVudD1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSBwb3BwZXIgZWxlbWVudCBvdmVybGFwcyBpdHMgcmVmZXJlbmNlIGJvdW5kYXJpZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3JpZ2luYWwgcGxhY2VtZW50IHNob3VsZCBoYXZlIGEgc2V0IHZhcmlhdGlvbi5cbiAgICAgKi9cbiAgICBmbGlwVmFyaWF0aW9uc0J5Q29udGVudDogZmFsc2VcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBtYWtlIHRoZSBwb3BwZXIgZmxvdyB0b3dhcmQgdGhlIGlubmVyIG9mIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQnkgZGVmYXVsdCwgd2hlbiB0aGlzIG1vZGlmaWVyIGlzIGRpc2FibGVkLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIG91dHNpZGVcbiAgICogdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaW5uZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA3MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPWZhbHNlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiBmYWxzZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGlubmVyXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gaGlkZSB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dHNpZGUgb2YgdGhlXG4gICAqIHBvcHBlciBib3VuZGFyaWVzLiBJdCB3aWxsIHNldCBhIGB4LW91dC1vZi1ib3VuZGFyaWVzYCBhdHRyaWJ1dGUgd2hpY2ggY2FuXG4gICAqIGJlIHVzZWQgdG8gaGlkZSB3aXRoIGEgQ1NTIHNlbGVjdG9yIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGlzXG4gICAqIG91dCBvZiBib3VuZGFyaWVzLlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBoaWRlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTgwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaGlkZVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgc3R5bGUgdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBlbGVtZW50IHRvIGdldHNcbiAgICogcHJvcGVybHkgcG9zaXRpb25lZC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgbW9kaWZpZXIgd2lsbCBub3QgdG91Y2ggdGhlIERPTSwgaXQganVzdCBwcmVwYXJlcyB0aGUgc3R5bGVzXG4gICAqIHNvIHRoYXQgYGFwcGx5U3R5bGVgIG1vZGlmaWVyIGNhbiBhcHBseSBpdC4gVGhpcyBzZXBhcmF0aW9uIGlzIHVzZWZ1bFxuICAgKiBpbiBjYXNlIHlvdSBuZWVkIHRvIHJlcGxhY2UgYGFwcGx5U3R5bGVgIHdpdGggYSBjdXN0b20gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIFRoaXMgbW9kaWZpZXIgaGFzIGA4NTBgIGFzIGBvcmRlcmAgdmFsdWUgdG8gbWFpbnRhaW4gYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgKiB3aXRoIHByZXZpb3VzIHZlcnNpb25zIG9mIFBvcHBlci5qcy4gRXhwZWN0IHRoZSBtb2RpZmllcnMgb3JkZXJpbmcgbWV0aG9kXG4gICAqIHRvIGNoYW5nZSBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBjb21wdXRlU3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODUwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4NTAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBjb21wdXRlU3R5bGUsXG4gICAgLyoqXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNEIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdXIgb3duIHRvIGFjaGlldmUgdGhlIGRlc2lyZWQgZWZmZWN0LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXBwbHlTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj05MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDkwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGFwcGx5U3R5bGUsXG4gICAgLyoqIEBwcm9wIHtGdW5jdGlvbn0gKi9cbiAgICBvbkxvYWQ6IGFwcGx5U3R5bGVPbkxvYWQsXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiAxLjEwLjAsIHRoZSBwcm9wZXJ0eSBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllclxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9uIHVzZWQgYnkgUG9wcGVyLmpzLlxuICogVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIG1vZGlmaWVycyBhbmQgdG8gdGhlIGBvbkNyZWF0ZWAgYW5kIGBvblVwZGF0ZWAgY2FsbGJhY2tzLlxuICogQG5hbWUgZGF0YU9iamVjdFxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuaW5zdGFuY2UgVGhlIFBvcHBlci5qcyBpbnN0YW5jZVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEucGxhY2VtZW50IFBsYWNlbWVudCBhcHBsaWVkIHRvIHBvcHBlclxuICogQHByb3BlcnR5IHtTdHJpbmd9IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgUGxhY2VtZW50IG9yaWdpbmFsbHkgZGVmaW5lZCBvbiBpbml0XG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuZmxpcHBlZCBUcnVlIGlmIHBvcHBlciBoYXMgYmVlbiBmbGlwcGVkIGJ5IGZsaXAgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gZGF0YS5oaWRlIFRydWUgaWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIG91dCBvZiBib3VuZGFyaWVzLCB1c2VmdWwgdG8ga25vdyB3aGVuIHRvIGhpZGUgdGhlIHBvcHBlclxuICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gZGF0YS5hcnJvd0VsZW1lbnQgTm9kZSB1c2VkIGFzIGFycm93IGJ5IGFycm93IG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5zdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5hcnJvd1N0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciBhcnJvdy4gSXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmJvdW5kYXJpZXMgT2Zmc2V0cyBvZiB0aGUgcG9wcGVyIGJvdW5kYXJpZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMgVGhlIG1lYXN1cmVtZW50cyBvZiBwb3BwZXIsIHJlZmVyZW5jZSBhbmQgYXJyb3cgZWxlbWVudHNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRkZW4gdXNpbmcgdGhlIGBvcHRpb25zYCBhcmd1bWVudCBvZiBQb3BwZXIuanMuPGJyIC8+XG4gKiBUbyBvdmVycmlkZSBhbiBvcHRpb24sIHNpbXBseSBwYXNzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIGBvcHRpb25zYCBvYmplY3QsIGFzIHRoZSAzcmQgYXJndW1lbnQuIEZvciBleGFtcGxlOlxuICogYGBgXG4gKiBuZXcgUG9wcGVyKHJlZiwgcG9wLCB7XG4gKiAgIG1vZGlmaWVyczoge1xuICogICAgIHByZXZlbnRPdmVyZmxvdzogeyBlbmFibGVkOiBmYWxzZSB9XG4gKiAgIH1cbiAqIH0pXG4gKiBgYGBcbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBEZWZhdWx0cyA9IHtcbiAgLyoqXG4gICAqIFBvcHBlcidzIHBsYWNlbWVudC5cbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFNldCB0aGlzIHRvIHRydWUgaWYgeW91IHdhbnQgcG9wcGVyIHRvIHBvc2l0aW9uIGl0IHNlbGYgaW4gJ2ZpeGVkJyBtb2RlXG4gICAqIEBwcm9wIHtCb29sZWFufSBwb3NpdGlvbkZpeGVkPWZhbHNlXG4gICAqL1xuICBwb3NpdGlvbkZpeGVkOiBmYWxzZSxcblxuICAvKipcbiAgICogV2hldGhlciBldmVudHMgKHJlc2l6ZSwgc2Nyb2xsKSBhcmUgaW5pdGlhbGx5IGVuYWJsZWQuXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQuIFRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpdCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qcy5cbiAgICogQHByb3Age21vZGlmaWVyc31cbiAgICovXG4gIG1vZGlmaWVyczogbW9kaWZpZXJzXG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBvbkNyZWF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgb25VcGRhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8vIFV0aWxzXG4vLyBNZXRob2RzXG52YXIgUG9wcGVyID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2UuXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fHJlZmVyZW5jZU9iamVjdH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIFRoZSBIVE1MIC8gWE1MIGVsZW1lbnQgdXNlZCBhcyB0aGUgcG9wcGVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gWW91ciBjdXN0b20gb3B0aW9ucyB0byBvdmVycmlkZSB0aGUgb25lcyBkZWZpbmVkIGluIFtEZWZhdWx0c10oI2RlZmF1bHRzKVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGluc3RhbmNlIC0gVGhlIGdlbmVyYXRlZCBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICovXG4gIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlcikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wcGVyKTtcblxuICAgIHRoaXMuc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnVwZGF0ZSk7XG4gICAgfTtcblxuICAgIC8vIG1ha2UgdXBkYXRlKCkgZGVib3VuY2VkLCBzbyB0aGF0IGl0IG9ubHkgcnVucyBhdCBtb3N0IG9uY2UtcGVyLXRpY2tcbiAgICB0aGlzLnVwZGF0ZSA9IGRlYm91bmNlKHRoaXMudXBkYXRlLmJpbmQodGhpcykpO1xuXG4gICAgLy8gd2l0aCB7fSB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggdGhlIG9wdGlvbnMgaW5zaWRlIGl0XG4gICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cywgb3B0aW9ucyk7XG5cbiAgICAvLyBpbml0IHN0YXRlXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGlzRGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzQ3JlYXRlZDogZmFsc2UsXG4gICAgICBzY3JvbGxQYXJlbnRzOiBbXVxuICAgIH07XG5cbiAgICAvLyBnZXQgcmVmZXJlbmNlIGFuZCBwb3BwZXIgZWxlbWVudHMgKGFsbG93IGpRdWVyeSB3cmFwcGVycylcbiAgICB0aGlzLnJlZmVyZW5jZSA9IHJlZmVyZW5jZSAmJiByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgIHRoaXMucG9wcGVyID0gcG9wcGVyICYmIHBvcHBlci5qcXVlcnkgPyBwb3BwZXJbMF0gOiBwb3BwZXI7XG5cbiAgICAvLyBEZWVwIG1lcmdlIG1vZGlmaWVycyBvcHRpb25zXG4gICAgdGhpcy5vcHRpb25zLm1vZGlmaWVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzLCBvcHRpb25zLm1vZGlmaWVycykpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdID0gX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnNbbmFtZV0gfHwge30sIG9wdGlvbnMubW9kaWZpZXJzID8gb3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gOiB7fSk7XG4gICAgfSk7XG5cbiAgICAvLyBSZWZhY3RvcmluZyBtb2RpZmllcnMnIGxpc3QgKE9iamVjdCA9PiBBcnJheSlcbiAgICB0aGlzLm1vZGlmaWVycyA9IE9iamVjdC5rZXlzKHRoaXMub3B0aW9ucy5tb2RpZmllcnMpLm1hcChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgICAgbmFtZTogbmFtZVxuICAgICAgfSwgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0pO1xuICAgIH0pXG4gICAgLy8gc29ydCB0aGUgbW9kaWZpZXJzIGJ5IG9yZGVyXG4gICAgLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBhLm9yZGVyIC0gYi5vcmRlcjtcbiAgICB9KTtcblxuICAgIC8vIG1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgd2hlbiBQb3BwZXIuanMgZ2V0IGluaXRlZFxuICAgIC8vIHN1Y2ggY29kZSBpcyBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBvZiBpdHMgbW9kaWZpZXJcbiAgICAvLyB0aGV5IGNvdWxkIGFkZCBuZXcgcHJvcGVydGllcyB0byB0aGVpciBvcHRpb25zIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBCRSBBV0FSRTogZG9uJ3QgYWRkIG9wdGlvbnMgdG8gYG9wdGlvbnMubW9kaWZpZXJzLm5hbWVgIGJ1dCB0byBgbW9kaWZpZXJPcHRpb25zYCFcbiAgICB0aGlzLm1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllck9wdGlvbnMpIHtcbiAgICAgIGlmIChtb2RpZmllck9wdGlvbnMuZW5hYmxlZCAmJiBpc0Z1bmN0aW9uKG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQpKSB7XG4gICAgICAgIG1vZGlmaWVyT3B0aW9ucy5vbkxvYWQoX3RoaXMucmVmZXJlbmNlLCBfdGhpcy5wb3BwZXIsIF90aGlzLm9wdGlvbnMsIG1vZGlmaWVyT3B0aW9ucywgX3RoaXMuc3RhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gZmlyZSB0aGUgZmlyc3QgdXBkYXRlIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIgaW4gdGhlIHJpZ2h0IHBsYWNlXG4gICAgdGhpcy51cGRhdGUoKTtcblxuICAgIHZhciBldmVudHNFbmFibGVkID0gdGhpcy5vcHRpb25zLmV2ZW50c0VuYWJsZWQ7XG4gICAgaWYgKGV2ZW50c0VuYWJsZWQpIHtcbiAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgIHRoaXMuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICB0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQgPSBldmVudHNFbmFibGVkO1xuICB9XG5cbiAgLy8gV2UgY2FuJ3QgdXNlIGNsYXNzIHByb3BlcnRpZXMgYmVjYXVzZSB0aGV5IGRvbid0IGdldCBsaXN0ZWQgaW4gdGhlXG4gIC8vIGNsYXNzIHByb3RvdHlwZSBhbmQgYnJlYWsgc3R1ZmYgbGlrZSBTaW5vbiBzdHVic1xuXG5cbiAgY3JlYXRlQ2xhc3MoUG9wcGVyLCBbe1xuICAgIGtleTogJ3VwZGF0ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZSQkMSgpIHtcbiAgICAgIHJldHVybiB1cGRhdGUuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSQkMSgpIHtcbiAgICAgIHJldHVybiBkZXN0cm95LmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZW5hYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBlbmFibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rpc2FibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycyQkMSgpIHtcbiAgICAgIHJldHVybiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZXMgYW4gdXBkYXRlLiBJdCB3aWxsIHJ1biBvbiB0aGUgbmV4dCBVSSB1cGRhdGUgYXZhaWxhYmxlLlxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cblxuICAgIC8qKlxuICAgICAqIENvbGxlY3Rpb24gb2YgdXRpbGl0aWVzIHVzZWZ1bCB3aGVuIHdyaXRpbmcgY3VzdG9tIG1vZGlmaWVycy5cbiAgICAgKiBTdGFydGluZyBmcm9tIHZlcnNpb24gMS43LCB0aGlzIG1ldGhvZCBpcyBhdmFpbGFibGUgb25seSBpZiB5b3VcbiAgICAgKiBpbmNsdWRlIGBwb3BwZXItdXRpbHMuanNgIGJlZm9yZSBgcG9wcGVyLmpzYC5cbiAgICAgKlxuICAgICAqICoqREVQUkVDQVRJT04qKjogVGhpcyB3YXkgdG8gYWNjZXNzIFBvcHBlclV0aWxzIGlzIGRlcHJlY2F0ZWRcbiAgICAgKiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHYyISBVc2UgdGhlIFBvcHBlclV0aWxzIG1vZHVsZSBkaXJlY3RseSBpbnN0ZWFkLlxuICAgICAqIER1ZSB0byB0aGUgaGlnaCBpbnN0YWJpbGl0eSBvZiB0aGUgbWV0aG9kcyBjb250YWluZWQgaW4gVXRpbHMsIHdlIGNhbid0XG4gICAgICogZ3VhcmFudGVlIHRoZW0gdG8gZm9sbG93IHNlbXZlci4gVXNlIHRoZW0gYXQgeW91ciBvd24gcmlzayFcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS44XG4gICAgICogQG1lbWJlciBVdGlsc1xuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKi9cblxuICB9XSk7XG4gIHJldHVybiBQb3BwZXI7XG59KCk7XG5cbi8qKlxuICogVGhlIGByZWZlcmVuY2VPYmplY3RgIGlzIGFuIG9iamVjdCB0aGF0IHByb3ZpZGVzIGFuIGludGVyZmFjZSBjb21wYXRpYmxlIHdpdGggUG9wcGVyLmpzXG4gKiBhbmQgbGV0cyB5b3UgdXNlIGl0IGFzIHJlcGxhY2VtZW50IG9mIGEgcmVhbCBET00gbm9kZS48YnIgLz5cbiAqIFlvdSBjYW4gdXNlIHRoaXMgbWV0aG9kIHRvIHBvc2l0aW9uIGEgcG9wcGVyIHJlbGF0aXZlbHkgdG8gYSBzZXQgb2YgY29vcmRpbmF0ZXNcbiAqIGluIGNhc2UgeW91IGRvbid0IGhhdmUgYSBET00gbm9kZSB0byB1c2UgYXMgcmVmZXJlbmNlLlxuICpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWZlcmVuY2VPYmplY3QsIHBvcHBlck5vZGUpO1xuICogYGBgXG4gKlxuICogTkI6IFRoaXMgZmVhdHVyZSBpc24ndCBzdXBwb3J0ZWQgaW4gSW50ZXJuZXQgRXhwbG9yZXIgMTAuXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuXG5Qb3BwZXIuVXRpbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiBnbG9iYWwpLlBvcHBlclV0aWxzO1xuUG9wcGVyLnBsYWNlbWVudHMgPSBwbGFjZW1lbnRzO1xuUG9wcGVyLkRlZmF1bHRzID0gRGVmYXVsdHM7XG5cbnJldHVybiBQb3BwZXI7XG5cbn0pKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9XG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uV2l0aFJlc2V0KCkge31cbmVtcHR5RnVuY3Rpb25XaXRoUmVzZXQucmVzZXRXYXJuaW5nQ2FjaGUgPSBlbXB0eUZ1bmN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICdVc2UgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCkgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICk7XG4gICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgdGhyb3cgZXJyO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYmlnaW50OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGVsZW1lbnRUeXBlOiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW0sXG5cbiAgICBjaGVja1Byb3BUeXBlczogZW1wdHlGdW5jdGlvbldpdGhSZXNldCxcbiAgICByZXNldFdhcm5pbmdDYWNoZTogZW1wdHlGdW5jdGlvblxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0SXMgPSByZXF1aXJlKCdyZWFjdC1pcycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuL2xpYi9oYXMnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICBwcmludFdhcm5pbmcgPSBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIHRleHQ7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCgpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBiaWdpbnQ6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdiaWdpbnQnKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBlbGVtZW50VHlwZTogY3JlYXRlRWxlbWVudFR5cGVUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSwgZGF0YSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5kYXRhID0gZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ29iamVjdCcgPyBkYXRhOiB7fTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBlbHNlIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJyArIHByb3BGdWxsTmFtZSArICdgIHByb3Agb24gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpLFxuICAgICAgICAgIHtleHBlY3RlZFR5cGU6IGV4cGVjdGVkVHlwZX1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudCB0eXBlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgXCJkZXZlbG9wbWVudFwiICE9PSAncHJvZHVjdGlvbicgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAnICsgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpICsgJyBhdCBpbmRleCAnICsgaSArICcuJ1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICB2YXIgY2hlY2tlclJlc3VsdCA9IGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChjaGVja2VyUmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdC5kYXRhICYmIGhhcyhjaGVja2VyUmVzdWx0LmRhdGEsICdleHBlY3RlZFR5cGUnKSkge1xuICAgICAgICAgIGV4cGVjdGVkVHlwZXMucHVzaChjaGVja2VyUmVzdWx0LmRhdGEuZXhwZWN0ZWRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGV4cGVjdGVkVHlwZXNNZXNzYWdlID0gKGV4cGVjdGVkVHlwZXMubGVuZ3RoID4gMCkgPyAnLCBleHBlY3RlZCBvbmUgb2YgdHlwZSBbJyArIGV4cGVjdGVkVHlwZXMuam9pbignLCAnKSArICddJzogJyc7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgJyArIGV4cGVjdGVkVHlwZXNNZXNzYWdlICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCB0eXBlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGUgKyAnYC4nXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgZ2V0UHJlY2lzZVR5cGUoY2hlY2tlcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKGhhcyhzaGFwZVR5cGVzLCBrZXkpICYmIHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBmYWxzeSB2YWx1ZSBjYW4ndCBiZSBhIFN5bWJvbFxuICAgIGlmICghcHJvcFZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGUgPSBjaGVja1Byb3BUeXBlcy5yZXNldFdhcm5pbmdDYWNoZTtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSZWFjdElzID0gcmVxdWlyZSgncmVhY3QtaXMnKTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlB1Yk51Yj10KCk6ZS5QdWJOdWI9dCgpfSh3aW5kb3csZnVuY3Rpb24oKXtyZXR1cm4gcj17fSxpLm09bj1bZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2UuZXhwb3J0cz17fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dC5kZWZhdWx0PXtQTlRpbWVPcGVyYXRpb246XCJQTlRpbWVPcGVyYXRpb25cIixQTkhpc3RvcnlPcGVyYXRpb246XCJQTkhpc3RvcnlPcGVyYXRpb25cIixQTkRlbGV0ZU1lc3NhZ2VzT3BlcmF0aW9uOlwiUE5EZWxldGVNZXNzYWdlc09wZXJhdGlvblwiLFBORmV0Y2hNZXNzYWdlc09wZXJhdGlvbjpcIlBORmV0Y2hNZXNzYWdlc09wZXJhdGlvblwiLFBOTWVzc2FnZUNvdW50czpcIlBOTWVzc2FnZUNvdW50c09wZXJhdGlvblwiLFBOU3Vic2NyaWJlT3BlcmF0aW9uOlwiUE5TdWJzY3JpYmVPcGVyYXRpb25cIixQTlVuc3Vic2NyaWJlT3BlcmF0aW9uOlwiUE5VbnN1YnNjcmliZU9wZXJhdGlvblwiLFBOUHVibGlzaE9wZXJhdGlvbjpcIlBOUHVibGlzaE9wZXJhdGlvblwiLFBOU2lnbmFsT3BlcmF0aW9uOlwiUE5TaWduYWxPcGVyYXRpb25cIixQTkFkZE1lc3NhZ2VBY3Rpb25PcGVyYXRpb246XCJQTkFkZEFjdGlvbk9wZXJhdGlvblwiLFBOUmVtb3ZlTWVzc2FnZUFjdGlvbk9wZXJhdGlvbjpcIlBOUmVtb3ZlTWVzc2FnZUFjdGlvbk9wZXJhdGlvblwiLFBOR2V0TWVzc2FnZUFjdGlvbnNPcGVyYXRpb246XCJQTkdldE1lc3NhZ2VBY3Rpb25zT3BlcmF0aW9uXCIsUE5DcmVhdGVVc2VyT3BlcmF0aW9uOlwiUE5DcmVhdGVVc2VyT3BlcmF0aW9uXCIsUE5VcGRhdGVVc2VyT3BlcmF0aW9uOlwiUE5VcGRhdGVVc2VyT3BlcmF0aW9uXCIsUE5EZWxldGVVc2VyT3BlcmF0aW9uOlwiUE5EZWxldGVVc2VyT3BlcmF0aW9uXCIsUE5HZXRVc2VyT3BlcmF0aW9uOlwiUE5HZXRVc2Vyc09wZXJhdGlvblwiLFBOR2V0VXNlcnNPcGVyYXRpb246XCJQTkdldFVzZXJzT3BlcmF0aW9uXCIsUE5DcmVhdGVTcGFjZU9wZXJhdGlvbjpcIlBOQ3JlYXRlU3BhY2VPcGVyYXRpb25cIixQTlVwZGF0ZVNwYWNlT3BlcmF0aW9uOlwiUE5VcGRhdGVTcGFjZU9wZXJhdGlvblwiLFBORGVsZXRlU3BhY2VPcGVyYXRpb246XCJQTkRlbGV0ZVNwYWNlT3BlcmF0aW9uXCIsUE5HZXRTcGFjZU9wZXJhdGlvbjpcIlBOR2V0U3BhY2VzT3BlcmF0aW9uXCIsUE5HZXRTcGFjZXNPcGVyYXRpb246XCJQTkdldFNwYWNlc09wZXJhdGlvblwiLFBOR2V0TWVtYmVyc09wZXJhdGlvbjpcIlBOR2V0TWVtYmVyc09wZXJhdGlvblwiLFBOVXBkYXRlTWVtYmVyc09wZXJhdGlvbjpcIlBOVXBkYXRlTWVtYmVyc09wZXJhdGlvblwiLFBOR2V0TWVtYmVyc2hpcHNPcGVyYXRpb246XCJQTkdldE1lbWJlcnNoaXBzT3BlcmF0aW9uXCIsUE5VcGRhdGVNZW1iZXJzaGlwc09wZXJhdGlvbjpcIlBOVXBkYXRlTWVtYmVyc2hpcHNPcGVyYXRpb25cIixQTlB1c2hOb3RpZmljYXRpb25FbmFibGVkQ2hhbm5lbHNPcGVyYXRpb246XCJQTlB1c2hOb3RpZmljYXRpb25FbmFibGVkQ2hhbm5lbHNPcGVyYXRpb25cIixQTlJlbW92ZUFsbFB1c2hOb3RpZmljYXRpb25zT3BlcmF0aW9uOlwiUE5SZW1vdmVBbGxQdXNoTm90aWZpY2F0aW9uc09wZXJhdGlvblwiLFBOV2hlcmVOb3dPcGVyYXRpb246XCJQTldoZXJlTm93T3BlcmF0aW9uXCIsUE5TZXRTdGF0ZU9wZXJhdGlvbjpcIlBOU2V0U3RhdGVPcGVyYXRpb25cIixQTkhlcmVOb3dPcGVyYXRpb246XCJQTkhlcmVOb3dPcGVyYXRpb25cIixQTkdldFN0YXRlT3BlcmF0aW9uOlwiUE5HZXRTdGF0ZU9wZXJhdGlvblwiLFBOSGVhcnRiZWF0T3BlcmF0aW9uOlwiUE5IZWFydGJlYXRPcGVyYXRpb25cIixQTkNoYW5uZWxHcm91cHNPcGVyYXRpb246XCJQTkNoYW5uZWxHcm91cHNPcGVyYXRpb25cIixQTlJlbW92ZUdyb3VwT3BlcmF0aW9uOlwiUE5SZW1vdmVHcm91cE9wZXJhdGlvblwiLFBOQ2hhbm5lbHNGb3JHcm91cE9wZXJhdGlvbjpcIlBOQ2hhbm5lbHNGb3JHcm91cE9wZXJhdGlvblwiLFBOQWRkQ2hhbm5lbHNUb0dyb3VwT3BlcmF0aW9uOlwiUE5BZGRDaGFubmVsc1RvR3JvdXBPcGVyYXRpb25cIixQTlJlbW92ZUNoYW5uZWxzRnJvbUdyb3VwT3BlcmF0aW9uOlwiUE5SZW1vdmVDaGFubmVsc0Zyb21Hcm91cE9wZXJhdGlvblwiLFBOQWNjZXNzTWFuYWdlckdyYW50OlwiUE5BY2Nlc3NNYW5hZ2VyR3JhbnRcIixQTkFjY2Vzc01hbmFnZXJHcmFudFRva2VuOlwiUE5BY2Nlc3NNYW5hZ2VyR3JhbnRUb2tlblwiLFBOQWNjZXNzTWFuYWdlckF1ZGl0OlwiUE5BY2Nlc3NNYW5hZ2VyQXVkaXRcIn0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlKS5yZXBsYWNlKC9bIX4qJygpXS9nLGZ1bmN0aW9uKGUpe3JldHVyblwiJVwiLmNvbmNhdChlLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkpfSl9ZnVuY3Rpb24gaShlKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9W107cmV0dXJuIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24oZSl7cmV0dXJuIHQucHVzaChlKX0pLHR9KGUpLnNvcnQoKX1lLmV4cG9ydHM9e3NpZ25QYW1Gcm9tUGFyYW1zOmZ1bmN0aW9uKHQpe3JldHVybiBpKHQpLm1hcChmdW5jdGlvbihlKXtyZXR1cm5cIlwiLmNvbmNhdChlLFwiPVwiKS5jb25jYXQocih0W2VdKSl9KS5qb2luKFwiJlwiKX0sZW5kc1dpdGg6ZnVuY3Rpb24oZSx0KXtyZXR1cm4tMSE9PWUuaW5kZXhPZih0LHRoaXMubGVuZ3RoLXQubGVuZ3RoKX0sY3JlYXRlUHJvbWlzZTpmdW5jdGlvbigpe3ZhciBuLHI7cmV0dXJue3Byb21pc2U6bmV3IFByb21pc2UoZnVuY3Rpb24oZSx0KXtuPWUscj10fSkscmVqZWN0OnIsZnVsZmlsbDpufX0sZW5jb2RlU3RyaW5nOnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgcixpPShyPW4oNSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfTtuKDApO2Z1bmN0aW9uIG8oZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIHMoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfXZhciBhLHUsYyxmPShhPWwsKHU9W3trZXk6XCJnZXRBdXRoS2V5XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hdXRoS2V5fX0se2tleTpcInNldEF1dGhLZXlcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5hdXRoS2V5PWUsdGhpc319LHtrZXk6XCJzZXRDaXBoZXJLZXlcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5jaXBoZXJLZXk9ZSx0aGlzfX0se2tleTpcImdldFVVSURcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLlVVSUR9fSx7a2V5Olwic2V0VVVJRFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9kYiYmdGhpcy5fZGIuc2V0JiZ0aGlzLl9kYi5zZXQoXCJcIi5jb25jYXQodGhpcy5zdWJzY3JpYmVLZXksXCJ1dWlkXCIpLGUpLHRoaXMuVVVJRD1lLHRoaXN9fSx7a2V5OlwiZ2V0RmlsdGVyRXhwcmVzc2lvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmlsdGVyRXhwcmVzc2lvbn19LHtrZXk6XCJzZXRGaWx0ZXJFeHByZXNzaW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZmlsdGVyRXhwcmVzc2lvbj1lLHRoaXN9fSx7a2V5OlwiZ2V0UHJlc2VuY2VUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJlc2VuY2VUaW1lb3V0fX0se2tleTpcInNldFByZXNlbmNlVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiAyMDw9ZT90aGlzLl9wcmVzZW5jZVRpbWVvdXQ9ZToodGhpcy5fcHJlc2VuY2VUaW1lb3V0PTIwLGNvbnNvbGUubG9nKFwiV0FSTklORzogUHJlc2VuY2UgdGltZW91dCBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0uIFVzaW5nIG1pbmltdW0gdmFsdWU6IFwiLHRoaXMuX3ByZXNlbmNlVGltZW91dCkpLHRoaXMuc2V0SGVhcnRiZWF0SW50ZXJ2YWwodGhpcy5fcHJlc2VuY2VUaW1lb3V0LzItMSksdGhpc319LHtrZXk6XCJzZXRQcm94eVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMucHJveHk9ZX19LHtrZXk6XCJnZXRIZWFydGJlYXRJbnRlcnZhbFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hlYXJ0YmVhdEludGVydmFsfX0se2tleTpcInNldEhlYXJ0YmVhdEludGVydmFsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2hlYXJ0YmVhdEludGVydmFsPWUsdGhpc319LHtrZXk6XCJnZXRTdWJzY3JpYmVUaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3Vic2NyaWJlUmVxdWVzdFRpbWVvdXR9fSx7a2V5Olwic2V0U3Vic2NyaWJlVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zdWJzY3JpYmVSZXF1ZXN0VGltZW91dD1lLHRoaXN9fSx7a2V5OlwiZ2V0VHJhbnNhY3Rpb25UaW1lb3V0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb25hbFJlcXVlc3RUaW1lb3V0fX0se2tleTpcInNldFRyYW5zYWN0aW9uVGltZW91dFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl90cmFuc2FjdGlvbmFsUmVxdWVzdFRpbWVvdXQ9ZSx0aGlzfX0se2tleTpcImlzU2VuZEJlYWNvbkVuYWJsZWRcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl91c2VTZW5kQmVhY29ufX0se2tleTpcInNldFNlbmRCZWFjb25Db25maWdcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fdXNlU2VuZEJlYWNvbj1lLHRoaXN9fSx7a2V5OlwiZ2V0VmVyc2lvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuXCI0LjI3LjNcIn19LHtrZXk6XCJfYWRkUG5zZGtTdWZmaXhcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3RoaXMuX1BOU0RLU3VmZml4W2VdPXR9fSx7a2V5OlwiX2dldFBuc2RrU3VmZml4XCIsdmFsdWU6ZnVuY3Rpb24obil7dmFyIHI9dGhpcztyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fUE5TREtTdWZmaXgpLnJlZHVjZShmdW5jdGlvbihlLHQpe3JldHVybiBlK24rci5fUE5TREtTdWZmaXhbdF19LFwiXCIpfX0se2tleTpcIl9kZWNpZGVVVUlEXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGV8fCh0aGlzLl9kYiYmdGhpcy5fZGIuZ2V0JiZ0aGlzLl9kYi5nZXQoXCJcIi5jb25jYXQodGhpcy5zdWJzY3JpYmVLZXksXCJ1dWlkXCIpKT90aGlzLl9kYi5nZXQoXCJcIi5jb25jYXQodGhpcy5zdWJzY3JpYmVLZXksXCJ1dWlkXCIpKTpcInBuLVwiLmNvbmNhdChpLmRlZmF1bHQuY3JlYXRlVVVJRCgpKSl9fV0pJiZvKGEucHJvdG90eXBlLHUpLHZvaWQoYyYmbyhhLGMpKSxsKTtmdW5jdGlvbiBsKGUpe3ZhciB0PWUuc2V0dXAsbj1lLmRiOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbCkscyh0aGlzLFwiX2RiXCIsdm9pZCAwKSxzKHRoaXMsXCJzdWJzY3JpYmVLZXlcIix2b2lkIDApLHModGhpcyxcInB1Ymxpc2hLZXlcIix2b2lkIDApLHModGhpcyxcInNlY3JldEtleVwiLHZvaWQgMCkscyh0aGlzLFwiY2lwaGVyS2V5XCIsdm9pZCAwKSxzKHRoaXMsXCJhdXRoS2V5XCIsdm9pZCAwKSxzKHRoaXMsXCJVVUlEXCIsdm9pZCAwKSxzKHRoaXMsXCJwcm94eVwiLHZvaWQgMCkscyh0aGlzLFwiaW5zdGFuY2VJZFwiLHZvaWQgMCkscyh0aGlzLFwic2RrTmFtZVwiLHZvaWQgMCkscyh0aGlzLFwic2RrRmFtaWx5XCIsdm9pZCAwKSxzKHRoaXMsXCJwYXJ0bmVySWRcIix2b2lkIDApLHModGhpcyxcImZpbHRlckV4cHJlc3Npb25cIix2b2lkIDApLHModGhpcyxcInN1cHByZXNzTGVhdmVFdmVudHNcIix2b2lkIDApLHModGhpcyxcInNlY3VyZVwiLHZvaWQgMCkscyh0aGlzLFwib3JpZ2luXCIsdm9pZCAwKSxzKHRoaXMsXCJsb2dWZXJib3NpdHlcIix2b2lkIDApLHModGhpcyxcInVzZUluc3RhbmNlSWRcIix2b2lkIDApLHModGhpcyxcInVzZVJlcXVlc3RJZFwiLHZvaWQgMCkscyh0aGlzLFwia2VlcEFsaXZlXCIsdm9pZCAwKSxzKHRoaXMsXCJrZWVwQWxpdmVTZXR0aW5nc1wiLHZvaWQgMCkscyh0aGlzLFwiYXV0b05ldHdvcmtEZXRlY3Rpb25cIix2b2lkIDApLHModGhpcyxcImFubm91bmNlU3VjY2Vzc2Z1bEhlYXJ0YmVhdHNcIix2b2lkIDApLHModGhpcyxcImFubm91bmNlRmFpbGVkSGVhcnRiZWF0c1wiLHZvaWQgMCkscyh0aGlzLFwiX3ByZXNlbmNlVGltZW91dFwiLHZvaWQgMCkscyh0aGlzLFwiX2hlYXJ0YmVhdEludGVydmFsXCIsdm9pZCAwKSxzKHRoaXMsXCJfc3Vic2NyaWJlUmVxdWVzdFRpbWVvdXRcIix2b2lkIDApLHModGhpcyxcIl90cmFuc2FjdGlvbmFsUmVxdWVzdFRpbWVvdXRcIix2b2lkIDApLHModGhpcyxcIl91c2VTZW5kQmVhY29uXCIsdm9pZCAwKSxzKHRoaXMsXCJfUE5TREtTdWZmaXhcIix2b2lkIDApLHModGhpcyxcInJlcXVlc3RNZXNzYWdlQ291bnRUaHJlc2hvbGRcIix2b2lkIDApLHModGhpcyxcInJlc3RvcmVcIix2b2lkIDApLHModGhpcyxcImRlZHVwZU9uU3Vic2NyaWJlXCIsdm9pZCAwKSxzKHRoaXMsXCJtYXhpbXVtQ2FjaGVTaXplXCIsdm9pZCAwKSxzKHRoaXMsXCJjdXN0b21FbmNyeXB0XCIsdm9pZCAwKSxzKHRoaXMsXCJjdXN0b21EZWNyeXB0XCIsdm9pZCAwKSx0aGlzLl9QTlNES1N1ZmZpeD17fSx0aGlzLl9kYj1uLHRoaXMuaW5zdGFuY2VJZD1cInBuLVwiLmNvbmNhdChpLmRlZmF1bHQuY3JlYXRlVVVJRCgpKSx0aGlzLnNlY3JldEtleT10LnNlY3JldEtleXx8dC5zZWNyZXRfa2V5LHRoaXMuc3Vic2NyaWJlS2V5PXQuc3Vic2NyaWJlS2V5fHx0LnN1YnNjcmliZV9rZXksdGhpcy5wdWJsaXNoS2V5PXQucHVibGlzaEtleXx8dC5wdWJsaXNoX2tleSx0aGlzLnNka05hbWU9dC5zZGtOYW1lLHRoaXMuc2RrRmFtaWx5PXQuc2RrRmFtaWx5LHRoaXMucGFydG5lcklkPXQucGFydG5lcklkLHRoaXMuc2V0QXV0aEtleSh0LmF1dGhLZXkpLHRoaXMuc2V0Q2lwaGVyS2V5KHQuY2lwaGVyS2V5KSx0aGlzLnNldEZpbHRlckV4cHJlc3Npb24odC5maWx0ZXJFeHByZXNzaW9uKSx0aGlzLm9yaWdpbj10Lm9yaWdpbnx8XCJwcy5wbmRzbi5jb21cIix0aGlzLnNlY3VyZT10LnNzbHx8ITEsdGhpcy5yZXN0b3JlPXQucmVzdG9yZXx8ITEsdGhpcy5wcm94eT10LnByb3h5LHRoaXMua2VlcEFsaXZlPXQua2VlcEFsaXZlLHRoaXMua2VlcEFsaXZlU2V0dGluZ3M9dC5rZWVwQWxpdmVTZXR0aW5ncyx0aGlzLmF1dG9OZXR3b3JrRGV0ZWN0aW9uPXQuYXV0b05ldHdvcmtEZXRlY3Rpb258fCExLHRoaXMuZGVkdXBlT25TdWJzY3JpYmU9dC5kZWR1cGVPblN1YnNjcmliZXx8ITEsdGhpcy5tYXhpbXVtQ2FjaGVTaXplPXQubWF4aW11bUNhY2hlU2l6ZXx8MTAwLHRoaXMuY3VzdG9tRW5jcnlwdD10LmN1c3RvbUVuY3J5cHQsdGhpcy5jdXN0b21EZWNyeXB0PXQuY3VzdG9tRGVjcnlwdCxcInVuZGVmaW5lZFwiIT10eXBlb2YgbG9jYXRpb24mJlwiaHR0cHM6XCI9PT1sb2NhdGlvbi5wcm90b2NvbCYmKHRoaXMuc2VjdXJlPSEwKSx0aGlzLmxvZ1ZlcmJvc2l0eT10LmxvZ1ZlcmJvc2l0eXx8ITEsdGhpcy5zdXBwcmVzc0xlYXZlRXZlbnRzPXQuc3VwcHJlc3NMZWF2ZUV2ZW50c3x8ITEsdGhpcy5hbm5vdW5jZUZhaWxlZEhlYXJ0YmVhdHM9dC5hbm5vdW5jZUZhaWxlZEhlYXJ0YmVhdHN8fCEwLHRoaXMuYW5ub3VuY2VTdWNjZXNzZnVsSGVhcnRiZWF0cz10LmFubm91bmNlU3VjY2Vzc2Z1bEhlYXJ0YmVhdHN8fCExLHRoaXMudXNlSW5zdGFuY2VJZD10LnVzZUluc3RhbmNlSWR8fCExLHRoaXMudXNlUmVxdWVzdElkPXQudXNlUmVxdWVzdElkfHwhMSx0aGlzLnJlcXVlc3RNZXNzYWdlQ291bnRUaHJlc2hvbGQ9dC5yZXF1ZXN0TWVzc2FnZUNvdW50VGhyZXNob2xkLHRoaXMuc2V0VHJhbnNhY3Rpb25UaW1lb3V0KHQudHJhbnNhY3Rpb25hbFJlcXVlc3RUaW1lb3V0fHwxNWUzKSx0aGlzLnNldFN1YnNjcmliZVRpbWVvdXQodC5zdWJzY3JpYmVSZXF1ZXN0VGltZW91dHx8MzFlNCksdGhpcy5zZXRTZW5kQmVhY29uQ29uZmlnKHQudXNlU2VuZEJlYWNvbnx8ITApLHQucHJlc2VuY2VUaW1lb3V0P3RoaXMuc2V0UHJlc2VuY2VUaW1lb3V0KHQucHJlc2VuY2VUaW1lb3V0KTp0aGlzLl9wcmVzZW5jZVRpbWVvdXQ9MzAwLG51bGwhPXQuaGVhcnRiZWF0SW50ZXJ2YWwmJnRoaXMuc2V0SGVhcnRiZWF0SW50ZXJ2YWwodC5oZWFydGJlYXRJbnRlcnZhbCksdGhpcy5zZXRVVUlEKHRoaXMuX2RlY2lkZVVVSUQodC51dWlkKSl9dC5kZWZhdWx0PWYsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dC5kZWZhdWx0PXtQTk5ldHdvcmtVcENhdGVnb3J5OlwiUE5OZXR3b3JrVXBDYXRlZ29yeVwiLFBOTmV0d29ya0Rvd25DYXRlZ29yeTpcIlBOTmV0d29ya0Rvd25DYXRlZ29yeVwiLFBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5OlwiUE5OZXR3b3JrSXNzdWVzQ2F0ZWdvcnlcIixQTlRpbWVvdXRDYXRlZ29yeTpcIlBOVGltZW91dENhdGVnb3J5XCIsUE5CYWRSZXF1ZXN0Q2F0ZWdvcnk6XCJQTkJhZFJlcXVlc3RDYXRlZ29yeVwiLFBOQWNjZXNzRGVuaWVkQ2F0ZWdvcnk6XCJQTkFjY2Vzc0RlbmllZENhdGVnb3J5XCIsUE5Vbmtub3duQ2F0ZWdvcnk6XCJQTlVua25vd25DYXRlZ29yeVwiLFBOUmVjb25uZWN0ZWRDYXRlZ29yeTpcIlBOUmVjb25uZWN0ZWRDYXRlZ29yeVwiLFBOQ29ubmVjdGVkQ2F0ZWdvcnk6XCJQTkNvbm5lY3RlZENhdGVnb3J5XCIsUE5SZXF1ZXN0TWVzc2FnZUNvdW50RXhjZWVkZWRDYXRlZ29yeTpcIlBOUmVxdWVzdE1lc3NhZ2VDb3VudEV4Y2VlZGVkQ2F0ZWdvcnlcIn0sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIHIsaT0ocj1uKDEzKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9O3ZhciBvPXtjcmVhdGVVVUlEOmZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC51dWlkP2kuZGVmYXVsdC51dWlkKCk6KDAsaS5kZWZhdWx0KSgpfX07dC5kZWZhdWx0PW8sZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7cihuKDMpKTt2YXIgdT1yKG4oMTQpKTtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBvKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgcyxhLGMsZj0ocz1sLChhPVt7a2V5OlwiSE1BQ1NIQTI1NlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVybiB1LmRlZmF1bHQuSG1hY1NIQTI1NihlLHRoaXMuX2NvbmZpZy5zZWNyZXRLZXkpLnRvU3RyaW5nKHUuZGVmYXVsdC5lbmMuQmFzZTY0KX19LHtrZXk6XCJTSEEyNTZcIix2YWx1ZTpmdW5jdGlvbihlKXtyZXR1cm4gdS5kZWZhdWx0LlNIQTI1NihlKS50b1N0cmluZyh1LmRlZmF1bHQuZW5jLkhleCl9fSx7a2V5OlwiX3BhcnNlT3B0aW9uc1wiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PWV8fHt9O3JldHVybiB0Lmhhc093blByb3BlcnR5KFwiZW5jcnlwdEtleVwiKXx8KHQuZW5jcnlwdEtleT10aGlzLl9kZWZhdWx0T3B0aW9ucy5lbmNyeXB0S2V5KSx0Lmhhc093blByb3BlcnR5KFwia2V5RW5jb2RpbmdcIil8fCh0LmtleUVuY29kaW5nPXRoaXMuX2RlZmF1bHRPcHRpb25zLmtleUVuY29kaW5nKSx0Lmhhc093blByb3BlcnR5KFwia2V5TGVuZ3RoXCIpfHwodC5rZXlMZW5ndGg9dGhpcy5fZGVmYXVsdE9wdGlvbnMua2V5TGVuZ3RoKSx0Lmhhc093blByb3BlcnR5KFwibW9kZVwiKXx8KHQubW9kZT10aGlzLl9kZWZhdWx0T3B0aW9ucy5tb2RlKSwtMT09PXRoaXMuX2FsbG93ZWRLZXlFbmNvZGluZ3MuaW5kZXhPZih0LmtleUVuY29kaW5nLnRvTG93ZXJDYXNlKCkpJiYodC5rZXlFbmNvZGluZz10aGlzLl9kZWZhdWx0T3B0aW9ucy5rZXlFbmNvZGluZyksLTE9PT10aGlzLl9hbGxvd2VkS2V5TGVuZ3Rocy5pbmRleE9mKHBhcnNlSW50KHQua2V5TGVuZ3RoLDEwKSkmJih0LmtleUxlbmd0aD10aGlzLl9kZWZhdWx0T3B0aW9ucy5rZXlMZW5ndGgpLC0xPT09dGhpcy5fYWxsb3dlZE1vZGVzLmluZGV4T2YodC5tb2RlLnRvTG93ZXJDYXNlKCkpJiYodC5tb2RlPXRoaXMuX2RlZmF1bHRPcHRpb25zLm1vZGUpLHR9fSx7a2V5OlwiX2RlY29kZUtleVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuXCJiYXNlNjRcIj09PXQua2V5RW5jb2Rpbmc/dS5kZWZhdWx0LmVuYy5CYXNlNjQucGFyc2UoZSk6XCJoZXhcIj09PXQua2V5RW5jb2Rpbmc/dS5kZWZhdWx0LmVuYy5IZXgucGFyc2UoZSk6ZX19LHtrZXk6XCJfZ2V0UGFkZGVkS2V5XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT10aGlzLl9kZWNvZGVLZXkoZSx0KSx0LmVuY3J5cHRLZXk/dS5kZWZhdWx0LmVuYy5VdGY4LnBhcnNlKHRoaXMuU0hBMjU2KGUpLnNsaWNlKDAsMzIpKTplfX0se2tleTpcIl9nZXRNb2RlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuXCJlY2JcIj09PWUubW9kZT91LmRlZmF1bHQubW9kZS5FQ0I6dS5kZWZhdWx0Lm1vZGUuQ0JDfX0se2tleTpcIl9nZXRJVlwiLHZhbHVlOmZ1bmN0aW9uKGUpe3JldHVyblwiY2JjXCI9PT1lLm1vZGU/dS5kZWZhdWx0LmVuYy5VdGY4LnBhcnNlKHRoaXMuX2l2KTpudWxsfX0se2tleTpcImVuY3J5cHRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIHRoaXMuX2NvbmZpZy5jdXN0b21FbmNyeXB0P3RoaXMuX2NvbmZpZy5jdXN0b21FbmNyeXB0KGUpOnRoaXMucG5FbmNyeXB0KGUsdCxuKX19LHtrZXk6XCJkZWNyeXB0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe3JldHVybiB0aGlzLl9jb25maWcuY3VzdG9tRGVjcnlwdD90aGlzLl9jb25maWcuY3VzdG9tRGVjcnlwdChlKTp0aGlzLnBuRGVjcnlwdChlLHQsbil9fSx7a2V5OlwicG5FbmNyeXB0XCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4pe2lmKCF0JiYhdGhpcy5fY29uZmlnLmNpcGhlcktleSlyZXR1cm4gZTtuPXRoaXMuX3BhcnNlT3B0aW9ucyhuKTt2YXIgcj10aGlzLl9nZXRJVihuKSxpPXRoaXMuX2dldE1vZGUobiksbz10aGlzLl9nZXRQYWRkZWRLZXkodHx8dGhpcy5fY29uZmlnLmNpcGhlcktleSxuKTtyZXR1cm4gdS5kZWZhdWx0LkFFUy5lbmNyeXB0KGUsbyx7aXY6cixtb2RlOml9KS5jaXBoZXJ0ZXh0LnRvU3RyaW5nKHUuZGVmYXVsdC5lbmMuQmFzZTY0KXx8ZX19LHtrZXk6XCJwbkRlY3J5cHRcIix2YWx1ZTpmdW5jdGlvbihlLHQsbil7aWYoIXQmJiF0aGlzLl9jb25maWcuY2lwaGVyS2V5KXJldHVybiBlO249dGhpcy5fcGFyc2VPcHRpb25zKG4pO3ZhciByPXRoaXMuX2dldElWKG4pLGk9dGhpcy5fZ2V0TW9kZShuKSxvPXRoaXMuX2dldFBhZGRlZEtleSh0fHx0aGlzLl9jb25maWcuY2lwaGVyS2V5LG4pO3RyeXt2YXIgcz11LmRlZmF1bHQuZW5jLkJhc2U2NC5wYXJzZShlKSxhPXUuZGVmYXVsdC5BRVMuZGVjcnlwdCh7Y2lwaGVydGV4dDpzfSxvLHtpdjpyLG1vZGU6aX0pLnRvU3RyaW5nKHUuZGVmYXVsdC5lbmMuVXRmOCk7cmV0dXJuIEpTT04ucGFyc2UoYSl9Y2F0Y2goZSl7cmV0dXJuIG51bGx9fX1dKSYmaShzLnByb3RvdHlwZSxhKSx2b2lkKGMmJmkocyxjKSksbCk7ZnVuY3Rpb24gbChlKXt2YXIgdD1lLmNvbmZpZzshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGwpLG8odGhpcyxcIl9jb25maWdcIix2b2lkIDApLG8odGhpcyxcIl9pdlwiLHZvaWQgMCksbyh0aGlzLFwiX2FsbG93ZWRLZXlFbmNvZGluZ3NcIix2b2lkIDApLG8odGhpcyxcIl9hbGxvd2VkS2V5TGVuZ3Roc1wiLHZvaWQgMCksbyh0aGlzLFwiX2FsbG93ZWRNb2Rlc1wiLHZvaWQgMCksbyh0aGlzLFwiX2RlZmF1bHRPcHRpb25zXCIsdm9pZCAwKSx0aGlzLl9jb25maWc9dCx0aGlzLl9pdj1cIjAxMjM0NTY3ODkwMTIzNDVcIix0aGlzLl9hbGxvd2VkS2V5RW5jb2RpbmdzPVtcImhleFwiLFwidXRmOFwiLFwiYmFzZTY0XCIsXCJiaW5hcnlcIl0sdGhpcy5fYWxsb3dlZEtleUxlbmd0aHM9WzEyOCwyNTZdLHRoaXMuX2FsbG93ZWRNb2Rlcz1bXCJlY2JcIixcImNiY1wiXSx0aGlzLl9kZWZhdWx0T3B0aW9ucz17ZW5jcnlwdEtleTohMCxrZXlFbmNvZGluZzpcInV0ZjhcIixrZXlMZW5ndGg6MjU2LG1vZGU6XCJjYmNcIn19dC5kZWZhdWx0PWYsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7bigwKTt2YXIgcixpPShyPW4oNCkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfTtmdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX12YXIgcyxhLHUsYz0ocz1mLChhPVt7a2V5OlwiYWRkTGlzdGVuZXJcIix2YWx1ZTpmdW5jdGlvbihlKXt0aGlzLl9saXN0ZW5lcnMucHVzaChlKX19LHtrZXk6XCJyZW1vdmVMaXN0ZW5lclwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBuPVtdO3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UhPT10JiZuLnB1c2goZSl9KSx0aGlzLl9saXN0ZW5lcnM9bn19LHtrZXk6XCJyZW1vdmVBbGxMaXN0ZW5lcnNcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX2xpc3RlbmVycz1bXX19LHtrZXk6XCJhbm5vdW5jZVByZXNlbmNlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5wcmVzZW5jZSYmZS5wcmVzZW5jZSh0KX0pfX0se2tleTpcImFubm91bmNlU3RhdHVzXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5zdGF0dXMmJmUuc3RhdHVzKHQpfSl9fSx7a2V5OlwiYW5ub3VuY2VNZXNzYWdlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5tZXNzYWdlJiZlLm1lc3NhZ2UodCl9KX19LHtrZXk6XCJhbm5vdW5jZVNpZ25hbFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2Uuc2lnbmFsJiZlLnNpZ25hbCh0KX0pfX0se2tleTpcImFubm91bmNlTWVzc2FnZUFjdGlvblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UubWVzc2FnZUFjdGlvbiYmZS5tZXNzYWdlQWN0aW9uKHQpfSl9fSx7a2V5OlwiYW5ub3VuY2VVc2VyXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS51c2VyJiZlLnVzZXIodCl9KX19LHtrZXk6XCJhbm5vdW5jZVNwYWNlXCIsdmFsdWU6ZnVuY3Rpb24odCl7dGhpcy5fbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7ZS5zcGFjZSYmZS5zcGFjZSh0KX0pfX0se2tleTpcImFubm91bmNlTWVtYmVyc2hpcFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3RoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UubWVtYmVyc2hpcCYmZS5tZW1iZXJzaGlwKHQpfSl9fSx7a2V5OlwiYW5ub3VuY2VOZXR3b3JrVXBcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciBlPXt9O2UuY2F0ZWdvcnk9aS5kZWZhdWx0LlBOTmV0d29ya1VwQ2F0ZWdvcnksdGhpcy5hbm5vdW5jZVN0YXR1cyhlKX19LHtrZXk6XCJhbm5vdW5jZU5ldHdvcmtEb3duXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT17fTtlLmNhdGVnb3J5PWkuZGVmYXVsdC5QTk5ldHdvcmtEb3duQ2F0ZWdvcnksdGhpcy5hbm5vdW5jZVN0YXR1cyhlKX19XSkmJm8ocy5wcm90b3R5cGUsYSksdm9pZCh1JiZvKHMsdSkpLGYpO2Z1bmN0aW9uIGYoKXshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGYpLGZ1bmN0aW9uKGUsdCxuKXt0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bn0odGhpcyxcIl9saXN0ZW5lcnNcIix2b2lkIDApLHRoaXMuX2xpc3RlbmVycz1bXX10LmRlZmF1bHQ9YyxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVGltZU9wZXJhdGlvbn0sdC5nZXRVUkw9ZnVuY3Rpb24oKXtyZXR1cm5cIi90aW1lLzBcIn0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiExfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJue3RpbWV0b2tlbjp0WzBdfX0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbigpe307bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSxJLEQpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbihlKXt2YXIgcj1EKDcxKSxvPUQoNzIpLHM9RCg3Myk7ZnVuY3Rpb24gbigpe3JldHVybiBsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIGEoZSx0KXtpZihuKCk8dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoXCIpO3JldHVybiBsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KGU9bmV3IFVpbnQ4QXJyYXkodCkpLl9fcHJvdG9fXz1sLnByb3RvdHlwZToobnVsbD09PWUmJihlPW5ldyBsKHQpKSxlLmxlbmd0aD10KSxlfWZ1bmN0aW9uIGwoZSx0LG4pe2lmKCEobC5UWVBFRF9BUlJBWV9TVVBQT1JUfHx0aGlzIGluc3RhbmNlb2YgbCkpcmV0dXJuIG5ldyBsKGUsdCxuKTtpZihcIm51bWJlclwiIT10eXBlb2YgZSlyZXR1cm4gaSh0aGlzLGUsdCxuKTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCl0aHJvdyBuZXcgRXJyb3IoXCJJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZ1wiKTtyZXR1cm4gYyh0aGlzLGUpfWZ1bmN0aW9uIGkoZSx0LG4scil7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJyk7cmV0dXJuXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZ0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXI/ZnVuY3Rpb24oZSx0LG4scil7aWYodC5ieXRlTGVuZ3RoLG48MHx8dC5ieXRlTGVuZ3RoPG4pdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInb2Zmc2V0JyBpcyBvdXQgb2YgYm91bmRzXCIpO2lmKHQuYnl0ZUxlbmd0aDxuKyhyfHwwKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIidsZW5ndGgnIGlzIG91dCBvZiBib3VuZHNcIik7dD12b2lkIDA9PT1uJiZ2b2lkIDA9PT1yP25ldyBVaW50OEFycmF5KHQpOnZvaWQgMD09PXI/bmV3IFVpbnQ4QXJyYXkodCxuKTpuZXcgVWludDhBcnJheSh0LG4scik7bC5UWVBFRF9BUlJBWV9TVVBQT1JUPyhlPXQpLl9fcHJvdG9fXz1sLnByb3RvdHlwZTplPWYoZSx0KTtyZXR1cm4gZX0oZSx0LG4scik6XCJzdHJpbmdcIj09dHlwZW9mIHQ/ZnVuY3Rpb24oZSx0LG4pe1wic3RyaW5nXCI9PXR5cGVvZiBuJiZcIlwiIT09bnx8KG49XCJ1dGY4XCIpO2lmKCFsLmlzRW5jb2RpbmcobikpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKTt2YXIgcj0wfHAodCxuKSxpPShlPWEoZSxyKSkud3JpdGUodCxuKTtpIT09ciYmKGU9ZS5zbGljZSgwLGkpKTtyZXR1cm4gZX0oZSx0LG4pOmZ1bmN0aW9uKGUsdCl7aWYobC5pc0J1ZmZlcih0KSl7dmFyIG49MHxoKHQubGVuZ3RoKTtyZXR1cm4gMD09PShlPWEoZSxuKSkubGVuZ3RofHx0LmNvcHkoZSwwLDAsbiksZX1pZih0KXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2YgQXJyYXlCdWZmZXImJnQuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJ8fFwibGVuZ3RoXCJpbiB0KXJldHVyblwibnVtYmVyXCIhPXR5cGVvZiB0Lmxlbmd0aHx8ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPWV9KHQubGVuZ3RoKT9hKGUsMCk6ZihlLHQpO2lmKFwiQnVmZmVyXCI9PT10LnR5cGUmJnModC5kYXRhKSlyZXR1cm4gZihlLHQuZGF0YSl9dGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC5cIil9KGUsdCl9ZnVuY3Rpb24gdShlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyk7aWYoZTwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpfWZ1bmN0aW9uIGMoZSx0KXtpZih1KHQpLGU9YShlLHQ8MD8wOjB8aCh0KSksIWwuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IodmFyIG49MDtuPHQ7KytuKWVbbl09MDtyZXR1cm4gZX1mdW5jdGlvbiBmKGUsdCl7dmFyIG49dC5sZW5ndGg8MD8wOjB8aCh0Lmxlbmd0aCk7ZT1hKGUsbik7Zm9yKHZhciByPTA7cjxuO3IrPTEpZVtyXT0yNTUmdFtyXTtyZXR1cm4gZX1mdW5jdGlvbiBoKGUpe2lmKGU+PW4oKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIituKCkudG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpO3JldHVybiAwfGV9ZnVuY3Rpb24gcChlLHQpe2lmKGwuaXNCdWZmZXIoZSkpcmV0dXJuIGUubGVuZ3RoO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3JiYoQXJyYXlCdWZmZXIuaXNWaWV3KGUpfHxlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXJldHVybiBlLmJ5dGVMZW5ndGg7XCJzdHJpbmdcIiE9dHlwZW9mIGUmJihlPVwiXCIrZSk7dmFyIG49ZS5sZW5ndGg7aWYoMD09PW4pcmV0dXJuIDA7Zm9yKHZhciByPSExOzspc3dpdGNoKHQpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIG47Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZSB2b2lkIDA6cmV0dXJuIHgoZSkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiAyKm47Y2FzZVwiaGV4XCI6cmV0dXJuIG4+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBVKGUpLmxlbmd0aDtkZWZhdWx0OmlmKHIpcmV0dXJuIHgoZSkubGVuZ3RoO3Q9KFwiXCIrdCkudG9Mb3dlckNhc2UoKSxyPSEwfX1mdW5jdGlvbiBkKGUsdCxuKXt2YXIgcj1lW3RdO2VbdF09ZVtuXSxlW25dPXJ9ZnVuY3Rpb24gZyhlLHQsbixyLGkpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4tMTtpZihcInN0cmluZ1wiPT10eXBlb2Ygbj8ocj1uLG49MCk6MjE0NzQ4MzY0NzxuP249MjE0NzQ4MzY0NzpuPC0yMTQ3NDgzNjQ4JiYobj0tMjE0NzQ4MzY0OCksbj0rbixpc05hTihuKSYmKG49aT8wOmUubGVuZ3RoLTEpLG48MCYmKG49ZS5sZW5ndGgrbiksbj49ZS5sZW5ndGgpe2lmKGkpcmV0dXJuLTE7bj1lLmxlbmd0aC0xfWVsc2UgaWYobjwwKXtpZighaSlyZXR1cm4tMTtuPTB9aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PWwuZnJvbSh0LHIpKSxsLmlzQnVmZmVyKHQpKXJldHVybiAwPT09dC5sZW5ndGg/LTE6eShlLHQsbixyLGkpO2lmKFwibnVtYmVyXCI9PXR5cGVvZiB0KXJldHVybiB0Jj0yNTUsbC5UWVBFRF9BUlJBWV9TVVBQT1JUJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mP2k/VWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUsdCxuKTpVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUsdCxuKTp5KGUsW3RdLG4scixpKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIHkoZSx0LG4scixpKXt2YXIgbyxzPTEsYT1lLmxlbmd0aCx1PXQubGVuZ3RoO2lmKHZvaWQgMCE9PXImJihcInVjczJcIj09PShyPVN0cmluZyhyKS50b0xvd2VyQ2FzZSgpKXx8XCJ1Y3MtMlwiPT09cnx8XCJ1dGYxNmxlXCI9PT1yfHxcInV0Zi0xNmxlXCI9PT1yKSl7aWYoZS5sZW5ndGg8Mnx8dC5sZW5ndGg8MilyZXR1cm4tMTthLz1zPTIsdS89MixuLz0yfWZ1bmN0aW9uIGMoZSx0KXtyZXR1cm4gMT09PXM/ZVt0XTplLnJlYWRVSW50MTZCRSh0KnMpfWlmKGkpe3ZhciBmPS0xO2ZvcihvPW47bzxhO28rKylpZihjKGUsbyk9PT1jKHQsLTE9PT1mPzA6by1mKSl7aWYoLTE9PT1mJiYoZj1vKSxvLWYrMT09PXUpcmV0dXJuIGYqc31lbHNlLTEhPT1mJiYoby09by1mKSxmPS0xfWVsc2UgZm9yKGE8bit1JiYobj1hLXUpLG89bjswPD1vO28tLSl7Zm9yKHZhciBsPSEwLGg9MDtoPHU7aCsrKWlmKGMoZSxvK2gpIT09Yyh0LGgpKXtsPSExO2JyZWFrfWlmKGwpcmV0dXJuIG99cmV0dXJuLTF9ZnVuY3Rpb24gdihlLHQsbixyKXtuPU51bWJlcihuKXx8MDt2YXIgaT1lLmxlbmd0aC1uO3I/aTwocj1OdW1iZXIocikpJiYocj1pKTpyPWk7dmFyIG89dC5sZW5ndGg7aWYobyUyIT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7by8yPHImJihyPW8vMik7Zm9yKHZhciBzPTA7czxyOysrcyl7dmFyIGE9cGFyc2VJbnQodC5zdWJzdHIoMipzLDIpLDE2KTtpZihpc05hTihhKSlyZXR1cm4gcztlW24rc109YX1yZXR1cm4gc31mdW5jdGlvbiBiKGUsdCxuLHIpe3JldHVybiBCKGZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxuPTA7bjxlLmxlbmd0aDsrK24pdC5wdXNoKDI1NSZlLmNoYXJDb2RlQXQobikpO3JldHVybiB0fSh0KSxlLG4scil9ZnVuY3Rpb24gbShlLHQsbil7cmV0dXJuIDA9PT10JiZuPT09ZS5sZW5ndGg/ci5mcm9tQnl0ZUFycmF5KGUpOnIuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHQsbikpfWZ1bmN0aW9uIF8oZSx0LG4pe249TWF0aC5taW4oZS5sZW5ndGgsbik7Zm9yKHZhciByPVtdLGk9dDtpPG47KXt2YXIgbyxzLGEsdSxjPWVbaV0sZj1udWxsLGw9MjM5PGM/NDoyMjM8Yz8zOjE5MTxjPzI6MTtpZihpK2w8PW4pc3dpdGNoKGwpe2Nhc2UgMTpjPDEyOCYmKGY9Yyk7YnJlYWs7Y2FzZSAyOjEyOD09KDE5MiYobz1lW2krMV0pKSYmMTI3PCh1PSgzMSZjKTw8Nnw2MyZvKSYmKGY9dSk7YnJlYWs7Y2FzZSAzOm89ZVtpKzFdLHM9ZVtpKzJdLDEyOD09KDE5MiZvKSYmMTI4PT0oMTkyJnMpJiYyMDQ3PCh1PSgxNSZjKTw8MTJ8KDYzJm8pPDw2fDYzJnMpJiYodTw1NTI5Nnx8NTczNDM8dSkmJihmPXUpO2JyZWFrO2Nhc2UgNDpvPWVbaSsxXSxzPWVbaSsyXSxhPWVbaSszXSwxMjg9PSgxOTImbykmJjEyOD09KDE5MiZzKSYmMTI4PT0oMTkyJmEpJiY2NTUzNTwodT0oMTUmYyk8PDE4fCg2MyZvKTw8MTJ8KDYzJnMpPDw2fDYzJmEpJiZ1PDExMTQxMTImJihmPXUpfW51bGw9PT1mPyhmPTY1NTMzLGw9MSk6NjU1MzU8ZiYmKGYtPTY1NTM2LHIucHVzaChmPj4+MTAmMTAyM3w1NTI5NiksZj01NjMyMHwxMDIzJmYpLHIucHVzaChmKSxpKz1sfXJldHVybiBmdW5jdGlvbihlKXt2YXIgdD1lLmxlbmd0aDtpZih0PD1rKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlKTt2YXIgbj1cIlwiLHI9MDtmb3IoO3I8dDspbis9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsZS5zbGljZShyLHIrPWspKTtyZXR1cm4gbn0ocil9SS5CdWZmZXI9bCxJLlNsb3dCdWZmZXI9ZnVuY3Rpb24oZSl7K2UhPWUmJihlPTApO3JldHVybiBsLmFsbG9jKCtlKX0sSS5JTlNQRUNUX01BWF9CWVRFUz01MCxsLlRZUEVEX0FSUkFZX1NVUFBPUlQ9dm9pZCAwIT09ZS5UWVBFRF9BUlJBWV9TVVBQT1JUP2UuVFlQRURfQVJSQVlfU1VQUE9SVDpmdW5jdGlvbigpe3RyeXt2YXIgZT1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gZS5fX3Byb3RvX189e19fcHJvdG9fXzpVaW50OEFycmF5LnByb3RvdHlwZSxmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fSw0Mj09PWUuZm9vKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUuc3ViYXJyYXkmJjA9PT1lLnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaChlKXtyZXR1cm4hMX19KCksSS5rTWF4TGVuZ3RoPW4oKSxsLnBvb2xTaXplPTgxOTIsbC5fYXVnbWVudD1mdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX189bC5wcm90b3R5cGUsZX0sbC5mcm9tPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gaShudWxsLGUsdCxuKX0sbC5UWVBFRF9BUlJBWV9TVVBQT1JUJiYobC5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLGwuX19wcm90b19fPVVpbnQ4QXJyYXksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnNwZWNpZXMmJmxbU3ltYm9sLnNwZWNpZXNdPT09bCYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGwsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwfSkpLGwuYWxsb2M9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gdSh0KSx0PD0wP2EoZSx0KTp2b2lkIDAhPT1uP1wic3RyaW5nXCI9PXR5cGVvZiByP2EoZSx0KS5maWxsKG4scik6YShlLHQpLmZpbGwobik6YShlLHQpfShudWxsLGUsdCxuKX0sbC5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtyZXR1cm4gYyhudWxsLGUpfSxsLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gYyhudWxsLGUpfSxsLmlzQnVmZmVyPWZ1bmN0aW9uKGUpe3JldHVybiEobnVsbD09ZXx8IWUuX2lzQnVmZmVyKX0sbC5jb21wYXJlPWZ1bmN0aW9uKGUsdCl7aWYoIWwuaXNCdWZmZXIoZSl8fCFsLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzXCIpO2lmKGU9PT10KXJldHVybiAwO2Zvcih2YXIgbj1lLmxlbmd0aCxyPXQubGVuZ3RoLGk9MCxvPU1hdGgubWluKG4scik7aTxvOysraSlpZihlW2ldIT09dFtpXSl7bj1lW2ldLHI9dFtpXTticmVha31yZXR1cm4gbjxyPy0xOnI8bj8xOjB9LGwuaXNFbmNvZGluZz1mdW5jdGlvbihlKXtzd2l0Y2goU3RyaW5nKGUpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19LGwuY29uY2F0PWZ1bmN0aW9uKGUsdCl7aWYoIXMoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoMD09PWUubGVuZ3RoKXJldHVybiBsLmFsbG9jKDApO3ZhciBuO2lmKHZvaWQgMD09PXQpZm9yKG49dD0wO248ZS5sZW5ndGg7KytuKXQrPWVbbl0ubGVuZ3RoO3ZhciByPWwuYWxsb2NVbnNhZmUodCksaT0wO2ZvcihuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciBvPWVbbl07aWYoIWwuaXNCdWZmZXIobykpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7by5jb3B5KHIsaSksaSs9by5sZW5ndGh9cmV0dXJuIHJ9LGwuYnl0ZUxlbmd0aD1wLGwucHJvdG90eXBlLl9pc0J1ZmZlcj0hMCxsLnByb3RvdHlwZS5zd2FwMTY9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTIhPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0c1wiKTtmb3IodmFyIHQ9MDt0PGU7dCs9MilkKHRoaXMsdCx0KzEpO3JldHVybiB0aGlzfSxsLnByb3RvdHlwZS5zd2FwMzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTQhPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0c1wiKTtmb3IodmFyIHQ9MDt0PGU7dCs9NClkKHRoaXMsdCx0KzMpLGQodGhpcyx0KzEsdCsyKTtyZXR1cm4gdGhpc30sbC5wcm90b3R5cGUuc3dhcDY0PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZSU4IT0wKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHNcIik7Zm9yKHZhciB0PTA7dDxlO3QrPTgpZCh0aGlzLHQsdCs3KSxkKHRoaXMsdCsxLHQrNiksZCh0aGlzLHQrMix0KzUpLGQodGhpcyx0KzMsdCs0KTtyZXR1cm4gdGhpc30sbC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXt2YXIgZT0wfHRoaXMubGVuZ3RoO3JldHVybiAwPT1lP1wiXCI6MD09PWFyZ3VtZW50cy5sZW5ndGg/Xyh0aGlzLDAsZSk6ZnVuY3Rpb24oZSx0LG4pe3ZhciByPSExO2lmKCh2b2lkIDA9PT10fHx0PDApJiYodD0wKSx0PnRoaXMubGVuZ3RoKXJldHVyblwiXCI7aWYoKHZvaWQgMD09PW58fG4+dGhpcy5sZW5ndGgpJiYobj10aGlzLmxlbmd0aCksbjw9MClyZXR1cm5cIlwiO2lmKChuPj4+PTApPD0odD4+Pj0wKSlyZXR1cm5cIlwiO2ZvcihlPWV8fFwidXRmOFwiOzspc3dpdGNoKGUpe2Nhc2VcImhleFwiOnJldHVybiBUKHRoaXMsdCxuKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gXyh0aGlzLHQsbik7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gUCh0aGlzLHQsbik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHcodGhpcyx0LG4pO2Nhc2VcImJhc2U2NFwiOnJldHVybiBtKHRoaXMsdCxuKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gTyh0aGlzLHQsbik7ZGVmYXVsdDppZihyKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitlKTtlPShlK1wiXCIpLnRvTG93ZXJDYXNlKCkscj0hMH19LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbC5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uKGUpe2lmKCFsLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO3JldHVybiB0aGlzPT09ZXx8MD09PWwuY29tcGFyZSh0aGlzLGUpfSxsLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uKCl7dmFyIGU9XCJcIix0PUkuSU5TUEVDVF9NQVhfQllURVM7cmV0dXJuIDA8dGhpcy5sZW5ndGgmJihlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLm1hdGNoKC8uezJ9L2cpLmpvaW4oXCIgXCIpLHRoaXMubGVuZ3RoPnQmJihlKz1cIiAuLi4gXCIpKSxcIjxCdWZmZXIgXCIrZStcIj5cIn0sbC5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihlLHQsbixyLGkpe2lmKCFsLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO2lmKHZvaWQgMD09PXQmJih0PTApLHZvaWQgMD09PW4mJihuPWU/ZS5sZW5ndGg6MCksdm9pZCAwPT09ciYmKHI9MCksdm9pZCAwPT09aSYmKGk9dGhpcy5sZW5ndGgpLHQ8MHx8bj5lLmxlbmd0aHx8cjwwfHxpPnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwib3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKGk8PXImJm48PXQpcmV0dXJuIDA7aWYoaTw9cilyZXR1cm4tMTtpZihuPD10KXJldHVybiAxO2lmKHRoaXM9PT1lKXJldHVybiAwO2Zvcih2YXIgbz0oaT4+Pj0wKS0ocj4+Pj0wKSxzPShuPj4+PTApLSh0Pj4+PTApLGE9TWF0aC5taW4obyxzKSx1PXRoaXMuc2xpY2UocixpKSxjPWUuc2xpY2UodCxuKSxmPTA7ZjxhOysrZilpZih1W2ZdIT09Y1tmXSl7bz11W2ZdLHM9Y1tmXTticmVha31yZXR1cm4gbzxzPy0xOnM8bz8xOjB9LGwucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4tMSE9PXRoaXMuaW5kZXhPZihlLHQsbil9LGwucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBnKHRoaXMsZSx0LG4sITApfSxsLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGcodGhpcyxlLHQsbiwhMSl9LGwucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKHZvaWQgMD09PXQpcj1cInV0ZjhcIixuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKHZvaWQgMD09PW4mJlwic3RyaW5nXCI9PXR5cGVvZiB0KXI9dCxuPXRoaXMubGVuZ3RoLHQ9MDtlbHNle2lmKCFpc0Zpbml0ZSh0KSl0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTt0fD0wLGlzRmluaXRlKG4pPyhufD0wLHZvaWQgMD09PXImJihyPVwidXRmOFwiKSk6KHI9bixuPXZvaWQgMCl9dmFyIGk9dGhpcy5sZW5ndGgtdDtpZigodm9pZCAwPT09bnx8aTxuKSYmKG49aSksMDxlLmxlbmd0aCYmKG48MHx8dDwwKXx8dD50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzXCIpO3I9cnx8XCJ1dGY4XCI7Zm9yKHZhciBvLHMsYSx1LGMsZixsLGgscCxkPSExOzspc3dpdGNoKHIpe2Nhc2VcImhleFwiOnJldHVybiB2KHRoaXMsZSx0LG4pO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBoPXQscD1uLEIoeChlLChsPXRoaXMpLmxlbmd0aC1oKSxsLGgscCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYih0aGlzLGUsdCxuKTtjYXNlXCJsYXRpbjFcIjpjYXNlXCJiaW5hcnlcIjpyZXR1cm4gYih0aGlzLGUsdCxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gdT10aGlzLGM9dCxmPW4sQihVKGUpLHUsYyxmKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gcz10LGE9bixCKGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuLHIsaSxvPVtdLHM9MDtzPGUubGVuZ3RoJiYhKCh0LT0yKTwwKTsrK3Mpbj1lLmNoYXJDb2RlQXQocykscj1uPj44LGk9biUyNTYsby5wdXNoKGkpLG8ucHVzaChyKTtyZXR1cm4gb30oZSwobz10aGlzKS5sZW5ndGgtcyksbyxzLGEpO2RlZmF1bHQ6aWYoZCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcik7cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpLGQ9ITB9fSxsLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07dmFyIGs9NDA5NjtmdW5jdGlvbiBQKGUsdCxuKXt2YXIgcj1cIlwiO249TWF0aC5taW4oZS5sZW5ndGgsbik7Zm9yKHZhciBpPXQ7aTxuOysraSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyZlW2ldKTtyZXR1cm4gcn1mdW5jdGlvbiB3KGUsdCxuKXt2YXIgcj1cIlwiO249TWF0aC5taW4oZS5sZW5ndGgsbik7Zm9yKHZhciBpPXQ7aTxuOysraSlyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbaV0pO3JldHVybiByfWZ1bmN0aW9uIFQoZSx0LG4pe3ZhciByPWUubGVuZ3RoOyghdHx8dDwwKSYmKHQ9MCksKCFufHxuPDB8fHI8bikmJihuPXIpO2Zvcih2YXIgaT1cIlwiLG89dDtvPG47KytvKWkrPU4oZVtvXSk7cmV0dXJuIGl9ZnVuY3Rpb24gTyhlLHQsbil7Zm9yKHZhciByPWUuc2xpY2UodCxuKSxpPVwiXCIsbz0wO288ci5sZW5ndGg7bys9MilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHJbb10rMjU2KnJbbysxXSk7cmV0dXJuIGl9ZnVuY3Rpb24gUyhlLHQsbil7aWYoZSUxIT0wfHxlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYobjxlK3QpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfWZ1bmN0aW9uIE0oZSx0LG4scixpLG8pe2lmKCFsLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKGk8dHx8dDxvKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKG4rcj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiBFKGUsdCxuLHIpe3Q8MCYmKHQ9NjU1MzUrdCsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKGUubGVuZ3RoLW4sMik7aTxvOysraSllW24raV09KHQmMjU1PDw4KihyP2k6MS1pKSk+Pj44KihyP2k6MS1pKX1mdW5jdGlvbiBBKGUsdCxuLHIpe3Q8MCYmKHQ9NDI5NDk2NzI5NSt0KzEpO2Zvcih2YXIgaT0wLG89TWF0aC5taW4oZS5sZW5ndGgtbiw0KTtpPG87KytpKWVbbitpXT10Pj4+OCoocj9pOjMtaSkmMjU1fWZ1bmN0aW9uIEMoZSx0LG4scil7aWYobityPmUubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO2lmKG48MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiBSKGUsdCxuLHIsaSl7cmV0dXJuIGl8fEMoZSwwLG4sNCksby53cml0ZShlLHQsbixyLDIzLDQpLG4rNH1mdW5jdGlvbiBqKGUsdCxuLHIsaSl7cmV0dXJuIGl8fEMoZSwwLG4sOCksby53cml0ZShlLHQsbixyLDUyLDgpLG4rOH1sLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbihlLHQpe3ZhciBuLHI9dGhpcy5sZW5ndGg7aWYoKGU9fn5lKTwwPyhlKz1yKTwwJiYoZT0wKTpyPGUmJihlPXIpLCh0PXZvaWQgMD09PXQ/cjp+fnQpPDA/KHQrPXIpPDAmJih0PTApOnI8dCYmKHQ9ciksdDxlJiYodD1lKSxsLlRZUEVEX0FSUkFZX1NVUFBPUlQpKG49dGhpcy5zdWJhcnJheShlLHQpKS5fX3Byb3RvX189bC5wcm90b3R5cGU7ZWxzZXt2YXIgaT10LWU7bj1uZXcgbChpLHZvaWQgMCk7Zm9yKHZhciBvPTA7bzxpOysrbyluW29dPXRoaXNbbytlXX1yZXR1cm4gbn0sbC5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbihlLHQsbil7ZXw9MCx0fD0wLG58fFMoZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIHI9dGhpc1tlXSxpPTEsbz0wOysrbzx0JiYoaSo9MjU2KTspcis9dGhpc1tlK29dKmk7cmV0dXJuIHJ9LGwucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24oZSx0LG4pe2V8PTAsdHw9MCxufHxTKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciByPXRoaXNbZSstLXRdLGk9MTswPHQmJihpKj0yNTYpOylyKz10aGlzW2UrLS10XSppO3JldHVybiByfSxsLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8UyhlLDEsdGhpcy5sZW5ndGgpLHRoaXNbZV19LGwucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsMix0aGlzLmxlbmd0aCksdGhpc1tlXXx0aGlzW2UrMV08PDh9LGwucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsMix0aGlzLmxlbmd0aCksdGhpc1tlXTw8OHx0aGlzW2UrMV19LGwucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsNCx0aGlzLmxlbmd0aCksKHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTYpKzE2Nzc3MjE2KnRoaXNbZSszXX0sbC5wcm90b3R5cGUucmVhZFVJbnQzMkJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSw0LHRoaXMubGVuZ3RoKSwxNjc3NzIxNip0aGlzW2VdKyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfSxsLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24oZSx0LG4pe2V8PTAsdHw9MCxufHxTKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciByPXRoaXNbZV0saT0xLG89MDsrK288dCYmKGkqPTI1Nik7KXIrPXRoaXNbZStvXSppO3JldHVybihpKj0xMjgpPD1yJiYoci09TWF0aC5wb3coMiw4KnQpKSxyfSxsLnByb3RvdHlwZS5yZWFkSW50QkU9ZnVuY3Rpb24oZSx0LG4pe2V8PTAsdHw9MCxufHxTKGUsdCx0aGlzLmxlbmd0aCk7Zm9yKHZhciByPXQsaT0xLG89dGhpc1tlKy0tcl07MDxyJiYoaSo9MjU2KTspbys9dGhpc1tlKy0tcl0qaTtyZXR1cm4oaSo9MTI4KTw9byYmKG8tPU1hdGgucG93KDIsOCp0KSksb30sbC5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8UyhlLDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW2VdPy0xKigyNTUtdGhpc1tlXSsxKTp0aGlzW2VdfSxsLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbihlLHQpe3R8fFMoZSwyLHRoaXMubGVuZ3RoKTt2YXIgbj10aGlzW2VdfHRoaXNbZSsxXTw8ODtyZXR1cm4gMzI3Njgmbj80Mjk0OTAxNzYwfG46bn0sbC5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24oZSx0KXt0fHxTKGUsMix0aGlzLmxlbmd0aCk7dmFyIG49dGhpc1tlKzFdfHRoaXNbZV08PDg7cmV0dXJuIDMyNzY4Jm4/NDI5NDkwMTc2MHxuOm59LGwucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSw0LHRoaXMubGVuZ3RoKSx0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9LGwucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSw0LHRoaXMubGVuZ3RoKSx0aGlzW2VdPDwyNHx0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM119LGwucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSw0LHRoaXMubGVuZ3RoKSxvLnJlYWQodGhpcyxlLCEwLDIzLDQpfSxsLnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbihlLHQpe3JldHVybiB0fHxTKGUsNCx0aGlzLmxlbmd0aCksby5yZWFkKHRoaXMsZSwhMSwyMyw0KX0sbC5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR8fFMoZSw4LHRoaXMubGVuZ3RoKSxvLnJlYWQodGhpcyxlLCEwLDUyLDgpfSxsLnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdHx8UyhlLDgsdGhpcy5sZW5ndGgpLG8ucmVhZCh0aGlzLGUsITEsNTIsOCl9LGwucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKGUsdCxuLHIpe2U9K2UsdHw9MCxufD0wLHJ8fE0odGhpcyxlLHQsbixNYXRoLnBvdygyLDgqbiktMSwwKTt2YXIgaT0xLG89MDtmb3IodGhpc1t0XT0yNTUmZTsrK288biYmKGkqPTI1Nik7KXRoaXNbdCtvXT1lL2kmMjU1O3JldHVybiB0K259LGwucHJvdG90eXBlLndyaXRlVUludEJFPWZ1bmN0aW9uKGUsdCxuLHIpe2U9K2UsdHw9MCxufD0wLHJ8fE0odGhpcyxlLHQsbixNYXRoLnBvdygyLDgqbiktMSwwKTt2YXIgaT1uLTEsbz0xO2Zvcih0aGlzW3QraV09MjU1JmU7MDw9LS1pJiYobyo9MjU2KTspdGhpc1t0K2ldPWUvbyYyNTU7cmV0dXJuIHQrbn0sbC5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdHw9MCxufHxNKHRoaXMsZSx0LDEsMjU1LDApLGwuVFlQRURfQVJSQVlfU1VQUE9SVHx8KGU9TWF0aC5mbG9vcihlKSksdGhpc1t0XT0yNTUmZSx0KzF9LGwucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHR8PTAsbnx8TSh0aGlzLGUsdCwyLDY1NTM1LDApLGwuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgpOkUodGhpcyxlLHQsITApLHQrMn0sbC5wcm90b3R5cGUud3JpdGVVSW50MTZCRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdHw9MCxufHxNKHRoaXMsZSx0LDIsNjU1MzUsMCksbC5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW3RdPWU+Pj44LHRoaXNbdCsxXT0yNTUmZSk6RSh0aGlzLGUsdCwhMSksdCsyfSxsLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0fD0wLG58fE0odGhpcyxlLHQsNCw0Mjk0OTY3Mjk1LDApLGwuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0KzNdPWU+Pj4yNCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCsxXT1lPj4+OCx0aGlzW3RdPTI1NSZlKTpBKHRoaXMsZSx0LCEwKSx0KzR9LGwucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHR8PTAsbnx8TSh0aGlzLGUsdCw0LDQyOTQ5NjcyOTUsMCksbC5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW3RdPWU+Pj4yNCx0aGlzW3QrMV09ZT4+PjE2LHRoaXNbdCsyXT1lPj4+OCx0aGlzW3QrM109MjU1JmUpOkEodGhpcyxlLHQsITEpLHQrNH0sbC5wcm90b3R5cGUud3JpdGVJbnRMRT1mdW5jdGlvbihlLHQsbixyKXtpZihlPStlLHR8PTAsIXIpe3ZhciBpPU1hdGgucG93KDIsOCpuLTEpO00odGhpcyxlLHQsbixpLTEsLWkpfXZhciBvPTAscz0xLGE9MDtmb3IodGhpc1t0XT0yNTUmZTsrK288biYmKHMqPTI1Nik7KWU8MCYmMD09PWEmJjAhPT10aGlzW3Qrby0xXSYmKGE9MSksdGhpc1t0K29dPShlL3M+PjApLWEmMjU1O3JldHVybiB0K259LGwucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24oZSx0LG4scil7aWYoZT0rZSx0fD0wLCFyKXt2YXIgaT1NYXRoLnBvdygyLDgqbi0xKTtNKHRoaXMsZSx0LG4saS0xLC1pKX12YXIgbz1uLTEscz0xLGE9MDtmb3IodGhpc1t0K29dPTI1NSZlOzA8PS0tbyYmKHMqPTI1Nik7KWU8MCYmMD09PWEmJjAhPT10aGlzW3QrbysxXSYmKGE9MSksdGhpc1t0K29dPShlL3M+PjApLWEmMjU1O3JldHVybiB0K259LGwucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdHw9MCxufHxNKHRoaXMsZSx0LDEsMTI3LC0xMjgpLGwuVFlQRURfQVJSQVlfU1VQUE9SVHx8KGU9TWF0aC5mbG9vcihlKSksZTwwJiYoZT0yNTUrZSsxKSx0aGlzW3RdPTI1NSZlLHQrMX0sbC5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0fD0wLG58fE0odGhpcyxlLHQsMiwzMjc2NywtMzI3NjgpLGwuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgpOkUodGhpcyxlLHQsITApLHQrMn0sbC5wcm90b3R5cGUud3JpdGVJbnQxNkJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0fD0wLG58fE0odGhpcyxlLHQsMiwzMjc2NywtMzI3NjgpLGwuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+OCx0aGlzW3QrMV09MjU1JmUpOkUodGhpcyxlLHQsITEpLHQrMn0sbC5wcm90b3R5cGUud3JpdGVJbnQzMkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0fD0wLG58fE0odGhpcyxlLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSxsLlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbdF09MjU1JmUsdGhpc1t0KzFdPWU+Pj44LHRoaXNbdCsyXT1lPj4+MTYsdGhpc1t0KzNdPWU+Pj4yNCk6QSh0aGlzLGUsdCwhMCksdCs0fSxsLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHR8PTAsbnx8TSh0aGlzLGUsdCw0LDIxNDc0ODM2NDcsLTIxNDc0ODM2NDgpLGU8MCYmKGU9NDI5NDk2NzI5NStlKzEpLGwuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1t0XT1lPj4+MjQsdGhpc1t0KzFdPWU+Pj4xNix0aGlzW3QrMl09ZT4+PjgsdGhpc1t0KzNdPTI1NSZlKTpBKHRoaXMsZSx0LCExKSx0KzR9LGwucHJvdG90eXBlLndyaXRlRmxvYXRMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIFIodGhpcyxlLHQsITAsbil9LGwucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIFIodGhpcyxlLHQsITEsbil9LGwucHJvdG90eXBlLndyaXRlRG91YmxlTEU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBqKHRoaXMsZSx0LCEwLG4pfSxsLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gaih0aGlzLGUsdCwhMSxuKX0sbC5wcm90b3R5cGUuY29weT1mdW5jdGlvbihlLHQsbixyKXtpZihuPW58fDAscnx8MD09PXJ8fChyPXRoaXMubGVuZ3RoKSx0Pj1lLmxlbmd0aCYmKHQ9ZS5sZW5ndGgpLHQ9dHx8MCwwPHImJnI8biYmKHI9bikscj09PW4pcmV0dXJuIDA7aWYoMD09PWUubGVuZ3RofHwwPT09dGhpcy5sZW5ndGgpcmV0dXJuIDA7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtpZihuPDB8fG4+PXRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlU3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtpZihyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtyPnRoaXMubGVuZ3RoJiYocj10aGlzLmxlbmd0aCksZS5sZW5ndGgtdDxyLW4mJihyPWUubGVuZ3RoLXQrbik7dmFyIGksbz1yLW47aWYodGhpcz09PWUmJm48dCYmdDxyKWZvcihpPW8tMTswPD1pOy0taSllW2krdF09dGhpc1tpK25dO2Vsc2UgaWYobzwxZTN8fCFsLlRZUEVEX0FSUkFZX1NVUFBPUlQpZm9yKGk9MDtpPG87KytpKWVbaSt0XT10aGlzW2krbl07ZWxzZSBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChlLHRoaXMuc3ViYXJyYXkobixuK28pLHQpO3JldHVybiBvfSxsLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgdD8ocj10LHQ9MCxuPXRoaXMubGVuZ3RoKTpcInN0cmluZ1wiPT10eXBlb2YgbiYmKHI9bixuPXRoaXMubGVuZ3RoKSwxPT09ZS5sZW5ndGgpe3ZhciBpPWUuY2hhckNvZGVBdCgwKTtpPDI1NiYmKGU9aSl9aWYodm9pZCAwIT09ciYmXCJzdHJpbmdcIiE9dHlwZW9mIHIpdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHImJiFsLmlzRW5jb2RpbmcocikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3IpfWVsc2VcIm51bWJlclwiPT10eXBlb2YgZSYmKGUmPTI1NSk7aWYodDwwfHx0aGlzLmxlbmd0aDx0fHx0aGlzLmxlbmd0aDxuKXRocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKG48PXQpcmV0dXJuIHRoaXM7dmFyIG87aWYodD4+Pj0wLG49dm9pZCAwPT09bj90aGlzLmxlbmd0aDpuPj4+MCxcIm51bWJlclwiPT10eXBlb2YoZT1lfHwwKSlmb3Iobz10O288bjsrK28pdGhpc1tvXT1lO2Vsc2V7dmFyIHM9bC5pc0J1ZmZlcihlKT9lOngobmV3IGwoZSxyKS50b1N0cmluZygpKSxhPXMubGVuZ3RoO2ZvcihvPTA7bzxuLXQ7KytvKXRoaXNbbyt0XT1zW28lYV19cmV0dXJuIHRoaXN9O3ZhciB0PS9bXitcXC8wLTlBLVphLXotX10vZztmdW5jdGlvbiBOKGUpe3JldHVybiBlPDE2P1wiMFwiK2UudG9TdHJpbmcoMTYpOmUudG9TdHJpbmcoMTYpfWZ1bmN0aW9uIHgoZSx0KXt2YXIgbjt0PXR8fDEvMDtmb3IodmFyIHI9ZS5sZW5ndGgsaT1udWxsLG89W10scz0wO3M8cjsrK3Mpe2lmKDU1Mjk1PChuPWUuY2hhckNvZGVBdChzKSkmJm48NTczNDQpe2lmKCFpKXtpZig1NjMxOTxuKXstMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9aWYocysxPT09cil7LTE8KHQtPTMpJiZvLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWk9bjtjb250aW51ZX1pZihuPDU2MzIwKXstMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSksaT1uO2NvbnRpbnVlfW49NjU1MzYrKGktNTUyOTY8PDEwfG4tNTYzMjApfWVsc2UgaSYmLTE8KHQtPTMpJiZvLnB1c2goMjM5LDE5MSwxODkpO2lmKGk9bnVsbCxuPDEyOCl7aWYoKHQtPTEpPDApYnJlYWs7by5wdXNoKG4pfWVsc2UgaWYobjwyMDQ4KXtpZigodC09Mik8MClicmVhaztvLnB1c2gobj4+NnwxOTIsNjMmbnwxMjgpfWVsc2UgaWYobjw2NTUzNil7aWYoKHQtPTMpPDApYnJlYWs7by5wdXNoKG4+PjEyfDIyNCxuPj42JjYzfDEyOCw2MyZufDEyOCl9ZWxzZXtpZighKG48MTExNDExMikpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpO2lmKCh0LT00KTwwKWJyZWFrO28ucHVzaChuPj4xOHwyNDAsbj4+MTImNjN8MTI4LG4+PjYmNjN8MTI4LDYzJm58MTI4KX19cmV0dXJuIG99ZnVuY3Rpb24gVShlKXtyZXR1cm4gci50b0J5dGVBcnJheShmdW5jdGlvbihlKXtpZigoZT1mdW5jdGlvbihlKXtyZXR1cm4gZS50cmltP2UudHJpbSgpOmUucmVwbGFjZSgvXlxccyt8XFxzKyQvZyxcIlwiKX0oZSkucmVwbGFjZSh0LFwiXCIpKS5sZW5ndGg8MilyZXR1cm5cIlwiO2Zvcig7ZS5sZW5ndGglNCE9MDspZSs9XCI9XCI7cmV0dXJuIGV9KGUpKX1mdW5jdGlvbiBCKGUsdCxuLHIpe2Zvcih2YXIgaT0wO2k8ciYmIShpK24+PXQubGVuZ3RofHxpPj1lLmxlbmd0aCk7KytpKXRbaStuXT1lW2ldO3JldHVybiBpfX0pLmNhbGwodGhpcyxEKDcwKSl9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtlLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIG51bGwhPT1lJiZcIm9iamVjdFwiPT10eXBlb2YgZX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciByPXUobigxMikpLGk9dShuKDY3KSksbz11KG4oNjgpKSxzPXUobig2OSkpLGE9big3NSk7bigwKTtmdW5jdGlvbiB1KGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBjKGUpe3JldHVybihjPVwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcj9mdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGV9OmZ1bmN0aW9uKGUpe3JldHVybiBlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJmUuY29uc3RydWN0b3I9PT1TeW1ib2wmJmUhPT1TeW1ib2wucHJvdG90eXBlP1wic3ltYm9sXCI6dHlwZW9mIGV9KShlKX1mdW5jdGlvbiBmKGUsdCl7cmV0dXJuIXR8fFwib2JqZWN0XCIhPT1jKHQpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0P2Z1bmN0aW9uKGUpe2lmKHZvaWQgMCE9PWUpcmV0dXJuIGU7dGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpfShlKTp0fWZ1bmN0aW9uIGwoZSl7cmV0dXJuKGw9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfWZ1bmN0aW9uIGgoZSx0KXtyZXR1cm4oaD1PYmplY3Quc2V0UHJvdG90eXBlT2Z8fGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUuX19wcm90b19fPXQsZX0pKGUsdCl9ZnVuY3Rpb24gcChlKXtpZighbmF2aWdhdG9yfHwhbmF2aWdhdG9yLnNlbmRCZWFjb24pcmV0dXJuITE7bmF2aWdhdG9yLnNlbmRCZWFjb24oZSl9dmFyIGQ9KGZ1bmN0aW9uKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZoKGUsdCl9KGcsci5kZWZhdWx0KSxnKTtmdW5jdGlvbiBnKGUpe3ZhciB0OyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZyk7dmFyIG49ZS5saXN0ZW5Ub0Jyb3dzZXJOZXR3b3JrRXZlbnRzLHI9dm9pZCAwPT09bnx8bjtyZXR1cm4gZS5kYj1vLmRlZmF1bHQsZS5jYm9yPW5ldyBzLmRlZmF1bHQsZS5zZGtGYW1pbHk9XCJXZWJcIixlLm5ldHdvcmtpbmc9bmV3IGkuZGVmYXVsdCh7ZGVsOmEuZGVsLGdldDphLmdldCxwb3N0OmEucG9zdCxwYXRjaDphLnBhdGNoLHNlbmRCZWFjb246cH0pLHQ9Zih0aGlzLGwoZykuY2FsbCh0aGlzLGUpKSxyJiYod2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJvZmZsaW5lXCIsZnVuY3Rpb24oKXt0Lm5ldHdvcmtEb3duRGV0ZWN0ZWQoKX0pLHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsZnVuY3Rpb24oKXt0Lm5ldHdvcmtVcERldGVjdGVkKCl9KSksdH10LmRlZmF1bHQ9ZCxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcyhlKXtyZXR1cm4ocz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBTeW1ib2wmJlwic3ltYm9sXCI9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3I/ZnVuY3Rpb24oZSl7cmV0dXJuIHR5cGVvZiBlfTpmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZlLmNvbnN0cnVjdG9yPT09U3ltYm9sJiZlIT09U3ltYm9sLnByb3RvdHlwZT9cInN5bWJvbFwiOnR5cGVvZiBlfSkoZSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgeT1mKG4oMykpLHY9ZihuKDYpKSxiPWYobigxNSkpLHI9ZihuKDE4KSksbT1mKG4oNykpLF89ZihuKDE5KSksaz1mKG4oMjApKSxQPWMobigyMSkpLHc9YyhuKDIyKSksVD1jKG4oMjMpKSxPPWMobigyNCkpLFM9YyhuKDI1KSksTT1jKG4oMjYpKSxFPWMobigyNykpLEE9YyhuKDI4KSksQz1jKG4oMjkpKSxSPWMobigzMCkpLGo9YyhuKDMxKSksTj1jKG4oMzIpKSx4PWMobigzMykpLFU9YyhuKDM0KSksQj1jKG4oMzUpKSxJPWMobigzNikpLEQ9YyhuKDM3KSksSz1jKG4oMzgpKSxMPWMobigzOSkpLEY9YyhuKDQwKSksRz1jKG4oNDEpKSxIPWMobig0MikpLHE9YyhuKDQzKSksej1jKG4oNDQpKSxZPWMobig0NSkpLCQ9YyhuKDQ2KSksVz1jKG4oNDcpKSxKPWMobig0OCkpLFg9YyhuKDQ5KSksVj1jKG4oNTApKSxRPWMobig1MSkpLFo9YyhuKDUyKSksZWU9YyhuKDUzKSksdGU9YyhuKDU0KSksbmU9YyhuKDU1KSkscmU9YyhuKDU2KSksaWU9YyhuKDU3KSksb2U9YyhuKDU4KSksc2U9YyhuKDU5KSksYWU9YyhuKDYwKSksdWU9YyhuKDYxKSksY2U9YyhuKDYyKSksZmU9YyhuKDYzKSksbGU9YyhuKDY0KSksaGU9YyhuKDY1KSkscGU9YyhuKDgpKSxkZT1jKG4oNjYpKSxpPWYobigxKSksbz1mKG4oNCkpLGE9KG4oMCksZihuKDUpKSk7ZnVuY3Rpb24gdSgpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIFdlYWtNYXApcmV0dXJuIG51bGw7dmFyIGU9bmV3IFdlYWtNYXA7cmV0dXJuIHU9ZnVuY3Rpb24oKXtyZXR1cm4gZX0sZX1mdW5jdGlvbiBjKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTtpZihudWxsPT09ZXx8XCJvYmplY3RcIiE9PXMoZSkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpcmV0dXJue2RlZmF1bHQ6ZX07dmFyIHQ9dSgpO2lmKHQmJnQuaGFzKGUpKXJldHVybiB0LmdldChlKTt2YXIgbj17fSxyPU9iamVjdC5kZWZpbmVQcm9wZXJ0eSYmT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmb3IodmFyIGkgaW4gZSlpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxpKSl7dmFyIG89cj9PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsaSk6bnVsbDtvJiYoby5nZXR8fG8uc2V0KT9PYmplY3QuZGVmaW5lUHJvcGVydHkobixpLG8pOm5baV09ZVtpXX1yZXR1cm4gbi5kZWZhdWx0PWUsdCYmdC5zZXQoZSxuKSxufWZ1bmN0aW9uIGYoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGwoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIGdlKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgaCxwLGQsZz0oaD15ZSxkPVt7a2V5Olwibm90aWZpY2F0aW9uUGF5bG9hZFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIG5ldyByLmRlZmF1bHQoZSx0KX19LHtrZXk6XCJnZW5lcmF0ZVVVSURcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBhLmRlZmF1bHQuY3JlYXRlVVVJRCgpfX1dLChwPVt7a2V5OlwiZ2V0VmVyc2lvblwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbmZpZy5nZXRWZXJzaW9uKCl9fSx7a2V5OlwiX2FkZFBuc2RrU3VmZml4XCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt0aGlzLl9jb25maWcuX2FkZFBuc2RrU3VmZml4KGUsdCl9fSx7a2V5OlwibmV0d29ya0Rvd25EZXRlY3RlZFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlTmV0d29ya0Rvd24oKSx0aGlzLl9jb25maWcucmVzdG9yZT90aGlzLmRpc2Nvbm5lY3QoKTp0aGlzLmRlc3Ryb3koITApfX0se2tleTpcIm5ldHdvcmtVcERldGVjdGVkXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VOZXR3b3JrVXAoKSx0aGlzLnJlY29ubmVjdCgpfX1dKSYmbChoLnByb3RvdHlwZSxwKSx2b2lkKGQmJmwoaCxkKSkseWUpO2Z1bmN0aW9uIHllKGUpe3ZhciBuPXRoaXM7IWZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx5ZSksZ2UodGhpcyxcIl9jb25maWdcIix2b2lkIDApLGdlKHRoaXMsXCJfbGlzdGVuZXJNYW5hZ2VyXCIsdm9pZCAwKSxnZSh0aGlzLFwiX3Rva2VuTWFuYWdlclwiLHZvaWQgMCksZ2UodGhpcyxcInRpbWVcIix2b2lkIDApLGdlKHRoaXMsXCJwdWJsaXNoXCIsdm9pZCAwKSxnZSh0aGlzLFwiZmlyZVwiLHZvaWQgMCksZ2UodGhpcyxcImhpc3RvcnlcIix2b2lkIDApLGdlKHRoaXMsXCJkZWxldGVNZXNzYWdlc1wiLHZvaWQgMCksZ2UodGhpcyxcIm1lc3NhZ2VDb3VudHNcIix2b2lkIDApLGdlKHRoaXMsXCJmZXRjaE1lc3NhZ2VzXCIsdm9pZCAwKSxnZSh0aGlzLFwiY2hhbm5lbEdyb3Vwc1wiLHZvaWQgMCksZ2UodGhpcyxcInB1c2hcIix2b2lkIDApLGdlKHRoaXMsXCJoZXJlTm93XCIsdm9pZCAwKSxnZSh0aGlzLFwid2hlcmVOb3dcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRTdGF0ZVwiLHZvaWQgMCksZ2UodGhpcyxcInNldFN0YXRlXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ3JhbnRcIix2b2lkIDApLGdlKHRoaXMsXCJncmFudFRva2VuXCIsdm9pZCAwKSxnZSh0aGlzLFwiYXVkaXRcIix2b2lkIDApLGdlKHRoaXMsXCJzdWJzY3JpYmVcIix2b2lkIDApLGdlKHRoaXMsXCJzaWduYWxcIix2b2lkIDApLGdlKHRoaXMsXCJwcmVzZW5jZVwiLHZvaWQgMCksZ2UodGhpcyxcInVuc3Vic2NyaWJlXCIsdm9pZCAwKSxnZSh0aGlzLFwidW5zdWJzY3JpYmVBbGxcIix2b2lkIDApLGdlKHRoaXMsXCJhZGRNZXNzYWdlQWN0aW9uXCIsdm9pZCAwKSxnZSh0aGlzLFwicmVtb3ZlTWVzc2FnZUFjdGlvblwiLHZvaWQgMCksZ2UodGhpcyxcImdldE1lc3NhZ2VBY3Rpb25zXCIsdm9pZCAwKSxnZSh0aGlzLFwiY3JlYXRlVXNlclwiLHZvaWQgMCksZ2UodGhpcyxcInVwZGF0ZVVzZXJcIix2b2lkIDApLGdlKHRoaXMsXCJkZWxldGVVc2VyXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0VXNlclwiLHZvaWQgMCksZ2UodGhpcyxcImdldFVzZXJzXCIsdm9pZCAwKSxnZSh0aGlzLFwiY3JlYXRlU3BhY2VcIix2b2lkIDApLGdlKHRoaXMsXCJ1cGRhdGVTcGFjZVwiLHZvaWQgMCksZ2UodGhpcyxcImRlbGV0ZVNwYWNlXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0U3BhY2VzXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0U3BhY2VcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRNZW1iZXJzXCIsdm9pZCAwKSxnZSh0aGlzLFwiYWRkTWVtYmVyc1wiLHZvaWQgMCksZ2UodGhpcyxcInVwZGF0ZU1lbWJlcnNcIix2b2lkIDApLGdlKHRoaXMsXCJyZW1vdmVNZW1iZXJzXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0TWVtYmVyc2hpcHNcIix2b2lkIDApLGdlKHRoaXMsXCJqb2luU3BhY2VzXCIsdm9pZCAwKSxnZSh0aGlzLFwidXBkYXRlTWVtYmVyc2hpcHNcIix2b2lkIDApLGdlKHRoaXMsXCJsZWF2ZVNwYWNlc1wiLHZvaWQgMCksZ2UodGhpcyxcImRpc2Nvbm5lY3RcIix2b2lkIDApLGdlKHRoaXMsXCJyZWNvbm5lY3RcIix2b2lkIDApLGdlKHRoaXMsXCJkZXN0cm95XCIsdm9pZCAwKSxnZSh0aGlzLFwic3RvcFwiLHZvaWQgMCksZ2UodGhpcyxcImdldFN1YnNjcmliZWRDaGFubmVsc1wiLHZvaWQgMCksZ2UodGhpcyxcImdldFN1YnNjcmliZWRDaGFubmVsR3JvdXBzXCIsdm9pZCAwKSxnZSh0aGlzLFwiYWRkTGlzdGVuZXJcIix2b2lkIDApLGdlKHRoaXMsXCJyZW1vdmVMaXN0ZW5lclwiLHZvaWQgMCksZ2UodGhpcyxcInJlbW92ZUFsbExpc3RlbmVyc1wiLHZvaWQgMCksZ2UodGhpcyxcInBhcnNlVG9rZW5cIix2b2lkIDApLGdlKHRoaXMsXCJzZXRUb2tlblwiLHZvaWQgMCksZ2UodGhpcyxcInNldFRva2Vuc1wiLHZvaWQgMCksZ2UodGhpcyxcImdldFRva2VuXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0VG9rZW5zXCIsdm9pZCAwKSxnZSh0aGlzLFwiY2xlYXJUb2tlbnNcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRBdXRoS2V5XCIsdm9pZCAwKSxnZSh0aGlzLFwic2V0QXV0aEtleVwiLHZvaWQgMCksZ2UodGhpcyxcInNldENpcGhlcktleVwiLHZvaWQgMCksZ2UodGhpcyxcInNldFVVSURcIix2b2lkIDApLGdlKHRoaXMsXCJnZXRVVUlEXCIsdm9pZCAwKSxnZSh0aGlzLFwiZ2V0RmlsdGVyRXhwcmVzc2lvblwiLHZvaWQgMCksZ2UodGhpcyxcInNldEZpbHRlckV4cHJlc3Npb25cIix2b2lkIDApLGdlKHRoaXMsXCJzZXRIZWFydGJlYXRJbnRlcnZhbFwiLHZvaWQgMCksZ2UodGhpcyxcInNldFByb3h5XCIsdm9pZCAwKSxnZSh0aGlzLFwiZW5jcnlwdFwiLHZvaWQgMCksZ2UodGhpcyxcImRlY3J5cHRcIix2b2lkIDApO3ZhciB0PWUuZGIscj1lLm5ldHdvcmtpbmcsaT1lLmNib3Isbz10aGlzLl9jb25maWc9bmV3IHkuZGVmYXVsdCh7c2V0dXA6ZSxkYjp0fSkscz1uZXcgdi5kZWZhdWx0KHtjb25maWc6b30pO3IuaW5pdChvKTt2YXIgYT10aGlzLl90b2tlbk1hbmFnZXI9bmV3IF8uZGVmYXVsdChvLGkpLHU9e2NvbmZpZzpvLG5ldHdvcmtpbmc6cixjcnlwdG86cyx0b2tlbk1hbmFnZXI6YX0sYz1rLmRlZmF1bHQuYmluZCh0aGlzLHUscGUpLGY9ay5kZWZhdWx0LmJpbmQodGhpcyx1LFIpLGw9ay5kZWZhdWx0LmJpbmQodGhpcyx1LE4pLGg9ay5kZWZhdWx0LmJpbmQodGhpcyx1LFUpLHA9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGRlKSxkPXRoaXMuX2xpc3RlbmVyTWFuYWdlcj1uZXcgbS5kZWZhdWx0LGc9bmV3IGIuZGVmYXVsdCh7dGltZUVuZHBvaW50OmMsbGVhdmVFbmRwb2ludDpmLGhlYXJ0YmVhdEVuZHBvaW50Omwsc2V0U3RhdGVFbmRwb2ludDpoLHN1YnNjcmliZUVuZHBvaW50OnAsY3J5cHRvOnUuY3J5cHRvLGNvbmZpZzp1LmNvbmZpZyxsaXN0ZW5lck1hbmFnZXI6ZH0pO3RoaXMuYWRkTGlzdGVuZXI9ZC5hZGRMaXN0ZW5lci5iaW5kKGQpLHRoaXMucmVtb3ZlTGlzdGVuZXI9ZC5yZW1vdmVMaXN0ZW5lci5iaW5kKGQpLHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzPWQucmVtb3ZlQWxsTGlzdGVuZXJzLmJpbmQoZCksdGhpcy5wYXJzZVRva2VuPWEucGFyc2VUb2tlbi5iaW5kKGEpLHRoaXMuc2V0VG9rZW49YS5zZXRUb2tlbi5iaW5kKGEpLHRoaXMuc2V0VG9rZW5zPWEuc2V0VG9rZW5zLmJpbmQoYSksdGhpcy5nZXRUb2tlbj1hLmdldFRva2VuLmJpbmQoYSksdGhpcy5nZXRUb2tlbnM9YS5nZXRUb2tlbnMuYmluZChhKSx0aGlzLmNsZWFyVG9rZW5zPWEuY2xlYXJUb2tlbnMuYmluZChhKSx0aGlzLmNoYW5uZWxHcm91cHM9e2xpc3RHcm91cHM6ay5kZWZhdWx0LmJpbmQodGhpcyx1LE8pLGxpc3RDaGFubmVsczprLmRlZmF1bHQuYmluZCh0aGlzLHUsUyksYWRkQ2hhbm5lbHM6ay5kZWZhdWx0LmJpbmQodGhpcyx1LFApLHJlbW92ZUNoYW5uZWxzOmsuZGVmYXVsdC5iaW5kKHRoaXMsdSx3KSxkZWxldGVHcm91cDprLmRlZmF1bHQuYmluZCh0aGlzLHUsVCl9LHRoaXMucHVzaD17YWRkQ2hhbm5lbHM6ay5kZWZhdWx0LmJpbmQodGhpcyx1LE0pLHJlbW92ZUNoYW5uZWxzOmsuZGVmYXVsdC5iaW5kKHRoaXMsdSxFKSxkZWxldGVEZXZpY2U6ay5kZWZhdWx0LmJpbmQodGhpcyx1LEMpLGxpc3RDaGFubmVsczprLmRlZmF1bHQuYmluZCh0aGlzLHUsQSl9LHRoaXMuaGVyZU5vdz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsQiksdGhpcy53aGVyZU5vdz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsaiksdGhpcy5nZXRTdGF0ZT1rLmRlZmF1bHQuYmluZCh0aGlzLHUseCksdGhpcy5zZXRTdGF0ZT1nLmFkYXB0U3RhdGVDaGFuZ2UuYmluZChnKSx0aGlzLmdyYW50PWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxvZSksdGhpcy5ncmFudFRva2VuPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxzZSksdGhpcy5hdWRpdD1rLmRlZmF1bHQuYmluZCh0aGlzLHUsaWUpLHRoaXMucHVibGlzaD1rLmRlZmF1bHQuYmluZCh0aGlzLHUsYWUpLHRoaXMuZmlyZT1mdW5jdGlvbihlLHQpe3JldHVybiBlLnJlcGxpY2F0ZT0hMSxlLnN0b3JlSW5IaXN0b3J5PSExLG4ucHVibGlzaChlLHQpfSx0aGlzLnNpZ25hbD1rLmRlZmF1bHQuYmluZCh0aGlzLHUsdWUpLHRoaXMuaGlzdG9yeT1rLmRlZmF1bHQuYmluZCh0aGlzLHUsY2UpLHRoaXMuZGVsZXRlTWVzc2FnZXM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGZlKSx0aGlzLm1lc3NhZ2VDb3VudHM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGxlKSx0aGlzLmZldGNoTWVzc2FnZXM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LGhlKSx0aGlzLmFkZE1lc3NhZ2VBY3Rpb249ay5kZWZhdWx0LmJpbmQodGhpcyx1LEkpLHRoaXMucmVtb3ZlTWVzc2FnZUFjdGlvbj1rLmRlZmF1bHQuYmluZCh0aGlzLHUsRCksdGhpcy5nZXRNZXNzYWdlQWN0aW9ucz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsSyksdGhpcy5jcmVhdGVVc2VyPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxMKSx0aGlzLnVwZGF0ZVVzZXI9ay5kZWZhdWx0LmJpbmQodGhpcyx1LEYpLHRoaXMuZGVsZXRlVXNlcj1rLmRlZmF1bHQuYmluZCh0aGlzLHUsRyksdGhpcy5nZXRVc2VyPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxIKSx0aGlzLmdldFVzZXJzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxxKSx0aGlzLmNyZWF0ZVNwYWNlPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSx6KSx0aGlzLnVwZGF0ZVNwYWNlPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxZKSx0aGlzLmRlbGV0ZVNwYWNlPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSwkKSx0aGlzLmdldFNwYWNlcz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsVyksdGhpcy5nZXRTcGFjZT1rLmRlZmF1bHQuYmluZCh0aGlzLHUsSiksdGhpcy5hZGRNZW1iZXJzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxWKSx0aGlzLnVwZGF0ZU1lbWJlcnM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LFEpLHRoaXMucmVtb3ZlTWVtYmVycz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsWiksdGhpcy5nZXRNZW1iZXJzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxYKSx0aGlzLmdldE1lbWJlcnNoaXBzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxlZSksdGhpcy5qb2luU3BhY2VzPWsuZGVmYXVsdC5iaW5kKHRoaXMsdSxuZSksdGhpcy51cGRhdGVNZW1iZXJzaGlwcz1rLmRlZmF1bHQuYmluZCh0aGlzLHUsdGUpLHRoaXMubGVhdmVTcGFjZXM9ay5kZWZhdWx0LmJpbmQodGhpcyx1LHJlKSx0aGlzLnRpbWU9Yyx0aGlzLnN1YnNjcmliZT1nLmFkYXB0U3Vic2NyaWJlQ2hhbmdlLmJpbmQoZyksdGhpcy5wcmVzZW5jZT1nLmFkYXB0UHJlc2VuY2VDaGFuZ2UuYmluZChnKSx0aGlzLnVuc3Vic2NyaWJlPWcuYWRhcHRVbnN1YnNjcmliZUNoYW5nZS5iaW5kKGcpLHRoaXMuZGlzY29ubmVjdD1nLmRpc2Nvbm5lY3QuYmluZChnKSx0aGlzLnJlY29ubmVjdD1nLnJlY29ubmVjdC5iaW5kKGcpLHRoaXMuZGVzdHJveT1mdW5jdGlvbihlKXtnLnVuc3Vic2NyaWJlQWxsKGUpLGcuZGlzY29ubmVjdCgpfSx0aGlzLnN0b3A9dGhpcy5kZXN0cm95LHRoaXMudW5zdWJzY3JpYmVBbGw9Zy51bnN1YnNjcmliZUFsbC5iaW5kKGcpLHRoaXMuZ2V0U3Vic2NyaWJlZENoYW5uZWxzPWcuZ2V0U3Vic2NyaWJlZENoYW5uZWxzLmJpbmQoZyksdGhpcy5nZXRTdWJzY3JpYmVkQ2hhbm5lbEdyb3Vwcz1nLmdldFN1YnNjcmliZWRDaGFubmVsR3JvdXBzLmJpbmQoZyksdGhpcy5lbmNyeXB0PXMuZW5jcnlwdC5iaW5kKHMpLHRoaXMuZGVjcnlwdD1zLmRlY3J5cHQuYmluZChzKSx0aGlzLmdldEF1dGhLZXk9dS5jb25maWcuZ2V0QXV0aEtleS5iaW5kKHUuY29uZmlnKSx0aGlzLnNldEF1dGhLZXk9dS5jb25maWcuc2V0QXV0aEtleS5iaW5kKHUuY29uZmlnKSx0aGlzLnNldENpcGhlcktleT11LmNvbmZpZy5zZXRDaXBoZXJLZXkuYmluZCh1LmNvbmZpZyksdGhpcy5nZXRVVUlEPXUuY29uZmlnLmdldFVVSUQuYmluZCh1LmNvbmZpZyksdGhpcy5zZXRVVUlEPXUuY29uZmlnLnNldFVVSUQuYmluZCh1LmNvbmZpZyksdGhpcy5nZXRGaWx0ZXJFeHByZXNzaW9uPXUuY29uZmlnLmdldEZpbHRlckV4cHJlc3Npb24uYmluZCh1LmNvbmZpZyksdGhpcy5zZXRGaWx0ZXJFeHByZXNzaW9uPXUuY29uZmlnLnNldEZpbHRlckV4cHJlc3Npb24uYmluZCh1LmNvbmZpZyksdGhpcy5zZXRIZWFydGJlYXRJbnRlcnZhbD11LmNvbmZpZy5zZXRIZWFydGJlYXRJbnRlcnZhbC5iaW5kKHUuY29uZmlnKSxyLmhhc01vZHVsZShcInByb3h5XCIpJiYodGhpcy5zZXRQcm94eT1mdW5jdGlvbihlKXt1LmNvbmZpZy5zZXRQcm94eShlKSxuLnJlY29ubmVjdCgpfSl9Z2UodC5kZWZhdWx0PWcsXCJPUEVSQVRJT05TXCIsaS5kZWZhdWx0KSxnZShnLFwiQ0FURUdPUklFU1wiLG8uZGVmYXVsdCksZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe3ZhciByLGksbztpPVt0XSx2b2lkIDA9PT0obz1cImZ1bmN0aW9uXCI9PXR5cGVvZihyPWZ1bmN0aW9uKGUpe3ZhciByPXszOi9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tM1swLTlBLUZdezN9LVswLTlBLUZdezR9LVswLTlBLUZdezEyfSQvaSw0Oi9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tNFswLTlBLUZdezN9LVs4OUFCXVswLTlBLUZdezN9LVswLTlBLUZdezEyfSQvaSw1Oi9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tNVswLTlBLUZdezN9LVs4OUFCXVswLTlBLUZdezN9LVswLTlBLUZdezEyfSQvaSxhbGw6L15bMC05QS1GXXs4fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXs0fS1bMC05QS1GXXsxMn0kL2l9O2Z1bmN0aW9uIHQoKXt2YXIgZSx0LG49XCJcIjtmb3IoZT0wO2U8MzI7ZSsrKXQ9MTYqTWF0aC5yYW5kb20oKXwwLDghPT1lJiYxMiE9PWUmJjE2IT09ZSYmMjAhPT1lfHwobis9XCItXCIpLG4rPSgxMj09PWU/NDoxNj09PWU/MyZ0fDg6dCkudG9TdHJpbmcoMTYpO3JldHVybiBufWZ1bmN0aW9uIG4oZSx0KXt2YXIgbj1yW3R8fFwiYWxsXCJdO3JldHVybiBuJiZuLnRlc3QoZSl8fCExfXQuaXNVVUlEPW4sdC5WRVJTSU9OPVwiMC4xLjBcIixlLnV1aWQ9dCxlLmlzVVVJRD1ufSk/ci5hcHBseSh0LGkpOnIpfHwoZS5leHBvcnRzPW8pfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIHIsYyxpLHUsbyxzLGEsZixsLGgsRT1FfHxmdW5jdGlvbihhKXtmdW5jdGlvbiBuKCl7fXZhciBlPXt9LHQ9ZS5saWI9e30scj10LkJhc2U9e2V4dGVuZDpmdW5jdGlvbihlKXtuLnByb3RvdHlwZT10aGlzO3ZhciB0PW5ldyBuO3JldHVybiBlJiZ0Lm1peEluKGUpLHQuaGFzT3duUHJvcGVydHkoXCJpbml0XCIpfHwodC5pbml0PWZ1bmN0aW9uKCl7dC4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KSwodC5pbml0LnByb3RvdHlwZT10KS4kc3VwZXI9dGhpcyx0fSxjcmVhdGU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmV4dGVuZCgpO3JldHVybiBlLmluaXQuYXBwbHkoZSxhcmd1bWVudHMpLGV9LGluaXQ6ZnVuY3Rpb24oKXt9LG1peEluOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiBlKWUuaGFzT3duUHJvcGVydHkodCkmJih0aGlzW3RdPWVbdF0pO2UuaGFzT3duUHJvcGVydHkoXCJ0b1N0cmluZ1wiKSYmKHRoaXMudG9TdHJpbmc9ZS50b1N0cmluZyl9LGNsb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpfX0sdT10LldvcmRBcnJheT1yLmV4dGVuZCh7aW5pdDpmdW5jdGlvbihlLHQpe2U9dGhpcy53b3Jkcz1lfHxbXSx0aGlzLnNpZ0J5dGVzPW51bGwhPXQ/dDo0KmUubGVuZ3RofSx0b1N0cmluZzpmdW5jdGlvbihlKXtyZXR1cm4oZXx8bykuc3RyaW5naWZ5KHRoaXMpfSxjb25jYXQ6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy53b3JkcyxuPWUud29yZHMscj10aGlzLnNpZ0J5dGVzO2lmKGU9ZS5zaWdCeXRlcyx0aGlzLmNsYW1wKCksciU0KWZvcih2YXIgaT0wO2k8ZTtpKyspdFtyK2k+Pj4yXXw9KG5baT4+PjJdPj4+MjQtaSU0KjgmMjU1KTw8MjQtKHIraSklNCo4O2Vsc2UgaWYoNjU1MzU8bi5sZW5ndGgpZm9yKGk9MDtpPGU7aSs9NCl0W3IraT4+PjJdPW5baT4+PjJdO2Vsc2UgdC5wdXNoLmFwcGx5KHQsbik7cmV0dXJuIHRoaXMuc2lnQnl0ZXMrPWUsdGhpc30sY2xhbXA6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLndvcmRzLHQ9dGhpcy5zaWdCeXRlcztlW3Q+Pj4yXSY9NDI5NDk2NzI5NTw8MzItdCU0KjgsZS5sZW5ndGg9YS5jZWlsKHQvNCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIGU9ci5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiBlLndvcmRzPXRoaXMud29yZHMuc2xpY2UoMCksZX0scmFuZG9tOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1bXSxuPTA7bjxlO24rPTQpdC5wdXNoKDQyOTQ5NjcyOTYqYS5yYW5kb20oKXwwKTtyZXR1cm4gbmV3IHUuaW5pdCh0LGUpfX0pLGk9ZS5lbmM9e30sbz1pLkhleD17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUud29yZHM7ZT1lLnNpZ0J5dGVzO2Zvcih2YXIgbj1bXSxyPTA7cjxlO3IrKyl7dmFyIGk9dFtyPj4+Ml0+Pj4yNC1yJTQqOCYyNTU7bi5wdXNoKChpPj4+NCkudG9TdHJpbmcoMTYpKSxuLnB1c2goKDE1JmkpLnRvU3RyaW5nKDE2KSl9cmV0dXJuIG4uam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWUubGVuZ3RoLG49W10scj0wO3I8dDtyKz0yKW5bcj4+PjNdfD1wYXJzZUludChlLnN1YnN0cihyLDIpLDE2KTw8MjQtciU4KjQ7cmV0dXJuIG5ldyB1LmluaXQobix0LzIpfX0scz1pLkxhdGluMT17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUud29yZHM7ZT1lLnNpZ0J5dGVzO2Zvcih2YXIgbj1bXSxyPTA7cjxlO3IrKyluLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSh0W3I+Pj4yXT4+PjI0LXIlNCo4JjI1NSkpO3JldHVybiBuLmpvaW4oXCJcIil9LHBhcnNlOmZ1bmN0aW9uKGUpe2Zvcih2YXIgdD1lLmxlbmd0aCxuPVtdLHI9MDtyPHQ7cisrKW5bcj4+PjJdfD0oMjU1JmUuY2hhckNvZGVBdChyKSk8PDI0LXIlNCo4O3JldHVybiBuZXcgdS5pbml0KG4sdCl9fSxjPWkuVXRmOD17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzLnN0cmluZ2lmeShlKSkpfWNhdGNoKGUpe3Rocm93IEVycm9yKFwiTWFsZm9ybWVkIFVURi04IGRhdGFcIil9fSxwYXJzZTpmdW5jdGlvbihlKXtyZXR1cm4gcy5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoZSkpKX19LGY9dC5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtPXIuZXh0ZW5kKHtyZXNldDpmdW5jdGlvbigpe3RoaXMuX2RhdGE9bmV3IHUuaW5pdCx0aGlzLl9uRGF0YUJ5dGVzPTB9LF9hcHBlbmQ6ZnVuY3Rpb24oZSl7XCJzdHJpbmdcIj09dHlwZW9mIGUmJihlPWMucGFyc2UoZSkpLHRoaXMuX2RhdGEuY29uY2F0KGUpLHRoaXMuX25EYXRhQnl0ZXMrPWUuc2lnQnl0ZXN9LF9wcm9jZXNzOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuX2RhdGEsbj10LndvcmRzLHI9dC5zaWdCeXRlcyxpPXRoaXMuYmxvY2tTaXplLG89ci8oNCppKTtpZihlPShvPWU/YS5jZWlsKG8pOmEubWF4KCgwfG8pLXRoaXMuX21pbkJ1ZmZlclNpemUsMCkpKmkscj1hLm1pbig0KmUsciksZSl7Zm9yKHZhciBzPTA7czxlO3MrPWkpdGhpcy5fZG9Qcm9jZXNzQmxvY2sobixzKTtzPW4uc3BsaWNlKDAsZSksdC5zaWdCeXRlcy09cn1yZXR1cm4gbmV3IHUuaW5pdChzLHIpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciBlPXIuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gZS5fZGF0YT10aGlzLl9kYXRhLmNsb25lKCksZX0sX21pbkJ1ZmZlclNpemU6MH0pO3QuSGFzaGVyPWYuZXh0ZW5kKHtjZmc6ci5leHRlbmQoKSxpbml0OmZ1bmN0aW9uKGUpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChlKSx0aGlzLnJlc2V0KCl9LHJlc2V0OmZ1bmN0aW9uKCl7Zi5yZXNldC5jYWxsKHRoaXMpLHRoaXMuX2RvUmVzZXQoKX0sdXBkYXRlOmZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9hcHBlbmQoZSksdGhpcy5fcHJvY2VzcygpLHRoaXN9LGZpbmFsaXplOmZ1bmN0aW9uKGUpe3JldHVybiBlJiZ0aGlzLl9hcHBlbmQoZSksdGhpcy5fZG9GaW5hbGl6ZSgpfSxibG9ja1NpemU6MTYsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihuKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IG4uaW5pdCh0KS5maW5hbGl6ZShlKX19LF9jcmVhdGVIbWFjSGVscGVyOmZ1bmN0aW9uKG4pe3JldHVybiBmdW5jdGlvbihlLHQpe3JldHVybiBuZXcgbC5ITUFDLmluaXQobix0KS5maW5hbGl6ZShlKX19fSk7dmFyIGw9ZS5hbGdvPXt9O3JldHVybiBlfShNYXRoKTshZnVuY3Rpb24oaSl7Zm9yKHZhciBlPUUsdD0ocj1lLmxpYikuV29yZEFycmF5LG49ci5IYXNoZXIscj1lLmFsZ28sbz1bXSxkPVtdLHM9ZnVuY3Rpb24oZSl7cmV0dXJuIDQyOTQ5NjcyOTYqKGUtKDB8ZSkpfDB9LGE9Mix1PTA7dTw2NDspe3ZhciBjO2U6e2M9YTtmb3IodmFyIGY9aS5zcXJ0KGMpLGw9MjtsPD1mO2wrKylpZighKGMlbCkpe2M9ITE7YnJlYWsgZX1jPSEwfWMmJih1PDgmJihvW3VdPXMoaS5wb3coYSwuNSkpKSxkW3VdPXMoaS5wb3coYSwxLzMpKSx1KyspLGErK312YXIgZz1bXTtyPXIuU0hBMjU2PW4uZXh0ZW5kKHtfZG9SZXNldDpmdW5jdGlvbigpe3RoaXMuX2hhc2g9bmV3IHQuaW5pdChvLnNsaWNlKDApKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPXRoaXMuX2hhc2gud29yZHMscj1uWzBdLGk9blsxXSxvPW5bMl0scz1uWzNdLGE9bls0XSx1PW5bNV0sYz1uWzZdLGY9bls3XSxsPTA7bDw2NDtsKyspe2lmKGw8MTYpZ1tsXT0wfGVbdCtsXTtlbHNle3ZhciBoPWdbbC0xNV0scD1nW2wtMl07Z1tsXT0oKGg8PDI1fGg+Pj43KV4oaDw8MTR8aD4+PjE4KV5oPj4+MykrZ1tsLTddKygocDw8MTV8cD4+PjE3KV4ocDw8MTN8cD4+PjE5KV5wPj4+MTApK2dbbC0xNl19aD1mKygoYTw8MjZ8YT4+PjYpXihhPDwyMXxhPj4+MTEpXihhPDw3fGE+Pj4yNSkpKyhhJnVefmEmYykrZFtsXStnW2xdLHA9KChyPDwzMHxyPj4+MileKHI8PDE5fHI+Pj4xMyleKHI8PDEwfHI+Pj4yMikpKyhyJmleciZvXmkmbyksZj1jLGM9dSx1PWEsYT1zK2h8MCxzPW8sbz1pLGk9cixyPWgrcHwwfW5bMF09blswXStyfDAsblsxXT1uWzFdK2l8MCxuWzJdPW5bMl0rb3wwLG5bM109blszXStzfDAsbls0XT1uWzRdK2F8MCxuWzVdPW5bNV0rdXwwLG5bNl09bls2XStjfDAsbls3XT1uWzddK2Z8MH0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9kYXRhLHQ9ZS53b3JkcyxuPTgqdGhpcy5fbkRhdGFCeXRlcyxyPTgqZS5zaWdCeXRlcztyZXR1cm4gdFtyPj4+NV18PTEyODw8MjQtciUzMix0WzE0Kyg2NCtyPj4+OTw8NCldPWkuZmxvb3Iobi80Mjk0OTY3Mjk2KSx0WzE1Kyg2NCtyPj4+OTw8NCldPW4sZS5zaWdCeXRlcz00KnQubGVuZ3RoLHRoaXMuX3Byb2Nlc3MoKSx0aGlzLl9oYXNofSxjbG9uZTpmdW5jdGlvbigpe3ZhciBlPW4uY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gZS5faGFzaD10aGlzLl9oYXNoLmNsb25lKCksZX19KTtlLlNIQTI1Nj1uLl9jcmVhdGVIZWxwZXIociksZS5IbWFjU0hBMjU2PW4uX2NyZWF0ZUhtYWNIZWxwZXIocil9KE1hdGgpLGM9KHI9RSkuZW5jLlV0Zjgsci5hbGdvLkhNQUM9ci5saWIuQmFzZS5leHRlbmQoe2luaXQ6ZnVuY3Rpb24oZSx0KXtlPXRoaXMuX2hhc2hlcj1uZXcgZS5pbml0LFwic3RyaW5nXCI9PXR5cGVvZiB0JiYodD1jLnBhcnNlKHQpKTt2YXIgbj1lLmJsb2NrU2l6ZSxyPTQqbjt0LnNpZ0J5dGVzPnImJih0PWUuZmluYWxpemUodCkpLHQuY2xhbXAoKTtmb3IodmFyIGk9dGhpcy5fb0tleT10LmNsb25lKCksbz10aGlzLl9pS2V5PXQuY2xvbmUoKSxzPWkud29yZHMsYT1vLndvcmRzLHU9MDt1PG47dSsrKXNbdV1ePTE1NDk1NTY4MjgsYVt1XV49OTA5NTIyNDg2O2kuc2lnQnl0ZXM9by5zaWdCeXRlcz1yLHRoaXMucmVzZXQoKX0scmVzZXQ6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9oYXNoZXI7ZS5yZXNldCgpLGUudXBkYXRlKHRoaXMuX2lLZXkpfSx1cGRhdGU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2hhc2hlci51cGRhdGUoZSksdGhpc30sZmluYWxpemU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5faGFzaGVyO3JldHVybiBlPXQuZmluYWxpemUoZSksdC5yZXNldCgpLHQuZmluYWxpemUodGhpcy5fb0tleS5jbG9uZSgpLmNvbmNhdChlKSl9fSksdT0oaT1FKS5saWIuV29yZEFycmF5LGkuZW5jLkJhc2U2ND17c3RyaW5naWZ5OmZ1bmN0aW9uKGUpe3ZhciB0PWUud29yZHMsbj1lLnNpZ0J5dGVzLHI9dGhpcy5fbWFwO2UuY2xhbXAoKSxlPVtdO2Zvcih2YXIgaT0wO2k8bjtpKz0zKWZvcih2YXIgbz0odFtpPj4+Ml0+Pj4yNC1pJTQqOCYyNTUpPDwxNnwodFtpKzE+Pj4yXT4+PjI0LShpKzEpJTQqOCYyNTUpPDw4fHRbaSsyPj4+Ml0+Pj4yNC0oaSsyKSU0KjgmMjU1LHM9MDtzPDQmJmkrLjc1KnM8bjtzKyspZS5wdXNoKHIuY2hhckF0KG8+Pj42KigzLXMpJjYzKSk7aWYodD1yLmNoYXJBdCg2NCkpZm9yKDtlLmxlbmd0aCU0OyllLnB1c2godCk7cmV0dXJuIGUuam9pbihcIlwiKX0scGFyc2U6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5sZW5ndGgsbj10aGlzLl9tYXA7IShyPW4uY2hhckF0KDY0KSl8fC0xIT0ocj1lLmluZGV4T2YocikpJiYodD1yKTtmb3IodmFyIHI9W10saT0wLG89MDtvPHQ7bysrKWlmKG8lNCl7dmFyIHM9bi5pbmRleE9mKGUuY2hhckF0KG8tMSkpPDxvJTQqMixhPW4uaW5kZXhPZihlLmNoYXJBdChvKSk+Pj42LW8lNCoyO3JbaT4+PjJdfD0oc3xhKTw8MjQtaSU0KjgsaSsrfXJldHVybiB1LmNyZWF0ZShyLGkpfSxfbWFwOlwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIn0sZnVuY3Rpb24obyl7ZnVuY3Rpb24gdyhlLHQsbixyLGksbyxzKXtyZXR1cm4oKGU9ZSsodCZufH50JnIpK2krcyk8PG98ZT4+PjMyLW8pK3R9ZnVuY3Rpb24gVChlLHQsbixyLGksbyxzKXtyZXR1cm4oKGU9ZSsodCZyfG4mfnIpK2krcyk8PG98ZT4+PjMyLW8pK3R9ZnVuY3Rpb24gTyhlLHQsbixyLGksbyxzKXtyZXR1cm4oKGU9ZSsodF5uXnIpK2krcyk8PG98ZT4+PjMyLW8pK3R9ZnVuY3Rpb24gUyhlLHQsbixyLGksbyxzKXtyZXR1cm4oKGU9ZSsobl4odHx+cikpK2krcyk8PG98ZT4+PjMyLW8pK3R9Zm9yKHZhciBlPUUsdD0ocj1lLmxpYikuV29yZEFycmF5LG49ci5IYXNoZXIscj1lLmFsZ28sTT1bXSxpPTA7aTw2NDtpKyspTVtpXT00Mjk0OTY3Mjk2Km8uYWJzKG8uc2luKGkrMSkpfDA7cj1yLk1ENT1uLmV4dGVuZCh7X2RvUmVzZXQ6ZnVuY3Rpb24oKXt0aGlzLl9oYXNoPW5ldyB0LmluaXQoWzE3MzI1ODQxOTMsNDAyMzIzMzQxNywyNTYyMzgzMTAyLDI3MTczMzg3OF0pfSxfZG9Qcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG49MDtuPDE2O24rKyl7dmFyIHI9ZVtzPXQrbl07ZVtzXT0xNjcxMTkzNSYocjw8OHxyPj4+MjQpfDQyNzgyNTUzNjAmKHI8PDI0fHI+Pj44KX1uPXRoaXMuX2hhc2gud29yZHM7dmFyIGksbyxzPWVbdCswXSxhPShyPWVbdCsxXSxlW3QrMl0pLHU9ZVt0KzNdLGM9ZVt0KzRdLGY9ZVt0KzVdLGw9ZVt0KzZdLGg9ZVt0KzddLHA9ZVt0KzhdLGQ9ZVt0KzldLGc9ZVt0KzEwXSx5PWVbdCsxMV0sdj1lW3QrMTJdLGI9ZVt0KzEzXSxtPWVbdCsxNF0sXz1lW3QrMTVdLGs9blswXSxQPVMoUD1TKFA9UyhQPVMoUD1PKFA9TyhQPU8oUD1PKFA9VChQPVQoUD1UKFA9VChQPXcoUD13KFA9dyhQPXcoUD1uWzFdLG89dyhvPW5bMl0saT13KGk9blszXSxrPXcoayxQLG8saSxzLDcsTVswXSksUCxvLHIsMTIsTVsxXSksayxQLGEsMTcsTVsyXSksaSxrLHUsMjIsTVszXSksbz13KG8saT13KGksaz13KGssUCxvLGksYyw3LE1bNF0pLFAsbyxmLDEyLE1bNV0pLGssUCxsLDE3LE1bNl0pLGksayxoLDIyLE1bN10pLG89dyhvLGk9dyhpLGs9dyhrLFAsbyxpLHAsNyxNWzhdKSxQLG8sZCwxMixNWzldKSxrLFAsZywxNyxNWzEwXSksaSxrLHksMjIsTVsxMV0pLG89dyhvLGk9dyhpLGs9dyhrLFAsbyxpLHYsNyxNWzEyXSksUCxvLGIsMTIsTVsxM10pLGssUCxtLDE3LE1bMTRdKSxpLGssXywyMixNWzE1XSksbz1UKG8saT1UKGksaz1UKGssUCxvLGksciw1LE1bMTZdKSxQLG8sbCw5LE1bMTddKSxrLFAseSwxNCxNWzE4XSksaSxrLHMsMjAsTVsxOV0pLG89VChvLGk9VChpLGs9VChrLFAsbyxpLGYsNSxNWzIwXSksUCxvLGcsOSxNWzIxXSksayxQLF8sMTQsTVsyMl0pLGksayxjLDIwLE1bMjNdKSxvPVQobyxpPVQoaSxrPVQoayxQLG8saSxkLDUsTVsyNF0pLFAsbyxtLDksTVsyNV0pLGssUCx1LDE0LE1bMjZdKSxpLGsscCwyMCxNWzI3XSksbz1UKG8saT1UKGksaz1UKGssUCxvLGksYiw1LE1bMjhdKSxQLG8sYSw5LE1bMjldKSxrLFAsaCwxNCxNWzMwXSksaSxrLHYsMjAsTVszMV0pLG89TyhvLGk9TyhpLGs9TyhrLFAsbyxpLGYsNCxNWzMyXSksUCxvLHAsMTEsTVszM10pLGssUCx5LDE2LE1bMzRdKSxpLGssbSwyMyxNWzM1XSksbz1PKG8saT1PKGksaz1PKGssUCxvLGksciw0LE1bMzZdKSxQLG8sYywxMSxNWzM3XSksayxQLGgsMTYsTVszOF0pLGksayxnLDIzLE1bMzldKSxvPU8obyxpPU8oaSxrPU8oayxQLG8saSxiLDQsTVs0MF0pLFAsbyxzLDExLE1bNDFdKSxrLFAsdSwxNixNWzQyXSksaSxrLGwsMjMsTVs0M10pLG89TyhvLGk9TyhpLGs9TyhrLFAsbyxpLGQsNCxNWzQ0XSksUCxvLHYsMTEsTVs0NV0pLGssUCxfLDE2LE1bNDZdKSxpLGssYSwyMyxNWzQ3XSksbz1TKG8saT1TKGksaz1TKGssUCxvLGkscyw2LE1bNDhdKSxQLG8saCwxMCxNWzQ5XSksayxQLG0sMTUsTVs1MF0pLGksayxmLDIxLE1bNTFdKSxvPVMobyxpPVMoaSxrPVMoayxQLG8saSx2LDYsTVs1Ml0pLFAsbyx1LDEwLE1bNTNdKSxrLFAsZywxNSxNWzU0XSksaSxrLHIsMjEsTVs1NV0pLG89UyhvLGk9UyhpLGs9UyhrLFAsbyxpLHAsNixNWzU2XSksUCxvLF8sMTAsTVs1N10pLGssUCxsLDE1LE1bNThdKSxpLGssYiwyMSxNWzU5XSksbz1TKG8saT1TKGksaz1TKGssUCxvLGksYyw2LE1bNjBdKSxQLG8seSwxMCxNWzYxXSksayxQLGEsMTUsTVs2Ml0pLGksayxkLDIxLE1bNjNdKTtuWzBdPW5bMF0ra3wwLG5bMV09blsxXStQfDAsblsyXT1uWzJdK298MCxuWzNdPW5bM10raXwwfSxfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3ZhciBlPXRoaXMuX2RhdGEsdD1lLndvcmRzLG49OCp0aGlzLl9uRGF0YUJ5dGVzLHI9OCplLnNpZ0J5dGVzO3Rbcj4+PjVdfD0xMjg8PDI0LXIlMzI7dmFyIGk9by5mbG9vcihuLzQyOTQ5NjcyOTYpO2Zvcih0WzE1KyhyKzY0Pj4+OTw8NCldPTE2NzExOTM1JihpPDw4fGk+Pj4yNCl8NDI3ODI1NTM2MCYoaTw8MjR8aT4+PjgpLHRbMTQrKHIrNjQ+Pj45PDw0KV09MTY3MTE5MzUmKG48PDh8bj4+PjI0KXw0Mjc4MjU1MzYwJihuPDwyNHxuPj4+OCksZS5zaWdCeXRlcz00Kih0Lmxlbmd0aCsxKSx0aGlzLl9wcm9jZXNzKCksdD0oZT10aGlzLl9oYXNoKS53b3JkcyxuPTA7bjw0O24rKylyPXRbbl0sdFtuXT0xNjcxMTkzNSYocjw8OHxyPj4+MjQpfDQyNzgyNTUzNjAmKHI8PDI0fHI+Pj44KTtyZXR1cm4gZX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgZT1uLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIGUuX2hhc2g9dGhpcy5faGFzaC5jbG9uZSgpLGV9fSksZS5NRDU9bi5fY3JlYXRlSGVscGVyKHIpLGUuSG1hY01ENT1uLl9jcmVhdGVIbWFjSGVscGVyKHIpfShNYXRoKSxhPShvPShzPUUpLmxpYikuQmFzZSxmPW8uV29yZEFycmF5LGw9KG89cy5hbGdvKS5FdnBLREY9YS5leHRlbmQoe2NmZzphLmV4dGVuZCh7a2V5U2l6ZTo0LGhhc2hlcjpvLk1ENSxpdGVyYXRpb25zOjF9KSxpbml0OmZ1bmN0aW9uKGUpe3RoaXMuY2ZnPXRoaXMuY2ZnLmV4dGVuZChlKX0sY29tcHV0ZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0ocz10aGlzLmNmZykuaGFzaGVyLmNyZWF0ZSgpLHI9Zi5jcmVhdGUoKSxpPXIud29yZHMsbz1zLmtleVNpemUscz1zLml0ZXJhdGlvbnM7aS5sZW5ndGg8bzspe2EmJm4udXBkYXRlKGEpO3ZhciBhPW4udXBkYXRlKGUpLmZpbmFsaXplKHQpO24ucmVzZXQoKTtmb3IodmFyIHU9MTt1PHM7dSsrKWE9bi5maW5hbGl6ZShhKSxuLnJlc2V0KCk7ci5jb25jYXQoYSl9cmV0dXJuIHIuc2lnQnl0ZXM9NCpvLHJ9fSkscy5FdnBLREY9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBsLmNyZWF0ZShuKS5jb21wdXRlKGUsdCl9LEUubGliLkNpcGhlcnx8ZnVuY3Rpb24oKXt2YXIgZT0oaD1FKS5saWIsdD1lLkJhc2Uscz1lLldvcmRBcnJheSxuPWUuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSxyPWguZW5jLkJhc2U2NCxpPWguYWxnby5FdnBLREYsbz1lLkNpcGhlcj1uLmV4dGVuZCh7Y2ZnOnQuZXh0ZW5kKCksY3JlYXRlRW5jcnlwdG9yOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLGUsdCl9LGNyZWF0ZURlY3J5cHRvcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSxlLHQpfSxpbml0OmZ1bmN0aW9uKGUsdCxuKXt0aGlzLmNmZz10aGlzLmNmZy5leHRlbmQobiksdGhpcy5feGZvcm1Nb2RlPWUsdGhpcy5fa2V5PXQsdGhpcy5yZXNldCgpfSxyZXNldDpmdW5jdGlvbigpe24ucmVzZXQuY2FsbCh0aGlzKSx0aGlzLl9kb1Jlc2V0KCl9LHByb2Nlc3M6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2FwcGVuZChlKSx0aGlzLl9wcm9jZXNzKCl9LGZpbmFsaXplOmZ1bmN0aW9uKGUpe3JldHVybiBlJiZ0aGlzLl9hcHBlbmQoZSksdGhpcy5fZG9GaW5hbGl6ZSgpfSxrZXlTaXplOjQsaXZTaXplOjQsX0VOQ19YRk9STV9NT0RFOjEsX0RFQ19YRk9STV9NT0RFOjIsX2NyZWF0ZUhlbHBlcjpmdW5jdGlvbihyKXtyZXR1cm57ZW5jcnlwdDpmdW5jdGlvbihlLHQsbil7cmV0dXJuKFwic3RyaW5nXCI9PXR5cGVvZiB0P3A6bCkuZW5jcnlwdChyLGUsdCxuKX0sZGVjcnlwdDpmdW5jdGlvbihlLHQsbil7cmV0dXJuKFwic3RyaW5nXCI9PXR5cGVvZiB0P3A6bCkuZGVjcnlwdChyLGUsdCxuKX19fX0pO2UuU3RyZWFtQ2lwaGVyPW8uZXh0ZW5kKHtfZG9GaW5hbGl6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wcm9jZXNzKCEwKX0sYmxvY2tTaXplOjF9KTtmdW5jdGlvbiBhKGUsdCxuKXt2YXIgcj10aGlzLl9pdjtyP3RoaXMuX2l2PXZvaWQgMDpyPXRoaXMuX3ByZXZCbG9jaztmb3IodmFyIGk9MDtpPG47aSsrKWVbdCtpXV49cltpXX12YXIgdT1oLm1vZGU9e30sYz0oZS5CbG9ja0NpcGhlck1vZGU9dC5leHRlbmQoe2NyZWF0ZUVuY3J5cHRvcjpmdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoZSx0KX0sY3JlYXRlRGVjcnlwdG9yOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShlLHQpfSxpbml0OmZ1bmN0aW9uKGUsdCl7dGhpcy5fY2lwaGVyPWUsdGhpcy5faXY9dH19KSkuZXh0ZW5kKCk7Yy5FbmNyeXB0b3I9Yy5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe3ZhciBuPXRoaXMuX2NpcGhlcixyPW4uYmxvY2tTaXplO2EuY2FsbCh0aGlzLGUsdCxyKSxuLmVuY3J5cHRCbG9jayhlLHQpLHRoaXMuX3ByZXZCbG9jaz1lLnNsaWNlKHQsdCtyKX19KSxjLkRlY3J5cHRvcj1jLmV4dGVuZCh7cHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5fY2lwaGVyLHI9bi5ibG9ja1NpemUsaT1lLnNsaWNlKHQsdCtyKTtuLmRlY3J5cHRCbG9jayhlLHQpLGEuY2FsbCh0aGlzLGUsdCxyKSx0aGlzLl9wcmV2QmxvY2s9aX19KSx1PXUuQ0JDPWMsYz0oaC5wYWQ9e30pLlBrY3M3PXtwYWQ6ZnVuY3Rpb24oZSx0KXtmb3IodmFyIG4scj0obj0obj00KnQpLWUuc2lnQnl0ZXMlbik8PDI0fG48PDE2fG48PDh8bixpPVtdLG89MDtvPG47bys9NClpLnB1c2gocik7bj1zLmNyZWF0ZShpLG4pLGUuY29uY2F0KG4pfSx1bnBhZDpmdW5jdGlvbihlKXtlLnNpZ0J5dGVzLT0yNTUmZS53b3Jkc1tlLnNpZ0J5dGVzLTE+Pj4yXX19LGUuQmxvY2tDaXBoZXI9by5leHRlbmQoe2NmZzpvLmNmZy5leHRlbmQoe21vZGU6dSxwYWRkaW5nOmN9KSxyZXNldDpmdW5jdGlvbigpe28ucmVzZXQuY2FsbCh0aGlzKTt2YXIgZT0odD10aGlzLmNmZykuaXYsdD10Lm1vZGU7aWYodGhpcy5feGZvcm1Nb2RlPT10aGlzLl9FTkNfWEZPUk1fTU9ERSl2YXIgbj10LmNyZWF0ZUVuY3J5cHRvcjtlbHNlIG49dC5jcmVhdGVEZWNyeXB0b3IsdGhpcy5fbWluQnVmZmVyU2l6ZT0xO3RoaXMuX21vZGU9bi5jYWxsKHQsdGhpcyxlJiZlLndvcmRzKX0sX2RvUHJvY2Vzc0Jsb2NrOmZ1bmN0aW9uKGUsdCl7dGhpcy5fbW9kZS5wcm9jZXNzQmxvY2soZSx0KX0sX2RvRmluYWxpemU6ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmNmZy5wYWRkaW5nO2lmKHRoaXMuX3hmb3JtTW9kZT09dGhpcy5fRU5DX1hGT1JNX01PREUpe2UucGFkKHRoaXMuX2RhdGEsdGhpcy5ibG9ja1NpemUpO3ZhciB0PXRoaXMuX3Byb2Nlc3MoITApfWVsc2UgdD10aGlzLl9wcm9jZXNzKCEwKSxlLnVucGFkKHQpO3JldHVybiB0fSxibG9ja1NpemU6NH0pO3ZhciBmPWUuQ2lwaGVyUGFyYW1zPXQuZXh0ZW5kKHtpbml0OmZ1bmN0aW9uKGUpe3RoaXMubWl4SW4oZSl9LHRvU3RyaW5nOmZ1bmN0aW9uKGUpe3JldHVybihlfHx0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpfX0pLGw9KHU9KGguZm9ybWF0PXt9KS5PcGVuU1NMPXtzdHJpbmdpZnk6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaXBoZXJ0ZXh0O3JldHVybigoZT1lLnNhbHQpP3MuY3JlYXRlKFsxMzk4ODkzNjg0LDE3MDEwNzY4MzFdKS5jb25jYXQoZSkuY29uY2F0KHQpOnQpLnRvU3RyaW5nKHIpfSxwYXJzZTpmdW5jdGlvbihlKXt2YXIgdD0oZT1yLnBhcnNlKGUpKS53b3JkcztpZigxMzk4ODkzNjg0PT10WzBdJiYxNzAxMDc2ODMxPT10WzFdKXt2YXIgbj1zLmNyZWF0ZSh0LnNsaWNlKDIsNCkpO3Quc3BsaWNlKDAsNCksZS5zaWdCeXRlcy09MTZ9cmV0dXJuIGYuY3JlYXRlKHtjaXBoZXJ0ZXh0OmUsc2FsdDpufSl9fSxlLlNlcmlhbGl6YWJsZUNpcGhlcj10LmV4dGVuZCh7Y2ZnOnQuZXh0ZW5kKHtmb3JtYXQ6dX0pLGVuY3J5cHQ6ZnVuY3Rpb24oZSx0LG4scil7cj10aGlzLmNmZy5leHRlbmQocik7dmFyIGk9ZS5jcmVhdGVFbmNyeXB0b3IobixyKTtyZXR1cm4gdD1pLmZpbmFsaXplKHQpLGk9aS5jZmcsZi5jcmVhdGUoe2NpcGhlcnRleHQ6dCxrZXk6bixpdjppLml2LGFsZ29yaXRobTplLG1vZGU6aS5tb2RlLHBhZGRpbmc6aS5wYWRkaW5nLGJsb2NrU2l6ZTplLmJsb2NrU2l6ZSxmb3JtYXR0ZXI6ci5mb3JtYXR9KX0sZGVjcnlwdDpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gcj10aGlzLmNmZy5leHRlbmQociksdD10aGlzLl9wYXJzZSh0LHIuZm9ybWF0KSxlLmNyZWF0ZURlY3J5cHRvcihuLHIpLmZpbmFsaXplKHQuY2lwaGVydGV4dCl9LF9wYXJzZTpmdW5jdGlvbihlLHQpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlP3QucGFyc2UoZSx0aGlzKTplfX0pKSxoPShoLmtkZj17fSkuT3BlblNTTD17ZXhlY3V0ZTpmdW5jdGlvbihlLHQsbixyKXtyZXR1cm4gcj1yfHxzLnJhbmRvbSg4KSxlPWkuY3JlYXRlKHtrZXlTaXplOnQrbn0pLmNvbXB1dGUoZSxyKSxuPXMuY3JlYXRlKGUud29yZHMuc2xpY2UodCksNCpuKSxlLnNpZ0J5dGVzPTQqdCxmLmNyZWF0ZSh7a2V5OmUsaXY6bixzYWx0OnJ9KX19LHA9ZS5QYXNzd29yZEJhc2VkQ2lwaGVyPWwuZXh0ZW5kKHtjZmc6bC5jZmcuZXh0ZW5kKHtrZGY6aH0pLGVuY3J5cHQ6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIG49KHI9dGhpcy5jZmcuZXh0ZW5kKHIpKS5rZGYuZXhlY3V0ZShuLGUua2V5U2l6ZSxlLml2U2l6ZSksci5pdj1uLml2LChlPWwuZW5jcnlwdC5jYWxsKHRoaXMsZSx0LG4ua2V5LHIpKS5taXhJbihuKSxlfSxkZWNyeXB0OmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiByPXRoaXMuY2ZnLmV4dGVuZChyKSx0PXRoaXMuX3BhcnNlKHQsci5mb3JtYXQpLG49ci5rZGYuZXhlY3V0ZShuLGUua2V5U2l6ZSxlLml2U2l6ZSx0LnNhbHQpLHIuaXY9bi5pdixsLmRlY3J5cHQuY2FsbCh0aGlzLGUsdCxuLmtleSxyKX19KX0oKSxmdW5jdGlvbigpe2Zvcih2YXIgZT1FLHQ9ZS5saWIuQmxvY2tDaXBoZXIsbj1lLmFsZ28scz1bXSxyPVtdLGk9W10sbz1bXSxhPVtdLHU9W10sYz1bXSxmPVtdLGw9W10saD1bXSxwPVtdLGQ9MDtkPDI1NjtkKyspcFtkXT1kPDEyOD9kPDwxOmQ8PDFeMjgzO3ZhciBnPTAseT0wO2ZvcihkPTA7ZDwyNTY7ZCsrKXt2YXIgdj0odj15Xnk8PDFeeTw8Ml55PDwzXnk8PDQpPj4+OF4yNTUmdl45OTtzW2ddPXY7dmFyIGI9cFtyW3ZdPWddLG09cFtiXSxfPXBbbV0saz0yNTcqcFt2XV4xNjg0MzAwOCp2O2lbZ109azw8MjR8az4+Pjgsb1tnXT1rPDwxNnxrPj4+MTYsYVtnXT1rPDw4fGs+Pj4yNCx1W2ddPWssaz0xNjg0MzAwOSpfXjY1NTM3Km1eMjU3KmJeMTY4NDMwMDgqZyxjW3ZdPWs8PDI0fGs+Pj44LGZbdl09azw8MTZ8az4+PjE2LGxbdl09azw8OHxrPj4+MjQsaFt2XT1rLGc/KGc9Yl5wW3BbcFtfXmJdXV0seV49cFtwW3ldXSk6Zz15PTF9dmFyIFA9WzAsMSwyLDQsOCwxNiwzMiw2NCwxMjgsMjcsNTRdO249bi5BRVM9dC5leHRlbmQoe19kb1Jlc2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBlPShuPXRoaXMuX2tleSkud29yZHMsdD1uLnNpZ0J5dGVzLzQsbj00KigodGhpcy5fblJvdW5kcz10KzYpKzEpLHI9dGhpcy5fa2V5U2NoZWR1bGU9W10saT0wO2k8bjtpKyspaWYoaTx0KXJbaV09ZVtpXTtlbHNle3ZhciBvPXJbaS0xXTtpJXQ/Njx0JiY0PT1pJXQmJihvPXNbbz4+PjI0XTw8MjR8c1tvPj4+MTYmMjU1XTw8MTZ8c1tvPj4+OCYyNTVdPDw4fHNbMjU1Jm9dKToobz1zWyhvPW88PDh8bz4+PjI0KT4+PjI0XTw8MjR8c1tvPj4+MTYmMjU1XTw8MTZ8c1tvPj4+OCYyNTVdPDw4fHNbMjU1Jm9dLG9ePVBbaS90fDBdPDwyNCkscltpXT1yW2ktdF1eb31mb3IoZT10aGlzLl9pbnZLZXlTY2hlZHVsZT1bXSx0PTA7dDxuO3QrKylpPW4tdCxvPXQlND9yW2ldOnJbaS00XSxlW3RdPXQ8NHx8aTw9ND9vOmNbc1tvPj4+MjRdXV5mW3Nbbz4+PjE2JjI1NV1dXmxbc1tvPj4+OCYyNTVdXV5oW3NbMjU1Jm9dXX0sZW5jcnlwdEJsb2NrOmZ1bmN0aW9uKGUsdCl7dGhpcy5fZG9DcnlwdEJsb2NrKGUsdCx0aGlzLl9rZXlTY2hlZHVsZSxpLG8sYSx1LHMpfSxkZWNyeXB0QmxvY2s6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lW3QrMV07ZVt0KzFdPWVbdCszXSxlW3QrM109bix0aGlzLl9kb0NyeXB0QmxvY2soZSx0LHRoaXMuX2ludktleVNjaGVkdWxlLGMsZixsLGgsciksbj1lW3QrMV0sZVt0KzFdPWVbdCszXSxlW3QrM109bn0sX2RvQ3J5cHRCbG9jazpmdW5jdGlvbihlLHQsbixyLGksbyxzLGEpe2Zvcih2YXIgdT10aGlzLl9uUm91bmRzLGM9ZVt0XV5uWzBdLGY9ZVt0KzFdXm5bMV0sbD1lW3QrMl1eblsyXSxoPWVbdCszXV5uWzNdLHA9NCxkPTE7ZDx1O2QrKyl7dmFyIGc9cltjPj4+MjRdXmlbZj4+PjE2JjI1NV1eb1tsPj4+OCYyNTVdXnNbMjU1JmhdXm5bcCsrXSx5PXJbZj4+PjI0XV5pW2w+Pj4xNiYyNTVdXm9baD4+PjgmMjU1XV5zWzI1NSZjXV5uW3ArK10sdj1yW2w+Pj4yNF1eaVtoPj4+MTYmMjU1XV5vW2M+Pj44JjI1NV1ec1syNTUmZl1ebltwKytdO2g9cltoPj4+MjRdXmlbYz4+PjE2JjI1NV1eb1tmPj4+OCYyNTVdXnNbMjU1JmxdXm5bcCsrXSxjPWcsZj15LGw9dn1nPShhW2M+Pj4yNF08PDI0fGFbZj4+PjE2JjI1NV08PDE2fGFbbD4+PjgmMjU1XTw8OHxhWzI1NSZoXSlebltwKytdLHk9KGFbZj4+PjI0XTw8MjR8YVtsPj4+MTYmMjU1XTw8MTZ8YVtoPj4+OCYyNTVdPDw4fGFbMjU1JmNdKV5uW3ArK10sdj0oYVtsPj4+MjRdPDwyNHxhW2g+Pj4xNiYyNTVdPDwxNnxhW2M+Pj44JjI1NV08PDh8YVsyNTUmZl0pXm5bcCsrXSxoPShhW2g+Pj4yNF08PDI0fGFbYz4+PjE2JjI1NV08PDE2fGFbZj4+PjgmMjU1XTw8OHxhWzI1NSZsXSlebltwKytdLGVbdF09ZyxlW3QrMV09eSxlW3QrMl09dixlW3QrM109aH0sa2V5U2l6ZTo4fSk7ZS5BRVM9dC5fY3JlYXRlSGVscGVyKG4pfSgpLEUubW9kZS5FQ0I9KChoPUUubGliLkJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKSkuRW5jcnlwdG9yPWguZXh0ZW5kKHtwcm9jZXNzQmxvY2s6ZnVuY3Rpb24oZSx0KXt0aGlzLl9jaXBoZXIuZW5jcnlwdEJsb2NrKGUsdCl9fSksaC5EZWNyeXB0b3I9aC5leHRlbmQoe3Byb2Nlc3NCbG9jazpmdW5jdGlvbihlLHQpe3RoaXMuX2NpcGhlci5kZWNyeXB0QmxvY2soZSx0KX19KSxoKSxlLmV4cG9ydHM9RX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7cihuKDYpKSxyKG4oMykpLHIobig3KSk7dmFyIGM9cihuKDE2KSksZj1yKG4oMTcpKSxsPXIobigyKSksYT0obigwKSxyKG4oNCkpKTtmdW5jdGlvbiByKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBpKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBoKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgbyxzLHUscD0obz1kLChzPVt7a2V5OlwiYWRhcHRTdGF0ZUNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcyxyPWUuc3RhdGUsaT1lLmNoYW5uZWxzLG89dm9pZCAwPT09aT9bXTppLHM9ZS5jaGFubmVsR3JvdXBzLGE9dm9pZCAwPT09cz9bXTpzO3JldHVybiBvLmZvckVhY2goZnVuY3Rpb24oZSl7ZSBpbiBuLl9jaGFubmVscyYmKG4uX2NoYW5uZWxzW2VdLnN0YXRlPXIpfSksYS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UgaW4gbi5fY2hhbm5lbEdyb3VwcyYmKG4uX2NoYW5uZWxHcm91cHNbZV0uc3RhdGU9cil9KSx0aGlzLl9zZXRTdGF0ZUVuZHBvaW50KHtzdGF0ZTpyLGNoYW5uZWxzOm8sY2hhbm5lbEdyb3VwczphfSx0KX19LHtrZXk6XCJhZGFwdFByZXNlbmNlQ2hhbmdlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPWUuY29ubmVjdGVkLHI9ZS5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPWUuY2hhbm5lbEdyb3VwcyxzPXZvaWQgMD09PW8/W106bztuPyhpLmZvckVhY2goZnVuY3Rpb24oZSl7dC5faGVhcnRiZWF0Q2hhbm5lbHNbZV09e3N0YXRlOnt9fX0pLHMuZm9yRWFjaChmdW5jdGlvbihlKXt0Ll9oZWFydGJlYXRDaGFubmVsR3JvdXBzW2VdPXtzdGF0ZTp7fX19KSk6KGkuZm9yRWFjaChmdW5jdGlvbihlKXtlIGluIHQuX2hlYXJ0YmVhdENoYW5uZWxzJiZkZWxldGUgdC5faGVhcnRiZWF0Q2hhbm5lbHNbZV19KSxzLmZvckVhY2goZnVuY3Rpb24oZSl7ZSBpbiB0Ll9oZWFydGJlYXRDaGFubmVsR3JvdXBzJiZkZWxldGUgdC5faGVhcnRiZWF0Q2hhbm5lbEdyb3Vwc1tlXX0pLCExPT09dGhpcy5fY29uZmlnLnN1cHByZXNzTGVhdmVFdmVudHMmJnRoaXMuX2xlYXZlRW5kcG9pbnQoe2NoYW5uZWxzOmksY2hhbm5lbEdyb3VwczpzfSxmdW5jdGlvbihlKXt0Ll9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMoZSl9KSksdGhpcy5yZWNvbm5lY3QoKX19LHtrZXk6XCJhZGFwdFN1YnNjcmliZUNoYW5nZVwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMsbj1lLnRpbWV0b2tlbixyPWUuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz1lLmNoYW5uZWxHcm91cHMscz12b2lkIDA9PT1vP1tdOm8sYT1lLndpdGhQcmVzZW5jZSx1PXZvaWQgMCE9PWEmJmEsYz1lLndpdGhIZWFydGJlYXRzLGY9dm9pZCAwIT09YyYmYzt0aGlzLl9jb25maWcuc3Vic2NyaWJlS2V5JiZcIlwiIT09dGhpcy5fY29uZmlnLnN1YnNjcmliZUtleT8obiYmKHRoaXMuX2xhc3RUaW1ldG9rZW49dGhpcy5fY3VycmVudFRpbWV0b2tlbix0aGlzLl9jdXJyZW50VGltZXRva2VuPW4pLFwiMFwiIT09dGhpcy5fY3VycmVudFRpbWV0b2tlbiYmMCE9PXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4mJih0aGlzLl9zdG9yZWRUaW1ldG9rZW49dGhpcy5fY3VycmVudFRpbWV0b2tlbix0aGlzLl9jdXJyZW50VGltZXRva2VuPTApLGkuZm9yRWFjaChmdW5jdGlvbihlKXt0Ll9jaGFubmVsc1tlXT17c3RhdGU6e319LHUmJih0Ll9wcmVzZW5jZUNoYW5uZWxzW2VdPXt9KSwoZnx8dC5fY29uZmlnLmdldEhlYXJ0YmVhdEludGVydmFsKCkpJiYodC5faGVhcnRiZWF0Q2hhbm5lbHNbZV09e30pLHQuX3BlbmRpbmdDaGFubmVsU3Vic2NyaXB0aW9ucy5wdXNoKGUpfSkscy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3QuX2NoYW5uZWxHcm91cHNbZV09e3N0YXRlOnt9fSx1JiYodC5fcHJlc2VuY2VDaGFubmVsR3JvdXBzW2VdPXt9KSwoZnx8dC5fY29uZmlnLmdldEhlYXJ0YmVhdEludGVydmFsKCkpJiYodC5faGVhcnRiZWF0Q2hhbm5lbEdyb3Vwc1tlXT17fSksdC5fcGVuZGluZ0NoYW5uZWxHcm91cFN1YnNjcmlwdGlvbnMucHVzaChlKX0pLHRoaXMuX3N1YnNjcmlwdGlvblN0YXR1c0Fubm91bmNlZD0hMSx0aGlzLnJlY29ubmVjdCgpKTpjb25zb2xlJiZjb25zb2xlLmxvZyYmY29uc29sZS5sb2coXCJzdWJzY3JpYmUga2V5IG1pc3Npbmc7IGFib3J0aW5nIHN1YnNjcmliZVwiKX19LHtrZXk6XCJhZGFwdFVuc3Vic2NyaWJlQ2hhbmdlXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbj10aGlzLHI9ZS5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPWUuY2hhbm5lbEdyb3VwcyxzPXZvaWQgMD09PW8/W106byxhPVtdLHU9W107aS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2UgaW4gbi5fY2hhbm5lbHMmJihkZWxldGUgbi5fY2hhbm5lbHNbZV0sYS5wdXNoKGUpLGUgaW4gbi5faGVhcnRiZWF0Q2hhbm5lbHMmJmRlbGV0ZSBuLl9oZWFydGJlYXRDaGFubmVsc1tlXSksZSBpbiBuLl9wcmVzZW5jZUNoYW5uZWxzJiYoZGVsZXRlIG4uX3ByZXNlbmNlQ2hhbm5lbHNbZV0sYS5wdXNoKGUpKX0pLHMuZm9yRWFjaChmdW5jdGlvbihlKXtlIGluIG4uX2NoYW5uZWxHcm91cHMmJihkZWxldGUgbi5fY2hhbm5lbEdyb3Vwc1tlXSx1LnB1c2goZSksZSBpbiBuLl9oZWFydGJlYXRDaGFubmVsR3JvdXBzJiZkZWxldGUgbi5faGVhcnRiZWF0Q2hhbm5lbEdyb3Vwc1tlXSksZSBpbiBuLl9wcmVzZW5jZUNoYW5uZWxHcm91cHMmJihkZWxldGUgbi5fY2hhbm5lbEdyb3Vwc1tlXSx1LnB1c2goZSkpfSksMD09PWEubGVuZ3RoJiYwPT09dS5sZW5ndGh8fCghMSE9PXRoaXMuX2NvbmZpZy5zdXBwcmVzc0xlYXZlRXZlbnRzfHx0fHx0aGlzLl9sZWF2ZUVuZHBvaW50KHtjaGFubmVsczphLGNoYW5uZWxHcm91cHM6dX0sZnVuY3Rpb24oZSl7ZS5hZmZlY3RlZENoYW5uZWxzPWEsZS5hZmZlY3RlZENoYW5uZWxHcm91cHM9dSxlLmN1cnJlbnRUaW1ldG9rZW49bi5fY3VycmVudFRpbWV0b2tlbixlLmxhc3RUaW1ldG9rZW49bi5fbGFzdFRpbWV0b2tlbixuLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMoZSl9KSwwPT09T2JqZWN0LmtleXModGhpcy5fY2hhbm5lbHMpLmxlbmd0aCYmMD09PU9iamVjdC5rZXlzKHRoaXMuX3ByZXNlbmNlQ2hhbm5lbHMpLmxlbmd0aCYmMD09PU9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxHcm91cHMpLmxlbmd0aCYmMD09PU9iamVjdC5rZXlzKHRoaXMuX3ByZXNlbmNlQ2hhbm5lbEdyb3VwcykubGVuZ3RoJiYodGhpcy5fbGFzdFRpbWV0b2tlbj0wLHRoaXMuX2N1cnJlbnRUaW1ldG9rZW49MCx0aGlzLl9zdG9yZWRUaW1ldG9rZW49bnVsbCx0aGlzLl9yZWdpb249bnVsbCx0aGlzLl9yZWNvbm5lY3Rpb25NYW5hZ2VyLnN0b3BQb2xsaW5nKCkpLHRoaXMucmVjb25uZWN0KCkpfX0se2tleTpcInVuc3Vic2NyaWJlQWxsXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5hZGFwdFVuc3Vic2NyaWJlQ2hhbmdlKHtjaGFubmVsczp0aGlzLmdldFN1YnNjcmliZWRDaGFubmVscygpLGNoYW5uZWxHcm91cHM6dGhpcy5nZXRTdWJzY3JpYmVkQ2hhbm5lbEdyb3VwcygpfSxlKX19LHtrZXk6XCJnZXRIZWFydGJlYXRDaGFubmVsc1wiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2hlYXJ0YmVhdENoYW5uZWxzKX19LHtrZXk6XCJnZXRIZWFydGJlYXRDaGFubmVsR3JvdXBzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5faGVhcnRiZWF0Q2hhbm5lbEdyb3Vwcyl9fSx7a2V5OlwiZ2V0U3Vic2NyaWJlZENoYW5uZWxzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY2hhbm5lbHMpfX0se2tleTpcImdldFN1YnNjcmliZWRDaGFubmVsR3JvdXBzXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXModGhpcy5fY2hhbm5lbEdyb3Vwcyl9fSx7a2V5OlwicmVjb25uZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9zdGFydFN1YnNjcmliZUxvb3AoKSx0aGlzLl9yZWdpc3RlckhlYXJ0YmVhdFRpbWVyKCl9fSx7a2V5OlwiZGlzY29ubmVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fc3RvcFN1YnNjcmliZUxvb3AoKSx0aGlzLl9zdG9wSGVhcnRiZWF0VGltZXIoKSx0aGlzLl9yZWNvbm5lY3Rpb25NYW5hZ2VyLnN0b3BQb2xsaW5nKCl9fSx7a2V5OlwiX3JlZ2lzdGVySGVhcnRiZWF0VGltZXJcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3N0b3BIZWFydGJlYXRUaW1lcigpLDAhPT10aGlzLl9jb25maWcuZ2V0SGVhcnRiZWF0SW50ZXJ2YWwoKSYmKHRoaXMuX3BlcmZvcm1IZWFydGJlYXRMb29wKCksdGhpcy5faGVhcnRiZWF0VGltZXI9c2V0SW50ZXJ2YWwodGhpcy5fcGVyZm9ybUhlYXJ0YmVhdExvb3AuYmluZCh0aGlzKSwxZTMqdGhpcy5fY29uZmlnLmdldEhlYXJ0YmVhdEludGVydmFsKCkpKX19LHtrZXk6XCJfc3RvcEhlYXJ0YmVhdFRpbWVyXCIsdmFsdWU6ZnVuY3Rpb24oKXt0aGlzLl9oZWFydGJlYXRUaW1lciYmKGNsZWFySW50ZXJ2YWwodGhpcy5faGVhcnRiZWF0VGltZXIpLHRoaXMuX2hlYXJ0YmVhdFRpbWVyPW51bGwpfX0se2tleTpcIl9wZXJmb3JtSGVhcnRiZWF0TG9vcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIG49dGhpcyxlPXRoaXMuZ2V0SGVhcnRiZWF0Q2hhbm5lbHMoKSx0PXRoaXMuZ2V0SGVhcnRiZWF0Q2hhbm5lbEdyb3VwcygpLHI9e307MD09PWUubGVuZ3RoJiYwPT09dC5sZW5ndGh8fCh0aGlzLmdldFN1YnNjcmliZWRDaGFubmVscygpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9bi5fY2hhbm5lbHNbZV0uc3RhdGU7T2JqZWN0LmtleXModCkubGVuZ3RoJiYocltlXT10KX0pLHRoaXMuZ2V0U3Vic2NyaWJlZENoYW5uZWxHcm91cHMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW4uX2NoYW5uZWxHcm91cHNbZV0uc3RhdGU7T2JqZWN0LmtleXModCkubGVuZ3RoJiYocltlXT10KX0pLHRoaXMuX2hlYXJ0YmVhdEVuZHBvaW50KHtjaGFubmVsczplLGNoYW5uZWxHcm91cHM6dCxzdGF0ZTpyfSxmdW5jdGlvbihlKXtlLmVycm9yJiZuLl9jb25maWcuYW5ub3VuY2VGYWlsZWRIZWFydGJlYXRzJiZuLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMoZSksZS5lcnJvciYmbi5fY29uZmlnLmF1dG9OZXR3b3JrRGV0ZWN0aW9uJiZuLl9pc09ubGluZSYmKG4uX2lzT25saW5lPSExLG4uZGlzY29ubmVjdCgpLG4uX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZU5ldHdvcmtEb3duKCksbi5yZWNvbm5lY3QoKSksIWUuZXJyb3ImJm4uX2NvbmZpZy5hbm5vdW5jZVN1Y2Nlc3NmdWxIZWFydGJlYXRzJiZuLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTdGF0dXMoZSl9LmJpbmQodGhpcykpKX19LHtrZXk6XCJfc3RhcnRTdWJzY3JpYmVMb29wXCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgbj10aGlzO3RoaXMuX3N0b3BTdWJzY3JpYmVMb29wKCk7dmFyIHI9e30saT1bXSxvPVtdO2lmKE9iamVjdC5rZXlzKHRoaXMuX2NoYW5uZWxzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PW4uX2NoYW5uZWxzW2VdLnN0YXRlO09iamVjdC5rZXlzKHQpLmxlbmd0aCYmKHJbZV09dCksaS5wdXNoKGUpfSksT2JqZWN0LmtleXModGhpcy5fcHJlc2VuY2VDaGFubmVscykuZm9yRWFjaChmdW5jdGlvbihlKXtpLnB1c2goXCJcIi5jb25jYXQoZSxcIi1wbnByZXNcIikpfSksT2JqZWN0LmtleXModGhpcy5fY2hhbm5lbEdyb3VwcykuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1uLl9jaGFubmVsR3JvdXBzW2VdLnN0YXRlO09iamVjdC5rZXlzKHQpLmxlbmd0aCYmKHJbZV09dCksby5wdXNoKGUpfSksT2JqZWN0LmtleXModGhpcy5fcHJlc2VuY2VDaGFubmVsR3JvdXBzKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe28ucHVzaChcIlwiLmNvbmNhdChlLFwiLXBucHJlc1wiKSl9KSwwIT09aS5sZW5ndGh8fDAhPT1vLmxlbmd0aCl7dmFyIGU9e2NoYW5uZWxzOmksY2hhbm5lbEdyb3VwczpvLHN0YXRlOnIsdGltZXRva2VuOnRoaXMuX2N1cnJlbnRUaW1ldG9rZW4sZmlsdGVyRXhwcmVzc2lvbjp0aGlzLl9jb25maWcuZmlsdGVyRXhwcmVzc2lvbixyZWdpb246dGhpcy5fcmVnaW9ufTt0aGlzLl9zdWJzY3JpYmVDYWxsPXRoaXMuX3N1YnNjcmliZUVuZHBvaW50KGUsdGhpcy5fcHJvY2Vzc1N1YnNjcmliZVJlc3BvbnNlLmJpbmQodGhpcykpfX19LHtrZXk6XCJfcHJvY2Vzc1N1YnNjcmliZVJlc3BvbnNlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt2YXIgYz10aGlzO2lmKHQuZXJyb3IpdC5jYXRlZ29yeT09PWEuZGVmYXVsdC5QTlRpbWVvdXRDYXRlZ29yeT90aGlzLl9zdGFydFN1YnNjcmliZUxvb3AoKToodC5jYXRlZ29yeT09PWEuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeT8odGhpcy5kaXNjb25uZWN0KCksdC5lcnJvciYmdGhpcy5fY29uZmlnLmF1dG9OZXR3b3JrRGV0ZWN0aW9uJiZ0aGlzLl9pc09ubGluZSYmKHRoaXMuX2lzT25saW5lPSExLHRoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZU5ldHdvcmtEb3duKCkpLHRoaXMuX3JlY29ubmVjdGlvbk1hbmFnZXIub25SZWNvbm5lY3Rpb24oZnVuY3Rpb24oKXtjLl9jb25maWcuYXV0b05ldHdvcmtEZXRlY3Rpb24mJiFjLl9pc09ubGluZSYmKGMuX2lzT25saW5lPSEwLGMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZU5ldHdvcmtVcCgpKSxjLnJlY29ubmVjdCgpLGMuX3N1YnNjcmlwdGlvblN0YXR1c0Fubm91bmNlZD0hMDt2YXIgZT17Y2F0ZWdvcnk6YS5kZWZhdWx0LlBOUmVjb25uZWN0ZWRDYXRlZ29yeSxvcGVyYXRpb246dC5vcGVyYXRpb24sbGFzdFRpbWV0b2tlbjpjLl9sYXN0VGltZXRva2VuLGN1cnJlbnRUaW1ldG9rZW46Yy5fY3VycmVudFRpbWV0b2tlbn07Yy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3RhdHVzKGUpfSksdGhpcy5fcmVjb25uZWN0aW9uTWFuYWdlci5zdGFydFBvbGxpbmcoKSk6dC5jYXRlZ29yeT09PWEuZGVmYXVsdC5QTkJhZFJlcXVlc3RDYXRlZ29yeSYmdGhpcy5fc3RvcEhlYXJ0YmVhdFRpbWVyKCksdGhpcy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3RhdHVzKHQpKTtlbHNle2lmKHRoaXMuX3N0b3JlZFRpbWV0b2tlbj8odGhpcy5fY3VycmVudFRpbWV0b2tlbj10aGlzLl9zdG9yZWRUaW1ldG9rZW4sdGhpcy5fc3RvcmVkVGltZXRva2VuPW51bGwpOih0aGlzLl9sYXN0VGltZXRva2VuPXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4sdGhpcy5fY3VycmVudFRpbWV0b2tlbj1lLm1ldGFkYXRhLnRpbWV0b2tlbiksIXRoaXMuX3N1YnNjcmlwdGlvblN0YXR1c0Fubm91bmNlZCl7dmFyIG49e307bi5jYXRlZ29yeT1hLmRlZmF1bHQuUE5Db25uZWN0ZWRDYXRlZ29yeSxuLm9wZXJhdGlvbj10Lm9wZXJhdGlvbixuLmFmZmVjdGVkQ2hhbm5lbHM9dGhpcy5fcGVuZGluZ0NoYW5uZWxTdWJzY3JpcHRpb25zLG4uc3Vic2NyaWJlZENoYW5uZWxzPXRoaXMuZ2V0U3Vic2NyaWJlZENoYW5uZWxzKCksbi5hZmZlY3RlZENoYW5uZWxHcm91cHM9dGhpcy5fcGVuZGluZ0NoYW5uZWxHcm91cFN1YnNjcmlwdGlvbnMsbi5sYXN0VGltZXRva2VuPXRoaXMuX2xhc3RUaW1ldG9rZW4sbi5jdXJyZW50VGltZXRva2VuPXRoaXMuX2N1cnJlbnRUaW1ldG9rZW4sdGhpcy5fc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkPSEwLHRoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyhuKSx0aGlzLl9wZW5kaW5nQ2hhbm5lbFN1YnNjcmlwdGlvbnM9W10sdGhpcy5fcGVuZGluZ0NoYW5uZWxHcm91cFN1YnNjcmlwdGlvbnM9W119dmFyIHI9ZS5tZXNzYWdlc3x8W10saT10aGlzLl9jb25maWcsbz1pLnJlcXVlc3RNZXNzYWdlQ291bnRUaHJlc2hvbGQsZj1pLmRlZHVwZU9uU3Vic2NyaWJlO2lmKG8mJnIubGVuZ3RoPj1vKXt2YXIgcz17fTtzLmNhdGVnb3J5PWEuZGVmYXVsdC5QTlJlcXVlc3RNZXNzYWdlQ291bnRFeGNlZWRlZENhdGVnb3J5LHMub3BlcmF0aW9uPXQub3BlcmF0aW9uLHRoaXMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVN0YXR1cyhzKX1yLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jaGFubmVsLG49ZS5zdWJzY3JpcHRpb25NYXRjaCxyPWUucHVibGlzaE1ldGFEYXRhO2lmKHQ9PT1uJiYobj1udWxsKSxmKXtpZihjLl9kZWR1cGluZ01hbmFnZXIuaXNEdXBsaWNhdGUoZSkpcmV0dXJuO2MuX2RlZHVwaW5nTWFuYWdlci5hZGRFbnRyeShlKX1pZihsLmRlZmF1bHQuZW5kc1dpdGgoZS5jaGFubmVsLFwiLXBucHJlc1wiKSl7dmFyIGk9e2NoYW5uZWw6bnVsbCxzdWJzY3JpcHRpb246bnVsbH07aS5hY3R1YWxDaGFubmVsPW51bGwhPW4/dDpudWxsLGkuc3Vic2NyaWJlZENoYW5uZWw9bnVsbCE9bj9uOnQsdCYmKGkuY2hhbm5lbD10LnN1YnN0cmluZygwLHQubGFzdEluZGV4T2YoXCItcG5wcmVzXCIpKSksbiYmKGkuc3Vic2NyaXB0aW9uPW4uc3Vic3RyaW5nKDAsbi5sYXN0SW5kZXhPZihcIi1wbnByZXNcIikpKSxpLmFjdGlvbj1lLnBheWxvYWQuYWN0aW9uLGkuc3RhdGU9ZS5wYXlsb2FkLmRhdGEsaS50aW1ldG9rZW49ci5wdWJsaXNoVGltZXRva2VuLGkub2NjdXBhbmN5PWUucGF5bG9hZC5vY2N1cGFuY3ksaS51dWlkPWUucGF5bG9hZC51dWlkLGkudGltZXN0YW1wPWUucGF5bG9hZC50aW1lc3RhbXAsZS5wYXlsb2FkLmpvaW4mJihpLmpvaW49ZS5wYXlsb2FkLmpvaW4pLGUucGF5bG9hZC5sZWF2ZSYmKGkubGVhdmU9ZS5wYXlsb2FkLmxlYXZlKSxlLnBheWxvYWQudGltZW91dCYmKGkudGltZW91dD1lLnBheWxvYWQudGltZW91dCksYy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlUHJlc2VuY2UoaSl9ZWxzZSBpZigxPT09ZS5tZXNzYWdlVHlwZSl7dmFyIG89e2NoYW5uZWw6bnVsbCxzdWJzY3JpcHRpb246bnVsbH07by5jaGFubmVsPXQsby5zdWJzY3JpcHRpb249bixvLnRpbWV0b2tlbj1yLnB1Ymxpc2hUaW1ldG9rZW4sby5wdWJsaXNoZXI9ZS5pc3N1aW5nQ2xpZW50SWQsZS51c2VyTWV0YWRhdGEmJihvLnVzZXJNZXRhZGF0YT1lLnVzZXJNZXRhZGF0YSksby5tZXNzYWdlPWUucGF5bG9hZCxjLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VTaWduYWwobyl9ZWxzZSBpZigyPT09ZS5tZXNzYWdlVHlwZSl7dmFyIHM9e2NoYW5uZWw6bnVsbCxzdWJzY3JpcHRpb246bnVsbH07cy5jaGFubmVsPXQscy5zdWJzY3JpcHRpb249bixzLnRpbWV0b2tlbj1yLnB1Ymxpc2hUaW1ldG9rZW4scy5wdWJsaXNoZXI9ZS5pc3N1aW5nQ2xpZW50SWQsZS51c2VyTWV0YWRhdGEmJihzLnVzZXJNZXRhZGF0YT1lLnVzZXJNZXRhZGF0YSkscy5tZXNzYWdlPXtldmVudDplLnBheWxvYWQuZXZlbnQsdHlwZTplLnBheWxvYWQudHlwZSxkYXRhOmUucGF5bG9hZC5kYXRhfSxcInVzZXJcIj09PWUucGF5bG9hZC50eXBlP2MuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZVVzZXIocyk6XCJzcGFjZVwiPT09ZS5wYXlsb2FkLnR5cGU/Yy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlU3BhY2Uocyk6XCJtZW1iZXJzaGlwXCI9PT1lLnBheWxvYWQudHlwZSYmYy5fbGlzdGVuZXJNYW5hZ2VyLmFubm91bmNlTWVtYmVyc2hpcChzKX1lbHNlIGlmKDM9PT1lLm1lc3NhZ2VUeXBlKXt2YXIgYT17fTthLmNoYW5uZWw9dCxhLnN1YnNjcmlwdGlvbj1uLGEudGltZXRva2VuPXIucHVibGlzaFRpbWV0b2tlbixhLnB1Ymxpc2hlcj1lLmlzc3VpbmdDbGllbnRJZCxhLmRhdGE9e21lc3NhZ2VUaW1ldG9rZW46ZS5wYXlsb2FkLmRhdGEubWVzc2FnZVRpbWV0b2tlbixhY3Rpb25UaW1ldG9rZW46ZS5wYXlsb2FkLmRhdGEuYWN0aW9uVGltZXRva2VuLHR5cGU6ZS5wYXlsb2FkLmRhdGEudHlwZSx1dWlkOmUuaXNzdWluZ0NsaWVudElkLHZhbHVlOmUucGF5bG9hZC5kYXRhLnZhbHVlfSxhLmV2ZW50PWUucGF5bG9hZC5ldmVudCxjLl9saXN0ZW5lck1hbmFnZXIuYW5ub3VuY2VNZXNzYWdlQWN0aW9uKGEpfWVsc2V7dmFyIHU9e2NoYW5uZWw6bnVsbCxzdWJzY3JpcHRpb246bnVsbH07dS5hY3R1YWxDaGFubmVsPW51bGwhPW4/dDpudWxsLHUuc3Vic2NyaWJlZENoYW5uZWw9bnVsbCE9bj9uOnQsdS5jaGFubmVsPXQsdS5zdWJzY3JpcHRpb249bix1LnRpbWV0b2tlbj1yLnB1Ymxpc2hUaW1ldG9rZW4sdS5wdWJsaXNoZXI9ZS5pc3N1aW5nQ2xpZW50SWQsZS51c2VyTWV0YWRhdGEmJih1LnVzZXJNZXRhZGF0YT1lLnVzZXJNZXRhZGF0YSksYy5fY29uZmlnLmNpcGhlcktleT91Lm1lc3NhZ2U9Yy5fY3J5cHRvLmRlY3J5cHQoZS5wYXlsb2FkKTp1Lm1lc3NhZ2U9ZS5wYXlsb2FkLGMuX2xpc3RlbmVyTWFuYWdlci5hbm5vdW5jZU1lc3NhZ2UodSl9fSksdGhpcy5fcmVnaW9uPWUubWV0YWRhdGEucmVnaW9uLHRoaXMuX3N0YXJ0U3Vic2NyaWJlTG9vcCgpfX19LHtrZXk6XCJfc3RvcFN1YnNjcmliZUxvb3BcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3N1YnNjcmliZUNhbGwmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9zdWJzY3JpYmVDYWxsLmFib3J0JiZ0aGlzLl9zdWJzY3JpYmVDYWxsLmFib3J0KCksdGhpcy5fc3Vic2NyaWJlQ2FsbD1udWxsKX19XSkmJmkoby5wcm90b3R5cGUscyksdm9pZCh1JiZpKG8sdSkpLGQpO2Z1bmN0aW9uIGQoZSl7dmFyIHQ9ZS5zdWJzY3JpYmVFbmRwb2ludCxuPWUubGVhdmVFbmRwb2ludCxyPWUuaGVhcnRiZWF0RW5kcG9pbnQsaT1lLnNldFN0YXRlRW5kcG9pbnQsbz1lLnRpbWVFbmRwb2ludCxzPWUuY29uZmlnLGE9ZS5jcnlwdG8sdT1lLmxpc3RlbmVyTWFuYWdlcjshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGQpLGgodGhpcyxcIl9jcnlwdG9cIix2b2lkIDApLGgodGhpcyxcIl9jb25maWdcIix2b2lkIDApLGgodGhpcyxcIl9saXN0ZW5lck1hbmFnZXJcIix2b2lkIDApLGgodGhpcyxcIl9yZWNvbm5lY3Rpb25NYW5hZ2VyXCIsdm9pZCAwKSxoKHRoaXMsXCJfbGVhdmVFbmRwb2ludFwiLHZvaWQgMCksaCh0aGlzLFwiX2hlYXJ0YmVhdEVuZHBvaW50XCIsdm9pZCAwKSxoKHRoaXMsXCJfc2V0U3RhdGVFbmRwb2ludFwiLHZvaWQgMCksaCh0aGlzLFwiX3N1YnNjcmliZUVuZHBvaW50XCIsdm9pZCAwKSxoKHRoaXMsXCJfY2hhbm5lbHNcIix2b2lkIDApLGgodGhpcyxcIl9wcmVzZW5jZUNoYW5uZWxzXCIsdm9pZCAwKSxoKHRoaXMsXCJfaGVhcnRiZWF0Q2hhbm5lbHNcIix2b2lkIDApLGgodGhpcyxcIl9oZWFydGJlYXRDaGFubmVsR3JvdXBzXCIsdm9pZCAwKSxoKHRoaXMsXCJfY2hhbm5lbEdyb3Vwc1wiLHZvaWQgMCksaCh0aGlzLFwiX3ByZXNlbmNlQ2hhbm5lbEdyb3Vwc1wiLHZvaWQgMCksaCh0aGlzLFwiX2N1cnJlbnRUaW1ldG9rZW5cIix2b2lkIDApLGgodGhpcyxcIl9sYXN0VGltZXRva2VuXCIsdm9pZCAwKSxoKHRoaXMsXCJfc3RvcmVkVGltZXRva2VuXCIsdm9pZCAwKSxoKHRoaXMsXCJfcmVnaW9uXCIsdm9pZCAwKSxoKHRoaXMsXCJfc3Vic2NyaWJlQ2FsbFwiLHZvaWQgMCksaCh0aGlzLFwiX2hlYXJ0YmVhdFRpbWVyXCIsdm9pZCAwKSxoKHRoaXMsXCJfc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkXCIsdm9pZCAwKSxoKHRoaXMsXCJfYXV0b05ldHdvcmtEZXRlY3Rpb25cIix2b2lkIDApLGgodGhpcyxcIl9pc09ubGluZVwiLHZvaWQgMCksaCh0aGlzLFwiX3BlbmRpbmdDaGFubmVsU3Vic2NyaXB0aW9uc1wiLHZvaWQgMCksaCh0aGlzLFwiX3BlbmRpbmdDaGFubmVsR3JvdXBTdWJzY3JpcHRpb25zXCIsdm9pZCAwKSxoKHRoaXMsXCJfZGVkdXBpbmdNYW5hZ2VyXCIsdm9pZCAwKSx0aGlzLl9saXN0ZW5lck1hbmFnZXI9dSx0aGlzLl9jb25maWc9cyx0aGlzLl9sZWF2ZUVuZHBvaW50PW4sdGhpcy5faGVhcnRiZWF0RW5kcG9pbnQ9cix0aGlzLl9zZXRTdGF0ZUVuZHBvaW50PWksdGhpcy5fc3Vic2NyaWJlRW5kcG9pbnQ9dCx0aGlzLl9jcnlwdG89YSx0aGlzLl9jaGFubmVscz17fSx0aGlzLl9wcmVzZW5jZUNoYW5uZWxzPXt9LHRoaXMuX2hlYXJ0YmVhdENoYW5uZWxzPXt9LHRoaXMuX2hlYXJ0YmVhdENoYW5uZWxHcm91cHM9e30sdGhpcy5fY2hhbm5lbEdyb3Vwcz17fSx0aGlzLl9wcmVzZW5jZUNoYW5uZWxHcm91cHM9e30sdGhpcy5fcGVuZGluZ0NoYW5uZWxTdWJzY3JpcHRpb25zPVtdLHRoaXMuX3BlbmRpbmdDaGFubmVsR3JvdXBTdWJzY3JpcHRpb25zPVtdLHRoaXMuX2N1cnJlbnRUaW1ldG9rZW49MCx0aGlzLl9sYXN0VGltZXRva2VuPTAsdGhpcy5fc3RvcmVkVGltZXRva2VuPW51bGwsdGhpcy5fc3Vic2NyaXB0aW9uU3RhdHVzQW5ub3VuY2VkPSExLHRoaXMuX2lzT25saW5lPSEwLHRoaXMuX3JlY29ubmVjdGlvbk1hbmFnZXI9bmV3IGMuZGVmYXVsdCh7dGltZUVuZHBvaW50Om99KSx0aGlzLl9kZWR1cGluZ01hbmFnZXI9bmV3IGYuZGVmYXVsdCh7Y29uZmlnOnN9KX10LmRlZmF1bHQ9cCxlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDt2YXIgcjsocj1uKDgpKSYmci5fX2VzTW9kdWxlLG4oMCk7ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKXt2YXIgcj10W25dO3IuZW51bWVyYWJsZT1yLmVudW1lcmFibGV8fCExLHIuY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIHImJihyLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLmtleSxyKX19ZnVuY3Rpb24gbyhlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9dmFyIHMsYSx1LGM9KHM9ZiwoYT1be2tleTpcIm9uUmVjb25uZWN0aW9uXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5fcmVjb25uZWN0aW9uQ2FsbGJhY2s9ZX19LHtrZXk6XCJzdGFydFBvbGxpbmdcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3RpbWVUaW1lcj1zZXRJbnRlcnZhbCh0aGlzLl9wZXJmb3JtVGltZUxvb3AuYmluZCh0aGlzKSwzZTMpfX0se2tleTpcInN0b3BQb2xsaW5nXCIsdmFsdWU6ZnVuY3Rpb24oKXtjbGVhckludGVydmFsKHRoaXMuX3RpbWVUaW1lcil9fSx7a2V5OlwiX3BlcmZvcm1UaW1lTG9vcFwiLHZhbHVlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpczt0aGlzLl90aW1lRW5kcG9pbnQoZnVuY3Rpb24oZSl7ZS5lcnJvcnx8KGNsZWFySW50ZXJ2YWwodC5fdGltZVRpbWVyKSx0Ll9yZWNvbm5lY3Rpb25DYWxsYmFjaygpKX0pfX1dKSYmaShzLnByb3RvdHlwZSxhKSx2b2lkKHUmJmkocyx1KSksZik7ZnVuY3Rpb24gZihlKXt2YXIgdD1lLnRpbWVFbmRwb2ludDshZnVuY3Rpb24oZSx0KXtpZighKGUgaW5zdGFuY2VvZiB0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpfSh0aGlzLGYpLG8odGhpcyxcIl9yZWNvbm5lY3Rpb25DYWxsYmFja1wiLHZvaWQgMCksbyh0aGlzLFwiX3RpbWVFbmRwb2ludFwiLHZvaWQgMCksbyh0aGlzLFwiX3RpbWVUaW1lclwiLHZvaWQgMCksdGhpcy5fdGltZUVuZHBvaW50PXR9dC5kZWZhdWx0PWMsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIHI7KHI9bigzKSkmJnIuX19lc01vZHVsZSxuKDApO2Z1bmN0aW9uIGkoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIG8oZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfXZhciBzLGEsdSxjPShzPWYsKGE9W3trZXk6XCJnZXRLZXlcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD1mdW5jdGlvbihlKXt2YXIgdD0wO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gdDtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rPTEpdD0odDw8NSktdCtlLmNoYXJDb2RlQXQobiksdCY9dDtyZXR1cm4gdH0oSlNPTi5zdHJpbmdpZnkoZS5wYXlsb2FkKSkudG9TdHJpbmcoKSxuPWUucHVibGlzaE1ldGFEYXRhLnB1Ymxpc2hUaW1ldG9rZW47cmV0dXJuXCJcIi5jb25jYXQobixcIi1cIikuY29uY2F0KHQpfX0se2tleTpcImlzRHVwbGljYXRlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuaGFzaEhpc3RvcnkuaW5jbHVkZXModGhpcy5nZXRLZXkoZSkpfX0se2tleTpcImFkZEVudHJ5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dGhpcy5oYXNoSGlzdG9yeS5sZW5ndGg+PXRoaXMuX2NvbmZpZy5tYXhpbXVtQ2FjaGVTaXplJiZ0aGlzLmhhc2hIaXN0b3J5LnNoaWZ0KCksdGhpcy5oYXNoSGlzdG9yeS5wdXNoKHRoaXMuZ2V0S2V5KGUpKX19LHtrZXk6XCJjbGVhckhpc3RvcnlcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuaGFzaEhpc3Rvcnk9W119fV0pJiZpKHMucHJvdG90eXBlLGEpLHZvaWQodSYmaShzLHUpKSxmKTtmdW5jdGlvbiBmKGUpe3ZhciB0PWUuY29uZmlnOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsZiksbyh0aGlzLFwiX2NvbmZpZ1wiLHZvaWQgMCksbyh0aGlzLFwiaGFzaEhpc3RvcnlcIix2b2lkIDApLHRoaXMuaGFzaEhpc3Rvcnk9W10sdGhpcy5fY29uZmlnPXR9dC5kZWZhdWx0PWMsZS5leHBvcnRzPXQuZGVmYXVsdH0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD10LkZDTU5vdGlmaWNhdGlvblBheWxvYWQ9dC5NUE5TTm90aWZpY2F0aW9uUGF5bG9hZD10LkFQTlNOb3RpZmljYXRpb25QYXlsb2FkPXZvaWQgMDtuKDApO2Z1bmN0aW9uIHIoZSl7cmV0dXJuKHI9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIGkoZSx0KXtpZihudWxsPT1lKXJldHVybnt9O3ZhciBuLHIsaT1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpcmV0dXJue307dmFyIG4scixpPXt9LG89T2JqZWN0LmtleXMoZSk7Zm9yKHI9MDtyPG8ubGVuZ3RoO3IrKyluPW9bcl0sMDw9dC5pbmRleE9mKG4pfHwoaVtuXT1lW25dKTtyZXR1cm4gaX0oZSx0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2ZvcihyPTA7cjxvLmxlbmd0aDtyKyspbj1vW3JdLDA8PXQuaW5kZXhPZihuKXx8T2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsbikmJihpW25dPWVbbl0pfXJldHVybiBpfWZ1bmN0aW9uIG8odCxlKXt2YXIgbj1PYmplY3Qua2V5cyh0KTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHQpO2UmJihyPXIuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiBzKHQpe2Zvcih2YXIgZT0xO2U8YXJndW1lbnRzLmxlbmd0aDtlKyspe3ZhciBuPW51bGwhPWFyZ3VtZW50c1tlXT9hcmd1bWVudHNbZV06e307ZSUyP28oT2JqZWN0KG4pLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe2codCxlLG5bZV0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXModCxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhuKSk6byhPYmplY3QobikpLmZvckVhY2goZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG4sZSkpfSl9cmV0dXJuIHR9ZnVuY3Rpb24gYShlLHQpe3JldHVybiF0fHxcIm9iamVjdFwiIT09cih0KSYmXCJmdW5jdGlvblwiIT10eXBlb2YgdD9jKGUpOnR9ZnVuY3Rpb24gdShlKXtyZXR1cm4odT1PYmplY3Quc2V0UHJvdG90eXBlT2Y/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKGUpe3JldHVybiBlLl9fcHJvdG9fX3x8T2JqZWN0LmdldFByb3RvdHlwZU9mKGUpfSkoZSl9ZnVuY3Rpb24gYyhlKXtpZih2b2lkIDA9PT1lKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtyZXR1cm4gZX1mdW5jdGlvbiBmKGUsdCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCYmbnVsbCE9PXQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodCYmdC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLHdyaXRhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMH19KSx0JiZsKGUsdCl9ZnVuY3Rpb24gbChlLHQpe3JldHVybihsPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS5fX3Byb3RvX189dCxlfSkoZSx0KX1mdW5jdGlvbiBoKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX1mdW5jdGlvbiBwKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBkKGUsdCxuKXtyZXR1cm4gdCYmcChlLnByb3RvdHlwZSx0KSxuJiZwKGUsbiksZX1mdW5jdGlvbiBnKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgeT0oZCh2LFt7a2V5OlwicGF5bG9hZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXlsb2FkfX0se2tleTpcInRpdGxlXCIsc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3RpdGxlPWV9fSx7a2V5Olwic3VidGl0bGVcIixzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fc3VidGl0bGU9ZX19LHtrZXk6XCJib2R5XCIsc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX2JvZHk9ZX19LHtrZXk6XCJiYWRnZVwiLHNldDpmdW5jdGlvbihlKXt0aGlzLl9iYWRnZT1lfX0se2tleTpcInNvdW5kXCIsc2V0OmZ1bmN0aW9uKGUpe3RoaXMuX3NvdW5kPWV9fV0pLGQodixbe2tleTpcIl9zZXREZWZhdWx0UGF5bG9hZFN0cnVjdHVyZVwiLHZhbHVlOmZ1bmN0aW9uKCl7fX0se2tleTpcInRvT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm57fX19XSksdik7ZnVuY3Rpb24gdihlLHQsbil7aCh0aGlzLHYpLGcodGhpcyxcIl9zdWJ0aXRsZVwiLHZvaWQgMCksZyh0aGlzLFwiX3BheWxvYWRcIix2b2lkIDApLGcodGhpcyxcIl9iYWRnZVwiLHZvaWQgMCksZyh0aGlzLFwiX3NvdW5kXCIsdm9pZCAwKSxnKHRoaXMsXCJfdGl0bGVcIix2b2lkIDApLGcodGhpcyxcIl9ib2R5XCIsdm9pZCAwKSx0aGlzLl9wYXlsb2FkPWUsdGhpcy5fc2V0RGVmYXVsdFBheWxvYWRTdHJ1Y3R1cmUoKSx0aGlzLnRpdGxlPXQsdGhpcy5ib2R5PW59dmFyIGI9KGYobSx5KSxkKG0sW3trZXk6XCJfc2V0RGVmYXVsdFBheWxvYWRTdHJ1Y3R1cmVcIix2YWx1ZTpmdW5jdGlvbigpe3RoaXMuX3BheWxvYWQuYXBzPXthbGVydDp7fX19fSx7a2V5OlwidG9PYmplY3RcIix2YWx1ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMsZT1zKHt9LHRoaXMuX3BheWxvYWQpLG49ZS5hcHMscj1uLmFsZXJ0O2lmKHRoaXMuX2lzU2lsZW50JiYobltcImNvbnRlbnQtYXZhaWxhYmxlXCJdPTEpLFwiYXBuczJcIj09PXRoaXMuX2FwbnNQdXNoVHlwZSl7aWYoIXRoaXMuX2NvbmZpZ3VyYXRpb25zfHwhdGhpcy5fY29uZmlndXJhdGlvbnMubGVuZ3RoKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIkFQTlMyIGNvbmZpZ3VyYXRpb24gaXMgbWlzc2luZ1wiKTt2YXIgaT1bXTt0aGlzLl9jb25maWd1cmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2kucHVzaCh0Ll9vYmplY3RGcm9tQVBOUzJDb25maWd1cmF0aW9uKGUpKX0pLGkubGVuZ3RoJiYoZS5wbl9wdXNoPWkpfXJldHVybiByJiZPYmplY3Qua2V5cyhyKS5sZW5ndGh8fGRlbGV0ZSBuLmFsZXJ0LHRoaXMuX2lzU2lsZW50JiYoZGVsZXRlIG4uYWxlcnQsZGVsZXRlIG4uYmFkZ2UsZGVsZXRlIG4uc291bmQscj17fSksdGhpcy5faXNTaWxlbnR8fE9iamVjdC5rZXlzKHIpLmxlbmd0aD9lOm51bGx9fSx7a2V5OlwiX29iamVjdEZyb21BUE5TMkNvbmZpZ3VyYXRpb25cIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD10aGlzO2lmKCFlLnRhcmdldHN8fCFlLnRhcmdldHMubGVuZ3RoKXRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcIkF0IGxlYXN0IG9uZSBBUE5TMiB0YXJnZXQgc2hvdWxkIGJlIHByb3ZpZGVkXCIpO3ZhciBuPVtdO2UudGFyZ2V0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe24ucHVzaCh0Ll9vYmplY3RGcm9tQVBOU1RhcmdldChlKSl9KTt2YXIgcj1lLmNvbGxhcHNlSWQsaT1lLmV4cGlyYXRpb25EYXRlLG89e2F1dGhfbWV0aG9kOlwidG9rZW5cIix0YXJnZXRzOm4sdmVyc2lvbjpcInYyXCJ9O3JldHVybiByJiZyLmxlbmd0aCYmKG8uY29sbGFwc2VfaWQ9ciksaSYmKG8uZXhwaXJhdGlvbj1pLnRvSVNPU3RyaW5nKCkpLG99fSx7a2V5OlwiX29iamVjdEZyb21BUE5TVGFyZ2V0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoIWUudG9waWN8fCFlLnRvcGljLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGFyZ2V0ICd0b3BpYycgdW5kZWZpbmVkLlwiKTt2YXIgdD1lLnRvcGljLG49ZS5lbnZpcm9ubWVudCxyPXZvaWQgMD09PW4/XCJkZXZlbG9wbWVudFwiOm4saT1lLmV4Y2x1ZGVkRGV2aWNlcyxvPXZvaWQgMD09PWk/W106aSxzPXt0b3BpYzp0LGVudmlyb25tZW50OnJ9O3JldHVybiBvLmxlbmd0aCYmKHMuZXhjbHVkZWRfZGV2aWNlcz1vKSxzfX0se2tleTpcImNvbmZpZ3VyYXRpb25zXCIsc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fY29uZmlndXJhdGlvbnM9ZSl9fSx7a2V5Olwibm90aWZpY2F0aW9uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3BheWxvYWQuYXBzfX0se2tleTpcInRpdGxlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3RpdGxlfSxzZXQ6ZnVuY3Rpb24oZSl7ZSYmZS5sZW5ndGgmJih0aGlzLl9wYXlsb2FkLmFwcy5hbGVydC50aXRsZT1lLHRoaXMuX3RpdGxlPWUpfX0se2tleTpcInN1YnRpdGxlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N1YnRpdGxlfSxzZXQ6ZnVuY3Rpb24oZSl7ZSYmZS5sZW5ndGgmJih0aGlzLl9wYXlsb2FkLmFwcy5hbGVydC5zdWJ0aXRsZT1lLHRoaXMuX3N1YnRpdGxlPWUpfX0se2tleTpcImJvZHlcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYm9keX0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC5hcHMuYWxlcnQuYm9keT1lLHRoaXMuX2JvZHk9ZSl9fSx7a2V5OlwiYmFkZ2VcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYmFkZ2V9LHNldDpmdW5jdGlvbihlKXtudWxsIT1lJiYodGhpcy5fcGF5bG9hZC5hcHMuYmFkZ2U9ZSx0aGlzLl9iYWRnZT1lKX19LHtrZXk6XCJzb3VuZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VuZH0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC5hcHMuc291bmQ9ZSx0aGlzLl9zb3VuZD1lKX19LHtrZXk6XCJzaWxlbnRcIixzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5faXNTaWxlbnQ9ZX19XSksbSk7ZnVuY3Rpb24gbSgpe3ZhciBlLHQ7aCh0aGlzLG0pO2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KG4pLGk9MDtpPG47aSsrKXJbaV09YXJndW1lbnRzW2ldO3JldHVybiBnKGModD1hKHRoaXMsKGU9dShtKSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQocikpKSksXCJfY29uZmlndXJhdGlvbnNcIix2b2lkIDApLGcoYyh0KSxcIl9hcG5zUHVzaFR5cGVcIix2b2lkIDApLGcoYyh0KSxcIl9pc1NpbGVudFwiLHZvaWQgMCksdH10LkFQTlNOb3RpZmljYXRpb25QYXlsb2FkPWI7dmFyIF89KGYoayx5KSxkKGssW3trZXk6XCJ0b09iamVjdFwiLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3BheWxvYWQpLmxlbmd0aD9zKHt9LHRoaXMuX3BheWxvYWQpOm51bGx9fSx7a2V5OlwiYmFja0NvbnRlbnRcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYmFja0NvbnRlbnR9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQuYmFja19jb250ZW50PWUsdGhpcy5fYmFja0NvbnRlbnQ9ZSl9fSx7a2V5OlwiYmFja1RpdGxlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JhY2tUaXRsZX0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC5iYWNrX3RpdGxlPWUsdGhpcy5fYmFja1RpdGxlPWUpfX0se2tleTpcImNvdW50XCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvdW50fSxzZXQ6ZnVuY3Rpb24oZSl7bnVsbCE9ZSYmKHRoaXMuX3BheWxvYWQuY291bnQ9ZSx0aGlzLl9jb3VudD1lKX19LHtrZXk6XCJ0aXRsZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90aXRsZX0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC50aXRsZT1lLHRoaXMuX3RpdGxlPWUpfX0se2tleTpcInR5cGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdHlwZX0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC50eXBlPWUsdGhpcy5fdHlwZT1lKX19LHtrZXk6XCJzdWJ0aXRsZVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tUaXRsZX0sc2V0OmZ1bmN0aW9uKGUpe3RoaXMuYmFja1RpdGxlPWV9fSx7a2V5OlwiYm9keVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJhY2tDb250ZW50fSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5iYWNrQ29udGVudD1lfX0se2tleTpcImJhZGdlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY291bnR9LHNldDpmdW5jdGlvbihlKXt0aGlzLmNvdW50PWV9fV0pLGspO2Z1bmN0aW9uIGsoKXt2YXIgZSx0O2godGhpcyxrKTtmb3IodmFyIG49YXJndW1lbnRzLmxlbmd0aCxyPW5ldyBBcnJheShuKSxpPTA7aTxuO2krKylyW2ldPWFyZ3VtZW50c1tpXTtyZXR1cm4gZyhjKHQ9YSh0aGlzLChlPXUoaykpLmNhbGwuYXBwbHkoZSxbdGhpc10uY29uY2F0KHIpKSkpLFwiX2JhY2tDb250ZW50XCIsdm9pZCAwKSxnKGModCksXCJfYmFja1RpdGxlXCIsdm9pZCAwKSxnKGModCksXCJfY291bnRcIix2b2lkIDApLGcoYyh0KSxcIl90eXBlXCIsdm9pZCAwKSx0fXQuTVBOU05vdGlmaWNhdGlvblBheWxvYWQ9Xzt2YXIgUD0oZih3LHkpLGQodyxbe2tleTpcIl9zZXREZWZhdWx0UGF5bG9hZFN0cnVjdHVyZVwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fcGF5bG9hZC5ub3RpZmljYXRpb249e30sdGhpcy5fcGF5bG9hZC5kYXRhPXt9fX0se2tleTpcInRvT2JqZWN0XCIsdmFsdWU6ZnVuY3Rpb24oKXt2YXIgZT1zKHt9LHRoaXMuX3BheWxvYWQuZGF0YSksdD1udWxsLG49e307aWYoMjxPYmplY3Qua2V5cyh0aGlzLl9wYXlsb2FkKS5sZW5ndGgpe3ZhciByPXRoaXMuX3BheWxvYWQ7ci5ub3RpZmljYXRpb24sci5kYXRhLGU9cyh7fSxlLHt9LGkocixbXCJub3RpZmljYXRpb25cIixcImRhdGFcIl0pKX1yZXR1cm4gdGhpcy5faXNTaWxlbnQ/ZS5ub3RpZmljYXRpb249dGhpcy5fcGF5bG9hZC5ub3RpZmljYXRpb246dD10aGlzLl9wYXlsb2FkLm5vdGlmaWNhdGlvbixPYmplY3Qua2V5cyhlKS5sZW5ndGgmJihuLmRhdGE9ZSksdCYmT2JqZWN0LmtleXModCkubGVuZ3RoJiYobi5ub3RpZmljYXRpb249dCksT2JqZWN0LmtleXMobikubGVuZ3RoP246bnVsbH19LHtrZXk6XCJub3RpZmljYXRpb25cIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcGF5bG9hZC5ub3RpZmljYXRpb259fSx7a2V5OlwiZGF0YVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9wYXlsb2FkLmRhdGF9fSx7a2V5OlwidGl0bGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGl0bGV9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQubm90aWZpY2F0aW9uLnRpdGxlPWUsdGhpcy5fdGl0bGU9ZSl9fSx7a2V5OlwiYm9keVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ib2R5fSxzZXQ6ZnVuY3Rpb24oZSl7ZSYmZS5sZW5ndGgmJih0aGlzLl9wYXlsb2FkLm5vdGlmaWNhdGlvbi5ib2R5PWUsdGhpcy5fYm9keT1lKX19LHtrZXk6XCJzb3VuZFwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zb3VuZH0sc2V0OmZ1bmN0aW9uKGUpe2UmJmUubGVuZ3RoJiYodGhpcy5fcGF5bG9hZC5ub3RpZmljYXRpb24uc291bmQ9ZSx0aGlzLl9zb3VuZD1lKX19LHtrZXk6XCJpY29uXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ljb259LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQubm90aWZpY2F0aW9uLmljb249ZSx0aGlzLl9pY29uPWUpfX0se2tleTpcInRhZ1wiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl90YWd9LHNldDpmdW5jdGlvbihlKXtlJiZlLmxlbmd0aCYmKHRoaXMuX3BheWxvYWQubm90aWZpY2F0aW9uLnRhZz1lLHRoaXMuX3RhZz1lKX19LHtrZXk6XCJzaWxlbnRcIixzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5faXNTaWxlbnQ9ZX19XSksdyk7ZnVuY3Rpb24gdygpe3ZhciBlLHQ7aCh0aGlzLHcpO2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHI9bmV3IEFycmF5KG4pLGk9MDtpPG47aSsrKXJbaV09YXJndW1lbnRzW2ldO3JldHVybiBnKGModD1hKHRoaXMsKGU9dSh3KSkuY2FsbC5hcHBseShlLFt0aGlzXS5jb25jYXQocikpKSksXCJfaXNTaWxlbnRcIix2b2lkIDApLGcoYyh0KSxcIl9pY29uXCIsdm9pZCAwKSxnKGModCksXCJfdGFnXCIsdm9pZCAwKSx0fWZ1bmN0aW9uIFQoZSx0KXtoKHRoaXMsVCksZyh0aGlzLFwiX3BheWxvYWRcIix2b2lkIDApLGcodGhpcyxcIl9kZWJ1Z2dpbmdcIix2b2lkIDApLGcodGhpcyxcIl9zdWJ0aXRsZVwiLHZvaWQgMCksZyh0aGlzLFwiX2JhZGdlXCIsdm9pZCAwKSxnKHRoaXMsXCJfc291bmRcIix2b2lkIDApLGcodGhpcyxcIl90aXRsZVwiLHZvaWQgMCksZyh0aGlzLFwiX2JvZHlcIix2b2lkIDApLGcodGhpcyxcImFwbnNcIix2b2lkIDApLGcodGhpcyxcIm1wbnNcIix2b2lkIDApLGcodGhpcyxcImZjbVwiLHZvaWQgMCksdGhpcy5fcGF5bG9hZD17YXBuczp7fSxtcG5zOnt9LGZjbTp7fX0sdGhpcy5fdGl0bGU9ZSx0aGlzLl9ib2R5PXQsdGhpcy5hcG5zPW5ldyBiKHRoaXMuX3BheWxvYWQuYXBucyxlLHQpLHRoaXMubXBucz1uZXcgXyh0aGlzLl9wYXlsb2FkLm1wbnMsZSx0KSx0aGlzLmZjbT1uZXcgUCh0aGlzLl9wYXlsb2FkLmZjbSxlLHQpfXQuRkNNTm90aWZpY2F0aW9uUGF5bG9hZD1QO3ZhciBPPShkKFQsW3trZXk6XCJkZWJ1Z2dpbmdcIixzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fZGVidWdnaW5nPWV9fSx7a2V5OlwidGl0bGVcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fdGl0bGV9fSx7a2V5OlwiYm9keVwiLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9ib2R5fX0se2tleTpcInN1YnRpdGxlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N1YnRpdGxlfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fc3VidGl0bGU9ZSx0aGlzLmFwbnMuc3VidGl0bGU9ZSx0aGlzLm1wbnMuc3VidGl0bGU9ZSx0aGlzLmZjbS5zdWJ0aXRsZT1lfX0se2tleTpcImJhZGdlXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2JhZGdlfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fYmFkZ2U9ZSx0aGlzLmFwbnMuYmFkZ2U9ZSx0aGlzLm1wbnMuYmFkZ2U9ZSx0aGlzLmZjbS5iYWRnZT1lfX0se2tleTpcInNvdW5kXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NvdW5kfSxzZXQ6ZnVuY3Rpb24oZSl7dGhpcy5fc291bmQ9ZSx0aGlzLmFwbnMuc291bmQ9ZSx0aGlzLm1wbnMuc291bmQ9ZSx0aGlzLmZjbS5zb3VuZD1lfX1dKSxkKFQsW3trZXk6XCJidWlsZFBheWxvYWRcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD17fTtpZihlLmluY2x1ZGVzKFwiYXBuc1wiKXx8ZS5pbmNsdWRlcyhcImFwbnMyXCIpKXt0aGlzLmFwbnMuX2FwbnNQdXNoVHlwZT1lLmluY2x1ZGVzKFwiYXBuc1wiKT9cImFwbnNcIjpcImFwbnMyXCI7dmFyIG49dGhpcy5hcG5zLnRvT2JqZWN0KCk7biYmT2JqZWN0LmtleXMobikubGVuZ3RoJiYodC5wbl9hcG5zPW4pfWlmKGUuaW5jbHVkZXMoXCJtcG5zXCIpKXt2YXIgcj10aGlzLm1wbnMudG9PYmplY3QoKTtyJiZPYmplY3Qua2V5cyhyKS5sZW5ndGgmJih0LnBuX21wbnM9cil9aWYoZS5pbmNsdWRlcyhcImZjbVwiKSl7dmFyIGk9dGhpcy5mY20udG9PYmplY3QoKTtpJiZPYmplY3Qua2V5cyhpKS5sZW5ndGgmJih0LnBuX2djbT1pKX1yZXR1cm4gT2JqZWN0LmtleXModCkubGVuZ3RoJiZ0aGlzLl9kZWJ1Z2dpbmcmJih0LnBuX2RlYnVnPSEwKSx0fX1dKSxUKTt0LmRlZmF1bHQ9T30sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZGVmYXVsdD12b2lkIDA7dmFyIHI7KHI9bigzKSkmJnIuX19lc01vZHVsZSxuKDApO2Z1bmN0aW9uIGkoZSl7cmV0dXJuKGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIG8oZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fWZ1bmN0aW9uIHMoZSx0LG4pe3JldHVybiB0IGluIGU/T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7dmFsdWU6bixlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMH0pOmVbdF09bixlfXZhciBhLHUsYyxmPShhPWwsKHU9W3trZXk6XCJfaW5pdGlhbGl6ZVRva2Vuc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5fdXNlclRva2Vucz17fSx0aGlzLl9zcGFjZVRva2Vucz17fSx0aGlzLl91c2VyVG9rZW49dm9pZCAwLHRoaXMuX3NwYWNlVG9rZW49dm9pZCAwfX0se2tleTpcIl9zZXRUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKHQpe3ZhciBuPXRoaXMsZT10aGlzLnBhcnNlVG9rZW4odCk7ZSYmZS5yZXNvdXJjZXMmJihlLnJlc291cmNlcy51c2VycyYmT2JqZWN0LmtleXMoZS5yZXNvdXJjZXMudXNlcnMpLmZvckVhY2goZnVuY3Rpb24oZSl7bi5fdXNlclRva2Vuc1tlXT10fSksZS5yZXNvdXJjZXMuc3BhY2VzJiZPYmplY3Qua2V5cyhlLnJlc291cmNlcy5zcGFjZXMpLmZvckVhY2goZnVuY3Rpb24oZSl7bi5fc3BhY2VUb2tlbnNbZV09dH0pKSxlJiZlLnBhdHRlcm5zJiYoZS5wYXR0ZXJucy51c2VycyYmMDxPYmplY3Qua2V5cyhlLnBhdHRlcm5zLnVzZXJzKS5sZW5ndGgmJih0aGlzLl91c2VyVG9rZW49dCksZS5wYXR0ZXJucy5zcGFjZXMmJjA8T2JqZWN0LmtleXMoZS5wYXR0ZXJucy5zcGFjZXMpLmxlbmd0aCYmKHRoaXMuX3NwYWNlVG9rZW49dCkpfX0se2tleTpcInNldFRva2VuXCIsdmFsdWU6ZnVuY3Rpb24oZSl7ZSYmMDxlLmxlbmd0aCYmdGhpcy5fc2V0VG9rZW4oZSl9fSx7a2V5Olwic2V0VG9rZW5zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcztlJiZlLmxlbmd0aCYmXCJvYmplY3RcIj09PWkoZSkmJmUuZm9yRWFjaChmdW5jdGlvbihlKXt0LnNldFRva2VuKGUpfSl9fSx7a2V5OlwiZ2V0VG9rZW5zXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPXt1c2Vyczp7fSxzcGFjZXM6e319O3JldHVybiBlPyhlLnVzZXImJihuLnVzZXI9dGhpcy5fdXNlclRva2VuKSxlLnNwYWNlJiYobi5zcGFjZT10aGlzLl9zcGFjZVRva2VuKSxlLnVzZXJzJiZlLnVzZXJzLmZvckVhY2goZnVuY3Rpb24oZSl7bi51c2Vyc1tlXT10Ll91c2VyVG9rZW5zW2VdfSksZS5zcGFjZSYmZS5zcGFjZXMuZm9yRWFjaChmdW5jdGlvbihlKXtuLnNwYWNlc1tlXT10Ll9zcGFjZVRva2Vuc1tlXX0pKToodGhpcy5fdXNlclRva2VuJiYobi51c2VyPXRoaXMuX3VzZXJUb2tlbiksdGhpcy5fc3BhY2VUb2tlbiYmKG4uc3BhY2U9dGhpcy5fc3BhY2VUb2tlbiksT2JqZWN0LmtleXModGhpcy5fdXNlclRva2VucykuZm9yRWFjaChmdW5jdGlvbihlKXtuLnVzZXJzW2VdPXQuX3VzZXJUb2tlbnNbZV19KSxPYmplY3Qua2V5cyh0aGlzLl9zcGFjZVRva2VucykuZm9yRWFjaChmdW5jdGlvbihlKXtuLnNwYWNlc1tlXT10Ll9zcGFjZVRva2Vuc1tlXX0pKSxufX0se2tleTpcImdldFRva2VuXCIsdmFsdWU6ZnVuY3Rpb24oZSx0KXt2YXIgbjtyZXR1cm4gdD9cInVzZXJcIj09PWU/bj10aGlzLl91c2VyVG9rZW5zW3RdOlwic3BhY2VcIj09PWUmJihuPXRoaXMuX3NwYWNlVG9rZW5zW3RdKTpcInVzZXJcIj09PWU/bj10aGlzLl91c2VyVG9rZW46XCJzcGFjZVwiPT09ZSYmKG49dGhpcy5fc3BhY2VUb2tlbiksbn19LHtrZXk6XCJleHRyYWN0UGVybWlzc2lvbnNcIix2YWx1ZTpmdW5jdGlvbihlKXt2YXIgdD17Y3JlYXRlOiExLHJlYWQ6ITEsd3JpdGU6ITEsbWFuYWdlOiExLGRlbGV0ZTohMX07cmV0dXJuIDE2PT0oMTYmZSkmJih0LmNyZWF0ZT0hMCksOD09KDgmZSkmJih0LmRlbGV0ZT0hMCksND09KDQmZSkmJih0Lm1hbmFnZT0hMCksMj09KDImZSkmJih0LndyaXRlPSEwKSwxPT0oMSZlKSYmKHQucmVhZD0hMCksdH19LHtrZXk6XCJwYXJzZVRva2VuXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxuPXRoaXMuX2Nib3IuZGVjb2RlVG9rZW4oZSk7aWYodm9pZCAwIT09bil7dmFyIHI9T2JqZWN0LmtleXMobi5yZXMudXNyKSxpPU9iamVjdC5rZXlzKG4ucmVzLnNwYyksbz1PYmplY3Qua2V5cyhuLnBhdC51c3IpLHM9T2JqZWN0LmtleXMobi5wYXQuc3BjKSxhPXt2ZXJzaW9uOm4udix0aW1lc3RhbXA6bi50LHR0bDpuLnR0bH0sdT0wPHIubGVuZ3RoLGM9MDxpLmxlbmd0aDsodXx8YykmJihhLnJlc291cmNlcz17fSx1JiYoYS5yZXNvdXJjZXMudXNlcnM9e30sci5mb3JFYWNoKGZ1bmN0aW9uKGUpe2EucmVzb3VyY2VzLnVzZXJzW2VdPXQuZXh0cmFjdFBlcm1pc3Npb25zKG4ucmVzLnVzcltlXSl9KSksYyYmKGEucmVzb3VyY2VzLnNwYWNlcz17fSxpLmZvckVhY2goZnVuY3Rpb24oZSl7YS5yZXNvdXJjZXMuc3BhY2VzW2VdPXQuZXh0cmFjdFBlcm1pc3Npb25zKG4ucmVzLnNwY1tlXSl9KSkpO3ZhciBmPTA8by5sZW5ndGgsbD0wPHMubGVuZ3RoO3JldHVybihmfHxsKSYmKGEucGF0dGVybnM9e30sZiYmKGEucGF0dGVybnMudXNlcnM9e30sby5mb3JFYWNoKGZ1bmN0aW9uKGUpe2EucGF0dGVybnMudXNlcnNbZV09dC5leHRyYWN0UGVybWlzc2lvbnMobi5wYXQudXNyW2VdKX0pKSxsJiYoYS5wYXR0ZXJucy5zcGFjZXM9e30scy5mb3JFYWNoKGZ1bmN0aW9uKGUpe2EucGF0dGVybnMuc3BhY2VzW2VdPXQuZXh0cmFjdFBlcm1pc3Npb25zKG4ucGF0LnNwY1tlXSl9KSkpLDA8T2JqZWN0LmtleXMobi5tZXRhKS5sZW5ndGgmJihhLm1ldGE9bi5tZXRhKSxhLnNpZ25hdHVyZT1uLnNpZyxhfX19LHtrZXk6XCJjbGVhclRva2Vuc1wiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5faW5pdGlhbGl6ZVRva2VucygpfX1dKSYmbyhhLnByb3RvdHlwZSx1KSx2b2lkKGMmJm8oYSxjKSksbCk7ZnVuY3Rpb24gbChlLHQpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbCkscyh0aGlzLFwiX2NvbmZpZ1wiLHZvaWQgMCkscyh0aGlzLFwiX2Nib3JcIix2b2lkIDApLHModGhpcyxcIl91c2VyVG9rZW5zXCIsdm9pZCAwKSxzKHRoaXMsXCJfc3BhY2VUb2tlbnNcIix2b2lkIDApLHModGhpcyxcIl91c2VyVG9rZW5cIix2b2lkIDApLHModGhpcyxcIl9zcGFjZVRva2VuXCIsdm9pZCAwKSx0aGlzLl9jb25maWc9ZSx0aGlzLl9jYm9yPXQsdGhpcy5faW5pdGlhbGl6ZVRva2VucygpfXQuZGVmYXVsdD1mLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9ZnVuY3Rpb24ocixpKXt2YXIgZT1yLm5ldHdvcmtpbmcsdD1yLmNvbmZpZyxvPW51bGwscz1udWxsLGE9e307bz1pLmdldE9wZXJhdGlvbigpPT09Yi5kZWZhdWx0LlBOVGltZU9wZXJhdGlvbnx8aS5nZXRPcGVyYXRpb24oKT09PWIuZGVmYXVsdC5QTkNoYW5uZWxHcm91cHNPcGVyYXRpb24/YXJndW1lbnRzLmxlbmd0aDw9Mj92b2lkIDA6YXJndW1lbnRzWzJdOihhPWFyZ3VtZW50cy5sZW5ndGg8PTI/dm9pZCAwOmFyZ3VtZW50c1syXSxhcmd1bWVudHMubGVuZ3RoPD0zP3ZvaWQgMDphcmd1bWVudHNbM10pO1widW5kZWZpbmVkXCI9PXR5cGVvZiBQcm9taXNlfHxvfHwocz12LmRlZmF1bHQuY3JlYXRlUHJvbWlzZSgpKTt2YXIgbj1pLnZhbGlkYXRlUGFyYW1zKHIsYSk7aWYobilyZXR1cm4gbz9vKF8obikpOnM/KHMucmVqZWN0KG5ldyBtKFwiVmFsaWRhdGlvbiBmYWlsZWQsIGNoZWNrIHN0YXR1cyBmb3IgZGV0YWlsc1wiLF8obikpKSxzLnByb21pc2UpOnZvaWQgMDt2YXIgdSxjPWkucHJlcGFyZVBhcmFtcyhyLGEpLGY9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlLnVzZVBvc3QmJmUudXNlUG9zdCh0LG4pP2UucG9zdFVSTCh0LG4pOmUudXNlUGF0Y2gmJmUudXNlUGF0Y2godCxuKT9lLnBhdGNoVVJMKHQsbik6ZS5nZXRVUkwodCxuKX0oaSxyLGEpLGw9e3VybDpmLG9wZXJhdGlvbjppLmdldE9wZXJhdGlvbigpLHRpbWVvdXQ6aS5nZXRSZXF1ZXN0VGltZW91dChyKSxoZWFkZXJzOmkuZ2V0UmVxdWVzdEhlYWRlcnM/aS5nZXRSZXF1ZXN0SGVhZGVycygpOnt9fTtjLnV1aWQ9dC5VVUlELGMucG5zZGs9ZnVuY3Rpb24oZSl7aWYoZS5zZGtOYW1lKXJldHVybiBlLnNka05hbWU7dmFyIHQ9XCJQdWJOdWItSlMtXCIuY29uY2F0KGUuc2RrRmFtaWx5KTtlLnBhcnRuZXJJZCYmKHQrPVwiLVwiLmNvbmNhdChlLnBhcnRuZXJJZCkpO3QrPVwiL1wiLmNvbmNhdChlLmdldFZlcnNpb24oKSk7dmFyIG49ZS5fZ2V0UG5zZGtTdWZmaXgoXCIgXCIpOzA8bi5sZW5ndGgmJih0Kz1uKTtyZXR1cm4gdH0odCksdC51c2VJbnN0YW5jZUlkJiYoYy5pbnN0YW5jZWlkPXQuaW5zdGFuY2VJZCk7dC51c2VSZXF1ZXN0SWQmJihjLnJlcXVlc3RpZD15LmRlZmF1bHQuY3JlYXRlVVVJRCgpKTtpZihpLmlzQXV0aFN1cHBvcnRlZCgpKXt2YXIgaD1mdW5jdGlvbihlLHQsbil7dmFyIHI7ZS5nZXRBdXRoVG9rZW4mJihyPWUuZ2V0QXV0aFRva2VuKHQsbikpO3JldHVybiByfShpLHIsYSl8fHQuZ2V0QXV0aEtleSgpO2gmJihjLmF1dGg9aCl9dC5zZWNyZXRLZXkmJmZ1bmN0aW9uKGUsdCxuLHIsaSl7dmFyIG89ZS5jb25maWcscz1lLmNyeXB0byxhPWsoZSxpLHIpO24udGltZXN0YW1wPU1hdGguZmxvb3IoKG5ldyBEYXRlKS5nZXRUaW1lKCkvMWUzKTt2YXIgdT1cIlwiLmNvbmNhdChhLFwiXFxuXCIpLmNvbmNhdChvLnB1Ymxpc2hLZXksXCJcXG5cIikuY29uY2F0KHQsXCJcXG5cIikuY29uY2F0KHYuZGVmYXVsdC5zaWduUGFtRnJvbVBhcmFtcyhuKSxcIlxcblwiKTtpZihcIlBPU1RcIj09PWEpe3ZhciBjPWkucG9zdFBheWxvYWQoZSxyKTt1Kz1cInN0cmluZ1wiPT10eXBlb2YgYz9jOkpTT04uc3RyaW5naWZ5KGMpfWVsc2UgaWYoXCJQQVRDSFwiPT09YSl7dmFyIGY9aS5wYXRjaFBheWxvYWQoZSxyKTt1Kz1cInN0cmluZ1wiPT10eXBlb2YgZj9mOkpTT04uc3RyaW5naWZ5KGYpfXZhciBsPVwidjIuXCIuY29uY2F0KHMuSE1BQ1NIQTI1Nih1KSk7bD0obD0obD1sLnJlcGxhY2UoL1xcKy9nLFwiLVwiKSkucmVwbGFjZSgvXFwvL2csXCJfXCIpKS5yZXBsYWNlKC89KyQvLFwiXCIpLG4uc2lnbmF0dXJlPWx9KHIsZixjLGEsaSk7ZnVuY3Rpb24gcChlLHQpe2lmKGUuZXJyb3Ipbz9vKGUpOnMmJnMucmVqZWN0KG5ldyBtKFwiUHViTnViIGNhbGwgZmFpbGVkLCBjaGVjayBzdGF0dXMgZm9yIGRldGFpbHNcIixlKSk7ZWxzZXt2YXIgbj1pLmhhbmRsZVJlc3BvbnNlKHIsdCxhKTtvP28oZSxuKTpzJiZzLmZ1bGZpbGwobil9fWlmKFwiUE9TVFwiPT09ayhyLGksYSkpe3ZhciBkPWkucG9zdFBheWxvYWQocixhKTt1PWUuUE9TVChjLGQsbCxwKX1lbHNlIGlmKFwiUEFUQ0hcIj09PWsocixpLGEpKXt2YXIgZz1pLnBhdGNoUGF5bG9hZChyLGEpO3U9ZS5QQVRDSChjLGcsbCxwKX1lbHNlIHU9XCJERUxFVEVcIj09PWsocixpLGEpP2UuREVMRVRFKGMsbCxwKTplLkdFVChjLGwscCk7aWYoaS5nZXRPcGVyYXRpb24oKT09PWIuZGVmYXVsdC5QTlN1YnNjcmliZU9wZXJhdGlvbilyZXR1cm4gdTtpZihzKXJldHVybiBzLnByb21pc2V9O3ZhciB5PXIobig1KSksdj0obigwKSxyKG4oMikpKSxiPShyKG4oMykpLHIobigxKSkpO2Z1bmN0aW9uIHIoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIGkoZSl7cmV0dXJuKGk9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIG8oZSx0KXtyZXR1cm4hdHx8XCJvYmplY3RcIiE9PWkodCkmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIHQ/ZnVuY3Rpb24oZSl7aWYodm9pZCAwIT09ZSlyZXR1cm4gZTt0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIil9KGUpOnR9ZnVuY3Rpb24gcyhlKXt2YXIgbj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuKHM9ZnVuY3Rpb24oZSl7aWYobnVsbD09PWV8fCFmdW5jdGlvbihlKXtyZXR1cm4tMSE9PUZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZSkuaW5kZXhPZihcIltuYXRpdmUgY29kZV1cIil9KGUpKXJldHVybiBlO2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO2lmKHZvaWQgMCE9PW4pe2lmKG4uaGFzKGUpKXJldHVybiBuLmdldChlKTtuLnNldChlLHQpfWZ1bmN0aW9uIHQoKXtyZXR1cm4gYShlLGFyZ3VtZW50cyxjKHRoaXMpLmNvbnN0cnVjdG9yKX1yZXR1cm4gdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdSh0LGUpfSkoZSl9ZnVuY3Rpb24gYShlLHQsbil7cmV0dXJuKGE9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiPT10eXBlb2YgUmVmbGVjdHx8IVJlZmxlY3QuY29uc3RydWN0KXJldHVybiExO2lmKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgUHJveHkpcmV0dXJuITA7dHJ5e3JldHVybiBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsW10sZnVuY3Rpb24oKXt9KSksITB9Y2F0Y2goZSl7cmV0dXJuITF9fSgpP1JlZmxlY3QuY29uc3RydWN0OmZ1bmN0aW9uKGUsdCxuKXt2YXIgcj1bbnVsbF07ci5wdXNoLmFwcGx5KHIsdCk7dmFyIGk9bmV3KEZ1bmN0aW9uLmJpbmQuYXBwbHkoZSxyKSk7cmV0dXJuIG4mJnUoaSxuLnByb3RvdHlwZSksaX0pLmFwcGx5KG51bGwsYXJndW1lbnRzKX1mdW5jdGlvbiB1KGUsdCl7cmV0dXJuKHU9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbihlLHQpe3JldHVybiBlLl9fcHJvdG9fXz10LGV9KShlLHQpfWZ1bmN0aW9uIGMoZSl7cmV0dXJuKGM9T2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5nZXRQcm90b3R5cGVPZjpmdW5jdGlvbihlKXtyZXR1cm4gZS5fX3Byb3RvX198fE9iamVjdC5nZXRQcm90b3R5cGVPZihlKX0pKGUpfXZhciBtPShmdW5jdGlvbihlLHQpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJm51bGwhPT10KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtlLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQmJnQucHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6ZSx3cml0YWJsZTohMCxjb25maWd1cmFibGU6ITB9fSksdCYmdShlLHQpfShmLHMoRXJyb3IpKSxmKTtmdW5jdGlvbiBmKGUsdCl7dmFyIG47cmV0dXJuIGZ1bmN0aW9uKGUsdCl7aWYoIShlIGluc3RhbmNlb2YgdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyxmKSwobj1vKHRoaXMsYyhmKS5jYWxsKHRoaXMsZSkpKS5uYW1lPW4uY29uc3RydWN0b3IubmFtZSxuLnN0YXR1cz10LG4ubWVzc2FnZT1lLG59ZnVuY3Rpb24gXyhlKXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50eXBlPXQsZS5lcnJvcj0hMCxlfSh7bWVzc2FnZTplfSxcInZhbGlkYXRpb25FcnJvclwiKX1mdW5jdGlvbiBrKGUsdCxuKXtyZXR1cm4gdC51c2VQb3N0JiZ0LnVzZVBvc3QoZSxuKT9cIlBPU1RcIjp0LnVzZVBhdGNoJiZ0LnVzZVBhdGNoKGUsbik/XCJQQVRDSFwiOnQudXNlRGVsZXRlJiZ0LnVzZURlbGV0ZShlLG4pP1wiREVMRVRFXCI6XCJHRVRcIn1lLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LlBOQWRkQ2hhbm5lbHNUb0dyb3VwT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVscyxyPXQuY2hhbm5lbEdyb3VwLGk9ZS5jb25maWc7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIENoYW5uZWwgR3JvdXBcIjtpZighbnx8MD09PW4ubGVuZ3RoKXJldHVyblwiTWlzc2luZyBDaGFubmVsc1wiO2lmKCFpLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwLHI9ZS5jb25maWc7cmV0dXJuXCIvdjEvY2hhbm5lbC1yZWdpc3RyYXRpb24vc3ViLWtleS9cIi5jb25jYXQoci5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC1ncm91cC9cIikuY29uY2F0KGkuZGVmYXVsdC5lbmNvZGVTdHJpbmcobikpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVscztyZXR1cm57YWRkOih2b2lkIDA9PT1uP1tdOm4pLmpvaW4oXCIsXCIpfX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbigpe3JldHVybnt9fTtuKDApO3ZhciByPW8obigxKSksaT1vKG4oMikpO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTlJlbW92ZUNoYW5uZWxzRnJvbUdyb3VwT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVscyxyPXQuY2hhbm5lbEdyb3VwLGk9ZS5jb25maWc7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIENoYW5uZWwgR3JvdXBcIjtpZighbnx8MD09PW4ubGVuZ3RoKXJldHVyblwiTWlzc2luZyBDaGFubmVsc1wiO2lmKCFpLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwLHI9ZS5jb25maWc7cmV0dXJuXCIvdjEvY2hhbm5lbC1yZWdpc3RyYXRpb24vc3ViLWtleS9cIi5jb25jYXQoci5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC1ncm91cC9cIikuY29uY2F0KGkuZGVmYXVsdC5lbmNvZGVTdHJpbmcobikpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVscztyZXR1cm57cmVtb3ZlOih2b2lkIDA9PT1uP1tdOm4pLmpvaW4oXCIsXCIpfX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbigpe3JldHVybnt9fTtuKDApO3ZhciByPW8obigxKSksaT1vKG4oMikpO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTlJlbW92ZUdyb3VwT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsR3JvdXAscj1lLmNvbmZpZztpZighbilyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbCBHcm91cFwiO2lmKCFyLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwLHI9ZS5jb25maWc7cmV0dXJuXCIvdjEvY2hhbm5lbC1yZWdpc3RyYXRpb24vc3ViLWtleS9cIi5jb25jYXQoci5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC1ncm91cC9cIikuY29uY2F0KGkuZGVmYXVsdC5lbmNvZGVTdHJpbmcobiksXCIvcmVtb3ZlXCIpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJue319LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcj1vKG4oMSkpLGk9byhuKDIpKTtmdW5jdGlvbiBvKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5DaGFubmVsR3JvdXBzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWc7cmV0dXJuXCIvdjEvY2hhbm5lbC1yZWdpc3RyYXRpb24vc3ViLWtleS9cIi5jb25jYXQodC5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC1ncm91cFwiKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJue2dyb3Vwczp0LnBheWxvYWQuZ3JvdXBzfX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkNoYW5uZWxzRm9yR3JvdXBPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cCxyPWUuY29uZmlnO2lmKCFuKXJldHVyblwiTWlzc2luZyBDaGFubmVsIEdyb3VwXCI7aWYoIXIuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsR3JvdXAscj1lLmNvbmZpZztyZXR1cm5cIi92MS9jaGFubmVsLXJlZ2lzdHJhdGlvbi9zdWIta2V5L1wiLmNvbmNhdChyLnN1YnNjcmliZUtleSxcIi9jaGFubmVsLWdyb3VwL1wiKS5jb25jYXQoaS5kZWZhdWx0LmVuY29kZVN0cmluZyhuKSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybntjaGFubmVsczp0LnBheWxvYWQuY2hhbm5lbHN9fTtuKDApO3ZhciByPW8obigxKSksaT1vKG4oMikpO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlB1c2hOb3RpZmljYXRpb25FbmFibGVkQ2hhbm5lbHNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT10LmNoYW5uZWxzLG89dC50b3BpYyxzPWUuY29uZmlnO2lmKCFuKXJldHVyblwiTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZSlcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgR1cgVHlwZSAocHVzaEdhdGV3YXk6IGdjbSwgYXBucyBvciBhcG5zMilcIjtpZihcImFwbnMyXCI9PT1yJiYhbylyZXR1cm5cIk1pc3NpbmcgQVBOUzIgdG9waWNcIjtpZighaXx8MD09PWkubGVuZ3RoKXJldHVyblwiTWlzc2luZyBDaGFubmVsc1wiO2lmKCFzLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuZGV2aWNlLHI9dC5wdXNoR2F0ZXdheSxpPWUuY29uZmlnO3JldHVyblwiYXBuczJcIiE9PXI/XCIvdjEvcHVzaC9zdWIta2V5L1wiLmNvbmNhdChpLnN1YnNjcmliZUtleSxcIi9kZXZpY2VzL1wiKS5jb25jYXQobik6XCIvdjIvcHVzaC9zdWIta2V5L1wiLmNvbmNhdChpLnN1YnNjcmliZUtleSxcIi9kZXZpY2VzLWFwbnMyL1wiKS5jb25jYXQobil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnB1c2hHYXRld2F5LHI9dC5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPXQuZW52aXJvbm1lbnQscz12b2lkIDA9PT1vP1wiZGV2ZWxvcG1lbnRcIjpvLGE9dC50b3BpYyx1PXt0eXBlOm4sYWRkOmkuam9pbihcIixcIil9O1wiYXBuczJcIj09PW4mJmRlbGV0ZSh1PU9iamVjdC5hc3NpZ24oe30sdSx7ZW52aXJvbm1lbnQ6cyx0b3BpYzphfSkpLnR5cGU7cmV0dXJuIHV9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlB1c2hOb3RpZmljYXRpb25FbmFibGVkQ2hhbm5lbHNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT10LmNoYW5uZWxzLG89dC50b3BpYyxzPWUuY29uZmlnO2lmKCFuKXJldHVyblwiTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZSlcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgR1cgVHlwZSAocHVzaEdhdGV3YXk6IGdjbSwgYXBucyBvciBhcG5zMilcIjtpZihcImFwbnMyXCI9PT1yJiYhbylyZXR1cm5cIk1pc3NpbmcgQVBOUzIgdG9waWNcIjtpZighaXx8MD09PWkubGVuZ3RoKXJldHVyblwiTWlzc2luZyBDaGFubmVsc1wiO2lmKCFzLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuZGV2aWNlLHI9dC5wdXNoR2F0ZXdheSxpPWUuY29uZmlnO3JldHVyblwiYXBuczJcIiE9PXI/XCIvdjEvcHVzaC9zdWIta2V5L1wiLmNvbmNhdChpLnN1YnNjcmliZUtleSxcIi9kZXZpY2VzL1wiKS5jb25jYXQobik6XCIvdjIvcHVzaC9zdWIta2V5L1wiLmNvbmNhdChpLnN1YnNjcmliZUtleSxcIi9kZXZpY2VzLWFwbnMyL1wiKS5jb25jYXQobil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnB1c2hHYXRld2F5LHI9dC5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPXQuZW52aXJvbm1lbnQscz12b2lkIDA9PT1vP1wiZGV2ZWxvcG1lbnRcIjpvLGE9dC50b3BpYyx1PXt0eXBlOm4scmVtb3ZlOmkuam9pbihcIixcIil9O1wiYXBuczJcIj09PW4mJmRlbGV0ZSh1PU9iamVjdC5hc3NpZ24oe30sdSx7ZW52aXJvbm1lbnQ6cyx0b3BpYzphfSkpLnR5cGU7cmV0dXJuIHV9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlB1c2hOb3RpZmljYXRpb25FbmFibGVkQ2hhbm5lbHNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT10LnRvcGljLG89ZS5jb25maWc7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIERldmljZSBJRCAoZGV2aWNlKVwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBHVyBUeXBlIChwdXNoR2F0ZXdheTogZ2NtLCBhcG5zIG9yIGFwbnMyKVwiO2lmKFwiYXBuczJcIj09PXImJiFpKXJldHVyblwiTWlzc2luZyBBUE5TMiB0b3BpY1wiO2lmKCFvLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuZGV2aWNlLHI9dC5wdXNoR2F0ZXdheSxpPWUuY29uZmlnO3JldHVyblwiYXBuczJcIiE9PXI/XCIvdjEvcHVzaC9zdWIta2V5L1wiLmNvbmNhdChpLnN1YnNjcmliZUtleSxcIi9kZXZpY2VzL1wiKS5jb25jYXQobik6XCIvdjIvcHVzaC9zdWIta2V5L1wiLmNvbmNhdChpLnN1YnNjcmliZUtleSxcIi9kZXZpY2VzLWFwbnMyL1wiKS5jb25jYXQobil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnB1c2hHYXRld2F5LHI9dC5lbnZpcm9ubWVudCxpPXZvaWQgMD09PXI/XCJkZXZlbG9wbWVudFwiOnIsbz10LnRvcGljLHM9e3R5cGU6bn07XCJhcG5zMlwiPT09biYmZGVsZXRlKHM9T2JqZWN0LmFzc2lnbih7fSxzLHtlbnZpcm9ubWVudDppLHRvcGljOm99KSkudHlwZTtyZXR1cm4gc30sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybntjaGFubmVsczp0fX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTlJlbW92ZUFsbFB1c2hOb3RpZmljYXRpb25zT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5kZXZpY2Uscj10LnB1c2hHYXRld2F5LGk9dC50b3BpYyxvPWUuY29uZmlnO2lmKCFuKXJldHVyblwiTWlzc2luZyBEZXZpY2UgSUQgKGRldmljZSlcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgR1cgVHlwZSAocHVzaEdhdGV3YXk6IGdjbSwgYXBucyBvciBhcG5zMilcIjtpZihcImFwbnMyXCI9PT1yJiYhaSlyZXR1cm5cIk1pc3NpbmcgQVBOUzIgdG9waWNcIjtpZighby5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmRldmljZSxyPXQucHVzaEdhdGV3YXksaT1lLmNvbmZpZztyZXR1cm5cImFwbnMyXCIhPT1yP1wiL3YxL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy9cIikuY29uY2F0KG4sXCIvcmVtb3ZlXCIpOlwiL3YyL3B1c2gvc3ViLWtleS9cIi5jb25jYXQoaS5zdWJzY3JpYmVLZXksXCIvZGV2aWNlcy1hcG5zMi9cIikuY29uY2F0KG4sXCIvcmVtb3ZlXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5wdXNoR2F0ZXdheSxyPXQuZW52aXJvbm1lbnQsaT12b2lkIDA9PT1yP1wiZGV2ZWxvcG1lbnRcIjpyLG89dC50b3BpYyxzPXt0eXBlOm59O1wiYXBuczJcIj09PW4mJmRlbGV0ZShzPU9iamVjdC5hc3NpZ24oe30scyx7ZW52aXJvbm1lbnQ6aSx0b3BpYzpvfSkpLnR5cGU7cmV0dXJuIHN9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTlVuc3Vic2NyaWJlT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz0wPGkubGVuZ3RoP2kuam9pbihcIixcIik6XCIsXCI7cmV0dXJuXCIvdjIvcHJlc2VuY2Uvc3ViLWtleS9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC9cIikuY29uY2F0KHMuZGVmYXVsdC5lbmNvZGVTdHJpbmcobyksXCIvbGVhdmVcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cHMscj12b2lkIDA9PT1uP1tdOm4saT17fTswPHIubGVuZ3RoJiYoaVtcImNoYW5uZWwtZ3JvdXBcIl09ci5qb2luKFwiLFwiKSk7cmV0dXJuIGl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcj1pKG4oMSkpLHM9aShuKDIpKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5XaGVyZU5vd09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlKXtpZighZS5jb25maWcuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LnV1aWQsaT12b2lkIDA9PT1yP24uVVVJRDpyO3JldHVyblwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3V1aWQvXCIpLmNvbmNhdChpKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQucGF5bG9hZD97Y2hhbm5lbHM6dC5wYXlsb2FkLmNoYW5uZWxzfTp7Y2hhbm5lbHM6W119fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LlBOSGVhcnRiZWF0T3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbHMsaT12b2lkIDA9PT1yP1tdOnIsbz0wPGkubGVuZ3RoP2kuam9pbihcIixcIik6XCIsXCI7cmV0dXJuXCIvdjIvcHJlc2VuY2Uvc3ViLWtleS9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC9cIikuY29uY2F0KHMuZGVmYXVsdC5lbmNvZGVTdHJpbmcobyksXCIvaGVhcnRiZWF0XCIpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsR3JvdXBzLHI9dm9pZCAwPT09bj9bXTpuLGk9dC5zdGF0ZSxvPXZvaWQgMD09PWk/e306aSxzPWUuY29uZmlnLGE9e307MDxyLmxlbmd0aCYmKGFbXCJjaGFubmVsLWdyb3VwXCJdPXIuam9pbihcIixcIikpO3JldHVybiBhLnN0YXRlPUpTT04uc3RyaW5naWZ5KG8pLGEuaGVhcnRiZWF0PXMuZ2V0UHJlc2VuY2VUaW1lb3V0KCksYX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbigpe3JldHVybnt9fTtuKDApO3ZhciByPWkobigxKSkscz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkdldFN0YXRlT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUpe2lmKCFlLmNvbmZpZy5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQudXVpZCxpPXZvaWQgMD09PXI/bi5VVUlEOnIsbz10LmNoYW5uZWxzLHM9dm9pZCAwPT09bz9bXTpvLGE9MDxzLmxlbmd0aD9zLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdCh1LmRlZmF1bHQuZW5jb2RlU3RyaW5nKGEpLFwiL3V1aWQvXCIpLmNvbmNhdChpKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbEdyb3VwcyxyPXZvaWQgMD09PW4/W106bixpPXt9OzA8ci5sZW5ndGgmJihpW1wiY2hhbm5lbC1ncm91cFwiXT1yLmpvaW4oXCIsXCIpKTtyZXR1cm4gaX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQsbil7dmFyIHI9bi5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPW4uY2hhbm5lbEdyb3VwcyxzPXZvaWQgMD09PW8/W106byxhPXt9OzE9PT1pLmxlbmd0aCYmMD09PXMubGVuZ3RoP2FbaVswXV09dC5wYXlsb2FkOmE9dC5wYXlsb2FkO3JldHVybntjaGFubmVsczphfX07bigwKTt2YXIgcj1pKG4oMSkpLHU9aShuKDIpKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5TZXRTdGF0ZU9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5zdGF0ZSxpPXQuY2hhbm5lbHMsbz12b2lkIDA9PT1pP1tdOmkscz10LmNoYW5uZWxHcm91cHMsYT12b2lkIDA9PT1zP1tdOnM7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIFN0YXRlXCI7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCI7aWYoMD09PW8ubGVuZ3RoJiYwPT09YS5sZW5ndGgpcmV0dXJuXCJQbGVhc2UgcHJvdmlkZSBhIGxpc3Qgb2YgY2hhbm5lbHMgYW5kL29yIGNoYW5uZWwtZ3JvdXBzXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWxzLGk9dm9pZCAwPT09cj9bXTpyLG89MDxpLmxlbmd0aD9pLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChzLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG8pLFwiL3V1aWQvXCIpLmNvbmNhdChuLlVVSUQsXCIvZGF0YVwiKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc3RhdGUscj10LmNoYW5uZWxHcm91cHMsaT12b2lkIDA9PT1yP1tdOnIsbz17fTtvLnN0YXRlPUpTT04uc3RyaW5naWZ5KG4pLDA8aS5sZW5ndGgmJihvW1wiY2hhbm5lbC1ncm91cFwiXT1pLmpvaW4oXCIsXCIpKTtyZXR1cm4gb30sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybntzdGF0ZTp0LnBheWxvYWR9fTtuKDApO3ZhciByPWkobigxKSkscz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkhlcmVOb3dPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVscyxpPXZvaWQgMD09PXI/W106cixvPXQuY2hhbm5lbEdyb3VwcyxzPXZvaWQgMD09PW8/W106byxhPVwiL3YyL3ByZXNlbmNlL3N1Yi1rZXkvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5KTtpZigwPGkubGVuZ3RofHwwPHMubGVuZ3RoKXt2YXIgdT0wPGkubGVuZ3RoP2kuam9pbihcIixcIik6XCIsXCI7YSs9XCIvY2hhbm5lbC9cIi5jb25jYXQoYy5kZWZhdWx0LmVuY29kZVN0cmluZyh1KSl9cmV0dXJuIGF9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxHcm91cHMscj12b2lkIDA9PT1uP1tdOm4saT10LmluY2x1ZGVVVUlEcyxvPXZvaWQgMD09PWl8fGkscz10LmluY2x1ZGVTdGF0ZSxhPXZvaWQgMCE9PXMmJnMsdT17fTtvfHwodS5kaXNhYmxlX3V1aWRzPTEpO2EmJih1LnN0YXRlPTEpOzA8ci5sZW5ndGgmJih1W1wiY2hhbm5lbC1ncm91cFwiXT1yLmpvaW4oXCIsXCIpKTtyZXR1cm4gdX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLGksdCl7dmFyIG4scj10LmNoYW5uZWxzLG89dm9pZCAwPT09cj9bXTpyLHM9dC5jaGFubmVsR3JvdXBzLGE9dm9pZCAwPT09cz9bXTpzLHU9dC5pbmNsdWRlVVVJRHMsYz12b2lkIDA9PT11fHx1LGY9dC5pbmNsdWRlU3RhdGUsbD12b2lkIDAhPT1mJiZmO249MTxvLmxlbmd0aHx8MDxhLmxlbmd0aHx8MD09PWEubGVuZ3RoJiYwPT09by5sZW5ndGg/ZnVuY3Rpb24oKXt2YXIgcj17fTtyZXR1cm4gci50b3RhbENoYW5uZWxzPWkucGF5bG9hZC50b3RhbF9jaGFubmVscyxyLnRvdGFsT2NjdXBhbmN5PWkucGF5bG9hZC50b3RhbF9vY2N1cGFuY3ksci5jaGFubmVscz17fSxPYmplY3Qua2V5cyhpLnBheWxvYWQuY2hhbm5lbHMpLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9aS5wYXlsb2FkLmNoYW5uZWxzW2VdLG49W107cmV0dXJuIHIuY2hhbm5lbHNbZV09e29jY3VwYW50czpuLG5hbWU6ZSxvY2N1cGFuY3k6dC5vY2N1cGFuY3l9LGMmJnQudXVpZHMuZm9yRWFjaChmdW5jdGlvbihlKXtsP24ucHVzaCh7c3RhdGU6ZS5zdGF0ZSx1dWlkOmUudXVpZH0pOm4ucHVzaCh7c3RhdGU6bnVsbCx1dWlkOmV9KX0pLHJ9KSxyfSgpOmZ1bmN0aW9uKCl7dmFyIGU9e30sdD1bXTtyZXR1cm4gZS50b3RhbENoYW5uZWxzPTEsZS50b3RhbE9jY3VwYW5jeT1pLm9jY3VwYW5jeSxlLmNoYW5uZWxzPXt9LGUuY2hhbm5lbHNbb1swXV09e29jY3VwYW50czp0LG5hbWU6b1swXSxvY2N1cGFuY3k6aS5vY2N1cGFuY3l9LGMmJmkudXVpZHMmJmkudXVpZHMuZm9yRWFjaChmdW5jdGlvbihlKXtsP3QucHVzaCh7c3RhdGU6ZS5zdGF0ZSx1dWlkOmUudXVpZH0pOnQucHVzaCh7c3RhdGU6bnVsbCx1dWlkOmV9KX0pLGV9KCk7cmV0dXJuIG59O24oMCk7dmFyIHI9aShuKDEpKSxjPWkobigyKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOQWRkTWVzc2FnZUFjdGlvbk9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5hY3Rpb24saT10LmNoYW5uZWw7aWYoIXQubWVzc2FnZVRpbWV0b2tlbilyZXR1cm5cIk1pc3NpbmcgbWVzc2FnZSB0aW1ldG9rZW5cIjtpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZighaSlyZXR1cm5cIk1pc3NpbmcgbWVzc2FnZSBjaGFubmVsXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIEFjdGlvblwiO2lmKCFyLnZhbHVlKXJldHVyblwiTWlzc2luZyBBY3Rpb24udmFsdWVcIjtpZighci50eXBlKXJldHVyblwiTWlzc2luZyBBY3Rpb24udHlwZVwiO2lmKDE1PHIudHlwZS5sZW5ndGgpcmV0dXJuXCJBY3Rpb24udHlwZSB2YWx1ZSBleGNlZWQgbWF4aW11bSBsZW5ndGggb2YgMTVcIn0sdC51c2VQb3N0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucG9zdFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVsLGk9dC5tZXNzYWdlVGltZXRva2VuO3JldHVyblwiL3YxL21lc3NhZ2UtYWN0aW9ucy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC9cIikuY29uY2F0KHIsXCIvbWVzc2FnZS9cIikuY29uY2F0KGkpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5nZXRSZXF1ZXN0SGVhZGVycz1mdW5jdGlvbigpe3JldHVybntcIkNvbnRlbnQtVHlwZVwiOlwiYXBwbGljYXRpb24vanNvblwifX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJue319LHQucG9zdFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5hY3Rpb259LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57ZGF0YTp0LmRhdGF9fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOUmVtb3ZlTWVzc2FnZUFjdGlvbk9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVsLGk9dC5hY3Rpb25UaW1ldG9rZW47aWYoIXQubWVzc2FnZVRpbWV0b2tlbilyZXR1cm5cIk1pc3NpbmcgbWVzc2FnZSB0aW1ldG9rZW5cIjtpZighaSlyZXR1cm5cIk1pc3NpbmcgYWN0aW9uIHRpbWV0b2tlblwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBtZXNzYWdlIGNoYW5uZWxcIn0sdC51c2VEZWxldGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbCxpPXQuYWN0aW9uVGltZXRva2VuLG89dC5tZXNzYWdlVGltZXRva2VuO3JldHVyblwiL3YxL21lc3NhZ2UtYWN0aW9ucy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC9cIikuY29uY2F0KHIsXCIvbWVzc2FnZS9cIikuY29uY2F0KG8sXCIvYWN0aW9uL1wiKS5jb25jYXQoaSl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybntkYXRhOnQuZGF0YX19O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5HZXRNZXNzYWdlQWN0aW9uc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVsO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBtZXNzYWdlIGNoYW5uZWxcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbDtyZXR1cm5cIi92MS9tZXNzYWdlLWFjdGlvbnMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChyKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQubGltaXQscj10LnN0YXJ0LGk9dC5lbmQsbz17fTtuJiYoby5saW1pdD1uKTtyJiYoby5zdGFydD1yKTtpJiYoby5lbmQ9aSk7cmV0dXJuIG99LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXt2YXIgbj17ZGF0YTp0LmRhdGEsc3RhcnQ6bnVsbCxlbmQ6bnVsbH07bi5kYXRhLmxlbmd0aCYmKG4uZW5kPW4uZGF0YVtuLmRhdGEubGVuZ3RoLTFdLmFjdGlvblRpbWV0b2tlbixuLnN0YXJ0PW4uZGF0YVswXS5hY3Rpb25UaW1ldG9rZW4pO3JldHVybiBufTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOQ3JlYXRlVXNlck9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5pZCxpPXQubmFtZSxvPXQuY3VzdG9tO2lmKCFyKXJldHVyblwiTWlzc2luZyBVc2VyLmlkXCI7aWYoIWkpcmV0dXJuXCJNaXNzaW5nIFVzZXIubmFtZVwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKG8mJiFPYmplY3QudmFsdWVzKG8pLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlfSkpcmV0dXJuXCJJbnZhbGlkIGN1c3RvbSB0eXBlLCBvbmx5IHN0cmluZywgbnVtYmVyIGFuZCBib29sZWFuIHZhbHVlcyBhcmUgYWxsb3dlZC5cIn0sdC51c2VQb3N0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5LFwiL3VzZXJzXCIpfSx0LnBvc3RVUkw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQodC5zdWJzY3JpYmVLZXksXCIvdXNlcnNcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIix0LmlkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj17fTtuP3ZvaWQgMD09PW4uY3VzdG9tRmllbGRzJiYobi5jdXN0b21GaWVsZHM9ITApOm49e2N1c3RvbUZpZWxkczohMH07aWYobil7dmFyIGk9W107bi5jdXN0b21GaWVsZHMmJmkucHVzaChcImN1c3RvbVwiKTt2YXIgbz1pLmpvaW4oXCIsXCIpOzA8by5sZW5ndGgmJihyLmluY2x1ZGU9byl9cmV0dXJuIHJ9LHQucG9zdFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH0oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlVXNlck9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5pZCxpPXQubmFtZSxvPXQuY3VzdG9tO2lmKCFyKXJldHVyblwiTWlzc2luZyBVc2VyLmlkXCI7aWYoIWkpcmV0dXJuXCJNaXNzaW5nIFVzZXIubmFtZVwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKG8mJiFPYmplY3QudmFsdWVzKG8pLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlfSkpcmV0dXJuXCJJbnZhbGlkIGN1c3RvbSB0eXBlLCBvbmx5IHN0cmluZywgbnVtYmVyIGFuZCBib29sZWFuIHZhbHVlcyBhcmUgYWxsb3dlZC5cIn0sdC51c2VQYXRjaD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5pZDtyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHIpfSx0LnBhdGNoVVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmlkO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3VzZXJzL1wiKS5jb25jYXQocil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIix0LmlkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj17fTtuP3ZvaWQgMD09PW4uY3VzdG9tRmllbGRzJiYobi5jdXN0b21GaWVsZHM9ITApOm49e2N1c3RvbUZpZWxkczohMH07aWYobil7dmFyIGk9W107bi5jdXN0b21GaWVsZHMmJmkucHVzaChcImN1c3RvbVwiKTt2YXIgbz1pLmpvaW4oXCIsXCIpOzA8by5sZW5ndGgmJihyLmluY2x1ZGU9byl9cmV0dXJuIHJ9LHQucGF0Y2hQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9KDAsdCl9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkRlbGV0ZVVzZXJPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztpZighdClyZXR1cm5cIk1pc3NpbmcgVXNlcklkXCI7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQudXNlRGVsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdCh0KX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiLHQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5HZXRVc2VyT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7aWYoIXQudXNlcklkKXJldHVyblwiTWlzc2luZyB1c2VySWRcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHQudXNlcklkKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiLHQudXNlcklkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj17fTtuP3ZvaWQgMD09PW4uY3VzdG9tRmllbGRzJiYobi5jdXN0b21GaWVsZHM9ITApOm49e2N1c3RvbUZpZWxkczohMH07aWYobil7dmFyIGk9W107bi5jdXN0b21GaWVsZHMmJmkucHVzaChcImN1c3RvbVwiKTt2YXIgbz1pLmpvaW4oXCIsXCIpOzA8by5sZW5ndGgmJihyLmluY2x1ZGU9byl9cmV0dXJuIHJ9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkdldFVzZXJzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKCl7fSx0LmdldFVSTD1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdCh0LnN1YnNjcmliZUtleSxcIi91c2Vyc1wiKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXQubGltaXQsaT10LnBhZ2Usbz17fTtyJiYoby5saW1pdD1yKTtpZihuKXt2YXIgcz1bXTtuLnRvdGFsQ291bnQmJihvLmNvdW50PSEwKSxuLmN1c3RvbUZpZWxkcyYmcy5wdXNoKFwiY3VzdG9tXCIpO3ZhciBhPXMuam9pbihcIixcIik7MDxhLmxlbmd0aCYmKG8uaW5jbHVkZT1hKX1pJiYoaS5uZXh0JiYoby5zdGFydD1pLm5leHQpLGkucHJldiYmKG8uZW5kPWkucHJldikpO3JldHVybiBvfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5DcmVhdGVTcGFjZU9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5pZCxpPXQubmFtZSxvPXQuY3VzdG9tO2lmKCFyKXJldHVyblwiTWlzc2luZyBTcGFjZS5pZFwiO2lmKCFpKXJldHVyblwiTWlzc2luZyBTcGFjZS5uYW1lXCI7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCI7aWYobyYmIU9iamVjdC52YWx1ZXMobykuZXZlcnkoZnVuY3Rpb24oZSl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlfHxcImJvb2xlYW5cIj09dHlwZW9mIGV9KSlyZXR1cm5cIkludmFsaWQgY3VzdG9tIHR5cGUsIG9ubHkgc3RyaW5nLCBudW1iZXIgYW5kIGJvb2xlYW4gdmFsdWVzIGFyZSBhbGxvd2VkLlwifSx0LnVzZVBvc3Q9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRVUkw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQodC5zdWJzY3JpYmVLZXksXCIvc3BhY2VzXCIpfSx0LnBvc3RVUkw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQodC5zdWJzY3JpYmVLZXksXCIvc3BhY2VzXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiLHQuaWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj17fTtuP3ZvaWQgMD09PW4uY3VzdG9tRmllbGRzJiYobi5jdXN0b21GaWVsZHM9ITApOm49e2N1c3RvbUZpZWxkczohMH07aWYobil7dmFyIGk9W107bi5jdXN0b21GaWVsZHMmJmkucHVzaChcImN1c3RvbVwiKTt2YXIgbz1pLmpvaW4oXCIsXCIpOzA8by5sZW5ndGgmJihyLmluY2x1ZGU9byl9cmV0dXJuIHJ9LHQucG9zdFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH0oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlU3BhY2VPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuaWQsaT10Lm5hbWUsbz10LmN1c3RvbTtpZighcilyZXR1cm5cIk1pc3NpbmcgU3BhY2UuaWRcIjtpZighaSlyZXR1cm5cIk1pc3NpbmcgU3BhY2UubmFtZVwiO2lmKCFuLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKG8mJiFPYmplY3QudmFsdWVzKG8pLmV2ZXJ5KGZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZXx8XCJib29sZWFuXCI9PXR5cGVvZiBlfSkpcmV0dXJuXCJJbnZhbGlkIGN1c3RvbSB0eXBlLCBvbmx5IHN0cmluZywgbnVtYmVyIGFuZCBib29sZWFuIHZhbHVlcyBhcmUgYWxsb3dlZC5cIn0sdC51c2VQYXRjaD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5pZDtyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdChyKX0sdC5wYXRjaFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5pZDtyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdChyKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIix0LmlkKXx8ZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9e307bj92b2lkIDA9PT1uLmN1c3RvbUZpZWxkcyYmKG4uY3VzdG9tRmllbGRzPSEwKTpuPXtjdXN0b21GaWVsZHM6ITB9O2lmKG4pe3ZhciBpPVtdO24uY3VzdG9tRmllbGRzJiZpLnB1c2goXCJjdXN0b21cIik7dmFyIG89aS5qb2luKFwiLFwiKTswPG8ubGVuZ3RoJiYoci5pbmNsdWRlPW8pfXJldHVybiByfSx0LnBhdGNoUGF5bG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3JldHVybiB0fSgwLHQpfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5EZWxldGVTcGFjZU9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO2lmKCF0KXJldHVyblwiTWlzc2luZyBTcGFjZUlkXCI7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQudXNlRGVsZXRlPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQodCl9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIsdCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbigpe3JldHVybnt9fSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5HZXRTcGFjZXNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oKXt9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5LFwiL3NwYWNlc1wiKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj10LmxpbWl0LGk9dC5wYWdlLG89e307ciYmKG8ubGltaXQ9cik7aWYobil7dmFyIHM9W107bi50b3RhbENvdW50JiYoby5jb3VudD0hMCksbi5jdXN0b21GaWVsZHMmJnMucHVzaChcImN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOR2V0U3BhY2VPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXtpZighdC5zcGFjZUlkKXJldHVyblwiTWlzc2luZyBzcGFjZUlkXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQodC5zcGFjZUlkKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIix0LnNwYWNlSWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj17fTtuP3ZvaWQgMD09PW4uY3VzdG9tRmllbGRzJiYobi5jdXN0b21GaWVsZHM9ITApOm49e2N1c3RvbUZpZWxkczohMH07aWYobil7dmFyIGk9W107bi5jdXN0b21GaWVsZHMmJmkucHVzaChcImN1c3RvbVwiKTt2YXIgbz1pLmpvaW4oXCIsXCIpOzA8by5sZW5ndGgmJihyLmluY2x1ZGU9byl9cmV0dXJuIHJ9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdH07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkdldE1lbWJlcnNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXtpZighdC5zcGFjZUlkKXJldHVyblwiTWlzc2luZyBzcGFjZUlkXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvc3BhY2VzL1wiKS5jb25jYXQodC5zcGFjZUlkLFwiL3VzZXJzXCIpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiLHQuc3BhY2VJZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXQubGltaXQsaT10LnBhZ2Usbz17fTtyJiYoby5saW1pdD1yKTtpZihuKXt2YXIgcz1bXTtuLnRvdGFsQ291bnQmJihvLmNvdW50PSEwKSxuLmN1c3RvbUZpZWxkcyYmcy5wdXNoKFwiY3VzdG9tXCIpLG4udXNlckZpZWxkcyYmcy5wdXNoKFwidXNlclwiKSxuLmN1c3RvbVVzZXJGaWVsZHMmJnMucHVzaChcInVzZXIuY3VzdG9tXCIpO3ZhciBhPXMuam9pbihcIixcIik7MDxhLmxlbmd0aCYmKG8uaW5jbHVkZT1hKX1pJiYoaS5uZXh0JiYoby5zdGFydD1pLm5leHQpLGkucHJldiYmKG8uZW5kPWkucHJldikpO3JldHVybiBvfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5VcGRhdGVNZW1iZXJzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5zcGFjZUlkLHI9dC51c2VycztpZighbilyZXR1cm5cIk1pc3Npbmcgc3BhY2VJZFwiO2lmKCFyKXJldHVyblwiTWlzc2luZyB1c2Vyc1wifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3NwYWNlcy9cIikuY29uY2F0KHQuc3BhY2VJZCxcIi91c2Vyc1wiKX0sdC5wYXRjaFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3NwYWNlcy9cIikuY29uY2F0KHQuc3BhY2VJZCxcIi91c2Vyc1wiKX0sdC51c2VQYXRjaD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJzcGFjZVwiLHQuc3BhY2VJZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXQubGltaXQsaT10LnBhZ2Usbz17fTtyJiYoby5saW1pdD1yKTtpZihuKXt2YXIgcz1bXTtuLnRvdGFsQ291bnQmJihvLmNvdW50PSEwKSxuLmN1c3RvbUZpZWxkcyYmcy5wdXNoKFwiY3VzdG9tXCIpLG4uc3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlXCIpLG4uY3VzdG9tU3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlLmN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5wYXRjaFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgbj10LnVzZXJzLHI9e307biYmMDxuLmxlbmd0aCYmKHIuYWRkPVtdLG4uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17aWQ6ZS5pZH07ZS5jdXN0b20mJih0LmN1c3RvbT1lLmN1c3RvbSksci5hZGQucHVzaCh0KX0pKTtyZXR1cm4gcn0oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlTWVtYmVyc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc3BhY2VJZCxyPXQudXNlcnM7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIHNwYWNlSWRcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgdXNlcnNcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdCh0LnNwYWNlSWQsXCIvdXNlcnNcIil9LHQucGF0Y2hVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdCh0LnNwYWNlSWQsXCIvdXNlcnNcIil9LHQudXNlUGF0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIix0LnNwYWNlSWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj10LmxpbWl0LGk9dC5wYWdlLG89e307ciYmKG8ubGltaXQ9cik7aWYobil7dmFyIHM9W107bi50b3RhbENvdW50JiYoby5jb3VudD0hMCksbi5jdXN0b21GaWVsZHMmJnMucHVzaChcImN1c3RvbVwiKSxuLnNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZVwiKSxuLmN1c3RvbVNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZS5jdXN0b21cIik7dmFyIGE9cy5qb2luKFwiLFwiKTswPGEubGVuZ3RoJiYoby5pbmNsdWRlPWEpfWkmJihpLm5leHQmJihvLnN0YXJ0PWkubmV4dCksaS5wcmV2JiYoby5lbmQ9aS5wcmV2KSk7cmV0dXJuIG99LHQucGF0Y2hQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dmFyIG49dC5hZGRNZW1iZXJzLHI9dC51cGRhdGVNZW1iZXJzLGk9dC5yZW1vdmVNZW1iZXJzLG89dC51c2VycyxzPXt9O24mJjA8bi5sZW5ndGgmJihzLmFkZD1bXSxuLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHQ9e2lkOmUuaWR9O2UuY3VzdG9tJiYodC5jdXN0b209ZS5jdXN0b20pLHMuYWRkLnB1c2godCl9KSk7ciYmMDxyLmxlbmd0aCYmKHMudXBkYXRlPVtdLHIuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17aWQ6ZS5pZH07ZS5jdXN0b20mJih0LmN1c3RvbT1lLmN1c3RvbSkscy51cGRhdGUucHVzaCh0KX0pKTtvJiYwPG8ubGVuZ3RoJiYocy51cGRhdGU9cy51cGRhdGV8fFtdLG8uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17aWQ6ZS5pZH07ZS5jdXN0b20mJih0LmN1c3RvbT1lLmN1c3RvbSkscy51cGRhdGUucHVzaCh0KX0pKTtpJiYwPGkubGVuZ3RoJiYocy5yZW1vdmU9W10saS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3MucmVtb3ZlLnB1c2goe2lkOmV9KX0pKTtyZXR1cm4gc30oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlTWVtYmVyc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc3BhY2VJZCxyPXQudXNlcnM7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIHNwYWNlSWRcIjtpZighcilyZXR1cm5cIk1pc3NpbmcgdXNlcnNcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdCh0LnNwYWNlSWQsXCIvdXNlcnNcIil9LHQucGF0Y2hVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi9zcGFjZXMvXCIpLmNvbmNhdCh0LnNwYWNlSWQsXCIvdXNlcnNcIil9LHQudXNlUGF0Y2g9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0QXV0aFRva2VuPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwic3BhY2VcIix0LnNwYWNlSWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInNwYWNlXCIpfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmluY2x1ZGUscj10LmxpbWl0LGk9dC5wYWdlLG89e307ciYmKG8ubGltaXQ9cik7aWYobil7dmFyIHM9W107bi50b3RhbENvdW50JiYoby5jb3VudD0hMCksbi5jdXN0b21GaWVsZHMmJnMucHVzaChcImN1c3RvbVwiKSxuLnNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZVwiKSxuLmN1c3RvbVNwYWNlRmllbGRzJiZzLnB1c2goXCJzcGFjZS5jdXN0b21cIik7dmFyIGE9cy5qb2luKFwiLFwiKTswPGEubGVuZ3RoJiYoby5pbmNsdWRlPWEpfWkmJihpLm5leHQmJihvLnN0YXJ0PWkubmV4dCksaS5wcmV2JiYoby5lbmQ9aS5wcmV2KSk7cmV0dXJuIG99LHQucGF0Y2hQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUsdCl7dmFyIG49dC51c2VycyxyPXt9O24mJjA8bi5sZW5ndGgmJihyLnJlbW92ZT1bXSxuLmZvckVhY2goZnVuY3Rpb24oZSl7ci5yZW1vdmUucHVzaCh7aWQ6ZX0pfSkpO3JldHVybiByfSgwLHQpfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5HZXRNZW1iZXJzaGlwc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe2lmKCF0LnVzZXJJZClyZXR1cm5cIk1pc3NpbmcgdXNlcklkXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdCh0LnVzZXJJZCxcIi9zcGFjZXNcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIix0LnVzZXJJZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9dC5saW1pdCxpPXQucGFnZSxvPXt9O3ImJihvLmxpbWl0PXIpO2lmKG4pe3ZhciBzPVtdO24udG90YWxDb3VudCYmKG8uY291bnQ9ITApLG4uY3VzdG9tRmllbGRzJiZzLnB1c2goXCJjdXN0b21cIiksbi5zcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2VcIiksbi5jdXN0b21TcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2UuY3VzdG9tXCIpO3ZhciBhPXMuam9pbihcIixcIik7MDxhLmxlbmd0aCYmKG8uaW5jbHVkZT1hKX1pJiYoaS5uZXh0JiYoby5zdGFydD1pLm5leHQpLGkucHJldiYmKG8uZW5kPWkucHJldikpO3JldHVybiBvfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5VcGRhdGVNZW1iZXJzaGlwc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQudXNlcklkLHI9dC5zcGFjZXM7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIHVzZXJJZFwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBzcGFjZXNcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHQudXNlcklkLFwiL3NwYWNlc1wiKX0sdC5wYXRjaFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3VzZXJzL1wiKS5jb25jYXQodC51c2VySWQsXCIvc3BhY2VzXCIpfSx0LnVzZVBhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIix0LnVzZXJJZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9dC5saW1pdCxpPXQucGFnZSxvPXt9O3ImJihvLmxpbWl0PXIpO2lmKG4pe3ZhciBzPVtdO24udG90YWxDb3VudCYmKG8uY291bnQ9ITApLG4uY3VzdG9tRmllbGRzJiZzLnB1c2goXCJjdXN0b21cIiksbi5zcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2VcIiksbi5jdXN0b21TcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2UuY3VzdG9tXCIpO3ZhciBhPXMuam9pbihcIixcIik7MDxhLmxlbmd0aCYmKG8uaW5jbHVkZT1hKX1pJiYoaS5uZXh0JiYoby5zdGFydD1pLm5leHQpLGkucHJldiYmKG8uZW5kPWkucHJldikpO3JldHVybiBvfSx0LnBhdGNoUGF5bG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3ZhciBuPXQuYWRkTWVtYmVyc2hpcHMscj10LnVwZGF0ZU1lbWJlcnNoaXBzLGk9dC5yZW1vdmVNZW1iZXJzaGlwcyxvPXQuc3BhY2VzLHM9e307biYmMDxuLmxlbmd0aCYmKHMuYWRkPVtdLG4uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17aWQ6ZS5pZH07ZS5jdXN0b20mJih0LmN1c3RvbT1lLmN1c3RvbSkscy5hZGQucHVzaCh0KX0pKTtyJiYwPHIubGVuZ3RoJiYocy51cGRhdGU9W10sci5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXtpZDplLmlkfTtlLmN1c3RvbSYmKHQuY3VzdG9tPWUuY3VzdG9tKSxzLnVwZGF0ZS5wdXNoKHQpfSkpO28mJjA8by5sZW5ndGgmJihzLnVwZGF0ZT1zLnVwZGF0ZXx8W10sby5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXtpZDplLmlkfTtlLmN1c3RvbSYmKHQuY3VzdG9tPWUuY3VzdG9tKSxzLnVwZGF0ZS5wdXNoKHQpfSkpO2kmJjA8aS5sZW5ndGgmJihzLnJlbW92ZT1bXSxpLmZvckVhY2goZnVuY3Rpb24oZSl7cy5yZW1vdmUucHVzaCh7aWQ6ZX0pfSkpO3JldHVybiBzfSgwLHQpfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5VcGRhdGVNZW1iZXJzaGlwc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQudXNlcklkLHI9dC5zcGFjZXM7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIHVzZXJJZFwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBzcGFjZXNcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHQudXNlcklkLFwiL3NwYWNlc1wiKX0sdC5wYXRjaFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnO3JldHVyblwiL3YxL29iamVjdHMvXCIuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiL3VzZXJzL1wiKS5jb25jYXQodC51c2VySWQsXCIvc3BhY2VzXCIpfSx0LnVzZVBhdGNoPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldEF1dGhUb2tlbj1mdW5jdGlvbihlLHQpe3JldHVybiBlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIix0LnVzZXJJZCl8fGUudG9rZW5NYW5hZ2VyLmdldFRva2VuKFwidXNlclwiKX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5pbmNsdWRlLHI9dC5saW1pdCxpPXQucGFnZSxvPXt9O3ImJihvLmxpbWl0PXIpO2lmKG4pe3ZhciBzPVtdO24udG90YWxDb3VudCYmKG8uY291bnQ9ITApLG4uY3VzdG9tRmllbGRzJiZzLnB1c2goXCJjdXN0b21cIiksbi5zcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2VcIiksbi5jdXN0b21TcGFjZUZpZWxkcyYmcy5wdXNoKFwic3BhY2UuY3VzdG9tXCIpO3ZhciBhPXMuam9pbihcIixcIik7MDxhLmxlbmd0aCYmKG8uaW5jbHVkZT1hKX1pJiYoaS5uZXh0JiYoby5zdGFydD1pLm5leHQpLGkucHJldiYmKG8uZW5kPWkucHJldikpO3JldHVybiBvfSx0LnBhdGNoUGF5bG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3ZhciBuPXQuc3BhY2VzLHI9e307biYmMDxuLmxlbmd0aCYmKHIuYWRkPVtdLG4uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17aWQ6ZS5pZH07ZS5jdXN0b20mJih0LmN1c3RvbT1lLmN1c3RvbSksci5hZGQucHVzaCh0KX0pKTtyZXR1cm4gcn0oMCx0KX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0fTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOVXBkYXRlTWVtYmVyc2hpcHNPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LnVzZXJJZCxyPXQuc3BhY2VzO2lmKCFuKXJldHVyblwiTWlzc2luZyB1c2VySWRcIjtpZighcilyZXR1cm5cIk1pc3Npbmcgc3BhY2VzXCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWc7cmV0dXJuXCIvdjEvb2JqZWN0cy9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvdXNlcnMvXCIpLmNvbmNhdCh0LnVzZXJJZCxcIi9zcGFjZXNcIil9LHQucGF0Y2hVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztyZXR1cm5cIi92MS9vYmplY3RzL1wiLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi91c2Vycy9cIikuY29uY2F0KHQudXNlcklkLFwiL3NwYWNlc1wiKX0sdC51c2VQYXRjaD1mdW5jdGlvbigpe3JldHVybiEwfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRBdXRoVG9rZW49ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZS50b2tlbk1hbmFnZXIuZ2V0VG9rZW4oXCJ1c2VyXCIsdC51c2VySWQpfHxlLnRva2VuTWFuYWdlci5nZXRUb2tlbihcInVzZXJcIil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuaW5jbHVkZSxyPXQubGltaXQsaT10LnBhZ2Usbz17fTtyJiYoby5saW1pdD1yKTtpZihuKXt2YXIgcz1bXTtuLnRvdGFsQ291bnQmJihvLmNvdW50PSEwKSxuLmN1c3RvbUZpZWxkcyYmcy5wdXNoKFwiY3VzdG9tXCIpLG4uc3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlXCIpLG4uY3VzdG9tU3BhY2VGaWVsZHMmJnMucHVzaChcInNwYWNlLmN1c3RvbVwiKTt2YXIgYT1zLmpvaW4oXCIsXCIpOzA8YS5sZW5ndGgmJihvLmluY2x1ZGU9YSl9aSYmKGkubmV4dCYmKG8uc3RhcnQ9aS5uZXh0KSxpLnByZXYmJihvLmVuZD1pLnByZXYpKTtyZXR1cm4gb30sdC5wYXRjaFBheWxvYWQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSx0KXt2YXIgbj10LnNwYWNlcyxyPXt9O24mJjA8bi5sZW5ndGgmJihyLnJlbW92ZT1bXSxuLmZvckVhY2goZnVuY3Rpb24oZSl7ci5yZW1vdmUucHVzaCh7aWQ6ZX0pfSkpO3JldHVybiByfSgwLHQpfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHR9O24oMCk7dmFyIHIsaT0ocj1uKDEpKSYmci5fX2VzTW9kdWxlP3I6e2RlZmF1bHQ6cn19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiBpLmRlZmF1bHQuUE5BY2Nlc3NNYW5hZ2VyQXVkaXR9LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSl7aWYoIWUuY29uZmlnLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlKXt2YXIgdD1lLmNvbmZpZztyZXR1cm5cIi92Mi9hdXRoL2F1ZGl0L3N1Yi1rZXkvXCIuY29uY2F0KHQuc3Vic2NyaWJlS2V5KX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITF9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbCxyPXQuY2hhbm5lbEdyb3VwLGk9dC5hdXRoS2V5cyxvPXZvaWQgMD09PWk/W106aSxzPXt9O24mJihzLmNoYW5uZWw9bik7ciYmKHNbXCJjaGFubmVsLWdyb3VwXCJdPXIpOzA8by5sZW5ndGgmJihzLmF1dGg9by5qb2luKFwiLFwiKSk7cmV0dXJuIHN9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gdC5wYXlsb2FkfTtuKDApO3ZhciByLGk9KHI9bigxKSkmJnIuX19lc01vZHVsZT9yOntkZWZhdWx0OnJ9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gaS5kZWZhdWx0LlBOQWNjZXNzTWFuYWdlckdyYW50fSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO2lmKCF0LnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKCF0LnB1Ymxpc2hLZXkpcmV0dXJuXCJNaXNzaW5nIFB1Ymxpc2ggS2V5XCI7aWYoIXQuc2VjcmV0S2V5KXJldHVyblwiTWlzc2luZyBTZWNyZXQgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUpe3ZhciB0PWUuY29uZmlnO3JldHVyblwiL3YyL2F1dGgvZ3JhbnQvc3ViLWtleS9cIi5jb25jYXQodC5zdWJzY3JpYmVLZXkpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMX0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVscyxyPXZvaWQgMD09PW4/W106bixpPXQuY2hhbm5lbEdyb3VwcyxvPXZvaWQgMD09PWk/W106aSxzPXQudHRsLGE9dC5yZWFkLHU9dm9pZCAwIT09YSYmYSxjPXQud3JpdGUsZj12b2lkIDAhPT1jJiZjLGw9dC5tYW5hZ2UsaD12b2lkIDAhPT1sJiZsLHA9dC5hdXRoS2V5cyxkPXZvaWQgMD09PXA/W106cCxnPXt9O2cucj11P1wiMVwiOlwiMFwiLGcudz1mP1wiMVwiOlwiMFwiLGcubT1oP1wiMVwiOlwiMFwiLDA8ci5sZW5ndGgmJihnLmNoYW5uZWw9ci5qb2luKFwiLFwiKSk7MDxvLmxlbmd0aCYmKGdbXCJjaGFubmVsLWdyb3VwXCJdPW8uam9pbihcIixcIikpOzA8ZC5sZW5ndGgmJihnLmF1dGg9ZC5qb2luKFwiLFwiKSk7IXMmJjAhPT1zfHwoZy50dGw9cyk7cmV0dXJuIGd9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oKXtyZXR1cm57fX07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIGkuZGVmYXVsdC5QTkFjY2Vzc01hbmFnZXJHcmFudFRva2VufSx0LmV4dHJhY3RQZXJtaXNzaW9ucz1sLHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZztpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIjtpZighbi5wdWJsaXNoS2V5KXJldHVyblwiTWlzc2luZyBQdWJsaXNoIEtleVwiO2lmKCFuLnNlY3JldEtleSlyZXR1cm5cIk1pc3NpbmcgU2VjcmV0IEtleVwiO2lmKCF0LnJlc291cmNlcyYmIXQucGF0dGVybnMpcmV0dXJuXCJNaXNzaW5nIGVpdGhlciBSZXNvdXJjZXMgb3IgUGF0dGVybnMuXCI7aWYodC5yZXNvdXJjZXMmJighdC5yZXNvdXJjZXMudXNlcnN8fDA9PT1PYmplY3Qua2V5cyh0LnJlc291cmNlcy51c2VycykubGVuZ3RoKSYmKCF0LnJlc291cmNlcy5zcGFjZXN8fDA9PT1PYmplY3Qua2V5cyh0LnJlc291cmNlcy5zcGFjZXMpLmxlbmd0aCl8fHQucGF0dGVybnMmJighdC5wYXR0ZXJucy51c2Vyc3x8MD09PU9iamVjdC5rZXlzKHQucGF0dGVybnMudXNlcnMpLmxlbmd0aCkmJighdC5wYXR0ZXJucy5zcGFjZXN8fDA9PT1PYmplY3Qua2V5cyh0LnBhdHRlcm5zLnNwYWNlcykubGVuZ3RoKSlyZXR1cm5cIk1pc3NpbmcgdmFsdWVzIGZvciBlaXRoZXIgUmVzb3VyY2VzIG9yIFBhdHRlcm5zLlwifSx0LnBvc3RVUkw9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5jb25maWc7cmV0dXJuXCIvdjMvcGFtL1wiLmNvbmNhdCh0LnN1YnNjcmliZUtleSxcIi9ncmFudFwiKX0sdC51c2VQb3N0PWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiExfSx0LnByZXBhcmVQYXJhbXM9ZnVuY3Rpb24oKXtyZXR1cm57fX0sdC5wb3N0UGF5bG9hZD1mdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlLHQpe3ZhciBuPXQudHRsLHI9dC5yZXNvdXJjZXMsaT10LnBhdHRlcm5zLG89dC5tZXRhLHM9e3R0bDowLHBlcm1pc3Npb25zOntyZXNvdXJjZXM6e2NoYW5uZWxzOnt9LGdyb3Vwczp7fSx1c2Vyczp7fSxzcGFjZXM6e319LHBhdHRlcm5zOntjaGFubmVsczp7fSxncm91cHM6e30sdXNlcnM6e30sc3BhY2VzOnt9fSxtZXRhOnt9fX07aWYocil7dmFyIGE9ci51c2Vycyx1PXIuc3BhY2VzO2EmJk9iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24oZSl7cy5wZXJtaXNzaW9ucy5yZXNvdXJjZXMudXNlcnNbZV09bChhW2VdKX0pLHUmJk9iamVjdC5rZXlzKHUpLmZvckVhY2goZnVuY3Rpb24oZSl7cy5wZXJtaXNzaW9ucy5yZXNvdXJjZXMuc3BhY2VzW2VdPWwodVtlXSl9KX1pZihpKXt2YXIgYz1pLnVzZXJzLGY9aS5zcGFjZXM7YyYmT2JqZWN0LmtleXMoYykuZm9yRWFjaChmdW5jdGlvbihlKXtzLnBlcm1pc3Npb25zLnBhdHRlcm5zLnVzZXJzW2VdPWwoY1tlXSl9KSxmJiZPYmplY3Qua2V5cyhmKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3MucGVybWlzc2lvbnMucGF0dGVybnMuc3BhY2VzW2VdPWwoZltlXSl9KX0hbiYmMCE9PW58fChzLnR0bD1uKTtvJiYocy5wZXJtaXNzaW9ucy5tZXRhPW8pO3JldHVybiBzfSgwLHQpfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHQuZGF0YS50b2tlbn07bigwKTt2YXIgcixpPShyPW4oMSkpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfTtmdW5jdGlvbiBsKGUpe3ZhciB0PTA7cmV0dXJuIGUuY3JlYXRlJiYodHw9MTYpLGUuZGVsZXRlJiYodHw9OCksZS5tYW5hZ2UmJih0fD00KSxlLndyaXRlJiYodHw9MiksZS5yZWFkJiYodHw9MSksdH19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5QdWJsaXNoT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10Lm1lc3NhZ2U7aWYoIXQuY2hhbm5lbClyZXR1cm5cIk1pc3NpbmcgQ2hhbm5lbFwiO2lmKCFyKXJldHVyblwiTWlzc2luZyBNZXNzYWdlXCI7aWYoIW4uc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQudXNlUG9zdD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc2VuZEJ5UG9zdDtyZXR1cm4gdm9pZCAwIT09biYmbn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbCxpPXQubWVzc2FnZSxvPWEoZSxpKTtyZXR1cm5cIi9wdWJsaXNoL1wiLmNvbmNhdChuLnB1Ymxpc2hLZXksXCIvXCIpLmNvbmNhdChuLnN1YnNjcmliZUtleSxcIi8wL1wiKS5jb25jYXQocy5kZWZhdWx0LmVuY29kZVN0cmluZyhyKSxcIi8wL1wiKS5jb25jYXQocy5kZWZhdWx0LmVuY29kZVN0cmluZyhvKSl9LHQucG9zdFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9dC5jaGFubmVsO3JldHVyblwiL3B1Ymxpc2gvXCIuY29uY2F0KG4ucHVibGlzaEtleSxcIi9cIikuY29uY2F0KG4uc3Vic2NyaWJlS2V5LFwiLzAvXCIpLmNvbmNhdChzLmRlZmF1bHQuZW5jb2RlU3RyaW5nKHIpLFwiLzBcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFRyYW5zYWN0aW9uVGltZW91dCgpfSx0LmlzQXV0aFN1cHBvcnRlZD1mdW5jdGlvbigpe3JldHVybiEwfSx0LnBvc3RQYXlsb2FkPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5tZXNzYWdlO3JldHVybiBhKGUsbil9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQubWV0YSxyPXQucmVwbGljYXRlLGk9dm9pZCAwPT09cnx8cixvPXQuc3RvcmVJbkhpc3Rvcnkscz10LnR0bCxhPXt9O251bGwhPW8mJihhLnN0b3JlPW8/XCIxXCI6XCIwXCIpO3MmJihhLnR0bD1zKTshMT09PWkmJihhLm5vcmVwPVwidHJ1ZVwiKTtuJiZcIm9iamVjdFwiPT09dShuKSYmKGEubWV0YT1KU09OLnN0cmluZ2lmeShuKSk7cmV0dXJuIGF9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57dGltZXRva2VuOnRbMl19fTtuKDApO3ZhciByPWkobigxKSkscz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fWZ1bmN0aW9uIHUoZSl7cmV0dXJuKHU9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIGEoZSx0KXt2YXIgbj1lLmNyeXB0byxyPWUuY29uZmlnLGk9SlNPTi5zdHJpbmdpZnkodCk7cmV0dXJuIHIuY2lwaGVyS2V5JiYoaT1uLmVuY3J5cHQoaSksaT1KU09OLnN0cmluZ2lmeShpKSksaX19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmdldE9wZXJhdGlvbj1mdW5jdGlvbigpe3JldHVybiByLmRlZmF1bHQuUE5TaWduYWxPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQubWVzc2FnZTtpZighdC5jaGFubmVsKXJldHVyblwiTWlzc2luZyBDaGFubmVsXCI7aWYoIXIpcmV0dXJuXCJNaXNzaW5nIE1lc3NhZ2VcIjtpZighbi5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLmNvbmZpZyxyPXQuY2hhbm5lbCxpPXQubWVzc2FnZSxvPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KHQpfSgwLGkpO3JldHVyblwiL3NpZ25hbC9cIi5jb25jYXQobi5wdWJsaXNoS2V5LFwiL1wiKS5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvMC9cIikuY29uY2F0KHMuZGVmYXVsdC5lbmNvZGVTdHJpbmcociksXCIvMC9cIikuY29uY2F0KHMuZGVmYXVsdC5lbmNvZGVTdHJpbmcobykpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKCl7cmV0dXJue319LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm57dGltZXRva2VuOnRbMl19fTtuKDApO3ZhciByPWkobigxKSkscz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkhpc3RvcnlPcGVyYXRpb259LHQudmFsaWRhdGVQYXJhbXM9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWwscj1lLmNvbmZpZztpZighbilyZXR1cm5cIk1pc3NpbmcgY2hhbm5lbFwiO2lmKCFyLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwifSx0LmdldFVSTD1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbCxyPWUuY29uZmlnO3JldHVyblwiL3YyL2hpc3Rvcnkvc3ViLWtleS9cIi5jb25jYXQoci5zdWJzY3JpYmVLZXksXCIvY2hhbm5lbC9cIikuY29uY2F0KGkuZGVmYXVsdC5lbmNvZGVTdHJpbmcobikpfSx0LmdldFJlcXVlc3RUaW1lb3V0PWZ1bmN0aW9uKGUpe3JldHVybiBlLmNvbmZpZy5nZXRUcmFuc2FjdGlvblRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5zdGFydCxyPXQuZW5kLGk9dC5yZXZlcnNlLG89dC5jb3VudCxzPXZvaWQgMD09PW8/MTAwOm8sYT10LnN0cmluZ2lmaWVkVGltZVRva2VuLHU9dm9pZCAwIT09YSYmYSxjPXQuaW5jbHVkZU1ldGEsZj12b2lkIDAhPT1jJiZjLGw9e2luY2x1ZGVfdG9rZW46XCJ0cnVlXCJ9O2wuY291bnQ9cyxuJiYobC5zdGFydD1uKTtyJiYobC5lbmQ9cik7dSYmKGwuc3RyaW5nX21lc3NhZ2VfdG9rZW49XCJ0cnVlXCIpO251bGwhPWkmJihsLnJldmVyc2U9aS50b1N0cmluZygpKTtmJiYobC5pbmNsdWRlX21ldGE9XCJ0cnVlXCIpO3JldHVybiBsfSx0LmhhbmRsZVJlc3BvbnNlPWZ1bmN0aW9uKG4sZSl7dmFyIHI9e21lc3NhZ2VzOltdLHN0YXJ0VGltZVRva2VuOmVbMV0sZW5kVGltZVRva2VuOmVbMl19O0FycmF5LmlzQXJyYXkoZVswXSkmJmVbMF0uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17dGltZXRva2VuOmUudGltZXRva2VuLGVudHJ5OmZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj1lLmNyeXB0bztpZighbi5jaXBoZXJLZXkpcmV0dXJuIHQ7dHJ5e3JldHVybiByLmRlY3J5cHQodCl9Y2F0Y2goZSl7cmV0dXJuIHR9fShuLGUubWVzc2FnZSl9O2UubWV0YSYmKHQubWV0YT1lLm1ldGEpLHIubWVzc2FnZXMucHVzaCh0KX0pO3JldHVybiByfTtuKDApO3ZhciByPW8obigxKSksaT1vKG4oMikpO2Z1bmN0aW9uIG8oZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTkRlbGV0ZU1lc3NhZ2VzT3BlcmF0aW9ufSx0LnZhbGlkYXRlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVsLHI9ZS5jb25maWc7aWYoIW4pcmV0dXJuXCJNaXNzaW5nIGNoYW5uZWxcIjtpZighci5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC51c2VEZWxldGU9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWwscj1lLmNvbmZpZztyZXR1cm5cIi92My9oaXN0b3J5L3N1Yi1rZXkvXCIuY29uY2F0KHIuc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChpLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG4pKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc3RhcnQscj10LmVuZCxpPXt9O24mJihpLnN0YXJ0PW4pO3ImJihpLmVuZD1yKTtyZXR1cm4gaX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybiB0LnBheWxvYWR9O24oMCk7dmFyIHI9byhuKDEpKSxpPW8obigyKSk7ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LlBOTWVzc2FnZUNvdW50c30sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHMscj10LnRpbWV0b2tlbixpPXQuY2hhbm5lbFRpbWV0b2tlbnMsbz1lLmNvbmZpZztpZighbilyZXR1cm5cIk1pc3NpbmcgY2hhbm5lbFwiO2lmKHImJmkpcmV0dXJuXCJ0aW1ldG9rZW4gYW5kIGNoYW5uZWxUaW1ldG9rZW5zIGFyZSBpbmNvbXBhdGlibGUgdG9nZXRoZXJcIjtpZihyJiZpJiYxPGkubGVuZ3RoJiZuLmxlbmd0aCE9PWkubGVuZ3RoKXJldHVyblwiTGVuZ3RoIG9mIGNoYW5uZWxUaW1ldG9rZW5zIGFuZCBjaGFubmVscyBkbyBub3QgbWF0Y2hcIjtpZighby5zdWJzY3JpYmVLZXkpcmV0dXJuXCJNaXNzaW5nIFN1YnNjcmliZSBLZXlcIn0sdC5nZXRVUkw9ZnVuY3Rpb24oZSx0KXt2YXIgbj10LmNoYW5uZWxzLHI9ZS5jb25maWcsaT1uLmpvaW4oXCIsXCIpO3JldHVyblwiL3YzL2hpc3Rvcnkvc3ViLWtleS9cIi5jb25jYXQoci5zdWJzY3JpYmVLZXksXCIvbWVzc2FnZS1jb3VudHMvXCIpLmNvbmNhdChvLmRlZmF1bHQuZW5jb2RlU3RyaW5nKGkpKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQudGltZXRva2VuLHI9dC5jaGFubmVsVGltZXRva2VucyxpPXt9O2lmKHImJjE9PT1yLmxlbmd0aCl7dmFyIG89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoQXJyYXkuaXNBcnJheShlKSlyZXR1cm4gZX0oZSl8fGZ1bmN0aW9uKGUsdCl7aWYoIShTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGUpfHxcIltvYmplY3QgQXJndW1lbnRzXVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGUpKSlyZXR1cm47dmFyIG49W10scj0hMCxpPSExLG89dm9pZCAwO3RyeXtmb3IodmFyIHMsYT1lW1N5bWJvbC5pdGVyYXRvcl0oKTshKHI9KHM9YS5uZXh0KCkpLmRvbmUpJiYobi5wdXNoKHMudmFsdWUpLCF0fHxuLmxlbmd0aCE9PXQpO3I9ITApO31jYXRjaChlKXtpPSEwLG89ZX1maW5hbGx5e3RyeXtyfHxudWxsPT1hLnJldHVybnx8YS5yZXR1cm4oKX1maW5hbGx5e2lmKGkpdGhyb3cgb319cmV0dXJuIG59KGUsdCl8fGZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIil9KCl9KHIsMSlbMF07aS50aW1ldG9rZW49b31lbHNlIHI/aS5jaGFubmVsc1RpbWV0b2tlbj1yLmpvaW4oXCIsXCIpOm4mJihpLnRpbWV0b2tlbj1uKTtyZXR1cm4gaX0sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihlLHQpe3JldHVybntjaGFubmVsczp0LmNoYW5uZWxzfX07dmFyIHI9aShuKDEpKSxvPWkobigyKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXRPcGVyYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4gci5kZWZhdWx0LlBORmV0Y2hNZXNzYWdlc09wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuY2hhbm5lbHMscj10LmluY2x1ZGVNZXNzYWdlQWN0aW9ucyxpPXZvaWQgMCE9PXImJnIsbz1lLmNvbmZpZztpZighbnx8MD09PW4ubGVuZ3RoKXJldHVyblwiTWlzc2luZyBjaGFubmVsc1wiO2lmKCFvLnN1YnNjcmliZUtleSlyZXR1cm5cIk1pc3NpbmcgU3Vic2NyaWJlIEtleVwiO2lmKGkmJjE8bi5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhpc3RvcnkgY2FuIHJldHVybiBhY3Rpb25zIGRhdGEgZm9yIGEgc2luZ2xlIGNoYW5uZWwgb25seS4gRWl0aGVyIHBhc3MgYSBzaW5nbGUgY2hhbm5lbCBvciBkaXNhYmxlIHRoZSBpbmNsdWRlTWVzc2FnZUFjdGlvbnMgZmxhZy5cIil9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49dC5jaGFubmVscyxyPXZvaWQgMD09PW4/W106bixpPXQuaW5jbHVkZU1lc3NhZ2VBY3Rpb25zLG89dm9pZCAwIT09aSYmaSxzPWUuY29uZmlnLGE9bz9cImhpc3Rvcnktd2l0aC1hY3Rpb25zXCI6XCJoaXN0b3J5XCIsdT0wPHIubGVuZ3RoP3Iuam9pbihcIixcIik6XCIsXCI7cmV0dXJuXCIvdjMvXCIuY29uY2F0KGEsXCIvc3ViLWtleS9cIikuY29uY2F0KHMuc3Vic2NyaWJlS2V5LFwiL2NoYW5uZWwvXCIpLmNvbmNhdChjLmRlZmF1bHQuZW5jb2RlU3RyaW5nKHUpKX0sdC5nZXRSZXF1ZXN0VGltZW91dD1mdW5jdGlvbihlKXtyZXR1cm4gZS5jb25maWcuZ2V0VHJhbnNhY3Rpb25UaW1lb3V0KCl9LHQuaXNBdXRoU3VwcG9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuITB9LHQucHJlcGFyZVBhcmFtcz1mdW5jdGlvbihlLHQpe3ZhciBuPXQuc3RhcnQscj10LmVuZCxpPXQuY291bnQsbz10LnN0cmluZ2lmaWVkVGltZVRva2VuLHM9dm9pZCAwIT09byYmbyxhPXQuaW5jbHVkZU1ldGEsdT12b2lkIDAhPT1hJiZhLGM9e307aSYmKGMubWF4PWkpO24mJihjLnN0YXJ0PW4pO3ImJihjLmVuZD1yKTtzJiYoYy5zdHJpbmdfbWVzc2FnZV90b2tlbj1cInRydWVcIik7dSYmKGMuaW5jbHVkZV9tZXRhPVwidHJ1ZVwiKTtyZXR1cm4gY30sdC5oYW5kbGVSZXNwb25zZT1mdW5jdGlvbihyLGUpe3ZhciBpPXtjaGFubmVsczp7fX07cmV0dXJuIE9iamVjdC5rZXlzKGUuY2hhbm5lbHN8fHt9KS5mb3JFYWNoKGZ1bmN0aW9uKG4pe2kuY2hhbm5lbHNbbl09W10sKGUuY2hhbm5lbHNbbl18fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3ZhciB0PXt9O3QuY2hhbm5lbD1uLHQudGltZXRva2VuPWUudGltZXRva2VuLHQubWVzc2FnZT1mdW5jdGlvbihlLHQpe3ZhciBuPWUuY29uZmlnLHI9ZS5jcnlwdG87aWYoIW4uY2lwaGVyS2V5KXJldHVybiB0O3RyeXtyZXR1cm4gci5kZWNyeXB0KHQpfWNhdGNoKGUpe3JldHVybiB0fX0ocixlLm1lc3NhZ2UpLGUuYWN0aW9ucyYmKHQuYWN0aW9ucz1lLmFjdGlvbnMsdC5kYXRhPWUuYWN0aW9ucyksZS5tZXRhJiYodC5tZXRhPWUubWV0YSksaS5jaGFubmVsc1tuXS5wdXNoKHQpfSl9KSxpfTtuKDApO3ZhciByPWkobigxKSksYz1pKG4oMikpO2Z1bmN0aW9uIGkoZSl7cmV0dXJuIGUmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9fX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQuZ2V0T3BlcmF0aW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHIuZGVmYXVsdC5QTlN1YnNjcmliZU9wZXJhdGlvbn0sdC52YWxpZGF0ZVBhcmFtcz1mdW5jdGlvbihlKXtpZighZS5jb25maWcuc3Vic2NyaWJlS2V5KXJldHVyblwiTWlzc2luZyBTdWJzY3JpYmUgS2V5XCJ9LHQuZ2V0VVJMPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LmNoYW5uZWxzLGk9dm9pZCAwPT09cj9bXTpyLG89MDxpLmxlbmd0aD9pLmpvaW4oXCIsXCIpOlwiLFwiO3JldHVyblwiL3YyL3N1YnNjcmliZS9cIi5jb25jYXQobi5zdWJzY3JpYmVLZXksXCIvXCIpLmNvbmNhdChzLmRlZmF1bHQuZW5jb2RlU3RyaW5nKG8pLFwiLzBcIil9LHQuZ2V0UmVxdWVzdFRpbWVvdXQ9ZnVuY3Rpb24oZSl7cmV0dXJuIGUuY29uZmlnLmdldFN1YnNjcmliZVRpbWVvdXQoKX0sdC5pc0F1dGhTdXBwb3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMH0sdC5wcmVwYXJlUGFyYW1zPWZ1bmN0aW9uKGUsdCl7dmFyIG49ZS5jb25maWcscj10LnN0YXRlLGk9dC5jaGFubmVsR3JvdXBzLG89dm9pZCAwPT09aT9bXTppLHM9dC50aW1ldG9rZW4sYT10LmZpbHRlckV4cHJlc3Npb24sdT10LnJlZ2lvbixjPXtoZWFydGJlYXQ6bi5nZXRQcmVzZW5jZVRpbWVvdXQoKX07MDxvLmxlbmd0aCYmKGNbXCJjaGFubmVsLWdyb3VwXCJdPW8uam9pbihcIixcIikpO2EmJjA8YS5sZW5ndGgmJihjW1wiZmlsdGVyLWV4cHJcIl09YSk7T2JqZWN0LmtleXMocikubGVuZ3RoJiYoYy5zdGF0ZT1KU09OLnN0cmluZ2lmeShyKSk7cyYmKGMudHQ9cyk7dSYmKGMudHI9dSk7cmV0dXJuIGN9LHQuaGFuZGxlUmVzcG9uc2U9ZnVuY3Rpb24oZSx0KXt2YXIgcj1bXTt0Lm0uZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD17cHVibGlzaFRpbWV0b2tlbjplLnAudCxyZWdpb246ZS5wLnJ9LG49e3NoYXJkOnBhcnNlSW50KGUuYSwxMCksc3Vic2NyaXB0aW9uTWF0Y2g6ZS5iLGNoYW5uZWw6ZS5jLG1lc3NhZ2VUeXBlOmUuZSxwYXlsb2FkOmUuZCxmbGFnczplLmYsaXNzdWluZ0NsaWVudElkOmUuaSxzdWJzY3JpYmVLZXk6ZS5rLG9yaWdpbmF0aW9uVGltZXRva2VuOmUubyx1c2VyTWV0YWRhdGE6ZS51LHB1Ymxpc2hNZXRhRGF0YTp0fTtyLnB1c2gobil9KTt2YXIgbj17dGltZXRva2VuOnQudC50LHJlZ2lvbjp0LnQucn07cmV0dXJue21lc3NhZ2VzOnIsbWV0YWRhdGE6bn19O24oMCk7dmFyIHI9aShuKDEpKSxzPWkobigyKSk7ZnVuY3Rpb24gaShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5kZWZhdWx0PXZvaWQgMDtpKG4oMykpO3ZhciByPWkobig0KSk7bigwKTtmdW5jdGlvbiBpKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiBvKGUsdCl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciByPXRbbl07ci5lbnVtZXJhYmxlPXIuZW51bWVyYWJsZXx8ITEsci5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gciYmKHIud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIua2V5LHIpfX1mdW5jdGlvbiBzKGUsdCxuKXtyZXR1cm4gdCBpbiBlP09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse3ZhbHVlOm4sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KTplW3RdPW4sZX12YXIgYSx1LGMsZj0oYT1sLCh1PVt7a2V5OlwiaW5pdFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3RoaXMuX2NvbmZpZz1lLHRoaXMuX21heFN1YkRvbWFpbj0yMCx0aGlzLl9jdXJyZW50U3ViRG9tYWluPU1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSp0aGlzLl9tYXhTdWJEb21haW4pLHRoaXMuX3Byb3ZpZGVkRlFETj0odGhpcy5fY29uZmlnLnNlY3VyZT9cImh0dHBzOi8vXCI6XCJodHRwOi8vXCIpK3RoaXMuX2NvbmZpZy5vcmlnaW4sdGhpcy5fY29yZVBhcmFtcz17fSx0aGlzLnNoaWZ0U3RhbmRhcmRPcmlnaW4oKX19LHtrZXk6XCJuZXh0T3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcHJvdmlkZWRGUUROLm1hdGNoKC9wc1xcLnBuZHNuXFwuY29tJC9pKT8odGhpcy5fY3VycmVudFN1YkRvbWFpbj10aGlzLl9jdXJyZW50U3ViRG9tYWluKzEsdGhpcy5fY3VycmVudFN1YkRvbWFpbj49dGhpcy5fbWF4U3ViRG9tYWluJiYodGhpcy5fY3VycmVudFN1YkRvbWFpbj0xKSxlPXRoaXMuX2N1cnJlbnRTdWJEb21haW4udG9TdHJpbmcoKSx0aGlzLl9wcm92aWRlZEZRRE4ucmVwbGFjZShcInBzLnBuZHNuLmNvbVwiLFwicHNcIi5jb25jYXQoZSxcIi5wbmRzbi5jb21cIikpKTp0aGlzLl9wcm92aWRlZEZRRE47dmFyIGV9fSx7a2V5OlwiaGFzTW9kdWxlXCIsdmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW4gdGhpcy5fbW9kdWxlc319LHtrZXk6XCJzaGlmdFN0YW5kYXJkT3JpZ2luXCIsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3RhbmRhcmRPcmlnaW49dGhpcy5uZXh0T3JpZ2luKCksdGhpcy5fc3RhbmRhcmRPcmlnaW59fSx7a2V5OlwiZ2V0U3RhbmRhcmRPcmlnaW5cIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zdGFuZGFyZE9yaWdpbn19LHtrZXk6XCJQT1NUXCIsdmFsdWU6ZnVuY3Rpb24oZSx0LG4scil7cmV0dXJuIHRoaXMuX21vZHVsZXMucG9zdChlLHQsbixyKX19LHtrZXk6XCJQQVRDSFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuLHIpe3JldHVybiB0aGlzLl9tb2R1bGVzLnBhdGNoKGUsdCxuLHIpfX0se2tleTpcIkdFVFwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5fbW9kdWxlcy5nZXQoZSx0LG4pfX0se2tleTpcIkRFTEVURVwiLHZhbHVlOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gdGhpcy5fbW9kdWxlcy5kZWwoZSx0LG4pfX0se2tleTpcIl9kZXRlY3RFcnJvckNhdGVnb3J5XCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoXCJFTk9URk9VTkRcIj09PWUuY29kZSlyZXR1cm4gci5kZWZhdWx0LlBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5O2lmKFwiRUNPTk5SRUZVU0VEXCI9PT1lLmNvZGUpcmV0dXJuIHIuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTtpZihcIkVDT05OUkVTRVRcIj09PWUuY29kZSlyZXR1cm4gci5kZWZhdWx0LlBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5O2lmKFwiRUFJX0FHQUlOXCI9PT1lLmNvZGUpcmV0dXJuIHIuZGVmYXVsdC5QTk5ldHdvcmtJc3N1ZXNDYXRlZ29yeTtpZigwPT09ZS5zdGF0dXN8fGUuaGFzT3duUHJvcGVydHkoXCJzdGF0dXNcIikmJnZvaWQgMD09PWUuc3RhdHVzKXJldHVybiByLmRlZmF1bHQuUE5OZXR3b3JrSXNzdWVzQ2F0ZWdvcnk7aWYoZS50aW1lb3V0KXJldHVybiByLmRlZmF1bHQuUE5UaW1lb3V0Q2F0ZWdvcnk7aWYoXCJFVElNRURPVVRcIj09PWUuY29kZSlyZXR1cm4gci5kZWZhdWx0LlBOTmV0d29ya0lzc3Vlc0NhdGVnb3J5O2lmKGUucmVzcG9uc2Upe2lmKGUucmVzcG9uc2UuYmFkUmVxdWVzdClyZXR1cm4gci5kZWZhdWx0LlBOQmFkUmVxdWVzdENhdGVnb3J5O2lmKGUucmVzcG9uc2UuZm9yYmlkZGVuKXJldHVybiByLmRlZmF1bHQuUE5BY2Nlc3NEZW5pZWRDYXRlZ29yeX1yZXR1cm4gci5kZWZhdWx0LlBOVW5rbm93bkNhdGVnb3J5fX1dKSYmbyhhLnByb3RvdHlwZSx1KSx2b2lkKGMmJm8oYSxjKSksbCk7ZnVuY3Rpb24gbCh0KXt2YXIgbj10aGlzOyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsbCkscyh0aGlzLFwiX21vZHVsZXNcIix2b2lkIDApLHModGhpcyxcIl9jb25maWdcIix2b2lkIDApLHModGhpcyxcIl9tYXhTdWJEb21haW5cIix2b2lkIDApLHModGhpcyxcIl9jdXJyZW50U3ViRG9tYWluXCIsdm9pZCAwKSxzKHRoaXMsXCJfc3RhbmRhcmRPcmlnaW5cIix2b2lkIDApLHModGhpcyxcIl9zdWJzY3JpYmVPcmlnaW5cIix2b2lkIDApLHModGhpcyxcIl9wcm92aWRlZEZRRE5cIix2b2lkIDApLHModGhpcyxcIl9yZXF1ZXN0VGltZW91dFwiLHZvaWQgMCkscyh0aGlzLFwiX2NvcmVQYXJhbXNcIix2b2lkIDApLHRoaXMuX21vZHVsZXM9e30sT2JqZWN0LmtleXModCkuZm9yRWFjaChmdW5jdGlvbihlKXtuLl9tb2R1bGVzW2VdPXRbZV0uYmluZChuKX0pfXQuZGVmYXVsdD1mLGUuZXhwb3J0cz10LmRlZmF1bHR9LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0LmRlZmF1bHQ9dm9pZCAwO3ZhciByPXtnZXQ6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShlKX1jYXRjaChlKXtyZXR1cm4gbnVsbH19LHNldDpmdW5jdGlvbihlLHQpe3RyeXtyZXR1cm4gbG9jYWxTdG9yYWdlLnNldEl0ZW0oZSx0KX1jYXRjaChlKXtyZXR1cm4gbnVsbH19fTt0LmRlZmF1bHQ9cixlLmV4cG9ydHM9dC5kZWZhdWx0fSxmdW5jdGlvbihmLGwsaCl7XCJ1c2Ugc3RyaWN0XCI7KGZ1bmN0aW9uKGkpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShsLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGwuZGVmYXVsdD12b2lkIDA7dmFyIGUsbz0oZT1oKDc0KSkmJmUuX19lc01vZHVsZT9lOntkZWZhdWx0OmV9O2Z1bmN0aW9uIHMoZSl7cmV0dXJuKHM9XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZX06ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmZS5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmZSE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgZX0pKGUpfWZ1bmN0aW9uIHQoZSx0KXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIHI9dFtuXTtyLmVudW1lcmFibGU9ci5lbnVtZXJhYmxlfHwhMSxyLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiByJiYoci53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsci5rZXkscil9fXZhciBuLHIsYSx1PShuPWMsKHI9W3trZXk6XCJkZWNvZGVUb2tlblwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PVwiXCI7ZS5sZW5ndGglND09Mz90PVwiPVwiOmUubGVuZ3RoJTQ9PTImJih0PVwiPT1cIik7dmFyIG49ZS5yZXBsYWNlKFwiLVwiLFwiK1wiKS5yZXBsYWNlKFwiX1wiLFwiL1wiKSt0LHI9by5kZWZhdWx0LmRlY29kZShuZXcgaS5mcm9tKG4sXCJiYXNlNjRcIikpO2lmKFwib2JqZWN0XCI9PT1zKHIpKXJldHVybiByfX1dKSYmdChuLnByb3RvdHlwZSxyKSx2b2lkKGEmJnQobixhKSksYyk7ZnVuY3Rpb24gYygpeyFmdW5jdGlvbihlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9KHRoaXMsYyl9bC5kZWZhdWx0PXUsZi5leHBvcnRzPWwuZGVmYXVsdH0pLmNhbGwodGhpcyxoKDkpLkJ1ZmZlcil9LGZ1bmN0aW9uKGUsdCl7dmFyIG47bj1mdW5jdGlvbigpe3JldHVybiB0aGlzfSgpO3RyeXtuPW58fG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCl9Y2F0Y2goZSl7XCJvYmplY3RcIj09dHlwZW9mIHdpbmRvdyYmKG49d2luZG93KX1lLmV4cG9ydHM9bn0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3QuYnl0ZUxlbmd0aD1mdW5jdGlvbihlKXt2YXIgdD1sKGUpLG49dFswXSxyPXRbMV07cmV0dXJuIDMqKG4rcikvNC1yfSx0LnRvQnl0ZUFycmF5PWZ1bmN0aW9uKGUpe3ZhciB0LG4scj1sKGUpLGk9clswXSxvPXJbMV0scz1uZXcgZihmdW5jdGlvbihlLHQsbil7cmV0dXJuIDMqKHQrbikvNC1ufSgwLGksbykpLGE9MCx1PTA8bz9pLTQ6aTtmb3Iobj0wO248dTtuKz00KXQ9Y1tlLmNoYXJDb2RlQXQobildPDwxOHxjW2UuY2hhckNvZGVBdChuKzEpXTw8MTJ8Y1tlLmNoYXJDb2RlQXQobisyKV08PDZ8Y1tlLmNoYXJDb2RlQXQobiszKV0sc1thKytdPXQ+PjE2JjI1NSxzW2ErK109dD4+OCYyNTUsc1thKytdPTI1NSZ0OzI9PT1vJiYodD1jW2UuY2hhckNvZGVBdChuKV08PDJ8Y1tlLmNoYXJDb2RlQXQobisxKV0+PjQsc1thKytdPTI1NSZ0KTsxPT09byYmKHQ9Y1tlLmNoYXJDb2RlQXQobildPDwxMHxjW2UuY2hhckNvZGVBdChuKzEpXTw8NHxjW2UuY2hhckNvZGVBdChuKzIpXT4+MixzW2ErK109dD4+OCYyNTUsc1thKytdPTI1NSZ0KTtyZXR1cm4gc30sdC5mcm9tQnl0ZUFycmF5PWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxuPWUubGVuZ3RoLHI9biUzLGk9W10sbz0wLHM9bi1yO288cztvKz0xNjM4MylpLnB1c2godShlLG8sczxvKzE2MzgzP3M6bysxNjM4MykpOzE9PXI/KHQ9ZVtuLTFdLGkucHVzaChhW3Q+PjJdK2FbdDw8NCY2M10rXCI9PVwiKSk6Mj09ciYmKHQ9KGVbbi0yXTw8OCkrZVtuLTFdLGkucHVzaChhW3Q+PjEwXSthW3Q+PjQmNjNdK2FbdDw8MiY2M10rXCI9XCIpKTtyZXR1cm4gaS5qb2luKFwiXCIpfTtmb3IodmFyIGE9W10sYz1bXSxmPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXkscj1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIixpPTAsbz1yLmxlbmd0aDtpPG87KytpKWFbaV09cltpXSxjW3IuY2hhckNvZGVBdChpKV09aTtmdW5jdGlvbiBsKGUpe3ZhciB0PWUubGVuZ3RoO2lmKDA8dCU0KXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7dmFyIG49ZS5pbmRleE9mKFwiPVwiKTtyZXR1cm4tMT09PW4mJihuPXQpLFtuLG49PT10PzA6NC1uJTRdfWZ1bmN0aW9uIHUoZSx0LG4pe2Zvcih2YXIgcixpLG89W10scz10O3M8bjtzKz0zKXI9KGVbc108PDE2JjE2NzExNjgwKSsoZVtzKzFdPDw4JjY1MjgwKSsoMjU1JmVbcysyXSksby5wdXNoKGFbKGk9cik+PjE4JjYzXSthW2k+PjEyJjYzXSthW2k+PjYmNjNdK2FbNjMmaV0pO3JldHVybiBvLmpvaW4oXCJcIil9Y1tcIi1cIi5jaGFyQ29kZUF0KDApXT02MixjW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzfSxmdW5jdGlvbihlLHQpe3QucmVhZD1mdW5jdGlvbihlLHQsbixyLGkpe3ZhciBvLHMsYT04Kmktci0xLHU9KDE8PGEpLTEsYz11Pj4xLGY9LTcsbD1uP2ktMTowLGg9bj8tMToxLHA9ZVt0K2xdO2ZvcihsKz1oLG89cCYoMTw8LWYpLTEscD4+PS1mLGYrPWE7MDxmO289MjU2Km8rZVt0K2xdLGwrPWgsZi09OCk7Zm9yKHM9byYoMTw8LWYpLTEsbz4+PS1mLGYrPXI7MDxmO3M9MjU2KnMrZVt0K2xdLGwrPWgsZi09OCk7aWYoMD09PW8pbz0xLWM7ZWxzZXtpZihvPT09dSlyZXR1cm4gcz9OYU46MS8wKihwPy0xOjEpO3MrPU1hdGgucG93KDIsciksby09Y31yZXR1cm4ocD8tMToxKSpzKk1hdGgucG93KDIsby1yKX0sdC53cml0ZT1mdW5jdGlvbihlLHQsbixyLGksbyl7dmFyIHMsYSx1LGM9OCpvLWktMSxmPSgxPDxjKS0xLGw9Zj4+MSxoPTIzPT09aT9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAscD1yPzA6by0xLGQ9cj8xOi0xLGc9dDwwfHwwPT09dCYmMS90PDA/MTowO2Zvcih0PU1hdGguYWJzKHQpLGlzTmFOKHQpfHx0PT09MS8wPyhhPWlzTmFOKHQpPzE6MCxzPWYpOihzPU1hdGguZmxvb3IoTWF0aC5sb2codCkvTWF0aC5MTjIpLHQqKHU9TWF0aC5wb3coMiwtcykpPDEmJihzLS0sdSo9MiksMjw9KHQrPTE8PXMrbD9oL3U6aCpNYXRoLnBvdygyLDEtbCkpKnUmJihzKyssdS89MiksZjw9cytsPyhhPTAscz1mKToxPD1zK2w/KGE9KHQqdS0xKSpNYXRoLnBvdygyLGkpLHMrPWwpOihhPXQqTWF0aC5wb3coMixsLTEpKk1hdGgucG93KDIsaSkscz0wKSk7ODw9aTtlW24rcF09MjU1JmEscCs9ZCxhLz0yNTYsaS09OCk7Zm9yKHM9czw8aXxhLGMrPWk7MDxjO2VbbitwXT0yNTUmcyxwKz1kLHMvPTI1NixjLT04KTtlW24rcC1kXXw9MTI4Kmd9fSxmdW5jdGlvbihlLHQpe3ZhciBuPXt9LnRvU3RyaW5nO2UuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbihlKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PW4uY2FsbChlKX19LGZ1bmN0aW9uKHIsaSxlKXsoZnVuY3Rpb24oYil7dmFyIGUsdCxuO3Q9W10sdm9pZCAwPT09KG49XCJmdW5jdGlvblwiPT10eXBlb2YoZT1mdW5jdGlvbigpe3ZhciBlPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gbyhlKXt0aGlzLiRoZXg9ZX1vLnByb3RvdHlwZT17bGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuJGhleC5sZW5ndGgvMn0sdG9TdHJpbmc6ZnVuY3Rpb24oZSl7aWYoIWV8fFwiaGV4XCI9PT1lfHwxNj09PWUpcmV0dXJuIHRoaXMuJGhleDtpZihcInV0Zi04XCI9PT1lKXtmb3IodmFyIHQ9XCJcIixuPTA7bjx0aGlzLiRoZXgubGVuZ3RoO24rPTIpdCs9XCIlXCIrdGhpcy4kaGV4LnN1YnN0cmluZyhuLG4rMik7cmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudCh0KX1pZihcImxhdGluXCIhPT1lKXRocm93IG5ldyBFcnJvcihcIlVucmVjb2duaXNlZCBmb3JtYXQ6IFwiK2UpO2Zvcih2YXIgdD1bXSxuPTA7bjx0aGlzLiRoZXgubGVuZ3RoO24rPTIpdC5wdXNoKHBhcnNlSW50KHRoaXMuJGhleC5zdWJzdHJpbmcobixuKzIpLDE2KSk7cmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLHQpfX0sby5mcm9tTGF0aW5TdHJpbmc9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVwiXCIsbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgcj1lLmNoYXJDb2RlQXQobikudG9TdHJpbmcoMTYpOzE9PT1yLmxlbmd0aCYmKHI9XCIwXCIrciksdCs9cn1yZXR1cm4gbmV3IG8odCl9LG8uZnJvbVV0ZjhTdHJpbmc9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PWVuY29kZVVSSUNvbXBvbmVudChlKSxuPVwiXCIscj0wO3I8dC5sZW5ndGg7cisrKWlmKFwiJVwiPT09dC5jaGFyQXQocikpbis9dC5zdWJzdHJpbmcocisxLHIrMykscis9MjtlbHNle3ZhciBpPXQuY2hhckNvZGVBdChyKS50b1N0cmluZygxNik7aS5sZW5ndGg8MiYmKGk9XCIwXCIraSksbis9aX1yZXR1cm4gbmV3IG8obil9O3ZhciBzPVtdLGY9e30scj1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoZStcIiBub3QgaW1wbGVtZW50ZWRcIil9fTtmdW5jdGlvbiBlKCl7fWZ1bmN0aW9uIHQoKXt9ZnVuY3Rpb24gbChlLHQpe3ZhciBuPWUudmFsdWU7cmV0dXJuIG48MjQ/bjoyND09bj90LnJlYWRCeXRlKCk6MjU9PW4/dC5yZWFkVWludDE2KCk6MjY9PW4/dC5yZWFkVWludDMyKCk6Mjc9PW4/dC5yZWFkVWludDY0KCk6MzE9PW4/bnVsbDp2b2lkIHIoXCJBZGRpdGlvbmFsIGluZm86IFwiK24pKCl9ZnVuY3Rpb24gYShlLHQsbil7dmFyIHI9ZTw8NTt0PDI0P24ud3JpdGVCeXRlKHJ8dCk6dDwyNTY/KG4ud3JpdGVCeXRlKDI0fHIpLG4ud3JpdGVCeXRlKHQpKTp0PDY1NTM2PyhuLndyaXRlQnl0ZSgyNXxyKSxuLndyaXRlVWludDE2KHQpKTp0PDQyOTQ5NjcyOTY/KG4ud3JpdGVCeXRlKDI2fHIpLG4ud3JpdGVVaW50MzIodCkpOihuLndyaXRlQnl0ZSgyN3xyKSxuLndyaXRlVWludDY0KHQpKX1lLnByb3RvdHlwZT17cGVla0J5dGU6cihcInBlZWtCeXRlXCIpLHJlYWRCeXRlOnIoXCJyZWFkQnl0ZVwiKSxyZWFkQ2h1bms6cihcInJlYWRDaHVua1wiKSxyZWFkRmxvYXQxNjpmdW5jdGlvbigpe3ZhciBlPXRoaXMucmVhZFVpbnQxNigpLHQ9KDMyNzY3JmUpPj4xMCxuPTEwMjMmZSxyPTMyNzY4JmU7aWYoMzE9PXQpcmV0dXJuIDA9PW4/cj8tMS8wOjEvMDpOYU47dmFyIGk9dD9NYXRoLnBvdygyLHQtMjUpKigxMDI0K24pOk1hdGgucG93KDIsLTI0KSpuO3JldHVybiByPy1pOml9LHJlYWRGbG9hdDMyOmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5yZWFkVWludDMyKCksdD0oMjE0NzQ4MzY0NyZlKT4+MjMsbj04Mzg4NjA3JmUscj0yMTQ3NDgzNjQ4JmU7aWYoMjU1PT10KXJldHVybiAwPT1uP3I/LTEvMDoxLzA6TmFOO3ZhciBpPXQ/TWF0aC5wb3coMix0LTIzLTEyNykqKDgzODg2MDgrbik6TWF0aC5wb3coMiwtMTQ5KSpuO3JldHVybiByPy1pOml9LHJlYWRGbG9hdDY0OmZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5yZWFkVWludDMyKCksdD10aGlzLnJlYWRVaW50MzIoKSxuPWU+PjIwJjIwNDcscj00Mjk0OTY3Mjk2KigxMDQ4NTc1JmUpK3QsaT0yMTQ3NDgzNjQ4JmU7aWYoMjA0Nz09bilyZXR1cm4gMD09PXI/aT8tMS8wOjEvMDpOYU47dmFyIG89bj9NYXRoLnBvdygyLG4tNTItMTAyMykqKDQ1MDM1OTk2MjczNzA0OTYrcik6TWF0aC5wb3coMiwtMTA3NCkqcjtyZXR1cm4gaT8tbzpvfSxyZWFkVWludDE2OmZ1bmN0aW9uKCl7cmV0dXJuIDI1Nip0aGlzLnJlYWRCeXRlKCkrdGhpcy5yZWFkQnl0ZSgpfSxyZWFkVWludDMyOmZ1bmN0aW9uKCl7cmV0dXJuIDY1NTM2KnRoaXMucmVhZFVpbnQxNigpK3RoaXMucmVhZFVpbnQxNigpfSxyZWFkVWludDY0OmZ1bmN0aW9uKCl7cmV0dXJuIDQyOTQ5NjcyOTYqdGhpcy5yZWFkVWludDMyKCkrdGhpcy5yZWFkVWludDMyKCl9fSx0LnByb3RvdHlwZT17d3JpdGVCeXRlOnIoXCJ3cml0ZUJ5dGVcIikscmVzdWx0OnIoXCJyZXN1bHRcIiksd3JpdGVGbG9hdDE2OnIoXCJ3cml0ZUZsb2F0MTZcIiksd3JpdGVGbG9hdDMyOnIoXCJ3cml0ZUZsb2F0MzJcIiksd3JpdGVGbG9hdDY0OnIoXCJ3cml0ZUZsb2F0NjRcIiksd3JpdGVVaW50MTY6ZnVuY3Rpb24oZSl7dGhpcy53cml0ZUJ5dGUoZT4+OCYyNTUpLHRoaXMud3JpdGVCeXRlKDI1NSZlKX0sd3JpdGVVaW50MzI6ZnVuY3Rpb24oZSl7dGhpcy53cml0ZVVpbnQxNihlPj4xNiY2NTUzNSksdGhpcy53cml0ZVVpbnQxNig2NTUzNSZlKX0sd3JpdGVVaW50NjQ6ZnVuY3Rpb24oZSl7aWYoOTAwNzE5OTI1NDc0MDk5Mjw9ZXx8ZTw9LTkwMDcxOTkyNTQ3NDA5OTIpdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGVuY29kZSBVaW50NjQgb2Y6IFwiK2UrXCIgbWFnbml0dWRlIHRvIGJpZyAoZmxvYXRpbmcgcG9pbnQgZXJyb3JzKVwiKTt0aGlzLndyaXRlVWludDMyKE1hdGguZmxvb3IoZS80Mjk0OTY3Mjk2KSksdGhpcy53cml0ZVVpbnQzMihlJTQyOTQ5NjcyOTYpfSx3cml0ZVN0cmluZzpyKFwid3JpdGVTdHJpbmdcIiksY2FuV3JpdGVCaW5hcnk6ZnVuY3Rpb24oZSl7cmV0dXJuITF9LHdyaXRlQmluYXJ5OnIoXCJ3cml0ZUNodW5rXCIpfTt2YXIgaD1uZXcgRXJyb3I7ZnVuY3Rpb24gcChlKXt2YXIgdD1mdW5jdGlvbihlKXt2YXIgdD1lLnJlYWRCeXRlKCk7cmV0dXJue3R5cGU6dD4+NSx2YWx1ZTozMSZ0fX0oZSk7c3dpdGNoKHQudHlwZSl7Y2FzZSAwOnJldHVybiBsKHQsZSk7Y2FzZSAxOnJldHVybi0xLWwodCxlKTtjYXNlIDI6cmV0dXJuIGUucmVhZENodW5rKGwodCxlKSk7Y2FzZSAzOnZhciBuPWUucmVhZENodW5rKGwodCxlKSk7cmV0dXJuIG4udG9TdHJpbmcoXCJ1dGYtOFwiKTtjYXNlIDQ6Y2FzZSA1OnZhciByPWwodCxlKSxpPVtdO2lmKG51bGwhPT1yKXs1PT09dC50eXBlJiYocio9Mik7Zm9yKHZhciBvPTA7bzxyO28rKylpW29dPXAoZSl9ZWxzZSBmb3IodmFyIHM7KHM9cChlKSkhPT1oOylpLnB1c2gocyk7aWYoNSE9PXQudHlwZSlyZXR1cm4gaTtmb3IodmFyIGE9e30sbz0wO288aS5sZW5ndGg7bys9MilhW2lbb11dPWlbbysxXTtyZXR1cm4gYTtjYXNlIDY6dmFyIHU9bCh0LGUpLGM9Zlt1XSxpPXAoZSk7cmV0dXJuIGM/YyhpKTppO2Nhc2UgNzppZigyNT09PXQudmFsdWUpcmV0dXJuIGUucmVhZEZsb2F0MTYoKTtpZigyNj09PXQudmFsdWUpcmV0dXJuIGUucmVhZEZsb2F0MzIoKTtpZigyNz09PXQudmFsdWUpcmV0dXJuIGUucmVhZEZsb2F0NjQoKTtzd2l0Y2gobCh0LGUpKXtjYXNlIDIwOnJldHVybiExO2Nhc2UgMjE6cmV0dXJuITA7Y2FzZSAyMjpyZXR1cm4gbnVsbDtjYXNlIDIzOnJldHVybjtjYXNlIG51bGw6cmV0dXJuIGg7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGZpeGVkIHZhbHVlOiBcIit0LnZhbHVlKX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGhlYWRlcjogXCIrSlNPTi5zdHJpbmdpZnkodCkpfXRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZCB5ZXRcIil9ZnVuY3Rpb24gdShlLHQpe2Zvcih2YXIgbj0wO248cy5sZW5ndGg7bisrKXt2YXIgcj1zW25dLmZuKGUpO2lmKHZvaWQgMCE9PXIpcmV0dXJuIGEoNixzW25dLnRhZyx0KSx1KHIsdCl9aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS50b0NCT1ImJihlPWUudG9DQk9SKCkpLCExPT09ZSlhKDcsMjAsdCk7ZWxzZSBpZighMD09PWUpYSg3LDIxLHQpO2Vsc2UgaWYobnVsbD09PWUpYSg3LDIyLHQpO2Vsc2UgaWYodm9pZCAwPT09ZSlhKDcsMjMsdCk7ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgZSlNYXRoLmZsb29yKGUpPT09ZSYmZTw5MDA3MTk5MjU0NzQwOTkyJiYtOTAwNzE5OTI1NDc0MDk5MjxlP2U8MD9hKDEsLTEtZSx0KTphKDAsZSx0KTooZnVuY3Rpb24oZSx0LG4pe24ud3JpdGVCeXRlKGU8PDV8dCl9KDcsMjcsdCksdC53cml0ZUZsb2F0NjQoZSkpO2Vsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdC53cml0ZVN0cmluZyhlLGZ1bmN0aW9uKGUpe2EoMyxlLHQpfSk7ZWxzZSBpZih0LmNhbldyaXRlQmluYXJ5KGUpKXQud3JpdGVCaW5hcnkoZSxmdW5jdGlvbihlKXthKDIsZSx0KX0pO2Vsc2V7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBlbmNvZGluZyBub3Qgc3VwcG9ydGVkOiBcIitlKTtpZihnLmNvbmZpZy51c2VUb0pTT04mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGUudG9KU09OJiYoZT1lLnRvSlNPTigpKSxBcnJheS5pc0FycmF5KGUpKXthKDQsZS5sZW5ndGgsdCk7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspdShlW25dLHQpfWVsc2V7dmFyIGk9T2JqZWN0LmtleXMoZSk7YSg1LGkubGVuZ3RoLHQpO2Zvcih2YXIgbj0wO248aS5sZW5ndGg7bisrKXUoaVtuXSx0KSx1KGVbaVtuXV0sdCl9fX12YXIgYz1bXSxkPVtdLGc9e2NvbmZpZzp7dXNlVG9KU09OOiEwfSxhZGRXcml0ZXI6ZnVuY3Rpb24odCxuKXtcInN0cmluZ1wiPT10eXBlb2YgdD9kLnB1c2goZnVuY3Rpb24oZSl7aWYodD09PWUpcmV0dXJuIG4oZSl9KTpkLnB1c2godCl9LGFkZFJlYWRlcjpmdW5jdGlvbihuLHIpe1wic3RyaW5nXCI9PXR5cGVvZiBuP2MucHVzaChmdW5jdGlvbihlLHQpe2lmKG49PT10KXJldHVybiByKGUsdCl9KTpjLnB1c2gobil9LGVuY29kZTpmdW5jdGlvbihlLHQpe2Zvcih2YXIgbj0wO248ZC5sZW5ndGg7bisrKXt2YXIgcj1kW25dLGk9cih0KTtpZihpKXJldHVybiB1KGUsaSksaS5yZXN1bHQoKX10aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBvdXRwdXQgZm9ybWF0OiBcIit0KX0sZGVjb2RlOmZ1bmN0aW9uKGUsdCl7Zm9yKHZhciBuPTA7bjxjLmxlbmd0aDtuKyspe3ZhciByPWNbbl0saT1yKGUsdCk7aWYoaSlyZXR1cm4gcChpKX10aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBpbnB1dCBmb3JtYXQ6IFwiK3QpfSxhZGRTZW1hbnRpY0VuY29kZTpmdW5jdGlvbihlLHQpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlfHxlJTEhPTB8fGU8MCl0aHJvdyBuZXcgRXJyb3IoXCJUYWcgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJcIik7cmV0dXJuIHMucHVzaCh7dGFnOmUsZm46dH0pLHRoaXN9LGFkZFNlbWFudGljRGVjb2RlOmZ1bmN0aW9uKGUsdCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGV8fGUlMSE9MHx8ZTwwKXRocm93IG5ldyBFcnJvcihcIlRhZyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlclwiKTtyZXR1cm4gZltlXT10LHRoaXN9LFJlYWRlcjplLFdyaXRlcjp0fTtmdW5jdGlvbiBpKGUpe3RoaXMuYnVmZmVyPWUsdGhpcy5wb3M9MH1mdW5jdGlvbiBuKGUpe3RoaXMuYnl0ZUxlbmd0aD0wLHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aD0xNjM4NCx0aGlzLmxhdGVzdEJ1ZmZlcj1iLmFsbG9jKHRoaXMuZGVmYXVsdEJ1ZmZlckxlbmd0aCksdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQ9MCx0aGlzLmNvbXBsZXRlQnVmZmVycz1bXSx0aGlzLnN0cmluZ0Zvcm1hdD1lfWZ1bmN0aW9uIHkoZSl7dGhpcy5oZXg9ZSx0aGlzLnBvcz0wfWZ1bmN0aW9uIHYoZSl7dGhpcy4kaGV4PVwiXCIsdGhpcy5maW5hbEZvcm1hdD1lfHxcImhleFwifXJldHVybihpLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSkucGVla0J5dGU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5wb3NdfSxpLnByb3RvdHlwZS5yZWFkQnl0ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1ZmZlclt0aGlzLnBvcysrXX0saS5wcm90b3R5cGUucmVhZFVpbnQxNj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuYnVmZmVyLnJlYWRVSW50MTZCRSh0aGlzLnBvcyk7cmV0dXJuIHRoaXMucG9zKz0yLGV9LGkucHJvdG90eXBlLnJlYWRVaW50MzI9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmJ1ZmZlci5yZWFkVUludDMyQkUodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9NCxlfSxpLnByb3RvdHlwZS5yZWFkRmxvYXQzMj1mdW5jdGlvbigpe3ZhciBlPXRoaXMuYnVmZmVyLnJlYWRGbG9hdEJFKHRoaXMucG9zKTtyZXR1cm4gdGhpcy5wb3MrPTQsZX0saS5wcm90b3R5cGUucmVhZEZsb2F0NjQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmJ1ZmZlci5yZWFkRG91YmxlQkUodGhpcy5wb3MpO3JldHVybiB0aGlzLnBvcys9OCxlfSxpLnByb3RvdHlwZS5yZWFkQ2h1bms9ZnVuY3Rpb24oZSl7dmFyIHQ9Yi5hbGxvYyhlKTtyZXR1cm4gdGhpcy5idWZmZXIuY29weSh0LDAsdGhpcy5wb3MsdGhpcy5wb3MrPWUpLHR9LChuLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHQucHJvdG90eXBlKSkud3JpdGVCeXRlPWZ1bmN0aW9uKGUpe3RoaXMubGF0ZXN0QnVmZmVyW3RoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0KytdPWUsdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQ+PXRoaXMubGF0ZXN0QnVmZmVyLmxlbmd0aCYmKHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2godGhpcy5sYXRlc3RCdWZmZXIpLHRoaXMubGF0ZXN0QnVmZmVyPWIuYWxsb2ModGhpcy5kZWZhdWx0QnVmZmVyTGVuZ3RoKSx0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldD0wKSx0aGlzLmJ5dGVMZW5ndGgrK30sbi5wcm90b3R5cGUud3JpdGVGbG9hdDMyPWZ1bmN0aW9uKGUpe3ZhciB0PWIuYWxsb2MoNCk7dC53cml0ZUZsb2F0QkUoZSwwKSx0aGlzLndyaXRlQnVmZmVyKHQpfSxuLnByb3RvdHlwZS53cml0ZUZsb2F0NjQ9ZnVuY3Rpb24oZSl7dmFyIHQ9Yi5hbGxvYyg4KTt0LndyaXRlRG91YmxlQkUoZSwwKSx0aGlzLndyaXRlQnVmZmVyKHQpfSxuLnByb3RvdHlwZS53cml0ZVN0cmluZz1mdW5jdGlvbihlLHQpe3ZhciBuPWIuZnJvbShlLFwidXRmLThcIik7dChuLmxlbmd0aCksdGhpcy53cml0ZUJ1ZmZlcihuKX0sbi5wcm90b3R5cGUuY2FuV3JpdGVCaW5hcnk9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBifSxuLnByb3RvdHlwZS53cml0ZUJpbmFyeT1mdW5jdGlvbihlLHQpe3QoZS5sZW5ndGgpLHRoaXMud3JpdGVCdWZmZXIoZSl9LG4ucHJvdG90eXBlLndyaXRlQnVmZmVyPWZ1bmN0aW9uKGUpe2lmKCEoZSBpbnN0YW5jZW9mIGIpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJCdWZmZXJXcml0ZXIgb25seSBhY2NlcHRzIEJ1ZmZlcnNcIik7dGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQ/dGhpcy5sYXRlc3RCdWZmZXIubGVuZ3RoLXRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0Pj1lLmxlbmd0aD8oZS5jb3B5KHRoaXMubGF0ZXN0QnVmZmVyLHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0KSx0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCs9ZS5sZW5ndGgsdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQ+PXRoaXMubGF0ZXN0QnVmZmVyLmxlbmd0aCYmKHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2godGhpcy5sYXRlc3RCdWZmZXIpLHRoaXMubGF0ZXN0QnVmZmVyPWIuYWxsb2ModGhpcy5kZWZhdWx0QnVmZmVyTGVuZ3RoKSx0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldD0wKSk6KHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2godGhpcy5sYXRlc3RCdWZmZXIuc2xpY2UoMCx0aGlzLmxhdGVzdEJ1ZmZlck9mZnNldCkpLHRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2goZSksdGhpcy5sYXRlc3RCdWZmZXI9Yi5hbGxvYyh0aGlzLmRlZmF1bHRCdWZmZXJMZW5ndGgpLHRoaXMubGF0ZXN0QnVmZmVyT2Zmc2V0PTApOnRoaXMuY29tcGxldGVCdWZmZXJzLnB1c2goZSksdGhpcy5ieXRlTGVuZ3RoKz1lLmxlbmd0aH0sbi5wcm90b3R5cGUucmVzdWx0PWZ1bmN0aW9uKCl7Zm9yKHZhciBlPWIuYWxsb2ModGhpcy5ieXRlTGVuZ3RoKSx0PTAsbj0wO248dGhpcy5jb21wbGV0ZUJ1ZmZlcnMubGVuZ3RoO24rKyl7dmFyIHI9dGhpcy5jb21wbGV0ZUJ1ZmZlcnNbbl07ci5jb3B5KGUsdCwwLHIubGVuZ3RoKSx0Kz1yLmxlbmd0aH1yZXR1cm4gdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQmJnRoaXMubGF0ZXN0QnVmZmVyLmNvcHkoZSx0LDAsdGhpcy5sYXRlc3RCdWZmZXJPZmZzZXQpLHRoaXMuc3RyaW5nRm9ybWF0P2UudG9TdHJpbmcodGhpcy5zdHJpbmdGb3JtYXQpOmV9LFwiZnVuY3Rpb25cIj09dHlwZW9mIGImJihnLmFkZFJlYWRlcihmdW5jdGlvbihlLHQpe2lmKGUgaW5zdGFuY2VvZiBiKXJldHVybiBuZXcgaShlKTtpZihcImhleFwiPT09dHx8XCJiYXNlNjRcIj09PXQpe3ZhciBuPWIuZnJvbShlLHQpO3JldHVybiBuZXcgaShuKX19KSxnLmFkZFdyaXRlcihmdW5jdGlvbihlKXtyZXR1cm4gZSYmXCJidWZmZXJcIiE9PWU/XCJoZXhcIj09PWV8fFwiYmFzZTY0XCI9PT1lP25ldyBuKGUpOnZvaWQgMDpuZXcgbn0pKSwoeS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSkpLnBlZWtCeXRlPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5oZXguc3Vic3RyaW5nKHRoaXMucG9zLDIpO3JldHVybiBwYXJzZUludChlLDE2KX0seS5wcm90b3R5cGUucmVhZEJ5dGU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLmhleC5zdWJzdHJpbmcodGhpcy5wb3MsdGhpcy5wb3MrMik7cmV0dXJuIHRoaXMucG9zKz0yLHBhcnNlSW50KGUsMTYpfSx5LnByb3RvdHlwZS5yZWFkQ2h1bms9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5oZXguc3Vic3RyaW5nKHRoaXMucG9zLHRoaXMucG9zKzIqZSk7cmV0dXJuIHRoaXMucG9zKz0yKmUsXCJmdW5jdGlvblwiPT10eXBlb2YgYj9iLmZyb20odCxcImhleFwiKTpuZXcgbyh0KX0sKHYucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpKS53cml0ZUJ5dGU9ZnVuY3Rpb24oZSl7aWYoZTwwfHwyNTU8ZSl0aHJvdyBuZXcgRXJyb3IoXCJCeXRlIHZhbHVlIG91dCBvZiByYW5nZTogXCIrZSk7dmFyIHQ9ZS50b1N0cmluZygxNik7MT09dC5sZW5ndGgmJih0PVwiMFwiK3QpLHRoaXMuJGhleCs9dH0sdi5wcm90b3R5cGUuY2FuV3JpdGVCaW5hcnk9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBvfHxcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiZlIGluc3RhbmNlb2YgYn0sdi5wcm90b3R5cGUud3JpdGVCaW5hcnk9ZnVuY3Rpb24oZSx0KXtpZihlIGluc3RhbmNlb2Ygbyl0KGUubGVuZ3RoKCkpLHRoaXMuJGhleCs9ZS4kaGV4O2Vsc2V7aWYoIShcImZ1bmN0aW9uXCI9PXR5cGVvZiBiJiZlIGluc3RhbmNlb2YgYikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkhleFdyaXRlciBvbmx5IGFjY2VwdHMgQmluYXJ5SGV4IG9yIEJ1ZmZlcnNcIik7dChlLmxlbmd0aCksdGhpcy4kaGV4Kz1lLnRvU3RyaW5nKFwiaGV4XCIpfX0sdi5wcm90b3R5cGUucmVzdWx0PWZ1bmN0aW9uKCl7cmV0dXJuXCJidWZmZXJcIj09PXRoaXMuZmluYWxGb3JtYXQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGI/Yi5mcm9tKHRoaXMuJGhleCxcImhleFwiKTpuZXcgbyh0aGlzLiRoZXgpLnRvU3RyaW5nKHRoaXMuZmluYWxGb3JtYXQpfSx2LnByb3RvdHlwZS53cml0ZVN0cmluZz1mdW5jdGlvbihlLHQpe3ZhciBuPW8uZnJvbVV0ZjhTdHJpbmcoZSk7dChuLmxlbmd0aCgpKSx0aGlzLiRoZXgrPW4uJGhleH0sZy5hZGRSZWFkZXIoZnVuY3Rpb24oZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIG98fGUuJGhleD9uZXcgeShlLiRoZXgpOlwiaGV4XCI9PT10P25ldyB5KGUpOnZvaWQgMH0pLGcuYWRkV3JpdGVyKGZ1bmN0aW9uKGUpe2lmKFwiaGV4XCI9PT1lKXJldHVybiBuZXcgdn0pLGd9KCk7cmV0dXJuIGUuYWRkU2VtYW50aWNFbmNvZGUoMCxmdW5jdGlvbihlKXtpZihlIGluc3RhbmNlb2YgRGF0ZSlyZXR1cm4gZS50b0lTT1N0cmluZygpfSkuYWRkU2VtYW50aWNEZWNvZGUoMCxmdW5jdGlvbihlKXtyZXR1cm4gbmV3IERhdGUoZSl9KS5hZGRTZW1hbnRpY0RlY29kZSgxLGZ1bmN0aW9uKGUpe3JldHVybiBuZXcgRGF0ZShlKX0pLGV9KT9lLmFwcGx5KGksdCk6ZSl8fChyLmV4cG9ydHM9bil9KS5jYWxsKHRoaXMsZSg5KS5CdWZmZXIpfSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdC5nZXQ9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPW8uZGVmYXVsdC5nZXQodGhpcy5nZXRTdGFuZGFyZE9yaWdpbigpK3QudXJsKS5zZXQodC5oZWFkZXJzKS5xdWVyeShlKTtyZXR1cm4gcy5jYWxsKHRoaXMscix0LG4pfSx0LnBvc3Q9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9by5kZWZhdWx0LnBvc3QodGhpcy5nZXRTdGFuZGFyZE9yaWdpbigpK24udXJsKS5xdWVyeShlKS5zZXQobi5oZWFkZXJzKS5zZW5kKHQpO3JldHVybiBzLmNhbGwodGhpcyxpLG4scil9LHQucGF0Y2g9ZnVuY3Rpb24oZSx0LG4scil7dmFyIGk9by5kZWZhdWx0LnBhdGNoKHRoaXMuZ2V0U3RhbmRhcmRPcmlnaW4oKStuLnVybCkucXVlcnkoZSkuc2V0KG4uaGVhZGVycykuc2VuZCh0KTtyZXR1cm4gcy5jYWxsKHRoaXMsaSxuLHIpfSx0LmRlbD1mdW5jdGlvbihlLHQsbil7dmFyIHI9by5kZWZhdWx0LmRlbGV0ZSh0aGlzLmdldFN0YW5kYXJkT3JpZ2luKCkrdC51cmwpLnNldCh0LmhlYWRlcnMpLnF1ZXJ5KGUpO3JldHVybiBzLmNhbGwodGhpcyxyLHQsbil9O3ZhciByLG89KHI9big3NikpJiZyLl9fZXNNb2R1bGU/cjp7ZGVmYXVsdDpyfTtuKDApO2Z1bmN0aW9uIGEocil7dmFyIGk9KG5ldyBEYXRlKS5nZXRUaW1lKCksZT0obmV3IERhdGUpLnRvSVNPU3RyaW5nKCksbz1jb25zb2xlJiZjb25zb2xlLmxvZz9jb25zb2xlOndpbmRvdyYmd2luZG93LmNvbnNvbGUmJndpbmRvdy5jb25zb2xlLmxvZz93aW5kb3cuY29uc29sZTpjb25zb2xlO28ubG9nKFwiPDw8PDxcIiksby5sb2coXCJbXCIuY29uY2F0KGUsXCJdXCIpLFwiXFxuXCIsci51cmwsXCJcXG5cIixyLnFzKSxvLmxvZyhcIi0tLS0tXCIpLHIub24oXCJyZXNwb25zZVwiLGZ1bmN0aW9uKGUpe3ZhciB0PShuZXcgRGF0ZSkuZ2V0VGltZSgpLWksbj0obmV3IERhdGUpLnRvSVNPU3RyaW5nKCk7by5sb2coXCI+Pj4+Pj5cIiksby5sb2coXCJbXCIuY29uY2F0KG4sXCIgLyBcIikuY29uY2F0KHQsXCJdXCIpLFwiXFxuXCIsci51cmwsXCJcXG5cIixyLnFzLFwiXFxuXCIsZS50ZXh0KSxvLmxvZyhcIi0tLS0tXCIpfSl9ZnVuY3Rpb24gcyhlLGksbyl7dmFyIHM9dGhpcztyZXR1cm4gdGhpcy5fY29uZmlnLmxvZ1ZlcmJvc2l0eSYmKGU9ZS51c2UoYSkpLHRoaXMuX2NvbmZpZy5wcm94eSYmdGhpcy5fbW9kdWxlcy5wcm94eSYmKGU9dGhpcy5fbW9kdWxlcy5wcm94eS5jYWxsKHRoaXMsZSkpLHRoaXMuX2NvbmZpZy5rZWVwQWxpdmUmJnRoaXMuX21vZHVsZXMua2VlcEFsaXZlJiYoZT10aGlzLl9tb2R1bGVzLmtlZXBBbGl2ZShlKSksZS50aW1lb3V0KGkudGltZW91dCkuZW5kKGZ1bmN0aW9uKHQsbil7dmFyIGUscj17fTtpZihyLmVycm9yPW51bGwhPT10LHIub3BlcmF0aW9uPWkub3BlcmF0aW9uLG4mJm4uc3RhdHVzJiYoci5zdGF0dXNDb2RlPW4uc3RhdHVzKSx0KXtpZih0LnJlc3BvbnNlJiZ0LnJlc3BvbnNlLnRleHQmJiFzLl9jb25maWcubG9nVmVyYm9zaXR5KXRyeXtyLmVycm9yRGF0YT1KU09OLnBhcnNlKHQucmVzcG9uc2UudGV4dCl9Y2F0Y2goZSl7ci5lcnJvckRhdGE9dH1lbHNlIHIuZXJyb3JEYXRhPXQ7cmV0dXJuIHIuY2F0ZWdvcnk9cy5fZGV0ZWN0RXJyb3JDYXRlZ29yeSh0KSxvKHIsbnVsbCl9dHJ5e2U9SlNPTi5wYXJzZShuLnRleHQpfWNhdGNoKGUpe3JldHVybiByLmVycm9yRGF0YT1uLHIuZXJyb3I9ITAsbyhyLG51bGwpfXJldHVybiBlLmVycm9yJiYxPT09ZS5lcnJvciYmZS5zdGF0dXMmJmUubWVzc2FnZSYmZS5zZXJ2aWNlPyhyLmVycm9yRGF0YT1lLHIuc3RhdHVzQ29kZT1lLnN0YXR1cyxyLmVycm9yPSEwLHIuY2F0ZWdvcnk9cy5fZGV0ZWN0RXJyb3JDYXRlZ29yeShyKSxvKHIsbnVsbCkpOihlLmVycm9yJiZlLmVycm9yLm1lc3NhZ2UmJihyLmVycm9yRGF0YT1lLmVycm9yKSxvKHIsZSkpfSl9fSxmdW5jdGlvbihlLG4sdCl7dmFyIHI7cj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzpcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOihjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpLHRoaXMpO3ZhciBpPXQoNzcpLG89dCg3OCkscz10KDEwKSxhPXQoNzkpLHU9dCg4MSk7ZnVuY3Rpb24gYygpe312YXIgZj1uPWUuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/bmV3IG4uUmVxdWVzdChcIkdFVFwiLGUpLmVuZCh0KToxPT1hcmd1bWVudHMubGVuZ3RoP25ldyBuLlJlcXVlc3QoXCJHRVRcIixlKTpuZXcgbi5SZXF1ZXN0KGUsdCl9O24uUmVxdWVzdD12LGYuZ2V0WEhSPWZ1bmN0aW9uKCl7aWYoISghci5YTUxIdHRwUmVxdWVzdHx8ci5sb2NhdGlvbiYmXCJmaWxlOlwiPT1yLmxvY2F0aW9uLnByb3RvY29sJiZyLkFjdGl2ZVhPYmplY3QpKXJldHVybiBuZXcgWE1MSHR0cFJlcXVlc3Q7dHJ5e3JldHVybiBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxIVFRQXCIpfWNhdGNoKGUpe310cnl7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFAuNi4wXCIpfWNhdGNoKGUpe310cnl7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFAuMy4wXCIpfWNhdGNoKGUpe310cnl7cmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KFwiTXN4bWwyLlhNTEhUVFBcIil9Y2F0Y2goZSl7fXRocm93IEVycm9yKFwiQnJvd3Nlci1vbmx5IHZlcnNpb24gb2Ygc3VwZXJhZ2VudCBjb3VsZCBub3QgZmluZCBYSFJcIil9O3ZhciBsPVwiXCIudHJpbT9mdW5jdGlvbihlKXtyZXR1cm4gZS50cmltKCl9OmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoLyheXFxzKnxcXHMqJCkvZyxcIlwiKX07ZnVuY3Rpb24gaChlKXtpZighcyhlKSlyZXR1cm4gZTt2YXIgdD1bXTtmb3IodmFyIG4gaW4gZSlwKHQsbixlW25dKTtyZXR1cm4gdC5qb2luKFwiJlwiKX1mdW5jdGlvbiBwKHQsbixlKXtpZihudWxsIT1lKWlmKEFycmF5LmlzQXJyYXkoZSkpZS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3AodCxuLGUpfSk7ZWxzZSBpZihzKGUpKWZvcih2YXIgciBpbiBlKXAodCxuK1wiW1wiK3IrXCJdXCIsZVtyXSk7ZWxzZSB0LnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KG4pK1wiPVwiK2VuY29kZVVSSUNvbXBvbmVudChlKSk7ZWxzZSBudWxsPT09ZSYmdC5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChuKSl9ZnVuY3Rpb24gZChlKXtmb3IodmFyIHQsbixyPXt9LGk9ZS5zcGxpdChcIiZcIiksbz0wLHM9aS5sZW5ndGg7bzxzOysrbyktMT09KG49KHQ9aVtvXSkuaW5kZXhPZihcIj1cIikpP3JbZGVjb2RlVVJJQ29tcG9uZW50KHQpXT1cIlwiOnJbZGVjb2RlVVJJQ29tcG9uZW50KHQuc2xpY2UoMCxuKSldPWRlY29kZVVSSUNvbXBvbmVudCh0LnNsaWNlKG4rMSkpO3JldHVybiByfWZ1bmN0aW9uIGcoZSl7cmV0dXJuL1tcXC8rXWpzb24oJHxbXi1cXHddKS8udGVzdChlKX1mdW5jdGlvbiB5KGUpe3RoaXMucmVxPWUsdGhpcy54aHI9dGhpcy5yZXEueGhyLHRoaXMudGV4dD1cIkhFQURcIiE9dGhpcy5yZXEubWV0aG9kJiYoXCJcIj09PXRoaXMueGhyLnJlc3BvbnNlVHlwZXx8XCJ0ZXh0XCI9PT10aGlzLnhoci5yZXNwb25zZVR5cGUpfHx2b2lkIDA9PT10aGlzLnhoci5yZXNwb25zZVR5cGU/dGhpcy54aHIucmVzcG9uc2VUZXh0Om51bGwsdGhpcy5zdGF0dXNUZXh0PXRoaXMucmVxLnhoci5zdGF0dXNUZXh0O3ZhciB0PXRoaXMueGhyLnN0YXR1czsxMjIzPT09dCYmKHQ9MjA0KSx0aGlzLl9zZXRTdGF0dXNQcm9wZXJ0aWVzKHQpLHRoaXMuaGVhZGVyPXRoaXMuaGVhZGVycz1mdW5jdGlvbihlKXtmb3IodmFyIHQsbixyLGksbz1lLnNwbGl0KC9cXHI/XFxuLykscz17fSxhPTAsdT1vLmxlbmd0aDthPHU7KythKS0xIT09KHQ9KG49b1thXSkuaW5kZXhPZihcIjpcIikpJiYocj1uLnNsaWNlKDAsdCkudG9Mb3dlckNhc2UoKSxpPWwobi5zbGljZSh0KzEpKSxzW3JdPWkpO3JldHVybiBzfSh0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSksdGhpcy5oZWFkZXJbXCJjb250ZW50LXR5cGVcIl09dGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJjb250ZW50LXR5cGVcIiksdGhpcy5fc2V0SGVhZGVyUHJvcGVydGllcyh0aGlzLmhlYWRlciksbnVsbD09PXRoaXMudGV4dCYmZS5fcmVzcG9uc2VUeXBlP3RoaXMuYm9keT10aGlzLnhoci5yZXNwb25zZTp0aGlzLmJvZHk9XCJIRUFEXCIhPXRoaXMucmVxLm1ldGhvZD90aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0P3RoaXMudGV4dDp0aGlzLnhoci5yZXNwb25zZSk6bnVsbH1mdW5jdGlvbiB2KGUsdCl7dmFyIHI9dGhpczt0aGlzLl9xdWVyeT10aGlzLl9xdWVyeXx8W10sdGhpcy5tZXRob2Q9ZSx0aGlzLnVybD10LHRoaXMuaGVhZGVyPXt9LHRoaXMuX2hlYWRlcj17fSx0aGlzLm9uKFwiZW5kXCIsZnVuY3Rpb24oKXt2YXIgdCxuPW51bGwsZT1udWxsO3RyeXtlPW5ldyB5KHIpfWNhdGNoKGUpe3JldHVybihuPW5ldyBFcnJvcihcIlBhcnNlciBpcyB1bmFibGUgdG8gcGFyc2UgdGhlIHJlc3BvbnNlXCIpKS5wYXJzZT0hMCxuLm9yaWdpbmFsPWUsci54aHI/KG4ucmF3UmVzcG9uc2U9dm9pZCAwPT09ci54aHIucmVzcG9uc2VUeXBlP3IueGhyLnJlc3BvbnNlVGV4dDpyLnhoci5yZXNwb25zZSxuLnN0YXR1cz1yLnhoci5zdGF0dXM/ci54aHIuc3RhdHVzOm51bGwsbi5zdGF0dXNDb2RlPW4uc3RhdHVzKToobi5yYXdSZXNwb25zZT1udWxsLG4uc3RhdHVzPW51bGwpLHIuY2FsbGJhY2sobil9ci5lbWl0KFwicmVzcG9uc2VcIixlKTt0cnl7ci5faXNSZXNwb25zZU9LKGUpfHwodD1uZXcgRXJyb3IoZS5zdGF0dXNUZXh0fHxcIlVuc3VjY2Vzc2Z1bCBIVFRQIHJlc3BvbnNlXCIpKX1jYXRjaChlKXt0PWV9dD8odC5vcmlnaW5hbD1uLHQucmVzcG9uc2U9ZSx0LnN0YXR1cz1lLnN0YXR1cyxyLmNhbGxiYWNrKHQsZSkpOnIuY2FsbGJhY2sobnVsbCxlKX0pfWZ1bmN0aW9uIGIoZSx0LG4pe3ZhciByPWYoXCJERUxFVEVcIixlKTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobj10LHQ9bnVsbCksdCYmci5zZW5kKHQpLG4mJnIuZW5kKG4pLHJ9Zi5zZXJpYWxpemVPYmplY3Q9aCxmLnBhcnNlU3RyaW5nPWQsZi50eXBlcz17aHRtbDpcInRleHQvaHRtbFwiLGpzb246XCJhcHBsaWNhdGlvbi9qc29uXCIseG1sOlwidGV4dC94bWxcIix1cmxlbmNvZGVkOlwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIsZm9ybTpcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFwiZm9ybS1kYXRhXCI6XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIn0sZi5zZXJpYWxpemU9e1wiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI6aCxcImFwcGxpY2F0aW9uL2pzb25cIjpKU09OLnN0cmluZ2lmeX0sZi5wYXJzZT17XCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIjpkLFwiYXBwbGljYXRpb24vanNvblwiOkpTT04ucGFyc2V9LGEoeS5wcm90b3R5cGUpLHkucHJvdG90eXBlLl9wYXJzZUJvZHk9ZnVuY3Rpb24oZSl7dmFyIHQ9Zi5wYXJzZVt0aGlzLnR5cGVdO3JldHVybiB0aGlzLnJlcS5fcGFyc2VyP3RoaXMucmVxLl9wYXJzZXIodGhpcyxlKTooIXQmJmcodGhpcy50eXBlKSYmKHQ9Zi5wYXJzZVtcImFwcGxpY2F0aW9uL2pzb25cIl0pLHQmJmUmJihlLmxlbmd0aHx8ZSBpbnN0YW5jZW9mIE9iamVjdCk/dChlKTpudWxsKX0seS5wcm90b3R5cGUudG9FcnJvcj1mdW5jdGlvbigpe3ZhciBlPXRoaXMucmVxLHQ9ZS5tZXRob2Qsbj1lLnVybCxyPVwiY2Fubm90IFwiK3QrXCIgXCIrbitcIiAoXCIrdGhpcy5zdGF0dXMrXCIpXCIsaT1uZXcgRXJyb3Iocik7cmV0dXJuIGkuc3RhdHVzPXRoaXMuc3RhdHVzLGkubWV0aG9kPXQsaS51cmw9bixpfSxmLlJlc3BvbnNlPXksaSh2LnByb3RvdHlwZSksbyh2LnByb3RvdHlwZSksdi5wcm90b3R5cGUudHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5zZXQoXCJDb250ZW50LVR5cGVcIixmLnR5cGVzW2VdfHxlKSx0aGlzfSx2LnByb3RvdHlwZS5hY2NlcHQ9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuc2V0KFwiQWNjZXB0XCIsZi50eXBlc1tlXXx8ZSksdGhpc30sdi5wcm90b3R5cGUuYXV0aD1mdW5jdGlvbihlLHQsbil7MT09PWFyZ3VtZW50cy5sZW5ndGgmJih0PVwiXCIpLFwib2JqZWN0XCI9PXR5cGVvZiB0JiZudWxsIT09dCYmKG49dCx0PVwiXCIpLG49bnx8e3R5cGU6XCJmdW5jdGlvblwiPT10eXBlb2YgYnRvYT9cImJhc2ljXCI6XCJhdXRvXCJ9O3JldHVybiB0aGlzLl9hdXRoKGUsdCxuLGZ1bmN0aW9uKGUpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGJ0b2EpcmV0dXJuIGJ0b2EoZSk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSBiYXNpYyBhdXRoLCBidG9hIGlzIG5vdCBhIGZ1bmN0aW9uXCIpfSl9LHYucHJvdG90eXBlLnF1ZXJ5PWZ1bmN0aW9uKGUpe3JldHVyblwic3RyaW5nXCIhPXR5cGVvZiBlJiYoZT1oKGUpKSxlJiZ0aGlzLl9xdWVyeS5wdXNoKGUpLHRoaXN9LHYucHJvdG90eXBlLmF0dGFjaD1mdW5jdGlvbihlLHQsbil7aWYodCl7aWYodGhpcy5fZGF0YSl0aHJvdyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTt0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChlLHQsbnx8dC5uYW1lKX1yZXR1cm4gdGhpc30sdi5wcm90b3R5cGUuX2dldEZvcm1EYXRhPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2Zvcm1EYXRhfHwodGhpcy5fZm9ybURhdGE9bmV3IHIuRm9ybURhdGEpLHRoaXMuX2Zvcm1EYXRhfSx2LnByb3RvdHlwZS5jYWxsYmFjaz1mdW5jdGlvbihlLHQpe2lmKHRoaXMuX3Nob3VsZFJldHJ5KGUsdCkpcmV0dXJuIHRoaXMuX3JldHJ5KCk7dmFyIG49dGhpcy5fY2FsbGJhY2s7dGhpcy5jbGVhclRpbWVvdXQoKSxlJiYodGhpcy5fbWF4UmV0cmllcyYmKGUucmV0cmllcz10aGlzLl9yZXRyaWVzLTEpLHRoaXMuZW1pdChcImVycm9yXCIsZSkpLG4oZSx0KX0sdi5wcm90b3R5cGUuY3Jvc3NEb21haW5FcnJvcj1mdW5jdGlvbigpe3ZhciBlPW5ldyBFcnJvcihcIlJlcXVlc3QgaGFzIGJlZW4gdGVybWluYXRlZFxcblBvc3NpYmxlIGNhdXNlczogdGhlIG5ldHdvcmsgaXMgb2ZmbGluZSwgT3JpZ2luIGlzIG5vdCBhbGxvd2VkIGJ5IEFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbiwgdGhlIHBhZ2UgaXMgYmVpbmcgdW5sb2FkZWQsIGV0Yy5cIik7ZS5jcm9zc0RvbWFpbj0hMCxlLnN0YXR1cz10aGlzLnN0YXR1cyxlLm1ldGhvZD10aGlzLm1ldGhvZCxlLnVybD10aGlzLnVybCx0aGlzLmNhbGxiYWNrKGUpfSx2LnByb3RvdHlwZS5idWZmZXI9di5wcm90b3R5cGUuY2E9di5wcm90b3R5cGUuYWdlbnQ9ZnVuY3Rpb24oKXtyZXR1cm4gY29uc29sZS53YXJuKFwiVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpLHRoaXN9LHYucHJvdG90eXBlLnBpcGU9di5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24oKXt0aHJvdyBFcnJvcihcIlN0cmVhbWluZyBpcyBub3Qgc3VwcG9ydGVkIGluIGJyb3dzZXIgdmVyc2lvbiBvZiBzdXBlcmFnZW50XCIpfSx2LnByb3RvdHlwZS5faXNIb3N0PWZ1bmN0aW9uKGUpe3JldHVybiBlJiZcIm9iamVjdFwiPT10eXBlb2YgZSYmIUFycmF5LmlzQXJyYXkoZSkmJlwiW29iamVjdCBPYmplY3RdXCIhPT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZSl9LHYucHJvdG90eXBlLmVuZD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fZW5kQ2FsbGVkJiZjb25zb2xlLndhcm4oXCJXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnRcIiksdGhpcy5fZW5kQ2FsbGVkPSEwLHRoaXMuX2NhbGxiYWNrPWV8fGMsdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpLHRoaXMuX2VuZCgpfSx2LnByb3RvdHlwZS5fZW5kPWZ1bmN0aW9uKCl7dmFyIG49dGhpcyxyPXRoaXMueGhyPWYuZ2V0WEhSKCksZT10aGlzLl9mb3JtRGF0YXx8dGhpcy5fZGF0YTt0aGlzLl9zZXRUaW1lb3V0cygpLHIub25yZWFkeXN0YXRlY2hhbmdlPWZ1bmN0aW9uKCl7dmFyIGU9ci5yZWFkeVN0YXRlO2lmKDI8PWUmJm4uX3Jlc3BvbnNlVGltZW91dFRpbWVyJiZjbGVhclRpbWVvdXQobi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpLDQ9PWUpe3ZhciB0O3RyeXt0PXIuc3RhdHVzfWNhdGNoKGUpe3Q9MH1pZighdCl7aWYobi50aW1lZG91dHx8bi5fYWJvcnRlZClyZXR1cm47cmV0dXJuIG4uY3Jvc3NEb21haW5FcnJvcigpfW4uZW1pdChcImVuZFwiKX19O2Z1bmN0aW9uIHQoZSx0KXswPHQudG90YWwmJih0LnBlcmNlbnQ9dC5sb2FkZWQvdC50b3RhbCoxMDApLHQuZGlyZWN0aW9uPWUsbi5lbWl0KFwicHJvZ3Jlc3NcIix0KX1pZih0aGlzLmhhc0xpc3RlbmVycyhcInByb2dyZXNzXCIpKXRyeXtyLm9ucHJvZ3Jlc3M9dC5iaW5kKG51bGwsXCJkb3dubG9hZFwiKSxyLnVwbG9hZCYmKHIudXBsb2FkLm9ucHJvZ3Jlc3M9dC5iaW5kKG51bGwsXCJ1cGxvYWRcIikpfWNhdGNoKGUpe310cnl7dGhpcy51c2VybmFtZSYmdGhpcy5wYXNzd29yZD9yLm9wZW4odGhpcy5tZXRob2QsdGhpcy51cmwsITAsdGhpcy51c2VybmFtZSx0aGlzLnBhc3N3b3JkKTpyLm9wZW4odGhpcy5tZXRob2QsdGhpcy51cmwsITApfWNhdGNoKGUpe3JldHVybiB0aGlzLmNhbGxiYWNrKGUpfWlmKHRoaXMuX3dpdGhDcmVkZW50aWFscyYmKHIud2l0aENyZWRlbnRpYWxzPSEwKSwhdGhpcy5fZm9ybURhdGEmJlwiR0VUXCIhPXRoaXMubWV0aG9kJiZcIkhFQURcIiE9dGhpcy5tZXRob2QmJlwic3RyaW5nXCIhPXR5cGVvZiBlJiYhdGhpcy5faXNIb3N0KGUpKXt2YXIgaT10aGlzLl9oZWFkZXJbXCJjb250ZW50LXR5cGVcIl0sbz10aGlzLl9zZXJpYWxpemVyfHxmLnNlcmlhbGl6ZVtpP2kuc3BsaXQoXCI7XCIpWzBdOlwiXCJdOyFvJiZnKGkpJiYobz1mLnNlcmlhbGl6ZVtcImFwcGxpY2F0aW9uL2pzb25cIl0pLG8mJihlPW8oZSkpfWZvcih2YXIgcyBpbiB0aGlzLmhlYWRlciludWxsIT10aGlzLmhlYWRlcltzXSYmdGhpcy5oZWFkZXIuaGFzT3duUHJvcGVydHkocykmJnIuc2V0UmVxdWVzdEhlYWRlcihzLHRoaXMuaGVhZGVyW3NdKTtyZXR1cm4gdGhpcy5fcmVzcG9uc2VUeXBlJiYoci5yZXNwb25zZVR5cGU9dGhpcy5fcmVzcG9uc2VUeXBlKSx0aGlzLmVtaXQoXCJyZXF1ZXN0XCIsdGhpcyksci5zZW5kKHZvaWQgMCE9PWU/ZTpudWxsKSx0aGlzfSxmLmFnZW50PWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyB1fSxbXCJHRVRcIixcIlBPU1RcIixcIk9QVElPTlNcIixcIlBBVENIXCIsXCJQVVRcIixcIkRFTEVURVwiXS5mb3JFYWNoKGZ1bmN0aW9uKHIpe3UucHJvdG90eXBlW3IudG9Mb3dlckNhc2UoKV09ZnVuY3Rpb24oZSx0KXt2YXIgbj1uZXcgZi5SZXF1ZXN0KHIsZSk7cmV0dXJuIHRoaXMuX3NldERlZmF1bHRzKG4pLHQmJm4uZW5kKHQpLG59fSksdS5wcm90b3R5cGUuZGVsPXUucHJvdG90eXBlLmRlbGV0ZSxmLmdldD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZihcIkdFVFwiLGUpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSx0JiZyLnF1ZXJ5KHQpLG4mJnIuZW5kKG4pLHJ9LGYuaGVhZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZihcIkhFQURcIixlKTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiYobj10LHQ9bnVsbCksdCYmci5xdWVyeSh0KSxuJiZyLmVuZChuKSxyfSxmLm9wdGlvbnM9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWYoXCJPUFRJT05TXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfSxmLmRlbD1iLGYuZGVsZXRlPWIsZi5wYXRjaD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZihcIlBBVENIXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfSxmLnBvc3Q9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPWYoXCJQT1NUXCIsZSk7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHQmJnIuc2VuZCh0KSxuJiZyLmVuZChuKSxyfSxmLnB1dD1mdW5jdGlvbihlLHQsbil7dmFyIHI9ZihcIlBVVFwiLGUpO3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQmJihuPXQsdD1udWxsKSx0JiZyLnNlbmQodCksbiYmci5lbmQobikscn19LGZ1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUpe2lmKGUpcmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiByLnByb3RvdHlwZSllW3RdPXIucHJvdG90eXBlW3RdO3JldHVybiBlfShlKX0oZS5leHBvcnRzPXIpLnByb3RvdHlwZS5vbj1yLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LCh0aGlzLl9jYWxsYmFja3NbXCIkXCIrZV09dGhpcy5fY2FsbGJhY2tzW1wiJFwiK2VdfHxbXSkucHVzaCh0KSx0aGlzfSxyLnByb3RvdHlwZS5vbmNlPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbigpe3RoaXMub2ZmKGUsbiksdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9cmV0dXJuIG4uZm49dCx0aGlzLm9uKGUsbiksdGhpc30sci5wcm90b3R5cGUub2ZmPXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1yLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7aWYodGhpcy5fY2FsbGJhY2tzPXRoaXMuX2NhbGxiYWNrc3x8e30sMD09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5fY2FsbGJhY2tzPXt9LHRoaXM7dmFyIG4scj10aGlzLl9jYWxsYmFja3NbXCIkXCIrZV07aWYoIXIpcmV0dXJuIHRoaXM7aWYoMT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tcIiRcIitlXSx0aGlzO2Zvcih2YXIgaT0wO2k8ci5sZW5ndGg7aSsrKWlmKChuPXJbaV0pPT09dHx8bi5mbj09PXQpe3Iuc3BsaWNlKGksMSk7YnJlYWt9cmV0dXJuIDA9PT1yLmxlbmd0aCYmZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tcIiRcIitlXSx0aGlzfSxyLnByb3RvdHlwZS5lbWl0PWZ1bmN0aW9uKGUpe3RoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9O2Zvcih2YXIgdD1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKSxuPXRoaXMuX2NhbGxiYWNrc1tcIiRcIitlXSxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl0W3ItMV09YXJndW1lbnRzW3JdO2lmKG4pe3I9MDtmb3IodmFyIGk9KG49bi5zbGljZSgwKSkubGVuZ3RoO3I8aTsrK3IpbltyXS5hcHBseSh0aGlzLHQpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS5saXN0ZW5lcnM9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX2NhbGxiYWNrcz10aGlzLl9jYWxsYmFja3N8fHt9LHRoaXMuX2NhbGxiYWNrc1tcIiRcIitlXXx8W119LHIucHJvdG90eXBlLmhhc0xpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm4hIXRoaXMubGlzdGVuZXJzKGUpLmxlbmd0aH19LGZ1bmN0aW9uKGUsdCxuKXtcInVzZSBzdHJpY3RcIjt2YXIgaT1uKDEwKTtmdW5jdGlvbiByKGUpe2lmKGUpcmV0dXJuIGZ1bmN0aW9uKGUpe2Zvcih2YXIgdCBpbiByLnByb3RvdHlwZSllW3RdPXIucHJvdG90eXBlW3RdO3JldHVybiBlfShlKX0oZS5leHBvcnRzPXIpLnByb3RvdHlwZS5jbGVhclRpbWVvdXQ9ZnVuY3Rpb24oKXtyZXR1cm4gY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKSxjbGVhclRpbWVvdXQodGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpLGRlbGV0ZSB0aGlzLl90aW1lcixkZWxldGUgdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIsdGhpc30sci5wcm90b3R5cGUucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuX3BhcnNlcj1lLHRoaXN9LHIucHJvdG90eXBlLnJlc3BvbnNlVHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fcmVzcG9uc2VUeXBlPWUsdGhpc30sci5wcm90b3R5cGUuc2VyaWFsaXplPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zZXJpYWxpemVyPWUsdGhpc30sci5wcm90b3R5cGUudGltZW91dD1mdW5jdGlvbihlKXtpZighZXx8XCJvYmplY3RcIiE9dHlwZW9mIGUpcmV0dXJuIHRoaXMuX3RpbWVvdXQ9ZSx0aGlzLl9yZXNwb25zZVRpbWVvdXQ9MCx0aGlzO2Zvcih2YXIgdCBpbiBlKXN3aXRjaCh0KXtjYXNlXCJkZWFkbGluZVwiOnRoaXMuX3RpbWVvdXQ9ZS5kZWFkbGluZTticmVhaztjYXNlXCJyZXNwb25zZVwiOnRoaXMuX3Jlc3BvbnNlVGltZW91dD1lLnJlc3BvbnNlO2JyZWFrO2RlZmF1bHQ6Y29uc29sZS53YXJuKFwiVW5rbm93biB0aW1lb3V0IG9wdGlvblwiLHQpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS5yZXRyeT1mdW5jdGlvbihlLHQpe3JldHVybiAwIT09YXJndW1lbnRzLmxlbmd0aCYmITAhPT1lfHwoZT0xKSxlPD0wJiYoZT0wKSx0aGlzLl9tYXhSZXRyaWVzPWUsdGhpcy5fcmV0cmllcz0wLHRoaXMuX3JldHJ5Q2FsbGJhY2s9dCx0aGlzfTt2YXIgbz1bXCJFQ09OTlJFU0VUXCIsXCJFVElNRURPVVRcIixcIkVBRERSSU5GT1wiLFwiRVNPQ0tFVFRJTUVET1VUXCJdO3IucHJvdG90eXBlLl9zaG91bGRSZXRyeT1mdW5jdGlvbihlLHQpe2lmKCF0aGlzLl9tYXhSZXRyaWVzfHx0aGlzLl9yZXRyaWVzKys+PXRoaXMuX21heFJldHJpZXMpcmV0dXJuITE7aWYodGhpcy5fcmV0cnlDYWxsYmFjayl0cnl7dmFyIG49dGhpcy5fcmV0cnlDYWxsYmFjayhlLHQpO2lmKCEwPT09bilyZXR1cm4hMDtpZighMT09PW4pcmV0dXJuITF9Y2F0Y2goZSl7Y29uc29sZS5lcnJvcihlKX1pZih0JiZ0LnN0YXR1cyYmNTAwPD10LnN0YXR1cyYmNTAxIT10LnN0YXR1cylyZXR1cm4hMDtpZihlKXtpZihlLmNvZGUmJn5vLmluZGV4T2YoZS5jb2RlKSlyZXR1cm4hMDtpZihlLnRpbWVvdXQmJlwiRUNPTk5BQk9SVEVEXCI9PWUuY29kZSlyZXR1cm4hMDtpZihlLmNyb3NzRG9tYWluKXJldHVybiEwfXJldHVybiExfSxyLnByb3RvdHlwZS5fcmV0cnk9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jbGVhclRpbWVvdXQoKSx0aGlzLnJlcSYmKHRoaXMucmVxPW51bGwsdGhpcy5yZXE9dGhpcy5yZXF1ZXN0KCkpLHRoaXMuX2Fib3J0ZWQ9ITEsdGhpcy50aW1lZG91dD0hMSx0aGlzLl9lbmQoKX0sci5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihlLHQpe2lmKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSl7dmFyIGk9dGhpczt0aGlzLl9lbmRDYWxsZWQmJmNvbnNvbGUud2FybihcIldhcm5pbmc6IHN1cGVyYWdlbnQgcmVxdWVzdCB3YXMgc2VudCB0d2ljZSwgYmVjYXVzZSBib3RoIC5lbmQoKSBhbmQgLnRoZW4oKSB3ZXJlIGNhbGxlZC4gTmV2ZXIgY2FsbCAuZW5kKCkgaWYgeW91IHVzZSBwcm9taXNlc1wiKSx0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZT1uZXcgUHJvbWlzZShmdW5jdGlvbihuLHIpe2kuZW5kKGZ1bmN0aW9uKGUsdCl7ZT9yKGUpOm4odCl9KX0pfXJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKGUsdCl9LHIucHJvdG90eXBlLmNhdGNoPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLnRoZW4odm9pZCAwLGUpfSxyLnByb3RvdHlwZS51c2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUodGhpcyksdGhpc30sci5wcm90b3R5cGUub2s9ZnVuY3Rpb24oZSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgZSl0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO3JldHVybiB0aGlzLl9va0NhbGxiYWNrPWUsdGhpc30sci5wcm90b3R5cGUuX2lzUmVzcG9uc2VPSz1mdW5jdGlvbihlKXtyZXR1cm4hIWUmJih0aGlzLl9va0NhbGxiYWNrP3RoaXMuX29rQ2FsbGJhY2soZSk6MjAwPD1lLnN0YXR1cyYmZS5zdGF0dXM8MzAwKX0sci5wcm90b3R5cGUuZ2V0SGVhZGVyPXIucHJvdG90eXBlLmdldD1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5faGVhZGVyW2UudG9Mb3dlckNhc2UoKV19LHIucHJvdG90eXBlLnNldD1mdW5jdGlvbihlLHQpe2lmKGkoZSkpe2Zvcih2YXIgbiBpbiBlKXRoaXMuc2V0KG4sZVtuXSk7cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMuX2hlYWRlcltlLnRvTG93ZXJDYXNlKCldPXQsdGhpcy5oZWFkZXJbZV09dCx0aGlzfSxyLnByb3RvdHlwZS51bnNldD1mdW5jdGlvbihlKXtyZXR1cm4gZGVsZXRlIHRoaXMuX2hlYWRlcltlLnRvTG93ZXJDYXNlKCldLGRlbGV0ZSB0aGlzLmhlYWRlcltlXSx0aGlzfSxyLnByb3RvdHlwZS5maWVsZD1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpdGhyb3cgbmV3IEVycm9yKFwiLmZpZWxkKG5hbWUsIHZhbCkgbmFtZSBjYW4gbm90IGJlIGVtcHR5XCIpO2lmKHRoaXMuX2RhdGEmJmNvbnNvbGUuZXJyb3IoXCIuZmllbGQoKSBjYW4ndCBiZSB1c2VkIGlmIC5zZW5kKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKSxpKGUpKXtmb3IodmFyIG4gaW4gZSl0aGlzLmZpZWxkKG4sZVtuXSk7cmV0dXJuIHRoaXN9aWYoQXJyYXkuaXNBcnJheSh0KSl7Zm9yKHZhciByIGluIHQpdGhpcy5maWVsZChlLHRbcl0pO3JldHVybiB0aGlzfWlmKG51bGw9PXQpdGhyb3cgbmV3IEVycm9yKFwiLmZpZWxkKG5hbWUsIHZhbCkgdmFsIGNhbiBub3QgYmUgZW1wdHlcIik7cmV0dXJuXCJib29sZWFuXCI9PXR5cGVvZiB0JiYodD1cIlwiK3QpLHRoaXMuX2dldEZvcm1EYXRhKCkuYXBwZW5kKGUsdCksdGhpc30sci5wcm90b3R5cGUuYWJvcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fYWJvcnRlZHx8KHRoaXMuX2Fib3J0ZWQ9ITAsdGhpcy54aHImJnRoaXMueGhyLmFib3J0KCksdGhpcy5yZXEmJnRoaXMucmVxLmFib3J0KCksdGhpcy5jbGVhclRpbWVvdXQoKSx0aGlzLmVtaXQoXCJhYm9ydFwiKSksdGhpc30sci5wcm90b3R5cGUuX2F1dGg9ZnVuY3Rpb24oZSx0LG4scil7c3dpdGNoKG4udHlwZSl7Y2FzZVwiYmFzaWNcIjp0aGlzLnNldChcIkF1dGhvcml6YXRpb25cIixcIkJhc2ljIFwiK3IoZStcIjpcIit0KSk7YnJlYWs7Y2FzZVwiYXV0b1wiOnRoaXMudXNlcm5hbWU9ZSx0aGlzLnBhc3N3b3JkPXQ7YnJlYWs7Y2FzZVwiYmVhcmVyXCI6dGhpcy5zZXQoXCJBdXRob3JpemF0aW9uXCIsXCJCZWFyZXIgXCIrZSl9cmV0dXJuIHRoaXN9LHIucHJvdG90eXBlLndpdGhDcmVkZW50aWFscz1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbD09ZSYmKGU9ITApLHRoaXMuX3dpdGhDcmVkZW50aWFscz1lLHRoaXN9LHIucHJvdG90eXBlLnJlZGlyZWN0cz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5fbWF4UmVkaXJlY3RzPWUsdGhpc30sci5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXRocm93IFR5cGVFcnJvcihcIkludmFsaWQgYXJndW1lbnRcIik7cmV0dXJuIHRoaXMuX21heFJlc3BvbnNlU2l6ZT1lLHRoaXN9LHIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnttZXRob2Q6dGhpcy5tZXRob2QsdXJsOnRoaXMudXJsLGRhdGE6dGhpcy5fZGF0YSxoZWFkZXJzOnRoaXMuX2hlYWRlcn19LHIucHJvdG90eXBlLnNlbmQ9ZnVuY3Rpb24oZSl7dmFyIHQ9aShlKSxuPXRoaXMuX2hlYWRlcltcImNvbnRlbnQtdHlwZVwiXTtpZih0aGlzLl9mb3JtRGF0YSYmY29uc29sZS5lcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKSx0JiYhdGhpcy5fZGF0YSlBcnJheS5pc0FycmF5KGUpP3RoaXMuX2RhdGE9W106dGhpcy5faXNIb3N0KGUpfHwodGhpcy5fZGF0YT17fSk7ZWxzZSBpZihlJiZ0aGlzLl9kYXRhJiZ0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpdGhyb3cgRXJyb3IoXCJDYW4ndCBtZXJnZSB0aGVzZSBzZW5kIGNhbGxzXCIpO2lmKHQmJmkodGhpcy5fZGF0YSkpZm9yKHZhciByIGluIGUpdGhpcy5fZGF0YVtyXT1lW3JdO2Vsc2VcInN0cmluZ1wiPT10eXBlb2YgZT8obnx8dGhpcy50eXBlKFwiZm9ybVwiKSxuPXRoaXMuX2hlYWRlcltcImNvbnRlbnQtdHlwZVwiXSx0aGlzLl9kYXRhPVwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCI9PW4/dGhpcy5fZGF0YT90aGlzLl9kYXRhK1wiJlwiK2U6ZToodGhpcy5fZGF0YXx8XCJcIikrZSk6dGhpcy5fZGF0YT1lO3JldHVybiF0fHx0aGlzLl9pc0hvc3QoZSl8fG58fHRoaXMudHlwZShcImpzb25cIiksdGhpc30sci5wcm90b3R5cGUuc29ydFF1ZXJ5PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLl9zb3J0PXZvaWQgMD09PWV8fGUsdGhpc30sci5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmc9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9xdWVyeS5qb2luKFwiJlwiKTtpZihlJiYodGhpcy51cmwrPSgwPD10aGlzLnVybC5pbmRleE9mKFwiP1wiKT9cIiZcIjpcIj9cIikrZSksdGhpcy5fcXVlcnkubGVuZ3RoPTAsdGhpcy5fc29ydCl7dmFyIHQ9dGhpcy51cmwuaW5kZXhPZihcIj9cIik7aWYoMDw9dCl7dmFyIG49dGhpcy51cmwuc3Vic3RyaW5nKHQrMSkuc3BsaXQoXCImXCIpO1wiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuX3NvcnQ/bi5zb3J0KHRoaXMuX3NvcnQpOm4uc29ydCgpLHRoaXMudXJsPXRoaXMudXJsLnN1YnN0cmluZygwLHQpK1wiP1wiK24uam9pbihcIiZcIil9fX0sci5wcm90b3R5cGUuX2FwcGVuZFF1ZXJ5U3RyaW5nPWZ1bmN0aW9uKCl7Y29uc29sZS50cmFjZShcIlVuc3VwcG9ydGVkXCIpfSxyLnByb3RvdHlwZS5fdGltZW91dEVycm9yPWZ1bmN0aW9uKGUsdCxuKXtpZighdGhpcy5fYWJvcnRlZCl7dmFyIHI9bmV3IEVycm9yKGUrdCtcIm1zIGV4Y2VlZGVkXCIpO3IudGltZW91dD10LHIuY29kZT1cIkVDT05OQUJPUlRFRFwiLHIuZXJybm89bix0aGlzLnRpbWVkb3V0PSEwLHRoaXMuYWJvcnQoKSx0aGlzLmNhbGxiYWNrKHIpfX0sci5wcm90b3R5cGUuX3NldFRpbWVvdXRzPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLl90aW1lb3V0JiYhdGhpcy5fdGltZXImJih0aGlzLl90aW1lcj1zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZS5fdGltZW91dEVycm9yKFwiVGltZW91dCBvZiBcIixlLl90aW1lb3V0LFwiRVRJTUVcIil9LHRoaXMuX3RpbWVvdXQpKSx0aGlzLl9yZXNwb25zZVRpbWVvdXQmJiF0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciYmKHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyPXNldFRpbWVvdXQoZnVuY3Rpb24oKXtlLl90aW1lb3V0RXJyb3IoXCJSZXNwb25zZSB0aW1lb3V0IG9mIFwiLGUuX3Jlc3BvbnNlVGltZW91dCxcIkVUSU1FRE9VVFwiKX0sdGhpcy5fcmVzcG9uc2VUaW1lb3V0KSl9fSxmdW5jdGlvbihlLHQsbil7XCJ1c2Ugc3RyaWN0XCI7dmFyIGk9big4MCk7ZnVuY3Rpb24gcihlKXtpZihlKXJldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHQgaW4gci5wcm90b3R5cGUpZVt0XT1yLnByb3RvdHlwZVt0XTtyZXR1cm4gZX0oZSl9KGUuZXhwb3J0cz1yKS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmhlYWRlcltlLnRvTG93ZXJDYXNlKCldfSxyLnByb3RvdHlwZS5fc2V0SGVhZGVyUHJvcGVydGllcz1mdW5jdGlvbihlKXt2YXIgdD1lW1wiY29udGVudC10eXBlXCJdfHxcIlwiO3RoaXMudHlwZT1pLnR5cGUodCk7dmFyIG49aS5wYXJhbXModCk7Zm9yKHZhciByIGluIG4pdGhpc1tyXT1uW3JdO3RoaXMubGlua3M9e307dHJ5e2UubGluayYmKHRoaXMubGlua3M9aS5wYXJzZUxpbmtzKGUubGluaykpfWNhdGNoKGUpe319LHIucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzPWZ1bmN0aW9uKGUpe3ZhciB0PWUvMTAwfDA7dGhpcy5zdGF0dXM9dGhpcy5zdGF0dXNDb2RlPWUsdGhpcy5zdGF0dXNUeXBlPXQsdGhpcy5pbmZvPTE9PXQsdGhpcy5vaz0yPT10LHRoaXMucmVkaXJlY3Q9Mz09dCx0aGlzLmNsaWVudEVycm9yPTQ9PXQsdGhpcy5zZXJ2ZXJFcnJvcj01PT10LHRoaXMuZXJyb3I9KDQ9PXR8fDU9PXQpJiZ0aGlzLnRvRXJyb3IoKSx0aGlzLmNyZWF0ZWQ9MjAxPT1lLHRoaXMuYWNjZXB0ZWQ9MjAyPT1lLHRoaXMubm9Db250ZW50PTIwND09ZSx0aGlzLmJhZFJlcXVlc3Q9NDAwPT1lLHRoaXMudW5hdXRob3JpemVkPTQwMT09ZSx0aGlzLm5vdEFjY2VwdGFibGU9NDA2PT1lLHRoaXMuZm9yYmlkZGVuPTQwMz09ZSx0aGlzLm5vdEZvdW5kPTQwND09ZSx0aGlzLnVucHJvY2Vzc2FibGVFbnRpdHk9NDIyPT1lfX0sZnVuY3Rpb24oZSx0LG4pe1widXNlIHN0cmljdFwiO3QudHlwZT1mdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdCgvICo7ICovKS5zaGlmdCgpfSx0LnBhcmFtcz1mdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdCgvICo7ICovKS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXt2YXIgbj10LnNwbGl0KC8gKj0gKi8pLHI9bi5zaGlmdCgpLGk9bi5zaGlmdCgpO3JldHVybiByJiZpJiYoZVtyXT1pKSxlfSx7fSl9LHQucGFyc2VMaW5rcz1mdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXt2YXIgbj10LnNwbGl0KC8gKjsgKi8pLHI9blswXS5zbGljZSgxLC0xKTtyZXR1cm4gZVtuWzFdLnNwbGl0KC8gKj0gKi8pWzFdLnNsaWNlKDEsLTEpXT1yLGV9LHt9KX0sdC5jbGVhbkhlYWRlcj1mdW5jdGlvbihlLHQpe3JldHVybiBkZWxldGUgZVtcImNvbnRlbnQtdHlwZVwiXSxkZWxldGUgZVtcImNvbnRlbnQtbGVuZ3RoXCJdLGRlbGV0ZSBlW1widHJhbnNmZXItZW5jb2RpbmdcIl0sZGVsZXRlIGUuaG9zdCx0JiYoZGVsZXRlIGUuYXV0aG9yaXphdGlvbixkZWxldGUgZS5jb29raWUpLGV9fSxmdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oKXt0aGlzLl9kZWZhdWx0cz1bXX1bXCJ1c2VcIixcIm9uXCIsXCJvbmNlXCIsXCJzZXRcIixcInF1ZXJ5XCIsXCJ0eXBlXCIsXCJhY2NlcHRcIixcImF1dGhcIixcIndpdGhDcmVkZW50aWFsc1wiLFwic29ydFF1ZXJ5XCIsXCJyZXRyeVwiLFwib2tcIixcInJlZGlyZWN0c1wiLFwidGltZW91dFwiLFwiYnVmZmVyXCIsXCJzZXJpYWxpemVcIixcInBhcnNlXCIsXCJjYVwiLFwia2V5XCIsXCJwZnhcIixcImNlcnRcIl0uZm9yRWFjaChmdW5jdGlvbihlKXtuLnByb3RvdHlwZVtlXT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9kZWZhdWx0cy5wdXNoKHtmbjplLGFyZ3VtZW50czphcmd1bWVudHN9KSx0aGlzfX0pLG4ucHJvdG90eXBlLl9zZXREZWZhdWx0cz1mdW5jdGlvbih0KXt0aGlzLl9kZWZhdWx0cy5mb3JFYWNoKGZ1bmN0aW9uKGUpe3RbZS5mbl0uYXBwbHkodCxlLmFyZ3VtZW50cyl9KX0sZS5leHBvcnRzPW59XSxpLmM9cixpLmQ9ZnVuY3Rpb24oZSx0LG4pe2kubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LGkucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxpLnQ9ZnVuY3Rpb24odCxlKXtpZigxJmUmJih0PWkodCkpLDgmZSlyZXR1cm4gdDtpZig0JmUmJlwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0JiZ0Ll9fZXNNb2R1bGUpcmV0dXJuIHQ7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihpLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6dH0pLDImZSYmXCJzdHJpbmdcIiE9dHlwZW9mIHQpZm9yKHZhciByIGluIHQpaS5kKG4scixmdW5jdGlvbihlKXtyZXR1cm4gdFtlXX0uYmluZChudWxsLHIpKTtyZXR1cm4gbn0saS5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBpLmQodCxcImFcIix0KSx0fSxpLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LGkucD1cIlwiLGkoaS5zPTExKTtmdW5jdGlvbiBpKGUpe2lmKHJbZV0pcmV0dXJuIHJbZV0uZXhwb3J0czt2YXIgdD1yW2VdPXtpOmUsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gbltlXS5jYWxsKHQuZXhwb3J0cyx0LHQuZXhwb3J0cyxpKSx0Lmw9ITAsdC5leHBvcnRzfXZhciBuLHJ9KTsiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvblwiKTtcbmZ1bmN0aW9uIHVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgcm5nKSB7XG4gICAgaWYgKHJuZyAhPSBudWxsKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfTtcbn1cbmV4cG9ydHMudW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIFVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25cIik7XG5mdW5jdGlvbiB1bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICBpZiAocm5nICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICAgICAgcmV0dXJuIFtVbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgbmV4dFJuZyksIG5leHRSbmddO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHJuZykge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gW1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfTtcbn1cbmV4cG9ydHMudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IHVuaWZvcm1CaWdJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvblwiKTtcbmZ1bmN0aW9uIHVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIHJuZykge1xuICAgIGlmIChybmcgIT0gbnVsbCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IHJuZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4gW1Vuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBuZXh0Um5nKSwgbmV4dFJuZ107XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAocm5nKSB7XG4gICAgICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgICAgIHJldHVybiBbVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb24oZnJvbSwgdG8sIG5leHRSbmcpLCBuZXh0Um5nXTtcbiAgICB9O1xufVxuZXhwb3J0cy51bmlmb3JtSW50RGlzdHJpYnV0aW9uID0gdW5pZm9ybUludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uID0gdm9pZCAwO1xudmFyIEFycmF5SW50XzEgPSByZXF1aXJlKFwiLi9pbnRlcm5hbHMvQXJyYXlJbnRcIik7XG52YXIgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9VbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbFwiKTtcbmZ1bmN0aW9uIHVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbihmcm9tLCB0bywgcm5nKSB7XG4gICAgdmFyIHJhbmdlU2l6ZSA9IEFycmF5SW50XzEudHJpbUFycmF5SW50SW5wbGFjZShBcnJheUludF8xLmFkZE9uZVRvUG9zaXRpdmVBcnJheUludChBcnJheUludF8xLnN1YnN0cmFjdEFycmF5SW50VG9OZXcodG8sIGZyb20pKSk7XG4gICAgdmFyIGVtcHR5QXJyYXlJbnREYXRhID0gcmFuZ2VTaXplLmRhdGEuc2xpY2UoMCk7XG4gICAgdmFyIGcgPSBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsKGVtcHR5QXJyYXlJbnREYXRhLCByYW5nZVNpemUuZGF0YSwgcm5nKTtcbiAgICByZXR1cm4gQXJyYXlJbnRfMS50cmltQXJyYXlJbnRJbnBsYWNlKEFycmF5SW50XzEuYWRkQXJyYXlJbnRUb05ldyh7IHNpZ246IDEsIGRhdGE6IGcgfSwgZnJvbSkpO1xufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSB2b2lkIDA7XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgZGlmZiA9IHRvIC0gZnJvbSArIEJpZ0ludCgxKTtcbiAgICB2YXIgTWluUm5nID0gQmlnSW50KHJuZy5taW4oKSk7XG4gICAgdmFyIE51bVZhbHVlcyA9IEJpZ0ludChybmcubWF4KCkgLSBybmcubWluKCkgKyAxKTtcbiAgICB2YXIgRmluYWxOdW1WYWx1ZXMgPSBOdW1WYWx1ZXM7XG4gICAgdmFyIE51bUl0ZXJhdGlvbnMgPSBCaWdJbnQoMSk7XG4gICAgd2hpbGUgKEZpbmFsTnVtVmFsdWVzIDwgZGlmZikge1xuICAgICAgICBGaW5hbE51bVZhbHVlcyAqPSBOdW1WYWx1ZXM7XG4gICAgICAgICsrTnVtSXRlcmF0aW9ucztcbiAgICB9XG4gICAgdmFyIE1heEFjY2VwdGVkUmFuZG9tID0gRmluYWxOdW1WYWx1ZXMgLSAoRmluYWxOdW1WYWx1ZXMgJSBkaWZmKTtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBCaWdJbnQoMCk7XG4gICAgICAgIGZvciAodmFyIG51bSA9IEJpZ0ludCgwKTsgbnVtICE9PSBOdW1JdGVyYXRpb25zOyArK251bSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IHJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bVZhbHVlcyAqIHZhbHVlICsgKEJpZ0ludChvdXQpIC0gTWluUm5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgPCBNYXhBY2NlcHRlZFJhbmRvbSkge1xuICAgICAgICAgICAgdmFyIGluRGlmZiA9IHZhbHVlICUgZGlmZjtcbiAgICAgICAgICAgIHJldHVybiBpbkRpZmYgKyBmcm9tO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gdW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IHZvaWQgMDtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxcIik7XG52YXIgQXJyYXlJbnRfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFscy9BcnJheUludFwiKTtcbnZhciBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWxzL1Vuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsXCIpO1xudmFyIHNoYXJlZEEgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZEIgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZEMgPSB7IHNpZ246IDEsIGRhdGE6IFswLCAwXSB9O1xudmFyIHNoYXJlZERhdGEgPSBbMCwgMF07XG5mdW5jdGlvbiB1bmlmb3JtTGFyZ2VJbnRJbnRlcm5hbChmcm9tLCB0bywgcmFuZ2VTaXplLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZSA9IHJhbmdlU2l6ZSA8PSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICAgICAgICA/IEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NChzaGFyZWRDLCByYW5nZVNpemUpXG4gICAgICAgIDogQXJyYXlJbnRfMS5zdWJzdHJhY3RBcnJheUludDY0KHNoYXJlZEMsIEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NChzaGFyZWRBLCB0byksIEFycmF5SW50XzEuZnJvbU51bWJlclRvQXJyYXlJbnQ2NChzaGFyZWRCLCBmcm9tKSk7XG4gICAgaWYgKHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVsxXSA9PT0gMHhmZmZmZmZmZikge1xuICAgICAgICByYW5nZVNpemVBcnJheUludFZhbHVlLmRhdGFbMF0gKz0gMTtcbiAgICAgICAgcmFuZ2VTaXplQXJyYXlJbnRWYWx1ZS5kYXRhWzFdID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YVsxXSArPSAxO1xuICAgIH1cbiAgICBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbkludGVybmFsKHNoYXJlZERhdGEsIHJhbmdlU2l6ZUFycmF5SW50VmFsdWUuZGF0YSwgcm5nKTtcbiAgICByZXR1cm4gc2hhcmVkRGF0YVswXSAqIDB4MTAwMDAwMDAwICsgc2hhcmVkRGF0YVsxXSArIGZyb207XG59XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uKGZyb20sIHRvLCBybmcpIHtcbiAgICB2YXIgcmFuZ2VTaXplID0gdG8gLSBmcm9tO1xuICAgIGlmIChyYW5nZVNpemUgPD0gMHhmZmZmZmZmZikge1xuICAgICAgICB2YXIgZyA9IFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbChyYW5nZVNpemUgKyAxLCBybmcpO1xuICAgICAgICByZXR1cm4gZyArIGZyb207XG4gICAgfVxuICAgIHJldHVybiB1bmlmb3JtTGFyZ2VJbnRJbnRlcm5hbChmcm9tLCB0bywgcmFuZ2VTaXplLCBybmcpO1xufVxuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uID0gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuc3Vic3RyYWN0QXJyYXlJbnQ2NCA9IGV4cG9ydHMuZnJvbU51bWJlclRvQXJyYXlJbnQ2NCA9IGV4cG9ydHMudHJpbUFycmF5SW50SW5wbGFjZSA9IGV4cG9ydHMuc3Vic3RyYWN0QXJyYXlJbnRUb05ldyA9IGV4cG9ydHMuYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50ID0gZXhwb3J0cy5hZGRBcnJheUludFRvTmV3ID0gdm9pZCAwO1xuZnVuY3Rpb24gYWRkQXJyYXlJbnRUb05ldyhhcnJheUludEEsIGFycmF5SW50Qikge1xuICAgIGlmIChhcnJheUludEEuc2lnbiAhPT0gYXJyYXlJbnRCLnNpZ24pIHtcbiAgICAgICAgcmV0dXJuIHN1YnN0cmFjdEFycmF5SW50VG9OZXcoYXJyYXlJbnRBLCB7IHNpZ246IC1hcnJheUludEIuc2lnbiwgZGF0YTogYXJyYXlJbnRCLmRhdGEgfSk7XG4gICAgfVxuICAgIHZhciBkYXRhID0gW107XG4gICAgdmFyIHJlbWluZGVyID0gMDtcbiAgICB2YXIgZGF0YUEgPSBhcnJheUludEEuZGF0YTtcbiAgICB2YXIgZGF0YUIgPSBhcnJheUludEIuZGF0YTtcbiAgICBmb3IgKHZhciBpbmRleEEgPSBkYXRhQS5sZW5ndGggLSAxLCBpbmRleEIgPSBkYXRhQi5sZW5ndGggLSAxOyBpbmRleEEgPj0gMCB8fCBpbmRleEIgPj0gMDsgLS1pbmRleEEsIC0taW5kZXhCKSB7XG4gICAgICAgIHZhciB2QSA9IGluZGV4QSA+PSAwID8gZGF0YUFbaW5kZXhBXSA6IDA7XG4gICAgICAgIHZhciB2QiA9IGluZGV4QiA+PSAwID8gZGF0YUJbaW5kZXhCXSA6IDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdkEgKyB2QiArIHJlbWluZGVyO1xuICAgICAgICBkYXRhLnB1c2goY3VycmVudCA+Pj4gMCk7XG4gICAgICAgIHJlbWluZGVyID0gfn4oY3VycmVudCAvIDB4MTAwMDAwMDAwKTtcbiAgICB9XG4gICAgaWYgKHJlbWluZGVyICE9PSAwKSB7XG4gICAgICAgIGRhdGEucHVzaChyZW1pbmRlcik7XG4gICAgfVxuICAgIHJldHVybiB7IHNpZ246IGFycmF5SW50QS5zaWduLCBkYXRhOiBkYXRhLnJldmVyc2UoKSB9O1xufVxuZXhwb3J0cy5hZGRBcnJheUludFRvTmV3ID0gYWRkQXJyYXlJbnRUb05ldztcbmZ1bmN0aW9uIGFkZE9uZVRvUG9zaXRpdmVBcnJheUludChhcnJheUludCkge1xuICAgIGFycmF5SW50LnNpZ24gPSAxO1xuICAgIHZhciBkYXRhID0gYXJyYXlJbnQuZGF0YTtcbiAgICBmb3IgKHZhciBpbmRleCA9IGRhdGEubGVuZ3RoIC0gMTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuICAgICAgICBpZiAoZGF0YVtpbmRleF0gPT09IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRhdGFbaW5kZXhdICs9IDE7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlJbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGF0YS51bnNoaWZ0KDEpO1xuICAgIHJldHVybiBhcnJheUludDtcbn1cbmV4cG9ydHMuYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50ID0gYWRkT25lVG9Qb3NpdGl2ZUFycmF5SW50O1xuZnVuY3Rpb24gaXNTdHJpY3RseVNtYWxsZXIoZGF0YUEsIGRhdGFCKSB7XG4gICAgdmFyIG1heExlbmd0aCA9IE1hdGgubWF4KGRhdGFBLmxlbmd0aCwgZGF0YUIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbWF4TGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBpbmRleEEgPSBpbmRleCArIGRhdGFBLmxlbmd0aCAtIG1heExlbmd0aDtcbiAgICAgICAgdmFyIGluZGV4QiA9IGluZGV4ICsgZGF0YUIubGVuZ3RoIC0gbWF4TGVuZ3RoO1xuICAgICAgICB2YXIgdkEgPSBpbmRleEEgPj0gMCA/IGRhdGFBW2luZGV4QV0gOiAwO1xuICAgICAgICB2YXIgdkIgPSBpbmRleEIgPj0gMCA/IGRhdGFCW2luZGV4Ql0gOiAwO1xuICAgICAgICBpZiAodkEgPCB2QilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodkEgPiB2QilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc3Vic3RyYWN0QXJyYXlJbnRUb05ldyhhcnJheUludEEsIGFycmF5SW50Qikge1xuICAgIGlmIChhcnJheUludEEuc2lnbiAhPT0gYXJyYXlJbnRCLnNpZ24pIHtcbiAgICAgICAgcmV0dXJuIGFkZEFycmF5SW50VG9OZXcoYXJyYXlJbnRBLCB7IHNpZ246IC1hcnJheUludEIuc2lnbiwgZGF0YTogYXJyYXlJbnRCLmRhdGEgfSk7XG4gICAgfVxuICAgIHZhciBkYXRhQSA9IGFycmF5SW50QS5kYXRhO1xuICAgIHZhciBkYXRhQiA9IGFycmF5SW50Qi5kYXRhO1xuICAgIGlmIChpc1N0cmljdGx5U21hbGxlcihkYXRhQSwgZGF0YUIpKSB7XG4gICAgICAgIHZhciBvdXQgPSBzdWJzdHJhY3RBcnJheUludFRvTmV3KGFycmF5SW50QiwgYXJyYXlJbnRBKTtcbiAgICAgICAgb3V0LnNpZ24gPSAtb3V0LnNpZ247XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHZhciBkYXRhID0gW107XG4gICAgdmFyIHJlbWluZGVyID0gMDtcbiAgICBmb3IgKHZhciBpbmRleEEgPSBkYXRhQS5sZW5ndGggLSAxLCBpbmRleEIgPSBkYXRhQi5sZW5ndGggLSAxOyBpbmRleEEgPj0gMCB8fCBpbmRleEIgPj0gMDsgLS1pbmRleEEsIC0taW5kZXhCKSB7XG4gICAgICAgIHZhciB2QSA9IGluZGV4QSA+PSAwID8gZGF0YUFbaW5kZXhBXSA6IDA7XG4gICAgICAgIHZhciB2QiA9IGluZGV4QiA+PSAwID8gZGF0YUJbaW5kZXhCXSA6IDA7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdkEgLSB2QiAtIHJlbWluZGVyO1xuICAgICAgICBkYXRhLnB1c2goY3VycmVudCA+Pj4gMCk7XG4gICAgICAgIHJlbWluZGVyID0gY3VycmVudCA8IDAgPyAxIDogMDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2lnbjogYXJyYXlJbnRBLnNpZ24sIGRhdGE6IGRhdGEucmV2ZXJzZSgpIH07XG59XG5leHBvcnRzLnN1YnN0cmFjdEFycmF5SW50VG9OZXcgPSBzdWJzdHJhY3RBcnJheUludFRvTmV3O1xuZnVuY3Rpb24gdHJpbUFycmF5SW50SW5wbGFjZShhcnJheUludCkge1xuICAgIHZhciBkYXRhID0gYXJyYXlJbnQuZGF0YTtcbiAgICB2YXIgZmlyc3ROb25aZXJvID0gMDtcbiAgICBmb3IgKDsgZmlyc3ROb25aZXJvICE9PSBkYXRhLmxlbmd0aCAmJiBkYXRhW2ZpcnN0Tm9uWmVyb10gPT09IDA7ICsrZmlyc3ROb25aZXJvKSB7IH1cbiAgICBpZiAoZmlyc3ROb25aZXJvID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICBhcnJheUludC5zaWduID0gMTtcbiAgICAgICAgYXJyYXlJbnQuZGF0YSA9IFswXTtcbiAgICAgICAgcmV0dXJuIGFycmF5SW50O1xuICAgIH1cbiAgICBkYXRhLnNwbGljZSgwLCBmaXJzdE5vblplcm8pO1xuICAgIHJldHVybiBhcnJheUludDtcbn1cbmV4cG9ydHMudHJpbUFycmF5SW50SW5wbGFjZSA9IHRyaW1BcnJheUludElucGxhY2U7XG5mdW5jdGlvbiBmcm9tTnVtYmVyVG9BcnJheUludDY0KG91dCwgbikge1xuICAgIGlmIChuIDwgMCkge1xuICAgICAgICB2YXIgcG9zTiA9IC1uO1xuICAgICAgICBvdXQuc2lnbiA9IC0xO1xuICAgICAgICBvdXQuZGF0YVswXSA9IH5+KHBvc04gLyAweDEwMDAwMDAwMCk7XG4gICAgICAgIG91dC5kYXRhWzFdID0gcG9zTiA+Pj4gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dC5zaWduID0gMTtcbiAgICAgICAgb3V0LmRhdGFbMF0gPSB+fihuIC8gMHgxMDAwMDAwMDApO1xuICAgICAgICBvdXQuZGF0YVsxXSA9IG4gPj4+IDA7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLmZyb21OdW1iZXJUb0FycmF5SW50NjQgPSBmcm9tTnVtYmVyVG9BcnJheUludDY0O1xuZnVuY3Rpb24gc3Vic3RyYWN0QXJyYXlJbnQ2NChvdXQsIGFycmF5SW50QSwgYXJyYXlJbnRCKSB7XG4gICAgdmFyIGxvd0EgPSBhcnJheUludEEuZGF0YVsxXTtcbiAgICB2YXIgaGlnaEEgPSBhcnJheUludEEuZGF0YVswXTtcbiAgICB2YXIgc2lnbkEgPSBhcnJheUludEEuc2lnbjtcbiAgICB2YXIgbG93QiA9IGFycmF5SW50Qi5kYXRhWzFdO1xuICAgIHZhciBoaWdoQiA9IGFycmF5SW50Qi5kYXRhWzBdO1xuICAgIHZhciBzaWduQiA9IGFycmF5SW50Qi5zaWduO1xuICAgIG91dC5zaWduID0gMTtcbiAgICBpZiAoc2lnbkEgPT09IDEgJiYgc2lnbkIgPT09IC0xKSB7XG4gICAgICAgIHZhciBsb3dfMSA9IGxvd0EgKyBsb3dCO1xuICAgICAgICB2YXIgaGlnaCA9IGhpZ2hBICsgaGlnaEIgKyAobG93XzEgPiAweGZmZmZmZmZmID8gMSA6IDApO1xuICAgICAgICBvdXQuZGF0YVswXSA9IGhpZ2ggPj4+IDA7XG4gICAgICAgIG91dC5kYXRhWzFdID0gbG93XzEgPj4+IDA7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHZhciBsb3dGaXJzdCA9IGxvd0E7XG4gICAgdmFyIGhpZ2hGaXJzdCA9IGhpZ2hBO1xuICAgIHZhciBsb3dTZWNvbmQgPSBsb3dCO1xuICAgIHZhciBoaWdoU2Vjb25kID0gaGlnaEI7XG4gICAgaWYgKHNpZ25BID09PSAtMSkge1xuICAgICAgICBsb3dGaXJzdCA9IGxvd0I7XG4gICAgICAgIGhpZ2hGaXJzdCA9IGhpZ2hCO1xuICAgICAgICBsb3dTZWNvbmQgPSBsb3dBO1xuICAgICAgICBoaWdoU2Vjb25kID0gaGlnaEE7XG4gICAgfVxuICAgIHZhciByZW1pbmRlckxvdyA9IDA7XG4gICAgdmFyIGxvdyA9IGxvd0ZpcnN0IC0gbG93U2Vjb25kO1xuICAgIGlmIChsb3cgPCAwKSB7XG4gICAgICAgIHJlbWluZGVyTG93ID0gMTtcbiAgICAgICAgbG93ID0gbG93ID4+PiAwO1xuICAgIH1cbiAgICBvdXQuZGF0YVswXSA9IGhpZ2hGaXJzdCAtIGhpZ2hTZWNvbmQgLSByZW1pbmRlckxvdztcbiAgICBvdXQuZGF0YVsxXSA9IGxvdztcbiAgICByZXR1cm4gb3V0O1xufVxuZXhwb3J0cy5zdWJzdHJhY3RBcnJheUludDY0ID0gc3Vic3RyYWN0QXJyYXlJbnQ2NDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwgPSB2b2lkIDA7XG52YXIgVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsXzEgPSByZXF1aXJlKFwiLi9VbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uSW50ZXJuYWxcIik7XG5mdW5jdGlvbiB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbChvdXQsIHJhbmdlU2l6ZSwgcm5nKSB7XG4gICAgdmFyIHJhbmdlTGVuZ3RoID0gcmFuZ2VTaXplLmxlbmd0aDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4ICE9PSByYW5nZUxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgICAgdmFyIGluZGV4UmFuZ2VTaXplID0gaW5kZXggPT09IDAgPyByYW5nZVNpemVbMF0gKyAxIDogMHgxMDAwMDAwMDA7XG4gICAgICAgICAgICB2YXIgZyA9IFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbF8xLnVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25JbnRlcm5hbChpbmRleFJhbmdlU2l6ZSwgcm5nKTtcbiAgICAgICAgICAgIG91dFtpbmRleF0gPSBnO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggIT09IHJhbmdlTGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IG91dFtpbmRleF07XG4gICAgICAgICAgICB2YXIgY3VycmVudEluUmFuZ2UgPSByYW5nZVNpemVbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPCBjdXJyZW50SW5SYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50ID4gY3VycmVudEluUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uSW50ZXJuYWwgPSB1bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25JbnRlcm5hbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdm9pZCAwO1xuZnVuY3Rpb24gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsKHJhbmdlU2l6ZSwgcm5nKSB7XG4gICAgdmFyIE1pblJuZyA9IHJuZy5taW4oKTtcbiAgICB2YXIgTnVtVmFsdWVzID0gcm5nLm1heCgpIC0gcm5nLm1pbigpICsgMTtcbiAgICBpZiAocmFuZ2VTaXplIDw9IE51bVZhbHVlcykge1xuICAgICAgICB2YXIgbnJuZ18xID0gcm5nO1xuICAgICAgICB2YXIgTWF4QWxsb3dlZCA9IE51bVZhbHVlcyAtIChOdW1WYWx1ZXMgJSByYW5nZVNpemUpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIG91dCA9IG5ybmdfMS51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YXIgZGVsdGFWID0gb3V0IC0gTWluUm5nO1xuICAgICAgICAgICAgaWYgKGRlbHRhViA8IE1heEFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVsdGFWICUgcmFuZ2VTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBGaW5hbE51bVZhbHVlcyA9IE51bVZhbHVlcyAqIE51bVZhbHVlcztcbiAgICB2YXIgTnVtSXRlcmF0aW9ucyA9IDI7XG4gICAgd2hpbGUgKEZpbmFsTnVtVmFsdWVzIDwgcmFuZ2VTaXplKSB7XG4gICAgICAgIEZpbmFsTnVtVmFsdWVzICo9IE51bVZhbHVlcztcbiAgICAgICAgKytOdW1JdGVyYXRpb25zO1xuICAgIH1cbiAgICB2YXIgTWF4QWNjZXB0ZWRSYW5kb20gPSByYW5nZVNpemUgKiBNYXRoLmZsb29yKCgxICogRmluYWxOdW1WYWx1ZXMpIC8gcmFuZ2VTaXplKTtcbiAgICB2YXIgbnJuZyA9IHJuZztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKHZhciBudW0gPSAwOyBudW0gIT09IE51bUl0ZXJhdGlvbnM7ICsrbnVtKSB7XG4gICAgICAgICAgICB2YXIgb3V0ID0gbnJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB2YWx1ZSA9IE51bVZhbHVlcyAqIHZhbHVlICsgKG91dCAtIE1pblJuZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgTWF4QWNjZXB0ZWRSYW5kb20pIHtcbiAgICAgICAgICAgIHZhciBpbkRpZmYgPSB2YWx1ZSAtIHJhbmdlU2l6ZSAqIE1hdGguZmxvb3IoKDEgKiB2YWx1ZSkgLyByYW5nZVNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGluRGlmZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsID0gdW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbkludGVybmFsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IGV4cG9ydHMuY29uZ3J1ZW50aWFsID0gdm9pZCAwO1xudmFyIE1VTFRJUExJRVIgPSAweDAwMDM0M2ZkO1xudmFyIElOQ1JFTUVOVCA9IDB4MDAyNjllYzM7XG52YXIgTUFTSyA9IDB4ZmZmZmZmZmY7XG52YXIgTUFTS18yID0gKDEgPDwgMzEpIC0gMTtcbnZhciBjb21wdXRlTmV4dFNlZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiAoc2VlZCAqIE1VTFRJUExJRVIgKyBJTkNSRU1FTlQpICYgTUFTSztcbn07XG52YXIgY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkID0gZnVuY3Rpb24gKG5leHRzZWVkKSB7XG4gICAgcmV0dXJuIChuZXh0c2VlZCAmIE1BU0tfMikgPj4gMTY7XG59O1xudmFyIExpbmVhckNvbmdydWVudGlhbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGluZWFyQ29uZ3J1ZW50aWFsKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwubWluO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwubWF4O1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwodGhpcy5zZWVkKTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbC5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNlZWQgPSBjb21wdXRlTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIGNvbXB1dGVWYWx1ZUZyb21OZXh0U2VlZCh0aGlzLnNlZWQpO1xuICAgIH07XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLm1pbiA9IDA7XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsLm1heCA9IE1hdGgucG93KDIsIDE1KSAtIDE7XG4gICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDtcbn0oKSk7XG52YXIgTGluZWFyQ29uZ3J1ZW50aWFsMzIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmVhckNvbmdydWVudGlhbDMyKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICB9XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIExpbmVhckNvbmdydWVudGlhbDMyLm1pbjtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBMaW5lYXJDb25ncnVlbnRpYWwzMi5tYXg7XG4gICAgfTtcbiAgICBMaW5lYXJDb25ncnVlbnRpYWwzMi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsMzIodGhpcy5zZWVkKTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBMaW5lYXJDb25ncnVlbnRpYWwzMih0aGlzLnNlZWQpO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLnByb3RvdHlwZS51bnNhZmVOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgczEgPSBjb21wdXRlTmV4dFNlZWQodGhpcy5zZWVkKTtcbiAgICAgICAgdmFyIHYxID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHMxKTtcbiAgICAgICAgdmFyIHMyID0gY29tcHV0ZU5leHRTZWVkKHMxKTtcbiAgICAgICAgdmFyIHYyID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHMyKTtcbiAgICAgICAgdGhpcy5zZWVkID0gY29tcHV0ZU5leHRTZWVkKHMyKTtcbiAgICAgICAgdmFyIHYzID0gY29tcHV0ZVZhbHVlRnJvbU5leHRTZWVkKHRoaXMuc2VlZCk7XG4gICAgICAgIHZhciB2bmV4dCA9IHYzICsgKCh2MiArICh2MSA8PCAxNSkpIDw8IDE1KTtcbiAgICAgICAgcmV0dXJuICgodm5leHQgKyAweDgwMDAwMDAwKSB8IDApICsgMHg4MDAwMDAwMDtcbiAgICB9O1xuICAgIExpbmVhckNvbmdydWVudGlhbDMyLm1pbiA9IDA7XG4gICAgTGluZWFyQ29uZ3J1ZW50aWFsMzIubWF4ID0gMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gTGluZWFyQ29uZ3J1ZW50aWFsMzI7XG59KCkpO1xudmFyIGNvbmdydWVudGlhbCA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBMaW5lYXJDb25ncnVlbnRpYWwoc2VlZCk7XG59O1xuZXhwb3J0cy5jb25ncnVlbnRpYWwgPSBjb25ncnVlbnRpYWw7XG52YXIgY29uZ3J1ZW50aWFsMzIgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyQ29uZ3J1ZW50aWFsMzIoc2VlZCk7XG59O1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IGNvbmdydWVudGlhbDMyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIE1lcnNlbm5lVHdpc3RlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVyc2VubmVUd2lzdGVyKHN0YXRlcywgaW5kZXgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBzdGF0ZXM7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICB9XG4gICAgTWVyc2VubmVUd2lzdGVyLnR3aXN0ID0gZnVuY3Rpb24gKHByZXYpIHtcbiAgICAgICAgdmFyIG10ID0gcHJldi5zbGljZSgpO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OIC0gTWVyc2VubmVUd2lzdGVyLk07ICsraWR4KSB7XG4gICAgICAgICAgICB2YXIgeV8xID0gKG10W2lkeF0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUikgKyAobXRbaWR4ICsgMV0gJiBNZXJzZW5uZVR3aXN0ZXIuTUFTS19MT1dFUik7XG4gICAgICAgICAgICBtdFtpZHhdID0gbXRbaWR4ICsgTWVyc2VubmVUd2lzdGVyLk1dIF4gKHlfMSA+Pj4gMSkgXiAoLSh5XzEgJiAxKSAmIE1lcnNlbm5lVHdpc3Rlci5BKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpZHggPSBNZXJzZW5uZVR3aXN0ZXIuTiAtIE1lcnNlbm5lVHdpc3Rlci5NOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OIC0gMTsgKytpZHgpIHtcbiAgICAgICAgICAgIHZhciB5XzIgPSAobXRbaWR4XSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSKSArIChtdFtpZHggKyAxXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSKTtcbiAgICAgICAgICAgIG10W2lkeF0gPSBtdFtpZHggKyBNZXJzZW5uZVR3aXN0ZXIuTSAtIE1lcnNlbm5lVHdpc3Rlci5OXSBeICh5XzIgPj4+IDEpIF4gKC0oeV8yICYgMSkgJiBNZXJzZW5uZVR3aXN0ZXIuQSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHkgPSAobXRbTWVyc2VubmVUd2lzdGVyLk4gLSAxXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX1VQUEVSKSArIChtdFswXSAmIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSKTtcbiAgICAgICAgbXRbTWVyc2VubmVUd2lzdGVyLk4gLSAxXSA9IG10W01lcnNlbm5lVHdpc3Rlci5NIC0gMV0gXiAoeSA+Pj4gMSkgXiAoLSh5ICYgMSkgJiBNZXJzZW5uZVR3aXN0ZXIuQSk7XG4gICAgICAgIHJldHVybiBtdDtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5zZWVkZWQgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICB2YXIgb3V0ID0gQXJyYXkoTWVyc2VubmVUd2lzdGVyLk4pO1xuICAgICAgICBvdXRbMF0gPSBzZWVkO1xuICAgICAgICBmb3IgKHZhciBpZHggPSAxOyBpZHggIT09IE1lcnNlbm5lVHdpc3Rlci5OOyArK2lkeCkge1xuICAgICAgICAgICAgdmFyIHhvcmVkID0gb3V0W2lkeCAtIDFdIF4gKG91dFtpZHggLSAxXSA+Pj4gMzApO1xuICAgICAgICAgICAgb3V0W2lkeF0gPSAoTWF0aC5pbXVsKE1lcnNlbm5lVHdpc3Rlci5GLCB4b3JlZCkgKyBpZHgpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLmZyb20gPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICByZXR1cm4gbmV3IE1lcnNlbm5lVHdpc3RlcihNZXJzZW5uZVR3aXN0ZXIudHdpc3QoTWVyc2VubmVUd2lzdGVyLnNlZWRlZChzZWVkKSksIDApO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXIubWluO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBNZXJzZW5uZVR3aXN0ZXIubWF4O1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNZXJzZW5uZVR3aXN0ZXIodGhpcy5zdGF0ZXMsIHRoaXMuaW5kZXgpO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBNZXJzZW5uZVR3aXN0ZXIodGhpcy5zdGF0ZXMsIHRoaXMuaW5kZXgpO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHkgPSB0aGlzLnN0YXRlc1t0aGlzLmluZGV4XTtcbiAgICAgICAgeSBePSB0aGlzLnN0YXRlc1t0aGlzLmluZGV4XSA+Pj4gTWVyc2VubmVUd2lzdGVyLlU7XG4gICAgICAgIHkgXj0gKHkgPDwgTWVyc2VubmVUd2lzdGVyLlMpICYgTWVyc2VubmVUd2lzdGVyLkI7XG4gICAgICAgIHkgXj0gKHkgPDwgTWVyc2VubmVUd2lzdGVyLlQpICYgTWVyc2VubmVUd2lzdGVyLkM7XG4gICAgICAgIHkgXj0geSA+Pj4gTWVyc2VubmVUd2lzdGVyLkw7XG4gICAgICAgIGlmICgrK3RoaXMuaW5kZXggPj0gTWVyc2VubmVUd2lzdGVyLk4pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzID0gTWVyc2VubmVUd2lzdGVyLnR3aXN0KHRoaXMuc3RhdGVzKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5ID4+PiAwO1xuICAgIH07XG4gICAgTWVyc2VubmVUd2lzdGVyLm1pbiA9IDA7XG4gICAgTWVyc2VubmVUd2lzdGVyLm1heCA9IDB4ZmZmZmZmZmY7XG4gICAgTWVyc2VubmVUd2lzdGVyLk4gPSA2MjQ7XG4gICAgTWVyc2VubmVUd2lzdGVyLk0gPSAzOTc7XG4gICAgTWVyc2VubmVUd2lzdGVyLlIgPSAzMTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuQSA9IDB4OTkwOGIwZGY7XG4gICAgTWVyc2VubmVUd2lzdGVyLkYgPSAxODEyNDMzMjUzO1xuICAgIE1lcnNlbm5lVHdpc3Rlci5VID0gMTE7XG4gICAgTWVyc2VubmVUd2lzdGVyLlMgPSA3O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5CID0gMHg5ZDJjNTY4MDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuVCA9IDE1O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5DID0gMHhlZmM2MDAwMDtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTCA9IDE4O1xuICAgIE1lcnNlbm5lVHdpc3Rlci5NQVNLX0xPV0VSID0gTWF0aC5wb3coMiwgTWVyc2VubmVUd2lzdGVyLlIpIC0gMTtcbiAgICBNZXJzZW5uZVR3aXN0ZXIuTUFTS19VUFBFUiA9IE1hdGgucG93KDIsIE1lcnNlbm5lVHdpc3Rlci5SKTtcbiAgICByZXR1cm4gTWVyc2VubmVUd2lzdGVyO1xufSgpKTtcbmZ1bmN0aW9uIGRlZmF1bHRfMShzZWVkKSB7XG4gICAgcmV0dXJuIE1lcnNlbm5lVHdpc3Rlci5mcm9tKHNlZWQpO1xufVxuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBkZWZhdWx0XzE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNraXBOID0gZXhwb3J0cy51bnNhZmVTa2lwTiA9IGV4cG9ydHMuZ2VuZXJhdGVOID0gZXhwb3J0cy51bnNhZmVHZW5lcmF0ZU4gPSB2b2lkIDA7XG5mdW5jdGlvbiB1bnNhZmVHZW5lcmF0ZU4ocm5nLCBudW0pIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4ICE9IG51bTsgKytpZHgpIHtcbiAgICAgICAgb3V0LnB1c2gocm5nLnVuc2FmZU5leHQoKSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG5leHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IHVuc2FmZUdlbmVyYXRlTjtcbmZ1bmN0aW9uIGdlbmVyYXRlTihybmcsIG51bSkge1xuICAgIHZhciBuZXh0Um5nID0gcm5nLmNsb25lKCk7XG4gICAgdmFyIG91dCA9IHVuc2FmZUdlbmVyYXRlTihuZXh0Um5nLCBudW0pO1xuICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbn1cbmV4cG9ydHMuZ2VuZXJhdGVOID0gZ2VuZXJhdGVOO1xuZnVuY3Rpb24gdW5zYWZlU2tpcE4ocm5nLCBudW0pIHtcbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggIT0gbnVtOyArK2lkeCkge1xuICAgICAgICBybmcudW5zYWZlTmV4dCgpO1xuICAgIH1cbn1cbmV4cG9ydHMudW5zYWZlU2tpcE4gPSB1bnNhZmVTa2lwTjtcbmZ1bmN0aW9uIHNraXBOKHJuZywgbnVtKSB7XG4gICAgdmFyIG5leHRSbmcgPSBybmcuY2xvbmUoKTtcbiAgICB1bnNhZmVTa2lwTihuZXh0Um5nLCBudW0pO1xuICAgIHJldHVybiBuZXh0Um5nO1xufVxuZXhwb3J0cy5za2lwTiA9IHNraXBOO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSB2b2lkIDA7XG52YXIgWG9yU2hpZnQxMjhQbHVzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBYb3JTaGlmdDEyOFBsdXMoczAxLCBzMDAsIHMxMSwgczEwKSB7XG4gICAgICAgIHRoaXMuczAxID0gczAxO1xuICAgICAgICB0aGlzLnMwMCA9IHMwMDtcbiAgICAgICAgdGhpcy5zMTEgPSBzMTE7XG4gICAgICAgIHRoaXMuczEwID0gczEwO1xuICAgIH1cbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC0weDgwMDAwMDAwO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAweDdmZmZmZmZmO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICB2YXIgb3V0ID0gbmV4dFJuZy51bnNhZmVOZXh0KCk7XG4gICAgICAgIHJldHVybiBbb3V0LCBuZXh0Um5nXTtcbiAgICB9O1xuICAgIFhvclNoaWZ0MTI4UGx1cy5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGEwID0gdGhpcy5zMDAgXiAodGhpcy5zMDAgPDwgMjMpO1xuICAgICAgICB2YXIgYTEgPSB0aGlzLnMwMSBeICgodGhpcy5zMDEgPDwgMjMpIHwgKHRoaXMuczAwID4+PiA5KSk7XG4gICAgICAgIHZhciBiMCA9IGEwIF4gdGhpcy5zMTAgXiAoKGEwID4+PiAxOCkgfCAoYTEgPDwgMTQpKSBeICgodGhpcy5zMTAgPj4+IDUpIHwgKHRoaXMuczExIDw8IDI3KSk7XG4gICAgICAgIHZhciBiMSA9IGExIF4gdGhpcy5zMTEgXiAoYTEgPj4+IDE4KSBeICh0aGlzLnMxMSA+Pj4gNSk7XG4gICAgICAgIHZhciBvdXQgPSAodGhpcy5zMDAgKyB0aGlzLnMxMCkgfCAwO1xuICAgICAgICB0aGlzLnMwMSA9IHRoaXMuczExO1xuICAgICAgICB0aGlzLnMwMCA9IHRoaXMuczEwO1xuICAgICAgICB0aGlzLnMxMSA9IGIxO1xuICAgICAgICB0aGlzLnMxMCA9IGIwO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH07XG4gICAgWG9yU2hpZnQxMjhQbHVzLnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JTaGlmdDEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgICAgICBuZXh0Um5nLnVuc2FmZUp1bXAoKTtcbiAgICAgICAgcmV0dXJuIG5leHRSbmc7XG4gICAgfTtcbiAgICBYb3JTaGlmdDEyOFBsdXMucHJvdG90eXBlLnVuc2FmZUp1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuczAxID0gMDtcbiAgICAgICAgdmFyIG5zMDAgPSAwO1xuICAgICAgICB2YXIgbnMxMSA9IDA7XG4gICAgICAgIHZhciBuczEwID0gMDtcbiAgICAgICAgdmFyIGp1bXAgPSBbMHg2MzVkMmRmZiwgMHg4YTVjZDc4OSwgMHg1YzQ3MmY5NiwgMHgxMjFmZDIxNV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpICE9PSA0OyArK2kpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG1hc2sgPSAxOyBtYXNrOyBtYXNrIDw8PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGp1bXBbaV0gJiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5zMDEgXj0gdGhpcy5zMDE7XG4gICAgICAgICAgICAgICAgICAgIG5zMDAgXj0gdGhpcy5zMDA7XG4gICAgICAgICAgICAgICAgICAgIG5zMTEgXj0gdGhpcy5zMTE7XG4gICAgICAgICAgICAgICAgICAgIG5zMTAgXj0gdGhpcy5zMTA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudW5zYWZlTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuczAxID0gbnMwMTtcbiAgICAgICAgdGhpcy5zMDAgPSBuczAwO1xuICAgICAgICB0aGlzLnMxMSA9IG5zMTE7XG4gICAgICAgIHRoaXMuczEwID0gbnMxMDtcbiAgICB9O1xuICAgIHJldHVybiBYb3JTaGlmdDEyOFBsdXM7XG59KCkpO1xudmFyIHhvcnNoaWZ0MTI4cGx1cyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBYb3JTaGlmdDEyOFBsdXMoLTEsIH5zZWVkLCBzZWVkIHwgMCwgMCk7XG59O1xuZXhwb3J0cy54b3JzaGlmdDEyOHBsdXMgPSB4b3JzaGlmdDEyOHBsdXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSB2b2lkIDA7XG52YXIgWG9yb1NoaXJvMTI4UGx1cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWG9yb1NoaXJvMTI4UGx1cyhzMDEsIHMwMCwgczExLCBzMTApIHtcbiAgICAgICAgdGhpcy5zMDEgPSBzMDE7XG4gICAgICAgIHRoaXMuczAwID0gczAwO1xuICAgICAgICB0aGlzLnMxMSA9IHMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBzMTA7XG4gICAgfVxuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIC0weDgwMDAwMDAwO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUubWF4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gMHg3ZmZmZmZmZjtcbiAgICB9O1xuICAgIFhvcm9TaGlybzEyOFBsdXMucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFhvcm9TaGlybzEyOFBsdXModGhpcy5zMDEsIHRoaXMuczAwLCB0aGlzLnMxMSwgdGhpcy5zMTApO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHRSbmcgPSBuZXcgWG9yb1NoaXJvMTI4UGx1cyh0aGlzLnMwMSwgdGhpcy5zMDAsIHRoaXMuczExLCB0aGlzLnMxMCk7XG4gICAgICAgIHZhciBvdXQgPSBuZXh0Um5nLnVuc2FmZU5leHQoKTtcbiAgICAgICAgcmV0dXJuIFtvdXQsIG5leHRSbmddO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUudW5zYWZlTmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG91dCA9ICh0aGlzLnMwMCArIHRoaXMuczEwKSB8IDA7XG4gICAgICAgIHZhciBhMCA9IHRoaXMuczEwIF4gdGhpcy5zMDA7XG4gICAgICAgIHZhciBhMSA9IHRoaXMuczExIF4gdGhpcy5zMDE7XG4gICAgICAgIHZhciBzMDAgPSB0aGlzLnMwMDtcbiAgICAgICAgdmFyIHMwMSA9IHRoaXMuczAxO1xuICAgICAgICB0aGlzLnMwMCA9IChzMDAgPDwgMjQpIF4gKHMwMSA+Pj4gOCkgXiBhMCBeIChhMCA8PCAxNik7XG4gICAgICAgIHRoaXMuczAxID0gKHMwMSA8PCAyNCkgXiAoczAwID4+PiA4KSBeIGExIF4gKChhMSA8PCAxNikgfCAoYTAgPj4+IDE2KSk7XG4gICAgICAgIHRoaXMuczEwID0gKGExIDw8IDUpIF4gKGEwID4+PiAyNyk7XG4gICAgICAgIHRoaXMuczExID0gKGEwIDw8IDUpIF4gKGExID4+PiAyNyk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBYb3JvU2hpcm8xMjhQbHVzLnByb3RvdHlwZS5qdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV4dFJuZyA9IG5ldyBYb3JvU2hpcm8xMjhQbHVzKHRoaXMuczAxLCB0aGlzLnMwMCwgdGhpcy5zMTEsIHRoaXMuczEwKTtcbiAgICAgICAgbmV4dFJuZy51bnNhZmVKdW1wKCk7XG4gICAgICAgIHJldHVybiBuZXh0Um5nO1xuICAgIH07XG4gICAgWG9yb1NoaXJvMTI4UGx1cy5wcm90b3R5cGUudW5zYWZlSnVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5zMDEgPSAwO1xuICAgICAgICB2YXIgbnMwMCA9IDA7XG4gICAgICAgIHZhciBuczExID0gMDtcbiAgICAgICAgdmFyIG5zMTAgPSAwO1xuICAgICAgICB2YXIganVtcCA9IFsweGQ4ZjU1NGE1LCAweGRmOTAwMjk0LCAweDRiMzIwMWZjLCAweDE3MDg2NWRmXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgIT09IDQ7ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgbWFzayA9IDE7IG1hc2s7IG1hc2sgPDw9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAoanVtcFtpXSAmIG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgbnMwMSBePSB0aGlzLnMwMTtcbiAgICAgICAgICAgICAgICAgICAgbnMwMCBePSB0aGlzLnMwMDtcbiAgICAgICAgICAgICAgICAgICAgbnMxMSBePSB0aGlzLnMxMTtcbiAgICAgICAgICAgICAgICAgICAgbnMxMCBePSB0aGlzLnMxMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51bnNhZmVOZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zMDEgPSBuczAxO1xuICAgICAgICB0aGlzLnMwMCA9IG5zMDA7XG4gICAgICAgIHRoaXMuczExID0gbnMxMTtcbiAgICAgICAgdGhpcy5zMTAgPSBuczEwO1xuICAgIH07XG4gICAgcmV0dXJuIFhvcm9TaGlybzEyOFBsdXM7XG59KCkpO1xudmFyIHhvcm9zaGlybzEyOHBsdXMgPSBmdW5jdGlvbiAoc2VlZCkge1xuICAgIHJldHVybiBuZXcgWG9yb1NoaXJvMTI4UGx1cygtMSwgfnNlZWQsIHNlZWQgfCAwLCAwKTtcbn07XG5leHBvcnRzLnhvcm9zaGlybzEyOHBsdXMgPSB4b3Jvc2hpcm8xMjhwbHVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uID0gZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1JbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBleHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IGV4cG9ydHMueG9yb3NoaXJvMTI4cGx1cyA9IGV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0gZXhwb3J0cy5tZXJzZW5uZSA9IGV4cG9ydHMuY29uZ3J1ZW50aWFsMzIgPSBleHBvcnRzLmNvbmdydWVudGlhbCA9IGV4cG9ydHMudW5zYWZlU2tpcE4gPSBleHBvcnRzLnVuc2FmZUdlbmVyYXRlTiA9IGV4cG9ydHMuc2tpcE4gPSBleHBvcnRzLmdlbmVyYXRlTiA9IGV4cG9ydHMuX19jb21taXRIYXNoID0gZXhwb3J0cy5fX3ZlcnNpb24gPSBleHBvcnRzLl9fdHlwZSA9IHZvaWQgMDtcbnZhciBSYW5kb21HZW5lcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9SYW5kb21HZW5lcmF0b3JcIik7XG5leHBvcnRzLmdlbmVyYXRlTiA9IFJhbmRvbUdlbmVyYXRvcl8xLmdlbmVyYXRlTjtcbmV4cG9ydHMuc2tpcE4gPSBSYW5kb21HZW5lcmF0b3JfMS5za2lwTjtcbmV4cG9ydHMudW5zYWZlR2VuZXJhdGVOID0gUmFuZG9tR2VuZXJhdG9yXzEudW5zYWZlR2VuZXJhdGVOO1xuZXhwb3J0cy51bnNhZmVTa2lwTiA9IFJhbmRvbUdlbmVyYXRvcl8xLnVuc2FmZVNraXBOO1xudmFyIExpbmVhckNvbmdydWVudGlhbF8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL0xpbmVhckNvbmdydWVudGlhbFwiKTtcbmV4cG9ydHMuY29uZ3J1ZW50aWFsID0gTGluZWFyQ29uZ3J1ZW50aWFsXzEuY29uZ3J1ZW50aWFsO1xuZXhwb3J0cy5jb25ncnVlbnRpYWwzMiA9IExpbmVhckNvbmdydWVudGlhbF8xLmNvbmdydWVudGlhbDMyO1xudmFyIE1lcnNlbm5lVHdpc3Rlcl8xID0gcmVxdWlyZShcIi4vZ2VuZXJhdG9yL01lcnNlbm5lVHdpc3RlclwiKTtcbmV4cG9ydHMubWVyc2VubmUgPSBNZXJzZW5uZVR3aXN0ZXJfMVtcImRlZmF1bHRcIl07XG52YXIgWG9yU2hpZnRfMSA9IHJlcXVpcmUoXCIuL2dlbmVyYXRvci9Yb3JTaGlmdFwiKTtcbmV4cG9ydHMueG9yc2hpZnQxMjhwbHVzID0gWG9yU2hpZnRfMS54b3JzaGlmdDEyOHBsdXM7XG52YXIgWG9yb1NoaXJvXzEgPSByZXF1aXJlKFwiLi9nZW5lcmF0b3IvWG9yb1NoaXJvXCIpO1xuZXhwb3J0cy54b3Jvc2hpcm8xMjhwbHVzID0gWG9yb1NoaXJvXzEueG9yb3NoaXJvMTI4cGx1cztcbnZhciBVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbiA9IFVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbl8xLnVuaWZvcm1BcnJheUludERpc3RyaWJ1dGlvbjtcbnZhciBVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbiA9IFVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25fMS51bmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uO1xudmFyIFVuaWZvcm1JbnREaXN0cmlidXRpb25fMSA9IHJlcXVpcmUoXCIuL2Rpc3RyaWJ1dGlvbi9Vbmlmb3JtSW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bmlmb3JtSW50RGlzdHJpYnV0aW9uID0gVW5pZm9ybUludERpc3RyaWJ1dGlvbl8xLnVuaWZvcm1JbnREaXN0cmlidXRpb247XG52YXIgVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUFycmF5SW50RGlzdHJpYnV0aW9uXCIpO1xuZXhwb3J0cy51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb24gPSBVbnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtQXJyYXlJbnREaXN0cmlidXRpb247XG52YXIgVW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbl8xID0gcmVxdWlyZShcIi4vZGlzdHJpYnV0aW9uL1Vuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb25cIik7XG5leHBvcnRzLnVuc2FmZVVuaWZvcm1CaWdJbnREaXN0cmlidXRpb24gPSBVbnNhZmVVbmlmb3JtQmlnSW50RGlzdHJpYnV0aW9uXzEudW5zYWZlVW5pZm9ybUJpZ0ludERpc3RyaWJ1dGlvbjtcbnZhciBVbnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uXzEgPSByZXF1aXJlKFwiLi9kaXN0cmlidXRpb24vVW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvblwiKTtcbmV4cG9ydHMudW5zYWZlVW5pZm9ybUludERpc3RyaWJ1dGlvbiA9IFVuc2FmZVVuaWZvcm1JbnREaXN0cmlidXRpb25fMS51bnNhZmVVbmlmb3JtSW50RGlzdHJpYnV0aW9uO1xudmFyIF9fdHlwZSA9ICdjb21tb25qcyc7XG5leHBvcnRzLl9fdHlwZSA9IF9fdHlwZTtcbnZhciBfX3ZlcnNpb24gPSAnNS4wLjAnO1xuZXhwb3J0cy5fX3ZlcnNpb24gPSBfX3ZlcnNpb247XG52YXIgX19jb21taXRIYXNoID0gJzc0NDU1NTg1NWEwMWUxNTUxYWIxY2Y2N2E2ZWE5NzNkMTQ5NjQ2NjEnO1xuZXhwb3J0cy5fX2NvbW1pdEhhc2ggPSBfX2NvbW1pdEhhc2g7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGV4cG9ydHMsIHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbnZhciBwcmFuZCA9IHJlcXVpcmUoXCIuL3B1cmUtcmFuZC1kZWZhdWx0XCIpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBwcmFuZDtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wdXJlLXJhbmQtZGVmYXVsdFwiKSwgZXhwb3J0cyk7XG4iLCJ2YXIgbW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xuXG5mdW5jdGlvbiBRUjhiaXRCeXRlKGRhdGEpIHtcblx0dGhpcy5tb2RlID0gbW9kZS5NT0RFXzhCSVRfQllURTtcblx0dGhpcy5kYXRhID0gZGF0YTtcbn1cblxuUVI4Yml0Qnl0ZS5wcm90b3R5cGUgPSB7XG5cblx0Z2V0TGVuZ3RoIDogZnVuY3Rpb24oYnVmZmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG5cdH0sXG5cdFxuXHR3cml0ZSA6IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQvLyBub3QgSklTIC4uLlxuXHRcdFx0YnVmZmVyLnB1dCh0aGlzLmRhdGEuY2hhckNvZGVBdChpKSwgOCk7XG5cdFx0fVxuXHR9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFFSOGJpdEJ5dGU7XG5cbiIsImZ1bmN0aW9uIFFSQml0QnVmZmVyKCkge1xuXHR0aGlzLmJ1ZmZlciA9IG5ldyBBcnJheSgpO1xuXHR0aGlzLmxlbmd0aCA9IDA7XG59XG5cblFSQml0QnVmZmVyLnByb3RvdHlwZSA9IHtcblxuXHRnZXQgOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHZhciBidWZJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyA4KTtcblx0XHRyZXR1cm4gKCAodGhpcy5idWZmZXJbYnVmSW5kZXhdID4+PiAoNyAtIGluZGV4ICUgOCkgKSAmIDEpID09IDE7XG5cdH0sXG5cdFxuXHRwdXQgOiBmdW5jdGlvbihudW0sIGxlbmd0aCkge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcblx0XHRcdHRoaXMucHV0Qml0KCAoIChudW0gPj4+IChsZW5ndGggLSBpIC0gMSkgKSAmIDEpID09IDEpO1xuXHRcdH1cblx0fSxcblx0XG5cdGdldExlbmd0aEluQml0cyA6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fSxcblx0XG5cdHB1dEJpdCA6IGZ1bmN0aW9uKGJpdCkge1xuXHRcblx0XHR2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKHRoaXMubGVuZ3RoIC8gOCk7XG5cdFx0aWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA8PSBidWZJbmRleCkge1xuXHRcdFx0dGhpcy5idWZmZXIucHVzaCgwKTtcblx0XHR9XG5cdFxuXHRcdGlmIChiaXQpIHtcblx0XHRcdHRoaXMuYnVmZmVyW2J1ZkluZGV4XSB8PSAoMHg4MCA+Pj4gKHRoaXMubGVuZ3RoICUgOCkgKTtcblx0XHR9XG5cdFxuXHRcdHRoaXMubGVuZ3RoKys7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJCaXRCdWZmZXI7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0TCA6IDEsXG5cdE0gOiAwLFxuXHRRIDogMyxcblx0SCA6IDJcbn07XG5cbiIsInZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5cbmZ1bmN0aW9uIFFSUG9seW5vbWlhbChudW0sIHNoaWZ0KSB7XG5cblx0aWYgKG51bS5sZW5ndGggPT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKG51bS5sZW5ndGggKyBcIi9cIiArIHNoaWZ0KTtcblx0fVxuXG5cdHZhciBvZmZzZXQgPSAwO1xuXG5cdHdoaWxlIChvZmZzZXQgPCBudW0ubGVuZ3RoICYmIG51bVtvZmZzZXRdID09IDApIHtcblx0XHRvZmZzZXQrKztcblx0fVxuXG5cdHRoaXMubnVtID0gbmV3IEFycmF5KG51bS5sZW5ndGggLSBvZmZzZXQgKyBzaGlmdCk7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aCAtIG9mZnNldDsgaSsrKSB7XG5cdFx0dGhpcy5udW1baV0gPSBudW1baSArIG9mZnNldF07XG5cdH1cbn1cblxuUVJQb2x5bm9taWFsLnByb3RvdHlwZSA9IHtcblxuXHRnZXQgOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLm51bVtpbmRleF07XG5cdH0sXG5cdFxuXHRnZXRMZW5ndGggOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5udW0ubGVuZ3RoO1xuXHR9LFxuXHRcblx0bXVsdGlwbHkgOiBmdW5jdGlvbihlKSB7XG5cdFxuXHRcdHZhciBudW0gPSBuZXcgQXJyYXkodGhpcy5nZXRMZW5ndGgoKSArIGUuZ2V0TGVuZ3RoKCkgLSAxKTtcblx0XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldExlbmd0aCgpOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZS5nZXRMZW5ndGgoKTsgaisrKSB7XG5cdFx0XHRcdG51bVtpICsgal0gXj0gbWF0aC5nZXhwKG1hdGguZ2xvZyh0aGlzLmdldChpKSApICsgbWF0aC5nbG9nKGUuZ2V0KGopICkgKTtcblx0XHRcdH1cblx0XHR9XG5cdFxuXHRcdHJldHVybiBuZXcgUVJQb2x5bm9taWFsKG51bSwgMCk7XG5cdH0sXG5cdFxuXHRtb2QgOiBmdW5jdGlvbihlKSB7XG5cdFxuXHRcdGlmICh0aGlzLmdldExlbmd0aCgpIC0gZS5nZXRMZW5ndGgoKSA8IDApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XG5cdFx0dmFyIHJhdGlvID0gbWF0aC5nbG9nKHRoaXMuZ2V0KDApICkgLSBtYXRoLmdsb2coZS5nZXQoMCkgKTtcblx0XG5cdFx0dmFyIG51bSA9IG5ldyBBcnJheSh0aGlzLmdldExlbmd0aCgpICk7XG5cdFx0XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmdldExlbmd0aCgpOyBpKyspIHtcblx0XHRcdG51bVtpXSA9IHRoaXMuZ2V0KGkpO1xuXHRcdH1cblx0XHRcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGUuZ2V0TGVuZ3RoKCk7IGkrKykge1xuXHRcdFx0bnVtW2ldIF49IG1hdGguZ2V4cChtYXRoLmdsb2coZS5nZXQoaSkgKSArIHJhdGlvKTtcblx0XHR9XG5cdFxuXHRcdC8vIHJlY3Vyc2l2ZSBjYWxsXG5cdFx0cmV0dXJuIG5ldyBRUlBvbHlub21pYWwobnVtLCAwKS5tb2QoZSk7XG5cdH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJQb2x5bm9taWFsO1xuIiwidmFyIEJpdEJ5dGUgPSByZXF1aXJlKCcuLzhCaXRCeXRlJyk7XG52YXIgUlNCbG9jayA9IHJlcXVpcmUoJy4vUlNCbG9jaycpO1xudmFyIEJpdEJ1ZmZlciA9IHJlcXVpcmUoJy4vQml0QnVmZmVyJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIFBvbHlub21pYWwgPSByZXF1aXJlKCcuL1BvbHlub21pYWwnKTtcblxuZnVuY3Rpb24gUVJDb2RlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsKSB7XG5cdHRoaXMudHlwZU51bWJlciA9IHR5cGVOdW1iZXI7XG5cdHRoaXMuZXJyb3JDb3JyZWN0TGV2ZWwgPSBlcnJvckNvcnJlY3RMZXZlbDtcblx0dGhpcy5tb2R1bGVzID0gbnVsbDtcblx0dGhpcy5tb2R1bGVDb3VudCA9IDA7XG5cdHRoaXMuZGF0YUNhY2hlID0gbnVsbDtcblx0dGhpcy5kYXRhTGlzdCA9IFtdO1xufVxuXG4vLyBmb3IgY2xpZW50IHNpZGUgbWluaWZpY2F0aW9uXG52YXIgcHJvdG8gPSBRUkNvZGUucHJvdG90eXBlO1xuXG5wcm90by5hZGREYXRhID0gZnVuY3Rpb24oZGF0YSkge1xuXHR2YXIgbmV3RGF0YSA9IG5ldyBCaXRCeXRlKGRhdGEpO1xuXHR0aGlzLmRhdGFMaXN0LnB1c2gobmV3RGF0YSk7XG5cdHRoaXMuZGF0YUNhY2hlID0gbnVsbDtcbn07XG5cbnByb3RvLmlzRGFyayA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cdGlmIChyb3cgPCAwIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gcm93IHx8IGNvbCA8IDAgfHwgdGhpcy5tb2R1bGVDb3VudCA8PSBjb2wpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3Iocm93ICsgXCIsXCIgKyBjb2wpO1xuXHR9XG5cdHJldHVybiB0aGlzLm1vZHVsZXNbcm93XVtjb2xdO1xufTtcblxucHJvdG8uZ2V0TW9kdWxlQ291bnQgPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXMubW9kdWxlQ291bnQ7XG59O1xuXG5wcm90by5tYWtlID0gZnVuY3Rpb24oKSB7XG5cdC8vIENhbGN1bGF0ZSBhdXRvbWF0aWNhbGx5IHR5cGVOdW1iZXIgaWYgcHJvdmlkZWQgaXMgPCAxXG5cdGlmICh0aGlzLnR5cGVOdW1iZXIgPCAxICl7XG5cdFx0dmFyIHR5cGVOdW1iZXIgPSAxO1xuXHRcdGZvciAodHlwZU51bWJlciA9IDE7IHR5cGVOdW1iZXIgPCA0MDsgdHlwZU51bWJlcisrKSB7XG5cdFx0XHR2YXIgcnNCbG9ja3MgPSBSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIHRoaXMuZXJyb3JDb3JyZWN0TGV2ZWwpO1xuXG5cdFx0XHR2YXIgYnVmZmVyID0gbmV3IEJpdEJ1ZmZlcigpO1xuXHRcdFx0dmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YUxpc3QubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0dmFyIGRhdGEgPSB0aGlzLmRhdGFMaXN0W2ldO1xuXHRcdFx0XHRidWZmZXIucHV0KGRhdGEubW9kZSwgNCk7XG5cdFx0XHRcdGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgdXRpbC5nZXRMZW5ndGhJbkJpdHMoZGF0YS5tb2RlLCB0eXBlTnVtYmVyKSApO1xuXHRcdFx0XHRkYXRhLndyaXRlKGJ1ZmZlcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpIDw9IHRvdGFsRGF0YUNvdW50ICogOClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMudHlwZU51bWJlciA9IHR5cGVOdW1iZXI7XG5cdH1cblx0dGhpcy5tYWtlSW1wbChmYWxzZSwgdGhpcy5nZXRCZXN0TWFza1BhdHRlcm4oKSApO1xufTtcblxucHJvdG8ubWFrZUltcGwgPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuXHRcblx0dGhpcy5tb2R1bGVDb3VudCA9IHRoaXMudHlwZU51bWJlciAqIDQgKyAxNztcblx0dGhpcy5tb2R1bGVzID0gbmV3IEFycmF5KHRoaXMubW9kdWxlQ291bnQpO1xuXHRcblx0Zm9yICh2YXIgcm93ID0gMDsgcm93IDwgdGhpcy5tb2R1bGVDb3VudDsgcm93KyspIHtcblx0XHRcblx0XHR0aGlzLm1vZHVsZXNbcm93XSA9IG5ldyBBcnJheSh0aGlzLm1vZHVsZUNvdW50KTtcblx0XHRcblx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLm1vZHVsZUNvdW50OyBjb2wrKykge1xuXHRcdFx0dGhpcy5tb2R1bGVzW3Jvd11bY29sXSA9IG51bGw7Ly8oY29sICsgcm93KSAlIDM7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5zZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIDApO1xuXHR0aGlzLnNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4odGhpcy5tb2R1bGVDb3VudCAtIDcsIDApO1xuXHR0aGlzLnNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgdGhpcy5tb2R1bGVDb3VudCAtIDcpO1xuXHR0aGlzLnNldHVwUG9zaXRpb25BZGp1c3RQYXR0ZXJuKCk7XG5cdHRoaXMuc2V0dXBUaW1pbmdQYXR0ZXJuKCk7XG5cdHRoaXMuc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybik7XG5cdFxuXHRpZiAodGhpcy50eXBlTnVtYmVyID49IDcpIHtcblx0XHR0aGlzLnNldHVwVHlwZU51bWJlcih0ZXN0KTtcblx0fVxuXG5cdGlmICh0aGlzLmRhdGFDYWNoZSA9PSBudWxsKSB7XG5cdFx0dGhpcy5kYXRhQ2FjaGUgPSBRUkNvZGUuY3JlYXRlRGF0YSh0aGlzLnR5cGVOdW1iZXIsIHRoaXMuZXJyb3JDb3JyZWN0TGV2ZWwsIHRoaXMuZGF0YUxpc3QpO1xuXHR9XG5cblx0dGhpcy5tYXBEYXRhKHRoaXMuZGF0YUNhY2hlLCBtYXNrUGF0dGVybik7XG59O1xuXG5wcm90by5zZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuID0gZnVuY3Rpb24ocm93LCBjb2wpICB7XG5cdFxuXHRmb3IgKHZhciByID0gLTE7IHIgPD0gNzsgcisrKSB7XG5cdFx0XG5cdFx0aWYgKHJvdyArIHIgPD0gLTEgfHwgdGhpcy5tb2R1bGVDb3VudCA8PSByb3cgKyByKSBjb250aW51ZTtcblx0XHRcblx0XHRmb3IgKHZhciBjID0gLTE7IGMgPD0gNzsgYysrKSB7XG5cdFx0XHRcblx0XHRcdGlmIChjb2wgKyBjIDw9IC0xIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gY29sICsgYykgY29udGludWU7XG5cdFx0XHRcblx0XHRcdGlmICggKDAgPD0gciAmJiByIDw9IDYgJiYgKGMgPT0gMCB8fCBjID09IDYpIClcblx0XHRcdFx0XHR8fCAoMCA8PSBjICYmIGMgPD0gNiAmJiAociA9PSAwIHx8IHIgPT0gNikgKVxuXHRcdFx0XHRcdHx8ICgyIDw9IHIgJiYgciA8PSA0ICYmIDIgPD0gYyAmJiBjIDw9IDQpICkge1xuXHRcdFx0XHR0aGlzLm1vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVx0XHRcblx0fVx0XHRcbn07XG5cbnByb3RvLmdldEJlc3RNYXNrUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBtaW5Mb3N0UG9pbnQgPSAwO1xuXHR2YXIgcGF0dGVybiA9IDA7XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspIHtcblx0XHRcblx0XHR0aGlzLm1ha2VJbXBsKHRydWUsIGkpO1xuXG5cdFx0dmFyIGxvc3RQb2ludCA9IHV0aWwuZ2V0TG9zdFBvaW50KHRoaXMpO1xuXG5cdFx0aWYgKGkgPT0gMCB8fCBtaW5Mb3N0UG9pbnQgPiAgbG9zdFBvaW50KSB7XG5cdFx0XHRtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XG5cdFx0XHRwYXR0ZXJuID0gaTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gcGF0dGVybjtcbn07XG5cbnByb3RvLmNyZWF0ZU1vdmllQ2xpcCA9IGZ1bmN0aW9uKHRhcmdldF9tYywgaW5zdGFuY2VfbmFtZSwgZGVwdGgpIHtcblxuXHR2YXIgcXJfbWMgPSB0YXJnZXRfbWMuY3JlYXRlRW1wdHlNb3ZpZUNsaXAoaW5zdGFuY2VfbmFtZSwgZGVwdGgpO1xuXHR2YXIgY3MgPSAxO1xuXG5cdHRoaXMubWFrZSgpO1xuXG5cdGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMubW9kdWxlcy5sZW5ndGg7IHJvdysrKSB7XG5cdFx0XG5cdFx0dmFyIHkgPSByb3cgKiBjcztcblx0XHRcblx0XHRmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLm1vZHVsZXNbcm93XS5sZW5ndGg7IGNvbCsrKSB7XG5cblx0XHRcdHZhciB4ID0gY29sICogY3M7XG5cdFx0XHR2YXIgZGFyayA9IHRoaXMubW9kdWxlc1tyb3ddW2NvbF07XG5cdFx0XG5cdFx0XHRpZiAoZGFyaykge1xuXHRcdFx0XHRxcl9tYy5iZWdpbkZpbGwoMCwgMTAwKTtcblx0XHRcdFx0cXJfbWMubW92ZVRvKHgsIHkpO1xuXHRcdFx0XHRxcl9tYy5saW5lVG8oeCArIGNzLCB5KTtcblx0XHRcdFx0cXJfbWMubGluZVRvKHggKyBjcywgeSArIGNzKTtcblx0XHRcdFx0cXJfbWMubGluZVRvKHgsIHkgKyBjcyk7XG5cdFx0XHRcdHFyX21jLmVuZEZpbGwoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0XG5cdHJldHVybiBxcl9tYztcbn07XG5cbnByb3RvLnNldHVwVGltaW5nUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXHRcblx0Zm9yICh2YXIgciA9IDg7IHIgPCB0aGlzLm1vZHVsZUNvdW50IC0gODsgcisrKSB7XG5cdFx0aWYgKHRoaXMubW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0dGhpcy5tb2R1bGVzW3JdWzZdID0gKHIgJSAyID09IDApO1xuXHR9XG5cblx0Zm9yICh2YXIgYyA9IDg7IGMgPCB0aGlzLm1vZHVsZUNvdW50IC0gODsgYysrKSB7XG5cdFx0aWYgKHRoaXMubW9kdWxlc1s2XVtjXSAhPSBudWxsKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0dGhpcy5tb2R1bGVzWzZdW2NdID0gKGMgJSAyID09IDApO1xuXHR9XG59O1xuXG5wcm90by5zZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBwb3MgPSB1dGlsLmdldFBhdHRlcm5Qb3NpdGlvbih0aGlzLnR5cGVOdW1iZXIpO1xuXHRcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb3MubGVuZ3RoOyBpKyspIHtcblx0XG5cdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBwb3MubGVuZ3RoOyBqKyspIHtcblx0XHRcblx0XHRcdHZhciByb3cgPSBwb3NbaV07XG5cdFx0XHR2YXIgY29sID0gcG9zW2pdO1xuXHRcdFx0XG5cdFx0XHRpZiAodGhpcy5tb2R1bGVzW3Jvd11bY29sXSAhPSBudWxsKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRmb3IgKHZhciByID0gLTI7IHIgPD0gMjsgcisrKSB7XG5cdFx0XHRcblx0XHRcdFx0Zm9yICh2YXIgYyA9IC0yOyBjIDw9IDI7IGMrKykge1xuXHRcdFx0XHRcblx0XHRcdFx0XHRpZiAociA9PSAtMiB8fCByID09IDIgfHwgYyA9PSAtMiB8fCBjID09IDJcblx0XHRcdFx0XHRcdFx0fHwgKHIgPT0gMCAmJiBjID09IDApICkge1xuXHRcdFx0XHRcdFx0dGhpcy5tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5wcm90by5zZXR1cFR5cGVOdW1iZXIgPSBmdW5jdGlvbih0ZXN0KSB7XG5cblx0dmFyIGJpdHMgPSB1dGlsLmdldEJDSFR5cGVOdW1iZXIodGhpcy50eXBlTnVtYmVyKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IDE4OyBpKyspIHtcblx0XHR2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblx0XHR0aGlzLm1vZHVsZXNbTWF0aC5mbG9vcihpIC8gMyldW2kgJSAzICsgdGhpcy5tb2R1bGVDb3VudCAtIDggLSAzXSA9IG1vZDtcblx0fVxuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkrKykge1xuXHRcdHZhciBtb2QgPSAoIXRlc3QgJiYgKCAoYml0cyA+PiBpKSAmIDEpID09IDEpO1xuXHRcdHRoaXMubW9kdWxlc1tpICUgMyArIHRoaXMubW9kdWxlQ291bnQgLSA4IC0gM11bTWF0aC5mbG9vcihpIC8gMyldID0gbW9kO1xuXHR9XG59O1xuXG5wcm90by5zZXR1cFR5cGVJbmZvID0gZnVuY3Rpb24odGVzdCwgbWFza1BhdHRlcm4pIHtcblxuXHR2YXIgZGF0YSA9ICh0aGlzLmVycm9yQ29ycmVjdExldmVsIDw8IDMpIHwgbWFza1BhdHRlcm47XG5cdHZhciBiaXRzID0gdXRpbC5nZXRCQ0hUeXBlSW5mbyhkYXRhKTtcblxuXHQvLyB2ZXJ0aWNhbFx0XHRcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxNTsgaSsrKSB7XG5cblx0XHR2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblxuXHRcdGlmIChpIDwgNikge1xuXHRcdFx0dGhpcy5tb2R1bGVzW2ldWzhdID0gbW9kO1xuXHRcdH0gZWxzZSBpZiAoaSA8IDgpIHtcblx0XHRcdHRoaXMubW9kdWxlc1tpICsgMV1bOF0gPSBtb2Q7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubW9kdWxlc1t0aGlzLm1vZHVsZUNvdW50IC0gMTUgKyBpXVs4XSA9IG1vZDtcblx0XHR9XG5cdH1cblxuXHQvLyBob3Jpem9udGFsXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkrKykge1xuXG5cdFx0dmFyIG1vZCA9ICghdGVzdCAmJiAoIChiaXRzID4+IGkpICYgMSkgPT0gMSk7XG5cdFx0XG5cdFx0aWYgKGkgPCA4KSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbOF1bdGhpcy5tb2R1bGVDb3VudCAtIGkgLSAxXSA9IG1vZDtcblx0XHR9IGVsc2UgaWYgKGkgPCA5KSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbOF1bMTUgLSBpIC0gMSArIDFdID0gbW9kO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1vZHVsZXNbOF1bMTUgLSBpIC0gMV0gPSBtb2Q7XG5cdFx0fVxuXHR9XG5cblx0Ly8gZml4ZWQgbW9kdWxlXG5cdHRoaXMubW9kdWxlc1t0aGlzLm1vZHVsZUNvdW50IC0gOF1bOF0gPSAoIXRlc3QpO1xufTtcblxucHJvdG8ubWFwRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1hc2tQYXR0ZXJuKSB7XG5cdFxuXHR2YXIgaW5jID0gLTE7XG5cdHZhciByb3cgPSB0aGlzLm1vZHVsZUNvdW50IC0gMTtcblx0dmFyIGJpdEluZGV4ID0gNztcblx0dmFyIGJ5dGVJbmRleCA9IDA7XG5cdFxuXHRmb3IgKHZhciBjb2wgPSB0aGlzLm1vZHVsZUNvdW50IC0gMTsgY29sID4gMDsgY29sIC09IDIpIHtcblxuXHRcdGlmIChjb2wgPT0gNikgY29sLS07XG5cblx0XHR3aGlsZSAodHJ1ZSkge1xuXG5cdFx0XHRmb3IgKHZhciBjID0gMDsgYyA8IDI7IGMrKykge1xuXHRcdFx0XHRcblx0XHRcdFx0aWYgKHRoaXMubW9kdWxlc1tyb3ddW2NvbCAtIGNdID09IG51bGwpIHtcblx0XHRcdFx0XHRcblx0XHRcdFx0XHR2YXIgZGFyayA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKGJ5dGVJbmRleCA8IGRhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRkYXJrID0gKCAoIChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4KSAmIDEpID09IDEpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhciBtYXNrID0gdXRpbC5nZXRNYXNrKG1hc2tQYXR0ZXJuLCByb3csIGNvbCAtIGMpO1xuXG5cdFx0XHRcdFx0aWYgKG1hc2spIHtcblx0XHRcdFx0XHRcdGRhcmsgPSAhZGFyaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XG5cdFx0XHRcdFx0dGhpcy5tb2R1bGVzW3Jvd11bY29sIC0gY10gPSBkYXJrO1xuXHRcdFx0XHRcdGJpdEluZGV4LS07XG5cblx0XHRcdFx0XHRpZiAoYml0SW5kZXggPT0gLTEpIHtcblx0XHRcdFx0XHRcdGJ5dGVJbmRleCsrO1xuXHRcdFx0XHRcdFx0Yml0SW5kZXggPSA3O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcblx0XHRcdHJvdyArPSBpbmM7XG5cblx0XHRcdGlmIChyb3cgPCAwIHx8IHRoaXMubW9kdWxlQ291bnQgPD0gcm93KSB7XG5cdFx0XHRcdHJvdyAtPSBpbmM7XG5cdFx0XHRcdGluYyA9IC1pbmM7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuUVJDb2RlLlBBRDAgPSAweEVDO1xuUVJDb2RlLlBBRDEgPSAweDExO1xuXG5RUkNvZGUuY3JlYXRlRGF0YSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdExldmVsLCBkYXRhTGlzdCkge1xuXHRcblx0dmFyIHJzQmxvY2tzID0gUlNCbG9jay5nZXRSU0Jsb2Nrcyh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCk7XG5cdFxuXHR2YXIgYnVmZmVyID0gbmV3IEJpdEJ1ZmZlcigpO1xuXHRcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBkYXRhID0gZGF0YUxpc3RbaV07XG5cdFx0YnVmZmVyLnB1dChkYXRhLm1vZGUsIDQpO1xuXHRcdGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgdXRpbC5nZXRMZW5ndGhJbkJpdHMoZGF0YS5tb2RlLCB0eXBlTnVtYmVyKSApO1xuXHRcdGRhdGEud3JpdGUoYnVmZmVyKTtcblx0fVxuXG5cdC8vIGNhbGMgbnVtIG1heCBkYXRhLlxuXHR2YXIgdG90YWxEYXRhQ291bnQgPSAwO1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHJzQmxvY2tzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xuXHR9XG5cblx0aWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+IHRvdGFsRGF0YUNvdW50ICogOCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcImNvZGUgbGVuZ3RoIG92ZXJmbG93LiAoXCJcblx0XHRcdCsgYnVmZmVyLmdldExlbmd0aEluQml0cygpXG5cdFx0XHQrIFwiPlwiXG5cdFx0XHQrICB0b3RhbERhdGFDb3VudCAqIDhcblx0XHRcdCsgXCIpXCIpO1xuXHR9XG5cblx0Ly8gZW5kIGNvZGVcblx0aWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSArIDQgPD0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG5cdFx0YnVmZmVyLnB1dCgwLCA0KTtcblx0fVxuXG5cdC8vIHBhZGRpbmdcblx0d2hpbGUgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSAlIDggIT0gMCkge1xuXHRcdGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xuXHR9XG5cblx0Ly8gcGFkZGluZ1xuXHR3aGlsZSAodHJ1ZSkge1xuXHRcdFxuXHRcdGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0YnVmZmVyLnB1dChRUkNvZGUuUEFEMCwgOCk7XG5cdFx0XG5cdFx0aWYgKGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKSA+PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRidWZmZXIucHV0KFFSQ29kZS5QQUQxLCA4KTtcblx0fVxuXG5cdHJldHVybiBRUkNvZGUuY3JlYXRlQnl0ZXMoYnVmZmVyLCByc0Jsb2Nrcyk7XG59O1xuXG5RUkNvZGUuY3JlYXRlQnl0ZXMgPSBmdW5jdGlvbihidWZmZXIsIHJzQmxvY2tzKSB7XG5cblx0dmFyIG9mZnNldCA9IDA7XG5cdFxuXHR2YXIgbWF4RGNDb3VudCA9IDA7XG5cdHZhciBtYXhFY0NvdW50ID0gMDtcblx0XG5cdHZhciBkY2RhdGEgPSBuZXcgQXJyYXkocnNCbG9ja3MubGVuZ3RoKTtcblx0dmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuXHRcblx0Zm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIrKykge1xuXG5cdFx0dmFyIGRjQ291bnQgPSByc0Jsb2Nrc1tyXS5kYXRhQ291bnQ7XG5cdFx0dmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcblxuXHRcdG1heERjQ291bnQgPSBNYXRoLm1heChtYXhEY0NvdW50LCBkY0NvdW50KTtcblx0XHRtYXhFY0NvdW50ID0gTWF0aC5tYXgobWF4RWNDb3VudCwgZWNDb3VudCk7XG5cdFx0XG5cdFx0ZGNkYXRhW3JdID0gbmV3IEFycmF5KGRjQ291bnQpO1xuXHRcdFxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGNkYXRhW3JdLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRkY2RhdGFbcl1baV0gPSAweGZmICYgYnVmZmVyLmJ1ZmZlcltpICsgb2Zmc2V0XTtcblx0XHR9XG5cdFx0b2Zmc2V0ICs9IGRjQ291bnQ7XG5cdFx0XG5cdFx0dmFyIHJzUG9seSA9IHV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcblx0XHR2YXIgcmF3UG9seSA9IG5ldyBQb2x5bm9taWFsKGRjZGF0YVtyXSwgcnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG5cblx0XHR2YXIgbW9kUG9seSA9IHJhd1BvbHkubW9kKHJzUG9seSk7XG5cdFx0ZWNkYXRhW3JdID0gbmV3IEFycmF5KHJzUG9seS5nZXRMZW5ndGgoKSAtIDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZWNkYXRhW3JdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbW9kSW5kZXggPSBpICsgbW9kUG9seS5nZXRMZW5ndGgoKSAtIGVjZGF0YVtyXS5sZW5ndGg7XG5cdFx0XHRlY2RhdGFbcl1baV0gPSAobW9kSW5kZXggPj0gMCk/IG1vZFBvbHkuZ2V0KG1vZEluZGV4KSA6IDA7XG5cdFx0fVxuXG5cdH1cblx0XG5cdHZhciB0b3RhbENvZGVDb3VudCA9IDA7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpKyspIHtcblx0XHR0b3RhbENvZGVDb3VudCArPSByc0Jsb2Nrc1tpXS50b3RhbENvdW50O1xuXHR9XG5cblx0dmFyIGRhdGEgPSBuZXcgQXJyYXkodG90YWxDb2RlQ291bnQpO1xuXHR2YXIgaW5kZXggPSAwO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbWF4RGNDb3VudDsgaSsrKSB7XG5cdFx0Zm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIrKykge1xuXHRcdFx0aWYgKGkgPCBkY2RhdGFbcl0ubGVuZ3RoKSB7XG5cdFx0XHRcdGRhdGFbaW5kZXgrK10gPSBkY2RhdGFbcl1baV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXhFY0NvdW50OyBpKyspIHtcblx0XHRmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgcisrKSB7XG5cdFx0XHRpZiAoaSA8IGVjZGF0YVtyXS5sZW5ndGgpIHtcblx0XHRcdFx0ZGF0YVtpbmRleCsrXSA9IGVjZGF0YVtyXVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJDb2RlO1xuXG4iLCIvLyBFcnJvckNvcnJlY3RMZXZlbFxudmFyIEVDTCA9IHJlcXVpcmUoJy4vRXJyb3JDb3JyZWN0TGV2ZWwnKTtcblxuZnVuY3Rpb24gUVJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkge1xuXHR0aGlzLnRvdGFsQ291bnQgPSB0b3RhbENvdW50O1xuXHR0aGlzLmRhdGFDb3VudCAgPSBkYXRhQ291bnQ7XG59XG5cblFSUlNCbG9jay5SU19CTE9DS19UQUJMRSA9IFtcblxuXHQvLyBMXG5cdC8vIE1cblx0Ly8gUVxuXHQvLyBIXG5cblx0Ly8gMVxuXHRbMSwgMjYsIDE5XSxcblx0WzEsIDI2LCAxNl0sXG5cdFsxLCAyNiwgMTNdLFxuXHRbMSwgMjYsIDldLFxuXHRcblx0Ly8gMlxuXHRbMSwgNDQsIDM0XSxcblx0WzEsIDQ0LCAyOF0sXG5cdFsxLCA0NCwgMjJdLFxuXHRbMSwgNDQsIDE2XSxcblxuXHQvLyAzXG5cdFsxLCA3MCwgNTVdLFxuXHRbMSwgNzAsIDQ0XSxcblx0WzIsIDM1LCAxN10sXG5cdFsyLCAzNSwgMTNdLFxuXG5cdC8vIDRcdFx0XG5cdFsxLCAxMDAsIDgwXSxcblx0WzIsIDUwLCAzMl0sXG5cdFsyLCA1MCwgMjRdLFxuXHRbNCwgMjUsIDldLFxuXHRcblx0Ly8gNVxuXHRbMSwgMTM0LCAxMDhdLFxuXHRbMiwgNjcsIDQzXSxcblx0WzIsIDMzLCAxNSwgMiwgMzQsIDE2XSxcblx0WzIsIDMzLCAxMSwgMiwgMzQsIDEyXSxcblx0XG5cdC8vIDZcblx0WzIsIDg2LCA2OF0sXG5cdFs0LCA0MywgMjddLFxuXHRbNCwgNDMsIDE5XSxcblx0WzQsIDQzLCAxNV0sXG5cdFxuXHQvLyA3XHRcdFxuXHRbMiwgOTgsIDc4XSxcblx0WzQsIDQ5LCAzMV0sXG5cdFsyLCAzMiwgMTQsIDQsIDMzLCAxNV0sXG5cdFs0LCAzOSwgMTMsIDEsIDQwLCAxNF0sXG5cdFxuXHQvLyA4XG5cdFsyLCAxMjEsIDk3XSxcblx0WzIsIDYwLCAzOCwgMiwgNjEsIDM5XSxcblx0WzQsIDQwLCAxOCwgMiwgNDEsIDE5XSxcblx0WzQsIDQwLCAxNCwgMiwgNDEsIDE1XSxcblx0XG5cdC8vIDlcblx0WzIsIDE0NiwgMTE2XSxcblx0WzMsIDU4LCAzNiwgMiwgNTksIDM3XSxcblx0WzQsIDM2LCAxNiwgNCwgMzcsIDE3XSxcblx0WzQsIDM2LCAxMiwgNCwgMzcsIDEzXSxcblx0XG5cdC8vIDEwXHRcdFxuXHRbMiwgODYsIDY4LCAyLCA4NywgNjldLFxuXHRbNCwgNjksIDQzLCAxLCA3MCwgNDRdLFxuXHRbNiwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuXHRbNiwgNDMsIDE1LCAyLCA0NCwgMTZdLFxuXG5cdC8vIDExXG5cdFs0LCAxMDEsIDgxXSxcblx0WzEsIDgwLCA1MCwgNCwgODEsIDUxXSxcblx0WzQsIDUwLCAyMiwgNCwgNTEsIDIzXSxcblx0WzMsIDM2LCAxMiwgOCwgMzcsIDEzXSxcblxuXHQvLyAxMlxuXHRbMiwgMTE2LCA5MiwgMiwgMTE3LCA5M10sXG5cdFs2LCA1OCwgMzYsIDIsIDU5LCAzN10sXG5cdFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sXG5cdFs3LCA0MiwgMTQsIDQsIDQzLCAxNV0sXG5cblx0Ly8gMTNcblx0WzQsIDEzMywgMTA3XSxcblx0WzgsIDU5LCAzNywgMSwgNjAsIDM4XSxcblx0WzgsIDQ0LCAyMCwgNCwgNDUsIDIxXSxcblx0WzEyLCAzMywgMTEsIDQsIDM0LCAxMl0sXG5cblx0Ly8gMTRcblx0WzMsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG5cdFs0LCA2NCwgNDAsIDUsIDY1LCA0MV0sXG5cdFsxMSwgMzYsIDE2LCA1LCAzNywgMTddLFxuXHRbMTEsIDM2LCAxMiwgNSwgMzcsIDEzXSxcblxuXHQvLyAxNVxuXHRbNSwgMTA5LCA4NywgMSwgMTEwLCA4OF0sXG5cdFs1LCA2NSwgNDEsIDUsIDY2LCA0Ml0sXG5cdFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG5cdFsxMSwgMzYsIDEyXSxcblxuXHQvLyAxNlxuXHRbNSwgMTIyLCA5OCwgMSwgMTIzLCA5OV0sXG5cdFs3LCA3MywgNDUsIDMsIDc0LCA0Nl0sXG5cdFsxNSwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuXHRbMywgNDUsIDE1LCAxMywgNDYsIDE2XSxcblxuXHQvLyAxN1xuXHRbMSwgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcblx0WzEwLCA3NCwgNDYsIDEsIDc1LCA0N10sXG5cdFsxLCA1MCwgMjIsIDE1LCA1MSwgMjNdLFxuXHRbMiwgNDIsIDE0LCAxNywgNDMsIDE1XSxcblxuXHQvLyAxOFxuXHRbNSwgMTUwLCAxMjAsIDEsIDE1MSwgMTIxXSxcblx0WzksIDY5LCA0MywgNCwgNzAsIDQ0XSxcblx0WzE3LCA1MCwgMjIsIDEsIDUxLCAyM10sXG5cdFsyLCA0MiwgMTQsIDE5LCA0MywgMTVdLFxuXG5cdC8vIDE5XG5cdFszLCAxNDEsIDExMywgNCwgMTQyLCAxMTRdLFxuXHRbMywgNzAsIDQ0LCAxMSwgNzEsIDQ1XSxcblx0WzE3LCA0NywgMjEsIDQsIDQ4LCAyMl0sXG5cdFs5LCAzOSwgMTMsIDE2LCA0MCwgMTRdLFxuXG5cdC8vIDIwXG5cdFszLCAxMzUsIDEwNywgNSwgMTM2LCAxMDhdLFxuXHRbMywgNjcsIDQxLCAxMywgNjgsIDQyXSxcblx0WzE1LCA1NCwgMjQsIDUsIDU1LCAyNV0sXG5cdFsxNSwgNDMsIDE1LCAxMCwgNDQsIDE2XSxcblxuXHQvLyAyMVxuXHRbNCwgMTQ0LCAxMTYsIDQsIDE0NSwgMTE3XSxcblx0WzE3LCA2OCwgNDJdLFxuXHRbMTcsIDUwLCAyMiwgNiwgNTEsIDIzXSxcblx0WzE5LCA0NiwgMTYsIDYsIDQ3LCAxN10sXG5cblx0Ly8gMjJcblx0WzIsIDEzOSwgMTExLCA3LCAxNDAsIDExMl0sXG5cdFsxNywgNzQsIDQ2XSxcblx0WzcsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG5cdFszNCwgMzcsIDEzXSxcblxuXHQvLyAyM1xuXHRbNCwgMTUxLCAxMjEsIDUsIDE1MiwgMTIyXSxcblx0WzQsIDc1LCA0NywgMTQsIDc2LCA0OF0sXG5cdFsxMSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcblx0WzE2LCA0NSwgMTUsIDE0LCA0NiwgMTZdLFxuXG5cdC8vIDI0XG5cdFs2LCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLFxuXHRbNiwgNzMsIDQ1LCAxNCwgNzQsIDQ2XSxcblx0WzExLCA1NCwgMjQsIDE2LCA1NSwgMjVdLFxuXHRbMzAsIDQ2LCAxNiwgMiwgNDcsIDE3XSxcblxuXHQvLyAyNVxuXHRbOCwgMTMyLCAxMDYsIDQsIDEzMywgMTA3XSxcblx0WzgsIDc1LCA0NywgMTMsIDc2LCA0OF0sXG5cdFs3LCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuXHRbMjIsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sXG5cblx0Ly8gMjZcblx0WzEwLCAxNDIsIDExNCwgMiwgMTQzLCAxMTVdLFxuXHRbMTksIDc0LCA0NiwgNCwgNzUsIDQ3XSxcblx0WzI4LCA1MCwgMjIsIDYsIDUxLCAyM10sXG5cdFszMywgNDYsIDE2LCA0LCA0NywgMTddLFxuXG5cdC8vIDI3XG5cdFs4LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLFxuXHRbMjIsIDczLCA0NSwgMywgNzQsIDQ2XSxcblx0WzgsIDUzLCAyMywgMjYsIDU0LCAyNF0sXG5cdFsxMiwgNDUsIDE1LCAyOCwgNDYsIDE2XSxcblxuXHQvLyAyOFxuXHRbMywgMTQ3LCAxMTcsIDEwLCAxNDgsIDExOF0sXG5cdFszLCA3MywgNDUsIDIzLCA3NCwgNDZdLFxuXHRbNCwgNTQsIDI0LCAzMSwgNTUsIDI1XSxcblx0WzExLCA0NSwgMTUsIDMxLCA0NiwgMTZdLFxuXG5cdC8vIDI5XG5cdFs3LCAxNDYsIDExNiwgNywgMTQ3LCAxMTddLFxuXHRbMjEsIDczLCA0NSwgNywgNzQsIDQ2XSxcblx0WzEsIDUzLCAyMywgMzcsIDU0LCAyNF0sXG5cdFsxOSwgNDUsIDE1LCAyNiwgNDYsIDE2XSxcblxuXHQvLyAzMFxuXHRbNSwgMTQ1LCAxMTUsIDEwLCAxNDYsIDExNl0sXG5cdFsxOSwgNzUsIDQ3LCAxMCwgNzYsIDQ4XSxcblx0WzE1LCA1NCwgMjQsIDI1LCA1NSwgMjVdLFxuXHRbMjMsIDQ1LCAxNSwgMjUsIDQ2LCAxNl0sXG5cblx0Ly8gMzFcblx0WzEzLCAxNDUsIDExNSwgMywgMTQ2LCAxMTZdLFxuXHRbMiwgNzQsIDQ2LCAyOSwgNzUsIDQ3XSxcblx0WzQyLCA1NCwgMjQsIDEsIDU1LCAyNV0sXG5cdFsyMywgNDUsIDE1LCAyOCwgNDYsIDE2XSxcblxuXHQvLyAzMlxuXHRbMTcsIDE0NSwgMTE1XSxcblx0WzEwLCA3NCwgNDYsIDIzLCA3NSwgNDddLFxuXHRbMTAsIDU0LCAyNCwgMzUsIDU1LCAyNV0sXG5cdFsxOSwgNDUsIDE1LCAzNSwgNDYsIDE2XSxcblxuXHQvLyAzM1xuXHRbMTcsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG5cdFsxNCwgNzQsIDQ2LCAyMSwgNzUsIDQ3XSxcblx0WzI5LCA1NCwgMjQsIDE5LCA1NSwgMjVdLFxuXHRbMTEsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG5cblx0Ly8gMzRcblx0WzEzLCAxNDUsIDExNSwgNiwgMTQ2LCAxMTZdLFxuXHRbMTQsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG5cdFs0NCwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuXHRbNTksIDQ2LCAxNiwgMSwgNDcsIDE3XSxcblxuXHQvLyAzNVxuXHRbMTIsIDE1MSwgMTIxLCA3LCAxNTIsIDEyMl0sXG5cdFsxMiwgNzUsIDQ3LCAyNiwgNzYsIDQ4XSxcblx0WzM5LCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuXHRbMjIsIDQ1LCAxNSwgNDEsIDQ2LCAxNl0sXG5cblx0Ly8gMzZcblx0WzYsIDE1MSwgMTIxLCAxNCwgMTUyLCAxMjJdLFxuXHRbNiwgNzUsIDQ3LCAzNCwgNzYsIDQ4XSxcblx0WzQ2LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuXHRbMiwgNDUsIDE1LCA2NCwgNDYsIDE2XSxcblxuXHQvLyAzN1xuXHRbMTcsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sXG5cdFsyOSwgNzQsIDQ2LCAxNCwgNzUsIDQ3XSxcblx0WzQ5LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuXHRbMjQsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG5cblx0Ly8gMzhcblx0WzQsIDE1MiwgMTIyLCAxOCwgMTUzLCAxMjNdLFxuXHRbMTMsIDc0LCA0NiwgMzIsIDc1LCA0N10sXG5cdFs0OCwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcblx0WzQyLCA0NSwgMTUsIDMyLCA0NiwgMTZdLFxuXG5cdC8vIDM5XG5cdFsyMCwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcblx0WzQwLCA3NSwgNDcsIDcsIDc2LCA0OF0sXG5cdFs0MywgNTQsIDI0LCAyMiwgNTUsIDI1XSxcblx0WzEwLCA0NSwgMTUsIDY3LCA0NiwgMTZdLFxuXG5cdC8vIDQwXG5cdFsxOSwgMTQ4LCAxMTgsIDYsIDE0OSwgMTE5XSxcblx0WzE4LCA3NSwgNDcsIDMxLCA3NiwgNDhdLFxuXHRbMzQsIDU0LCAyNCwgMzQsIDU1LCAyNV0sXG5cdFsyMCwgNDUsIDE1LCA2MSwgNDYsIDE2XVxuXTtcblxuUVJSU0Jsb2NrLmdldFJTQmxvY2tzID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0TGV2ZWwpIHtcblx0XG5cdHZhciByc0Jsb2NrID0gUVJSU0Jsb2NrLmdldFJzQmxvY2tUYWJsZSh0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCk7XG5cdFxuXHRpZiAocnNCbG9jayA9PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOlwiICsgdHlwZU51bWJlciArIFwiL2Vycm9yQ29ycmVjdExldmVsOlwiICsgZXJyb3JDb3JyZWN0TGV2ZWwpO1xuXHR9XG5cblx0dmFyIGxlbmd0aCA9IHJzQmxvY2subGVuZ3RoIC8gMztcblx0XG5cdHZhciBsaXN0ID0gbmV3IEFycmF5KCk7XG5cdFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cblx0XHR2YXIgY291bnQgPSByc0Jsb2NrW2kgKiAzICsgMF07XG5cdFx0dmFyIHRvdGFsQ291bnQgPSByc0Jsb2NrW2kgKiAzICsgMV07XG5cdFx0dmFyIGRhdGFDb3VudCAgPSByc0Jsb2NrW2kgKiAzICsgMl07XG5cblx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcblx0XHRcdGxpc3QucHVzaChuZXcgUVJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkgKTtcdFxuXHRcdH1cblx0fVxuXHRcblx0cmV0dXJuIGxpc3Q7XG59XG5cblFSUlNCbG9jay5nZXRSc0Jsb2NrVGFibGUgPSBmdW5jdGlvbih0eXBlTnVtYmVyLCBlcnJvckNvcnJlY3RMZXZlbCkge1xuXG5cdHN3aXRjaChlcnJvckNvcnJlY3RMZXZlbCkge1xuXHRjYXNlIEVDTC5MIDpcblx0XHRyZXR1cm4gUVJSU0Jsb2NrLlJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMF07XG5cdGNhc2UgRUNMLk0gOlxuXHRcdHJldHVybiBRUlJTQmxvY2suUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAxXTtcblx0Y2FzZSBFQ0wuUSA6XG5cdFx0cmV0dXJuIFFSUlNCbG9jay5SU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDJdO1xuXHRjYXNlIEVDTC5IIDpcblx0XHRyZXR1cm4gUVJSU0Jsb2NrLlJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgM107XG5cdGRlZmF1bHQgOlxuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRUlJTQmxvY2s7XG4iLCJ2YXIgUVJNYXRoID0ge1xuXG5cdGdsb2cgOiBmdW5jdGlvbihuKSB7XG5cdFxuXHRcdGlmIChuIDwgMSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiZ2xvZyhcIiArIG4gKyBcIilcIik7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBRUk1hdGguTE9HX1RBQkxFW25dO1xuXHR9LFxuXHRcblx0Z2V4cCA6IGZ1bmN0aW9uKG4pIHtcblx0XG5cdFx0d2hpbGUgKG4gPCAwKSB7XG5cdFx0XHRuICs9IDI1NTtcblx0XHR9XG5cdFxuXHRcdHdoaWxlIChuID49IDI1Nikge1xuXHRcdFx0biAtPSAyNTU7XG5cdFx0fVxuXHRcblx0XHRyZXR1cm4gUVJNYXRoLkVYUF9UQUJMRVtuXTtcblx0fSxcblx0XG5cdEVYUF9UQUJMRSA6IG5ldyBBcnJheSgyNTYpLFxuXHRcblx0TE9HX1RBQkxFIDogbmV3IEFycmF5KDI1NilcblxufTtcblx0XG5mb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuXHRRUk1hdGguRVhQX1RBQkxFW2ldID0gMSA8PCBpO1xufVxuZm9yICh2YXIgaSA9IDg7IGkgPCAyNTY7IGkrKykge1xuXHRRUk1hdGguRVhQX1RBQkxFW2ldID0gUVJNYXRoLkVYUF9UQUJMRVtpIC0gNF1cblx0XHReIFFSTWF0aC5FWFBfVEFCTEVbaSAtIDVdXG5cdFx0XiBRUk1hdGguRVhQX1RBQkxFW2kgLSA2XVxuXHRcdF4gUVJNYXRoLkVYUF9UQUJMRVtpIC0gOF07XG59XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NTsgaSsrKSB7XG5cdFFSTWF0aC5MT0dfVEFCTEVbUVJNYXRoLkVYUF9UQUJMRVtpXSBdID0gaTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRUk1hdGg7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcblx0TU9ERV9OVU1CRVIgOlx0XHQxIDw8IDAsXG5cdE1PREVfQUxQSEFfTlVNIDogXHQxIDw8IDEsXG5cdE1PREVfOEJJVF9CWVRFIDogXHQxIDw8IDIsXG5cdE1PREVfS0FOSkkgOlx0XHQxIDw8IDNcbn07XG4iLCJ2YXIgTW9kZSA9IHJlcXVpcmUoJy4vbW9kZScpO1xudmFyIFBvbHlub21pYWwgPSByZXF1aXJlKCcuL1BvbHlub21pYWwnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnLi9tYXRoJyk7XG5cbnZhciBRUk1hc2tQYXR0ZXJuID0ge1xuXHRQQVRURVJOMDAwIDogMCxcblx0UEFUVEVSTjAwMSA6IDEsXG5cdFBBVFRFUk4wMTAgOiAyLFxuXHRQQVRURVJOMDExIDogMyxcblx0UEFUVEVSTjEwMCA6IDQsXG5cdFBBVFRFUk4xMDEgOiA1LFxuXHRQQVRURVJOMTEwIDogNixcblx0UEFUVEVSTjExMSA6IDdcbn07XG5cbnZhciBRUlV0aWwgPSB7XG5cbiAgICBQQVRURVJOX1BPU0lUSU9OX1RBQkxFIDogW1xuXHQgICAgW10sXG5cdCAgICBbNiwgMThdLFxuXHQgICAgWzYsIDIyXSxcblx0ICAgIFs2LCAyNl0sXG5cdCAgICBbNiwgMzBdLFxuXHQgICAgWzYsIDM0XSxcblx0ICAgIFs2LCAyMiwgMzhdLFxuXHQgICAgWzYsIDI0LCA0Ml0sXG5cdCAgICBbNiwgMjYsIDQ2XSxcblx0ICAgIFs2LCAyOCwgNTBdLFxuXHQgICAgWzYsIDMwLCA1NF0sXHRcdFxuXHQgICAgWzYsIDMyLCA1OF0sXG5cdCAgICBbNiwgMzQsIDYyXSxcblx0ICAgIFs2LCAyNiwgNDYsIDY2XSxcblx0ICAgIFs2LCAyNiwgNDgsIDcwXSxcblx0ICAgIFs2LCAyNiwgNTAsIDc0XSxcblx0ICAgIFs2LCAzMCwgNTQsIDc4XSxcblx0ICAgIFs2LCAzMCwgNTYsIDgyXSxcblx0ICAgIFs2LCAzMCwgNTgsIDg2XSxcblx0ICAgIFs2LCAzNCwgNjIsIDkwXSxcblx0ICAgIFs2LCAyOCwgNTAsIDcyLCA5NF0sXG5cdCAgICBbNiwgMjYsIDUwLCA3NCwgOThdLFxuXHQgICAgWzYsIDMwLCA1NCwgNzgsIDEwMl0sXG5cdCAgICBbNiwgMjgsIDU0LCA4MCwgMTA2XSxcblx0ICAgIFs2LCAzMiwgNTgsIDg0LCAxMTBdLFxuXHQgICAgWzYsIDMwLCA1OCwgODYsIDExNF0sXG5cdCAgICBbNiwgMzQsIDYyLCA5MCwgMTE4XSxcblx0ICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSxcblx0ICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0sXG5cdCAgICBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLFxuXHQgICAgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSxcblx0ICAgIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sXG5cdCAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLFxuXHQgICAgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSxcblx0ICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSxcblx0ICAgIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSxcblx0ICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSxcblx0ICAgIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSxcblx0ICAgIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSxcblx0ICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXVxuICAgIF0sXG5cbiAgICBHMTUgOiAoMSA8PCAxMCkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgNCkgfCAoMSA8PCAyKSB8ICgxIDw8IDEpIHwgKDEgPDwgMCksXG4gICAgRzE4IDogKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKSxcbiAgICBHMTVfTUFTSyA6ICgxIDw8IDE0KSB8ICgxIDw8IDEyKSB8ICgxIDw8IDEwKVx0fCAoMSA8PCA0KSB8ICgxIDw8IDEpLFxuXG4gICAgZ2V0QkNIVHlwZUluZm8gOiBmdW5jdGlvbihkYXRhKSB7XG5cdCAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG5cdCAgICB3aGlsZSAoUVJVdGlsLmdldEJDSERpZ2l0KGQpIC0gUVJVdGlsLmdldEJDSERpZ2l0KFFSVXRpbC5HMTUpID49IDApIHtcblx0XHQgICAgZCBePSAoUVJVdGlsLkcxNSA8PCAoUVJVdGlsLmdldEJDSERpZ2l0KGQpIC0gUVJVdGlsLmdldEJDSERpZ2l0KFFSVXRpbC5HMTUpICkgKTsgXHRcblx0ICAgIH1cblx0ICAgIHJldHVybiAoIChkYXRhIDw8IDEwKSB8IGQpIF4gUVJVdGlsLkcxNV9NQVNLO1xuICAgIH0sXG5cbiAgICBnZXRCQ0hUeXBlTnVtYmVyIDogZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgdmFyIGQgPSBkYXRhIDw8IDEyO1xuXHQgICAgd2hpbGUgKFFSVXRpbC5nZXRCQ0hEaWdpdChkKSAtIFFSVXRpbC5nZXRCQ0hEaWdpdChRUlV0aWwuRzE4KSA+PSAwKSB7XG5cdFx0ICAgIGQgXj0gKFFSVXRpbC5HMTggPDwgKFFSVXRpbC5nZXRCQ0hEaWdpdChkKSAtIFFSVXRpbC5nZXRCQ0hEaWdpdChRUlV0aWwuRzE4KSApICk7IFx0XG5cdCAgICB9XG5cdCAgICByZXR1cm4gKGRhdGEgPDwgMTIpIHwgZDtcbiAgICB9LFxuXG4gICAgZ2V0QkNIRGlnaXQgOiBmdW5jdGlvbihkYXRhKSB7XG5cblx0ICAgIHZhciBkaWdpdCA9IDA7XG5cblx0ICAgIHdoaWxlIChkYXRhICE9IDApIHtcblx0XHQgICAgZGlnaXQrKztcblx0XHQgICAgZGF0YSA+Pj49IDE7XG5cdCAgICB9XG5cblx0ICAgIHJldHVybiBkaWdpdDtcbiAgICB9LFxuXG4gICAgZ2V0UGF0dGVyblBvc2l0aW9uIDogZnVuY3Rpb24odHlwZU51bWJlcikge1xuXHQgICAgcmV0dXJuIFFSVXRpbC5QQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcbiAgICB9LFxuXG4gICAgZ2V0TWFzayA6IGZ1bmN0aW9uKG1hc2tQYXR0ZXJuLCBpLCBqKSB7XG5cdCAgICBcblx0ICAgIHN3aXRjaCAobWFza1BhdHRlcm4pIHtcblx0XHQgICAgXG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMCA6IHJldHVybiAoaSArIGopICUgMiA9PSAwO1xuXHQgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMDEgOiByZXR1cm4gaSAlIDIgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDEwIDogcmV0dXJuIGogJSAzID09IDA7XG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMSA6IHJldHVybiAoaSArIGopICUgMyA9PSAwO1xuXHQgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDAgOiByZXR1cm4gKE1hdGguZmxvb3IoaSAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykgKSAlIDIgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAxIDogcmV0dXJuIChpICogaikgJSAyICsgKGkgKiBqKSAlIDMgPT0gMDtcblx0ICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTEwIDogcmV0dXJuICggKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMykgJSAyID09IDA7XG5cdCAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjExMSA6IHJldHVybiAoIChpICogaikgJSAzICsgKGkgKyBqKSAlIDIpICUgMiA9PSAwO1xuXG5cdCAgICBkZWZhdWx0IDpcblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIG1hc2tQYXR0ZXJuOlwiICsgbWFza1BhdHRlcm4pO1xuXHQgICAgfVxuICAgIH0sXG5cbiAgICBnZXRFcnJvckNvcnJlY3RQb2x5bm9taWFsIDogZnVuY3Rpb24oZXJyb3JDb3JyZWN0TGVuZ3RoKSB7XG5cblx0ICAgIHZhciBhID0gbmV3IFBvbHlub21pYWwoWzFdLCAwKTtcblxuXHQgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlcnJvckNvcnJlY3RMZW5ndGg7IGkrKykge1xuXHRcdCAgICBhID0gYS5tdWx0aXBseShuZXcgUG9seW5vbWlhbChbMSwgbWF0aC5nZXhwKGkpXSwgMCkgKTtcblx0ICAgIH1cblxuXHQgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIGdldExlbmd0aEluQml0cyA6IGZ1bmN0aW9uKG1vZGUsIHR5cGUpIHtcblxuXHQgICAgaWYgKDEgPD0gdHlwZSAmJiB0eXBlIDwgMTApIHtcblxuXHRcdCAgICAvLyAxIC0gOVxuXG5cdFx0ICAgIHN3aXRjaChtb2RlKSB7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX05VTUJFUiBcdDogcmV0dXJuIDEwO1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9BTFBIQV9OVU0gXHQ6IHJldHVybiA5O1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV84QklUX0JZVEVcdDogcmV0dXJuIDg7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0tBTkpJICBcdDogcmV0dXJuIDg7XG5cdFx0ICAgIGRlZmF1bHQgOlxuXHRcdFx0ICAgIHRocm93IG5ldyBFcnJvcihcIm1vZGU6XCIgKyBtb2RlKTtcblx0XHQgICAgfVxuXG5cdCAgICB9IGVsc2UgaWYgKHR5cGUgPCAyNykge1xuXG5cdFx0ICAgIC8vIDEwIC0gMjZcblxuXHRcdCAgICBzd2l0Y2gobW9kZSkge1xuXHRcdCAgICBjYXNlIE1vZGUuTU9ERV9OVU1CRVIgXHQ6IHJldHVybiAxMjtcblx0XHQgICAgY2FzZSBNb2RlLk1PREVfQUxQSEFfTlVNIFx0OiByZXR1cm4gMTE7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFXzhCSVRfQllURVx0OiByZXR1cm4gMTY7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0tBTkpJICBcdDogcmV0dXJuIDEwO1xuXHRcdCAgICBkZWZhdWx0IDpcblx0XHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2RlOlwiICsgbW9kZSk7XG5cdFx0ICAgIH1cblxuXHQgICAgfSBlbHNlIGlmICh0eXBlIDwgNDEpIHtcblxuXHRcdCAgICAvLyAyNyAtIDQwXG5cblx0XHQgICAgc3dpdGNoKG1vZGUpIHtcblx0XHQgICAgY2FzZSBNb2RlLk1PREVfTlVNQkVSIFx0OiByZXR1cm4gMTQ7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0FMUEhBX05VTVx0OiByZXR1cm4gMTM7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFXzhCSVRfQllURVx0OiByZXR1cm4gMTY7XG5cdFx0ICAgIGNhc2UgTW9kZS5NT0RFX0tBTkpJICBcdDogcmV0dXJuIDEyO1xuXHRcdCAgICBkZWZhdWx0IDpcblx0XHRcdCAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb2RlOlwiICsgbW9kZSk7XG5cdFx0ICAgIH1cblxuXHQgICAgfSBlbHNlIHtcblx0XHQgICAgdGhyb3cgbmV3IEVycm9yKFwidHlwZTpcIiArIHR5cGUpO1xuXHQgICAgfVxuICAgIH0sXG5cbiAgICBnZXRMb3N0UG9pbnQgOiBmdW5jdGlvbihxckNvZGUpIHtcblx0ICAgIFxuXHQgICAgdmFyIG1vZHVsZUNvdW50ID0gcXJDb2RlLmdldE1vZHVsZUNvdW50KCk7XG5cdCAgICBcblx0ICAgIHZhciBsb3N0UG9pbnQgPSAwO1xuXHQgICAgXG5cdCAgICAvLyBMRVZFTDFcblx0ICAgIFxuXHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdysrKSB7XG5cblx0XHQgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCsrKSB7XG5cblx0XHRcdCAgICB2YXIgc2FtZUNvdW50ID0gMDtcblx0XHRcdCAgICB2YXIgZGFyayA9IHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpO1xuXG5cdFx0XHRcdGZvciAodmFyIHIgPSAtMTsgciA8PSAxOyByKyspIHtcblxuXHRcdFx0XHQgICAgaWYgKHJvdyArIHIgPCAwIHx8IG1vZHVsZUNvdW50IDw9IHJvdyArIHIpIHtcblx0XHRcdFx0XHQgICAgY29udGludWU7XG5cdFx0XHRcdCAgICB9XG5cblx0XHRcdFx0ICAgIGZvciAodmFyIGMgPSAtMTsgYyA8PSAxOyBjKyspIHtcblxuXHRcdFx0XHRcdCAgICBpZiAoY29sICsgYyA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sICsgYykge1xuXHRcdFx0XHRcdFx0ICAgIGNvbnRpbnVlO1xuXHRcdFx0XHRcdCAgICB9XG5cblx0XHRcdFx0XHQgICAgaWYgKHIgPT0gMCAmJiBjID09IDApIHtcblx0XHRcdFx0XHRcdCAgICBjb250aW51ZTtcblx0XHRcdFx0XHQgICAgfVxuXG5cdFx0XHRcdFx0ICAgIGlmIChkYXJrID09IHFyQ29kZS5pc0Rhcmsocm93ICsgciwgY29sICsgYykgKSB7XG5cdFx0XHRcdFx0XHQgICAgc2FtZUNvdW50Kys7XG5cdFx0XHRcdFx0ICAgIH1cblx0XHRcdFx0ICAgIH1cblx0XHRcdCAgICB9XG5cblx0XHRcdCAgICBpZiAoc2FtZUNvdW50ID4gNSkge1xuXHRcdFx0XHQgICAgbG9zdFBvaW50ICs9ICgzICsgc2FtZUNvdW50IC0gNSk7XG5cdFx0XHQgICAgfVxuXHRcdCAgICB9XG5cdCAgICB9XG5cblx0ICAgIC8vIExFVkVMMlxuXG5cdCAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDE7IHJvdysrKSB7XG5cdFx0ICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gMTsgY29sKyspIHtcblx0XHRcdCAgICB2YXIgY291bnQgPSAwO1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgICAgIGNvbCAgICApICkgY291bnQrKztcblx0XHRcdCAgICBpZiAocXJDb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wgICAgKSApIGNvdW50Kys7XG5cdFx0XHQgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCAgICAgY29sICsgMSkgKSBjb3VudCsrO1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbCArIDEpICkgY291bnQrKztcblx0XHRcdCAgICBpZiAoY291bnQgPT0gMCB8fCBjb3VudCA9PSA0KSB7XG5cdFx0XHRcdCAgICBsb3N0UG9pbnQgKz0gMztcblx0XHRcdCAgICB9XG5cdFx0ICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gTEVWRUwzXG5cblx0ICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3crKykge1xuXHRcdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudCAtIDY7IGNvbCsrKSB7XG5cdFx0XHQgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICFxckNvZGUuaXNEYXJrKHJvdywgY29sICsgMSlcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyAyKVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDMpXG5cdFx0XHRcdFx0ICAgICYmICBxckNvZGUuaXNEYXJrKHJvdywgY29sICsgNClcblx0XHRcdFx0XHQgICAgJiYgIXFyQ29kZS5pc0Rhcmsocm93LCBjb2wgKyA1KVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3csIGNvbCArIDYpICkge1xuXHRcdFx0XHQgICAgbG9zdFBvaW50ICs9IDQwO1xuXHRcdFx0ICAgIH1cblx0XHQgICAgfVxuXHQgICAgfVxuXG5cdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sKyspIHtcblx0XHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSA2OyByb3crKykge1xuXHRcdFx0ICAgIGlmIChxckNvZGUuaXNEYXJrKHJvdywgY29sKVxuXHRcdFx0XHRcdCAgICAmJiAhcXJDb2RlLmlzRGFyayhyb3cgKyAxLCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICBxckNvZGUuaXNEYXJrKHJvdyArIDIsIGNvbClcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93ICsgMywgY29sKVxuXHRcdFx0XHRcdCAgICAmJiAgcXJDb2RlLmlzRGFyayhyb3cgKyA0LCBjb2wpXG5cdFx0XHRcdFx0ICAgICYmICFxckNvZGUuaXNEYXJrKHJvdyArIDUsIGNvbClcblx0XHRcdFx0XHQgICAgJiYgIHFyQ29kZS5pc0Rhcmsocm93ICsgNiwgY29sKSApIHtcblx0XHRcdFx0ICAgIGxvc3RQb2ludCArPSA0MDtcblx0XHRcdCAgICB9XG5cdFx0ICAgIH1cblx0ICAgIH1cblxuXHQgICAgLy8gTEVWRUw0XG5cdCAgICBcblx0ICAgIHZhciBkYXJrQ291bnQgPSAwO1xuXG5cdCAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sKyspIHtcblx0XHQgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdysrKSB7XG5cdFx0XHQgICAgaWYgKHFyQ29kZS5pc0Rhcmsocm93LCBjb2wpICkge1xuXHRcdFx0XHQgICAgZGFya0NvdW50Kys7XG5cdFx0XHQgICAgfVxuXHRcdCAgICB9XG5cdCAgICB9XG5cdCAgICBcblx0ICAgIHZhciByYXRpbyA9IE1hdGguYWJzKDEwMCAqIGRhcmtDb3VudCAvIG1vZHVsZUNvdW50IC8gbW9kdWxlQ291bnQgLSA1MCkgLyA1O1xuXHQgICAgbG9zdFBvaW50ICs9IHJhdGlvICogMTA7XG5cblx0ICAgIHJldHVybiBsb3N0UG9pbnQ7XHRcdFxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUVJVdGlsO1xuIiwiLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vXG4vLyBRUiBDb2RlIEdlbmVyYXRvciBmb3IgSmF2YVNjcmlwdFxuLy9cbi8vIENvcHlyaWdodCAoYykgMjAwOSBLYXp1aGlrbyBBcmFzZVxuLy9cbi8vIFVSTDogaHR0cDovL3d3dy5kLXByb2plY3QuY29tL1xuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbi8vICBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuLy9cbi8vIFRoZSB3b3JkICdRUiBDb2RlJyBpcyByZWdpc3RlcmVkIHRyYWRlbWFyayBvZlxuLy8gREVOU08gV0FWRSBJTkNPUlBPUkFURURcbi8vICBodHRwOi8vd3d3LmRlbnNvLXdhdmUuY29tL3FyY29kZS9mYXFwYXRlbnQtZS5odG1sXG4vL1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHFyY29kZSA9IGZ1bmN0aW9uKCkge1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyY29kZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBxcmNvZGVcbiAgICogQHBhcmFtIHR5cGVOdW1iZXIgMSB0byA0MFxuICAgKiBAcGFyYW0gZXJyb3JDb3JyZWN0aW9uTGV2ZWwgJ0wnLCdNJywnUScsJ0gnXG4gICAqL1xuICB2YXIgcXJjb2RlID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcblxuICAgIHZhciBQQUQwID0gMHhFQztcbiAgICB2YXIgUEFEMSA9IDB4MTE7XG5cbiAgICB2YXIgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuICAgIHZhciBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBRUkVycm9yQ29ycmVjdGlvbkxldmVsW2Vycm9yQ29ycmVjdGlvbkxldmVsXTtcbiAgICB2YXIgX21vZHVsZXMgPSBudWxsO1xuICAgIHZhciBfbW9kdWxlQ291bnQgPSAwO1xuICAgIHZhciBfZGF0YUNhY2hlID0gbnVsbDtcbiAgICB2YXIgX2RhdGFMaXN0ID0gW107XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIHZhciBtYWtlSW1wbCA9IGZ1bmN0aW9uKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgIF9tb2R1bGVDb3VudCA9IF90eXBlTnVtYmVyICogNCArIDE3O1xuICAgICAgX21vZHVsZXMgPSBmdW5jdGlvbihtb2R1bGVDb3VudCkge1xuICAgICAgICB2YXIgbW9kdWxlcyA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgIG1vZHVsZXNbcm93XSA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBtb2R1bGVzW3Jvd11bY29sXSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb2R1bGVzO1xuICAgICAgfShfbW9kdWxlQ291bnQpO1xuXG4gICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIDApO1xuICAgICAgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybihfbW9kdWxlQ291bnQgLSA3LCAwKTtcbiAgICAgIHNldHVwUG9zaXRpb25Qcm9iZVBhdHRlcm4oMCwgX21vZHVsZUNvdW50IC0gNyk7XG4gICAgICBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpO1xuICAgICAgc2V0dXBUaW1pbmdQYXR0ZXJuKCk7XG4gICAgICBzZXR1cFR5cGVJbmZvKHRlc3QsIG1hc2tQYXR0ZXJuKTtcblxuICAgICAgaWYgKF90eXBlTnVtYmVyID49IDcpIHtcbiAgICAgICAgc2V0dXBUeXBlTnVtYmVyKHRlc3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoX2RhdGFDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgIF9kYXRhQ2FjaGUgPSBjcmVhdGVEYXRhKF90eXBlTnVtYmVyLCBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwsIF9kYXRhTGlzdCk7XG4gICAgICB9XG5cbiAgICAgIG1hcERhdGEoX2RhdGFDYWNoZSwgbWFza1BhdHRlcm4pO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dXBQb3NpdGlvblByb2JlUGF0dGVybiA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG5cbiAgICAgIGZvciAodmFyIHIgPSAtMTsgciA8PSA3OyByICs9IDEpIHtcblxuICAgICAgICBpZiAocm93ICsgciA8PSAtMSB8fCBfbW9kdWxlQ291bnQgPD0gcm93ICsgcikgY29udGludWU7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IC0xOyBjIDw9IDc7IGMgKz0gMSkge1xuXG4gICAgICAgICAgaWYgKGNvbCArIGMgPD0gLTEgfHwgX21vZHVsZUNvdW50IDw9IGNvbCArIGMpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgaWYgKCAoMCA8PSByICYmIHIgPD0gNiAmJiAoYyA9PSAwIHx8IGMgPT0gNikgKVxuICAgICAgICAgICAgICB8fCAoMCA8PSBjICYmIGMgPD0gNiAmJiAociA9PSAwIHx8IHIgPT0gNikgKVxuICAgICAgICAgICAgICB8fCAoMiA8PSByICYmIHIgPD0gNCAmJiAyIDw9IGMgJiYgYyA8PSA0KSApIHtcbiAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGNdID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGdldEJlc3RNYXNrUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB2YXIgbWluTG9zdFBvaW50ID0gMDtcbiAgICAgIHZhciBwYXR0ZXJuID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcblxuICAgICAgICBtYWtlSW1wbCh0cnVlLCBpKTtcblxuICAgICAgICB2YXIgbG9zdFBvaW50ID0gUVJVdGlsLmdldExvc3RQb2ludChfdGhpcyk7XG5cbiAgICAgICAgaWYgKGkgPT0gMCB8fCBtaW5Mb3N0UG9pbnQgPiBsb3N0UG9pbnQpIHtcbiAgICAgICAgICBtaW5Mb3N0UG9pbnQgPSBsb3N0UG9pbnQ7XG4gICAgICAgICAgcGF0dGVybiA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfTtcblxuICAgIHZhciBzZXR1cFRpbWluZ1BhdHRlcm4gPSBmdW5jdGlvbigpIHtcblxuICAgICAgZm9yICh2YXIgciA9IDg7IHIgPCBfbW9kdWxlQ291bnQgLSA4OyByICs9IDEpIHtcbiAgICAgICAgaWYgKF9tb2R1bGVzW3JdWzZdICE9IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBfbW9kdWxlc1tyXVs2XSA9IChyICUgMiA9PSAwKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgYyA9IDg7IGMgPCBfbW9kdWxlQ291bnQgLSA4OyBjICs9IDEpIHtcbiAgICAgICAgaWYgKF9tb2R1bGVzWzZdW2NdICE9IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBfbW9kdWxlc1s2XVtjXSA9IChjICUgMiA9PSAwKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHNldHVwUG9zaXRpb25BZGp1c3RQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBwb3MgPSBRUlV0aWwuZ2V0UGF0dGVyblBvc2l0aW9uKF90eXBlTnVtYmVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3MubGVuZ3RoOyBpICs9IDEpIHtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvcy5sZW5ndGg7IGogKz0gMSkge1xuXG4gICAgICAgICAgdmFyIHJvdyA9IHBvc1tpXTtcbiAgICAgICAgICB2YXIgY29sID0gcG9zW2pdO1xuXG4gICAgICAgICAgaWYgKF9tb2R1bGVzW3Jvd11bY29sXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciByID0gLTI7IHIgPD0gMjsgciArPSAxKSB7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGMgPSAtMjsgYyA8PSAyOyBjICs9IDEpIHtcblxuICAgICAgICAgICAgICBpZiAociA9PSAtMiB8fCByID09IDIgfHwgYyA9PSAtMiB8fCBjID09IDJcbiAgICAgICAgICAgICAgICAgIHx8IChyID09IDAgJiYgYyA9PSAwKSApIHtcbiAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjXSA9IHRydWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgY10gPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2V0dXBUeXBlTnVtYmVyID0gZnVuY3Rpb24odGVzdCkge1xuXG4gICAgICB2YXIgYml0cyA9IFFSVXRpbC5nZXRCQ0hUeXBlTnVtYmVyKF90eXBlTnVtYmVyKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxODsgaSArPSAxKSB7XG4gICAgICAgIHZhciBtb2QgPSAoIXRlc3QgJiYgKCAoYml0cyA+PiBpKSAmIDEpID09IDEpO1xuICAgICAgICBfbW9kdWxlc1tNYXRoLmZsb29yKGkgLyAzKV1baSAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM10gPSBtb2Q7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcbiAgICAgICAgX21vZHVsZXNbaSAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM11bTWF0aC5mbG9vcihpIC8gMyldID0gbW9kO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgc2V0dXBUeXBlSW5mbyA9IGZ1bmN0aW9uKHRlc3QsIG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgIHZhciBkYXRhID0gKF9lcnJvckNvcnJlY3Rpb25MZXZlbCA8PCAzKSB8IG1hc2tQYXR0ZXJuO1xuICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZUluZm8oZGF0YSk7XG5cbiAgICAgIC8vIHZlcnRpY2FsXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE1OyBpICs9IDEpIHtcblxuICAgICAgICB2YXIgbW9kID0gKCF0ZXN0ICYmICggKGJpdHMgPj4gaSkgJiAxKSA9PSAxKTtcblxuICAgICAgICBpZiAoaSA8IDYpIHtcbiAgICAgICAgICBfbW9kdWxlc1tpXVs4XSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgOCkge1xuICAgICAgICAgIF9tb2R1bGVzW2kgKyAxXVs4XSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9kdWxlc1tfbW9kdWxlQ291bnQgLSAxNSArIGldWzhdID0gbW9kO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGhvcml6b250YWxcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTU7IGkgKz0gMSkge1xuXG4gICAgICAgIHZhciBtb2QgPSAoIXRlc3QgJiYgKCAoYml0cyA+PiBpKSAmIDEpID09IDEpO1xuXG4gICAgICAgIGlmIChpIDwgOCkge1xuICAgICAgICAgIF9tb2R1bGVzWzhdW19tb2R1bGVDb3VudCAtIGkgLSAxXSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIGlmIChpIDwgOSkge1xuICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaSAtIDEgKyAxXSA9IG1vZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfbW9kdWxlc1s4XVsxNSAtIGkgLSAxXSA9IG1vZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmaXhlZCBtb2R1bGVcbiAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDhdWzhdID0gKCF0ZXN0KTtcbiAgICB9O1xuXG4gICAgdmFyIG1hcERhdGEgPSBmdW5jdGlvbihkYXRhLCBtYXNrUGF0dGVybikge1xuXG4gICAgICB2YXIgaW5jID0gLTE7XG4gICAgICB2YXIgcm93ID0gX21vZHVsZUNvdW50IC0gMTtcbiAgICAgIHZhciBiaXRJbmRleCA9IDc7XG4gICAgICB2YXIgYnl0ZUluZGV4ID0gMDtcbiAgICAgIHZhciBtYXNrRnVuYyA9IFFSVXRpbC5nZXRNYXNrRnVuY3Rpb24obWFza1BhdHRlcm4pO1xuXG4gICAgICBmb3IgKHZhciBjb2wgPSBfbW9kdWxlQ291bnQgLSAxOyBjb2wgPiAwOyBjb2wgLT0gMikge1xuXG4gICAgICAgIGlmIChjb2wgPT0gNikgY29sIC09IDE7XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcblxuICAgICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYyArPSAxKSB7XG5cbiAgICAgICAgICAgIGlmIChfbW9kdWxlc1tyb3ddW2NvbCAtIGNdID09IG51bGwpIHtcblxuICAgICAgICAgICAgICB2YXIgZGFyayA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRhcmsgPSAoICggKGRhdGFbYnl0ZUluZGV4XSA+Pj4gYml0SW5kZXgpICYgMSkgPT0gMSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgbWFzayA9IG1hc2tGdW5jKHJvdywgY29sIC0gYyk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICBkYXJrID0gIWRhcms7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfbW9kdWxlc1tyb3ddW2NvbCAtIGNdID0gZGFyaztcbiAgICAgICAgICAgICAgYml0SW5kZXggLT0gMTtcblxuICAgICAgICAgICAgICBpZiAoYml0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBieXRlSW5kZXggKz0gMTtcbiAgICAgICAgICAgICAgICBiaXRJbmRleCA9IDc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gaW5jO1xuXG4gICAgICAgICAgaWYgKHJvdyA8IDAgfHwgX21vZHVsZUNvdW50IDw9IHJvdykge1xuICAgICAgICAgICAgcm93IC09IGluYztcbiAgICAgICAgICAgIGluYyA9IC1pbmM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGNyZWF0ZUJ5dGVzID0gZnVuY3Rpb24oYnVmZmVyLCByc0Jsb2Nrcykge1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgdmFyIG1heERjQ291bnQgPSAwO1xuICAgICAgdmFyIG1heEVjQ291bnQgPSAwO1xuXG4gICAgICB2YXIgZGNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG4gICAgICB2YXIgZWNkYXRhID0gbmV3IEFycmF5KHJzQmxvY2tzLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgcnNCbG9ja3MubGVuZ3RoOyByICs9IDEpIHtcblxuICAgICAgICB2YXIgZGNDb3VudCA9IHJzQmxvY2tzW3JdLmRhdGFDb3VudDtcbiAgICAgICAgdmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcblxuICAgICAgICBtYXhEY0NvdW50ID0gTWF0aC5tYXgobWF4RGNDb3VudCwgZGNDb3VudCk7XG4gICAgICAgIG1heEVjQ291bnQgPSBNYXRoLm1heChtYXhFY0NvdW50LCBlY0NvdW50KTtcblxuICAgICAgICBkY2RhdGFbcl0gPSBuZXcgQXJyYXkoZGNDb3VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkY2RhdGFbcl0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBkY2RhdGFbcl1baV0gPSAweGZmICYgYnVmZmVyLmdldEJ1ZmZlcigpW2kgKyBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCArPSBkY0NvdW50O1xuXG4gICAgICAgIHZhciByc1BvbHkgPSBRUlV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcbiAgICAgICAgdmFyIHJhd1BvbHkgPSBxclBvbHlub21pYWwoZGNkYXRhW3JdLCByc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcblxuICAgICAgICB2YXIgbW9kUG9seSA9IHJhd1BvbHkubW9kKHJzUG9seSk7XG4gICAgICAgIGVjZGF0YVtyXSA9IG5ldyBBcnJheShyc1BvbHkuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlY2RhdGFbcl0ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICB2YXIgbW9kSW5kZXggPSBpICsgbW9kUG9seS5nZXRMZW5ndGgoKSAtIGVjZGF0YVtyXS5sZW5ndGg7XG4gICAgICAgICAgZWNkYXRhW3JdW2ldID0gKG1vZEluZGV4ID49IDApPyBtb2RQb2x5LmdldEF0KG1vZEluZGV4KSA6IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsQ29kZUNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG90YWxDb2RlQ291bnQgKz0gcnNCbG9ja3NbaV0udG90YWxDb3VudDtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGEgPSBuZXcgQXJyYXkodG90YWxDb2RlQ291bnQpO1xuICAgICAgdmFyIGluZGV4ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXhEY0NvdW50OyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCByc0Jsb2Nrcy5sZW5ndGg7IHIgKz0gMSkge1xuICAgICAgICAgIGlmIChpIDwgZGNkYXRhW3JdLmxlbmd0aCkge1xuICAgICAgICAgICAgZGF0YVtpbmRleF0gPSBkY2RhdGFbcl1baV07XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heEVjQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgaWYgKGkgPCBlY2RhdGFbcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICBkYXRhW2luZGV4XSA9IGVjZGF0YVtyXVtpXTtcbiAgICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICB2YXIgY3JlYXRlRGF0YSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsLCBkYXRhTGlzdCkge1xuXG4gICAgICB2YXIgcnNCbG9ja3MgPSBRUlJTQmxvY2suZ2V0UlNCbG9ja3ModHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuXG4gICAgICB2YXIgYnVmZmVyID0gcXJCaXRCdWZmZXIoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGlzdC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgZGF0YSA9IGRhdGFMaXN0W2ldO1xuICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TW9kZSgpLCA0KTtcbiAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBRUlV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEuZ2V0TW9kZSgpLCB0eXBlTnVtYmVyKSApO1xuICAgICAgICBkYXRhLndyaXRlKGJ1ZmZlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGMgbnVtIG1heCBkYXRhLlxuICAgICAgdmFyIHRvdGFsRGF0YUNvdW50ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaV0uZGF0YUNvdW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID4gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgIHRocm93ICdjb2RlIGxlbmd0aCBvdmVyZmxvdy4gKCdcbiAgICAgICAgICArIGJ1ZmZlci5nZXRMZW5ndGhJbkJpdHMoKVxuICAgICAgICAgICsgJz4nXG4gICAgICAgICAgKyB0b3RhbERhdGFDb3VudCAqIDhcbiAgICAgICAgICArICcpJztcbiAgICAgIH1cblxuICAgICAgLy8gZW5kIGNvZGVcbiAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgKyA0IDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICBidWZmZXIucHV0KDAsIDQpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYWRkaW5nXG4gICAgICB3aGlsZSAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICUgOCAhPSAwKSB7XG4gICAgICAgIGJ1ZmZlci5wdXRCaXQoZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBwYWRkaW5nXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuXG4gICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyLnB1dChQQUQwLCA4KTtcblxuICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXQoUEFEMSwgOCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVCeXRlcyhidWZmZXIsIHJzQmxvY2tzKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuYWRkRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1vZGUpIHtcblxuICAgICAgbW9kZSA9IG1vZGUgfHwgJ0J5dGUnO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IG51bGw7XG5cbiAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICBjYXNlICdOdW1lcmljJyA6XG4gICAgICAgIG5ld0RhdGEgPSBxck51bWJlcihkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdBbHBoYW51bWVyaWMnIDpcbiAgICAgICAgbmV3RGF0YSA9IHFyQWxwaGFOdW0oZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQnl0ZScgOlxuICAgICAgICBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdLYW5qaScgOlxuICAgICAgICBuZXdEYXRhID0gcXJLYW5qaShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0IDpcbiAgICAgICAgdGhyb3cgJ21vZGU6JyArIG1vZGU7XG4gICAgICB9XG5cbiAgICAgIF9kYXRhTGlzdC5wdXNoKG5ld0RhdGEpO1xuICAgICAgX2RhdGFDYWNoZSA9IG51bGw7XG4gICAgfTtcblxuICAgIF90aGlzLmlzRGFyayA9IGZ1bmN0aW9uKHJvdywgY29sKSB7XG4gICAgICBpZiAocm93IDwgMCB8fCBfbW9kdWxlQ291bnQgPD0gcm93IHx8IGNvbCA8IDAgfHwgX21vZHVsZUNvdW50IDw9IGNvbCkge1xuICAgICAgICB0aHJvdyByb3cgKyAnLCcgKyBjb2w7XG4gICAgICB9XG4gICAgICByZXR1cm4gX21vZHVsZXNbcm93XVtjb2xdO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRNb2R1bGVDb3VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2R1bGVDb3VudDtcbiAgICB9O1xuXG4gICAgX3RoaXMubWFrZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKF90eXBlTnVtYmVyIDwgMSkge1xuICAgICAgICB2YXIgdHlwZU51bWJlciA9IDE7XG5cbiAgICAgICAgZm9yICg7IHR5cGVOdW1iZXIgPCA0MDsgdHlwZU51bWJlcisrKSB7XG4gICAgICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIsIF9lcnJvckNvcnJlY3Rpb25MZXZlbCk7XG4gICAgICAgICAgdmFyIGJ1ZmZlciA9IHFyQml0QnVmZmVyKCk7XG5cbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF9kYXRhTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBfZGF0YUxpc3RbaV07XG4gICAgICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TW9kZSgpLCA0KTtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRMZW5ndGgoKSwgUVJVdGlsLmdldExlbmd0aEluQml0cyhkYXRhLmdldE1vZGUoKSwgdHlwZU51bWJlcikgKTtcbiAgICAgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdG90YWxEYXRhQ291bnQgPSAwO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnNCbG9ja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2ldLmRhdGFDb3VudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpIDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuICAgICAgfVxuXG4gICAgICBtYWtlSW1wbChmYWxzZSwgZ2V0QmVzdE1hc2tQYXR0ZXJuKCkgKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlVGFibGVUYWcgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICB2YXIgcXJIdG1sID0gJyc7XG5cbiAgICAgIHFySHRtbCArPSAnPHRhYmxlIHN0eWxlPVwiJztcbiAgICAgIHFySHRtbCArPSAnIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7JztcbiAgICAgIHFySHRtbCArPSAnIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7JztcbiAgICAgIHFySHRtbCArPSAnIHBhZGRpbmc6IDBweDsgbWFyZ2luOiAnICsgbWFyZ2luICsgJ3B4Oyc7XG4gICAgICBxckh0bWwgKz0gJ1wiPic7XG4gICAgICBxckh0bWwgKz0gJzx0Ym9keT4nO1xuXG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuXG4gICAgICAgIHFySHRtbCArPSAnPHRyPic7XG5cbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjICs9IDEpIHtcbiAgICAgICAgICBxckh0bWwgKz0gJzx0ZCBzdHlsZT1cIic7XG4gICAgICAgICAgcXJIdG1sICs9ICcgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIGJvcmRlci1jb2xsYXBzZTogY29sbGFwc2U7JztcbiAgICAgICAgICBxckh0bWwgKz0gJyBwYWRkaW5nOiAwcHg7IG1hcmdpbjogMHB4Oyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgd2lkdGg6ICcgKyBjZWxsU2l6ZSArICdweDsnO1xuICAgICAgICAgIHFySHRtbCArPSAnIGhlaWdodDogJyArIGNlbGxTaXplICsgJ3B4Oyc7XG4gICAgICAgICAgcXJIdG1sICs9ICcgYmFja2dyb3VuZC1jb2xvcjogJztcbiAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMpPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZic7XG4gICAgICAgICAgcXJIdG1sICs9ICc7JztcbiAgICAgICAgICBxckh0bWwgKz0gJ1wiLz4nO1xuICAgICAgICB9XG5cbiAgICAgICAgcXJIdG1sICs9ICc8L3RyPic7XG4gICAgICB9XG5cbiAgICAgIHFySHRtbCArPSAnPC90Ym9keT4nO1xuICAgICAgcXJIdG1sICs9ICc8L3RhYmxlPic7XG5cbiAgICAgIHJldHVybiBxckh0bWw7XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZVN2Z1RhZyA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcblxuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICB2YXIgYywgbWMsIHIsIG1yLCBxclN2Zz0nJywgcmVjdDtcblxuICAgICAgcmVjdCA9ICdsJyArIGNlbGxTaXplICsgJywwIDAsJyArIGNlbGxTaXplICtcbiAgICAgICAgJyAtJyArIGNlbGxTaXplICsgJywwIDAsLScgKyBjZWxsU2l6ZSArICd6ICc7XG5cbiAgICAgIHFyU3ZnICs9ICc8c3ZnIHZlcnNpb249XCIxLjFcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCInO1xuICAgICAgcXJTdmcgKz0gJyB3aWR0aD1cIicgKyBzaXplICsgJ3B4XCInO1xuICAgICAgcXJTdmcgKz0gJyBoZWlnaHQ9XCInICsgc2l6ZSArICdweFwiJztcbiAgICAgIHFyU3ZnICs9ICcgdmlld0JveD1cIjAgMCAnICsgc2l6ZSArICcgJyArIHNpemUgKyAnXCIgJztcbiAgICAgIHFyU3ZnICs9ICcgcHJlc2VydmVBc3BlY3RSYXRpbz1cInhNaW5ZTWluIG1lZXRcIj4nO1xuICAgICAgcXJTdmcgKz0gJzxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmaWxsPVwid2hpdGVcIiBjeD1cIjBcIiBjeT1cIjBcIi8+JztcbiAgICAgIHFyU3ZnICs9ICc8cGF0aCBkPVwiJztcblxuICAgICAgZm9yIChyID0gMDsgciA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IHIgKz0gMSkge1xuICAgICAgICBtciA9IHIgKiBjZWxsU2l6ZSArIG1hcmdpbjtcbiAgICAgICAgZm9yIChjID0gMDsgYyA8IF90aGlzLmdldE1vZHVsZUNvdW50KCk7IGMgKz0gMSkge1xuICAgICAgICAgIGlmIChfdGhpcy5pc0RhcmsociwgYykgKSB7XG4gICAgICAgICAgICBtYyA9IGMqY2VsbFNpemUrbWFyZ2luO1xuICAgICAgICAgICAgcXJTdmcgKz0gJ00nICsgbWMgKyAnLCcgKyBtciArIHJlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHFyU3ZnICs9ICdcIiBzdHJva2U9XCJ0cmFuc3BhcmVudFwiIGZpbGw9XCJibGFja1wiLz4nO1xuICAgICAgcXJTdmcgKz0gJzwvc3ZnPic7XG5cbiAgICAgIHJldHVybiBxclN2ZztcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlRGF0YVVSTCA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcblxuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG5cbiAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBtaW4gPSBtYXJnaW47XG4gICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblxuICAgICAgcmV0dXJuIGNyZWF0ZURhdGFVUkwoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAobWluIDw9IHggJiYgeCA8IG1heCAmJiBtaW4gPD0geSAmJiB5IDwgbWF4KSB7XG4gICAgICAgICAgdmFyIGMgPSBNYXRoLmZsb29yKCAoeCAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgdmFyIHIgPSBNYXRoLmZsb29yKCAoeSAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgcmV0dXJuIF90aGlzLmlzRGFyayhyLCBjKT8gMCA6IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgIH0gKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlSW1nVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbiwgYWx0KSB7XG5cbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgIG1hcmdpbiA9ICh0eXBlb2YgbWFyZ2luID09ICd1bmRlZmluZWQnKT8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuXG4gICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG5cbiAgICAgIHZhciBpbWcgPSAnJztcbiAgICAgIGltZyArPSAnPGltZyc7XG4gICAgICBpbWcgKz0gJ1xcdTAwMjBzcmM9XCInO1xuICAgICAgaW1nICs9IF90aGlzLmNyZWF0ZURhdGFVUkwoY2VsbFNpemUsIG1hcmdpbik7XG4gICAgICBpbWcgKz0gJ1wiJztcbiAgICAgIGltZyArPSAnXFx1MDAyMHdpZHRoPVwiJztcbiAgICAgIGltZyArPSBzaXplO1xuICAgICAgaW1nICs9ICdcIic7XG4gICAgICBpbWcgKz0gJ1xcdTAwMjBoZWlnaHQ9XCInO1xuICAgICAgaW1nICs9IHNpemU7XG4gICAgICBpbWcgKz0gJ1wiJztcbiAgICAgIGlmIChhbHQpIHtcbiAgICAgICAgaW1nICs9ICdcXHUwMDIwYWx0PVwiJztcbiAgICAgICAgaW1nICs9IGFsdDtcbiAgICAgICAgaW1nICs9ICdcIic7XG4gICAgICB9XG4gICAgICBpbWcgKz0gJy8+JztcblxuICAgICAgcmV0dXJuIGltZztcbiAgICB9O1xuXG4gICAgdmFyIF9jcmVhdGVIYWxmQVNDSUkgPSBmdW5jdGlvbihtYXJnaW4pIHtcbiAgICAgIHZhciBjZWxsU2l6ZSA9IDE7XG4gICAgICBtYXJnaW4gPSAodHlwZW9mIG1hcmdpbiA9PSAndW5kZWZpbmVkJyk/IGNlbGxTaXplICogMiA6IG1hcmdpbjtcblxuICAgICAgdmFyIHNpemUgPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpICogY2VsbFNpemUgKyBtYXJnaW4gKiAyO1xuICAgICAgdmFyIG1pbiA9IG1hcmdpbjtcbiAgICAgIHZhciBtYXggPSBzaXplIC0gbWFyZ2luO1xuXG4gICAgICB2YXIgeSwgeCwgcjEsIHIyLCBwO1xuXG4gICAgICB2YXIgYmxvY2tzID0ge1xuICAgICAgICAn4paI4paIJzogJ+KWiCcsXG4gICAgICAgICfiloggJzogJ+KWgCcsXG4gICAgICAgICcg4paIJzogJ+KWhCcsXG4gICAgICAgICcgICc6ICcgJ1xuICAgICAgfTtcblxuICAgICAgdmFyIGFzY2lpID0gJyc7XG4gICAgICBmb3IgKHkgPSAwOyB5IDwgc2l6ZTsgeSArPSAyKSB7XG4gICAgICAgIHIxID0gTWF0aC5mbG9vcigoeSAtIG1pbikgLyBjZWxsU2l6ZSk7XG4gICAgICAgIHIyID0gTWF0aC5mbG9vcigoeSArIDEgLSBtaW4pIC8gY2VsbFNpemUpO1xuICAgICAgICBmb3IgKHggPSAwOyB4IDwgc2l6ZTsgeCArPSAxKSB7XG4gICAgICAgICAgcCA9ICfilognO1xuXG4gICAgICAgICAgaWYgKG1pbiA8PSB4ICYmIHggPCBtYXggJiYgbWluIDw9IHkgJiYgeSA8IG1heCAmJiBfdGhpcy5pc0RhcmsocjEsIE1hdGguZmxvb3IoKHggLSBtaW4pIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgcCA9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWluIDw9IHggJiYgeCA8IG1heCAmJiBtaW4gPD0geSsxICYmIHkrMSA8IG1heCAmJiBfdGhpcy5pc0RhcmsocjIsIE1hdGguZmxvb3IoKHggLSBtaW4pIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgcCArPSAnICc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcCArPSAn4paIJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBPdXRwdXQgMiBjaGFyYWN0ZXJzIHBlciBwaXhlbCwgdG8gY3JlYXRlIGZ1bGwgc3F1YXJlLiAxIGNoYXJhY3RlciBwZXIgcGl4ZWxzIGdpdmVzIG9ubHkgaGFsZiB3aWR0aCBvZiBzcXVhcmUuXG4gICAgICAgICAgYXNjaWkgKz0gYmxvY2tzW3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgYXNjaWkgKz0gJ1xcbic7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaXplICUgMikge1xuICAgICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aCAtIHNpemUgLSAxKSArIEFycmF5KHNpemUrMSkuam9pbign4paAJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhc2NpaS5zdWJzdHJpbmcoMCwgYXNjaWkubGVuZ3RoLTEpO1xuICAgIH07XG5cbiAgICBfdGhpcy5jcmVhdGVBU0NJSSA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcbiAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMTtcblxuICAgICAgaWYgKGNlbGxTaXplIDwgMikge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZUhhbGZBU0NJSShtYXJnaW4pO1xuICAgICAgfVxuXG4gICAgICBjZWxsU2l6ZSAtPSAxO1xuICAgICAgbWFyZ2luID0gKHR5cGVvZiBtYXJnaW4gPT0gJ3VuZGVmaW5lZCcpPyBjZWxsU2l6ZSAqIDIgOiBtYXJnaW47XG5cbiAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBtaW4gPSBtYXJnaW47XG4gICAgICB2YXIgbWF4ID0gc2l6ZSAtIG1hcmdpbjtcblxuICAgICAgdmFyIHksIHgsIHIsIHA7XG5cbiAgICAgIHZhciB3aGl0ZSA9IEFycmF5KGNlbGxTaXplKzEpLmpvaW4oJ+KWiOKWiCcpO1xuICAgICAgdmFyIGJsYWNrID0gQXJyYXkoY2VsbFNpemUrMSkuam9pbignICAnKTtcblxuICAgICAgdmFyIGFzY2lpID0gJyc7XG4gICAgICB2YXIgbGluZSA9ICcnO1xuICAgICAgZm9yICh5ID0gMDsgeSA8IHNpemU7IHkgKz0gMSkge1xuICAgICAgICByID0gTWF0aC5mbG9vciggKHkgLSBtaW4pIC8gY2VsbFNpemUpO1xuICAgICAgICBsaW5lID0gJyc7XG4gICAgICAgIGZvciAoeCA9IDA7IHggPCBzaXplOyB4ICs9IDEpIHtcbiAgICAgICAgICBwID0gMTtcblxuICAgICAgICAgIGlmIChtaW4gPD0geCAmJiB4IDwgbWF4ICYmIG1pbiA8PSB5ICYmIHkgPCBtYXggJiYgX3RoaXMuaXNEYXJrKHIsIE1hdGguZmxvb3IoKHggLSBtaW4pIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgcCA9IDA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gT3V0cHV0IDIgY2hhcmFjdGVycyBwZXIgcGl4ZWwsIHRvIGNyZWF0ZSBmdWxsIHNxdWFyZS4gMSBjaGFyYWN0ZXIgcGVyIHBpeGVscyBnaXZlcyBvbmx5IGhhbGYgd2lkdGggb2Ygc3F1YXJlLlxuICAgICAgICAgIGxpbmUgKz0gcCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHIgPSAwOyByIDwgY2VsbFNpemU7IHIgKz0gMSkge1xuICAgICAgICAgIGFzY2lpICs9IGxpbmUgKyAnXFxuJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXNjaWkuc3Vic3RyaW5nKDAsIGFzY2lpLmxlbmd0aC0xKTtcbiAgICB9O1xuXG4gICAgX3RoaXMucmVuZGVyVG8yZENvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBjZWxsU2l6ZSkge1xuICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgdmFyIGxlbmd0aCA9IF90aGlzLmdldE1vZHVsZUNvdW50KCk7XG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsZW5ndGg7IHJvdysrKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IF90aGlzLmlzRGFyayhyb3csIGNvbCkgPyAnYmxhY2snIDogJ3doaXRlJztcbiAgICAgICAgICBjb250ZXh0LmZpbGxSZWN0KHJvdyAqIGNlbGxTaXplLCBjb2wgKiBjZWxsU2l6ZSwgY2VsbFNpemUsIGNlbGxTaXplKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcmNvZGUuc3RyaW5nVG9CeXRlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHFyY29kZS5zdHJpbmdUb0J5dGVzRnVuY3MgPSB7XG4gICAgJ2RlZmF1bHQnIDogZnVuY3Rpb24ocykge1xuICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGJ5dGVzLnB1c2goYyAmIDB4ZmYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfTtcblxuICBxcmNvZGUuc3RyaW5nVG9CeXRlcyA9IHFyY29kZS5zdHJpbmdUb0J5dGVzRnVuY3NbJ2RlZmF1bHQnXTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxcmNvZGUuY3JlYXRlU3RyaW5nVG9CeXRlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gdW5pY29kZURhdGEgYmFzZTY0IHN0cmluZyBvZiBieXRlIGFycmF5LlxuICAgKiBbMTZiaXQgVW5pY29kZV0sWzE2Yml0IEJ5dGVzXSwgLi4uXG4gICAqIEBwYXJhbSBudW1DaGFyc1xuICAgKi9cbiAgcXJjb2RlLmNyZWF0ZVN0cmluZ1RvQnl0ZXMgPSBmdW5jdGlvbih1bmljb2RlRGF0YSwgbnVtQ2hhcnMpIHtcblxuICAgIC8vIGNyZWF0ZSBjb252ZXJzaW9uIG1hcC5cblxuICAgIHZhciB1bmljb2RlTWFwID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBiaW4gPSBiYXNlNjREZWNvZGVJbnB1dFN0cmVhbSh1bmljb2RlRGF0YSk7XG4gICAgICB2YXIgcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYiA9IGJpbi5yZWFkKCk7XG4gICAgICAgIGlmIChiID09IC0xKSB0aHJvdyAnZW9mJztcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9O1xuXG4gICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgdmFyIHVuaWNvZGVNYXAgPSB7fTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBiMCA9IGJpbi5yZWFkKCk7XG4gICAgICAgIGlmIChiMCA9PSAtMSkgYnJlYWs7XG4gICAgICAgIHZhciBiMSA9IHJlYWQoKTtcbiAgICAgICAgdmFyIGIyID0gcmVhZCgpO1xuICAgICAgICB2YXIgYjMgPSByZWFkKCk7XG4gICAgICAgIHZhciBrID0gU3RyaW5nLmZyb21DaGFyQ29kZSggKGIwIDw8IDgpIHwgYjEpO1xuICAgICAgICB2YXIgdiA9IChiMiA8PCA4KSB8IGIzO1xuICAgICAgICB1bmljb2RlTWFwW2tdID0gdjtcbiAgICAgICAgY291bnQgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChjb3VudCAhPSBudW1DaGFycykge1xuICAgICAgICB0aHJvdyBjb3VudCArICcgIT0gJyArIG51bUNoYXJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5pY29kZU1hcDtcbiAgICB9KCk7XG5cbiAgICB2YXIgdW5rbm93bkNoYXIgPSAnPycuY2hhckNvZGVBdCgwKTtcblxuICAgIHJldHVybiBmdW5jdGlvbihzKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgYyA9IHMuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAxMjgpIHtcbiAgICAgICAgICBieXRlcy5wdXNoKGMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBiID0gdW5pY29kZU1hcFtzLmNoYXJBdChpKV07XG4gICAgICAgICAgaWYgKHR5cGVvZiBiID09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBpZiAoIChiICYgMHhmZikgPT0gYikge1xuICAgICAgICAgICAgICAvLyAxYnl0ZVxuICAgICAgICAgICAgICBieXRlcy5wdXNoKGIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gMmJ5dGVzXG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiA+Pj4gOCk7XG4gICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiAmIDB4ZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlcy5wdXNoKHVua25vd25DaGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9O1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIFFSTW9kZVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBRUk1vZGUgPSB7XG4gICAgTU9ERV9OVU1CRVIgOiAgICAxIDw8IDAsXG4gICAgTU9ERV9BTFBIQV9OVU0gOiAxIDw8IDEsXG4gICAgTU9ERV84QklUX0JZVEUgOiAxIDw8IDIsXG4gICAgTU9ERV9LQU5KSSA6ICAgICAxIDw8IDNcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUkVycm9yQ29ycmVjdGlvbkxldmVsXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSB7XG4gICAgTCA6IDEsXG4gICAgTSA6IDAsXG4gICAgUSA6IDMsXG4gICAgSCA6IDJcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUk1hc2tQYXR0ZXJuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSTWFza1BhdHRlcm4gPSB7XG4gICAgUEFUVEVSTjAwMCA6IDAsXG4gICAgUEFUVEVSTjAwMSA6IDEsXG4gICAgUEFUVEVSTjAxMCA6IDIsXG4gICAgUEFUVEVSTjAxMSA6IDMsXG4gICAgUEFUVEVSTjEwMCA6IDQsXG4gICAgUEFUVEVSTjEwMSA6IDUsXG4gICAgUEFUVEVSTjExMCA6IDYsXG4gICAgUEFUVEVSTjExMSA6IDdcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBRUlV0aWxcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgUVJVdGlsID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgUEFUVEVSTl9QT1NJVElPTl9UQUJMRSA9IFtcbiAgICAgIFtdLFxuICAgICAgWzYsIDE4XSxcbiAgICAgIFs2LCAyMl0sXG4gICAgICBbNiwgMjZdLFxuICAgICAgWzYsIDMwXSxcbiAgICAgIFs2LCAzNF0sXG4gICAgICBbNiwgMjIsIDM4XSxcbiAgICAgIFs2LCAyNCwgNDJdLFxuICAgICAgWzYsIDI2LCA0Nl0sXG4gICAgICBbNiwgMjgsIDUwXSxcbiAgICAgIFs2LCAzMCwgNTRdLFxuICAgICAgWzYsIDMyLCA1OF0sXG4gICAgICBbNiwgMzQsIDYyXSxcbiAgICAgIFs2LCAyNiwgNDYsIDY2XSxcbiAgICAgIFs2LCAyNiwgNDgsIDcwXSxcbiAgICAgIFs2LCAyNiwgNTAsIDc0XSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4XSxcbiAgICAgIFs2LCAzMCwgNTYsIDgyXSxcbiAgICAgIFs2LCAzMCwgNTgsIDg2XSxcbiAgICAgIFs2LCAzNCwgNjIsIDkwXSxcbiAgICAgIFs2LCAyOCwgNTAsIDcyLCA5NF0sXG4gICAgICBbNiwgMjYsIDUwLCA3NCwgOThdLFxuICAgICAgWzYsIDMwLCA1NCwgNzgsIDEwMl0sXG4gICAgICBbNiwgMjgsIDU0LCA4MCwgMTA2XSxcbiAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTBdLFxuICAgICAgWzYsIDMwLCA1OCwgODYsIDExNF0sXG4gICAgICBbNiwgMzQsIDYyLCA5MCwgMTE4XSxcbiAgICAgIFs2LCAyNiwgNTAsIDc0LCA5OCwgMTIyXSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0sXG4gICAgICBbNiwgMjYsIDUyLCA3OCwgMTA0LCAxMzBdLFxuICAgICAgWzYsIDMwLCA1NiwgODIsIDEwOCwgMTM0XSxcbiAgICAgIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sXG4gICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDJdLFxuICAgICAgWzYsIDM0LCA2MiwgOTAsIDExOCwgMTQ2XSxcbiAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSxcbiAgICAgIFs2LCAyNCwgNTAsIDc2LCAxMDIsIDEyOCwgMTU0XSxcbiAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDYsIDEzMiwgMTU4XSxcbiAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSxcbiAgICAgIFs2LCAyNiwgNTQsIDgyLCAxMTAsIDEzOCwgMTY2XSxcbiAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0MiwgMTcwXVxuICAgIF07XG4gICAgdmFyIEcxNSA9ICgxIDw8IDEwKSB8ICgxIDw8IDgpIHwgKDEgPDwgNSkgfCAoMSA8PCA0KSB8ICgxIDw8IDIpIHwgKDEgPDwgMSkgfCAoMSA8PCAwKTtcbiAgICB2YXIgRzE4ID0gKDEgPDwgMTIpIHwgKDEgPDwgMTEpIHwgKDEgPDwgMTApIHwgKDEgPDwgOSkgfCAoMSA8PCA4KSB8ICgxIDw8IDUpIHwgKDEgPDwgMikgfCAoMSA8PCAwKTtcbiAgICB2YXIgRzE1X01BU0sgPSAoMSA8PCAxNCkgfCAoMSA8PCAxMikgfCAoMSA8PCAxMCkgfCAoMSA8PCA0KSB8ICgxIDw8IDEpO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICB2YXIgZ2V0QkNIRGlnaXQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgZGlnaXQgPSAwO1xuICAgICAgd2hpbGUgKGRhdGEgIT0gMCkge1xuICAgICAgICBkaWdpdCArPSAxO1xuICAgICAgICBkYXRhID4+Pj0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWdpdDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QkNIVHlwZUluZm8gPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgICB3aGlsZSAoZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTUpID49IDApIHtcbiAgICAgICAgZCBePSAoRzE1IDw8IChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxNSkgKSApO1xuICAgICAgfVxuICAgICAgcmV0dXJuICggKGRhdGEgPDwgMTApIHwgZCkgXiBHMTVfTUFTSztcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0QkNIVHlwZU51bWJlciA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBkID0gZGF0YSA8PCAxMjtcbiAgICAgIHdoaWxlIChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxOCkgPj0gMCkge1xuICAgICAgICBkIF49IChHMTggPDwgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KSApICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKGRhdGEgPDwgMTIpIHwgZDtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0UGF0dGVyblBvc2l0aW9uID0gZnVuY3Rpb24odHlwZU51bWJlcikge1xuICAgICAgcmV0dXJuIFBBVFRFUk5fUE9TSVRJT05fVEFCTEVbdHlwZU51bWJlciAtIDFdO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRNYXNrRnVuY3Rpb24gPSBmdW5jdGlvbihtYXNrUGF0dGVybikge1xuXG4gICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG5cbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDAwIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIChpICsgaikgJSAyID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMSA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiBpICUgMiA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMTAgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gaiAlIDMgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDExIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuIChpICsgaikgJSAzID09IDA7IH07XG4gICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMCA6XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihpLCBqKSB7IHJldHVybiAoTWF0aC5mbG9vcihpIC8gMikgKyBNYXRoLmZsb29yKGogLyAzKSApICUgMiA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMDEgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gKGkgKiBqKSAlIDIgKyAoaSAqIGopICUgMyA9PSAwOyB9O1xuICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTAgOlxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaSwgaikgeyByZXR1cm4gKCAoaSAqIGopICUgMiArIChpICogaikgJSAzKSAlIDIgPT0gMDsgfTtcbiAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTExIDpcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGksIGopIHsgcmV0dXJuICggKGkgKiBqKSAlIDMgKyAoaSArIGopICUgMikgJSAyID09IDA7IH07XG5cbiAgICAgIGRlZmF1bHQgOlxuICAgICAgICB0aHJvdyAnYmFkIG1hc2tQYXR0ZXJuOicgKyBtYXNrUGF0dGVybjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbCA9IGZ1bmN0aW9uKGVycm9yQ29ycmVjdExlbmd0aCkge1xuICAgICAgdmFyIGEgPSBxclBvbHlub21pYWwoWzFdLCAwKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXJyb3JDb3JyZWN0TGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYSA9IGEubXVsdGlwbHkocXJQb2x5bm9taWFsKFsxLCBRUk1hdGguZ2V4cChpKV0sIDApICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24obW9kZSwgdHlwZSkge1xuXG4gICAgICBpZiAoMSA8PSB0eXBlICYmIHR5cGUgPCAxMCkge1xuXG4gICAgICAgIC8vIDEgLSA5XG5cbiAgICAgICAgc3dpdGNoKG1vZGUpIHtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVIgICAgOiByZXR1cm4gMTA7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNIDogcmV0dXJuIDk7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFIDogcmV0dXJuIDg7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkkgICAgIDogcmV0dXJuIDg7XG4gICAgICAgIGRlZmF1bHQgOlxuICAgICAgICAgIHRocm93ICdtb2RlOicgKyBtb2RlO1xuICAgICAgICB9XG5cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA8IDI3KSB7XG5cbiAgICAgICAgLy8gMTAgLSAyNlxuXG4gICAgICAgIHN3aXRjaChtb2RlKSB7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSICAgIDogcmV0dXJuIDEyO1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTSA6IHJldHVybiAxMTtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV84QklUX0JZVEUgOiByZXR1cm4gMTY7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfS0FOSkkgICAgIDogcmV0dXJuIDEwO1xuICAgICAgICBkZWZhdWx0IDpcbiAgICAgICAgICB0aHJvdyAnbW9kZTonICsgbW9kZTtcbiAgICAgICAgfVxuXG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPCA0MSkge1xuXG4gICAgICAgIC8vIDI3IC0gNDBcblxuICAgICAgICBzd2l0Y2gobW9kZSkge1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUiAgICA6IHJldHVybiAxNDtcbiAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU0gOiByZXR1cm4gMTM7XG4gICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFIDogcmV0dXJuIDE2O1xuICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJICAgICA6IHJldHVybiAxMjtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgJ21vZGU6JyArIG1vZGU7XG4gICAgICAgIH1cblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgJ3R5cGU6JyArIHR5cGU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmdldExvc3RQb2ludCA9IGZ1bmN0aW9uKHFyY29kZSkge1xuXG4gICAgICB2YXIgbW9kdWxlQ291bnQgPSBxcmNvZGUuZ2V0TW9kdWxlQ291bnQoKTtcblxuICAgICAgdmFyIGxvc3RQb2ludCA9IDA7XG5cbiAgICAgIC8vIExFVkVMMVxuXG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG5cbiAgICAgICAgICB2YXIgc2FtZUNvdW50ID0gMDtcbiAgICAgICAgICB2YXIgZGFyayA9IHFyY29kZS5pc0Rhcmsocm93LCBjb2wpO1xuXG4gICAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDE7IHIgKz0gMSkge1xuXG4gICAgICAgICAgICBpZiAocm93ICsgciA8IDAgfHwgbW9kdWxlQ291bnQgPD0gcm93ICsgcikge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgYyA9IC0xOyBjIDw9IDE7IGMgKz0gMSkge1xuXG4gICAgICAgICAgICAgIGlmIChjb2wgKyBjIDwgMCB8fCBtb2R1bGVDb3VudCA8PSBjb2wgKyBjKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAociA9PSAwICYmIGMgPT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKGRhcmsgPT0gcXJjb2RlLmlzRGFyayhyb3cgKyByLCBjb2wgKyBjKSApIHtcbiAgICAgICAgICAgICAgICBzYW1lQ291bnQgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzYW1lQ291bnQgPiA1KSB7XG4gICAgICAgICAgICBsb3N0UG9pbnQgKz0gKDMgKyBzYW1lQ291bnQgLSA1KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIExFVkVMMlxuXG4gICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDE7IHJvdyArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gMTsgY29sICs9IDEpIHtcbiAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgIGlmIChxcmNvZGUuaXNEYXJrKHJvdywgY29sKSApIGNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sKSApIGNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAxKSApIGNvdW50ICs9IDE7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93ICsgMSwgY29sICsgMSkgKSBjb3VudCArPSAxO1xuICAgICAgICAgIGlmIChjb3VudCA9PSAwIHx8IGNvdW50ID09IDQpIHtcbiAgICAgICAgICAgIGxvc3RQb2ludCArPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMRVZFTDNcblxuICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50IC0gNjsgY29sICs9IDEpIHtcbiAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbClcbiAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyAxKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDIpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgMylcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93LCBjb2wgKyA0KVxuICAgICAgICAgICAgICAmJiAhcXJjb2RlLmlzRGFyayhyb3csIGNvbCArIDUpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdywgY29sICsgNikgKSB7XG4gICAgICAgICAgICBsb3N0UG9pbnQgKz0gNDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDY7IHJvdyArPSAxKSB7XG4gICAgICAgICAgaWYgKHFyY29kZS5pc0Rhcmsocm93LCBjb2wpXG4gICAgICAgICAgICAgICYmICFxcmNvZGUuaXNEYXJrKHJvdyArIDEsIGNvbClcbiAgICAgICAgICAgICAgJiYgIHFyY29kZS5pc0Rhcmsocm93ICsgMiwgY29sKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3cgKyAzLCBjb2wpXG4gICAgICAgICAgICAgICYmICBxcmNvZGUuaXNEYXJrKHJvdyArIDQsIGNvbClcbiAgICAgICAgICAgICAgJiYgIXFyY29kZS5pc0Rhcmsocm93ICsgNSwgY29sKVxuICAgICAgICAgICAgICAmJiAgcXJjb2RlLmlzRGFyayhyb3cgKyA2LCBjb2wpICkge1xuICAgICAgICAgICAgbG9zdFBvaW50ICs9IDQwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBMRVZFTDRcblxuICAgICAgdmFyIGRhcmtDb3VudCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICBpZiAocXJjb2RlLmlzRGFyayhyb3csIGNvbCkgKSB7XG4gICAgICAgICAgICBkYXJrQ291bnQgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJhdGlvID0gTWF0aC5hYnMoMTAwICogZGFya0NvdW50IC8gbW9kdWxlQ291bnQgLyBtb2R1bGVDb3VudCAtIDUwKSAvIDU7XG4gICAgICBsb3N0UG9pbnQgKz0gcmF0aW8gKiAxMDtcblxuICAgICAgcmV0dXJuIGxvc3RQb2ludDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9KCk7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUVJNYXRoXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSTWF0aCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIEVYUF9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuICAgIHZhciBMT0dfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuICAgIC8vIGluaXRpYWxpemUgdGFibGVzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgIEVYUF9UQUJMRVtpXSA9IDEgPDwgaTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDg7IGkgPCAyNTY7IGkgKz0gMSkge1xuICAgICAgRVhQX1RBQkxFW2ldID0gRVhQX1RBQkxFW2kgLSA0XVxuICAgICAgICBeIEVYUF9UQUJMRVtpIC0gNV1cbiAgICAgICAgXiBFWFBfVEFCTEVbaSAtIDZdXG4gICAgICAgIF4gRVhQX1RBQkxFW2kgLSA4XTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTU7IGkgKz0gMSkge1xuICAgICAgTE9HX1RBQkxFW0VYUF9UQUJMRVtpXSBdID0gaTtcbiAgICB9XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdsb2cgPSBmdW5jdGlvbihuKSB7XG5cbiAgICAgIGlmIChuIDwgMSkge1xuICAgICAgICB0aHJvdyAnZ2xvZygnICsgbiArICcpJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIExPR19UQUJMRVtuXTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V4cCA9IGZ1bmN0aW9uKG4pIHtcblxuICAgICAgd2hpbGUgKG4gPCAwKSB7XG4gICAgICAgIG4gKz0gMjU1O1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobiA+PSAyNTYpIHtcbiAgICAgICAgbiAtPSAyNTU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBFWFBfVEFCTEVbbl07XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfSgpO1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyUG9seW5vbWlhbFxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGZ1bmN0aW9uIHFyUG9seW5vbWlhbChudW0sIHNoaWZ0KSB7XG5cbiAgICBpZiAodHlwZW9mIG51bS5sZW5ndGggPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG51bS5sZW5ndGggKyAnLycgKyBzaGlmdDtcbiAgICB9XG5cbiAgICB2YXIgX251bSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICB3aGlsZSAob2Zmc2V0IDwgbnVtLmxlbmd0aCAmJiBudW1bb2Zmc2V0XSA9PSAwKSB7XG4gICAgICAgIG9mZnNldCArPSAxO1xuICAgICAgfVxuICAgICAgdmFyIF9udW0gPSBuZXcgQXJyYXkobnVtLmxlbmd0aCAtIG9mZnNldCArIHNoaWZ0KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aCAtIG9mZnNldDsgaSArPSAxKSB7XG4gICAgICAgIF9udW1baV0gPSBudW1baSArIG9mZnNldF07XG4gICAgICB9XG4gICAgICByZXR1cm4gX251bTtcbiAgICB9KCk7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIHJldHVybiBfbnVtW2luZGV4XTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX251bS5sZW5ndGg7XG4gICAgfTtcblxuICAgIF90aGlzLm11bHRpcGx5ID0gZnVuY3Rpb24oZSkge1xuXG4gICAgICB2YXIgbnVtID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpICsgZS5nZXRMZW5ndGgoKSAtIDEpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmdldExlbmd0aCgpOyBpICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlLmdldExlbmd0aCgpOyBqICs9IDEpIHtcbiAgICAgICAgICBudW1baSArIGpdIF49IFFSTWF0aC5nZXhwKFFSTWF0aC5nbG9nKF90aGlzLmdldEF0KGkpICkgKyBRUk1hdGguZ2xvZyhlLmdldEF0KGopICkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcXJQb2x5bm9taWFsKG51bSwgMCk7XG4gICAgfTtcblxuICAgIF90aGlzLm1vZCA9IGZ1bmN0aW9uKGUpIHtcblxuICAgICAgaWYgKF90aGlzLmdldExlbmd0aCgpIC0gZS5nZXRMZW5ndGgoKSA8IDApIHtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmF0aW8gPSBRUk1hdGguZ2xvZyhfdGhpcy5nZXRBdCgwKSApIC0gUVJNYXRoLmdsb2coZS5nZXRBdCgwKSApO1xuXG4gICAgICB2YXIgbnVtID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpICk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmdldExlbmd0aCgpOyBpICs9IDEpIHtcbiAgICAgICAgbnVtW2ldID0gX3RoaXMuZ2V0QXQoaSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5nZXRMZW5ndGgoKTsgaSArPSAxKSB7XG4gICAgICAgIG51bVtpXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhlLmdldEF0KGkpICkgKyByYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICByZXR1cm4gcXJQb2x5bm9taWFsKG51bSwgMCkubW9kKGUpO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gUVJSU0Jsb2NrXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIFFSUlNCbG9jayA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIFJTX0JMT0NLX1RBQkxFID0gW1xuXG4gICAgICAvLyBMXG4gICAgICAvLyBNXG4gICAgICAvLyBRXG4gICAgICAvLyBIXG5cbiAgICAgIC8vIDFcbiAgICAgIFsxLCAyNiwgMTldLFxuICAgICAgWzEsIDI2LCAxNl0sXG4gICAgICBbMSwgMjYsIDEzXSxcbiAgICAgIFsxLCAyNiwgOV0sXG5cbiAgICAgIC8vIDJcbiAgICAgIFsxLCA0NCwgMzRdLFxuICAgICAgWzEsIDQ0LCAyOF0sXG4gICAgICBbMSwgNDQsIDIyXSxcbiAgICAgIFsxLCA0NCwgMTZdLFxuXG4gICAgICAvLyAzXG4gICAgICBbMSwgNzAsIDU1XSxcbiAgICAgIFsxLCA3MCwgNDRdLFxuICAgICAgWzIsIDM1LCAxN10sXG4gICAgICBbMiwgMzUsIDEzXSxcblxuICAgICAgLy8gNFxuICAgICAgWzEsIDEwMCwgODBdLFxuICAgICAgWzIsIDUwLCAzMl0sXG4gICAgICBbMiwgNTAsIDI0XSxcbiAgICAgIFs0LCAyNSwgOV0sXG5cbiAgICAgIC8vIDVcbiAgICAgIFsxLCAxMzQsIDEwOF0sXG4gICAgICBbMiwgNjcsIDQzXSxcbiAgICAgIFsyLCAzMywgMTUsIDIsIDM0LCAxNl0sXG4gICAgICBbMiwgMzMsIDExLCAyLCAzNCwgMTJdLFxuXG4gICAgICAvLyA2XG4gICAgICBbMiwgODYsIDY4XSxcbiAgICAgIFs0LCA0MywgMjddLFxuICAgICAgWzQsIDQzLCAxOV0sXG4gICAgICBbNCwgNDMsIDE1XSxcblxuICAgICAgLy8gN1xuICAgICAgWzIsIDk4LCA3OF0sXG4gICAgICBbNCwgNDksIDMxXSxcbiAgICAgIFsyLCAzMiwgMTQsIDQsIDMzLCAxNV0sXG4gICAgICBbNCwgMzksIDEzLCAxLCA0MCwgMTRdLFxuXG4gICAgICAvLyA4XG4gICAgICBbMiwgMTIxLCA5N10sXG4gICAgICBbMiwgNjAsIDM4LCAyLCA2MSwgMzldLFxuICAgICAgWzQsIDQwLCAxOCwgMiwgNDEsIDE5XSxcbiAgICAgIFs0LCA0MCwgMTQsIDIsIDQxLCAxNV0sXG5cbiAgICAgIC8vIDlcbiAgICAgIFsyLCAxNDYsIDExNl0sXG4gICAgICBbMywgNTgsIDM2LCAyLCA1OSwgMzddLFxuICAgICAgWzQsIDM2LCAxNiwgNCwgMzcsIDE3XSxcbiAgICAgIFs0LCAzNiwgMTIsIDQsIDM3LCAxM10sXG5cbiAgICAgIC8vIDEwXG4gICAgICBbMiwgODYsIDY4LCAyLCA4NywgNjldLFxuICAgICAgWzQsIDY5LCA0MywgMSwgNzAsIDQ0XSxcbiAgICAgIFs2LCA0MywgMTksIDIsIDQ0LCAyMF0sXG4gICAgICBbNiwgNDMsIDE1LCAyLCA0NCwgMTZdLFxuXG4gICAgICAvLyAxMVxuICAgICAgWzQsIDEwMSwgODFdLFxuICAgICAgWzEsIDgwLCA1MCwgNCwgODEsIDUxXSxcbiAgICAgIFs0LCA1MCwgMjIsIDQsIDUxLCAyM10sXG4gICAgICBbMywgMzYsIDEyLCA4LCAzNywgMTNdLFxuXG4gICAgICAvLyAxMlxuICAgICAgWzIsIDExNiwgOTIsIDIsIDExNywgOTNdLFxuICAgICAgWzYsIDU4LCAzNiwgMiwgNTksIDM3XSxcbiAgICAgIFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sXG4gICAgICBbNywgNDIsIDE0LCA0LCA0MywgMTVdLFxuXG4gICAgICAvLyAxM1xuICAgICAgWzQsIDEzMywgMTA3XSxcbiAgICAgIFs4LCA1OSwgMzcsIDEsIDYwLCAzOF0sXG4gICAgICBbOCwgNDQsIDIwLCA0LCA0NSwgMjFdLFxuICAgICAgWzEyLCAzMywgMTEsIDQsIDM0LCAxMl0sXG5cbiAgICAgIC8vIDE0XG4gICAgICBbMywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSxcbiAgICAgIFs0LCA2NCwgNDAsIDUsIDY1LCA0MV0sXG4gICAgICBbMTEsIDM2LCAxNiwgNSwgMzcsIDE3XSxcbiAgICAgIFsxMSwgMzYsIDEyLCA1LCAzNywgMTNdLFxuXG4gICAgICAvLyAxNVxuICAgICAgWzUsIDEwOSwgODcsIDEsIDExMCwgODhdLFxuICAgICAgWzUsIDY1LCA0MSwgNSwgNjYsIDQyXSxcbiAgICAgIFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG4gICAgICBbMTEsIDM2LCAxMiwgNywgMzcsIDEzXSxcblxuICAgICAgLy8gMTZcbiAgICAgIFs1LCAxMjIsIDk4LCAxLCAxMjMsIDk5XSxcbiAgICAgIFs3LCA3MywgNDUsIDMsIDc0LCA0Nl0sXG4gICAgICBbMTUsIDQzLCAxOSwgMiwgNDQsIDIwXSxcbiAgICAgIFszLCA0NSwgMTUsIDEzLCA0NiwgMTZdLFxuXG4gICAgICAvLyAxN1xuICAgICAgWzEsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sXG4gICAgICBbMTAsIDc0LCA0NiwgMSwgNzUsIDQ3XSxcbiAgICAgIFsxLCA1MCwgMjIsIDE1LCA1MSwgMjNdLFxuICAgICAgWzIsIDQyLCAxNCwgMTcsIDQzLCAxNV0sXG5cbiAgICAgIC8vIDE4XG4gICAgICBbNSwgMTUwLCAxMjAsIDEsIDE1MSwgMTIxXSxcbiAgICAgIFs5LCA2OSwgNDMsIDQsIDcwLCA0NF0sXG4gICAgICBbMTcsIDUwLCAyMiwgMSwgNTEsIDIzXSxcbiAgICAgIFsyLCA0MiwgMTQsIDE5LCA0MywgMTVdLFxuXG4gICAgICAvLyAxOVxuICAgICAgWzMsIDE0MSwgMTEzLCA0LCAxNDIsIDExNF0sXG4gICAgICBbMywgNzAsIDQ0LCAxMSwgNzEsIDQ1XSxcbiAgICAgIFsxNywgNDcsIDIxLCA0LCA0OCwgMjJdLFxuICAgICAgWzksIDM5LCAxMywgMTYsIDQwLCAxNF0sXG5cbiAgICAgIC8vIDIwXG4gICAgICBbMywgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcbiAgICAgIFszLCA2NywgNDEsIDEzLCA2OCwgNDJdLFxuICAgICAgWzE1LCA1NCwgMjQsIDUsIDU1LCAyNV0sXG4gICAgICBbMTUsIDQzLCAxNSwgMTAsIDQ0LCAxNl0sXG5cbiAgICAgIC8vIDIxXG4gICAgICBbNCwgMTQ0LCAxMTYsIDQsIDE0NSwgMTE3XSxcbiAgICAgIFsxNywgNjgsIDQyXSxcbiAgICAgIFsxNywgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgWzE5LCA0NiwgMTYsIDYsIDQ3LCAxN10sXG5cbiAgICAgIC8vIDIyXG4gICAgICBbMiwgMTM5LCAxMTEsIDcsIDE0MCwgMTEyXSxcbiAgICAgIFsxNywgNzQsIDQ2XSxcbiAgICAgIFs3LCA1NCwgMjQsIDE2LCA1NSwgMjVdLFxuICAgICAgWzM0LCAzNywgMTNdLFxuXG4gICAgICAvLyAyM1xuICAgICAgWzQsIDE1MSwgMTIxLCA1LCAxNTIsIDEyMl0sXG4gICAgICBbNCwgNzUsIDQ3LCAxNCwgNzYsIDQ4XSxcbiAgICAgIFsxMSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgIFsxNiwgNDUsIDE1LCAxNCwgNDYsIDE2XSxcblxuICAgICAgLy8gMjRcbiAgICAgIFs2LCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLFxuICAgICAgWzYsIDczLCA0NSwgMTQsIDc0LCA0Nl0sXG4gICAgICBbMTEsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICBbMzAsIDQ2LCAxNiwgMiwgNDcsIDE3XSxcblxuICAgICAgLy8gMjVcbiAgICAgIFs4LCAxMzIsIDEwNiwgNCwgMTMzLCAxMDddLFxuICAgICAgWzgsIDc1LCA0NywgMTMsIDc2LCA0OF0sXG4gICAgICBbNywgNTQsIDI0LCAyMiwgNTUsIDI1XSxcbiAgICAgIFsyMiwgNDUsIDE1LCAxMywgNDYsIDE2XSxcblxuICAgICAgLy8gMjZcbiAgICAgIFsxMCwgMTQyLCAxMTQsIDIsIDE0MywgMTE1XSxcbiAgICAgIFsxOSwgNzQsIDQ2LCA0LCA3NSwgNDddLFxuICAgICAgWzI4LCA1MCwgMjIsIDYsIDUxLCAyM10sXG4gICAgICBbMzMsIDQ2LCAxNiwgNCwgNDcsIDE3XSxcblxuICAgICAgLy8gMjdcbiAgICAgIFs4LCAxNTIsIDEyMiwgNCwgMTUzLCAxMjNdLFxuICAgICAgWzIyLCA3MywgNDUsIDMsIDc0LCA0Nl0sXG4gICAgICBbOCwgNTMsIDIzLCAyNiwgNTQsIDI0XSxcbiAgICAgIFsxMiwgNDUsIDE1LCAyOCwgNDYsIDE2XSxcblxuICAgICAgLy8gMjhcbiAgICAgIFszLCAxNDcsIDExNywgMTAsIDE0OCwgMTE4XSxcbiAgICAgIFszLCA3MywgNDUsIDIzLCA3NCwgNDZdLFxuICAgICAgWzQsIDU0LCAyNCwgMzEsIDU1LCAyNV0sXG4gICAgICBbMTEsIDQ1LCAxNSwgMzEsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDI5XG4gICAgICBbNywgMTQ2LCAxMTYsIDcsIDE0NywgMTE3XSxcbiAgICAgIFsyMSwgNzMsIDQ1LCA3LCA3NCwgNDZdLFxuICAgICAgWzEsIDUzLCAyMywgMzcsIDU0LCAyNF0sXG4gICAgICBbMTksIDQ1LCAxNSwgMjYsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDMwXG4gICAgICBbNSwgMTQ1LCAxMTUsIDEwLCAxNDYsIDExNl0sXG4gICAgICBbMTksIDc1LCA0NywgMTAsIDc2LCA0OF0sXG4gICAgICBbMTUsIDU0LCAyNCwgMjUsIDU1LCAyNV0sXG4gICAgICBbMjMsIDQ1LCAxNSwgMjUsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDMxXG4gICAgICBbMTMsIDE0NSwgMTE1LCAzLCAxNDYsIDExNl0sXG4gICAgICBbMiwgNzQsIDQ2LCAyOSwgNzUsIDQ3XSxcbiAgICAgIFs0MiwgNTQsIDI0LCAxLCA1NSwgMjVdLFxuICAgICAgWzIzLCA0NSwgMTUsIDI4LCA0NiwgMTZdLFxuXG4gICAgICAvLyAzMlxuICAgICAgWzE3LCAxNDUsIDExNV0sXG4gICAgICBbMTAsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG4gICAgICBbMTAsIDU0LCAyNCwgMzUsIDU1LCAyNV0sXG4gICAgICBbMTksIDQ1LCAxNSwgMzUsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDMzXG4gICAgICBbMTcsIDE0NSwgMTE1LCAxLCAxNDYsIDExNl0sXG4gICAgICBbMTQsIDc0LCA0NiwgMjEsIDc1LCA0N10sXG4gICAgICBbMjksIDU0LCAyNCwgMTksIDU1LCAyNV0sXG4gICAgICBbMTEsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG5cbiAgICAgIC8vIDM0XG4gICAgICBbMTMsIDE0NSwgMTE1LCA2LCAxNDYsIDExNl0sXG4gICAgICBbMTQsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG4gICAgICBbNDQsIDU0LCAyNCwgNywgNTUsIDI1XSxcbiAgICAgIFs1OSwgNDYsIDE2LCAxLCA0NywgMTddLFxuXG4gICAgICAvLyAzNVxuICAgICAgWzEyLCAxNTEsIDEyMSwgNywgMTUyLCAxMjJdLFxuICAgICAgWzEyLCA3NSwgNDcsIDI2LCA3NiwgNDhdLFxuICAgICAgWzM5LCA1NCwgMjQsIDE0LCA1NSwgMjVdLFxuICAgICAgWzIyLCA0NSwgMTUsIDQxLCA0NiwgMTZdLFxuXG4gICAgICAvLyAzNlxuICAgICAgWzYsIDE1MSwgMTIxLCAxNCwgMTUyLCAxMjJdLFxuICAgICAgWzYsIDc1LCA0NywgMzQsIDc2LCA0OF0sXG4gICAgICBbNDYsIDU0LCAyNCwgMTAsIDU1LCAyNV0sXG4gICAgICBbMiwgNDUsIDE1LCA2NCwgNDYsIDE2XSxcblxuICAgICAgLy8gMzdcbiAgICAgIFsxNywgMTUyLCAxMjIsIDQsIDE1MywgMTIzXSxcbiAgICAgIFsyOSwgNzQsIDQ2LCAxNCwgNzUsIDQ3XSxcbiAgICAgIFs0OSwgNTQsIDI0LCAxMCwgNTUsIDI1XSxcbiAgICAgIFsyNCwgNDUsIDE1LCA0NiwgNDYsIDE2XSxcblxuICAgICAgLy8gMzhcbiAgICAgIFs0LCAxNTIsIDEyMiwgMTgsIDE1MywgMTIzXSxcbiAgICAgIFsxMywgNzQsIDQ2LCAzMiwgNzUsIDQ3XSxcbiAgICAgIFs0OCwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgIFs0MiwgNDUsIDE1LCAzMiwgNDYsIDE2XSxcblxuICAgICAgLy8gMzlcbiAgICAgIFsyMCwgMTQ3LCAxMTcsIDQsIDE0OCwgMTE4XSxcbiAgICAgIFs0MCwgNzUsIDQ3LCA3LCA3NiwgNDhdLFxuICAgICAgWzQzLCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgWzEwLCA0NSwgMTUsIDY3LCA0NiwgMTZdLFxuXG4gICAgICAvLyA0MFxuICAgICAgWzE5LCAxNDgsIDExOCwgNiwgMTQ5LCAxMTldLFxuICAgICAgWzE4LCA3NSwgNDcsIDMxLCA3NiwgNDhdLFxuICAgICAgWzM0LCA1NCwgMjQsIDM0LCA1NSwgMjVdLFxuICAgICAgWzIwLCA0NSwgMTUsIDYxLCA0NiwgMTZdXG4gICAgXTtcblxuICAgIHZhciBxclJTQmxvY2sgPSBmdW5jdGlvbih0b3RhbENvdW50LCBkYXRhQ291bnQpIHtcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgX3RoaXMudG90YWxDb3VudCA9IHRvdGFsQ291bnQ7XG4gICAgICBfdGhpcy5kYXRhQ291bnQgPSBkYXRhQ291bnQ7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgdmFyIGdldFJzQmxvY2tUYWJsZSA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG5cbiAgICAgIHN3aXRjaChlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLkwgOlxuICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAwXTtcbiAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5NIDpcbiAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMV07XG4gICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUSA6XG4gICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDJdO1xuICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLkggOlxuICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAzXTtcbiAgICAgIGRlZmF1bHQgOlxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRSU0Jsb2NrcyA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG5cbiAgICAgIHZhciByc0Jsb2NrID0gZ2V0UnNCbG9ja1RhYmxlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcblxuICAgICAgaWYgKHR5cGVvZiByc0Jsb2NrID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93ICdiYWQgcnMgYmxvY2sgQCB0eXBlTnVtYmVyOicgKyB0eXBlTnVtYmVyICtcbiAgICAgICAgICAgICcvZXJyb3JDb3JyZWN0aW9uTGV2ZWw6JyArIGVycm9yQ29ycmVjdGlvbkxldmVsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuZ3RoID0gcnNCbG9jay5sZW5ndGggLyAzO1xuXG4gICAgICB2YXIgbGlzdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gcnNCbG9ja1tpICogMyArIDBdO1xuICAgICAgICB2YXIgdG90YWxDb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGRhdGFDb3VudCA9IHJzQmxvY2tbaSAqIDMgKyAyXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNvdW50OyBqICs9IDEpIHtcbiAgICAgICAgICBsaXN0LnB1c2gocXJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9KCk7XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJCaXRCdWZmZXJcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgcXJCaXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcblxuICAgIHZhciBfYnVmZmVyID0gW107XG4gICAgdmFyIF9sZW5ndGggPSAwO1xuXG4gICAgdmFyIF90aGlzID0ge307XG5cbiAgICBfdGhpcy5nZXRCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfYnVmZmVyO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRBdCA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKGluZGV4IC8gOCk7XG4gICAgICByZXR1cm4gKCAoX2J1ZmZlcltidWZJbmRleF0gPj4+ICg3IC0gaW5kZXggJSA4KSApICYgMSkgPT0gMTtcbiAgICB9O1xuXG4gICAgX3RoaXMucHV0ID0gZnVuY3Rpb24obnVtLCBsZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgX3RoaXMucHV0Qml0KCAoIChudW0gPj4+IChsZW5ndGggLSBpIC0gMSkgKSAmIDEpID09IDEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGhJbkJpdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy5wdXRCaXQgPSBmdW5jdGlvbihiaXQpIHtcblxuICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihfbGVuZ3RoIC8gOCk7XG4gICAgICBpZiAoX2J1ZmZlci5sZW5ndGggPD0gYnVmSW5kZXgpIHtcbiAgICAgICAgX2J1ZmZlci5wdXNoKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYml0KSB7XG4gICAgICAgIF9idWZmZXJbYnVmSW5kZXhdIHw9ICgweDgwID4+PiAoX2xlbmd0aCAlIDgpICk7XG4gICAgICB9XG5cbiAgICAgIF9sZW5ndGggKz0gMTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyTnVtYmVyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyTnVtYmVyID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfTlVNQkVSO1xuICAgIHZhciBfZGF0YSA9IGRhdGE7XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfbW9kZTtcbiAgICB9O1xuXG4gICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICByZXR1cm4gX2RhdGEubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuXG4gICAgICB2YXIgZGF0YSA9IF9kYXRhO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpICsgMiA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YS5zdWJzdHJpbmcoaSwgaSArIDMpICksIDEwKTtcbiAgICAgICAgaSArPSAzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAtIGkgPT0gMSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YS5zdWJzdHJpbmcoaSwgaSArIDEpICksIDQpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoIC0gaSA9PSAyKSB7XG4gICAgICAgICAgYnVmZmVyLnB1dChzdHJUb051bShkYXRhLnN1YnN0cmluZyhpLCBpICsgMikgKSwgNyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHN0clRvTnVtID0gZnVuY3Rpb24ocykge1xuICAgICAgdmFyIG51bSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgbnVtID0gbnVtICogMTAgKyBjaGF0VG9OdW0ocy5jaGFyQXQoaSkgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudW07XG4gICAgfTtcblxuICAgIHZhciBjaGF0VG9OdW0gPSBmdW5jdGlvbihjKSB7XG4gICAgICBpZiAoJzAnIDw9IGMgJiYgYyA8PSAnOScpIHtcbiAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtICcwJy5jaGFyQ29kZUF0KDApO1xuICAgICAgfVxuICAgICAgdGhyb3cgJ2lsbGVnYWwgY2hhciA6JyArIGM7XG4gICAgfTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfTtcblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBxckFscGhhTnVtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIHFyQWxwaGFOdW0gPSBmdW5jdGlvbihkYXRhKSB7XG5cbiAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV9BTFBIQV9OVU07XG4gICAgdmFyIF9kYXRhID0gZGF0YTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2RlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBfZGF0YS5sZW5ndGg7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG5cbiAgICAgIHZhciBzID0gX2RhdGE7XG5cbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgKyAxIDwgcy5sZW5ndGgpIHtcbiAgICAgICAgYnVmZmVyLnB1dChcbiAgICAgICAgICBnZXRDb2RlKHMuY2hhckF0KGkpICkgKiA0NSArXG4gICAgICAgICAgZ2V0Q29kZShzLmNoYXJBdChpICsgMSkgKSwgMTEpO1xuICAgICAgICBpICs9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgICAgYnVmZmVyLnB1dChnZXRDb2RlKHMuY2hhckF0KGkpICksIDYpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgZ2V0Q29kZSA9IGZ1bmN0aW9uKGMpIHtcblxuICAgICAgaWYgKCcwJyA8PSBjICYmIGMgPD0gJzknKSB7XG4gICAgICAgIHJldHVybiBjLmNoYXJDb2RlQXQoMCkgLSAnMCcuY2hhckNvZGVBdCgwKTtcbiAgICAgIH0gZWxzZSBpZiAoJ0EnIDw9IGMgJiYgYyA8PSAnWicpIHtcbiAgICAgICAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKSAtICdBJy5jaGFyQ29kZUF0KDApICsgMTA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnICcgOiByZXR1cm4gMzY7XG4gICAgICAgIGNhc2UgJyQnIDogcmV0dXJuIDM3O1xuICAgICAgICBjYXNlICclJyA6IHJldHVybiAzODtcbiAgICAgICAgY2FzZSAnKicgOiByZXR1cm4gMzk7XG4gICAgICAgIGNhc2UgJysnIDogcmV0dXJuIDQwO1xuICAgICAgICBjYXNlICctJyA6IHJldHVybiA0MTtcbiAgICAgICAgY2FzZSAnLicgOiByZXR1cm4gNDI7XG4gICAgICAgIGNhc2UgJy8nIDogcmV0dXJuIDQzO1xuICAgICAgICBjYXNlICc6JyA6IHJldHVybiA0NDtcbiAgICAgICAgZGVmYXVsdCA6XG4gICAgICAgICAgdGhyb3cgJ2lsbGVnYWwgY2hhciA6JyArIGM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHFyOEJpdEJ5dGVcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgcXI4Qml0Qnl0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcblxuICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFXzhCSVRfQllURTtcbiAgICB2YXIgX2RhdGEgPSBkYXRhO1xuICAgIHZhciBfYnl0ZXMgPSBxcmNvZGUuc3RyaW5nVG9CeXRlcyhkYXRhKTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2RlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiBfYnl0ZXMubGVuZ3RoO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYnVmZmVyLnB1dChfYnl0ZXNbaV0sIDgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcXJLYW5qaVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIHZhciBxckthbmppID0gZnVuY3Rpb24oZGF0YSkge1xuXG4gICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfS0FOSkk7XG4gICAgdmFyIF9kYXRhID0gZGF0YTtcblxuICAgIHZhciBzdHJpbmdUb0J5dGVzID0gcXJjb2RlLnN0cmluZ1RvQnl0ZXNGdW5jc1snU0pJUyddO1xuICAgIGlmICghc3RyaW5nVG9CeXRlcykge1xuICAgICAgdGhyb3cgJ3NqaXMgbm90IHN1cHBvcnRlZC4nO1xuICAgIH1cbiAgICAhZnVuY3Rpb24oYywgY29kZSkge1xuICAgICAgLy8gc2VsZiB0ZXN0IGZvciBzamlzIHN1cHBvcnQuXG4gICAgICB2YXIgdGVzdCA9IHN0cmluZ1RvQnl0ZXMoYyk7XG4gICAgICBpZiAodGVzdC5sZW5ndGggIT0gMiB8fCAoICh0ZXN0WzBdIDw8IDgpIHwgdGVzdFsxXSkgIT0gY29kZSkge1xuICAgICAgICB0aHJvdyAnc2ppcyBub3Qgc3VwcG9ydGVkLic7XG4gICAgICB9XG4gICAgfSgnXFx1NTNjYicsIDB4OTc0Nik7XG5cbiAgICB2YXIgX2J5dGVzID0gc3RyaW5nVG9CeXRlcyhkYXRhKTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF9tb2RlO1xuICAgIH07XG5cbiAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgIHJldHVybiB+fihfYnl0ZXMubGVuZ3RoIC8gMik7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG5cbiAgICAgIHZhciBkYXRhID0gX2J5dGVzO1xuXG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpICsgMSA8IGRhdGEubGVuZ3RoKSB7XG5cbiAgICAgICAgdmFyIGMgPSAoICgweGZmICYgZGF0YVtpXSkgPDwgOCkgfCAoMHhmZiAmIGRhdGFbaSArIDFdKTtcblxuICAgICAgICBpZiAoMHg4MTQwIDw9IGMgJiYgYyA8PSAweDlGRkMpIHtcbiAgICAgICAgICBjIC09IDB4ODE0MDtcbiAgICAgICAgfSBlbHNlIGlmICgweEUwNDAgPD0gYyAmJiBjIDw9IDB4RUJCRikge1xuICAgICAgICAgIGMgLT0gMHhDMTQwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93ICdpbGxlZ2FsIGNoYXIgYXQgJyArIChpICsgMSkgKyAnLycgKyBjO1xuICAgICAgICB9XG5cbiAgICAgICAgYyA9ICggKGMgPj4+IDgpICYgMHhmZikgKiAweEMwICsgKGMgJiAweGZmKTtcblxuICAgICAgICBidWZmZXIucHV0KGMsIDEzKTtcblxuICAgICAgICBpICs9IDI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpIDwgZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgJ2lsbGVnYWwgY2hhciBhdCAnICsgKGkgKyAxKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEdJRiBTdXBwb3J0IGV0Yy5cbiAgLy9cblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyBieXRlQXJyYXlPdXRwdXRTdHJlYW1cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgYnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG5cbiAgICB2YXIgX2J5dGVzID0gW107XG5cbiAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIF9ieXRlcy5wdXNoKGIgJiAweGZmKTtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVTaG9ydCA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIF90aGlzLndyaXRlQnl0ZShpKTtcbiAgICAgIF90aGlzLndyaXRlQnl0ZShpID4+PiA4KTtcbiAgICB9O1xuXG4gICAgX3RoaXMud3JpdGVCeXRlcyA9IGZ1bmN0aW9uKGIsIG9mZiwgbGVuKSB7XG4gICAgICBvZmYgPSBvZmYgfHwgMDtcbiAgICAgIGxlbiA9IGxlbiB8fCBiLmxlbmd0aDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgX3RoaXMud3JpdGVCeXRlKGJbaSArIG9mZl0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZVN0cmluZyA9IGZ1bmN0aW9uKHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfdGhpcy53cml0ZUJ5dGUocy5jaGFyQ29kZUF0KGkpICk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2J5dGVzO1xuICAgIH07XG5cbiAgICBfdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHMgKz0gJ1snO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgcyArPSAnLCc7XG4gICAgICAgIH1cbiAgICAgICAgcyArPSBfYnl0ZXNbaV07XG4gICAgICB9XG4gICAgICBzICs9ICddJztcbiAgICAgIHJldHVybiBzO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGJhc2U2NEVuY29kZU91dHB1dFN0cmVhbSA9IGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIF9idWZmZXIgPSAwO1xuICAgIHZhciBfYnVmbGVuID0gMDtcbiAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgdmFyIF9iYXNlNjQgPSAnJztcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgdmFyIHdyaXRlRW5jb2RlZCA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgIF9iYXNlNjQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlbmNvZGUoYiAmIDB4M2YpICk7XG4gICAgfTtcblxuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbihuKSB7XG4gICAgICBpZiAobiA8IDApIHtcbiAgICAgICAgLy8gZXJyb3IuXG4gICAgICB9IGVsc2UgaWYgKG4gPCAyNikge1xuICAgICAgICByZXR1cm4gMHg0MSArIG47XG4gICAgICB9IGVsc2UgaWYgKG4gPCA1Mikge1xuICAgICAgICByZXR1cm4gMHg2MSArIChuIC0gMjYpO1xuICAgICAgfSBlbHNlIGlmIChuIDwgNjIpIHtcbiAgICAgICAgcmV0dXJuIDB4MzAgKyAobiAtIDUyKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PSA2Mikge1xuICAgICAgICByZXR1cm4gMHgyYjtcbiAgICAgIH0gZWxzZSBpZiAobiA9PSA2Mykge1xuICAgICAgICByZXR1cm4gMHgyZjtcbiAgICAgIH1cbiAgICAgIHRocm93ICduOicgKyBuO1xuICAgIH07XG5cbiAgICBfdGhpcy53cml0ZUJ5dGUgPSBmdW5jdGlvbihuKSB7XG5cbiAgICAgIF9idWZmZXIgPSAoX2J1ZmZlciA8PCA4KSB8IChuICYgMHhmZik7XG4gICAgICBfYnVmbGVuICs9IDg7XG4gICAgICBfbGVuZ3RoICs9IDE7XG5cbiAgICAgIHdoaWxlIChfYnVmbGVuID49IDYpIHtcbiAgICAgICAgd3JpdGVFbmNvZGVkKF9idWZmZXIgPj4+IChfYnVmbGVuIC0gNikgKTtcbiAgICAgICAgX2J1ZmxlbiAtPSA2O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICBpZiAoX2J1ZmxlbiA+IDApIHtcbiAgICAgICAgd3JpdGVFbmNvZGVkKF9idWZmZXIgPDwgKDYgLSBfYnVmbGVuKSApO1xuICAgICAgICBfYnVmZmVyID0gMDtcbiAgICAgICAgX2J1ZmxlbiA9IDA7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbGVuZ3RoICUgMyAhPSAwKSB7XG4gICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgdmFyIHBhZGxlbiA9IDMgLSBfbGVuZ3RoICUgMztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYWRsZW47IGkgKz0gMSkge1xuICAgICAgICAgIF9iYXNlNjQgKz0gJz0nO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gX2Jhc2U2NDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9O1xuXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIGJhc2U2NERlY29kZUlucHV0U3RyZWFtXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgdmFyIGJhc2U2NERlY29kZUlucHV0U3RyZWFtID0gZnVuY3Rpb24oc3RyKSB7XG5cbiAgICB2YXIgX3N0ciA9IHN0cjtcbiAgICB2YXIgX3BvcyA9IDA7XG4gICAgdmFyIF9idWZmZXIgPSAwO1xuICAgIHZhciBfYnVmbGVuID0gMDtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMucmVhZCA9IGZ1bmN0aW9uKCkge1xuXG4gICAgICB3aGlsZSAoX2J1ZmxlbiA8IDgpIHtcblxuICAgICAgICBpZiAoX3BvcyA+PSBfc3RyLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChfYnVmbGVuID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUuLycgKyBfYnVmbGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGMgPSBfc3RyLmNoYXJBdChfcG9zKTtcbiAgICAgICAgX3BvcyArPSAxO1xuXG4gICAgICAgIGlmIChjID09ICc9Jykge1xuICAgICAgICAgIF9idWZsZW4gPSAwO1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSBlbHNlIGlmIChjLm1hdGNoKC9eXFxzJC8pICkge1xuICAgICAgICAgIC8vIGlnbm9yZSBpZiB3aGl0ZXNwYWNlLlxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgX2J1ZmZlciA9IChfYnVmZmVyIDw8IDYpIHwgZGVjb2RlKGMuY2hhckNvZGVBdCgwKSApO1xuICAgICAgICBfYnVmbGVuICs9IDY7XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gKF9idWZmZXIgPj4+IChfYnVmbGVuIC0gOCkgKSAmIDB4ZmY7XG4gICAgICBfYnVmbGVuIC09IDg7XG4gICAgICByZXR1cm4gbjtcbiAgICB9O1xuXG4gICAgdmFyIGRlY29kZSA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIGlmICgweDQxIDw9IGMgJiYgYyA8PSAweDVhKSB7XG4gICAgICAgIHJldHVybiBjIC0gMHg0MTtcbiAgICAgIH0gZWxzZSBpZiAoMHg2MSA8PSBjICYmIGMgPD0gMHg3YSkge1xuICAgICAgICByZXR1cm4gYyAtIDB4NjEgKyAyNjtcbiAgICAgIH0gZWxzZSBpZiAoMHgzMCA8PSBjICYmIGMgPD0gMHgzOSkge1xuICAgICAgICByZXR1cm4gYyAtIDB4MzAgKyA1MjtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PSAweDJiKSB7XG4gICAgICAgIHJldHVybiA2MjtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PSAweDJmKSB7XG4gICAgICAgIHJldHVybiA2MztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93ICdjOicgKyBjO1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gZ2lmSW1hZ2UgKEIvVylcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICB2YXIgZ2lmSW1hZ2UgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICB2YXIgX3dpZHRoID0gd2lkdGg7XG4gICAgdmFyIF9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdmFyIF9kYXRhID0gbmV3IEFycmF5KHdpZHRoICogaGVpZ2h0KTtcblxuICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgX3RoaXMuc2V0UGl4ZWwgPSBmdW5jdGlvbih4LCB5LCBwaXhlbCkge1xuICAgICAgX2RhdGFbeSAqIF93aWR0aCArIHhdID0gcGl4ZWw7XG4gICAgfTtcblxuICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24ob3V0KSB7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBHSUYgU2lnbmF0dXJlXG5cbiAgICAgIG91dC53cml0ZVN0cmluZygnR0lGODdhJyk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBTY3JlZW4gRGVzY3JpcHRvclxuXG4gICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG5cbiAgICAgIG91dC53cml0ZUJ5dGUoMHg4MCk7IC8vIDJiaXRcbiAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDApO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gR2xvYmFsIENvbG9yIE1hcFxuXG4gICAgICAvLyBibGFja1xuICAgICAgb3V0LndyaXRlQnl0ZSgweDAwKTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4MDApO1xuXG4gICAgICAvLyB3aGl0ZVxuICAgICAgb3V0LndyaXRlQnl0ZSgweGZmKTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHhmZik7XG4gICAgICBvdXQud3JpdGVCeXRlKDB4ZmYpO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gSW1hZ2UgRGVzY3JpcHRvclxuXG4gICAgICBvdXQud3JpdGVTdHJpbmcoJywnKTtcbiAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgb3V0LndyaXRlU2hvcnQoMCk7XG4gICAgICBvdXQud3JpdGVTaG9ydChfd2lkdGgpO1xuICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG4gICAgICBvdXQud3JpdGVCeXRlKDApO1xuXG4gICAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gTG9jYWwgQ29sb3IgTWFwXG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBSYXN0ZXIgRGF0YVxuXG4gICAgICB2YXIgbHp3TWluQ29kZVNpemUgPSAyO1xuICAgICAgdmFyIHJhc3RlciA9IGdldExaV1Jhc3RlcihsendNaW5Db2RlU2l6ZSk7XG5cbiAgICAgIG91dC53cml0ZUJ5dGUobHp3TWluQ29kZVNpemUpO1xuXG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgICAgd2hpbGUgKHJhc3Rlci5sZW5ndGggLSBvZmZzZXQgPiAyNTUpIHtcbiAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICBvdXQud3JpdGVCeXRlcyhyYXN0ZXIsIG9mZnNldCwgMjU1KTtcbiAgICAgICAgb2Zmc2V0ICs9IDI1NTtcbiAgICAgIH1cblxuICAgICAgb3V0LndyaXRlQnl0ZShyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgIG91dC53cml0ZUJ5dGVzKHJhc3Rlciwgb2Zmc2V0LCByYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgIG91dC53cml0ZUJ5dGUoMHgwMCk7XG5cbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyBHSUYgVGVybWluYXRvclxuICAgICAgb3V0LndyaXRlU3RyaW5nKCc7Jyk7XG4gICAgfTtcblxuICAgIHZhciBiaXRPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbihvdXQpIHtcblxuICAgICAgdmFyIF9vdXQgPSBvdXQ7XG4gICAgICB2YXIgX2JpdExlbmd0aCA9IDA7XG4gICAgICB2YXIgX2JpdEJ1ZmZlciA9IDA7XG5cbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuXG4gICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGxlbmd0aCkge1xuXG4gICAgICAgIGlmICggKGRhdGEgPj4+IGxlbmd0aCkgIT0gMCkge1xuICAgICAgICAgIHRocm93ICdsZW5ndGggb3Zlcic7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoX2JpdExlbmd0aCArIGxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgX291dC53cml0ZUJ5dGUoMHhmZiAmICggKGRhdGEgPDwgX2JpdExlbmd0aCkgfCBfYml0QnVmZmVyKSApO1xuICAgICAgICAgIGxlbmd0aCAtPSAoOCAtIF9iaXRMZW5ndGgpO1xuICAgICAgICAgIGRhdGEgPj4+PSAoOCAtIF9iaXRMZW5ndGgpO1xuICAgICAgICAgIF9iaXRCdWZmZXIgPSAwO1xuICAgICAgICAgIF9iaXRMZW5ndGggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgX2JpdEJ1ZmZlciA9IChkYXRhIDw8IF9iaXRMZW5ndGgpIHwgX2JpdEJ1ZmZlcjtcbiAgICAgICAgX2JpdExlbmd0aCA9IF9iaXRMZW5ndGggKyBsZW5ndGg7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX2JpdExlbmd0aCA+IDApIHtcbiAgICAgICAgICBfb3V0LndyaXRlQnl0ZShfYml0QnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0TFpXUmFzdGVyID0gZnVuY3Rpb24obHp3TWluQ29kZVNpemUpIHtcblxuICAgICAgdmFyIGNsZWFyQ29kZSA9IDEgPDwgbHp3TWluQ29kZVNpemU7XG4gICAgICB2YXIgZW5kQ29kZSA9ICgxIDw8IGx6d01pbkNvZGVTaXplKSArIDE7XG4gICAgICB2YXIgYml0TGVuZ3RoID0gbHp3TWluQ29kZVNpemUgKyAxO1xuXG4gICAgICAvLyBTZXR1cCBMWldUYWJsZVxuICAgICAgdmFyIHRhYmxlID0gbHp3VGFibGUoKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGVhckNvZGU7IGkgKz0gMSkge1xuICAgICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICAgICAgfVxuICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoY2xlYXJDb2RlKSApO1xuICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kQ29kZSkgKTtcblxuICAgICAgdmFyIGJ5dGVPdXQgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICAgIHZhciBiaXRPdXQgPSBiaXRPdXRwdXRTdHJlYW0oYnl0ZU91dCk7XG5cbiAgICAgIC8vIGNsZWFyIGNvZGVcbiAgICAgIGJpdE91dC53cml0ZShjbGVhckNvZGUsIGJpdExlbmd0aCk7XG5cbiAgICAgIHZhciBkYXRhSW5kZXggPSAwO1xuXG4gICAgICB2YXIgcyA9IFN0cmluZy5mcm9tQ2hhckNvZGUoX2RhdGFbZGF0YUluZGV4XSk7XG4gICAgICBkYXRhSW5kZXggKz0gMTtcblxuICAgICAgd2hpbGUgKGRhdGFJbmRleCA8IF9kYXRhLmxlbmd0aCkge1xuXG4gICAgICAgIHZhciBjID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcbiAgICAgICAgZGF0YUluZGV4ICs9IDE7XG5cbiAgICAgICAgaWYgKHRhYmxlLmNvbnRhaW5zKHMgKyBjKSApIHtcblxuICAgICAgICAgIHMgPSBzICsgYztcblxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgYml0T3V0LndyaXRlKHRhYmxlLmluZGV4T2YocyksIGJpdExlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodGFibGUuc2l6ZSgpIDwgMHhmZmYpIHtcblxuICAgICAgICAgICAgaWYgKHRhYmxlLnNpemUoKSA9PSAoMSA8PCBiaXRMZW5ndGgpICkge1xuICAgICAgICAgICAgICBiaXRMZW5ndGggKz0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGFibGUuYWRkKHMgKyBjKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzID0gYztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzKSwgYml0TGVuZ3RoKTtcblxuICAgICAgLy8gZW5kIGNvZGVcbiAgICAgIGJpdE91dC53cml0ZShlbmRDb2RlLCBiaXRMZW5ndGgpO1xuXG4gICAgICBiaXRPdXQuZmx1c2goKTtcblxuICAgICAgcmV0dXJuIGJ5dGVPdXQudG9CeXRlQXJyYXkoKTtcbiAgICB9O1xuXG4gICAgdmFyIGx6d1RhYmxlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgIHZhciBfbWFwID0ge307XG4gICAgICB2YXIgX3NpemUgPSAwO1xuXG4gICAgICB2YXIgX3RoaXMgPSB7fTtcblxuICAgICAgX3RoaXMuYWRkID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChfdGhpcy5jb250YWlucyhrZXkpICkge1xuICAgICAgICAgIHRocm93ICdkdXAga2V5OicgKyBrZXk7XG4gICAgICAgIH1cbiAgICAgICAgX21hcFtrZXldID0gX3NpemU7XG4gICAgICAgIF9zaXplICs9IDE7XG4gICAgICB9O1xuXG4gICAgICBfdGhpcy5zaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmluZGV4T2YgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9tYXBba2V5XTtcbiAgICAgIH07XG5cbiAgICAgIF90aGlzLmNvbnRhaW5zID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgX21hcFtrZXldICE9ICd1bmRlZmluZWQnO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZURhdGFVUkwgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBnZXRQaXhlbCkge1xuICAgIHZhciBnaWYgPSBnaWZJbWFnZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSAxKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4ICs9IDEpIHtcbiAgICAgICAgZ2lmLnNldFBpeGVsKHgsIHksIGdldFBpeGVsKHgsIHkpICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGIgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICBnaWYud3JpdGUoYik7XG5cbiAgICB2YXIgYmFzZTY0ID0gYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtKCk7XG4gICAgdmFyIGJ5dGVzID0gYi50b0J5dGVBcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGJhc2U2NC53cml0ZUJ5dGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICBiYXNlNjQuZmx1c2goKTtcblxuICAgIHJldHVybiAnZGF0YTppbWFnZS9naWY7YmFzZTY0LCcgKyBiYXNlNjQ7XG4gIH07XG5cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gcmV0dXJucyBxcmNvZGUgZnVuY3Rpb24uXG5cbiAgcmV0dXJuIHFyY29kZTtcbn0oKTtcblxuLy8gbXVsdGlieXRlIHN1cHBvcnRcbiFmdW5jdGlvbigpIHtcblxuICBxcmNvZGUuc3RyaW5nVG9CeXRlc0Z1bmNzWydVVEYtOCddID0gZnVuY3Rpb24ocykge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTg3Mjk0MDUvaG93LXRvLWNvbnZlcnQtdXRmOC1zdHJpbmctdG8tYnl0ZS1hcnJheVxuICAgIGZ1bmN0aW9uIHRvVVRGOEFycmF5KHN0cikge1xuICAgICAgdmFyIHV0ZjggPSBbXTtcbiAgICAgIGZvciAodmFyIGk9MDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNoYXJjb2RlIDwgMHg4MCkgdXRmOC5wdXNoKGNoYXJjb2RlKTtcbiAgICAgICAgZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuICAgICAgICAgIHV0ZjgucHVzaCgweGMwIHwgKGNoYXJjb2RlID4+IDYpLFxuICAgICAgICAgICAgICAweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuICAgICAgICAgIHV0ZjgucHVzaCgweGUwIHwgKGNoYXJjb2RlID4+IDEyKSxcbiAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG4gICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcbiAgICAgICAgICAvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG4gICAgICAgICAgLy8gMjAgYml0cyBvZiAweDAtMHhGRkZGRiBpbnRvIHR3byBoYWx2ZXNcbiAgICAgICAgICBjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG4gICAgICAgICAgICB8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSk7XG4gICAgICAgICAgdXRmOC5wdXNoKDB4ZjAgfCAoY2hhcmNvZGUgPj4xOCksXG4gICAgICAgICAgICAgIDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcbiAgICAgICAgICAgICAgMHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG4gICAgICAgICAgICAgIDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB1dGY4O1xuICAgIH1cbiAgICByZXR1cm4gdG9VVEY4QXJyYXkocyk7XG4gIH07XG5cbn0oKTtcblxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgfVxufShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHFyY29kZTtcbn0pKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7IF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTsgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzJyk7IC8vIHFyLmpzIGRvZXNuJ3QgaGFuZGxlIGVycm9yIGxldmVsIG9mIHplcm8gKE0pIHNvIHdlIG5lZWQgdG8gZG8gaXQgcmlnaHQsXG4vLyB0aHVzIHRoZSBkZWVwIHJlcXVpcmUuXG5cblxudmFyIFFSQ29kZUltcGwgPSByZXF1aXJlKCdxci5qcy9saWIvUVJDb2RlJyk7XG5cbnZhciBFcnJvckNvcnJlY3RMZXZlbCA9IHJlcXVpcmUoJ3FyLmpzL2xpYi9FcnJvckNvcnJlY3RMZXZlbCcpOyAvLyBUT0RPOiBwdWxsIHRoaXMgb2ZmIG9mIHRoZSBRUkNvZGUgY2xhc3MgdHlwZSBzbyBpdCBtYXRjaGVzLlxuXG5cbi8vIENvbnZlcnQgZnJvbSBVVEYtMTYsIGZvcmNpbmcgdGhlIHVzZSBvZiBieXRlLW1vZGUgZW5jb2RpbmcgaW4gb3VyIFFSIENvZGUuXG4vLyBUaGlzIGFsbG93cyB1cyB0byBlbmNvZGUgSGFuamksIEthbmppLCBlbW9qaSwgZXRjLiBJZGVhbGx5IHdlJ2QgZG8gbW9yZVxuLy8gZGV0ZWN0aW9uIGFuZCBub3QgcmVzb3J0IHRvIGJ5dGUtbW9kZSBpZiBwb3NzaWJsZSwgYnV0IHdlJ3JlIHRyYWRpbmcgb2ZmXG4vLyBhIHNtYWxsZXIgbGlicmFyeSBmb3IgYSBzbWFsbGVyIGFtb3VudCBvZiBkYXRhIHdlIGNhbiBwb3RlbnRpYWxseSBlbmNvZGUuXG4vLyBCYXNlZCBvbiBodHRwOi8vam9uaXNhbG9uZW4uY29tLzIwMTIvZnJvbS11dGYtMTYtdG8tdXRmLTgtaW4tamF2YXNjcmlwdC9cbmZ1bmN0aW9uIGNvbnZlcnRTdHIoc3RyKSB7XG4gIHZhciBvdXQgPSAnJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBjaGFyY29kZSA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGNoYXJjb2RlIDwgMHgwMDgwKSB7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyY29kZSk7XG4gICAgfSBlbHNlIGlmIChjaGFyY29kZSA8IDB4MDgwMCkge1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHhjMCB8IGNoYXJjb2RlID4+IDYpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlICYgMHgzZik7XG4gICAgfSBlbHNlIGlmIChjaGFyY29kZSA8IDB4ZDgwMCB8fCBjaGFyY29kZSA+PSAweGUwMDApIHtcbiAgICAgIG91dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZTAgfCBjaGFyY29kZSA+PiAxMik7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgY2hhcmNvZGUgPj4gNiAmIDB4M2YpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlICYgMHgzZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSBzdXJyb2dhdGUgcGFpciwgc28gd2UnbGwgcmVjb25zaXR1dGUgdGhlIHBpZWNlcyBhbmQgd29ya1xuICAgICAgLy8gZnJvbSB0aGF0XG4gICAgICBpKys7XG4gICAgICBjaGFyY29kZSA9IDB4MTAwMDAgKyAoKGNoYXJjb2RlICYgMHgzZmYpIDw8IDEwIHwgc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZik7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweGYwIHwgY2hhcmNvZGUgPj4gMTgpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlID4+IDEyICYgMHgzZik7XG4gICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgweDgwIHwgY2hhcmNvZGUgPj4gNiAmIDB4M2YpO1xuICAgICAgb3V0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg4MCB8IGNoYXJjb2RlICYgMHgzZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cblxudmFyIERFRkFVTFRfUFJPUFMgPSB7XG4gIHNpemU6IDEyOCxcbiAgbGV2ZWw6ICdMJyxcbiAgYmdDb2xvcjogJyNGRkZGRkYnLFxuICBmZ0NvbG9yOiAnIzAwMDAwMCcsXG4gIGluY2x1ZGVNYXJnaW46IGZhbHNlXG59O1xudmFyIFBST1BfVFlQRVMgPSBcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJyA/IHtcbiAgdmFsdWU6IFByb3BUeXBlcy5zdHJpbmcuaXNSZXF1aXJlZCxcbiAgc2l6ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgbGV2ZWw6IFByb3BUeXBlcy5vbmVPZihbJ0wnLCAnTScsICdRJywgJ0gnXSksXG4gIGJnQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGZnQ29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGluY2x1ZGVNYXJnaW46IFByb3BUeXBlcy5ib29sLFxuICBpbWFnZVNldHRpbmdzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIHNyYzogUHJvcFR5cGVzLnN0cmluZy5pc1JlcXVpcmVkLFxuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuICAgIHdpZHRoOiBQcm9wVHlwZXMubnVtYmVyLmlzUmVxdWlyZWQsXG4gICAgZXhjYXZhdGU6IFByb3BUeXBlcy5ib29sLFxuICAgIHg6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgeTogUHJvcFR5cGVzLm51bWJlclxuICB9KVxufSA6IHt9O1xudmFyIE1BUkdJTl9TSVpFID0gNDsgLy8gVGhpcyBpcyAqdmVyeSogcm91Z2ggZXN0aW1hdGUgb2YgbWF4IGFtb3VudCBvZiBRUkNvZGUgYWxsb3dlZCB0byBiZSBjb3ZlcmVkLlxuLy8gSXQgaXMgXCJ3cm9uZ1wiIGluIGEgbG90IG9mIHdheXMgKGFyZWEgaXMgYSB0ZXJyaWJsZSB3YXkgdG8gZXN0aW1hdGUsIGl0XG4vLyByZWFsbHkgc2hvdWxkIGJlIG51bWJlciBvZiBtb2R1bGVzIGNvdmVyZWQpLCBidXQgaWYgZm9yIHNvbWUgcmVhc29uIHdlIGRvbid0XG4vLyBnZXQgYW4gZXhwbGljaXQgaGVpZ2h0IG9yIHdpZHRoLCBJJ2QgcmF0aGVyIGRlZmF1bHQgdG8gc29tZXRoaW5nIHRoYW4gdGhyb3cuXG5cbnZhciBERUZBVUxUX0lNR19TQ0FMRSA9IDAuMTtcblxuZnVuY3Rpb24gZ2VuZXJhdGVQYXRoKG1vZHVsZXMpIHtcbiAgdmFyIG1hcmdpbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgdmFyIG9wcyA9IFtdO1xuICBtb2R1bGVzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgeSkge1xuICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgcm93LmZvckVhY2goZnVuY3Rpb24gKGNlbGwsIHgpIHtcbiAgICAgIGlmICghY2VsbCAmJiBzdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBNMCAwaDd2MUgweiBpbmplY3RzIHRoZSBzcGFjZSB3aXRoIHRoZSBtb3ZlIGFuZCBkcm9wcyB0aGUgY29tbWEsXG4gICAgICAgIC8vIHNhdmluZyBhIGNoYXIgcGVyIG9wZXJhdGlvblxuICAgICAgICBvcHMucHVzaChcIk1cIi5jb25jYXQoc3RhcnQgKyBtYXJnaW4sIFwiIFwiKS5jb25jYXQoeSArIG1hcmdpbiwgXCJoXCIpLmNvbmNhdCh4IC0gc3RhcnQsIFwidjFIXCIpLmNvbmNhdChzdGFydCArIG1hcmdpbiwgXCJ6XCIpKTtcbiAgICAgICAgc3RhcnQgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIGVuZCBvZiByb3csIGNsZWFuIHVwIG9yIHNraXBcblxuXG4gICAgICBpZiAoeCA9PT0gcm93Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgaWYgKCFjZWxsKSB7XG4gICAgICAgICAgLy8gV2Ugd291bGQgaGF2ZSBjbG9zZWQgdGhlIG9wIGFib3ZlIGFscmVhZHkgc28gdGhpcyBjYW4gb25seSBtZWFuXG4gICAgICAgICAgLy8gMisgbGlnaHQgbW9kdWxlcyBpbiBhIHJvdy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBKdXN0IGEgc2luZ2xlIGRhcmsgbW9kdWxlLlxuICAgICAgICAgIG9wcy5wdXNoKFwiTVwiLmNvbmNhdCh4ICsgbWFyZ2luLCBcIixcIikuY29uY2F0KHkgKyBtYXJnaW4sIFwiIGgxdjFIXCIpLmNvbmNhdCh4ICsgbWFyZ2luLCBcInpcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBmaW5pc2ggdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICBvcHMucHVzaChcIk1cIi5jb25jYXQoc3RhcnQgKyBtYXJnaW4sIFwiLFwiKS5jb25jYXQoeSArIG1hcmdpbiwgXCIgaFwiKS5jb25jYXQoeCArIDEgLSBzdGFydCwgXCJ2MUhcIikuY29uY2F0KHN0YXJ0ICsgbWFyZ2luLCBcInpcIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2VsbCAmJiBzdGFydCA9PT0gbnVsbCkge1xuICAgICAgICBzdGFydCA9IHg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb3BzLmpvaW4oJycpO1xufSAvLyBXZSBjb3VsZCBqdXN0IGRvIHRoaXMgaW4gZ2VuZXJhdGVQYXRoLCBleGNlcHQgdGhhdCB3ZSB3YW50IHRvIHN1cHBvcnRcbi8vIG5vbi1QYXRoMkQgY2FudmFzLCBzbyB3ZSBuZWVkIHRvIGtlZXAgaXQgYW4gZXhwbGljaXQgc3RlcC5cblxuXG5mdW5jdGlvbiBleGNhdmF0ZU1vZHVsZXMobW9kdWxlcywgZXhjYXZhdGlvbikge1xuICByZXR1cm4gbW9kdWxlcy5zbGljZSgpLm1hcChmdW5jdGlvbiAocm93LCB5KSB7XG4gICAgaWYgKHkgPCBleGNhdmF0aW9uLnkgfHwgeSA+PSBleGNhdmF0aW9uLnkgKyBleGNhdmF0aW9uLmgpIHtcbiAgICAgIHJldHVybiByb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvdy5tYXAoZnVuY3Rpb24gKGNlbGwsIHgpIHtcbiAgICAgIGlmICh4IDwgZXhjYXZhdGlvbi54IHx8IHggPj0gZXhjYXZhdGlvbi54ICsgZXhjYXZhdGlvbi53KSB7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRJbWFnZVNldHRpbmdzKHByb3BzLCBjZWxscykge1xuICB2YXIgaW1hZ2VTZXR0aW5ncyA9IHByb3BzLmltYWdlU2V0dGluZ3MsXG4gICAgICBzaXplID0gcHJvcHMuc2l6ZSxcbiAgICAgIGluY2x1ZGVNYXJnaW4gPSBwcm9wcy5pbmNsdWRlTWFyZ2luO1xuXG4gIGlmIChpbWFnZVNldHRpbmdzID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICB2YXIgbnVtQ2VsbHMgPSBjZWxscy5sZW5ndGggKyBtYXJnaW4gKiAyO1xuICB2YXIgZGVmYXVsdFNpemUgPSBNYXRoLmZsb29yKHNpemUgKiBERUZBVUxUX0lNR19TQ0FMRSk7XG4gIHZhciBzY2FsZSA9IG51bUNlbGxzIC8gc2l6ZTtcbiAgdmFyIHcgPSAoaW1hZ2VTZXR0aW5ncy53aWR0aCB8fCBkZWZhdWx0U2l6ZSkgKiBzY2FsZTtcbiAgdmFyIGggPSAoaW1hZ2VTZXR0aW5ncy5oZWlnaHQgfHwgZGVmYXVsdFNpemUpICogc2NhbGU7XG4gIHZhciB4ID0gaW1hZ2VTZXR0aW5ncy54ID09IG51bGwgPyBjZWxscy5sZW5ndGggLyAyIC0gdyAvIDIgOiBpbWFnZVNldHRpbmdzLnggKiBzY2FsZTtcbiAgdmFyIHkgPSBpbWFnZVNldHRpbmdzLnkgPT0gbnVsbCA/IGNlbGxzLmxlbmd0aCAvIDIgLSBoIC8gMiA6IGltYWdlU2V0dGluZ3MueSAqIHNjYWxlO1xuICB2YXIgZXhjYXZhdGlvbiA9IG51bGw7XG5cbiAgaWYgKGltYWdlU2V0dGluZ3MuZXhjYXZhdGUpIHtcbiAgICB2YXIgZmxvb3JYID0gTWF0aC5mbG9vcih4KTtcbiAgICB2YXIgZmxvb3JZID0gTWF0aC5mbG9vcih5KTtcbiAgICB2YXIgY2VpbFcgPSBNYXRoLmNlaWwodyArIHggLSBmbG9vclgpO1xuICAgIHZhciBjZWlsSCA9IE1hdGguY2VpbChoICsgeSAtIGZsb29yWSk7XG4gICAgZXhjYXZhdGlvbiA9IHtcbiAgICAgIHg6IGZsb29yWCxcbiAgICAgIHk6IGZsb29yWSxcbiAgICAgIHc6IGNlaWxXLFxuICAgICAgaDogY2VpbEhcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiB4LFxuICAgIHk6IHksXG4gICAgaDogaCxcbiAgICB3OiB3LFxuICAgIGV4Y2F2YXRpb246IGV4Y2F2YXRpb25cbiAgfTtcbn0gLy8gRm9yIGNhbnZhcyB3ZSdyZSBnb2luZyB0byBzd2l0Y2ggb3VyIGRyYXdpbmcgbW9kZSBiYXNlZCBvbiB3aGV0aGVyIG9yIG5vdFxuLy8gdGhlIGVudmlyb25tZW50IHN1cHBvcnRzIFBhdGgyRC4gV2Ugb25seSBuZWVkIHRoZSBjb25zdHJ1Y3RvciB0byBiZVxuLy8gc3VwcG9ydGVkLCBidXQgRWRnZSBkb2Vzbid0IGFjdHVhbGx5IHN1cHBvcnQgdGhlIHBhdGggKHN0cmluZykgdHlwZVxuLy8gYXJndW1lbnQuIEx1Y2tpbHkgaXQgYWxzbyBkb2Vzbid0IHN1cHBvcnQgdGhlIGFkZFBhdGgoKSBtZXRob2QuIFdlIGNhblxuLy8gdHJlYXQgdGhhdCBhcyB0aGUgc2FtZSB0aGluZy5cblxuXG52YXIgU1VQUE9SVFNfUEFUSDJEID0gZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIG5ldyBQYXRoMkQoKS5hZGRQYXRoKG5ldyBQYXRoMkQoKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn0oKTtcblxudmFyIFFSQ29kZUNhbnZhcyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKFFSQ29kZUNhbnZhcywgX1JlYWN0JFB1cmVDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFFSQ29kZUNhbnZhcygpIHtcbiAgICB2YXIgX2dldFByb3RvdHlwZU9mMjtcblxuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRUkNvZGVDYW52YXMpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKF9nZXRQcm90b3R5cGVPZjIgPSBfZ2V0UHJvdG90eXBlT2YoUVJDb2RlQ2FudmFzKSkuY2FsbC5hcHBseShfZ2V0UHJvdG90eXBlT2YyLCBbdGhpc10uY29uY2F0KGFyZ3MpKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2NhbnZhc1wiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9pbWFnZVwiLCB2b2lkIDApO1xuXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0YXRlXCIsIHtcbiAgICAgIGltZ0xvYWRlZDogZmFsc2VcbiAgICB9KTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoYW5kbGVJbWFnZUxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBpbWdMb2FkZWQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFFSQ29kZUNhbnZhcywgW3tcbiAgICBrZXk6IFwiY29tcG9uZW50RGlkTW91bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICBpZiAodGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVJbWFnZUxvYWQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xuICAgICAgdmFyIF90aGlzJHByb3BzJGltYWdlU2V0dCwgX25leHRQcm9wcyRpbWFnZVNldHRpO1xuXG4gICAgICB2YXIgY3VycmVudFNyYyA9IChfdGhpcyRwcm9wcyRpbWFnZVNldHQgPSB0aGlzLnByb3BzLmltYWdlU2V0dGluZ3MpID09PSBudWxsIHx8IF90aGlzJHByb3BzJGltYWdlU2V0dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMkaW1hZ2VTZXR0LnNyYztcbiAgICAgIHZhciBuZXh0U3JjID0gKF9uZXh0UHJvcHMkaW1hZ2VTZXR0aSA9IG5leHRQcm9wcy5pbWFnZVNldHRpbmdzKSA9PT0gbnVsbCB8fCBfbmV4dFByb3BzJGltYWdlU2V0dGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9uZXh0UHJvcHMkaW1hZ2VTZXR0aS5zcmM7XG5cbiAgICAgIGlmIChjdXJyZW50U3JjICE9PSBuZXh0U3JjKSB7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIGltZ0xvYWRlZDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBvbmVudERpZFVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBfdGhpcyRwcm9wcy5zaXplLFxuICAgICAgICAgIGxldmVsID0gX3RoaXMkcHJvcHMubGV2ZWwsXG4gICAgICAgICAgYmdDb2xvciA9IF90aGlzJHByb3BzLmJnQ29sb3IsXG4gICAgICAgICAgZmdDb2xvciA9IF90aGlzJHByb3BzLmZnQ29sb3IsXG4gICAgICAgICAgaW5jbHVkZU1hcmdpbiA9IF90aGlzJHByb3BzLmluY2x1ZGVNYXJnaW4sXG4gICAgICAgICAgaW1hZ2VTZXR0aW5ncyA9IF90aGlzJHByb3BzLmltYWdlU2V0dGluZ3M7IC8vIFdlJ2xsIHVzZSB0eXBlPT09LTEgdG8gZm9yY2UgUVJDb2RlIHRvIGF1dG9tYXRpY2FsbHkgcGljayB0aGUgYmVzdCB0eXBlXG5cbiAgICAgIHZhciBxcmNvZGUgPSBuZXcgUVJDb2RlSW1wbCgtMSwgRXJyb3JDb3JyZWN0TGV2ZWxbbGV2ZWxdKTtcbiAgICAgIHFyY29kZS5hZGREYXRhKGNvbnZlcnRTdHIodmFsdWUpKTtcbiAgICAgIHFyY29kZS5tYWtlKCk7XG5cbiAgICAgIGlmICh0aGlzLl9jYW52YXMgIT0gbnVsbCkge1xuICAgICAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2VsbHMgPSBxcmNvZGUubW9kdWxlcztcblxuICAgICAgICBpZiAoY2VsbHMgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFyZ2luID0gaW5jbHVkZU1hcmdpbiA/IE1BUkdJTl9TSVpFIDogMDtcbiAgICAgICAgdmFyIG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzID0gZ2V0SW1hZ2VTZXR0aW5ncyh0aGlzLnByb3BzLCBjZWxscyk7XG5cbiAgICAgICAgaWYgKGltYWdlU2V0dGluZ3MgIT0gbnVsbCAmJiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgY2VsbHMgPSBleGNhdmF0ZU1vZHVsZXMoY2VsbHMsIGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmV4Y2F2YXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBXZSdyZSBnb2luZyB0byBzY2FsZSB0aGlzIHNvIHRoYXQgdGhlIG51bWJlciBvZiBkcmF3YWJsZSB1bml0c1xuICAgICAgICAvLyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgY2VsbHMuIFRoaXMgYXZvaWRzIHJvdW5kaW5nIGlzc3VlcywgYnV0IGRvZXNcbiAgICAgICAgLy8gcmVzdWx0IGluIHNvbWUgcG90ZW50aWFsbHkgdW53YW50ZWQgc2luZ2xlIHBpeGVsIGlzc3VlcyBiZXR3ZWVuXG4gICAgICAgIC8vIGJsb2Nrcywgb25seSBpbiBlbnZpcm9ubWVudHMgdGhhdCBkb24ndCBzdXBwb3J0IFBhdGgyRC5cblxuXG4gICAgICAgIHZhciBwaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy53aWR0aCA9IHNpemUgKiBwaXhlbFJhdGlvO1xuICAgICAgICB2YXIgc2NhbGUgPSBzaXplIC8gbnVtQ2VsbHMgKiBwaXhlbFJhdGlvO1xuICAgICAgICBjdHguc2NhbGUoc2NhbGUsIHNjYWxlKTsgLy8gRHJhdyBzb2xpZCBiYWNrZ3JvdW5kLCBvbmx5IHBhaW50IGRhcmsgbW9kdWxlcy5cblxuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIG51bUNlbGxzLCBudW1DZWxscyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmZ0NvbG9yO1xuXG4gICAgICAgIGlmIChTVVBQT1JUU19QQVRIMkQpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lOiBQYXRoMkQgYyd0b3IgZG9lc24ndCBzdXBwb3J0IGFyZ3MgeWV0LlxuICAgICAgICAgIGN0eC5maWxsKG5ldyBQYXRoMkQoZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2VsbHMuZm9yRWFjaChmdW5jdGlvbiAocm93LCByZHgpIHtcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKGZ1bmN0aW9uIChjZWxsLCBjZHgpIHtcbiAgICAgICAgICAgICAgaWYgKGNlbGwpIHtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoY2R4ICsgbWFyZ2luLCByZHggKyBtYXJnaW4sIDEsIDEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmltZ0xvYWRlZCAmJiB0aGlzLl9pbWFnZSAmJiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueCArIG1hcmdpbiwgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueSArIG1hcmdpbiwgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MudywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICB2YWx1ZSA9IF90aGlzJHByb3BzMi52YWx1ZSxcbiAgICAgICAgICBzaXplID0gX3RoaXMkcHJvcHMyLnNpemUsXG4gICAgICAgICAgbGV2ZWwgPSBfdGhpcyRwcm9wczIubGV2ZWwsXG4gICAgICAgICAgYmdDb2xvciA9IF90aGlzJHByb3BzMi5iZ0NvbG9yLFxuICAgICAgICAgIGZnQ29sb3IgPSBfdGhpcyRwcm9wczIuZmdDb2xvcixcbiAgICAgICAgICBzdHlsZSA9IF90aGlzJHByb3BzMi5zdHlsZSxcbiAgICAgICAgICBpbmNsdWRlTWFyZ2luID0gX3RoaXMkcHJvcHMyLmluY2x1ZGVNYXJnaW4sXG4gICAgICAgICAgaW1hZ2VTZXR0aW5ncyA9IF90aGlzJHByb3BzMi5pbWFnZVNldHRpbmdzLFxuICAgICAgICAgIG90aGVyUHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkcHJvcHMyLCBbXCJ2YWx1ZVwiLCBcInNpemVcIiwgXCJsZXZlbFwiLCBcImJnQ29sb3JcIiwgXCJmZ0NvbG9yXCIsIFwic3R5bGVcIiwgXCJpbmNsdWRlTWFyZ2luXCIsIFwiaW1hZ2VTZXR0aW5nc1wiXSk7XG5cbiAgICAgIHZhciBjYW52YXNTdHlsZSA9IF9vYmplY3RTcHJlYWQoe1xuICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgIHdpZHRoOiBzaXplXG4gICAgICB9LCBzdHlsZSk7XG5cbiAgICAgIHZhciBpbWcgPSBudWxsO1xuICAgICAgdmFyIGltZ1NyYyA9IGltYWdlU2V0dGluZ3MgJiYgaW1hZ2VTZXR0aW5ncy5zcmM7XG5cbiAgICAgIGlmIChpbWFnZVNldHRpbmdzICE9IG51bGwgJiYgaW1nU3JjICE9IG51bGwpIHtcbiAgICAgICAgaW1nID0gUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7XG4gICAgICAgICAgc3JjOiBpbWdTcmMsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6ICdub25lJ1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Mb2FkOiB0aGlzLmhhbmRsZUltYWdlTG9hZCxcbiAgICAgICAgICByZWY6IGZ1bmN0aW9uIHJlZihfcmVmKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9pbWFnZSA9IF9yZWY7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiwgX2V4dGVuZHMoe1xuICAgICAgICBzdHlsZTogY2FudmFzU3R5bGUsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIHJlZjogZnVuY3Rpb24gcmVmKF9yZWYyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fY2FudmFzID0gX3JlZjI7XG4gICAgICAgIH1cbiAgICAgIH0sIG90aGVyUHJvcHMpKSwgaW1nKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUVJDb2RlQ2FudmFzO1xufShSZWFjdC5QdXJlQ29tcG9uZW50KTtcblxuX2RlZmluZVByb3BlcnR5KFFSQ29kZUNhbnZhcywgXCJkZWZhdWx0UHJvcHNcIiwgREVGQVVMVF9QUk9QUyk7XG5cbmlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICBRUkNvZGVDYW52YXMucHJvcFR5cGVzID0gUFJPUF9UWVBFUztcbn1cblxudmFyIFFSQ29kZVNWRyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1JlYWN0JFB1cmVDb21wb25lbnQyKSB7XG4gIF9pbmhlcml0cyhRUkNvZGVTVkcsIF9SZWFjdCRQdXJlQ29tcG9uZW50Mik7XG5cbiAgZnVuY3Rpb24gUVJDb2RlU1ZHKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRUkNvZGVTVkcpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihRUkNvZGVTVkcpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFFSQ29kZVNWRywgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIHZhbHVlID0gX3RoaXMkcHJvcHMzLnZhbHVlLFxuICAgICAgICAgIHNpemUgPSBfdGhpcyRwcm9wczMuc2l6ZSxcbiAgICAgICAgICBsZXZlbCA9IF90aGlzJHByb3BzMy5sZXZlbCxcbiAgICAgICAgICBiZ0NvbG9yID0gX3RoaXMkcHJvcHMzLmJnQ29sb3IsXG4gICAgICAgICAgZmdDb2xvciA9IF90aGlzJHByb3BzMy5mZ0NvbG9yLFxuICAgICAgICAgIGluY2x1ZGVNYXJnaW4gPSBfdGhpcyRwcm9wczMuaW5jbHVkZU1hcmdpbixcbiAgICAgICAgICBpbWFnZVNldHRpbmdzID0gX3RoaXMkcHJvcHMzLmltYWdlU2V0dGluZ3MsXG4gICAgICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRwcm9wczMsIFtcInZhbHVlXCIsIFwic2l6ZVwiLCBcImxldmVsXCIsIFwiYmdDb2xvclwiLCBcImZnQ29sb3JcIiwgXCJpbmNsdWRlTWFyZ2luXCIsIFwiaW1hZ2VTZXR0aW5nc1wiXSk7IC8vIFdlJ2xsIHVzZSB0eXBlPT09LTEgdG8gZm9yY2UgUVJDb2RlIHRvIGF1dG9tYXRpY2FsbHkgcGljayB0aGUgYmVzdCB0eXBlXG5cblxuICAgICAgdmFyIHFyY29kZSA9IG5ldyBRUkNvZGVJbXBsKC0xLCBFcnJvckNvcnJlY3RMZXZlbFtsZXZlbF0pO1xuICAgICAgcXJjb2RlLmFkZERhdGEoY29udmVydFN0cih2YWx1ZSkpO1xuICAgICAgcXJjb2RlLm1ha2UoKTtcbiAgICAgIHZhciBjZWxscyA9IHFyY29kZS5tb2R1bGVzO1xuXG4gICAgICBpZiAoY2VsbHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJnaW4gPSBpbmNsdWRlTWFyZ2luID8gTUFSR0lOX1NJWkUgOiAwO1xuICAgICAgdmFyIG51bUNlbGxzID0gY2VsbHMubGVuZ3RoICsgbWFyZ2luICogMjtcbiAgICAgIHZhciBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyA9IGdldEltYWdlU2V0dGluZ3ModGhpcy5wcm9wcywgY2VsbHMpO1xuICAgICAgdmFyIGltYWdlID0gbnVsbDtcblxuICAgICAgaWYgKGltYWdlU2V0dGluZ3MgIT0gbnVsbCAmJiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncyAhPSBudWxsKSB7XG4gICAgICAgIGlmIChjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy5leGNhdmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBjZWxscyA9IGV4Y2F2YXRlTW9kdWxlcyhjZWxscywgY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MuZXhjYXZhdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpbWFnZSA9IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiLCB7XG4gICAgICAgICAgeGxpbmtIcmVmOiBpbWFnZVNldHRpbmdzLnNyYyxcbiAgICAgICAgICBoZWlnaHQ6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLmgsXG4gICAgICAgICAgd2lkdGg6IGNhbGN1bGF0ZWRJbWFnZVNldHRpbmdzLncsXG4gICAgICAgICAgeDogY2FsY3VsYXRlZEltYWdlU2V0dGluZ3MueCArIG1hcmdpbixcbiAgICAgICAgICB5OiBjYWxjdWxhdGVkSW1hZ2VTZXR0aW5ncy55ICsgbWFyZ2luLFxuICAgICAgICAgIHByZXNlcnZlQXNwZWN0UmF0aW86IFwibm9uZVwiXG4gICAgICAgIH0pO1xuICAgICAgfSAvLyBEcmF3aW5nIHN0cmF0ZWd5OiBpbnN0ZWFkIG9mIGEgcmVjdCBwZXIgbW9kdWxlLCB3ZSdyZSBnb2luZyB0byBjcmVhdGUgYVxuICAgICAgLy8gc2luZ2xlIHBhdGggZm9yIHRoZSBkYXJrIG1vZHVsZXMgYW5kIGxheWVyIHRoYXQgb24gdG9wIG9mIGEgbGlnaHQgcmVjdCxcbiAgICAgIC8vIGZvciBhIHRvdGFsIG9mIDIgRE9NIG5vZGVzLiBXZSBwYXkgYSBiaXQgbW9yZSBpbiBzdHJpbmcgY29uY2F0IGJ1dCB0aGF0J3NcbiAgICAgIC8vIHdheSBmYXN0ZXIgdGhhbiBET00gb3BzLlxuICAgICAgLy8gRm9yIGxldmVsIDEsIDQ0MSBub2RlcyAtPiAyXG4gICAgICAvLyBGb3IgbGV2ZWwgNDAsIDMxMzI5IC0+IDJcblxuXG4gICAgICB2YXIgZmdQYXRoID0gZ2VuZXJhdGVQYXRoKGNlbGxzLCBtYXJnaW4pO1xuICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgX2V4dGVuZHMoe1xuICAgICAgICBzaGFwZVJlbmRlcmluZzogXCJjcmlzcEVkZ2VzXCIsXG4gICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIFwiLmNvbmNhdChudW1DZWxscywgXCIgXCIpLmNvbmNhdChudW1DZWxscylcbiAgICAgIH0sIG90aGVyUHJvcHMpLCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7XG4gICAgICAgIGZpbGw6IGJnQ29sb3IsXG4gICAgICAgIGQ6IFwiTTAsMCBoXCIuY29uY2F0KG51bUNlbGxzLCBcInZcIikuY29uY2F0KG51bUNlbGxzLCBcIkgwelwiKVxuICAgICAgfSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHtcbiAgICAgICAgZmlsbDogZmdDb2xvcixcbiAgICAgICAgZDogZmdQYXRoXG4gICAgICB9KSwgaW1hZ2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBRUkNvZGVTVkc7XG59KFJlYWN0LlB1cmVDb21wb25lbnQpO1xuXG5fZGVmaW5lUHJvcGVydHkoUVJDb2RlU1ZHLCBcImRlZmF1bHRQcm9wc1wiLCBERUZBVUxUX1BST1BTKTtcblxuaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFFSQ29kZVNWRy5wcm9wVHlwZXMgPSBQUk9QX1RZUEVTO1xufVxuXG52YXIgUVJDb2RlID0gZnVuY3Rpb24gUVJDb2RlKHByb3BzKSB7XG4gIHZhciByZW5kZXJBcyA9IHByb3BzLnJlbmRlckFzLFxuICAgICAgb3RoZXJQcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhwcm9wcywgW1wicmVuZGVyQXNcIl0pO1xuXG4gIHZhciBDb21wb25lbnQgPSByZW5kZXJBcyA9PT0gJ3N2ZycgPyBRUkNvZGVTVkcgOiBRUkNvZGVDYW52YXM7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgb3RoZXJQcm9wcyk7XG59O1xuXG5RUkNvZGUuZGVmYXVsdFByb3BzID0gX29iamVjdFNwcmVhZCh7XG4gIHJlbmRlckFzOiAnY2FudmFzJ1xufSwgREVGQVVMVF9QUk9QUyk7XG5tb2R1bGUuZXhwb3J0cyA9IFFSQ29kZTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdC9iYWNrZW5kJyk7XG4iLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJSZWFjdERldlRvb2xzQmFja2VuZFwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJSZWFjdERldlRvb2xzQmFja2VuZFwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAxOSk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG59IGVsc2Uge31cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG4gIGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXG5cbiAgICB2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblxuICAgIHRlc3QxWzVdID0gJ2RlJztcblxuICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXG5cbiAgICB2YXIgdGVzdDIgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgdGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuICAgIH1cblxuICAgIHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG4gICAgICByZXR1cm4gdGVzdDJbbl07XG4gICAgfSk7XG5cbiAgICBpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblxuXG4gICAgdmFyIHRlc3QzID0ge307XG4gICAgJ2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG4gICAgICB0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGZyb207XG4gIHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG4gIHZhciBzeW1ib2xzO1xuXG4gIGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG4gICAgZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG4gICAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcbiAgICAgICAgdG9ba2V5XSA9IGZyb21ba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgICBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuICAgICAgICAgIHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn07XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24ocHJvY2Vzcykge2Z1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU2VtVmVyO1xudmFyIGRlYnVnO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuaWYgKCh0eXBlb2YgcHJvY2VzcyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHByb2Nlc3MpKSA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyAmJiAvXFxic2VtdmVyXFxiL2kudGVzdChwcm9jZXNzLmVudi5OT0RFX0RFQlVHKSkge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICBhcmdzLnVuc2hpZnQoJ1NFTVZFUicpO1xuICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICB9O1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufSAvLyBOb3RlOiB0aGlzIGlzIHRoZSBzZW12ZXIub3JnIHZlcnNpb24gb2YgdGhlIHNwZWMgdGhhdCBpdCBpbXBsZW1lbnRzXG4vLyBOb3QgbmVjZXNzYXJpbHkgdGhlIHBhY2thZ2UgdmVyc2lvbiBvZiB0aGlzIGNvZGUuXG5cblxuZXhwb3J0cy5TRU1WRVJfU1BFQ19WRVJTSU9OID0gJzIuMC4wJztcbnZhciBNQVhfTEVOR1RIID0gMjU2O1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fFxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbjkwMDcxOTkyNTQ3NDA5OTE7IC8vIE1heCBzYWZlIHNlZ21lbnQgbGVuZ3RoIGZvciBjb2VyY2lvbi5cblxudmFyIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggPSAxNjsgLy8gVGhlIGFjdHVhbCByZWdleHBzIGdvIG9uIGV4cG9ydHMucmVcblxudmFyIHJlID0gZXhwb3J0cy5yZSA9IFtdO1xudmFyIHNyYyA9IGV4cG9ydHMuc3JjID0gW107XG52YXIgdCA9IGV4cG9ydHMudG9rZW5zID0ge307XG52YXIgUiA9IDA7XG5cbmZ1bmN0aW9uIHRvayhuKSB7XG4gIHRbbl0gPSBSKys7XG59IC8vIFRoZSBmb2xsb3dpbmcgUmVndWxhciBFeHByZXNzaW9ucyBjYW4gYmUgdXNlZCBmb3IgdG9rZW5pemluZyxcbi8vIHZhbGlkYXRpbmcsIGFuZCBwYXJzaW5nIFNlbVZlciB2ZXJzaW9uIHN0cmluZ3MuXG4vLyAjIyBOdW1lcmljIElkZW50aWZpZXJcbi8vIEEgc2luZ2xlIGAwYCwgb3IgYSBub24temVybyBkaWdpdCBmb2xsb3dlZCBieSB6ZXJvIG9yIG1vcmUgZGlnaXRzLlxuXG5cbnRvaygnTlVNRVJJQ0lERU5USUZJRVInKTtcbnNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSA9ICcwfFsxLTldXFxcXGQqJztcbnRvaygnTlVNRVJJQ0lERU5USUZJRVJMT09TRScpO1xuc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gPSAnWzAtOV0rJzsgLy8gIyMgTm9uLW51bWVyaWMgSWRlbnRpZmllclxuLy8gWmVybyBvciBtb3JlIGRpZ2l0cywgZm9sbG93ZWQgYnkgYSBsZXR0ZXIgb3IgaHlwaGVuLCBhbmQgdGhlbiB6ZXJvIG9yXG4vLyBtb3JlIGxldHRlcnMsIGRpZ2l0cywgb3IgaHlwaGVucy5cblxudG9rKCdOT05OVU1FUklDSURFTlRJRklFUicpO1xuc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdID0gJ1xcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSonOyAvLyAjIyBNYWluIFZlcnNpb25cbi8vIFRocmVlIGRvdC1zZXBhcmF0ZWQgbnVtZXJpYyBpZGVudGlmaWVycy5cblxudG9rKCdNQUlOVkVSU0lPTicpO1xuc3JjW3QuTUFJTlZFUlNJT05dID0gJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJylcXFxcLicgKyAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUl0gKyAnKVxcXFwuJyArICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSXSArICcpJztcbnRvaygnTUFJTlZFUlNJT05MT09TRScpO1xuc3JjW3QuTUFJTlZFUlNJT05MT09TRV0gPSAnKCcgKyBzcmNbdC5OVU1FUklDSURFTlRJRklFUkxPT1NFXSArICcpXFxcXC4nICsgJygnICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnKVxcXFwuJyArICcoJyArIHNyY1t0Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdICsgJyknOyAvLyAjIyBQcmUtcmVsZWFzZSBWZXJzaW9uIElkZW50aWZpZXJcbi8vIEEgbnVtZXJpYyBpZGVudGlmaWVyLCBvciBhIG5vbi1udW1lcmljIGlkZW50aWZpZXIuXG5cbnRvaygnUFJFUkVMRUFTRUlERU5USUZJRVInKTtcbnNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSXSA9ICcoPzonICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJ3wnICsgc3JjW3QuTk9OTlVNRVJJQ0lERU5USUZJRVJdICsgJyknO1xudG9rKCdQUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFJyk7XG5zcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXSA9ICcoPzonICsgc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfCcgKyBzcmNbdC5OT05OVU1FUklDSURFTlRJRklFUl0gKyAnKSc7IC8vICMjIFByZS1yZWxlYXNlIFZlcnNpb25cbi8vIEh5cGhlbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgZG90LXNlcGFyYXRlZCBwcmUtcmVsZWFzZSB2ZXJzaW9uXG4vLyBpZGVudGlmaWVycy5cblxudG9rKCdQUkVSRUxFQVNFJyk7XG5zcmNbdC5QUkVSRUxFQVNFXSA9ICcoPzotKCcgKyBzcmNbdC5QUkVSRUxFQVNFSURFTlRJRklFUl0gKyAnKD86XFxcXC4nICsgc3JjW3QuUFJFUkVMRUFTRUlERU5USUZJRVJdICsgJykqKSknO1xudG9rKCdQUkVSRUxFQVNFTE9PU0UnKTtcbnNyY1t0LlBSRVJFTEVBU0VMT09TRV0gPSAnKD86LT8oJyArIHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJyg/OlxcXFwuJyArIHNyY1t0LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdICsgJykqKSknOyAvLyAjIyBCdWlsZCBNZXRhZGF0YSBJZGVudGlmaWVyXG4vLyBBbnkgY29tYmluYXRpb24gb2YgZGlnaXRzLCBsZXR0ZXJzLCBvciBoeXBoZW5zLlxuXG50b2soJ0JVSUxESURFTlRJRklFUicpO1xuc3JjW3QuQlVJTERJREVOVElGSUVSXSA9ICdbMC05QS1aYS16LV0rJzsgLy8gIyMgQnVpbGQgTWV0YWRhdGFcbi8vIFBsdXMgc2lnbiwgZm9sbG93ZWQgYnkgb25lIG9yIG1vcmUgcGVyaW9kLXNlcGFyYXRlZCBidWlsZCBtZXRhZGF0YVxuLy8gaWRlbnRpZmllcnMuXG5cbnRvaygnQlVJTEQnKTtcbnNyY1t0LkJVSUxEXSA9ICcoPzpcXFxcKygnICsgc3JjW3QuQlVJTERJREVOVElGSUVSXSArICcoPzpcXFxcLicgKyBzcmNbdC5CVUlMRElERU5USUZJRVJdICsgJykqKSknOyAvLyAjIyBGdWxsIFZlcnNpb24gU3RyaW5nXG4vLyBBIG1haW4gdmVyc2lvbiwgZm9sbG93ZWQgb3B0aW9uYWxseSBieSBhIHByZS1yZWxlYXNlIHZlcnNpb24gYW5kXG4vLyBidWlsZCBtZXRhZGF0YS5cbi8vIE5vdGUgdGhhdCB0aGUgb25seSBtYWpvciwgbWlub3IsIHBhdGNoLCBhbmQgcHJlLXJlbGVhc2Ugc2VjdGlvbnMgb2Zcbi8vIHRoZSB2ZXJzaW9uIHN0cmluZyBhcmUgY2FwdHVyaW5nIGdyb3Vwcy4gIFRoZSBidWlsZCBtZXRhZGF0YSBpcyBub3QgYVxuLy8gY2FwdHVyaW5nIGdyb3VwLCBiZWNhdXNlIGl0IHNob3VsZCBub3QgZXZlciBiZSB1c2VkIGluIHZlcnNpb25cbi8vIGNvbXBhcmlzb24uXG5cbnRvaygnRlVMTCcpO1xudG9rKCdGVUxMUExBSU4nKTtcbnNyY1t0LkZVTExQTEFJTl0gPSAndj8nICsgc3JjW3QuTUFJTlZFUlNJT05dICsgc3JjW3QuUFJFUkVMRUFTRV0gKyAnPycgKyBzcmNbdC5CVUlMRF0gKyAnPyc7XG5zcmNbdC5GVUxMXSA9ICdeJyArIHNyY1t0LkZVTExQTEFJTl0gKyAnJCc7IC8vIGxpa2UgZnVsbCwgYnV0IGFsbG93cyB2MS4yLjMgYW5kID0xLjIuMywgd2hpY2ggcGVvcGxlIGRvIHNvbWV0aW1lcy5cbi8vIGFsc28sIDEuMC4wYWxwaGExIChwcmVyZWxlYXNlIHdpdGhvdXQgdGhlIGh5cGhlbikgd2hpY2ggaXMgcHJldHR5XG4vLyBjb21tb24gaW4gdGhlIG5wbSByZWdpc3RyeS5cblxudG9rKCdMT09TRVBMQUlOJyk7XG5zcmNbdC5MT09TRVBMQUlOXSA9ICdbdj1cXFxcc10qJyArIHNyY1t0Lk1BSU5WRVJTSU9OTE9PU0VdICsgc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSArICc/JyArIHNyY1t0LkJVSUxEXSArICc/JztcbnRvaygnTE9PU0UnKTtcbnNyY1t0LkxPT1NFXSA9ICdeJyArIHNyY1t0LkxPT1NFUExBSU5dICsgJyQnO1xudG9rKCdHVExUJyk7XG5zcmNbdC5HVExUXSA9ICcoKD86PHw+KT89PyknOyAvLyBTb21ldGhpbmcgbGlrZSBcIjIuKlwiIG9yIFwiMS4yLnhcIi5cbi8vIE5vdGUgdGhhdCBcIngueFwiIGlzIGEgdmFsaWQgeFJhbmdlIGlkZW50aWZlciwgbWVhbmluZyBcImFueSB2ZXJzaW9uXCJcbi8vIE9ubHkgdGhlIGZpcnN0IGl0ZW0gaXMgc3RyaWN0bHkgcmVxdWlyZWQuXG5cbnRvaygnWFJBTkdFSURFTlRJRklFUkxPT1NFJyk7XG5zcmNbdC5YUkFOR0VJREVOVElGSUVSTE9PU0VdID0gc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJMT09TRV0gKyAnfHh8WHxcXFxcKic7XG50b2soJ1hSQU5HRUlERU5USUZJRVInKTtcbnNyY1t0LlhSQU5HRUlERU5USUZJRVJdID0gc3JjW3QuTlVNRVJJQ0lERU5USUZJRVJdICsgJ3x4fFh8XFxcXConO1xudG9rKCdYUkFOR0VQTEFJTicpO1xuc3JjW3QuWFJBTkdFUExBSU5dID0gJ1t2PVxcXFxzXSooJyArIHNyY1t0LlhSQU5HRUlERU5USUZJRVJdICsgJyknICsgJyg/OlxcXFwuKCcgKyBzcmNbdC5YUkFOR0VJREVOVElGSUVSXSArICcpJyArICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUl0gKyAnKScgKyAnKD86JyArIHNyY1t0LlBSRVJFTEVBU0VdICsgJyk/JyArIHNyY1t0LkJVSUxEXSArICc/JyArICcpPyk/JztcbnRvaygnWFJBTkdFUExBSU5MT09TRScpO1xuc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gPSAnW3Y9XFxcXHNdKignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArICcoPzpcXFxcLignICsgc3JjW3QuWFJBTkdFSURFTlRJRklFUkxPT1NFXSArICcpJyArICcoPzonICsgc3JjW3QuUFJFUkVMRUFTRUxPT1NFXSArICcpPycgKyBzcmNbdC5CVUlMRF0gKyAnPycgKyAnKT8pPyc7XG50b2soJ1hSQU5HRScpO1xuc3JjW3QuWFJBTkdFXSA9ICdeJyArIHNyY1t0LkdUTFRdICsgJ1xcXFxzKicgKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnJCc7XG50b2soJ1hSQU5HRUxPT1NFJyk7XG5zcmNbdC5YUkFOR0VMT09TRV0gPSAnXicgKyBzcmNbdC5HVExUXSArICdcXFxccyonICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7IC8vIENvZXJjaW9uLlxuLy8gRXh0cmFjdCBhbnl0aGluZyB0aGF0IGNvdWxkIGNvbmNlaXZhYmx5IGJlIGEgcGFydCBvZiBhIHZhbGlkIHNlbXZlclxuXG50b2soJ0NPRVJDRScpO1xuc3JjW3QuQ09FUkNFXSA9ICcoXnxbXlxcXFxkXSknICsgJyhcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pJyArICcoPzpcXFxcLihcXFxcZHsxLCcgKyBNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIICsgJ30pKT8nICsgJyg/OlxcXFwuKFxcXFxkezEsJyArIE1BWF9TQUZFX0NPTVBPTkVOVF9MRU5HVEggKyAnfSkpPycgKyAnKD86JHxbXlxcXFxkXSknO1xudG9rKCdDT0VSQ0VSVEwnKTtcbnJlW3QuQ09FUkNFUlRMXSA9IG5ldyBSZWdFeHAoc3JjW3QuQ09FUkNFXSwgJ2cnKTsgLy8gVGlsZGUgcmFuZ2VzLlxuLy8gTWVhbmluZyBpcyBcInJlYXNvbmFibHkgYXQgb3IgZ3JlYXRlciB0aGFuXCJcblxudG9rKCdMT05FVElMREUnKTtcbnNyY1t0LkxPTkVUSUxERV0gPSAnKD86fj4/KSc7XG50b2soJ1RJTERFVFJJTScpO1xuc3JjW3QuVElMREVUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbdC5MT05FVElMREVdICsgJ1xcXFxzKyc7XG5yZVt0LlRJTERFVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LlRJTERFVFJJTV0sICdnJyk7XG52YXIgdGlsZGVUcmltUmVwbGFjZSA9ICckMX4nO1xudG9rKCdUSUxERScpO1xuc3JjW3QuVElMREVdID0gJ14nICsgc3JjW3QuTE9ORVRJTERFXSArIHNyY1t0LlhSQU5HRVBMQUlOXSArICckJztcbnRvaygnVElMREVMT09TRScpO1xuc3JjW3QuVElMREVMT09TRV0gPSAnXicgKyBzcmNbdC5MT05FVElMREVdICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7IC8vIENhcmV0IHJhbmdlcy5cbi8vIE1lYW5pbmcgaXMgXCJhdCBsZWFzdCBhbmQgYmFja3dhcmRzIGNvbXBhdGlibGUgd2l0aFwiXG5cbnRvaygnTE9ORUNBUkVUJyk7XG5zcmNbdC5MT05FQ0FSRVRdID0gJyg/OlxcXFxeKSc7XG50b2soJ0NBUkVUVFJJTScpO1xuc3JjW3QuQ0FSRVRUUklNXSA9ICcoXFxcXHMqKScgKyBzcmNbdC5MT05FQ0FSRVRdICsgJ1xcXFxzKyc7XG5yZVt0LkNBUkVUVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LkNBUkVUVFJJTV0sICdnJyk7XG52YXIgY2FyZXRUcmltUmVwbGFjZSA9ICckMV4nO1xudG9rKCdDQVJFVCcpO1xuc3JjW3QuQ0FSRVRdID0gJ14nICsgc3JjW3QuTE9ORUNBUkVUXSArIHNyY1t0LlhSQU5HRVBMQUlOXSArICckJztcbnRvaygnQ0FSRVRMT09TRScpO1xuc3JjW3QuQ0FSRVRMT09TRV0gPSAnXicgKyBzcmNbdC5MT05FQ0FSRVRdICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnJCc7IC8vIEEgc2ltcGxlIGd0L2x0L2VxIHRoaW5nLCBvciBqdXN0IFwiXCIgdG8gaW5kaWNhdGUgXCJhbnkgdmVyc2lvblwiXG5cbnRvaygnQ09NUEFSQVRPUkxPT1NFJyk7XG5zcmNbdC5DT01QQVJBVE9STE9PU0VdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqKCcgKyBzcmNbdC5MT09TRVBMQUlOXSArICcpJHxeJCc7XG50b2soJ0NPTVBBUkFUT1InKTtcbnNyY1t0LkNPTVBBUkFUT1JdID0gJ14nICsgc3JjW3QuR1RMVF0gKyAnXFxcXHMqKCcgKyBzcmNbdC5GVUxMUExBSU5dICsgJykkfF4kJzsgLy8gQW4gZXhwcmVzc2lvbiB0byBzdHJpcCBhbnkgd2hpdGVzcGFjZSBiZXR3ZWVuIHRoZSBndGx0IGFuZCB0aGUgdGhpbmdcbi8vIGl0IG1vZGlmaWVzLCBzbyB0aGF0IGA+IDEuMi4zYCA9PT4gYD4xLjIuM2BcblxudG9rKCdDT01QQVJBVE9SVFJJTScpO1xuc3JjW3QuQ09NUEFSQVRPUlRSSU1dID0gJyhcXFxccyopJyArIHNyY1t0LkdUTFRdICsgJ1xcXFxzKignICsgc3JjW3QuTE9PU0VQTEFJTl0gKyAnfCcgKyBzcmNbdC5YUkFOR0VQTEFJTl0gKyAnKSc7IC8vIHRoaXMgb25lIGhhcyB0byB1c2UgdGhlIC9nIGZsYWdcblxucmVbdC5DT01QQVJBVE9SVFJJTV0gPSBuZXcgUmVnRXhwKHNyY1t0LkNPTVBBUkFUT1JUUklNXSwgJ2cnKTtcbnZhciBjb21wYXJhdG9yVHJpbVJlcGxhY2UgPSAnJDEkMiQzJzsgLy8gU29tZXRoaW5nIGxpa2UgYDEuMi4zIC0gMS4yLjRgXG4vLyBOb3RlIHRoYXQgdGhlc2UgYWxsIHVzZSB0aGUgbG9vc2UgZm9ybSwgYmVjYXVzZSB0aGV5J2xsIGJlXG4vLyBjaGVja2VkIGFnYWluc3QgZWl0aGVyIHRoZSBzdHJpY3Qgb3IgbG9vc2UgY29tcGFyYXRvciBmb3JtXG4vLyBsYXRlci5cblxudG9rKCdIWVBIRU5SQU5HRScpO1xuc3JjW3QuSFlQSEVOUkFOR0VdID0gJ15cXFxccyooJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJyArICdcXFxccystXFxcXHMrJyArICcoJyArIHNyY1t0LlhSQU5HRVBMQUlOXSArICcpJyArICdcXFxccyokJztcbnRvaygnSFlQSEVOUkFOR0VMT09TRScpO1xuc3JjW3QuSFlQSEVOUkFOR0VMT09TRV0gPSAnXlxcXFxzKignICsgc3JjW3QuWFJBTkdFUExBSU5MT09TRV0gKyAnKScgKyAnXFxcXHMrLVxcXFxzKycgKyAnKCcgKyBzcmNbdC5YUkFOR0VQTEFJTkxPT1NFXSArICcpJyArICdcXFxccyokJzsgLy8gU3RhciByYW5nZXMgYmFzaWNhbGx5IGp1c3QgYWxsb3cgYW55dGhpbmcgYXQgYWxsLlxuXG50b2soJ1NUQVInKTtcbnNyY1t0LlNUQVJdID0gJyg8fD4pPz0/XFxcXHMqXFxcXConOyAvLyBDb21waWxlIHRvIGFjdHVhbCByZWdleHAgb2JqZWN0cy5cbi8vIEFsbCBhcmUgZmxhZy1mcmVlLCB1bmxlc3MgdGhleSB3ZXJlIGNyZWF0ZWQgYWJvdmUgd2l0aCBhIGZsYWcuXG5cbmZvciAodmFyIGkgPSAwOyBpIDwgUjsgaSsrKSB7XG4gIGRlYnVnKGksIHNyY1tpXSk7XG5cbiAgaWYgKCFyZVtpXSkge1xuICAgIHJlW2ldID0gbmV3IFJlZ0V4cChzcmNbaV0pO1xuICB9XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcblxuZnVuY3Rpb24gcGFyc2UodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHZlcnNpb24ubGVuZ3RoID4gTUFYX0xFTkdUSCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHIgPSBvcHRpb25zLmxvb3NlID8gcmVbdC5MT09TRV0gOiByZVt0LkZVTExdO1xuXG4gIGlmICghci50ZXN0KHZlcnNpb24pKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMudmFsaWQgPSB2YWxpZDtcblxuZnVuY3Rpb24gdmFsaWQodmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgdiA9IHBhcnNlKHZlcnNpb24sIG9wdGlvbnMpO1xuICByZXR1cm4gdiA/IHYudmVyc2lvbiA6IG51bGw7XG59XG5cbmV4cG9ydHMuY2xlYW4gPSBjbGVhbjtcblxuZnVuY3Rpb24gY2xlYW4odmVyc2lvbiwgb3B0aW9ucykge1xuICB2YXIgcyA9IHBhcnNlKHZlcnNpb24udHJpbSgpLnJlcGxhY2UoL15bPXZdKy8sICcnKSwgb3B0aW9ucyk7XG4gIHJldHVybiBzID8gcy52ZXJzaW9uIDogbnVsbDtcbn1cblxuZXhwb3J0cy5TZW1WZXIgPSBTZW1WZXI7XG5cbmZ1bmN0aW9uIFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uIGluc3RhbmNlb2YgU2VtVmVyKSB7XG4gICAgaWYgKHZlcnNpb24ubG9vc2UgPT09IG9wdGlvbnMubG9vc2UpIHtcbiAgICAgIHJldHVybiB2ZXJzaW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2ZXJzaW9uID0gdmVyc2lvbi52ZXJzaW9uO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmVyc2lvbiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFZlcnNpb246ICcgKyB2ZXJzaW9uKTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uLmxlbmd0aCA+IE1BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2ZXJzaW9uIGlzIGxvbmdlciB0aGFuICcgKyBNQVhfTEVOR1RIICsgJyBjaGFyYWN0ZXJzJyk7XG4gIH1cblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIHJldHVybiBuZXcgU2VtVmVyKHZlcnNpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgZGVidWcoJ1NlbVZlcicsIHZlcnNpb24sIG9wdGlvbnMpO1xuICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB0aGlzLmxvb3NlID0gISFvcHRpb25zLmxvb3NlO1xuICB2YXIgbSA9IHZlcnNpb24udHJpbSgpLm1hdGNoKG9wdGlvbnMubG9vc2UgPyByZVt0LkxPT1NFXSA6IHJlW3QuRlVMTF0pO1xuXG4gIGlmICghbSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgVmVyc2lvbjogJyArIHZlcnNpb24pO1xuICB9XG5cbiAgdGhpcy5yYXcgPSB2ZXJzaW9uOyAvLyB0aGVzZSBhcmUgYWN0dWFsbHkgbnVtYmVyc1xuXG4gIHRoaXMubWFqb3IgPSArbVsxXTtcbiAgdGhpcy5taW5vciA9ICttWzJdO1xuICB0aGlzLnBhdGNoID0gK21bM107XG5cbiAgaWYgKHRoaXMubWFqb3IgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHRoaXMubWFqb3IgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBtYWpvciB2ZXJzaW9uJyk7XG4gIH1cblxuICBpZiAodGhpcy5taW5vciA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdGhpcy5taW5vciA8IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG1pbm9yIHZlcnNpb24nKTtcbiAgfVxuXG4gIGlmICh0aGlzLnBhdGNoID4gTUFYX1NBRkVfSU5URUdFUiB8fCB0aGlzLnBhdGNoIDwgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgcGF0Y2ggdmVyc2lvbicpO1xuICB9IC8vIG51bWJlcmlmeSBhbnkgcHJlcmVsZWFzZSBudW1lcmljIGlkc1xuXG5cbiAgaWYgKCFtWzRdKSB7XG4gICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5wcmVyZWxlYXNlID0gbVs0XS5zcGxpdCgnLicpLm1hcChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmICgvXlswLTldKyQvLnRlc3QoaWQpKSB7XG4gICAgICAgIHZhciBudW0gPSAraWQ7XG5cbiAgICAgICAgaWYgKG51bSA+PSAwICYmIG51bSA8IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgICByZXR1cm4gbnVtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpZDtcbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuYnVpbGQgPSBtWzVdID8gbVs1XS5zcGxpdCgnLicpIDogW107XG4gIHRoaXMuZm9ybWF0KCk7XG59XG5cblNlbVZlci5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnZlcnNpb24gPSB0aGlzLm1ham9yICsgJy4nICsgdGhpcy5taW5vciArICcuJyArIHRoaXMucGF0Y2g7XG5cbiAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICB0aGlzLnZlcnNpb24gKz0gJy0nICsgdGhpcy5wcmVyZWxlYXNlLmpvaW4oJy4nKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnZlcnNpb247XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52ZXJzaW9uO1xufTtcblxuU2VtVmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGRlYnVnKCdTZW1WZXIuY29tcGFyZScsIHRoaXMudmVyc2lvbiwgdGhpcy5vcHRpb25zLCBvdGhlcik7XG5cbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBTZW1WZXIpKSB7XG4gICAgb3RoZXIgPSBuZXcgU2VtVmVyKG90aGVyLCB0aGlzLm9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY29tcGFyZU1haW4ob3RoZXIpIHx8IHRoaXMuY29tcGFyZVByZShvdGhlcik7XG59O1xuXG5TZW1WZXIucHJvdG90eXBlLmNvbXBhcmVNYWluID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnModGhpcy5tYWpvciwgb3RoZXIubWFqb3IpIHx8IGNvbXBhcmVJZGVudGlmaWVycyh0aGlzLm1pbm9yLCBvdGhlci5taW5vcikgfHwgY29tcGFyZUlkZW50aWZpZXJzKHRoaXMucGF0Y2gsIG90aGVyLnBhdGNoKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZVByZSA9IGZ1bmN0aW9uIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFNlbVZlcikpIHtcbiAgICBvdGhlciA9IG5ldyBTZW1WZXIob3RoZXIsIHRoaXMub3B0aW9ucyk7XG4gIH0gLy8gTk9UIGhhdmluZyBhIHByZXJlbGVhc2UgaXMgPiBoYXZpbmcgb25lXG5cblxuICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGggJiYgb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmICghdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3RoZXIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLnByZXJlbGVhc2VbaV07XG4gICAgdmFyIGIgPSBvdGhlci5wcmVyZWxlYXNlW2ldO1xuICAgIGRlYnVnKCdwcmVyZWxlYXNlIGNvbXBhcmUnLCBpLCBhLCBiKTtcblxuICAgIGlmIChhID09PSB1bmRlZmluZWQgJiYgYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9IGVsc2UgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGEgPT09IGIpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpO1xuICAgIH1cbiAgfSB3aGlsZSAoKytpKTtcbn07XG5cblNlbVZlci5wcm90b3R5cGUuY29tcGFyZUJ1aWxkID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgU2VtVmVyKSkge1xuICAgIG90aGVyID0gbmV3IFNlbVZlcihvdGhlciwgdGhpcy5vcHRpb25zKTtcbiAgfVxuXG4gIHZhciBpID0gMDtcblxuICBkbyB7XG4gICAgdmFyIGEgPSB0aGlzLmJ1aWxkW2ldO1xuICAgIHZhciBiID0gb3RoZXIuYnVpbGRbaV07XG4gICAgZGVidWcoJ3ByZXJlbGVhc2UgY29tcGFyZScsIGksIGEsIGIpO1xuXG4gICAgaWYgKGEgPT09IHVuZGVmaW5lZCAmJiBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gZWxzZSBpZiAoYSA9PT0gYikge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYSwgYik7XG4gICAgfVxuICB9IHdoaWxlICgrK2kpO1xufTsgLy8gcHJlbWlub3Igd2lsbCBidW1wIHRoZSB2ZXJzaW9uIHVwIHRvIHRoZSBuZXh0IG1pbm9yIHJlbGVhc2UsIGFuZCBpbW1lZGlhdGVseVxuLy8gZG93biB0byBwcmUtcmVsZWFzZS4gcHJlbWFqb3IgYW5kIHByZXBhdGNoIHdvcmsgdGhlIHNhbWUgd2F5LlxuXG5cblNlbVZlci5wcm90b3R5cGUuaW5jID0gZnVuY3Rpb24gKHJlbGVhc2UsIGlkZW50aWZpZXIpIHtcbiAgc3dpdGNoIChyZWxlYXNlKSB7XG4gICAgY2FzZSAncHJlbWFqb3InOlxuICAgICAgdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBhdGNoID0gMDtcbiAgICAgIHRoaXMubWlub3IgPSAwO1xuICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcmVtaW5vcic6XG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5taW5vcisrO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwcmVwYXRjaCc6XG4gICAgICAvLyBJZiB0aGlzIGlzIGFscmVhZHkgYSBwcmVyZWxlYXNlLCBpdCB3aWxsIGJ1bXAgdG8gdGhlIG5leHQgdmVyc2lvblxuICAgICAgLy8gZHJvcCBhbnkgcHJlcmVsZWFzZXMgdGhhdCBtaWdodCBhbHJlYWR5IGV4aXN0LCBzaW5jZSB0aGV5IGFyZSBub3RcbiAgICAgIC8vIHJlbGV2YW50IGF0IHRoaXMgcG9pbnQuXG4gICAgICB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgdGhpcy5pbmMoJ3ByZScsIGlkZW50aWZpZXIpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgbm9uLXByZXJlbGVhc2UgdmVyc2lvbiwgdGhpcyBhY3RzIHRoZSBzYW1lIGFzXG4gICAgLy8gcHJlcGF0Y2guXG5cbiAgICBjYXNlICdwcmVyZWxlYXNlJzpcbiAgICAgIGlmICh0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuaW5jKCdwYXRjaCcsIGlkZW50aWZpZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluYygncHJlJywgaWRlbnRpZmllcik7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21ham9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWFqb3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtYWpvci5cbiAgICAgIC8vIDEuMC4wLTUgYnVtcHMgdG8gMS4wLjBcbiAgICAgIC8vIDEuMS4wIGJ1bXBzIHRvIDIuMC4wXG4gICAgICBpZiAodGhpcy5taW5vciAhPT0gMCB8fCB0aGlzLnBhdGNoICE9PSAwIHx8IHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5tYWpvcisrO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1pbm9yID0gMDtcbiAgICAgIHRoaXMucGF0Y2ggPSAwO1xuICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW107XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ21pbm9yJzpcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBwcmUtbWlub3IgdmVyc2lvbiwgYnVtcCB1cCB0byB0aGUgc2FtZSBtaW5vciB2ZXJzaW9uLlxuICAgICAgLy8gT3RoZXJ3aXNlIGluY3JlbWVudCBtaW5vci5cbiAgICAgIC8vIDEuMi4wLTUgYnVtcHMgdG8gMS4yLjBcbiAgICAgIC8vIDEuMi4xIGJ1bXBzIHRvIDEuMy4wXG4gICAgICBpZiAodGhpcy5wYXRjaCAhPT0gMCB8fCB0aGlzLnByZXJlbGVhc2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMubWlub3IrKztcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXRjaCA9IDA7XG4gICAgICB0aGlzLnByZXJlbGVhc2UgPSBbXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0Y2gnOlxuICAgICAgLy8gSWYgdGhpcyBpcyBub3QgYSBwcmUtcmVsZWFzZSB2ZXJzaW9uLCBpdCB3aWxsIGluY3JlbWVudCB0aGUgcGF0Y2guXG4gICAgICAvLyBJZiBpdCBpcyBhIHByZS1yZWxlYXNlIGl0IHdpbGwgYnVtcCB1cCB0byB0aGUgc2FtZSBwYXRjaCB2ZXJzaW9uLlxuICAgICAgLy8gMS4yLjAtNSBwYXRjaGVzIHRvIDEuMi4wXG4gICAgICAvLyAxLjIuMCBwYXRjaGVzIHRvIDEuMi4xXG4gICAgICBpZiAodGhpcy5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLnBhdGNoKys7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucHJlcmVsZWFzZSA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgLy8gVGhpcyBwcm9iYWJseSBzaG91bGRuJ3QgYmUgdXNlZCBwdWJsaWNseS5cbiAgICAvLyAxLjAuMCBcInByZVwiIHdvdWxkIGJlY29tZSAxLjAuMC0wIHdoaWNoIGlzIHRoZSB3cm9uZyBkaXJlY3Rpb24uXG5cbiAgICBjYXNlICdwcmUnOlxuICAgICAgaWYgKHRoaXMucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLnByZXJlbGVhc2UubGVuZ3RoO1xuXG4gICAgICAgIHdoaWxlICgtLWkgPj0gMCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5wcmVyZWxlYXNlW2ldID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlW2ldKys7XG4gICAgICAgICAgICBpID0gLTI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gZGlkbid0IGluY3JlbWVudCBhbnl0aGluZ1xuICAgICAgICAgIHRoaXMucHJlcmVsZWFzZS5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIDEuMi4wLWJldGEuMSBidW1wcyB0byAxLjIuMC1iZXRhLjIsXG4gICAgICAgIC8vIDEuMi4wLWJldGEuZm9vYmx6IG9yIDEuMi4wLWJldGEgYnVtcHMgdG8gMS4yLjAtYmV0YS4wXG4gICAgICAgIGlmICh0aGlzLnByZXJlbGVhc2VbMF0gPT09IGlkZW50aWZpZXIpIHtcbiAgICAgICAgICBpZiAoaXNOYU4odGhpcy5wcmVyZWxlYXNlWzFdKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVyZWxlYXNlID0gW2lkZW50aWZpZXIsIDBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnByZXJlbGVhc2UgPSBbaWRlbnRpZmllciwgMF07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJyArIHJlbGVhc2UpO1xuICB9XG5cbiAgdGhpcy5mb3JtYXQoKTtcbiAgdGhpcy5yYXcgPSB0aGlzLnZlcnNpb247XG4gIHJldHVybiB0aGlzO1xufTtcblxuZXhwb3J0cy5pbmMgPSBpbmM7XG5cbmZ1bmN0aW9uIGluYyh2ZXJzaW9uLCByZWxlYXNlLCBsb29zZSwgaWRlbnRpZmllcikge1xuICBpZiAodHlwZW9mIGxvb3NlID09PSAnc3RyaW5nJykge1xuICAgIGlkZW50aWZpZXIgPSBsb29zZTtcbiAgICBsb29zZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBTZW1WZXIodmVyc2lvbiwgbG9vc2UpLmluYyhyZWxlYXNlLCBpZGVudGlmaWVyKS52ZXJzaW9uO1xuICB9IGNhdGNoIChlcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmV4cG9ydHMuZGlmZiA9IGRpZmY7XG5cbmZ1bmN0aW9uIGRpZmYodmVyc2lvbjEsIHZlcnNpb24yKSB7XG4gIGlmIChlcSh2ZXJzaW9uMSwgdmVyc2lvbjIpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHYxID0gcGFyc2UodmVyc2lvbjEpO1xuICAgIHZhciB2MiA9IHBhcnNlKHZlcnNpb24yKTtcbiAgICB2YXIgcHJlZml4ID0gJyc7XG5cbiAgICBpZiAodjEucHJlcmVsZWFzZS5sZW5ndGggfHwgdjIucHJlcmVsZWFzZS5sZW5ndGgpIHtcbiAgICAgIHByZWZpeCA9ICdwcmUnO1xuICAgICAgdmFyIGRlZmF1bHRSZXN1bHQgPSAncHJlcmVsZWFzZSc7XG4gICAgfVxuXG4gICAgZm9yICh2YXIga2V5IGluIHYxKSB7XG4gICAgICBpZiAoa2V5ID09PSAnbWFqb3InIHx8IGtleSA9PT0gJ21pbm9yJyB8fCBrZXkgPT09ICdwYXRjaCcpIHtcbiAgICAgICAgaWYgKHYxW2tleV0gIT09IHYyW2tleV0pIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsga2V5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7IC8vIG1heSBiZSB1bmRlZmluZWRcbiAgfVxufVxuXG5leHBvcnRzLmNvbXBhcmVJZGVudGlmaWVycyA9IGNvbXBhcmVJZGVudGlmaWVycztcbnZhciBudW1lcmljID0gL15bMC05XSskLztcblxuZnVuY3Rpb24gY29tcGFyZUlkZW50aWZpZXJzKGEsIGIpIHtcbiAgdmFyIGFudW0gPSBudW1lcmljLnRlc3QoYSk7XG4gIHZhciBibnVtID0gbnVtZXJpYy50ZXN0KGIpO1xuXG4gIGlmIChhbnVtICYmIGJudW0pIHtcbiAgICBhID0gK2E7XG4gICAgYiA9ICtiO1xuICB9XG5cbiAgcmV0dXJuIGEgPT09IGIgPyAwIDogYW51bSAmJiAhYm51bSA/IC0xIDogYm51bSAmJiAhYW51bSA/IDEgOiBhIDwgYiA/IC0xIDogMTtcbn1cblxuZXhwb3J0cy5yY29tcGFyZUlkZW50aWZpZXJzID0gcmNvbXBhcmVJZGVudGlmaWVycztcblxuZnVuY3Rpb24gcmNvbXBhcmVJZGVudGlmaWVycyhhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlSWRlbnRpZmllcnMoYiwgYSk7XG59XG5cbmV4cG9ydHMubWFqb3IgPSBtYWpvcjtcblxuZnVuY3Rpb24gbWFqb3IoYSwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLm1ham9yO1xufVxuXG5leHBvcnRzLm1pbm9yID0gbWlub3I7XG5cbmZ1bmN0aW9uIG1pbm9yKGEsIGxvb3NlKSB7XG4gIHJldHVybiBuZXcgU2VtVmVyKGEsIGxvb3NlKS5taW5vcjtcbn1cblxuZXhwb3J0cy5wYXRjaCA9IHBhdGNoO1xuXG5mdW5jdGlvbiBwYXRjaChhLCBsb29zZSkge1xuICByZXR1cm4gbmV3IFNlbVZlcihhLCBsb29zZSkucGF0Y2g7XG59XG5cbmV4cG9ydHMuY29tcGFyZSA9IGNvbXBhcmU7XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIG5ldyBTZW1WZXIoYSwgbG9vc2UpLmNvbXBhcmUobmV3IFNlbVZlcihiLCBsb29zZSkpO1xufVxuXG5leHBvcnRzLmNvbXBhcmVMb29zZSA9IGNvbXBhcmVMb29zZTtcblxuZnVuY3Rpb24gY29tcGFyZUxvb3NlKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgdHJ1ZSk7XG59XG5cbmV4cG9ydHMuY29tcGFyZUJ1aWxkID0gY29tcGFyZUJ1aWxkO1xuXG5mdW5jdGlvbiBjb21wYXJlQnVpbGQoYSwgYiwgbG9vc2UpIHtcbiAgdmFyIHZlcnNpb25BID0gbmV3IFNlbVZlcihhLCBsb29zZSk7XG4gIHZhciB2ZXJzaW9uQiA9IG5ldyBTZW1WZXIoYiwgbG9vc2UpO1xuICByZXR1cm4gdmVyc2lvbkEuY29tcGFyZSh2ZXJzaW9uQikgfHwgdmVyc2lvbkEuY29tcGFyZUJ1aWxkKHZlcnNpb25CKTtcbn1cblxuZXhwb3J0cy5yY29tcGFyZSA9IHJjb21wYXJlO1xuXG5mdW5jdGlvbiByY29tcGFyZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShiLCBhLCBsb29zZSk7XG59XG5cbmV4cG9ydHMuc29ydCA9IHNvcnQ7XG5cbmZ1bmN0aW9uIHNvcnQobGlzdCwgbG9vc2UpIHtcbiAgcmV0dXJuIGxpc3Quc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBleHBvcnRzLmNvbXBhcmVCdWlsZChhLCBiLCBsb29zZSk7XG4gIH0pO1xufVxuXG5leHBvcnRzLnJzb3J0ID0gcnNvcnQ7XG5cbmZ1bmN0aW9uIHJzb3J0KGxpc3QsIGxvb3NlKSB7XG4gIHJldHVybiBsaXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5jb21wYXJlQnVpbGQoYiwgYSwgbG9vc2UpO1xuICB9KTtcbn1cblxuZXhwb3J0cy5ndCA9IGd0O1xuXG5mdW5jdGlvbiBndChhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPiAwO1xufVxuXG5leHBvcnRzLmx0ID0gbHQ7XG5cbmZ1bmN0aW9uIGx0KGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSA8IDA7XG59XG5cbmV4cG9ydHMuZXEgPSBlcTtcblxuZnVuY3Rpb24gZXEoYSwgYiwgbG9vc2UpIHtcbiAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgbG9vc2UpID09PSAwO1xufVxuXG5leHBvcnRzLm5lcSA9IG5lcTtcblxuZnVuY3Rpb24gbmVxKGEsIGIsIGxvb3NlKSB7XG4gIHJldHVybiBjb21wYXJlKGEsIGIsIGxvb3NlKSAhPT0gMDtcbn1cblxuZXhwb3J0cy5ndGUgPSBndGU7XG5cbmZ1bmN0aW9uIGd0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPj0gMDtcbn1cblxuZXhwb3J0cy5sdGUgPSBsdGU7XG5cbmZ1bmN0aW9uIGx0ZShhLCBiLCBsb29zZSkge1xuICByZXR1cm4gY29tcGFyZShhLCBiLCBsb29zZSkgPD0gMDtcbn1cblxuZXhwb3J0cy5jbXAgPSBjbXA7XG5cbmZ1bmN0aW9uIGNtcChhLCBvcCwgYiwgbG9vc2UpIHtcbiAgc3dpdGNoIChvcCkge1xuICAgIGNhc2UgJz09PSc6XG4gICAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAoX3R5cGVvZihiKSA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXR1cm4gYSA9PT0gYjtcblxuICAgIGNhc2UgJyE9PSc6XG4gICAgICBpZiAoX3R5cGVvZihhKSA9PT0gJ29iamVjdCcpIGEgPSBhLnZlcnNpb247XG4gICAgICBpZiAoX3R5cGVvZihiKSA9PT0gJ29iamVjdCcpIGIgPSBiLnZlcnNpb247XG4gICAgICByZXR1cm4gYSAhPT0gYjtcblxuICAgIGNhc2UgJyc6XG4gICAgY2FzZSAnPSc6XG4gICAgY2FzZSAnPT0nOlxuICAgICAgcmV0dXJuIGVxKGEsIGIsIGxvb3NlKTtcblxuICAgIGNhc2UgJyE9JzpcbiAgICAgIHJldHVybiBuZXEoYSwgYiwgbG9vc2UpO1xuXG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gZ3QoYSwgYiwgbG9vc2UpO1xuXG4gICAgY2FzZSAnPj0nOlxuICAgICAgcmV0dXJuIGd0ZShhLCBiLCBsb29zZSk7XG5cbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiBsdChhLCBiLCBsb29zZSk7XG5cbiAgICBjYXNlICc8PSc6XG4gICAgICByZXR1cm4gbHRlKGEsIGIsIGxvb3NlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG9wZXJhdG9yOiAnICsgb3ApO1xuICB9XG59XG5cbmV4cG9ydHMuQ29tcGFyYXRvciA9IENvbXBhcmF0b3I7XG5cbmZ1bmN0aW9uIENvbXBhcmF0b3IoY29tcCwgb3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMgfHwgX3R5cGVvZihvcHRpb25zKSAhPT0gJ29iamVjdCcpIHtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbG9vc2U6ICEhb3B0aW9ucyxcbiAgICAgIGluY2x1ZGVQcmVyZWxlYXNlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICBpZiAoY29tcCBpbnN0YW5jZW9mIENvbXBhcmF0b3IpIHtcbiAgICBpZiAoY29tcC5sb29zZSA9PT0gISFvcHRpb25zLmxvb3NlKSB7XG4gICAgICByZXR1cm4gY29tcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcCA9IGNvbXAudmFsdWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvbXBhcmF0b3IpKSB7XG4gICAgcmV0dXJuIG5ldyBDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpO1xuICB9XG5cbiAgZGVidWcoJ2NvbXBhcmF0b3InLCBjb21wLCBvcHRpb25zKTtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcbiAgdGhpcy5wYXJzZShjb21wKTtcblxuICBpZiAodGhpcy5zZW12ZXIgPT09IEFOWSkge1xuICAgIHRoaXMudmFsdWUgPSAnJztcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5vcGVyYXRvciArIHRoaXMuc2VtdmVyLnZlcnNpb247XG4gIH1cblxuICBkZWJ1ZygnY29tcCcsIHRoaXMpO1xufVxuXG52YXIgQU5ZID0ge307XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKGNvbXApIHtcbiAgdmFyIHIgPSB0aGlzLm9wdGlvbnMubG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdO1xuICB2YXIgbSA9IGNvbXAubWF0Y2gocik7XG5cbiAgaWYgKCFtKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBjb21wYXJhdG9yOiAnICsgY29tcCk7XG4gIH1cblxuICB0aGlzLm9wZXJhdG9yID0gbVsxXSAhPT0gdW5kZWZpbmVkID8gbVsxXSA6ICcnO1xuXG4gIGlmICh0aGlzLm9wZXJhdG9yID09PSAnPScpIHtcbiAgICB0aGlzLm9wZXJhdG9yID0gJyc7XG4gIH0gLy8gaWYgaXQgbGl0ZXJhbGx5IGlzIGp1c3QgJz4nIG9yICcnIHRoZW4gYWxsb3cgYW55dGhpbmcuXG5cblxuICBpZiAoIW1bMl0pIHtcbiAgICB0aGlzLnNlbXZlciA9IEFOWTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnNlbXZlciA9IG5ldyBTZW1WZXIobVsyXSwgdGhpcy5vcHRpb25zLmxvb3NlKTtcbiAgfVxufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuQ29tcGFyYXRvci5wcm90b3R5cGUudGVzdCA9IGZ1bmN0aW9uICh2ZXJzaW9uKSB7XG4gIGRlYnVnKCdDb21wYXJhdG9yLnRlc3QnLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMubG9vc2UpO1xuXG4gIGlmICh0aGlzLnNlbXZlciA9PT0gQU5ZIHx8IHZlcnNpb24gPT09IEFOWSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGNtcCh2ZXJzaW9uLCB0aGlzLm9wZXJhdG9yLCB0aGlzLnNlbXZlciwgdGhpcy5vcHRpb25zKTtcbn07XG5cbkNvbXBhcmF0b3IucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiAoY29tcCwgb3B0aW9ucykge1xuICBpZiAoIShjb21wIGluc3RhbmNlb2YgQ29tcGFyYXRvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhIENvbXBhcmF0b3IgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHZhciByYW5nZVRtcDtcblxuICBpZiAodGhpcy5vcGVyYXRvciA9PT0gJycpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gJycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJhbmdlVG1wID0gbmV3IFJhbmdlKGNvbXAudmFsdWUsIG9wdGlvbnMpO1xuICAgIHJldHVybiBzYXRpc2ZpZXModGhpcy52YWx1ZSwgcmFuZ2VUbXAsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKGNvbXAub3BlcmF0b3IgPT09ICcnKSB7XG4gICAgaWYgKGNvbXAudmFsdWUgPT09ICcnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByYW5nZVRtcCA9IG5ldyBSYW5nZSh0aGlzLnZhbHVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gc2F0aXNmaWVzKGNvbXAuc2VtdmVyLCByYW5nZVRtcCwgb3B0aW9ucyk7XG4gIH1cblxuICB2YXIgc2FtZURpcmVjdGlvbkluY3JlYXNpbmcgPSAodGhpcy5vcGVyYXRvciA9PT0gJz49JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPicpICYmIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+Jyk7XG4gIHZhciBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyA9ICh0aGlzLm9wZXJhdG9yID09PSAnPD0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8JykgJiYgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTtcbiAgdmFyIHNhbWVTZW1WZXIgPSB0aGlzLnNlbXZlci52ZXJzaW9uID09PSBjb21wLnNlbXZlci52ZXJzaW9uO1xuICB2YXIgZGlmZmVyZW50RGlyZWN0aW9uc0luY2x1c2l2ZSA9ICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc8PScpICYmIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc8PScpO1xuICB2YXIgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gPSBjbXAodGhpcy5zZW12ZXIsICc8JywgY29tcC5zZW12ZXIsIG9wdGlvbnMpICYmICh0aGlzLm9wZXJhdG9yID09PSAnPj0nIHx8IHRoaXMub3BlcmF0b3IgPT09ICc+JykgJiYgKGNvbXAub3BlcmF0b3IgPT09ICc8PScgfHwgY29tcC5vcGVyYXRvciA9PT0gJzwnKTtcbiAgdmFyIG9wcG9zaXRlRGlyZWN0aW9uc0dyZWF0ZXJUaGFuID0gY21wKHRoaXMuc2VtdmVyLCAnPicsIGNvbXAuc2VtdmVyLCBvcHRpb25zKSAmJiAodGhpcy5vcGVyYXRvciA9PT0gJzw9JyB8fCB0aGlzLm9wZXJhdG9yID09PSAnPCcpICYmIChjb21wLm9wZXJhdG9yID09PSAnPj0nIHx8IGNvbXAub3BlcmF0b3IgPT09ICc+Jyk7XG4gIHJldHVybiBzYW1lRGlyZWN0aW9uSW5jcmVhc2luZyB8fCBzYW1lRGlyZWN0aW9uRGVjcmVhc2luZyB8fCBzYW1lU2VtVmVyICYmIGRpZmZlcmVudERpcmVjdGlvbnNJbmNsdXNpdmUgfHwgb3Bwb3NpdGVEaXJlY3Rpb25zTGVzc1RoYW4gfHwgb3Bwb3NpdGVEaXJlY3Rpb25zR3JlYXRlclRoYW47XG59O1xuXG5leHBvcnRzLlJhbmdlID0gUmFuZ2U7XG5cbmZ1bmN0aW9uIFJhbmdlKHJhbmdlLCBvcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucyB8fCBfdHlwZW9mKG9wdGlvbnMpICE9PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICBsb29zZTogISFvcHRpb25zLFxuICAgICAgaW5jbHVkZVByZXJlbGVhc2U6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIGlmIChyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLmxvb3NlID09PSAhIW9wdGlvbnMubG9vc2UgJiYgcmFuZ2UuaW5jbHVkZVByZXJlbGVhc2UgPT09ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgICAgcmV0dXJuIHJhbmdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLnJhdywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJhbmdlIGluc3RhbmNlb2YgQ29tcGFyYXRvcikge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UudmFsdWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5sb29zZSA9ICEhb3B0aW9ucy5sb29zZTtcbiAgdGhpcy5pbmNsdWRlUHJlcmVsZWFzZSA9ICEhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZTsgLy8gRmlyc3QsIHNwbGl0IGJhc2VkIG9uIGJvb2xlYW4gb3IgfHxcblxuICB0aGlzLnJhdyA9IHJhbmdlO1xuICB0aGlzLnNldCA9IHJhbmdlLnNwbGl0KC9cXHMqXFx8XFx8XFxzKi8pLm1hcChmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZVJhbmdlKHJhbmdlLnRyaW0oKSk7XG4gIH0sIHRoaXMpLmZpbHRlcihmdW5jdGlvbiAoYykge1xuICAgIC8vIHRocm93IG91dCBhbnkgdGhhdCBhcmUgbm90IHJlbGV2YW50IGZvciB3aGF0ZXZlciByZWFzb25cbiAgICByZXR1cm4gYy5sZW5ndGg7XG4gIH0pO1xuXG4gIGlmICghdGhpcy5zZXQubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBTZW1WZXIgUmFuZ2U6ICcgKyByYW5nZSk7XG4gIH1cblxuICB0aGlzLmZvcm1hdCgpO1xufVxuXG5SYW5nZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJhbmdlID0gdGhpcy5zZXQubWFwKGZ1bmN0aW9uIChjb21wcykge1xuICAgIHJldHVybiBjb21wcy5qb2luKCcgJykudHJpbSgpO1xuICB9KS5qb2luKCd8fCcpLnRyaW0oKTtcbiAgcmV0dXJuIHRoaXMucmFuZ2U7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnJhbmdlO1xufTtcblxuUmFuZ2UucHJvdG90eXBlLnBhcnNlUmFuZ2UgPSBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgdmFyIGxvb3NlID0gdGhpcy5vcHRpb25zLmxvb3NlO1xuICByYW5nZSA9IHJhbmdlLnRyaW0oKTsgLy8gYDEuMi4zIC0gMS4yLjRgID0+IGA+PTEuMi4zIDw9MS4yLjRgXG5cbiAgdmFyIGhyID0gbG9vc2UgPyByZVt0LkhZUEhFTlJBTkdFTE9PU0VdIDogcmVbdC5IWVBIRU5SQU5HRV07XG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShociwgaHlwaGVuUmVwbGFjZSk7XG4gIGRlYnVnKCdoeXBoZW4gcmVwbGFjZScsIHJhbmdlKTsgLy8gYD4gMS4yLjMgPCAxLjIuNWAgPT4gYD4xLjIuMyA8MS4yLjVgXG5cbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuQ09NUEFSQVRPUlRSSU1dLCBjb21wYXJhdG9yVHJpbVJlcGxhY2UpO1xuICBkZWJ1ZygnY29tcGFyYXRvciB0cmltJywgcmFuZ2UsIHJlW3QuQ09NUEFSQVRPUlRSSU1dKTsgLy8gYH4gMS4yLjNgID0+IGB+MS4yLjNgXG5cbiAgcmFuZ2UgPSByYW5nZS5yZXBsYWNlKHJlW3QuVElMREVUUklNXSwgdGlsZGVUcmltUmVwbGFjZSk7IC8vIGBeIDEuMi4zYCA9PiBgXjEuMi4zYFxuXG4gIHJhbmdlID0gcmFuZ2UucmVwbGFjZShyZVt0LkNBUkVUVFJJTV0sIGNhcmV0VHJpbVJlcGxhY2UpOyAvLyBub3JtYWxpemUgc3BhY2VzXG5cbiAgcmFuZ2UgPSByYW5nZS5zcGxpdCgvXFxzKy8pLmpvaW4oJyAnKTsgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJhbmdlIGlzIGNvbXBsZXRlbHkgdHJpbW1lZCBhbmRcbiAgLy8gcmVhZHkgdG8gYmUgc3BsaXQgaW50byBjb21wYXJhdG9ycy5cblxuICB2YXIgY29tcFJlID0gbG9vc2UgPyByZVt0LkNPTVBBUkFUT1JMT09TRV0gOiByZVt0LkNPTVBBUkFUT1JdO1xuICB2YXIgc2V0ID0gcmFuZ2Uuc3BsaXQoJyAnKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gcGFyc2VDb21wYXJhdG9yKGNvbXAsIHRoaXMub3B0aW9ucyk7XG4gIH0sIHRoaXMpLmpvaW4oJyAnKS5zcGxpdCgvXFxzKy8pO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMubG9vc2UpIHtcbiAgICAvLyBpbiBsb29zZSBtb2RlLCB0aHJvdyBvdXQgYW55IHRoYXQgYXJlIG5vdCB2YWxpZCBjb21wYXJhdG9yc1xuICAgIHNldCA9IHNldC5maWx0ZXIoZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgIHJldHVybiAhIWNvbXAubWF0Y2goY29tcFJlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gbmV3IENvbXBhcmF0b3IoY29tcCwgdGhpcy5vcHRpb25zKTtcbiAgfSwgdGhpcyk7XG4gIHJldHVybiBzZXQ7XG59O1xuXG5SYW5nZS5wcm90b3R5cGUuaW50ZXJzZWN0cyA9IGZ1bmN0aW9uIChyYW5nZSwgb3B0aW9ucykge1xuICBpZiAoIShyYW5nZSBpbnN0YW5jZW9mIFJhbmdlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2EgUmFuZ2UgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLnNldC5zb21lKGZ1bmN0aW9uICh0aGlzQ29tcGFyYXRvcnMpIHtcbiAgICByZXR1cm4gaXNTYXRpc2ZpYWJsZSh0aGlzQ29tcGFyYXRvcnMsIG9wdGlvbnMpICYmIHJhbmdlLnNldC5zb21lKGZ1bmN0aW9uIChyYW5nZUNvbXBhcmF0b3JzKSB7XG4gICAgICByZXR1cm4gaXNTYXRpc2ZpYWJsZShyYW5nZUNvbXBhcmF0b3JzLCBvcHRpb25zKSAmJiB0aGlzQ29tcGFyYXRvcnMuZXZlcnkoZnVuY3Rpb24gKHRoaXNDb21wYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiByYW5nZUNvbXBhcmF0b3JzLmV2ZXJ5KGZ1bmN0aW9uIChyYW5nZUNvbXBhcmF0b3IpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc0NvbXBhcmF0b3IuaW50ZXJzZWN0cyhyYW5nZUNvbXBhcmF0b3IsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn07IC8vIHRha2UgYSBzZXQgb2YgY29tcGFyYXRvcnMgYW5kIGRldGVybWluZSB3aGV0aGVyIHRoZXJlXG4vLyBleGlzdHMgYSB2ZXJzaW9uIHdoaWNoIGNhbiBzYXRpc2Z5IGl0XG5cblxuZnVuY3Rpb24gaXNTYXRpc2ZpYWJsZShjb21wYXJhdG9ycywgb3B0aW9ucykge1xuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgdmFyIHJlbWFpbmluZ0NvbXBhcmF0b3JzID0gY29tcGFyYXRvcnMuc2xpY2UoKTtcbiAgdmFyIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKCk7XG5cbiAgd2hpbGUgKHJlc3VsdCAmJiByZW1haW5pbmdDb21wYXJhdG9ycy5sZW5ndGgpIHtcbiAgICByZXN1bHQgPSByZW1haW5pbmdDb21wYXJhdG9ycy5ldmVyeShmdW5jdGlvbiAob3RoZXJDb21wYXJhdG9yKSB7XG4gICAgICByZXR1cm4gdGVzdENvbXBhcmF0b3IuaW50ZXJzZWN0cyhvdGhlckNvbXBhcmF0b3IsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHRlc3RDb21wYXJhdG9yID0gcmVtYWluaW5nQ29tcGFyYXRvcnMucG9wKCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufSAvLyBNb3N0bHkganVzdCBmb3IgdGVzdGluZyBhbmQgbGVnYWN5IEFQSSByZWFzb25zXG5cblxuZXhwb3J0cy50b0NvbXBhcmF0b3JzID0gdG9Db21wYXJhdG9ycztcblxuZnVuY3Rpb24gdG9Db21wYXJhdG9ycyhyYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKS5zZXQubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIGNvbXAubWFwKGZ1bmN0aW9uIChjKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9KS5qb2luKCcgJykudHJpbSgpLnNwbGl0KCcgJyk7XG4gIH0pO1xufSAvLyBjb21wcmlzZWQgb2YgeHJhbmdlcywgdGlsZGVzLCBzdGFycywgYW5kIGd0bHQncyBhdCB0aGlzIHBvaW50LlxuLy8gYWxyZWFkeSByZXBsYWNlZCB0aGUgaHlwaGVuIHJhbmdlc1xuLy8gdHVybiBpbnRvIGEgc2V0IG9mIEpVU1QgY29tcGFyYXRvcnMuXG5cblxuZnVuY3Rpb24gcGFyc2VDb21wYXJhdG9yKGNvbXAsIG9wdGlvbnMpIHtcbiAgZGVidWcoJ2NvbXAnLCBjb21wLCBvcHRpb25zKTtcbiAgY29tcCA9IHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVRpbGRlcyhjb21wLCBvcHRpb25zKTtcbiAgZGVidWcoJ3RpbGRlcycsIGNvbXApO1xuICBjb21wID0gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucyk7XG4gIGRlYnVnKCd4cmFuZ2UnLCBjb21wKTtcbiAgY29tcCA9IHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKTtcbiAgZGVidWcoJ3N0YXJzJywgY29tcCk7XG4gIHJldHVybiBjb21wO1xufVxuXG5mdW5jdGlvbiBpc1goaWQpIHtcbiAgcmV0dXJuICFpZCB8fCBpZC50b0xvd2VyQ2FzZSgpID09PSAneCcgfHwgaWQgPT09ICcqJztcbn0gLy8gfiwgfj4gLS0gPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gfjIsIH4yLngsIH4yLngueCwgfj4yLCB+PjIueCB+PjIueC54IC0tID4gPj0yLjAuMCA8My4wLjBcbi8vIH4yLjAsIH4yLjAueCwgfj4yLjAsIH4+Mi4wLnggLS0gPiA+PTIuMC4wIDwyLjEuMFxuLy8gfjEuMiwgfjEuMi54LCB+PjEuMiwgfj4xLjIueCAtLSA+ID49MS4yLjAgPDEuMy4wXG4vLyB+MS4yLjMsIH4+MS4yLjMgLS0gPiA+PTEuMi4zIDwxLjMuMFxuLy8gfjEuMi4wLCB+PjEuMi4wIC0tID4gPj0xLjIuMCA8MS4zLjBcblxuXG5mdW5jdGlvbiByZXBsYWNlVGlsZGVzKGNvbXAsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGNvbXAudHJpbSgpLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uIChjb21wKSB7XG4gICAgcmV0dXJuIHJlcGxhY2VUaWxkZShjb21wLCBvcHRpb25zKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlVGlsZGUoY29tcCwgb3B0aW9ucykge1xuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlRJTERFTE9PU0VdIDogcmVbdC5USUxERV07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ3RpbGRlJywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJztcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICAvLyB+MS4yID09ID49MS4yLjAgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnO1xuICAgIH0gZWxzZSBpZiAocHIpIHtcbiAgICAgIGRlYnVnKCdyZXBsYWNlVGlsZGUgcHInLCBwcik7XG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgKyAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gfjEuMi4zID09ID49MS4yLjMgPDEuMy4wXG4gICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJyA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgfVxuXG4gICAgZGVidWcoJ3RpbGRlIHJldHVybicsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSk7XG59IC8vIF4gLS0gPiAqIChhbnksIGtpbmRhIHNpbGx5KVxuLy8gXjIsIF4yLngsIF4yLngueCAtLSA+ID49Mi4wLjAgPDMuMC4wXG4vLyBeMi4wLCBeMi4wLnggLS0gPiA+PTIuMC4wIDwzLjAuMFxuLy8gXjEuMiwgXjEuMi54IC0tID4gPj0xLjIuMCA8Mi4wLjBcbi8vIF4xLjIuMyAtLSA+ID49MS4yLjMgPDIuMC4wXG4vLyBeMS4yLjAgLS0gPiA+PTEuMi4wIDwyLjAuMFxuXG5cbmZ1bmN0aW9uIHJlcGxhY2VDYXJldHMoY29tcCwgb3B0aW9ucykge1xuICByZXR1cm4gY29tcC50cmltKCkuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZUNhcmV0KGNvbXAsIG9wdGlvbnMpO1xuICB9KS5qb2luKCcgJyk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VDYXJldChjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdjYXJldCcsIGNvbXAsIG9wdGlvbnMpO1xuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LkNBUkVUTE9PU0VdIDogcmVbdC5DQVJFVF07XG4gIHJldHVybiBjb21wLnJlcGxhY2UociwgZnVuY3Rpb24gKF8sIE0sIG0sIHAsIHByKSB7XG4gICAgZGVidWcoJ2NhcmV0JywgY29tcCwgXywgTSwgbSwgcCwgcHIpO1xuICAgIHZhciByZXQ7XG5cbiAgICBpZiAoaXNYKE0pKSB7XG4gICAgICByZXQgPSAnJztcbiAgICB9IGVsc2UgaWYgKGlzWChtKSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgIH0gZWxzZSBpZiAoaXNYKHApKSB7XG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCA8JyArIE0gKyAnLicgKyAoK20gKyAxKSArICcuMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLjAgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByKSB7XG4gICAgICBkZWJ1ZygncmVwbGFjZUNhcmV0IHByJywgcHIpO1xuXG4gICAgICBpZiAoTSA9PT0gJzAnKSB7XG4gICAgICAgIGlmIChtID09PSAnMCcpIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgKyAnIDwnICsgTSArICcuJyArIG0gKyAnLicgKyAoK3AgKyAxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXQgPSAnPj0nICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgJy0nICsgcHIgKyAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICctJyArIHByICsgJyA8JyArICgrTSArIDEpICsgJy4wLjAnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Zygnbm8gcHInKTtcblxuICAgICAgaWYgKE0gPT09ICcwJykge1xuICAgICAgICBpZiAobSA9PT0gJzAnKSB7XG4gICAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICcgPCcgKyBNICsgJy4nICsgbSArICcuJyArICgrcCArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuJyArIHAgKyAnIDwnICsgTSArICcuJyArICgrbSArIDEpICsgJy4wJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0ID0gJz49JyArIE0gKyAnLicgKyBtICsgJy4nICsgcCArICcgPCcgKyAoK00gKyAxKSArICcuMC4wJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZWJ1ZygnY2FyZXQgcmV0dXJuJywgcmV0KTtcbiAgICByZXR1cm4gcmV0O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVwbGFjZVhSYW5nZXMoY29tcCwgb3B0aW9ucykge1xuICBkZWJ1ZygncmVwbGFjZVhSYW5nZXMnLCBjb21wLCBvcHRpb25zKTtcbiAgcmV0dXJuIGNvbXAuc3BsaXQoL1xccysvKS5tYXAoZnVuY3Rpb24gKGNvbXApIHtcbiAgICByZXR1cm4gcmVwbGFjZVhSYW5nZShjb21wLCBvcHRpb25zKTtcbiAgfSkuam9pbignICcpO1xufVxuXG5mdW5jdGlvbiByZXBsYWNlWFJhbmdlKGNvbXAsIG9wdGlvbnMpIHtcbiAgY29tcCA9IGNvbXAudHJpbSgpO1xuICB2YXIgciA9IG9wdGlvbnMubG9vc2UgPyByZVt0LlhSQU5HRUxPT1NFXSA6IHJlW3QuWFJBTkdFXTtcbiAgcmV0dXJuIGNvbXAucmVwbGFjZShyLCBmdW5jdGlvbiAocmV0LCBndGx0LCBNLCBtLCBwLCBwcikge1xuICAgIGRlYnVnKCd4UmFuZ2UnLCBjb21wLCByZXQsIGd0bHQsIE0sIG0sIHAsIHByKTtcbiAgICB2YXIgeE0gPSBpc1goTSk7XG4gICAgdmFyIHhtID0geE0gfHwgaXNYKG0pO1xuICAgIHZhciB4cCA9IHhtIHx8IGlzWChwKTtcbiAgICB2YXIgYW55WCA9IHhwO1xuXG4gICAgaWYgKGd0bHQgPT09ICc9JyAmJiBhbnlYKSB7XG4gICAgICBndGx0ID0gJyc7XG4gICAgfSAvLyBpZiB3ZSdyZSBpbmNsdWRpbmcgcHJlcmVsZWFzZXMgaW4gdGhlIG1hdGNoLCB0aGVuIHdlIG5lZWRcbiAgICAvLyB0byBmaXggdGhpcyB0byAtMCwgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIHZhbHVlXG5cblxuICAgIHByID0gb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSA/ICctMCcgOiAnJztcblxuICAgIGlmICh4TSkge1xuICAgICAgaWYgKGd0bHQgPT09ICc+JyB8fCBndGx0ID09PSAnPCcpIHtcbiAgICAgICAgLy8gbm90aGluZyBpcyBhbGxvd2VkXG4gICAgICAgIHJldCA9ICc8MC4wLjAtMCc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBub3RoaW5nIGlzIGZvcmJpZGRlblxuICAgICAgICByZXQgPSAnKic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChndGx0ICYmIGFueVgpIHtcbiAgICAgIC8vIHdlIGtub3cgcGF0Y2ggaXMgYW4geCwgYmVjYXVzZSB3ZSBoYXZlIGFueSB4IGF0IGFsbC5cbiAgICAgIC8vIHJlcGxhY2UgWCB3aXRoIDBcbiAgICAgIGlmICh4bSkge1xuICAgICAgICBtID0gMDtcbiAgICAgIH1cblxuICAgICAgcCA9IDA7XG5cbiAgICAgIGlmIChndGx0ID09PSAnPicpIHtcbiAgICAgICAgLy8gPjEgPT4gPj0yLjAuMFxuICAgICAgICAvLyA+MS4yID0+ID49MS4zLjBcbiAgICAgICAgLy8gPjEuMi4zID0+ID49IDEuMi40XG4gICAgICAgIGd0bHQgPSAnPj0nO1xuXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgcCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgICAgICBwID0gMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChndGx0ID09PSAnPD0nKSB7XG4gICAgICAgIC8vIDw9MC43LnggaXMgYWN0dWFsbHkgPDAuOC4wLCBzaW5jZSBhbnkgMC43Lnggc2hvdWxkXG4gICAgICAgIC8vIHBhc3MuICBTaW1pbGFybHksIDw9Ny54IGlzIGFjdHVhbGx5IDw4LjAuMCwgZXRjLlxuICAgICAgICBndGx0ID0gJzwnO1xuXG4gICAgICAgIGlmICh4bSkge1xuICAgICAgICAgIE0gPSArTSArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9ICttICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXQgPSBndGx0ICsgTSArICcuJyArIG0gKyAnLicgKyBwICsgcHI7XG4gICAgfSBlbHNlIGlmICh4bSkge1xuICAgICAgcmV0ID0gJz49JyArIE0gKyAnLjAuMCcgKyBwciArICcgPCcgKyAoK00gKyAxKSArICcuMC4wJyArIHByO1xuICAgIH0gZWxzZSBpZiAoeHApIHtcbiAgICAgIHJldCA9ICc+PScgKyBNICsgJy4nICsgbSArICcuMCcgKyBwciArICcgPCcgKyBNICsgJy4nICsgKCttICsgMSkgKyAnLjAnICsgcHI7XG4gICAgfVxuXG4gICAgZGVidWcoJ3hSYW5nZSByZXR1cm4nLCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH0pO1xufSAvLyBCZWNhdXNlICogaXMgQU5ELWVkIHdpdGggZXZlcnl0aGluZyBlbHNlIGluIHRoZSBjb21wYXJhdG9yLFxuLy8gYW5kICcnIG1lYW5zIFwiYW55IHZlcnNpb25cIiwganVzdCByZW1vdmUgdGhlICpzIGVudGlyZWx5LlxuXG5cbmZ1bmN0aW9uIHJlcGxhY2VTdGFycyhjb21wLCBvcHRpb25zKSB7XG4gIGRlYnVnKCdyZXBsYWNlU3RhcnMnLCBjb21wLCBvcHRpb25zKTsgLy8gTG9vc2VuZXNzIGlzIGlnbm9yZWQgaGVyZS4gIHN0YXIgaXMgYWx3YXlzIGFzIGxvb3NlIGFzIGl0IGdldHMhXG5cbiAgcmV0dXJuIGNvbXAudHJpbSgpLnJlcGxhY2UocmVbdC5TVEFSXSwgJycpO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIHBhc3NlZCB0byBzdHJpbmcucmVwbGFjZShyZVt0LkhZUEhFTlJBTkdFXSlcbi8vIE0sIG0sIHBhdGNoLCBwcmVyZWxlYXNlLCBidWlsZFxuLy8gMS4yIC0gMy40LjUgPT4gPj0xLjIuMCA8PTMuNC41XG4vLyAxLjIuMyAtIDMuNCA9PiA+PTEuMi4wIDwzLjUuMCBBbnkgMy40Lnggd2lsbCBkb1xuLy8gMS4yIC0gMy40ID0+ID49MS4yLjAgPDMuNS4wXG5cblxuZnVuY3Rpb24gaHlwaGVuUmVwbGFjZSgkMCwgZnJvbSwgZk0sIGZtLCBmcCwgZnByLCBmYiwgdG8sIHRNLCB0bSwgdHAsIHRwciwgdGIpIHtcbiAgaWYgKGlzWChmTSkpIHtcbiAgICBmcm9tID0gJyc7XG4gIH0gZWxzZSBpZiAoaXNYKGZtKSkge1xuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLjAuMCc7XG4gIH0gZWxzZSBpZiAoaXNYKGZwKSkge1xuICAgIGZyb20gPSAnPj0nICsgZk0gKyAnLicgKyBmbSArICcuMCc7XG4gIH0gZWxzZSB7XG4gICAgZnJvbSA9ICc+PScgKyBmcm9tO1xuICB9XG5cbiAgaWYgKGlzWCh0TSkpIHtcbiAgICB0byA9ICcnO1xuICB9IGVsc2UgaWYgKGlzWCh0bSkpIHtcbiAgICB0byA9ICc8JyArICgrdE0gKyAxKSArICcuMC4wJztcbiAgfSBlbHNlIGlmIChpc1godHApKSB7XG4gICAgdG8gPSAnPCcgKyB0TSArICcuJyArICgrdG0gKyAxKSArICcuMCc7XG4gIH0gZWxzZSBpZiAodHByKSB7XG4gICAgdG8gPSAnPD0nICsgdE0gKyAnLicgKyB0bSArICcuJyArIHRwICsgJy0nICsgdHByO1xuICB9IGVsc2Uge1xuICAgIHRvID0gJzw9JyArIHRvO1xuICB9XG5cbiAgcmV0dXJuIChmcm9tICsgJyAnICsgdG8pLnRyaW0oKTtcbn0gLy8gaWYgQU5ZIG9mIHRoZSBzZXRzIG1hdGNoIEFMTCBvZiBpdHMgY29tcGFyYXRvcnMsIHRoZW4gcGFzc1xuXG5cblJhbmdlLnByb3RvdHlwZS50ZXN0ID0gZnVuY3Rpb24gKHZlcnNpb24pIHtcbiAgaWYgKCF2ZXJzaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgIHRyeSB7XG4gICAgICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0ZXN0U2V0KHRoaXMuc2V0W2ldLCB2ZXJzaW9uLCB0aGlzLm9wdGlvbnMpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiB0ZXN0U2V0KHNldCwgdmVyc2lvbiwgb3B0aW9ucykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKykge1xuICAgIGlmICghc2V0W2ldLnRlc3QodmVyc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAodmVyc2lvbi5wcmVyZWxlYXNlLmxlbmd0aCAmJiAhb3B0aW9ucy5pbmNsdWRlUHJlcmVsZWFzZSkge1xuICAgIC8vIEZpbmQgdGhlIHNldCBvZiB2ZXJzaW9ucyB0aGF0IGFyZSBhbGxvd2VkIHRvIGhhdmUgcHJlcmVsZWFzZXNcbiAgICAvLyBGb3IgZXhhbXBsZSwgXjEuMi4zLXByLjEgZGVzdWdhcnMgdG8gPj0xLjIuMy1wci4xIDwyLjAuMFxuICAgIC8vIFRoYXQgc2hvdWxkIGFsbG93IGAxLjIuMy1wci4yYCB0byBwYXNzLlxuICAgIC8vIEhvd2V2ZXIsIGAxLjIuNC1hbHBoYS5ub3RyZWFkeWAgc2hvdWxkIE5PVCBiZSBhbGxvd2VkLFxuICAgIC8vIGV2ZW4gdGhvdWdoIGl0J3Mgd2l0aGluIHRoZSByYW5nZSBzZXQgYnkgdGhlIGNvbXBhcmF0b3JzLlxuICAgIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlYnVnKHNldFtpXS5zZW12ZXIpO1xuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlciA9PT0gQU5ZKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2V0W2ldLnNlbXZlci5wcmVyZWxlYXNlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFsbG93ZWQgPSBzZXRbaV0uc2VtdmVyO1xuXG4gICAgICAgIGlmIChhbGxvd2VkLm1ham9yID09PSB2ZXJzaW9uLm1ham9yICYmIGFsbG93ZWQubWlub3IgPT09IHZlcnNpb24ubWlub3IgJiYgYWxsb3dlZC5wYXRjaCA9PT0gdmVyc2lvbi5wYXRjaCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBWZXJzaW9uIGhhcyBhIC1wcmUsIGJ1dCBpdCdzIG5vdCBvbmUgb2YgdGhlIG9uZXMgd2UgbGlrZS5cblxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmV4cG9ydHMuc2F0aXNmaWVzID0gc2F0aXNmaWVzO1xuXG5mdW5jdGlvbiBzYXRpc2ZpZXModmVyc2lvbiwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgdHJ5IHtcbiAgICByYW5nZSA9IG5ldyBSYW5nZShyYW5nZSwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHJhbmdlLnRlc3QodmVyc2lvbik7XG59XG5cbmV4cG9ydHMubWF4U2F0aXNmeWluZyA9IG1heFNhdGlzZnlpbmc7XG5cbmZ1bmN0aW9uIG1heFNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSB7XG4gIHZhciBtYXggPSBudWxsO1xuICB2YXIgbWF4U1YgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtYXggfHwgbWF4U1YuY29tcGFyZSh2KSA9PT0gLTEpIHtcbiAgICAgICAgLy8gY29tcGFyZShtYXgsIHYsIHRydWUpXG4gICAgICAgIG1heCA9IHY7XG4gICAgICAgIG1heFNWID0gbmV3IFNlbVZlcihtYXgsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBtYXg7XG59XG5cbmV4cG9ydHMubWluU2F0aXNmeWluZyA9IG1pblNhdGlzZnlpbmc7XG5cbmZ1bmN0aW9uIG1pblNhdGlzZnlpbmcodmVyc2lvbnMsIHJhbmdlLCBvcHRpb25zKSB7XG4gIHZhciBtaW4gPSBudWxsO1xuICB2YXIgbWluU1YgPSBudWxsO1xuXG4gIHRyeSB7XG4gICAgdmFyIHJhbmdlT2JqID0gbmV3IFJhbmdlKHJhbmdlLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZlcnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICBpZiAocmFuZ2VPYmoudGVzdCh2KSkge1xuICAgICAgLy8gc2F0aXNmaWVzKHYsIHJhbmdlLCBvcHRpb25zKVxuICAgICAgaWYgKCFtaW4gfHwgbWluU1YuY29tcGFyZSh2KSA9PT0gMSkge1xuICAgICAgICAvLyBjb21wYXJlKG1pbiwgdiwgdHJ1ZSlcbiAgICAgICAgbWluID0gdjtcbiAgICAgICAgbWluU1YgPSBuZXcgU2VtVmVyKG1pbiwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG1pbjtcbn1cblxuZXhwb3J0cy5taW5WZXJzaW9uID0gbWluVmVyc2lvbjtcblxuZnVuY3Rpb24gbWluVmVyc2lvbihyYW5nZSwgbG9vc2UpIHtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIGxvb3NlKTtcbiAgdmFyIG1pbnZlciA9IG5ldyBTZW1WZXIoJzAuMC4wJyk7XG5cbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXI7XG4gIH1cblxuICBtaW52ZXIgPSBuZXcgU2VtVmVyKCcwLjAuMC0wJyk7XG5cbiAgaWYgKHJhbmdlLnRlc3QobWludmVyKSkge1xuICAgIHJldHVybiBtaW52ZXI7XG4gIH1cblxuICBtaW52ZXIgPSBudWxsO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldO1xuICAgIGNvbXBhcmF0b3JzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBhcmF0b3IpIHtcbiAgICAgIC8vIENsb25lIHRvIGF2b2lkIG1hbmlwdWxhdGluZyB0aGUgY29tcGFyYXRvcidzIHNlbXZlciBvYmplY3QuXG4gICAgICB2YXIgY29tcHZlciA9IG5ldyBTZW1WZXIoY29tcGFyYXRvci5zZW12ZXIudmVyc2lvbik7XG5cbiAgICAgIHN3aXRjaCAoY29tcGFyYXRvci5vcGVyYXRvcikge1xuICAgICAgICBjYXNlICc+JzpcbiAgICAgICAgICBpZiAoY29tcHZlci5wcmVyZWxlYXNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29tcHZlci5wYXRjaCsrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wdmVyLnByZXJlbGVhc2UucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb21wdmVyLnJhdyA9IGNvbXB2ZXIuZm9ybWF0KCk7XG5cbiAgICAgICAgLyogZmFsbHRocm91Z2ggKi9cblxuICAgICAgICBjYXNlICcnOlxuICAgICAgICBjYXNlICc+PSc6XG4gICAgICAgICAgaWYgKCFtaW52ZXIgfHwgZ3QobWludmVyLCBjb21wdmVyKSkge1xuICAgICAgICAgICAgbWludmVyID0gY29tcHZlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgY2FzZSAnPD0nOlxuICAgICAgICAgIC8qIElnbm9yZSBtYXhpbXVtIHZlcnNpb25zICovXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBvcGVyYXRpb246ICcgKyBjb21wYXJhdG9yLm9wZXJhdG9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChtaW52ZXIgJiYgcmFuZ2UudGVzdChtaW52ZXIpKSB7XG4gICAgcmV0dXJuIG1pbnZlcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnRzLnZhbGlkUmFuZ2UgPSB2YWxpZFJhbmdlO1xuXG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgLy8gUmV0dXJuICcqJyBpbnN0ZWFkIG9mICcnIHNvIHRoYXQgdHJ1dGhpbmVzcyB3b3Jrcy5cbiAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgaXQncyBpbnZhbGlkIGFueXdheVxuICAgIHJldHVybiBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpLnJhbmdlIHx8ICcqJztcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufSAvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBsZXNzIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2VcblxuXG5leHBvcnRzLmx0ciA9IGx0cjtcblxuZnVuY3Rpb24gbHRyKHZlcnNpb24sIHJhbmdlLCBvcHRpb25zKSB7XG4gIHJldHVybiBvdXRzaWRlKHZlcnNpb24sIHJhbmdlLCAnPCcsIG9wdGlvbnMpO1xufSAvLyBEZXRlcm1pbmUgaWYgdmVyc2lvbiBpcyBncmVhdGVyIHRoYW4gYWxsIHRoZSB2ZXJzaW9ucyBwb3NzaWJsZSBpbiB0aGUgcmFuZ2UuXG5cblxuZXhwb3J0cy5ndHIgPSBndHI7XG5cbmZ1bmN0aW9uIGd0cih2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgJz4nLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0cy5vdXRzaWRlID0gb3V0c2lkZTtcblxuZnVuY3Rpb24gb3V0c2lkZSh2ZXJzaW9uLCByYW5nZSwgaGlsbywgb3B0aW9ucykge1xuICB2ZXJzaW9uID0gbmV3IFNlbVZlcih2ZXJzaW9uLCBvcHRpb25zKTtcbiAgcmFuZ2UgPSBuZXcgUmFuZ2UocmFuZ2UsIG9wdGlvbnMpO1xuICB2YXIgZ3RmbiwgbHRlZm4sIGx0Zm4sIGNvbXAsIGVjb21wO1xuXG4gIHN3aXRjaCAoaGlsbykge1xuICAgIGNhc2UgJz4nOlxuICAgICAgZ3RmbiA9IGd0O1xuICAgICAgbHRlZm4gPSBsdGU7XG4gICAgICBsdGZuID0gbHQ7XG4gICAgICBjb21wID0gJz4nO1xuICAgICAgZWNvbXAgPSAnPj0nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICc8JzpcbiAgICAgIGd0Zm4gPSBsdDtcbiAgICAgIGx0ZWZuID0gZ3RlO1xuICAgICAgbHRmbiA9IGd0O1xuICAgICAgY29tcCA9ICc8JztcbiAgICAgIGVjb21wID0gJzw9JztcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ011c3QgcHJvdmlkZSBhIGhpbG8gdmFsIG9mIFwiPFwiIG9yIFwiPlwiJyk7XG4gIH0gLy8gSWYgaXQgc2F0aXNpZmVzIHRoZSByYW5nZSBpdCBpcyBub3Qgb3V0c2lkZVxuXG5cbiAgaWYgKHNhdGlzZmllcyh2ZXJzaW9uLCByYW5nZSwgb3B0aW9ucykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gRnJvbSBub3cgb24sIHZhcmlhYmxlIHRlcm1zIGFyZSBhcyBpZiB3ZSdyZSBpbiBcImd0clwiIG1vZGUuXG4gIC8vIGJ1dCBub3RlIHRoYXQgZXZlcnl0aGluZyBpcyBmbGlwcGVkIGZvciB0aGUgXCJsdHJcIiBmdW5jdGlvbi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2Uuc2V0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGNvbXBhcmF0b3JzID0gcmFuZ2Uuc2V0W2ldO1xuICAgIHZhciBoaWdoID0gbnVsbDtcbiAgICB2YXIgbG93ID0gbnVsbDtcbiAgICBjb21wYXJhdG9ycy5mb3JFYWNoKGZ1bmN0aW9uIChjb21wYXJhdG9yKSB7XG4gICAgICBpZiAoY29tcGFyYXRvci5zZW12ZXIgPT09IEFOWSkge1xuICAgICAgICBjb21wYXJhdG9yID0gbmV3IENvbXBhcmF0b3IoJz49MC4wLjAnKTtcbiAgICAgIH1cblxuICAgICAgaGlnaCA9IGhpZ2ggfHwgY29tcGFyYXRvcjtcbiAgICAgIGxvdyA9IGxvdyB8fCBjb21wYXJhdG9yO1xuXG4gICAgICBpZiAoZ3Rmbihjb21wYXJhdG9yLnNlbXZlciwgaGlnaC5zZW12ZXIsIG9wdGlvbnMpKSB7XG4gICAgICAgIGhpZ2ggPSBjb21wYXJhdG9yO1xuICAgICAgfSBlbHNlIGlmIChsdGZuKGNvbXBhcmF0b3Iuc2VtdmVyLCBsb3cuc2VtdmVyLCBvcHRpb25zKSkge1xuICAgICAgICBsb3cgPSBjb21wYXJhdG9yO1xuICAgICAgfVxuICAgIH0pOyAvLyBJZiB0aGUgZWRnZSB2ZXJzaW9uIGNvbXBhcmF0b3IgaGFzIGEgb3BlcmF0b3IgdGhlbiBvdXIgdmVyc2lvblxuICAgIC8vIGlzbid0IG91dHNpZGUgaXRcblxuICAgIGlmIChoaWdoLm9wZXJhdG9yID09PSBjb21wIHx8IGhpZ2gub3BlcmF0b3IgPT09IGVjb21wKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBJZiB0aGUgbG93ZXN0IHZlcnNpb24gY29tcGFyYXRvciBoYXMgYW4gb3BlcmF0b3IgYW5kIG91ciB2ZXJzaW9uXG4gICAgLy8gaXMgbGVzcyB0aGFuIGl0IHRoZW4gaXQgaXNuJ3QgaGlnaGVyIHRoYW4gdGhlIHJhbmdlXG5cblxuICAgIGlmICgoIWxvdy5vcGVyYXRvciB8fCBsb3cub3BlcmF0b3IgPT09IGNvbXApICYmIGx0ZWZuKHZlcnNpb24sIGxvdy5zZW12ZXIpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChsb3cub3BlcmF0b3IgPT09IGVjb21wICYmIGx0Zm4odmVyc2lvbiwgbG93LnNlbXZlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0cy5wcmVyZWxlYXNlID0gcHJlcmVsZWFzZTtcblxuZnVuY3Rpb24gcHJlcmVsZWFzZSh2ZXJzaW9uLCBvcHRpb25zKSB7XG4gIHZhciBwYXJzZWQgPSBwYXJzZSh2ZXJzaW9uLCBvcHRpb25zKTtcbiAgcmV0dXJuIHBhcnNlZCAmJiBwYXJzZWQucHJlcmVsZWFzZS5sZW5ndGggPyBwYXJzZWQucHJlcmVsZWFzZSA6IG51bGw7XG59XG5cbmV4cG9ydHMuaW50ZXJzZWN0cyA9IGludGVyc2VjdHM7XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMocjEsIHIyLCBvcHRpb25zKSB7XG4gIHIxID0gbmV3IFJhbmdlKHIxLCBvcHRpb25zKTtcbiAgcjIgPSBuZXcgUmFuZ2UocjIsIG9wdGlvbnMpO1xuICByZXR1cm4gcjEuaW50ZXJzZWN0cyhyMik7XG59XG5cbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuXG5mdW5jdGlvbiBjb2VyY2UodmVyc2lvbiwgb3B0aW9ucykge1xuICBpZiAodmVyc2lvbiBpbnN0YW5jZW9mIFNlbVZlcikge1xuICAgIHJldHVybiB2ZXJzaW9uO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2ZXJzaW9uID09PSAnbnVtYmVyJykge1xuICAgIHZlcnNpb24gPSBTdHJpbmcodmVyc2lvbik7XG4gIH1cblxuICBpZiAodHlwZW9mIHZlcnNpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG1hdGNoID0gbnVsbDtcblxuICBpZiAoIW9wdGlvbnMucnRsKSB7XG4gICAgbWF0Y2ggPSB2ZXJzaW9uLm1hdGNoKHJlW3QuQ09FUkNFXSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRmluZCB0aGUgcmlnaHQtbW9zdCBjb2VyY2libGUgc3RyaW5nIHRoYXQgZG9lcyBub3Qgc2hhcmVcbiAgICAvLyBhIHRlcm1pbnVzIHdpdGggYSBtb3JlIGxlZnQtd2FyZCBjb2VyY2libGUgc3RyaW5nLlxuICAgIC8vIEVnLCAnMS4yLjMuNCcgd2FudHMgdG8gY29lcmNlICcyLjMuNCcsIG5vdCAnMy40JyBvciAnNCdcbiAgICAvL1xuICAgIC8vIFdhbGsgdGhyb3VnaCB0aGUgc3RyaW5nIGNoZWNraW5nIHdpdGggYSAvZyByZWdleHBcbiAgICAvLyBNYW51YWxseSBzZXQgdGhlIGluZGV4IHNvIGFzIHRvIHBpY2sgdXAgb3ZlcmxhcHBpbmcgbWF0Y2hlcy5cbiAgICAvLyBTdG9wIHdoZW4gd2UgZ2V0IGEgbWF0Y2ggdGhhdCBlbmRzIGF0IHRoZSBzdHJpbmcgZW5kLCBzaW5jZSBub1xuICAgIC8vIGNvZXJjaWJsZSBzdHJpbmcgY2FuIGJlIG1vcmUgcmlnaHQtd2FyZCB3aXRob3V0IHRoZSBzYW1lIHRlcm1pbnVzLlxuICAgIHZhciBuZXh0O1xuXG4gICAgd2hpbGUgKChuZXh0ID0gcmVbdC5DT0VSQ0VSVExdLmV4ZWModmVyc2lvbikpICYmICghbWF0Y2ggfHwgbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggIT09IHZlcnNpb24ubGVuZ3RoKSkge1xuICAgICAgaWYgKCFtYXRjaCB8fCBuZXh0LmluZGV4ICsgbmV4dFswXS5sZW5ndGggIT09IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKSB7XG4gICAgICAgIG1hdGNoID0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgcmVbdC5DT0VSQ0VSVExdLmxhc3RJbmRleCA9IG5leHQuaW5kZXggKyBuZXh0WzFdLmxlbmd0aCArIG5leHRbMl0ubGVuZ3RoO1xuICAgIH0gLy8gbGVhdmUgaXQgaW4gYSBjbGVhbiBzdGF0ZVxuXG5cbiAgICByZVt0LkNPRVJDRVJUTF0ubGFzdEluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBwYXJzZShtYXRjaFsyXSArICcuJyArIChtYXRjaFszXSB8fCAnMCcpICsgJy4nICsgKG1hdGNoWzRdIHx8ICcwJyksIG9wdGlvbnMpO1xufVxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNSkpKVxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge2Z1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHRoZSBgVHlwZUVycm9yYCBtZXNzYWdlIGZvciBcIkZ1bmN0aW9uc1wiIG1ldGhvZHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG5cbnZhciBOQU4gPSAwIC8gMDtcbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cblxudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cblxudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cblxudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cblxudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cblxudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xuXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xuXG52YXIgZnJlZUdsb2JhbCA9ICh0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoZ2xvYmFsKSkgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuXG52YXIgZnJlZVNlbGYgPSAodHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihzZWxmKSkgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cblxudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG5cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG5cbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xuXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG5cbnZhciBub3cgPSBmdW5jdGlvbiBub3coKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAqIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdhc1xuICogaW52b2tlZC4gVGhlIGRlYm91bmNlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGAgbWV0aG9kIHRvIGNhbmNlbFxuICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gKiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYCBzaG91bGQgYmUgaW52b2tlZCBvbiB0aGVcbiAqIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YCB0aW1lb3V0LiBUaGUgYGZ1bmNgIGlzIGludm9rZWRcbiAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAqIGNhbGxzIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgXG4gKiBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4V2FpdF1cbiAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIF8uZGVib3VuY2UoY2FsY3VsYXRlTGF5b3V0LCAxNTApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCBfLmRlYm91bmNlKHNlbmRNYWlsLCAzMDAsIHtcbiAqICAgJ2xlYWRpbmcnOiB0cnVlLFxuICogICAndHJhaWxpbmcnOiBmYWxzZVxuICogfSkpO1xuICpcbiAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gKiB2YXIgZGVib3VuY2VkID0gXy5kZWJvdW5jZShiYXRjaExvZywgMjUwLCB7ICdtYXhXYWl0JzogMTAwMCB9KTtcbiAqIHZhciBzb3VyY2UgPSBuZXcgRXZlbnRTb3VyY2UoJy9zdHJlYW0nKTtcbiAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAqXG4gKiAvLyBDYW5jZWwgdGhlIHRyYWlsaW5nIGRlYm91bmNlZCBpbnZvY2F0aW9uLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gKi9cblxuXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuXG4gIHdhaXQgPSB0b051bWJlcih3YWl0KSB8fCAwO1xuXG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gbGVhZGluZ0VkZ2UodGltZSkge1xuICAgIC8vIFJlc2V0IGFueSBgbWF4V2FpdGAgdGltZXIuXG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lOyAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuXG4gICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTsgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG5cbiAgICByZXR1cm4gbGVhZGluZyA/IGludm9rZUZ1bmModGltZSkgOiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lLFxuICAgICAgICByZXN1bHQgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG4gICAgcmV0dXJuIG1heGluZyA/IG5hdGl2ZU1pbihyZXN1bHQsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTsgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cblxuICAgIHJldHVybiBsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCB0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0IHx8IHRpbWVTaW5jZUxhc3RDYWxsIDwgMCB8fCBtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0O1xuICB9XG5cbiAgZnVuY3Rpb24gdGltZXJFeHBpcmVkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCk7XG5cbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH0gLy8gUmVzdGFydCB0aGUgdGltZXIuXG5cblxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7IC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAvLyBkZWJvdW5jZWQgYXQgbGVhc3Qgb25jZS5cblxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuXG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG5cbiAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgbGFzdEFyZ3MgPSBsYXN0Q2FsbFRpbWUgPSBsYXN0VGhpcyA9IHRpbWVySWQgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICByZXR1cm4gdGltZXJJZCA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogdHJhaWxpbmdFZGdlKG5vdygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpLFxuICAgICAgICBpc0ludm9raW5nID0gc2hvdWxkSW52b2tlKHRpbWUpO1xuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXhpbmcpIHtcbiAgICAgICAgLy8gSGFuZGxlIGludm9jYXRpb25zIGluIGEgdGlnaHQgbG9vcC5cbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5cblxuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cblxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIHJldHVybiBkZWJvdW5jZShmdW5jLCB3YWl0LCB7XG4gICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICdtYXhXYWl0Jzogd2FpdCxcbiAgICAndHJhaWxpbmcnOiB0cmFpbGluZ1xuICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IF90eXBlb2YodmFsdWUpO1xuXG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gISF2YWx1ZSAmJiBfdHlwZW9mKHZhbHVlKSA9PSAnb2JqZWN0Jztcbn1cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTeW1ib2xgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiBfdHlwZW9mKHZhbHVlKSA9PSAnc3ltYm9sJyB8fCBpc09iamVjdExpa2UodmFsdWUpICYmIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpID09IHN5bWJvbFRhZztcbn1cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5cblxuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG5cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IG90aGVyICsgJycgOiBvdGhlcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuXG4gIHZhbHVlID0gdmFsdWUucmVwbGFjZShyZVRyaW0sICcnKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOCkgOiByZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRocm90dGxlO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNCkpKVxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgZzsgLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcblxuZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KCk7XG5cbnRyeSB7XG4gIC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuICBnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuICAvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuICBpZiAoKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZih3aW5kb3cpKSA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn0gLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTsgLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQoKSB7XG4gIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gIH1cblxuICB0cnkge1xuICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgfVxufSkoKTtcblxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICB9IC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgfSAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG5cblxuICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgfVxuICB9XG59XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBkcmFpbmluZyA9IGZhbHNlO1xuXG4gIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgZHJhaW5RdWV1ZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gIGlmIChkcmFpbmluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICBkcmFpbmluZyA9IHRydWU7XG4gIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG5cbiAgd2hpbGUgKGxlbikge1xuICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgIHF1ZXVlID0gW107XG5cbiAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICB9XG5cbiAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG5cbiAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICB9XG59OyAvLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5cblxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gIHRoaXMuZnVuID0gZnVuO1xuICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xuXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIFtdO1xufTtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAnLyc7XG59O1xuXG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDA7XG59O1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4gLy8gQSBsaW5rZWQgbGlzdCB0byBrZWVwIHRyYWNrIG9mIHJlY2VudGx5LXVzZWQtbmVzc1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBZYWxsaXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIE1BWCA9IFN5bWJvbCgnbWF4Jyk7XG52YXIgTEVOR1RIID0gU3ltYm9sKCdsZW5ndGgnKTtcbnZhciBMRU5HVEhfQ0FMQ1VMQVRPUiA9IFN5bWJvbCgnbGVuZ3RoQ2FsY3VsYXRvcicpO1xudmFyIEFMTE9XX1NUQUxFID0gU3ltYm9sKCdhbGxvd1N0YWxlJyk7XG52YXIgTUFYX0FHRSA9IFN5bWJvbCgnbWF4QWdlJyk7XG52YXIgRElTUE9TRSA9IFN5bWJvbCgnZGlzcG9zZScpO1xudmFyIE5PX0RJU1BPU0VfT05fU0VUID0gU3ltYm9sKCdub0Rpc3Bvc2VPblNldCcpO1xudmFyIExSVV9MSVNUID0gU3ltYm9sKCdscnVMaXN0Jyk7XG52YXIgQ0FDSEUgPSBTeW1ib2woJ2NhY2hlJyk7XG52YXIgVVBEQVRFX0FHRV9PTl9HRVQgPSBTeW1ib2woJ3VwZGF0ZUFnZU9uR2V0Jyk7XG5cbnZhciBuYWl2ZUxlbmd0aCA9IGZ1bmN0aW9uIG5haXZlTGVuZ3RoKCkge1xuICByZXR1cm4gMTtcbn07IC8vIGxydUxpc3QgaXMgYSB5YWxsaXN0IHdoZXJlIHRoZSBoZWFkIGlzIHRoZSB5b3VuZ2VzdFxuLy8gaXRlbSwgYW5kIHRoZSB0YWlsIGlzIHRoZSBvbGRlc3QuICB0aGUgbGlzdCBjb250YWlucyB0aGUgSGl0XG4vLyBvYmplY3RzIGFzIHRoZSBlbnRyaWVzLlxuLy8gRWFjaCBIaXQgb2JqZWN0IGhhcyBhIHJlZmVyZW5jZSB0byBpdHMgWWFsbGlzdC5Ob2RlLiAgVGhpc1xuLy8gbmV2ZXIgY2hhbmdlcy5cbi8vXG4vLyBjYWNoZSBpcyBhIE1hcCAob3IgUHNldWRvTWFwKSB0aGF0IG1hdGNoZXMgdGhlIGtleXMgdG9cbi8vIHRoZSBZYWxsaXN0Lk5vZGUgb2JqZWN0LlxuXG5cbnZhciBMUlVDYWNoZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExSVUNhY2hlKG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTFJVQ2FjaGUpO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnbnVtYmVyJykgb3B0aW9ucyA9IHtcbiAgICAgIG1heDogb3B0aW9uc1xuICAgIH07XG4gICAgaWYgKCFvcHRpb25zKSBvcHRpb25zID0ge307XG4gICAgaWYgKG9wdGlvbnMubWF4ICYmICh0eXBlb2Ygb3B0aW9ucy5tYXggIT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4IDwgMCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcicpOyAvLyBLaW5kIG9mIHdlaXJkIHRvIGhhdmUgYSBkZWZhdWx0IG1heCBvZiBJbmZpbml0eSwgYnV0IG9oIHdlbGwuXG5cbiAgICB2YXIgbWF4ID0gdGhpc1tNQVhdID0gb3B0aW9ucy5tYXggfHwgSW5maW5pdHk7XG4gICAgdmFyIGxjID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGg7XG4gICAgdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl0gPSB0eXBlb2YgbGMgIT09ICdmdW5jdGlvbicgPyBuYWl2ZUxlbmd0aCA6IGxjO1xuICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gb3B0aW9ucy5zdGFsZSB8fCBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy5tYXhBZ2UgJiYgdHlwZW9mIG9wdGlvbnMubWF4QWdlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICB0aGlzW01BWF9BR0VdID0gb3B0aW9ucy5tYXhBZ2UgfHwgMDtcbiAgICB0aGlzW0RJU1BPU0VdID0gb3B0aW9ucy5kaXNwb3NlO1xuICAgIHRoaXNbTk9fRElTUE9TRV9PTl9TRVRdID0gb3B0aW9ucy5ub0Rpc3Bvc2VPblNldCB8fCBmYWxzZTtcbiAgICB0aGlzW1VQREFURV9BR0VfT05fR0VUXSA9IG9wdGlvbnMudXBkYXRlQWdlT25HZXQgfHwgZmFsc2U7XG4gICAgdGhpcy5yZXNldCgpO1xuICB9IC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbWF4IGNoYW5nZXMuXG5cblxuICBfY3JlYXRlQ2xhc3MoTFJVQ2FjaGUsIFt7XG4gICAga2V5OiBcInJmb3JFYWNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJmb3JFYWNoKGZuLCB0aGlzcCkge1xuICAgICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuXG4gICAgICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXY7XG4gICAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKTtcbiAgICAgICAgd2Fsa2VyID0gcHJldjtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9yRWFjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JFYWNoKGZuLCB0aGlzcCkge1xuICAgICAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuXG4gICAgICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzW0xSVV9MSVNUXS5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAgIHZhciBuZXh0ID0gd2Fsa2VyLm5leHQ7XG4gICAgICAgIGZvckVhY2hTdGVwKHRoaXMsIGZuLCB3YWxrZXIsIHRoaXNwKTtcbiAgICAgICAgd2Fsa2VyID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwia2V5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgICAgcmV0dXJuIHRoaXNbTFJVX0xJU1RdLnRvQXJyYXkoKS5tYXAoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsua2V5O1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInZhbHVlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0udG9BcnJheSgpLm1hcChmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gay52YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzW0RJU1BPU0VdICYmIHRoaXNbTFJVX0xJU1RdICYmIHRoaXNbTFJVX0xJU1RdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXNbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXNbQ0FDSEVdID0gbmV3IE1hcCgpOyAvLyBoYXNoIG9mIGl0ZW1zIGJ5IGtleVxuXG4gICAgICB0aGlzW0xSVV9MSVNUXSA9IG5ldyBZYWxsaXN0KCk7IC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcblxuICAgICAgdGhpc1tMRU5HVEhdID0gMDsgLy8gbGVuZ3RoIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR1bXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVtcCgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubWFwKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RhbGUoX3RoaXMyLCBoaXQpID8gZmFsc2UgOiB7XG4gICAgICAgICAgazogaGl0LmtleSxcbiAgICAgICAgICB2OiBoaXQudmFsdWUsXG4gICAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICAgIH07XG4gICAgICB9KS50b0FycmF5KCkuZmlsdGVyKGZ1bmN0aW9uIChoKSB7XG4gICAgICAgIHJldHVybiBoO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImR1bXBMcnVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHVtcExydSgpIHtcbiAgICAgIHJldHVybiB0aGlzW0xSVV9MSVNUXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgICAgIG1heEFnZSA9IG1heEFnZSB8fCB0aGlzW01BWF9BR0VdO1xuICAgICAgaWYgKG1heEFnZSAmJiB0eXBlb2YgbWF4QWdlICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSh2YWx1ZSwga2V5KTtcblxuICAgICAgaWYgKHRoaXNbQ0FDSEVdLmhhcyhrZXkpKSB7XG4gICAgICAgIGlmIChsZW4gPiB0aGlzW01BWF0pIHtcbiAgICAgICAgICBfZGVsKHRoaXMsIHRoaXNbQ0FDSEVdLmdldChrZXkpKTtcblxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBub2RlID0gdGhpc1tDQUNIRV0uZ2V0KGtleSk7XG4gICAgICAgIHZhciBpdGVtID0gbm9kZS52YWx1ZTsgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICAgICAgLy8gc3BsaXQgb3V0IGludG8gMiBpZnMgZm9yIGJldHRlciBjb3ZlcmFnZSB0cmFja2luZ1xuXG4gICAgICAgIGlmICh0aGlzW0RJU1BPU0VdKSB7XG4gICAgICAgICAgaWYgKCF0aGlzW05PX0RJU1BPU0VfT05fU0VUXSkgdGhpc1tESVNQT1NFXShrZXksIGl0ZW0udmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaXRlbS5ub3cgPSBub3c7XG4gICAgICAgIGl0ZW0ubWF4QWdlID0gbWF4QWdlO1xuICAgICAgICBpdGVtLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXNbTEVOR1RIXSArPSBsZW4gLSBpdGVtLmxlbmd0aDtcbiAgICAgICAgaXRlbS5sZW5ndGggPSBsZW47XG4gICAgICAgIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgIHRyaW0odGhpcyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGl0ID0gbmV3IEVudHJ5KGtleSwgdmFsdWUsIGxlbiwgbm93LCBtYXhBZ2UpOyAvLyBvdmVyc2l6ZWQgb2JqZWN0cyBmYWxsIG91dCBvZiBjYWNoZSBhdXRvbWF0aWNhbGx5LlxuXG4gICAgICBpZiAoaGl0Lmxlbmd0aCA+IHRoaXNbTUFYXSkge1xuICAgICAgICBpZiAodGhpc1tESVNQT1NFXSkgdGhpc1tESVNQT1NFXShrZXksIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzW0xFTkdUSF0gKz0gaGl0Lmxlbmd0aDtcbiAgICAgIHRoaXNbTFJVX0xJU1RdLnVuc2hpZnQoaGl0KTtcbiAgICAgIHRoaXNbQ0FDSEVdLnNldChrZXksIHRoaXNbTFJVX0xJU1RdLmhlYWQpO1xuICAgICAgdHJpbSh0aGlzKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgaWYgKCF0aGlzW0NBQ0hFXS5oYXMoa2V5KSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdmFyIGhpdCA9IHRoaXNbQ0FDSEVdLmdldChrZXkpLnZhbHVlO1xuICAgICAgcmV0dXJuICFpc1N0YWxlKHRoaXMsIGhpdCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICByZXR1cm4gX2dldCh0aGlzLCBrZXksIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwZWVrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBlZWsoa2V5KSB7XG4gICAgICByZXR1cm4gX2dldCh0aGlzLCBrZXksIGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicG9wXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBvcCgpIHtcbiAgICAgIHZhciBub2RlID0gdGhpc1tMUlVfTElTVF0udGFpbDtcbiAgICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG5cbiAgICAgIF9kZWwodGhpcywgbm9kZSk7XG5cbiAgICAgIHJldHVybiBub2RlLnZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVsKGtleSkge1xuICAgICAgX2RlbCh0aGlzLCB0aGlzW0NBQ0hFXS5nZXQoa2V5KSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZChhcnIpIHtcbiAgICAgIC8vIHJlc2V0IHRoZSBjYWNoZVxuICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7IC8vIEEgcHJldmlvdXMgc2VyaWFsaXplZCBjYWNoZSBoYXMgdGhlIG1vc3QgcmVjZW50IGl0ZW1zIGZpcnN0XG5cbiAgICAgIGZvciAodmFyIGwgPSBhcnIubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICAgICAgdmFyIGhpdCA9IGFycltsXTtcbiAgICAgICAgdmFyIGV4cGlyZXNBdCA9IGhpdC5lIHx8IDA7XG4gICAgICAgIGlmIChleHBpcmVzQXQgPT09IDApIC8vIHRoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICAgICAgdGhpcy5zZXQoaGl0LmssIGhpdC52KTtlbHNlIHtcbiAgICAgICAgICB2YXIgbWF4QWdlID0gZXhwaXJlc0F0IC0gbm93OyAvLyBkb250IGFkZCBhbHJlYWR5IGV4cGlyZWQgaXRlbXNcblxuICAgICAgICAgIGlmIChtYXhBZ2UgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYsIG1heEFnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBydW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBydW5lKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXNbQ0FDSEVdLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXQoX3RoaXMzLCBrZXksIGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJtYXhcIixcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChtTCkge1xuICAgICAgaWYgKHR5cGVvZiBtTCAhPT0gJ251bWJlcicgfHwgbUwgPCAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXggbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXInKTtcbiAgICAgIHRoaXNbTUFYXSA9IG1MIHx8IEluZmluaXR5O1xuICAgICAgdHJpbSh0aGlzKTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbTUFYXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWxsb3dTdGFsZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGFsbG93U3RhbGUpIHtcbiAgICAgIHRoaXNbQUxMT1dfU1RBTEVdID0gISFhbGxvd1N0YWxlO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tBTExPV19TVEFMRV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm1heEFnZVwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG1BKSB7XG4gICAgICBpZiAodHlwZW9mIG1BICE9PSAnbnVtYmVyJykgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4QWdlIG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgICB0aGlzW01BWF9BR0VdID0gbUE7XG4gICAgICB0cmltKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tNQVhfQUdFXTtcbiAgICB9IC8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwibGVuZ3RoQ2FsY3VsYXRvclwiLFxuICAgIHNldDogZnVuY3Rpb24gc2V0KGxDKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHR5cGVvZiBsQyAhPT0gJ2Z1bmN0aW9uJykgbEMgPSBuYWl2ZUxlbmd0aDtcblxuICAgICAgaWYgKGxDICE9PSB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSkge1xuICAgICAgICB0aGlzW0xFTkdUSF9DQUxDVUxBVE9SXSA9IGxDO1xuICAgICAgICB0aGlzW0xFTkdUSF0gPSAwO1xuICAgICAgICB0aGlzW0xSVV9MSVNUXS5mb3JFYWNoKGZ1bmN0aW9uIChoaXQpIHtcbiAgICAgICAgICBoaXQubGVuZ3RoID0gX3RoaXM0W0xFTkdUSF9DQUxDVUxBVE9SXShoaXQudmFsdWUsIGhpdC5rZXkpO1xuICAgICAgICAgIF90aGlzNFtMRU5HVEhdICs9IGhpdC5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0cmltKHRoaXMpO1xuICAgIH0sXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMRU5HVEhfQ0FMQ1VMQVRPUl07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbTEVOR1RIXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXRlbUNvdW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpc1tMUlVfTElTVF0ubGVuZ3RoO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMUlVDYWNoZTtcbn0oKTtcblxudmFyIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHNlbGYsIGtleSwgZG9Vc2UpIHtcbiAgdmFyIG5vZGUgPSBzZWxmW0NBQ0hFXS5nZXQoa2V5KTtcblxuICBpZiAobm9kZSkge1xuICAgIHZhciBoaXQgPSBub2RlLnZhbHVlO1xuXG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgX2RlbChzZWxmLCBub2RlKTtcblxuICAgICAgaWYgKCFzZWxmW0FMTE9XX1NUQUxFXSkgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRvVXNlKSB7XG4gICAgICAgIGlmIChzZWxmW1VQREFURV9BR0VfT05fR0VUXSkgbm9kZS52YWx1ZS5ub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBzZWxmW0xSVV9MSVNUXS51bnNoaWZ0Tm9kZShub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaGl0LnZhbHVlO1xuICB9XG59O1xuXG52YXIgaXNTdGFsZSA9IGZ1bmN0aW9uIGlzU3RhbGUoc2VsZiwgaGl0KSB7XG4gIGlmICghaGl0IHx8ICFoaXQubWF4QWdlICYmICFzZWxmW01BWF9BR0VdKSByZXR1cm4gZmFsc2U7XG4gIHZhciBkaWZmID0gRGF0ZS5ub3coKSAtIGhpdC5ub3c7XG4gIHJldHVybiBoaXQubWF4QWdlID8gZGlmZiA+IGhpdC5tYXhBZ2UgOiBzZWxmW01BWF9BR0VdICYmIGRpZmYgPiBzZWxmW01BWF9BR0VdO1xufTtcblxudmFyIHRyaW0gPSBmdW5jdGlvbiB0cmltKHNlbGYpIHtcbiAgaWYgKHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSkge1xuICAgIGZvciAodmFyIHdhbGtlciA9IHNlbGZbTFJVX0xJU1RdLnRhaWw7IHNlbGZbTEVOR1RIXSA+IHNlbGZbTUFYXSAmJiB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgICAvLyBXZSBrbm93IHRoYXQgd2UncmUgYWJvdXQgdG8gZGVsZXRlIHRoaXMgb25lLCBhbmQgYWxzb1xuICAgICAgLy8gd2hhdCB0aGUgbmV4dCBsZWFzdCByZWNlbnRseSB1c2VkIGtleSB3aWxsIGJlLCBzbyBqdXN0XG4gICAgICAvLyBnbyBhaGVhZCBhbmQgc2V0IGl0IG5vdy5cbiAgICAgIHZhciBwcmV2ID0gd2Fsa2VyLnByZXY7XG5cbiAgICAgIF9kZWwoc2VsZiwgd2Fsa2VyKTtcblxuICAgICAgd2Fsa2VyID0gcHJldjtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBfZGVsID0gZnVuY3Rpb24gX2RlbChzZWxmLCBub2RlKSB7XG4gIGlmIChub2RlKSB7XG4gICAgdmFyIGhpdCA9IG5vZGUudmFsdWU7XG4gICAgaWYgKHNlbGZbRElTUE9TRV0pIHNlbGZbRElTUE9TRV0oaGl0LmtleSwgaGl0LnZhbHVlKTtcbiAgICBzZWxmW0xFTkdUSF0gLT0gaGl0Lmxlbmd0aDtcbiAgICBzZWxmW0NBQ0hFXS5kZWxldGUoaGl0LmtleSk7XG4gICAgc2VsZltMUlVfTElTVF0ucmVtb3ZlTm9kZShub2RlKTtcbiAgfVxufTtcblxudmFyIEVudHJ5ID0gZnVuY3Rpb24gRW50cnkoa2V5LCB2YWx1ZSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW50cnkpO1xuXG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICB0aGlzLm5vdyA9IG5vdztcbiAgdGhpcy5tYXhBZ2UgPSBtYXhBZ2UgfHwgMDtcbn07XG5cbnZhciBmb3JFYWNoU3RlcCA9IGZ1bmN0aW9uIGZvckVhY2hTdGVwKHNlbGYsIGZuLCBub2RlLCB0aGlzcCkge1xuICB2YXIgaGl0ID0gbm9kZS52YWx1ZTtcblxuICBpZiAoaXNTdGFsZShzZWxmLCBoaXQpKSB7XG4gICAgX2RlbChzZWxmLCBub2RlKTtcblxuICAgIGlmICghc2VsZltBTExPV19TVEFMRV0pIGhpdCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmIChoaXQpIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgc2VsZik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExSVUNhY2hlO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKHNldEltbWVkaWF0ZSkge2Z1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuLy8gIEltcG9ydCBzdXBwb3J0IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzNjczMzQ2L3N1cHBvcnRpbmctYm90aC1jb21tb25qcy1hbmQtYW1kXG4oZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcbiAgaWYgKHRydWUpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGRlZmluaXRpb24oKTtcbiAgfSBlbHNlIHt9XG59KShcImNsaXBib2FyZFwiLCBmdW5jdGlvbiAoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8ICFkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY2xpcGJvYXJkID0ge307XG5cbiAgY2xpcGJvYXJkLmNvcHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pbnRlcmNlcHQgPSBmYWxzZTtcbiAgICB2YXIgX2RhdGEgPSBudWxsOyAvLyBNYXAgZnJvbSBkYXRhIHR5cGUgKGUuZy4gXCJ0ZXh0L2h0bWxcIikgdG8gdmFsdWUuXG5cbiAgICB2YXIgX2JvZ3VzU2VsZWN0aW9uID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgX2ludGVyY2VwdCA9IGZhbHNlO1xuICAgICAgX2RhdGEgPSBudWxsO1xuXG4gICAgICBpZiAoX2JvZ3VzU2VsZWN0aW9uKSB7XG4gICAgICAgIHdpbmRvdy5nZXRTZWxlY3Rpb24oKS5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIH1cblxuICAgICAgX2JvZ3VzU2VsZWN0aW9uID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfaW50ZXJjZXB0KSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBfZGF0YSkge1xuICAgICAgICAgIGUuY2xpcGJvYXJkRGF0YS5zZXREYXRhKGtleSwgX2RhdGFba2V5XSk7XG4gICAgICAgIH1cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7IC8vIFdvcmthcm91bmQgZm9yIFNhZmFyaTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NjUyOVxuXG4gICAgZnVuY3Rpb24gYm9ndXNTZWxlY3QoKSB7XG4gICAgICB2YXIgc2VsID0gZG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7IC8vIElmIFwibm90aGluZ1wiIGlzIHNlbGVjdGVkLi4uXG5cbiAgICAgIGlmICghZG9jdW1lbnQucXVlcnlDb21tYW5kRW5hYmxlZChcImNvcHlcIikgJiYgc2VsLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgIC8vIC4uLiB0ZW1wb3JhcmlseSBzZWxlY3QgdGhlIGVudGlyZSBib2R5LlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBzZWxlY3QgdGhlIGVudGlyZSBib2R5IGJlY2F1c2U6XG4gICAgICAgIC8vIC0gaXQncyBndWFyYW50ZWVkIHRvIGV4aXN0LFxuICAgICAgICAvLyAtIGl0IHdvcmtzICh1bmxpa2UsIHNheSwgZG9jdW1lbnQuaGVhZCwgb3IgcGhhbnRvbSBlbGVtZW50IHRoYXQgaXNcbiAgICAgICAgLy8gICBub3QgaW5zZXJ0ZWQgaW50byB0aGUgRE9NKSxcbiAgICAgICAgLy8gLSBpdCBkb2Vzbid0IHNlZW0gdG8gZmxpY2tlciAoZHVlIHRvIHRoZSBzeW5jaHJvbm91cyBjb3B5IGV2ZW50KSwgYW5kXG4gICAgICAgIC8vIC0gaXQgYXZvaWRzIG1vZGlmeWluZyB0aGUgRE9NIChjYW4gdHJpZ2dlciBtdXRhdGlvbiBvYnNlcnZlcnMpLlxuICAgICAgICAvL1xuICAgICAgICAvLyBCZWNhdXNlIHdlIGNhbid0IGRvIHByb3BlciBmZWF0dXJlIGRldGVjdGlvbiAod2UgYWxyZWFkeSBjaGVja2VkXG4gICAgICAgIC8vIGRvY3VtZW50LnF1ZXJ5Q29tbWFuZEVuYWJsZWQoXCJjb3B5XCIpICwgd2hpY2ggYWN0dWFsbHkgZ2l2ZXMgYSBmYWxzZVxuICAgICAgICAvLyBuZWdhdGl2ZSBmb3IgQmxpbmsgd2hlbiBub3RoaW5nIGlzIHNlbGVjdGVkKSBhbmQgVUEgc25pZmZpbmcgaXMgbm90XG4gICAgICAgIC8vIHJlbGlhYmxlIChhIGxvdCBvZiBVQSBzdHJpbmdzIGNvbnRhaW4gXCJTYWZhcmlcIiksIHRoaXMgd2lsbCBhbHNvXG4gICAgICAgIC8vIGhhcHBlbiBmb3Igc29tZSBicm93c2VycyBvdGhlciB0aGFuIFNhZmFyaS4gOi0oKVxuICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgX2JvZ3VzU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBfaW50ZXJjZXB0ID0gdHJ1ZTtcblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBfZGF0YSA9IHtcbiAgICAgICAgICAgIFwidGV4dC9wbGFpblwiOiBkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIF9kYXRhID0ge1xuICAgICAgICAgICAgXCJ0ZXh0L2h0bWxcIjogbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhkYXRhKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIF9kYXRhID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QoXCJJbnZhbGlkIGRhdGEgdHlwZS4gTXVzdCBiZSBzdHJpbmcsIERPTSBub2RlLCBvciBhbiBvYmplY3QgbWFwcGluZyBNSU1FIHR5cGVzIHRvIHN0cmluZ3MuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdHJpZ2dlckNvcHkodHJ5Qm9ndXNTZWxlY3QpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY29weVwiKSkge1xuICAgICAgICAgICAgICAvLyBkb2N1bWVudC5leGVjQ29tbWFuZCBpcyBzeW5jaHJvbm91czogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC1jbGlwYm9hcmQtYXBpcy0yMDE1MDQyMS8jaW50ZWdyYXRpb24td2l0aC1yaWNoLXRleHQtZWRpdGluZy1hcGlzXG4gICAgICAgICAgICAgIC8vIFNvIHdlIGNhbiBjYWxsIHJlc29sdmUoKSBiYWNrIGhlcmUuXG4gICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF0cnlCb2d1c1NlbGVjdCkge1xuICAgICAgICAgICAgICAgIGJvZ3VzU2VsZWN0KCk7XG4gICAgICAgICAgICAgICAgdHJpZ2dlckNvcHkodHJ1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb3B5LiBQZXJoYXBzIGl0J3Mgbm90IGF2YWlsYWJsZSBpbiB5b3VyIGJyb3dzZXI/XCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRyaWdnZXJDb3B5KGZhbHNlKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0oKTtcblxuICBjbGlwYm9hcmQucGFzdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9pbnRlcmNlcHQgPSBmYWxzZTtcblxuICAgIHZhciBfcmVzb2x2ZTtcblxuICAgIHZhciBfZGF0YVR5cGU7XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChfaW50ZXJjZXB0KSB7XG4gICAgICAgIF9pbnRlcmNlcHQgPSBmYWxzZTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgcmVzb2x2ZSA9IF9yZXNvbHZlO1xuICAgICAgICBfcmVzb2x2ZSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoZS5jbGlwYm9hcmREYXRhLmdldERhdGEoX2RhdGFUeXBlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRhVHlwZSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgX2ludGVyY2VwdCA9IHRydWU7XG4gICAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgX2RhdGFUeXBlID0gZGF0YVR5cGUgfHwgXCJ0ZXh0L3BsYWluXCI7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmV4ZWNDb21tYW5kKFwicGFzdGVcIikpIHtcbiAgICAgICAgICAgIF9pbnRlcmNlcHQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJVbmFibGUgdG8gcGFzdGUuIFBhc3Rpbmcgb25seSB3b3JrcyBpbiBJbnRlcm5ldCBFeHBsb3JlciBhdCB0aGUgbW9tZW50LlwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX2ludGVyY2VwdCA9IGZhbHNlO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9KCk7IC8vIEhhbmRsZSBJRSBiZWhhdmlvdXIuXG5cblxuICBpZiAodHlwZW9mIENsaXBib2FyZEV2ZW50ID09PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiB3aW5kb3cuY2xpcGJvYXJkRGF0YSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2Ygd2luZG93LmNsaXBib2FyZERhdGEuc2V0RGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIC8qISBwcm9taXNlLXBvbHlmaWxsIDIuMC4xICovXG4gICAgKGZ1bmN0aW9uIChhKSB7XG4gICAgICBmdW5jdGlvbiBiKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBhLmFwcGx5KGIsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGMoYSkge1xuICAgICAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHRoaXMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJvbWlzZXMgbXVzdCBiZSBjb25zdHJ1Y3RlZCB2aWEgbmV3XCIpO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBhKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwibm90IGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gbnVsbCwgdGhpcy5fdmFsdWUgPSBudWxsLCB0aGlzLl9kZWZlcnJlZHMgPSBbXSwgaShhLCBiKGUsIHRoaXMpLCBiKGYsIHRoaXMpKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZChhKSB7XG4gICAgICAgIHZhciBiID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG51bGwgPT09IHRoaXMuX3N0YXRlID8gdm9pZCB0aGlzLl9kZWZlcnJlZHMucHVzaChhKSA6IHZvaWQgaihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGMgPSBiLl9zdGF0ZSA/IGEub25GdWxmaWxsZWQgOiBhLm9uUmVqZWN0ZWQ7XG4gICAgICAgICAgaWYgKG51bGwgPT09IGMpIHJldHVybiB2b2lkIChiLl9zdGF0ZSA/IGEucmVzb2x2ZSA6IGEucmVqZWN0KShiLl92YWx1ZSk7XG4gICAgICAgICAgdmFyIGQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZCA9IGMoYi5fdmFsdWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2lkIGEucmVqZWN0KGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGEucmVzb2x2ZShkKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGUoYSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChhID09PSB0aGlzKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi5cIik7XG5cbiAgICAgICAgICBpZiAoYSAmJiAoXCJvYmplY3RcIiA9PSBfdHlwZW9mKGEpIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYSkpIHtcbiAgICAgICAgICAgIHZhciBjID0gYS50aGVuO1xuICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgYykgcmV0dXJuIHZvaWQgaShiKGMsIGEpLCBiKGUsIHRoaXMpLCBiKGYsIHRoaXMpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9ICEwLCB0aGlzLl92YWx1ZSA9IGEsIGcuY2FsbCh0aGlzKTtcbiAgICAgICAgfSBjYXRjaCAoZCkge1xuICAgICAgICAgIGYuY2FsbCh0aGlzLCBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmKGEpIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSAhMSwgdGhpcy5fdmFsdWUgPSBhLCBnLmNhbGwodGhpcyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIGZvciAodmFyIGEgPSAwLCBiID0gdGhpcy5fZGVmZXJyZWRzLmxlbmd0aDsgYiA+IGE7IGErKykge1xuICAgICAgICAgIGQuY2FsbCh0aGlzLCB0aGlzLl9kZWZlcnJlZHNbYV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZGVmZXJyZWRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaChhLCBiLCBjLCBkKSB7XG4gICAgICAgIHRoaXMub25GdWxmaWxsZWQgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGEgPyBhIDogbnVsbCwgdGhpcy5vblJlamVjdGVkID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBiID8gYiA6IG51bGwsIHRoaXMucmVzb2x2ZSA9IGMsIHRoaXMucmVqZWN0ID0gZDtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaShhLCBiLCBjKSB7XG4gICAgICAgIHZhciBkID0gITE7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBhKGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkIHx8IChkID0gITAsIGIoYSkpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgICAgICBkIHx8IChkID0gITAsIGMoYSkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGQpIHJldHVybjtcbiAgICAgICAgICBkID0gITAsIGMoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGogPSBjLmltbWVkaWF0ZUZuIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygc2V0SW1tZWRpYXRlICYmIHNldEltbWVkaWF0ZSB8fCBmdW5jdGlvbiAoYSkge1xuICAgICAgICBzZXRUaW1lb3V0KGEsIDEpO1xuICAgICAgfSxcbiAgICAgICAgICBrID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gXCJbb2JqZWN0IEFycmF5XVwiID09PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSk7XG4gICAgICB9O1xuXG4gICAgICBjLnByb3RvdHlwZVtcImNhdGNoXCJdID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbihudWxsLCBhKTtcbiAgICAgIH0sIGMucHJvdG90eXBlLnRoZW4gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBuZXcgYyhmdW5jdGlvbiAoYywgZikge1xuICAgICAgICAgIGQuY2FsbChlLCBuZXcgaChhLCBiLCBjLCBmKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgYy5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoMSA9PT0gYXJndW1lbnRzLmxlbmd0aCAmJiBrKGFyZ3VtZW50c1swXSkgPyBhcmd1bWVudHNbMF0gOiBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gbmV3IGMoZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICBmdW5jdGlvbiBkKGYsIGcpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGlmIChnICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZykgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBnKSkge1xuICAgICAgICAgICAgICAgIHZhciBoID0gZy50aGVuO1xuICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGgpIHJldHVybiB2b2lkIGguY2FsbChnLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgICAgZChmLCBhKTtcbiAgICAgICAgICAgICAgICB9LCBjKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFbZl0gPSBnLCAwID09PSAtLWUgJiYgYihhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgICAgICAgYyhpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoMCA9PT0gYS5sZW5ndGgpIHJldHVybiBiKFtdKTtcblxuICAgICAgICAgIGZvciAodmFyIGUgPSBhLmxlbmd0aCwgZiA9IDA7IGYgPCBhLmxlbmd0aDsgZisrKSB7XG4gICAgICAgICAgICBkKGYsIGFbZl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9LCBjLnJlc29sdmUgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gYSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YoYSkgJiYgYS5jb25zdHJ1Y3RvciA9PT0gYyA/IGEgOiBuZXcgYyhmdW5jdGlvbiAoYikge1xuICAgICAgICAgIGIoYSk7XG4gICAgICAgIH0pO1xuICAgICAgfSwgYy5yZWplY3QgPSBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gbmV3IGMoZnVuY3Rpb24gKGIsIGMpIHtcbiAgICAgICAgICBjKGEpO1xuICAgICAgICB9KTtcbiAgICAgIH0sIGMucmFjZSA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiBuZXcgYyhmdW5jdGlvbiAoYiwgYykge1xuICAgICAgICAgIGZvciAodmFyIGQgPSAwLCBlID0gYS5sZW5ndGg7IGUgPiBkOyBkKyspIHtcbiAgICAgICAgICAgIGFbZF0udGhlbihiLCBjKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgIHRydWUgJiYgbW9kdWxlLmV4cG9ydHMgPyBtb2R1bGUuZXhwb3J0cyA9IGMgOiBhLlByb21pc2UgfHwgKGEuUHJvbWlzZSA9IGMpO1xuICAgIH0pKHRoaXMpO1xuXG4gICAgY2xpcGJvYXJkLmNvcHkgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgLy8gSUUgc3VwcG9ydHMgc3RyaW5nIGFuZCBVUkwgdHlwZXM6IGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvbXM1MzY3NDQodj12cy44NSkuYXNweFxuICAgICAgICAvLyBXZSBvbmx5IHN1cHBvcnQgdGhlIHN0cmluZyB0eXBlIGZvciBub3cuXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiAmJiAhKFwidGV4dC9wbGFpblwiIGluIGRhdGEpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcHJvdmlkZSBhIHRleHQvcGxhaW4gdHlwZS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RyRGF0YSA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiID8gZGF0YSA6IGRhdGFbXCJ0ZXh0L3BsYWluXCJdO1xuICAgICAgICB2YXIgY29weVN1Y2NlZWRlZCA9IHdpbmRvdy5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsIHN0ckRhdGEpO1xuXG4gICAgICAgIGlmIChjb3B5U3VjY2VlZGVkKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDb3B5aW5nIHdhcyByZWplY3RlZC5cIikpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgY2xpcGJvYXJkLnBhc3RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHN0ckRhdGEgPSB3aW5kb3cuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwiVGV4dFwiKTtcblxuICAgICAgICBpZiAoc3RyRGF0YSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyRGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGhlIHVzZXIgcmVqZWN0ZWQgdGhlIHBhc3RlIHJlcXVlc3QuXG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlBhc3Rpbmcgd2FzIHJlamVjdGVkLlwiKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gY2xpcGJvYXJkO1xufSk7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxMikuc2V0SW1tZWRpYXRlKSlcblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmlmICh0cnVlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG59IGVsc2Uge31cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gWWFsbGlzdDtcbllhbGxpc3QuTm9kZSA9IE5vZGU7XG5ZYWxsaXN0LmNyZWF0ZSA9IFlhbGxpc3Q7XG5cbmZ1bmN0aW9uIFlhbGxpc3QobGlzdCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCEoc2VsZiBpbnN0YW5jZW9mIFlhbGxpc3QpKSB7XG4gICAgc2VsZiA9IG5ldyBZYWxsaXN0KCk7XG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsO1xuICBzZWxmLmhlYWQgPSBudWxsO1xuICBzZWxmLmxlbmd0aCA9IDA7XG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pO1xuICAgIH0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBzZWxmLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmIChub2RlLmxpc3QgIT09IHRoaXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlbW92aW5nIG5vZGUgd2hpY2ggZG9lcyBub3QgYmVsb25nIHRvIHRoaXMgbGlzdCcpO1xuICB9XG5cbiAgdmFyIG5leHQgPSBub2RlLm5leHQ7XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2O1xuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gcHJldjtcbiAgfVxuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXY7XG4gIH1cblxuICBub2RlLmxpc3QubGVuZ3RoLS07XG4gIG5vZGUubmV4dCA9IG51bGw7XG4gIG5vZGUucHJldiA9IG51bGw7XG4gIG5vZGUubGlzdCA9IG51bGw7XG4gIHJldHVybiBuZXh0O1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICB9XG5cbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWQ7XG4gIG5vZGUubGlzdCA9IHRoaXM7XG4gIG5vZGUubmV4dCA9IGhlYWQ7XG5cbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlO1xuICB9XG5cbiAgdGhpcy5oZWFkID0gbm9kZTtcblxuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLmxlbmd0aCsrO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpO1xuICB9XG5cbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWw7XG4gIG5vZGUubGlzdCA9IHRoaXM7XG4gIG5vZGUucHJldiA9IHRhaWw7XG5cbiAgaWYgKHRhaWwpIHtcbiAgICB0YWlsLm5leHQgPSBub2RlO1xuICB9XG5cbiAgdGhpcy50YWlsID0gbm9kZTtcblxuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLmxlbmd0aCsrO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgcHVzaCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMubGVuZ3RoO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudGFpbCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlO1xuICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwucHJldjtcblxuICBpZiAodGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gIH1cblxuICB0aGlzLmxlbmd0aC0tO1xuICByZXR1cm4gcmVzO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWU7XG4gIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuXG4gIGlmICh0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQucHJldiA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgfVxuXG4gIHRoaXMubGVuZ3RoLS07XG4gIHJldHVybiByZXM7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXM7XG5cbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkLCBpID0gMDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpO1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5mb3JFYWNoUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMudGFpbCwgaSA9IHRoaXMubGVuZ3RoIC0gMTsgd2Fsa2VyICE9PSBudWxsOyBpLS0pIHtcbiAgICBmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIGksIHRoaXMpO1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobikge1xuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IG47IGkrKykge1xuICAgIC8vIGFib3J0IG91dCBvZiB0aGUgbGlzdCBlYXJseSBpZiB3ZSBoaXQgYSBjeWNsZVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG5cbiAgaWYgKGkgPT09IG4gJiYgd2Fsa2VyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdhbGtlci52YWx1ZTtcbiAgfVxufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0UmV2ZXJzZSA9IGZ1bmN0aW9uIChuKSB7XG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgbjsgaSsrKSB7XG4gICAgLy8gYWJvcnQgb3V0IG9mIHRoZSBsaXN0IGVhcmx5IGlmIHdlIGhpdCBhIGN5Y2xlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cblxuICBpZiAoaSA9PT0gbiAmJiB3YWxrZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4gd2Fsa2VyLnZhbHVlO1xuICB9XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpcztcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KCk7XG5cbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSk7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUubWFwUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzO1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKTtcblxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoZm4sIGluaXRpYWwpIHtcbiAgdmFyIGFjYztcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZDtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsO1xuICB9IGVsc2UgaWYgKHRoaXMuaGVhZCkge1xuICAgIHdhbGtlciA9IHRoaXMuaGVhZC5uZXh0O1xuICAgIGFjYyA9IHRoaXMuaGVhZC52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuXG4gIHJldHVybiBhY2M7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZWR1Y2VSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2M7XG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWw7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbDtcbiAgfSBlbHNlIGlmICh0aGlzLnRhaWwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWwucHJldjtcbiAgICBhY2MgPSB0aGlzLnRhaWwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJyk7XG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyB3YWxrZXIgIT09IG51bGw7IGktLSkge1xuICAgIGFjYyA9IGZuKGFjYywgd2Fsa2VyLnZhbHVlLCBpKTtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldjtcbiAgfVxuXG4gIHJldHVybiBhY2M7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGw7IGkrKykge1xuICAgIGFycltpXSA9IHdhbGtlci52YWx1ZTtcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgfVxuXG4gIHJldHVybiBhcnI7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS50b0FycmF5UmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWU7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cblxuICByZXR1cm4gYXJyO1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aDtcblxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBmcm9tID0gZnJvbSB8fCAwO1xuXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKTtcblxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMDtcbiAgfVxuXG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgZnJvbTsgaSsrKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHQ7XG4gIH1cblxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCB0bzsgaSsrLCB3YWxrZXIgPSB3YWxrZXIubmV4dCkge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuWWFsbGlzdC5wcm90b3R5cGUuc2xpY2VSZXZlcnNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGg7XG5cbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgZnJvbSA9IGZyb20gfHwgMDtcblxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KCk7XG5cbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDA7XG4gIH1cblxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGg7XG4gIH1cblxuICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGgsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiB0bzsgaS0tKSB7XG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXY7XG4gIH1cblxuICBmb3IgKDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPiBmcm9tOyBpLS0sIHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgcmV0LnB1c2god2Fsa2VyLnZhbHVlKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50XG4vKiwgLi4ubm9kZXMgKi9cbikge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxO1xuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0O1xuICB9XG5cbiAgdmFyIHJldCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyB3YWxrZXIgJiYgaSA8IGRlbGV0ZUNvdW50OyBpKyspIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpO1xuICAgIHdhbGtlciA9IHRoaXMucmVtb3ZlTm9kZSh3YWxrZXIpO1xuICB9XG5cbiAgaWYgKHdhbGtlciA9PT0gbnVsbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbDtcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2O1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB3YWxrZXIgPSBpbnNlcnQodGhpcywgd2Fsa2VyLCBhcmd1bWVudHNbaV0pO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbllhbGxpc3QucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBoZWFkID0gdGhpcy5oZWFkO1xuICB2YXIgdGFpbCA9IHRoaXMudGFpbDtcblxuICBmb3IgKHZhciB3YWxrZXIgPSBoZWFkOyB3YWxrZXIgIT09IG51bGw7IHdhbGtlciA9IHdhbGtlci5wcmV2KSB7XG4gICAgdmFyIHAgPSB3YWxrZXIucHJldjtcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0O1xuICAgIHdhbGtlci5uZXh0ID0gcDtcbiAgfVxuXG4gIHRoaXMuaGVhZCA9IHRhaWw7XG4gIHRoaXMudGFpbCA9IGhlYWQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gaW5zZXJ0KHNlbGYsIG5vZGUsIHZhbHVlKSB7XG4gIHZhciBpbnNlcnRlZCA9IG5vZGUgPT09IHNlbGYuaGVhZCA/IG5ldyBOb2RlKHZhbHVlLCBudWxsLCBub2RlLCBzZWxmKSA6IG5ldyBOb2RlKHZhbHVlLCBub2RlLCBub2RlLm5leHQsIHNlbGYpO1xuXG4gIGlmIChpbnNlcnRlZC5uZXh0ID09PSBudWxsKSB7XG4gICAgc2VsZi50YWlsID0gaW5zZXJ0ZWQ7XG4gIH1cblxuICBpZiAoaW5zZXJ0ZWQucHJldiA9PT0gbnVsbCkge1xuICAgIHNlbGYuaGVhZCA9IGluc2VydGVkO1xuICB9XG5cbiAgc2VsZi5sZW5ndGgrKztcbiAgcmV0dXJuIGluc2VydGVkO1xufVxuXG5mdW5jdGlvbiBwdXNoKHNlbGYsIGl0ZW0pIHtcbiAgc2VsZi50YWlsID0gbmV3IE5vZGUoaXRlbSwgc2VsZi50YWlsLCBudWxsLCBzZWxmKTtcblxuICBpZiAoIXNlbGYuaGVhZCkge1xuICAgIHNlbGYuaGVhZCA9IHNlbGYudGFpbDtcbiAgfVxuXG4gIHNlbGYubGVuZ3RoKys7XG59XG5cbmZ1bmN0aW9uIHVuc2hpZnQoc2VsZiwgaXRlbSkge1xuICBzZWxmLmhlYWQgPSBuZXcgTm9kZShpdGVtLCBudWxsLCBzZWxmLmhlYWQsIHNlbGYpO1xuXG4gIGlmICghc2VsZi50YWlsKSB7XG4gICAgc2VsZi50YWlsID0gc2VsZi5oZWFkO1xuICB9XG5cbiAgc2VsZi5sZW5ndGgrKztcbn1cblxuZnVuY3Rpb24gTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIHByZXYsIG5leHQsIGxpc3QpO1xuICB9XG5cbiAgdGhpcy5saXN0ID0gbGlzdDtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuXG4gIGlmIChwcmV2KSB7XG4gICAgcHJldi5uZXh0ID0gdGhpcztcbiAgICB0aGlzLnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGw7XG4gIH1cblxuICBpZiAobmV4dCkge1xuICAgIG5leHQucHJldiA9IHRoaXM7XG4gICAgdGhpcy5uZXh0ID0gbmV4dDtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsO1xuICB9XG59XG5cbnRyeSB7XG4gIC8vIGFkZCBpZiBzdXBwb3J0IGZvciBTeW1ib2wuaXRlcmF0b3IgaXMgcHJlc2VudFxuICBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKShZYWxsaXN0KTtcbn0gY2F0Y2ggKGVyKSB7fVxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFlhbGxpc3QpIHtcbiAgWWFsbGlzdC5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgIHZhciB3YWxrZXI7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgd2Fsa2VyID0gdGhpcy5oZWFkO1xuXG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgaWYgKCF3YWxrZXIpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgIHJldHVybiB3YWxrZXIudmFsdWU7XG5cbiAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB3YWxrZXIgPSB3YWxrZXIubmV4dDtcbiAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICB9KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQGxpY2Vuc2UgUmVhY3QgdnVuZGVmaW5lZFxuICogcmVhY3QtaXMucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGIgPSA2MDEwMyxcbiAgICBjID0gNjAxMDYsXG4gICAgZCA9IDYwMTA3LFxuICAgIGUgPSA2MDEwOCxcbiAgICBmID0gNjAxMTQsXG4gICAgZyA9IDYwMTA5LFxuICAgIGggPSA2MDExMCxcbiAgICBrID0gNjAxMTIsXG4gICAgbCA9IDYwMTEzLFxuICAgIG0gPSA2MDEyMCxcbiAgICBuID0gNjAxMTUsXG4gICAgcCA9IDYwMTE2LFxuICAgIHEgPSA2MDEyOSxcbiAgICByID0gNjAxMzAsXG4gICAgdSA9IDYwMTMxLFxuICAgIHYgPSA2MDEzMjtcblxuaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciB3ID0gU3ltYm9sLmZvcjtcbiAgYiA9IHcoXCJyZWFjdC5lbGVtZW50XCIpO1xuICBjID0gdyhcInJlYWN0LnBvcnRhbFwiKTtcbiAgZCA9IHcoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgZSA9IHcoXCJyZWFjdC5zdHJpY3RfbW9kZVwiKTtcbiAgZiA9IHcoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgZyA9IHcoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgaCA9IHcoXCJyZWFjdC5jb250ZXh0XCIpO1xuICBrID0gdyhcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xuICBsID0gdyhcInJlYWN0LnN1c3BlbnNlXCIpO1xuICBtID0gdyhcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG4gIG4gPSB3KFwicmVhY3QubWVtb1wiKTtcbiAgcCA9IHcoXCJyZWFjdC5sYXp5XCIpO1xuICBxID0gdyhcInJlYWN0LmRlYnVnX3RyYWNlX21vZGVcIik7XG4gIHIgPSB3KFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xuICB1ID0gdyhcInJlYWN0LmxlZ2FjeV9oaWRkZW5cIik7XG4gIHYgPSB3KFwicmVhY3QuY2FjaGVcIik7XG59XG5cbnZhciB4ID0gMDtcblwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiAoeCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpKTtcblxuZnVuY3Rpb24geShhKSB7XG4gIGlmIChcIm9iamVjdFwiID09PSBfdHlwZW9mKGEpICYmIG51bGwgIT09IGEpIHtcbiAgICB2YXIgdCA9IGEuJCR0eXBlb2Y7XG5cbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgYjpcbiAgICAgICAgc3dpdGNoIChhID0gYS50eXBlLCBhKSB7XG4gICAgICAgICAgY2FzZSBkOlxuICAgICAgICAgIGNhc2UgZjpcbiAgICAgICAgICBjYXNlIGU6XG4gICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgIGNhc2UgbTpcbiAgICAgICAgICAgIHJldHVybiBhO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHN3aXRjaCAoYSA9IGEgJiYgYS4kJHR5cGVvZiwgYSkge1xuICAgICAgICAgICAgICBjYXNlIGg6XG4gICAgICAgICAgICAgIGNhc2UgazpcbiAgICAgICAgICAgICAgY2FzZSBwOlxuICAgICAgICAgICAgICBjYXNlIG46XG4gICAgICAgICAgICAgIGNhc2UgZzpcbiAgICAgICAgICAgICAgICByZXR1cm4gYTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgY2FzZSBjOlxuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gIH1cbn1cblxudmFyIHogPSBnLFxuICAgIEEgPSBiLFxuICAgIEIgPSBrLFxuICAgIEMgPSBkLFxuICAgIEQgPSBwLFxuICAgIEUgPSBuLFxuICAgIEYgPSBjLFxuICAgIEcgPSBmLFxuICAgIEggPSBlLFxuICAgIEkgPSBsLFxuICAgIEogPSBtO1xuZXhwb3J0cy5Db250ZXh0Q29uc3VtZXIgPSBoO1xuZXhwb3J0cy5Db250ZXh0UHJvdmlkZXIgPSB6O1xuZXhwb3J0cy5FbGVtZW50ID0gQTtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEI7XG5leHBvcnRzLkZyYWdtZW50ID0gQztcbmV4cG9ydHMuTGF6eSA9IEQ7XG5leHBvcnRzLk1lbW8gPSBFO1xuZXhwb3J0cy5Qb3J0YWwgPSBGO1xuZXhwb3J0cy5Qcm9maWxlciA9IEc7XG5leHBvcnRzLlN0cmljdE1vZGUgPSBIO1xuZXhwb3J0cy5TdXNwZW5zZSA9IEk7XG5leHBvcnRzLlN1c3BlbnNlTGlzdCA9IEo7XG5cbmV4cG9ydHMuaXNBc3luY01vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiAhMTtcbn07XG5cbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICExO1xufTtcblxuZXhwb3J0cy5pc0NvbnRleHRDb25zdW1lciA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB5KGEpID09PSBoO1xufTtcblxuZXhwb3J0cy5pc0NvbnRleHRQcm92aWRlciA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB5KGEpID09PSBnO1xufTtcblxuZXhwb3J0cy5pc0VsZW1lbnQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiBudWxsICE9PSBhICYmIGEuJCR0eXBlb2YgPT09IGI7XG59O1xuXG5leHBvcnRzLmlzRm9yd2FyZFJlZiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB5KGEpID09PSBrO1xufTtcblxuZXhwb3J0cy5pc0ZyYWdtZW50ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIHkoYSkgPT09IGQ7XG59O1xuXG5leHBvcnRzLmlzTGF6eSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB5KGEpID09PSBwO1xufTtcblxuZXhwb3J0cy5pc01lbW8gPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4geShhKSA9PT0gbjtcbn07XG5cbmV4cG9ydHMuaXNQb3J0YWwgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4geShhKSA9PT0gYztcbn07XG5cbmV4cG9ydHMuaXNQcm9maWxlciA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB5KGEpID09PSBmO1xufTtcblxuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4geShhKSA9PT0gZTtcbn07XG5cbmV4cG9ydHMuaXNTdXNwZW5zZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB5KGEpID09PSBsO1xufTtcblxuZXhwb3J0cy5pc1N1c3BlbnNlTGlzdCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB5KGEpID09PSBtO1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGEgfHwgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYSB8fCBhID09PSBkIHx8IGEgPT09IGYgfHwgYSA9PT0gcSB8fCBhID09PSBlIHx8IGEgPT09IGwgfHwgYSA9PT0gbSB8fCBhID09PSB1IHx8IGEgPT09IHIgfHwgYSA9PT0gdiB8fCBcIm9iamVjdFwiID09PSBfdHlwZW9mKGEpICYmIG51bGwgIT09IGEgJiYgKGEuJCR0eXBlb2YgPT09IHAgfHwgYS4kJHR5cGVvZiA9PT0gbiB8fCBhLiQkdHlwZW9mID09PSBnIHx8IGEuJCR0eXBlb2YgPT09IGggfHwgYS4kJHR5cGVvZiA9PT0gayB8fCBhLiQkdHlwZW9mID09PSB4IHx8IHZvaWQgMCAhPT0gYS5nZXRNb2R1bGVJZCkgPyAhMCA6ICExO1xufTtcblxuZXhwb3J0cy50eXBlT2YgPSB5O1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgc2NvcGUgPSB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbCB8fCB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmIHx8IHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTsgLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5cbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuXG5leHBvcnRzLmNsZWFyVGltZW91dCA9IGV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuXG5UaW1lb3V0LnByb3RvdHlwZS51bnJlZiA9IFRpbWVvdXQucHJvdG90eXBlLnJlZiA9IGZ1bmN0aW9uICgpIHt9O1xuXG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59OyAvLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cblxuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uIChpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG5cbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KSBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07IC8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcblxuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTsgLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cblxuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlIHx8IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCB0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUgfHwgdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUgfHwgdGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNCkpKVxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIHByb2Nlc3MpIHsoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cblxuICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgfSAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuXG5cbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgIH0gLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG5cblxuICAgIHZhciB0YXNrID0ge1xuICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgYXJnczogYXJnc1xuICAgIH07XG4gICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gIH1cblxuICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG5cbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG5cbiAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24gcmVnaXN0ZXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcblxuICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG4gICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcblxuICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbiBvbkdsb2JhbE1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJiB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJiBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICB9XG5cbiAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uIHJlZ2lzdGVySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcblxuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgIH07XG5cbiAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uIHJlZ2lzdGVySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblxuICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24gcmVnaXN0ZXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG5cbiAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24gcmVnaXN0ZXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICB9O1xuICB9IC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuXG5cbiAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDsgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuXG4gIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcbiAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgLy8gRm9yIElFIDbigJM4XG4gICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuICB9IGVsc2Uge1xuICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgfVxuXG4gIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0pKHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpKSlcblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKiBAbGljZW5zZSBSZWFjdCB2dW5kZWZpbmVkXG4gKiByZWFjdC1kZWJ1Zy10b29scy5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgayA9IF9fd2VicGFja19yZXF1aXJlX18oMSksXG4gICAgcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuXG5mdW5jdGlvbiByKGEpIHtcbiAgZm9yICh2YXIgYiA9IFwiaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnQ9XCIgKyBhLCBlID0gMTsgZSA8IGFyZ3VtZW50cy5sZW5ndGg7IGUrKykge1xuICAgIGIgKz0gXCImYXJnc1tdPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tlXSk7XG4gIH1cblxuICByZXR1cm4gXCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIgKyBhICsgXCI7IHZpc2l0IFwiICsgYiArIFwiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIjtcbn1cblxudmFyIHcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCxcbiAgICB4ID0gNjAxMjg7XG5cbmlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBTeW1ib2wgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgeSA9IFN5bWJvbC5mb3I7XG4gIHggPSB5KFwicmVhY3Qub3BhcXVlLmlkXCIpO1xufVxuXG52YXIgeiA9IFtdLFxuICAgIEEgPSBudWxsLFxuICAgIEIgPSBudWxsO1xuXG5mdW5jdGlvbiBDKCkge1xuICBpZiAobnVsbCA9PT0gQSkge1xuICAgIHZhciBhID0gbmV3IE1hcCgpO1xuXG4gICAgdHJ5IHtcbiAgICAgIEQudXNlQ29udGV4dCh7XG4gICAgICAgIF9jdXJyZW50VmFsdWU6IG51bGxcbiAgICAgIH0pLCBELnVzZVN0YXRlKG51bGwpLCBELnVzZVJlZHVjZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9LCBudWxsKSwgRC51c2VSZWYobnVsbCksIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIEQudXNlQ2FjaGVSZWZyZXNoICYmIEQudXNlQ2FjaGVSZWZyZXNoKCksIEQudXNlTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHt9KSwgRC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge30pLCBELnVzZUltcGVyYXRpdmVIYW5kbGUodm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSksIEQudXNlRGVidWdWYWx1ZShudWxsKSwgRC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7fSksIEQudXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHZhciBiID0gejtcbiAgICAgIHogPSBbXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBlID0gMDsgZSA8IGIubGVuZ3RoOyBlKyspIHtcbiAgICAgIHZhciBmID0gYltlXTtcbiAgICAgIGEuc2V0KGYucHJpbWl0aXZlLCBwLnBhcnNlKGYuc3RhY2tFcnJvcikpO1xuICAgIH1cblxuICAgIEEgPSBhO1xuICB9XG5cbiAgcmV0dXJuIEE7XG59XG5cbnZhciBFID0gbnVsbDtcblxuZnVuY3Rpb24gRigpIHtcbiAgdmFyIGEgPSBFO1xuICBudWxsICE9PSBhICYmIChFID0gYS5uZXh0KTtcbiAgcmV0dXJuIGE7XG59XG5cbnZhciBEID0ge1xuICBnZXRDYWNoZUZvclR5cGU6IGZ1bmN0aW9uIGdldENhY2hlRm9yVHlwZSgpIHtcbiAgICB0aHJvdyBFcnJvcihyKDI0OCkpO1xuICB9LFxuICByZWFkQ29udGV4dDogZnVuY3Rpb24gcmVhZENvbnRleHQoYSkge1xuICAgIHJldHVybiBhLl9jdXJyZW50VmFsdWU7XG4gIH0sXG4gIHVzZUNhY2hlUmVmcmVzaDogZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgIHZhciBhID0gRigpO1xuICAgIHoucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiQ2FjaGVSZWZyZXNoXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IG51bGwgIT09IGEgPyBhLm1lbW9pemVkU3RhdGUgOiBmdW5jdGlvbiAoKSB7fVxuICAgIH0pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgfSxcbiAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGEpIHtcbiAgICB2YXIgYiA9IEYoKTtcbiAgICB6LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIkNhbGxiYWNrXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IG51bGwgIT09IGIgPyBiLm1lbW9pemVkU3RhdGVbMF0gOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIHVzZUNvbnRleHQoYSkge1xuICAgIHoucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiQ29udGV4dFwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhLl9jdXJyZW50VmFsdWVcbiAgICB9KTtcbiAgICByZXR1cm4gYS5fY3VycmVudFZhbHVlO1xuICB9LFxuICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIHVzZUVmZmVjdChhKSB7XG4gICAgRigpO1xuICAgIHoucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiRWZmZWN0XCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgfSxcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShhKSB7XG4gICAgRigpO1xuICAgIHZhciBiID0gdm9pZCAwO1xuICAgIG51bGwgIT09IGEgJiYgXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiAoYiA9IGEuY3VycmVudCk7XG4gICAgei5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJJbXBlcmF0aXZlSGFuZGxlXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGJcbiAgICB9KTtcbiAgfSxcbiAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gdXNlRGVidWdWYWx1ZShhLCBiKSB7XG4gICAgei5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJEZWJ1Z1ZhbHVlXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGIgPyBiKGEpIDogYVxuICAgIH0pO1xuICB9LFxuICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChhKSB7XG4gICAgRigpO1xuICAgIHoucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiTGF5b3V0RWZmZWN0XCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgfSxcbiAgdXNlTWVtbzogZnVuY3Rpb24gdXNlTWVtbyhhKSB7XG4gICAgdmFyIGIgPSBGKCk7XG4gICAgYSA9IG51bGwgIT09IGIgPyBiLm1lbW9pemVkU3RhdGVbMF0gOiBhKCk7XG4gICAgei5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJNZW1vXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfSxcbiAgdXNlUmVkdWNlcjogZnVuY3Rpb24gdXNlUmVkdWNlcihhLCBiLCBlKSB7XG4gICAgYSA9IEYoKTtcbiAgICBiID0gbnVsbCAhPT0gYSA/IGEubWVtb2l6ZWRTdGF0ZSA6IHZvaWQgMCAhPT0gZSA/IGUoYikgOiBiO1xuICAgIHoucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiUmVkdWNlclwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBiXG4gICAgfSk7XG4gICAgcmV0dXJuIFtiLCBmdW5jdGlvbiAoKSB7fV07XG4gIH0sXG4gIHVzZVJlZjogZnVuY3Rpb24gdXNlUmVmKGEpIHtcbiAgICB2YXIgYiA9IEYoKTtcbiAgICBhID0gbnVsbCAhPT0gYiA/IGIubWVtb2l6ZWRTdGF0ZSA6IHtcbiAgICAgIGN1cnJlbnQ6IGFcbiAgICB9O1xuICAgIHoucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiUmVmXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGEuY3VycmVudFxuICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9LFxuICB1c2VTdGF0ZTogZnVuY3Rpb24gdXNlU3RhdGUoYSkge1xuICAgIHZhciBiID0gRigpO1xuICAgIGEgPSBudWxsICE9PSBiID8gYi5tZW1vaXplZFN0YXRlIDogXCJmdW5jdGlvblwiID09PSB0eXBlb2YgYSA/IGEoKSA6IGE7XG4gICAgei5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJTdGF0ZVwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIFthLCBmdW5jdGlvbiAoKSB7fV07XG4gIH0sXG4gIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uIHVzZVRyYW5zaXRpb24oKSB7XG4gICAgRigpO1xuICAgIEYoKTtcbiAgICB6LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIlRyYW5zaXRpb25cIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIFshMSwgZnVuY3Rpb24gKCkge31dO1xuICB9LFxuICB1c2VNdXRhYmxlU291cmNlOiBmdW5jdGlvbiB1c2VNdXRhYmxlU291cmNlKGEsIGIpIHtcbiAgICBGKCk7XG4gICAgRigpO1xuICAgIEYoKTtcbiAgICBGKCk7XG4gICAgYSA9IGIoYS5fc291cmNlKTtcbiAgICB6LnB1c2goe1xuICAgICAgcHJpbWl0aXZlOiBcIk11dGFibGVTb3VyY2VcIixcbiAgICAgIHN0YWNrRXJyb3I6IEVycm9yKCksXG4gICAgICB2YWx1ZTogYVxuICAgIH0pO1xuICAgIHJldHVybiBhO1xuICB9LFxuICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiB1c2VEZWZlcnJlZFZhbHVlKGEpIHtcbiAgICBGKCk7XG4gICAgRigpO1xuICAgIHoucHVzaCh7XG4gICAgICBwcmltaXRpdmU6IFwiRGVmZXJyZWRWYWx1ZVwiLFxuICAgICAgc3RhY2tFcnJvcjogRXJyb3IoKSxcbiAgICAgIHZhbHVlOiBhXG4gICAgfSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sXG4gIHVzZU9wYXF1ZUlkZW50aWZpZXI6IGZ1bmN0aW9uIHVzZU9wYXF1ZUlkZW50aWZpZXIoKSB7XG4gICAgdmFyIGEgPSBGKCk7XG4gICAgQiAmJiAwID09PSBCLm1vZGUgJiYgRigpO1xuICAgIChhID0gbnVsbCA9PT0gYSA/IHZvaWQgMCA6IGEubWVtb2l6ZWRTdGF0ZSkgJiYgYS4kJHR5cGVvZiA9PT0geCAmJiAoYSA9IHZvaWQgMCk7XG4gICAgei5wdXNoKHtcbiAgICAgIHByaW1pdGl2ZTogXCJPcGFxdWVJZGVudGlmaWVyXCIsXG4gICAgICBzdGFja0Vycm9yOiBFcnJvcigpLFxuICAgICAgdmFsdWU6IGFcbiAgICB9KTtcbiAgICByZXR1cm4gYTtcbiAgfVxufSxcbiAgICBHID0gMDtcblxuZnVuY3Rpb24gSChhLCBiLCBlKSB7XG4gIHZhciBmID0gYltlXS5zb3VyY2UsXG4gICAgICBjID0gMDtcblxuICBhOiBmb3IgKDsgYyA8IGEubGVuZ3RoOyBjKyspIHtcbiAgICBpZiAoYVtjXS5zb3VyY2UgPT09IGYpIHtcbiAgICAgIGZvciAodmFyIGwgPSBlICsgMSwgcSA9IGMgKyAxOyBsIDwgYi5sZW5ndGggJiYgcSA8IGEubGVuZ3RoOyBsKyssIHErKykge1xuICAgICAgICBpZiAoYVtxXS5zb3VyY2UgIT09IGJbbF0uc291cmNlKSBjb250aW51ZSBhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbmZ1bmN0aW9uIEkoYSwgYikge1xuICBpZiAoIWEpIHJldHVybiAhMTtcbiAgYiA9IFwidXNlXCIgKyBiO1xuICByZXR1cm4gYS5sZW5ndGggPCBiLmxlbmd0aCA/ICExIDogYS5sYXN0SW5kZXhPZihiKSA9PT0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbn1cblxuZnVuY3Rpb24gSihhLCBiLCBlKSB7XG4gIGZvciAodmFyIGYgPSBbXSwgYyA9IG51bGwsIGwgPSBmLCBxID0gMCwgdCA9IFtdLCB2ID0gMDsgdiA8IGIubGVuZ3RoOyB2KyspIHtcbiAgICB2YXIgdSA9IGJbdl07XG4gICAgdmFyIGQgPSBhO1xuICAgIHZhciBoID0gcC5wYXJzZSh1LnN0YWNrRXJyb3IpO1xuXG4gICAgYjoge1xuICAgICAgdmFyIG0gPSBoLFxuICAgICAgICAgIG4gPSBIKG0sIGQsIEcpO1xuICAgICAgaWYgKC0xICE9PSBuKSBkID0gbjtlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgZyA9IDA7IGcgPCBkLmxlbmd0aCAmJiA1ID4gZzsgZysrKSB7XG4gICAgICAgICAgaWYgKG4gPSBIKG0sIGQsIGcpLCAtMSAhPT0gbikge1xuICAgICAgICAgICAgRyA9IGc7XG4gICAgICAgICAgICBkID0gbjtcbiAgICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZCA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGI6IHtcbiAgICAgIG0gPSBoO1xuICAgICAgbiA9IEMoKS5nZXQodS5wcmltaXRpdmUpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gbikgZm9yIChnID0gMDsgZyA8IG4ubGVuZ3RoICYmIGcgPCBtLmxlbmd0aDsgZysrKSB7XG4gICAgICAgIGlmIChuW2ddLnNvdXJjZSAhPT0gbVtnXS5zb3VyY2UpIHtcbiAgICAgICAgICBnIDwgbS5sZW5ndGggLSAxICYmIEkobVtnXS5mdW5jdGlvbk5hbWUsIHUucHJpbWl0aXZlKSAmJiBnKys7XG4gICAgICAgICAgZyA8IG0ubGVuZ3RoIC0gMSAmJiBJKG1bZ10uZnVuY3Rpb25OYW1lLCB1LnByaW1pdGl2ZSkgJiYgZysrO1xuICAgICAgICAgIG0gPSBnO1xuICAgICAgICAgIGJyZWFrIGI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0gPSAtMTtcbiAgICB9XG5cbiAgICBoID0gLTEgPT09IGQgfHwgLTEgPT09IG0gfHwgMiA+IGQgLSBtID8gbnVsbCA6IGguc2xpY2UobSwgZCAtIDEpO1xuXG4gICAgaWYgKG51bGwgIT09IGgpIHtcbiAgICAgIGQgPSAwO1xuXG4gICAgICBpZiAobnVsbCAhPT0gYykge1xuICAgICAgICBmb3IgKDsgZCA8IGgubGVuZ3RoICYmIGQgPCBjLmxlbmd0aCAmJiBoW2gubGVuZ3RoIC0gZCAtIDFdLnNvdXJjZSA9PT0gY1tjLmxlbmd0aCAtIGQgLSAxXS5zb3VyY2U7KSB7XG4gICAgICAgICAgZCsrO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjID0gYy5sZW5ndGggLSAxOyBjID4gZDsgYy0tKSB7XG4gICAgICAgICAgbCA9IHQucG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChjID0gaC5sZW5ndGggLSBkIC0gMTsgMSA8PSBjOyBjLS0pIHtcbiAgICAgICAgZCA9IFtdLCBtID0gaFtjXSwgKG4gPSBoW2MgLSAxXS5mdW5jdGlvbk5hbWUpID8gKGcgPSBuLmxhc3RJbmRleE9mKFwiLlwiKSwgLTEgPT09IGcgJiYgKGcgPSAwKSwgXCJ1c2VcIiA9PT0gbi5zdWJzdHIoZywgMykgJiYgKGcgKz0gMyksIG4gPSBuLnN1YnN0cihnKSkgOiBuID0gXCJcIiwgbiA9IHtcbiAgICAgICAgICBpZDogbnVsbCxcbiAgICAgICAgICBpc1N0YXRlRWRpdGFibGU6ICExLFxuICAgICAgICAgIG5hbWU6IG4sXG4gICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICBzdWJIb29rczogZFxuICAgICAgICB9LCBlICYmIChuLmhvb2tTb3VyY2UgPSB7XG4gICAgICAgICAgbGluZU51bWJlcjogbS5saW5lTnVtYmVyLFxuICAgICAgICAgIGNvbHVtbk51bWJlcjogbS5jb2x1bW5OdW1iZXIsXG4gICAgICAgICAgZnVuY3Rpb25OYW1lOiBtLmZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICBmaWxlTmFtZTogbS5maWxlTmFtZVxuICAgICAgICB9KSwgbC5wdXNoKG4pLCB0LnB1c2gobCksIGwgPSBkO1xuICAgICAgfVxuXG4gICAgICBjID0gaDtcbiAgICB9XG5cbiAgICBkID0gdS5wcmltaXRpdmU7XG4gICAgdSA9IHtcbiAgICAgIGlkOiBcIkNvbnRleHRcIiA9PT0gZCB8fCBcIkRlYnVnVmFsdWVcIiA9PT0gZCA/IG51bGwgOiBxKyssXG4gICAgICBpc1N0YXRlRWRpdGFibGU6IFwiUmVkdWNlclwiID09PSBkIHx8IFwiU3RhdGVcIiA9PT0gZCxcbiAgICAgIG5hbWU6IGQsXG4gICAgICB2YWx1ZTogdS52YWx1ZSxcbiAgICAgIHN1Ykhvb2tzOiBbXVxuICAgIH07XG4gICAgZSAmJiAoZCA9IHtcbiAgICAgIGxpbmVOdW1iZXI6IG51bGwsXG4gICAgICBmdW5jdGlvbk5hbWU6IG51bGwsXG4gICAgICBmaWxlTmFtZTogbnVsbCxcbiAgICAgIGNvbHVtbk51bWJlcjogbnVsbFxuICAgIH0sIGggJiYgMSA8PSBoLmxlbmd0aCAmJiAoaCA9IGhbMF0sIGQubGluZU51bWJlciA9IGgubGluZU51bWJlciwgZC5mdW5jdGlvbk5hbWUgPSBoLmZ1bmN0aW9uTmFtZSwgZC5maWxlTmFtZSA9IGguZmlsZU5hbWUsIGQuY29sdW1uTnVtYmVyID0gaC5jb2x1bW5OdW1iZXIpLCB1Lmhvb2tTb3VyY2UgPSBkKTtcbiAgICBsLnB1c2godSk7XG4gIH1cblxuICBLKGYsIG51bGwpO1xuICByZXR1cm4gZjtcbn1cblxuZnVuY3Rpb24gSyhhLCBiKSB7XG4gIGZvciAodmFyIGUgPSBbXSwgZiA9IDA7IGYgPCBhLmxlbmd0aDsgZisrKSB7XG4gICAgdmFyIGMgPSBhW2ZdO1xuICAgIFwiRGVidWdWYWx1ZVwiID09PSBjLm5hbWUgJiYgMCA9PT0gYy5zdWJIb29rcy5sZW5ndGggPyAoYS5zcGxpY2UoZiwgMSksIGYtLSwgZS5wdXNoKGMpKSA6IEsoYy5zdWJIb29rcywgYyk7XG4gIH1cblxuICBudWxsICE9PSBiICYmICgxID09PSBlLmxlbmd0aCA/IGIudmFsdWUgPSBlWzBdLnZhbHVlIDogMSA8IGUubGVuZ3RoICYmIChiLnZhbHVlID0gZS5tYXAoZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYS52YWx1ZTtcbiAgfSkpKTtcbn1cblxuZnVuY3Rpb24gTChhLCBiLCBlKSB7XG4gIHZhciBmID0gMyA8IGFyZ3VtZW50cy5sZW5ndGggJiYgdm9pZCAwICE9PSBhcmd1bWVudHNbM10gPyBhcmd1bWVudHNbM10gOiAhMTtcbiAgbnVsbCA9PSBlICYmIChlID0gdy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyKTtcbiAgdmFyIGMgPSBlLmN1cnJlbnQ7XG4gIGUuY3VycmVudCA9IEQ7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbCA9IEVycm9yKCk7XG4gICAgYShiKTtcbiAgfSBmaW5hbGx5IHtcbiAgICB2YXIgcSA9IHo7XG4gICAgeiA9IFtdO1xuICAgIGUuY3VycmVudCA9IGM7XG4gIH1cblxuICBjID0gcC5wYXJzZShsKTtcbiAgcmV0dXJuIEooYywgcSwgZik7XG59XG5cbmZ1bmN0aW9uIE0oYSkge1xuICBhLmZvckVhY2goZnVuY3Rpb24gKGEsIGUpIHtcbiAgICByZXR1cm4gZS5fY3VycmVudFZhbHVlID0gYTtcbiAgfSk7XG59XG5cbmV4cG9ydHMuaW5zcGVjdEhvb2tzID0gTDtcblxuZXhwb3J0cy5pbnNwZWN0SG9va3NPZkZpYmVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGUgPSAyIDwgYXJndW1lbnRzLmxlbmd0aCAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1syXSA/IGFyZ3VtZW50c1syXSA6ICExO1xuICBudWxsID09IGIgJiYgKGIgPSB3LlJlYWN0Q3VycmVudERpc3BhdGNoZXIpO1xuICBCID0gYTtcbiAgaWYgKDAgIT09IGEudGFnICYmIDE1ICE9PSBhLnRhZyAmJiAxMSAhPT0gYS50YWcpIHRocm93IEVycm9yKFwiVW5rbm93biBGaWJlci4gTmVlZHMgdG8gYmUgYSBmdW5jdGlvbiBjb21wb25lbnQgdG8gaW5zcGVjdCBob29rcy5cIik7XG4gIEMoKTtcbiAgdmFyIGYgPSBhLnR5cGUsXG4gICAgICBjID0gYS5tZW1vaXplZFByb3BzO1xuXG4gIGlmIChmICE9PSBhLmVsZW1lbnRUeXBlICYmIGYgJiYgZi5kZWZhdWx0UHJvcHMpIHtcbiAgICBjID0gayh7fSwgYyk7XG4gICAgdmFyIGwgPSBmLmRlZmF1bHRQcm9wcztcblxuICAgIGZvciAocSBpbiBsKSB7XG4gICAgICB2b2lkIDAgPT09IGNbcV0gJiYgKGNbcV0gPSBsW3FdKTtcbiAgICB9XG4gIH1cblxuICBFID0gYS5tZW1vaXplZFN0YXRlO1xuICB2YXIgcSA9IG5ldyBNYXAoKTtcblxuICB0cnkge1xuICAgIGZvciAobCA9IGE7IGw7KSB7XG4gICAgICBpZiAoMTAgPT09IGwudGFnKSB7XG4gICAgICAgIHZhciB0ID0gbC50eXBlLl9jb250ZXh0O1xuICAgICAgICBxLmhhcyh0KSB8fCAocS5zZXQodCwgdC5fY3VycmVudFZhbHVlKSwgdC5fY3VycmVudFZhbHVlID0gbC5tZW1vaXplZFByb3BzLnZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgbCA9IGwucmV0dXJuO1xuICAgIH1cblxuICAgIGlmICgxMSA9PT0gYS50YWcpIHtcbiAgICAgIHZhciB2ID0gZi5yZW5kZXI7XG4gICAgICBmID0gYztcbiAgICAgIHZhciB1ID0gYS5yZWY7XG4gICAgICB0ID0gYjtcbiAgICAgIHZhciBkID0gdC5jdXJyZW50O1xuICAgICAgdC5jdXJyZW50ID0gRDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGggPSBFcnJvcigpO1xuICAgICAgICB2KGYsIHUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdmFyIG0gPSB6O1xuICAgICAgICB6ID0gW107XG4gICAgICAgIHQuY3VycmVudCA9IGQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBuID0gcC5wYXJzZShoKTtcbiAgICAgIHJldHVybiBKKG4sIG0sIGUpO1xuICAgIH1cblxuICAgIHJldHVybiBMKGYsIGMsIGIsIGUpO1xuICB9IGZpbmFsbHkge1xuICAgIEUgPSBudWxsLCBNKHEpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18sIF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fO2Z1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gICd1c2Ugc3RyaWN0JzsgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cbiAgaWYgKHRydWUpIHtcbiAgICAhKF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18gPSBbX193ZWJwYWNrX3JlcXVpcmVfXygxNildLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgfSBlbHNlIHt9XG59KSh0aGlzLCBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyKFN0YWNrRnJhbWUpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrOlxcZCsvO1xuICB2YXIgQ0hST01FX0lFX1NUQUNLX1JFR0VYUCA9IC9eXFxzKmF0IC4qKFxcUys6XFxkK3xcXChuYXRpdmVcXCkpL207XG4gIHZhciBTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQID0gL14oZXZhbEApPyhcXFtuYXRpdmUgY29kZV0pPyQvO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIEVycm9yIG9iamVjdCwgZXh0cmFjdCB0aGUgbW9zdCBpbmZvcm1hdGlvbiBmcm9tIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICogQHJldHVybiB7QXJyYXl9IG9mIFN0YWNrRnJhbWVzXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmEoZXJyb3IpO1xuICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjayAmJiBlcnJvci5zdGFjay5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVY4T3JJRShlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBwYXJzZSBnaXZlbiBFcnJvciBvYmplY3QnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgZXh0cmFjdExvY2F0aW9uOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24odXJsTGlrZSkge1xuICAgICAgLy8gRmFpbC1mYXN0IGJ1dCByZXR1cm4gbG9jYXRpb25zIGxpa2UgXCIobmF0aXZlKVwiXG4gICAgICBpZiAodXJsTGlrZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICB9XG5cbiAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLztcbiAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCAnJykpO1xuICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xuICAgIH0sXG4gICAgcGFyc2VWOE9ySUU6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlVjhPcklFKGVycm9yKSB7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goQ0hST01FX0lFX1NUQUNLX1JFR0VYUCk7XG4gICAgICB9LCB0aGlzKTtcbiAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignKGV2YWwgJykgPiAtMSkge1xuICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICBsaW5lID0gbGluZS5yZXBsYWNlKC9ldmFsIGNvZGUvZywgJ2V2YWwnKS5yZXBsYWNlKC8oXFwoZXZhbCBhdCBbXigpXSopfChcXCksLiokKS9nLCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJyk7IC8vIGNhcHR1cmUgYW5kIHByZXNldmUgdGhlIHBhcmVudGhlc2l6ZWQgbG9jYXRpb24gXCIoL2Zvby9teSBiYXIuanM6MTI6ODcpXCIgaW5cbiAgICAgICAgLy8gY2FzZSBpdCBoYXMgc3BhY2VzIGluIGl0LCBhcyB0aGUgc3RyaW5nIGlzIHNwbGl0IG9uIFxccysgbGF0ZXIgb25cblxuICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKCguKyk6KFxcZCspOihcXGQrKVxcKSQpLyk7IC8vIHJlbW92ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBmcm9tIHRoZSBsaW5lLCBpZiBpdCB3YXMgbWF0Y2hlZFxuXG4gICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvbiA/IHNhbml0aXplZExpbmUucmVwbGFjZShsb2NhdGlvblswXSwgJycpIDogc2FuaXRpemVkTGluZTtcbiAgICAgICAgdmFyIHRva2VucyA9IHNhbml0aXplZExpbmUuc3BsaXQoL1xccysvKS5zbGljZSgxKTsgLy8gaWYgYSBsb2NhdGlvbiB3YXMgbWF0Y2hlZCwgcGFzcyBpdCB0byBleHRyYWN0TG9jYXRpb24oKSBvdGhlcndpc2UgcG9wIHRoZSBsYXN0IHRva2VuXG5cbiAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsb2NhdGlvbiA/IGxvY2F0aW9uWzFdIDogdG9rZW5zLnBvcCgpKTtcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRva2Vucy5qb2luKCcgJykgfHwgdW5kZWZpbmVkO1xuICAgICAgICB2YXIgZmlsZU5hbWUgPSBbJ2V2YWwnLCAnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgfSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAhbGluZS5tYXRjaChTQUZBUklfTkFUSVZFX0NPREVfUkVHRVhQKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAvLyBUaHJvdyBhd2F5IGV2YWwgaW5mb3JtYXRpb24gdW50aWwgd2UgaW1wbGVtZW50IHN0YWNrdHJhY2UuanMvc3RhY2tmcmFtZSM4XG4gICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvIGxpbmUgKFxcZCspKD86ID4gZXZhbCBsaW5lIFxcZCspKiA+IGV2YWw6XFxkKzpcXGQrL2csICc6JDEnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaW5lLmluZGV4T2YoJ0AnKSA9PT0gLTEgJiYgbGluZS5pbmRleE9mKCc6JykgPT09IC0xKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG4gICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWVSZWdleCA9IC8oKC4qXCIuK1wiW15AXSopP1teQF0qKSg/OkApLztcbiAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goZnVuY3Rpb25OYW1lUmVnZXgpO1xuICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBtYXRjaGVzICYmIG1hdGNoZXNbMV0gPyBtYXRjaGVzWzFdIDogdW5kZWZpbmVkO1xuICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obGluZS5yZXBsYWNlKGZ1bmN0aW9uTmFtZVJlZ2V4LCAnJykpO1xuICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgICAgIGZpbGVOYW1lOiBsb2NhdGlvblBhcnRzWzBdLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgIGNvbHVtbk51bWJlcjogbG9jYXRpb25QYXJ0c1syXSxcbiAgICAgICAgICAgIHNvdXJjZTogbGluZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEoZSkge1xuICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgZS5tZXNzYWdlLmluZGV4T2YoJ1xcbicpID4gLTEgJiYgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTEwKGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYTExKGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFyc2VPcGVyYTk6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmE5KGUpIHtcbiAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKS9pO1xuICAgICAgdmFyIGxpbmVzID0gZS5tZXNzYWdlLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDIsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IGxpbmVSRS5leGVjKGxpbmVzW2ldKTtcblxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICBmaWxlTmFtZTogbWF0Y2hbMl0sXG4gICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgIHNvdXJjZTogbGluZXNbaV1cbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbGluZVJFLmV4ZWMobGluZXNbaV0pO1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbWF0Y2hbM10gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgZmlsZU5hbWU6IG1hdGNoWzJdLFxuICAgICAgICAgICAgbGluZU51bWJlcjogbWF0Y2hbMV0sXG4gICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuICAgIHBhcnNlT3BlcmExMTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExKGVycm9yKSB7XG4gICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHJldHVybiAhIWxpbmUubWF0Y2goRklSRUZPWF9TQUZBUklfU1RBQ0tfUkVHRVhQKSAmJiAhbGluZS5tYXRjaCgvXkVycm9yIGNyZWF0ZWQgYXQvKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgdG9rZW5zID0gbGluZS5zcGxpdCgnQCcpO1xuICAgICAgICB2YXIgbG9jYXRpb25QYXJ0cyA9IHRoaXMuZXh0cmFjdExvY2F0aW9uKHRva2Vucy5wb3AoKSk7XG4gICAgICAgIHZhciBmdW5jdGlvbkNhbGwgPSB0b2tlbnMuc2hpZnQoKSB8fCAnJztcbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC88YW5vbnltb3VzIGZ1bmN0aW9uKDogKFxcdyspKT8+LywgJyQyJykucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGFyZ3NSYXc7XG5cbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbC5tYXRjaCgvXFwoKFteKV0qKVxcKS8pKSB7XG4gICAgICAgICAgYXJnc1JhdyA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC9eW14oXStcXCgoW14pXSopXFwpJC8sICckMScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nID8gdW5kZWZpbmVkIDogYXJnc1Jhdy5zcGxpdCgnLCcpO1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgIGFyZ3M6IGFyZ3MsXG4gICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICBjb2x1bW5OdW1iZXI6IGxvY2F0aW9uUGFydHNbMl0sXG4gICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgIH0pO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXywgX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX187ZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4oZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgJ3VzZSBzdHJpY3QnOyAvLyBVbml2ZXJzYWwgTW9kdWxlIERlZmluaXRpb24gKFVNRCkgdG8gc3VwcG9ydCBBTUQsIENvbW1vbkpTL05vZGUuanMsIFJoaW5vLCBhbmQgYnJvd3NlcnMuXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuICBpZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfQVJSQVlfXyA9IFtdLCBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPSAoZmFjdG9yeSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fID0gKHR5cGVvZiBfX1dFQlBBQ0tfQU1EX0RFRklORV9GQUNUT1JZX18gPT09ICdmdW5jdGlvbicgP1xuXHRcdFx0XHQoX19XRUJQQUNLX0FNRF9ERUZJTkVfRkFDVE9SWV9fLmFwcGx5KGV4cG9ydHMsIF9fV0VCUEFDS19BTURfREVGSU5FX0FSUkFZX18pKSA6IF9fV0VCUEFDS19BTURfREVGSU5FX0ZBQ1RPUllfXyksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgfSBlbHNlIHt9XG59KSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICBmdW5jdGlvbiBfaXNOdW1iZXIobikge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG4gIH1cblxuICBmdW5jdGlvbiBfY2FwaXRhbGl6ZShzdHIpIHtcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXR0ZXIocCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpc1twXTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGJvb2xlYW5Qcm9wcyA9IFsnaXNDb25zdHJ1Y3RvcicsICdpc0V2YWwnLCAnaXNOYXRpdmUnLCAnaXNUb3BsZXZlbCddO1xuICB2YXIgbnVtZXJpY1Byb3BzID0gWydjb2x1bW5OdW1iZXInLCAnbGluZU51bWJlciddO1xuICB2YXIgc3RyaW5nUHJvcHMgPSBbJ2ZpbGVOYW1lJywgJ2Z1bmN0aW9uTmFtZScsICdzb3VyY2UnXTtcbiAgdmFyIGFycmF5UHJvcHMgPSBbJ2FyZ3MnXTtcbiAgdmFyIHByb3BzID0gYm9vbGVhblByb3BzLmNvbmNhdChudW1lcmljUHJvcHMsIHN0cmluZ1Byb3BzLCBhcnJheVByb3BzKTtcblxuICBmdW5jdGlvbiBTdGFja0ZyYW1lKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob2JqW3Byb3BzW2ldXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXNbJ3NldCcgKyBfY2FwaXRhbGl6ZShwcm9wc1tpXSldKG9ialtwcm9wc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFN0YWNrRnJhbWUucHJvdG90eXBlID0ge1xuICAgIGdldEFyZ3M6IGZ1bmN0aW9uIGdldEFyZ3MoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hcmdzO1xuICAgIH0sXG4gICAgc2V0QXJnczogZnVuY3Rpb24gc2V0QXJncyh2KSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHYpICE9PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3MgbXVzdCBiZSBhbiBBcnJheScpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFyZ3MgPSB2O1xuICAgIH0sXG4gICAgZ2V0RXZhbE9yaWdpbjogZnVuY3Rpb24gZ2V0RXZhbE9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmV2YWxPcmlnaW47XG4gICAgfSxcbiAgICBzZXRFdmFsT3JpZ2luOiBmdW5jdGlvbiBzZXRFdmFsT3JpZ2luKHYpIHtcbiAgICAgIGlmICh2IGluc3RhbmNlb2YgU3RhY2tGcmFtZSkge1xuICAgICAgICB0aGlzLmV2YWxPcmlnaW4gPSB2O1xuICAgICAgfSBlbHNlIGlmICh2IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIHRoaXMuZXZhbE9yaWdpbiA9IG5ldyBTdGFja0ZyYW1lKHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXZhbCBPcmlnaW4gbXVzdCBiZSBhbiBPYmplY3Qgb3IgU3RhY2tGcmFtZScpO1xuICAgICAgfVxuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gdGhpcy5nZXRGaWxlTmFtZSgpIHx8ICcnO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSB0aGlzLmdldExpbmVOdW1iZXIoKSB8fCAnJztcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSB0aGlzLmdldENvbHVtbk51bWJlcigpIHx8ICcnO1xuICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHRoaXMuZ2V0RnVuY3Rpb25OYW1lKCkgfHwgJyc7XG5cbiAgICAgIGlmICh0aGlzLmdldElzRXZhbCgpKSB7XG4gICAgICAgIGlmIChmaWxlTmFtZSkge1xuICAgICAgICAgIHJldHVybiAnW2V2YWxdICgnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJzonICsgY29sdW1uTnVtYmVyICsgJyknO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdbZXZhbF06JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChmdW5jdGlvbk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uTmFtZSArICcgKCcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXIgKyAnKSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnOicgKyBjb2x1bW5OdW1iZXI7XG4gICAgfVxuICB9O1xuXG4gIFN0YWNrRnJhbWUuZnJvbVN0cmluZyA9IGZ1bmN0aW9uIFN0YWNrRnJhbWUkJGZyb21TdHJpbmcoc3RyKSB7XG4gICAgdmFyIGFyZ3NTdGFydEluZGV4ID0gc3RyLmluZGV4T2YoJygnKTtcbiAgICB2YXIgYXJnc0VuZEluZGV4ID0gc3RyLmxhc3RJbmRleE9mKCcpJyk7XG4gICAgdmFyIGZ1bmN0aW9uTmFtZSA9IHN0ci5zdWJzdHJpbmcoMCwgYXJnc1N0YXJ0SW5kZXgpO1xuICAgIHZhciBhcmdzID0gc3RyLnN1YnN0cmluZyhhcmdzU3RhcnRJbmRleCArIDEsIGFyZ3NFbmRJbmRleCkuc3BsaXQoJywnKTtcbiAgICB2YXIgbG9jYXRpb25TdHJpbmcgPSBzdHIuc3Vic3RyaW5nKGFyZ3NFbmRJbmRleCArIDEpO1xuXG4gICAgaWYgKGxvY2F0aW9uU3RyaW5nLmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuICAgICAgdmFyIHBhcnRzID0gL0AoLis/KSg/OjooXFxkKykpPyg/OjooXFxkKykpPyQvLmV4ZWMobG9jYXRpb25TdHJpbmcsICcnKTtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHBhcnRzWzFdO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBwYXJ0c1syXTtcbiAgICAgIHZhciBjb2x1bW5OdW1iZXIgPSBwYXJ0c1szXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICBhcmdzOiBhcmdzIHx8IHVuZGVmaW5lZCxcbiAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IGxpbmVOdW1iZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgY29sdW1uTnVtYmVyOiBjb2x1bW5OdW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29sZWFuUHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnZ2V0JyArIF9jYXBpdGFsaXplKGJvb2xlYW5Qcm9wc1tpXSldID0gX2dldHRlcihib29sZWFuUHJvcHNbaV0pO1xuXG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ3NldCcgKyBfY2FwaXRhbGl6ZShib29sZWFuUHJvcHNbaV0pXSA9IGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgdGhpc1twXSA9IEJvb2xlYW4odik7XG4gICAgICB9O1xuICAgIH0oYm9vbGVhblByb3BzW2ldKTtcbiAgfVxuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgbnVtZXJpY1Byb3BzLmxlbmd0aDsgaisrKSB7XG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShudW1lcmljUHJvcHNbal0pXSA9IF9nZXR0ZXIobnVtZXJpY1Byb3BzW2pdKTtcblxuICAgIFN0YWNrRnJhbWUucHJvdG90eXBlWydzZXQnICsgX2NhcGl0YWxpemUobnVtZXJpY1Byb3BzW2pdKV0gPSBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIGlmICghX2lzTnVtYmVyKHYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihwICsgJyBtdXN0IGJlIGEgTnVtYmVyJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzW3BdID0gTnVtYmVyKHYpO1xuICAgICAgfTtcbiAgICB9KG51bWVyaWNQcm9wc1tqXSk7XG4gIH1cblxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cmluZ1Byb3BzLmxlbmd0aDsgaysrKSB7XG4gICAgU3RhY2tGcmFtZS5wcm90b3R5cGVbJ2dldCcgKyBfY2FwaXRhbGl6ZShzdHJpbmdQcm9wc1trXSldID0gX2dldHRlcihzdHJpbmdQcm9wc1trXSk7XG5cbiAgICBTdGFja0ZyYW1lLnByb3RvdHlwZVsnc2V0JyArIF9jYXBpdGFsaXplKHN0cmluZ1Byb3BzW2tdKV0gPSBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHRoaXNbcF0gPSBTdHJpbmcodik7XG4gICAgICB9O1xuICAgIH0oc3RyaW5nUHJvcHNba10pO1xuICB9XG5cbiAgcmV0dXJuIFN0YWNrRnJhbWU7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5pZiAodHJ1ZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xufSBlbHNlIHt9XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQGxpY2Vuc2UgUmVhY3QgdnVuZGVmaW5lZFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpLFxuICAgIG0gPSA2MDEwMyxcbiAgICBwID0gNjAxMDY7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSA2MDEwNztcbmV4cG9ydHMuU3RyaWN0TW9kZSA9IDYwMTA4O1xuZXhwb3J0cy5Qcm9maWxlciA9IDYwMTE0O1xudmFyIHEgPSA2MDEwOSxcbiAgICByID0gNjAxMTAsXG4gICAgdCA9IDYwMTEyO1xuZXhwb3J0cy5TdXNwZW5zZSA9IDYwMTEzO1xuZXhwb3J0cy5TdXNwZW5zZUxpc3QgPSA2MDEyMDtcbnZhciB1ID0gNjAxMTUsXG4gICAgdiA9IDYwMTE2O1xuZXhwb3J0cy51bnN0YWJsZV9EZWJ1Z1RyYWNpbmdNb2RlID0gNjAxMjk7XG5leHBvcnRzLnVuc3RhYmxlX09mZnNjcmVlbiA9IDYwMTMwO1xuZXhwb3J0cy51bnN0YWJsZV9MZWdhY3lIaWRkZW4gPSA2MDEzMTtcbmV4cG9ydHMudW5zdGFibGVfQ2FjaGUgPSA2MDEzMjtcblxuaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuZm9yKSB7XG4gIHZhciB3ID0gU3ltYm9sLmZvcjtcbiAgbSA9IHcoXCJyZWFjdC5lbGVtZW50XCIpO1xuICBwID0gdyhcInJlYWN0LnBvcnRhbFwiKTtcbiAgZXhwb3J0cy5GcmFnbWVudCA9IHcoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgZXhwb3J0cy5TdHJpY3RNb2RlID0gdyhcInJlYWN0LnN0cmljdF9tb2RlXCIpO1xuICBleHBvcnRzLlByb2ZpbGVyID0gdyhcInJlYWN0LnByb2ZpbGVyXCIpO1xuICBxID0gdyhcInJlYWN0LnByb3ZpZGVyXCIpO1xuICByID0gdyhcInJlYWN0LmNvbnRleHRcIik7XG4gIHQgPSB3KFwicmVhY3QuZm9yd2FyZF9yZWZcIik7XG4gIGV4cG9ydHMuU3VzcGVuc2UgPSB3KFwicmVhY3Quc3VzcGVuc2VcIik7XG4gIGV4cG9ydHMuU3VzcGVuc2VMaXN0ID0gdyhcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG4gIHUgPSB3KFwicmVhY3QubWVtb1wiKTtcbiAgdiA9IHcoXCJyZWFjdC5sYXp5XCIpO1xuICBleHBvcnRzLnVuc3RhYmxlX0RlYnVnVHJhY2luZ01vZGUgPSB3KFwicmVhY3QuZGVidWdfdHJhY2VfbW9kZVwiKTtcbiAgZXhwb3J0cy51bnN0YWJsZV9PZmZzY3JlZW4gPSB3KFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xuICBleHBvcnRzLnVuc3RhYmxlX0xlZ2FjeUhpZGRlbiA9IHcoXCJyZWFjdC5sZWdhY3lfaGlkZGVuXCIpO1xuICBleHBvcnRzLnVuc3RhYmxlX0NhY2hlID0gdyhcInJlYWN0LmNhY2hlXCIpO1xufVxuXG52YXIgeCA9IFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3I7XG5cbmZ1bmN0aW9uIHkoYSkge1xuICBpZiAobnVsbCA9PT0gYSB8fCBcIm9iamVjdFwiICE9PSBfdHlwZW9mKGEpKSByZXR1cm4gbnVsbDtcbiAgYSA9IHggJiYgYVt4XSB8fCBhW1wiQEBpdGVyYXRvclwiXTtcbiAgcmV0dXJuIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGEgPyBhIDogbnVsbDtcbn1cblxuZnVuY3Rpb24geihhKSB7XG4gIGZvciAodmFyIGIgPSBcImh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50PVwiICsgYSwgYyA9IDE7IGMgPCBhcmd1bWVudHMubGVuZ3RoOyBjKyspIHtcbiAgICBiICs9IFwiJmFyZ3NbXT1cIiArIGVuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbY10pO1xuICB9XG5cbiAgcmV0dXJuIFwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiICsgYSArIFwiOyB2aXNpdCBcIiArIGIgKyBcIiBmb3IgdGhlIGZ1bGwgbWVzc2FnZSBvciB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgZm9yIGZ1bGwgZXJyb3JzIGFuZCBhZGRpdGlvbmFsIGhlbHBmdWwgd2FybmluZ3MuXCI7XG59XG5cbnZhciBBID0ge1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIGlzTW91bnRlZCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH0sXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gZW5xdWV1ZUZvcmNlVXBkYXRlKCkge30sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIGVucXVldWVSZXBsYWNlU3RhdGUoKSB7fSxcbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiBlbnF1ZXVlU2V0U3RhdGUoKSB7fVxufSxcbiAgICBCID0ge307XG5cbmZ1bmN0aW9uIEMoYSwgYiwgYykge1xuICB0aGlzLnByb3BzID0gYTtcbiAgdGhpcy5jb250ZXh0ID0gYjtcbiAgdGhpcy5yZWZzID0gQjtcbiAgdGhpcy51cGRhdGVyID0gYyB8fCBBO1xufVxuXG5DLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbkMucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT09IF90eXBlb2YoYSkgJiYgXCJmdW5jdGlvblwiICE9PSB0eXBlb2YgYSAmJiBudWxsICE9IGEpIHRocm93IEVycm9yKHooODUpKTtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBhLCBiLCBcInNldFN0YXRlXCIpO1xufTtcblxuQy5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoYSkge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGEsIFwiZm9yY2VVcGRhdGVcIik7XG59O1xuXG5mdW5jdGlvbiBEKCkge31cblxuRC5wcm90b3R5cGUgPSBDLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gRShhLCBiLCBjKSB7XG4gIHRoaXMucHJvcHMgPSBhO1xuICB0aGlzLmNvbnRleHQgPSBiO1xuICB0aGlzLnJlZnMgPSBCO1xuICB0aGlzLnVwZGF0ZXIgPSBjIHx8IEE7XG59XG5cbnZhciBGID0gRS5wcm90b3R5cGUgPSBuZXcgRCgpO1xuRi5jb25zdHJ1Y3RvciA9IEU7XG5sKEYsIEMucHJvdG90eXBlKTtcbkYuaXNQdXJlUmVhY3RDb21wb25lbnQgPSAhMDtcbnZhciBHID0gQXJyYXkuaXNBcnJheSxcbiAgICBIID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBJID0ge1xuICBjdXJyZW50OiBudWxsXG59LFxuICAgIEogPSB7XG4gIGtleTogITAsXG4gIHJlZjogITAsXG4gIF9fc2VsZjogITAsXG4gIF9fc291cmNlOiAhMFxufTtcblxuZnVuY3Rpb24gSyhhLCBiLCBjKSB7XG4gIHZhciBlLFxuICAgICAgZCA9IHt9LFxuICAgICAgayA9IG51bGwsXG4gICAgICBoID0gbnVsbDtcbiAgaWYgKG51bGwgIT0gYikgZm9yIChlIGluIHZvaWQgMCAhPT0gYi5yZWYgJiYgKGggPSBiLnJlZiksIHZvaWQgMCAhPT0gYi5rZXkgJiYgKGsgPSBcIlwiICsgYi5rZXkpLCBiKSB7XG4gICAgSC5jYWxsKGIsIGUpICYmICFKLmhhc093blByb3BlcnR5KGUpICYmIChkW2VdID0gYltlXSk7XG4gIH1cbiAgdmFyIGcgPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKDEgPT09IGcpIGQuY2hpbGRyZW4gPSBjO2Vsc2UgaWYgKDEgPCBnKSB7XG4gICAgZm9yICh2YXIgZiA9IEFycmF5KGcpLCBuID0gMDsgbiA8IGc7IG4rKykge1xuICAgICAgZltuXSA9IGFyZ3VtZW50c1tuICsgMl07XG4gICAgfVxuXG4gICAgZC5jaGlsZHJlbiA9IGY7XG4gIH1cbiAgaWYgKGEgJiYgYS5kZWZhdWx0UHJvcHMpIGZvciAoZSBpbiBnID0gYS5kZWZhdWx0UHJvcHMsIGcpIHtcbiAgICB2b2lkIDAgPT09IGRbZV0gJiYgKGRbZV0gPSBnW2VdKTtcbiAgfVxuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBtLFxuICAgIHR5cGU6IGEsXG4gICAga2V5OiBrLFxuICAgIHJlZjogaCxcbiAgICBwcm9wczogZCxcbiAgICBfb3duZXI6IEkuY3VycmVudFxuICB9O1xufVxuXG5mdW5jdGlvbiBMKGEsIGIpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogbSxcbiAgICB0eXBlOiBhLnR5cGUsXG4gICAga2V5OiBiLFxuICAgIHJlZjogYS5yZWYsXG4gICAgcHJvcHM6IGEucHJvcHMsXG4gICAgX293bmVyOiBhLl9vd25lclxuICB9O1xufVxuXG5mdW5jdGlvbiBNKGEpIHtcbiAgcmV0dXJuIFwib2JqZWN0XCIgPT09IF90eXBlb2YoYSkgJiYgbnVsbCAhPT0gYSAmJiBhLiQkdHlwZW9mID09PSBtO1xufVxuXG5mdW5jdGlvbiBlc2NhcGUoYSkge1xuICB2YXIgYiA9IHtcbiAgICBcIj1cIjogXCI9MFwiLFxuICAgIFwiOlwiOiBcIj0yXCJcbiAgfTtcbiAgcmV0dXJuIFwiJFwiICsgYS5yZXBsYWNlKC9bPTpdL2csIGZ1bmN0aW9uIChhKSB7XG4gICAgcmV0dXJuIGJbYV07XG4gIH0pO1xufVxuXG52YXIgTiA9IC9cXC8rL2c7XG5cbmZ1bmN0aW9uIE8oYSwgYikge1xuICByZXR1cm4gXCJvYmplY3RcIiA9PT0gX3R5cGVvZihhKSAmJiBudWxsICE9PSBhICYmIG51bGwgIT0gYS5rZXkgPyBlc2NhcGUoXCJcIiArIGEua2V5KSA6IGIudG9TdHJpbmcoMzYpO1xufVxuXG5mdW5jdGlvbiBQKGEsIGIsIGMsIGUsIGQpIHtcbiAgdmFyIGsgPSBfdHlwZW9mKGEpO1xuXG4gIGlmIChcInVuZGVmaW5lZFwiID09PSBrIHx8IFwiYm9vbGVhblwiID09PSBrKSBhID0gbnVsbDtcbiAgdmFyIGggPSAhMTtcbiAgaWYgKG51bGwgPT09IGEpIGggPSAhMDtlbHNlIHN3aXRjaCAoaykge1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBoID0gITA7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIHN3aXRjaCAoYS4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIG06XG4gICAgICAgIGNhc2UgcDpcbiAgICAgICAgICBoID0gITA7XG4gICAgICB9XG5cbiAgfVxuICBpZiAoaCkgcmV0dXJuIGggPSBhLCBkID0gZChoKSwgYSA9IFwiXCIgPT09IGUgPyBcIi5cIiArIE8oaCwgMCkgOiBlLCBHKGQpID8gKGMgPSBcIlwiLCBudWxsICE9IGEgJiYgKGMgPSBhLnJlcGxhY2UoTiwgXCIkJi9cIikgKyBcIi9cIiksIFAoZCwgYiwgYywgXCJcIiwgZnVuY3Rpb24gKGEpIHtcbiAgICByZXR1cm4gYTtcbiAgfSkpIDogbnVsbCAhPSBkICYmIChNKGQpICYmIChkID0gTChkLCBjICsgKCFkLmtleSB8fCBoICYmIGgua2V5ID09PSBkLmtleSA/IFwiXCIgOiAoXCJcIiArIGQua2V5KS5yZXBsYWNlKE4sIFwiJCYvXCIpICsgXCIvXCIpICsgYSkpLCBiLnB1c2goZCkpLCAxO1xuICBoID0gMDtcbiAgZSA9IFwiXCIgPT09IGUgPyBcIi5cIiA6IGUgKyBcIjpcIjtcbiAgaWYgKEcoYSkpIGZvciAodmFyIGcgPSAwOyBnIDwgYS5sZW5ndGg7IGcrKykge1xuICAgIGsgPSBhW2ddO1xuICAgIHZhciBmID0gZSArIE8oaywgZyk7XG4gICAgaCArPSBQKGssIGIsIGMsIGYsIGQpO1xuICB9IGVsc2UgaWYgKGYgPSB5KGEpLCBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmKSBmb3IgKGEgPSBmLmNhbGwoYSksIGcgPSAwOyAhKGsgPSBhLm5leHQoKSkuZG9uZTspIHtcbiAgICBrID0gay52YWx1ZSwgZiA9IGUgKyBPKGssIGcrKyksIGggKz0gUChrLCBiLCBjLCBmLCBkKTtcbiAgfSBlbHNlIGlmIChcIm9iamVjdFwiID09PSBrKSB0aHJvdyBiID0gXCJcIiArIGEsIEVycm9yKHooMzEsIFwiW29iamVjdCBPYmplY3RdXCIgPT09IGIgPyBcIm9iamVjdCB3aXRoIGtleXMge1wiICsgT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpICsgXCJ9XCIgOiBiKSk7XG4gIHJldHVybiBoO1xufVxuXG5mdW5jdGlvbiBRKGEsIGIsIGMpIHtcbiAgaWYgKG51bGwgPT0gYSkgcmV0dXJuIGE7XG4gIHZhciBlID0gW10sXG4gICAgICBkID0gMDtcbiAgUChhLCBlLCBcIlwiLCBcIlwiLCBmdW5jdGlvbiAoYSkge1xuICAgIHJldHVybiBiLmNhbGwoYywgYSwgZCsrKTtcbiAgfSk7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBSKGEpIHtcbiAgaWYgKC0xID09PSBhLl9zdGF0dXMpIHtcbiAgICB2YXIgYiA9IGEuX3Jlc3VsdDtcbiAgICBiID0gYigpO1xuICAgIGIudGhlbihmdW5jdGlvbiAoYikge1xuICAgICAgaWYgKDAgPT09IGEuX3N0YXR1cyB8fCAtMSA9PT0gYS5fc3RhdHVzKSBhLl9zdGF0dXMgPSAxLCBhLl9yZXN1bHQgPSBiO1xuICAgIH0sIGZ1bmN0aW9uIChiKSB7XG4gICAgICBpZiAoMCA9PT0gYS5fc3RhdHVzIHx8IC0xID09PSBhLl9zdGF0dXMpIGEuX3N0YXR1cyA9IDIsIGEuX3Jlc3VsdCA9IGI7XG4gICAgfSk7XG4gICAgLTEgPT09IGEuX3N0YXR1cyAmJiAoYS5fc3RhdHVzID0gMCwgYS5fcmVzdWx0ID0gYik7XG4gIH1cblxuICBpZiAoMSA9PT0gYS5fc3RhdHVzKSByZXR1cm4gYS5fcmVzdWx0LmRlZmF1bHQ7XG4gIHRocm93IGEuX3Jlc3VsdDtcbn1cblxudmFyIFMgPSB7XG4gIGN1cnJlbnQ6IG51bGxcbn0sXG4gICAgVCA9IHtcbiAgdHJhbnNpdGlvbjogMFxufSxcbiAgICBVID0ge1xuICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyOiBTLFxuICBSZWFjdEN1cnJlbnRCYXRjaENvbmZpZzogVCxcbiAgUmVhY3RDdXJyZW50T3duZXI6IEksXG4gIGFzc2lnbjogbFxufTtcbmV4cG9ydHMuQ2hpbGRyZW4gPSB7XG4gIG1hcDogUSxcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChhLCBiLCBjKSB7XG4gICAgUShhLCBmdW5jdGlvbiAoKSB7XG4gICAgICBiLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSwgYyk7XG4gIH0sXG4gIGNvdW50OiBmdW5jdGlvbiBjb3VudChhKSB7XG4gICAgdmFyIGIgPSAwO1xuICAgIFEoYSwgZnVuY3Rpb24gKCkge1xuICAgICAgYisrO1xuICAgIH0pO1xuICAgIHJldHVybiBiO1xuICB9LFxuICB0b0FycmF5OiBmdW5jdGlvbiB0b0FycmF5KGEpIHtcbiAgICByZXR1cm4gUShhLCBmdW5jdGlvbiAoYSkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSkgfHwgW107XG4gIH0sXG4gIG9ubHk6IGZ1bmN0aW9uIG9ubHkoYSkge1xuICAgIGlmICghTShhKSkgdGhyb3cgRXJyb3IoeigxNDMpKTtcbiAgICByZXR1cm4gYTtcbiAgfVxufTtcbmV4cG9ydHMuQ29tcG9uZW50ID0gQztcbmV4cG9ydHMuUHVyZUNvbXBvbmVudCA9IEU7XG5leHBvcnRzLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEID0gVTtcblxuZXhwb3J0cy5jbG9uZUVsZW1lbnQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICBpZiAobnVsbCA9PT0gYSB8fCB2b2lkIDAgPT09IGEpIHRocm93IEVycm9yKHooMjY3LCBhKSk7XG4gIHZhciBlID0gbCh7fSwgYS5wcm9wcyksXG4gICAgICBkID0gYS5rZXksXG4gICAgICBrID0gYS5yZWYsXG4gICAgICBoID0gYS5fb3duZXI7XG5cbiAgaWYgKG51bGwgIT0gYikge1xuICAgIHZvaWQgMCAhPT0gYi5yZWYgJiYgKGsgPSBiLnJlZiwgaCA9IEkuY3VycmVudCk7XG4gICAgdm9pZCAwICE9PSBiLmtleSAmJiAoZCA9IFwiXCIgKyBiLmtleSk7XG4gICAgaWYgKGEudHlwZSAmJiBhLnR5cGUuZGVmYXVsdFByb3BzKSB2YXIgZyA9IGEudHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICBmb3IgKGYgaW4gYikge1xuICAgICAgSC5jYWxsKGIsIGYpICYmICFKLmhhc093blByb3BlcnR5KGYpICYmIChlW2ZdID0gdm9pZCAwID09PSBiW2ZdICYmIHZvaWQgMCAhPT0gZyA/IGdbZl0gOiBiW2ZdKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoMSA9PT0gZikgZS5jaGlsZHJlbiA9IGM7ZWxzZSBpZiAoMSA8IGYpIHtcbiAgICBnID0gQXJyYXkoZik7XG5cbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IGY7IG4rKykge1xuICAgICAgZ1tuXSA9IGFyZ3VtZW50c1tuICsgMl07XG4gICAgfVxuXG4gICAgZS5jaGlsZHJlbiA9IGc7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogbSxcbiAgICB0eXBlOiBhLnR5cGUsXG4gICAga2V5OiBkLFxuICAgIHJlZjogayxcbiAgICBwcm9wczogZSxcbiAgICBfb3duZXI6IGhcbiAgfTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSB7XG4gICAgJCR0eXBlb2Y6IHIsXG4gICAgX2N1cnJlbnRWYWx1ZTogYSxcbiAgICBfY3VycmVudFZhbHVlMjogYSxcbiAgICBfdGhyZWFkQ291bnQ6IDAsXG4gICAgUHJvdmlkZXI6IG51bGwsXG4gICAgQ29uc3VtZXI6IG51bGxcbiAgfTtcbiAgYS5Qcm92aWRlciA9IHtcbiAgICAkJHR5cGVvZjogcSxcbiAgICBfY29udGV4dDogYVxuICB9O1xuICByZXR1cm4gYS5Db25zdW1lciA9IGE7XG59O1xuXG5leHBvcnRzLmNyZWF0ZUVsZW1lbnQgPSBLO1xuXG5leHBvcnRzLmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAoYSkge1xuICB2YXIgYiA9IEsuYmluZChudWxsLCBhKTtcbiAgYi50eXBlID0gYTtcbiAgcmV0dXJuIGI7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBudWxsXG4gIH07XG59O1xuXG5leHBvcnRzLmZvcndhcmRSZWYgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiB0LFxuICAgIHJlbmRlcjogYVxuICB9O1xufTtcblxuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudCA9IE07XG5cbmV4cG9ydHMubGF6eSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IHYsXG4gICAgX3BheWxvYWQ6IHtcbiAgICAgIF9zdGF0dXM6IC0xLFxuICAgICAgX3Jlc3VsdDogYVxuICAgIH0sXG4gICAgX2luaXQ6IFJcbiAgfTtcbn07XG5cbmV4cG9ydHMubWVtbyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IHUsXG4gICAgdHlwZTogYSxcbiAgICBjb21wYXJlOiB2b2lkIDAgPT09IGIgPyBudWxsIDogYlxuICB9O1xufTtcblxuZXhwb3J0cy5zdGFydFRyYW5zaXRpb24gPSBmdW5jdGlvbiAoYSkge1xuICB2YXIgYiA9IFQudHJhbnNpdGlvbjtcbiAgVC50cmFuc2l0aW9uID0gMTtcblxuICB0cnkge1xuICAgIGEoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBULnRyYW5zaXRpb24gPSBiO1xuICB9XG59O1xuXG5leHBvcnRzLnVuc3RhYmxlX2FjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgRXJyb3Ioeig0MDYpKTtcbn07XG5cbmV4cG9ydHMudW5zdGFibGVfY3JlYXRlTXV0YWJsZVNvdXJjZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiB7XG4gICAgX2dldFZlcnNpb246IGIsXG4gICAgX3NvdXJjZTogYSxcbiAgICBfd29ya0luUHJvZ3Jlc3NWZXJzaW9uUHJpbWFyeTogbnVsbCxcbiAgICBfd29ya0luUHJvZ3Jlc3NWZXJzaW9uU2Vjb25kYXJ5OiBudWxsXG4gIH07XG59O1xuXG5leHBvcnRzLnVuc3RhYmxlX2dldENhY2hlRm9yVHlwZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBTLmN1cnJlbnQuZ2V0Q2FjaGVGb3JUeXBlKGEpO1xufTtcblxuZXhwb3J0cy51bnN0YWJsZV91c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBTLmN1cnJlbnQudXNlQ2FjaGVSZWZyZXNoKCk7XG59O1xuXG5leHBvcnRzLnVuc3RhYmxlX3VzZU11dGFibGVTb3VyY2UgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICByZXR1cm4gUy5jdXJyZW50LnVzZU11dGFibGVTb3VyY2UoYSwgYiwgYyk7XG59O1xuXG5leHBvcnRzLnVuc3RhYmxlX3VzZU9wYXF1ZUlkZW50aWZpZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBTLmN1cnJlbnQudXNlT3BhcXVlSWRlbnRpZmllcigpO1xufTtcblxuZXhwb3J0cy51c2VDYWxsYmFjayA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBTLmN1cnJlbnQudXNlQ2FsbGJhY2soYSwgYik7XG59O1xuXG5leHBvcnRzLnVzZUNvbnRleHQgPSBmdW5jdGlvbiAoYSkge1xuICByZXR1cm4gUy5jdXJyZW50LnVzZUNvbnRleHQoYSk7XG59O1xuXG5leHBvcnRzLnVzZURlYnVnVmFsdWUgPSBmdW5jdGlvbiAoKSB7fTtcblxuZXhwb3J0cy51c2VEZWZlcnJlZFZhbHVlID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIFMuY3VycmVudC51c2VEZWZlcnJlZFZhbHVlKGEpO1xufTtcblxuZXhwb3J0cy51c2VFZmZlY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gUy5jdXJyZW50LnVzZUVmZmVjdChhLCBiKTtcbn07XG5cbmV4cG9ydHMudXNlSW1wZXJhdGl2ZUhhbmRsZSA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gIHJldHVybiBTLmN1cnJlbnQudXNlSW1wZXJhdGl2ZUhhbmRsZShhLCBiLCBjKTtcbn07XG5cbmV4cG9ydHMudXNlTGF5b3V0RWZmZWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIFMuY3VycmVudC51c2VMYXlvdXRFZmZlY3QoYSwgYik7XG59O1xuXG5leHBvcnRzLnVzZU1lbW8gPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gUy5jdXJyZW50LnVzZU1lbW8oYSwgYik7XG59O1xuXG5leHBvcnRzLnVzZVJlZHVjZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xuICByZXR1cm4gUy5jdXJyZW50LnVzZVJlZHVjZXIoYSwgYiwgYyk7XG59O1xuXG5leHBvcnRzLnVzZVJlZiA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBTLmN1cnJlbnQudXNlUmVmKGEpO1xufTtcblxuZXhwb3J0cy51c2VTdGF0ZSA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBTLmN1cnJlbnQudXNlU3RhdGUoYSk7XG59O1xuXG5leHBvcnRzLnVzZVRyYW5zaXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBTLmN1cnJlbnQudXNlVHJhbnNpdGlvbigpO1xufTtcblxuZXhwb3J0cy52ZXJzaW9uID0gXCIxOC4wLjAtZXhwZXJpbWVudGFsLWY2ZWM0NjYxZC0yMDIxMDgxNlwiO1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYUE9SVFNcbl9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNvbm5lY3RUb0RldlRvb2xzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gLyogYmluZGluZyAqLyBjb25uZWN0VG9EZXZUb29sczsgfSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvZXZlbnRzLmpzXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50RW1pdHRlcik7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJsaXN0ZW5lcnNNYXBcIiwgbmV3IE1hcCgpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhFdmVudEVtaXR0ZXIsIFt7XG4gICAga2V5OiBcImFkZExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzTWFwLmdldChldmVudCk7XG5cbiAgICAgIGlmIChsaXN0ZW5lcnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc01hcC5zZXQoZXZlbnQsIFtsaXN0ZW5lcl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuXG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICBsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbWl0KGV2ZW50KSB7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNNYXAuZ2V0KGV2ZW50KTtcblxuICAgICAgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgLy8gTm8gbmVlZCB0byBjbG9uZSBvciB0cnkvY2F0Y2hcbiAgICAgICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbMF07XG4gICAgICAgICAgbGlzdGVuZXIuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGRpZFRocm93ID0gZmFsc2U7XG4gICAgICAgICAgdmFyIGNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgICAgICB2YXIgY2xvbmVkTGlzdGVuZXJzID0gQXJyYXkuZnJvbShsaXN0ZW5lcnMpO1xuXG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbG9uZWRMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBfbGlzdGVuZXIgPSBjbG9uZWRMaXN0ZW5lcnNbaV07XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIF9saXN0ZW5lci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRpZFRocm93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpZFRocm93KSB7XG4gICAgICAgICAgICB0aHJvdyBjYXVnaHRFcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlQWxsTGlzdGVuZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycygpIHtcbiAgICAgIHRoaXMubGlzdGVuZXJzTWFwLmNsZWFyKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUxpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzTWFwLmdldChldmVudCk7XG5cbiAgICAgIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICBsaXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBFdmVudEVtaXR0ZXI7XG59KCk7XG5cblxuLy8gRVhURVJOQUwgTU9EVUxFOiAvVXNlcnMvbHVuYS9jb2RlL3JlYWN0L25vZGVfbW9kdWxlcy9sb2Rhc2gudGhyb3R0bGUvaW5kZXguanNcbnZhciBsb2Rhc2hfdGhyb3R0bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIGxvZGFzaF90aHJvdHRsZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfdGhyb3R0bGUpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2NvbnN0YW50cy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuLy8gRmxpcCB0aGlzIGZsYWcgdG8gdHJ1ZSB0byBlbmFibGUgdmVyYm9zZSBjb25zb2xlIGRlYnVnIGxvZ2dpbmcuXG52YXIgX19ERUJVR19fID0gZmFsc2U7XG52YXIgVFJFRV9PUEVSQVRJT05fQUREID0gMTtcbnZhciBUUkVFX09QRVJBVElPTl9SRU1PVkUgPSAyO1xudmFyIFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4gPSAzO1xudmFyIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT04gPSA0O1xudmFyIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1MgPSA1O1xudmFyIFRSRUVfT1BFUkFUSU9OX1JFTU9WRV9ST09UID0gNjtcbnZhciBMT0NBTF9TVE9SQUdFX0ZJTFRFUl9QUkVGRVJFTkNFU19LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpjb21wb25lbnRGaWx0ZXJzJztcbnZhciBTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6bGFzdFNlbGVjdGlvbic7XG52YXIgTE9DQUxfU1RPUkFHRV9QQVJTRV9IT09LX05BTUVTX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OnBhcnNlSG9va05hbWVzJztcbnZhciBTRVNTSU9OX1NUT1JBR0VfUkVDT1JEX0NIQU5HRV9ERVNDUklQVElPTlNfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6cmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zJztcbnZhciBTRVNTSU9OX1NUT1JBR0VfUkVMT0FEX0FORF9QUk9GSUxFX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OnJlbG9hZEFuZFByb2ZpbGUnO1xudmFyIExPQ0FMX1NUT1JBR0VfU0hPVUxEX0JSRUFLX09OX0NPTlNPTEVfRVJST1JTID0gJ1JlYWN0OjpEZXZUb29sczo6YnJlYWtPbkNvbnNvbGVFcnJvcnMnO1xudmFyIExPQ0FMX1NUT1JBR0VfU0hPVUxEX1BBVENIX0NPTlNPTEVfS0VZID0gJ1JlYWN0OjpEZXZUb29sczo6YXBwZW5kQ29tcG9uZW50U3RhY2snO1xudmFyIExPQ0FMX1NUT1JBR0VfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19LRVkgPSAnUmVhY3Q6OkRldlRvb2xzOjpzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMnO1xudmFyIExPQ0FMX1NUT1JBR0VfVFJBQ0VfVVBEQVRFU19FTkFCTEVEX0tFWSA9ICdSZWFjdDo6RGV2VG9vbHM6OnRyYWNlVXBkYXRlc0VuYWJsZWQnO1xudmFyIFBST0ZJTEVSX0VYUE9SVF9WRVJTSU9OID0gNTtcbnZhciBDSEFOR0VfTE9HX1VSTCA9ICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LWRldnRvb2xzL0NIQU5HRUxPRy5tZCc7XG52YXIgVU5TVVBQT1JURURfVkVSU0lPTl9VUkwgPSAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9ibG9nLzIwMTkvMDgvMTUvbmV3LXJlYWN0LWRldnRvb2xzLmh0bWwjaG93LWRvLWktZ2V0LXRoZS1vbGQtdmVyc2lvbi1iYWNrJztcbnZhciBSRUFDVF9ERVZUT09MU19XT1JLUExBQ0VfVVJMID0gJ2h0dHBzOi8vZmJ1cmwuY29tL3JlYWN0LWRldnRvb2xzLXdvcmtwbGFjZS1ncm91cCc7XG52YXIgVEhFTUVfU1RZTEVTID0ge1xuICBsaWdodDoge1xuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lJzogJyNlZjY2MzInLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS1uYW1lLW5vdC1lZGl0YWJsZSc6ICcjMjMyNzJmJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZS1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZSc6ICcjMWExYWE2JyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtdmFsdWUtaW52ZXJ0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLWVkaXRhYmxlLXZhbHVlJzogJyMxYTFhYTYnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItYmFja2dyb3VuZC1ob3Zlcic6ICdyZ2JhKDAsIDEzNiwgMjUwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWluYWN0aXZlJzogJyNlNWU1ZTUnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaW52YWxpZCc6ICcjZmZmMGYwJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLXNlbGVjdGVkJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kLWZvY3VzJzogJyNlZGVkZWQnLFxuICAgICctLWNvbG9yLWJ1dHRvbic6ICcjNWY2NjczJyxcbiAgICAnLS1jb2xvci1idXR0b24tZGlzYWJsZWQnOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItYnV0dG9uLWFjdGl2ZSc6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1idXR0b24tZm9jdXMnOiAnIzIzMjcyZicsXG4gICAgJy0tY29sb3ItYnV0dG9uLWhvdmVyJzogJyMyMzI3MmYnLFxuICAgICctLWNvbG9yLWJvcmRlcic6ICcjZWVlZWVlJyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbCc6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuLXRleHQnOiAnIzMzMzMzMycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTAnOiAnIzM3YWZhOScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTEnOiAnIzYzYjE5ZScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTInOiAnIzgwYjM5MycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTMnOiAnIzk3YjQ4OCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTQnOiAnI2FiYjY3ZCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTUnOiAnI2JlYjc3MScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTYnOiAnI2NmYjk2NScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTcnOiAnI2RmYmE1NycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTgnOiAnI2VmYmI0OScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTknOiAnI2ZlYmMzOCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUnOiAnIzZhNTFiMicsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUtaW52ZXJ0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWJhY2tncm91bmQnOiAncmdiYSgwLCAwLCAwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtYmFja2dyb3VuZC1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1jb21wb25lbnQtYmFkZ2UtY291bnQnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWNvdW50LWludmVydGVkJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43KScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1iYWRnZS10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFja2dyb3VuZCc6ICcjZmZmMGYwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJvcmRlcic6ICcjZmZkNmQ2JyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWljb24nOiAnI2ViMzk0MScsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci10ZXh0JzogJyNmZTJlMzEnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWRnZS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1iYWNrZ3JvdW5kJzogJyNmZmZiZTUnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1ib3JkZXInOiAnI2ZmZjVjMScsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLWljb24nOiAnI2Y0YmQwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS13YXJuaW5nLXRleHQnOiAnIzY0NDYwYycsXG4gICAgJy0tY29sb3ItY29udGV4dC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwwLDAsLjkpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtaG92ZXInOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItY29udGV4dC1ib3JkZXInOiAnIzNkNDI0YScsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0JzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLWNvbnRleHQtdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1kaW0nOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItZGltbWVyJzogJyNjZmQxZDUnLFxuICAgICctLWNvbG9yLWRpbW1lc3QnOiAnI2VmZjBmMScsXG4gICAgJy0tY29sb3ItZXJyb3ItYmFja2dyb3VuZCc6ICdoc2woMCwgMTAwJSwgOTclKScsXG4gICAgJy0tY29sb3ItZXJyb3ItYm9yZGVyJzogJ2hzbCgwLCAxMDAlLCA5MiUpJyxcbiAgICAnLS1jb2xvci1lcnJvci10ZXh0JzogJyNmZjAwMDAnLFxuICAgICctLWNvbG9yLWV4cGFuZC1jb2xsYXBzZS10b2dnbGUnOiAnIzc3N2Q4OCcsXG4gICAgJy0tY29sb3ItbGluayc6ICcjMDAwMGZmJyxcbiAgICAnLS1jb2xvci1tb2RhbC1iYWNrZ3JvdW5kJzogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS1iYWNrZ3JvdW5kJzogJyNlZmYwZjEnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW5wbS10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWJyaWRnZS12ZXJzaW9uLW51bWJlcic6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci1wcmltaXRpdmUtaG9vay1iYWRnZS1iYWNrZ3JvdW5kJzogJyNlNWU1ZTUnLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLXRleHQnOiAnIzVmNjY3MycsXG4gICAgJy0tY29sb3ItcmVjb3JkLWFjdGl2ZSc6ICcjZmMzYTRiJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtaG92ZXInOiAnIzM1NzhlNScsXG4gICAgJy0tY29sb3ItcmVjb3JkLWluYWN0aXZlJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLXJlc2l6ZS1iYXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1hY3RpdmUnOiAnI2RjZGNkYycsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1ib3JkZXInOiAnI2QxZDFkMScsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhci1kb3QnOiAnIzMzMzMzMycsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1uYXRpdmUtZXZlbnQnOiAnI2NjYycsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1uYXRpdmUtZXZlbnQtaG92ZXInOiAnI2FhYScsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1wcmlvcml0eS1iYWNrZ3JvdW5kJzogJyNmNmY2ZjYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcHJpb3JpdHktYm9yZGVyJzogJyNlZWVlZWUnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItdXNlci10aW1pbmcnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci11c2VyLXRpbWluZy1ob3Zlcic6ICcjOTM5NTlhJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LWlkbGUnOiAnI2QzZTVmNicsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1pZGxlLWhvdmVyJzogJyNjM2Q5ZWYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtcmVuZGVyJzogJyM5ZmMzZjMnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtcmVuZGVyLWhvdmVyJzogJyM4M2FmZTknLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtcmVuZGVyLXRleHQnOiAnIzExMzY1ZScsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1jb21taXQnOiAnI2M4OGZmMCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1jb21taXQtaG92ZXInOiAnI2IyODFkNicsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1jb21taXQtdGV4dCc6ICcjM2UyYzRhJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LWxheW91dC1lZmZlY3RzJzogJyNiMjgxZDYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtbGF5b3V0LWVmZmVjdHMtaG92ZXInOiAnIzlkNzFiZCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1sYXlvdXQtZWZmZWN0cy10ZXh0JzogJyMzZTJjNGEnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtcGFzc2l2ZS1lZmZlY3RzJzogJyNiMjgxZDYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLWhvdmVyJzogJyM5ZDcxYmQnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtcGFzc2l2ZS1lZmZlY3RzLXRleHQnOiAnIzNlMmM0YScsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1zY2hlZHVsZSc6ICcjOWZjM2YzJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LXNjaGVkdWxlLWhvdmVyJzogJyMyNjgzRTInLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3Qtc3VzcGVuc2UtcmVqZWN0ZWQnOiAnI2YxY2MxNCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1zdXNwZW5zZS1yZWplY3RlZC1ob3Zlcic6ICcjZmZkZjM3JyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LXN1c3BlbnNlLXJlc29sdmVkJzogJyNhNmU1OWYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQtaG92ZXInOiAnIzg5ZDI4MScsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1zdXNwZW5zZS11bnJlc29sdmVkJzogJyNjOWNhY2QnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3Qtc3VzcGVuc2UtdW5yZXNvbHZlZC1ob3Zlcic6ICcjOTM5NTlhJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXRleHQtY29sb3InOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci10ZXh0LWRpbS1jb2xvcic6ICcjY2NjJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LXdvcmstYm9yZGVyJzogJyNmZmZmZmYnLFxuICAgICctLWNvbG9yLXNlYXJjaC1tYXRjaCc6ICd5ZWxsb3cnLFxuICAgICctLWNvbG9yLXNlYXJjaC1tYXRjaC1jdXJyZW50JzogJyNmNzkyM2InLFxuICAgICctLWNvbG9yLXNlbGVjdGVkLXRyZWUtaGlnaGxpZ2h0LWFjdGl2ZSc6ICdyZ2JhKDAsIDEzNiwgMjUwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1zZWxlY3RlZC10cmVlLWhpZ2hsaWdodC1pbmFjdGl2ZSc6ICdyZ2JhKDAsIDAsIDAsIDAuMDUpJyxcbiAgICAnLS1jb2xvci1zY3JvbGwtY2FyZXQnOiAncmdiYSgxNTAsIDE1MCwgMTUwLCAwLjUpJyxcbiAgICAnLS1jb2xvci10YWItc2VsZWN0ZWQtYm9yZGVyJzogJyMwMDg4ZmEnLFxuICAgICctLWNvbG9yLXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItdGV4dC1pbnZhbGlkJzogJyNmZjAwMDAnLFxuICAgICctLWNvbG9yLXRleHQtc2VsZWN0ZWQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItdG9nZ2xlLWJhY2tncm91bmQtaW52YWxpZCc6ICcjZmMzYTRiJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1vbic6ICcjMDA4OGZhJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1vZmYnOiAnI2NmZDFkNScsXG4gICAgJy0tY29sb3ItdG9nZ2xlLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kJzogJyNmYjM2NTUnLFxuICAgICctLWNvbG9yLXdhcm5pbmctYmFja2dyb3VuZC1ob3Zlcic6ICcjZjgyMDQyJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLXRleHQtY29sb3InOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3Itd2FybmluZy10ZXh0LWNvbG9yLWludmVydGVkJzogJyNmZDRkNjknLFxuICAgIC8vIFRoZSBzdHlsZXMgYmVsb3cgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoICdyb290LmNzcydcbiAgICAvLyBUaGV5IGFyZSByZXBlYXRlZCB0aGVyZSBiZWNhdXNlIHRoZXkncmUgdXNlZCBieSBlLmcuIHRvb2x0aXBzIG9yIGNvbnRleHQgbWVudXNcbiAgICAvLyB3aGljaCBnZXQgcmVuZGVyZWQgb3V0c2lkZSBvZiB0aGUgRE9NIHN1YnRyZWUgKHdoZXJlIG5vcm1hbCB0aGVtZS9zdHlsZXMgYXJlIHdyaXR0ZW4pLlxuICAgICctLWNvbG9yLXNjcm9sbC10aHVtYic6ICcjYzJjMmMyJyxcbiAgICAnLS1jb2xvci1zY3JvbGwtdHJhY2snOiAnI2ZhZmFmYScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC45KScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC10ZXh0JzogJyNmZmZmZmYnXG4gIH0sXG4gIGRhcms6IHtcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZSc6ICcjOWQ4N2QyJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtbmFtZS1ub3QtZWRpdGFibGUnOiAnI2VkZWRlZCcsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLW5hbWUtaW52ZXJ0ZWQnOiAnIzI4MjgyOCcsXG4gICAgJy0tY29sb3ItYXR0cmlidXRlLXZhbHVlJzogJyNjZWRhZTAnLFxuICAgICctLWNvbG9yLWF0dHJpYnV0ZS12YWx1ZS1pbnZlcnRlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1hdHRyaWJ1dGUtZWRpdGFibGUtdmFsdWUnOiAneWVsbG93JyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaG92ZXInOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLWluYWN0aXZlJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLWJhY2tncm91bmQtaW52YWxpZCc6ICcjNWMwMDAwJyxcbiAgICAnLS1jb2xvci1iYWNrZ3JvdW5kLXNlbGVjdGVkJzogJyMxNzhmYjknLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kJzogJyMyODJjMzQnLFxuICAgICctLWNvbG9yLWJ1dHRvbi1iYWNrZ3JvdW5kLWZvY3VzJzogJyMzZDQyNGEnLFxuICAgICctLWNvbG9yLWJ1dHRvbic6ICcjYWZiM2I5JyxcbiAgICAnLS1jb2xvci1idXR0b24tYWN0aXZlJzogJyM2MWRhZmInLFxuICAgICctLWNvbG9yLWJ1dHRvbi1kaXNhYmxlZCc6ICcjNGY1NzY2JyxcbiAgICAnLS1jb2xvci1idXR0b24tZm9jdXMnOiAnI2EyZTlmYycsXG4gICAgJy0tY29sb3ItYnV0dG9uLWhvdmVyJzogJyNlZGVkZWQnLFxuICAgICctLWNvbG9yLWJvcmRlcic6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbCc6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci1jb21taXQtZGlkLW5vdC1yZW5kZXItZmlsbC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuJzogJyM2NjZjNzcnLFxuICAgICctLWNvbG9yLWNvbW1pdC1kaWQtbm90LXJlbmRlci1wYXR0ZXJuLXRleHQnOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTAnOiAnIzM3YWZhOScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTEnOiAnIzYzYjE5ZScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTInOiAnIzgwYjM5MycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTMnOiAnIzk3YjQ4OCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTQnOiAnI2FiYjY3ZCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTUnOiAnI2JlYjc3MScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTYnOiAnI2NmYjk2NScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTcnOiAnI2RmYmE1NycsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTgnOiAnI2VmYmI0OScsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LTknOiAnI2ZlYmMzOCcsXG4gICAgJy0tY29sb3ItY29tbWl0LWdyYWRpZW50LXRleHQnOiAnIzAwMDAwMCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUnOiAnIzYxZGFmYicsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LW5hbWUtaW52ZXJ0ZWQnOiAnIzI4MjgyOCcsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWJhY2tncm91bmQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KScsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWJhY2tncm91bmQtaW52ZXJ0ZWQnOiAncmdiYSgwLCAwLCAwLCAwLjI1KScsXG4gICAgJy0tY29sb3ItY29tcG9uZW50LWJhZGdlLWNvdW50JzogJyM4Zjk0OWQnLFxuICAgICctLWNvbG9yLWNvbXBvbmVudC1iYWRnZS1jb3VudC1pbnZlcnRlZCc6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItYmFkZ2UtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLWVycm9yLWJhY2tncm91bmQnOiAnIzI5MDAwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1ib3JkZXInOiAnIzVjMDAwMCcsXG4gICAgJy0tY29sb3ItY29uc29sZS1lcnJvci1pY29uJzogJyNlYjM5NDEnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtZXJyb3ItdGV4dCc6ICcjZmM3ZjdmJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYmFkZ2UtdGV4dCc6ICcjMDAwMDAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYmFja2dyb3VuZCc6ICcjMzMyYjAwJyxcbiAgICAnLS1jb2xvci1jb25zb2xlLXdhcm5pbmctYm9yZGVyJzogJyM2NjU1MDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy1pY29uJzogJyNmNGJkMDAnLFxuICAgICctLWNvbG9yLWNvbnNvbGUtd2FybmluZy10ZXh0JzogJyNmNWYyZWQnLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZCc6ICdyZ2JhKDI1NSwyNTUsMjU1LC45NSknLFxuICAgICctLWNvbG9yLWNvbnRleHQtYmFja2dyb3VuZC1ob3Zlcic6ICdyZ2JhKDAsIDEzNiwgMjUwLCAwLjEpJyxcbiAgICAnLS1jb2xvci1jb250ZXh0LWJhY2tncm91bmQtc2VsZWN0ZWQnOiAnIzAwODhmYScsXG4gICAgJy0tY29sb3ItY29udGV4dC1ib3JkZXInOiAnI2VlZWVlZScsXG4gICAgJy0tY29sb3ItY29udGV4dC10ZXh0JzogJyMwMDAwMDAnLFxuICAgICctLWNvbG9yLWNvbnRleHQtdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1kaW0nOiAnIzhmOTQ5ZCcsXG4gICAgJy0tY29sb3ItZGltbWVyJzogJyM3NzdkODgnLFxuICAgICctLWNvbG9yLWRpbW1lc3QnOiAnIzRmNTc2NicsXG4gICAgJy0tY29sb3ItZXJyb3ItYmFja2dyb3VuZCc6ICcjMjAwJyxcbiAgICAnLS1jb2xvci1lcnJvci1ib3JkZXInOiAnIzkwMCcsXG4gICAgJy0tY29sb3ItZXJyb3ItdGV4dCc6ICcjZjU1JyxcbiAgICAnLS1jb2xvci1leHBhbmQtY29sbGFwc2UtdG9nZ2xlJzogJyM4Zjk0OWQnLFxuICAgICctLWNvbG9yLWxpbmsnOiAnIzYxZGFmYicsXG4gICAgJy0tY29sb3ItbW9kYWwtYmFja2dyb3VuZCc6ICdyZ2JhKDAsIDAsIDAsIDAuNzUpJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1ucG0tYmFja2dyb3VuZCc6ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1ucG0tdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci1icmlkZ2UtdmVyc2lvbi1udW1iZXInOiAneWVsbG93JyxcbiAgICAnLS1jb2xvci1wcmltaXRpdmUtaG9vay1iYWRnZS1iYWNrZ3JvdW5kJzogJ3JnYmEoMCwgMCwgMCwgMC4yNSknLFxuICAgICctLWNvbG9yLXByaW1pdGl2ZS1ob29rLWJhZGdlLXRleHQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtYWN0aXZlJzogJyNmYzNhNGInLFxuICAgICctLWNvbG9yLXJlY29yZC1ob3Zlcic6ICcjYTJlOWZjJyxcbiAgICAnLS1jb2xvci1yZWNvcmQtaW5hY3RpdmUnOiAnIzYxZGFmYicsXG4gICAgJy0tY29sb3ItcmVzaXplLWJhcic6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWFjdGl2ZSc6ICcjMzEzNjNmJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWJvcmRlcic6ICcjM2Q0MjRhJyxcbiAgICAnLS1jb2xvci1yZXNpemUtYmFyLWRvdCc6ICcjY2ZkMWQ1JyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLW5hdGl2ZS1ldmVudCc6ICcjYjJiMmIyJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLW5hdGl2ZS1ldmVudC1ob3Zlcic6ICcjOTQ5NDk0JyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXByaW9yaXR5LWJhY2tncm91bmQnOiAnIzFkMjEyOScsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1wcmlvcml0eS1ib3JkZXInOiAnIzI4MmMzNCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci11c2VyLXRpbWluZyc6ICcjYzljYWNkJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXVzZXItdGltaW5nLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtaWRsZSc6ICcjM2Q0ODViJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LWlkbGUtaG92ZXInOiAnIzQ2NTI2OScsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1yZW5kZXInOiAnIzI2ODNFMicsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1yZW5kZXItaG92ZXInOiAnIzFhNzZkNCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1yZW5kZXItdGV4dCc6ICcjMTEzNjVlJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LWNvbW1pdCc6ICcjNzMxZmFkJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LWNvbW1pdC1ob3Zlcic6ICcjNjExYjk0JyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LWNvbW1pdC10ZXh0JzogJyNlNWMxZmYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3QtbGF5b3V0LWVmZmVjdHMnOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1sYXlvdXQtZWZmZWN0cy1ob3Zlcic6ICcjNTExNjdhJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LWxheW91dC1lZmZlY3RzLXRleHQnOiAnI2U1YzFmZicsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1wYXNzaXZlLWVmZmVjdHMnOiAnIzYxMWI5NCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1wYXNzaXZlLWVmZmVjdHMtaG92ZXInOiAnIzUxMTY3YScsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1wYXNzaXZlLWVmZmVjdHMtdGV4dCc6ICcjZTVjMWZmJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LXNjaGVkdWxlJzogJyMyNjgzRTInLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3Qtc2NoZWR1bGUtaG92ZXInOiAnIzFhNzZkNCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1zdXNwZW5zZS1yZWplY3RlZCc6ICcjZjFjYzE0JyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LXN1c3BlbnNlLXJlamVjdGVkLWhvdmVyJzogJyNlNGMwMGYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3Qtc3VzcGVuc2UtcmVzb2x2ZWQnOiAnI2E2ZTU5ZicsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1zdXNwZW5zZS1yZXNvbHZlZC1ob3Zlcic6ICcjODlkMjgxJyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXJlYWN0LXN1c3BlbnNlLXVucmVzb2x2ZWQnOiAnI2M5Y2FjZCcsXG4gICAgJy0tY29sb3Itc2NoZWR1bGluZy1wcm9maWxlci1yZWFjdC1zdXNwZW5zZS11bnJlc29sdmVkLWhvdmVyJzogJyM5Mzk1OWEnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItdGV4dC1jb2xvcic6ICcjMjgyYzM0JyxcbiAgICAnLS1jb2xvci1zY2hlZHVsaW5nLXByb2ZpbGVyLXRleHQtZGltLWNvbG9yJzogJyM1NTViNjYnLFxuICAgICctLWNvbG9yLXNjaGVkdWxpbmctcHJvZmlsZXItcmVhY3Qtd29yay1ib3JkZXInOiAnI2ZmZmZmZicsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoJzogJ3llbGxvdycsXG4gICAgJy0tY29sb3Itc2VhcmNoLW1hdGNoLWN1cnJlbnQnOiAnI2Y3OTIzYicsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtYWN0aXZlJzogJ3JnYmEoMjMsIDE0MywgMTg1LCAwLjE1KScsXG4gICAgJy0tY29sb3Itc2VsZWN0ZWQtdHJlZS1oaWdobGlnaHQtaW5hY3RpdmUnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA1KScsXG4gICAgJy0tY29sb3Itc2Nyb2xsLWNhcmV0JzogJyM0ZjU3NjYnLFxuICAgICctLWNvbG9yLXNoYWRvdyc6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICctLWNvbG9yLXRhYi1zZWxlY3RlZC1ib3JkZXInOiAnIzE3OGZiOScsXG4gICAgJy0tY29sb3ItdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci10ZXh0LWludmFsaWQnOiAnI2ZmODA4MCcsXG4gICAgJy0tY29sb3ItdGV4dC1zZWxlY3RlZCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci10b2dnbGUtYmFja2dyb3VuZC1pbnZhbGlkJzogJyNmYzNhNGInLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9uJzogJyMxNzhmYjknLFxuICAgICctLWNvbG9yLXRvZ2dsZS1iYWNrZ3JvdW5kLW9mZic6ICcjNzc3ZDg4JyxcbiAgICAnLS1jb2xvci10b2dnbGUtdGV4dCc6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLWJhY2tncm91bmQnOiAnI2VlMTYzOCcsXG4gICAgJy0tY29sb3Itd2FybmluZy1iYWNrZ3JvdW5kLWhvdmVyJzogJyNkYTEwMzAnLFxuICAgICctLWNvbG9yLXdhcm5pbmctdGV4dC1jb2xvcic6ICcjZmZmZmZmJyxcbiAgICAnLS1jb2xvci13YXJuaW5nLXRleHQtY29sb3ItaW52ZXJ0ZWQnOiAnI2VlMTYzOCcsXG4gICAgLy8gVGhlIHN0eWxlcyBiZWxvdyBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggJ3Jvb3QuY3NzJ1xuICAgIC8vIFRoZXkgYXJlIHJlcGVhdGVkIHRoZXJlIGJlY2F1c2UgdGhleSdyZSB1c2VkIGJ5IGUuZy4gdG9vbHRpcHMgb3IgY29udGV4dCBtZW51c1xuICAgIC8vIHdoaWNoIGdldCByZW5kZXJlZCBvdXRzaWRlIG9mIHRoZSBET00gc3VidHJlZSAod2hlcmUgbm9ybWFsIHRoZW1lL3N0eWxlcyBhcmUgd3JpdHRlbikuXG4gICAgJy0tY29sb3Itc2Nyb2xsLXRodW1iJzogJyNhZmIzYjknLFxuICAgICctLWNvbG9yLXNjcm9sbC10cmFjayc6ICcjMzEzNjQwJyxcbiAgICAnLS1jb2xvci10b29sdGlwLWJhY2tncm91bmQnOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjk1KScsXG4gICAgJy0tY29sb3ItdG9vbHRpcC10ZXh0JzogJyMwMDAwMDAnXG4gIH0sXG4gIGNvbXBhY3Q6IHtcbiAgICAnLS1mb250LXNpemUtbW9ub3NwYWNlLXNtYWxsJzogJzlweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1ub3JtYWwnOiAnMTFweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1sYXJnZSc6ICcxNXB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1zbWFsbCc6ICcxMHB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1ub3JtYWwnOiAnMTJweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbGFyZ2UnOiAnMTRweCcsXG4gICAgJy0tbGluZS1oZWlnaHQtZGF0YSc6ICcxOHB4J1xuICB9LFxuICBjb21mb3J0YWJsZToge1xuICAgICctLWZvbnQtc2l6ZS1tb25vc3BhY2Utc21hbGwnOiAnMTBweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1ub3JtYWwnOiAnMTNweCcsXG4gICAgJy0tZm9udC1zaXplLW1vbm9zcGFjZS1sYXJnZSc6ICcxN3B4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1zbWFsbCc6ICcxMnB4JyxcbiAgICAnLS1mb250LXNpemUtc2Fucy1ub3JtYWwnOiAnMTRweCcsXG4gICAgJy0tZm9udC1zaXplLXNhbnMtbGFyZ2UnOiAnMTZweCcsXG4gICAgJy0tbGluZS1oZWlnaHQtZGF0YSc6ICcyMnB4J1xuICB9XG59OyAvLyBIQUNLXG4vL1xuLy8gU29tZXRpbWVzIHRoZSBpbmxpbmUgdGFyZ2V0IGlzIHJlbmRlcmVkIGJlZm9yZSByb290IHN0eWxlcyBhcmUgYXBwbGllZCxcbi8vIHdoaWNoIHdvdWxkIHJlc3VsdCBpbiBlLmcuIE5hTiBpdGVtU2l6ZSBiZWluZyBwYXNzZWQgdG8gcmVhY3Qtd2luZG93IGxpc3QuXG5cbnZhciBDT01GT1JUQUJMRV9MSU5FX0hFSUdIVCA9IHBhcnNlSW50KFRIRU1FX1NUWUxFUy5jb21mb3J0YWJsZVsnLS1saW5lLWhlaWdodC1kYXRhJ10sIDEwKTtcbnZhciBDT01QQUNUX0xJTkVfSEVJR0hUID0gcGFyc2VJbnQoVEhFTUVfU1RZTEVTLmNvbXBhY3RbJy0tbGluZS1oZWlnaHQtZGF0YSddLCAxMCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvc3RvcmFnZS5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuZnVuY3Rpb24gbG9jYWxTdG9yYWdlR2V0SXRlbShrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gbG9jYWxTdG9yYWdlUmVtb3ZlSXRlbShrZXkpIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cbmZ1bmN0aW9uIGxvY2FsU3RvcmFnZVNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG59XG5mdW5jdGlvbiBzZXNzaW9uU3RvcmFnZUdldEl0ZW0oa2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKGtleSkge1xuICB0cnkge1xuICAgIHNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oa2V5KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG59XG5mdW5jdGlvbiBzZXNzaW9uU3RvcmFnZVNldEl0ZW0oa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIHJldHVybiBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICB9IGNhdGNoIChlcnJvcikge31cbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC9Vc2Vycy9sdW5hL2NvZGUvcmVhY3Qvbm9kZV9tb2R1bGVzL21lbW9pemUtb25lL2VzbS9pbmRleC5qc1xudmFyIHNpbXBsZUlzRXF1YWwgPSBmdW5jdGlvbiBzaW1wbGVJc0VxdWFsKGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IGI7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBlc20gPSAoZnVuY3Rpb24gKHJlc3VsdEZuKSB7XG4gIHZhciBpc0VxdWFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBzaW1wbGVJc0VxdWFsO1xuICB2YXIgbGFzdFRoaXMgPSB2b2lkIDA7XG4gIHZhciBsYXN0QXJncyA9IFtdO1xuICB2YXIgbGFzdFJlc3VsdCA9IHZvaWQgMDtcbiAgdmFyIGNhbGxlZE9uY2UgPSBmYWxzZTtcblxuICB2YXIgaXNOZXdBcmdFcXVhbFRvTGFzdCA9IGZ1bmN0aW9uIGlzTmV3QXJnRXF1YWxUb0xhc3QobmV3QXJnLCBpbmRleCkge1xuICAgIHJldHVybiBpc0VxdWFsKG5ld0FyZywgbGFzdEFyZ3NbaW5kZXhdKTtcbiAgfTtcblxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24gcmVzdWx0KCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBuZXdBcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBuZXdBcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChjYWxsZWRPbmNlICYmIGxhc3RUaGlzID09PSB0aGlzICYmIG5ld0FyZ3MubGVuZ3RoID09PSBsYXN0QXJncy5sZW5ndGggJiYgbmV3QXJncy5ldmVyeShpc05ld0FyZ0VxdWFsVG9MYXN0KSkge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuXG4gICAgY2FsbGVkT25jZSA9IHRydWU7XG4gICAgbGFzdFRoaXMgPSB0aGlzO1xuICAgIGxhc3RBcmdzID0gbmV3QXJncztcbiAgICBsYXN0UmVzdWx0ID0gcmVzdWx0Rm4uYXBwbHkodGhpcywgbmV3QXJncyk7XG4gICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gIH07XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAvVXNlcnMvbHVuYS9jb2RlL3JlYWN0L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzXG52YXIgb2JqZWN0X2Fzc2lnbiA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG52YXIgb2JqZWN0X2Fzc2lnbl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihvYmplY3RfYXNzaWduKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL3V0aWxzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBHZXQgdGhlIHdpbmRvdyBvYmplY3QgZm9yIHRoZSBkb2N1bWVudCB0aGF0IGEgbm9kZSBiZWxvbmdzIHRvLFxuLy8gb3IgcmV0dXJuIG51bGwgaWYgaXQgY2Fubm90IGJlIGZvdW5kIChub2RlIG5vdCBhdHRhY2hlZCB0byBET00sXG4vLyBldGMpLlxuZnVuY3Rpb24gZ2V0T3duZXJXaW5kb3cobm9kZSkge1xuICBpZiAoIW5vZGUub3duZXJEb2N1bWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldztcbn0gLy8gR2V0IHRoZSBpZnJhbWUgY29udGFpbmluZyBhIG5vZGUsIG9yIHJldHVybiBudWxsIGlmIGl0IGNhbm5vdFxuLy8gYmUgZm91bmQgKG5vZGUgbm90IHdpdGhpbiBpZnJhbWUsIGV0YykuXG5cbmZ1bmN0aW9uIGdldE93bmVySWZyYW1lKG5vZGUpIHtcbiAgdmFyIG5vZGVXaW5kb3cgPSBnZXRPd25lcldpbmRvdyhub2RlKTtcblxuICBpZiAobm9kZVdpbmRvdykge1xuICAgIHJldHVybiBub2RlV2luZG93LmZyYW1lRWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXQgYSBib3VuZGluZyBjbGllbnQgcmVjdCBmb3IgYSBub2RlLCB3aXRoIGFuXG4vLyBvZmZzZXQgYWRkZWQgdG8gY29tcGVuc2F0ZSBmb3IgaXRzIGJvcmRlci5cblxuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0V2l0aEJvcmRlck9mZnNldChub2RlKSB7XG4gIHZhciBkaW1lbnNpb25zID0gZ2V0RWxlbWVudERpbWVuc2lvbnMobm9kZSk7XG4gIHJldHVybiBtZXJnZVJlY3RPZmZzZXRzKFtub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB7XG4gICAgdG9wOiBkaW1lbnNpb25zLmJvcmRlclRvcCxcbiAgICBsZWZ0OiBkaW1lbnNpb25zLmJvcmRlckxlZnQsXG4gICAgYm90dG9tOiBkaW1lbnNpb25zLmJvcmRlckJvdHRvbSxcbiAgICByaWdodDogZGltZW5zaW9ucy5ib3JkZXJSaWdodCxcbiAgICAvLyBUaGlzIHdpZHRoIGFuZCBoZWlnaHQgd29uJ3QgZ2V0IHVzZWQgYnkgbWVyZ2VSZWN0T2Zmc2V0cyAoc2luY2UgdGhpc1xuICAgIC8vIGlzIG5vdCB0aGUgZmlyc3QgcmVjdCBpbiB0aGUgYXJyYXkpLCBidXQgd2Ugc2V0IHRoZW0gc28gdGhhdCB0aGlzXG4gICAgLy8gb2JqZWN0IHR5cGVjaGVja3MgYXMgYSBDbGllbnRSZWN0LlxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9XSk7XG59IC8vIEFkZCB0b2dldGhlciB0aGUgdG9wLCBsZWZ0LCBib3R0b20sIGFuZCByaWdodCBwcm9wZXJ0aWVzIG9mXG4vLyBlYWNoIENsaWVudFJlY3QsIGJ1dCBrZWVwIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBmaXJzdCBvbmUuXG5cbmZ1bmN0aW9uIG1lcmdlUmVjdE9mZnNldHMocmVjdHMpIHtcbiAgcmV0dXJuIHJlY3RzLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXNSZWN0LCByZWN0KSB7XG4gICAgaWYgKHByZXZpb3VzUmVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBwcmV2aW91c1JlY3QudG9wICsgcmVjdC50b3AsXG4gICAgICBsZWZ0OiBwcmV2aW91c1JlY3QubGVmdCArIHJlY3QubGVmdCxcbiAgICAgIHdpZHRoOiBwcmV2aW91c1JlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHByZXZpb3VzUmVjdC5oZWlnaHQsXG4gICAgICBib3R0b206IHByZXZpb3VzUmVjdC5ib3R0b20gKyByZWN0LmJvdHRvbSxcbiAgICAgIHJpZ2h0OiBwcmV2aW91c1JlY3QucmlnaHQgKyByZWN0LnJpZ2h0XG4gICAgfTtcbiAgfSk7XG59IC8vIENhbGN1bGF0ZSBhIGJvdW5kaW5nQ2xpZW50UmVjdCBmb3IgYSBub2RlIHJlbGF0aXZlIHRvIGJvdW5kYXJ5V2luZG93LFxuLy8gdGFraW5nIGludG8gYWNjb3VudCBhbnkgb2Zmc2V0cyBjYXVzZWQgYnkgaW50ZXJtZWRpYXRlIGlmcmFtZXMuXG5cbmZ1bmN0aW9uIGdldE5lc3RlZEJvdW5kaW5nQ2xpZW50UmVjdChub2RlLCBib3VuZGFyeVdpbmRvdykge1xuICB2YXIgb3duZXJJZnJhbWUgPSBnZXRPd25lcklmcmFtZShub2RlKTtcblxuICBpZiAob3duZXJJZnJhbWUgJiYgb3duZXJJZnJhbWUgIT09IGJvdW5kYXJ5V2luZG93KSB7XG4gICAgdmFyIHJlY3RzID0gW25vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCldO1xuICAgIHZhciBjdXJyZW50SWZyYW1lID0gb3duZXJJZnJhbWU7XG4gICAgdmFyIG9ubHlPbmVNb3JlID0gZmFsc2U7XG5cbiAgICB3aGlsZSAoY3VycmVudElmcmFtZSkge1xuICAgICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3RXaXRoQm9yZGVyT2Zmc2V0KGN1cnJlbnRJZnJhbWUpO1xuICAgICAgcmVjdHMucHVzaChyZWN0KTtcbiAgICAgIGN1cnJlbnRJZnJhbWUgPSBnZXRPd25lcklmcmFtZShjdXJyZW50SWZyYW1lKTtcblxuICAgICAgaWYgKG9ubHlPbmVNb3JlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBXZSBkb24ndCB3YW50IHRvIGNhbGN1bGF0ZSBpZnJhbWUgb2Zmc2V0cyB1cHdhcmRzIGJleW9uZFxuICAgICAgLy8gdGhlIGlmcmFtZSBjb250YWluaW5nIHRoZSBib3VuZGFyeVdpbmRvdywgYnV0IHdlXG4gICAgICAvLyBuZWVkIHRvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBib3VuZGFyeVdpbmRvdy5cblxuXG4gICAgICBpZiAoY3VycmVudElmcmFtZSAmJiBnZXRPd25lcldpbmRvdyhjdXJyZW50SWZyYW1lKSA9PT0gYm91bmRhcnlXaW5kb3cpIHtcbiAgICAgICAgb25seU9uZU1vcmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXJnZVJlY3RPZmZzZXRzKHJlY3RzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0RWxlbWVudERpbWVuc2lvbnMoZG9tRWxlbWVudCkge1xuICB2YXIgY2FsY3VsYXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgYm9yZGVyTGVmdDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aCwgMTApLFxuICAgIGJvcmRlclJpZ2h0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApLFxuICAgIGJvcmRlclRvcDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLmJvcmRlclRvcFdpZHRoLCAxMCksXG4gICAgYm9yZGVyQm90dG9tOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUuYm9yZGVyQm90dG9tV2lkdGgsIDEwKSxcbiAgICBtYXJnaW5MZWZ0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luTGVmdCwgMTApLFxuICAgIG1hcmdpblJpZ2h0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUubWFyZ2luUmlnaHQsIDEwKSxcbiAgICBtYXJnaW5Ub3A6IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5tYXJnaW5Ub3AsIDEwKSxcbiAgICBtYXJnaW5Cb3R0b206IHBhcnNlSW50KGNhbGN1bGF0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sIDEwKSxcbiAgICBwYWRkaW5nTGVmdDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdMZWZ0LCAxMCksXG4gICAgcGFkZGluZ1JpZ2h0OiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUucGFkZGluZ1JpZ2h0LCAxMCksXG4gICAgcGFkZGluZ1RvcDogcGFyc2VJbnQoY2FsY3VsYXRlZFN0eWxlLnBhZGRpbmdUb3AsIDEwKSxcbiAgICBwYWRkaW5nQm90dG9tOiBwYXJzZUludChjYWxjdWxhdGVkU3R5bGUucGFkZGluZ0JvdHRvbSwgMTApXG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvSGlnaGxpZ2h0ZXIvT3ZlcmxheS5qc1xuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBPdmVybGF5X2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gT3ZlcmxheV9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gT3ZlcmxheV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIE92ZXJsYXlfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIE92ZXJsYXlfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuLy8gTm90ZSB0aGF0IHRoZSBPdmVybGF5IGNvbXBvbmVudHMgYXJlIG5vdCBhZmZlY3RlZCBieSB0aGUgYWN0aXZlIFRoZW1lLFxuLy8gYmVjYXVzZSB0aGV5IGhpZ2hsaWdodCBlbGVtZW50cyBpbiB0aGUgbWFpbiBDaHJvbWUgd2luZG93IChvdXRzaWRlIG9mIGRldnRvb2xzKS5cbi8vIFRoZSBjb2xvcnMgYmVsb3cgd2VyZSBjaG9zZW4gdG8gcm91Z2hseSBtYXRjaCB0aG9zZSB1c2VkIGJ5IENocm9tZSBkZXZ0b29scy5cbnZhciBPdmVybGF5X092ZXJsYXlSZWN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3ZlcmxheVJlY3QoZG9jLCBjb250YWluZXIpIHtcbiAgICBPdmVybGF5X2NsYXNzQ2FsbENoZWNrKHRoaXMsIE92ZXJsYXlSZWN0KTtcblxuICAgIHRoaXMubm9kZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLmJvcmRlciA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5jb250ZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuYm9yZGVyLnN0eWxlLmJvcmRlckNvbG9yID0gb3ZlcmxheVN0eWxlcy5ib3JkZXI7XG4gICAgdGhpcy5wYWRkaW5nLnN0eWxlLmJvcmRlckNvbG9yID0gb3ZlcmxheVN0eWxlcy5wYWRkaW5nO1xuICAgIHRoaXMuY29udGVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBvdmVybGF5U3R5bGVzLmJhY2tncm91bmQ7XG4gICAgb2JqZWN0X2Fzc2lnbl9kZWZhdWx0KCkodGhpcy5ub2RlLnN0eWxlLCB7XG4gICAgICBib3JkZXJDb2xvcjogb3ZlcmxheVN0eWxlcy5tYXJnaW4sXG4gICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXG4gICAgICBwb3NpdGlvbjogJ2ZpeGVkJ1xuICAgIH0pO1xuICAgIHRoaXMubm9kZS5zdHlsZS56SW5kZXggPSAnMTAwMDAwMDAnO1xuICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmJvcmRlcik7XG4gICAgdGhpcy5ib3JkZXIuYXBwZW5kQ2hpbGQodGhpcy5wYWRkaW5nKTtcbiAgICB0aGlzLnBhZGRpbmcuYXBwZW5kQ2hpbGQodGhpcy5jb250ZW50KTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5ub2RlKTtcbiAgfVxuXG4gIE92ZXJsYXlfY3JlYXRlQ2xhc3MoT3ZlcmxheVJlY3QsIFt7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAodGhpcy5ub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5ub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShib3gsIGRpbXMpIHtcbiAgICAgIGJveFdyYXAoZGltcywgJ21hcmdpbicsIHRoaXMubm9kZSk7XG4gICAgICBib3hXcmFwKGRpbXMsICdib3JkZXInLCB0aGlzLmJvcmRlcik7XG4gICAgICBib3hXcmFwKGRpbXMsICdwYWRkaW5nJywgdGhpcy5wYWRkaW5nKTtcbiAgICAgIG9iamVjdF9hc3NpZ25fZGVmYXVsdCgpKHRoaXMuY29udGVudC5zdHlsZSwge1xuICAgICAgICBoZWlnaHQ6IGJveC5oZWlnaHQgLSBkaW1zLmJvcmRlclRvcCAtIGRpbXMuYm9yZGVyQm90dG9tIC0gZGltcy5wYWRkaW5nVG9wIC0gZGltcy5wYWRkaW5nQm90dG9tICsgJ3B4JyxcbiAgICAgICAgd2lkdGg6IGJveC53aWR0aCAtIGRpbXMuYm9yZGVyTGVmdCAtIGRpbXMuYm9yZGVyUmlnaHQgLSBkaW1zLnBhZGRpbmdMZWZ0IC0gZGltcy5wYWRkaW5nUmlnaHQgKyAncHgnXG4gICAgICB9KTtcbiAgICAgIG9iamVjdF9hc3NpZ25fZGVmYXVsdCgpKHRoaXMubm9kZS5zdHlsZSwge1xuICAgICAgICB0b3A6IGJveC50b3AgLSBkaW1zLm1hcmdpblRvcCArICdweCcsXG4gICAgICAgIGxlZnQ6IGJveC5sZWZ0IC0gZGltcy5tYXJnaW5MZWZ0ICsgJ3B4J1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE92ZXJsYXlSZWN0O1xufSgpO1xuXG52YXIgT3ZlcmxheV9PdmVybGF5VGlwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3ZlcmxheVRpcChkb2MsIGNvbnRhaW5lcikge1xuICAgIE92ZXJsYXlfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3ZlcmxheVRpcCk7XG5cbiAgICB0aGlzLnRpcCA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBvYmplY3RfYXNzaWduX2RlZmF1bHQoKSh0aGlzLnRpcC5zdHlsZSwge1xuICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgZmxleEZsb3c6ICdyb3cgbm93cmFwJyxcbiAgICAgIGJhY2tncm91bmRDb2xvcjogJyMzMzM3NDAnLFxuICAgICAgYm9yZGVyUmFkaXVzOiAnMnB4JyxcbiAgICAgIGZvbnRGYW1pbHk6ICdcIlNGTW9uby1SZWd1bGFyXCIsIENvbnNvbGFzLCBcIkxpYmVyYXRpb24gTW9ub1wiLCBNZW5sbywgQ291cmllciwgbW9ub3NwYWNlJyxcbiAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgIHBhZGRpbmc6ICczcHggNXB4JyxcbiAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICAgIHBvc2l0aW9uOiAnZml4ZWQnLFxuICAgICAgZm9udFNpemU6ICcxMnB4JyxcbiAgICAgIHdoaXRlU3BhY2U6ICdub3dyYXAnXG4gICAgfSk7XG4gICAgdGhpcy5uYW1lU3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy50aXAuYXBwZW5kQ2hpbGQodGhpcy5uYW1lU3Bhbik7XG4gICAgb2JqZWN0X2Fzc2lnbl9kZWZhdWx0KCkodGhpcy5uYW1lU3Bhbi5zdHlsZSwge1xuICAgICAgY29sb3I6ICcjZWU3OGU2JyxcbiAgICAgIGJvcmRlclJpZ2h0OiAnMXB4IHNvbGlkICNhYWFhYWEnLFxuICAgICAgcGFkZGluZ1JpZ2h0OiAnMC41cmVtJyxcbiAgICAgIG1hcmdpblJpZ2h0OiAnMC41cmVtJ1xuICAgIH0pO1xuICAgIHRoaXMuZGltU3BhbiA9IGRvYy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgdGhpcy50aXAuYXBwZW5kQ2hpbGQodGhpcy5kaW1TcGFuKTtcbiAgICBvYmplY3RfYXNzaWduX2RlZmF1bHQoKSh0aGlzLmRpbVNwYW4uc3R5bGUsIHtcbiAgICAgIGNvbG9yOiAnI2Q3ZDdkNydcbiAgICB9KTtcbiAgICB0aGlzLnRpcC5zdHlsZS56SW5kZXggPSAnMTAwMDAwMDAnO1xuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnRpcCk7XG4gIH1cblxuICBPdmVybGF5X2NyZWF0ZUNsYXNzKE92ZXJsYXlUaXAsIFt7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICBpZiAodGhpcy50aXAucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLnRpcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMudGlwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlVGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVUZXh0KG5hbWUsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHRoaXMubmFtZVNwYW4udGV4dENvbnRlbnQgPSBuYW1lO1xuICAgICAgdGhpcy5kaW1TcGFuLnRleHRDb250ZW50ID0gTWF0aC5yb3VuZCh3aWR0aCkgKyAncHggw5cgJyArIE1hdGgucm91bmQoaGVpZ2h0KSArICdweCc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKGRpbXMsIGJvdW5kcykge1xuICAgICAgdmFyIHRpcFJlY3QgPSB0aGlzLnRpcC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB0aXBQb3MgPSBmaW5kVGlwUG9zKGRpbXMsIGJvdW5kcywge1xuICAgICAgICB3aWR0aDogdGlwUmVjdC53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aXBSZWN0LmhlaWdodFxuICAgICAgfSk7XG4gICAgICBvYmplY3RfYXNzaWduX2RlZmF1bHQoKSh0aGlzLnRpcC5zdHlsZSwgdGlwUG9zLnN0eWxlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT3ZlcmxheVRpcDtcbn0oKTtcblxudmFyIE92ZXJsYXlfT3ZlcmxheSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE92ZXJsYXkoKSB7XG4gICAgT3ZlcmxheV9jbGFzc0NhbGxDaGVjayh0aGlzLCBPdmVybGF5KTtcblxuICAgIC8vIEZpbmQgdGhlIHJvb3Qgd2luZG93LCBiZWNhdXNlIG92ZXJsYXlzIGFyZSBwb3NpdGlvbmVkIHJlbGF0aXZlIHRvIGl0LlxuICAgIHZhciBjdXJyZW50V2luZG93ID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfVEFSR0VUX1dJTkRPV19fIHx8IHdpbmRvdztcbiAgICB0aGlzLndpbmRvdyA9IGN1cnJlbnRXaW5kb3c7IC8vIFdoZW4gb3BlbmVkIGluIHNoZWxscy9kZXYsIHRoZSB0b29sdGlwIHNob3VsZCBiZSBib3VuZCBieSB0aGUgYXBwIGlmcmFtZSwgbm90IGJ5IHRoZSB0b3Btb3N0IHdpbmRvdy5cblxuICAgIHZhciB0aXBCb3VuZHNXaW5kb3cgPSB3aW5kb3cuX19SRUFDVF9ERVZUT09MU19UQVJHRVRfV0lORE9XX18gfHwgd2luZG93O1xuICAgIHRoaXMudGlwQm91bmRzV2luZG93ID0gdGlwQm91bmRzV2luZG93O1xuICAgIHZhciBkb2MgPSBjdXJyZW50V2luZG93LmRvY3VtZW50O1xuICAgIHRoaXMuY29udGFpbmVyID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCA9ICcxMDAwMDAwMCc7XG4gICAgdGhpcy50aXAgPSBuZXcgT3ZlcmxheV9PdmVybGF5VGlwKGRvYywgdGhpcy5jb250YWluZXIpO1xuICAgIHRoaXMucmVjdHMgPSBbXTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcik7XG4gIH1cblxuICBPdmVybGF5X2NyZWF0ZUNsYXNzKE92ZXJsYXksIFt7XG4gICAga2V5OiBcInJlbW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICB0aGlzLnRpcC5yZW1vdmUoKTtcbiAgICAgIHRoaXMucmVjdHMuZm9yRWFjaChmdW5jdGlvbiAocmVjdCkge1xuICAgICAgICByZWN0LnJlbW92ZSgpO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJlY3RzLmxlbmd0aCA9IDA7XG5cbiAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5jb250YWluZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNwZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc3BlY3Qobm9kZXMsIG5hbWUpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIC8vIFdlIGNhbid0IGdldCB0aGUgc2l6ZSBvZiB0ZXh0IG5vZGVzIG9yIGNvbW1lbnQgbm9kZXMuIFJlYWN0IGFzIG9mIHYxNVxuICAgICAgLy8gaGVhdmlseSB1c2VzIGNvbW1lbnQgbm9kZXMgdG8gZGVsaW1pdCB0ZXh0LlxuICAgICAgdmFyIGVsZW1lbnRzID0gbm9kZXMuZmlsdGVyKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcbiAgICAgIH0pO1xuXG4gICAgICB3aGlsZSAodGhpcy5yZWN0cy5sZW5ndGggPiBlbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnJlY3RzLnBvcCgpO1xuICAgICAgICByZWN0LnJlbW92ZSgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKHRoaXMucmVjdHMubGVuZ3RoIDwgZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVjdHMucHVzaChuZXcgT3ZlcmxheV9PdmVybGF5UmVjdCh0aGlzLndpbmRvdy5kb2N1bWVudCwgdGhpcy5jb250YWluZXIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dGVyQm94ID0ge1xuICAgICAgICB0b3A6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgcmlnaHQ6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgYm90dG9tOiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIGxlZnQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgfTtcbiAgICAgIGVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgIHZhciBib3ggPSBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgX3RoaXMud2luZG93KTtcbiAgICAgICAgdmFyIGRpbXMgPSBnZXRFbGVtZW50RGltZW5zaW9ucyhlbGVtZW50KTtcbiAgICAgICAgb3V0ZXJCb3gudG9wID0gTWF0aC5taW4ob3V0ZXJCb3gudG9wLCBib3gudG9wIC0gZGltcy5tYXJnaW5Ub3ApO1xuICAgICAgICBvdXRlckJveC5yaWdodCA9IE1hdGgubWF4KG91dGVyQm94LnJpZ2h0LCBib3gubGVmdCArIGJveC53aWR0aCArIGRpbXMubWFyZ2luUmlnaHQpO1xuICAgICAgICBvdXRlckJveC5ib3R0b20gPSBNYXRoLm1heChvdXRlckJveC5ib3R0b20sIGJveC50b3AgKyBib3guaGVpZ2h0ICsgZGltcy5tYXJnaW5Cb3R0b20pO1xuICAgICAgICBvdXRlckJveC5sZWZ0ID0gTWF0aC5taW4ob3V0ZXJCb3gubGVmdCwgYm94LmxlZnQgLSBkaW1zLm1hcmdpbkxlZnQpO1xuICAgICAgICB2YXIgcmVjdCA9IF90aGlzLnJlY3RzW2luZGV4XTtcbiAgICAgICAgcmVjdC51cGRhdGUoYm94LCBkaW1zKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgbmFtZSA9IGVsZW1lbnRzWzBdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBub2RlID0gZWxlbWVudHNbMF07XG4gICAgICAgIHZhciBob29rID0gbm9kZS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICAgICAgICBpZiAoaG9vayAhPSBudWxsICYmIGhvb2sucmVuZGVyZXJJbnRlcmZhY2VzICE9IG51bGwpIHtcbiAgICAgICAgICB2YXIgb3duZXJOYW1lID0gbnVsbDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcblxuICAgICAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihob29rLnJlbmRlcmVySW50ZXJmYWNlcy52YWx1ZXMoKSksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgaWQgPSByZW5kZXJlckludGVyZmFjZS5nZXRGaWJlcklERm9yTmF0aXZlKG5vZGUsIHRydWUpO1xuXG4gICAgICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG93bmVyTmFtZSA9IHJlbmRlcmVySW50ZXJmYWNlLmdldERpc3BsYXlOYW1lRm9yRmliZXJJRChpZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAgICAgbmFtZSArPSAnIChpbiAnICsgb3duZXJOYW1lICsgJyknO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnRpcC51cGRhdGVUZXh0KG5hbWUsIG91dGVyQm94LnJpZ2h0IC0gb3V0ZXJCb3gubGVmdCwgb3V0ZXJCb3guYm90dG9tIC0gb3V0ZXJCb3gudG9wKTtcbiAgICAgIHZhciB0aXBCb3VuZHMgPSBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3QodGhpcy50aXBCb3VuZHNXaW5kb3cuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLndpbmRvdyk7XG4gICAgICB0aGlzLnRpcC51cGRhdGVQb3NpdGlvbih7XG4gICAgICAgIHRvcDogb3V0ZXJCb3gudG9wLFxuICAgICAgICBsZWZ0OiBvdXRlckJveC5sZWZ0LFxuICAgICAgICBoZWlnaHQ6IG91dGVyQm94LmJvdHRvbSAtIG91dGVyQm94LnRvcCxcbiAgICAgICAgd2lkdGg6IG91dGVyQm94LnJpZ2h0IC0gb3V0ZXJCb3gubGVmdFxuICAgICAgfSwge1xuICAgICAgICB0b3A6IHRpcEJvdW5kcy50b3AgKyB0aGlzLnRpcEJvdW5kc1dpbmRvdy5zY3JvbGxZLFxuICAgICAgICBsZWZ0OiB0aXBCb3VuZHMubGVmdCArIHRoaXMudGlwQm91bmRzV2luZG93LnNjcm9sbFgsXG4gICAgICAgIGhlaWdodDogdGhpcy50aXBCb3VuZHNXaW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgIHdpZHRoOiB0aGlzLnRpcEJvdW5kc1dpbmRvdy5pbm5lcldpZHRoXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gT3ZlcmxheTtcbn0oKTtcblxuXG5cbmZ1bmN0aW9uIGZpbmRUaXBQb3MoZGltcywgYm91bmRzLCB0aXBTaXplKSB7XG4gIHZhciB0aXBIZWlnaHQgPSBNYXRoLm1heCh0aXBTaXplLmhlaWdodCwgMjApO1xuICB2YXIgdGlwV2lkdGggPSBNYXRoLm1heCh0aXBTaXplLndpZHRoLCA2MCk7XG4gIHZhciBtYXJnaW4gPSA1O1xuICB2YXIgdG9wO1xuXG4gIGlmIChkaW1zLnRvcCArIGRpbXMuaGVpZ2h0ICsgdGlwSGVpZ2h0IDw9IGJvdW5kcy50b3AgKyBib3VuZHMuaGVpZ2h0KSB7XG4gICAgaWYgKGRpbXMudG9wICsgZGltcy5oZWlnaHQgPCBib3VuZHMudG9wICsgMCkge1xuICAgICAgdG9wID0gYm91bmRzLnRvcCArIG1hcmdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gZGltcy50b3AgKyBkaW1zLmhlaWdodCArIG1hcmdpbjtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGltcy50b3AgLSB0aXBIZWlnaHQgPD0gYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQpIHtcbiAgICBpZiAoZGltcy50b3AgLSB0aXBIZWlnaHQgLSBtYXJnaW4gPCBib3VuZHMudG9wICsgbWFyZ2luKSB7XG4gICAgICB0b3AgPSBib3VuZHMudG9wICsgbWFyZ2luO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b3AgPSBkaW1zLnRvcCAtIHRpcEhlaWdodCAtIG1hcmdpbjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdG9wID0gYm91bmRzLnRvcCArIGJvdW5kcy5oZWlnaHQgLSB0aXBIZWlnaHQgLSBtYXJnaW47XG4gIH1cblxuICB2YXIgbGVmdCA9IGRpbXMubGVmdCArIG1hcmdpbjtcblxuICBpZiAoZGltcy5sZWZ0IDwgYm91bmRzLmxlZnQpIHtcbiAgICBsZWZ0ID0gYm91bmRzLmxlZnQgKyBtYXJnaW47XG4gIH1cblxuICBpZiAoZGltcy5sZWZ0ICsgdGlwV2lkdGggPiBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCkge1xuICAgIGxlZnQgPSBib3VuZHMubGVmdCArIGJvdW5kcy53aWR0aCAtIHRpcFdpZHRoIC0gbWFyZ2luO1xuICB9XG5cbiAgdG9wICs9ICdweCc7XG4gIGxlZnQgKz0gJ3B4JztcbiAgcmV0dXJuIHtcbiAgICBzdHlsZToge1xuICAgICAgdG9wOiB0b3AsXG4gICAgICBsZWZ0OiBsZWZ0XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBib3hXcmFwKGRpbXMsIHdoYXQsIG5vZGUpIHtcbiAgb2JqZWN0X2Fzc2lnbl9kZWZhdWx0KCkobm9kZS5zdHlsZSwge1xuICAgIGJvcmRlclRvcFdpZHRoOiBkaW1zW3doYXQgKyAnVG9wJ10gKyAncHgnLFxuICAgIGJvcmRlckxlZnRXaWR0aDogZGltc1t3aGF0ICsgJ0xlZnQnXSArICdweCcsXG4gICAgYm9yZGVyUmlnaHRXaWR0aDogZGltc1t3aGF0ICsgJ1JpZ2h0J10gKyAncHgnLFxuICAgIGJvcmRlckJvdHRvbVdpZHRoOiBkaW1zW3doYXQgKyAnQm90dG9tJ10gKyAncHgnLFxuICAgIGJvcmRlclN0eWxlOiAnc29saWQnXG4gIH0pO1xufVxuXG52YXIgb3ZlcmxheVN0eWxlcyA9IHtcbiAgYmFja2dyb3VuZDogJ3JnYmEoMTIwLCAxNzAsIDIxMCwgMC43KScsXG4gIHBhZGRpbmc6ICdyZ2JhKDc3LCAyMDAsIDAsIDAuMyknLFxuICBtYXJnaW46ICdyZ2JhKDI1NSwgMTU1LCAwLCAwLjMpJyxcbiAgYm9yZGVyOiAncmdiYSgyNTUsIDIwMCwgNTAsIDAuMyknXG59O1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL0hpZ2hsaWdodGVyL0hpZ2hsaWdodGVyLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBTSE9XX0RVUkFUSU9OID0gMjAwMDtcbnZhciB0aW1lb3V0SUQgPSBudWxsO1xudmFyIG92ZXJsYXkgPSBudWxsO1xuZnVuY3Rpb24gaGlkZU92ZXJsYXkoKSB7XG4gIHRpbWVvdXRJRCA9IG51bGw7XG5cbiAgaWYgKG92ZXJsYXkgIT09IG51bGwpIHtcbiAgICBvdmVybGF5LnJlbW92ZSgpO1xuICAgIG92ZXJsYXkgPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBzaG93T3ZlcmxheShlbGVtZW50cywgY29tcG9uZW50TmFtZSwgaGlkZUFmdGVyVGltZW91dCkge1xuICAvLyBUT0RPIChucG0tcGFja2FnZXMpIERldGVjdCBSTiBhbmQgc3VwcG9ydCBpdCBzb21laG93XG4gIGlmICh3aW5kb3cuZG9jdW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0aW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcbiAgfVxuXG4gIGlmIChlbGVtZW50cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG92ZXJsYXkgPT09IG51bGwpIHtcbiAgICBvdmVybGF5ID0gbmV3IE92ZXJsYXlfT3ZlcmxheSgpO1xuICB9XG5cbiAgb3ZlcmxheS5pbnNwZWN0KGVsZW1lbnRzLCBjb21wb25lbnROYW1lKTtcblxuICBpZiAoaGlkZUFmdGVyVGltZW91dCkge1xuICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoaGlkZU92ZXJsYXksIFNIT1dfRFVSQVRJT04pO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvdmlld3MvSGlnaGxpZ2h0ZXIvaW5kZXguanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cblxuLy8gVGhpcyBwbHVnLWluIHByb3ZpZGVzIGluLXBhZ2UgaGlnaGxpZ2h0aW5nIG9mIHRoZSBzZWxlY3RlZCBlbGVtZW50LlxuLy8gSXQgaXMgdXNlZCBieSB0aGUgYnJvd3NlciBleHRlbnNpb24gYW5kIHRoZSBzdGFuZGFsb25lIERldlRvb2xzIHNoZWxsICh3aGVuIGNvbm5lY3RlZCB0byBhIGJyb3dzZXIpLlxuLy8gSXQgaXMgbm90IGN1cnJlbnRseSB0aGUgbWVjaGFuaXNtIHVzZWQgdG8gaGlnaGxpZ2h0IFJlYWN0IE5hdGl2ZSB2aWV3cy5cbi8vIFRoYXQgaXMgZG9uZSBieSB0aGUgUmVhY3QgTmF0aXZlIEluc3BlY3RvciBjb21wb25lbnQuXG52YXIgaWZyYW1lc0xpc3RlbmluZ1RvID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gc2V0dXBIaWdobGlnaHRlcihicmlkZ2UsIGFnZW50KSB7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcignY2xlYXJOYXRpdmVFbGVtZW50SGlnaGxpZ2h0JywgY2xlYXJOYXRpdmVFbGVtZW50SGlnaGxpZ2h0KTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdoaWdobGlnaHROYXRpdmVFbGVtZW50JywgaGlnaGxpZ2h0TmF0aXZlRWxlbWVudCk7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCBzdG9wSW5zcGVjdGluZ05hdGl2ZSk7XG4gIGJyaWRnZS5hZGRMaXN0ZW5lcignc3RhcnRJbnNwZWN0aW5nTmF0aXZlJywgc3RhcnRJbnNwZWN0aW5nTmF0aXZlKTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdzdG9wSW5zcGVjdGluZ05hdGl2ZScsIHN0b3BJbnNwZWN0aW5nTmF0aXZlKTtcblxuICBmdW5jdGlvbiBzdGFydEluc3BlY3RpbmdOYXRpdmUoKSB7XG4gICAgcmVnaXN0ZXJMaXN0ZW5lcnNPbldpbmRvdyh3aW5kb3cpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVnaXN0ZXJMaXN0ZW5lcnNPbldpbmRvdyh3aW5kb3cpIHtcbiAgICAvLyBUaGlzIHBsdWctaW4gbWF5IHJ1biBpbiBub24tRE9NIGVudmlyb25tZW50cyAoZS5nLiBSZWFjdCBOYXRpdmUpLlxuICAgIGlmICh3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsaWNrLCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvbk1vdXNlRXZlbnQsIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3ZlcicsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBvblBvaW50ZXJEb3duLCB0cnVlKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyb3ZlcicsIG9uUG9pbnRlck92ZXIsIHRydWUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wSW5zcGVjdGluZ05hdGl2ZSgpIHtcbiAgICBoaWRlT3ZlcmxheSgpO1xuICAgIHJlbW92ZUxpc3RlbmVyc09uV2luZG93KHdpbmRvdyk7XG4gICAgaWZyYW1lc0xpc3RlbmluZ1RvLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcnNPbldpbmRvdyhmcmFtZS5jb250ZW50V2luZG93KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gVGhpcyBjYW4gZXJyb3Igd2hlbiB0aGUgaWZyYW1lIGlzIG9uIGEgY3Jvc3Mtb3JpZ2luLlxuICAgICAgfVxuICAgIH0pO1xuICAgIGlmcmFtZXNMaXN0ZW5pbmdUbyA9IG5ldyBTZXQoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyc09uV2luZG93KHdpbmRvdykge1xuICAgIC8vIFRoaXMgcGx1Zy1pbiBtYXkgcnVuIGluIG5vbi1ET00gZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSkuXG4gICAgaWYgKHdpbmRvdyAmJiB0eXBlb2Ygd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2ssIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uTW91c2VFdmVudCwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgb25Nb3VzZUV2ZW50LCB0cnVlKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIG9uUG9pbnRlckRvd24sIHRydWUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJvdmVyJywgb25Qb2ludGVyT3ZlciwgdHJ1ZSk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Qb2ludGVyVXAsIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTmF0aXZlRWxlbWVudEhpZ2hsaWdodCgpIHtcbiAgICBoaWRlT3ZlcmxheSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0TmF0aXZlRWxlbWVudChfcmVmKSB7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gX3JlZi5kaXNwbGF5TmFtZSxcbiAgICAgICAgaGlkZUFmdGVyVGltZW91dCA9IF9yZWYuaGlkZUFmdGVyVGltZW91dCxcbiAgICAgICAgaWQgPSBfcmVmLmlkLFxuICAgICAgICBvcGVuTmF0aXZlRWxlbWVudHNQYW5lbCA9IF9yZWYub3Blbk5hdGl2ZUVsZW1lbnRzUGFuZWwsXG4gICAgICAgIHJlbmRlcmVySUQgPSBfcmVmLnJlbmRlcmVySUQsXG4gICAgICAgIHNjcm9sbEludG9WaWV3ID0gX3JlZi5zY3JvbGxJbnRvVmlldztcbiAgICB2YXIgcmVuZGVyZXIgPSBhZ2VudC5yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBudWxsO1xuXG4gICAgaWYgKHJlbmRlcmVyICE9IG51bGwpIHtcbiAgICAgIG5vZGVzID0gcmVuZGVyZXIuZmluZE5hdGl2ZU5vZGVzRm9yRmliZXJJRChpZCk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGVzICE9IG51bGwgJiYgbm9kZXNbMF0gIT0gbnVsbCkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1swXTtcblxuICAgICAgaWYgKHNjcm9sbEludG9WaWV3ICYmIHR5cGVvZiBub2RlLnNjcm9sbEludG9WaWV3ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIElmIHRoZSBub2RlIGlzbid0IHZpc2libGUgc2hvdyBpdCBiZWZvcmUgaGlnaGxpZ2h0aW5nIGl0LlxuICAgICAgICAvLyBXZSBtYXkgd2FudCB0byByZWNvbnNpZGVyIHRoaXM7IGl0IG1pZ2h0IGJlIGEgbGl0dGxlIGRpc3J1cHRpdmUuXG4gICAgICAgIC8vICRGbG93Rml4TWUgRmxvdyBvbmx5IGtub3dzIGFib3V0ICdzdGFydCcgfCAnZW5kJ1xuICAgICAgICBub2RlLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICBibG9jazogJ25lYXJlc3QnLFxuICAgICAgICAgIGlubGluZTogJ25lYXJlc3QnXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBzaG93T3ZlcmxheShub2RlcywgZGlzcGxheU5hbWUsIGhpZGVBZnRlclRpbWVvdXQpO1xuXG4gICAgICBpZiAob3Blbk5hdGl2ZUVsZW1lbnRzUGFuZWwpIHtcbiAgICAgICAgd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy4kMCA9IG5vZGU7XG4gICAgICAgIGJyaWRnZS5zZW5kKCdzeW5jU2VsZWN0aW9uVG9OYXRpdmVFbGVtZW50c1BhbmVsJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGhpZGVPdmVybGF5KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25DbGljayhldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgc3RvcEluc3BlY3RpbmdOYXRpdmUoKTtcbiAgICBicmlkZ2Uuc2VuZCgnc3RvcEluc3BlY3RpbmdOYXRpdmUnLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uTW91c2VFdmVudChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBzZWxlY3RGaWJlckZvck5vZGUoZXZlbnQudGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9pbnRlck92ZXIoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cbiAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09ICdJRlJBTUUnKSB7XG4gICAgICB2YXIgaWZyYW1lID0gdGFyZ2V0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlmcmFtZXNMaXN0ZW5pbmdUby5oYXMoaWZyYW1lKSkge1xuICAgICAgICAgIHZhciBfd2luZG93ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3c7XG4gICAgICAgICAgcmVnaXN0ZXJMaXN0ZW5lcnNPbldpbmRvdyhfd2luZG93KTtcbiAgICAgICAgICBpZnJhbWVzTGlzdGVuaW5nVG8uYWRkKGlmcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gVGhpcyBjYW4gZXJyb3Igd2hlbiB0aGUgaWZyYW1lIGlzIG9uIGEgY3Jvc3Mtb3JpZ2luLlxuICAgICAgfVxuICAgIH0gLy8gRG9uJ3QgcGFzcyB0aGUgbmFtZSBleHBsaWNpdGx5LlxuICAgIC8vIEl0IHdpbGwgYmUgaW5mZXJyZWQgZnJvbSBET00gdGFnIGFuZCBGaWJlciBvd25lci5cblxuXG4gICAgc2hvd092ZXJsYXkoW3RhcmdldF0sIG51bGwsIGZhbHNlKTtcbiAgICBzZWxlY3RGaWJlckZvck5vZGUodGFyZ2V0KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIHZhciBzZWxlY3RGaWJlckZvck5vZGUgPSBsb2Rhc2hfdGhyb3R0bGVfZGVmYXVsdCgpKGVzbShmdW5jdGlvbiAobm9kZSkge1xuICAgIHZhciBpZCA9IGFnZW50LmdldElERm9yTm9kZShub2RlKTtcblxuICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgYnJpZGdlLnNlbmQoJ3NlbGVjdEZpYmVyJywgaWQpO1xuICAgIH1cbiAgfSksIDIwMCwgLy8gRG9uJ3QgY2hhbmdlIHRoZSBzZWxlY3Rpb24gaW4gdGhlIHZlcnkgZmlyc3QgMjAwbXNcbiAgLy8gYmVjYXVzZSB0aG9zZSBhcmUgdXN1YWxseSB1bmludGVudGlvbmFsIGFzIHlvdSBsaWZ0IHRoZSBjdXJzb3IuXG4gIHtcbiAgICBsZWFkaW5nOiBmYWxzZVxuICB9KTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC92aWV3cy9UcmFjZVVwZGF0ZXMvY2FudmFzLmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG52YXIgT1VUTElORV9DT0xPUiA9ICcjZjBmMGYwJzsgLy8gTm90ZSB0aGVzZSBjb2xvcnMgYXJlIGluIHN5bmMgd2l0aCBEZXZUb29scyBQcm9maWxlciBjaGFydCBjb2xvcnMuXG5cbnZhciBDT0xPUlMgPSBbJyMzN2FmYTknLCAnIzYzYjE5ZScsICcjODBiMzkzJywgJyM5N2I0ODgnLCAnI2FiYjY3ZCcsICcjYmViNzcxJywgJyNjZmI5NjUnLCAnI2RmYmE1NycsICcjZWZiYjQ5JywgJyNmZWJjMzgnXTtcbnZhciBjYW52YXMgPSBudWxsO1xuZnVuY3Rpb24gZHJhdyhub2RlVG9EYXRhKSB7XG4gIGlmIChjYW52YXMgPT09IG51bGwpIHtcbiAgICBpbml0aWFsaXplKCk7XG4gIH1cblxuICB2YXIgY2FudmFzRmxvdyA9IGNhbnZhcztcbiAgY2FudmFzRmxvdy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICBjYW52YXNGbG93LmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgdmFyIGNvbnRleHQgPSBjYW52YXNGbG93LmdldENvbnRleHQoJzJkJyk7XG4gIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNhbnZhc0Zsb3cud2lkdGgsIGNhbnZhc0Zsb3cuaGVpZ2h0KTtcbiAgbm9kZVRvRGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGNvdW50ID0gX3JlZi5jb3VudCxcbiAgICAgICAgcmVjdCA9IF9yZWYucmVjdDtcblxuICAgIGlmIChyZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgY29sb3JJbmRleCA9IE1hdGgubWluKENPTE9SUy5sZW5ndGggLSAxLCBjb3VudCAtIDEpO1xuICAgICAgdmFyIGNvbG9yID0gQ09MT1JTW2NvbG9ySW5kZXhdO1xuICAgICAgZHJhd0JvcmRlcihjb250ZXh0LCByZWN0LCBjb2xvcik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZHJhd0JvcmRlcihjb250ZXh0LCByZWN0LCBjb2xvcikge1xuICB2YXIgaGVpZ2h0ID0gcmVjdC5oZWlnaHQsXG4gICAgICBsZWZ0ID0gcmVjdC5sZWZ0LFxuICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGg7IC8vIG91dGxpbmVcblxuICBjb250ZXh0LmxpbmVXaWR0aCA9IDE7XG4gIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBPVVRMSU5FX0NPTE9SO1xuICBjb250ZXh0LnN0cm9rZVJlY3QobGVmdCAtIDEsIHRvcCAtIDEsIHdpZHRoICsgMiwgaGVpZ2h0ICsgMik7IC8vIGluc2V0XG5cbiAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gT1VUTElORV9DT0xPUjtcbiAgY29udGV4dC5zdHJva2VSZWN0KGxlZnQgKyAxLCB0b3AgKyAxLCB3aWR0aCAtIDEsIGhlaWdodCAtIDEpO1xuICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gIGNvbnRleHQuc2V0TGluZURhc2goWzBdKTsgLy8gYm9yZGVyXG5cbiAgY29udGV4dC5saW5lV2lkdGggPSAxO1xuICBjb250ZXh0LnN0cm9rZVJlY3QobGVmdCwgdG9wLCB3aWR0aCAtIDEsIGhlaWdodCAtIDEpO1xuICBjb250ZXh0LnNldExpbmVEYXNoKFswXSk7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIGlmIChjYW52YXMgIT09IG51bGwpIHtcbiAgICBpZiAoY2FudmFzLnBhcmVudE5vZGUgIT0gbnVsbCkge1xuICAgICAgY2FudmFzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICB9XG5cbiAgICBjYW52YXMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gIGNhbnZhcyA9IHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLnN0eWxlLmNzc1RleHQgPSBcIlxcbiAgICB4eC1iYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XFxuICAgIHh4LW9wYWNpdHk6IDAuNTtcXG4gICAgYm90dG9tOiAwO1xcbiAgICBsZWZ0OiAwO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICByaWdodDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB6LWluZGV4OiAxMDAwMDAwMDAwO1xcbiAgXCI7XG4gIHZhciByb290ID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgcm9vdC5pbnNlcnRCZWZvcmUoY2FudmFzLCByb290LmZpcnN0Q2hpbGQpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3ZpZXdzL1RyYWNlVXBkYXRlcy9pbmRleC5qc1xuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG4vLyBIb3cgbG9uZyB0aGUgcmVjdCBzaG91bGQgYmUgc2hvd24gZm9yP1xudmFyIERJU1BMQVlfRFVSQVRJT04gPSAyNTA7IC8vIFdoYXQncyB0aGUgbG9uZ2VzdCB3ZSBhcmUgd2lsbGluZyB0byBzaG93IHRoZSBvdmVybGF5IGZvcj9cbi8vIFRoaXMgY2FuIGJlIGltcG9ydGFudCBpZiB3ZSdyZSBnZXR0aW5nIGEgZmx1cnJ5IG9mIGV2ZW50cyAoZS5nLiBzY3JvbGwgdXBkYXRlKS5cblxudmFyIE1BWF9ESVNQTEFZX0RVUkFUSU9OID0gMzAwMDsgLy8gSG93IGxvbmcgc2hvdWxkIGEgcmVjdCBiZSBjb25zaWRlcmVkIHZhbGlkIGZvcj9cblxudmFyIFJFTUVBU1VSRU1FTlRfQUZURVJfRFVSQVRJT04gPSAyNTA7IC8vIFNvbWUgZW52aXJvbm1lbnRzIChlLmcuIFJlYWN0IE5hdGl2ZSAvIEhlcm1lcykgZG9uJ3Qgc3VwcG9ydCB0aGUgcGVyZm9ybWFuY2UgQVBJIHlldC5cblxudmFyIGdldEN1cnJlbnRUaW1lID0gKHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHBlcmZvcm1hbmNlKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbnZhciBub2RlVG9EYXRhID0gbmV3IE1hcCgpO1xudmFyIFRyYWNlVXBkYXRlc19hZ2VudCA9IG51bGw7XG52YXIgZHJhd0FuaW1hdGlvbkZyYW1lSUQgPSBudWxsO1xudmFyIGlzRW5hYmxlZCA9IGZhbHNlO1xudmFyIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG5mdW5jdGlvbiBUcmFjZVVwZGF0ZXNfaW5pdGlhbGl6ZShpbmplY3RlZEFnZW50KSB7XG4gIFRyYWNlVXBkYXRlc19hZ2VudCA9IGluamVjdGVkQWdlbnQ7XG4gIFRyYWNlVXBkYXRlc19hZ2VudC5hZGRMaXN0ZW5lcigndHJhY2VVcGRhdGVzJywgdHJhY2VVcGRhdGVzKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUVuYWJsZWQodmFsdWUpIHtcbiAgaXNFbmFibGVkID0gdmFsdWU7XG5cbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICBub2RlVG9EYXRhLmNsZWFyKCk7XG5cbiAgICBpZiAoZHJhd0FuaW1hdGlvbkZyYW1lSUQgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGRyYXdBbmltYXRpb25GcmFtZUlEKTtcbiAgICAgIGRyYXdBbmltYXRpb25GcmFtZUlEID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocmVkcmF3VGltZW91dElEICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQocmVkcmF3VGltZW91dElEKTtcbiAgICAgIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG4gICAgfVxuXG4gICAgZGVzdHJveSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyYWNlVXBkYXRlcyhub2Rlcykge1xuICBpZiAoIWlzRW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB2YXIgZGF0YSA9IG5vZGVUb0RhdGEuZ2V0KG5vZGUpO1xuICAgIHZhciBub3cgPSBnZXRDdXJyZW50VGltZSgpO1xuICAgIHZhciBsYXN0TWVhc3VyZWRBdCA9IGRhdGEgIT0gbnVsbCA/IGRhdGEubGFzdE1lYXN1cmVkQXQgOiAwO1xuICAgIHZhciByZWN0ID0gZGF0YSAhPSBudWxsID8gZGF0YS5yZWN0IDogbnVsbDtcblxuICAgIGlmIChyZWN0ID09PSBudWxsIHx8IGxhc3RNZWFzdXJlZEF0ICsgUkVNRUFTVVJFTUVOVF9BRlRFUl9EVVJBVElPTiA8IG5vdykge1xuICAgICAgbGFzdE1lYXN1cmVkQXQgPSBub3c7XG4gICAgICByZWN0ID0gbWVhc3VyZU5vZGUobm9kZSk7XG4gICAgfVxuXG4gICAgbm9kZVRvRGF0YS5zZXQobm9kZSwge1xuICAgICAgY291bnQ6IGRhdGEgIT0gbnVsbCA/IGRhdGEuY291bnQgKyAxIDogMSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBkYXRhICE9IG51bGwgPyBNYXRoLm1pbihub3cgKyBNQVhfRElTUExBWV9EVVJBVElPTiwgZGF0YS5leHBpcmF0aW9uVGltZSArIERJU1BMQVlfRFVSQVRJT04pIDogbm93ICsgRElTUExBWV9EVVJBVElPTixcbiAgICAgIGxhc3RNZWFzdXJlZEF0OiBsYXN0TWVhc3VyZWRBdCxcbiAgICAgIHJlY3Q6IHJlY3RcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKHJlZHJhd1RpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgIGNsZWFyVGltZW91dChyZWRyYXdUaW1lb3V0SUQpO1xuICAgIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG4gIH1cblxuICBpZiAoZHJhd0FuaW1hdGlvbkZyYW1lSUQgPT09IG51bGwpIHtcbiAgICBkcmF3QW5pbWF0aW9uRnJhbWVJRCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShwcmVwYXJlVG9EcmF3KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9EcmF3KCkge1xuICBkcmF3QW5pbWF0aW9uRnJhbWVJRCA9IG51bGw7XG4gIHJlZHJhd1RpbWVvdXRJRCA9IG51bGw7XG4gIHZhciBub3cgPSBnZXRDdXJyZW50VGltZSgpO1xuICB2YXIgZWFybGllc3RFeHBpcmF0aW9uID0gTnVtYmVyLk1BWF9WQUxVRTsgLy8gUmVtb3ZlIGFueSBpdGVtcyB0aGF0IGhhdmUgYWxyZWFkeSBleHBpcmVkLlxuXG4gIG5vZGVUb0RhdGEuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSwgbm9kZSkge1xuICAgIGlmIChkYXRhLmV4cGlyYXRpb25UaW1lIDwgbm93KSB7XG4gICAgICBub2RlVG9EYXRhLmRlbGV0ZShub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWFybGllc3RFeHBpcmF0aW9uID0gTWF0aC5taW4oZWFybGllc3RFeHBpcmF0aW9uLCBkYXRhLmV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH0pO1xuICBkcmF3KG5vZGVUb0RhdGEpO1xuXG4gIGlmIChlYXJsaWVzdEV4cGlyYXRpb24gIT09IE51bWJlci5NQVhfVkFMVUUpIHtcbiAgICByZWRyYXdUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KHByZXBhcmVUb0RyYXcsIGVhcmxpZXN0RXhwaXJhdGlvbiAtIG5vdyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVhc3VyZU5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgY3VycmVudFdpbmRvdyA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1RBUkdFVF9XSU5ET1dfXyB8fCB3aW5kb3c7XG4gIHJldHVybiBnZXROZXN0ZWRCb3VuZGluZ0NsaWVudFJlY3Qobm9kZSwgY3VycmVudFdpbmRvdyk7XG59XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9ub2RlX21vZHVsZXMvc2VtdmVyL3NlbXZlci5qc1xudmFyIHNlbXZlciA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvdHlwZXMuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIFdBUk5JTkdcbi8vIFRoZSB2YWx1ZXMgYmVsb3cgYXJlIHJlZmVyZW5jZWQgYnkgQ29tcG9uZW50RmlsdGVycyAod2hpY2ggYXJlIHNhdmVkIHZpYSBsb2NhbFN0b3JhZ2UpLlxuLy8gRG8gbm90IGNoYW5nZSB0aGVtIG9yIGl0IHdpbGwgYnJlYWsgcHJldmlvdXNseSBzYXZlZCB1c2VyIGN1c3RvbWl6YXRpb25zLlxuLy8gSWYgbmV3IGVsZW1lbnQgdHlwZXMgYXJlIGFkZGVkLCB1c2UgbmV3IG51bWJlcnMgcmF0aGVyIHRoYW4gcmUtb3JkZXJpbmcgZXhpc3Rpbmcgb25lcy5cbi8vXG4vLyBDaGFuZ2luZyB0aGVzZSB0eXBlcyBpcyBhbHNvIGEgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSBmb3IgdGhlIHN0YW5kYWxvbmUgc2hlbGwsXG4vLyBzaW5jZSB0aGUgZnJvbnRlbmQgYW5kIGJhY2tlbmQgbXVzdCBzaGFyZSB0aGUgc2FtZSB2YWx1ZXMtXG4vLyBhbmQgdGhlIGJhY2tlbmQgaXMgZW1iZWRkZWQgaW4gY2VydGFpbiBlbnZpcm9ubWVudHMgKGxpa2UgUmVhY3QgTmF0aXZlKS5cbnZhciBFbGVtZW50VHlwZUNsYXNzID0gMTtcbnZhciBFbGVtZW50VHlwZUNvbnRleHQgPSAyO1xudmFyIEVsZW1lbnRUeXBlRnVuY3Rpb24gPSA1O1xudmFyIEVsZW1lbnRUeXBlRm9yd2FyZFJlZiA9IDY7XG52YXIgRWxlbWVudFR5cGVIb3N0Q29tcG9uZW50ID0gNztcbnZhciBFbGVtZW50VHlwZU1lbW8gPSA4O1xudmFyIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24gPSA5O1xudmFyIEVsZW1lbnRUeXBlUHJvZmlsZXIgPSAxMDtcbnZhciBFbGVtZW50VHlwZVJvb3QgPSAxMTtcbnZhciBFbGVtZW50VHlwZVN1c3BlbnNlID0gMTI7XG52YXIgRWxlbWVudFR5cGVTdXNwZW5zZUxpc3QgPSAxMzsgLy8gRGlmZmVyZW50IHR5cGVzIG9mIGVsZW1lbnRzIGRpc3BsYXllZCBpbiB0aGUgRWxlbWVudHMgdHJlZS5cbi8vIFRoZXNlIHR5cGVzIG1heSBiZSB1c2VkIHRvIHZpc3VhbGx5IGRpc3Rpbmd1aXNoIHR5cGVzLFxuLy8gb3IgdG8gZW5hYmxlL2Rpc2FibGUgY2VydGFpbiBmdW5jdGlvbmFsaXR5LlxuXG4vLyBXQVJOSU5HXG4vLyBUaGUgdmFsdWVzIGJlbG93IGFyZSByZWZlcmVuY2VkIGJ5IENvbXBvbmVudEZpbHRlcnMgKHdoaWNoIGFyZSBzYXZlZCB2aWEgbG9jYWxTdG9yYWdlKS5cbi8vIERvIG5vdCBjaGFuZ2UgdGhlbSBvciBpdCB3aWxsIGJyZWFrIHByZXZpb3VzbHkgc2F2ZWQgdXNlciBjdXN0b21pemF0aW9ucy5cbi8vIElmIG5ldyBmaWx0ZXIgdHlwZXMgYXJlIGFkZGVkLCB1c2UgbmV3IG51bWJlcnMgcmF0aGVyIHRoYW4gcmUtb3JkZXJpbmcgZXhpc3Rpbmcgb25lcy5cbnZhciBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZSA9IDE7XG52YXIgQ29tcG9uZW50RmlsdGVyRGlzcGxheU5hbWUgPSAyO1xudmFyIENvbXBvbmVudEZpbHRlckxvY2F0aW9uID0gMztcbnZhciBDb21wb25lbnRGaWx0ZXJIT0MgPSA0O1xuLy8gRVhURVJOQUwgTU9EVUxFOiAvVXNlcnMvbHVuYS9jb2RlL3JlYWN0L25vZGVfbW9kdWxlcy9scnUtY2FjaGUvaW5kZXguanNcbnZhciBscnVfY2FjaGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xudmFyIGxydV9jYWNoZV9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihscnVfY2FjaGUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC9Vc2Vycy9sdW5hL2NvZGUvcmVhY3QvYnVpbGQvbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2luZGV4LmpzXG52YXIgcmVhY3RfaXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9zaGFyZWQvUmVhY3RTeW1ib2xzLmpzXG5mdW5jdGlvbiBSZWFjdFN5bWJvbHNfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBSZWFjdFN5bWJvbHNfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IFJlYWN0U3ltYm9sc190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gUmVhY3RTeW1ib2xzX3R5cGVvZihvYmopOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSAweGVhY2E7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IDB4ZWFjYjtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSAweGVhZDI7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IDB4ZWFjZDtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSAweGVhY2U7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IDB4ZWFkMDtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gMHhlYWQ0O1xudmFyIFJFQUNUX1NDT1BFX1RZUEUgPSAweGVhZDc7XG52YXIgUkVBQ1RfT1BBUVVFX0lEX1RZUEUgPSAweGVhZTA7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSAweGVhZTE7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSAweGVhZTI7XG52YXIgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gMHhlYWUzO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSAweGVhZTQ7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9TQ09QRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zY29wZScpO1xuICBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Qub3BhcXVlLmlkJyk7XG4gIFJFQUNUX0RFQlVHX1RSQUNJTkdfTU9ERV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG4gIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbiAgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG4gIFJFQUNUX0NBQ0hFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmNhY2hlJyk7XG59XG5cbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCBSZWFjdFN5bWJvbHNfdHlwZW9mKG1heWJlSXRlcmFibGUpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2h5ZHJhdGlvbi5qc1xuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgaHlkcmF0aW9uX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGh5ZHJhdGlvbl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIG1ldGEgPSB7XG4gIGluc3BlY3RhYmxlOiBTeW1ib2woJ2luc3BlY3RhYmxlJyksXG4gIGluc3BlY3RlZDogU3ltYm9sKCdpbnNwZWN0ZWQnKSxcbiAgbmFtZTogU3ltYm9sKCduYW1lJyksXG4gIHByZXZpZXdfbG9uZzogU3ltYm9sKCdwcmV2aWV3X2xvbmcnKSxcbiAgcHJldmlld19zaG9ydDogU3ltYm9sKCdwcmV2aWV3X3Nob3J0JyksXG4gIHJlYWRvbmx5OiBTeW1ib2woJ3JlYWRvbmx5JyksXG4gIHNpemU6IFN5bWJvbCgnc2l6ZScpLFxuICB0eXBlOiBTeW1ib2woJ3R5cGUnKSxcbiAgdW5zZXJpYWxpemFibGU6IFN5bWJvbCgndW5zZXJpYWxpemFibGUnKVxufTtcbi8vIFRoaXMgdGhyZXNob2xkIGRldGVybWluZXMgdGhlIGRlcHRoIGF0IHdoaWNoIHRoZSBicmlkZ2UgXCJkZWh5ZHJhdGVzXCIgbmVzdGVkIGRhdGEuXG4vLyBEZWh5ZHJhdGlvbiBtZWFucyB0aGF0IHdlIGRvbid0IHNlcmlhbGl6ZSB0aGUgZGF0YSBmb3IgZS5nLiBwb3N0TWVzc2FnZSBvciBzdHJpbmdpZnksXG4vLyB1bmxlc3MgdGhlIGZyb250ZW5kIGV4cGxpY2l0bHkgcmVxdWVzdHMgaXQgKGUuZy4gYSB1c2VyIGNsaWNrcyB0byBleHBhbmQgYSBwcm9wcyBvYmplY3QpLlxuLy9cbi8vIFJlZHVjaW5nIHRoaXMgdGhyZXNob2xkIHdpbGwgaW1wcm92ZSB0aGUgc3BlZWQgb2YgaW5pdGlhbCBjb21wb25lbnQgaW5zcGVjdGlvbixcbi8vIGJ1dCBtYXkgZGVjcmVhc2UgdGhlIHJlc3BvbnNpdmVuZXNzIG9mIGV4cGFuZGluZyBvYmplY3RzL2FycmF5cyB0byBpbnNwZWN0IGZ1cnRoZXIuXG52YXIgTEVWRUxfVEhSRVNIT0xEID0gMjtcbi8qKlxuICogR2VuZXJhdGUgdGhlIGRlaHlkcmF0ZWQgbWV0YWRhdGEgZm9yIGNvbXBsZXggb2JqZWN0IGluc3RhbmNlc1xuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgaW5zcGVjdGFibGUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpIHtcbiAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICB2YXIgZGVoeWRyYXRlZCA9IHtcbiAgICBpbnNwZWN0YWJsZTogaW5zcGVjdGFibGUsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICBuYW1lOiAhZGF0YS5jb25zdHJ1Y3RvciB8fCBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gJycgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWVcbiAgfTtcblxuICBpZiAodHlwZSA9PT0gJ2FycmF5JyB8fCB0eXBlID09PSAndHlwZWRfYXJyYXknKSB7XG4gICAgZGVoeWRyYXRlZC5zaXplID0gZGF0YS5sZW5ndGg7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBkZWh5ZHJhdGVkLnNpemUgPSBPYmplY3Qua2V5cyhkYXRhKS5sZW5ndGg7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gJ2l0ZXJhdG9yJyB8fCB0eXBlID09PSAndHlwZWRfYXJyYXknKSB7XG4gICAgZGVoeWRyYXRlZC5yZWFkb25seSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gZGVoeWRyYXRlZDtcbn1cbi8qKlxuICogU3RyaXAgb3V0IGNvbXBsZXggZGF0YSAoaW5zdGFuY2VzLCBmdW5jdGlvbnMsIGFuZCBkYXRhIG5lc3RlZCA+IExFVkVMX1RIUkVTSE9MRCBsZXZlbHMgZGVlcCkuXG4gKiBUaGUgcGF0aHMgb2YgdGhlIHN0cmlwcGVkIG91dCBvYmplY3RzIGFyZSBhcHBlbmRlZCB0byB0aGUgYGNsZWFuZWRgIGxpc3QuXG4gKiBPbiB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgYmFycmllciwgdGhlIGNsZWFuZWQgbGlzdCBpcyB1c2VkIHRvIFwicmUtaHlkcmF0ZVwiIHRoZSBjbGVhbmVkIHJlcHJlc2VudGF0aW9uIGludG9cbiAqIGFuIG9iamVjdCB3aXRoIHN5bWJvbHMgYXMgYXR0cmlidXRlcywgc28gdGhhdCBhIHNhbml0aXplZCBvYmplY3QgY2FuIGJlIGRpc3Rpbmd1aXNoZWQgZnJvbSBhIG5vcm1hbCBvYmplY3QuXG4gKlxuICogSW5wdXQ6IHtcInNvbWVcIjoge1wiYXR0clwiOiBmbigpfSwgXCJvdGhlclwiOiBBbkluc3RhbmNlfVxuICogT3V0cHV0OiB7XG4gKiAgIFwic29tZVwiOiB7XG4gKiAgICAgXCJhdHRyXCI6IHtcIm5hbWVcIjogdGhlIGZuLm5hbWUsIHR5cGU6IFwiZnVuY3Rpb25cIn1cbiAqICAgfSxcbiAqICAgXCJvdGhlclwiOiB7XG4gKiAgICAgXCJuYW1lXCI6IFwiQW5JbnN0YW5jZVwiLFxuICogICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICogICB9LFxuICogfVxuICogYW5kIGNsZWFuZWQgPSBbW1wic29tZVwiLCBcImF0dHJcIl0sIFtcIm90aGVyXCJdXVxuICovXG5cblxuZnVuY3Rpb24gZGVoeWRyYXRlKGRhdGEsIGNsZWFuZWQsIHVuc2VyaWFsaXphYmxlLCBwYXRoLCBpc1BhdGhBbGxvd2VkKSB7XG4gIHZhciBsZXZlbCA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcbiAgdmFyIHR5cGUgPSBnZXREYXRhVHlwZShkYXRhKTtcbiAgdmFyIGlzUGF0aEFsbG93ZWRDaGVjaztcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdodG1sX2VsZW1lbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudGFnTmFtZSxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiB0eXBlb2YgZGF0YS5uYW1lID09PSAnZnVuY3Rpb24nIHx8ICFkYXRhLm5hbWUgPyAnZnVuY3Rpb24nIDogZGF0YS5uYW1lLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGlzUGF0aEFsbG93ZWRDaGVjayA9IGlzUGF0aEFsbG93ZWQocGF0aCk7XG5cbiAgICAgIGlmIChpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGF0YS5sZW5ndGggPD0gNTAwID8gZGF0YSA6IGRhdGEuc2xpY2UoMCwgNTAwKSArICcuLi4nO1xuICAgICAgfVxuXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhLnRvU3RyaW5nKCksXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGRhdGEudG9TdHJpbmcoKSxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICAvLyBSZWFjdCBFbGVtZW50cyBhcmVuJ3QgdmVyeSBpbnNwZWN0b3ItZnJpZW5kbHksXG4gICAgLy8gYW5kIG9mdGVuIGNvbnRhaW4gcHJpdmF0ZSBmaWVsZHMgb3IgY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICAgIGNhc2UgJ3JlYWN0X2VsZW1lbnQnOlxuICAgICAgY2xlYW5lZC5wdXNoKHBhdGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaW5zcGVjdGFibGU6IGZhbHNlLFxuICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgIHByZXZpZXdfbG9uZzogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgdHJ1ZSksXG4gICAgICAgIG5hbWU6IGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KGRhdGEpIHx8ICdVbmtub3duJyxcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICAvLyBBcnJheUJ1ZmZlcnMgZXJyb3IgaWYgeW91IHRyeSB0byBpbnNwZWN0IHRoZW0uXG5cbiAgICBjYXNlICdhcnJheV9idWZmZXInOlxuICAgIGNhc2UgJ2RhdGFfdmlldyc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogdHlwZSA9PT0gJ2RhdGFfdmlldycgPyAnRGF0YVZpZXcnIDogJ0FycmF5QnVmZmVyJyxcbiAgICAgICAgc2l6ZTogZGF0YS5ieXRlTGVuZ3RoLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAnYXJyYXknOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcblxuICAgICAgaWYgKGxldmVsID49IExFVkVMX1RIUkVTSE9MRCAmJiAhaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWh5ZHJhdGVkKHR5cGUsIHRydWUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGF0YS5tYXAoZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgcmV0dXJuIGRlaHlkcmF0ZShpdGVtLCBjbGVhbmVkLCB1bnNlcmlhbGl6YWJsZSwgcGF0aC5jb25jYXQoW2ldKSwgaXNQYXRoQWxsb3dlZCwgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSk7XG4gICAgICB9KTtcblxuICAgIGNhc2UgJ2h0bWxfYWxsX2NvbGxlY3Rpb24nOlxuICAgIGNhc2UgJ3R5cGVkX2FycmF5JzpcbiAgICBjYXNlICdpdGVyYXRvcic6XG4gICAgICBpc1BhdGhBbGxvd2VkQ2hlY2sgPSBpc1BhdGhBbGxvd2VkKHBhdGgpO1xuXG4gICAgICBpZiAobGV2ZWwgPj0gTEVWRUxfVEhSRVNIT0xEICYmICFpc1BhdGhBbGxvd2VkQ2hlY2spIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURlaHlkcmF0ZWQodHlwZSwgdHJ1ZSwgZGF0YSwgY2xlYW5lZCwgcGF0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdW5zZXJpYWxpemFibGVWYWx1ZSA9IHtcbiAgICAgICAgICB1bnNlcmlhbGl6YWJsZTogdHJ1ZSxcbiAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgIHJlYWRvbmx5OiB0cnVlLFxuICAgICAgICAgIHNpemU6IHR5cGUgPT09ICd0eXBlZF9hcnJheScgPyBkYXRhLmxlbmd0aCA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwcmV2aWV3X3Nob3J0OiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCBmYWxzZSksXG4gICAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgICBuYW1lOiAhZGF0YS5jb25zdHJ1Y3RvciB8fCBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdPYmplY3QnID8gJycgOiBkYXRhLmNvbnN0cnVjdG9yLm5hbWVcbiAgICAgICAgfTsgLy8gVFJJQ0tZXG4gICAgICAgIC8vIERvbid0IHVzZSBbLi4uc3ByZWFkXSBzeW50YXggZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHVzZXMgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tc3ByZWFkIGluIFwibG9vc2VcIiBtb2RlIHdoaWNoIG9ubHkgd29ya3Mgd2l0aCBBcnJheSB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyIHR5cGVzIChlLmcuIHR5cGVkIGFycmF5cywgU2V0cykgd2lsbCBub3Qgc3ByZWFkIGNvcnJlY3RseS5cblxuICAgICAgICBBcnJheS5mcm9tKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICAgICAgICByZXR1cm4gdW5zZXJpYWxpemFibGVWYWx1ZVtpXSA9IGRlaHlkcmF0ZShpdGVtLCBjbGVhbmVkLCB1bnNlcmlhbGl6YWJsZSwgcGF0aC5jb25jYXQoW2ldKSwgaXNQYXRoQWxsb3dlZCwgaXNQYXRoQWxsb3dlZENoZWNrID8gMSA6IGxldmVsICsgMSk7XG4gICAgICAgIH0pO1xuICAgICAgICB1bnNlcmlhbGl6YWJsZS5wdXNoKHBhdGgpO1xuICAgICAgICByZXR1cm4gdW5zZXJpYWxpemFibGVWYWx1ZTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ29wYXF1ZV9pdGVyYXRvcic6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YVtTeW1ib2wudG9TdHJpbmdUYWddLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbnNwZWN0YWJsZTogZmFsc2UsXG4gICAgICAgIHByZXZpZXdfc2hvcnQ6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIGZhbHNlKSxcbiAgICAgICAgcHJldmlld19sb25nOiBmb3JtYXREYXRhRm9yUHJldmlldyhkYXRhLCB0cnVlKSxcbiAgICAgICAgbmFtZTogZGF0YS50b1N0cmluZygpLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgY2FzZSAncmVnZXhwJzpcbiAgICAgIGNsZWFuZWQucHVzaChwYXRoKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGluc3BlY3RhYmxlOiBmYWxzZSxcbiAgICAgICAgcHJldmlld19zaG9ydDogZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgZmFsc2UpLFxuICAgICAgICBwcmV2aWV3X2xvbmc6IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGEsIHRydWUpLFxuICAgICAgICBuYW1lOiBkYXRhLnRvU3RyaW5nKCksXG4gICAgICAgIHR5cGU6IHR5cGVcbiAgICAgIH07XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaXNQYXRoQWxsb3dlZENoZWNrID0gaXNQYXRoQWxsb3dlZChwYXRoKTtcblxuICAgICAgaWYgKGxldmVsID49IExFVkVMX1RIUkVTSE9MRCAmJiAhaXNQYXRoQWxsb3dlZENoZWNrKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEZWh5ZHJhdGVkKHR5cGUsIHRydWUsIGRhdGEsIGNsZWFuZWQsIHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgICAgICBnZXRBbGxFbnVtZXJhYmxlS2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgbmFtZSA9IGtleS50b1N0cmluZygpO1xuICAgICAgICAgIG9iamVjdFtuYW1lXSA9IGRlaHlkcmF0ZShkYXRhW2tleV0sIGNsZWFuZWQsIHVuc2VyaWFsaXphYmxlLCBwYXRoLmNvbmNhdChbbmFtZV0pLCBpc1BhdGhBbGxvd2VkLCBpc1BhdGhBbGxvd2VkQ2hlY2sgPyAxIDogbGV2ZWwgKyAxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbmZpbml0eSc6XG4gICAgY2FzZSAnbmFuJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgLy8gU29tZSB2YWx1ZXMgYXJlIGxvc3N5IHdoZW4gc2VudCB0aHJvdWdoIGEgV2ViU29ja2V0LlxuICAgICAgLy8gV2UgZGVoeWRyYXRlK3JlaHlkcmF0ZSB0aGVtIHRvIHByZXNlcnZlIHRoZWlyIHR5cGUuXG4gICAgICBjbGVhbmVkLnB1c2gocGF0aCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBkYXRhO1xuICB9XG59XG5mdW5jdGlvbiBmaWxsSW5QYXRoKG9iamVjdCwgZGF0YSwgcGF0aCwgdmFsdWUpIHtcbiAgdmFyIHRhcmdldCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aCk7XG5cbiAgaWYgKHRhcmdldCAhPSBudWxsKSB7XG4gICAgaWYgKCF0YXJnZXRbbWV0YS51bnNlcmlhbGl6YWJsZV0pIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5pbnNwZWN0YWJsZV07XG4gICAgICBkZWxldGUgdGFyZ2V0W21ldGEuaW5zcGVjdGVkXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5uYW1lXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5wcmV2aWV3X2xvbmddO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnByZXZpZXdfc2hvcnRdO1xuICAgICAgZGVsZXRlIHRhcmdldFttZXRhLnJlYWRvbmx5XTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS5zaXplXTtcbiAgICAgIGRlbGV0ZSB0YXJnZXRbbWV0YS50eXBlXTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgZGF0YS51bnNlcmlhbGl6YWJsZS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHVuc2VyaWFsaXphYmxlUGF0aCA9IGRhdGEudW5zZXJpYWxpemFibGVbMF07XG4gICAgdmFyIGlzTWF0Y2ggPSB1bnNlcmlhbGl6YWJsZVBhdGgubGVuZ3RoID09PSBwYXRoLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gIT09IHVuc2VyaWFsaXphYmxlUGF0aFtpXSkge1xuICAgICAgICBpc01hdGNoID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc01hdGNoKSB7XG4gICAgICB1cGdyYWRlVW5zZXJpYWxpemFibGUodmFsdWUsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBzZXRJbk9iamVjdChvYmplY3QsIHBhdGgsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGh5ZHJhdGUob2JqZWN0LCBjbGVhbmVkLCB1bnNlcmlhbGl6YWJsZSkge1xuICBjbGVhbmVkLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICB2YXIgbGVuZ3RoID0gcGF0aC5sZW5ndGg7XG4gICAgdmFyIGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuICAgIHZhciBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuXG4gICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC5oYXNPd25Qcm9wZXJ0eShsYXN0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IHBhcmVudFtsYXN0XTtcblxuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICdpbmZpbml0eScpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IEluZmluaXR5O1xuICAgIH0gZWxzZSBpZiAodmFsdWUudHlwZSA9PT0gJ25hbicpIHtcbiAgICAgIHBhcmVudFtsYXN0XSA9IE5hTjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlLnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwYXJlbnRbbGFzdF0gPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlcGxhY2UgdGhlIHN0cmluZyBrZXlzIHdpdGggU3ltYm9scyBzbyB0aGV5J3JlIG5vbi1lbnVtZXJhYmxlLlxuICAgICAgdmFyIHJlcGxhY2VkID0ge307XG4gICAgICByZXBsYWNlZFttZXRhLmluc3BlY3RhYmxlXSA9ICEhdmFsdWUuaW5zcGVjdGFibGU7XG4gICAgICByZXBsYWNlZFttZXRhLmluc3BlY3RlZF0gPSBmYWxzZTtcbiAgICAgIHJlcGxhY2VkW21ldGEubmFtZV0gPSB2YWx1ZS5uYW1lO1xuICAgICAgcmVwbGFjZWRbbWV0YS5wcmV2aWV3X2xvbmddID0gdmFsdWUucHJldmlld19sb25nO1xuICAgICAgcmVwbGFjZWRbbWV0YS5wcmV2aWV3X3Nob3J0XSA9IHZhbHVlLnByZXZpZXdfc2hvcnQ7XG4gICAgICByZXBsYWNlZFttZXRhLnNpemVdID0gdmFsdWUuc2l6ZTtcbiAgICAgIHJlcGxhY2VkW21ldGEucmVhZG9ubHldID0gISF2YWx1ZS5yZWFkb25seTtcbiAgICAgIHJlcGxhY2VkW21ldGEudHlwZV0gPSB2YWx1ZS50eXBlO1xuICAgICAgcGFyZW50W2xhc3RdID0gcmVwbGFjZWQ7XG4gICAgfVxuICB9KTtcbiAgdW5zZXJpYWxpemFibGUuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgbGFzdCA9IHBhdGhbbGVuZ3RoIC0gMV07XG4gICAgdmFyIHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG5cbiAgICBpZiAoIXBhcmVudCB8fCAhcGFyZW50Lmhhc093blByb3BlcnR5KGxhc3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBwYXJlbnRbbGFzdF07XG5cbiAgICB2YXIgcmVwbGFjZW1lbnQgPSBfb2JqZWN0U3ByZWFkKHt9LCBub2RlKTtcblxuICAgIHVwZ3JhZGVVbnNlcmlhbGl6YWJsZShyZXBsYWNlbWVudCwgbm9kZSk7XG4gICAgcGFyZW50W2xhc3RdID0gcmVwbGFjZW1lbnQ7XG4gIH0pO1xuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlVW5zZXJpYWxpemFibGUoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICB2YXIgX09iamVjdCRkZWZpbmVQcm9wZXJ0O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGRlc3RpbmF0aW9uLCAoX09iamVjdCRkZWZpbmVQcm9wZXJ0ID0ge30sIGh5ZHJhdGlvbl9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEuaW5zcGVjdGVkLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiAhIXNvdXJjZS5pbnNwZWN0ZWRcbiAgfSksIGh5ZHJhdGlvbl9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEubmFtZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogc291cmNlLm5hbWVcbiAgfSksIGh5ZHJhdGlvbl9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGRlZmluZVByb3BlcnQsIG1ldGEucHJldmlld19sb25nLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBzb3VyY2UucHJldmlld19sb25nXG4gIH0pLCBoeWRyYXRpb25fZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLnByZXZpZXdfc2hvcnQsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHNvdXJjZS5wcmV2aWV3X3Nob3J0XG4gIH0pLCBoeWRyYXRpb25fZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLnNpemUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IHNvdXJjZS5zaXplXG4gIH0pLCBoeWRyYXRpb25fZGVmaW5lUHJvcGVydHkoX09iamVjdCRkZWZpbmVQcm9wZXJ0LCBtZXRhLnJlYWRvbmx5LCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiAhIXNvdXJjZS5yZWFkb25seVxuICB9KSwgaHlkcmF0aW9uX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS50eXBlLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBzb3VyY2UudHlwZVxuICB9KSwgaHlkcmF0aW9uX2RlZmluZVByb3BlcnR5KF9PYmplY3QkZGVmaW5lUHJvcGVydCwgbWV0YS51bnNlcmlhbGl6YWJsZSwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB2YWx1ZTogISFzb3VyY2UudW5zZXJpYWxpemFibGVcbiAgfSksIF9PYmplY3QkZGVmaW5lUHJvcGVydCkpO1xuICBkZWxldGUgZGVzdGluYXRpb24uaW5zcGVjdGVkO1xuICBkZWxldGUgZGVzdGluYXRpb24ubmFtZTtcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfbG9uZztcbiAgZGVsZXRlIGRlc3RpbmF0aW9uLnByZXZpZXdfc2hvcnQ7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi5zaXplO1xuICBkZWxldGUgZGVzdGluYXRpb24ucmVhZG9ubHk7XG4gIGRlbGV0ZSBkZXN0aW5hdGlvbi50eXBlO1xuICBkZWxldGUgZGVzdGluYXRpb24udW5zZXJpYWxpemFibGU7XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL3V0aWxzLmpzXG5mdW5jdGlvbiB1dGlsc190eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHV0aWxzX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyB1dGlsc190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gdXRpbHNfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHV0aWxzX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiB1dGlsc191bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIHV0aWxzX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiB1dGlsc19hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIHV0aWxzX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiB1dGlsc19hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBjYWNoZWREaXNwbGF5TmFtZXMgPSBuZXcgV2Vha01hcCgpOyAvLyBPbiBsYXJnZSB0cmVlcywgZW5jb2RpbmcgdGFrZXMgc2lnbmlmaWNhbnQgdGltZS5cbi8vIFRyeSB0byByZXVzZSB0aGUgYWxyZWFkeSBlbmNvZGVkIHN0cmluZ3MuXG5cbnZhciBlbmNvZGVkU3RyaW5nQ2FjaGUgPSBuZXcgbHJ1X2NhY2hlX2RlZmF1bHQuYSh7XG4gIG1heDogMTAwMFxufSk7XG5mdW5jdGlvbiBhbHBoYVNvcnRLZXlzKGEsIGIpIHtcbiAgaWYgKGEudG9TdHJpbmcoKSA+IGIudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiAxO1xuICB9IGVsc2UgaWYgKGIudG9TdHJpbmcoKSA+IGEudG9TdHJpbmcoKSkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gMDtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsRW51bWVyYWJsZUtleXMob2JqKSB7XG4gIHZhciBrZXlzID0gbmV3IFNldCgpO1xuICB2YXIgY3VycmVudCA9IG9iajtcblxuICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICB2YXIgY3VycmVudEtleXMgPSBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5rZXlzKGN1cnJlbnQpKSwgX3RvQ29uc3VtYWJsZUFycmF5KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoY3VycmVudCkpKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhjdXJyZW50KTtcbiAgICBjdXJyZW50S2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIC8vICRGbG93Rml4TWU6IGtleSBjYW4gYmUgYSBTeW1ib2wgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2dldE93blByb3BlcnR5RGVzY3JpcHRvclxuICAgICAgaWYgKGRlc2NyaXB0b3JzW2tleV0uZW51bWVyYWJsZSkge1xuICAgICAgICBrZXlzLmFkZChrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN1cnJlbnQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY3VycmVudCk7XG4gIH07XG5cbiAgd2hpbGUgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgIF9sb29wKCk7XG4gIH1cblxuICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lKHR5cGUpIHtcbiAgdmFyIGZhbGxiYWNrTmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ0Fub255bW91cyc7XG4gIHZhciBuYW1lRnJvbUNhY2hlID0gY2FjaGVkRGlzcGxheU5hbWVzLmdldCh0eXBlKTtcblxuICBpZiAobmFtZUZyb21DYWNoZSAhPSBudWxsKSB7XG4gICAgcmV0dXJuIG5hbWVGcm9tQ2FjaGU7XG4gIH1cblxuICB2YXIgZGlzcGxheU5hbWUgPSBmYWxsYmFja05hbWU7IC8vIFRoZSBkaXNwbGF5TmFtZSBwcm9wZXJ0eSBpcyBub3QgZ3VhcmFudGVlZCB0byBiZSBhIHN0cmluZy5cbiAgLy8gSXQncyBvbmx5IHNhZmUgdG8gdXNlIGZvciBvdXIgcHVycG9zZXMgaWYgaXQncyBhIHN0cmluZy5cbiAgLy8gZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1kZXZ0b29scy9pc3N1ZXMvODAzXG5cbiAgaWYgKHR5cGVvZiB0eXBlLmRpc3BsYXlOYW1lID09PSAnc3RyaW5nJykge1xuICAgIGRpc3BsYXlOYW1lID0gdHlwZS5kaXNwbGF5TmFtZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZS5uYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlLm5hbWUgIT09ICcnKSB7XG4gICAgZGlzcGxheU5hbWUgPSB0eXBlLm5hbWU7XG4gIH1cblxuICBjYWNoZWREaXNwbGF5TmFtZXMuc2V0KHR5cGUsIGRpc3BsYXlOYW1lKTtcbiAgcmV0dXJuIGRpc3BsYXlOYW1lO1xufVxudmFyIHV0aWxzX3VpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gZ2V0VUlEKCkge1xuICByZXR1cm4gKyt1dGlsc191aWRDb3VudGVyO1xufVxuZnVuY3Rpb24gdXRmRGVjb2RlU3RyaW5nKGFycmF5KSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShTdHJpbmcsIF90b0NvbnN1bWFibGVBcnJheShhcnJheSkpO1xufVxuZnVuY3Rpb24gdXRmRW5jb2RlU3RyaW5nKHN0cmluZykge1xuICB2YXIgY2FjaGVkID0gZW5jb2RlZFN0cmluZ0NhY2hlLmdldChzdHJpbmcpO1xuXG4gIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBjYWNoZWQ7XG4gIH1cblxuICB2YXIgZW5jb2RlZCA9IG5ldyBBcnJheShzdHJpbmcubGVuZ3RoKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgIGVuY29kZWRbaV0gPSBzdHJpbmcuY29kZVBvaW50QXQoaSk7XG4gIH1cblxuICBlbmNvZGVkU3RyaW5nQ2FjaGUuc2V0KHN0cmluZywgZW5jb2RlZCk7XG4gIHJldHVybiBlbmNvZGVkO1xufVxuZnVuY3Rpb24gcHJpbnRPcGVyYXRpb25zQXJyYXkob3BlcmF0aW9ucykge1xuICAvLyBUaGUgZmlyc3QgdHdvIHZhbHVlcyBhcmUgYWx3YXlzIHJlbmRlcmVySUQgYW5kIHJvb3RJRFxuICB2YXIgcmVuZGVyZXJJRCA9IG9wZXJhdGlvbnNbMF07XG4gIHZhciByb290SUQgPSBvcGVyYXRpb25zWzFdO1xuICB2YXIgbG9ncyA9IFtcIm9wZXJhdGlvbnMgZm9yIHJlbmRlcmVyOlwiLmNvbmNhdChyZW5kZXJlcklELCBcIiBhbmQgcm9vdDpcIikuY29uY2F0KHJvb3RJRCldO1xuICB2YXIgaSA9IDI7IC8vIFJlYXNzZW1ibGUgdGhlIHN0cmluZyB0YWJsZS5cblxuICB2YXIgc3RyaW5nVGFibGUgPSBbbnVsbCAvLyBJRCA9IDAgY29ycmVzcG9uZHMgdG8gdGhlIG51bGwgc3RyaW5nLlxuICBdO1xuICB2YXIgc3RyaW5nVGFibGVTaXplID0gb3BlcmF0aW9uc1tpKytdO1xuICB2YXIgc3RyaW5nVGFibGVFbmQgPSBpICsgc3RyaW5nVGFibGVTaXplO1xuXG4gIHdoaWxlIChpIDwgc3RyaW5nVGFibGVFbmQpIHtcbiAgICB2YXIgbmV4dExlbmd0aCA9IG9wZXJhdGlvbnNbaSsrXTtcbiAgICB2YXIgbmV4dFN0cmluZyA9IHV0ZkRlY29kZVN0cmluZyhvcGVyYXRpb25zLnNsaWNlKGksIGkgKyBuZXh0TGVuZ3RoKSk7XG4gICAgc3RyaW5nVGFibGUucHVzaChuZXh0U3RyaW5nKTtcbiAgICBpICs9IG5leHRMZW5ndGg7XG4gIH1cblxuICB3aGlsZSAoaSA8IG9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgdmFyIG9wZXJhdGlvbiA9IG9wZXJhdGlvbnNbaV07XG5cbiAgICBzd2l0Y2ggKG9wZXJhdGlvbikge1xuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9BREQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2lkID0gb3BlcmF0aW9uc1tpICsgMV07XG4gICAgICAgICAgdmFyIHR5cGUgPSBvcGVyYXRpb25zW2kgKyAyXTtcbiAgICAgICAgICBpICs9IDM7XG5cbiAgICAgICAgICBpZiAodHlwZSA9PT0gRWxlbWVudFR5cGVSb290KSB7XG4gICAgICAgICAgICBsb2dzLnB1c2goXCJBZGQgbmV3IHJvb3Qgbm9kZSBcIi5jb25jYXQoX2lkKSk7XG4gICAgICAgICAgICBpKys7IC8vIHN1cHBvcnRzUHJvZmlsaW5nXG5cbiAgICAgICAgICAgIGkrKzsgLy8gaGFzT3duZXJNZXRhZGF0YVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50SUQgPSBvcGVyYXRpb25zW2ldO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaSsrOyAvLyBvd25lcklEXG5cbiAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZVN0cmluZ0lEID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHN0cmluZ1RhYmxlW2Rpc3BsYXlOYW1lU3RyaW5nSURdO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaSsrOyAvLyBrZXlcblxuICAgICAgICAgICAgbG9ncy5wdXNoKFwiQWRkIG5vZGUgXCIuY29uY2F0KF9pZCwgXCIgKFwiKS5jb25jYXQoZGlzcGxheU5hbWUgfHwgJ251bGwnLCBcIikgYXMgY2hpbGQgb2YgXCIpLmNvbmNhdChwYXJlbnRJRCkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgVFJFRV9PUEVSQVRJT05fUkVNT1ZFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHJlbW92ZUxlbmd0aCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICAgIGkgKz0gMjtcblxuICAgICAgICAgIGZvciAodmFyIHJlbW92ZUluZGV4ID0gMDsgcmVtb3ZlSW5kZXggPCByZW1vdmVMZW5ndGg7IHJlbW92ZUluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBfaWQyID0gb3BlcmF0aW9uc1tpXTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgIGxvZ3MucHVzaChcIlJlbW92ZSBub2RlIFwiLmNvbmNhdChfaWQyKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVDpcbiAgICAgICAge1xuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICBsb2dzLnB1c2goXCJSZW1vdmUgcm9vdCBcIi5jb25jYXQocm9vdElEKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pZDMgPSBvcGVyYXRpb25zW2kgKyAxXTtcbiAgICAgICAgICB2YXIgbnVtQ2hpbGRyZW4gPSBvcGVyYXRpb25zW2kgKyAyXTtcbiAgICAgICAgICBpICs9IDM7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gb3BlcmF0aW9ucy5zbGljZShpLCBpICsgbnVtQ2hpbGRyZW4pO1xuICAgICAgICAgIGkgKz0gbnVtQ2hpbGRyZW47XG4gICAgICAgICAgbG9ncy5wdXNoKFwiUmUtb3JkZXIgbm9kZSBcIi5jb25jYXQoX2lkMywgXCIgY2hpbGRyZW4gXCIpLmNvbmNhdChjaGlsZHJlbi5qb2luKCcsJykpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1VQREFURV9UUkVFX0JBU0VfRFVSQVRJT046XG4gICAgICAgIC8vIEJhc2UgZHVyYXRpb24gdXBkYXRlcyBhcmUgb25seSBzZW50IHdoaWxlIHByb2ZpbGluZyBpcyBpbiBwcm9ncmVzcy5cbiAgICAgICAgLy8gV2UgY2FuIGlnbm9yZSB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIC8vIFRoZSBwcm9maWxlciBVSSB1c2VzIHRoZW0gbGF6aWx5IGluIG9yZGVyIHRvIGdlbmVyYXRlIHRoZSB0cmVlLlxuICAgICAgICBpICs9IDM7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRSRUVfT1BFUkFUSU9OX1VQREFURV9FUlJPUlNfT1JfV0FSTklOR1M6XG4gICAgICAgIHZhciBpZCA9IG9wZXJhdGlvbnNbaSArIDFdO1xuICAgICAgICB2YXIgbnVtRXJyb3JzID0gb3BlcmF0aW9uc1tpICsgMl07XG4gICAgICAgIHZhciBudW1XYXJuaW5ncyA9IG9wZXJhdGlvbnNbaSArIDNdO1xuICAgICAgICBpICs9IDQ7XG4gICAgICAgIGxvZ3MucHVzaChcIk5vZGUgXCIuY29uY2F0KGlkLCBcIiBoYXMgXCIpLmNvbmNhdChudW1FcnJvcnMsIFwiIGVycm9ycyBhbmQgXCIpLmNvbmNhdChudW1XYXJuaW5ncywgXCIgd2FybmluZ3NcIikpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJVbnN1cHBvcnRlZCBCcmlkZ2Ugb3BlcmF0aW9uIFxcXCJcIi5jb25jYXQob3BlcmF0aW9uLCBcIlxcXCJcIikpO1xuICAgIH1cbiAgfVxuXG4gIGNvbnNvbGUubG9nKGxvZ3Muam9pbignXFxuICAnKSk7XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycygpIHtcbiAgcmV0dXJuIFt7XG4gICAgdHlwZTogQ29tcG9uZW50RmlsdGVyRWxlbWVudFR5cGUsXG4gICAgdmFsdWU6IEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCxcbiAgICBpc0VuYWJsZWQ6IHRydWVcbiAgfV07XG59XG5mdW5jdGlvbiBnZXRTYXZlZENvbXBvbmVudEZpbHRlcnMoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJhdyA9IGxvY2FsU3RvcmFnZUdldEl0ZW0oTE9DQUxfU1RPUkFHRV9GSUxURVJfUFJFRkVSRU5DRVNfS0VZKTtcblxuICAgIGlmIChyYXcgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gIHJldHVybiBnZXREZWZhdWx0Q29tcG9uZW50RmlsdGVycygpO1xufVxuZnVuY3Rpb24gc2F2ZUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycykge1xuICBsb2NhbFN0b3JhZ2VTZXRJdGVtKExPQ0FMX1NUT1JBR0VfRklMVEVSX1BSRUZFUkVOQ0VTX0tFWSwgSlNPTi5zdHJpbmdpZnkoY29tcG9uZW50RmlsdGVycykpO1xufVxuZnVuY3Rpb24gZ2V0QXBwZW5kQ29tcG9uZW50U3RhY2soKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJhdyA9IGxvY2FsU3RvcmFnZUdldEl0ZW0oTE9DQUxfU1RPUkFHRV9TSE9VTERfUEFUQ0hfQ09OU09MRV9LRVkpO1xuXG4gICAgaWYgKHJhdyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZXRBcHBlbmRDb21wb25lbnRTdGFjayh2YWx1ZSkge1xuICBsb2NhbFN0b3JhZ2VTZXRJdGVtKExPQ0FMX1NUT1JBR0VfU0hPVUxEX1BBVENIX0NPTlNPTEVfS0VZLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gZ2V0QnJlYWtPbkNvbnNvbGVFcnJvcnMoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHJhdyA9IGxvY2FsU3RvcmFnZUdldEl0ZW0oTE9DQUxfU1RPUkFHRV9TSE9VTERfQlJFQUtfT05fQ09OU09MRV9FUlJPUlMpO1xuXG4gICAgaWYgKHJhdyAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShyYXcpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gc2V0QnJlYWtPbkNvbnNvbGVFcnJvcnModmFsdWUpIHtcbiAgbG9jYWxTdG9yYWdlU2V0SXRlbShMT0NBTF9TVE9SQUdFX1NIT1VMRF9CUkVBS19PTl9DT05TT0xFX0VSUk9SUywgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGdldFNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycygpIHtcbiAgdHJ5IHtcbiAgICB2YXIgcmF3ID0gbG9jYWxTdG9yYWdlR2V0SXRlbShMT0NBTF9TVE9SQUdFX1NIT1dfSU5MSU5FX1dBUk5JTkdTX0FORF9FUlJPUlNfS0VZKTtcblxuICAgIGlmIChyYXcgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmF3KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7fVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2V0U2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKHZhbHVlKSB7XG4gIGxvY2FsU3RvcmFnZVNldEl0ZW0oTE9DQUxfU1RPUkFHRV9TSE9XX0lOTElORV9XQVJOSU5HU19BTkRfRVJST1JTX0tFWSwgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHNlcGFyYXRlRGlzcGxheU5hbWVBbmRIT0NzKGRpc3BsYXlOYW1lLCB0eXBlKSB7XG4gIGlmIChkaXNwbGF5TmFtZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gIH1cblxuICB2YXIgaG9jRGlzcGxheU5hbWVzID0gbnVsbDtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIEVsZW1lbnRUeXBlQ2xhc3M6XG4gICAgY2FzZSBFbGVtZW50VHlwZUZvcndhcmRSZWY6XG4gICAgY2FzZSBFbGVtZW50VHlwZUZ1bmN0aW9uOlxuICAgIGNhc2UgRWxlbWVudFR5cGVNZW1vOlxuICAgICAgaWYgKGRpc3BsYXlOYW1lLmluZGV4T2YoJygnKSA+PSAwKSB7XG4gICAgICAgIHZhciBtYXRjaGVzID0gZGlzcGxheU5hbWUubWF0Y2goL1teKCldKy9nKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyAhPSBudWxsKSB7XG4gICAgICAgICAgZGlzcGxheU5hbWUgPSBtYXRjaGVzLnBvcCgpO1xuICAgICAgICAgIGhvY0Rpc3BsYXlOYW1lcyA9IG1hdGNoZXM7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodHlwZSA9PT0gRWxlbWVudFR5cGVNZW1vKSB7XG4gICAgaWYgKGhvY0Rpc3BsYXlOYW1lcyA9PT0gbnVsbCkge1xuICAgICAgaG9jRGlzcGxheU5hbWVzID0gWydNZW1vJ107XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvY0Rpc3BsYXlOYW1lcy51bnNoaWZ0KCdNZW1vJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09IEVsZW1lbnRUeXBlRm9yd2FyZFJlZikge1xuICAgIGlmIChob2NEaXNwbGF5TmFtZXMgPT09IG51bGwpIHtcbiAgICAgIGhvY0Rpc3BsYXlOYW1lcyA9IFsnRm9yd2FyZFJlZiddO1xuICAgIH0gZWxzZSB7XG4gICAgICBob2NEaXNwbGF5TmFtZXMudW5zaGlmdCgnRm9yd2FyZFJlZicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBbZGlzcGxheU5hbWUsIGhvY0Rpc3BsYXlOYW1lc107XG59IC8vIFB1bGxlZCBmcm9tIHJlYWN0LWNvbXBhdFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RldmVsb3BpdC9wcmVhY3QtY29tcGF0L2Jsb2IvN2M1ZGUwMGU3Yzg1ZTJmZmQwMTFiZjNhZjAyODk5YjYzZjY5OWQzYS9zcmMvaW5kZXguanMjTDM0OVxuXG5mdW5jdGlvbiBzaGFsbG93RGlmZmVycyhwcmV2LCBuZXh0KSB7XG4gIGZvciAodmFyIGF0dHJpYnV0ZSBpbiBwcmV2KSB7XG4gICAgaWYgKCEoYXR0cmlidXRlIGluIG5leHQpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfYXR0cmlidXRlIGluIG5leHQpIHtcbiAgICBpZiAocHJldltfYXR0cmlidXRlXSAhPT0gbmV4dFtfYXR0cmlidXRlXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZ2V0SW5PYmplY3Qob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBwYXRoLnJlZHVjZShmdW5jdGlvbiAocmVkdWNlZCwgYXR0cikge1xuICAgIGlmIChyZWR1Y2VkKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZWR1Y2VkLCBhdHRyKSkge1xuICAgICAgICByZXR1cm4gcmVkdWNlZFthdHRyXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiByZWR1Y2VkW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQ29udmVydCBpdGVyYWJsZSB0byBhcnJheSBhbmQgcmV0dXJuIGFycmF5W2luZGV4XVxuICAgICAgICAvL1xuICAgICAgICAvLyBUUklDS1lcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFsuLi5zcHJlYWRdIHN5bnRheCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICAvLyBUaGlzIHByb2plY3QgdXNlcyBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1zcHJlYWQgaW4gXCJsb29zZVwiIG1vZGUgd2hpY2ggb25seSB3b3JrcyB3aXRoIEFycmF5IHZhbHVlcy5cbiAgICAgICAgLy8gT3RoZXIgdHlwZXMgKGUuZy4gdHlwZWQgYXJyYXlzLCBTZXRzKSB3aWxsIG5vdCBzcHJlYWQgY29ycmVjdGx5LlxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShyZWR1Y2VkKVthdHRyXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSwgb2JqZWN0KTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVBhdGhJbk9iamVjdChvYmplY3QsIHBhdGgpIHtcbiAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICB2YXIgbGFzdCA9IHBhdGhbbGVuZ3RoIC0gMV07XG5cbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgdmFyIHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgcGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudC5zcGxpY2UobGFzdCwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgcGFyZW50W2xhc3RdO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVuYW1lUGF0aEluT2JqZWN0KG9iamVjdCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICB2YXIgbGVuZ3RoID0gb2xkUGF0aC5sZW5ndGg7XG5cbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgdmFyIHBhcmVudCA9IGdldEluT2JqZWN0KG9iamVjdCwgb2xkUGF0aC5zbGljZSgwLCBsZW5ndGggLSAxKSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgbGFzdE9sZCA9IG9sZFBhdGhbbGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGFzdE5ldyA9IG5ld1BhdGhbbGVuZ3RoIC0gMV07XG4gICAgICBwYXJlbnRbbGFzdE5ld10gPSBwYXJlbnRbbGFzdE9sZF07XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgICAgcGFyZW50LnNwbGljZShsYXN0T2xkLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBwYXJlbnRbbGFzdE9sZF07XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJbk9iamVjdChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgdmFyIGxhc3QgPSBwYXRoW2xlbmd0aCAtIDFdO1xuXG4gIGlmIChvYmplY3QgIT0gbnVsbCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRJbk9iamVjdChvYmplY3QsIHBhdGguc2xpY2UoMCwgbGVuZ3RoIC0gMSkpO1xuXG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgcGFyZW50W2xhc3RdID0gdmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IGEgZW5oYW5jZWQvYXJ0aWZpY2lhbCB0eXBlIHN0cmluZyBiYXNlZCBvbiB0aGUgb2JqZWN0IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGdldERhdGFUeXBlKGRhdGEpIHtcbiAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgfVxuXG4gIGlmIChPYmplY3QocmVhY3RfaXNbXCJpc0VsZW1lbnRcIl0pKGRhdGEpKSB7XG4gICAgcmV0dXJuICdyZWFjdF9lbGVtZW50JztcbiAgfVxuXG4gIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgIHJldHVybiAnaHRtbF9lbGVtZW50JztcbiAgfVxuXG4gIHZhciB0eXBlID0gdXRpbHNfdHlwZW9mKGRhdGEpO1xuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2JpZ2ludCc6XG4gICAgICByZXR1cm4gJ2JpZ2ludCc7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiAnYm9vbGVhbic7XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiAnbmFuJztcbiAgICAgIH0gZWxzZSBpZiAoIU51bWJlci5pc0Zpbml0ZShkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ2luZmluaXR5JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgIH1cblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICByZXR1cm4gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEuY29uc3RydWN0b3IsICdCWVRFU19QRVJfRUxFTUVOVCcpID8gJ3R5cGVkX2FycmF5JyA6ICdkYXRhX3ZpZXcnO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmNvbnN0cnVjdG9yICYmIGRhdGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJykge1xuICAgICAgICAvLyBIQUNLIFRoaXMgQXJyYXlCdWZmZXIgY2hlY2sgaXMgZ3Jvc3M7IGlzIHRoZXJlIGEgYmV0dGVyIHdheT9cbiAgICAgICAgLy8gV2UgY291bGQgdHJ5IHRvIGNyZWF0ZSBhIG5ldyBEYXRhVmlldyB3aXRoIHRoZSB2YWx1ZS5cbiAgICAgICAgLy8gSWYgaXQgZG9lc24ndCBlcnJvciwgd2Uga25vdyBpdCdzIGFuIEFycmF5QnVmZmVyLFxuICAgICAgICAvLyBidXQgdGhpcyBzZWVtcyBraW5kIG9mIGF3a3dhcmQgYW5kIGV4cGVuc2l2ZS5cbiAgICAgICAgcmV0dXJuICdhcnJheV9idWZmZXInO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZGF0YVtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGRhdGFbU3ltYm9sLml0ZXJhdG9yXSgpO1xuXG4gICAgICAgIGlmICghaXRlcmF0b3IpIHsvLyBQcm94aWVzIG1pZ2h0IGJyZWFrIGFzc3VtcHRvaW5zIGFib3V0IGl0ZXJhdG9ycy5cbiAgICAgICAgICAvLyBTZWUgZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjE2NTRcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gaXRlcmF0b3IgPT09IGRhdGEgPyAnb3BhcXVlX2l0ZXJhdG9yJyA6ICdpdGVyYXRvcic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5jb25zdHJ1Y3RvciAmJiBkYXRhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdSZWdFeHAnKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0b1N0cmluZ1ZhbHVlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpO1xuXG4gICAgICAgIGlmICh0b1N0cmluZ1ZhbHVlID09PSAnW29iamVjdCBEYXRlXScpIHtcbiAgICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgICB9IGVsc2UgaWYgKHRvU3RyaW5nVmFsdWUgPT09ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXScpIHtcbiAgICAgICAgICByZXR1cm4gJ2h0bWxfYWxsX2NvbGxlY3Rpb24nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gJ3N0cmluZyc7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkgPT09ICdbb2JqZWN0IEhUTUxBbGxDb2xsZWN0aW9uXScpIHtcbiAgICAgICAgcmV0dXJuICdodG1sX2FsbF9jb2xsZWN0aW9uJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAndW5rbm93bic7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgdmFyIGVsZW1lbnRUeXBlID0gT2JqZWN0KHJlYWN0X2lzW1widHlwZU9mXCJdKShlbGVtZW50KTtcblxuICBzd2l0Y2ggKGVsZW1lbnRUeXBlKSB7XG4gICAgY2FzZSByZWFjdF9pc1tcIkNvbnRleHRDb25zdW1lclwiXTpcbiAgICAgIHJldHVybiAnQ29udGV4dENvbnN1bWVyJztcblxuICAgIGNhc2UgcmVhY3RfaXNbXCJDb250ZXh0UHJvdmlkZXJcIl06XG4gICAgICByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XG5cbiAgICBjYXNlIHJlYWN0X2lzW1wiRm9yd2FyZFJlZlwiXTpcbiAgICAgIHJldHVybiAnRm9yd2FyZFJlZic7XG5cbiAgICBjYXNlIHJlYWN0X2lzW1wiRnJhZ21lbnRcIl06XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgcmVhY3RfaXNbXCJMYXp5XCJdOlxuICAgICAgcmV0dXJuICdMYXp5JztcblxuICAgIGNhc2UgcmVhY3RfaXNbXCJNZW1vXCJdOlxuICAgICAgcmV0dXJuICdNZW1vJztcblxuICAgIGNhc2UgcmVhY3RfaXNbXCJQb3J0YWxcIl06XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIHJlYWN0X2lzW1wiUHJvZmlsZXJcIl06XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgcmVhY3RfaXNbXCJTdHJpY3RNb2RlXCJdOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgcmVhY3RfaXNbXCJTdXNwZW5zZVwiXTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZSh0eXBlLCAnQW5vbnltb3VzJyk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gJ05vdEltcGxlbWVudGVkSW5EZXZ0b29scyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ0VsZW1lbnQnO1xuICAgICAgfVxuXG4gIH1cbn1cbnZhciBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIID0gNTA7XG5cbmZ1bmN0aW9uIHRydW5jYXRlRm9yRGlzcGxheShzdHJpbmcpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSDtcblxuICBpZiAoc3RyaW5nLmxlbmd0aCA+IGxlbmd0aCkge1xuICAgIHJldHVybiBzdHJpbmcuc3Vic3RyKDAsIGxlbmd0aCkgKyAn4oCmJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG59IC8vIEF0dGVtcHRzIHRvIG1pbWljIENocm9tZSdzIGlubGluZSBwcmV2aWV3IGZvciB2YWx1ZXMuXG4vLyBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyB2YWx1ZS4uLlxuLy8gICB7XG4vLyAgICAgIGZvbzogMTIzLFxuLy8gICAgICBiYXI6IFwiYWJjXCIsXG4vLyAgICAgIGJhejogW3RydWUsIGZhbHNlXSxcbi8vICAgICAgcXV4OiB7IGFiOiAxLCBjZDogMiB9XG4vLyAgIH07XG4vL1xuLy8gV291bGQgc2hvdyBhIHByZXZpZXcgb2YuLi5cbi8vICAge2ZvbzogMTIzLCBiYXI6IFwiYWJjXCIsIGJhejogQXJyYXkoMiksIHF1eDoge+KApn19XG4vL1xuLy8gQW5kIHRoZSBmb2xsb3dpbmcgdmFsdWUuLi5cbi8vICAgW1xuLy8gICAgIDEyMyxcbi8vICAgICBcImFiY1wiLFxuLy8gICAgIFt0cnVlLCBmYWxzZV0sXG4vLyAgICAgeyBmb286IDEyMywgYmFyOiBcImFiY1wiIH1cbi8vICAgXTtcbi8vXG4vLyBXb3VsZCBzaG93IGEgcHJldmlldyBvZi4uLlxuLy8gICBbMTIzLCBcImFiY1wiLCBBcnJheSgyKSwge+KApn1dXG5cblxuZnVuY3Rpb24gZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YSwgc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gIGlmIChkYXRhICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBtZXRhLnR5cGUpKSB7XG4gICAgcmV0dXJuIHNob3dGb3JtYXR0ZWRWYWx1ZSA/IGRhdGFbbWV0YS5wcmV2aWV3X2xvbmddIDogZGF0YVttZXRhLnByZXZpZXdfc2hvcnRdO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBnZXREYXRhVHlwZShkYXRhKTtcblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdodG1sX2VsZW1lbnQnOlxuICAgICAgcmV0dXJuIFwiPFwiLmNvbmNhdCh0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpLCBcIiAvPlwiKTtcblxuICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoXCJcXHUwMTkyIFwiLmNvbmNhdCh0eXBlb2YgZGF0YS5uYW1lID09PSAnZnVuY3Rpb24nID8gJycgOiBkYXRhLm5hbWUsIFwiKCkge31cIikpO1xuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiBcIlxcXCJcIi5jb25jYXQoZGF0YSwgXCJcXFwiXCIpO1xuXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoZGF0YS50b1N0cmluZygpICsgJ24nKTtcblxuICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICByZXR1cm4gdHJ1bmNhdGVGb3JEaXNwbGF5KGRhdGEudG9TdHJpbmcoKSk7XG5cbiAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgcmV0dXJuIHRydW5jYXRlRm9yRGlzcGxheShkYXRhLnRvU3RyaW5nKCkpO1xuXG4gICAgY2FzZSAncmVhY3RfZWxlbWVudCc6XG4gICAgICByZXR1cm4gXCI8XCIuY29uY2F0KHRydW5jYXRlRm9yRGlzcGxheShnZXREaXNwbGF5TmFtZUZvclJlYWN0RWxlbWVudChkYXRhKSB8fCAnVW5rbm93bicpLCBcIiAvPlwiKTtcblxuICAgIGNhc2UgJ2FycmF5X2J1ZmZlcic6XG4gICAgICByZXR1cm4gXCJBcnJheUJ1ZmZlcihcIi5jb25jYXQoZGF0YS5ieXRlTGVuZ3RoLCBcIilcIik7XG5cbiAgICBjYXNlICdkYXRhX3ZpZXcnOlxuICAgICAgcmV0dXJuIFwiRGF0YVZpZXcoXCIuY29uY2F0KGRhdGEuYnVmZmVyLmJ5dGVMZW5ndGgsIFwiKVwiKTtcblxuICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGlmIChzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9ICcnO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgZm9ybWF0dGVkICs9ICcsICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9ybWF0dGVkICs9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGRhdGFbaV0sIGZhbHNlKTtcblxuICAgICAgICAgIGlmIChmb3JtYXR0ZWQubGVuZ3RoID4gTUFYX1BSRVZJRVdfU1RSSU5HX0xFTkdUSCkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBkb2luZyBhIGxvdCBvZiB1bm5lY2Vzc2FyeSBpdGVyYXRpb24uLi5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBcIltcIi5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KGZvcm1hdHRlZCksIFwiXVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIG1ldGEuc2l6ZSkgPyBkYXRhW21ldGEuc2l6ZV0gOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIFwiQXJyYXkoXCIuY29uY2F0KGxlbmd0aCwgXCIpXCIpO1xuICAgICAgfVxuXG4gICAgY2FzZSAndHlwZWRfYXJyYXknOlxuICAgICAgdmFyIHNob3J0TmFtZSA9IFwiXCIuY29uY2F0KGRhdGEuY29uc3RydWN0b3IubmFtZSwgXCIoXCIpLmNvbmNhdChkYXRhLmxlbmd0aCwgXCIpXCIpO1xuXG4gICAgICBpZiAoc2hvd0Zvcm1hdHRlZFZhbHVlKSB7XG4gICAgICAgIHZhciBfZm9ybWF0dGVkID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGRhdGEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgaWYgKF9pID4gMCkge1xuICAgICAgICAgICAgX2Zvcm1hdHRlZCArPSAnLCAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9mb3JtYXR0ZWQgKz0gZGF0YVtfaV07XG5cbiAgICAgICAgICBpZiAoX2Zvcm1hdHRlZC5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KHNob3J0TmFtZSwgXCIgW1wiKS5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KF9mb3JtYXR0ZWQpLCBcIl1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2hvcnROYW1lO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaXRlcmF0b3InOlxuICAgICAgdmFyIG5hbWUgPSBkYXRhLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICAgIGlmIChzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgLy8gVFJJQ0tZXG4gICAgICAgIC8vIERvbid0IHVzZSBbLi4uc3ByZWFkXSBzeW50YXggZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgLy8gVGhpcyBwcm9qZWN0IHVzZXMgQGJhYmVsL3BsdWdpbi10cmFuc2Zvcm0tc3ByZWFkIGluIFwibG9vc2VcIiBtb2RlIHdoaWNoIG9ubHkgd29ya3Mgd2l0aCBBcnJheSB2YWx1ZXMuXG4gICAgICAgIC8vIE90aGVyIHR5cGVzIChlLmcuIHR5cGVkIGFycmF5cywgU2V0cykgd2lsbCBub3Qgc3ByZWFkIGNvcnJlY3RseS5cbiAgICAgICAgdmFyIGFycmF5ID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgICAgICAgdmFyIF9mb3JtYXR0ZWQyID0gJyc7XG5cbiAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgYXJyYXkubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICAgIHZhciBlbnRyeU9yRW50cmllcyA9IGFycmF5W19pMl07XG5cbiAgICAgICAgICBpZiAoX2kyID4gMCkge1xuICAgICAgICAgICAgX2Zvcm1hdHRlZDIgKz0gJywgJztcbiAgICAgICAgICB9IC8vIFRSSUNLWVxuICAgICAgICAgIC8vIEJyb3dzZXJzIGRpc3BsYXkgTWFwcyBhbmQgU2V0cyBkaWZmZXJlbnRseS5cbiAgICAgICAgICAvLyBUbyBtaW1pYyB0aGVpciBiZWhhdmlvciwgZGV0ZWN0IGlmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYW4gZW50cmllcyB0dXBsZS5cbiAgICAgICAgICAvLyAgIE1hcCgyKSB7XCJhYmNcIiA9PiAxMjMsIFwiZGVmXCIgPT4gMTIzfVxuICAgICAgICAgIC8vICAgU2V0KDIpIHtcImFiY1wiLCAxMjN9XG5cblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVudHJ5T3JFbnRyaWVzKSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGZvcm1hdERhdGFGb3JQcmV2aWV3KGVudHJ5T3JFbnRyaWVzWzFdLCBmYWxzZSk7XG4gICAgICAgICAgICBfZm9ybWF0dGVkMiArPSBcIlwiLmNvbmNhdChrZXksIFwiID0+IFwiKS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfZm9ybWF0dGVkMiArPSBmb3JtYXREYXRhRm9yUHJldmlldyhlbnRyeU9yRW50cmllcywgZmFsc2UpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfZm9ybWF0dGVkMi5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG5hbWUsIFwiKFwiKS5jb25jYXQoZGF0YS5zaXplLCBcIikge1wiKS5jb25jYXQodHJ1bmNhdGVGb3JEaXNwbGF5KF9mb3JtYXR0ZWQyKSwgXCJ9XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KG5hbWUsIFwiKFwiKS5jb25jYXQoZGF0YS5zaXplLCBcIilcIik7XG4gICAgICB9XG5cbiAgICBjYXNlICdvcGFxdWVfaXRlcmF0b3InOlxuICAgICAge1xuICAgICAgICByZXR1cm4gZGF0YVtTeW1ib2wudG9TdHJpbmdUYWddO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChzaG93Rm9ybWF0dGVkVmFsdWUpIHtcbiAgICAgICAgdmFyIGtleXMgPSBBcnJheS5mcm9tKGdldEFsbEVudW1lcmFibGVLZXlzKGRhdGEpKS5zb3J0KGFscGhhU29ydEtleXMpO1xuICAgICAgICB2YXIgX2Zvcm1hdHRlZDMgPSAnJztcblxuICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBrZXlzLmxlbmd0aDsgX2kzKyspIHtcbiAgICAgICAgICB2YXIgX2tleSA9IGtleXNbX2kzXTtcblxuICAgICAgICAgIGlmIChfaTMgPiAwKSB7XG4gICAgICAgICAgICBfZm9ybWF0dGVkMyArPSAnLCAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9mb3JtYXR0ZWQzICs9IFwiXCIuY29uY2F0KF9rZXkudG9TdHJpbmcoKSwgXCI6IFwiKS5jb25jYXQoZm9ybWF0RGF0YUZvclByZXZpZXcoZGF0YVtfa2V5XSwgZmFsc2UpKTtcblxuICAgICAgICAgIGlmIChfZm9ybWF0dGVkMy5sZW5ndGggPiBNQVhfUFJFVklFV19TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRvaW5nIGEgbG90IG9mIHVubmVjZXNzYXJ5IGl0ZXJhdGlvbi4uLlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwie1wiLmNvbmNhdCh0cnVuY2F0ZUZvckRpc3BsYXkoX2Zvcm1hdHRlZDMpLCBcIn1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gJ3vigKZ9JztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnaW5maW5pdHknOlxuICAgIGNhc2UgJ25hbic6XG4gICAgY2FzZSAnbnVsbCc6XG4gICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgIHJldHVybiBkYXRhO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0cnVuY2F0ZUZvckRpc3BsYXkoJycgKyBkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiAndW5zZXJpYWxpemFibGUnO1xuICAgICAgfVxuXG4gIH1cbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogL1VzZXJzL2x1bmEvY29kZS9yZWFjdC9ub2RlX21vZHVsZXMvY2xpcGJvYXJkLWpzL2NsaXBib2FyZC5qc1xudmFyIGNsaXBib2FyZCA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3NoYXJlZC9pc0FycmF5LmpzXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNoYXJlZF9pc0FycmF5ID0gKGlzQXJyYXkpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL3V0aWxzLmpzXG5mdW5jdGlvbiBiYWNrZW5kX3V0aWxzX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgYmFja2VuZF91dGlsc190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgYmFja2VuZF91dGlsc190eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gYmFja2VuZF91dGlsc190eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiB1dGlsc19vd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiB1dGlsc19vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgdXRpbHNfb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IHV0aWxzX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IHV0aWxzX293bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIHV0aWxzX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuZnVuY3Rpb24gY2xlYW5Gb3JCcmlkZ2UoZGF0YSwgaXNQYXRoQWxsb3dlZCkge1xuICB2YXIgcGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogW107XG5cbiAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICB2YXIgY2xlYW5lZFBhdGhzID0gW107XG4gICAgdmFyIHVuc2VyaWFsaXphYmxlUGF0aHMgPSBbXTtcbiAgICB2YXIgY2xlYW5lZERhdGEgPSBkZWh5ZHJhdGUoZGF0YSwgY2xlYW5lZFBhdGhzLCB1bnNlcmlhbGl6YWJsZVBhdGhzLCBwYXRoLCBpc1BhdGhBbGxvd2VkKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogY2xlYW5lZERhdGEsXG4gICAgICBjbGVhbmVkOiBjbGVhbmVkUGF0aHMsXG4gICAgICB1bnNlcmlhbGl6YWJsZTogdW5zZXJpYWxpemFibGVQYXRoc1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlUb0NsaXBib2FyZCh2YWx1ZSkge1xuICB2YXIgc2FmZVRvQ29weSA9IHNlcmlhbGl6ZVRvU3RyaW5nKHZhbHVlKTtcbiAgdmFyIHRleHQgPSBzYWZlVG9Db3B5ID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IHNhZmVUb0NvcHk7XG4gIHZhciBjbGlwYm9hcmRDb3B5VGV4dCA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2xpcGJvYXJkQ29weVRleHQ7IC8vIE9uIEZpcmVmb3ggbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQgaGFzIHRvIGJlIGNhbGxlZCBmcm9tXG4gIC8vIHRoZSBjb250ZW50IHNjcmlwdCBqcyBjb2RlIChiZWNhdXNlIGl0IHJlcXVpcmVzIHRoZSBjbGlwYm9hcmRXcml0ZVxuICAvLyBwZXJtaXNzaW9uIHRvIGJlIGFsbG93ZWQgb3V0IG9mIGEgXCJ1c2VyIGhhbmRsaW5nXCIgY2FsbGJhY2spLFxuICAvLyBjbGlwYm9hcmRDb3B5VGV4dCBpcyBhbiBoZWxwZXIgaW5qZWN0ZWQgaW50byB0aGUgcGFnZSBmcm9tLlxuICAvLyBpbmplY3RHbG9iYWxIb29rLlxuXG4gIGlmICh0eXBlb2YgY2xpcGJvYXJkQ29weVRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjbGlwYm9hcmRDb3B5VGV4dCh0ZXh0KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7fSk7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0KGNsaXBib2FyZFtcImNvcHlcIl0pKHRleHQpO1xuICB9XG59XG5mdW5jdGlvbiBjb3B5V2l0aERlbGV0ZShvYmosIHBhdGgpIHtcbiAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAwO1xuICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gIHZhciB1cGRhdGVkID0gc2hhcmVkX2lzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogdXRpbHNfb2JqZWN0U3ByZWFkKHt9LCBvYmopO1xuXG4gIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgaWYgKHNoYXJlZF9pc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICB1cGRhdGVkLnNwbGljZShrZXksIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgdXBkYXRlZFtrZXldO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhEZWxldGUob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlZDtcbn0gLy8gVGhpcyBmdW5jdGlvbiBleHBlY3RzIHBhdGhzIHRvIGJlIHRoZSBzYW1lIGV4Y2VwdCBmb3IgdGhlIGZpbmFsIHZhbHVlLlxuLy8gZS5nLiBbJ3BhdGgnLCAndG8nLCAnZm9vJ10gYW5kIFsncGF0aCcsICd0bycsICdiYXInXVxuXG5mdW5jdGlvbiBjb3B5V2l0aFJlbmFtZShvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgdmFyIGluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gIHZhciB1cGRhdGVkID0gc2hhcmVkX2lzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogdXRpbHNfb2JqZWN0U3ByZWFkKHt9LCBvYmopO1xuXG4gIGlmIChpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoKSB7XG4gICAgdmFyIG5ld0tleSA9IG5ld1BhdGhbaW5kZXhdOyAvLyAkRmxvd0ZpeE1lIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cbiAgICB1cGRhdGVkW25ld0tleV0gPSB1cGRhdGVkW29sZEtleV07XG5cbiAgICBpZiAoc2hhcmVkX2lzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgIHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB1cGRhdGVkW29sZEtleV07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWUgbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZShvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVkO1xufVxuZnVuY3Rpb24gY29weVdpdGhTZXQob2JqLCBwYXRoLCB2YWx1ZSkge1xuICB2YXIgaW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG5cbiAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICB2YXIgdXBkYXRlZCA9IHNoYXJlZF9pc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IHV0aWxzX29iamVjdFNwcmVhZCh7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoU2V0KG9ialtrZXldLCBwYXRoLCB2YWx1ZSwgaW5kZXggKyAxKTtcbiAgcmV0dXJuIHVwZGF0ZWQ7XG59XG5mdW5jdGlvbiBnZXRFZmZlY3REdXJhdGlvbnMocm9vdCkge1xuICAvLyBQcm9maWxpbmcgZHVyYXRpb25zIGFyZSBvbmx5IGF2YWlsYWJsZSBmb3IgY2VydGFpbiBidWlsZHMuXG4gIC8vIElmIGF2YWlsYWJsZSwgdGhleSdsbCBiZSBzdG9yZWQgb24gdGhlIEhvc3RSb290LlxuICB2YXIgZWZmZWN0RHVyYXRpb24gPSBudWxsO1xuICB2YXIgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gbnVsbDtcbiAgdmFyIGhvc3RSb290ID0gcm9vdC5jdXJyZW50O1xuXG4gIGlmIChob3N0Um9vdCAhPSBudWxsKSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IGhvc3RSb290LnN0YXRlTm9kZTtcblxuICAgIGlmIChzdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgZWZmZWN0RHVyYXRpb24gPSBzdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gIT0gbnVsbCA/IHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA6IG51bGw7XG4gICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICE9IG51bGwgPyBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uIDogbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVmZmVjdER1cmF0aW9uOiBlZmZlY3REdXJhdGlvbixcbiAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IHBhc3NpdmVFZmZlY3REdXJhdGlvblxuICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVG9TdHJpbmcoZGF0YSkge1xuICB2YXIgY2FjaGUgPSBuZXcgU2V0KCk7IC8vIFVzZSBhIGN1c3RvbSByZXBsYWNlciBmdW5jdGlvbiB0byBwcm90ZWN0IGFnYWluc3QgY2lyY3VsYXIgcmVmZXJlbmNlcy5cblxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoYmFja2VuZF91dGlsc190eXBlb2YodmFsdWUpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNhY2hlLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYWNoZS5hZGQodmFsdWUpO1xuICAgIH0gLy8gJEZsb3dGaXhNZVxuXG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYmlnaW50Jykge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyAnbic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9KTtcbn0gLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RtcGZzL2Zvcm1hdC11dGlsL2Jsb2IvMGU2MmQ0MzBlZmIwYTFjNTE0NDg3MDlhYmQzZTI0MDZjMTRkODQwMS9mb3JtYXQuanMjTDFcbi8vIGJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9jb25zb2xlI1VzaW5nX3N0cmluZ19zdWJzdGl0dXRpb25zXG4vLyBJbXBsZW1lbnRzIHMsIGQsIGkgYW5kIGYgcGxhY2Vob2xkZXJzXG5cbmZ1bmN0aW9uIGZvcm1hdChtYXliZU1lc3NhZ2UpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGlucHV0QXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgaW5wdXRBcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBhcmdzID0gaW5wdXRBcmdzLnNsaWNlKCk7IC8vIFN5bWJvbHMgY2Fubm90IGJlIGNvbmNhdGVuYXRlZCB3aXRoIFN0cmluZ3MuXG5cbiAgdmFyIGZvcm1hdHRlZCA9IGJhY2tlbmRfdXRpbHNfdHlwZW9mKG1heWJlTWVzc2FnZSkgPT09ICdzeW1ib2wnID8gbWF5YmVNZXNzYWdlLnRvU3RyaW5nKCkgOiAnJyArIG1heWJlTWVzc2FnZTsgLy8gSWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGEgc3RyaW5nLCBjaGVjayBmb3Igc3Vic3RpdHV0aW9ucy5cblxuICBpZiAodHlwZW9mIG1heWJlTWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgIHZhciBSRUdFWFAgPSAvKCU/KSglKFtqZHNdKSkvZztcbiAgICAgIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKFJFR0VYUCwgZnVuY3Rpb24gKG1hdGNoLCBlc2NhcGVkLCBwdG4sIGZsYWcpIHtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ3Muc2hpZnQoKTtcblxuICAgICAgICBzd2l0Y2ggKGZsYWcpIHtcbiAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgIGFyZyArPSAnJztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgY2FzZSAnaSc6XG4gICAgICAgICAgICBhcmcgPSBwYXJzZUludChhcmcsIDEwKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIGFyZyA9IHBhcnNlRmxvYXQoYXJnKS50b1N0cmluZygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWVzY2FwZWQpIHtcbiAgICAgICAgICByZXR1cm4gYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgYXJncy51bnNoaWZ0KGFyZyk7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBBcmd1bWVudHMgdGhhdCByZW1haW4gYWZ0ZXIgZm9ybWF0dGluZy5cblxuXG4gIGlmIChhcmdzLmxlbmd0aCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGFyZyA9IGFyZ3NbaV07IC8vIFN5bWJvbHMgY2Fubm90IGJlIGNvbmNhdGVuYXRlZCB3aXRoIFN0cmluZ3MuXG5cbiAgICAgIGZvcm1hdHRlZCArPSAnICcgKyAoYmFja2VuZF91dGlsc190eXBlb2YoYXJnKSA9PT0gJ3N5bWJvbCcgPyBhcmcudG9TdHJpbmcoKSA6IGFyZyk7XG4gICAgfVxuICB9IC8vIFVwZGF0ZSBlc2NhcGVkICUlIHZhbHVlcy5cblxuXG4gIGZvcm1hdHRlZCA9IGZvcm1hdHRlZC5yZXBsYWNlKC8lezIsMn0vZywgJyUnKTtcbiAgcmV0dXJuICcnICsgZm9ybWF0dGVkO1xufVxuZnVuY3Rpb24gaXNTeW5jaHJvbm91c1hIUlN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuICEhKHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuZmVhdHVyZVBvbGljeSAmJiB3aW5kb3cuZG9jdW1lbnQuZmVhdHVyZVBvbGljeS5hbGxvd3NGZWF0dXJlKCdzeW5jLXhocicpKTtcbn1cbi8vIEVYVEVSTkFMIE1PRFVMRTogL1VzZXJzL2x1bmEvY29kZS9yZWFjdC9idWlsZC9ub2RlX21vZHVsZXMvcmVhY3QtZGVidWctdG9vbHMvaW5kZXguanNcbnZhciByZWFjdF9kZWJ1Z190b29scyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIFRoaXMgbGlzdCBzaG91bGQgYmUga2VwdCB1cGRhdGVkIHRvIHJlZmxlY3QgYWRkaXRpb25zIHRvICdzaGFyZWQvUmVhY3RTeW1ib2xzJy5cbi8vIERldlRvb2xzIGNhbid0IGltcG9ydCBzeW1ib2xzIGZyb20gJ3NoYXJlZC9SZWFjdFN5bWJvbHMnIGRpcmVjdGx5IGZvciB0d28gcmVhc29uczpcbi8vIDEuIERldlRvb2xzIHJlcXVpcmVzIHN5bWJvbHMgd2hpY2ggbWF5IGhhdmUgYmVlbiBkZWxldGVkIGluIG1vcmUgcmVjZW50IHZlcnNpb25zIChlLmcuIGNvbmN1cnJlbnQgbW9kZSlcbi8vIDIuIERldlRvb2xzIG11c3Qgc3VwcG9ydCBib3RoIFN5bWJvbCBhbmQgbnVtZXJpYyBmb3JtcyBvZiBlYWNoIHN5bWJvbDtcbi8vICAgIFNpbmNlIGUuZy4gc3RhbmRhbG9uZSBEZXZUb29scyBydW5zIGluIGEgc2VwYXJhdGUgcHJvY2VzcywgaXQgY2FuJ3QgcmVseSBvbiBpdHMgb3duIEVTIGNhcGFiaWxpdGllcy5cbnZhciBDT05DVVJSRU5UX01PREVfTlVNQkVSID0gMHhlYWNmO1xudmFyIENPTkNVUlJFTlRfTU9ERV9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5jb25jdXJyZW50X21vZGUpJztcbnZhciBDT05URVhUX05VTUJFUiA9IDB4ZWFjZTtcbnZhciBDT05URVhUX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmNvbnRleHQpJztcbnZhciBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuYXN5bmNfbW9kZSknO1xudmFyIEVMRU1FTlRfTlVNQkVSID0gMHhlYWM3O1xudmFyIEVMRU1FTlRfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZWxlbWVudCknO1xudmFyIERFQlVHX1RSQUNJTkdfTU9ERV9OVU1CRVIgPSAweGVhZTE7XG52YXIgREVCVUdfVFJBQ0lOR19NT0RFX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmRlYnVnX3RyYWNlX21vZGUpJztcbnZhciBGT1JXQVJEX1JFRl9OVU1CRVIgPSAweGVhZDA7XG52YXIgRk9SV0FSRF9SRUZfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZm9yd2FyZF9yZWYpJztcbnZhciBGUkFHTUVOVF9OVU1CRVIgPSAweGVhY2I7XG52YXIgRlJBR01FTlRfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QuZnJhZ21lbnQpJztcbnZhciBMQVpZX05VTUJFUiA9IDB4ZWFkNDtcbnZhciBMQVpZX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LmxhenkpJztcbnZhciBNRU1PX05VTUJFUiA9IDB4ZWFkMztcbnZhciBNRU1PX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0Lm1lbW8pJztcbnZhciBPUEFRVUVfSURfTlVNQkVSID0gMHhlYWUwO1xudmFyIE9QQVFVRV9JRF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5vcGFxdWUuaWQpJztcbnZhciBQT1JUQUxfTlVNQkVSID0gMHhlYWNhO1xudmFyIFBPUlRBTF9TWU1CT0xfU1RSSU5HID0gJ1N5bWJvbChyZWFjdC5wb3J0YWwpJztcbnZhciBQUk9GSUxFUl9OVU1CRVIgPSAweGVhZDI7XG52YXIgUFJPRklMRVJfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QucHJvZmlsZXIpJztcbnZhciBQUk9WSURFUl9OVU1CRVIgPSAweGVhY2Q7XG52YXIgUFJPVklERVJfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3QucHJvdmlkZXIpJztcbnZhciBTQ09QRV9OVU1CRVIgPSAweGVhZDc7XG52YXIgU0NPUEVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc2NvcGUpJztcbnZhciBTVFJJQ1RfTU9ERV9OVU1CRVIgPSAweGVhY2M7XG52YXIgU1RSSUNUX01PREVfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc3RyaWN0X21vZGUpJztcbnZhciBTVVNQRU5TRV9OVU1CRVIgPSAweGVhZDE7XG52YXIgU1VTUEVOU0VfU1lNQk9MX1NUUklORyA9ICdTeW1ib2wocmVhY3Quc3VzcGVuc2UpJztcbnZhciBTVVNQRU5TRV9MSVNUX05VTUJFUiA9IDB4ZWFkODtcbnZhciBTVVNQRU5TRV9MSVNUX1NZTUJPTF9TVFJJTkcgPSAnU3ltYm9sKHJlYWN0LnN1c3BlbnNlX2xpc3QpJztcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvY29uZmlnL0RldlRvb2xzRmVhdHVyZUZsYWdzLmRlZmF1bHQuanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogVGhpcyBmaWxlIGlzIGZvcmtlZCBiZXR3ZWVuIGRpZmZlcmVudCBEZXZUb29scyBpbXBsZW1lbnRhdGlvbnMuXG4gKiBJdCBzaG91bGQgbmV2ZXIgYmUgaW1wb3J0ZWQgZGlyZWN0bHkhXG4gKiBJdCBzaG91bGQgYWx3YXlzIGJlIGltcG9ydGVkIGZyb20gXCJyZWFjdC1kZXZ0b29scy1mZWF0dXJlLWZsYWdzXCIuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIGVuYWJsZVByb2ZpbGVyQ2hhbmdlZEhvb2tJbmRpY2VzID0gZmFsc2U7XG52YXIgaXNJbnRlcm5hbEZhY2Vib29rQnVpbGQgPSBmYWxzZTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3NoYXJlZC9vYmplY3RJcy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gdHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc2hhcmVkX29iamVjdElzID0gKG9iamVjdElzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9yZW5kZXJlci5qc1xuZnVuY3Rpb24gcmVuZGVyZXJfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gcmVuZGVyZXJfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IHJlbmRlcmVyX293bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZW5kZXJlcl9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyByZW5kZXJlcl9vd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgcmVuZGVyZXJfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gcmVuZGVyZXJfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCByZW5kZXJlcl9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCByZW5kZXJlcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHJlbmRlcmVyX25vbkl0ZXJhYmxlU3ByZWFkKCk7IH1cblxuZnVuY3Rpb24gcmVuZGVyZXJfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gcmVuZGVyZXJfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSByZW5kZXJlcl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IHRocm93IF9lMjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXQucmV0dXJuICE9IG51bGwpIGl0LnJldHVybigpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIHJlbmRlcmVyX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gcmVuZGVyZXJfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIHJlbmRlcmVyX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiByZW5kZXJlcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IHJlbmRlcmVyX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyByZW5kZXJlcl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gcmVuZGVyZXJfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmZ1bmN0aW9uIGdldEZpYmVyRmxhZ3MoZmliZXIpIHtcbiAgLy8gVGhlIG5hbWUgb2YgdGhpcyBmaWVsZCBjaGFuZ2VkIGZyb20gXCJlZmZlY3RUYWdcIiB0byBcImZsYWdzXCJcbiAgcmV0dXJuIGZpYmVyLmZsYWdzICE9PSB1bmRlZmluZWQgPyBmaWJlci5mbGFncyA6IGZpYmVyLmVmZmVjdFRhZztcbn0gLy8gU29tZSBlbnZpcm9ubWVudHMgKGUuZy4gUmVhY3QgTmF0aXZlIC8gSGVybWVzKSBkb24ndCBzdXBwb3J0IHRoZSBwZXJmb3JtYW5jZSBBUEkgeWV0LlxuXG5cbnZhciByZW5kZXJlcl9nZXRDdXJyZW50VGltZSA9ICh0eXBlb2YgcGVyZm9ybWFuY2UgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogcmVuZGVyZXJfdHlwZW9mKHBlcmZvcm1hbmNlKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbicgPyBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbmZ1bmN0aW9uIGdldEludGVybmFsUmVhY3RDb25zdGFudHModmVyc2lvbikge1xuICB2YXIgUmVhY3RUeXBlT2ZTaWRlRWZmZWN0ID0ge1xuICAgIERpZENhcHR1cmU6IDEyOCxcbiAgICBOb0ZsYWdzOiAwLFxuICAgIFBlcmZvcm1lZFdvcms6IDEsXG4gICAgUGxhY2VtZW50OiAyLFxuICAgIEluY29tcGxldGU6IDgxOTJcbiAgfTsgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAvLyBUaGUgc2VjdGlvbiBiZWxvdyBpcyBjb3BpZWQgZnJvbSBmaWxlcyBpbiBSZWFjdCByZXBvLlxuICAvLyBLZWVwIGl0IGluIHN5bmMsIGFuZCBhZGQgdmVyc2lvbiBndWFyZHMgaWYgaXQgY2hhbmdlcy5cbiAgLy9cbiAgLy8gVGVjaG5pY2FsbHkgdGhlc2UgcHJpb3JpdHkgbGV2ZWxzIGFyZSBpbnZhbGlkIGZvciB2ZXJzaW9ucyBiZWZvcmUgMTYuOSxcbiAgLy8gYnV0IDE2LjkgaXMgdGhlIGZpcnN0IHZlcnNpb24gdG8gcmVwb3J0IHByaW9yaXR5IGxldmVsIHRvIERldlRvb2xzLFxuICAvLyBzbyB3ZSBjYW4gYXZvaWQgY2hlY2tpbmcgZm9yIGVhcmxpZXIgdmVyc2lvbnMgYW5kIHN1cHBvcnQgcHJlLTE2LjkgY2FuYXJ5IHJlbGVhc2VzIGluIHRoZSBwcm9jZXNzLlxuXG4gIHZhciBSZWFjdFByaW9yaXR5TGV2ZWxzID0ge1xuICAgIEltbWVkaWF0ZVByaW9yaXR5OiA5OSxcbiAgICBVc2VyQmxvY2tpbmdQcmlvcml0eTogOTgsXG4gICAgTm9ybWFsUHJpb3JpdHk6IDk3LFxuICAgIExvd1ByaW9yaXR5OiA5NixcbiAgICBJZGxlUHJpb3JpdHk6IDk1LFxuICAgIE5vUHJpb3JpdHk6IDkwXG4gIH07XG5cbiAgaWYgKE9iamVjdChzZW12ZXJbXCJndFwiXSkodmVyc2lvbiwgJzE3LjAuMicpKSB7XG4gICAgUmVhY3RQcmlvcml0eUxldmVscyA9IHtcbiAgICAgIEltbWVkaWF0ZVByaW9yaXR5OiAxLFxuICAgICAgVXNlckJsb2NraW5nUHJpb3JpdHk6IDIsXG4gICAgICBOb3JtYWxQcmlvcml0eTogMyxcbiAgICAgIExvd1ByaW9yaXR5OiA0LFxuICAgICAgSWRsZVByaW9yaXR5OiA1LFxuICAgICAgTm9Qcmlvcml0eTogMFxuICAgIH07XG4gIH1cblxuICB2YXIgUmVhY3RUeXBlT2ZXb3JrID0gbnVsbDsgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAvLyBUaGUgc2VjdGlvbiBiZWxvdyBpcyBjb3BpZWQgZnJvbSBmaWxlcyBpbiBSZWFjdCByZXBvLlxuICAvLyBLZWVwIGl0IGluIHN5bmMsIGFuZCBhZGQgdmVyc2lvbiBndWFyZHMgaWYgaXQgY2hhbmdlcy5cbiAgLy9cbiAgLy8gVE9ETyBVcGRhdGUgdGhlIGd0KCkgY2hlY2sgYmVsb3cgdG8gYmUgZ3RlKCkgd2hpY2hldmVyIHRoZSBuZXh0IHZlcnNpb24gbnVtYmVyIGlzLlxuICAvLyBDdXJyZW50bHkgdGhlIHZlcnNpb24gaW4gR2l0IGlzIDE3LjAuMiAoYnV0IHRoYXQgdmVyc2lvbiBoYXMgbm90IGJlZW4vbWF5IG5vdCBlbmQgdXAgYmVpbmcgcmVsZWFzZWQpLlxuXG4gIGlmIChPYmplY3Qoc2VtdmVyW1wiZ3RcIl0pKHZlcnNpb24sICcxNy4wLjEnKSkge1xuICAgIFJlYWN0VHlwZU9mV29yayA9IHtcbiAgICAgIENhY2hlQ29tcG9uZW50OiAyNCxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDEsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDksXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEwLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIENvcm91dGluZUhhbmRsZXJQaGFzZTogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IDE4LFxuICAgICAgLy8gQmVoaW5kIGEgZmxhZ1xuICAgICAgRm9yd2FyZFJlZjogMTEsXG4gICAgICBGcmFnbWVudDogNyxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAxNyxcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDIsXG4gICAgICBMYXp5Q29tcG9uZW50OiAxNixcbiAgICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudDogMjMsXG4gICAgICBNZW1vQ29tcG9uZW50OiAxNCxcbiAgICAgIE1vZGU6IDgsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IDIyLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBQcm9maWxlcjogMTIsXG4gICAgICBTY29wZUNvbXBvbmVudDogMjEsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xIC8vIFJlbW92ZWRcblxuICAgIH07XG4gIH0gZWxzZSBpZiAoT2JqZWN0KHNlbXZlcltcImd0ZVwiXSkodmVyc2lvbiwgJzE3LjAuMC1hbHBoYScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIENsYXNzQ29tcG9uZW50OiAxLFxuICAgICAgQ29udGV4dENvbnN1bWVyOiA5LFxuICAgICAgQ29udGV4dFByb3ZpZGVyOiAxMCxcbiAgICAgIENvcm91dGluZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBDb3JvdXRpbmVIYW5kbGVyUGhhc2U6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAxOCxcbiAgICAgIC8vIEJlaGluZCBhIGZsYWdcbiAgICAgIEZvcndhcmRSZWY6IDExLFxuICAgICAgRnJhZ21lbnQ6IDcsXG4gICAgICBGdW5jdGlvbkNvbXBvbmVudDogMCxcbiAgICAgIEhvc3RDb21wb25lbnQ6IDUsXG4gICAgICBIb3N0UG9ydGFsOiA0LFxuICAgICAgSG9zdFJvb3Q6IDMsXG4gICAgICBIb3N0VGV4dDogNixcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDogMTcsXG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAyLFxuICAgICAgTGF6eUNvbXBvbmVudDogMTYsXG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQ6IDI0LFxuICAgICAgTWVtb0NvbXBvbmVudDogMTQsXG4gICAgICBNb2RlOiA4LFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAyMyxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDEyLFxuICAgICAgU2NvcGVDb21wb25lbnQ6IDIxLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAxNSxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50OiAxMyxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudDogMTksXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFlpZWxkQ29tcG9uZW50OiAtMSAvLyBSZW1vdmVkXG5cbiAgICB9O1xuICB9IGVsc2UgaWYgKE9iamVjdChzZW12ZXJbXCJndGVcIl0pKHZlcnNpb24sICcxNi42LjAtYmV0YS4wJykpIHtcbiAgICBSZWFjdFR5cGVPZldvcmsgPSB7XG4gICAgICBDYWNoZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgQ2xhc3NDb21wb25lbnQ6IDEsXG4gICAgICBDb250ZXh0Q29uc3VtZXI6IDksXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEwLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIENvcm91dGluZUhhbmRsZXJQaGFzZTogLTEsXG4gICAgICAvLyBSZW1vdmVkXG4gICAgICBEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQ6IDE4LFxuICAgICAgLy8gQmVoaW5kIGEgZmxhZ1xuICAgICAgRm9yd2FyZFJlZjogMTEsXG4gICAgICBGcmFnbWVudDogNyxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAxNyxcbiAgICAgIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6IDIsXG4gICAgICBMYXp5Q29tcG9uZW50OiAxNixcbiAgICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudDogLTEsXG4gICAgICBNZW1vQ29tcG9uZW50OiAxNCxcbiAgICAgIE1vZGU6IDgsXG4gICAgICBPZmZzY3JlZW5Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBQcm9maWxlcjogMTIsXG4gICAgICBTY29wZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBFeHBlcmltZW50YWxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQ6IDE1LFxuICAgICAgU3VzcGVuc2VDb21wb25lbnQ6IDEzLFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50OiAxOSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgWWllbGRDb21wb25lbnQ6IC0xIC8vIFJlbW92ZWRcblxuICAgIH07XG4gIH0gZWxzZSBpZiAoT2JqZWN0KHNlbXZlcltcImd0ZVwiXSkodmVyc2lvbiwgJzE2LjQuMy1hbHBoYScpKSB7XG4gICAgUmVhY3RUeXBlT2ZXb3JrID0ge1xuICAgICAgQ2FjaGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIENsYXNzQ29tcG9uZW50OiAyLFxuICAgICAgQ29udGV4dENvbnN1bWVyOiAxMSxcbiAgICAgIENvbnRleHRQcm92aWRlcjogMTIsXG4gICAgICBDb3JvdXRpbmVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gUmVtb3ZlZFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiAtMSxcbiAgICAgIC8vIFJlbW92ZWRcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgRm9yd2FyZFJlZjogMTMsXG4gICAgICBGcmFnbWVudDogOSxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAwLFxuICAgICAgSG9zdENvbXBvbmVudDogNyxcbiAgICAgIEhvc3RQb3J0YWw6IDYsXG4gICAgICBIb3N0Um9vdDogNSxcbiAgICAgIEhvc3RUZXh0OiA4LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiA0LFxuICAgICAgTGF6eUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAtMSxcbiAgICAgIE1lbW9Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIE1vZGU6IDEwLFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDE1LFxuICAgICAgU2NvcGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBTdXNwZW5zZUNvbXBvbmVudDogMTYsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFlpZWxkQ29tcG9uZW50OiAtMSAvLyBSZW1vdmVkXG5cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIFJlYWN0VHlwZU9mV29yayA9IHtcbiAgICAgIENhY2hlQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBDbGFzc0NvbXBvbmVudDogMixcbiAgICAgIENvbnRleHRDb25zdW1lcjogMTIsXG4gICAgICBDb250ZXh0UHJvdmlkZXI6IDEzLFxuICAgICAgQ29yb3V0aW5lQ29tcG9uZW50OiA3LFxuICAgICAgQ29yb3V0aW5lSGFuZGxlclBoYXNlOiA4LFxuICAgICAgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBGb3J3YXJkUmVmOiAxNCxcbiAgICAgIEZyYWdtZW50OiAxMCxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50OiAxLFxuICAgICAgSG9zdENvbXBvbmVudDogNSxcbiAgICAgIEhvc3RQb3J0YWw6IDQsXG4gICAgICBIb3N0Um9vdDogMyxcbiAgICAgIEhvc3RUZXh0OiA2LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50OiAwLFxuICAgICAgTGF6eUNvbXBvbmVudDogLTEsXG4gICAgICAvLyBEb2Vzbid0IGV4aXN0IHlldFxuICAgICAgTGVnYWN5SGlkZGVuQ29tcG9uZW50OiAtMSxcbiAgICAgIE1lbW9Db21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIE1vZGU6IDExLFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIEV4cGVyaW1lbnRhbFxuICAgICAgUHJvZmlsZXI6IDE1LFxuICAgICAgU2NvcGVDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRXhwZXJpbWVudGFsXG4gICAgICBTaW1wbGVNZW1vQ29tcG9uZW50OiAtMSxcbiAgICAgIC8vIERvZXNuJ3QgZXhpc3QgeWV0XG4gICAgICBTdXNwZW5zZUNvbXBvbmVudDogMTYsXG4gICAgICBTdXNwZW5zZUxpc3RDb21wb25lbnQ6IC0xLFxuICAgICAgLy8gRG9lc24ndCBleGlzdCB5ZXRcbiAgICAgIFlpZWxkQ29tcG9uZW50OiA5XG4gICAgfTtcbiAgfSAvLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gIC8vIEVuZCBvZiBjb3BpZWQgY29kZS5cbiAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuXG5cbiAgZnVuY3Rpb24gZ2V0VHlwZVN5bWJvbCh0eXBlKSB7XG4gICAgdmFyIHN5bWJvbE9yTnVtYmVyID0gcmVuZGVyZXJfdHlwZW9mKHR5cGUpID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsID8gdHlwZS4kJHR5cGVvZiA6IHR5cGU7IC8vICRGbG93Rml4TWUgRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgdHlwZW9mIFwic3ltYm9sXCJcblxuICAgIHJldHVybiByZW5kZXJlcl90eXBlb2Yoc3ltYm9sT3JOdW1iZXIpID09PSAnc3ltYm9sJyA/IHN5bWJvbE9yTnVtYmVyLnRvU3RyaW5nKCkgOiBzeW1ib2xPck51bWJlcjtcbiAgfVxuXG4gIHZhciBfUmVhY3RUeXBlT2ZXb3JrID0gUmVhY3RUeXBlT2ZXb3JrLFxuICAgICAgQ2FjaGVDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkNhY2hlQ29tcG9uZW50LFxuICAgICAgQ2xhc3NDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50LFxuICAgICAgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5JbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQsXG4gICAgICBGdW5jdGlvbkNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuRnVuY3Rpb25Db21wb25lbnQsXG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5JbmRldGVybWluYXRlQ29tcG9uZW50LFxuICAgICAgRm9yd2FyZFJlZiA9IF9SZWFjdFR5cGVPZldvcmsuRm9yd2FyZFJlZixcbiAgICAgIEhvc3RSb290ID0gX1JlYWN0VHlwZU9mV29yay5Ib3N0Um9vdCxcbiAgICAgIEhvc3RDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQsXG4gICAgICBIb3N0UG9ydGFsID0gX1JlYWN0VHlwZU9mV29yay5Ib3N0UG9ydGFsLFxuICAgICAgSG9zdFRleHQgPSBfUmVhY3RUeXBlT2ZXb3JrLkhvc3RUZXh0LFxuICAgICAgRnJhZ21lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLkZyYWdtZW50LFxuICAgICAgTGF6eUNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuTGF6eUNvbXBvbmVudCxcbiAgICAgIExlZ2FjeUhpZGRlbkNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuTGVnYWN5SGlkZGVuQ29tcG9uZW50LFxuICAgICAgTWVtb0NvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuTWVtb0NvbXBvbmVudCxcbiAgICAgIE9mZnNjcmVlbkNvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuT2Zmc2NyZWVuQ29tcG9uZW50LFxuICAgICAgUHJvZmlsZXIgPSBfUmVhY3RUeXBlT2ZXb3JrLlByb2ZpbGVyLFxuICAgICAgU2NvcGVDb21wb25lbnQgPSBfUmVhY3RUeXBlT2ZXb3JrLlNjb3BlQ29tcG9uZW50LFxuICAgICAgU2ltcGxlTWVtb0NvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuU2ltcGxlTWVtb0NvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50ID0gX1JlYWN0VHlwZU9mV29yay5TdXNwZW5zZUNvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudCA9IF9SZWFjdFR5cGVPZldvcmsuU3VzcGVuc2VMaXN0Q29tcG9uZW50O1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVGaWJlclR5cGUodHlwZSkge1xuICAgIHZhciB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgIHN3aXRjaCAodHlwZVN5bWJvbCkge1xuICAgICAgY2FzZSBNRU1PX05VTUJFUjpcbiAgICAgIGNhc2UgTUVNT19TWU1CT0xfU1RSSU5HOlxuICAgICAgICAvLyByZWN1cnNpdmVseSByZXNvbHZpbmcgbWVtbyB0eXBlIGluIGNhc2Ugb2YgbWVtbyhmb3J3YXJkUmVmKENvbXBvbmVudCkpXG4gICAgICAgIHJldHVybiByZXNvbHZlRmliZXJUeXBlKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgRk9SV0FSRF9SRUZfTlVNQkVSOlxuICAgICAgY2FzZSBGT1JXQVJEX1JFRl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICByZXR1cm4gdHlwZS5yZW5kZXI7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfSAvLyBOT1RJQ0UgS2VlcCBpbiBzeW5jIHdpdGggc2hvdWxkRmlsdGVyRmliZXIoKSBhbmQgb3RoZXIgZ2V0KkZvckZpYmVyIG1ldGhvZHNcblxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBmaWJlci5lbGVtZW50VHlwZSxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGUsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZztcbiAgICB2YXIgcmVzb2x2ZWRUeXBlID0gdHlwZTtcblxuICAgIGlmIChyZW5kZXJlcl90eXBlb2YodHlwZSkgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGaWJlclR5cGUodHlwZSk7XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmVkQ29udGV4dCA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIGdldERpc3BsYXlOYW1lKHJlc29sdmVkVHlwZSk7XG5cbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBnZXREaXNwbGF5TmFtZShyZXNvbHZlZFR5cGUpO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIC8vIE1pcnJvciBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi83YzIxYmY3MmFjZTc3MDk0ZmQxOTEwY2MzNTBhNTQ4Mjg3ZWY4MzUwL3BhY2thZ2VzL3NoYXJlZC9nZXRDb21wb25lbnROYW1lLmpzI0wyNy1MMzdcbiAgICAgICAgcmV0dXJuIHR5cGUgJiYgdHlwZS5kaXNwbGF5TmFtZSB8fCBnZXREaXNwbGF5TmFtZShyZXNvbHZlZFR5cGUsICdBbm9ueW1vdXMnKTtcblxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgICAvLyBUaGlzIGRpc3BsYXkgbmFtZSB3aWxsIG5vdCBiZSB1c2VyIHZpc2libGUuXG4gICAgICAgIC8vIE9uY2UgYSBMYXp5IGNvbXBvbmVudCBsb2FkcyBpdHMgaW5uZXIgY29tcG9uZW50LCBSZWFjdCByZXBsYWNlcyB0aGUgdGFnIGFuZCB0eXBlLlxuICAgICAgICAvLyBUaGlzIGRpc3BsYXkgbmFtZSB3aWxsIG9ubHkgc2hvdyB1cCBpbiBjb25zb2xlIGxvZ3Mgd2hlbiBEZXZUb29scyBERUJVRyBtb2RlIGlzIG9uLlxuICAgICAgICByZXR1cm4gJ0xhenknO1xuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiBlbGVtZW50VHlwZSAmJiBlbGVtZW50VHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlICYmIHR5cGUuZGlzcGxheU5hbWUgfHwgZ2V0RGlzcGxheU5hbWUocmVzb2x2ZWRUeXBlLCAnQW5vbnltb3VzJyk7XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdMZWdhY3lIaWRkZW4nO1xuXG4gICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuICdPZmZzY3JlZW4nO1xuXG4gICAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gJ1Njb3BlJztcblxuICAgICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgICAgICBjYXNlIENPTkNVUlJFTlRfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICBjYXNlIERFUFJFQ0FURURfQVNZTkNfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICBjYXNlIFBST1ZJREVSX05VTUJFUjpcbiAgICAgICAgICBjYXNlIFBST1ZJREVSX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICAvLyAxNi4zLjAgZXhwb3NlZCB0aGUgY29udGV4dCBvYmplY3QgYXMgXCJjb250ZXh0XCJcbiAgICAgICAgICAgIC8vIFBSICMxMjUwMSBjaGFuZ2VkIGl0IHRvIFwiX2NvbnRleHRcIiBmb3IgMTYuMy4xK1xuICAgICAgICAgICAgLy8gTk9URSBLZWVwIGluIHN5bmMgd2l0aCBpbnNwZWN0RWxlbWVudFJhdygpXG4gICAgICAgICAgICByZXNvbHZlZENvbnRleHQgPSBmaWJlci50eXBlLl9jb250ZXh0IHx8IGZpYmVyLnR5cGUuY29udGV4dDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZXNvbHZlZENvbnRleHQuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnLCBcIi5Qcm92aWRlclwiKTtcblxuICAgICAgICAgIGNhc2UgQ09OVEVYVF9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBDT05URVhUX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICAvLyAxNi4zLTE2LjUgcmVhZCBmcm9tIFwidHlwZVwiIGJlY2F1c2UgdGhlIENvbnN1bWVyIGlzIHRoZSBhY3R1YWwgY29udGV4dCBvYmplY3QuXG4gICAgICAgICAgICAvLyAxNi42KyBzaG91bGQgcmVhZCBmcm9tIFwidHlwZS5fY29udGV4dFwiIGJlY2F1c2UgQ29uc3VtZXIgY2FuIGJlIGRpZmZlcmVudCAoaW4gREVWKS5cbiAgICAgICAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggaW5zcGVjdEVsZW1lbnRSYXcoKVxuICAgICAgICAgICAgcmVzb2x2ZWRDb250ZXh0ID0gZmliZXIudHlwZS5fY29udGV4dCB8fCBmaWJlci50eXBlOyAvLyBOT1RFOiBUcmFjZVVwZGF0ZXNCYWNrZW5kTWFuYWdlciBkZXBlbmRzIG9uIHRoZSBuYW1lIGVuZGluZyBpbiAnLkNvbnN1bWVyJ1xuICAgICAgICAgICAgLy8gSWYgeW91IGNoYW5nZSB0aGUgbmFtZSwgZmlndXJlIG91dCBhIG1vcmUgcmVzaWxpZW50IHdheSB0byBkZXRlY3QgaXQuXG5cbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChyZXNvbHZlZENvbnRleHQuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnLCBcIi5Db25zdW1lclwiKTtcblxuICAgICAgICAgIGNhc2UgU1RSSUNUX01PREVfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgU1RSSUNUX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBQUk9GSUxFUl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXIoXCIuY29uY2F0KGZpYmVyLm1lbW9pemVkUHJvcHMuaWQsIFwiKVwiKTtcblxuICAgICAgICAgIGNhc2UgU0NPUEVfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgU0NPUEVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiAnU2NvcGUnO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIC8vIFVua25vd24gZWxlbWVudCB0eXBlLlxuICAgICAgICAgICAgLy8gVGhpcyBtYXkgbWVhbiBhIG5ldyBlbGVtZW50IHR5cGUgdGhhdCBoYXMgbm90IHlldCBiZWVuIGFkZGVkIHRvIERldlRvb2xzLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlcjogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcixcbiAgICBnZXRUeXBlU3ltYm9sOiBnZXRUeXBlU3ltYm9sLFxuICAgIFJlYWN0UHJpb3JpdHlMZXZlbHM6IFJlYWN0UHJpb3JpdHlMZXZlbHMsXG4gICAgUmVhY3RUeXBlT2ZXb3JrOiBSZWFjdFR5cGVPZldvcmssXG4gICAgUmVhY3RUeXBlT2ZTaWRlRWZmZWN0OiBSZWFjdFR5cGVPZlNpZGVFZmZlY3RcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcmVyX2F0dGFjaChob29rLCByZW5kZXJlcklELCByZW5kZXJlciwgZ2xvYmFsKSB7XG4gIC8vIE5ld2VyIHZlcnNpb25zIG9mIHRoZSByZWNvbmNpbGVyIHBhY2thZ2UgYWxzbyBzcGVjaWZpYyByZWNvbmNpbGVyIHZlcnNpb24uXG4gIC8vIElmIHRoYXQgdmVyc2lvbiBudW1iZXIgaXMgcHJlc2VudCwgdXNlIGl0LlxuICAvLyBUaGlyZCBwYXJ0eSByZW5kZXJlciB2ZXJzaW9ucyBtYXkgbm90IG1hdGNoIHRoZSByZWNvbmNpbGVyIHZlcnNpb24sXG4gIC8vIGFuZCB0aGUgbGF0dGVyIGlzIHdoYXQncyBpbXBvcnRhbnQgaW4gdGVybXMgb2YgdGFncyBhbmQgc3ltYm9scy5cbiAgdmFyIHZlcnNpb24gPSByZW5kZXJlci5yZWNvbmNpbGVyVmVyc2lvbiB8fCByZW5kZXJlci52ZXJzaW9uO1xuXG4gIHZhciBfZ2V0SW50ZXJuYWxSZWFjdENvbnMgPSBnZXRJbnRlcm5hbFJlYWN0Q29uc3RhbnRzKHZlcnNpb24pLFxuICAgICAgZ2V0RGlzcGxheU5hbWVGb3JGaWJlciA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5nZXREaXNwbGF5TmFtZUZvckZpYmVyLFxuICAgICAgZ2V0VHlwZVN5bWJvbCA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5nZXRUeXBlU3ltYm9sLFxuICAgICAgUmVhY3RQcmlvcml0eUxldmVscyA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5SZWFjdFByaW9yaXR5TGV2ZWxzLFxuICAgICAgUmVhY3RUeXBlT2ZXb3JrID0gX2dldEludGVybmFsUmVhY3RDb25zLlJlYWN0VHlwZU9mV29yayxcbiAgICAgIFJlYWN0VHlwZU9mU2lkZUVmZmVjdCA9IF9nZXRJbnRlcm5hbFJlYWN0Q29ucy5SZWFjdFR5cGVPZlNpZGVFZmZlY3Q7XG5cbiAgdmFyIERpZENhcHR1cmUgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuRGlkQ2FwdHVyZSxcbiAgICAgIEluY29tcGxldGUgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuSW5jb21wbGV0ZSxcbiAgICAgIE5vRmxhZ3MgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuTm9GbGFncyxcbiAgICAgIFBlcmZvcm1lZFdvcmsgPSBSZWFjdFR5cGVPZlNpZGVFZmZlY3QuUGVyZm9ybWVkV29yayxcbiAgICAgIFBsYWNlbWVudCA9IFJlYWN0VHlwZU9mU2lkZUVmZmVjdC5QbGFjZW1lbnQ7XG4gIHZhciBDYWNoZUNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5DYWNoZUNvbXBvbmVudCxcbiAgICAgIENsYXNzQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkNsYXNzQ29tcG9uZW50LFxuICAgICAgQ29udGV4dENvbnN1bWVyID0gUmVhY3RUeXBlT2ZXb3JrLkNvbnRleHRDb25zdW1lcixcbiAgICAgIERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5EZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQsXG4gICAgICBGb3J3YXJkUmVmID0gUmVhY3RUeXBlT2ZXb3JrLkZvcndhcmRSZWYsXG4gICAgICBGcmFnbWVudCA9IFJlYWN0VHlwZU9mV29yay5GcmFnbWVudCxcbiAgICAgIEZ1bmN0aW9uQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkZ1bmN0aW9uQ29tcG9uZW50LFxuICAgICAgSG9zdFJvb3QgPSBSZWFjdFR5cGVPZldvcmsuSG9zdFJvb3QsXG4gICAgICBIb3N0UG9ydGFsID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RQb3J0YWwsXG4gICAgICBIb3N0Q29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkhvc3RDb21wb25lbnQsXG4gICAgICBIb3N0VGV4dCA9IFJlYWN0VHlwZU9mV29yay5Ib3N0VGV4dCxcbiAgICAgIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5JbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQsXG4gICAgICBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLkluZGV0ZXJtaW5hdGVDb21wb25lbnQsXG4gICAgICBMZWdhY3lIaWRkZW5Db21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuTGVnYWN5SGlkZGVuQ29tcG9uZW50LFxuICAgICAgTWVtb0NvbXBvbmVudCA9IFJlYWN0VHlwZU9mV29yay5NZW1vQ29tcG9uZW50LFxuICAgICAgT2Zmc2NyZWVuQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLk9mZnNjcmVlbkNvbXBvbmVudCxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQgPSBSZWFjdFR5cGVPZldvcmsuU2ltcGxlTWVtb0NvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlQ29tcG9uZW50LFxuICAgICAgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gUmVhY3RUeXBlT2ZXb3JrLlN1c3BlbnNlTGlzdENvbXBvbmVudDtcbiAgdmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5JbW1lZGlhdGVQcmlvcml0eSxcbiAgICAgIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5Vc2VyQmxvY2tpbmdQcmlvcml0eSxcbiAgICAgIE5vcm1hbFByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5Ob3JtYWxQcmlvcml0eSxcbiAgICAgIExvd1ByaW9yaXR5ID0gUmVhY3RQcmlvcml0eUxldmVscy5Mb3dQcmlvcml0eSxcbiAgICAgIElkbGVQcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuSWRsZVByaW9yaXR5LFxuICAgICAgTm9Qcmlvcml0eSA9IFJlYWN0UHJpb3JpdHlMZXZlbHMuTm9Qcmlvcml0eTtcbiAgdmFyIG92ZXJyaWRlSG9va1N0YXRlID0gcmVuZGVyZXIub3ZlcnJpZGVIb29rU3RhdGUsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGggPSByZW5kZXJlci5vdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSByZW5kZXJlci5vdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgsXG4gICAgICBvdmVycmlkZVByb3BzID0gcmVuZGVyZXIub3ZlcnJpZGVQcm9wcyxcbiAgICAgIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gcmVuZGVyZXIub3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IHJlbmRlcmVyLm92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoLFxuICAgICAgc2NoZWR1bGVSZWZyZXNoID0gcmVuZGVyZXIuc2NoZWR1bGVSZWZyZXNoLFxuICAgICAgc2V0RXJyb3JIYW5kbGVyID0gcmVuZGVyZXIuc2V0RXJyb3JIYW5kbGVyLFxuICAgICAgc2V0U3VzcGVuc2VIYW5kbGVyID0gcmVuZGVyZXIuc2V0U3VzcGVuc2VIYW5kbGVyLFxuICAgICAgc2NoZWR1bGVVcGRhdGUgPSByZW5kZXJlci5zY2hlZHVsZVVwZGF0ZTtcbiAgdmFyIHN1cHBvcnRzVG9nZ2xpbmdFcnJvciA9IHR5cGVvZiBzZXRFcnJvckhhbmRsZXIgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHNjaGVkdWxlVXBkYXRlID09PSAnZnVuY3Rpb24nO1xuICB2YXIgc3VwcG9ydHNUb2dnbGluZ1N1c3BlbnNlID0gdHlwZW9mIHNldFN1c3BlbnNlSGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygc2NoZWR1bGVVcGRhdGUgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKHR5cGVvZiBzY2hlZHVsZVJlZnJlc2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBXaGVuIEZhc3QgUmVmcmVzaCB1cGRhdGVzIGEgY29tcG9uZW50LCB0aGUgZnJvbnRlbmQgbWF5IG5lZWQgdG8gcHVyZ2UgY2FjaGVkIGluZm9ybWF0aW9uLlxuICAgIC8vIEZvciBleGFtcGxlLCBBU1RzIGNhY2hlZCBmb3IgdGhlIGNvbXBvbmVudCAoZm9yIG5hbWVkIGhvb2tzKSBtYXkgbm8gbG9uZ2VyIGJlIHZhbGlkLlxuICAgIC8vIFNlbmQgYSBzaWduYWwgdG8gdGhlIGZyb250ZW5kIHRvIHB1cmdlIHRoaXMgY2FjaGVkIGluZm9ybWF0aW9uLlxuICAgIC8vIFRoZSBcImZhc3RSZWZyZXNoU2NoZWR1bGVkXCIgZGlzcGF0Y2hlZCBpcyBnbG9iYWwgKG5vdCBGaWJlciBvciBldmVuIFJlbmRlcmVyIHNwZWNpZmljKS5cbiAgICAvLyBUaGlzIGlzIGxlc3MgZWZmZWNpZW50IHNpbmNlIGl0IG1lYW5zIHRoZSBmcm9udC1lbmQgd2lsbCBuZWVkIHRvIHB1cmdlIHRoZSBlbnRpcmUgY2FjaGUsXG4gICAgLy8gYnV0IHRoaXMgaXMgcHJvYmFibHkgYW4gb2theSB0cmFkZSBvZmYgaW4gb3JkZXIgdG8gcmVkdWNlIGNvdXBsaW5nIGJldHdlZW4gdGhlIERldlRvb2xzIGFuZCBGYXN0IFJlZnJlc2guXG4gICAgcmVuZGVyZXIuc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaG9vay5lbWl0KCdmYXN0UmVmcmVzaFNjaGVkdWxlZCcpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmV0dXJuIHNjaGVkdWxlUmVmcmVzaC5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSAvLyBUcmFja3MgRmliZXJzIHdpdGggcmVjZW50bHkgY2hhbmdlZCBudW1iZXIgb2YgZXJyb3Ivd2FybmluZyBtZXNzYWdlcy5cbiAgLy8gVGhlc2UgY29sbGVjdGlvbnMgc3RvcmUgdGhlIEZpYmVyIHJhdGhlciB0aGFuIHRoZSBJRCxcbiAgLy8gaW4gb3JkZXIgdG8gYXZvaWQgZ2VuZXJhdGluZyBhbiBJRCBmb3IgRmliZXJzIHRoYXQgbmV2ZXIgZ2V0IG1vdW50ZWRcbiAgLy8gKGR1ZSB0byBlLmcuIFN1c3BlbnNlIG9yIGVycm9yIGJvdW5kYXJpZXMpLlxuICAvLyBvbkVycm9yT3JXYXJuaW5nKCkgYWRkcyBGaWJlcnMgYW5kIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpIGxhdGVyIGNsZWFycyB0aGVtLlxuXG5cbiAgdmFyIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMgPSBuZXcgU2V0KCk7XG4gIHZhciBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHBlbmRpbmdGaWJlclRvV2FybmluZ3NNYXAgPSBuZXcgTWFwKCk7IC8vIE1hcHBpbmcgb2YgZmliZXIgSURzIHRvIGVycm9yL3dhcm5pbmcgbWVzc2FnZXMgYW5kIGNvdW50cy5cblxuICB2YXIgZmliZXJJRFRvRXJyb3JzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgZmliZXJJRFRvV2FybmluZ3NNYXAgPSBuZXcgTWFwKCk7XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIHZhciBfaXRlcmF0b3IgPSByZW5kZXJlcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpYmVySURUb0Vycm9yc01hcC5rZXlzKCkpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgaWQgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICB2YXIgX2ZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICAgICAgaWYgKF9maWJlciAhPSBudWxsKSB7XG4gICAgICAgICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5hZGQoX2ZpYmVyKTtcbiAgICAgICAgICB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoaWQpO1xuICAgICAgICB9XG4gICAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG5cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgdmFyIF9pdGVyYXRvcjIgPSByZW5kZXJlcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGZpYmVySURUb1dhcm5pbmdzTWFwLmtleXMoKSksXG4gICAgICAgIF9zdGVwMjtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICB2YXIgX2lkID0gX3N0ZXAyLnZhbHVlO1xuXG4gICAgICAgIHZhciBfZmliZXIyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChfaWQpO1xuXG4gICAgICAgIGlmIChfZmliZXIyICE9IG51bGwpIHtcbiAgICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChfZmliZXIyKTtcbiAgICAgICAgICB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoX2lkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgIH1cblxuICAgIGZpYmVySURUb0Vycm9yc01hcC5jbGVhcigpO1xuICAgIGZpYmVySURUb1dhcm5pbmdzTWFwLmNsZWFyKCk7XG4gICAgZmx1c2hQZW5kaW5nRXZlbnRzKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhck1lc3NhZ2VDb3VudEhlbHBlcihmaWJlcklELCBwZW5kaW5nRmliZXJUb01lc3NhZ2VDb3VudE1hcCwgZmliZXJJRFRvTWVzc2FnZUNvdW50TWFwKSB7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChmaWJlcklEKTtcblxuICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAvLyBUaHJvdyBvdXQgYW55IHBlbmRpbmcgY2hhbmdlcy5cbiAgICAgIHBlbmRpbmdGaWJlclRvRXJyb3JzTWFwLmRlbGV0ZShmaWJlcik7XG5cbiAgICAgIGlmIChmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuaGFzKGZpYmVySUQpKSB7XG4gICAgICAgIGZpYmVySURUb01lc3NhZ2VDb3VudE1hcC5kZWxldGUoZmliZXJJRCk7IC8vIElmIHByZXZpb3VzIGZsdXNoZWQgY291bnRzIGhhdmUgY2hhbmdlZCwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvby5cblxuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmFkZChmaWJlcik7XG4gICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cygpO1xuICAgICAgICB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoZmliZXJJRCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaWJlcnNXaXRoQ2hhbmdlZEVycm9yT3JXYXJuaW5nQ291bnRzLmRlbGV0ZShmaWJlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnNGb3JGaWJlcklEKGZpYmVySUQpIHtcbiAgICBjbGVhck1lc3NhZ2VDb3VudEhlbHBlcihmaWJlcklELCBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCwgZmliZXJJRFRvRXJyb3JzTWFwKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyV2FybmluZ3NGb3JGaWJlcklEKGZpYmVySUQpIHtcbiAgICBjbGVhck1lc3NhZ2VDb3VudEhlbHBlcihmaWJlcklELCBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwLCBmaWJlcklEVG9XYXJuaW5nc01hcCk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50SWZOZWNlc3NhcnkoZmliZXJJRCkge1xuICAgIGlmIChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQuaWQgPT09IGZpYmVySUQpIHtcbiAgICAgIGhhc0VsZW1lbnRVcGRhdGVkU2luY2VMYXN0SW5zcGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gLy8gQ2FsbGVkIHdoZW4gYW4gZXJyb3Igb3Igd2FybmluZyBpcyBsb2dnZWQgZHVyaW5nIHJlbmRlciwgY29tbWl0LCBvciBwYXNzaXZlIChpbmNsdWRpbmcgdW5tb3VudCBmdW5jdGlvbnMpLlxuXG5cbiAgZnVuY3Rpb24gb25FcnJvck9yV2FybmluZyhmaWJlciwgdHlwZSwgYXJncykge1xuICAgIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgICB2YXIgbWF5YmVJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpOyAvLyBpZiB0aGlzIGlzIGFuIGVycm9yIHNpbXVsYXRlZCBieSB1cyB0byB0cmlnZ2VyIGVycm9yIGJvdW5kYXJ5LCBpZ25vcmVcblxuICAgICAgaWYgKG1heWJlSUQgIT0gbnVsbCAmJiBmb3JjZUVycm9yRm9yRmliZXJJRHMuZ2V0KG1heWJlSUQpID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbWVzc2FnZSA9IGZvcm1hdC5hcHBseSh2b2lkIDAsIHJlbmRlcmVyX3RvQ29uc3VtYWJsZUFycmF5KGFyZ3MpKTtcblxuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdvbkVycm9yT3JXYXJuaW5nJywgZmliZXIsIG51bGwsIFwiXCIuY29uY2F0KHR5cGUsIFwiOiBcXFwiXCIpLmNvbmNhdChtZXNzYWdlLCBcIlxcXCJcIikpO1xuICAgIH0gLy8gTWFyayB0aGlzIEZpYmVyIGFzIG5lZWRlZCBpdHMgd2FybmluZy9lcnJvciBjb3VudCB1cGRhdGVkIGR1cmluZyB0aGUgbmV4dCBmbHVzaC5cblxuXG4gICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5hZGQoZmliZXIpOyAvLyBUcmFjayB0aGUgd2FybmluZy9lcnJvciBmb3IgbGF0ZXIuXG5cbiAgICB2YXIgZmliZXJNYXAgPSB0eXBlID09PSAnZXJyb3InID8gcGVuZGluZ0ZpYmVyVG9FcnJvcnNNYXAgOiBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwO1xuICAgIHZhciBtZXNzYWdlTWFwID0gZmliZXJNYXAuZ2V0KGZpYmVyKTtcblxuICAgIGlmIChtZXNzYWdlTWFwICE9IG51bGwpIHtcbiAgICAgIHZhciBjb3VudCA9IG1lc3NhZ2VNYXAuZ2V0KG1lc3NhZ2UpIHx8IDA7XG4gICAgICBtZXNzYWdlTWFwLnNldChtZXNzYWdlLCBjb3VudCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWJlck1hcC5zZXQoZmliZXIsIG5ldyBNYXAoW1ttZXNzYWdlLCAxXV0pKTtcbiAgICB9IC8vIFBhc3NpdmUgZWZmZWN0cyBtYXkgdHJpZ2dlciBlcnJvcnMgb3Igd2FybmluZ3MgdG9vO1xuICAgIC8vIEluIHRoaXMgY2FzZSwgd2Ugc2hvdWxkIHdhaXQgdW50aWwgdGhlIHJlc3Qgb2YgdGhlIHBhc3NpdmUgZWZmZWN0cyBoYXZlIHJ1bixcbiAgICAvLyBidXQgd2Ugc2hvdWxkbid0IHdhaXQgdW50aWwgdGhlIG5leHQgY29tbWl0IGJlY2F1c2UgdGhhdCBtaWdodCBiZSBhIGxvbmcgdGltZS5cbiAgICAvLyBUaGlzIHdvdWxkIGFsc28gY2F1c2UgXCJ0ZWFyaW5nXCIgYmV0d2VlbiBhbiBpbnNwZWN0ZWQgQ29tcG9uZW50IGFuZCB0aGUgdHJlZSB2aWV3LlxuICAgIC8vIFRoZW4gYWdhaW4gd2UgZG9uJ3Qgd2FudCB0byBmbHVzaCB0b28gc29vbiBiZWNhdXNlIHRoaXMgY291bGQgYmUgYW4gZXJyb3IgZHVyaW5nIGFzeW5jIHJlbmRlcmluZy5cbiAgICAvLyBVc2UgYSBkZWJvdW5jZSB0ZWNobmlxdWUgdG8gZW5zdXJlIHRoYXQgd2UnbGwgZXZlbnR1YWxseSBmbHVzaC5cblxuXG4gICAgZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCk7XG4gIH0gLy8gUGF0Y2hpbmcgdGhlIGNvbnNvbGUgZW5hYmxlcyBEZXZUb29scyB0byBkbyBhIGZldyB1c2VmdWwgdGhpbmdzOlxuICAvLyAqIEFwcGVuZCBjb21wb25lbnQgc3RhY2tzIHRvIHdhcm5pbmdzIGFuZCBlcnJvciBtZXNzYWdlc1xuICAvLyAqIERpc2FibGUgbG9nZ2luZyBkdXJpbmcgcmUtcmVuZGVycyB0byBpbnNwZWN0IGhvb2tzIChzZWUgaW5zcGVjdEhvb2tzT2ZGaWJlcilcbiAgLy9cbiAgLy8gRG9uJ3QgcGF0Y2ggaW4gdGVzdCBlbnZpcm9ubWVudHMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGludGVyZmVyZSB3aXRoIEplc3QncyBvd24gY29uc29sZSBvdmVycmlkZXMuXG5cblxuICBpZiAodHJ1ZSkge1xuICAgIHJlZ2lzdGVyUmVuZGVyZXIocmVuZGVyZXIsIG9uRXJyb3JPcldhcm5pbmcpOyAvLyBUaGUgcmVuZGVyZXIgaW50ZXJmYWNlIGNhbid0IHJlYWQgdGhlc2UgcHJlZmVyZW5jZXMgZGlyZWN0bHksXG4gICAgLy8gYmVjYXVzZSBpdCBpcyBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZXh0ZW5zaW9uLlxuICAgIC8vIEl0IHJlbGllcyBvbiB0aGUgZXh0ZW5zaW9uIHRvIHBhc3MgdGhlIHByZWZlcmVuY2UgdGhyb3VnaCB2aWEgdGhlIGdsb2JhbC5cblxuICAgIHZhciBhcHBlbmRDb21wb25lbnRTdGFjayA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0FQUEVORF9DT01QT05FTlRfU1RBQ0tfXyAhPT0gZmFsc2U7XG4gICAgdmFyIGJyZWFrT25Db25zb2xlRXJyb3JzID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQlJFQUtfT05fQ09OU09MRV9FUlJPUlNfXyA9PT0gdHJ1ZTtcbiAgICB2YXIgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfU0hPV19JTkxJTkVfV0FSTklOR1NfQU5EX0VSUk9SU19fICE9PSBmYWxzZTtcblxuICAgIGlmIChhcHBlbmRDb21wb25lbnRTdGFjayB8fCBicmVha09uQ29uc29sZUVycm9ycyB8fCBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMpIHtcbiAgICAgIHBhdGNoKHtcbiAgICAgICAgYXBwZW5kQ29tcG9uZW50U3RhY2s6IGFwcGVuZENvbXBvbmVudFN0YWNrLFxuICAgICAgICBicmVha09uQ29uc29sZUVycm9yczogYnJlYWtPbkNvbnNvbGVFcnJvcnMsXG4gICAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9yczogc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZyhuYW1lLCBmaWJlciwgcGFyZW50RmliZXIpIHtcbiAgICB2YXIgZXh0cmFTdHJpbmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6ICcnO1xuXG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gZmliZXIudGFnICsgJzonICsgKGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICdudWxsJyk7XG4gICAgICB2YXIgbWF5YmVJRCA9IGdldEZpYmVySURVbnNhZmUoZmliZXIpIHx8ICc8bm8gaWQ+JztcbiAgICAgIHZhciBwYXJlbnREaXNwbGF5TmFtZSA9IHBhcmVudEZpYmVyID8gcGFyZW50RmliZXIudGFnICsgJzonICsgKGdldERpc3BsYXlOYW1lRm9yRmliZXIocGFyZW50RmliZXIpIHx8ICdudWxsJykgOiAnJztcbiAgICAgIHZhciBtYXliZVBhcmVudElEID0gcGFyZW50RmliZXIgPyBnZXRGaWJlcklEVW5zYWZlKHBhcmVudEZpYmVyKSB8fCAnPG5vLWlkPicgOiAnJztcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJbcmVuZGVyZXJdICVjXCIuY29uY2F0KG5hbWUsIFwiICVjXCIpLmNvbmNhdChkaXNwbGF5TmFtZSwgXCIgKFwiKS5jb25jYXQobWF5YmVJRCwgXCIpICVjXCIpLmNvbmNhdChwYXJlbnRGaWJlciA/IFwiXCIuY29uY2F0KHBhcmVudERpc3BsYXlOYW1lLCBcIiAoXCIpLmNvbmNhdChtYXliZVBhcmVudElELCBcIilcIikgOiAnJywgXCIgJWNcIikuY29uY2F0KGV4dHJhU3RyaW5nKSwgJ2NvbG9yOiByZWQ7IGZvbnQtd2VpZ2h0OiBib2xkOycsICdjb2xvcjogYmx1ZTsnLCAnY29sb3I6IHB1cnBsZTsnLCAnY29sb3I6IGJsYWNrOycpO1xuICAgICAgY29uc29sZS5sb2cobmV3IEVycm9yKCkuc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKDEpLmpvaW4oJ1xcbicpKTtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gIH07IC8vIENvbmZpZ3VyYWJsZSBDb21wb25lbnRzIHRyZWUgZmlsdGVycy5cblxuXG4gIHZhciBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzID0gbmV3IFNldCgpO1xuICB2YXIgaGlkZUVsZW1lbnRzV2l0aFBhdGhzID0gbmV3IFNldCgpO1xuICB2YXIgaGlkZUVsZW1lbnRzV2l0aFR5cGVzID0gbmV3IFNldCgpOyAvLyBIaWdobGlnaHQgdXBkYXRlc1xuXG4gIHZhciB0cmFjZVVwZGF0ZXNFbmFibGVkID0gZmFsc2U7XG4gIHZhciB0cmFjZVVwZGF0ZXNGb3JOb2RlcyA9IG5ldyBTZXQoKTtcblxuICBmdW5jdGlvbiBhcHBseUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycykge1xuICAgIGhpZGVFbGVtZW50c1dpdGhUeXBlcy5jbGVhcigpO1xuICAgIGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMuY2xlYXIoKTtcbiAgICBoaWRlRWxlbWVudHNXaXRoUGF0aHMuY2xlYXIoKTtcbiAgICBjb21wb25lbnRGaWx0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGNvbXBvbmVudEZpbHRlcikge1xuICAgICAgaWYgKCFjb21wb25lbnRGaWx0ZXIuaXNFbmFibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjb21wb25lbnRGaWx0ZXIudHlwZSkge1xuICAgICAgICBjYXNlIENvbXBvbmVudEZpbHRlckRpc3BsYXlOYW1lOlxuICAgICAgICAgIGlmIChjb21wb25lbnRGaWx0ZXIuaXNWYWxpZCAmJiBjb21wb25lbnRGaWx0ZXIudmFsdWUgIT09ICcnKSB7XG4gICAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoRGlzcGxheU5hbWVzLmFkZChuZXcgUmVnRXhwKGNvbXBvbmVudEZpbHRlci52YWx1ZSwgJ2knKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb21wb25lbnRGaWx0ZXJFbGVtZW50VHlwZTpcbiAgICAgICAgICBoaWRlRWxlbWVudHNXaXRoVHlwZXMuYWRkKGNvbXBvbmVudEZpbHRlci52YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb21wb25lbnRGaWx0ZXJMb2NhdGlvbjpcbiAgICAgICAgICBpZiAoY29tcG9uZW50RmlsdGVyLmlzVmFsaWQgJiYgY29tcG9uZW50RmlsdGVyLnZhbHVlICE9PSAnJykge1xuICAgICAgICAgICAgaGlkZUVsZW1lbnRzV2l0aFBhdGhzLmFkZChuZXcgUmVnRXhwKGNvbXBvbmVudEZpbHRlci52YWx1ZSwgJ2knKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDb21wb25lbnRGaWx0ZXJIT0M6XG4gICAgICAgICAgaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcy5hZGQobmV3IFJlZ0V4cCgnXFxcXCgnKSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIGNvbXBvbmVudCBmaWx0ZXIgdHlwZSBcXFwiXCIuY29uY2F0KGNvbXBvbmVudEZpbHRlci50eXBlLCBcIlxcXCJcIikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuICB9IC8vIFRoZSByZW5kZXJlciBpbnRlcmZhY2UgY2FuJ3QgcmVhZCBzYXZlZCBjb21wb25lbnQgZmlsdGVycyBkaXJlY3RseSxcbiAgLy8gYmVjYXVzZSB0aGV5IGFyZSBzdG9yZWQgaW4gbG9jYWxTdG9yYWdlIHdpdGhpbiB0aGUgY29udGV4dCBvZiB0aGUgZXh0ZW5zaW9uLlxuICAvLyBJbnN0ZWFkIGl0IHJlbGllcyBvbiB0aGUgZXh0ZW5zaW9uIHRvIHBhc3MgZmlsdGVycyB0aHJvdWdoLlxuXG5cbiAgaWYgKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTVBPTkVOVF9GSUxURVJTX18gIT0gbnVsbCkge1xuICAgIGFwcGx5Q29tcG9uZW50RmlsdGVycyh3aW5kb3cuX19SRUFDVF9ERVZUT09MU19DT01QT05FTlRfRklMVEVSU19fKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5IHRoaXMgZmVhdHVyZSBpcyBub3QgZXhwZWN0ZWQgdG8gd29yayBmb3IgUmVhY3QgTmF0aXZlIGZvciBub3cuXG4gICAgLy8gSXQgd291bGQgYmUgYW5ub3lpbmcgZm9yIHVzIHRvIHNwYW0gWWVsbG93Qm94IHdhcm5pbmdzIHdpdGggdW5hY3Rpb25hYmxlIHN0dWZmLFxuICAgIC8vIHNvIGZvciBub3cganVzdCBza2lwIHRoaXMgbWVzc2FnZS4uLlxuICAgIC8vY29uc29sZS53YXJuKCfimpvvuI8gRGV2VG9vbHM6IENvdWxkIG5vdCBsb2NhdGUgc2F2ZWQgY29tcG9uZW50IGZpbHRlcnMnKTtcbiAgICAvLyBGYWxsYmFjayB0byBhc3N1bWluZyB0aGUgZGVmYXVsdCBmaWx0ZXJzIGluIHRoaXMgY2FzZS5cbiAgICBhcHBseUNvbXBvbmVudEZpbHRlcnMoZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMoKSk7XG4gIH0gLy8gSWYgbmVjZXNzYXJ5LCB3ZSBjYW4gcmV2aXNpdCBvcHRpbWl6aW5nIHRoaXMgb3BlcmF0aW9uLlxuICAvLyBGb3IgZXhhbXBsZSwgd2UgY291bGQgYWRkIGEgbmV3IHJlY3Vyc2l2ZSB1bm1vdW50IHRyZWUgb3BlcmF0aW9uLlxuICAvLyBUaGUgdW5tb3VudCBvcGVyYXRpb25zIGFyZSBhbHJlYWR5IHNpZ25pZmljYW50bHkgc21hbGxlciB0aGFuIG1vdW50IG9wZXJhdGlvbnMgdGhvdWdoLlxuICAvLyBUaGlzIGlzIHNvbWV0aGluZyB0byBrZWVwIGluIG1pbmQgZm9yIGxhdGVyLlxuXG5cbiAgZnVuY3Rpb24gdXBkYXRlQ29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAvLyBSZS1tb3VudGluZyBhIHRyZWUgd2hpbGUgcHJvZmlsaW5nIGlzIGluIHByb2dyZXNzIG1pZ2h0IGJyZWFrIGEgbG90IG9mIGFzc3VtcHRpb25zLlxuICAgICAgLy8gSWYgbmVjZXNzYXJ5LCB3ZSBjb3VsZCBzdXBwb3J0IHRoaXMtIGJ1dCBpdCBkb2Vzbid0IHNlZW0gbGlrZSBhIG5lY2Vzc2FyeSB1c2UgY2FzZS5cbiAgICAgIHRocm93IEVycm9yKCdDYW5ub3QgbW9kaWZ5IGZpbHRlciBwcmVmZXJlbmNlcyB3aGlsZSBwcm9maWxpbmcnKTtcbiAgICB9IC8vIFJlY3Vyc2l2ZWx5IHVubW91bnQgYWxsIHJvb3RzLlxuXG5cbiAgICBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCkuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgY3VycmVudFJvb3RJRCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKHJvb3QuY3VycmVudCk7IC8vIFRoZSBUUkVFX09QRVJBVElPTl9SRU1PVkVfUk9PVCBvcGVyYXRpb24gc2VydmVzIHR3byBwdXJwb3NlczpcbiAgICAgIC8vIDEuIEl0IGF2b2lkcyBzZW5kaW5nIHVubmVjZXNzYXJ5IGJyaWRnZSB0cmFmZmljIHRvIGNsZWFyIGEgcm9vdC5cbiAgICAgIC8vIDIuIEl0IHByZXNlcnZlcyBGaWJlciBJRHMgd2hlbiByZW1vdW50aW5nIChiZWxvdykgd2hpY2ggaW4gdHVybiBJRCB0byBlcnJvci93YXJuaW5nIG1hcHBpbmcuXG5cbiAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fUkVNT1ZFX1JPT1QpO1xuICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3QpO1xuICAgICAgY3VycmVudFJvb3RJRCA9IC0xO1xuICAgIH0pO1xuICAgIGFwcGx5Q29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKTsgLy8gUmVzZXQgcHNldWRvIGNvdW50ZXJzIHNvIHRoYXQgbmV3IHBhdGggc2VsZWN0aW9ucyB3aWxsIGJlIHBlcnNpc3RlZC5cblxuICAgIHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuY2xlYXIoKTsgLy8gUmVjdXJzaXZlbHkgcmUtbW91bnQgYWxsIHJvb3RzIHdpdGggbmV3IGZpbHRlciBjcml0ZXJpYSBhcHBsaWVkLlxuXG4gICAgaG9vay5nZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIGN1cnJlbnRSb290SUQgPSBnZXRPckdlbmVyYXRlRmliZXJJRChyb290LmN1cnJlbnQpO1xuICAgICAgc2V0Um9vdFBzZXVkb0tleShjdXJyZW50Um9vdElELCByb290LmN1cnJlbnQpO1xuICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgbnVsbCwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcbiAgICAgIGN1cnJlbnRSb290SUQgPSAtMTtcbiAgICB9KTsgLy8gQWxzbyByZS1ldmFsdWF0ZSBhbGwgZXJyb3IgYW5kIHdhcm5pbmcgY291bnRzIGdpdmVuIHRoZSBuZXcgZmlsdGVycy5cblxuICAgIHJlZXZhbHVhdGVFcnJvcnNBbmRXYXJuaW5ncygpO1xuICAgIGZsdXNoUGVuZGluZ0V2ZW50cygpO1xuICB9IC8vIE5PVElDRSBLZWVwIGluIHN5bmMgd2l0aCBnZXQqRm9yRmliZXIgbWV0aG9kc1xuXG5cbiAgZnVuY3Rpb24gc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpIHtcbiAgICB2YXIgX2RlYnVnU291cmNlID0gZmliZXIuX2RlYnVnU291cmNlLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgICAvLyBUT0RPOiBpZGVhbGx5IHdlIHdvdWxkIHNob3cgZGVoeWRyYXRlZCBTdXNwZW5zZSBpbW1lZGlhdGVseS5cbiAgICAgICAgLy8gSG93ZXZlciwgaXQgaGFzIHNvbWUgc3BlY2lhbCBiZWhhdmlvciAobGlrZSBkaXNjb25uZWN0aW5nXG4gICAgICAgIC8vIGFuIGFsdGVybmF0ZSBhbmQgdHVybmluZyBpbnRvIHJlYWwgU3VzcGVuc2UpIHdoaWNoIGJyZWFrcyBEZXZUb29scy5cbiAgICAgICAgLy8gRm9yIG5vdywgaWdub3JlIGl0LCBhbmQgb25seSBzaG93IGl0IG9uY2UgaXQgZ2V0cyBoeWRyYXRlZC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2J2YXVnaG4vcmVhY3QtZGV2dG9vbHMtZXhwZXJpbWVudGFsL2lzc3Vlcy8xOTdcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIC8vIEl0IGlzIG5ldmVyIHZhbGlkIHRvIGZpbHRlciB0aGUgcm9vdCBlbGVtZW50LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciB0eXBlU3ltYm9sID0gZ2V0VHlwZVN5bWJvbCh0eXBlKTtcblxuICAgICAgICBzd2l0Y2ggKHR5cGVTeW1ib2wpIHtcbiAgICAgICAgICBjYXNlIENPTkNVUlJFTlRfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBDT05DVVJSRU5UX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICBjYXNlIERFUFJFQ0FURURfQVNZTkNfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgIGNhc2UgU1RSSUNUX01PREVfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgU1RSSUNUX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudFR5cGUgPSBnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChoaWRlRWxlbWVudHNXaXRoVHlwZXMuaGFzKGVsZW1lbnRUeXBlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGhpZGVFbGVtZW50c1dpdGhEaXNwbGF5TmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuXG4gICAgICBpZiAoZGlzcGxheU5hbWUgIT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IHJlbmRlcmVyX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaGlkZUVsZW1lbnRzV2l0aERpc3BsYXlOYW1lcyksXG4gICAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGRpc3BsYXlOYW1lUmVnRXhwID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoZGlzcGxheU5hbWVSZWdFeHAudGVzdChkaXNwbGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3IzLmYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChfZGVidWdTb3VyY2UgIT0gbnVsbCAmJiBoaWRlRWxlbWVudHNXaXRoUGF0aHMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IF9kZWJ1Z1NvdXJjZS5maWxlTmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcblxuICAgICAgdmFyIF9pdGVyYXRvcjQgPSByZW5kZXJlcl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGhpZGVFbGVtZW50c1dpdGhQYXRocyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBwYXRoUmVnRXhwID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgaWYgKHBhdGhSZWdFeHAudGVzdChmaWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIE5PVElDRSBLZWVwIGluIHN5bmMgd2l0aCBzaG91bGRGaWx0ZXJGaWJlcigpIGFuZCBvdGhlciBnZXQqRm9yRmliZXIgbWV0aG9kc1xuXG5cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcikge1xuICAgIHZhciB0eXBlID0gZmliZXIudHlwZSxcbiAgICAgICAgdGFnID0gZmliZXIudGFnO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlQ2xhc3M7XG5cbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZUZ1bmN0aW9uO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZUZvcndhcmRSZWY7XG5cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZVJvb3Q7XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudDtcblxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duO1xuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZU1lbW87XG5cbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBFbGVtZW50VHlwZVN1c3BlbnNlO1xuXG4gICAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlU3VzcGVuc2VMaXN0O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB2YXIgdHlwZVN5bWJvbCA9IGdldFR5cGVTeW1ib2wodHlwZSk7XG5cbiAgICAgICAgc3dpdGNoICh0eXBlU3ltYm9sKSB7XG4gICAgICAgICAgY2FzZSBDT05DVVJSRU5UX01PREVfTlVNQkVSOlxuICAgICAgICAgIGNhc2UgQ09OQ1VSUkVOVF9NT0RFX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgY2FzZSBERVBSRUNBVEVEX0FTWU5DX01PREVfU1lNQk9MX1NUUklORzpcbiAgICAgICAgICAgIHJldHVybiBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duO1xuXG4gICAgICAgICAgY2FzZSBQUk9WSURFUl9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBQUk9WSURFUl9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlQ29udGV4dDtcblxuICAgICAgICAgIGNhc2UgQ09OVEVYVF9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBDT05URVhUX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVDb250ZXh0O1xuXG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9OVU1CRVI6XG4gICAgICAgICAgY2FzZSBTVFJJQ1RfTU9ERV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd247XG5cbiAgICAgICAgICBjYXNlIFBST0ZJTEVSX05VTUJFUjpcbiAgICAgICAgICBjYXNlIFBST0ZJTEVSX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVQcm9maWxlcjtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bjtcbiAgICAgICAgfVxuXG4gICAgfVxuICB9IC8vIE1hcCBvZiBvbmUgb3IgbW9yZSBGaWJlcnMgaW4gYSBwYWlyIHRvIHRoZWlyIHVuaXF1ZSBpZCBudW1iZXIuXG4gIC8vIFdlIHRyYWNrIGJvdGggRmliZXJzIHRvIHN1cHBvcnQgRmFzdCBSZWZyZXNoLFxuICAvLyB3aGljaCBtYXkgZm9yY2VmdWxseSByZXBsYWNlIG9uZSBvZiB0aGUgcGFpciBhcyBwYXJ0IG9mIGhvdCByZWxvYWRpbmcuXG4gIC8vIEluIHRoYXQgY2FzZSBpdCdzIHN0aWxsIGltcG9ydGFudCB0byBiZSBhYmxlIHRvIGxvY2F0ZSB0aGUgcHJldmlvdXMgSUQgZHVyaW5nIHN1YnNlcXVlbnQgcmVuZGVycy5cblxuXG4gIHZhciBmaWJlclRvSURNYXAgPSBuZXcgTWFwKCk7IC8vIE1hcCBvZiBpZCB0byBvbmUgKGFyYml0cmFyeSkgRmliZXIgaW4gYSBwYWlyLlxuICAvLyBUaGlzIE1hcCBpcyB1c2VkIHRvIGUuZy4gZ2V0IHRoZSBkaXNwbGF5IG5hbWUgZm9yIGEgRmliZXIgb3Igc2NoZWR1bGUgYW4gdXBkYXRlLFxuICAvLyBvcGVyYXRpb25zIHRoYXQgc2hvdWxkIGJlIHRoZSBzYW1lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYW5kIHdvcmstaW4tcHJvZ3Jlc3MgRmliZXIgaXMgdXNlZC5cblxuICB2YXIgaWRUb0FyYml0cmFyeUZpYmVyTWFwID0gbmV3IE1hcCgpOyAvLyBXaGVuIHByb2ZpbGluZyBpcyBzdXBwb3J0ZWQsIHdlIHN0b3JlIHRoZSBsYXRlc3QgdHJlZSBiYXNlIGR1cmF0aW9ucyBmb3IgZWFjaCBGaWJlci5cbiAgLy8gVGhpcyBpcyBzbyB0aGF0IHdlIGNhbiBxdWlja2x5IGNhcHR1cmUgYSBzbmFwc2hvdCBvZiB0aG9zZSB2YWx1ZXMgaWYgcHJvZmlsaW5nIHN0YXJ0cy5cbiAgLy8gSWYgd2UgZGlkbid0IHN0b3JlIHRoZXNlIHZhbHVlcywgd2UnZCBoYXZlIHRvIGNyYXdsIHRoZSB0cmVlIHdoZW4gcHJvZmlsaW5nIHN0YXJ0ZWQsXG4gIC8vIGFuZCB1c2UgYSBzbG93IHBhdGggdG8gZmluZCBlYWNoIG9mIHRoZSBjdXJyZW50IEZpYmVycy5cblxuICB2YXIgaWRUb1RyZWVCYXNlRHVyYXRpb25NYXAgPSBuZXcgTWFwKCk7IC8vIFdoZW4gcHJvZmlsaW5nIGlzIHN1cHBvcnRlZCwgd2Ugc3RvcmUgdGhlIGxhdGVzdCB0cmVlIGJhc2UgZHVyYXRpb25zIGZvciBlYWNoIEZpYmVyLlxuICAvLyBUaGlzIG1hcCBlbmFibGVzIHVzIHRvIGZpbHRlciB0aGVzZSB0aW1lcyBieSByb290IHdoZW4gc2VuZGluZyB0aGVtIHRvIHRoZSBmcm9udGVuZC5cblxuICB2YXIgaWRUb1Jvb3RNYXAgPSBuZXcgTWFwKCk7IC8vIFdoZW4gYSBtb3VudCBvciB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3MsIHRoaXMgdmFsdWUgdHJhY2tzIHRoZSByb290IHRoYXQgaXMgYmVpbmcgb3BlcmF0ZWQgb24uXG5cbiAgdmFyIGN1cnJlbnRSb290SUQgPSAtMTsgLy8gUmV0dXJucyB0aGUgdW5pcXVlIElEIGZvciBhIEZpYmVyIG9yIGdlbmVyYXRlcyBhbmQgY2FjaGVzIGEgbmV3IG9uZSBpZiB0aGUgRmliZXIgaGFzbid0IGJlZW4gc2VlbiBiZWZvcmUuXG4gIC8vIE9uY2UgdGhpcyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkIGZvciBhIEZpYmVyLCB1bnRyYWNrRmliZXJJRCgpIHNob3VsZCBhbHdheXMgYmUgY2FsbGVkIGxhdGVyIHRvIGF2b2lkIGxlYWtpbmcuXG5cbiAgZnVuY3Rpb24gZ2V0T3JHZW5lcmF0ZUZpYmVySUQoZmliZXIpIHtcbiAgICB2YXIgaWQgPSBudWxsO1xuXG4gICAgaWYgKGZpYmVyVG9JRE1hcC5oYXMoZmliZXIpKSB7XG4gICAgICBpZCA9IGZpYmVyVG9JRE1hcC5nZXQoZmliZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2FsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgZmliZXJUb0lETWFwLmhhcyhfYWx0ZXJuYXRlKSkge1xuICAgICAgICBpZCA9IGZpYmVyVG9JRE1hcC5nZXQoX2FsdGVybmF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZEdlbmVyYXRlSUQgPSBmYWxzZTtcblxuICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgZGlkR2VuZXJhdGVJRCA9IHRydWU7XG4gICAgICBpZCA9IGdldFVJRCgpO1xuICAgIH0gLy8gVGhpcyByZWZpbmVtZW50IGlzIGZvciBGbG93IHB1cnBvc2VzIG9ubHkuXG5cblxuICAgIHZhciByZWZpbmVkSUQgPSBpZDsgLy8gTWFrZSBzdXJlIHdlJ3JlIHRyYWNraW5nIHRoaXMgRmliZXJcbiAgICAvLyBlLmcuIGlmIGl0IGp1c3QgbW91bnRlZCBvciBhbiBlcnJvciB3YXMgbG9nZ2VkIGR1cmluZyBpbml0aWFsIHJlbmRlci5cblxuICAgIGlmICghZmliZXJUb0lETWFwLmhhcyhmaWJlcikpIHtcbiAgICAgIGZpYmVyVG9JRE1hcC5zZXQoZmliZXIsIHJlZmluZWRJRCk7XG4gICAgICBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuc2V0KHJlZmluZWRJRCwgZmliZXIpO1xuICAgIH0gLy8gQWxzbyBtYWtlIHN1cmUgd2UncmUgdHJhY2tpbmcgaXRzIGFsdGVybmF0ZSxcbiAgICAvLyBlLmcuIGluIGNhc2UgdGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlIGFmdGVyIG1vdW50LlxuXG5cbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFmaWJlclRvSURNYXAuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgZmliZXJUb0lETWFwLnNldChhbHRlcm5hdGUsIHJlZmluZWRJRCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgaWYgKGRpZEdlbmVyYXRlSUQpIHtcbiAgICAgICAgZGVidWcoJ2dldE9yR2VuZXJhdGVGaWJlcklEKCknLCBmaWJlciwgZmliZXIucmV0dXJuLCAnR2VuZXJhdGVkIGEgbmV3IFVJRCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWZpbmVkSUQ7XG4gIH0gLy8gUmV0dXJucyBhbiBJRCBpZiBvbmUgaGFzIGFscmVhZHkgYmVlbiBnZW5lcmF0ZWQgZm9yIHRoZSBGaWJlciBvciB0aHJvd3MuXG5cblxuICBmdW5jdGlvbiBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlSUQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcblxuICAgIGlmIChtYXliZUlEICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF5YmVJRDtcbiAgICB9XG5cbiAgICB0aHJvdyBFcnJvcihcIkNvdWxkIG5vdCBmaW5kIElEIGZvciBGaWJlciBcXFwiXCIuY29uY2F0KGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpIHx8ICcnLCBcIlxcXCJcIikpO1xuICB9IC8vIFJldHVybnMgYW4gSUQgaWYgb25lIGhhcyBhbHJlYWR5IGJlZW4gZ2VuZXJhdGVkIGZvciB0aGUgRmliZXIgb3IgbnVsbCBpZiBvbmUgaGFzIG5vdCBiZWVuIGdlbmVyYXRlZC5cbiAgLy8gVXNlIHRoaXMgbWV0aG9kIHdoaWxlIGUuZy4gbG9nZ2luZyB0byBhdm9pZCBvdmVyLXJldGFpbmluZyBGaWJlcnMuXG5cblxuICBmdW5jdGlvbiBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyVG9JRE1hcC5oYXMoZmliZXIpKSB7XG4gICAgICByZXR1cm4gZmliZXJUb0lETWFwLmdldChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgZmliZXJUb0lETWFwLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgIHJldHVybiBmaWJlclRvSURNYXAuZ2V0KGFsdGVybmF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gUmVtb3ZlcyBhIEZpYmVyIChhbmQgaXRzIGFsdGVybmF0ZSkgZnJvbSB0aGUgTWFwcyB1c2VkIHRvIHRyYWNrIHRoZWlyIGlkLlxuICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgYWx3YXlzIGJlIGNhbGxlZCB3aGVuIGEgRmliZXIgaXMgdW5tb3VudGluZy5cblxuXG4gIGZ1bmN0aW9uIHVudHJhY2tGaWJlcklEKGZpYmVyKSB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgZGVidWcoJ3VudHJhY2tGaWJlcklEKCknLCBmaWJlciwgZmliZXIucmV0dXJuLCAnc2NoZWR1bGUgYWZ0ZXIgZGVsYXknKTtcbiAgICB9IC8vIFVudHJhY2sgRmliZXJzIGFmdGVyIGEgc2xpZ2h0IGRlbGF5IGluIG9yZGVyIHRvIHN1cHBvcnQgYSBGYXN0IFJlZnJlc2ggZWRnZSBjYXNlOlxuICAgIC8vIDEuIENvbXBvbmVudCB0eXBlIGlzIHVwZGF0ZWQgYW5kIEZhc3QgUmVmcmVzaCBzY2hlZHVsZXMgYW4gdXBkYXRlK3JlbW91bnQuXG4gICAgLy8gMi4gZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5KCkgcnVucywgc2VlcyB0aGUgb2xkIEZpYmVyIGlzIG5vIGxvbmdlciBtb3VudGVkXG4gICAgLy8gICAgKGl0J3MgYmVlbiBkaXNjb25uZWN0ZWQgYnkgRmFzdCBSZWZyZXNoKSwgYW5kIGNhbGxzIHVudHJhY2tGaWJlcklEKCkgdG8gY2xlYXIgaXQgZnJvbSB0aGUgTWFwLlxuICAgIC8vIDMuIFJlYWN0IGZsdXNoZXMgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGl0IHJ1bnMgdGhlIG5leHQgcmVuZGVyLFxuICAgIC8vICAgIHdoaWNoIGxvZ3MgYW4gZXJyb3Igb3Igd2FybmluZywgd2hpY2ggY2F1c2VzIGEgbmV3IElEIHRvIGJlIGdlbmVyYXRlZCBmb3IgdGhpcyBGaWJlci5cbiAgICAvLyA0LiBEZXZUb29scyBub3cgdHJpZXMgdG8gdW5tb3VudCB0aGUgb2xkIENvbXBvbmVudCB3aXRoIHRoZSBuZXcgSUQuXG4gICAgLy9cbiAgICAvLyBUaGUgdW5kZXJseWluZyBwcm9ibGVtIGhlcmUgaXMgdGhlIHByZW1hdHVyZSBjbGVhcmluZyBvZiB0aGUgRmliZXIgSUQsXG4gICAgLy8gYnV0IERldlRvb2xzIGhhcyBubyB3YXkgdG8gZGV0ZWN0IHRoYXQgYSBnaXZlbiBGaWJlciBoYXMgYmVlbiBzY2hlZHVsZWQgZm9yIEZhc3QgUmVmcmVzaC5cbiAgICAvLyAoVGhlIFwiX2RlYnVnTmVlZHNSZW1vdW50XCIgZmxhZyB3b24ndCBuZWNlc3NhcmlseSBiZSBzZXQuKVxuICAgIC8vXG4gICAgLy8gVGhlIGJlc3Qgd2UgY2FuIGRvIGlzIHRvIGRlbGF5IHVudHJhY2tpbmcgYnkgYSBzbWFsbCBhbW91bnQsXG4gICAgLy8gYW5kIGdpdmUgUmVhY3QgdGltZSB0byBwcm9jZXNzIHRoZSBGYXN0IFJlZnJlc2ggZGVsYXkuXG5cblxuICAgIHVudHJhY2tGaWJlcnNTZXQuYWRkKGZpYmVyKTtcblxuICAgIGlmICh1bnRyYWNrRmliZXJzVGltZW91dElEID09PSBudWxsKSB7XG4gICAgICB1bnRyYWNrRmliZXJzVGltZW91dElEID0gc2V0VGltZW91dCh1bnRyYWNrRmliZXJzLCAxMDAwKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW50cmFja0ZpYmVyc1NldCA9IG5ldyBTZXQoKTtcbiAgdmFyIHVudHJhY2tGaWJlcnNUaW1lb3V0SUQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHVudHJhY2tGaWJlcnMoKSB7XG4gICAgaWYgKHVudHJhY2tGaWJlcnNUaW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh1bnRyYWNrRmliZXJzVGltZW91dElEKTtcbiAgICAgIHVudHJhY2tGaWJlcnNUaW1lb3V0SUQgPSBudWxsO1xuICAgIH1cblxuICAgIHVudHJhY2tGaWJlcnNTZXQuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBmaWJlcklEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG5cbiAgICAgIGlmIChmaWJlcklEICE9PSBudWxsKSB7XG4gICAgICAgIGlkVG9BcmJpdHJhcnlGaWJlck1hcC5kZWxldGUoZmliZXJJRCk7IC8vIEFsc28gY2xlYXIgYW55IGVycm9ycy93YXJuaW5ncyBhc3NvY2lhdGVkIHdpdGggdGhpcyBmaWJlci5cblxuICAgICAgICBjbGVhckVycm9yc0ZvckZpYmVySUQoZmliZXJJRCk7XG4gICAgICAgIGNsZWFyV2FybmluZ3NGb3JGaWJlcklEKGZpYmVySUQpO1xuICAgICAgfVxuXG4gICAgICBmaWJlclRvSURNYXAuZGVsZXRlKGZpYmVyKTtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgZmliZXJUb0lETWFwLmRlbGV0ZShhbHRlcm5hdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVySURzLmhhcyhmaWJlcklEKSkge1xuICAgICAgICBmb3JjZUVycm9yRm9yRmliZXJJRHMuZGVsZXRlKGZpYmVySUQpO1xuXG4gICAgICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJJRHMuc2l6ZSA9PT0gMCAmJiBzZXRFcnJvckhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgIHNldEVycm9ySGFuZGxlcihzaG91bGRFcnJvckZpYmVyQWx3YXlzTnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICB1bnRyYWNrRmliZXJzU2V0LmNsZWFyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDaGFuZ2VEZXNjcmlwdGlvbihwcmV2RmliZXIsIG5leHRGaWJlcikge1xuICAgIHN3aXRjaCAoZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihuZXh0RmliZXIpKSB7XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlQ2xhc3M6XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlRnVuY3Rpb246XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlTWVtbzpcbiAgICAgIGNhc2UgRWxlbWVudFR5cGVGb3J3YXJkUmVmOlxuICAgICAgICBpZiAocHJldkZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRleHQ6IG51bGwsXG4gICAgICAgICAgICBkaWRIb29rc0NoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICBpc0ZpcnN0TW91bnQ6IHRydWUsXG4gICAgICAgICAgICBwcm9wczogbnVsbCxcbiAgICAgICAgICAgIHN0YXRlOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIGNvbnRleHQ6IGdldENvbnRleHRDaGFuZ2VkS2V5cyhuZXh0RmliZXIpLFxuICAgICAgICAgICAgZGlkSG9va3NDaGFuZ2U6IGZhbHNlLFxuICAgICAgICAgICAgaXNGaXJzdE1vdW50OiBmYWxzZSxcbiAgICAgICAgICAgIHByb3BzOiBnZXRDaGFuZ2VkS2V5cyhwcmV2RmliZXIubWVtb2l6ZWRQcm9wcywgbmV4dEZpYmVyLm1lbW9pemVkUHJvcHMpLFxuICAgICAgICAgICAgc3RhdGU6IGdldENoYW5nZWRLZXlzKHByZXZGaWJlci5tZW1vaXplZFN0YXRlLCBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSlcbiAgICAgICAgICB9OyAvLyBPbmx5IHRyYXZlcnNlIHRoZSBob29rcyBsaXN0IG9uY2UsIGRlcGVuZGluZyBvbiB3aGF0IGluZm8gd2UncmUgcmV0dXJuaW5nLlxuXG4gICAgICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyQ2hhbmdlZEhvb2tJbmRpY2VzKSB7XG4gICAgICAgICAgICB2YXIgaW5kaWNlcyA9IGdldENoYW5nZWRIb29rc0luZGljZXMocHJldkZpYmVyLm1lbW9pemVkU3RhdGUsIG5leHRGaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgICAgIGRhdGEuaG9va3MgPSBpbmRpY2VzO1xuICAgICAgICAgICAgZGF0YS5kaWRIb29rc0NoYW5nZSA9IGluZGljZXMgIT09IG51bGwgJiYgaW5kaWNlcy5sZW5ndGggPiAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRhLmRpZEhvb2tzQ2hhbmdlID0gZGlkSG9va3NDaGFuZ2UocHJldkZpYmVyLm1lbW9pemVkU3RhdGUsIG5leHRGaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDb250ZXh0c0ZvckZpYmVyKGZpYmVyKSB7XG4gICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKSkge1xuICAgICAgY2FzZSBFbGVtZW50VHlwZUZ1bmN0aW9uOlxuICAgICAgY2FzZSBFbGVtZW50VHlwZUNsYXNzOlxuICAgICAgICBpZiAoaWRUb0NvbnRleHRzTWFwICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGlkID0gZ2V0RmliZXJJRFRocm93cyhmaWJlcik7XG4gICAgICAgICAgdmFyIGNvbnRleHRzID0gZ2V0Q29udGV4dHNGb3JGaWJlcihmaWJlcik7XG5cbiAgICAgICAgICBpZiAoY29udGV4dHMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlkVG9Db250ZXh0c01hcC5zZXQoaWQsIGNvbnRleHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIERpZmZlcmVudGlhdGVzIGJldHdlZW4gYSBudWxsIGNvbnRleHQgdmFsdWUgYW5kIG5vIGNvbnRleHQuXG5cblxuICB2YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRzRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgbGVnYWN5Q29udGV4dCA9IE5PX0NPTlRFWFQ7XG4gICAgdmFyIG1vZGVybkNvbnRleHQgPSBOT19DT05URVhUO1xuXG4gICAgc3dpdGNoIChnZXRFbGVtZW50VHlwZUZvckZpYmVyKGZpYmVyKSkge1xuICAgICAgY2FzZSBFbGVtZW50VHlwZUNsYXNzOlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UuY29uc3RydWN0b3IgJiYgaW5zdGFuY2UuY29uc3RydWN0b3IuY29udGV4dFR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbW9kZXJuQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZ2FjeUNvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuXG4gICAgICAgICAgICBpZiAobGVnYWN5Q29udGV4dCAmJiBPYmplY3Qua2V5cyhsZWdhY3lDb250ZXh0KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgbGVnYWN5Q29udGV4dCA9IE5PX0NPTlRFWFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsZWdhY3lDb250ZXh0LCBtb2Rlcm5Db250ZXh0XTtcblxuICAgICAgY2FzZSBFbGVtZW50VHlwZUZ1bmN0aW9uOlxuICAgICAgICB2YXIgZGVwZW5kZW5jaWVzID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuXG4gICAgICAgIGlmIChkZXBlbmRlbmNpZXMgJiYgZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dCkge1xuICAgICAgICAgIG1vZGVybkNvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsZWdhY3lDb250ZXh0LCBtb2Rlcm5Db250ZXh0XTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIFJlY29yZCBhbGwgY29udGV4dHMgYXQgdGhlIHRpbWUgcHJvZmlsaW5nIGlzIHN0YXJ0ZWQuXG4gIC8vIEZpYmVycyBvbmx5IHN0b3JlIHRoZSBjdXJyZW50IGNvbnRleHQgdmFsdWUsXG4gIC8vIHNvIHdlIG5lZWQgdG8gdHJhY2sgdGhlbSBzZXBhcmF0ZWx5IGluIG9yZGVyIHRvIGRldGVybWluZSBjaGFuZ2VkIGtleXMuXG5cblxuICBmdW5jdGlvbiBjcmF3bFRvSW5pdGlhbGl6ZUNvbnRleHRzTWFwKGZpYmVyKSB7XG4gICAgdXBkYXRlQ29udGV4dHNGb3JGaWJlcihmaWJlcik7XG4gICAgdmFyIGN1cnJlbnQgPSBmaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBjcmF3bFRvSW5pdGlhbGl6ZUNvbnRleHRzTWFwKGN1cnJlbnQpO1xuICAgICAgY3VycmVudCA9IGN1cnJlbnQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDb250ZXh0Q2hhbmdlZEtleXMoZmliZXIpIHtcbiAgICBpZiAoaWRUb0NvbnRleHRzTWFwICE9PSBudWxsKSB7XG4gICAgICB2YXIgaWQgPSBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKTtcbiAgICAgIHZhciBwcmV2Q29udGV4dHMgPSBpZFRvQ29udGV4dHNNYXAuaGFzKGlkKSA/IGlkVG9Db250ZXh0c01hcC5nZXQoaWQpIDogbnVsbDtcbiAgICAgIHZhciBuZXh0Q29udGV4dHMgPSBnZXRDb250ZXh0c0ZvckZpYmVyKGZpYmVyKTtcblxuICAgICAgaWYgKHByZXZDb250ZXh0cyA9PSBudWxsIHx8IG5leHRDb250ZXh0cyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3ByZXZDb250ZXh0cyA9IF9zbGljZWRUb0FycmF5KHByZXZDb250ZXh0cywgMiksXG4gICAgICAgICAgcHJldkxlZ2FjeUNvbnRleHQgPSBfcHJldkNvbnRleHRzWzBdLFxuICAgICAgICAgIHByZXZNb2Rlcm5Db250ZXh0ID0gX3ByZXZDb250ZXh0c1sxXTtcblxuICAgICAgdmFyIF9uZXh0Q29udGV4dHMgPSBfc2xpY2VkVG9BcnJheShuZXh0Q29udGV4dHMsIDIpLFxuICAgICAgICAgIG5leHRMZWdhY3lDb250ZXh0ID0gX25leHRDb250ZXh0c1swXSxcbiAgICAgICAgICBuZXh0TW9kZXJuQ29udGV4dCA9IF9uZXh0Q29udGV4dHNbMV07XG5cbiAgICAgIHN3aXRjaCAoZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcikpIHtcbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZUNsYXNzOlxuICAgICAgICAgIGlmIChwcmV2Q29udGV4dHMgJiYgbmV4dENvbnRleHRzKSB7XG4gICAgICAgICAgICBpZiAobmV4dExlZ2FjeUNvbnRleHQgIT09IE5PX0NPTlRFWFQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldENoYW5nZWRLZXlzKHByZXZMZWdhY3lDb250ZXh0LCBuZXh0TGVnYWN5Q29udGV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5leHRNb2Rlcm5Db250ZXh0ICE9PSBOT19DT05URVhUKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcmV2TW9kZXJuQ29udGV4dCAhPT0gbmV4dE1vZGVybkNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBFbGVtZW50VHlwZUZ1bmN0aW9uOlxuICAgICAgICAgIGlmIChuZXh0TW9kZXJuQ29udGV4dCAhPT0gTk9fQ09OVEVYVCkge1xuICAgICAgICAgICAgdmFyIHByZXZDb250ZXh0ID0gcHJldk1vZGVybkNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgbmV4dENvbnRleHQgPSBuZXh0TW9kZXJuQ29udGV4dDtcblxuICAgICAgICAgICAgd2hpbGUgKHByZXZDb250ZXh0ICYmIG5leHRDb250ZXh0KSB7XG4gICAgICAgICAgICAgIGlmICghc2hhcmVkX29iamVjdElzKHByZXZDb250ZXh0Lm1lbW9pemVkVmFsdWUsIG5leHRDb250ZXh0Lm1lbW9pemVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwcmV2Q29udGV4dCA9IHByZXZDb250ZXh0Lm5leHQ7XG4gICAgICAgICAgICAgIG5leHRDb250ZXh0ID0gbmV4dENvbnRleHQubmV4dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSB7XG4gICAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoc2hhcmVkX29iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWZmZWN0KG1lbW9pemVkU3RhdGUpIHtcbiAgICBpZiAobWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbCB8fCByZW5kZXJlcl90eXBlb2YobWVtb2l6ZWRTdGF0ZSkgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGRlcHMgPSBtZW1vaXplZFN0YXRlLmRlcHM7XG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5iaW5kKG1lbW9pemVkU3RhdGUpO1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eSgnY3JlYXRlJykgJiYgaGFzT3duUHJvcGVydHkoJ2Rlc3Ryb3knKSAmJiBoYXNPd25Qcm9wZXJ0eSgnZGVwcycpICYmIGhhc093blByb3BlcnR5KCduZXh0JykgJiYgaGFzT3duUHJvcGVydHkoJ3RhZycpICYmIChkZXBzID09PSBudWxsIHx8IHNoYXJlZF9pc0FycmF5KGRlcHMpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpZEhvb2tDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIHZhciBwcmV2TWVtb2l6ZWRTdGF0ZSA9IHByZXYubWVtb2l6ZWRTdGF0ZTtcbiAgICB2YXIgbmV4dE1lbW9pemVkU3RhdGUgPSBuZXh0Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoaXNFZmZlY3QocHJldk1lbW9pemVkU3RhdGUpICYmIGlzRWZmZWN0KG5leHRNZW1vaXplZFN0YXRlKSkge1xuICAgICAgcmV0dXJuIHByZXZNZW1vaXplZFN0YXRlICE9PSBuZXh0TWVtb2l6ZWRTdGF0ZSAmJiAhYXJlSG9va0lucHV0c0VxdWFsKG5leHRNZW1vaXplZFN0YXRlLmRlcHMsIHByZXZNZW1vaXplZFN0YXRlLmRlcHMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXh0TWVtb2l6ZWRTdGF0ZSAhPT0gcHJldk1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBkaWRIb29rc0NoYW5nZShwcmV2LCBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIFdlIGNhbid0IHJlcG9ydCBhbnl0aGluZyBtZWFuaW5nZnVsIGZvciBob29rcyBjaGFuZ2VzLlxuXG5cbiAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eSgnYmFzZVN0YXRlJykgJiYgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbWVtb2l6ZWRTdGF0ZScpICYmIG5leHQuaGFzT3duUHJvcGVydHkoJ25leHQnKSAmJiBuZXh0Lmhhc093blByb3BlcnR5KCdxdWV1ZScpKSB7XG4gICAgICB3aGlsZSAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoZGlkSG9va0NoYW5nZShwcmV2LCBuZXh0KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgcHJldiA9IHByZXYubmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoYW5nZWRIb29rc0luZGljZXMocHJldiwgbmV4dCkge1xuICAgIGlmIChlbmFibGVQcm9maWxlckNoYW5nZWRIb29rSW5kaWNlcykge1xuICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICB2YXIgaW5kZXggPSAwO1xuXG4gICAgICBpZiAobmV4dC5oYXNPd25Qcm9wZXJ0eSgnYmFzZVN0YXRlJykgJiYgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbWVtb2l6ZWRTdGF0ZScpICYmIG5leHQuaGFzT3duUHJvcGVydHkoJ25leHQnKSAmJiBuZXh0Lmhhc093blByb3BlcnR5KCdxdWV1ZScpKSB7XG4gICAgICAgIHdoaWxlIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGRpZEhvb2tDaGFuZ2UocHJldiwgbmV4dCkpIHtcbiAgICAgICAgICAgIGluZGljZXMucHVzaChpbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgICBwcmV2ID0gcHJldi5uZXh0O1xuICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluZGljZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDaGFuZ2VkS2V5cyhwcmV2LCBuZXh0KSB7XG4gICAgaWYgKHByZXYgPT0gbnVsbCB8fCBuZXh0ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gV2UgY2FuJ3QgcmVwb3J0IGFueXRoaW5nIG1lYW5pbmdmdWwgZm9yIGhvb2tzIGNoYW5nZXMuXG5cblxuICAgIGlmIChuZXh0Lmhhc093blByb3BlcnR5KCdiYXNlU3RhdGUnKSAmJiBuZXh0Lmhhc093blByb3BlcnR5KCdtZW1vaXplZFN0YXRlJykgJiYgbmV4dC5oYXNPd25Qcm9wZXJ0eSgnbmV4dCcpICYmIG5leHQuaGFzT3duUHJvcGVydHkoJ3F1ZXVlJykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBrZXlzID0gbmV3IFNldChbXS5jb25jYXQocmVuZGVyZXJfdG9Db25zdW1hYmxlQXJyYXkoT2JqZWN0LmtleXMocHJldikpLCByZW5kZXJlcl90b0NvbnN1bWFibGVBcnJheShPYmplY3Qua2V5cyhuZXh0KSkpKTtcbiAgICB2YXIgY2hhbmdlZEtleXMgPSBbXTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZvci1vZi1sb29wcy9uby1mb3Itb2YtbG9vcHNcblxuICAgIHZhciBfaXRlcmF0b3I1ID0gcmVuZGVyZXJfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihrZXlzKSxcbiAgICAgICAgX3N0ZXA1O1xuXG4gICAgdHJ5IHtcbiAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgIHZhciBrZXkgPSBfc3RlcDUudmFsdWU7XG5cbiAgICAgICAgaWYgKHByZXZba2V5XSAhPT0gbmV4dFtrZXldKSB7XG4gICAgICAgICAgY2hhbmdlZEtleXMucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNoYW5nZWRLZXlzO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuXG5cbiAgZnVuY3Rpb24gZGlkRmliZXJSZW5kZXIocHJldkZpYmVyLCBuZXh0RmliZXIpIHtcbiAgICBzd2l0Y2ggKG5leHRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIC8vIEZvciB0eXBlcyB0aGF0IGV4ZWN1dGUgdXNlciBjb2RlLCB3ZSBjaGVjayBQZXJmb3JtZWRXb3JrIGVmZmVjdC5cbiAgICAgICAgLy8gV2UgZG9uJ3QgcmVmbGVjdCBiYWlsb3V0cyAoZWl0aGVyIHJlZmVyZW50aWFsIG9yIHNDVSkgaW4gRGV2VG9vbHMuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1iaXR3aXNlXG4gICAgICAgIHJldHVybiAoZ2V0RmliZXJGbGFncyhuZXh0RmliZXIpICYgUGVyZm9ybWVkV29yaykgPT09IFBlcmZvcm1lZFdvcms7XG4gICAgICAvLyBOb3RlOiBDb250ZXh0Q29uc3VtZXIgb25seSBnZXRzIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGluIDE2LjMuMytcbiAgICAgIC8vIHNvIGl0IHdvbid0IGdldCBoaWdobGlnaHRlZCB3aXRoIFJlYWN0IDE2LjMuMCB0byAxNi4zLjIuXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vIEZvciBob3N0IGNvbXBvbmVudHMgYW5kIG90aGVyIHR5cGVzLCB3ZSBjb21wYXJlIGlucHV0c1xuICAgICAgICAvLyB0byBkZXRlcm1pbmUgd2hldGhlciBzb21ldGhpbmcgaXMgYW4gdXBkYXRlLlxuICAgICAgICByZXR1cm4gcHJldkZpYmVyLm1lbW9pemVkUHJvcHMgIT09IG5leHRGaWJlci5tZW1vaXplZFByb3BzIHx8IHByZXZGaWJlci5tZW1vaXplZFN0YXRlICE9PSBuZXh0RmliZXIubWVtb2l6ZWRTdGF0ZSB8fCBwcmV2RmliZXIucmVmICE9PSBuZXh0RmliZXIucmVmO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwZW5kaW5nT3BlcmF0aW9ucyA9IFtdO1xuICB2YXIgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMgPSBbXTtcbiAgdmFyIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMgPSBbXTtcbiAgdmFyIHBlbmRpbmdPcGVyYXRpb25zUXVldWUgPSBbXTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZSA9IG5ldyBNYXAoKTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIHZhciBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBwdXNoT3BlcmF0aW9uKG9wKSB7XG4gICAgaWYgKGZhbHNlKSB7fVxuXG4gICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaE9yUXVldWVPcGVyYXRpb25zKG9wZXJhdGlvbnMpIHtcbiAgICBpZiAocGVuZGluZ09wZXJhdGlvbnNRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgcGVuZGluZ09wZXJhdGlvbnNRdWV1ZS5wdXNoKG9wZXJhdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rLmVtaXQoJ29wZXJhdGlvbnMnLCBvcGVyYXRpb25zKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmx1c2hQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3NBZnRlckRlbGF5VGltZW91dElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBjbGVhclBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKSB7XG4gICAgaWYgKGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCk7XG4gICAgICBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheSgpIHtcbiAgICBjbGVhclBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXkoKTtcbiAgICBmbHVzaFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5nc0FmdGVyRGVsYXlUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZsdXNoUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheVRpbWVvdXRJRCA9IG51bGw7XG5cbiAgICAgIGlmIChwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIE9uIHRoZSBvZmYgY2hhbmNlIHRoYXQgc29tZXRoaW5nIGVsc2UgaGFzIHB1c2hlZCBwZW5kaW5nIG9wZXJhdGlvbnMsXG4gICAgICAgIC8vIHdlIHNob3VsZCBiYWlsIG9uIHdhcm5pbmdzOyBpdCdzIHByb2JhYmx5IG5vdCBzYWZlIHRvIHB1c2ggbWlkd2F5LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpO1xuXG4gICAgICBpZiAocGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIE5vIHdhcm5pbmdzIG9yIGVycm9ycyB0byBmbHVzaDsgd2UgY2FuIGJhaWwgb3V0IGVhcmx5IGhlcmUgdG9vLlxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFdlIGNhbiBjcmVhdGUgYSBzbWFsbGVyIG9wZXJhdGlvbnMgYXJyYXkgdGhhbiBmbHVzaFBlbmRpbmdFdmVudHMoKVxuICAgICAgLy8gYmVjYXVzZSB3ZSBvbmx5IG5lZWQgdG8gZmx1c2ggd2FybmluZyBhbmQgZXJyb3IgY291bnRzLlxuICAgICAgLy8gT25seSBhIGZldyBwaWVjZXMgb2YgZml4ZWQgaW5mb3JtYXRpb24gYXJlIHJlcXVpcmVkIHVwIGZyb250LlxuXG5cbiAgICAgIHZhciBvcGVyYXRpb25zID0gbmV3IEFycmF5KDMgKyBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgpO1xuICAgICAgb3BlcmF0aW9uc1swXSA9IHJlbmRlcmVySUQ7XG4gICAgICBvcGVyYXRpb25zWzFdID0gY3VycmVudFJvb3RJRDtcbiAgICAgIG9wZXJhdGlvbnNbMl0gPSAwOyAvLyBTdHJpbmcgdGFibGUgc2l6ZVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbMyArIGpdID0gcGVuZGluZ09wZXJhdGlvbnNbal07XG4gICAgICB9XG5cbiAgICAgIGZsdXNoT3JRdWV1ZU9wZXJhdGlvbnMob3BlcmF0aW9ucyk7XG4gICAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPSAwO1xuICAgIH0sIDEwMDApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVldmFsdWF0ZUVycm9yc0FuZFdhcm5pbmdzKCkge1xuICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuY2xlYXIoKTtcbiAgICBmaWJlcklEVG9FcnJvcnNNYXAuZm9yRWFjaChmdW5jdGlvbiAoY291bnRNYXAsIGZpYmVySUQpIHtcbiAgICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoZmliZXJJRCk7XG5cbiAgICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuYWRkKGZpYmVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmaWJlcklEVG9XYXJuaW5nc01hcC5mb3JFYWNoKGZ1bmN0aW9uIChjb3VudE1hcCwgZmliZXJJRCkge1xuICAgICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChmaWJlcklEKTtcblxuICAgICAgaWYgKGZpYmVyICE9IG51bGwpIHtcbiAgICAgICAgZmliZXJzV2l0aENoYW5nZWRFcnJvck9yV2FybmluZ0NvdW50cy5hZGQoZmliZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlY29yZFBlbmRpbmdFcnJvcnNBbmRXYXJuaW5ncygpO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VNYXBzQW5kR2V0Q291bnRIZWxwZXIoZmliZXIsIGZpYmVySUQsIHBlbmRpbmdGaWJlclRvTWVzc2FnZUNvdW50TWFwLCBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXApIHtcbiAgICB2YXIgbmV3Q291bnQgPSAwO1xuICAgIHZhciBtZXNzYWdlQ291bnRNYXAgPSBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuZ2V0KGZpYmVySUQpO1xuICAgIHZhciBwZW5kaW5nTWVzc2FnZUNvdW50TWFwID0gcGVuZGluZ0ZpYmVyVG9NZXNzYWdlQ291bnRNYXAuZ2V0KGZpYmVyKTtcblxuICAgIGlmIChwZW5kaW5nTWVzc2FnZUNvdW50TWFwICE9IG51bGwpIHtcbiAgICAgIGlmIChtZXNzYWdlQ291bnRNYXAgPT0gbnVsbCkge1xuICAgICAgICBtZXNzYWdlQ291bnRNYXAgPSBwZW5kaW5nTWVzc2FnZUNvdW50TWFwO1xuICAgICAgICBmaWJlcklEVG9NZXNzYWdlQ291bnRNYXAuc2V0KGZpYmVySUQsIHBlbmRpbmdNZXNzYWdlQ291bnRNYXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBGbG93IHJlZmluZW1lbnQgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYW5kIHlldC4uLlxuICAgICAgICB2YXIgcmVmaW5lZE1lc3NhZ2VDb3VudE1hcCA9IG1lc3NhZ2VDb3VudE1hcDtcbiAgICAgICAgcGVuZGluZ01lc3NhZ2VDb3VudE1hcC5mb3JFYWNoKGZ1bmN0aW9uIChwZW5kaW5nQ291bnQsIG1lc3NhZ2UpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNDb3VudCA9IHJlZmluZWRNZXNzYWdlQ291bnRNYXAuZ2V0KG1lc3NhZ2UpIHx8IDA7XG4gICAgICAgICAgcmVmaW5lZE1lc3NhZ2VDb3VudE1hcC5zZXQobWVzc2FnZSwgcHJldmlvdXNDb3VudCArIHBlbmRpbmdDb3VudCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpKSB7XG4gICAgICBpZiAobWVzc2FnZUNvdW50TWFwICE9IG51bGwpIHtcbiAgICAgICAgbWVzc2FnZUNvdW50TWFwLmZvckVhY2goZnVuY3Rpb24gKGNvdW50KSB7XG4gICAgICAgICAgbmV3Q291bnQgKz0gY291bnQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBlbmRpbmdGaWJlclRvTWVzc2FnZUNvdW50TWFwLmRlbGV0ZShmaWJlcik7XG4gICAgcmV0dXJuIG5ld0NvdW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzKCkge1xuICAgIGNsZWFyUGVuZGluZ0Vycm9yc0FuZFdhcm5pbmdzQWZ0ZXJEZWxheSgpO1xuICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHZhciBmaWJlcklEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG5cbiAgICAgIGlmIChmaWJlcklEID09PSBudWxsKSB7Ly8gRG9uJ3Qgc2VuZCB1cGRhdGVzIGZvciBGaWJlcnMgdGhhdCBkaWRuJ3QgbW91bnQgZHVlIHRvIGUuZy4gU3VzcGVuc2Ugb3IgYW4gZXJyb3IgYm91bmRhcnkuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZXJyb3JDb3VudCA9IG1lcmdlTWFwc0FuZEdldENvdW50SGVscGVyKGZpYmVyLCBmaWJlcklELCBwZW5kaW5nRmliZXJUb0Vycm9yc01hcCwgZmliZXJJRFRvRXJyb3JzTWFwKTtcbiAgICAgICAgdmFyIHdhcm5pbmdDb3VudCA9IG1lcmdlTWFwc0FuZEdldENvdW50SGVscGVyKGZpYmVyLCBmaWJlcklELCBwZW5kaW5nRmliZXJUb1dhcm5pbmdzTWFwLCBmaWJlcklEVG9XYXJuaW5nc01hcCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fVVBEQVRFX0VSUk9SU19PUl9XQVJOSU5HUyk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oZmliZXJJRCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oZXJyb3JDb3VudCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24od2FybmluZ0NvdW50KTtcbiAgICAgIH0gLy8gQWx3YXlzIGNsZWFuIHVwIHNvIHRoYXQgd2UgZG9uJ3QgbGVhay5cblxuXG4gICAgICBwZW5kaW5nRmliZXJUb0Vycm9yc01hcC5kZWxldGUoZmliZXIpO1xuICAgICAgcGVuZGluZ0ZpYmVyVG9XYXJuaW5nc01hcC5kZWxldGUoZmliZXIpO1xuICAgIH0pO1xuICAgIGZpYmVyc1dpdGhDaGFuZ2VkRXJyb3JPcldhcm5pbmdDb3VudHMuY2xlYXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KSB7XG4gICAgLy8gQWRkIGFueSBwZW5kaW5nIGVycm9ycyBhbmQgd2FybmluZ3MgdG8gdGhlIG9wZXJhdGlvbnMgYXJyYXkuXG4gICAgLy8gV2UgZG8gdGhpcyBqdXN0IGJlZm9yZSBmbHVzaGluZywgc28gd2UgY2FuIGlnbm9yZSBlcnJvcnMgZm9yIG5vLWxvbmdlci1tb3VudGVkIEZpYmVycy5cbiAgICByZWNvcmRQZW5kaW5nRXJyb3JzQW5kV2FybmluZ3MoKTtcblxuICAgIGlmIChwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPT09IDAgJiYgcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoID09PSAwICYmIHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMubGVuZ3RoID09PSAwICYmIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGFyZW4ndCBwcm9maWxpbmcsIHdlIGNhbiBqdXN0IGJhaWwgb3V0IGhlcmUuXG4gICAgICAvLyBObyB1c2Ugc2VuZGluZyBhbiBlbXB0eSB1cGRhdGUgb3ZlciB0aGUgYnJpZGdlLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBQcm9maWxlciBzdG9yZXMgbWV0YWRhdGEgZm9yIGVhY2ggY29tbWl0IGFuZCByZWNvbnN0cnVjdHMgdGhlIGFwcCB0cmVlIHBlciBjb21taXQgdXNpbmc6XG4gICAgICAvLyAoMSkgYW4gaW5pdGlhbCB0cmVlIHNuYXBzaG90IGFuZFxuICAgICAgLy8gKDIpIHRoZSBvcGVyYXRpb25zIGFycmF5IGZvciBlYWNoIGNvbW1pdFxuICAgICAgLy8gQmVjYXVzZSBvZiB0aGlzLCBpdCdzIGltcG9ydGFudCB0aGF0IHRoZSBvcGVyYXRpb25zIGFuZCBtZXRhZGF0YSBhcnJheXMgYWxpZ24sXG4gICAgICAvLyBTbyBpdCdzIGltcG9ydGFudCBub3QgdG8gb21pdCBldmVuIGVtcHR5IG9wZXJhdGlvbnMgd2hpbGUgcHJvZmlsaW5nIGlzIGFjdGl2ZS5cbiAgICAgIGlmICghaXNQcm9maWxpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBudW1Vbm1vdW50SURzID0gcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoICsgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGggKyAocGVuZGluZ1VubW91bnRlZFJvb3RJRCA9PT0gbnVsbCA/IDAgOiAxKTtcbiAgICB2YXIgb3BlcmF0aW9ucyA9IG5ldyBBcnJheSggLy8gSWRlbnRpZnkgd2hpY2ggcmVuZGVyZXIgdGhpcyB1cGRhdGUgaXMgY29taW5nIGZyb20uXG4gICAgMiArIC8vIFtyZW5kZXJlcklELCByb290RmliZXJJRF1cbiAgICAvLyBIb3cgYmlnIGlzIHRoZSBzdHJpbmcgdGFibGU/XG4gICAgMSArIC8vIFtzdHJpbmdUYWJsZUxlbmd0aF1cbiAgICAvLyBUaGVuIGdvZXMgdGhlIGFjdHVhbCBzdHJpbmcgdGFibGUuXG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlTGVuZ3RoICsgKCAvLyBBbGwgdW5tb3VudHMgYXJlIGJhdGNoZWQgaW4gYSBzaW5nbGUgbWVzc2FnZS5cbiAgICAvLyBbVFJFRV9PUEVSQVRJT05fUkVNT1ZFLCByZW1vdmVkSURMZW5ndGgsIC4uLmlkc11cbiAgICBudW1Vbm1vdW50SURzID4gMCA/IDIgKyBudW1Vbm1vdW50SURzIDogMCkgKyAvLyBSZWd1bGFyIG9wZXJhdGlvbnNcbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgpOyAvLyBJZGVudGlmeSB3aGljaCByZW5kZXJlciB0aGlzIHVwZGF0ZSBpcyBjb21pbmcgZnJvbS5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcm9vdHMgdG8gYmUgbWFwcGVkIHRvIHJlbmRlcmVycyxcbiAgICAvLyBXaGljaCBpbiB0dXJuIGVuYWJsZXMgZmliZXIgcHJvcHMsIHN0YXRlcywgYW5kIGhvb2tzIHRvIGJlIGluc3BlY3RlZC5cblxuICAgIHZhciBpID0gMDtcbiAgICBvcGVyYXRpb25zW2krK10gPSByZW5kZXJlcklEO1xuICAgIG9wZXJhdGlvbnNbaSsrXSA9IGN1cnJlbnRSb290SUQ7IC8vIE5vdyBmaWxsIGluIHRoZSBzdHJpbmcgdGFibGUuXG4gICAgLy8gW3N0cmluZ1RhYmxlTGVuZ3RoLCBzdHIxTGVuZ3RoLCAuLi5zdHIxLCBzdHIyTGVuZ3RoLCAuLi5zdHIyLCAuLi5dXG5cbiAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGg7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IGtleS5sZW5ndGg7XG4gICAgICB2YXIgZW5jb2RlZEtleSA9IHV0ZkVuY29kZVN0cmluZyhrZXkpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVuY29kZWRLZXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpICsgal0gPSBlbmNvZGVkS2V5W2pdO1xuICAgICAgfVxuXG4gICAgICBpICs9IGtleS5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBpZiAobnVtVW5tb3VudElEcyA+IDApIHtcbiAgICAgIC8vIEFsbCB1bm1vdW50cyBleGNlcHQgcm9vdHMgYXJlIGJhdGNoZWQgaW4gYSBzaW5nbGUgbWVzc2FnZS5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IFRSRUVfT1BFUkFUSU9OX1JFTU9WRTsgLy8gVGhlIGZpcnN0IG51bWJlciBpcyBob3cgbWFueSB1bm1vdW50ZWQgSURzIHdlJ3JlIGdvbm5hIHNlbmQuXG5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IG51bVVubW91bnRJRHM7IC8vIEZpbGwgaW4gdGhlIHJlYWwgdW5tb3VudHMgaW4gdGhlIHJldmVyc2Ugb3JkZXIuXG4gICAgICAvLyBUaGV5IHdlcmUgaW5zZXJ0ZWQgcGFyZW50cy1maXJzdCBieSBSZWFjdCwgYnV0IHdlIHdhbnQgY2hpbGRyZW4tZmlyc3QuXG4gICAgICAvLyBTbyB3ZSB0cmF2ZXJzZSBvdXIgYXJyYXkgYmFja3dhcmRzLlxuXG4gICAgICBmb3IgKHZhciBqID0gcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpKytdID0gcGVuZGluZ1JlYWxVbm1vdW50ZWRJRHNbal07XG4gICAgICB9IC8vIEZpbGwgaW4gdGhlIHNpbXVsYXRlZCB1bm1vdW50cyAoaGlkZGVuIFN1c3BlbnNlIHN1YnRyZWVzKSBpbiB0aGVpciBvcmRlci5cbiAgICAgIC8vIChXZSB3YW50IGNoaWxkcmVuIHRvIGdvIGJlZm9yZSBwYXJlbnRzLilcbiAgICAgIC8vIFRoZXkgZ28gKmFmdGVyKiB0aGUgcmVhbCB1bm1vdW50cyBiZWNhdXNlIHdlIGtub3cgZm9yIHN1cmUgdGhleSB3b24ndCBiZVxuICAgICAgLy8gY2hpbGRyZW4gb2YgYWxyZWFkeSBwdXNoZWQgXCJyZWFsXCIgSURzLiBJZiB0aGV5IHdlcmUsIHdlIHdvdWxkbid0IGJlIGFibGVcbiAgICAgIC8vIHRvIGRpc2NvdmVyIHRoZW0gZHVyaW5nIHRoZSB0cmF2ZXJzYWwsIGFzIHRoZXkgd291bGQgaGF2ZSBiZWVuIGRlbGV0ZWQuXG5cblxuICAgICAgZm9yICh2YXIgX2ogPSAwOyBfaiA8IHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMubGVuZ3RoOyBfaisrKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaSArIF9qXSA9IHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHNbX2pdO1xuICAgICAgfVxuXG4gICAgICBpICs9IHBlbmRpbmdTaW11bGF0ZWRVbm1vdW50ZWRJRHMubGVuZ3RoOyAvLyBUaGUgcm9vdCBJRCBzaG91bGQgYWx3YXlzIGJlIHVubW91bnRlZCBsYXN0LlxuXG4gICAgICBpZiAocGVuZGluZ1VubW91bnRlZFJvb3RJRCAhPT0gbnVsbCkge1xuICAgICAgICBvcGVyYXRpb25zW2ldID0gcGVuZGluZ1VubW91bnRlZFJvb3RJRDtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH0gLy8gRmlsbCBpbiB0aGUgcmVzdCBvZiB0aGUgb3BlcmF0aW9ucy5cblxuXG4gICAgZm9yICh2YXIgX2oyID0gMDsgX2oyIDwgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoOyBfajIrKykge1xuICAgICAgb3BlcmF0aW9uc1tpICsgX2oyXSA9IHBlbmRpbmdPcGVyYXRpb25zW19qMl07XG4gICAgfVxuXG4gICAgaSArPSBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGg7IC8vIExldCB0aGUgZnJvbnRlbmQga25vdyBhYm91dCB0cmVlIG9wZXJhdGlvbnMuXG5cbiAgICBmbHVzaE9yUXVldWVPcGVyYXRpb25zKG9wZXJhdGlvbnMpOyAvLyBSZXNldCBhbGwgb2YgdGhlIHBlbmRpbmcgc3RhdGUgbm93IHRoYXQgd2UndmUgdG9sZCB0aGUgZnJvbnRlbmQgYWJvdXQgaXQuXG5cbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGggPSAwO1xuICAgIHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLmxlbmd0aCA9IDA7XG4gICAgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5sZW5ndGggPSAwO1xuICAgIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPSBudWxsO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5jbGVhcigpO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdJRChzdHIpIHtcbiAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgZXhpc3RpbmdJRCA9IHBlbmRpbmdTdHJpbmdUYWJsZS5nZXQoc3RyKTtcblxuICAgIGlmIChleGlzdGluZ0lEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0lEO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdJRCA9IHBlbmRpbmdTdHJpbmdUYWJsZS5zaXplICsgMTtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuc2V0KHN0ciwgc3RyaW5nSUQpOyAvLyBUaGUgc3RyaW5nIHRhYmxlIHRvdGFsIGxlbmd0aCBuZWVkcyB0byBhY2NvdW50XG4gICAgLy8gYm90aCBmb3IgdGhlIHN0cmluZyBsZW5ndGgsIGFuZCBmb3IgdGhlIGFycmF5IGl0ZW1cbiAgICAvLyB0aGF0IGNvbnRhaW5zIHRoZSBsZW5ndGggaXRzZWxmLiBIZW5jZSArIDEuXG5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKz0gc3RyLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIHN0cmluZ0lEO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkTW91bnQoZmliZXIsIHBhcmVudEZpYmVyKSB7XG4gICAgdmFyIGlzUm9vdCA9IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3Q7XG4gICAgdmFyIGlkID0gZ2V0T3JHZW5lcmF0ZUZpYmVySUQoZmliZXIpO1xuXG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgZGVidWcoJ3JlY29yZE1vdW50KCknLCBmaWJlciwgcGFyZW50RmliZXIpO1xuICAgIH1cblxuICAgIHZhciBoYXNPd25lck1ldGFkYXRhID0gZmliZXIuaGFzT3duUHJvcGVydHkoJ19kZWJ1Z093bmVyJyk7XG4gICAgdmFyIGlzUHJvZmlsaW5nU3VwcG9ydGVkID0gZmliZXIuaGFzT3duUHJvcGVydHkoJ3RyZWVCYXNlRHVyYXRpb24nKTtcblxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fQUREKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihFbGVtZW50VHlwZVJvb3QpO1xuICAgICAgcHVzaE9wZXJhdGlvbihpc1Byb2ZpbGluZ1N1cHBvcnRlZCA/IDEgOiAwKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaGFzT3duZXJNZXRhZGF0YSA/IDEgOiAwKTtcblxuICAgICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICAgIGlmIChkaXNwbGF5TmFtZXNCeVJvb3RJRCAhPT0gbnVsbCkge1xuICAgICAgICAgIGRpc3BsYXlOYW1lc0J5Um9vdElELnNldChpZCwgZ2V0RGlzcGxheU5hbWVGb3JSb290KGZpYmVyKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleSA9IGZpYmVyLmtleTtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgX2RlYnVnT3duZXIgPSBmaWJlci5fZGVidWdPd25lcjsgLy8gSWRlYWxseSB3ZSBzaG91bGQgY2FsbCBnZXRGaWJlcklEVGhyb3dzKCkgZm9yIF9kZWJ1Z093bmVyLFxuICAgICAgLy8gc2luY2Ugb3duZXJzIGFyZSBhbG1vc3QgYWx3YXlzIGhpZ2hlciBpbiB0aGUgdHJlZSAoYW5kIHNvIGhhdmUgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCksXG4gICAgICAvLyBidXQgaW4gc29tZSAocmFyZSkgaW5zdGFuY2VzIHJlcG9ydGVkIGluIG9wZW4gc291cmNlLCBhIGRlc2NlbmRhbnQgbW91bnRzIGJlZm9yZSBhbiBvd25lci5cbiAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBERVYgb25seSBmaWVsZCBpdCdzIHByb2JhYmx5IG9rYXkgdG8gYWxzbyBqdXN0IGxhemlseSBnZW5lcmF0ZSBhbmQgSUQgaGVyZSBpZiBuZWVkZWQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMTQ0NVxuXG4gICAgICB2YXIgb3duZXJJRCA9IF9kZWJ1Z093bmVyICE9IG51bGwgPyBnZXRPckdlbmVyYXRlRmliZXJJRChfZGVidWdPd25lcikgOiAwO1xuICAgICAgdmFyIHBhcmVudElEID0gcGFyZW50RmliZXIgPyBnZXRGaWJlcklEVGhyb3dzKHBhcmVudEZpYmVyKSA6IDA7XG4gICAgICB2YXIgZGlzcGxheU5hbWVTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGRpc3BsYXlOYW1lKTsgLy8gVGhpcyBjaGVjayBpcyBhIGd1YXJkIHRvIGhhbmRsZSBhIFJlYWN0IGVsZW1lbnQgdGhhdCBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgLy8gaW4gc3VjaCBhIHdheSBhcyB0byBieXBhc3MgdGhlIGRlZmF1bHQgc3RyaW5naWZpY2F0aW9uIG9mIHRoZSBcImtleVwiIHByb3BlcnR5LlxuXG4gICAgICB2YXIga2V5U3RyaW5nID0ga2V5ID09PSBudWxsID8gbnVsbCA6ICcnICsga2V5O1xuICAgICAgdmFyIGtleVN0cmluZ0lEID0gZ2V0U3RyaW5nSUQoa2V5U3RyaW5nKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fQUREKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihlbGVtZW50VHlwZSk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHBhcmVudElEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24ob3duZXJJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGRpc3BsYXlOYW1lU3RyaW5nSUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihrZXlTdHJpbmdJRCk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICBpZFRvUm9vdE1hcC5zZXQoaWQsIGN1cnJlbnRSb290SUQpO1xuICAgICAgcmVjb3JkUHJvZmlsaW5nRHVyYXRpb25zKGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRVbm1vdW50KGZpYmVyLCBpc1NpbXVsYXRlZCkge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdyZWNvcmRVbm1vdW50KCknLCBmaWJlciwgbnVsbCwgaXNTaW11bGF0ZWQgPyAndW5tb3VudCBpcyBzaW11bGF0ZWQnIDogJycpO1xuICAgIH1cblxuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIGluIHRoZSBwcm9jZXNzIG9mIHRyeWluZyB0byByZXN0b3JlIHByZXZpb3VzIHNlbGVjdGlvbi5cbiAgICAgIC8vIElmIHRoaXMgZmliZXIgbWF0Y2hlZCBidXQgaXMgYmVpbmcgdW5tb3VudGVkLCB0aGVyZSdzIG5vIHVzZSB0cnlpbmcuXG4gICAgICAvLyBSZXNldCB0aGUgc3RhdGUgc28gd2UgZG9uJ3Qga2VlcCBob2xkaW5nIG9udG8gaXQuXG4gICAgICBpZiAoZmliZXIgPT09IHRyYWNrZWRQYXRoTWF0Y2hGaWJlciB8fCBmaWJlciA9PT0gdHJhY2tlZFBhdGhNYXRjaEZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgICBzZXRUcmFja2VkUGF0aChudWxsKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdW5zYWZlSUQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcblxuICAgIGlmICh1bnNhZmVJRCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UndmUgbmV2ZXIgc2VlbiB0aGlzIEZpYmVyLCBpdCBtaWdodCBiZSBpbnNpZGUgb2YgYSBsZWdhY3kgcmVuZGVyIFN1c3BlbnNlIGZyYWdtZW50IChzbyB0aGUgc3RvcmUgaXMgbm90IGV2ZW4gYXdhcmUgb2YgaXQpLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IGlnbm9yZSBpdCBvciBpdCB3aWxsIGNhdXNlIGVycm9ycyBsYXRlciBvbi5cbiAgICAgIC8vIE9uZSBleGFtcGxlIG9mIHRoaXMgaXMgYSBMYXp5IGNvbXBvbmVudCB0aGF0IG5ldmVyIHJlc29sdmVzIGJlZm9yZSBiZWluZyB1bm1vdW50ZWQuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBhbHNvIG1pZ2h0IGluZGljYXRlIGEgRmFzdCBSZWZyZXNoIGZvcmNlLXJlbW91bnQgc2NlbmFyaW8uXG4gICAgICAvL1xuICAgICAgLy8gVE9ETzogVGhpcyBpcyBmcmFnaWxlIGFuZCBjYW4gb2JzY3VyZSBhY3R1YWwgYnVncy5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgcmVmaW5lbWVudC5cblxuXG4gICAgdmFyIGlkID0gdW5zYWZlSUQ7XG4gICAgdmFyIGlzUm9vdCA9IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3Q7XG5cbiAgICBpZiAoaXNSb290KSB7XG4gICAgICAvLyBSb290cyBtdXN0IGJlIHJlbW92ZWQgb25seSBhZnRlciBhbGwgY2hpbGRyZW4gKHBlbmRpbmcgYW5kIHNpbXVsYXRlZCkgaGF2ZSBiZWVuIHJlbW92ZWQuXG4gICAgICAvLyBTbyB3ZSB0cmFjayBpdCBzZXBhcmF0ZWx5LlxuICAgICAgcGVuZGluZ1VubW91bnRlZFJvb3RJRCA9IGlkO1xuICAgIH0gZWxzZSBpZiAoIXNob3VsZEZpbHRlckZpYmVyKGZpYmVyKSkge1xuICAgICAgLy8gVG8gbWFpbnRhaW4gY2hpbGQtZmlyc3Qgb3JkZXJpbmcsXG4gICAgICAvLyB3ZSdsbCBwdXNoIGl0IGludG8gb25lIG9mIHRoZXNlIHF1ZXVlcyxcbiAgICAgIC8vIGFuZCBsYXRlciBhcnJhbmdlIHRoZW0gaW4gdGhlIGNvcnJlY3Qgb3JkZXIuXG4gICAgICBpZiAoaXNTaW11bGF0ZWQpIHtcbiAgICAgICAgcGVuZGluZ1NpbXVsYXRlZFVubW91bnRlZElEcy5wdXNoKGlkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdSZWFsVW5tb3VudGVkSURzLnB1c2goaWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghZmliZXIuX2RlYnVnTmVlZHNSZW1vdW50KSB7XG4gICAgICB1bnRyYWNrRmliZXJJRChmaWJlcik7XG4gICAgICB2YXIgaXNQcm9maWxpbmdTdXBwb3J0ZWQgPSBmaWJlci5oYXNPd25Qcm9wZXJ0eSgndHJlZUJhc2VEdXJhdGlvbicpO1xuXG4gICAgICBpZiAoaXNQcm9maWxpbmdTdXBwb3J0ZWQpIHtcbiAgICAgICAgaWRUb1Jvb3RNYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgaWRUb1RyZWVCYXNlRHVyYXRpb25NYXAuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEZpYmVyUmVjdXJzaXZlbHkoZmlyc3RDaGlsZCwgcGFyZW50RmliZXIsIHRyYXZlcnNlU2libGluZ3MsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgc2libGluZ3MgcmF0aGVyIHRoYW4gcmVjdXJzaW5nLlxuICAgIC8vIFRoaXMgcmVkdWNlcyB0aGUgY2hhbmNlIG9mIHN0YWNrIG92ZXJmbG93IGZvciB3aWRlIHRyZWVzIChlLmcuIGxpc3RzIHdpdGggbWFueSBpdGVtcykuXG4gICAgdmFyIGZpYmVyID0gZmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgLy8gR2VuZXJhdGUgYW4gSUQgZXZlbiBmb3IgZmlsdGVyZWQgRmliZXJzLCBpbiBjYXNlIGl0J3MgbmVlZGVkIGxhdGVyIChlLmcuIGZvciBQcm9maWxpbmcpLlxuICAgICAgZ2V0T3JHZW5lcmF0ZUZpYmVySUQoZmliZXIpO1xuXG4gICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgIGRlYnVnKCdtb3VudEZpYmVyUmVjdXJzaXZlbHkoKScsIGZpYmVyLCBwYXJlbnRGaWJlcik7XG4gICAgICB9IC8vIElmIHdlIGhhdmUgdGhlIHRyZWUgc2VsZWN0aW9uIGZyb20gcHJldmlvdXMgcmVsb2FkLCB0cnkgdG8gbWF0Y2ggdGhpcyBGaWJlci5cbiAgICAgIC8vIEFsc28gcmVtZW1iZXIgd2hldGhlciB0byBkbyB0aGUgc2FtZSBmb3Igc2libGluZ3MuXG5cblxuICAgICAgdmFyIG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGggPSB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoZmliZXIpO1xuICAgICAgdmFyIHNob3VsZEluY2x1ZGVJblRyZWUgPSAhc2hvdWxkRmlsdGVyRmliZXIoZmliZXIpO1xuXG4gICAgICBpZiAoc2hvdWxkSW5jbHVkZUluVHJlZSkge1xuICAgICAgICByZWNvcmRNb3VudChmaWJlciwgcGFyZW50RmliZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgICBpZiAodHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpOyAvLyBJZiBhbiBhbmNlc3RvciB1cGRhdGVkLCB3ZSBzaG91bGQgbWFyayB0aGUgbmVhcmVzdCBob3N0IG5vZGVzIGZvciBoaWdobGlnaHRpbmcuXG5cbiAgICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCkge1xuICAgICAgICAgICAgdHJhY2VVcGRhdGVzRm9yTm9kZXMuYWRkKGZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFdlIGludGVudGlvbmFsbHkgZG8gbm90IHJlLWVuYWJsZSB0aGUgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSBmbGFnIGluIHRoaXMgYnJhbmNoLFxuICAgICAgICAvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gaGlnaGxpZ2h0IGV2ZXJ5IGhvc3Qgbm9kZSBpbnNpZGUgb2YgYSBuZXdseSBtb3VudGVkIHN1YnRyZWUuXG5cbiAgICAgIH1cblxuICAgICAgdmFyIGlzU3VzcGVuc2UgPSBmaWJlci50YWcgPT09IFJlYWN0VHlwZU9mV29yay5TdXNwZW5zZUNvbXBvbmVudDtcblxuICAgICAgaWYgKGlzU3VzcGVuc2UpIHtcbiAgICAgICAgdmFyIGlzVGltZWRPdXQgPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc1RpbWVkT3V0KSB7XG4gICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBpZiBTdXNwZW5zZSBtb3VudHMgaW4gYSB0aW1lZC1vdXQgc3RhdGUsXG4gICAgICAgICAgLy8gZ2V0IHRoZSBmYWxsYmFjayBjaGlsZCBmcm9tIHRoZSBpbm5lciBmcmFnbWVudCBhbmQgbW91bnRcbiAgICAgICAgICAvLyBpdCBhcyBpZiBpdCB3YXMgb3VyIG93biBjaGlsZC4gVXBkYXRlcyBoYW5kbGUgdGhpcyB0b28uXG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHByaW1hcnlDaGlsZEZyYWdtZW50ID8gcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA6IG51bGw7XG4gICAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGQgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPyBmYWxsYmFja0NoaWxkRnJhZ21lbnQuY2hpbGQgOiBudWxsO1xuXG4gICAgICAgICAgaWYgKGZhbGxiYWNrQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShmYWxsYmFja0NoaWxkLCBzaG91bGRJbmNsdWRlSW5UcmVlID8gZmliZXIgOiBwYXJlbnRGaWJlciwgdHJ1ZSwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGQgPSBudWxsO1xuICAgICAgICAgIHZhciBhcmVTdXNwZW5zZUNoaWxkcmVuQ29uZGl0aW9uYWxseVdyYXBwZWQgPSBPZmZzY3JlZW5Db21wb25lbnQgPT09IC0xO1xuXG4gICAgICAgICAgaWYgKGFyZVN1c3BlbnNlQ2hpbGRyZW5Db25kaXRpb25hbGx5V3JhcHBlZCkge1xuICAgICAgICAgICAgcHJpbWFyeUNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWJlci5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJpbWFyeUNoaWxkID0gZmliZXIuY2hpbGQuY2hpbGQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHByaW1hcnlDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KHByaW1hcnlDaGlsZCwgc2hvdWxkSW5jbHVkZUluVHJlZSA/IGZpYmVyIDogcGFyZW50RmliZXIsIHRydWUsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZpYmVyLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGZpYmVyLmNoaWxkLCBzaG91bGRJbmNsdWRlSW5UcmVlID8gZmliZXIgOiBwYXJlbnRGaWJlciwgdHJ1ZSwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2UncmUgZXhpdGluZyB0aGlzIEZpYmVyIG5vdywgYW5kIGVudGVyaW5nIGl0cyBzaWJsaW5ncy5cbiAgICAgIC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIHRvIHJlc3RvcmUsIHdlIG1pZ2h0IG5lZWQgdG8gcmUtYWN0aXZhdGUgdHJhY2tpbmcuXG5cblxuICAgICAgdXBkYXRlVHJhY2tlZFBhdGhTdGF0ZUFmdGVyTW91bnQobWlnaHRTaWJsaW5nc0JlT25UcmFja2VkUGF0aCk7XG4gICAgICBmaWJlciA9IHRyYXZlcnNlU2libGluZ3MgPyBmaWJlci5zaWJsaW5nIDogbnVsbDtcbiAgICB9XG4gIH0gLy8gV2UgdXNlIHRoaXMgdG8gc2ltdWxhdGUgdW5tb3VudGluZyBmb3IgU3VzcGVuc2UgdHJlZXNcbiAgLy8gd2hlbiB3ZSBzd2l0Y2ggZnJvbSBwcmltYXJ5IHRvIGZhbGxiYWNrLlxuXG5cbiAgZnVuY3Rpb24gdW5tb3VudEZpYmVyQ2hpbGRyZW5SZWN1cnNpdmVseShmaWJlcikge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCd1bm1vdW50RmliZXJDaGlsZHJlblJlY3Vyc2l2ZWx5KCknLCBmaWJlcik7XG4gICAgfSAvLyBXZSBtaWdodCBtZWV0IGEgbmVzdGVkIFN1c3BlbnNlIG9uIG91ciB3YXkuXG5cblxuICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBmaWJlci50YWcgPT09IFJlYWN0VHlwZU9mV29yay5TdXNwZW5zZUNvbXBvbmVudCAmJiBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKGlzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgLy8gSWYgaXQncyBzaG93aW5nIGZhbGxiYWNrIHRyZWUsIGxldCdzIHRyYXZlcnNlIGl0IGluc3RlYWQuXG4gICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudCA/IHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgOiBudWxsOyAvLyBTa2lwIG92ZXIgdG8gdGhlIHJlYWwgRmliZXIgY2hpbGQuXG5cbiAgICAgIGNoaWxkID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50ID8gZmFsbGJhY2tDaGlsZEZyYWdtZW50LmNoaWxkIDogbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFJlY29yZCBzaW11bGF0ZWQgdW5tb3VudHMgY2hpbGRyZW4tZmlyc3QuXG4gICAgICAvLyBXZSBza2lwIG5vZGVzIHdpdGhvdXQgcmV0dXJuIGJlY2F1c2UgdGhvc2UgYXJlIHJlYWwgdW5tb3VudHMuXG4gICAgICBpZiAoY2hpbGQucmV0dXJuICE9PSBudWxsKSB7XG4gICAgICAgIHVubW91bnRGaWJlckNoaWxkcmVuUmVjdXJzaXZlbHkoY2hpbGQpO1xuICAgICAgICByZWNvcmRVbm1vdW50KGNoaWxkLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29yZFByb2ZpbGluZ0R1cmF0aW9ucyhmaWJlcikge1xuICAgIHZhciBpZCA9IGdldEZpYmVySURUaHJvd3MoZmliZXIpO1xuICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGZpYmVyLmFjdHVhbER1cmF0aW9uLFxuICAgICAgICB0cmVlQmFzZUR1cmF0aW9uID0gZmliZXIudHJlZUJhc2VEdXJhdGlvbjtcbiAgICBpZFRvVHJlZUJhc2VEdXJhdGlvbk1hcC5zZXQoaWQsIHRyZWVCYXNlRHVyYXRpb24gfHwgMCk7XG5cbiAgICBpZiAoaXNQcm9maWxpbmcpIHtcbiAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7IC8vIEl0J3MgaW1wb3J0YW50IHRvIHVwZGF0ZSB0cmVlQmFzZUR1cmF0aW9uIGV2ZW4gaWYgdGhlIGN1cnJlbnQgRmliZXIgZGlkIG5vdCByZW5kZXIsXG4gICAgICAvLyBiZWNhdXNlIGl0J3MgcG9zc2libGUgdGhhdCBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGRpZC5cblxuICAgICAgaWYgKGFsdGVybmF0ZSA9PSBudWxsIHx8IHRyZWVCYXNlRHVyYXRpb24gIT09IGFsdGVybmF0ZS50cmVlQmFzZUR1cmF0aW9uKSB7XG4gICAgICAgIC8vIFRyZWUgYmFzZSBkdXJhdGlvbiB1cGRhdGVzIGFyZSBpbmNsdWRlZCBpbiB0aGUgb3BlcmF0aW9ucyB0eXBlZCBhcnJheS5cbiAgICAgICAgLy8gU28gd2UgaGF2ZSB0byBjb252ZXJ0IHRoZW0gZnJvbSBtaWxsaXNlY29uZHMgdG8gbWljcm9zZWNvbmRzIHNvIHdlIGNhbiBzZW5kIHRoZW0gYXMgaW50cy5cbiAgICAgICAgdmFyIGNvbnZlcnRlZFRyZWVCYXNlRHVyYXRpb24gPSBNYXRoLmZsb29yKCh0cmVlQmFzZUR1cmF0aW9uIHx8IDApICogMTAwMCk7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fVVBEQVRFX1RSRUVfQkFTRV9EVVJBVElPTik7XG4gICAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgICBwdXNoT3BlcmF0aW9uKGNvbnZlcnRlZFRyZWVCYXNlRHVyYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWx0ZXJuYXRlID09IG51bGwgfHwgZGlkRmliZXJSZW5kZXIoYWx0ZXJuYXRlLCBmaWJlcikpIHtcbiAgICAgICAgaWYgKGFjdHVhbER1cmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBUaGUgYWN0dWFsIGR1cmF0aW9uIHJlcG9ydGVkIGJ5IFJlYWN0IGluY2x1ZGVzIHRpbWUgc3BlbnQgd29ya2luZyBvbiBjaGlsZHJlbi5cbiAgICAgICAgICAvLyBUaGlzIGlzIHVzZWZ1bCBpbmZvcm1hdGlvbiwgYnV0IGl0J3MgYWxzbyB1c2VmdWwgdG8gYmUgYWJsZSB0byBleGNsdWRlIGNoaWxkIGR1cmF0aW9ucy5cbiAgICAgICAgICAvLyBUaGUgZnJvbnRlbmQgY2FuJ3QgY29tcHV0ZSB0aGlzLCBzaW5jZSB0aGUgaW1tZWRpYXRlIGNoaWxkcmVuIG1heSBoYXZlIGJlZW4gZmlsdGVyZWQgb3V0LlxuICAgICAgICAgIC8vIFNvIHdlIG5lZWQgdG8gZG8gdGhpcyBvbiB0aGUgYmFja2VuZC5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBjYWxjdWxhdGVkIHNlbGYgZHVyYXRpb24gaXMgbm90IHRoZSBzYW1lIHRoaW5nIGFzIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgIC8vIFRoZSB0d28gYXJlIGNhbGN1bGF0ZWQgZGlmZmVyZW50bHkgKHRyZWUgZHVyYXRpb24gZG9lcyBub3QgYWNjdW11bGF0ZSkuXG4gICAgICAgICAgdmFyIHNlbGZEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgICAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZWxmRHVyYXRpb24gLT0gY2hpbGQuYWN0dWFsRHVyYXRpb24gfHwgMDtcbiAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgICB9IC8vIElmIHByb2ZpbGluZyBpcyBhY3RpdmUsIHN0b3JlIGR1cmF0aW9ucyBmb3IgZWxlbWVudHMgdGhhdCB3ZXJlIHJlbmRlcmVkIGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB3ZSBzaG91bGQgZG8gdGhpcyBmb3IgYW55IGZpYmVyIHdlIHBlcmZvcm1lZCB3b3JrIG9uLCByZWdhcmRsZXNzIG9mIGl0cyBhY3R1YWxEdXJhdGlvbiB2YWx1ZS5cbiAgICAgICAgICAvLyBJbiBzb21lIGNhc2VzIGFjdHVhbER1cmF0aW9uIG1pZ2h0IGJlIDAgZm9yIGZpYmVycyB3ZSB3b3JrZWQgb24gKHBhcnRpY3VsYXJseSBpZiB3ZSdyZSB1c2luZyBEYXRlLm5vdylcbiAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcyAoZS5nLiBNZW1vKSBhY3R1YWxEdXJhdGlvbiBtaWdodCBiZSBncmVhdGVyIHRoYW4gMCBldmVuIGlmIHdlIFwiYmFpbGVkIG91dFwiLlxuXG5cbiAgICAgICAgICB2YXIgbWV0YWRhdGEgPSBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGE7XG4gICAgICAgICAgbWV0YWRhdGEuZHVyYXRpb25zLnB1c2goaWQsIGFjdHVhbER1cmF0aW9uLCBzZWxmRHVyYXRpb24pO1xuICAgICAgICAgIG1ldGFkYXRhLm1heEFjdHVhbER1cmF0aW9uID0gTWF0aC5tYXgobWV0YWRhdGEubWF4QWN0dWFsRHVyYXRpb24sIGFjdHVhbER1cmF0aW9uKTtcblxuICAgICAgICAgIGlmIChyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VEZXNjcmlwdGlvbiA9IGdldENoYW5nZURlc2NyaXB0aW9uKGFsdGVybmF0ZSwgZmliZXIpO1xuXG4gICAgICAgICAgICBpZiAoY2hhbmdlRGVzY3JpcHRpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmNoYW5nZURlc2NyaXB0aW9ucy5zZXQoaWQsIGNoYW5nZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVDb250ZXh0c0ZvckZpYmVyKGZpYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRSZXNldENoaWxkcmVuKGZpYmVyLCBjaGlsZFNldCkge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGRlYnVnKCdyZWNvcmRSZXNldENoaWxkcmVuKCknLCBjaGlsZFNldCwgZmliZXIpO1xuICAgIH0gLy8gVGhlIGZyb250ZW5kIG9ubHkgcmVhbGx5IGNhcmVzIGFib3V0IHRoZSBkaXNwbGF5TmFtZSwga2V5LCBhbmQgY2hpbGRyZW4uXG4gICAgLy8gVGhlIGZpcnN0IHR3byBkb24ndCByZWFsbHkgY2hhbmdlLCBzbyB3ZSBhcmUgb25seSBjb25jZXJuZWQgd2l0aCB0aGUgb3JkZXIgb2YgY2hpbGRyZW4gaGVyZS5cbiAgICAvLyBUaGlzIGlzIHRyaWNraWVyIHRoYW4gYSBzaW1wbGUgY29tcGFyaXNvbiB0aG91Z2gsIHNpbmNlIGNlcnRhaW4gdHlwZXMgb2YgZmliZXJzIGFyZSBmaWx0ZXJlZC5cblxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IFtdOyAvLyBUaGlzIGlzIGEgbmFpdmUgaW1wbGVtZW50YXRpb24gdGhhdCBzaGFsbG93bHkgcmVjb3Vyc2VzIGNoaWxkcmVuLlxuICAgIC8vIFdlIG1pZ2h0IHdhbnQgdG8gcmV2aXNpdCB0aGlzIGlmIGl0IHByb3ZlcyB0byBiZSB0b28gaW5lZmZpY2llbnQuXG5cbiAgICB2YXIgY2hpbGQgPSBjaGlsZFNldDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgZmluZFJlb3JkZXJlZENoaWxkcmVuUmVjdXJzaXZlbHkoY2hpbGQsIG5leHRDaGlsZHJlbik7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIG51bUNoaWxkcmVuID0gbmV4dENoaWxkcmVuLmxlbmd0aDtcblxuICAgIGlmIChudW1DaGlsZHJlbiA8IDIpIHtcbiAgICAgIC8vIE5vIG5lZWQgdG8gcmVvcmRlci5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwdXNoT3BlcmF0aW9uKFRSRUVfT1BFUkFUSU9OX1JFT1JERVJfQ0hJTERSRU4pO1xuICAgIHB1c2hPcGVyYXRpb24oZ2V0RmliZXJJRFRocm93cyhmaWJlcikpO1xuICAgIHB1c2hPcGVyYXRpb24obnVtQ2hpbGRyZW4pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXh0Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHB1c2hPcGVyYXRpb24obmV4dENoaWxkcmVuW2ldKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kUmVvcmRlcmVkQ2hpbGRyZW5SZWN1cnNpdmVseShmaWJlciwgbmV4dENoaWxkcmVuKSB7XG4gICAgaWYgKCFzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgIG5leHRDaGlsZHJlbi5wdXNoKGdldEZpYmVySURUaHJvd3MoZmliZXIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgaXNUaW1lZE91dFN1c3BlbnNlID0gZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogaWYgU3VzcGVuc2UgbW91bnRzIGluIGEgdGltZWQtb3V0IHN0YXRlLFxuICAgICAgICAvLyBnZXQgdGhlIGZhbGxiYWNrIGNoaWxkIGZyb20gdGhlIGlubmVyIGZyYWdtZW50LFxuICAgICAgICAvLyBhbmQgc2tpcCBvdmVyIHRoZSBwcmltYXJ5IGNoaWxkLlxuICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBmaWJlci5jaGlsZDtcbiAgICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IHByaW1hcnlDaGlsZEZyYWdtZW50ID8gcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA6IG51bGw7XG4gICAgICAgIHZhciBmYWxsYmFja0NoaWxkID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50ID8gZmFsbGJhY2tDaGlsZEZyYWdtZW50LmNoaWxkIDogbnVsbDtcblxuICAgICAgICBpZiAoZmFsbGJhY2tDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkID0gZmFsbGJhY2tDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmluZFJlb3JkZXJlZENoaWxkcmVuUmVjdXJzaXZlbHkoY2hpbGQsIG5leHRDaGlsZHJlbik7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmV0dXJucyB3aGV0aGVyIGNsb3Nlc3QgdW5maWx0ZXJlZCBmaWJlciBwYXJlbnQgbmVlZHMgdG8gcmVzZXQgaXRzIGNoaWxkIGxpc3QuXG5cblxuICBmdW5jdGlvbiB1cGRhdGVGaWJlclJlY3Vyc2l2ZWx5KG5leHRGaWJlciwgcHJldkZpYmVyLCBwYXJlbnRGaWJlciwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkge1xuICAgIHZhciBpZCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKG5leHRGaWJlcik7XG5cbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBkZWJ1ZygndXBkYXRlRmliZXJSZWN1cnNpdmVseSgpJywgbmV4dEZpYmVyLCBwYXJlbnRGaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgIHZhciBlbGVtZW50VHlwZSA9IGdldEVsZW1lbnRUeXBlRm9yRmliZXIobmV4dEZpYmVyKTtcblxuICAgICAgaWYgKHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgLy8gSWYgYW4gYW5jZXN0b3IgdXBkYXRlZCwgd2Ugc2hvdWxkIG1hcmsgdGhlIG5lYXJlc3QgaG9zdCBub2RlcyBmb3IgaGlnaGxpZ2h0aW5nLlxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlSG9zdENvbXBvbmVudCkge1xuICAgICAgICAgIHRyYWNlVXBkYXRlc0Zvck5vZGVzLmFkZChuZXh0RmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVGdW5jdGlvbiB8fCBlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVDbGFzcyB8fCBlbGVtZW50VHlwZSA9PT0gRWxlbWVudFR5cGVDb250ZXh0IHx8IGVsZW1lbnRUeXBlID09PSBFbGVtZW50VHlwZU1lbW8gfHwgZWxlbWVudFR5cGUgPT09IEVsZW1lbnRUeXBlRm9yd2FyZFJlZikge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBpZiB0aGlzIGlzIGEgdHJhY2VkIGFuY2VzdG9yLCBmbGFnIGZvciB0aGUgbmVhcmVzdCBob3N0IGRlc2NlbmRhbnQocykuXG4gICAgICAgICAgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSA9IGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgbmV4dEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsICYmIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQuaWQgPT09IGlkICYmIGRpZEZpYmVyUmVuZGVyKHByZXZGaWJlciwgbmV4dEZpYmVyKSkge1xuICAgICAgLy8gSWYgdGhpcyBGaWJlciBoYXMgdXBkYXRlZCwgY2xlYXIgY2FjaGVkIGluc3BlY3RlZCBkYXRhLlxuICAgICAgLy8gSWYgaXQgaXMgaW5zcGVjdGVkIGFnYWluLCBpdCBtYXkgbmVlZCB0byBiZSByZS1ydW4gdG8gb2J0YWluIHVwZGF0ZWQgaG9va3MgdmFsdWVzLlxuICAgICAgaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRJbmNsdWRlSW5UcmVlID0gIXNob3VsZEZpbHRlckZpYmVyKG5leHRGaWJlcik7XG4gICAgdmFyIGlzU3VzcGVuc2UgPSBuZXh0RmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudDtcbiAgICB2YXIgc2hvdWxkUmVzZXRDaGlsZHJlbiA9IGZhbHNlOyAvLyBUaGUgYmVoYXZpb3Igb2YgdGltZWQtb3V0IFN1c3BlbnNlIHRyZWVzIGlzIHVuaXF1ZS5cbiAgICAvLyBSYXRoZXIgdGhhbiB1bm1vdW50IHRoZSB0aW1lZCBvdXQgY29udGVudCAoYW5kIHBvc3NpYmx5IGxvc2UgaW1wb3J0YW50IHN0YXRlKSxcbiAgICAvLyBSZWFjdCByZS1wYXJlbnRzIHRoaXMgY29udGVudCB3aXRoaW4gYSBoaWRkZW4gRnJhZ21lbnQgd2hpbGUgdGhlIGZhbGxiYWNrIGlzIHNob3dpbmcuXG4gICAgLy8gVGhpcyBiZWhhdmlvciBkb2Vzbid0IG5lZWQgdG8gYmUgb2JzZXJ2YWJsZSBpbiB0aGUgRGV2VG9vbHMgdGhvdWdoLlxuICAgIC8vIEl0IG1pZ2h0IGV2ZW4gcmVzdWx0IGluIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSBmb3IgZS5nLiBub2RlIHNlbGVjdGlvbiBpbiB0aGUgRWxlbWVudHMgcGFuZWwuXG4gICAgLy8gVGhlIGVhc2llc3QgZml4IGlzIHRvIHN0cmlwIG91dCB0aGUgaW50ZXJtZWRpYXRlIEZyYWdtZW50IGZpYmVycyxcbiAgICAvLyBzbyB0aGUgRWxlbWVudHMgcGFuZWwgYW5kIFByb2ZpbGVyIGRvbid0IG5lZWQgdG8gc3BlY2lhbCBjYXNlIHRoZW0uXG4gICAgLy8gU3VzcGVuc2UgY29tcG9uZW50cyBvbmx5IGhhdmUgYSBub24tbnVsbCBtZW1vaXplZFN0YXRlIGlmIHRoZXkncmUgdGltZWQtb3V0LlxuXG4gICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gaXNTdXNwZW5zZSAmJiBwcmV2RmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICB2YXIgbmV4dERpZFRpbWVPdXQgPSBpc1N1c3BlbnNlICYmIG5leHRGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsOyAvLyBUaGUgbG9naWMgYmVsb3cgaXMgaW5zcGlyZWQgYnkgdGhlIGNvZGUgcGF0aHMgaW4gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoKVxuICAgIC8vIGluc2lkZSBSZWFjdEZpYmVyQmVnaW5Xb3JrIGluIHRoZSBSZWFjdCBzb3VyY2UgY29kZS5cblxuICAgIGlmIChwcmV2RGlkVGltZW91dCAmJiBuZXh0RGlkVGltZU91dCkge1xuICAgICAgLy8gRmFsbGJhY2sgLT4gRmFsbGJhY2s6XG4gICAgICAvLyAxLiBSZWNvbmNpbGUgZmFsbGJhY2sgc2V0LlxuICAgICAgdmFyIG5leHRGaWJlckNoaWxkID0gbmV4dEZpYmVyLmNoaWxkO1xuICAgICAgdmFyIG5leHRGYWxsYmFja0NoaWxkU2V0ID0gbmV4dEZpYmVyQ2hpbGQgPyBuZXh0RmliZXJDaGlsZC5zaWJsaW5nIDogbnVsbDsgLy8gTm90ZTogV2UgY2FuJ3QgdXNlIG5leHRGaWJlci5jaGlsZC5zaWJsaW5nLmFsdGVybmF0ZVxuICAgICAgLy8gYmVjYXVzZSB0aGUgc2V0IGlzIHNwZWNpYWwgYW5kIGFsdGVybmF0ZSBtYXkgbm90IGV4aXN0LlxuXG4gICAgICB2YXIgcHJldkZpYmVyQ2hpbGQgPSBwcmV2RmliZXIuY2hpbGQ7XG4gICAgICB2YXIgcHJldkZhbGxiYWNrQ2hpbGRTZXQgPSBwcmV2RmliZXJDaGlsZCA/IHByZXZGaWJlckNoaWxkLnNpYmxpbmcgOiBudWxsO1xuXG4gICAgICBpZiAobmV4dEZhbGxiYWNrQ2hpbGRTZXQgIT0gbnVsbCAmJiBwcmV2RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsICYmIHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkobmV4dEZhbGxiYWNrQ2hpbGRTZXQsIHByZXZGYWxsYmFja0NoaWxkU2V0LCBuZXh0RmliZXIsIHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpKSB7XG4gICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJldkRpZFRpbWVvdXQgJiYgIW5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBGYWxsYmFjayAtPiBQcmltYXJ5OlxuICAgICAgLy8gMS4gVW5tb3VudCBmYWxsYmFjayBzZXRcbiAgICAgIC8vIE5vdGU6IGRvbid0IGVtdWxhdGUgZmFsbGJhY2sgdW5tb3VudCBiZWNhdXNlIFJlYWN0IGFjdHVhbGx5IGRpZCBpdC5cbiAgICAgIC8vIDIuIE1vdW50IHByaW1hcnkgc2V0XG4gICAgICB2YXIgbmV4dFByaW1hcnlDaGlsZFNldCA9IG5leHRGaWJlci5jaGlsZDtcblxuICAgICAgaWYgKG5leHRQcmltYXJ5Q2hpbGRTZXQgIT09IG51bGwpIHtcbiAgICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KG5leHRQcmltYXJ5Q2hpbGRTZXQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlciwgdHJ1ZSwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoIXByZXZEaWRUaW1lb3V0ICYmIG5leHREaWRUaW1lT3V0KSB7XG4gICAgICAvLyBQcmltYXJ5IC0+IEZhbGxiYWNrOlxuICAgICAgLy8gMS4gSGlkZSBwcmltYXJ5IHNldFxuICAgICAgLy8gVGhpcyBpcyBub3QgYSByZWFsIHVubW91bnQsIHNvIGl0IHdvbid0IGdldCByZXBvcnRlZCBieSBSZWFjdC5cbiAgICAgIC8vIFdlIG5lZWQgdG8gbWFudWFsbHkgd2FsayB0aGUgcHJldmlvdXMgdHJlZSBhbmQgcmVjb3JkIHVubW91bnRzLlxuICAgICAgdW5tb3VudEZpYmVyQ2hpbGRyZW5SZWN1cnNpdmVseShwcmV2RmliZXIpOyAvLyAyLiBNb3VudCBmYWxsYmFjayBzZXRcblxuICAgICAgdmFyIF9uZXh0RmliZXJDaGlsZCA9IG5leHRGaWJlci5jaGlsZDtcblxuICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZFNldCA9IF9uZXh0RmliZXJDaGlsZCA/IF9uZXh0RmliZXJDaGlsZC5zaWJsaW5nIDogbnVsbDtcblxuICAgICAgaWYgKF9uZXh0RmFsbGJhY2tDaGlsZFNldCAhPSBudWxsKSB7XG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShfbmV4dEZhbGxiYWNrQ2hpbGRTZXQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlciwgdHJ1ZSwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSk7XG4gICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb21tb24gY2FzZTogUHJpbWFyeSAtPiBQcmltYXJ5LlxuICAgICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBjb2RlIHBhdGggYXMgZm9yIG5vbi1TdXNwZW5zZSBmaWJlcnMuXG4gICAgICBpZiAobmV4dEZpYmVyLmNoaWxkICE9PSBwcmV2RmliZXIuY2hpbGQpIHtcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGNoaWxkIGlzIGRpZmZlcmVudCwgd2UgbmVlZCB0byB0cmF2ZXJzZSB0aGVtLlxuICAgICAgICAvLyBFYWNoIG5leHQgY2hpbGQgd2lsbCBiZSBlaXRoZXIgYSBuZXcgY2hpbGQgKG1vdW50KSBvciBhbiBhbHRlcm5hdGUgKHVwZGF0ZSkuXG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0RmliZXIuY2hpbGQ7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRBdFNhbWVJbmRleCA9IHByZXZGaWJlci5jaGlsZDtcblxuICAgICAgICB3aGlsZSAobmV4dENoaWxkKSB7XG4gICAgICAgICAgLy8gV2UgYWxyZWFkeSBrbm93IGNoaWxkcmVuIHdpbGwgYmUgcmVmZXJlbnRpYWxseSBkaWZmZXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZXkgYXJlIGVpdGhlciBuZXcgbW91bnRzIG9yIGFsdGVybmF0ZXMgb2YgcHJldmlvdXMgY2hpbGRyZW4uXG4gICAgICAgICAgLy8gU2NoZWR1bGUgdXBkYXRlcyBhbmQgbW91bnRzIGRlcGVuZGluZyBvbiB3aGV0aGVyIGFsdGVybmF0ZXMgZXhpc3QuXG4gICAgICAgICAgLy8gV2UgZG9uJ3QgdHJhY2sgZGVsZXRpb25zIGhlcmUgYmVjYXVzZSB0aGV5IGFyZSByZXBvcnRlZCBzZXBhcmF0ZWx5LlxuICAgICAgICAgIGlmIChuZXh0Q2hpbGQuYWx0ZXJuYXRlKSB7XG4gICAgICAgICAgICB2YXIgcHJldkNoaWxkID0gbmV4dENoaWxkLmFsdGVybmF0ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZUZpYmVyUmVjdXJzaXZlbHkobmV4dENoaWxkLCBwcmV2Q2hpbGQsIHNob3VsZEluY2x1ZGVJblRyZWUgPyBuZXh0RmliZXIgOiBwYXJlbnRGaWJlciwgdHJhY2VOZWFyZXN0SG9zdENvbXBvbmVudFVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYSBuZXN0ZWQgdHJlZSBjaGlsZCBvcmRlciBjaGFuZ2VkIGJ1dCBpdCBjYW4ndCBoYW5kbGUgaXRzIG93blxuICAgICAgICAgICAgICAvLyBjaGlsZCBvcmRlciBpbnZhbGlkYXRpb24gKGUuZy4gYmVjYXVzZSBpdCdzIGZpbHRlcmVkIG91dCBsaWtlIGhvc3Qgbm9kZXMpLFxuICAgICAgICAgICAgICAvLyBwcm9wYWdhdGUgdGhlIG5lZWQgdG8gcmVzZXQgY2hpbGQgb3JkZXIgdXB3YXJkcyB0byB0aGlzIEZpYmVyLlxuICAgICAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gLy8gSG93ZXZlciB3ZSBhbHNvIGtlZXAgdHJhY2sgaWYgdGhlIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBtYXRjaGVzXG4gICAgICAgICAgICAvLyB0aGUgcHJldmlvdXMgb3JkZXIuIFRoZXkgYXJlIGFsd2F5cyBkaWZmZXJlbnQgcmVmZXJlbnRpYWxseSwgYnV0XG4gICAgICAgICAgICAvLyBpZiB0aGUgaW5zdGFuY2VzIGxpbmUgdXAgY29uY2VwdHVhbGx5IHdlJ2xsIHdhbnQgdG8ga25vdyB0aGF0LlxuXG5cbiAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQgIT09IHByZXZDaGlsZEF0U2FtZUluZGV4KSB7XG4gICAgICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkobmV4dENoaWxkLCBzaG91bGRJbmNsdWRlSW5UcmVlID8gbmV4dEZpYmVyIDogcGFyZW50RmliZXIsIGZhbHNlLCB0cmFjZU5lYXJlc3RIb3N0Q29tcG9uZW50VXBkYXRlKTtcbiAgICAgICAgICAgIHNob3VsZFJlc2V0Q2hpbGRyZW4gPSB0cnVlO1xuICAgICAgICAgIH0gLy8gVHJ5IHRoZSBuZXh0IGNoaWxkLlxuXG5cbiAgICAgICAgICBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGQuc2libGluZzsgLy8gQWR2YW5jZSB0aGUgcG9pbnRlciBpbiB0aGUgcHJldmlvdXMgbGlzdCBzbyB0aGF0IHdlIGNhblxuICAgICAgICAgIC8vIGtlZXAgY29tcGFyaW5nIGlmIHRoZXkgbGluZSB1cC5cblxuICAgICAgICAgIGlmICghc2hvdWxkUmVzZXRDaGlsZHJlbiAmJiBwcmV2Q2hpbGRBdFNhbWVJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldkNoaWxkQXRTYW1lSW5kZXggPSBwcmV2Q2hpbGRBdFNhbWVJbmRleC5zaWJsaW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB3ZSBoYXZlIG5vIG1vcmUgY2hpbGRyZW4sIGJ1dCB1c2VkIHRvLCB0aGV5IGRvbid0IGxpbmUgdXAuXG5cblxuICAgICAgICBpZiAocHJldkNoaWxkQXRTYW1lSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBzaG91bGRSZXNldENoaWxkcmVuID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgICAgICAvLyBJZiB3ZSdyZSB0cmFjaW5nIHVwZGF0ZXMgYW5kIHdlJ3ZlIGJhaWxlZCBvdXQgYmVmb3JlIHJlYWNoaW5nIGEgaG9zdCBub2RlLFxuICAgICAgICAgIC8vIHdlIHNob3VsZCBmYWxsIGJhY2sgdG8gcmVjdXJzaXZlbHkgbWFya2luZyB0aGUgbmVhcmVzdCBob3N0IGRlc2NlbmRhbnRzIGZvciBoaWdobGlnaHQuXG4gICAgICAgICAgaWYgKHRyYWNlTmVhcmVzdEhvc3RDb21wb25lbnRVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBob3N0RmliZXJzID0gZmluZEFsbEN1cnJlbnRIb3N0RmliZXJzKGdldEZpYmVySURUaHJvd3MobmV4dEZpYmVyKSk7XG4gICAgICAgICAgICBob3N0RmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGhvc3RGaWJlcikge1xuICAgICAgICAgICAgICB0cmFjZVVwZGF0ZXNGb3JOb2Rlcy5hZGQoaG9zdEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkSW5jbHVkZUluVHJlZSkge1xuICAgICAgdmFyIGlzUHJvZmlsaW5nU3VwcG9ydGVkID0gbmV4dEZpYmVyLmhhc093blByb3BlcnR5KCd0cmVlQmFzZUR1cmF0aW9uJyk7XG5cbiAgICAgIGlmIChpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgICByZWNvcmRQcm9maWxpbmdEdXJhdGlvbnMobmV4dEZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUmVzZXRDaGlsZHJlbikge1xuICAgICAgLy8gV2UgbmVlZCB0byBjcmF3bCB0aGUgc3VidHJlZSBmb3IgY2xvc2VzdCBub24tZmlsdGVyZWQgRmliZXJzXG4gICAgICAvLyBzbyB0aGF0IHdlIGNhbiBkaXNwbGF5IHRoZW0gaW4gYSBmbGF0IGNoaWxkcmVuIHNldC5cbiAgICAgIGlmIChzaG91bGRJbmNsdWRlSW5UcmVlKSB7XG4gICAgICAgIC8vIE5vcm1hbGx5LCBzZWFyY2ggZm9yIGNoaWxkcmVuIGZyb20gdGhlIHJlbmRlcmVkIGNoaWxkLlxuICAgICAgICB2YXIgbmV4dENoaWxkU2V0ID0gbmV4dEZpYmVyLmNoaWxkO1xuXG4gICAgICAgIGlmIChuZXh0RGlkVGltZU91dCkge1xuICAgICAgICAgIC8vIFNwZWNpYWwgY2FzZTogdGltZWQtb3V0IFN1c3BlbnNlIHJlbmRlcnMgdGhlIGZhbGxiYWNrIHNldC5cbiAgICAgICAgICB2YXIgX25leHRGaWJlckNoaWxkMiA9IG5leHRGaWJlci5jaGlsZDtcbiAgICAgICAgICBuZXh0Q2hpbGRTZXQgPSBfbmV4dEZpYmVyQ2hpbGQyID8gX25leHRGaWJlckNoaWxkMi5zaWJsaW5nIDogbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0Q2hpbGRTZXQgIT0gbnVsbCkge1xuICAgICAgICAgIHJlY29yZFJlc2V0Q2hpbGRyZW4obmV4dEZpYmVyLCBuZXh0Q2hpbGRTZXQpO1xuICAgICAgICB9IC8vIFdlJ3ZlIGhhbmRsZWQgdGhlIGNoaWxkIG9yZGVyIGNoYW5nZSBmb3IgdGhpcyBGaWJlci5cbiAgICAgICAgLy8gU2luY2UgaXQncyBpbmNsdWRlZCwgdGhlcmUncyBubyBuZWVkIHRvIGludmFsaWRhdGUgcGFyZW50IGNoaWxkIG9yZGVyLlxuXG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTGV0IHRoZSBjbG9zZXN0IHVuZmlsdGVyZWQgcGFyZW50IEZpYmVyIHJlc2V0IGl0cyBjaGlsZCBvcmRlciBpbnN0ZWFkLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7Ly8gV2UgZG9uJ3QgcGF0Y2ggYW55IG1ldGhvZHMgc28gdGhlcmUgaXMgbm8gY2xlYW51cC5cbiAgfVxuXG4gIGZ1bmN0aW9uIHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KSB7XG4gICAgaWYgKHJvb3QubWVtb2l6ZWRJbnRlcmFjdGlvbnMgIT0gbnVsbCkge1xuICAgICAgLy8gdjE2IGJ1aWxkcyBpbmNsdWRlIHRoaXMgZmllbGQgZm9yIHRoZSBzY2hlZHVsZXIvdHJhY2luZyBBUEkuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHJvb3QuY3VycmVudCAhPSBudWxsICYmIHJvb3QuY3VycmVudC5oYXNPd25Qcm9wZXJ0eSgndHJlZUJhc2VEdXJhdGlvbicpKSB7XG4gICAgICAvLyBUaGUgc2NoZWR1bGVyL3RyYWNpbmcgQVBJIHdhcyByZW1vdmVkIGluIHYxNyB0aG91Z2hcbiAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgYSBub24tcm9vdCBGaWJlci5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2hJbml0aWFsT3BlcmF0aW9ucygpIHtcbiAgICB2YXIgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlID0gcGVuZGluZ09wZXJhdGlvbnNRdWV1ZTtcbiAgICBwZW5kaW5nT3BlcmF0aW9uc1F1ZXVlID0gbnVsbDtcblxuICAgIGlmIChsb2NhbFBlbmRpbmdPcGVyYXRpb25zUXVldWUgIT09IG51bGwgJiYgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIFdlIG1heSBoYXZlIGFscmVhZHkgcXVldWVkIHVwIHNvbWUgb3BlcmF0aW9ucyBiZWZvcmUgdGhlIGZyb250ZW5kIGNvbm5lY3RlZFxuICAgICAgLy8gSWYgc28sIGxldCB0aGUgZnJvbnRlbmQga25vdyBhYm91dCB0aGVtLlxuICAgICAgbG9jYWxQZW5kaW5nT3BlcmF0aW9uc1F1ZXVlLmZvckVhY2goZnVuY3Rpb24gKG9wZXJhdGlvbnMpIHtcbiAgICAgICAgaG9vay5lbWl0KCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQmVmb3JlIHRoZSB0cmF2ZXJzYWxzLCByZW1lbWJlciB0byBzdGFydCB0cmFja2luZ1xuICAgICAgLy8gb3VyIHBhdGggaW4gY2FzZSB3ZSBoYXZlIHNlbGVjdGlvbiB0byByZXN0b3JlLlxuICAgICAgaWYgKHRyYWNrZWRQYXRoICE9PSBudWxsKSB7XG4gICAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gdHJ1ZTtcbiAgICAgIH0gLy8gSWYgd2UgaGF2ZSBub3QgYmVlbiBwcm9maWxpbmcsIHRoZW4gd2UgY2FuIGp1c3Qgd2FsayB0aGUgdHJlZSBhbmQgYnVpbGQgdXAgaXRzIGN1cnJlbnQgc3RhdGUgYXMtaXMuXG5cblxuICAgICAgaG9vay5nZXRGaWJlclJvb3RzKHJlbmRlcmVySUQpLmZvckVhY2goZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgICAgY3VycmVudFJvb3RJRCA9IGdldE9yR2VuZXJhdGVGaWJlcklEKHJvb3QuY3VycmVudCk7XG4gICAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3RJRCwgcm9vdC5jdXJyZW50KTsgLy8gSGFuZGxlIG11bHRpLXJlbmRlcmVyIGVkZ2UtY2FzZSB3aGVyZSBvbmx5IHNvbWUgdjE2IHJlbmRlcmVycyBzdXBwb3J0IHByb2ZpbGluZy5cblxuICAgICAgICBpZiAoaXNQcm9maWxpbmcgJiYgcm9vdFN1cHBvcnRzUHJvZmlsaW5nKHJvb3QpKSB7XG4gICAgICAgICAgLy8gSWYgcHJvZmlsaW5nIGlzIGFjdGl2ZSwgc3RvcmUgY29tbWl0IHRpbWUgYW5kIGR1cmF0aW9uLlxuICAgICAgICAgIC8vIFRoZSBmcm9udGVuZCBtYXkgcmVxdWVzdCB0aGlzIGluZm9ybWF0aW9uIGFmdGVyIHByb2ZpbGluZyBoYXMgc3RvcHBlZC5cbiAgICAgICAgICBjdXJyZW50Q29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/IG5ldyBNYXAoKSA6IG51bGwsXG4gICAgICAgICAgICBkdXJhdGlvbnM6IFtdLFxuICAgICAgICAgICAgY29tbWl0VGltZTogcmVuZGVyZXJfZ2V0Q3VycmVudFRpbWUoKSAtIHByb2ZpbGluZ1N0YXJ0VGltZSxcbiAgICAgICAgICAgIG1heEFjdHVhbER1cmF0aW9uOiAwLFxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbDogbnVsbCxcbiAgICAgICAgICAgIHVwZGF0ZXJzOiBnZXRVcGRhdGVyc0xpc3Qocm9vdCksXG4gICAgICAgICAgICBlZmZlY3REdXJhdGlvbjogbnVsbCxcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBtb3VudEZpYmVyUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdCk7XG4gICAgICAgIGN1cnJlbnRSb290SUQgPSAtMTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFVwZGF0ZXJzTGlzdChyb290KSB7XG4gICAgcmV0dXJuIHJvb3QubWVtb2l6ZWRVcGRhdGVycyAhPSBudWxsID8gQXJyYXkuZnJvbShyb290Lm1lbW9pemVkVXBkYXRlcnMpLm1hcChmaWJlclRvU2VyaWFsaXplZEVsZW1lbnQpIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudChmaWJlcikge1xuICAgIC8vIFRoaXMgaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBXZSBjYW4ndCB0cmF2ZXJzZSBmaWJlcnMgYWZ0ZXIgdW5tb3VudGluZyBzbyBpbnN0ZWFkXG4gICAgLy8gd2UgcmVseSBvbiBSZWFjdCB0ZWxsaW5nIHVzIGFib3V0IGVhY2ggdW5tb3VudC5cbiAgICByZWNvcmRVbm1vdW50KGZpYmVyLCBmYWxzZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290KHJvb3QpIHtcbiAgICBpZiAoaXNQcm9maWxpbmcgJiYgcm9vdFN1cHBvcnRzUHJvZmlsaW5nKHJvb3QpKSB7XG4gICAgICBpZiAoY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfZ2V0RWZmZWN0RHVyYXRpb25zID0gZ2V0RWZmZWN0RHVyYXRpb25zKHJvb3QpLFxuICAgICAgICAgICAgZWZmZWN0RHVyYXRpb24gPSBfZ2V0RWZmZWN0RHVyYXRpb25zLmVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gX2dldEVmZmVjdER1cmF0aW9ucy5wYXNzaXZlRWZmZWN0RHVyYXRpb247XG5cbiAgICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhLmVmZmVjdER1cmF0aW9uID0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgIGN1cnJlbnRDb21taXRQcm9maWxpbmdNZXRhZGF0YS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBwYXNzaXZlRWZmZWN0RHVyYXRpb247XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ29tbWl0RmliZXJSb290KHJvb3QsIHByaW9yaXR5TGV2ZWwpIHtcbiAgICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgICB2YXIgYWx0ZXJuYXRlID0gY3VycmVudC5hbHRlcm5hdGU7IC8vIEZsdXNoIGFueSBwZW5kaW5nIEZpYmVycyB0aGF0IHdlIGFyZSB1bnRyYWNraW5nIGJlZm9yZSBwcm9jZXNzaW5nIHRoZSBuZXcgY29tbWl0LlxuICAgIC8vIElmIHdlIGRvbid0IGRvIHRoaXMsIHdlIG1pZ2h0IGVuZCB1cCBkb3VibGUtZGVsZXRpbmcgRmliZXJzIGluIHNvbWUgY2FzZXMgKGxpa2UgTGVnYWN5IFN1c3BlbnNlKS5cblxuICAgIHVudHJhY2tGaWJlcnMoKTtcbiAgICBjdXJyZW50Um9vdElEID0gZ2V0T3JHZW5lcmF0ZUZpYmVySUQoY3VycmVudCk7IC8vIEJlZm9yZSB0aGUgdHJhdmVyc2FscywgcmVtZW1iZXIgdG8gc3RhcnQgdHJhY2tpbmdcbiAgICAvLyBvdXIgcGF0aCBpbiBjYXNlIHdlIGhhdmUgc2VsZWN0aW9uIHRvIHJlc3RvcmUuXG5cbiAgICBpZiAodHJhY2tlZFBhdGggIT09IG51bGwpIHtcbiAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHJhY2VVcGRhdGVzRW5hYmxlZCkge1xuICAgICAgdHJhY2VVcGRhdGVzRm9yTm9kZXMuY2xlYXIoKTtcbiAgICB9IC8vIEhhbmRsZSBtdWx0aS1yZW5kZXJlciBlZGdlLWNhc2Ugd2hlcmUgb25seSBzb21lIHYxNiByZW5kZXJlcnMgc3VwcG9ydCBwcm9maWxpbmcuXG5cblxuICAgIHZhciBpc1Byb2ZpbGluZ1N1cHBvcnRlZCA9IHJvb3RTdXBwb3J0c1Byb2ZpbGluZyhyb290KTtcblxuICAgIGlmIChpc1Byb2ZpbGluZyAmJiBpc1Byb2ZpbGluZ1N1cHBvcnRlZCkge1xuICAgICAgLy8gSWYgcHJvZmlsaW5nIGlzIGFjdGl2ZSwgc3RvcmUgY29tbWl0IHRpbWUgYW5kIGR1cmF0aW9uLlxuICAgICAgLy8gVGhlIGZyb250ZW5kIG1heSByZXF1ZXN0IHRoaXMgaW5mb3JtYXRpb24gYWZ0ZXIgcHJvZmlsaW5nIGhhcyBzdG9wcGVkLlxuICAgICAgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0ge1xuICAgICAgICBjaGFuZ2VEZXNjcmlwdGlvbnM6IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/IG5ldyBNYXAoKSA6IG51bGwsXG4gICAgICAgIGR1cmF0aW9uczogW10sXG4gICAgICAgIGNvbW1pdFRpbWU6IHJlbmRlcmVyX2dldEN1cnJlbnRUaW1lKCkgLSBwcm9maWxpbmdTdGFydFRpbWUsXG4gICAgICAgIG1heEFjdHVhbER1cmF0aW9uOiAwLFxuICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsID09IG51bGwgPyBudWxsIDogZm9ybWF0UHJpb3JpdHlMZXZlbChwcmlvcml0eUxldmVsKSxcbiAgICAgICAgdXBkYXRlcnM6IGdldFVwZGF0ZXJzTGlzdChyb290KSxcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0byBudWxsOyBpZiBuZXcgZW5vdWdoIFJlYWN0IHZlcnNpb24gaXMgcnVubmluZyxcbiAgICAgICAgLy8gdGhlc2UgdmFsdWVzIHdpbGwgYmUgcmVhZCBkdXJpbmcgc2VwYXJhdGUgaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCgpIGNhbGwuXG4gICAgICAgIGVmZmVjdER1cmF0aW9uOiBudWxsLFxuICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGFsdGVybmF0ZSkge1xuICAgICAgLy8gVE9ETzogcmVseWluZyBvbiB0aGlzIHNlZW1zIGEgYml0IGZpc2h5LlxuICAgICAgdmFyIHdhc01vdW50ZWQgPSBhbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZSAhPSBudWxsICYmIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmVsZW1lbnQgIT0gbnVsbDtcbiAgICAgIHZhciBpc01vdW50ZWQgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZWxlbWVudCAhPSBudWxsO1xuXG4gICAgICBpZiAoIXdhc01vdW50ZWQgJiYgaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICAgIHNldFJvb3RQc2V1ZG9LZXkoY3VycmVudFJvb3RJRCwgY3VycmVudCk7XG4gICAgICAgIG1vdW50RmliZXJSZWN1cnNpdmVseShjdXJyZW50LCBudWxsLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmICh3YXNNb3VudGVkICYmIGlzTW91bnRlZCkge1xuICAgICAgICAvLyBVcGRhdGUgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgdXBkYXRlRmliZXJSZWN1cnNpdmVseShjdXJyZW50LCBhbHRlcm5hdGUsIG51bGwsIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAod2FzTW91bnRlZCAmJiAhaXNNb3VudGVkKSB7XG4gICAgICAgIC8vIFVubW91bnQgYW4gZXhpc3Rpbmcgcm9vdC5cbiAgICAgICAgcmVtb3ZlUm9vdFBzZXVkb0tleShjdXJyZW50Um9vdElEKTtcbiAgICAgICAgcmVjb3JkVW5tb3VudChjdXJyZW50LCBmYWxzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdW50IGEgbmV3IHJvb3QuXG4gICAgICBzZXRSb290UHNldWRvS2V5KGN1cnJlbnRSb290SUQsIGN1cnJlbnQpO1xuICAgICAgbW91bnRGaWJlclJlY3Vyc2l2ZWx5KGN1cnJlbnQsIG51bGwsIGZhbHNlLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzUHJvZmlsaW5nICYmIGlzUHJvZmlsaW5nU3VwcG9ydGVkKSB7XG4gICAgICB2YXIgY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEgPSByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcC5nZXQoY3VycmVudFJvb3RJRCk7XG5cbiAgICAgIGlmIChjb21taXRQcm9maWxpbmdNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgICAgIGNvbW1pdFByb2ZpbGluZ01ldGFkYXRhLnB1c2goY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3RUb0NvbW1pdFByb2ZpbGluZ01ldGFkYXRhTWFwLnNldChjdXJyZW50Um9vdElELCBbY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhXSk7XG4gICAgICB9XG4gICAgfSAvLyBXZSdyZSBkb25lIGhlcmUuXG5cblxuICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290KTtcblxuICAgIGlmICh0cmFjZVVwZGF0ZXNFbmFibGVkKSB7XG4gICAgICBob29rLmVtaXQoJ3RyYWNlVXBkYXRlcycsIHRyYWNlVXBkYXRlc0Zvck5vZGVzKTtcbiAgICB9XG5cbiAgICBjdXJyZW50Um9vdElEID0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kQWxsQ3VycmVudEhvc3RGaWJlcnMoaWQpIHtcbiAgICB2YXIgZmliZXJzID0gW107XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmICghZmliZXIpIHtcbiAgICAgIHJldHVybiBmaWJlcnM7XG4gICAgfSAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCBhbGwgSG9zdENvbXBvbmVudC9UZXh0LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgZmliZXJzLnB1c2gobm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZmliZXJzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgICBpZiAoIW5vZGUucmV0dXJuIHx8IG5vZGUucmV0dXJuID09PSBmaWJlcikge1xuICAgICAgICAgIHJldHVybiBmaWJlcnM7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfSAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICAgIHJldHVybiBmaWJlcnM7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfZmliZXIzID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgICAgaWYgKF9maWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIFNwZWNpYWwgY2FzZSBmb3IgYSB0aW1lZC1vdXQgU3VzcGVuc2UuXG5cblxuICAgICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IF9maWJlcjMudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBfZmliZXIzLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgLy8gQSB0aW1lZC1vdXQgU3VzcGVuc2UncyBmaW5kRE9NTm9kZSBpcyB1c2VsZXNzLlxuICAgICAgICAvLyBUcnkgb3VyIGJlc3QgdG8gZmluZCB0aGUgZmFsbGJhY2sgZGlyZWN0bHkuXG4gICAgICAgIHZhciBtYXliZUZhbGxiYWNrRmliZXIgPSBfZmliZXIzLmNoaWxkICYmIF9maWJlcjMuY2hpbGQuc2libGluZztcblxuICAgICAgICBpZiAobWF5YmVGYWxsYmFja0ZpYmVyICE9IG51bGwpIHtcbiAgICAgICAgICBfZmliZXIzID0gbWF5YmVGYWxsYmFja0ZpYmVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBob3N0RmliZXJzID0gZmluZEFsbEN1cnJlbnRIb3N0RmliZXJzKGlkKTtcbiAgICAgIHJldHVybiBob3N0RmliZXJzLm1hcChmdW5jdGlvbiAoaG9zdEZpYmVyKSB7XG4gICAgICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICAgICAgfSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gVGhlIGZpYmVyIG1pZ2h0IGhhdmUgdW5tb3VudGVkIGJ5IG5vdy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yRmliZXJJRChpZCkge1xuICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuICAgIHJldHVybiBmaWJlciAhPSBudWxsID8gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0RmliZXJJREZvck5hdGl2ZShob3N0SW5zdGFuY2UpIHtcbiAgICB2YXIgZmluZE5lYXJlc3RVbmZpbHRlcmVkQW5jZXN0b3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBmaWJlciA9IHJlbmRlcmVyLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGhvc3RJbnN0YW5jZSk7XG5cbiAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgaWYgKGZpbmROZWFyZXN0VW5maWx0ZXJlZEFuY2VzdG9yKSB7XG4gICAgICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCAmJiBzaG91bGRGaWx0ZXJGaWJlcihmaWJlcikpIHtcbiAgICAgICAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0RmliZXJJRFRocm93cyhmaWJlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgTU9VTlRJTkcgPSAxO1xuICB2YXIgTU9VTlRFRCA9IDI7XG4gIHZhciBVTk1PVU5URUQgPSAzOyAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIFJlYWN0IGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5qc1xuXG4gIGZ1bmN0aW9uIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikge1xuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgdmFyIHByZXZOb2RlID0gbnVsbDtcblxuICAgIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICAgIGlmICgoZ2V0RmliZXJGbGFncyhub2RlKSAmIFBsYWNlbWVudCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgfSAvLyBUaGlzIGluZGljYXRlcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyLlxuXG5cbiAgICAgIGlmICgoZ2V0RmliZXJGbGFncyhub2RlKSAmIEluY29tcGxldGUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgIHJldHVybiBVTk1PVU5URUQ7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgICBwcmV2Tm9kZSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcblxuICAgICAgICBpZiAoKGdldEZpYmVyRmxhZ3Mobm9kZSkgJiBQbGFjZW1lbnQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgICB9IC8vIFRoaXMgaW5kaWNhdGVzIGFuIGVycm9yIGR1cmluZyByZW5kZXIuXG5cblxuICAgICAgICBpZiAoKGdldEZpYmVyRmxhZ3Mobm9kZSkgJiBJbmNvbXBsZXRlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgIHJldHVybiBVTk1PVU5URUQ7XG4gICAgICAgIH0gLy8gSWYgdGhpcyBub2RlIGlzIGluc2lkZSBvZiBhIHRpbWVkIG91dCBzdXNwZW5zZSBzdWJ0cmVlLCB3ZSBzaG91bGQgYWxzbyBpZ25vcmUgZXJyb3JzL3dhcm5pbmdzLlxuXG5cbiAgICAgICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IG5vZGUudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGRvZXMgbm90IGluY2x1ZGUgZXJyb3JzL3dhcm5pbmdzIGluIHRoZSBGYWxsYmFjayB0cmVlIHRob3VnaCFcbiAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudCA/IHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgOiBudWxsO1xuXG4gICAgICAgICAgaWYgKHByZXZOb2RlICE9PSBmYWxsYmFja0NoaWxkRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBVTk1PVU5URUQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgICAgcmV0dXJuIE1PVU5URUQ7XG4gICAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cblxuXG4gICAgcmV0dXJuIFVOTU9VTlRFRDtcbiAgfSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGNvcGllZCBmcm9tIFJlYWN0IGFuZCBzaG91bGQgYmUga2VwdCBpbiBzeW5jOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIvc3JjL1JlYWN0RmliZXJUcmVlUmVmbGVjdGlvbi5qc1xuICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHdlIHVwZGF0ZWQgUmVhY3QgdG8gaW5qZWN0IHRoaXMgZnVuY3Rpb24gZGlyZWN0bHkgKHZzIGp1c3QgaW5kaXJlY3RseSB2aWEgZmluZERPTU5vZGUpLlxuICAvLyBCRUdJTiBjb3BpZWQgY29kZVxuXG5cbiAgZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKSB7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGZpbmQgRmliZXIgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuXG4gICAgICBpZiAoc3RhdGUgPT09IFVOTU9VTlRFRCkge1xuICAgICAgICB0aHJvdyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfSAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gICAgdmFyIGEgPSBmaWJlcjtcbiAgICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICB2YXIgcGFyZW50QSA9IGEucmV0dXJuO1xuXG4gICAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChwYXJlbnRCID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgICAvLyBpcyBpbnNlcnRlZCBpbiBiZXR3ZWVuIHRoZSBTdXNwZW5zZSBmaWJlciBhbmQgaXRzIGNoaWxkcmVuLiBTa2lwXG4gICAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgICAgaWYgKG5leHRQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSWYgdGhlcmUncyBubyBwYXJlbnQsIHdlJ3JlIGF0IHRoZSByb290LlxuXG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICAgIGlmIChpc0ZpYmVyTW91bnRlZEltcGwocGFyZW50QSkgIT09IE1PVU5URUQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgICAgaWYgKGlzRmliZXJNb3VudGVkSW1wbChwYXJlbnRBKSAhPT0gTU9VTlRFRCkge1xuICAgICAgICAgICAgICB0aHJvdyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgICAgfSAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAgICB0aHJvdyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuXG4gICAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgJyArICdpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYikge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gXCIgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gICAgLy8gdW5tb3VudGVkLlxuXG5cbiAgICBpZiAoYS50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfSAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG5cblxuICAgIHJldHVybiBhbHRlcm5hdGU7XG4gIH0gLy8gRU5EIGNvcGllZCBjb2RlXG5cblxuICBmdW5jdGlvbiBwcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZShpZCwgcGF0aCkge1xuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpKSB7XG4gICAgICB3aW5kb3cuJGF0dHJpYnV0ZSA9IGdldEluT2JqZWN0KG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVWaWV3RWxlbWVudFNvdXJjZShpZCkge1xuICAgIHZhciBmaWJlciA9IGlkVG9BcmJpdHJhcnlGaWJlck1hcC5nZXQoaWQpO1xuXG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIEZpYmVyIHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudFR5cGUgPSBmaWJlci5lbGVtZW50VHlwZSxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBnbG9iYWwuJHR5cGUgPSB0eXBlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBnbG9iYWwuJHR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiR0eXBlID0gZWxlbWVudFR5cGUgIT0gbnVsbCAmJiBlbGVtZW50VHlwZS50eXBlICE9IG51bGwgPyBlbGVtZW50VHlwZS50eXBlIDogdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGdsb2JhbC4kdHlwZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpYmVyVG9TZXJpYWxpemVkRWxlbWVudChmaWJlcikge1xuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5TmFtZTogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihmaWJlcikgfHwgJ0Fub255bW91cycsXG4gICAgICBpZDogZ2V0RmliZXJJRFRocm93cyhmaWJlciksXG4gICAgICBrZXk6IGZpYmVyLmtleSxcbiAgICAgIHR5cGU6IGdldEVsZW1lbnRUeXBlRm9yRmliZXIoZmliZXIpXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE93bmVyc0xpc3QoaWQpIHtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfZGVidWdPd25lciA9IGZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIHZhciBvd25lcnMgPSBbZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KGZpYmVyKV07XG5cbiAgICBpZiAoX2RlYnVnT3duZXIpIHtcbiAgICAgIHZhciBvd25lciA9IF9kZWJ1Z093bmVyO1xuXG4gICAgICB3aGlsZSAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgb3duZXJzLnVuc2hpZnQoZmliZXJUb1NlcmlhbGl6ZWRFbGVtZW50KG93bmVyKSk7XG4gICAgICAgIG93bmVyID0gb3duZXIuX2RlYnVnT3duZXIgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3duZXJzO1xuICB9IC8vIEZhc3QgcGF0aCBwcm9wcyBsb29rdXAgZm9yIFJlYWN0IE5hdGl2ZSBzdHlsZSBlZGl0b3IuXG4gIC8vIENvdWxkIHVzZSBpbnNwZWN0RWxlbWVudFJhdygpIGJ1dCB0aGF0IHdvdWxkIHJlcXVpcmUgc2hhbGxvdyByZW5kZXJpbmcgaG9va3MgY29tcG9uZW50cyxcbiAgLy8gYW5kIGNvdWxkIGFsc28gbWVzcyB3aXRoIG1lbW9pemF0aW9uLlxuXG5cbiAgZnVuY3Rpb24gZ2V0SW5zdGFuY2VBbmRTdHlsZShpZCkge1xuICAgIHZhciBpbnN0YW5jZSA9IG51bGw7XG4gICAgdmFyIHN0eWxlID0gbnVsbDtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKGZpYmVyLm1lbW9pemVkUHJvcHMgIT09IG51bGwpIHtcbiAgICAgICAgc3R5bGUgPSBmaWJlci5tZW1vaXplZFByb3BzLnN0eWxlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICBzdHlsZTogc3R5bGVcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFcnJvckJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVhcmVzdEVycm9yQm91bmRhcnlJRChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNFcnJvckJvdW5kYXJ5KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEZpYmVySURVbnNhZmUocGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50UmF3KGlkKSB7XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgX2RlYnVnT3duZXIgPSBmaWJlci5fZGVidWdPd25lcixcbiAgICAgICAgX2RlYnVnU291cmNlID0gZmliZXIuX2RlYnVnU291cmNlLFxuICAgICAgICBzdGF0ZU5vZGUgPSBmaWJlci5zdGF0ZU5vZGUsXG4gICAgICAgIGtleSA9IGZpYmVyLmtleSxcbiAgICAgICAgbWVtb2l6ZWRQcm9wcyA9IGZpYmVyLm1lbW9pemVkUHJvcHMsXG4gICAgICAgIG1lbW9pemVkU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgICAgICBkZXBlbmRlbmNpZXMgPSBmaWJlci5kZXBlbmRlbmNpZXMsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZ2V0RWxlbWVudFR5cGVGb3JGaWJlcihmaWJlcik7XG4gICAgdmFyIHVzZXNIb29rcyA9ICh0YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50IHx8IHRhZyA9PT0gU2ltcGxlTWVtb0NvbXBvbmVudCB8fCB0YWcgPT09IEZvcndhcmRSZWYpICYmICghIW1lbW9pemVkU3RhdGUgfHwgISFkZXBlbmRlbmNpZXMpOyAvLyBUT0RPIFNob3cgY3VzdG9tIFVJIGZvciBDYWNoZSBsaWtlIHdlIGRvIGZvciBTdXNwZW5zZVxuICAgIC8vIEZvciBub3csIGp1c3QgaGlkZSBzdGF0ZSBkYXRhIGVudGlyZWx5IHNpbmNlIGl0J3Mgbm90IG1lYW50IHRvIGJlIGluc3BlY3RlZC5cblxuICAgIHZhciBzaG93U3RhdGUgPSAhdXNlc0hvb2tzICYmIHRhZyAhPT0gQ2FjaGVDb21wb25lbnQ7XG4gICAgdmFyIHR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKHR5cGUpO1xuICAgIHZhciBjYW5WaWV3U291cmNlID0gZmFsc2U7XG4gICAgdmFyIGNvbnRleHQgPSBudWxsO1xuXG4gICAgaWYgKHRhZyA9PT0gQ2xhc3NDb21wb25lbnQgfHwgdGFnID09PSBGdW5jdGlvbkNvbXBvbmVudCB8fCB0YWcgPT09IEluY29tcGxldGVDbGFzc0NvbXBvbmVudCB8fCB0YWcgPT09IEluZGV0ZXJtaW5hdGVDb21wb25lbnQgfHwgdGFnID09PSBNZW1vQ29tcG9uZW50IHx8IHRhZyA9PT0gRm9yd2FyZFJlZiB8fCB0YWcgPT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgIGNhblZpZXdTb3VyY2UgPSB0cnVlO1xuXG4gICAgICBpZiAoc3RhdGVOb2RlICYmIHN0YXRlTm9kZS5jb250ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgLy8gRG9uJ3Qgc2hvdyBhbiBlbXB0eSBjb250ZXh0IG9iamVjdCBmb3IgY2xhc3MgY29tcG9uZW50cyB0aGF0IGRvbid0IHVzZSB0aGUgY29udGV4dCBBUEkuXG4gICAgICAgIHZhciBzaG91bGRIaWRlQ29udGV4dCA9IGVsZW1lbnRUeXBlID09PSBFbGVtZW50VHlwZUNsYXNzICYmICEodHlwZS5jb250ZXh0VHlwZXMgfHwgdHlwZS5jb250ZXh0VHlwZSk7XG5cbiAgICAgICAgaWYgKCFzaG91bGRIaWRlQ29udGV4dCkge1xuICAgICAgICAgIGNvbnRleHQgPSBzdGF0ZU5vZGUuY29udGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZVN5bWJvbCA9PT0gQ09OVEVYVF9OVU1CRVIgfHwgdHlwZVN5bWJvbCA9PT0gQ09OVEVYVF9TWU1CT0xfU1RSSU5HKSB7XG4gICAgICAvLyAxNi4zLTE2LjUgcmVhZCBmcm9tIFwidHlwZVwiIGJlY2F1c2UgdGhlIENvbnN1bWVyIGlzIHRoZSBhY3R1YWwgY29udGV4dCBvYmplY3QuXG4gICAgICAvLyAxNi42KyBzaG91bGQgcmVhZCBmcm9tIFwidHlwZS5fY29udGV4dFwiIGJlY2F1c2UgQ29uc3VtZXIgY2FuIGJlIGRpZmZlcmVudCAoaW4gREVWKS5cbiAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggZ2V0RGlzcGxheU5hbWVGb3JGaWJlcigpXG4gICAgICB2YXIgY29uc3VtZXJSZXNvbHZlZENvbnRleHQgPSB0eXBlLl9jb250ZXh0IHx8IHR5cGU7IC8vIEdsb2JhbCBjb250ZXh0IHZhbHVlLlxuXG4gICAgICBjb250ZXh0ID0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQuX2N1cnJlbnRWYWx1ZSB8fCBudWxsOyAvLyBMb29rIGZvciBvdmVycmlkZGVuIHZhbHVlLlxuXG4gICAgICB2YXIgX2N1cnJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgICAgIHdoaWxlIChfY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY3VycmVudFR5cGUgPSBfY3VycmVudC50eXBlO1xuICAgICAgICB2YXIgY3VycmVudFR5cGVTeW1ib2wgPSBnZXRUeXBlU3ltYm9sKGN1cnJlbnRUeXBlKTtcblxuICAgICAgICBpZiAoY3VycmVudFR5cGVTeW1ib2wgPT09IFBST1ZJREVSX05VTUJFUiB8fCBjdXJyZW50VHlwZVN5bWJvbCA9PT0gUFJPVklERVJfU1lNQk9MX1NUUklORykge1xuICAgICAgICAgIC8vIDE2LjMuMCBleHBvc2VkIHRoZSBjb250ZXh0IG9iamVjdCBhcyBcImNvbnRleHRcIlxuICAgICAgICAgIC8vIFBSICMxMjUwMSBjaGFuZ2VkIGl0IHRvIFwiX2NvbnRleHRcIiBmb3IgMTYuMy4xK1xuICAgICAgICAgIC8vIE5PVEUgS2VlcCBpbiBzeW5jIHdpdGggZ2V0RGlzcGxheU5hbWVGb3JGaWJlcigpXG4gICAgICAgICAgdmFyIHByb3ZpZGVyUmVzb2x2ZWRDb250ZXh0ID0gY3VycmVudFR5cGUuX2NvbnRleHQgfHwgY3VycmVudFR5cGUuY29udGV4dDtcblxuICAgICAgICAgIGlmIChwcm92aWRlclJlc29sdmVkQ29udGV4dCA9PT0gY29uc3VtZXJSZXNvbHZlZENvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSBfY3VycmVudC5tZW1vaXplZFByb3BzLnZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2N1cnJlbnQgPSBfY3VycmVudC5yZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhhc0xlZ2FjeUNvbnRleHQgPSBmYWxzZTtcblxuICAgIGlmIChjb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICBoYXNMZWdhY3lDb250ZXh0ID0gISF0eXBlLmNvbnRleHRUeXBlczsgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IGxvZ2ljIGZvciBjb250ZXh0LCB3cmFwIGluIGEgdmFsdWUgb2JqZWN0LlxuICAgICAgLy8gT3RoZXJ3aXNlIHNpbXBsZSB2YWx1ZXMgKGUuZy4gc3RyaW5ncywgYm9vbGVhbnMpIGJlY29tZSBoYXJkZXIgdG8gaGFuZGxlLlxuXG4gICAgICBjb250ZXh0ID0ge1xuICAgICAgICB2YWx1ZTogY29udGV4dFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgb3duZXJzID0gbnVsbDtcblxuICAgIGlmIChfZGVidWdPd25lcikge1xuICAgICAgb3duZXJzID0gW107XG4gICAgICB2YXIgb3duZXIgPSBfZGVidWdPd25lcjtcblxuICAgICAgd2hpbGUgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIG93bmVycy5wdXNoKGZpYmVyVG9TZXJpYWxpemVkRWxlbWVudChvd25lcikpO1xuICAgICAgICBvd25lciA9IG93bmVyLl9kZWJ1Z093bmVyIHx8IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IHRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQgJiYgbWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICB2YXIgaG9va3MgPSBudWxsO1xuXG4gICAgaWYgKHVzZXNIb29rcykge1xuICAgICAgdmFyIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTsgLy8gVGVtcG9yYXJpbHkgZGlzYWJsZSBhbGwgY29uc29sZSBsb2dnaW5nIGJlZm9yZSByZS1ydW5uaW5nIHRoZSBob29rLlxuXG4gICAgICBmb3IgKHZhciBtZXRob2QgaW4gY29uc29sZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG9yaWdpbmFsQ29uc29sZU1ldGhvZHNbbWV0aG9kXSA9IGNvbnNvbGVbbWV0aG9kXTsgLy8gJEZsb3dGaXhNZSBwcm9wZXJ0eSBlcnJvcnx3YXJuIGlzIG5vdCB3cml0YWJsZS5cblxuICAgICAgICAgIGNvbnNvbGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgaG9va3MgPSBPYmplY3QocmVhY3RfZGVidWdfdG9vbHNbXCJpbnNwZWN0SG9va3NPZkZpYmVyXCJdKShmaWJlciwgcmVuZGVyZXIuY3VycmVudERpc3BhdGNoZXJSZWYsIHRydWUgLy8gSW5jbHVkZSBzb3VyY2UgbG9jYXRpb24gaW5mbyBmb3IgaG9va3NcbiAgICAgICAgKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgY29uc29sZSBmdW5jdGlvbmFsaXR5LlxuICAgICAgICBmb3IgKHZhciBfbWV0aG9kIGluIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSBwcm9wZXJ0eSBlcnJvcnx3YXJuIGlzIG5vdCB3cml0YWJsZS5cbiAgICAgICAgICAgIGNvbnNvbGVbX21ldGhvZF0gPSBvcmlnaW5hbENvbnNvbGVNZXRob2RzW19tZXRob2RdO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJvb3RUeXBlID0gbnVsbDtcbiAgICB2YXIgY3VycmVudCA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKGN1cnJlbnQucmV0dXJuICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5yZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGZpYmVyUm9vdCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGZpYmVyUm9vdCAhPSBudWxsICYmIGZpYmVyUm9vdC5fZGVidWdSb290VHlwZSAhPT0gbnVsbCkge1xuICAgICAgcm9vdFR5cGUgPSBmaWJlclJvb3QuX2RlYnVnUm9vdFR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGVycm9ycyA9IGZpYmVySURUb0Vycm9yc01hcC5nZXQoaWQpIHx8IG5ldyBNYXAoKTtcbiAgICB2YXIgd2FybmluZ3MgPSBmaWJlcklEVG9XYXJuaW5nc01hcC5nZXQoaWQpIHx8IG5ldyBNYXAoKTtcbiAgICB2YXIgaXNFcnJvcmVkID0gKGZpYmVyLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MgfHwgZm9yY2VFcnJvckZvckZpYmVySURzLmdldChpZCkgPT09IHRydWU7XG4gICAgdmFyIHRhcmdldEVycm9yQm91bmRhcnlJRDtcblxuICAgIGlmIChpc0Vycm9yQm91bmRhcnkoZmliZXIpKSB7XG4gICAgICAvLyBpZiB0aGUgY3VycmVudCBpbnNwZWN0ZWQgZWxlbWVudCBpcyBhbiBlcnJvciBib3VuZGFyeSxcbiAgICAgIC8vIGVpdGhlciB0aGF0IHdlIHdhbnQgdG8gdXNlIGl0IHRvIHRvZ2dsZSBvZmYgZXJyb3Igc3RhdGVcbiAgICAgIC8vIG9yIHRoYXQgd2UgYWxsb3cgdG8gZm9yY2UgZXJyb3Igc3RhdGUgb24gaXQgaWYgaXQncyB3aXRoaW4gYW5vdGhlclxuICAgICAgLy8gZXJyb3IgYm91bmRhcnlcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRCA9IGlzRXJyb3JlZCA/IGlkIDogZ2V0TmVhcmVzdEVycm9yQm91bmRhcnlJRChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRCA9IGdldE5lYXJlc3RFcnJvckJvdW5kYXJ5SUQoZmliZXIpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBpZDogaWQsXG4gICAgICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgZWRpdGFibGUgaG9va3MgYW5kIGZ1bmN0aW9uIHByb3BzP1xuICAgICAgY2FuRWRpdEhvb2tzOiB0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGUgPT09ICdmdW5jdGlvbicsXG4gICAgICBjYW5FZGl0RnVuY3Rpb25Qcm9wczogdHlwZW9mIG92ZXJyaWRlUHJvcHMgPT09ICdmdW5jdGlvbicsXG4gICAgICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgYWR2YW5jZWQgZWRpdGluZyBpbnRlcmZhY2U/XG4gICAgICBjYW5FZGl0SG9va3NBbmREZWxldGVQYXRoczogdHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICAgIGNhbkVkaXRIb29rc0FuZFJlbmFtZVBhdGhzOiB0eXBlb2Ygb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNEZWxldGVQYXRoczogdHlwZW9mIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuRWRpdEZ1bmN0aW9uUHJvcHNSZW5hbWVQYXRoczogdHlwZW9mIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nLFxuICAgICAgY2FuVG9nZ2xlRXJyb3I6IHN1cHBvcnRzVG9nZ2xpbmdFcnJvciAmJiB0YXJnZXRFcnJvckJvdW5kYXJ5SUQgIT0gbnVsbCxcbiAgICAgIC8vIElzIHRoaXMgZXJyb3IgYm91bmRhcnkgaW4gZXJyb3Igc3RhdGUuXG4gICAgICBpc0Vycm9yZWQ6IGlzRXJyb3JlZCxcbiAgICAgIHRhcmdldEVycm9yQm91bmRhcnlJRDogdGFyZ2V0RXJyb3JCb3VuZGFyeUlELFxuICAgICAgY2FuVG9nZ2xlU3VzcGVuc2U6IHN1cHBvcnRzVG9nZ2xpbmdTdXNwZW5zZSAmJiAoIC8vIElmIGl0J3Mgc2hvd2luZyB0aGUgcmVhbCBjb250ZW50LCB3ZSBjYW4gYWx3YXlzIGZsaXAgZmFsbGJhY2suXG4gICAgICAhaXNUaW1lZE91dFN1c3BlbnNlIHx8IC8vIElmIGl0J3Mgc2hvd2luZyBmYWxsYmFjayBiZWNhdXNlIHdlIHByZXZpb3VzbHkgZm9yY2VkIGl0IHRvLFxuICAgICAgLy8gYWxsb3cgdG9nZ2xpbmcgaXQgYmFjayB0byByZW1vdmUgdGhlIGZhbGxiYWNrIG92ZXJyaWRlLlxuICAgICAgZm9yY2VGYWxsYmFja0ZvclN1c3BlbnNlSURzLmhhcyhpZCkpLFxuICAgICAgLy8gQ2FuIHZpZXcgY29tcG9uZW50IHNvdXJjZSBsb2NhdGlvbi5cbiAgICAgIGNhblZpZXdTb3VyY2U6IGNhblZpZXdTb3VyY2UsXG4gICAgICAvLyBEb2VzIHRoZSBjb21wb25lbnQgaGF2ZSBsZWdhY3kgY29udGV4dCBhdHRhY2hlZCB0byBpdC5cbiAgICAgIGhhc0xlZ2FjeUNvbnRleHQ6IGhhc0xlZ2FjeUNvbnRleHQsXG4gICAgICBrZXk6IGtleSAhPSBudWxsID8ga2V5IDogbnVsbCxcbiAgICAgIGRpc3BsYXlOYW1lOiBnZXREaXNwbGF5TmFtZUZvckZpYmVyKGZpYmVyKSxcbiAgICAgIHR5cGU6IGVsZW1lbnRUeXBlLFxuICAgICAgLy8gSW5zcGVjdGFibGUgcHJvcGVydGllcy5cbiAgICAgIC8vIFRPRE8gUmV2aWV3IHNhbml0aXphdGlvbiBhcHByb2FjaCBmb3IgdGhlIGJlbG93IGluc3BlY3RhYmxlIHZhbHVlcy5cbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBob29rczogaG9va3MsXG4gICAgICBwcm9wczogbWVtb2l6ZWRQcm9wcyxcbiAgICAgIHN0YXRlOiBzaG93U3RhdGUgPyBtZW1vaXplZFN0YXRlIDogbnVsbCxcbiAgICAgIGVycm9yczogQXJyYXkuZnJvbShlcnJvcnMuZW50cmllcygpKSxcbiAgICAgIHdhcm5pbmdzOiBBcnJheS5mcm9tKHdhcm5pbmdzLmVudHJpZXMoKSksXG4gICAgICAvLyBMaXN0IG9mIG93bmVyc1xuICAgICAgb3duZXJzOiBvd25lcnMsXG4gICAgICAvLyBMb2NhdGlvbiBvZiBjb21wb25lbnQgaW4gc291cmNlIGNvZGUuXG4gICAgICBzb3VyY2U6IF9kZWJ1Z1NvdXJjZSB8fCBudWxsLFxuICAgICAgcm9vdFR5cGU6IHJvb3RUeXBlLFxuICAgICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogcmVuZGVyZXIucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICAgIHJlbmRlcmVyVmVyc2lvbjogcmVuZGVyZXIudmVyc2lvblxuICAgIH07XG4gIH1cblxuICB2YXIgbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA9IG51bGw7XG4gIHZhciBoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCA9IGZhbHNlO1xuICB2YXIgY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgPSB7fTtcblxuICBmdW5jdGlvbiBpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpIHtcbiAgICByZXR1cm4gbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCAmJiBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50LmlkID09PSBpZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudEN1cnJlbnQoaWQpIHtcbiAgICByZXR1cm4gaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSAmJiAhaGFzRWxlbWVudFVwZGF0ZWRTaW5jZUxhc3RJbnNwZWN0ZWQ7XG4gIH0gLy8gVHJhY2sgdGhlIGludGVyc2VjdGlvbiBvZiBjdXJyZW50bHkgaW5zcGVjdGVkIHBhdGhzLFxuICAvLyBzbyB0aGF0IHdlIGNhbiBzZW5kIHRoZWlyIGRhdGEgYWxvbmcgaWYgdGhlIGVsZW1lbnQgaXMgcmUtcmVuZGVyZWQuXG5cblxuICBmdW5jdGlvbiBtZXJnZUluc3BlY3RlZFBhdGhzKHBhdGgpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzO1xuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIWN1cnJlbnRba2V5XSkge1xuICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnRba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUlzUGF0aEFsbG93ZWQoa2V5LCBzZWNvbmRhcnlDYXRlZ29yeSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaGVscHMgcHJldmVudCBwcmV2aW91c2x5LWluc3BlY3RlZCBwYXRocyBmcm9tIGJlaW5nIGRlaHlkcmF0ZWQgaW4gdXBkYXRlcy5cbiAgICAvLyBUaGlzIGlzIGltcG9ydGFudCB0byBhdm9pZCBhIGJhZCB1c2VyIGV4cGVyaWVuY2Ugd2hlcmUgZXhwYW5kZWQgdG9nZ2xlcyBjb2xsYXBzZSBvbiB1cGRhdGUuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzUGF0aEFsbG93ZWQocGF0aCkge1xuICAgICAgc3dpdGNoIChzZWNvbmRhcnlDYXRlZ29yeSkge1xuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAvLyBOZXZlciBkZWh5ZHJhdGUgdGhlIFwiaG9va3NcIiBvYmplY3QgYXQgdGhlIHRvcCBsZXZlbHMuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aFtwYXRoLmxlbmd0aCAtIDJdID09PSAnaG9va1NvdXJjZScgJiYgcGF0aFtwYXRoLmxlbmd0aCAtIDFdID09PSAnZmlsZU5hbWUnKSB7XG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBwcmVzZXJ2ZSB0aGUgZnVsbCBmaWxlIG5hbWUgKFVSTCkgZm9yIGhvb2sgc291cmNlc1xuICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdXNlciBoYXMgZW5hYmxlZCB0aGUgbmFtZWQgaG9va3MgZmVhdHVyZS5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSB0aGUgZnJvbnRlbmQgbWF5IGVuZCB1cCB3aXRoIGEgcGFydGlhbCBVUkwgd2hpY2ggaXQgY2FuJ3QgbG9hZC5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09ICdzdWJIb29rcycgfHwgcGF0aFtwYXRoLmxlbmd0aCAtIDJdID09PSAnc3ViSG9va3MnKSB7XG4gICAgICAgICAgICAvLyBEZWh5ZHJhdGluZyB0aGUgJ3N1Ykhvb2tzJyBwcm9wZXJ0eSBtYWtlcyB0aGUgSG9va3NUcmVlIFVJIGEgbG90IG1vcmUgY29tcGxpY2F0ZWQsXG4gICAgICAgICAgICAvLyBzbyBpdCdzIGVhc2llc3QgZm9yIG5vdyBpZiB3ZSBqdXN0IGRvbid0IGJyZWFrIG9uIHRoaXMgYm91bmRhcnkuXG4gICAgICAgICAgICAvLyBXZSBjYW4gYWx3YXlzIGRlaHlkcmF0ZSBhIGxldmVsIGRlZXBlciAoaW4gdGhlIHZhbHVlIG9iamVjdCkuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudCA9IGtleSA9PT0gbnVsbCA/IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzIDogY3VycmVudGx5SW5zcGVjdGVkUGF0aHNba2V5XTtcblxuICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhbaV1dO1xuXG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0ZWRFbGVtZW50KGluc3BlY3RlZEVsZW1lbnQpIHtcbiAgICB2YXIgaG9va3MgPSBpbnNwZWN0ZWRFbGVtZW50Lmhvb2tzLFxuICAgICAgICBpZCA9IGluc3BlY3RlZEVsZW1lbnQuaWQsXG4gICAgICAgIHByb3BzID0gaW5zcGVjdGVkRWxlbWVudC5wcm9wcztcbiAgICB2YXIgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChmaWJlciA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBGaWJlciB3aXRoIGlkIFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnRUeXBlID0gZmliZXIuZWxlbWVudFR5cGUsXG4gICAgICAgIHN0YXRlTm9kZSA9IGZpYmVyLnN0YXRlTm9kZSxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGdsb2JhbC4kciA9IHN0YXRlTm9kZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIGdsb2JhbC4kciA9IHtcbiAgICAgICAgICBob29rczogaG9va3MsXG4gICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgIHR5cGU6IHR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgZ2xvYmFsLiRyID0ge1xuICAgICAgICAgIGhvb2tzOiBob29rcyxcbiAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgdHlwZTogdHlwZS5yZW5kZXJcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgZ2xvYmFsLiRyID0ge1xuICAgICAgICAgIGhvb2tzOiBob29rcyxcbiAgICAgICAgICBwcm9wczogcHJvcHMsXG4gICAgICAgICAgdHlwZTogZWxlbWVudFR5cGUgIT0gbnVsbCAmJiBlbGVtZW50VHlwZS50eXBlICE9IG51bGwgPyBlbGVtZW50VHlwZS50eXBlIDogdHlwZVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZ2xvYmFsLiRyID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3RvcmVBc0dsb2JhbChpZCwgcGF0aCwgY291bnQpIHtcbiAgICBpZiAoaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0SW5PYmplY3QobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCwgcGF0aCk7XG4gICAgICB2YXIga2V5ID0gXCIkcmVhY3RUZW1wXCIuY29uY2F0KGNvdW50KTtcbiAgICAgIHdpbmRvd1trZXldID0gdmFsdWU7XG4gICAgICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAgY29uc29sZS5sb2codmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlFbGVtZW50UGF0aChpZCwgcGF0aCkge1xuICAgIGlmIChpc01vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQoaWQpKSB7XG4gICAgICBjb3B5VG9DbGlwYm9hcmQoZ2V0SW5PYmplY3QobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCwgcGF0aCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50KHJlcXVlc3RJRCwgaWQsIHBhdGgpIHtcbiAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgbWVyZ2VJbnNwZWN0ZWRQYXRocyhwYXRoKTtcbiAgICB9XG5cbiAgICBpZiAoaXNNb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KGlkKSkge1xuICAgICAgaWYgKCFoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCkge1xuICAgICAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBzZWNvbmRhcnlDYXRlZ29yeSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAocGF0aFswXSA9PT0gJ2hvb2tzJykge1xuICAgICAgICAgICAgc2Vjb25kYXJ5Q2F0ZWdvcnkgPSAnaG9va3MnO1xuICAgICAgICAgIH0gLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBub3QgYmVlbiB1cGRhdGVkIHNpbmNlIGl0IHdhcyBsYXN0IGluc3BlY3RlZCxcbiAgICAgICAgICAvLyB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIHN1YnNldCBvZiBkYXRhIGluIHRoZSBuZXdseS1pbnNwZWN0ZWQgcGF0aC5cblxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHJlc3BvbnNlSUQ6IHJlcXVlc3RJRCxcbiAgICAgICAgICAgIHR5cGU6ICdoeWRyYXRlZC1wYXRoJyxcbiAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICB2YWx1ZTogY2xlYW5Gb3JCcmlkZ2UoZ2V0SW5PYmplY3QobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCwgcGF0aCksIGNyZWF0ZUlzUGF0aEFsbG93ZWQobnVsbCwgc2Vjb25kYXJ5Q2F0ZWdvcnkpLCBwYXRoKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBlbGVtZW50IGhhcyBub3QgYmVlbiB1cGRhdGVkIHNpbmNlIGl0IHdhcyBsYXN0IGluc3BlY3RlZCwgd2UgZG9uJ3QgbmVlZCB0byByZXR1cm4gaXQuXG4gICAgICAgICAgLy8gSW5zdGVhZCB3ZSBjYW4ganVzdCByZXR1cm4gdGhlIElEIHRvIGluZGljYXRlIHRoYXQgaXQgaGFzIG5vdCBjaGFuZ2VkLlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgICAgICB0eXBlOiAnbm8tY2hhbmdlJ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudGx5SW5zcGVjdGVkUGF0aHMgPSB7fTtcbiAgICB9XG5cbiAgICBoYXNFbGVtZW50VXBkYXRlZFNpbmNlTGFzdEluc3BlY3RlZCA9IGZhbHNlO1xuICAgIG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAobW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICAgIHR5cGU6ICdub3QtZm91bmQnXG4gICAgICB9O1xuICAgIH0gLy8gQW55IHRpbWUgYW4gaW5zcGVjdGVkIGVsZW1lbnQgaGFzIGFuIHVwZGF0ZSxcbiAgICAvLyB3ZSBzaG91bGQgdXBkYXRlIHRoZSBzZWxlY3RlZCAkciB2YWx1ZSBhcyB3ZWwuXG4gICAgLy8gRG8gdGhpcyBiZWZvcmUgZGVoeWRyYXRpb24gKGNsZWFuRm9yQnJpZGdlKS5cblxuXG4gICAgdXBkYXRlU2VsZWN0ZWRFbGVtZW50KG1vc3RSZWNlbnRseUluc3BlY3RlZEVsZW1lbnQpOyAvLyBDbG9uZSBiZWZvcmUgY2xlYW5pbmcgc28gdGhhdCB3ZSBwcmVzZXJ2ZSB0aGUgZnVsbCBkYXRhLlxuICAgIC8vIFRoaXMgd2lsbCBlbmFibGUgdXMgdG8gc2VuZCBwYXRjaGVzIHdpdGhvdXQgcmUtaW5zcGVjdGluZyBpZiBoeWRyYXRlZCBwYXRocyBhcmUgcmVxdWVzdGVkLlxuICAgIC8vIChSZWR1Y2luZyBob3cgb2Z0ZW4gd2Ugc2hhbGxvdy1yZW5kZXIgaXMgYSBiZXR0ZXIgRFggZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMgdGhhdCB1c2UgaG9va3MuKVxuXG4gICAgdmFyIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50ID0gcmVuZGVyZXJfb2JqZWN0U3ByZWFkKHt9LCBtb3N0UmVjZW50bHlJbnNwZWN0ZWRFbGVtZW50KTtcblxuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LmNvbnRleHQgPSBjbGVhbkZvckJyaWRnZShjbGVhbmVkSW5zcGVjdGVkRWxlbWVudC5jb250ZXh0LCBjcmVhdGVJc1BhdGhBbGxvd2VkKCdjb250ZXh0JywgbnVsbCkpO1xuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50Lmhvb2tzID0gY2xlYW5Gb3JCcmlkZ2UoY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuaG9va3MsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ2hvb2tzJywgJ2hvb2tzJykpO1xuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnByb3BzID0gY2xlYW5Gb3JCcmlkZ2UoY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQucHJvcHMsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ3Byb3BzJywgbnVsbCkpO1xuICAgIGNsZWFuZWRJbnNwZWN0ZWRFbGVtZW50LnN0YXRlID0gY2xlYW5Gb3JCcmlkZ2UoY2xlYW5lZEluc3BlY3RlZEVsZW1lbnQuc3RhdGUsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ3N0YXRlJywgbnVsbCkpO1xuICAgIHJldHVybiB7XG4gICAgICBpZDogaWQsXG4gICAgICByZXNwb25zZUlEOiByZXF1ZXN0SUQsXG4gICAgICB0eXBlOiAnZnVsbC1kYXRhJyxcbiAgICAgIHZhbHVlOiBjbGVhbmVkSW5zcGVjdGVkRWxlbWVudFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsb2dFbGVtZW50VG9Db25zb2xlKGlkKSB7XG4gICAgdmFyIHJlc3VsdCA9IGlzTW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudEN1cnJlbnQoaWQpID8gbW9zdFJlY2VudGx5SW5zcGVjdGVkRWxlbWVudCA6IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcblxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIEZpYmVyIHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3VwcG9ydHNHcm91cCA9IHR5cGVvZiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkID09PSAnZnVuY3Rpb24nO1xuXG4gICAgaWYgKHN1cHBvcnRzR3JvdXApIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJbQ2xpY2sgdG8gZXhwYW5kXSAlYzxcIi5jb25jYXQocmVzdWx0LmRpc3BsYXlOYW1lIHx8ICdDb21wb25lbnQnLCBcIiAvPlwiKSwgLy8gLS1kb20tdGFnLW5hbWUtY29sb3IgaXMgdGhlIENTUyB2YXJpYWJsZSBDaHJvbWUgc3R5bGVzIEhUTUwgZWxlbWVudHMgd2l0aCBpbiB0aGUgY29uc29sZS5cbiAgICAgICdjb2xvcjogdmFyKC0tZG9tLXRhZy1uYW1lLWNvbG9yKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsnKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnByb3BzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnUHJvcHM6JywgcmVzdWx0LnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnN0YXRlICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RhdGU6JywgcmVzdWx0LnN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0Lmhvb2tzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnSG9va3M6JywgcmVzdWx0Lmhvb2tzKTtcbiAgICB9XG5cbiAgICB2YXIgbmF0aXZlTm9kZXMgPSBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKTtcblxuICAgIGlmIChuYXRpdmVOb2RlcyAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ05vZGVzOicsIG5hdGl2ZU5vZGVzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ0xvY2F0aW9uOicsIHJlc3VsdC5zb3VyY2UpO1xuICAgIH1cblxuICAgIGlmICh3aW5kb3cuY2hyb21lIHx8IC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgY29uc29sZS5sb2coJ1JpZ2h0LWNsaWNrIGFueSB2YWx1ZSB0byBzYXZlIGl0IGFzIGEgZ2xvYmFsIHZhcmlhYmxlIGZvciBmdXJ0aGVyIGluc3BlY3Rpb24uJyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzR3JvdXApIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVQYXRoKHR5cGUsIGlkLCBob29rSUQsIHBhdGgpIHtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgb2YgcHJpbWl0aXZlIGNvbnRleHQgdmFsdWVzIChlLmcuIG51bWJlciwgc3RyaW5nKVxuICAgICAgICAgIC8vIHRoZSBpbnNwZWN0RWxlbWVudCgpIG1ldGhvZCB3cmFwcyBjb250ZXh0IGluIGEge3ZhbHVlOiAuLi59IG9iamVjdC5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGF0aCAodGhlIFwidmFsdWVcIikgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7Ly8gU2ltcGxlIGNvbnRleHQgdmFsdWUgKG5vb3ApXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlUGF0aEluT2JqZWN0KGluc3RhbmNlLmNvbnRleHQsIHBhdGgpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNvbXBvbmVudHMgdXNpbmcgbGVnYWN5IGNvbnRleHQgYXJlIG5vdCBlZGl0YWJsZVxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gaW5zdGFuY2Ugb24gd2hpY2ggdG8gY3JlYXRlIGEgY2xvbmVkLCBtdXRhdGVkIGNvbnRleHQuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoKGZpYmVyLCBob29rSUQsIHBhdGgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgoZmliZXIsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShpbnN0YW5jZS5wcm9wcywgcGF0aCk7XG4gICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICBkZWxldGVQYXRoSW5PYmplY3QoaW5zdGFuY2Uuc3RhdGUsIHBhdGgpO1xuICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuYW1lUGF0aCh0eXBlLCBpZCwgaG9va0lELCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgdmFyIGZpYmVyID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGhCeUlkKGlkKTtcblxuICAgIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgLy8gVG8gc2ltcGxpZnkgaHlkcmF0aW9uIGFuZCBkaXNwbGF5IG9mIHByaW1pdGl2ZSBjb250ZXh0IHZhbHVlcyAoZS5nLiBudW1iZXIsIHN0cmluZylcbiAgICAgICAgICAvLyB0aGUgaW5zcGVjdEVsZW1lbnQoKSBtZXRob2Qgd3JhcHMgY29udGV4dCBpbiBhIHt2YWx1ZTogLi4ufSBvYmplY3QuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byByZW1vdmUgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIHBhdGggKHRoZSBcInZhbHVlXCIpIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgIG9sZFBhdGggPSBvbGRQYXRoLnNsaWNlKDEpO1xuICAgICAgICAgIG5ld1BhdGggPSBuZXdQYXRoLnNsaWNlKDEpO1xuXG4gICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGlmIChvbGRQYXRoLmxlbmd0aCA9PT0gMCkgey8vIFNpbXBsZSBjb250ZXh0IHZhbHVlIChub29wKVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmFtZVBhdGhJbk9iamVjdChpbnN0YW5jZS5jb250ZXh0LCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICAgICAgICAvLyBGdW5jdGlvbiBjb21wb25lbnRzIHVzaW5nIGxlZ2FjeSBjb250ZXh0IGFyZSBub3QgZWRpdGFibGVcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGVyZSdzIG5vIGluc3RhbmNlIG9uIHdoaWNoIHRvIGNyZWF0ZSBhIGNsb25lZCwgbXV0YXRlZCBjb250ZXh0LlxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdob29rcyc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aChmaWJlciwgaG9va0lELCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgaWYgKGluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoKGZpYmVyLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhSZW5hbWUoaW5zdGFuY2UucHJvcHMsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzdGF0ZSc6XG4gICAgICAgICAgcmVuYW1lUGF0aEluT2JqZWN0KGluc3RhbmNlLnN0YXRlLCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlVmFsdWVBdFBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgZmliZXIgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aEJ5SWQoaWQpO1xuXG4gICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAvLyBUbyBzaW1wbGlmeSBoeWRyYXRpb24gYW5kIGRpc3BsYXkgb2YgcHJpbWl0aXZlIGNvbnRleHQgdmFsdWVzIChlLmcuIG51bWJlciwgc3RyaW5nKVxuICAgICAgICAgIC8vIHRoZSBpbnNwZWN0RWxlbWVudCgpIG1ldGhvZCB3cmFwcyBjb250ZXh0IGluIGEge3ZhbHVlOiAuLi59IG9iamVjdC5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSB0aGUgZmlyc3QgcGFydCBvZiB0aGUgcGF0aCAodGhlIFwidmFsdWVcIikgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgcGF0aCA9IHBhdGguc2xpY2UoMSk7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIGNvbnRleHQgdmFsdWVcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jb250ZXh0ID0gdmFsdWU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW5PYmplY3QoaW5zdGFuY2UuY29udGV4dCwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgICAgICAgIC8vIEZ1bmN0aW9uIGNvbXBvbmVudHMgdXNpbmcgbGVnYWN5IGNvbnRleHQgYXJlIG5vdCBlZGl0YWJsZVxuICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlJ3Mgbm8gaW5zdGFuY2Ugb24gd2hpY2ggdG8gY3JlYXRlIGEgY2xvbmVkLCBtdXRhdGVkIGNvbnRleHQuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG92ZXJyaWRlSG9va1N0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvdmVycmlkZUhvb2tTdGF0ZShmaWJlciwgaG9va0lELCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncHJvcHMnOlxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFNldChpbnN0YW5jZS5wcm9wcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvdmVycmlkZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3ZlcnJpZGVQcm9wcyhmaWJlciwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICBzZXRJbk9iamVjdChpbnN0YW5jZS5zdGF0ZSwgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudENvbW1pdFByb2ZpbGluZ01ldGFkYXRhID0gbnVsbDtcbiAgdmFyIGRpc3BsYXlOYW1lc0J5Um9vdElEID0gbnVsbDtcbiAgdmFyIGlkVG9Db250ZXh0c01hcCA9IG51bGw7XG4gIHZhciBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnNNYXAgPSBudWxsO1xuICB2YXIgaW5pdGlhbElEVG9Sb290TWFwID0gbnVsbDtcbiAgdmFyIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gIHZhciBwcm9maWxpbmdTdGFydFRpbWUgPSAwO1xuICB2YXIgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gZmFsc2U7XG4gIHZhciByb290VG9Db21taXRQcm9maWxpbmdNZXRhZGF0YU1hcCA9IG51bGw7XG5cbiAgZnVuY3Rpb24gZ2V0UHJvZmlsaW5nRGF0YSgpIHtcbiAgICB2YXIgZGF0YUZvclJvb3RzID0gW107XG5cbiAgICBpZiAocm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAgPT09IG51bGwpIHtcbiAgICAgIHRocm93IEVycm9yKCdnZXRQcm9maWxpbmdEYXRhKCkgY2FsbGVkIGJlZm9yZSBhbnkgcHJvZmlsaW5nIGRhdGEgd2FzIHJlY29yZGVkJyk7XG4gICAgfVxuXG4gICAgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0UHJvZmlsaW5nTWV0YWRhdGEsIHJvb3RJRCkge1xuICAgICAgdmFyIGNvbW1pdERhdGEgPSBbXTtcbiAgICAgIHZhciBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMgPSBbXTtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lc0J5Um9vdElEICE9PSBudWxsICYmIGRpc3BsYXlOYW1lc0J5Um9vdElELmdldChyb290SUQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcCAhPSBudWxsKSB7XG4gICAgICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcC5mb3JFYWNoKGZ1bmN0aW9uICh0cmVlQmFzZUR1cmF0aW9uLCBpZCkge1xuICAgICAgICAgIGlmIChpbml0aWFsSURUb1Jvb3RNYXAgIT0gbnVsbCAmJiBpbml0aWFsSURUb1Jvb3RNYXAuZ2V0KGlkKSA9PT0gcm9vdElEKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnZlcnQgbWlsbGlzZWNvbmRzIHRvIG1pY3Jvc2Vjb25kcyBpbiB0aGlzIGNhc2UsXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBwcm9maWxpbmcgc3VtbWFyeSBpcyBKU09OIHNlcmlhbGl6ZWQuXG4gICAgICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnMucHVzaChbaWQsIHRyZWVCYXNlRHVyYXRpb25dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb21taXRQcm9maWxpbmdNZXRhZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRQcm9maWxpbmdEYXRhLCBjb21taXRJbmRleCkge1xuICAgICAgICB2YXIgY2hhbmdlRGVzY3JpcHRpb25zID0gY29tbWl0UHJvZmlsaW5nRGF0YS5jaGFuZ2VEZXNjcmlwdGlvbnMsXG4gICAgICAgICAgICBkdXJhdGlvbnMgPSBjb21taXRQcm9maWxpbmdEYXRhLmR1cmF0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdER1cmF0aW9uID0gY29tbWl0UHJvZmlsaW5nRGF0YS5lZmZlY3REdXJhdGlvbixcbiAgICAgICAgICAgIG1heEFjdHVhbER1cmF0aW9uID0gY29tbWl0UHJvZmlsaW5nRGF0YS5tYXhBY3R1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IGNvbW1pdFByb2ZpbGluZ0RhdGEucGFzc2l2ZUVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgICAgcHJpb3JpdHlMZXZlbCA9IGNvbW1pdFByb2ZpbGluZ0RhdGEucHJpb3JpdHlMZXZlbCxcbiAgICAgICAgICAgIGNvbW1pdFRpbWUgPSBjb21taXRQcm9maWxpbmdEYXRhLmNvbW1pdFRpbWUsXG4gICAgICAgICAgICB1cGRhdGVycyA9IGNvbW1pdFByb2ZpbGluZ0RhdGEudXBkYXRlcnM7XG4gICAgICAgIHZhciBmaWJlckFjdHVhbER1cmF0aW9ucyA9IFtdO1xuICAgICAgICB2YXIgZmliZXJTZWxmRHVyYXRpb25zID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkdXJhdGlvbnMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICB2YXIgZmliZXJJRCA9IGR1cmF0aW9uc1tpXTtcbiAgICAgICAgICBmaWJlckFjdHVhbER1cmF0aW9ucy5wdXNoKFtmaWJlcklELCBkdXJhdGlvbnNbaSArIDFdXSk7XG4gICAgICAgICAgZmliZXJTZWxmRHVyYXRpb25zLnB1c2goW2ZpYmVySUQsIGR1cmF0aW9uc1tpICsgMl1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1pdERhdGEucHVzaCh7XG4gICAgICAgICAgY2hhbmdlRGVzY3JpcHRpb25zOiBjaGFuZ2VEZXNjcmlwdGlvbnMgIT09IG51bGwgPyBBcnJheS5mcm9tKGNoYW5nZURlc2NyaXB0aW9ucy5lbnRyaWVzKCkpIDogbnVsbCxcbiAgICAgICAgICBkdXJhdGlvbjogbWF4QWN0dWFsRHVyYXRpb24sXG4gICAgICAgICAgZWZmZWN0RHVyYXRpb246IGVmZmVjdER1cmF0aW9uLFxuICAgICAgICAgIGZpYmVyQWN0dWFsRHVyYXRpb25zOiBmaWJlckFjdHVhbER1cmF0aW9ucyxcbiAgICAgICAgICBmaWJlclNlbGZEdXJhdGlvbnM6IGZpYmVyU2VsZkR1cmF0aW9ucyxcbiAgICAgICAgICBwYXNzaXZlRWZmZWN0RHVyYXRpb246IHBhc3NpdmVFZmZlY3REdXJhdGlvbixcbiAgICAgICAgICBwcmlvcml0eUxldmVsOiBwcmlvcml0eUxldmVsLFxuICAgICAgICAgIHRpbWVzdGFtcDogY29tbWl0VGltZSxcbiAgICAgICAgICB1cGRhdGVyczogdXBkYXRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGRhdGFGb3JSb290cy5wdXNoKHtcbiAgICAgICAgY29tbWl0RGF0YTogY29tbWl0RGF0YSxcbiAgICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgICBpbml0aWFsVHJlZUJhc2VEdXJhdGlvbnM6IGluaXRpYWxUcmVlQmFzZUR1cmF0aW9ucyxcbiAgICAgICAgcm9vdElEOiByb290SURcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBkYXRhRm9yUm9vdHM6IGRhdGFGb3JSb290cyxcbiAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySURcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRQcm9maWxpbmcoc2hvdWxkUmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zKSB7XG4gICAgaWYgKGlzUHJvZmlsaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gc2hvdWxkUmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zOyAvLyBDYXB0dXJlIGluaXRpYWwgdmFsdWVzIGFzIG9mIHRoZSB0aW1lIHByb2ZpbGluZyBzdGFydHMuXG4gICAgLy8gSXQncyBpbXBvcnRhbnQgd2Ugc25hcHNob3QgYm90aCB0aGUgZHVyYXRpb25zIGFuZCB0aGUgaWQtdG8tcm9vdCBtYXAsXG4gICAgLy8gc2luY2UgZWl0aGVyIG9mIHRoZXNlIG1heSBjaGFuZ2UgZHVyaW5nIHRoZSBwcm9maWxpbmcgc2Vzc2lvblxuICAgIC8vIChlLmcuIHdoZW4gYSBmaWJlciBpcyByZS1yZW5kZXJlZCBvciB3aGVuIGEgZmliZXIgZ2V0cyByZW1vdmVkKS5cblxuICAgIGRpc3BsYXlOYW1lc0J5Um9vdElEID0gbmV3IE1hcCgpO1xuICAgIGluaXRpYWxUcmVlQmFzZUR1cmF0aW9uc01hcCA9IG5ldyBNYXAoaWRUb1RyZWVCYXNlRHVyYXRpb25NYXApO1xuICAgIGluaXRpYWxJRFRvUm9vdE1hcCA9IG5ldyBNYXAoaWRUb1Jvb3RNYXApO1xuICAgIGlkVG9Db250ZXh0c01hcCA9IG5ldyBNYXAoKTtcbiAgICBob29rLmdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCkuZm9yRWFjaChmdW5jdGlvbiAocm9vdCkge1xuICAgICAgdmFyIHJvb3RJRCA9IGdldEZpYmVySURUaHJvd3Mocm9vdC5jdXJyZW50KTtcbiAgICAgIGRpc3BsYXlOYW1lc0J5Um9vdElELnNldChyb290SUQsIGdldERpc3BsYXlOYW1lRm9yUm9vdChyb290LmN1cnJlbnQpKTtcblxuICAgICAgaWYgKHNob3VsZFJlY29yZENoYW5nZURlc2NyaXB0aW9ucykge1xuICAgICAgICAvLyBSZWNvcmQgYWxsIGNvbnRleHRzIGF0IHRoZSB0aW1lIHByb2ZpbGluZyBpcyBzdGFydGVkLlxuICAgICAgICAvLyBGaWJlcnMgb25seSBzdG9yZSB0aGUgY3VycmVudCBjb250ZXh0IHZhbHVlLFxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHRyYWNrIHRoZW0gc2VwYXJhdGVseSBpbiBvcmRlciB0byBkZXRlcm1pbmUgY2hhbmdlZCBrZXlzLlxuICAgICAgICBjcmF3bFRvSW5pdGlhbGl6ZUNvbnRleHRzTWFwKHJvb3QuY3VycmVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaXNQcm9maWxpbmcgPSB0cnVlO1xuICAgIHByb2ZpbGluZ1N0YXJ0VGltZSA9IHJlbmRlcmVyX2dldEN1cnJlbnRUaW1lKCk7XG4gICAgcm9vdFRvQ29tbWl0UHJvZmlsaW5nTWV0YWRhdGFNYXAgPSBuZXcgTWFwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBzdG9wUHJvZmlsaW5nKCkge1xuICAgIGlzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gZmFsc2U7XG4gIH0gLy8gQXV0b21hdGljYWxseSBzdGFydCBwcm9maWxpbmcgc28gdGhhdCB3ZSBkb24ndCBtaXNzIHRpbWluZyBpbmZvIGZyb20gaW5pdGlhbCBcIm1vdW50XCIuXG5cblxuICBpZiAoc2Vzc2lvblN0b3JhZ2VHZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZKSA9PT0gJ3RydWUnKSB7XG4gICAgc3RhcnRQcm9maWxpbmcoc2Vzc2lvblN0b3JhZ2VHZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkpID09PSAndHJ1ZScpO1xuICB9IC8vIFJlYWN0IHdpbGwgc3dpdGNoIGJldHdlZW4gdGhlc2UgaW1wbGVtZW50YXRpb25zIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gIC8vIHdlIGhhdmUgYW55IG1hbnVhbGx5IHN1c3BlbmRlZC9lcnJvcmVkLW91dCBGaWJlcnMgb3Igbm90LlxuXG5cbiAgZnVuY3Rpb24gc2hvdWxkRXJyb3JGaWJlckFsd2F5c051bGwoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gTWFwIG9mIGlkIGFuZCBpdHMgZm9yY2UgZXJyb3Igc3RhdHVzOiB0cnVlIChlcnJvciksIGZhbHNlICh0b2dnbGVkIG9mZiksXG4gIC8vIG51bGwgKGRvIG5vdGhpbmcpXG5cblxuICB2YXIgZm9yY2VFcnJvckZvckZpYmVySURzID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIHNob3VsZEVycm9yRmliZXJBY2NvcmRpbmdUb01hcChmaWJlcikge1xuICAgIGlmICh0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG92ZXJyaWRlRXJyb3IoKSB0byBub3QgZ2V0IGNhbGxlZCBmb3IgZWFybGllciBSZWFjdCB2ZXJzaW9ucy4nKTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBnZXRGaWJlcklEVW5zYWZlKGZpYmVyKTtcblxuICAgIGlmIChpZCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHN0YXR1cyA9IG51bGw7XG5cbiAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVySURzLmhhcyhpZCkpIHtcbiAgICAgIHN0YXR1cyA9IGZvcmNlRXJyb3JGb3JGaWJlcklEcy5nZXQoaWQpO1xuXG4gICAgICBpZiAoc3RhdHVzID09PSBmYWxzZSkge1xuICAgICAgICAvLyBUUklDS1kgb3ZlcnJpZGVFcnJvciBhZGRzIGVudHJpZXMgdG8gdGhpcyBNYXAsXG4gICAgICAgIC8vIHNvIGlkZWFsbHkgaXQgd291bGQgYmUgdGhlIG1ldGhvZCB0aGF0IGNsZWFycyB0aGVtIHRvbyxcbiAgICAgICAgLy8gYnV0IHRoYXQgd291bGQgYnJlYWsgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgdGhlIGZlYXR1cmUsXG4gICAgICAgIC8vIHNpbmNlIERldlRvb2xzIG5lZWRzIHRvIHRlbGwgUmVhY3QgdG8gYWN0IGRpZmZlcmVudGx5IHRoYW4gaXQgbm9ybWFsbHkgd291bGRcbiAgICAgICAgLy8gKGRvbid0IGp1c3QgcmUtcmVuZGVyIHRoZSBmYWlsZWQgYm91bmRhcnksIGJ1dCByZXNldCBpdHMgZXJyb3JlZCBzdGF0ZSB0b28pLlxuICAgICAgICAvLyBTbyB3ZSBjYW4gb25seSBjbGVhciBpdCBhZnRlciB0ZWxsaW5nIFJlYWN0IHRvIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBpcyBwcmVtYXR1cmUgYW5kIHdlIHNob3VsZCBzY2hlZHVsZSBpdCBmb3IgbGF0ZXIsXG4gICAgICAgIC8vIHNpbmNlIHRoZSByZW5kZXIgY291bGQgYWx3YXlzIGZhaWwgd2l0aG91dCBjb21taXR0aW5nIHRoZSB1cGRhdGVkIGVycm9yIGJvdW5kYXJ5LFxuICAgICAgICAvLyBidXQgc2luY2UgdGhpcyBpcyBhIERFVi1vbmx5IGZlYXR1cmUsIHRoZSBzaW1wbGljaXR5IGlzIHdvcnRoIHRoZSB0cmFkZSBvZmYuXG4gICAgICAgIGZvcmNlRXJyb3JGb3JGaWJlcklEcy5kZWxldGUoaWQpO1xuXG4gICAgICAgIGlmIChmb3JjZUVycm9yRm9yRmliZXJJRHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgIC8vIExhc3Qgb3ZlcnJpZGUgaXMgZ29uZS4gU3dpdGNoIFJlYWN0IGJhY2sgdG8gZmFzdCBwYXRoLlxuICAgICAgICAgIHNldEVycm9ySGFuZGxlcihzaG91bGRFcnJvckZpYmVyQWx3YXlzTnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdHVzO1xuICB9XG5cbiAgZnVuY3Rpb24gb3ZlcnJpZGVFcnJvcihpZCwgZm9yY2VFcnJvcikge1xuICAgIGlmICh0eXBlb2Ygc2V0RXJyb3JIYW5kbGVyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBzY2hlZHVsZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBvdmVycmlkZUVycm9yKCkgdG8gbm90IGdldCBjYWxsZWQgZm9yIGVhcmxpZXIgUmVhY3QgdmVyc2lvbnMuJyk7XG4gICAgfVxuXG4gICAgZm9yY2VFcnJvckZvckZpYmVySURzLnNldChpZCwgZm9yY2VFcnJvcik7XG5cbiAgICBpZiAoZm9yY2VFcnJvckZvckZpYmVySURzLnNpemUgPT09IDEpIHtcbiAgICAgIC8vIEZpcnN0IG92ZXJyaWRlIGlzIGFkZGVkLiBTd2l0Y2ggUmVhY3QgdG8gc2xvd2VyIHBhdGguXG4gICAgICBzZXRFcnJvckhhbmRsZXIoc2hvdWxkRXJyb3JGaWJlckFjY29yZGluZ1RvTWFwKTtcbiAgICB9XG5cbiAgICB2YXIgZmliZXIgPSBpZFRvQXJiaXRyYXJ5RmliZXJNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChmaWJlciAhPSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZShmaWJlcik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkU3VzcGVuZEZpYmVyQWx3YXlzRmFsc2UoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcyA9IG5ldyBTZXQoKTtcblxuICBmdW5jdGlvbiBzaG91bGRTdXNwZW5kRmliZXJBY2NvcmRpbmdUb1NldChmaWJlcikge1xuICAgIHZhciBtYXliZUlEID0gZ2V0RmliZXJJRFVuc2FmZShmaWJlcik7XG4gICAgcmV0dXJuIG1heWJlSUQgIT09IG51bGwgJiYgZm9yY2VGYWxsYmFja0ZvclN1c3BlbnNlSURzLmhhcyhtYXliZUlEKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlU3VzcGVuc2UoaWQsIGZvcmNlRmFsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHNldFN1c3BlbnNlSGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2Ygc2NoZWR1bGVVcGRhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgb3ZlcnJpZGVTdXNwZW5zZSgpIHRvIG5vdCBnZXQgY2FsbGVkIGZvciBlYXJsaWVyIFJlYWN0IHZlcnNpb25zLicpO1xuICAgIH1cblxuICAgIGlmIChmb3JjZUZhbGxiYWNrKSB7XG4gICAgICBmb3JjZUZhbGxiYWNrRm9yU3VzcGVuc2VJRHMuYWRkKGlkKTtcblxuICAgICAgaWYgKGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5zaXplID09PSAxKSB7XG4gICAgICAgIC8vIEZpcnN0IG92ZXJyaWRlIGlzIGFkZGVkLiBTd2l0Y2ggUmVhY3QgdG8gc2xvd2VyIHBhdGguXG4gICAgICAgIHNldFN1c3BlbnNlSGFuZGxlcihzaG91bGRTdXNwZW5kRmliZXJBY2NvcmRpbmdUb1NldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcmNlRmFsbGJhY2tGb3JTdXNwZW5zZUlEcy5kZWxldGUoaWQpO1xuXG4gICAgICBpZiAoZm9yY2VGYWxsYmFja0ZvclN1c3BlbnNlSURzLnNpemUgPT09IDApIHtcbiAgICAgICAgLy8gTGFzdCBvdmVycmlkZSBpcyBnb25lLiBTd2l0Y2ggUmVhY3QgYmFjayB0byBmYXN0IHBhdGguXG4gICAgICAgIHNldFN1c3BlbnNlSGFuZGxlcihzaG91bGRTdXNwZW5kRmliZXJBbHdheXNGYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgIT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGUoZmliZXIpO1xuICAgIH1cbiAgfSAvLyBSZW1lbWJlciBpZiB3ZSdyZSB0cnlpbmcgdG8gcmVzdG9yZSB0aGUgc2VsZWN0aW9uIGFmdGVyIHJlbG9hZC5cbiAgLy8gSW4gdGhhdCBjYXNlLCB3ZSdsbCBkbyBzb21lIGV4dHJhIGNoZWNrcyBmb3IgbWF0Y2hpbmcgbW91bnRzLlxuXG5cbiAgdmFyIHRyYWNrZWRQYXRoID0gbnVsbDtcbiAgdmFyIHRyYWNrZWRQYXRoTWF0Y2hGaWJlciA9IG51bGw7XG4gIHZhciB0cmFja2VkUGF0aE1hdGNoRGVwdGggPSAtMTtcbiAgdmFyIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gc2V0VHJhY2tlZFBhdGgocGF0aCkge1xuICAgIGlmIChwYXRoID09PSBudWxsKSB7XG4gICAgICB0cmFja2VkUGF0aE1hdGNoRmliZXIgPSBudWxsO1xuICAgICAgdHJhY2tlZFBhdGhNYXRjaERlcHRoID0gLTE7XG4gICAgICBtaWdodEJlT25UcmFja2VkUGF0aCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRyYWNrZWRQYXRoID0gcGF0aDtcbiAgfSAvLyBXZSBjYWxsIHRoaXMgYmVmb3JlIHRyYXZlcnNpbmcgYSBuZXcgbW91bnQuXG4gIC8vIEl0IHJlbWVtYmVycyB3aGV0aGVyIHRoaXMgRmliZXIgaXMgdGhlIG5leHQgYmVzdCBtYXRjaCBmb3IgdHJhY2tlZCBwYXRoLlxuICAvLyBUaGUgcmV0dXJuIHZhbHVlIHNpZ25hbHMgd2hldGhlciB3ZSBzaG91bGQga2VlcCBtYXRjaGluZyBzaWJsaW5ncyBvciBub3QuXG5cblxuICBmdW5jdGlvbiB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoZmliZXIpIHtcbiAgICBpZiAodHJhY2tlZFBhdGggPT09IG51bGwgfHwgIW1pZ2h0QmVPblRyYWNrZWRQYXRoKSB7XG4gICAgICAvLyBGYXN0IHBhdGg6IHRoZXJlJ3Mgbm90aGluZyB0byB0cmFjayBzbyBkbyBub3RoaW5nIGFuZCBpZ25vcmUgc2libGluZ3MuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHJldHVybkZpYmVyID0gZmliZXIucmV0dXJuO1xuICAgIHZhciByZXR1cm5BbHRlcm5hdGUgPSByZXR1cm5GaWJlciAhPT0gbnVsbCA/IHJldHVybkZpYmVyLmFsdGVybmF0ZSA6IG51bGw7IC8vIEJ5IG5vdyB3ZSBrbm93IHRoZXJlJ3Mgc29tZSBzZWxlY3Rpb24gdG8gcmVzdG9yZSwgYW5kIHRoaXMgaXMgYSBuZXcgRmliZXIuXG4gICAgLy8gSXMgdGhpcyBuZXdseSBtb3VudGVkIEZpYmVyIGEgZGlyZWN0IGNoaWxkIG9mIHRoZSBjdXJyZW50IGJlc3QgbWF0Y2g/XG4gICAgLy8gKFRoaXMgd2lsbCBhbHNvIGJlIHRydWUgZm9yIG5ldyByb290cyBpZiB3ZSBoYXZlbid0IG1hdGNoZWQgYW55dGhpbmcgeWV0LilcblxuICAgIGlmICh0cmFja2VkUGF0aE1hdGNoRmliZXIgPT09IHJldHVybkZpYmVyIHx8IHRyYWNrZWRQYXRoTWF0Y2hGaWJlciA9PT0gcmV0dXJuQWx0ZXJuYXRlICYmIHJldHVybkFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gSXMgdGhpcyB0aGUgbmV4dCBGaWJlciB3ZSBzaG91bGQgc2VsZWN0PyBMZXQncyBjb21wYXJlIHRoZSBmcmFtZXMuXG4gICAgICB2YXIgYWN0dWFsRnJhbWUgPSBnZXRQYXRoRnJhbWUoZmliZXIpO1xuICAgICAgdmFyIGV4cGVjdGVkRnJhbWUgPSB0cmFja2VkUGF0aFt0cmFja2VkUGF0aE1hdGNoRGVwdGggKyAxXTtcblxuICAgICAgaWYgKGV4cGVjdGVkRnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHNlZSBhIGZyYW1lIGF0IHRoZSBuZXh0IGRlcHRoLicpO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWN0dWFsRnJhbWUuaW5kZXggPT09IGV4cGVjdGVkRnJhbWUuaW5kZXggJiYgYWN0dWFsRnJhbWUua2V5ID09PSBleHBlY3RlZEZyYW1lLmtleSAmJiBhY3R1YWxGcmFtZS5kaXNwbGF5TmFtZSA9PT0gZXhwZWN0ZWRGcmFtZS5kaXNwbGF5TmFtZSkge1xuICAgICAgICAvLyBXZSBoYXZlIG91ciBuZXh0IG1hdGNoLlxuICAgICAgICB0cmFja2VkUGF0aE1hdGNoRmliZXIgPSBmaWJlcjtcbiAgICAgICAgdHJhY2tlZFBhdGhNYXRjaERlcHRoKys7IC8vIEFyZSB3ZSBvdXQgb2YgZnJhbWVzIHRvIG1hdGNoP1xuXG4gICAgICAgIGlmICh0cmFja2VkUGF0aE1hdGNoRGVwdGggPT09IHRyYWNrZWRQYXRoLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBUaGVyZSdzIG5vdGhpbmcgdGhhdCBjYW4gcG9zc2libHkgbWF0Y2ggYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAvLyBEb24ndCBjaGVjayB0aGUgY2hpbGRyZW4uXG4gICAgICAgICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDaGVjayB0aGUgY2hpbGRyZW4sIGFzIHRoZXkgbWlnaHQgcmV2ZWFsIHRoZSBuZXh0IG1hdGNoLlxuICAgICAgICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gdHJ1ZTtcbiAgICAgICAgfSAvLyBJbiBlaXRoZXIgY2FzZSwgc2luY2Ugd2UgaGF2ZSBhIG1hdGNoLCB3ZSBkb24ndCBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRoZSBzaWJsaW5ncy4gVGhleSdsbCBuZXZlciBtYXRjaC5cblxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IC8vIFRoaXMgRmliZXIncyBwYXJlbnQgaXMgb24gdGhlIHBhdGgsIGJ1dCB0aGlzIEZpYmVyIGl0c2VsZiBpc24ndC5cbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgaXRzIGNoaWxkcmVuLS10aGV5IHdvbid0IGJlIG9uIHRoZSBwYXRoIGVpdGhlci5cblxuXG4gICAgbWlnaHRCZU9uVHJhY2tlZFBhdGggPSBmYWxzZTsgLy8gSG93ZXZlciwgb25lIG9mIGl0cyBzaWJsaW5ncyBtYXkgYmUgb24gdGhlIHBhdGggc28ga2VlcCBzZWFyY2hpbmcuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRyYWNrZWRQYXRoU3RhdGVBZnRlck1vdW50KG1pZ2h0U2libGluZ3NCZU9uVHJhY2tlZFBhdGgpIHtcbiAgICAvLyB1cGRhdGVUcmFja2VkUGF0aFN0YXRlQmVmb3JlTW91bnQoKSB0b2xkIHVzIHdoZXRoZXIgdG8gbWF0Y2ggc2libGluZ3MuXG4gICAgLy8gTm93IHRoYXQgd2UncmUgZW50ZXJpbmcgc2libGluZ3MsIGxldCdzIHVzZSB0aGF0IGluZm9ybWF0aW9uLlxuICAgIG1pZ2h0QmVPblRyYWNrZWRQYXRoID0gbWlnaHRTaWJsaW5nc0JlT25UcmFja2VkUGF0aDtcbiAgfSAvLyBSb290cyBkb24ndCBoYXZlIGEgcmVhbCBwZXJzaXN0ZW50IGlkZW50aXR5LlxuICAvLyBBIHJvb3QncyBcInBzZXVkbyBrZXlcIiBpcyBcImNoaWxkRGlzcGxheU5hbWU6aW5kZXhXaXRoVGhhdE5hbWVcIi5cbiAgLy8gRm9yIGV4YW1wbGUsIFwiQXBwOjBcIiBvciwgaW4gY2FzZSBvZiBzaW1pbGFyIHJvb3RzLCBcIlN0b3J5OjBcIiwgXCJTdG9yeToxXCIsIGV0Yy5cbiAgLy8gV2Ugd2lsbCB1c2UgdGhpcyB0byB0cnkgdG8gZGlzYW1iaWd1YXRlIHJvb3RzIHdoZW4gcmVzdG9yaW5nIHNlbGVjdGlvbiBiZXR3ZWVuIHJlbG9hZHMuXG5cblxuICB2YXIgcm9vdFBzZXVkb0tleXMgPSBuZXcgTWFwKCk7XG4gIHZhciByb290RGlzcGxheU5hbWVDb3VudGVyID0gbmV3IE1hcCgpO1xuXG4gIGZ1bmN0aW9uIHNldFJvb3RQc2V1ZG9LZXkoaWQsIGZpYmVyKSB7XG4gICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZUZvclJvb3QoZmliZXIpO1xuICAgIHZhciBjb3VudGVyID0gcm9vdERpc3BsYXlOYW1lQ291bnRlci5nZXQobmFtZSkgfHwgMDtcbiAgICByb290RGlzcGxheU5hbWVDb3VudGVyLnNldChuYW1lLCBjb3VudGVyICsgMSk7XG4gICAgdmFyIHBzZXVkb0tleSA9IFwiXCIuY29uY2F0KG5hbWUsIFwiOlwiKS5jb25jYXQoY291bnRlcik7XG4gICAgcm9vdFBzZXVkb0tleXMuc2V0KGlkLCBwc2V1ZG9LZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlUm9vdFBzZXVkb0tleShpZCkge1xuICAgIHZhciBwc2V1ZG9LZXkgPSByb290UHNldWRvS2V5cy5nZXQoaWQpO1xuXG4gICAgaWYgKHBzZXVkb0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJvb3QgcHNldWRvIGtleSB0byBiZSBrbm93bi4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IHBzZXVkb0tleS5zdWJzdHJpbmcoMCwgcHNldWRvS2V5Lmxhc3RJbmRleE9mKCc6JykpO1xuICAgIHZhciBjb3VudGVyID0gcm9vdERpc3BsYXlOYW1lQ291bnRlci5nZXQobmFtZSk7XG5cbiAgICBpZiAoY291bnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGNvdW50ZXIgdG8gYmUga25vd24uJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvdW50ZXIgPiAxKSB7XG4gICAgICByb290RGlzcGxheU5hbWVDb3VudGVyLnNldChuYW1lLCBjb3VudGVyIC0gMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3REaXNwbGF5TmFtZUNvdW50ZXIuZGVsZXRlKG5hbWUpO1xuICAgIH1cblxuICAgIHJvb3RQc2V1ZG9LZXlzLmRlbGV0ZShpZCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREaXNwbGF5TmFtZUZvclJvb3QoZmliZXIpIHtcbiAgICB2YXIgcHJlZmVycmVkRGlzcGxheU5hbWUgPSBudWxsO1xuICAgIHZhciBmYWxsYmFja0Rpc3BsYXlOYW1lID0gbnVsbDtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgLy8gR28gYXQgbW9zdCB0aHJlZSBsZXZlbHMgZGVlcCBpbnRvIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIHdoaWxlIHNlYXJjaGluZyBmb3IgYSBjaGlsZCB0aGF0IGhhcyBhIGRpc3BsYXlOYW1lLlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWVGb3JGaWJlcihjaGlsZCk7XG5cbiAgICAgIGlmIChkaXNwbGF5TmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBQcmVmZXIgZGlzcGxheSBuYW1lcyB0aGF0IHdlIGdldCBmcm9tIHVzZXItZGVmaW5lZCBjb21wb25lbnRzLlxuICAgICAgICAvLyBXZSB3YW50IHRvIGF2b2lkIHVzaW5nIGUuZy4gJ1N1c3BlbnNlJyB1bmxlc3Mgd2UgZmluZCBub3RoaW5nIGVsc2UuXG4gICAgICAgIGlmICh0eXBlb2YgY2hpbGQudHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIFRoZXJlJ3MgYSBmZXcgdXNlci1kZWZpbmVkIHRhZ3MsIGJ1dCB3ZSdsbCBwcmVmZXIgdGhlIG9uZXNcbiAgICAgICAgICAvLyB0aGF0IGFyZSB1c3VhbGx5IGV4cGxpY2l0bHkgbmFtZWQgKGZ1bmN0aW9uIG9yIGNsYXNzIGNvbXBvbmVudHMpLlxuICAgICAgICAgIHByZWZlcnJlZERpc3BsYXlOYW1lID0gZGlzcGxheU5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZmFsbGJhY2tEaXNwbGF5TmFtZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGZhbGxiYWNrRGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJlZmVycmVkRGlzcGxheU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuY2hpbGQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZlcnJlZERpc3BsYXlOYW1lIHx8IGZhbGxiYWNrRGlzcGxheU5hbWUgfHwgJ0Fub255bW91cyc7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXRoRnJhbWUoZmliZXIpIHtcbiAgICB2YXIga2V5ID0gZmliZXIua2V5O1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldERpc3BsYXlOYW1lRm9yRmliZXIoZmliZXIpO1xuICAgIHZhciBpbmRleCA9IGZpYmVyLmluZGV4O1xuXG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIC8vIFJvb3RzIGRvbid0IGhhdmUgYSByZWFsIGRpc3BsYXlOYW1lLCBpbmRleCwgb3Iga2V5LlxuICAgICAgICAvLyBJbnN0ZWFkLCB3ZSdsbCB1c2UgdGhlIHBzZXVkbyBrZXkgKGNoaWxkRGlzcGxheU5hbWU6aW5kZXhXaXRoVGhhdE5hbWUpLlxuICAgICAgICB2YXIgaWQgPSBnZXRGaWJlcklEVGhyb3dzKGZpYmVyKTtcbiAgICAgICAgdmFyIHBzZXVkb0tleSA9IHJvb3RQc2V1ZG9LZXlzLmdldChpZCk7XG5cbiAgICAgICAgaWYgKHBzZXVkb0tleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBtb3VudGVkIHJvb3QgdG8gaGF2ZSBrbm93biBwc2V1ZG8ga2V5LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGxheU5hbWUgPSBwc2V1ZG9LZXk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIGRpc3BsYXlOYW1lID0gZmliZXIudHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXNwbGF5TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIGluZGV4OiBpbmRleFxuICAgIH07XG4gIH0gLy8gUHJvZHVjZXMgYSBzZXJpYWxpemFibGUgcmVwcmVzZW50YXRpb24gdGhhdCBkb2VzIGEgYmVzdCBlZmZvcnRcbiAgLy8gb2YgaWRlbnRpZnlpbmcgYSBwYXJ0aWN1bGFyIEZpYmVyIGJldHdlZW4gcGFnZSByZWxvYWRzLlxuICAvLyBUaGUgcmV0dXJuIHBhdGggd2lsbCBjb250YWluIEZpYmVycyB0aGF0IGFyZSBcImludmlzaWJsZVwiIHRvIHRoZSBzdG9yZVxuICAvLyBiZWNhdXNlIHRoZWlyIGtleXMgYW5kIGluZGV4ZXMgYXJlIGltcG9ydGFudCB0byByZXN0b3JpbmcgdGhlIHNlbGVjdGlvbi5cblxuXG4gIGZ1bmN0aW9uIGdldFBhdGhGb3JFbGVtZW50KGlkKSB7XG4gICAgdmFyIGZpYmVyID0gaWRUb0FyYml0cmFyeUZpYmVyTWFwLmdldChpZCk7XG5cbiAgICBpZiAoZmliZXIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGtleVBhdGggPSBbXTtcblxuICAgIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgICAga2V5UGF0aC5wdXNoKGdldFBhdGhGcmFtZShmaWJlcikpO1xuICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgfVxuXG4gICAga2V5UGF0aC5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGtleVBhdGg7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCgpIHtcbiAgICBpZiAodHJhY2tlZFBhdGggPT09IG51bGwpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gbWF0Y2guXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodHJhY2tlZFBhdGhNYXRjaEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBXZSBkaWRuJ3QgZmluZCBhbnl0aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gRmluZCB0aGUgY2xvc2VzdCBGaWJlciBzdG9yZSBpcyBhd2FyZSBvZi5cblxuXG4gICAgdmFyIGZpYmVyID0gdHJhY2tlZFBhdGhNYXRjaEZpYmVyO1xuXG4gICAgd2hpbGUgKGZpYmVyICE9PSBudWxsICYmIHNob3VsZEZpbHRlckZpYmVyKGZpYmVyKSkge1xuICAgICAgZmliZXIgPSBmaWJlci5yZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGdldEZpYmVySURUaHJvd3MoZmliZXIpLFxuICAgICAgaXNGdWxsTWF0Y2g6IHRyYWNrZWRQYXRoTWF0Y2hEZXB0aCA9PT0gdHJhY2tlZFBhdGgubGVuZ3RoIC0gMVxuICAgIH07XG4gIH1cblxuICB2YXIgZm9ybWF0UHJpb3JpdHlMZXZlbCA9IGZ1bmN0aW9uIGZvcm1hdFByaW9yaXR5TGV2ZWwocHJpb3JpdHlMZXZlbCkge1xuICAgIGlmIChwcmlvcml0eUxldmVsID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnVW5rbm93bic7XG4gICAgfVxuXG4gICAgc3dpdGNoIChwcmlvcml0eUxldmVsKSB7XG4gICAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgICByZXR1cm4gJ0ltbWVkaWF0ZSc7XG5cbiAgICAgIGNhc2UgVXNlckJsb2NraW5nUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnVXNlci1CbG9ja2luZyc7XG5cbiAgICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAgIHJldHVybiAnTm9ybWFsJztcblxuICAgICAgY2FzZSBMb3dQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdMb3cnO1xuXG4gICAgICBjYXNlIElkbGVQcmlvcml0eTpcbiAgICAgICAgcmV0dXJuICdJZGxlJztcblxuICAgICAgY2FzZSBOb1ByaW9yaXR5OlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0VHJhY2VVcGRhdGVzRW5hYmxlZChpc0VuYWJsZWQpIHtcbiAgICB0cmFjZVVwZGF0ZXNFbmFibGVkID0gaXNFbmFibGVkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgIGNsZWFyRXJyb3JzQW5kV2FybmluZ3M6IGNsZWFyRXJyb3JzQW5kV2FybmluZ3MsXG4gICAgY2xlYXJFcnJvcnNGb3JGaWJlcklEOiBjbGVhckVycm9yc0ZvckZpYmVySUQsXG4gICAgY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQ6IGNsZWFyV2FybmluZ3NGb3JGaWJlcklELFxuICAgIGNvcHlFbGVtZW50UGF0aDogY29weUVsZW1lbnRQYXRoLFxuICAgIGRlbGV0ZVBhdGg6IGRlbGV0ZVBhdGgsXG4gICAgZmluZE5hdGl2ZU5vZGVzRm9yRmliZXJJRDogZmluZE5hdGl2ZU5vZGVzRm9yRmliZXJJRCxcbiAgICBmbHVzaEluaXRpYWxPcGVyYXRpb25zOiBmbHVzaEluaXRpYWxPcGVyYXRpb25zLFxuICAgIGdldEJlc3RNYXRjaEZvclRyYWNrZWRQYXRoOiBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCxcbiAgICBnZXREaXNwbGF5TmFtZUZvckZpYmVySUQ6IGdldERpc3BsYXlOYW1lRm9yRmliZXJJRCxcbiAgICBnZXRGaWJlcklERm9yTmF0aXZlOiBnZXRGaWJlcklERm9yTmF0aXZlLFxuICAgIGdldEluc3RhbmNlQW5kU3R5bGU6IGdldEluc3RhbmNlQW5kU3R5bGUsXG4gICAgZ2V0T3duZXJzTGlzdDogZ2V0T3duZXJzTGlzdCxcbiAgICBnZXRQYXRoRm9yRWxlbWVudDogZ2V0UGF0aEZvckVsZW1lbnQsXG4gICAgZ2V0UHJvZmlsaW5nRGF0YTogZ2V0UHJvZmlsaW5nRGF0YSxcbiAgICBoYW5kbGVDb21taXRGaWJlclJvb3Q6IGhhbmRsZUNvbW1pdEZpYmVyUm9vdCxcbiAgICBoYW5kbGVDb21taXRGaWJlclVubW91bnQ6IGhhbmRsZUNvbW1pdEZpYmVyVW5tb3VudCxcbiAgICBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290OiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290LFxuICAgIGluc3BlY3RFbGVtZW50OiBpbnNwZWN0RWxlbWVudCxcbiAgICBsb2dFbGVtZW50VG9Db25zb2xlOiBsb2dFbGVtZW50VG9Db25zb2xlLFxuICAgIHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlOiBwcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZSxcbiAgICBwcmVwYXJlVmlld0VsZW1lbnRTb3VyY2U6IHByZXBhcmVWaWV3RWxlbWVudFNvdXJjZSxcbiAgICBvdmVycmlkZUVycm9yOiBvdmVycmlkZUVycm9yLFxuICAgIG92ZXJyaWRlU3VzcGVuc2U6IG92ZXJyaWRlU3VzcGVuc2UsXG4gICAgb3ZlcnJpZGVWYWx1ZUF0UGF0aDogb3ZlcnJpZGVWYWx1ZUF0UGF0aCxcbiAgICByZW5hbWVQYXRoOiByZW5hbWVQYXRoLFxuICAgIHJlbmRlcmVyOiByZW5kZXJlcixcbiAgICBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkOiBzZXRUcmFjZVVwZGF0ZXNFbmFibGVkLFxuICAgIHNldFRyYWNrZWRQYXRoOiBzZXRUcmFja2VkUGF0aCxcbiAgICBzdGFydFByb2ZpbGluZzogc3RhcnRQcm9maWxpbmcsXG4gICAgc3RvcFByb2ZpbGluZzogc3RvcFByb2ZpbGluZyxcbiAgICBzdG9yZUFzR2xvYmFsOiBzdG9yZUFzR2xvYmFsLFxuICAgIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnM6IHVwZGF0ZUNvbXBvbmVudEZpbHRlcnNcbiAgfTtcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9EZXZUb29sc0NvbnNvbGVQYXRjaGluZy5qc1xuZnVuY3Rpb24gRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IERldlRvb2xzQ29uc29sZVBhdGNoaW5nX293bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBEZXZUb29sc0NvbnNvbGVQYXRjaGluZ19kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBEZXZUb29sc0NvbnNvbGVQYXRjaGluZ19vd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBEZXZUb29sc0NvbnNvbGVQYXRjaGluZ19kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIHNoYXJlZC9Db25zb2xlUGF0Y2hpbmdEZXYuXG4vLyBUaGUgc2hhcmVkIGNvbnNvbGUgcGF0Y2hpbmcgY29kZSBpcyBERVYtb25seS5cbi8vIFdlIGNhbid0IHVzZSBpdCBzaW5jZSBEZXZUb29scyBvbmx5IHNoaXBzIHByb2R1Y3Rpb24gYnVpbGRzLlxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgIGluZm86IHByb3BzLFxuICAgICAgbG9nOiBwcm9wcyxcbiAgICAgIHdhcm46IHByb3BzLFxuICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgfSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgfVxuXG4gIGRpc2FibGVkRGVwdGgrKztcbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgZGlzYWJsZWREZXB0aC0tO1xuXG4gIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgdmFyIHByb3BzID0ge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgIGxvZzogRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb2JqZWN0U3ByZWFkKERldlRvb2xzQ29uc29sZVBhdGNoaW5nX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgfSksXG4gICAgICBpbmZvOiBEZXZUb29sc0NvbnNvbGVQYXRjaGluZ19vYmplY3RTcHJlYWQoRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgfSksXG4gICAgICB3YXJuOiBEZXZUb29sc0NvbnNvbGVQYXRjaGluZ19vYmplY3RTcHJlYWQoRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgfSksXG4gICAgICBlcnJvcjogRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb2JqZWN0U3ByZWFkKERldlRvb2xzQ29uc29sZVBhdGNoaW5nX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICB9KSxcbiAgICAgIGdyb3VwOiBEZXZUb29sc0NvbnNvbGVQYXRjaGluZ19vYmplY3RTcHJlYWQoRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIHt9LCB7XG4gICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgIH0pLFxuICAgICAgZ3JvdXBDb2xsYXBzZWQ6IERldlRvb2xzQ29uc29sZVBhdGNoaW5nX29iamVjdFNwcmVhZChEZXZUb29sc0NvbnNvbGVQYXRjaGluZ19vYmplY3RTcHJlYWQoe30sIHByb3BzKSwge30sIHtcbiAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgfSksXG4gICAgICBncm91cEVuZDogRGV2VG9vbHNDb25zb2xlUGF0Y2hpbmdfb2JqZWN0U3ByZWFkKERldlRvb2xzQ29uc29sZVBhdGNoaW5nX29iamVjdFNwcmVhZCh7fSwgcHJvcHMpLCB7fSwge1xuICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICB9KVxuICAgIH0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gIH1cblxuICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICBjb25zb2xlLmVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL0RldlRvb2xzQ29tcG9uZW50U3RhY2tGcmFtZS5qc1xuZnVuY3Rpb24gRGV2VG9vbHNDb21wb25lbnRTdGFja0ZyYW1lX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgRGV2VG9vbHNDb21wb25lbnRTdGFja0ZyYW1lX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBEZXZUb29sc0NvbXBvbmVudFN0YWNrRnJhbWVfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIERldlRvb2xzQ29tcG9uZW50U3RhY2tGcmFtZV90eXBlb2Yob2JqKTsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG4vLyBUaGlzIGlzIGEgRGV2VG9vbHMgZm9yayBvZiBSZWFjdENvbXBvbmVudFN0YWNrRnJhbWUuXG4vLyBUaGlzIGZvcmsgZW5hYmxlcyBEZXZUb29scyB0byB1c2UgdGhlIHNhbWUgXCJuYXRpdmVcIiBjb21wb25lbnQgc3RhY2sgZm9ybWF0LFxuLy8gd2hpbGUgc3RpbGwgbWFpbnRhaW5pbmcgc3VwcG9ydCBmb3IgbXVsdGlwbGUgcmVuZGVyZXIgdmVyc2lvbnNcbi8vICh3aGljaCB1c2UgZGlmZmVyZW50IHZhbHVlcyBmb3IgUmVhY3RUeXBlT2ZXb3JrKS5cbiAvLyBUaGUgc2hhcmVkIGNvbnNvbGUgcGF0Y2hpbmcgY29kZSBpcyBERVYtb25seS5cbi8vIFdlIGNhbid0IHVzZSBpdCBzaW5jZSBEZXZUb29scyBvbmx5IHNoaXBzIHByb2R1Y3Rpb24gYnVpbGRzLlxuXG5cbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgIHRyeSB7XG4gICAgICB0aHJvdyBFcnJvcigpO1xuICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICB9XG4gIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG5pZiAoZmFsc2UpIHsgdmFyIFBvc3NpYmx5V2Vha01hcDsgfVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QsIGN1cnJlbnREaXNwYXRjaGVyUmVmKSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoZmFsc2UpIHsgdmFyIGZyYW1lOyB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICByZWVudHJ5ID0gdHJ1ZTsgLy8gT3ZlcnJpZGUgdGhlIGRpc3BhdGNoZXIgc28gZWZmZWN0cyBzY2hlZHVsZWQgYnkgdGhpcyBzaGFsbG93IHJlbmRlciBhcmUgdGhyb3duIGF3YXkuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB1bmxpa2UgdGhlIGNvZGUgdGhpcyB3YXMgZm9ya2VkIGZyb20gKGluIFJlYWN0Q29tcG9uZW50U3RhY2tGcmFtZSlcbiAgLy8gRGV2VG9vbHMgc2hvdWxkIG92ZXJyaWRlIHRoZSBkaXNwYXRjaGVyIGV2ZW4gd2hlbiBEZXZUb29scyBpcyBjb21waWxlZCBpbiBwcm9kdWN0aW9uIG1vZGUsXG4gIC8vIGJlY2F1c2UgdGhlIGFwcCBpdHNlbGYgbWF5IGJlIGluIGRldmVsb3BtZW50IG1vZGUgYW5kIGxvZyBlcnJvcnMvd2FybmluZ3MuXG5cbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IGN1cnJlbnREaXNwYXRjaGVyUmVmLmN1cnJlbnQ7XG4gIGN1cnJlbnREaXNwYXRjaGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICBkaXNhYmxlTG9ncygpO1xuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uIEZha2UoKSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICgodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogRGV2VG9vbHNDb21wb25lbnRTdGFja0ZyYW1lX3R5cGVvZihSZWZsZWN0KSkgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICB9XG5cbiAgICAgIGZuKCk7XG4gICAgfVxuICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAvLyBUaGlzIGlzIGlubGluZWQgbWFudWFsbHkgYmVjYXVzZSBjbG9zdXJlIGRvZXNuJ3QgZG8gaXQgZm9yIHVzLlxuICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gVGhpcyBleHRyYWN0cyB0aGUgZmlyc3QgZnJhbWUgZnJvbSB0aGUgc2FtcGxlIHRoYXQgaXNuJ3QgYWxzbyBpbiB0aGUgY29udHJvbC5cbiAgICAgIC8vIFNraXBwaW5nIG9uZSBmcmFtZSB0aGF0IHdlIGFzc3VtZSBpcyB0aGUgZnJhbWUgdGhhdCBjYWxscyB0aGUgdHdvLlxuICAgICAgdmFyIHNhbXBsZUxpbmVzID0gc2FtcGxlLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sLnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgLy8gV2UgZXhwZWN0IGF0IGxlYXN0IG9uZSBzdGFjayBmcmFtZSB0byBiZSBzaGFyZWQuXG4gICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgLy8gZWFybGllciB0aGFuIHRoZSBvdGhlci4gV2UgYXNzdW1lIHRoYXQgdGhlIHNhbXBsZSBpcyBsb25nZXIgb3IgdGhlIHNhbWVcbiAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgIGMtLTtcbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZmFsc2UpIHt9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZi5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgIHJlZW5hYmxlTG9ncygpO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIGlmIChmYWxzZSkge31cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvciwgc291cmNlLCBvd25lckZuLCBjdXJyZW50RGlzcGF0Y2hlclJlZikge1xuICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbiwgY3VycmVudERpc3BhdGNoZXJSZWYpIHtcbiAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuLCBjdXJyZW50RGlzcGF0Y2hlclJlZikge1xuICBpZiAodHJ1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSksIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSwgc291cmNlLCBvd25lckZuKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU1VTUEVOU0VfTlVNQkVSOlxuICAgIGNhc2UgU1VTUEVOU0VfU1lNQk9MX1NUUklORzpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnLCBzb3VyY2UsIG93bmVyRm4pO1xuXG4gICAgY2FzZSBTVVNQRU5TRV9MSVNUX05VTUJFUjpcbiAgICBjYXNlIFNVU1BFTlNFX0xJU1RfU1lNQk9MX1NUUklORzpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jywgc291cmNlLCBvd25lckZuKTtcbiAgfVxuXG4gIGlmIChEZXZUb29sc0NvbXBvbmVudFN0YWNrRnJhbWVfdHlwZW9mKHR5cGUpID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBGT1JXQVJEX1JFRl9OVU1CRVI6XG4gICAgICBjYXNlIEZPUldBUkRfUkVGX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsIHNvdXJjZSwgb3duZXJGbiwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgICBjYXNlIE1FTU9fTlVNQkVSOlxuICAgICAgY2FzZSBNRU1PX1NZTUJPTF9TVFJJTkc6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4sIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcblxuICAgICAgY2FzZSBMQVpZX05VTUJFUjpcbiAgICAgIGNhc2UgTEFaWV9TWU1CT0xfU1RSSU5HOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuLCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9EZXZUb29sc0ZpYmVyQ29tcG9uZW50U3RhY2suanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cbi8vIFRoaXMgaXMgYSBEZXZUb29scyBmb3JrIG9mIFJlYWN0RmliZXJDb21wb25lbnRTdGFjay5cbi8vIFRoaXMgZm9yayBlbmFibGVzIERldlRvb2xzIHRvIHVzZSB0aGUgc2FtZSBcIm5hdGl2ZVwiIGNvbXBvbmVudCBzdGFjayBmb3JtYXQsXG4vLyB3aGlsZSBzdGlsbCBtYWludGFpbmluZyBzdXBwb3J0IGZvciBtdWx0aXBsZSByZW5kZXJlciB2ZXJzaW9uc1xuLy8gKHdoaWNoIHVzZSBkaWZmZXJlbnQgdmFsdWVzIGZvciBSZWFjdFR5cGVPZldvcmspLlxuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIod29ya1RhZ01hcCwgd29ya0luUHJvZ3Jlc3MsIGN1cnJlbnREaXNwYXRjaGVyUmVmKSB7XG4gIHZhciBIb3N0Q29tcG9uZW50ID0gd29ya1RhZ01hcC5Ib3N0Q29tcG9uZW50LFxuICAgICAgTGF6eUNvbXBvbmVudCA9IHdvcmtUYWdNYXAuTGF6eUNvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlQ29tcG9uZW50ID0gd29ya1RhZ01hcC5TdXNwZW5zZUNvbXBvbmVudCxcbiAgICAgIFN1c3BlbnNlTGlzdENvbXBvbmVudCA9IHdvcmtUYWdNYXAuU3VzcGVuc2VMaXN0Q29tcG9uZW50LFxuICAgICAgRnVuY3Rpb25Db21wb25lbnQgPSB3b3JrVGFnTWFwLkZ1bmN0aW9uQ29tcG9uZW50LFxuICAgICAgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCA9IHdvcmtUYWdNYXAuSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCxcbiAgICAgIFNpbXBsZU1lbW9Db21wb25lbnQgPSB3b3JrVGFnTWFwLlNpbXBsZU1lbW9Db21wb25lbnQsXG4gICAgICBGb3J3YXJkUmVmID0gd29ya1RhZ01hcC5Gb3J3YXJkUmVmLFxuICAgICAgQ2xhc3NDb21wb25lbnQgPSB3b3JrVGFnTWFwLkNsYXNzQ29tcG9uZW50O1xuICB2YXIgb3duZXIgPSAgZmFsc2UgPyB1bmRlZmluZWQgOiBudWxsO1xuICB2YXIgc291cmNlID0gIGZhbHNlID8gdW5kZWZpbmVkIDogbnVsbDtcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlLCBzb3VyY2UsIG93bmVyKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScsIHNvdXJjZSwgb3duZXIpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnLCBzb3VyY2UsIG93bmVyKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnLCBzb3VyY2UsIG93bmVyKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUod29ya0luUHJvZ3Jlc3MudHlwZSwgc291cmNlLCBvd25lciwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh3b3JrSW5Qcm9ncmVzcy50eXBlLnJlbmRlciwgc291cmNlLCBvd25lciwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUod29ya0luUHJvZ3Jlc3MudHlwZSwgc291cmNlLCBvd25lciwgY3VycmVudERpc3BhdGNoZXJSZWYpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya1RhZ01hcCwgd29ya0luUHJvZ3Jlc3MsIGN1cnJlbnREaXNwYXRjaGVyUmVmKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSAnJztcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuXG4gICAgZG8ge1xuICAgICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKHdvcmtUYWdNYXAsIG5vZGUsIGN1cnJlbnREaXNwYXRjaGVyUmVmKTtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvY29uc29sZS5qc1xuZnVuY3Rpb24gY29uc29sZV9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gY29uc29sZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0LnJldHVybiAhPSBudWxsKSBpdC5yZXR1cm4oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBjb25zb2xlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gY29uc29sZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gY29uc29sZV9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gY29uc29sZV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxudmFyIEFQUEVORF9TVEFDS19UT19NRVRIT0RTID0gWydlcnJvcicsICd0cmFjZScsICd3YXJuJ107IC8vIFJlYWN0J3MgY3VzdG9tIGJ1aWx0IGNvbXBvbmVudCBzdGFjayBzdHJpbmdzIG1hdGNoIFwiXFxzezR9aW5cIlxuLy8gQ2hyb21lJ3MgcHJlZml4IG1hdGNoZXMgXCJcXHN7NH1hdFwiXG5cbnZhciBQUkVGSVhfUkVHRVggPSAvXFxzezR9KGlufGF0KVxcc3sxfS87IC8vIEZpcmVmb3ggYW5kIFNhZmFyaSBoYXZlIG5vIHByZWZpeCAoXCJcIilcbi8vIGJ1dCB3ZSBjYW4gZmFsbGJhY2sgdG8gbG9va2luZyBmb3IgbG9jYXRpb24gaW5mbyAoZS5nLiBcImZvby5qczoxMjozNDVcIilcblxudmFyIFJPV19DT0xVTU5fTlVNQkVSX1JFR0VYID0gLzpcXGQrOlxcZCsoXFxufCQpLztcbmZ1bmN0aW9uIGlzU3RyaW5nQ29tcG9uZW50U3RhY2sodGV4dCkge1xuICByZXR1cm4gUFJFRklYX1JFR0VYLnRlc3QodGV4dCkgfHwgUk9XX0NPTFVNTl9OVU1CRVJfUkVHRVgudGVzdCh0ZXh0KTtcbn1cbnZhciBpbmplY3RlZFJlbmRlcmVycyA9IG5ldyBNYXAoKTtcbnZhciB0YXJnZXRDb25zb2xlID0gY29uc29sZTtcbnZhciB0YXJnZXRDb25zb2xlTWV0aG9kcyA9IHt9O1xuXG5mb3IgKHZhciBjb25zb2xlX21ldGhvZCBpbiBjb25zb2xlKSB7XG4gIHRhcmdldENvbnNvbGVNZXRob2RzW2NvbnNvbGVfbWV0aG9kXSA9IGNvbnNvbGVbY29uc29sZV9tZXRob2RdO1xufVxuXG52YXIgdW5wYXRjaEZuID0gbnVsbDsgLy8gRW5hYmxlcyBlLmcuIEplc3QgdGVzdHMgdG8gaW5qZWN0IGEgbW9jayBjb25zb2xlIG9iamVjdC5cblxuZnVuY3Rpb24gZGFuZ2Vyb3VzX3NldFRhcmdldENvbnNvbGVGb3JUZXN0aW5nKHRhcmdldENvbnNvbGVGb3JUZXN0aW5nKSB7XG4gIHRhcmdldENvbnNvbGUgPSB0YXJnZXRDb25zb2xlRm9yVGVzdGluZztcbiAgdGFyZ2V0Q29uc29sZU1ldGhvZHMgPSB7fTtcblxuICBmb3IgKHZhciBfbWV0aG9kIGluIHRhcmdldENvbnNvbGUpIHtcbiAgICB0YXJnZXRDb25zb2xlTWV0aG9kc1tfbWV0aG9kXSA9IGNvbnNvbGVbX21ldGhvZF07XG4gIH1cbn0gLy8gdjE2IHJlbmRlcmVycyBzaG91bGQgdXNlIHRoaXMgbWV0aG9kIHRvIGluamVjdCBpbnRlcm5hbHMgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIGEgY29tcG9uZW50IHN0YWNrLlxuLy8gVGhlc2UgaW50ZXJuYWxzIHdpbGwgYmUgdXNlZCBpZiB0aGUgY29uc29sZSBpcyBwYXRjaGVkLlxuLy8gSW5qZWN0aW5nIHRoZW0gc2VwYXJhdGVseSBhbGxvd3MgdGhlIGNvbnNvbGUgdG8gZWFzaWx5IGJlIHBhdGNoZWQgb3IgdW4tcGF0Y2hlZCBsYXRlciAoYXQgcnVudGltZSkuXG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVuZGVyZXIocmVuZGVyZXIsIG9uRXJyb3JPcldhcm5pbmcpIHtcbiAgdmFyIGN1cnJlbnREaXNwYXRjaGVyUmVmID0gcmVuZGVyZXIuY3VycmVudERpc3BhdGNoZXJSZWYsXG4gICAgICBnZXRDdXJyZW50RmliZXIgPSByZW5kZXJlci5nZXRDdXJyZW50RmliZXIsXG4gICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IHJlbmRlcmVyLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLFxuICAgICAgdmVyc2lvbiA9IHJlbmRlcmVyLnZlcnNpb247IC8vIElnbm9yZSBSZWFjdCB2MTUgYW5kIG9sZGVyIGJlY2F1c2UgdGhleSBkb24ndCBleHBvc2UgYSBjb21wb25lbnQgc3RhY2sgYW55d2F5LlxuXG4gIGlmICh0eXBlb2YgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gY3VycmVudERpc3BhdGNoZXJSZWYgZ2V0cyBpbmplY3RlZCBmb3IgdjE2LjgrIHRvIHN1cHBvcnQgaG9va3MgaW5zcGVjdGlvbi5cbiAgLy8gZ2V0Q3VycmVudEZpYmVyIGdldHMgaW5qZWN0ZWQgZm9yIHYxNi45Ky5cblxuXG4gIGlmIChjdXJyZW50RGlzcGF0Y2hlclJlZiAhPSBudWxsICYmIHR5cGVvZiBnZXRDdXJyZW50RmliZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgX2dldEludGVybmFsUmVhY3RDb25zID0gZ2V0SW50ZXJuYWxSZWFjdENvbnN0YW50cyh2ZXJzaW9uKSxcbiAgICAgICAgUmVhY3RUeXBlT2ZXb3JrID0gX2dldEludGVybmFsUmVhY3RDb25zLlJlYWN0VHlwZU9mV29yaztcblxuICAgIGluamVjdGVkUmVuZGVyZXJzLnNldChyZW5kZXJlciwge1xuICAgICAgY3VycmVudERpc3BhdGNoZXJSZWY6IGN1cnJlbnREaXNwYXRjaGVyUmVmLFxuICAgICAgZ2V0Q3VycmVudEZpYmVyOiBnZXRDdXJyZW50RmliZXIsXG4gICAgICB3b3JrVGFnTWFwOiBSZWFjdFR5cGVPZldvcmssXG4gICAgICBvbkVycm9yT3JXYXJuaW5nOiBvbkVycm9yT3JXYXJuaW5nXG4gICAgfSk7XG4gIH1cbn1cbnZhciBjb25zb2xlU2V0dGluZ3NSZWYgPSB7XG4gIGFwcGVuZENvbXBvbmVudFN0YWNrOiBmYWxzZSxcbiAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IGZhbHNlLFxuICBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnM6IGZhbHNlXG59OyAvLyBQYXRjaGVzIGNvbnNvbGUgbWV0aG9kcyB0byBhcHBlbmQgY29tcG9uZW50IHN0YWNrIGZvciB0aGUgY3VycmVudCBmaWJlci5cbi8vIENhbGwgdW5wYXRjaCgpIHRvIHJlbW92ZSB0aGUgaW5qZWN0ZWQgYmVoYXZpb3IuXG5cbmZ1bmN0aW9uIHBhdGNoKF9yZWYpIHtcbiAgdmFyIGFwcGVuZENvbXBvbmVudFN0YWNrID0gX3JlZi5hcHBlbmRDb21wb25lbnRTdGFjayxcbiAgICAgIGJyZWFrT25Db25zb2xlRXJyb3JzID0gX3JlZi5icmVha09uQ29uc29sZUVycm9ycyxcbiAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IF9yZWYuc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzO1xuICAvLyBTZXR0aW5ncyBtYXkgY2hhbmdlIGFmdGVyIHdlJ3ZlIHBhdGNoZWQgdGhlIGNvbnNvbGUuXG4gIC8vIFVzaW5nIGEgc2hhcmVkIHJlZiBhbGxvd3MgdGhlIHBhdGNoIGZ1bmN0aW9uIHRvIHJlYWQgdGhlIGxhdGVzdCB2YWx1ZXMuXG4gIGNvbnNvbGVTZXR0aW5nc1JlZi5hcHBlbmRDb21wb25lbnRTdGFjayA9IGFwcGVuZENvbXBvbmVudFN0YWNrO1xuICBjb25zb2xlU2V0dGluZ3NSZWYuYnJlYWtPbkNvbnNvbGVFcnJvcnMgPSBicmVha09uQ29uc29sZUVycm9ycztcbiAgY29uc29sZVNldHRpbmdzUmVmLnNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycztcblxuICBpZiAodW5wYXRjaEZuICE9PSBudWxsKSB7XG4gICAgLy8gRG9uJ3QgcGF0Y2ggdHdpY2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9yaWdpbmFsQ29uc29sZU1ldGhvZHMgPSB7fTtcblxuICB1bnBhdGNoRm4gPSBmdW5jdGlvbiB1bnBhdGNoRm4oKSB7XG4gICAgZm9yICh2YXIgX21ldGhvZDIgaW4gb3JpZ2luYWxDb25zb2xlTWV0aG9kcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSBwcm9wZXJ0eSBlcnJvcnx3YXJuIGlzIG5vdCB3cml0YWJsZS5cbiAgICAgICAgdGFyZ2V0Q29uc29sZVtfbWV0aG9kMl0gPSBvcmlnaW5hbENvbnNvbGVNZXRob2RzW19tZXRob2QyXTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7fVxuICAgIH1cbiAgfTtcblxuICBBUFBFTkRfU1RBQ0tfVE9fTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIG9yaWdpbmFsTWV0aG9kID0gb3JpZ2luYWxDb25zb2xlTWV0aG9kc1ttZXRob2RdID0gdGFyZ2V0Q29uc29sZVttZXRob2RdO1xuXG4gICAgICB2YXIgb3ZlcnJpZGVNZXRob2QgPSBmdW5jdGlvbiBvdmVycmlkZU1ldGhvZCgpIHtcbiAgICAgICAgdmFyIHNob3VsZEFwcGVuZFdhcm5pbmdTdGFjayA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uc29sZVNldHRpbmdzUmVmLmFwcGVuZENvbXBvbmVudFN0YWNrKSB7XG4gICAgICAgICAgdmFyIGxhc3RBcmcgPSBhcmdzLmxlbmd0aCA+IDAgPyBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgICAgICAgIHZhciBhbHJlYWR5SGFzQ29tcG9uZW50U3RhY2sgPSB0eXBlb2YgbGFzdEFyZyA9PT0gJ3N0cmluZycgJiYgaXNTdHJpbmdDb21wb25lbnRTdGFjayhsYXN0QXJnKTsgLy8gSWYgd2UgYXJlIGV2ZXIgY2FsbGVkIHdpdGggYSBzdHJpbmcgdGhhdCBhbHJlYWR5IGhhcyBhIGNvbXBvbmVudCBzdGFjayxcbiAgICAgICAgICAvLyBlLmcuIGEgUmVhY3QgZXJyb3Ivd2FybmluZywgZG9uJ3QgYXBwZW5kIGEgc2Vjb25kIHN0YWNrLlxuXG4gICAgICAgICAgc2hvdWxkQXBwZW5kV2FybmluZ1N0YWNrID0gIWFscmVhZHlIYXNDb21wb25lbnRTdGFjaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaG91bGRTaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPSBjb25zb2xlU2V0dGluZ3NSZWYuc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzICYmIChtZXRob2QgPT09ICdlcnJvcicgfHwgbWV0aG9kID09PSAnd2FybicpO1xuXG4gICAgICAgIGlmIChzaG91bGRBcHBlbmRXYXJuaW5nU3RhY2sgfHwgc2hvdWxkU2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSB7XG4gICAgICAgICAgLy8gU2VhcmNoIGZvciB0aGUgZmlyc3QgcmVuZGVyZXIgdGhhdCBoYXMgYSBjdXJyZW50IEZpYmVyLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGhhbmRsZSB0aGUgZWRnZSBjYXNlIG9mIHN0YWNrcyBmb3IgbW9yZSB0aGFuIG9uZSAoZS5nLiBpbnRlcmxlYXZlZCByZW5kZXJlcnM/KVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mb3Itb2YtbG9vcHMvbm8tZm9yLW9mLWxvb3BzXG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IGNvbnNvbGVfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihpbmplY3RlZFJlbmRlcmVycy52YWx1ZXMoKSksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfc3RlcCR2YWx1ZSA9IF9zdGVwLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgY3VycmVudERpc3BhdGNoZXJSZWYgPSBfc3RlcCR2YWx1ZS5jdXJyZW50RGlzcGF0Y2hlclJlZixcbiAgICAgICAgICAgICAgICAgIGdldEN1cnJlbnRGaWJlciA9IF9zdGVwJHZhbHVlLmdldEN1cnJlbnRGaWJlcixcbiAgICAgICAgICAgICAgICAgIG9uRXJyb3JPcldhcm5pbmcgPSBfc3RlcCR2YWx1ZS5vbkVycm9yT3JXYXJuaW5nLFxuICAgICAgICAgICAgICAgICAgd29ya1RhZ01hcCA9IF9zdGVwJHZhbHVlLndvcmtUYWdNYXA7XG4gICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudEZpYmVyKCk7XG5cbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHBhdGNoKCkgaXMgY2FsbGVkIGJ5IHR3byBwbGFjZXM6ICgxKSB0aGUgaG9vayBhbmQgKDIpIHRoZSByZW5kZXJlciBiYWNrZW5kLlxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmFja2VuZCBpcyB3aGF0IGltcGxlbWVudHMgYSBtZXNzYWdlIHF1ZXVlLCBzbyBpdCdzIHRoZSBvbmx5IG9uZSB0aGF0IGluamVjdHMgb25FcnJvck9yV2FybmluZy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvbkVycm9yT3JXYXJuaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb25FcnJvck9yV2FybmluZyhjdXJyZW50LCBtZXRob2QsIC8vIENvcHkgYXJncyBiZWZvcmUgd2UgbXV0YXRlIHRoZW0gKGUuZy4gYWRkaW5nIHRoZSBjb21wb25lbnQgc3RhY2spXG4gICAgICAgICAgICAgICAgICAgICAgYXJncy5zbGljZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkQXBwZW5kV2FybmluZ1N0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrVGFnTWFwLCBjdXJyZW50LCBjdXJyZW50RGlzcGF0Y2hlclJlZik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudFN0YWNrICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3MucHVzaChjb21wb25lbnRTdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIERvbid0IGxldCBhIERldlRvb2xzIG9yIFJlYWN0IGludGVybmFsIGVycm9yIGludGVyZmVyZSB3aXRoIGxvZ2dpbmcuXG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29uc29sZVNldHRpbmdzUmVmLmJyZWFrT25Db25zb2xlRXJyb3JzKSB7XG4gICAgICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIHdpdGggUmVhY3QgRGV2VG9vbHMgLS0tXG4gICAgICAgICAgLy8gVGhpcyBkZWJ1Z2dlciBzdGF0ZW1lbnQgbWVhbnMgdGhhdCB5b3UndmUgZW5hYmxlZCB0aGUgXCJicmVhayBvbiB3YXJuaW5nc1wiIGZlYXR1cmUuXG4gICAgICAgICAgLy8gVXNlIHRoZSBicm93c2VyJ3MgQ2FsbCBTdGFjayBwYW5lbCB0byBzdGVwIG91dCBvZiB0aGlzIG92ZXJyaWRlIGZ1bmN0aW9uLVxuICAgICAgICAgIC8vIHRvIHdoZXJlIHRoZSBvcmlnaW5hbCB3YXJuaW5nIG9yIGVycm9yIHdhcyBsb2dnZWQuXG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWRlYnVnZ2VyXG4gICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgIH1cblxuICAgICAgICBvcmlnaW5hbE1ldGhvZC5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgfTtcblxuICAgICAgb3ZlcnJpZGVNZXRob2QuX19SRUFDVF9ERVZUT09MU19PUklHSU5BTF9NRVRIT0RfXyA9IG9yaWdpbmFsTWV0aG9kO1xuICAgICAgb3JpZ2luYWxNZXRob2QuX19SRUFDVF9ERVZUT09MU19PVkVSUklERV9NRVRIT0RfXyA9IG92ZXJyaWRlTWV0aG9kOyAvLyAkRmxvd0ZpeE1lIHByb3BlcnR5IGVycm9yfHdhcm4gaXMgbm90IHdyaXRhYmxlLlxuXG4gICAgICB0YXJnZXRDb25zb2xlW21ldGhvZF0gPSBvdmVycmlkZU1ldGhvZDtcbiAgICB9IGNhdGNoIChlcnJvcikge31cbiAgfSk7XG59IC8vIFJlbW92ZWQgY29tcG9uZW50IHN0YWNrIHBhdGNoIGZyb20gY29uc29sZSBtZXRob2RzLlxuXG5mdW5jdGlvbiB1bnBhdGNoKCkge1xuICBpZiAodW5wYXRjaEZuICE9PSBudWxsKSB7XG4gICAgdW5wYXRjaEZuKCk7XG4gICAgdW5wYXRjaEZuID0gbnVsbDtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9icmlkZ2UuanNcbmZ1bmN0aW9uIGJyaWRnZV90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IGJyaWRnZV90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgYnJpZGdlX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBicmlkZ2VfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gYnJpZGdlX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gYnJpZGdlX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgYnJpZGdlX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IGJyaWRnZV91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IGJyaWRnZV9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gYnJpZGdlX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gYnJpZGdlX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBicmlkZ2VfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBicmlkZ2VfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBicmlkZ2VfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBicmlkZ2VfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBicmlkZ2VfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGJyaWRnZV9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGJyaWRnZV9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgYnJpZGdlX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKGJyaWRnZV90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBicmlkZ2VfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBCQVRDSF9EVVJBVElPTiA9IDEwMDsgLy8gVGhpcyBtZXNzYWdlIHNwZWNpZmllcyB0aGUgdmVyc2lvbiBvZiB0aGUgRGV2VG9vbHMgcHJvdG9jb2wgY3VycmVudGx5IHN1cHBvcnRlZCBieSB0aGUgYmFja2VuZCxcbi8vIGFzIHdlbGwgYXMgdGhlIGVhcmxpZXN0IE5QTSB2ZXJzaW9uIChlLmcuIFwiNC4xMy4wXCIpIHRoYXQgcHJvdG9jb2wgaXMgc3VwcG9ydGVkIGJ5IG9uIHRoZSBmcm9udGVuZC5cbi8vIFRoaXMgZW5hYmxlcyBhbiBvbGRlciBmcm9udGVuZCB0byBkaXNwbGF5IGFuIHVwZ3JhZGUgbWVzc2FnZSB0byB1c2VycyBmb3IgYSBuZXdlciwgdW5zdXBwb3J0ZWQgYmFja2VuZC5cblxuLy8gQnVtcCBwcm90b2NvbCB2ZXJzaW9uIHdoZW5ldmVyIGEgYmFja3dhcmRzIGJyZWFraW5nIGNoYW5nZSBpcyBtYWRlXG4vLyBpbiB0aGUgbWVzc2FnZXMgc2VudCBiZXR3ZWVuIEJhY2tlbmRCcmlkZ2UgYW5kIEZyb250ZW5kQnJpZGdlLlxuLy8gVGhpcyBtYXBwaW5nIGlzIGVtYmVkZGVkIGluIGJvdGggZnJvbnRlbmQgYW5kIGJhY2tlbmQgYnVpbGRzLlxuLy9cbi8vIFRoZSBiYWNrZW5kIHByb3RvY29sIHdpbGwgYWx3YXlzIGJlIHRoZSBsYXRlc3QgZW50cnkgaW4gdGhlIEJSSURHRV9QUk9UT0NPTCBhcnJheS5cbi8vXG4vLyBXaGVuIGFuIG9sZGVyIGZyb250ZW5kIGNvbm5lY3RzIHRvIGEgbmV3ZXIgYmFja2VuZCxcbi8vIHRoZSBiYWNrZW5kIGNhbiBzZW5kIHRoZSBtaW5OcG1WZXJzaW9uIGFuZCB0aGUgZnJvbnRlbmQgY2FuIGRpc3BsYXkgYW4gTlBNIHVwZ3JhZGUgcHJvbXB0LlxuLy9cbi8vIFdoZW4gYSBuZXdlciBmcm9udGVuZCBjb25uZWN0cyB3aXRoIGFuIG9sZGVyIHByb3RvY29sIHZlcnNpb24sXG4vLyB0aGUgZnJvbnRlbmQgY2FuIHVzZSB0aGUgZW1iZWRkZWQgbWluTnBtVmVyc2lvbi9tYXhOcG1WZXJzaW9uIHZhbHVlcyB0byBkaXNwbGF5IGEgZG93bmdyYWRlIHByb21wdC5cbnZhciBCUklER0VfUFJPVE9DT0wgPSBbLy8gVGhpcyB2ZXJzaW9uIHRlY2huaWNhbGx5IG5ldmVyIGV4aXN0ZWQsXG4vLyBidXQgYSBiYWNrd2FyZHMgYnJlYWtpbmcgY2hhbmdlIHdhcyBhZGRlZCBpbiA0LjExLFxuLy8gc28gdGhlIHNhZmVzdCBndWVzcyB0byBkb3duZ3JhZGUgdGhlIGZyb250ZW5kIHdvdWxkIGJlIHRvIHZlcnNpb24gNC4xMC5cbntcbiAgdmVyc2lvbjogMCxcbiAgbWluTnBtVmVyc2lvbjogJ1wiPDQuMTEuMFwiJyxcbiAgbWF4TnBtVmVyc2lvbjogJ1wiPDQuMTEuMFwiJ1xufSwge1xuICB2ZXJzaW9uOiAxLFxuICBtaW5OcG1WZXJzaW9uOiAnNC4xMy4wJyxcbiAgbWF4TnBtVmVyc2lvbjogbnVsbFxufV07XG52YXIgY3VycmVudEJyaWRnZVByb3RvY29sID0gQlJJREdFX1BST1RPQ09MW0JSSURHRV9QUk9UT0NPTC5sZW5ndGggLSAxXTtcblxudmFyIEJyaWRnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQnJpZGdlLCBfRXZlbnRFbWl0dGVyKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJyaWRnZSk7XG5cbiAgZnVuY3Rpb24gQnJpZGdlKHdhbGwpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBicmlkZ2VfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnJpZGdlKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG5cbiAgICBicmlkZ2VfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX2lzU2h1dGRvd25cIiwgZmFsc2UpO1xuXG4gICAgYnJpZGdlX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9tZXNzYWdlUXVldWVcIiwgW10pO1xuXG4gICAgYnJpZGdlX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl90aW1lb3V0SURcIiwgbnVsbCk7XG5cbiAgICBicmlkZ2VfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3dhbGxVbmxpc3RlblwiLCBudWxsKTtcblxuICAgIGJyaWRnZV9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfZmx1c2hcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdXNlZCBhZnRlciB0aGUgYnJpZGdlIGlzIG1hcmtlZCBhcyBkZXN0cm95ZWQgaW4gc2h1dGRvd24gc2VxdWVuY2UsXG4gICAgICAvLyBzbyB3ZSBkbyBub3QgYmFpbCBvdXQgaWYgdGhlIGJyaWRnZSBtYXJrZWQgYXMgZGVzdHJveWVkLlxuICAgICAgLy8gSXQgaXMgYSBwcml2YXRlIG1ldGhvZCB0aGF0IHRoZSBicmlkZ2UgZW5zdXJlcyBpcyBvbmx5IGNhbGxlZCBhdCB0aGUgcmlnaHQgdGltZXMuXG4gICAgICBpZiAoX3RoaXMuX3RpbWVvdXRJRCAhPT0gbnVsbCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX3RpbWVvdXRJRCk7XG4gICAgICAgIF90aGlzLl90aW1lb3V0SUQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3RoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5fbWVzc2FnZVF1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIF90aGlzJF93YWxsO1xuXG4gICAgICAgICAgKF90aGlzJF93YWxsID0gX3RoaXMuX3dhbGwpLnNlbmQuYXBwbHkoX3RoaXMkX3dhbGwsIFtfdGhpcy5fbWVzc2FnZVF1ZXVlW2ldXS5jb25jYXQoYnJpZGdlX3RvQ29uc3VtYWJsZUFycmF5KF90aGlzLl9tZXNzYWdlUXVldWVbaSArIDFdKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGggPSAwOyAvLyBDaGVjayBhZ2FpbiBmb3IgcXVldWVkIG1lc3NhZ2VzIGluIEJBVENIX0RVUkFUSU9OIG1zLiBUaGlzIHdpbGwga2VlcFxuICAgICAgICAvLyBmbHVzaGluZyBpbiBhIGxvb3AgYXMgbG9uZyBhcyBtZXNzYWdlcyBjb250aW51ZSB0byBiZSBhZGRlZC4gT25jZSBub1xuICAgICAgICAvLyBtb3JlIGFyZSwgdGhlIHRpbWVyIGV4cGlyZXMuXG5cbiAgICAgICAgX3RoaXMuX3RpbWVvdXRJRCA9IHNldFRpbWVvdXQoX3RoaXMuX2ZsdXNoLCBCQVRDSF9EVVJBVElPTik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBicmlkZ2VfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib3ZlcnJpZGVWYWx1ZUF0UGF0aFwiLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZi5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmLnJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYudHlwZSxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYudmFsdWU7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICBfdGhpcy5zZW5kKCdvdmVycmlkZUNvbnRleHQnLCB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICAgIHdhc0ZvcndhcmRlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgIF90aGlzLnNlbmQoJ292ZXJyaWRlSG9va1N0YXRlJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICBfdGhpcy5zZW5kKCdvdmVycmlkZVByb3BzJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICBfdGhpcy5zZW5kKCdvdmVycmlkZVN0YXRlJywge1xuICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgICB3YXNGb3J3YXJkZWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgX3RoaXMuX3dhbGwgPSB3YWxsO1xuICAgIF90aGlzLl93YWxsVW5saXN0ZW4gPSB3YWxsLmxpc3RlbihmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykuZW1pdChtZXNzYWdlLmV2ZW50LCBtZXNzYWdlLnBheWxvYWQpO1xuICAgIH0pIHx8IG51bGw7IC8vIFRlbXBvcmFyaWx5IHN1cHBvcnQgb2xkZXIgc3RhbmRhbG9uZSBmcm9udC1lbmRzIHNlbmRpbmcgY29tbWFuZHMgdG8gbmV3ZXIgZW1iZWRkZWQgYmFja2VuZHMuXG4gICAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIFJlYWN0IE5hdGl2ZSBlbWJlZHMgdGhlIFJlYWN0IERldlRvb2xzIGJhY2tlbmQsXG4gICAgLy8gYnV0IGNhbm5vdCBjb250cm9sIHdoaWNoIHZlcnNpb24gb2YgdGhlIGZyb250ZW5kIHVzZXJzIHVzZS5cblxuICAgIF90aGlzLmFkZExpc3RlbmVyKCdvdmVycmlkZVZhbHVlQXRQYXRoJywgX3RoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH0gLy8gTGlzdGVuaW5nIGRpcmVjdGx5IHRvIHRoZSB3YWxsIGlzbid0IGFkdmlzZWQuXG4gIC8vIEl0IGNhbiBiZSB1c2VkIHRvIGxpc3RlbiBmb3IgbGVnYWN5ICh2MykgbWVzc2FnZXMgKHNpbmNlIHRoZXkgdXNlIGEgZGlmZmVyZW50IGZvcm1hdCkuXG5cblxuICBicmlkZ2VfY3JlYXRlQ2xhc3MoQnJpZGdlLCBbe1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoZXZlbnQpIHtcbiAgICAgIGlmICh0aGlzLl9pc1NodXRkb3duKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkNhbm5vdCBzZW5kIG1lc3NhZ2UgXFxcIlwiLmNvbmNhdChldmVudCwgXCJcXFwiIHRocm91Z2ggYSBCcmlkZ2UgdGhhdCBoYXMgYmVlbiBzaHV0ZG93bi5cIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFdoZW4gd2UgcmVjZWl2ZSBhIG1lc3NhZ2U6XG4gICAgICAvLyAtIHdlIGFkZCBpdCB0byBvdXIgcXVldWUgb2YgbWVzc2FnZXMgdG8gYmUgc2VudFxuICAgICAgLy8gLSBpZiB0aGVyZSBoYXNuJ3QgYmVlbiBhIG1lc3NhZ2UgcmVjZW50bHksIHdlIHNldCBhIHRpbWVyIGZvciAwIG1zIGluXG4gICAgICAvLyAgIHRoZSBmdXR1cmUsIGFsbG93aW5nIGFsbCBtZXNzYWdlcyBjcmVhdGVkIGluIHRoZSBzYW1lIHRpY2sgdG8gYmUgc2VudFxuICAgICAgLy8gICB0b2dldGhlclxuICAgICAgLy8gLSBpZiB0aGVyZSAqaGFzKiBiZWVuIGEgbWVzc2FnZSBmbHVzaGVkIGluIHRoZSBsYXN0IEJBVENIX0RVUkFUSU9OIG1zXG4gICAgICAvLyAgIChvciB3ZSdyZSB3YWl0aW5nIGZvciBvdXIgc2V0VGltZW91dC0wIHRvIGZpcmUpLCB0aGVuIF90aW1lb3V0SUQgd2lsbFxuICAgICAgLy8gICBiZSBzZXQsIGFuZCB3ZSdsbCBzaW1wbHkgYWRkIHRvIHRoZSBxdWV1ZSBhbmQgd2FpdCBmb3IgdGhhdFxuXG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXlsb2FkID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgcGF5bG9hZFtfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZS5wdXNoKGV2ZW50LCBwYXlsb2FkKTtcblxuICAgICAgaWYgKCF0aGlzLl90aW1lb3V0SUQpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dElEID0gc2V0VGltZW91dCh0aGlzLl9mbHVzaCwgMCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNodXRkb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNodXRkb3duKCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2h1dGRvd24pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdCcmlkZ2Ugd2FzIGFscmVhZHkgc2h1dGRvd24uJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUXVldWUgdGhlIHNodXRkb3duIG91dGdvaW5nIG1lc3NhZ2UgZm9yIHN1YnNjcmliZXJzLlxuXG5cbiAgICAgIHRoaXMuc2VuZCgnc2h1dGRvd24nKTsgLy8gTWFyayB0aGlzIGJyaWRnZSBhcyBkZXN0cm95ZWQsIGkuZS4gZGlzYWJsZSBpdHMgcHVibGljIEFQSS5cblxuICAgICAgdGhpcy5faXNTaHV0ZG93biA9IHRydWU7IC8vIERpc2FibGUgdGhlIEFQSSBpbmhlcml0ZWQgZnJvbSBFdmVudEVtaXR0ZXIgdGhhdCBjYW4gYWRkIG1vcmUgbGlzdGVuZXJzIGFuZCBzZW5kIG1vcmUgbWVzc2FnZXMuXG4gICAgICAvLyAkRmxvd0ZpeE1lIFRoaXMgcHJvcGVydHkgaXMgbm90IHdyaXRhYmxlLlxuXG4gICAgICB0aGlzLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKCkge307IC8vICRGbG93Rml4TWUgVGhpcyBwcm9wZXJ0eSBpcyBub3Qgd3JpdGFibGUuXG5cblxuICAgICAgdGhpcy5lbWl0ID0gZnVuY3Rpb24gKCkge307IC8vIE5PVEU6IFRoZXJlJ3MgYWxzbyBFdmVudEVtaXR0ZXIgQVBJIGxpa2UgYG9uYCBhbmQgYHByZXBlbmRMaXN0ZW5lcmAgdGhhdCB3ZSBkaWRuJ3QgYWRkIHRvIG91ciBGbG93IHR5cGUgb2YgRXZlbnRFbWl0dGVyLlxuICAgICAgLy8gVW5zdWJzY3JpYmUgdGhpcyBicmlkZ2UgaW5jb21pbmcgbWVzc2FnZSBsaXN0ZW5lcnMgdG8gYmUgc3VyZSwgYW5kIHNvIHRoZXkgZG9uJ3QgaGF2ZSB0byBkbyB0aGF0LlxuXG5cbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7IC8vIFN0b3AgYWNjZXB0aW5nIGFuZCBlbWl0dGluZyBpbmNvbWluZyBtZXNzYWdlcyBmcm9tIHRoZSB3YWxsLlxuXG4gICAgICB2YXIgd2FsbFVubGlzdGVuID0gdGhpcy5fd2FsbFVubGlzdGVuO1xuXG4gICAgICBpZiAod2FsbFVubGlzdGVuKSB7XG4gICAgICAgIHdhbGxVbmxpc3RlbigpO1xuICAgICAgfSAvLyBTeW5jaHJvbm91c2x5IGZsdXNoIGFsbCBxdWV1ZWQgb3V0Z29pbmcgbWVzc2FnZXMuXG4gICAgICAvLyBBdCB0aGlzIHN0ZXAgdGhlIHN1YnNjcmliZXJzJyBjb2RlIG1heSBydW4gaW4gdGhpcyBjYWxsIHN0YWNrLlxuXG5cbiAgICAgIGRvIHtcbiAgICAgICAgdGhpcy5fZmx1c2goKTtcbiAgICAgIH0gd2hpbGUgKHRoaXMuX21lc3NhZ2VRdWV1ZS5sZW5ndGgpOyAvLyBNYWtlIHN1cmUgb25jZSBhZ2FpbiB0aGF0IHRoZXJlIGlzIG5vIGRhbmdsaW5nIHRpbWVyLlxuXG5cbiAgICAgIGlmICh0aGlzLl90aW1lb3V0SUQgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXRJRCk7XG4gICAgICAgIHRoaXMuX3RpbWVvdXRJRCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndhbGxcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl93YWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCcmlkZ2U7XG59KEV2ZW50RW1pdHRlcik7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY19icmlkZ2UgPSAoQnJpZGdlKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4uL3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9hZ2VudC5qc1xuZnVuY3Rpb24gYWdlbnRfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBhZ2VudF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgYWdlbnRfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIGFnZW50X3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIGFnZW50X2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gYWdlbnRfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIGFnZW50X2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgYWdlbnRfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGFnZW50X2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIGFnZW50X2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIGFnZW50X3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBhZ2VudF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IGFnZW50X3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBhZ2VudF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBhZ2VudF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gYWdlbnRfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gYWdlbnRfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IGFnZW50X2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBhZ2VudF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gYWdlbnRfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChhZ2VudF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBhZ2VudF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gYWdlbnRfZ2V0UHJvdG90eXBlT2YobykgeyBhZ2VudF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBhZ2VudF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBhZ2VudF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGFnZW50X2RlYnVnID0gZnVuY3Rpb24gZGVidWcobWV0aG9kTmFtZSkge1xuICBpZiAoX19ERUJVR19fKSB7XG4gICAgdmFyIF9jb25zb2xlO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSkubG9nLmFwcGx5KF9jb25zb2xlLCBbXCIlY0FnZW50ICVjXCIuY29uY2F0KG1ldGhvZE5hbWUpLCAnY29sb3I6IHB1cnBsZTsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2ZvbnQtd2VpZ2h0OiBib2xkOyddLmNvbmNhdChhcmdzKSk7XG4gIH1cbn07XG5cbnZhciBhZ2VudF9BZ2VudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICBhZ2VudF9pbmhlcml0cyhBZ2VudCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IGFnZW50X2NyZWF0ZVN1cGVyKEFnZW50KTtcblxuICBmdW5jdGlvbiBBZ2VudChicmlkZ2UpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBhZ2VudF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBZ2VudCk7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfaXNQcm9maWxpbmdcIiwgZmFsc2UpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJfcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zXCIsIGZhbHNlKTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3JlbmRlcmVySW50ZXJmYWNlc1wiLCB7fSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9wZXJzaXN0ZWRTZWxlY3Rpb25cIiwgbnVsbCk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaFwiLCBudWxsKTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiX3RyYWNlVXBkYXRlc0VuYWJsZWRcIiwgZmFsc2UpO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGVhckVycm9yc0FuZFdhcm5pbmdzXCIsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgcmVuZGVyZXJJRCA9IF9yZWYucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGVhckVycm9yc0ZvckZpYmVySURcIiwgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjIucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXJFcnJvcnNGb3JGaWJlcklEKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY2xlYXJXYXJuaW5nc0ZvckZpYmVySURcIiwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMy5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjMucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIuY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQoaWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjb3B5RWxlbWVudFBhdGhcIiwgZnVuY3Rpb24gKF9yZWY0KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmNC5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjQucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjQucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5jb3B5RWxlbWVudFBhdGgoaWQsIHBhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJkZWxldGVQYXRoXCIsIGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgdmFyIGhvb2tJRCA9IF9yZWY1Lmhvb2tJRCxcbiAgICAgICAgICBpZCA9IF9yZWY1LmlkLFxuICAgICAgICAgIHBhdGggPSBfcmVmNS5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmNS5yZW5kZXJlcklELFxuICAgICAgICAgIHR5cGUgPSBfcmVmNS50eXBlO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLmRlbGV0ZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldEJyaWRnZVByb3RvY29sXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgnYnJpZGdlUHJvdG9jb2wnLCBjdXJyZW50QnJpZGdlUHJvdG9jb2wpO1xuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJnZXRQcm9maWxpbmdEYXRhXCIsIGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgdmFyIHJlbmRlcmVySUQgPSBfcmVmNi5yZW5kZXJlcklEO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgncHJvZmlsaW5nRGF0YScsIHJlbmRlcmVyLmdldFByb2ZpbGluZ0RhdGEoKSk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldFByb2ZpbGluZ1N0YXR1c1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ1N0YXR1cycsIF90aGlzLl9pc1Byb2ZpbGluZyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdldE93bmVyc0xpc3RcIiwgZnVuY3Rpb24gKF9yZWY3KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmNy5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjcucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgb3duZXJzID0gcmVuZGVyZXIuZ2V0T3duZXJzTGlzdChpZCk7XG5cbiAgICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdvd25lcnNMaXN0Jywge1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBvd25lcnM6IG93bmVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaW5zcGVjdEVsZW1lbnRcIiwgZnVuY3Rpb24gKF9yZWY4KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmOC5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjgucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjgucmVuZGVyZXJJRCxcbiAgICAgICAgICByZXF1ZXN0SUQgPSBfcmVmOC5yZXF1ZXN0SUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdpbnNwZWN0ZWRFbGVtZW50JywgcmVuZGVyZXIuaW5zcGVjdEVsZW1lbnQocmVxdWVzdElELCBpZCwgcGF0aCkpOyAvLyBXaGVuIHVzZXIgc2VsZWN0cyBhbiBlbGVtZW50LCBzdG9wIHRyeWluZyB0byByZXN0b3JlIHRoZSBzZWxlY3Rpb24sXG4gICAgICAgIC8vIGFuZCBpbnN0ZWFkIHJlbWVtYmVyIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBmb3IgdGhlIG5leHQgcmVsb2FkLlxuXG5cbiAgICAgICAgaWYgKF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaCA9PT0gbnVsbCB8fCBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uTWF0Y2guaWQgIT09IGlkKSB7XG4gICAgICAgICAgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoID0gbnVsbDtcbiAgICAgICAgICByZW5kZXJlci5zZXRUcmFja2VkUGF0aChudWxsKTtcblxuICAgICAgICAgIF90aGlzLl90aHJvdHRsZWRQZXJzaXN0U2VsZWN0aW9uKHJlbmRlcmVySUQsIGlkKTtcbiAgICAgICAgfSAvLyBUT0RPOiBJZiB0aGVyZSB3YXMgYSB3YXkgdG8gY2hhbmdlIHRoZSBzZWxlY3RlZCBET00gZWxlbWVudFxuICAgICAgICAvLyBpbiBuYXRpdmUgRWxlbWVudHMgdGFiIHdpdGhvdXQgZm9yY2luZyBhIHN3aXRjaCB0byBpdCwgd2UnZCBkbyBpdCBoZXJlLlxuICAgICAgICAvLyBGb3Igbm93LCBpdCBkb2Vzbid0IHNlZW0gbGlrZSB0aGVyZSBpcyBhIHdheSB0byBkbyB0aGF0OlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnZhdWdobi9yZWFjdC1kZXZ0b29scy1leHBlcmltZW50YWwvaXNzdWVzLzEwMlxuICAgICAgICAvLyAoU2V0dGluZyAkMCBkb2Vzbid0IHdvcmssIGFuZCBjYWxsaW5nIGluc3BlY3QoKSBzd2l0Y2hlcyB0aGUgdGFiLilcblxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJsb2dFbGVtZW50VG9Db25zb2xlXCIsIGZ1bmN0aW9uIChfcmVmOSkge1xuICAgICAgdmFyIGlkID0gX3JlZjkuaWQsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWY5LnJlbmRlcmVySUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIubG9nRWxlbWVudFRvQ29uc29sZShpZCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlRXJyb3JcIiwgZnVuY3Rpb24gKF9yZWYxMCkge1xuICAgICAgdmFyIGlkID0gX3JlZjEwLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTAucmVuZGVyZXJJRCxcbiAgICAgICAgICBmb3JjZUVycm9yID0gX3JlZjEwLmZvcmNlRXJyb3I7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIub3ZlcnJpZGVFcnJvcihpZCwgZm9yY2VFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlU3VzcGVuc2VcIiwgZnVuY3Rpb24gKF9yZWYxMSkge1xuICAgICAgdmFyIGlkID0gX3JlZjExLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTEucmVuZGVyZXJJRCxcbiAgICAgICAgICBmb3JjZUZhbGxiYWNrID0gX3JlZjExLmZvcmNlRmFsbGJhY2s7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIub3ZlcnJpZGVTdXNwZW5zZShpZCwgZm9yY2VGYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlVmFsdWVBdFBhdGhcIiwgZnVuY3Rpb24gKF9yZWYxMikge1xuICAgICAgdmFyIGhvb2tJRCA9IF9yZWYxMi5ob29rSUQsXG4gICAgICAgICAgaWQgPSBfcmVmMTIuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxMi5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTIucmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlID0gX3JlZjEyLnR5cGUsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMTIudmFsdWU7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIub3ZlcnJpZGVWYWx1ZUF0UGF0aCh0eXBlLCBpZCwgaG9va0lELCBwYXRoLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlQ29udGV4dFwiLCBmdW5jdGlvbiAoX3JlZjEzKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMTMuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxMy5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTMucmVuZGVyZXJJRCxcbiAgICAgICAgICB3YXNGb3J3YXJkZWQgPSBfcmVmMTMud2FzRm9yd2FyZGVkLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjEzLnZhbHVlO1xuXG4gICAgICAvLyBEb24ndCBmb3J3YXJkIGEgbWVzc2FnZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGZvcndhcmRlZCBieSB0aGUgZnJvbnQtZW5kIEJyaWRnZS5cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBvdmVycmlkZSBjb21tYW5kIG9uY2UhXG4gICAgICBpZiAoIXdhc0ZvcndhcmRlZCkge1xuICAgICAgICBfdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgIHR5cGU6ICdjb250ZXh0JyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm92ZXJyaWRlSG9va1N0YXRlXCIsIGZ1bmN0aW9uIChfcmVmMTQpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYxNC5pZCxcbiAgICAgICAgICBob29rSUQgPSBfcmVmMTQuaG9va0lELFxuICAgICAgICAgIHBhdGggPSBfcmVmMTQucGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjE0LnJlbmRlcmVySUQsXG4gICAgICAgICAgd2FzRm9yd2FyZGVkID0gX3JlZjE0Lndhc0ZvcndhcmRlZCxcbiAgICAgICAgICB2YWx1ZSA9IF9yZWYxNC52YWx1ZTtcblxuICAgICAgLy8gRG9uJ3QgZm9yd2FyZCBhIG1lc3NhZ2UgdGhhdCdzIGFscmVhZHkgYmVlbiBmb3J3YXJkZWQgYnkgdGhlIGZyb250LWVuZCBCcmlkZ2UuXG4gICAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcHJvY2VzcyB0aGUgb3ZlcnJpZGUgY29tbWFuZCBvbmNlIVxuICAgICAgaWYgKCF3YXNGb3J3YXJkZWQpIHtcbiAgICAgICAgX3RoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICB0eXBlOiAnaG9va3MnLFxuICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib3ZlcnJpZGVQcm9wc1wiLCBmdW5jdGlvbiAoX3JlZjE1KSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMTUuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxNS5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTUucmVuZGVyZXJJRCxcbiAgICAgICAgICB3YXNGb3J3YXJkZWQgPSBfcmVmMTUud2FzRm9yd2FyZGVkLFxuICAgICAgICAgIHZhbHVlID0gX3JlZjE1LnZhbHVlO1xuXG4gICAgICAvLyBEb24ndCBmb3J3YXJkIGEgbWVzc2FnZSB0aGF0J3MgYWxyZWFkeSBiZWVuIGZvcndhcmRlZCBieSB0aGUgZnJvbnQtZW5kIEJyaWRnZS5cbiAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byBwcm9jZXNzIHRoZSBvdmVycmlkZSBjb21tYW5kIG9uY2UhXG4gICAgICBpZiAoIXdhc0ZvcndhcmRlZCkge1xuICAgICAgICBfdGhpcy5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJvdmVycmlkZVN0YXRlXCIsIGZ1bmN0aW9uIChfcmVmMTYpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYxNi5pZCxcbiAgICAgICAgICBwYXRoID0gX3JlZjE2LnBhdGgsXG4gICAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYxNi5yZW5kZXJlcklELFxuICAgICAgICAgIHdhc0ZvcndhcmRlZCA9IF9yZWYxNi53YXNGb3J3YXJkZWQsXG4gICAgICAgICAgdmFsdWUgPSBfcmVmMTYudmFsdWU7XG5cbiAgICAgIC8vIERvbid0IGZvcndhcmQgYSBtZXNzYWdlIHRoYXQncyBhbHJlYWR5IGJlZW4gZm9yd2FyZGVkIGJ5IHRoZSBmcm9udC1lbmQgQnJpZGdlLlxuICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHByb2Nlc3MgdGhlIG92ZXJyaWRlIGNvbW1hbmQgb25jZSFcbiAgICAgIGlmICghd2FzRm9yd2FyZGVkKSB7XG4gICAgICAgIF90aGlzLm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZTogJ3N0YXRlJyxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbG9hZEFuZFByb2ZpbGVcIiwgZnVuY3Rpb24gKHJlY29yZENoYW5nZURlc2NyaXB0aW9ucykge1xuICAgICAgc2Vzc2lvblN0b3JhZ2VTZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZLCAndHJ1ZScpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2VTZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVksIHJlY29yZENoYW5nZURlc2NyaXB0aW9ucyA/ICd0cnVlJyA6ICdmYWxzZScpOyAvLyBUaGlzIGNvZGUgcGF0aCBzaG91bGQgb25seSBiZSBoaXQgaWYgdGhlIHNoZWxsIGhhcyBleHBsaWNpdGx5IHRvbGQgdGhlIFN0b3JlIHRoYXQgaXQgc3VwcG9ydHMgcHJvZmlsaW5nLlxuICAgICAgLy8gSW4gdGhhdCBjYXNlLCB0aGUgc2hlbGwgbXVzdCBhbHNvIGxpc3RlbiBmb3IgdGhpcyBzcGVjaWZpYyBtZXNzYWdlIHRvIGtub3cgd2hlbiBpdCBuZWVkcyB0byByZWxvYWQgdGhlIGFwcC5cbiAgICAgIC8vIFRoZSBhZ2VudCBjYW4ndCBkbyB0aGlzIGluIGEgd2F5IHRoYXQgaXMgcmVuZGVyZXIgYWdub3N0aWMuXG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgncmVsb2FkQXBwRm9yUHJvZmlsaW5nJyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbmFtZVBhdGhcIiwgZnVuY3Rpb24gKF9yZWYxNykge1xuICAgICAgdmFyIGhvb2tJRCA9IF9yZWYxNy5ob29rSUQsXG4gICAgICAgICAgaWQgPSBfcmVmMTcuaWQsXG4gICAgICAgICAgbmV3UGF0aCA9IF9yZWYxNy5uZXdQYXRoLFxuICAgICAgICAgIG9sZFBhdGggPSBfcmVmMTcub2xkUGF0aCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjE3LnJlbmRlcmVySUQsXG4gICAgICAgICAgdHlwZSA9IF9yZWYxNy50eXBlO1xuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIiBmb3IgZWxlbWVudCBcXFwiXCIpLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlbmRlcmVyLnJlbmFtZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInNldFRyYWNlVXBkYXRlc0VuYWJsZWRcIiwgZnVuY3Rpb24gKHRyYWNlVXBkYXRlc0VuYWJsZWQpIHtcbiAgICAgIF90aGlzLl90cmFjZVVwZGF0ZXNFbmFibGVkID0gdHJhY2VVcGRhdGVzRW5hYmxlZDtcbiAgICAgIHRvZ2dsZUVuYWJsZWQodHJhY2VVcGRhdGVzRW5hYmxlZCk7XG5cbiAgICAgIGZvciAodmFyIHJlbmRlcmVySUQgaW4gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgICAgICByZW5kZXJlci5zZXRUcmFjZVVwZGF0ZXNFbmFibGVkKHRyYWNlVXBkYXRlc0VuYWJsZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzeW5jU2VsZWN0aW9uRnJvbU5hdGl2ZUVsZW1lbnRzUGFuZWxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRhcmdldCA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uJDA7XG5cbiAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzLnNlbGVjdE5vZGUodGFyZ2V0KTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic2h1dGRvd25cIiwgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gQ2xlYW4gdXAgdGhlIG92ZXJsYXkgaWYgdmlzaWJsZSwgYW5kIGFzc29jaWF0ZWQgZXZlbnRzLlxuICAgICAgX3RoaXMuZW1pdCgnc2h1dGRvd24nKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RhcnRQcm9maWxpbmdcIiwgZnVuY3Rpb24gKHJlY29yZENoYW5nZURlc2NyaXB0aW9ucykge1xuICAgICAgX3RoaXMuX3JlY29yZENoYW5nZURlc2NyaXB0aW9ucyA9IHJlY29yZENoYW5nZURlc2NyaXB0aW9ucztcbiAgICAgIF90aGlzLl9pc1Byb2ZpbGluZyA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIHJlbmRlcmVySUQgaW4gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgICAgICByZW5kZXJlci5zdGFydFByb2ZpbGluZyhyZWNvcmRDaGFuZ2VEZXNjcmlwdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ1N0YXR1cycsIF90aGlzLl9pc1Byb2ZpbGluZyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInN0b3BQcm9maWxpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2lzUHJvZmlsaW5nID0gZmFsc2U7XG4gICAgICBfdGhpcy5fcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gZmFsc2U7XG5cbiAgICAgIGZvciAodmFyIHJlbmRlcmVySUQgaW4gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlcykge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuICAgICAgICByZW5kZXJlci5zdG9wUHJvZmlsaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9icmlkZ2Uuc2VuZCgncHJvZmlsaW5nU3RhdHVzJywgX3RoaXMuX2lzUHJvZmlsaW5nKTtcbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwic3RvcmVBc0dsb2JhbFwiLCBmdW5jdGlvbiAoX3JlZjE4KSB7XG4gICAgICB2YXIgY291bnQgPSBfcmVmMTguY291bnQsXG4gICAgICAgICAgaWQgPSBfcmVmMTguaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYxOC5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMTgucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5zdG9yZUFzR2xvYmFsKGlkLCBwYXRoLCBjb3VudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInVwZGF0ZUNvbnNvbGVQYXRjaFNldHRpbmdzXCIsIGZ1bmN0aW9uIChfcmVmMTkpIHtcbiAgICAgIHZhciBhcHBlbmRDb21wb25lbnRTdGFjayA9IF9yZWYxOS5hcHBlbmRDb21wb25lbnRTdGFjayxcbiAgICAgICAgICBicmVha09uQ29uc29sZUVycm9ycyA9IF9yZWYxOS5icmVha09uQ29uc29sZUVycm9ycyxcbiAgICAgICAgICBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnMgPSBfcmVmMTkuc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzO1xuXG4gICAgICAvLyBJZiB0aGUgZnJvbnRlbmQgcHJlZmVyZW5jZSBoYXMgY2hhbmdlLFxuICAgICAgLy8gb3IgaW4gdGhlIGNhc2Ugb2YgUmVhY3QgTmF0aXZlLSBpZiB0aGUgYmFja2VuZCBpcyBqdXN0IGZpbmRpbmcgb3V0IHRoZSBwcmVmZXJlbmNlLVxuICAgICAgLy8gdGhlbiBpbnN0YWxsIG9yIHVuaW5zdGFsbCB0aGUgY29uc29sZSBvdmVycmlkZXMuXG4gICAgICAvLyBJdCdzIHNhZmUgdG8gY2FsbCB0aGVzZSBtZXRob2RzIG11bHRpcGxlIHRpbWVzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIHdvcnJ5IGFib3V0IHRoYXQuXG4gICAgICBpZiAoYXBwZW5kQ29tcG9uZW50U3RhY2sgfHwgYnJlYWtPbkNvbnNvbGVFcnJvcnMgfHwgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSB7XG4gICAgICAgIHBhdGNoKHtcbiAgICAgICAgICBhcHBlbmRDb21wb25lbnRTdGFjazogYXBwZW5kQ29tcG9uZW50U3RhY2ssXG4gICAgICAgICAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IGJyZWFrT25Db25zb2xlRXJyb3JzLFxuICAgICAgICAgIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9yczogc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdW5wYXRjaCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgYWdlbnRfZGVmaW5lUHJvcGVydHkoYWdlbnRfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ1cGRhdGVDb21wb25lbnRGaWx0ZXJzXCIsIGZ1bmN0aW9uIChjb21wb25lbnRGaWx0ZXJzKSB7XG4gICAgICBmb3IgKHZhciByZW5kZXJlcklEIGluIF90aGlzLl9yZW5kZXJlckludGVyZmFjZXMpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICAgICAgcmVuZGVyZXIudXBkYXRlQ29tcG9uZW50RmlsdGVycyhjb21wb25lbnRGaWx0ZXJzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidmlld0F0dHJpYnV0ZVNvdXJjZVwiLCBmdW5jdGlvbiAoX3JlZjIwKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMjAuaWQsXG4gICAgICAgICAgcGF0aCA9IF9yZWYyMC5wYXRoLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMjAucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IF90aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF07XG5cbiAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgcmVuZGVyZXIgaWQgXFxcIlwiLmNvbmNhdChyZW5kZXJlcklELCBcIlxcXCIgZm9yIGVsZW1lbnQgXFxcIlwiKS5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW5kZXJlci5wcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZShpZCwgcGF0aCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInZpZXdFbGVtZW50U291cmNlXCIsIGZ1bmN0aW9uIChfcmVmMjEpIHtcbiAgICAgIHZhciBpZCA9IF9yZWYyMS5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjIxLnJlbmRlcmVySUQ7XG4gICAgICB2YXIgcmVuZGVyZXIgPSBfdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICBpZiAocmVuZGVyZXIgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiIGZvciBlbGVtZW50IFxcXCJcIikuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVuZGVyZXIucHJlcGFyZVZpZXdFbGVtZW50U291cmNlKGlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGFnZW50X2RlZmluZVByb3BlcnR5KGFnZW50X2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwib25UcmFjZVVwZGF0ZXNcIiwgZnVuY3Rpb24gKG5vZGVzKSB7XG4gICAgICBfdGhpcy5lbWl0KCd0cmFjZVVwZGF0ZXMnLCBub2Rlcyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uRmFzdFJlZnJlc2hTY2hlZHVsZWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICBhZ2VudF9kZWJ1Zygnb25GYXN0UmVmcmVzaFNjaGVkdWxlZCcpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5fYnJpZGdlLnNlbmQoJ2Zhc3RSZWZyZXNoU2NoZWR1bGVkJyk7XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm9uSG9va09wZXJhdGlvbnNcIiwgZnVuY3Rpb24gKG9wZXJhdGlvbnMpIHtcbiAgICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgICAgYWdlbnRfZGVidWcoJ29uSG9va09wZXJhdGlvbnMnLCBcIihcIi5jb25jYXQob3BlcmF0aW9ucy5sZW5ndGgsIFwiKSBbXCIpLmNvbmNhdChvcGVyYXRpb25zLmpvaW4oJywgJyksIFwiXVwiKSk7XG4gICAgICB9IC8vIFRPRE86XG4gICAgICAvLyBUaGUgY2hyb21lLnJ1bnRpbWUgZG9lcyBub3QgY3VycmVudGx5IHN1cHBvcnQgdHJhbnNmZXJhYmxlczsgaXQgZm9yY2VzIEpTT04gc2VyaWFsaXphdGlvbi5cbiAgICAgIC8vIFNlZSBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTI3MTM0XG4gICAgICAvL1xuICAgICAgLy8gUmVnYXJkaW5nIHRyYW5zZmVyYWJsZXMsIHRoZSBwb3N0TWVzc2FnZSBkb2Mgc3RhdGVzOlxuICAgICAgLy8gSWYgdGhlIG93bmVyc2hpcCBvZiBhbiBvYmplY3QgaXMgdHJhbnNmZXJyZWQsIGl0IGJlY29tZXMgdW51c2FibGUgKG5ldXRlcmVkKVxuICAgICAgLy8gaW4gdGhlIGNvbnRleHQgaXQgd2FzIHNlbnQgZnJvbSBhbmQgYmVjb21lcyBhdmFpbGFibGUgb25seSB0byB0aGUgd29ya2VyIGl0IHdhcyBzZW50IHRvLlxuICAgICAgLy9cbiAgICAgIC8vIEV2ZW4gdGhvdWdoIENocm9tZSBpcyBldmVudHVhbGx5IEpTT04gc2VyaWFsaXppbmcgdGhlIGFycmF5IGJ1ZmZlcixcbiAgICAgIC8vIHVzaW5nIHRoZSB0cmFuc2ZlcmFibGUgYXBwcm9hY2ggYWxzbyBzb21ldGltZXMgY2F1c2VzIGl0IHRvIHRocm93OlxuICAgICAgLy8gICBET01FeGNlcHRpb246IEZhaWxlZCB0byBleGVjdXRlICdwb3N0TWVzc2FnZScgb24gJ1dpbmRvdyc6IEFycmF5QnVmZmVyIGF0IGluZGV4IDAgaXMgYWxyZWFkeSBuZXV0ZXJlZC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWUgYnVnIGh0dHBzOi8vZ2l0aHViLmNvbS9idmF1Z2huL3JlYWN0LWRldnRvb2xzLWV4cGVyaW1lbnRhbC9pc3N1ZXMvMjVcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgU3RvcmUgaGFzIGEgZmFsbGJhY2sgaW4gcGxhY2UgdGhhdCBwYXJzZXMgdGhlIG1lc3NhZ2UgYXMgSlNPTiBpZiB0aGUgdHlwZSBpc24ndCBhbiBhcnJheS5cbiAgICAgIC8vIEZvciBub3cgdGhlIHNpbXBsZXN0IGZpeCBzZWVtcyB0byBiZSB0byBub3QgdHJhbnNmZXIgdGhlIGFycmF5LlxuICAgICAgLy8gVGhpcyB3aWxsIG5lZ2F0aXZlbHkgaW1wYWN0IHBlcmZvcm1hbmNlIG9uIEZpcmVmb3ggc28gaXQncyB1bmZvcnR1bmF0ZSxcbiAgICAgIC8vIGJ1dCB1bnRpbCB3ZSdyZSBhYmxlIHRvIGZpeCB0aGUgQ2hyb21lIGVycm9yIG1lbnRpb25lZCBhYm92ZSwgaXQgc2VlbXMgbmVjZXNzYXJ5LlxuICAgICAgLy9cbiAgICAgIC8vIHRoaXMuX2JyaWRnZS5zZW5kKCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucywgW29wZXJhdGlvbnMuYnVmZmVyXSk7XG5cblxuICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdvcGVyYXRpb25zJywgb3BlcmF0aW9ucyk7XG5cbiAgICAgIGlmIChfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIHZhciByZW5kZXJlcklEID0gb3BlcmF0aW9uc1swXTtcblxuICAgICAgICBpZiAoX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbi5yZW5kZXJlcklEID09PSByZW5kZXJlcklEKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHNlbGVjdCBhIGRlZXBlciBtYXRjaCBmb3IgdGhlIHBlcnNpc3RlZCBzZWxlY3Rpb24uXG4gICAgICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgICAgIGlmIChyZW5kZXJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJJbnZhbGlkIHJlbmRlcmVyIGlkIFxcXCJcIi5jb25jYXQocmVuZGVyZXJJRCwgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZNYXRjaCA9IF90aGlzLl9wZXJzaXN0ZWRTZWxlY3Rpb25NYXRjaDtcbiAgICAgICAgICAgIHZhciBuZXh0TWF0Y2ggPSByZW5kZXJlci5nZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCgpO1xuICAgICAgICAgICAgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoID0gbmV4dE1hdGNoO1xuICAgICAgICAgICAgdmFyIHByZXZNYXRjaElEID0gcHJldk1hdGNoICE9PSBudWxsID8gcHJldk1hdGNoLmlkIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBuZXh0TWF0Y2hJRCA9IG5leHRNYXRjaCAhPT0gbnVsbCA/IG5leHRNYXRjaC5pZCA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChwcmV2TWF0Y2hJRCAhPT0gbmV4dE1hdGNoSUQpIHtcbiAgICAgICAgICAgICAgaWYgKG5leHRNYXRjaElEICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgbW92ZWQgZm9yd2FyZCwgdW5sb2NraW5nIGEgZGVlcGVyIG5vZGUuXG4gICAgICAgICAgICAgICAgX3RoaXMuX2JyaWRnZS5zZW5kKCdzZWxlY3RGaWJlcicsIG5leHRNYXRjaElEKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV4dE1hdGNoICE9PSBudWxsICYmIG5leHRNYXRjaC5pc0Z1bGxNYXRjaCkge1xuICAgICAgICAgICAgICAvLyBXZSd2ZSBqdXN0IHVubG9ja2VkIHRoZSBpbm5lcm1vc3Qgc2VsZWN0ZWQgbm9kZS5cbiAgICAgICAgICAgICAgLy8gVGhlcmUncyBubyBwb2ludCB0cmFja2luZyBpdCBmdXJ0aGVyLlxuICAgICAgICAgICAgICBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgX3RoaXMuX3BlcnNpc3RlZFNlbGVjdGlvbk1hdGNoID0gbnVsbDtcbiAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0VHJhY2tlZFBhdGgobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBhZ2VudF9kZWZpbmVQcm9wZXJ0eShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIl90aHJvdHRsZWRQZXJzaXN0U2VsZWN0aW9uXCIsIGxvZGFzaF90aHJvdHRsZV9kZWZhdWx0KCkoZnVuY3Rpb24gKHJlbmRlcmVySUQsIGlkKSB7XG4gICAgICAvLyBUaGlzIGlzIHRocm90dGxlZCwgc28gYm90aCByZW5kZXJlciBhbmQgc2VsZWN0ZWQgSURcbiAgICAgIC8vIG1pZ2h0IG5vdCBiZSBhdmFpbGFibGUgYnkgdGhlIHRpbWUgd2UgcmVhZCB0aGVtLlxuICAgICAgLy8gVGhpcyBpcyB3aHkgd2UgbmVlZCB0aGUgZGVmZW5zaXZlIGNoZWNrcyBoZXJlLlxuICAgICAgdmFyIHJlbmRlcmVyID0gX3RoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcbiAgICAgIHZhciBwYXRoID0gcmVuZGVyZXIgIT0gbnVsbCA/IHJlbmRlcmVyLmdldFBhdGhGb3JFbGVtZW50KGlkKSA6IG51bGw7XG5cbiAgICAgIGlmIChwYXRoICE9PSBudWxsKSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlU2V0SXRlbShTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgICBwYXRoOiBwYXRoXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlc3Npb25TdG9yYWdlUmVtb3ZlSXRlbShTRVNTSU9OX1NUT1JBR0VfTEFTVF9TRUxFQ1RJT05fS0VZKTtcbiAgICAgIH1cbiAgICB9LCAxMDAwKSk7XG5cbiAgICBpZiAoc2Vzc2lvblN0b3JhZ2VHZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZKSA9PT0gJ3RydWUnKSB7XG4gICAgICBfdGhpcy5fcmVjb3JkQ2hhbmdlRGVzY3JpcHRpb25zID0gc2Vzc2lvblN0b3JhZ2VHZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkpID09PSAndHJ1ZSc7XG4gICAgICBfdGhpcy5faXNQcm9maWxpbmcgPSB0cnVlO1xuICAgICAgc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUNPUkRfQ0hBTkdFX0RFU0NSSVBUSU9OU19LRVkpO1xuICAgICAgc2Vzc2lvblN0b3JhZ2VSZW1vdmVJdGVtKFNFU1NJT05fU1RPUkFHRV9SRUxPQURfQU5EX1BST0ZJTEVfS0VZKTtcbiAgICB9XG5cbiAgICB2YXIgcGVyc2lzdGVkU2VsZWN0aW9uU3RyaW5nID0gc2Vzc2lvblN0b3JhZ2VHZXRJdGVtKFNFU1NJT05fU1RPUkFHRV9MQVNUX1NFTEVDVElPTl9LRVkpO1xuXG4gICAgaWYgKHBlcnNpc3RlZFNlbGVjdGlvblN0cmluZyAhPSBudWxsKSB7XG4gICAgICBfdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uID0gSlNPTi5wYXJzZShwZXJzaXN0ZWRTZWxlY3Rpb25TdHJpbmcpO1xuICAgIH1cblxuICAgIF90aGlzLl9icmlkZ2UgPSBicmlkZ2U7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjbGVhckVycm9yc0FuZFdhcm5pbmdzJywgX3RoaXMuY2xlYXJFcnJvcnNBbmRXYXJuaW5ncyk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjbGVhckVycm9yc0ZvckZpYmVySUQnLCBfdGhpcy5jbGVhckVycm9yc0ZvckZpYmVySUQpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQnLCBfdGhpcy5jbGVhcldhcm5pbmdzRm9yRmliZXJJRCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdjb3B5RWxlbWVudFBhdGgnLCBfdGhpcy5jb3B5RWxlbWVudFBhdGgpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZGVsZXRlUGF0aCcsIF90aGlzLmRlbGV0ZVBhdGgpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZ2V0QnJpZGdlUHJvdG9jb2wnLCBfdGhpcy5nZXRCcmlkZ2VQcm90b2NvbCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRQcm9maWxpbmdEYXRhJywgX3RoaXMuZ2V0UHJvZmlsaW5nRGF0YSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdnZXRQcm9maWxpbmdTdGF0dXMnLCBfdGhpcy5nZXRQcm9maWxpbmdTdGF0dXMpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignZ2V0T3duZXJzTGlzdCcsIF90aGlzLmdldE93bmVyc0xpc3QpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignaW5zcGVjdEVsZW1lbnQnLCBfdGhpcy5pbnNwZWN0RWxlbWVudCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdsb2dFbGVtZW50VG9Db25zb2xlJywgX3RoaXMubG9nRWxlbWVudFRvQ29uc29sZSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZUVycm9yJywgX3RoaXMub3ZlcnJpZGVFcnJvcik7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZVN1c3BlbnNlJywgX3RoaXMub3ZlcnJpZGVTdXNwZW5zZSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdvdmVycmlkZVZhbHVlQXRQYXRoJywgX3RoaXMub3ZlcnJpZGVWYWx1ZUF0UGF0aCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdyZWxvYWRBbmRQcm9maWxlJywgX3RoaXMucmVsb2FkQW5kUHJvZmlsZSk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdyZW5hbWVQYXRoJywgX3RoaXMucmVuYW1lUGF0aCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzZXRUcmFjZVVwZGF0ZXNFbmFibGVkJywgX3RoaXMuc2V0VHJhY2VVcGRhdGVzRW5hYmxlZCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzdGFydFByb2ZpbGluZycsIF90aGlzLnN0YXJ0UHJvZmlsaW5nKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0b3BQcm9maWxpbmcnLCBfdGhpcy5zdG9wUHJvZmlsaW5nKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N0b3JlQXNHbG9iYWwnLCBfdGhpcy5zdG9yZUFzR2xvYmFsKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3N5bmNTZWxlY3Rpb25Gcm9tTmF0aXZlRWxlbWVudHNQYW5lbCcsIF90aGlzLnN5bmNTZWxlY3Rpb25Gcm9tTmF0aXZlRWxlbWVudHNQYW5lbCk7XG4gICAgYnJpZGdlLmFkZExpc3RlbmVyKCdzaHV0ZG93bicsIF90aGlzLnNodXRkb3duKTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ3VwZGF0ZUNvbnNvbGVQYXRjaFNldHRpbmdzJywgX3RoaXMudXBkYXRlQ29uc29sZVBhdGNoU2V0dGluZ3MpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigndXBkYXRlQ29tcG9uZW50RmlsdGVycycsIF90aGlzLnVwZGF0ZUNvbXBvbmVudEZpbHRlcnMpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigndmlld0F0dHJpYnV0ZVNvdXJjZScsIF90aGlzLnZpZXdBdHRyaWJ1dGVTb3VyY2UpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigndmlld0VsZW1lbnRTb3VyY2UnLCBfdGhpcy52aWV3RWxlbWVudFNvdXJjZSk7IC8vIFRlbXBvcmFyaWx5IHN1cHBvcnQgb2xkZXIgc3RhbmRhbG9uZSBmcm9udC1lbmRzIHNlbmRpbmcgY29tbWFuZHMgdG8gbmV3ZXIgZW1iZWRkZWQgYmFja2VuZHMuXG4gICAgLy8gV2UgZG8gdGhpcyBiZWNhdXNlIFJlYWN0IE5hdGl2ZSBlbWJlZHMgdGhlIFJlYWN0IERldlRvb2xzIGJhY2tlbmQsXG4gICAgLy8gYnV0IGNhbm5vdCBjb250cm9sIHdoaWNoIHZlcnNpb24gb2YgdGhlIGZyb250ZW5kIHVzZXJzIHVzZS5cblxuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVDb250ZXh0JywgX3RoaXMub3ZlcnJpZGVDb250ZXh0KTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ292ZXJyaWRlSG9va1N0YXRlJywgX3RoaXMub3ZlcnJpZGVIb29rU3RhdGUpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVQcm9wcycsIF90aGlzLm92ZXJyaWRlUHJvcHMpO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcignb3ZlcnJpZGVTdGF0ZScsIF90aGlzLm92ZXJyaWRlU3RhdGUpO1xuXG4gICAgaWYgKF90aGlzLl9pc1Byb2ZpbGluZykge1xuICAgICAgYnJpZGdlLnNlbmQoJ3Byb2ZpbGluZ1N0YXR1cycsIHRydWUpO1xuICAgIH0gLy8gTm90aWZ5IHRoZSBmcm9udGVuZCBpZiB0aGUgYmFja2VuZCBzdXBwb3J0cyB0aGUgU3RvcmFnZSBBUEkgKGUuZy4gbG9jYWxTdG9yYWdlKS5cbiAgICAvLyBJZiBub3QsIGZlYXR1cmVzIGxpa2UgcmVsb2FkLWFuZC1wcm9maWxlIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGFuZCBtdXN0IGJlIGRpc2FibGVkLlxuXG5cbiAgICB2YXIgaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgdHJ5IHtcbiAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0ZXN0Jyk7XG4gICAgICBpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge31cblxuICAgIGJyaWRnZS5zZW5kKCdpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkJywgaXNCYWNrZW5kU3RvcmFnZUFQSVN1cHBvcnRlZCk7XG4gICAgYnJpZGdlLnNlbmQoJ2lzU3luY2hyb25vdXNYSFJTdXBwb3J0ZWQnLCBpc1N5bmNocm9ub3VzWEhSU3VwcG9ydGVkKCkpO1xuICAgIHNldHVwSGlnaGxpZ2h0ZXIoYnJpZGdlLCBhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBUcmFjZVVwZGF0ZXNfaW5pdGlhbGl6ZShhZ2VudF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBhZ2VudF9jcmVhdGVDbGFzcyhBZ2VudCwgW3tcbiAgICBrZXk6IFwiZ2V0SW5zdGFuY2VBbmRTdHlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbnN0YW5jZUFuZFN0eWxlKF9yZWYyMikge1xuICAgICAgdmFyIGlkID0gX3JlZjIyLmlkLFxuICAgICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMjIucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW52YWxpZCByZW5kZXJlciBpZCBcXFwiXCIuY29uY2F0KHJlbmRlcmVySUQsIFwiXFxcIlwiKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVuZGVyZXIuZ2V0SW5zdGFuY2VBbmRTdHlsZShpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldElERm9yTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJREZvck5vZGUobm9kZSkge1xuICAgICAgZm9yICh2YXIgcmVuZGVyZXJJRCBpbiB0aGlzLl9yZW5kZXJlckludGVyZmFjZXMpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzW3JlbmRlcmVySURdO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGlkID0gcmVuZGVyZXIuZ2V0RmliZXJJREZvck5hdGl2ZShub2RlLCB0cnVlKTtcblxuICAgICAgICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHsvLyBTb21lIG9sZCBSZWFjdCB2ZXJzaW9ucyBtaWdodCB0aHJvdyBpZiB0aGV5IGNhbid0IGZpbmQgYSBtYXRjaC5cbiAgICAgICAgICAvLyBJZiBzbyB3ZSBzaG91bGQgaWdub3JlIGl0Li4uXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlbGVjdE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0Tm9kZSh0YXJnZXQpIHtcbiAgICAgIHZhciBpZCA9IHRoaXMuZ2V0SURGb3JOb2RlKHRhcmdldCk7XG5cbiAgICAgIGlmIChpZCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9icmlkZ2Uuc2VuZCgnc2VsZWN0RmliZXInLCBpZCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFJlbmRlcmVySW50ZXJmYWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFJlbmRlcmVySW50ZXJmYWNlKHJlbmRlcmVySUQsIHJlbmRlcmVySW50ZXJmYWNlKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlckludGVyZmFjZXNbcmVuZGVyZXJJRF0gPSByZW5kZXJlckludGVyZmFjZTtcblxuICAgICAgaWYgKHRoaXMuX2lzUHJvZmlsaW5nKSB7XG4gICAgICAgIHJlbmRlcmVySW50ZXJmYWNlLnN0YXJ0UHJvZmlsaW5nKHRoaXMuX3JlY29yZENoYW5nZURlc2NyaXB0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHJlbmRlcmVySW50ZXJmYWNlLnNldFRyYWNlVXBkYXRlc0VuYWJsZWQodGhpcy5fdHJhY2VVcGRhdGVzRW5hYmxlZCk7IC8vIFdoZW4gdGhlIHJlbmRlcmVyIGlzIGF0dGFjaGVkLCB3ZSBuZWVkIHRvIHRlbGwgaXQgd2hldGhlclxuICAgICAgLy8gd2UgcmVtZW1iZXIgdGhlIHByZXZpb3VzIHNlbGVjdGlvbiB0aGF0IHdlJ2QgbGlrZSB0byByZXN0b3JlLlxuICAgICAgLy8gSXQnbGwgc3RhcnQgdHJhY2tpbmcgbW91bnRzIGZvciBtYXRjaGVzIHRvIHRoZSBsYXN0IHNlbGVjdGlvbiBwYXRoLlxuXG4gICAgICB2YXIgc2VsZWN0aW9uID0gdGhpcy5fcGVyc2lzdGVkU2VsZWN0aW9uO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsICYmIHNlbGVjdGlvbi5yZW5kZXJlcklEID09PSByZW5kZXJlcklEKSB7XG4gICAgICAgIHJlbmRlcmVySW50ZXJmYWNlLnNldFRyYWNrZWRQYXRoKHNlbGVjdGlvbi5wYXRoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25VbnN1cHBvcnRlZFJlbmRlcmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVW5zdXBwb3J0ZWRSZW5kZXJlcihyZW5kZXJlcklEKSB7XG4gICAgICB0aGlzLl9icmlkZ2Uuc2VuZCgndW5zdXBwb3J0ZWRSZW5kZXJlclZlcnNpb24nLCByZW5kZXJlcklEKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyZXJJbnRlcmZhY2VzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVuZGVyZXJJbnRlcmZhY2VzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBZ2VudDtcbn0oRXZlbnRFbWl0dGVyKTtcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2hvb2suanNcbi8qKlxuICogSW5zdGFsbCB0aGUgaG9vayBvbiB3aW5kb3csIHdoaWNoIGlzIGFuIGV2ZW50IGVtaXR0ZXIuXG4gKiBOb3RlIGJlY2F1c2UgQ2hyb21lIGNvbnRlbnQgc2NyaXB0cyBjYW5ub3QgZGlyZWN0bHkgbW9kaWZ5IHRoZSB3aW5kb3cgb2JqZWN0LFxuICogd2UgYXJlIGV2YWxpbmcgdGhpcyBmdW5jdGlvbiBieSBpbnNlcnRpbmcgYSBzY3JpcHQgdGFnLlxuICogVGhhdCdzIHdoeSB3ZSBoYXZlIHRvIGlubGluZSB0aGUgd2hvbGUgZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiBoZXJlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIGluc3RhbGxIb29rKHRhcmdldCkge1xuICBpZiAodGFyZ2V0Lmhhc093blByb3BlcnR5KCdfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18nKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0UmVhY3RCdWlsZFR5cGUocmVuZGVyZXIpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiByZW5kZXJlci52ZXJzaW9uID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBSZWFjdCBET00gRmliZXIgKDE2KylcbiAgICAgICAgaWYgKHJlbmRlcmVyLmJ1bmRsZVR5cGUgPiAwKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYSBwcm9kdWN0aW9uIGJ1aWxkLlxuICAgICAgICAgIC8vIFdlIGFyZSBjdXJyZW50bHkgb25seSB1c2luZyAwIChQUk9EKSBhbmQgMSAoREVWKVxuICAgICAgICAgIC8vIGJ1dCBtaWdodCBhZGQgMiAoUFJPRklMRSkgaW4gdGhlIGZ1dHVyZS5cbiAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgfSAvLyBSZWFjdCAxNiB1c2VzIGZsYXQgYnVuZGxlcy4gSWYgd2UgcmVwb3J0IHRoZSBidW5kbGUgYXMgcHJvZHVjdGlvblxuICAgICAgICAvLyB2ZXJzaW9uLCBpdCBtZWFucyB3ZSBhbHNvIG1pbmlmaWVkIGFuZCBlbnZpZmllZCBpdCBvdXJzZWx2ZXMuXG5cblxuICAgICAgICByZXR1cm4gJ3Byb2R1Y3Rpb24nOyAvLyBOb3RlOiBUaGVyZSBpcyBzdGlsbCBhIHJpc2sgdGhhdCB0aGUgQ29tbW9uSlMgZW50cnkgcG9pbnQgaGFzIG5vdFxuICAgICAgICAvLyBiZWVuIGVudmlmaWVkIG9yIHVnbGlmaWVkLiBJbiB0aGlzIGNhc2UgdGhlIHVzZXIgd291bGQgaGF2ZSAqYm90aCpcbiAgICAgICAgLy8gZGV2ZWxvcG1lbnQgYW5kIHByb2R1Y3Rpb24gYnVuZGxlLCBidXQgb25seSB0aGUgcHJvZCBvbmUgd291bGQgcnVuLlxuICAgICAgICAvLyBUaGlzIHdvdWxkIGJlIHJlYWxseSBiYWQuIFdlIGhhdmUgYSBzZXBhcmF0ZSBjaGVjayBmb3IgdGhpcyBiZWNhdXNlXG4gICAgICAgIC8vIGl0IGhhcHBlbnMgKm91dHNpZGUqIG9mIHRoZSByZW5kZXJlciBpbmplY3Rpb24uIFNlZSBgY2hlY2tEQ0VgIGJlbG93LlxuICAgICAgfVxuXG4gICAgICB2YXIgX3RvU3RyaW5nID0gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4gICAgICBpZiAocmVuZGVyZXIuTW91bnQgJiYgcmVuZGVyZXIuTW91bnQuX3JlbmRlck5ld1Jvb3RDb21wb25lbnQpIHtcbiAgICAgICAgLy8gUmVhY3QgRE9NIFN0YWNrXG4gICAgICAgIHZhciByZW5kZXJSb290Q29kZSA9IF90b1N0cmluZy5jYWxsKHJlbmRlcmVyLk1vdW50Ll9yZW5kZXJOZXdSb290Q29tcG9uZW50KTsgLy8gRmlsdGVyIG91dCBiYWQgcmVzdWx0cyAoaWYgdGhhdCBpcyBldmVuIHBvc3NpYmxlKTpcblxuXG4gICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdmdW5jdGlvbicpICE9PSAwKSB7XG4gICAgICAgICAgLy8gSG9wZSBmb3IgdGhlIGJlc3QgaWYgd2UncmUgbm90IHN1cmUuXG4gICAgICAgICAgcmV0dXJuICdwcm9kdWN0aW9uJztcbiAgICAgICAgfSAvLyBDaGVjayBmb3IgUmVhY3QgRE9NIFN0YWNrIDwgMTUuMS4wIGluIGRldmVsb3BtZW50LlxuICAgICAgICAvLyBJZiBpdCBjb250YWlucyBcInN0b3JlZE1lYXN1cmVcIiBjYWxsLCBpdCdzIHdyYXBwZWQgaW4gUmVhY3RQZXJmIChERVYgb25seSkuXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgdHJ1ZSBldmVuIGlmIGl0J3MgbWluaWZpZWQsIGFzIG1ldGhvZCBuYW1lIHN0aWxsIG1hdGNoZXMuXG5cblxuICAgICAgICBpZiAocmVuZGVyUm9vdENvZGUuaW5kZXhPZignc3RvcmVkTWVhc3VyZScpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICB9IC8vIEZvciBvdGhlciB2ZXJzaW9ucyAoYW5kIGNvbmZpZ3VyYXRpb25zKSBpdCdzIG5vdCBzbyBlYXN5LlxuICAgICAgICAvLyBMZXQncyBxdWlja2x5IGV4Y2x1ZGUgcHJvcGVyIHByb2R1Y3Rpb24gYnVpbGRzLlxuICAgICAgICAvLyBJZiBpdCBjb250YWlucyBhIHdhcm5pbmcgbWVzc2FnZSwgaXQncyBlaXRoZXIgYSBERVYgYnVpbGQsXG4gICAgICAgIC8vIG9yIGFuIFBST0QgYnVpbGQgd2l0aG91dCBwcm9wZXIgZGVhZCBjb2RlIGVsaW1pbmF0aW9uLlxuXG5cbiAgICAgICAgaWYgKHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ3Nob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24nKSAhPT0gLTEpIHtcbiAgICAgICAgICAvLyBOb3cgaG93IGRvIHdlIHRlbGwgYSBERVYgYnVpbGQgZnJvbSBhIGJhZCBQUk9EIGJ1aWxkP1xuICAgICAgICAgIC8vIElmIHdlIHNlZSBOT0RFX0VOViwgd2UncmUgZ29pbmcgdG8gYXNzdW1lIHRoaXMgaXMgYSBkZXYgYnVpbGRcbiAgICAgICAgICAvLyBiZWNhdXNlIG1vc3QgbGlrZWx5IGl0IGlzIHJlZmVycmluZyB0byBhbiBlbXB0eSBzaGltLlxuICAgICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCdOT0RFX0VOVicpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICdkZXZlbG9wbWVudCc7XG4gICAgICAgICAgfSAvLyBJZiB3ZSBzZWUgXCJkZXZlbG9wbWVudFwiLCB3ZSdyZSBkZWFsaW5nIHdpdGggYW4gZW52aWZpZWQgREVWIGJ1aWxkXG4gICAgICAgICAgLy8gKHN1Y2ggYXMgdGhlIG9mZmljaWFsIFJlYWN0IERFViBVTUQpLlxuXG5cbiAgICAgICAgICBpZiAocmVuZGVyUm9vdENvZGUuaW5kZXhPZignZGV2ZWxvcG1lbnQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAnZGV2ZWxvcG1lbnQnO1xuICAgICAgICAgIH0gLy8gSSd2ZSBzZWVuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgYmVpbmcgc21hcnRseVxuICAgICAgICAgIC8vIHJlcGxhY2VkIGJ5IGB0cnVlYCBpbiBERVYgYnkgV2VicGFjay4gSSBkb24ndCBrbm93IGhvdyB0aGF0XG4gICAgICAgICAgLy8gd29ya3MgYnV0IHdlIGNhbiBzYWZlbHkgZ3VhcmQgYWdhaW5zdCBpdCBiZWNhdXNlIGB0cnVlYCB3YXNcbiAgICAgICAgICAvLyBuZXZlciB1c2VkIGluIHRoZSBmdW5jdGlvbiBzb3VyY2Ugc2luY2UgaXQgd2FzIHdyaXR0ZW4uXG5cblxuICAgICAgICAgIGlmIChyZW5kZXJSb290Q29kZS5pbmRleE9mKCd0cnVlJykgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgICB9IC8vIEJ5IG5vdyBlaXRoZXIgaXQgaXMgYSBwcm9kdWN0aW9uIGJ1aWxkIHRoYXQgaGFzIG5vdCBiZWVuIG1pbmlmaWVkLFxuICAgICAgICAgIC8vIG9yICh3b3JzZSkgdGhpcyBpcyBhIG1pbmlmaWVkIGRldmVsb3BtZW50IGJ1aWxkIHVzaW5nIG5vbi1zdGFuZGFyZFxuICAgICAgICAgIC8vIGVudmlyb25tZW50IChlLmcuIFwic3RhZ2luZ1wiKS4gV2UncmUgZ29pbmcgdG8gbG9vayBhdCB3aGV0aGVyXG4gICAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGFyZ3VtZW50IG5hbWUgaXMgbWFuZ2xlZDpcblxuXG4gICAgICAgICAgaWYgKCAvLyAwLjEzIHRvIDE1XG4gICAgICAgICAgcmVuZGVyUm9vdENvZGUuaW5kZXhPZignbmV4dEVsZW1lbnQnKSAhPT0gLTEgfHwgLy8gMC4xMlxuICAgICAgICAgIHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ25leHRDb21wb25lbnQnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIFdlIGNhbid0IGJlIGNlcnRhaW4gd2hldGhlciB0aGlzIGlzIGEgZGV2ZWxvcG1lbnQgYnVpbGQgb3Igbm90LFxuICAgICAgICAgICAgLy8gYnV0IGl0IGlzIGRlZmluaXRlbHkgdW5taW5pZmllZC5cbiAgICAgICAgICAgIHJldHVybiAndW5taW5pZmllZCc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgbWluaWZpZWQgZGV2ZWxvcG1lbnQgYnVpbGQuXG4gICAgICAgICAgICByZXR1cm4gJ2RldmVsb3BtZW50JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQnkgbm93IHdlIGtub3cgdGhhdCBpdCdzIGVudmlmaWVkIGFuZCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd29ya2VkLFxuICAgICAgICAvLyBidXQgd2hhdCBpZiBpdCdzIHN0aWxsIG5vdCBtaW5pZmllZD8gKElzIHRoaXMgZXZlbiBwb3NzaWJsZT8pXG4gICAgICAgIC8vIExldCdzIGNoZWNrIG1hdGNoZXMgZm9yIHRoZSBmaXJzdCBhcmd1bWVudCBuYW1lLlxuXG5cbiAgICAgICAgaWYgKCAvLyAwLjEzIHRvIDE1XG4gICAgICAgIHJlbmRlclJvb3RDb2RlLmluZGV4T2YoJ25leHRFbGVtZW50JykgIT09IC0xIHx8IC8vIDAuMTJcbiAgICAgICAgcmVuZGVyUm9vdENvZGUuaW5kZXhPZignbmV4dENvbXBvbmVudCcpICE9PSAtMSkge1xuICAgICAgICAgIHJldHVybiAndW5taW5pZmllZCc7XG4gICAgICAgIH0gLy8gU2VlbXMgbGlrZSB3ZSdyZSB1c2luZyB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uLlxuICAgICAgICAvLyBIb3dldmVyLCB0aGUgYnJhbmNoIGFib3ZlIGlzIFN0YWNrLW9ubHkgc28gdGhpcyBpcyAxNSBvciBlYXJsaWVyLlxuXG5cbiAgICAgICAgcmV0dXJuICdvdXRkYXRlZCc7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7Ly8gV2VpcmQgZW52aXJvbm1lbnRzIG1heSBleGlzdC5cbiAgICAgIC8vIFRoaXMgY29kZSBuZWVkcyBhIGhpZ2hlciBmYXVsdCB0b2xlcmFuY2VcbiAgICAgIC8vIGJlY2F1c2UgaXQgcnVucyBldmVuIHdpdGggY2xvc2VkIERldlRvb2xzLlxuICAgICAgLy8gVE9ETzogc2hvdWxkIHdlIGNhdGNoIGVycm9ycyBpbiBhbGwgaW5qZWN0ZWQgY29kZSwgYW5kIG5vdCBqdXN0IHRoaXMgcGFydD9cbiAgICB9XG5cbiAgICByZXR1cm4gJ3Byb2R1Y3Rpb24nO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tEQ0UoZm4pIHtcbiAgICAvLyBUaGlzIHJ1bnMgZm9yIHByb2R1Y3Rpb24gdmVyc2lvbnMgb2YgUmVhY3QuXG4gICAgLy8gTmVlZHMgdG8gYmUgc3VwZXIgc2FmZS5cbiAgICB0cnkge1xuICAgICAgdmFyIF90b1N0cmluZzIgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG5cbiAgICAgIHZhciBjb2RlID0gX3RvU3RyaW5nMi5jYWxsKGZuKTsgLy8gVGhpcyBpcyBhIHN0cmluZyBlbWJlZGRlZCBpbiB0aGUgcGFzc2VkIGZ1bmN0aW9uIHVuZGVyIERFVi1vbmx5XG4gICAgICAvLyBjb25kaXRpb24uIEhvd2V2ZXIgdGhlIGZ1bmN0aW9uIGV4ZWN1dGVzIG9ubHkgaW4gUFJPRC4gVGhlcmVmb3JlLFxuICAgICAgLy8gaWYgd2Ugc2VlIGl0LCBkZWFkIGNvZGUgZWxpbWluYXRpb24gZGlkIG5vdCB3b3JrLlxuXG5cbiAgICAgIGlmIChjb2RlLmluZGV4T2YoJ15fXicpID4gLTEpIHtcbiAgICAgICAgLy8gUmVtZW1iZXIgdG8gcmVwb3J0IGR1cmluZyBuZXh0IGluamVjdGlvbi5cbiAgICAgICAgaGFzRGV0ZWN0ZWRCYWREQ0UgPSB0cnVlOyAvLyBCb251czogdGhyb3cgYW4gZXhjZXB0aW9uIGhvcGluZyB0aGF0IGl0IGdldHMgcGlja2VkIHVwIGJ5IGEgcmVwb3J0aW5nIHN5c3RlbS5cbiAgICAgICAgLy8gTm90IHN5bmNocm9ub3VzbHkgc28gdGhhdCBpdCBkb2Vzbid0IGJyZWFrIHRoZSBjYWxsaW5nIGNvZGUuXG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFjdCBpcyBydW5uaW5nIGluIHByb2R1Y3Rpb24gbW9kZSwgYnV0IGRlYWQgY29kZSAnICsgJ2VsaW1pbmF0aW9uIGhhcyBub3QgYmVlbiBhcHBsaWVkLiBSZWFkIGhvdyB0byBjb3JyZWN0bHkgJyArICdjb25maWd1cmUgUmVhY3QgZm9yIHByb2R1Y3Rpb246ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3BlcmYtdXNlLXByb2R1Y3Rpb24tYnVpbGQnKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7fVxuICB9XG5cbiAgdmFyIHVpZENvdW50ZXIgPSAwO1xuXG4gIGZ1bmN0aW9uIGluamVjdChyZW5kZXJlcikge1xuICAgIHZhciBpZCA9ICsrdWlkQ291bnRlcjtcbiAgICByZW5kZXJlcnMuc2V0KGlkLCByZW5kZXJlcik7XG4gICAgdmFyIHJlYWN0QnVpbGRUeXBlID0gaGFzRGV0ZWN0ZWRCYWREQ0UgPyAnZGVhZGNvZGUnIDogZGV0ZWN0UmVhY3RCdWlsZFR5cGUocmVuZGVyZXIpOyAvLyBQYXRjaGluZyB0aGUgY29uc29sZSBlbmFibGVzIERldlRvb2xzIHRvIGRvIGEgZmV3IHVzZWZ1bCB0aGluZ3M6XG4gICAgLy8gKiBBcHBlbmQgY29tcG9uZW50IHN0YWNrcyB0byB3YXJuaW5ncyBhbmQgZXJyb3IgbWVzc2FnZXNcbiAgICAvLyAqIERpc2FibGUgbG9nZ2luZyBkdXJpbmcgcmUtcmVuZGVycyB0byBpbnNwZWN0IGhvb2tzIChzZWUgaW5zcGVjdEhvb2tzT2ZGaWJlcilcbiAgICAvL1xuICAgIC8vIEZvciBSZWFjdCBOYXRpdmUsIHdlIGludGVudGlvbmFsbHkgcGF0Y2ggZWFybHkgKGR1cmluZyBpbmplY3Rpb24pLlxuICAgIC8vIFRoaXMgcHJvdmlkZXMgUmVhY3QgTmF0aXZlIGRldmVsb3BlcnMgd2l0aCBjb21wb25lbnRzIHN0YWNrcyBldmVuIGlmIHRoZXkgZG9uJ3QgcnVuIERldlRvb2xzLlxuICAgIC8vIFRoaXMgd29uJ3Qgd29yayBmb3IgRE9NIHRob3VnaCwgc2luY2UgdGhpcyBlbnRpcmUgZmlsZSBpcyBldmFsJ2VkIGFuZCBpbnNlcnRlZCBhcyBhIHNjcmlwdCB0YWcuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSdsbCBwYXRjaCBsYXRlciAod2hlbiB0aGUgZnJvbnRlbmQgYXR0YWNoZXMpLlxuICAgIC8vXG4gICAgLy8gRG9uJ3QgcGF0Y2ggaW4gdGVzdCBlbnZpcm9ubWVudHMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIGludGVyZmVyZSB3aXRoIEplc3QncyBvd24gY29uc29sZSBvdmVycmlkZXMuXG4gICAgLy9cbiAgICAvLyBOb3RlIHRoYXQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGlubGluZWQsIHRoaXMgY29uZGl0aW9uYWwgY2hlY2sgbXVzdCBvbmx5IHVzZSBzdGF0aWMgYm9vbGVhbnMuXG4gICAgLy8gT3RoZXJ3aXNlIHRoZSBleHRlbnNpb24gd2lsbCB0aHJvdyB3aXRoIGFuIHVuZGVmaW5lZCBlcnJvci5cbiAgICAvLyAoU2VlIGNvbW1lbnRzIGluIHRoZSB0cnkvY2F0Y2ggYmVsb3cgZm9yIG1vcmUgY29udGV4dCBvbiBpbmxpbmluZy4pXG5cbiAgICBpZiAodHJ1ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGFwcGVuZENvbXBvbmVudFN0YWNrID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQVBQRU5EX0NPTVBPTkVOVF9TVEFDS19fICE9PSBmYWxzZTtcbiAgICAgICAgdmFyIGJyZWFrT25Db25zb2xlRXJyb3JzID0gd2luZG93Ll9fUkVBQ1RfREVWVE9PTFNfQlJFQUtfT05fQ09OU09MRV9FUlJPUlNfXyA9PT0gdHJ1ZTtcbiAgICAgICAgdmFyIHNob3dJbmxpbmVXYXJuaW5nc0FuZEVycm9ycyA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX1NIT1dfSU5MSU5FX1dBUk5JTkdTX0FORF9FUlJPUlNfXyAhPT0gZmFsc2U7IC8vIFRoZSBpbnN0YWxsSG9vaygpIGZ1bmN0aW9uIGlzIGluamVjdGVkIGJ5IGJlaW5nIHN0cmluZ2lmaWVkIGluIHRoZSBicm93c2VyLFxuICAgICAgICAvLyBzbyBpbXBvcnRzIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbiBkbyBub3QgZ2V0IGluY2x1ZGVkLlxuICAgICAgICAvL1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSBjb3VsZCBjaGVjayBcInR5cGVvZiBwYXRjaENvbnNvbGUgPT09ICdmdW5jdGlvbidcIixcbiAgICAgICAgLy8gYnV0IFdlYnBhY2sgd3JhcHMgaW1wb3J0cyB3aXRoIGFuIG9iamVjdCAoZS5nLiBfYmFja2VuZF9jb25zb2xlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pXG4gICAgICAgIC8vIGFuZCB0aGUgb2JqZWN0IGl0c2VsZiB3aWxsIGJlIHVuZGVmaW5lZCBhcyB3ZWxsIGZvciB0aGUgcmVhc29ucyBtZW50aW9uZWQgYWJvdmUsXG4gICAgICAgIC8vIHNvIHdlIHVzZSB0cnkvY2F0Y2ggaW5zdGVhZC5cblxuICAgICAgICBpZiAoYXBwZW5kQ29tcG9uZW50U3RhY2sgfHwgYnJlYWtPbkNvbnNvbGVFcnJvcnMgfHwgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzKSB7XG4gICAgICAgICAgcmVnaXN0ZXJSZW5kZXJlcihyZW5kZXJlcik7XG4gICAgICAgICAgcGF0Y2goe1xuICAgICAgICAgICAgYXBwZW5kQ29tcG9uZW50U3RhY2s6IGFwcGVuZENvbXBvbmVudFN0YWNrLFxuICAgICAgICAgICAgYnJlYWtPbkNvbnNvbGVFcnJvcnM6IGJyZWFrT25Db25zb2xlRXJyb3JzLFxuICAgICAgICAgICAgc2hvd0lubGluZVdhcm5pbmdzQW5kRXJyb3JzOiBzaG93SW5saW5lV2FybmluZ3NBbmRFcnJvcnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfSAvLyBJZiB3ZSBoYXZlIGp1c3QgcmVsb2FkZWQgdG8gcHJvZmlsZSwgd2UgbmVlZCB0byBpbmplY3QgdGhlIHJlbmRlcmVyIGludGVyZmFjZSBiZWZvcmUgdGhlIGFwcCBsb2Fkcy5cbiAgICAvLyBPdGhlcndpc2UgdGhlIHJlbmRlcmVyIHdvbid0IHlldCBleGlzdCBhbmQgd2UgY2FuIHNraXAgdGhpcyBzdGVwLlxuXG5cbiAgICB2YXIgYXR0YWNoID0gdGFyZ2V0Ll9fUkVBQ1RfREVWVE9PTFNfQVRUQUNIX187XG5cbiAgICBpZiAodHlwZW9mIGF0dGFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHJlbmRlcmVySW50ZXJmYWNlID0gYXR0YWNoKGhvb2ssIGlkLCByZW5kZXJlciwgdGFyZ2V0KTtcbiAgICAgIGhvb2sucmVuZGVyZXJJbnRlcmZhY2VzLnNldChpZCwgcmVuZGVyZXJJbnRlcmZhY2UpO1xuICAgIH1cblxuICAgIGhvb2suZW1pdCgncmVuZGVyZXInLCB7XG4gICAgICBpZDogaWQsXG4gICAgICByZW5kZXJlcjogcmVuZGVyZXIsXG4gICAgICByZWFjdEJ1aWxkVHlwZTogcmVhY3RCdWlsZFR5cGVcbiAgICB9KTtcbiAgICByZXR1cm4gaWQ7XG4gIH1cblxuICB2YXIgaGFzRGV0ZWN0ZWRCYWREQ0UgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzdWIoZXZlbnQsIGZuKSB7XG4gICAgaG9vay5vbihldmVudCwgZm4pO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gaG9vay5vZmYoZXZlbnQsIGZuKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gb24oZXZlbnQsIGZuKSB7XG4gICAgaWYgKCFsaXN0ZW5lcnNbZXZlbnRdKSB7XG4gICAgICBsaXN0ZW5lcnNbZXZlbnRdID0gW107XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzW2V2ZW50XS5wdXNoKGZuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9mZihldmVudCwgZm4pIHtcbiAgICBpZiAoIWxpc3RlbmVyc1tldmVudF0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBsaXN0ZW5lcnNbZXZlbnRdLmluZGV4T2YoZm4pO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmICghbGlzdGVuZXJzW2V2ZW50XS5sZW5ndGgpIHtcbiAgICAgIGRlbGV0ZSBsaXN0ZW5lcnNbZXZlbnRdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGRhdGEpIHtcbiAgICBpZiAobGlzdGVuZXJzW2V2ZW50XSkge1xuICAgICAgbGlzdGVuZXJzW2V2ZW50XS5tYXAoZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbihkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpYmVyUm9vdHMocmVuZGVyZXJJRCkge1xuICAgIHZhciByb290cyA9IGZpYmVyUm9vdHM7XG5cbiAgICBpZiAoIXJvb3RzW3JlbmRlcmVySURdKSB7XG4gICAgICByb290c1tyZW5kZXJlcklEXSA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdHNbcmVuZGVyZXJJRF07XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcikge1xuICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IHJlbmRlcmVySW50ZXJmYWNlcy5nZXQocmVuZGVyZXJJRCk7XG5cbiAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgcmVuZGVyZXJJbnRlcmZhY2UuaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50KGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBwcmlvcml0eUxldmVsKSB7XG4gICAgdmFyIG1vdW50ZWRSb290cyA9IGhvb2suZ2V0RmliZXJSb290cyhyZW5kZXJlcklEKTtcbiAgICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgICB2YXIgaXNLbm93blJvb3QgPSBtb3VudGVkUm9vdHMuaGFzKHJvb3QpO1xuICAgIHZhciBpc1VubW91bnRpbmcgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUgPT0gbnVsbCB8fCBjdXJyZW50Lm1lbW9pemVkU3RhdGUuZWxlbWVudCA9PSBudWxsOyAvLyBLZWVwIHRyYWNrIG9mIG1vdW50ZWQgcm9vdHMgc28gd2UgY2FuIGh5ZHJhdGUgd2hlbiBEZXZUb29scyBjb25uZWN0LlxuXG4gICAgaWYgKCFpc0tub3duUm9vdCAmJiAhaXNVbm1vdW50aW5nKSB7XG4gICAgICBtb3VudGVkUm9vdHMuYWRkKHJvb3QpO1xuICAgIH0gZWxzZSBpZiAoaXNLbm93blJvb3QgJiYgaXNVbm1vdW50aW5nKSB7XG4gICAgICBtb3VudGVkUm9vdHMuZGVsZXRlKHJvb3QpO1xuICAgIH1cblxuICAgIHZhciByZW5kZXJlckludGVyZmFjZSA9IHJlbmRlcmVySW50ZXJmYWNlcy5nZXQocmVuZGVyZXJJRCk7XG5cbiAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgcmVuZGVyZXJJbnRlcmZhY2UuaGFuZGxlQ29tbWl0RmliZXJSb290KHJvb3QsIHByaW9yaXR5TGV2ZWwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KSB7XG4gICAgdmFyIHJlbmRlcmVySW50ZXJmYWNlID0gcmVuZGVyZXJJbnRlcmZhY2VzLmdldChyZW5kZXJlcklEKTtcblxuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSAhPSBudWxsKSB7XG4gICAgICByZW5kZXJlckludGVyZmFjZS5oYW5kbGVQb3N0Q29tbWl0RmliZXJSb290KHJvb3QpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBNb3JlIG1lYW5pbmdmdWwgbmFtZXMgZm9yIFwicmVuZGVyZXJJbnRlcmZhY2VzXCIgYW5kIFwicmVuZGVyZXJzXCIuXG5cblxuICB2YXIgZmliZXJSb290cyA9IHt9O1xuICB2YXIgcmVuZGVyZXJJbnRlcmZhY2VzID0gbmV3IE1hcCgpO1xuICB2YXIgbGlzdGVuZXJzID0ge307XG4gIHZhciByZW5kZXJlcnMgPSBuZXcgTWFwKCk7XG4gIHZhciBob29rID0ge1xuICAgIHJlbmRlcmVySW50ZXJmYWNlczogcmVuZGVyZXJJbnRlcmZhY2VzLFxuICAgIGxpc3RlbmVyczogbGlzdGVuZXJzLFxuICAgIC8vIEZhc3QgUmVmcmVzaCBmb3Igd2ViIHJlbGllcyBvbiB0aGlzLlxuICAgIHJlbmRlcmVyczogcmVuZGVyZXJzLFxuICAgIGVtaXQ6IGVtaXQsXG4gICAgZ2V0RmliZXJSb290czogZ2V0RmliZXJSb290cyxcbiAgICBpbmplY3Q6IGluamVjdCxcbiAgICBvbjogb24sXG4gICAgb2ZmOiBvZmYsXG4gICAgc3ViOiBzdWIsXG4gICAgLy8gVGhpcyBpcyBhIGxlZ2FjeSBmbGFnLlxuICAgIC8vIFJlYWN0IHYxNiBjaGVja3MgdGhlIGhvb2sgZm9yIHRoaXMgdG8gZW5zdXJlIERldlRvb2xzIGlzIG5ldyBlbm91Z2guXG4gICAgc3VwcG9ydHNGaWJlcjogdHJ1ZSxcbiAgICAvLyBSZWFjdCBjYWxscyB0aGVzZSBtZXRob2RzLlxuICAgIGNoZWNrRENFOiBjaGVja0RDRSxcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudDogb25Db21taXRGaWJlclVubW91bnQsXG4gICAgb25Db21taXRGaWJlclJvb3Q6IG9uQ29tbWl0RmliZXJSb290LFxuICAgIG9uUG9zdENvbW1pdEZpYmVyUm9vdDogb25Qb3N0Q29tbWl0RmliZXJSb290XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsICdfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18nLCB7XG4gICAgLy8gVGhpcyBwcm9wZXJ0eSBuZWVkcyB0byBiZSBjb25maWd1cmFibGUgZm9yIHRoZSB0ZXN0IGVudmlyb25tZW50LFxuICAgIC8vIGVsc2Ugd2Ugd29uJ3QgYmUgYWJsZSB0byBkZWxldGUgYW5kIHJlY3JlYXRlIGl0IGJldHdlZW4gdGVzdHMuXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBob29rO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBob29rO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2xlZ2FjeS91dGlscy5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuZnVuY3Rpb24gZGVjb3JhdGUob2JqZWN0LCBhdHRyLCBmbikge1xuICB2YXIgb2xkID0gb2JqZWN0W2F0dHJdO1xuXG4gIG9iamVjdFthdHRyXSA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIG9sZCwgYXJndW1lbnRzKTtcbiAgfTtcblxuICByZXR1cm4gb2xkO1xufVxuZnVuY3Rpb24gZGVjb3JhdGVNYW55KHNvdXJjZSwgZm5zKSB7XG4gIHZhciBvbGRzID0ge307XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBmbnMpIHtcbiAgICBvbGRzW25hbWVdID0gZGVjb3JhdGUoc291cmNlLCBuYW1lLCBmbnNbbmFtZV0pO1xuICB9XG5cbiAgcmV0dXJuIG9sZHM7XG59XG5mdW5jdGlvbiByZXN0b3JlTWFueShzb3VyY2UsIG9sZHMpIHtcbiAgZm9yICh2YXIgbmFtZSBpbiBvbGRzKSB7XG4gICAgc291cmNlW25hbWVdID0gb2xkc1tuYW1lXTtcbiAgfVxufVxuZnVuY3Rpb24gZm9yY2VVcGRhdGUoaW5zdGFuY2UpIHtcbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5mb3JjZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmZvcmNlVXBkYXRlKCk7XG4gIH0gZWxzZSBpZiAoaW5zdGFuY2UudXBkYXRlciAhPSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGZ1bmN0aW9uICgpIHt9LCAnZm9yY2VVcGRhdGUnKTtcbiAgfVxufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL2xlZ2FjeS9yZW5kZXJlci5qc1xuZnVuY3Rpb24gbGVnYWN5X3JlbmRlcmVyX293bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIGxlZ2FjeV9yZW5kZXJlcl9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgbGVnYWN5X3JlbmRlcmVyX293bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBsZWdhY3lfcmVuZGVyZXJfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgbGVnYWN5X3JlbmRlcmVyX293bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGxlZ2FjeV9yZW5kZXJlcl9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIGxlZ2FjeV9yZW5kZXJlcl90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IGxlZ2FjeV9yZW5kZXJlcl90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgbGVnYWN5X3JlbmRlcmVyX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBsZWdhY3lfcmVuZGVyZXJfdHlwZW9mKG9iaik7IH1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuXG5cblxuXG5mdW5jdGlvbiBnZXREYXRhKGludGVybmFsSW5zdGFuY2UpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gbnVsbDtcbiAgdmFyIGtleSA9IG51bGw7IC8vICE9IHVzZWQgZGVsaWJlcmF0ZWx5IGhlcmUgdG8gY2F0Y2ggdW5kZWZpbmVkIGFuZCBudWxsXG5cbiAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQua2V5KSB7XG4gICAgICBrZXkgPSAnJyArIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50LmtleTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudFR5cGUgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gZWxlbWVudFR5cGU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gZ2V0RGlzcGxheU5hbWUoZWxlbWVudFR5cGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgIGtleToga2V5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpIHtcbiAgLy8gIT0gdXNlZCBkZWxpYmVyYXRlbHkgaGVyZSB0byBjYXRjaCB1bmRlZmluZWQgYW5kIG51bGxcbiAgaWYgKGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50ICE9IG51bGwpIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHB1YmxpY0luc3RhbmNlID0gaW50ZXJuYWxJbnN0YW5jZS5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuXG4gICAgICBpZiAocHVibGljSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIEVsZW1lbnRUeXBlQ2xhc3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gRWxlbWVudFR5cGVGdW5jdGlvbjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBFbGVtZW50VHlwZUhvc3RDb21wb25lbnQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEVsZW1lbnRUeXBlT3RoZXJPclVua25vd247XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpIHtcbiAgdmFyIGNoaWxkcmVuID0gW107IC8vIElmIHRoZSBwYXJlbnQgaXMgYSBuYXRpdmUgbm9kZSB3aXRob3V0IHJlbmRlcmVkIGNoaWxkcmVuLCBidXQgd2l0aFxuICAvLyBtdWx0aXBsZSBzdHJpbmcgY2hpbGRyZW4sIHRoZW4gdGhlIGBlbGVtZW50YCB0aGF0IGdldHMgcGFzc2VkIGluIGhlcmUgaXNcbiAgLy8gYSBwbGFpbiB2YWx1ZSAtLSBhIHN0cmluZyBvciBudW1iZXIuXG5cbiAgaWYgKGxlZ2FjeV9yZW5kZXJlcl90eXBlb2YoaW50ZXJuYWxJbnN0YW5jZSkgIT09ICdvYmplY3QnKSB7Ly8gTm8gY2hpbGRyZW5cbiAgfSBlbHNlIGlmIChpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9PT0gbnVsbCB8fCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9PT0gZmFsc2UpIHsvLyBObyBjaGlsZHJlblxuICB9IGVsc2UgaWYgKGludGVybmFsSW5zdGFuY2UuX3JlbmRlcmVkQ29tcG9uZW50KSB7XG4gICAgdmFyIGNoaWxkID0gaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG5cbiAgICBpZiAoZ2V0RWxlbWVudFR5cGUoY2hpbGQpICE9PSBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDaGlsZHJlbikge1xuICAgIHZhciByZW5kZXJlZENoaWxkcmVuID0gaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDaGlsZHJlbjtcblxuICAgIGZvciAodmFyIG5hbWUgaW4gcmVuZGVyZWRDaGlsZHJlbikge1xuICAgICAgdmFyIF9jaGlsZCA9IHJlbmRlcmVkQ2hpbGRyZW5bbmFtZV07XG5cbiAgICAgIGlmIChnZXRFbGVtZW50VHlwZShfY2hpbGQpICE9PSBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duKSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goX2NoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gTm90ZTogd2Ugc2tpcCB0aGUgY2FzZSB3aGVyZSBjaGlsZHJlbiBhcmUganVzdCBzdHJpbmdzIG9yIG51bWJlcnNcbiAgLy8gYmVjYXVzZSB0aGUgbmV3IERldlRvb2xzIHNraXBzIG92ZXIgaG9zdCB0ZXh0IG5vZGVzIGFueXdheS5cblxuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gbGVnYWN5X3JlbmRlcmVyX2F0dGFjaChob29rLCByZW5kZXJlcklELCByZW5kZXJlciwgZ2xvYmFsKSB7XG4gIHZhciBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIGludGVybmFsSW5zdGFuY2VUb0lETWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgdmFyIGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBnZXRJbnRlcm5hbElERm9yTmF0aXZlID0gbnVsbDtcbiAgdmFyIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRDtcblxuICBpZiAocmVuZGVyZXIuQ29tcG9uZW50VHJlZSkge1xuICAgIGdldEludGVybmFsSURGb3JOYXRpdmUgPSBmdW5jdGlvbiBnZXRJbnRlcm5hbElERm9yTmF0aXZlKG5vZGUsIGZpbmROZWFyZXN0VW5maWx0ZXJlZEFuY2VzdG9yKSB7XG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHJlbmRlcmVyLkNvbXBvbmVudFRyZWUuZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSk7XG4gICAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZVRvSURNYXAuZ2V0KGludGVybmFsSW5zdGFuY2UpIHx8IG51bGw7XG4gICAgfTtcblxuICAgIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRCA9IGZ1bmN0aW9uIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCkge1xuICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBpZFRvSW50ZXJuYWxJbnN0YW5jZU1hcC5nZXQoaWQpO1xuICAgICAgcmV0dXJuIHJlbmRlcmVyLkNvbXBvbmVudFRyZWUuZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlbmRlcmVyLk1vdW50LmdldElEICYmIHJlbmRlcmVyLk1vdW50LmdldE5vZGUpIHtcbiAgICBnZXRJbnRlcm5hbElERm9yTmF0aXZlID0gZnVuY3Rpb24gZ2V0SW50ZXJuYWxJREZvck5hdGl2ZShub2RlLCBmaW5kTmVhcmVzdFVuZmlsdGVyZWRBbmNlc3Rvcikge1xuICAgICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRCA9IGZ1bmN0aW9uIGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCkge1xuICAgICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERpc3BsYXlOYW1lRm9yRmliZXJJRChpZCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcbiAgICByZXR1cm4gaW50ZXJuYWxJbnN0YW5jZSA/IGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSkuZGlzcGxheU5hbWUgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChsZWdhY3lfcmVuZGVyZXJfdHlwZW9mKGludGVybmFsSW5zdGFuY2UpICE9PSAnb2JqZWN0JyB8fCBpbnRlcm5hbEluc3RhbmNlID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW50ZXJuYWwgaW5zdGFuY2U6ICcgKyBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2VUb0lETWFwLmhhcyhpbnRlcm5hbEluc3RhbmNlKSkge1xuICAgICAgdmFyIF9pZCA9IGdldFVJRCgpO1xuXG4gICAgICBpbnRlcm5hbEluc3RhbmNlVG9JRE1hcC5zZXQoaW50ZXJuYWxJbnN0YW5jZSwgX2lkKTtcbiAgICAgIGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLnNldChfaWQsIGludGVybmFsSW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcm5hbEluc3RhbmNlVG9JRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBhcmVFcXVhbEFycmF5cyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFRoaXMgaXMgc2hhcmVkIG11dGFibGUgc3RhdGUgdGhhdCBsZXRzIHVzIGtlZXAgdHJhY2sgb2Ygd2hlcmUgd2UgYXJlLlxuXG5cbiAgdmFyIHBhcmVudElEU3RhY2sgPSBbXTtcbiAgdmFyIG9sZFJlY29uY2lsZXJNZXRob2RzID0gbnVsbDtcblxuICBpZiAocmVuZGVyZXIuUmVjb25jaWxlcikge1xuICAgIC8vIFJlYWN0IDE1XG4gICAgb2xkUmVjb25jaWxlck1ldGhvZHMgPSBkZWNvcmF0ZU1hbnkocmVuZGVyZXIuUmVjb25jaWxlciwge1xuICAgICAgbW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIG1vdW50Q29tcG9uZW50KGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGhvc3RDb250YWluZXJJbmZvID0gYXJnc1szXTtcblxuICAgICAgICBpZiAoZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSkgPT09IEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24pIHtcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaG9zdENvbnRhaW5lckluZm8uX3RvcExldmVsV3JhcHBlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gU1NSXG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSk7IC8vIFB1c2ggdGhlIG9wZXJhdGlvbi5cblxuICAgICAgICB2YXIgcGFyZW50SUQgPSBwYXJlbnRJRFN0YWNrLmxlbmd0aCA+IDAgPyBwYXJlbnRJRFN0YWNrW3BhcmVudElEU3RhY2subGVuZ3RoIC0gMV0gOiAwO1xuICAgICAgICByZWNvcmRNb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCwgcGFyZW50SUQpO1xuICAgICAgICBwYXJlbnRJRFN0YWNrLnB1c2goaWQpOyAvLyBSZW1lbWJlciB0aGUgcm9vdC5cblxuICAgICAgICBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuc2V0KGludGVybmFsSW5zdGFuY2UsIGdldElEKGhvc3RDb250YWluZXJJbmZvLl90b3BMZXZlbFdyYXBwZXIpKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHBhcmVudElEU3RhY2sgPSBbXTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHBhcmVudElEU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdElEID0gaW50ZXJuYWxJbnN0YW5jZVRvUm9vdElETWFwLmdldChpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgICAgICAgaWYgKHJvb3RJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCByb290IElELicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShmbiwgYXJncykge1xuICAgICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGFyZ3NbMF07XG5cbiAgICAgICAgaWYgKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpID09PSBFbGVtZW50VHlwZU90aGVyT3JVbmtub3duKSB7XG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGlkID0gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgICAgIHBhcmVudElEU3RhY2sucHVzaChpZCk7XG4gICAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSBnZXRDaGlsZHJlbihpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICB2YXIgbmV4dENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgICBpZiAoIWFyZUVxdWFsQXJyYXlzKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuKSkge1xuICAgICAgICAgICAgLy8gUHVzaCB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAgICByZWNvcmRSZW9yZGVyKGludGVybmFsSW5zdGFuY2UsIGlkLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudElEU3RhY2sucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcGFyZW50SURTdGFjayA9IFtdO1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAocGFyZW50SURTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHZhciByb290SUQgPSBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuZ2V0KGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAocm9vdElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHJvb3QgSUQuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhyb290SUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIHJlY2VpdmVDb21wb25lbnQoZm4sIGFyZ3MpIHtcbiAgICAgICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBhcmdzWzBdO1xuXG4gICAgICAgIGlmIChnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKSA9PT0gRWxlbWVudFR5cGVPdGhlck9yVW5rbm93bikge1xuICAgICAgICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpZCA9IGdldElEKGludGVybmFsSW5zdGFuY2UpO1xuICAgICAgICBwYXJlbnRJRFN0YWNrLnB1c2goaWQpO1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gZ2V0Q2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IGdldENoaWxkcmVuKGludGVybmFsSW5zdGFuY2UpO1xuXG4gICAgICAgICAgaWYgKCFhcmVFcXVhbEFycmF5cyhwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbikpIHtcbiAgICAgICAgICAgIC8vIFB1c2ggdGhlIG9wZXJhdGlvblxuICAgICAgICAgICAgcmVjb3JkUmVvcmRlcihpbnRlcm5hbEluc3RhbmNlLCBpZCwgbmV4dENoaWxkcmVuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHBhcmVudElEU3RhY2sgPSBbXTtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKHBhcmVudElEU3RhY2subGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcm9vdElEID0gaW50ZXJuYWxJbnN0YW5jZVRvUm9vdElETWFwLmdldChpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgICAgICAgaWYgKHJvb3RJRCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCByb290IElELicpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiB1bm1vdW50Q29tcG9uZW50KGZuLCBhcmdzKSB7XG4gICAgICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gYXJnc1swXTtcblxuICAgICAgICBpZiAoZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSkgPT09IEVsZW1lbnRUeXBlT3RoZXJPclVua25vd24pIHtcbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaWQgPSBnZXRJRChpbnRlcm5hbEluc3RhbmNlKTtcbiAgICAgICAgcGFyZW50SURTdGFjay5wdXNoKGlkKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrLnBvcCgpOyAvLyBQdXNoIHRoZSBvcGVyYXRpb24uXG5cbiAgICAgICAgICByZWNvcmRVbm1vdW50KGludGVybmFsSW5zdGFuY2UsIGlkKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBwYXJlbnRJRFN0YWNrID0gW107XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChwYXJlbnRJRFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHJvb3RJRCA9IGludGVybmFsSW5zdGFuY2VUb1Jvb3RJRE1hcC5nZXQoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChyb290SUQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgcm9vdCBJRC4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmx1c2hQZW5kaW5nRXZlbnRzKHJvb3RJRCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGlmIChvbGRSZWNvbmNpbGVyTWV0aG9kcyAhPT0gbnVsbCkge1xuICAgICAgaWYgKHJlbmRlcmVyLkNvbXBvbmVudCkge1xuICAgICAgICByZXN0b3JlTWFueShyZW5kZXJlci5Db21wb25lbnQuTWl4aW4sIG9sZFJlY29uY2lsZXJNZXRob2RzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3RvcmVNYW55KHJlbmRlcmVyLlJlY29uY2lsZXIsIG9sZFJlY29uY2lsZXJNZXRob2RzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBvbGRSZWNvbmNpbGVyTWV0aG9kcyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvcmRNb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCwgcGFyZW50SUQpIHtcbiAgICB2YXIgaXNSb290ID0gcGFyZW50SUQgPT09IDA7XG5cbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBjb25zb2xlLmxvZygnJWNyZWNvcmRNb3VudCgpJywgJ2NvbG9yOiBncmVlbjsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgaWQsIGdldERhdGEoaW50ZXJuYWxJbnN0YW5jZSkuZGlzcGxheU5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpc1Jvb3QpIHtcbiAgICAgIC8vIFRPRE8gSXMgdGhpcyByaWdodD8gRm9yIGFsbCB2ZXJzaW9ucz9cbiAgICAgIHZhciBoYXNPd25lck1ldGFkYXRhID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgIT0gbnVsbCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgIT0gbnVsbDtcbiAgICAgIHB1c2hPcGVyYXRpb24oVFJFRV9PUEVSQVRJT05fQUREKTtcbiAgICAgIHB1c2hPcGVyYXRpb24oaWQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihFbGVtZW50VHlwZVJvb3QpO1xuICAgICAgcHVzaE9wZXJhdGlvbigwKTsgLy8gaXNQcm9maWxpbmdTdXBwb3J0ZWQ/XG5cbiAgICAgIHB1c2hPcGVyYXRpb24oaGFzT3duZXJNZXRhZGF0YSA/IDEgOiAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSBnZXRFbGVtZW50VHlwZShpbnRlcm5hbEluc3RhbmNlKTtcblxuICAgICAgdmFyIF9nZXREYXRhID0gZ2V0RGF0YShpbnRlcm5hbEluc3RhbmNlKSxcbiAgICAgICAgICBkaXNwbGF5TmFtZSA9IF9nZXREYXRhLmRpc3BsYXlOYW1lLFxuICAgICAgICAgIGtleSA9IF9nZXREYXRhLmtleTtcblxuICAgICAgdmFyIG93bmVySUQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAhPSBudWxsICYmIGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50Ll9vd25lciAhPSBudWxsID8gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKSA6IDA7XG4gICAgICB2YXIgZGlzcGxheU5hbWVTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGRpc3BsYXlOYW1lKTtcbiAgICAgIHZhciBrZXlTdHJpbmdJRCA9IGdldFN0cmluZ0lEKGtleSk7XG4gICAgICBwdXNoT3BlcmF0aW9uKFRSRUVfT1BFUkFUSU9OX0FERCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICAgIHB1c2hPcGVyYXRpb24odHlwZSk7XG4gICAgICBwdXNoT3BlcmF0aW9uKHBhcmVudElEKTtcbiAgICAgIHB1c2hPcGVyYXRpb24ob3duZXJJRCk7XG4gICAgICBwdXNoT3BlcmF0aW9uKGRpc3BsYXlOYW1lU3RyaW5nSUQpO1xuICAgICAgcHVzaE9wZXJhdGlvbihrZXlTdHJpbmdJRCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkUmVvcmRlcihpbnRlcm5hbEluc3RhbmNlLCBpZCwgbmV4dENoaWxkcmVuKSB7XG4gICAgcHVzaE9wZXJhdGlvbihUUkVFX09QRVJBVElPTl9SRU9SREVSX0NISUxEUkVOKTtcbiAgICBwdXNoT3BlcmF0aW9uKGlkKTtcbiAgICB2YXIgbmV4dENoaWxkSURzID0gbmV4dENoaWxkcmVuLm1hcChnZXRJRCk7XG4gICAgcHVzaE9wZXJhdGlvbihuZXh0Q2hpbGRJRHMubGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV4dENoaWxkSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwdXNoT3BlcmF0aW9uKG5leHRDaGlsZElEc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb3JkVW5tb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCkge1xuICAgIHBlbmRpbmdVbm1vdW50ZWRJRHMucHVzaChpZCk7XG4gICAgaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZGVsZXRlKGlkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cyhpZCwgcGFyZW50SUQsIHJvb3RJRCkge1xuICAgIGlmIChfX0RFQlVHX18pIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXAoJ2NyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cygpIGlkOicsIGlkKTtcbiAgICB9XG5cbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICBpbnRlcm5hbEluc3RhbmNlVG9Sb290SURNYXAuc2V0KGludGVybmFsSW5zdGFuY2UsIHJvb3RJRCk7XG4gICAgICByZWNvcmRNb3VudChpbnRlcm5hbEluc3RhbmNlLCBpZCwgcGFyZW50SUQpO1xuICAgICAgZ2V0Q2hpbGRyZW4oaW50ZXJuYWxJbnN0YW5jZSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGNyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cyhnZXRJRChjaGlsZCksIGlkLCByb290SUQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMoKSB7XG4gICAgLy8gQ3Jhd2wgcm9vdHMgdGhvdWdoIGFuZCByZWdpc3RlciBhbnkgbm9kZXMgdGhhdCBtb3VudGVkIGJlZm9yZSB3ZSB3ZXJlIGluamVjdGVkLlxuICAgIHZhciByb290cyA9IHJlbmRlcmVyLk1vdW50Ll9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIHx8IHJlbmRlcmVyLk1vdW50Ll9pbnN0YW5jZXNCeUNvbnRhaW5lcklEO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHJvb3RzKSB7XG4gICAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IHJvb3RzW2tleV07XG5cbiAgICAgIHZhciBfaWQyID0gZ2V0SUQoaW50ZXJuYWxJbnN0YW5jZSk7XG5cbiAgICAgIGNyYXdsQW5kUmVjb3JkSW5pdGlhbE1vdW50cyhfaWQyLCAwLCBfaWQyKTtcbiAgICAgIGZsdXNoUGVuZGluZ0V2ZW50cyhfaWQyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ09wZXJhdGlvbnMgPSBbXTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZSA9IG5ldyBNYXAoKTtcbiAgdmFyIHBlbmRpbmdVbm1vdW50ZWRJRHMgPSBbXTtcbiAgdmFyIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIHZhciBwZW5kaW5nVW5tb3VudGVkUm9vdElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBmbHVzaFBlbmRpbmdFdmVudHMocm9vdElEKSB7XG4gICAgaWYgKHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCA9PT0gMCAmJiBwZW5kaW5nVW5tb3VudGVkSURzLmxlbmd0aCA9PT0gMCAmJiBwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG51bVVubW91bnRJRHMgPSBwZW5kaW5nVW5tb3VudGVkSURzLmxlbmd0aCArIChwZW5kaW5nVW5tb3VudGVkUm9vdElEID09PSBudWxsID8gMCA6IDEpO1xuICAgIHZhciBvcGVyYXRpb25zID0gbmV3IEFycmF5KCAvLyBJZGVudGlmeSB3aGljaCByZW5kZXJlciB0aGlzIHVwZGF0ZSBpcyBjb21pbmcgZnJvbS5cbiAgICAyICsgLy8gW3JlbmRlcmVySUQsIHJvb3RGaWJlcklEXVxuICAgIC8vIEhvdyBiaWcgaXMgdGhlIHN0cmluZyB0YWJsZT9cbiAgICAxICsgLy8gW3N0cmluZ1RhYmxlTGVuZ3RoXVxuICAgIC8vIFRoZW4gZ29lcyB0aGUgYWN0dWFsIHN0cmluZyB0YWJsZS5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKyAoIC8vIEFsbCB1bm1vdW50cyBhcmUgYmF0Y2hlZCBpbiBhIHNpbmdsZSBtZXNzYWdlLlxuICAgIC8vIFtUUkVFX09QRVJBVElPTl9SRU1PVkUsIHJlbW92ZWRJRExlbmd0aCwgLi4uaWRzXVxuICAgIG51bVVubW91bnRJRHMgPiAwID8gMiArIG51bVVubW91bnRJRHMgOiAwKSArIC8vIE1vdW50IG9wZXJhdGlvbnNcbiAgICBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGgpOyAvLyBJZGVudGlmeSB3aGljaCByZW5kZXJlciB0aGlzIHVwZGF0ZSBpcyBjb21pbmcgZnJvbS5cbiAgICAvLyBUaGlzIGVuYWJsZXMgcm9vdHMgdG8gYmUgbWFwcGVkIHRvIHJlbmRlcmVycyxcbiAgICAvLyBXaGljaCBpbiB0dXJuIGVuYWJsZXMgZmliZXIgcHJvcGVyYXRpb25zLCBzdGF0ZXMsIGFuZCBob29rcyB0byBiZSBpbnNwZWN0ZWQuXG5cbiAgICB2YXIgaSA9IDA7XG4gICAgb3BlcmF0aW9uc1tpKytdID0gcmVuZGVyZXJJRDtcbiAgICBvcGVyYXRpb25zW2krK10gPSByb290SUQ7IC8vIE5vdyBmaWxsIGluIHRoZSBzdHJpbmcgdGFibGUuXG4gICAgLy8gW3N0cmluZ1RhYmxlTGVuZ3RoLCBzdHIxTGVuZ3RoLCAuLi5zdHIxLCBzdHIyTGVuZ3RoLCAuLi5zdHIyLCAuLi5dXG5cbiAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGg7XG4gICAgcGVuZGluZ1N0cmluZ1RhYmxlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IGtleS5sZW5ndGg7XG4gICAgICB2YXIgZW5jb2RlZEtleSA9IHV0ZkVuY29kZVN0cmluZyhrZXkpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGVuY29kZWRLZXkubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgb3BlcmF0aW9uc1tpICsgal0gPSBlbmNvZGVkS2V5W2pdO1xuICAgICAgfVxuXG4gICAgICBpICs9IGtleS5sZW5ndGg7XG4gICAgfSk7XG5cbiAgICBpZiAobnVtVW5tb3VudElEcyA+IDApIHtcbiAgICAgIC8vIEFsbCB1bm1vdW50cyBleGNlcHQgcm9vdHMgYXJlIGJhdGNoZWQgaW4gYSBzaW5nbGUgbWVzc2FnZS5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IFRSRUVfT1BFUkFUSU9OX1JFTU9WRTsgLy8gVGhlIGZpcnN0IG51bWJlciBpcyBob3cgbWFueSB1bm1vdW50ZWQgSURzIHdlJ3JlIGdvbm5hIHNlbmQuXG5cbiAgICAgIG9wZXJhdGlvbnNbaSsrXSA9IG51bVVubW91bnRJRHM7IC8vIEZpbGwgaW4gdGhlIHVubW91bnRzXG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGVuZGluZ1VubW91bnRlZElEcy5sZW5ndGg7IGorKykge1xuICAgICAgICBvcGVyYXRpb25zW2krK10gPSBwZW5kaW5nVW5tb3VudGVkSURzW2pdO1xuICAgICAgfSAvLyBUaGUgcm9vdCBJRCBzaG91bGQgYWx3YXlzIGJlIHVubW91bnRlZCBsYXN0LlxuXG5cbiAgICAgIGlmIChwZW5kaW5nVW5tb3VudGVkUm9vdElEICE9PSBudWxsKSB7XG4gICAgICAgIG9wZXJhdGlvbnNbaV0gPSBwZW5kaW5nVW5tb3VudGVkUm9vdElEO1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfSAvLyBGaWxsIGluIHRoZSByZXN0IG9mIHRoZSBvcGVyYXRpb25zLlxuXG5cbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgcGVuZGluZ09wZXJhdGlvbnMubGVuZ3RoOyBfaisrKSB7XG4gICAgICBvcGVyYXRpb25zW2kgKyBfal0gPSBwZW5kaW5nT3BlcmF0aW9uc1tfal07XG4gICAgfVxuXG4gICAgaSArPSBwZW5kaW5nT3BlcmF0aW9ucy5sZW5ndGg7XG5cbiAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICBwcmludE9wZXJhdGlvbnNBcnJheShvcGVyYXRpb25zKTtcbiAgICB9IC8vIElmIHdlJ3ZlIGFscmVhZHkgY29ubmVjdGVkIHRvIHRoZSBmcm9udGVuZCwganVzdCBwYXNzIHRoZSBvcGVyYXRpb25zIHRocm91Z2guXG5cblxuICAgIGhvb2suZW1pdCgnb3BlcmF0aW9ucycsIG9wZXJhdGlvbnMpO1xuICAgIHBlbmRpbmdPcGVyYXRpb25zLmxlbmd0aCA9IDA7XG4gICAgcGVuZGluZ1VubW91bnRlZElEcyA9IFtdO1xuICAgIHBlbmRpbmdVbm1vdW50ZWRSb290SUQgPSBudWxsO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZS5jbGVhcigpO1xuICAgIHBlbmRpbmdTdHJpbmdUYWJsZUxlbmd0aCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoT3BlcmF0aW9uKG9wKSB7XG4gICAgaWYgKGZhbHNlKSB7fVxuXG4gICAgcGVuZGluZ09wZXJhdGlvbnMucHVzaChvcCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdHJpbmdJRChzdHIpIHtcbiAgICBpZiAoc3RyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIgZXhpc3RpbmdJRCA9IHBlbmRpbmdTdHJpbmdUYWJsZS5nZXQoc3RyKTtcblxuICAgIGlmIChleGlzdGluZ0lEICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ0lEO1xuICAgIH1cblxuICAgIHZhciBzdHJpbmdJRCA9IHBlbmRpbmdTdHJpbmdUYWJsZS5zaXplICsgMTtcbiAgICBwZW5kaW5nU3RyaW5nVGFibGUuc2V0KHN0ciwgc3RyaW5nSUQpOyAvLyBUaGUgc3RyaW5nIHRhYmxlIHRvdGFsIGxlbmd0aCBuZWVkcyB0byBhY2NvdW50XG4gICAgLy8gYm90aCBmb3IgdGhlIHN0cmluZyBsZW5ndGgsIGFuZCBmb3IgdGhlIGFycmF5IGl0ZW1cbiAgICAvLyB0aGF0IGNvbnRhaW5zIHRoZSBsZW5ndGggaXRzZWxmLiBIZW5jZSArIDEuXG5cbiAgICBwZW5kaW5nU3RyaW5nVGFibGVMZW5ndGggKz0gc3RyLmxlbmd0aCArIDE7XG4gICAgcmV0dXJuIHN0cmluZ0lEO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRseUluc3BlY3RlZEVsZW1lbnRJRCA9IG51bGw7XG4gIHZhciBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9OyAvLyBUcmFjayB0aGUgaW50ZXJzZWN0aW9uIG9mIGN1cnJlbnRseSBpbnNwZWN0ZWQgcGF0aHMsXG4gIC8vIHNvIHRoYXQgd2UgY2FuIHNlbmQgdGhlaXIgZGF0YSBhbG9uZyBpZiB0aGUgZWxlbWVudCBpcyByZS1yZW5kZXJlZC5cblxuICBmdW5jdGlvbiBtZXJnZUluc3BlY3RlZFBhdGhzKHBhdGgpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzO1xuICAgIHBhdGguZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoIWN1cnJlbnRba2V5XSkge1xuICAgICAgICBjdXJyZW50W2tleV0gPSB7fTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IGN1cnJlbnRba2V5XTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUlzUGF0aEFsbG93ZWQoa2V5KSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoZWxwcyBwcmV2ZW50IHByZXZpb3VzbHktaW5zcGVjdGVkIHBhdGhzIGZyb20gYmVpbmcgZGVoeWRyYXRlZCBpbiB1cGRhdGVzLlxuICAgIC8vIFRoaXMgaXMgaW1wb3J0YW50IHRvIGF2b2lkIGEgYmFkIHVzZXIgZXhwZXJpZW5jZSB3aGVyZSBleHBhbmRlZCB0b2dnbGVzIGNvbGxhcHNlIG9uIHVwZGF0ZS5cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNQYXRoQWxsb3dlZChwYXRoKSB7XG4gICAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseUluc3BlY3RlZFBhdGhzW2tleV07XG5cbiAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJyZW50ID0gY3VycmVudFtwYXRoW2ldXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgfSAvLyBGYXN0IHBhdGggcHJvcHMgbG9va3VwIGZvciBSZWFjdCBOYXRpdmUgc3R5bGUgZWRpdG9yLlxuXG5cbiAgZnVuY3Rpb24gZ2V0SW5zdGFuY2VBbmRTdHlsZShpZCkge1xuICAgIHZhciBpbnN0YW5jZSA9IG51bGw7XG4gICAgdmFyIHN0eWxlID0gbnVsbDtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICBpbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlIHx8IG51bGw7XG4gICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgICBpZiAoZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQucHJvcHMgIT0gbnVsbCkge1xuICAgICAgICBzdHlsZSA9IGVsZW1lbnQucHJvcHMuc3R5bGUgfHwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgc3R5bGU6IHN0eWxlXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGVkRWxlbWVudChpZCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGluc3RhbmNlIHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGdldEVsZW1lbnRUeXBlKGludGVybmFsSW5zdGFuY2UpKSB7XG4gICAgICBjYXNlIEVsZW1lbnRUeXBlQ2xhc3M6XG4gICAgICAgIGdsb2JhbC4kciA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBFbGVtZW50VHlwZUZ1bmN0aW9uOlxuICAgICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnbG9iYWwuJHIgPSB7XG4gICAgICAgICAgcHJvcHM6IGVsZW1lbnQucHJvcHMsXG4gICAgICAgICAgdHlwZTogZWxlbWVudC50eXBlXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBnbG9iYWwuJHIgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzdG9yZUFzR2xvYmFsKGlkLCBwYXRoLCBjb3VudCkge1xuICAgIHZhciBpbnNwZWN0ZWRFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnRSYXcoaWQpO1xuXG4gICAgaWYgKGluc3BlY3RlZEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldEluT2JqZWN0KGluc3BlY3RlZEVsZW1lbnQsIHBhdGgpO1xuICAgICAgdmFyIGtleSA9IFwiJHJlYWN0VGVtcFwiLmNvbmNhdChjb3VudCk7XG4gICAgICB3aW5kb3dba2V5XSA9IHZhbHVlO1xuICAgICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5RWxlbWVudFBhdGgoaWQsIHBhdGgpIHtcbiAgICB2YXIgaW5zcGVjdGVkRWxlbWVudCA9IGluc3BlY3RFbGVtZW50UmF3KGlkKTtcblxuICAgIGlmIChpbnNwZWN0ZWRFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICBjb3B5VG9DbGlwYm9hcmQoZ2V0SW5PYmplY3QoaW5zcGVjdGVkRWxlbWVudCwgcGF0aCkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3RFbGVtZW50KHJlcXVlc3RJRCwgaWQsIHBhdGgpIHtcbiAgICBpZiAoY3VycmVudGx5SW5zcGVjdGVkRWxlbWVudElEICE9PSBpZCkge1xuICAgICAgY3VycmVudGx5SW5zcGVjdGVkRWxlbWVudElEID0gaWQ7XG4gICAgICBjdXJyZW50bHlJbnNwZWN0ZWRQYXRocyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBpbnNwZWN0ZWRFbGVtZW50ID0gaW5zcGVjdEVsZW1lbnRSYXcoaWQpO1xuXG4gICAgaWYgKGluc3BlY3RlZEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgICB0eXBlOiAnbm90LWZvdW5kJ1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAocGF0aCAhPT0gbnVsbCkge1xuICAgICAgbWVyZ2VJbnNwZWN0ZWRQYXRocyhwYXRoKTtcbiAgICB9IC8vIEFueSB0aW1lIGFuIGluc3BlY3RlZCBlbGVtZW50IGhhcyBhbiB1cGRhdGUsXG4gICAgLy8gd2Ugc2hvdWxkIHVwZGF0ZSB0aGUgc2VsZWN0ZWQgJHIgdmFsdWUgYXMgd2VsLlxuICAgIC8vIERvIHRoaXMgYmVmb3JlIGRlaHlyYXRpb24gKGNsZWFuRm9yQnJpZGdlKS5cblxuXG4gICAgdXBkYXRlU2VsZWN0ZWRFbGVtZW50KGlkKTtcbiAgICBpbnNwZWN0ZWRFbGVtZW50LmNvbnRleHQgPSBjbGVhbkZvckJyaWRnZShpbnNwZWN0ZWRFbGVtZW50LmNvbnRleHQsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ2NvbnRleHQnKSk7XG4gICAgaW5zcGVjdGVkRWxlbWVudC5wcm9wcyA9IGNsZWFuRm9yQnJpZGdlKGluc3BlY3RlZEVsZW1lbnQucHJvcHMsIGNyZWF0ZUlzUGF0aEFsbG93ZWQoJ3Byb3BzJykpO1xuICAgIGluc3BlY3RlZEVsZW1lbnQuc3RhdGUgPSBjbGVhbkZvckJyaWRnZShpbnNwZWN0ZWRFbGVtZW50LnN0YXRlLCBjcmVhdGVJc1BhdGhBbGxvd2VkKCdzdGF0ZScpKTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgcmVzcG9uc2VJRDogcmVxdWVzdElELFxuICAgICAgdHlwZTogJ2Z1bGwtZGF0YScsXG4gICAgICB2YWx1ZTogaW5zcGVjdGVkRWxlbWVudFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpbnNwZWN0RWxlbWVudFJhdyhpZCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBfZ2V0RGF0YTIgPSBnZXREYXRhKGludGVybmFsSW5zdGFuY2UpLFxuICAgICAgICBkaXNwbGF5TmFtZSA9IF9nZXREYXRhMi5kaXNwbGF5TmFtZSxcbiAgICAgICAga2V5ID0gX2dldERhdGEyLmtleTtcblxuICAgIHZhciB0eXBlID0gZ2V0RWxlbWVudFR5cGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgdmFyIGNvbnRleHQgPSBudWxsO1xuICAgIHZhciBvd25lcnMgPSBudWxsO1xuICAgIHZhciBwcm9wcyA9IG51bGw7XG4gICAgdmFyIHN0YXRlID0gbnVsbDtcbiAgICB2YXIgc291cmNlID0gbnVsbDtcbiAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHByb3BzID0gZWxlbWVudC5wcm9wcztcbiAgICAgIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZSAhPSBudWxsID8gZWxlbWVudC5fc291cmNlIDogbnVsbDtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgb3duZXJzID0gW107XG5cbiAgICAgICAgd2hpbGUgKG93bmVyICE9IG51bGwpIHtcbiAgICAgICAgICBvd25lcnMucHVzaCh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogZ2V0RGF0YShvd25lcikuZGlzcGxheU5hbWUgfHwgJ1Vua25vd24nLFxuICAgICAgICAgICAgaWQ6IGdldElEKG93bmVyKSxcbiAgICAgICAgICAgIGtleTogZWxlbWVudC5rZXksXG4gICAgICAgICAgICB0eXBlOiBnZXRFbGVtZW50VHlwZShvd25lcilcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmIChvd25lci5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIG93bmVyID0gb3duZXIuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHVibGljSW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZTtcblxuICAgIGlmIChwdWJsaWNJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICBjb250ZXh0ID0gcHVibGljSW5zdGFuY2UuY29udGV4dCB8fCBudWxsO1xuICAgICAgc3RhdGUgPSBwdWJsaWNJbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuICAgIH0gLy8gTm90IGltcGxlbWVudGVkXG5cblxuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICB2YXIgd2FybmluZ3MgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgLy8gRG9lcyB0aGUgY3VycmVudCByZW5kZXJlciBzdXBwb3J0IGVkaXRhYmxlIGhvb2tzIGFuZCBmdW5jdGlvbiBwcm9wcz9cbiAgICAgIGNhbkVkaXRIb29rczogZmFsc2UsXG4gICAgICBjYW5FZGl0RnVuY3Rpb25Qcm9wczogZmFsc2UsXG4gICAgICAvLyBEb2VzIHRoZSBjdXJyZW50IHJlbmRlcmVyIHN1cHBvcnQgYWR2YW5jZWQgZWRpdGluZyBpbnRlcmZhY2U/XG4gICAgICBjYW5FZGl0SG9va3NBbmREZWxldGVQYXRoczogZmFsc2UsXG4gICAgICBjYW5FZGl0SG9va3NBbmRSZW5hbWVQYXRoczogZmFsc2UsXG4gICAgICBjYW5FZGl0RnVuY3Rpb25Qcm9wc0RlbGV0ZVBhdGhzOiBmYWxzZSxcbiAgICAgIGNhbkVkaXRGdW5jdGlvblByb3BzUmVuYW1lUGF0aHM6IGZhbHNlLFxuICAgICAgLy8gVG9nZ2xlIGVycm9yIGJvdW5kYXJ5IGRpZCBub3QgZXhpc3QgaW4gbGVnYWN5IHZlcnNpb25zXG4gICAgICBjYW5Ub2dnbGVFcnJvcjogZmFsc2UsXG4gICAgICBpc0Vycm9yZWQ6IGZhbHNlLFxuICAgICAgdGFyZ2V0RXJyb3JCb3VuZGFyeUlEOiBudWxsLFxuICAgICAgLy8gU3VzcGVuc2UgZGlkIG5vdCBleGlzdCBpbiBsZWdhY3kgdmVyc2lvbnNcbiAgICAgIGNhblRvZ2dsZVN1c3BlbnNlOiBmYWxzZSxcbiAgICAgIC8vIENhbiB2aWV3IGNvbXBvbmVudCBzb3VyY2UgbG9jYXRpb24uXG4gICAgICBjYW5WaWV3U291cmNlOiB0eXBlID09PSBFbGVtZW50VHlwZUNsYXNzIHx8IHR5cGUgPT09IEVsZW1lbnRUeXBlRnVuY3Rpb24sXG4gICAgICAvLyBPbmx5IGxlZ2FjeSBjb250ZXh0IGV4aXN0cyBpbiBsZWdhY3kgdmVyc2lvbnMuXG4gICAgICBoYXNMZWdhY3lDb250ZXh0OiB0cnVlLFxuICAgICAgZGlzcGxheU5hbWU6IGRpc3BsYXlOYW1lLFxuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGtleToga2V5ICE9IG51bGwgPyBrZXkgOiBudWxsLFxuICAgICAgLy8gSW5zcGVjdGFibGUgcHJvcGVydGllcy5cbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBob29rczogbnVsbCxcbiAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIGVycm9yczogZXJyb3JzLFxuICAgICAgd2FybmluZ3M6IHdhcm5pbmdzLFxuICAgICAgLy8gTGlzdCBvZiBvd25lcnNcbiAgICAgIG93bmVyczogb3duZXJzLFxuICAgICAgLy8gTG9jYXRpb24gb2YgY29tcG9uZW50IGluIHNvdXJjZSBjb2RlLlxuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICByb290VHlwZTogbnVsbCxcbiAgICAgIHJlbmRlcmVyUGFja2FnZU5hbWU6IG51bGwsXG4gICAgICByZW5kZXJlclZlcnNpb246IG51bGxcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbG9nRWxlbWVudFRvQ29uc29sZShpZCkge1xuICAgIHZhciByZXN1bHQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBlbGVtZW50IHdpdGggaWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3VwcG9ydHNHcm91cCA9IHR5cGVvZiBjb25zb2xlLmdyb3VwQ29sbGFwc2VkID09PSAnZnVuY3Rpb24nO1xuXG4gICAgaWYgKHN1cHBvcnRzR3JvdXApIHtcbiAgICAgIGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQoXCJbQ2xpY2sgdG8gZXhwYW5kXSAlYzxcIi5jb25jYXQocmVzdWx0LmRpc3BsYXlOYW1lIHx8ICdDb21wb25lbnQnLCBcIiAvPlwiKSwgLy8gLS1kb20tdGFnLW5hbWUtY29sb3IgaXMgdGhlIENTUyB2YXJpYWJsZSBDaHJvbWUgc3R5bGVzIEhUTUwgZWxlbWVudHMgd2l0aCBpbiB0aGUgY29uc29sZS5cbiAgICAgICdjb2xvcjogdmFyKC0tZG9tLXRhZy1uYW1lLWNvbG9yKTsgZm9udC13ZWlnaHQ6IG5vcm1hbDsnKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnByb3BzICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnUHJvcHM6JywgcmVzdWx0LnByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LnN0YXRlICE9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmxvZygnU3RhdGU6JywgcmVzdWx0LnN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAocmVzdWx0LmNvbnRleHQgIT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdDb250ZXh0OicsIHJlc3VsdC5jb250ZXh0KTtcbiAgICB9XG5cbiAgICB2YXIgbmF0aXZlTm9kZSA9IGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCk7XG5cbiAgICBpZiAobmF0aXZlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc29sZS5sb2coJ05vZGU6JywgbmF0aXZlTm9kZSk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5jaHJvbWUgfHwgL2ZpcmVmb3gvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICBjb25zb2xlLmxvZygnUmlnaHQtY2xpY2sgYW55IHZhbHVlIHRvIHNhdmUgaXQgYXMgYSBnbG9iYWwgdmFyaWFibGUgZm9yIGZ1cnRoZXIgaW5zcGVjdGlvbi4nKTtcbiAgICB9XG5cbiAgICBpZiAoc3VwcG9ydHNHcm91cCkge1xuICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlKGlkLCBwYXRoKSB7XG4gICAgdmFyIGluc3BlY3RlZEVsZW1lbnQgPSBpbnNwZWN0RWxlbWVudFJhdyhpZCk7XG5cbiAgICBpZiAoaW5zcGVjdGVkRWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgd2luZG93LiRhdHRyaWJ1dGUgPSBnZXRJbk9iamVjdChpbnNwZWN0ZWRFbGVtZW50LCBwYXRoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVmlld0VsZW1lbnRTb3VyY2UoaWQpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZmluZCBpbnN0YW5jZSB3aXRoIGlkIFxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGVsZW1lbnQgd2l0aCBpZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCJcIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbC4kdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuXG4gICAgICBpZiAocHVibGljSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAgIGRlbGV0ZVBhdGhJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5jb250ZXh0LCBwYXRoKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcblxuICAgICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9IGxlZ2FjeV9yZW5kZXJlcl9vYmplY3RTcHJlYWQobGVnYWN5X3JlbmRlcmVyX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBjb3B5V2l0aERlbGV0ZShlbGVtZW50LnByb3BzLCBwYXRoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICAgIGRlbGV0ZVBhdGhJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5zdGF0ZSwgcGF0aCk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmFtZVBhdGgodHlwZSwgaWQsIGhvb2tJRCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gaWRUb0ludGVybmFsSW5zdGFuY2VNYXAuZ2V0KGlkKTtcblxuICAgIGlmIChpbnRlcm5hbEluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgIHZhciBwdWJsaWNJbnN0YW5jZSA9IGludGVybmFsSW5zdGFuY2UuX2luc3RhbmNlO1xuXG4gICAgICBpZiAocHVibGljSW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlICdjb250ZXh0JzpcbiAgICAgICAgICAgIHJlbmFtZVBhdGhJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5jb250ZXh0LCBvbGRQYXRoLCBuZXdQYXRoKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnaG9va3MnOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcblxuICAgICAgICAgIGNhc2UgJ3Byb3BzJzpcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCA9IGxlZ2FjeV9yZW5kZXJlcl9vYmplY3RTcHJlYWQobGVnYWN5X3JlbmRlcmVyX29iamVjdFNwcmVhZCh7fSwgZWxlbWVudCksIHt9LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBjb3B5V2l0aFJlbmFtZShlbGVtZW50LnByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ3N0YXRlJzpcbiAgICAgICAgICAgIHJlbmFtZVBhdGhJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5zdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG92ZXJyaWRlVmFsdWVBdFBhdGgodHlwZSwgaWQsIGhvb2tJRCwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGlkVG9JbnRlcm5hbEluc3RhbmNlTWFwLmdldChpZCk7XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICB2YXIgcHVibGljSW5zdGFuY2UgPSBpbnRlcm5hbEluc3RhbmNlLl9pbnN0YW5jZTtcblxuICAgICAgaWYgKHB1YmxpY0luc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSAnY29udGV4dCc6XG4gICAgICAgICAgICBzZXRJbk9iamVjdChwdWJsaWNJbnN0YW5jZS5jb250ZXh0LCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZShwdWJsaWNJbnN0YW5jZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgJ2hvb2tzJzpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSG9va3Mgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG5cbiAgICAgICAgICBjYXNlICdwcm9wcyc6XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgPSBsZWdhY3lfcmVuZGVyZXJfb2JqZWN0U3ByZWFkKGxlZ2FjeV9yZW5kZXJlcl9vYmplY3RTcHJlYWQoe30sIGVsZW1lbnQpLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wczogY29weVdpdGhTZXQoZWxlbWVudC5wcm9wcywgcGF0aCwgdmFsdWUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAnc3RhdGUnOlxuICAgICAgICAgICAgc2V0SW5PYmplY3QocHVibGljSW5zdGFuY2Uuc3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHYxNisgb25seSBmZWF0dXJlc1xuXG5cbiAgdmFyIGdldFByb2ZpbGluZ0RhdGEgPSBmdW5jdGlvbiBnZXRQcm9maWxpbmdEYXRhKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2V0UHJvZmlsaW5nRGF0YSBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlQ29tbWl0RmliZXJSb290ID0gZnVuY3Rpb24gaGFuZGxlQ29tbWl0RmliZXJSb290KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlQ29tbWl0RmliZXJSb290IG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVDb21taXRGaWJlclVubW91bnQgPSBmdW5jdGlvbiBoYW5kbGVDb21taXRGaWJlclVubW91bnQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdoYW5kbGVDb21taXRGaWJlclVubW91bnQgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG5cbiAgdmFyIGhhbmRsZVBvc3RDb21taXRGaWJlclJvb3QgPSBmdW5jdGlvbiBoYW5kbGVQb3N0Q29tbWl0RmliZXJSb290KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXInKTtcbiAgfTtcblxuICB2YXIgb3ZlcnJpZGVFcnJvciA9IGZ1bmN0aW9uIG92ZXJyaWRlRXJyb3IoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdvdmVycmlkZUVycm9yIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlcicpO1xuICB9O1xuXG4gIHZhciBvdmVycmlkZVN1c3BlbnNlID0gZnVuY3Rpb24gb3ZlcnJpZGVTdXNwZW5zZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ292ZXJyaWRlU3VzcGVuc2Ugbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyJyk7XG4gIH07XG5cbiAgdmFyIHN0YXJ0UHJvZmlsaW5nID0gZnVuY3Rpb24gc3RhcnRQcm9maWxpbmcoKSB7Ly8gRG8gbm90IHRocm93LCBzaW5jZSB0aGlzIHdvdWxkIGJyZWFrIGEgbXVsdGktcm9vdCBzY2VuYXJpbyB3aGVyZSB2MTUgYW5kIHYxNiB3ZXJlIGJvdGggcHJlc2VudC5cbiAgfTtcblxuICB2YXIgc3RvcFByb2ZpbGluZyA9IGZ1bmN0aW9uIHN0b3BQcm9maWxpbmcoKSB7Ly8gRG8gbm90IHRocm93LCBzaW5jZSB0aGlzIHdvdWxkIGJyZWFrIGEgbXVsdGktcm9vdCBzY2VuYXJpbyB3aGVyZSB2MTUgYW5kIHYxNiB3ZXJlIGJvdGggcHJlc2VudC5cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRCZXN0TWF0Y2hGb3JUcmFja2VkUGF0aCgpIHtcbiAgICAvLyBOb3QgaW1wbGVtZW50ZWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRQYXRoRm9yRWxlbWVudChpZCkge1xuICAgIC8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNvbXBvbmVudEZpbHRlcnMoY29tcG9uZW50RmlsdGVycykgey8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYWNlVXBkYXRlc0VuYWJsZWQoZW5hYmxlZCkgey8vIE5vdCBpbXBsZW1lbnRlZC5cbiAgfVxuXG4gIGZ1bmN0aW9uIHNldFRyYWNrZWRQYXRoKHBhdGgpIHsvLyBOb3QgaW1wbGVtZW50ZWQuXG4gIH1cblxuICBmdW5jdGlvbiBnZXRPd25lcnNMaXN0KGlkKSB7XG4gICAgLy8gTm90IGltcGxlbWVudGVkLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJFcnJvcnNBbmRXYXJuaW5ncygpIHsvLyBOb3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyRXJyb3JzRm9yRmliZXJJRChpZCkgey8vIE5vdCBpbXBsZW1lbnRlZFxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQoaWQpIHsvLyBOb3QgaW1wbGVtZW50ZWRcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY2xlYXJFcnJvcnNBbmRXYXJuaW5nczogY2xlYXJFcnJvcnNBbmRXYXJuaW5ncyxcbiAgICBjbGVhckVycm9yc0ZvckZpYmVySUQ6IGNsZWFyRXJyb3JzRm9yRmliZXJJRCxcbiAgICBjbGVhcldhcm5pbmdzRm9yRmliZXJJRDogY2xlYXJXYXJuaW5nc0ZvckZpYmVySUQsXG4gICAgY2xlYW51cDogY2xlYW51cCxcbiAgICBjb3B5RWxlbWVudFBhdGg6IGNvcHlFbGVtZW50UGF0aCxcbiAgICBkZWxldGVQYXRoOiBkZWxldGVQYXRoLFxuICAgIGZsdXNoSW5pdGlhbE9wZXJhdGlvbnM6IGZsdXNoSW5pdGlhbE9wZXJhdGlvbnMsXG4gICAgZ2V0QmVzdE1hdGNoRm9yVHJhY2tlZFBhdGg6IGdldEJlc3RNYXRjaEZvclRyYWNrZWRQYXRoLFxuICAgIGdldERpc3BsYXlOYW1lRm9yRmliZXJJRDogZ2V0RGlzcGxheU5hbWVGb3JGaWJlcklELFxuICAgIGdldEZpYmVySURGb3JOYXRpdmU6IGdldEludGVybmFsSURGb3JOYXRpdmUsXG4gICAgZ2V0SW5zdGFuY2VBbmRTdHlsZTogZ2V0SW5zdGFuY2VBbmRTdHlsZSxcbiAgICBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEOiBmdW5jdGlvbiBmaW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKSB7XG4gICAgICB2YXIgbmF0aXZlTm9kZSA9IGZpbmROYXRpdmVOb2RlRm9ySW50ZXJuYWxJRChpZCk7XG4gICAgICByZXR1cm4gbmF0aXZlTm9kZSA9PSBudWxsID8gbnVsbCA6IFtuYXRpdmVOb2RlXTtcbiAgICB9LFxuICAgIGdldE93bmVyc0xpc3Q6IGdldE93bmVyc0xpc3QsXG4gICAgZ2V0UGF0aEZvckVsZW1lbnQ6IGdldFBhdGhGb3JFbGVtZW50LFxuICAgIGdldFByb2ZpbGluZ0RhdGE6IGdldFByb2ZpbGluZ0RhdGEsXG4gICAgaGFuZGxlQ29tbWl0RmliZXJSb290OiBoYW5kbGVDb21taXRGaWJlclJvb3QsXG4gICAgaGFuZGxlQ29tbWl0RmliZXJVbm1vdW50OiBoYW5kbGVDb21taXRGaWJlclVubW91bnQsXG4gICAgaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdDogaGFuZGxlUG9zdENvbW1pdEZpYmVyUm9vdCxcbiAgICBpbnNwZWN0RWxlbWVudDogaW5zcGVjdEVsZW1lbnQsXG4gICAgbG9nRWxlbWVudFRvQ29uc29sZTogbG9nRWxlbWVudFRvQ29uc29sZSxcbiAgICBvdmVycmlkZUVycm9yOiBvdmVycmlkZUVycm9yLFxuICAgIG92ZXJyaWRlU3VzcGVuc2U6IG92ZXJyaWRlU3VzcGVuc2UsXG4gICAgb3ZlcnJpZGVWYWx1ZUF0UGF0aDogb3ZlcnJpZGVWYWx1ZUF0UGF0aCxcbiAgICByZW5hbWVQYXRoOiByZW5hbWVQYXRoLFxuICAgIHByZXBhcmVWaWV3QXR0cmlidXRlU291cmNlOiBwcmVwYXJlVmlld0F0dHJpYnV0ZVNvdXJjZSxcbiAgICBwcmVwYXJlVmlld0VsZW1lbnRTb3VyY2U6IHByZXBhcmVWaWV3RWxlbWVudFNvdXJjZSxcbiAgICByZW5kZXJlcjogcmVuZGVyZXIsXG4gICAgc2V0VHJhY2VVcGRhdGVzRW5hYmxlZDogc2V0VHJhY2VVcGRhdGVzRW5hYmxlZCxcbiAgICBzZXRUcmFja2VkUGF0aDogc2V0VHJhY2tlZFBhdGgsXG4gICAgc3RhcnRQcm9maWxpbmc6IHN0YXJ0UHJvZmlsaW5nLFxuICAgIHN0b3BQcm9maWxpbmc6IHN0b3BQcm9maWxpbmcsXG4gICAgc3RvcmVBc0dsb2JhbDogc3RvcmVBc0dsb2JhbCxcbiAgICB1cGRhdGVDb21wb25lbnRGaWx0ZXJzOiB1cGRhdGVDb21wb25lbnRGaWx0ZXJzXG4gIH07XG59XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuLi9yZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvaW5kZXguanNcbi8qKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuXG5cbmZ1bmN0aW9uIGluaXRCYWNrZW5kKGhvb2ssIGFnZW50LCBnbG9iYWwpIHtcbiAgaWYgKGhvb2sgPT0gbnVsbCkge1xuICAgIC8vIERldlRvb2xzIGRpZG4ndCBnZXQgaW5qZWN0ZWQgaW50byB0aGlzIHBhZ2UgKG1heWJlIGInYyBvZiB0aGUgY29udGVudFR5cGUpLlxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIHZhciBzdWJzID0gW2hvb2suc3ViKCdyZW5kZXJlci1hdHRhY2hlZCcsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIGlkID0gX3JlZi5pZCxcbiAgICAgICAgcmVuZGVyZXIgPSBfcmVmLnJlbmRlcmVyLFxuICAgICAgICByZW5kZXJlckludGVyZmFjZSA9IF9yZWYucmVuZGVyZXJJbnRlcmZhY2U7XG4gICAgYWdlbnQuc2V0UmVuZGVyZXJJbnRlcmZhY2UoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTsgLy8gTm93IHRoYXQgdGhlIFN0b3JlIGFuZCB0aGUgcmVuZGVyZXIgaW50ZXJmYWNlIGFyZSBjb25uZWN0ZWQsXG4gICAgLy8gaXQncyB0aW1lIHRvIGZsdXNoIHRoZSBwZW5kaW5nIG9wZXJhdGlvbiBjb2RlcyB0byB0aGUgZnJvbnRlbmQuXG5cbiAgICByZW5kZXJlckludGVyZmFjZS5mbHVzaEluaXRpYWxPcGVyYXRpb25zKCk7XG4gIH0pLCBob29rLnN1YigndW5zdXBwb3J0ZWQtcmVuZGVyZXItdmVyc2lvbicsIGZ1bmN0aW9uIChpZCkge1xuICAgIGFnZW50Lm9uVW5zdXBwb3J0ZWRSZW5kZXJlcihpZCk7XG4gIH0pLCBob29rLnN1YignZmFzdFJlZnJlc2hTY2hlZHVsZWQnLCBhZ2VudC5vbkZhc3RSZWZyZXNoU2NoZWR1bGVkKSwgaG9vay5zdWIoJ29wZXJhdGlvbnMnLCBhZ2VudC5vbkhvb2tPcGVyYXRpb25zKSwgaG9vay5zdWIoJ3RyYWNlVXBkYXRlcycsIGFnZW50Lm9uVHJhY2VVcGRhdGVzKSAvLyBUT0RPIEFkZCBhZGRpdGlvbmFsIHN1YnNjcmlwdGlvbnMgcmVxdWlyZWQgZm9yIHByb2ZpbGluZyBtb2RlXG4gIF07XG5cbiAgdmFyIGF0dGFjaFJlbmRlcmVyID0gZnVuY3Rpb24gYXR0YWNoUmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XG4gICAgdmFyIHJlbmRlcmVySW50ZXJmYWNlID0gaG9vay5yZW5kZXJlckludGVyZmFjZXMuZ2V0KGlkKTsgLy8gSW5qZWN0IGFueSBub3QteWV0LWluamVjdGVkIHJlbmRlcmVycyAoaWYgd2UgZGlkbid0IHJlbG9hZC1hbmQtcHJvZmlsZSlcblxuICAgIGlmIChyZW5kZXJlckludGVyZmFjZSA9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVyLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIHJlYWN0LXJlY29uY2lsZXIgdjE2K1xuICAgICAgICByZW5kZXJlckludGVyZmFjZSA9IHJlbmRlcmVyX2F0dGFjaChob29rLCBpZCwgcmVuZGVyZXIsIGdsb2JhbCk7XG4gICAgICB9IGVsc2UgaWYgKHJlbmRlcmVyLkNvbXBvbmVudFRyZWUpIHtcbiAgICAgICAgLy8gcmVhY3QtZG9tIHYxNVxuICAgICAgICByZW5kZXJlckludGVyZmFjZSA9IGxlZ2FjeV9yZW5kZXJlcl9hdHRhY2goaG9vaywgaWQsIHJlbmRlcmVyLCBnbG9iYWwpO1xuICAgICAgfSBlbHNlIHsvLyBPbGRlciByZWFjdC1kb20gb3Igb3RoZXIgdW5zdXBwb3J0ZWQgcmVuZGVyZXIgdmVyc2lvblxuICAgICAgfVxuXG4gICAgICBpZiAocmVuZGVyZXJJbnRlcmZhY2UgIT0gbnVsbCkge1xuICAgICAgICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5zZXQoaWQsIHJlbmRlcmVySW50ZXJmYWNlKTtcbiAgICAgIH1cbiAgICB9IC8vIE5vdGlmeSB0aGUgRGV2VG9vbHMgZnJvbnRlbmQgYWJvdXQgbmV3IHJlbmRlcmVycy5cbiAgICAvLyBUaGlzIGluY2x1ZGVzIGFueSB0aGF0IHdlcmUgYXR0YWNoZWQgZWFybHkgKHZpYSBfX1JFQUNUX0RFVlRPT0xTX0FUVEFDSF9fKS5cblxuXG4gICAgaWYgKHJlbmRlcmVySW50ZXJmYWNlICE9IG51bGwpIHtcbiAgICAgIGhvb2suZW1pdCgncmVuZGVyZXItYXR0YWNoZWQnLCB7XG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVuZGVyZXI6IHJlbmRlcmVyLFxuICAgICAgICByZW5kZXJlckludGVyZmFjZTogcmVuZGVyZXJJbnRlcmZhY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rLmVtaXQoJ3Vuc3VwcG9ydGVkLXJlbmRlcmVyLXZlcnNpb24nLCBpZCk7XG4gICAgfVxuICB9OyAvLyBDb25uZWN0IHJlbmRlcmVycyB0aGF0IGhhdmUgYWxyZWFkeSBpbmplY3RlZCB0aGVtc2VsdmVzLlxuXG5cbiAgaG9vay5yZW5kZXJlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVuZGVyZXIsIGlkKSB7XG4gICAgYXR0YWNoUmVuZGVyZXIoaWQsIHJlbmRlcmVyKTtcbiAgfSk7IC8vIENvbm5lY3QgYW55IG5ldyByZW5kZXJlcnMgdGhhdCBpbmplY3RlZCB0aGVtc2VsdmVzLlxuXG4gIHN1YnMucHVzaChob29rLnN1YigncmVuZGVyZXInLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgcmVuZGVyZXIgPSBfcmVmMi5yZW5kZXJlcjtcbiAgICBhdHRhY2hSZW5kZXJlcihpZCwgcmVuZGVyZXIpO1xuICB9KSk7XG4gIGhvb2suZW1pdCgncmVhY3QtZGV2dG9vbHMnLCBhZ2VudCk7XG4gIGhvb2sucmVhY3REZXZ0b29sc0FnZW50ID0gYWdlbnQ7XG5cbiAgdmFyIG9uQWdlbnRTaHV0ZG93biA9IGZ1bmN0aW9uIG9uQWdlbnRTaHV0ZG93bigpIHtcbiAgICBzdWJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9KTtcbiAgICBob29rLnJlbmRlcmVySW50ZXJmYWNlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZW5kZXJlckludGVyZmFjZSkge1xuICAgICAgcmVuZGVyZXJJbnRlcmZhY2UuY2xlYW51cCgpO1xuICAgIH0pO1xuICAgIGhvb2sucmVhY3REZXZ0b29sc0FnZW50ID0gbnVsbDtcbiAgfTtcblxuICBhZ2VudC5hZGRMaXN0ZW5lcignc2h1dGRvd24nLCBvbkFnZW50U2h1dGRvd24pO1xuICBzdWJzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGFnZW50LnJlbW92ZUxpc3RlbmVyKCdzaHV0ZG93bicsIG9uQWdlbnRTaHV0ZG93bik7XG4gIH0pO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN1YnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL05hdGl2ZVN0eWxlRWRpdG9yL3Jlc29sdmVCb3hTdHlsZS5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG4vKipcbiAqIFRoaXMgbWlycm9ycyByZWFjdC1uYXRpdmUvTGlicmFyaWVzL0luc3BlY3Rvci9yZXNvbHZlQm94U3R5bGUuanMgKGJ1dCB3aXRob3V0IFJUTCBzdXBwb3J0KS5cbiAqXG4gKiBSZXNvbHZlIGEgc3R5bGUgcHJvcGVydHkgaW50byBpdCdzIGNvbXBvbmVudCBwYXJ0cywgZS5nLlxuICpcbiAqIHJlc29sdmVCb3hTdHlsZSgnbWFyZ2luJywge21hcmdpbjogNSwgbWFyZ2luQm90dG9tOiAxMH0pXG4gKiAtPiB7dG9wOiA1LCBsZWZ0OiA1LCByaWdodDogNSwgYm90dG9tOiAxMH1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUJveFN0eWxlKHByZWZpeCwgc3R5bGUpIHtcbiAgdmFyIGhhc1BhcnRzID0gZmFsc2U7XG4gIHZhciByZXN1bHQgPSB7XG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgdG9wOiAwXG4gIH07XG4gIHZhciBzdHlsZUZvckFsbCA9IHN0eWxlW3ByZWZpeF07XG5cbiAgaWYgKHN0eWxlRm9yQWxsICE9IG51bGwpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZm9yLW9mLWxvb3BzL25vLWZvci1vZi1sb29wc1xuICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRrZXlzID0gT2JqZWN0LmtleXMocmVzdWx0KTsgX2kgPCBfT2JqZWN0JGtleXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzW19pXTtcbiAgICAgIHJlc3VsdFtrZXldID0gc3R5bGVGb3JBbGw7XG4gICAgfVxuXG4gICAgaGFzUGFydHMgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHN0eWxlRm9ySG9yaXpvbnRhbCA9IHN0eWxlW3ByZWZpeCArICdIb3Jpem9udGFsJ107XG5cbiAgaWYgKHN0eWxlRm9ySG9yaXpvbnRhbCAhPSBudWxsKSB7XG4gICAgcmVzdWx0LmxlZnQgPSBzdHlsZUZvckhvcml6b250YWw7XG4gICAgcmVzdWx0LnJpZ2h0ID0gc3R5bGVGb3JIb3Jpem9udGFsO1xuICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3R5bGVGb3JMZWZ0ID0gc3R5bGVbcHJlZml4ICsgJ0xlZnQnXTtcblxuICAgIGlmIChzdHlsZUZvckxlZnQgIT0gbnVsbCkge1xuICAgICAgcmVzdWx0LmxlZnQgPSBzdHlsZUZvckxlZnQ7XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlRm9yUmlnaHQgPSBzdHlsZVtwcmVmaXggKyAnUmlnaHQnXTtcblxuICAgIGlmIChzdHlsZUZvclJpZ2h0ICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC5yaWdodCA9IHN0eWxlRm9yUmlnaHQ7XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlRm9yRW5kID0gc3R5bGVbcHJlZml4ICsgJ0VuZCddO1xuXG4gICAgaWYgKHN0eWxlRm9yRW5kICE9IG51bGwpIHtcbiAgICAgIC8vIFRPRE8gUlRMIHN1cHBvcnRcbiAgICAgIHJlc3VsdC5yaWdodCA9IHN0eWxlRm9yRW5kO1xuICAgICAgaGFzUGFydHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBzdHlsZUZvclN0YXJ0ID0gc3R5bGVbcHJlZml4ICsgJ1N0YXJ0J107XG5cbiAgICBpZiAoc3R5bGVGb3JTdGFydCAhPSBudWxsKSB7XG4gICAgICAvLyBUT0RPIFJUTCBzdXBwb3J0XG4gICAgICByZXN1bHQubGVmdCA9IHN0eWxlRm9yU3RhcnQ7XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0eWxlRm9yVmVydGljYWwgPSBzdHlsZVtwcmVmaXggKyAnVmVydGljYWwnXTtcblxuICBpZiAoc3R5bGVGb3JWZXJ0aWNhbCAhPSBudWxsKSB7XG4gICAgcmVzdWx0LmJvdHRvbSA9IHN0eWxlRm9yVmVydGljYWw7XG4gICAgcmVzdWx0LnRvcCA9IHN0eWxlRm9yVmVydGljYWw7XG4gICAgaGFzUGFydHMgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdHlsZUZvckJvdHRvbSA9IHN0eWxlW3ByZWZpeCArICdCb3R0b20nXTtcblxuICAgIGlmIChzdHlsZUZvckJvdHRvbSAhPSBudWxsKSB7XG4gICAgICByZXN1bHQuYm90dG9tID0gc3R5bGVGb3JCb3R0b207XG4gICAgICBoYXNQYXJ0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlRm9yVG9wID0gc3R5bGVbcHJlZml4ICsgJ1RvcCddO1xuXG4gICAgaWYgKHN0eWxlRm9yVG9wICE9IG51bGwpIHtcbiAgICAgIHJlc3VsdC50b3AgPSBzdHlsZUZvclRvcDtcbiAgICAgIGhhc1BhcnRzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaGFzUGFydHMgPyByZXN1bHQgOiBudWxsO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi4vcmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL05hdGl2ZVN0eWxlRWRpdG9yL3NldHVwTmF0aXZlU3R5bGVFZGl0b3IuanNcbmZ1bmN0aW9uIHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBzZXR1cE5hdGl2ZVN0eWxlRWRpdG9yX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cblxuZnVuY3Rpb24gc2V0dXBOYXRpdmVTdHlsZUVkaXRvcihicmlkZ2UsIGFnZW50LCByZXNvbHZlTmF0aXZlU3R5bGUsIHZhbGlkQXR0cmlidXRlcykge1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ05hdGl2ZVN0eWxlRWRpdG9yX21lYXN1cmUnLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBpZCA9IF9yZWYuaWQsXG4gICAgICAgIHJlbmRlcmVySUQgPSBfcmVmLnJlbmRlcmVySUQ7XG4gICAgbWVhc3VyZVN0eWxlKGFnZW50LCBicmlkZ2UsIHJlc29sdmVOYXRpdmVTdHlsZSwgaWQsIHJlbmRlcmVySUQpO1xuICB9KTtcbiAgYnJpZGdlLmFkZExpc3RlbmVyKCdOYXRpdmVTdHlsZUVkaXRvcl9yZW5hbWVBdHRyaWJ1dGUnLCBmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgcmVuZGVyZXJJRCA9IF9yZWYyLnJlbmRlcmVySUQsXG4gICAgICAgIG9sZE5hbWUgPSBfcmVmMi5vbGROYW1lLFxuICAgICAgICBuZXdOYW1lID0gX3JlZjIubmV3TmFtZSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMi52YWx1ZTtcbiAgICByZW5hbWVTdHlsZShhZ2VudCwgaWQsIHJlbmRlcmVySUQsIG9sZE5hbWUsIG5ld05hbWUsIHZhbHVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlU3R5bGUoYWdlbnQsIGJyaWRnZSwgcmVzb2x2ZU5hdGl2ZVN0eWxlLCBpZCwgcmVuZGVyZXJJRCk7XG4gICAgfSk7XG4gIH0pO1xuICBicmlkZ2UuYWRkTGlzdGVuZXIoJ05hdGl2ZVN0eWxlRWRpdG9yX3NldFZhbHVlJywgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgdmFyIGlkID0gX3JlZjMuaWQsXG4gICAgICAgIHJlbmRlcmVySUQgPSBfcmVmMy5yZW5kZXJlcklELFxuICAgICAgICBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgdmFsdWUgPSBfcmVmMy52YWx1ZTtcbiAgICBzZXRTdHlsZShhZ2VudCwgaWQsIHJlbmRlcmVySUQsIG5hbWUsIHZhbHVlKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlU3R5bGUoYWdlbnQsIGJyaWRnZSwgcmVzb2x2ZU5hdGl2ZVN0eWxlLCBpZCwgcmVuZGVyZXJJRCk7XG4gICAgfSk7XG4gIH0pO1xuICBicmlkZ2Uuc2VuZCgnaXNOYXRpdmVTdHlsZUVkaXRvclN1cHBvcnRlZCcsIHtcbiAgICBpc1N1cHBvcnRlZDogdHJ1ZSxcbiAgICB2YWxpZEF0dHJpYnV0ZXM6IHZhbGlkQXR0cmlidXRlc1xuICB9KTtcbn1cbnZhciBFTVBUWV9CT1hfU1RZTEUgPSB7XG4gIHRvcDogMCxcbiAgbGVmdDogMCxcbiAgcmlnaHQ6IDAsXG4gIGJvdHRvbTogMFxufTtcbnZhciBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMgPSBuZXcgTWFwKCk7XG5cbmZ1bmN0aW9uIG1lYXN1cmVTdHlsZShhZ2VudCwgYnJpZGdlLCByZXNvbHZlTmF0aXZlU3R5bGUsIGlkLCByZW5kZXJlcklEKSB7XG4gIHZhciBkYXRhID0gYWdlbnQuZ2V0SW5zdGFuY2VBbmRTdHlsZSh7XG4gICAgaWQ6IGlkLFxuICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySURcbiAgfSk7XG5cbiAgaWYgKCFkYXRhIHx8ICFkYXRhLnN0eWxlKSB7XG4gICAgYnJpZGdlLnNlbmQoJ05hdGl2ZVN0eWxlRWRpdG9yX3N0eWxlQW5kTGF5b3V0Jywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgbGF5b3V0OiBudWxsLFxuICAgICAgc3R5bGU6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBkYXRhLmluc3RhbmNlLFxuICAgICAgc3R5bGUgPSBkYXRhLnN0eWxlO1xuICB2YXIgcmVzb2x2ZWRTdHlsZSA9IHJlc29sdmVOYXRpdmVTdHlsZShzdHlsZSk7IC8vIElmIGl0J3MgYSBob3N0IGNvbXBvbmVudCB3ZSBlZGl0ZWQgYmVmb3JlLCBhbWVuZCBzdHlsZXMuXG5cbiAgdmFyIHN0eWxlT3ZlcnJpZGVzID0gY29tcG9uZW50SURUb1N0eWxlT3ZlcnJpZGVzLmdldChpZCk7XG5cbiAgaWYgKHN0eWxlT3ZlcnJpZGVzICE9IG51bGwpIHtcbiAgICByZXNvbHZlZFN0eWxlID0gT2JqZWN0LmFzc2lnbih7fSwgcmVzb2x2ZWRTdHlsZSwgc3R5bGVPdmVycmlkZXMpO1xuICB9XG5cbiAgaWYgKCFpbnN0YW5jZSB8fCB0eXBlb2YgaW5zdGFuY2UubWVhc3VyZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGJyaWRnZS5zZW5kKCdOYXRpdmVTdHlsZUVkaXRvcl9zdHlsZUFuZExheW91dCcsIHtcbiAgICAgIGlkOiBpZCxcbiAgICAgIGxheW91dDogbnVsbCxcbiAgICAgIHN0eWxlOiByZXNvbHZlZFN0eWxlIHx8IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH0gLy8gJEZsb3dGaXhNZSB0aGUgcGFyYW1ldGVyIHR5cGVzIG9mIGFuIHVua25vd24gZnVuY3Rpb24gYXJlIHVua25vd25cblxuXG4gIGluc3RhbmNlLm1lYXN1cmUoZnVuY3Rpb24gKHgsIHksIHdpZHRoLCBoZWlnaHQsIGxlZnQsIHRvcCkge1xuICAgIC8vIFJOIEFuZHJvaWQgc29tZXRpbWVzIHJldHVybnMgdW5kZWZpbmVkIGhlcmUuIERvbid0IHNlbmQgbWVhc3VyZW1lbnRzIGluIHRoaXMgY2FzZS5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vamhlbjA0MDkvcmVhY3QtbmF0aXZlLWRlYnVnZ2VyL2lzc3Vlcy84NCNpc3N1ZWNvbW1lbnQtMzA0NjExODE3XG4gICAgaWYgKHR5cGVvZiB4ICE9PSAnbnVtYmVyJykge1xuICAgICAgYnJpZGdlLnNlbmQoJ05hdGl2ZVN0eWxlRWRpdG9yX3N0eWxlQW5kTGF5b3V0Jywge1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIGxheW91dDogbnVsbCxcbiAgICAgICAgc3R5bGU6IHJlc29sdmVkU3R5bGUgfHwgbnVsbFxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG1hcmdpbiA9IHJlc29sdmVkU3R5bGUgIT0gbnVsbCAmJiByZXNvbHZlQm94U3R5bGUoJ21hcmdpbicsIHJlc29sdmVkU3R5bGUpIHx8IEVNUFRZX0JPWF9TVFlMRTtcbiAgICB2YXIgcGFkZGluZyA9IHJlc29sdmVkU3R5bGUgIT0gbnVsbCAmJiByZXNvbHZlQm94U3R5bGUoJ3BhZGRpbmcnLCByZXNvbHZlZFN0eWxlKSB8fCBFTVBUWV9CT1hfU1RZTEU7XG4gICAgYnJpZGdlLnNlbmQoJ05hdGl2ZVN0eWxlRWRpdG9yX3N0eWxlQW5kTGF5b3V0Jywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgbGF5b3V0OiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHRvcDogdG9wLFxuICAgICAgICBtYXJnaW46IG1hcmdpbixcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiByZXNvbHZlZFN0eWxlIHx8IG51bGxcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmplY3QpIHtcbiAgdmFyIGNsb25lZCA9IHt9O1xuXG4gIGZvciAodmFyIG4gaW4gb2JqZWN0KSB7XG4gICAgY2xvbmVkW25dID0gb2JqZWN0W25dO1xuICB9XG5cbiAgcmV0dXJuIGNsb25lZDtcbn1cblxuZnVuY3Rpb24gcmVuYW1lU3R5bGUoYWdlbnQsIGlkLCByZW5kZXJlcklELCBvbGROYW1lLCBuZXdOYW1lLCB2YWx1ZSkge1xuICB2YXIgX3JlZjQ7XG5cbiAgdmFyIGRhdGEgPSBhZ2VudC5nZXRJbnN0YW5jZUFuZFN0eWxlKHtcbiAgICBpZDogaWQsXG4gICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRFxuICB9KTtcblxuICBpZiAoIWRhdGEgfHwgIWRhdGEuc3R5bGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBkYXRhLmluc3RhbmNlLFxuICAgICAgc3R5bGUgPSBkYXRhLnN0eWxlO1xuICB2YXIgbmV3U3R5bGUgPSBuZXdOYW1lID8gKF9yZWY0ID0ge30sIHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfZGVmaW5lUHJvcGVydHkoX3JlZjQsIG9sZE5hbWUsIHVuZGVmaW5lZCksIHNldHVwTmF0aXZlU3R5bGVFZGl0b3JfZGVmaW5lUHJvcGVydHkoX3JlZjQsIG5ld05hbWUsIHZhbHVlKSwgX3JlZjQpIDogc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl9kZWZpbmVQcm9wZXJ0eSh7fSwgb2xkTmFtZSwgdW5kZWZpbmVkKTtcbiAgdmFyIGN1c3RvbVN0eWxlOyAvLyBUT0RPIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIHJlbmRlcmVyIGludGVyZmFjZSBhYnN0cmFjdGVkIHRoaXMgYXdheSBzb21laG93LlxuXG4gIGlmIChpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2Uuc2V0TmF0aXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJbiB0aGUgY2FzZSBvZiBhIGhvc3QgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHVzZSBzZXROYXRpdmVQcm9wcygpLlxuICAgIC8vIFJlbWVtYmVyIHRvIFwiY29ycmVjdFwiIHJlc29sdmVkIHN0eWxlcyB3aGVuIHdlIHJlYWQgdGhlbSBuZXh0IHRpbWUuXG4gICAgdmFyIHN0eWxlT3ZlcnJpZGVzID0gY29tcG9uZW50SURUb1N0eWxlT3ZlcnJpZGVzLmdldChpZCk7XG5cbiAgICBpZiAoIXN0eWxlT3ZlcnJpZGVzKSB7XG4gICAgICBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMuc2V0KGlkLCBuZXdTdHlsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGVPdmVycmlkZXMsIG5ld1N0eWxlKTtcbiAgICB9IC8vIFRPRE8gRmFicmljIGRvZXMgbm90IHN1cHBvcnQgc2V0TmF0aXZlUHJvcHM7IGNoYXQgd2l0aCBTZWJhc3RpYW4gb3IgRWxpXG5cblxuICAgIGluc3RhbmNlLnNldE5hdGl2ZVByb3BzKHtcbiAgICAgIHN0eWxlOiBuZXdTdHlsZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3R5bGUpKSB7XG4gICAgdmFyIGxhc3RJbmRleCA9IHN0eWxlLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl90eXBlb2Yoc3R5bGVbbGFzdEluZGV4XSkgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHN0eWxlW2xhc3RJbmRleF0pKSB7XG4gICAgICBjdXN0b21TdHlsZSA9IHNoYWxsb3dDbG9uZShzdHlsZVtsYXN0SW5kZXhdKTtcbiAgICAgIGRlbGV0ZSBjdXN0b21TdHlsZVtvbGROYW1lXTtcblxuICAgICAgaWYgKG5ld05hbWUpIHtcbiAgICAgICAgY3VzdG9tU3R5bGVbbmV3TmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1c3RvbVN0eWxlW29sZE5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBhZ2VudC5vdmVycmlkZVZhbHVlQXRQYXRoKHtcbiAgICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICByZW5kZXJlcklEOiByZW5kZXJlcklELFxuICAgICAgICBwYXRoOiBbJ3N0eWxlJywgbGFzdEluZGV4XSxcbiAgICAgICAgdmFsdWU6IGN1c3RvbVN0eWxlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgcGF0aDogWydzdHlsZSddLFxuICAgICAgICB2YWx1ZTogc3R5bGUuY29uY2F0KFtuZXdTdHlsZV0pXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl90eXBlb2Yoc3R5bGUpID09PSAnb2JqZWN0Jykge1xuICAgIGN1c3RvbVN0eWxlID0gc2hhbGxvd0Nsb25lKHN0eWxlKTtcbiAgICBkZWxldGUgY3VzdG9tU3R5bGVbb2xkTmFtZV07XG5cbiAgICBpZiAobmV3TmFtZSkge1xuICAgICAgY3VzdG9tU3R5bGVbbmV3TmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VzdG9tU3R5bGVbb2xkTmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgaWQ6IGlkLFxuICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgIHZhbHVlOiBjdXN0b21TdHlsZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgdHlwZTogJ3Byb3BzJyxcbiAgICAgIGlkOiBpZCxcbiAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICBwYXRoOiBbJ3N0eWxlJ10sXG4gICAgICB2YWx1ZTogW3N0eWxlLCBuZXdTdHlsZV1cbiAgICB9KTtcbiAgfVxuXG4gIGFnZW50LmVtaXQoJ2hpZGVOYXRpdmVIaWdobGlnaHQnKTtcbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoYWdlbnQsIGlkLCByZW5kZXJlcklELCBuYW1lLCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGFnZW50LmdldEluc3RhbmNlQW5kU3R5bGUoe1xuICAgIGlkOiBpZCxcbiAgICByZW5kZXJlcklEOiByZW5kZXJlcklEXG4gIH0pO1xuXG4gIGlmICghZGF0YSB8fCAhZGF0YS5zdHlsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGRhdGEuaW5zdGFuY2UsXG4gICAgICBzdHlsZSA9IGRhdGEuc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl9kZWZpbmVQcm9wZXJ0eSh7fSwgbmFtZSwgdmFsdWUpOyAvLyBUT0RPIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIHJlbmRlcmVyIGludGVyZmFjZSBhYnN0cmFjdGVkIHRoaXMgYXdheSBzb21laG93LlxuXG5cbiAgaWYgKGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5zZXROYXRpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgaG9zdCBjb21wb25lbnQsIHdlIG5lZWQgdG8gdXNlIHNldE5hdGl2ZVByb3BzKCkuXG4gICAgLy8gUmVtZW1iZXIgdG8gXCJjb3JyZWN0XCIgcmVzb2x2ZWQgc3R5bGVzIHdoZW4gd2UgcmVhZCB0aGVtIG5leHQgdGltZS5cbiAgICB2YXIgc3R5bGVPdmVycmlkZXMgPSBjb21wb25lbnRJRFRvU3R5bGVPdmVycmlkZXMuZ2V0KGlkKTtcblxuICAgIGlmICghc3R5bGVPdmVycmlkZXMpIHtcbiAgICAgIGNvbXBvbmVudElEVG9TdHlsZU92ZXJyaWRlcy5zZXQoaWQsIG5ld1N0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZU92ZXJyaWRlcywgbmV3U3R5bGUpO1xuICAgIH0gLy8gVE9ETyBGYWJyaWMgZG9lcyBub3Qgc3VwcG9ydCBzZXROYXRpdmVQcm9wczsgY2hhdCB3aXRoIFNlYmFzdGlhbiBvciBFbGlcblxuXG4gICAgaW5zdGFuY2Uuc2V0TmF0aXZlUHJvcHMoe1xuICAgICAgc3R5bGU6IG5ld1N0eWxlXG4gICAgfSk7XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzdHlsZSkpIHtcbiAgICB2YXIgbGFzdExlbmd0aCA9IHN0eWxlLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoc2V0dXBOYXRpdmVTdHlsZUVkaXRvcl90eXBlb2Yoc3R5bGVbbGFzdExlbmd0aF0pID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzdHlsZVtsYXN0TGVuZ3RoXSkpIHtcbiAgICAgIGFnZW50Lm92ZXJyaWRlVmFsdWVBdFBhdGgoe1xuICAgICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgICBpZDogaWQsXG4gICAgICAgIHJlbmRlcmVySUQ6IHJlbmRlcmVySUQsXG4gICAgICAgIHBhdGg6IFsnc3R5bGUnLCBsYXN0TGVuZ3RoLCBuYW1lXSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICAgIHR5cGU6ICdwcm9wcycsXG4gICAgICAgIGlkOiBpZCxcbiAgICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgICAgcGF0aDogWydzdHlsZSddLFxuICAgICAgICB2YWx1ZTogc3R5bGUuY29uY2F0KFtuZXdTdHlsZV0pXG4gICAgICB9KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYWdlbnQub3ZlcnJpZGVWYWx1ZUF0UGF0aCh7XG4gICAgICB0eXBlOiAncHJvcHMnLFxuICAgICAgaWQ6IGlkLFxuICAgICAgcmVuZGVyZXJJRDogcmVuZGVyZXJJRCxcbiAgICAgIHBhdGg6IFsnc3R5bGUnXSxcbiAgICAgIHZhbHVlOiBbc3R5bGUsIG5ld1N0eWxlXVxuICAgIH0pO1xuICB9XG5cbiAgYWdlbnQuZW1pdCgnaGlkZU5hdGl2ZUhpZ2hsaWdodCcpO1xufVxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvYmFja2VuZC5qc1xuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5cblxuXG5cblxuXG5pbnN0YWxsSG9vayh3aW5kb3cpO1xudmFyIGJhY2tlbmRfaG9vayA9IHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG52YXIgc2F2ZWRDb21wb25lbnRGaWx0ZXJzID0gZ2V0RGVmYXVsdENvbXBvbmVudEZpbHRlcnMoKTtcblxuZnVuY3Rpb24gYmFja2VuZF9kZWJ1ZyhtZXRob2ROYW1lKSB7XG4gIGlmIChfX0RFQlVHX18pIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIFtcIiVjW2NvcmUvYmFja2VuZF0gJWNcIi5jb25jYXQobWV0aG9kTmFtZSksICdjb2xvcjogdGVhbDsgZm9udC13ZWlnaHQ6IGJvbGQ7JywgJ2ZvbnQtd2VpZ2h0OiBib2xkOyddLmNvbmNhdChhcmdzKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29ubmVjdFRvRGV2VG9vbHMob3B0aW9ucykge1xuICBpZiAoYmFja2VuZF9ob29rID09IG51bGwpIHtcbiAgICAvLyBEZXZUb29scyBkaWRuJ3QgZ2V0IGluamVjdGVkIGludG8gdGhpcyBwYWdlIChtYXliZSBiJ2Mgb2YgdGhlIGNvbnRlbnRUeXBlKS5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgX3JlZiA9IG9wdGlvbnMgfHwge30sXG4gICAgICBfcmVmJGhvc3QgPSBfcmVmLmhvc3QsXG4gICAgICBob3N0ID0gX3JlZiRob3N0ID09PSB2b2lkIDAgPyAnbG9jYWxob3N0JyA6IF9yZWYkaG9zdCxcbiAgICAgIG5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzID0gX3JlZi5uYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyxcbiAgICAgIF9yZWYkdXNlSHR0cHMgPSBfcmVmLnVzZUh0dHBzLFxuICAgICAgdXNlSHR0cHMgPSBfcmVmJHVzZUh0dHBzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkdXNlSHR0cHMsXG4gICAgICBfcmVmJHBvcnQgPSBfcmVmLnBvcnQsXG4gICAgICBwb3J0ID0gX3JlZiRwb3J0ID09PSB2b2lkIDAgPyA4MDk3IDogX3JlZiRwb3J0LFxuICAgICAgd2Vic29ja2V0ID0gX3JlZi53ZWJzb2NrZXQsXG4gICAgICBfcmVmJHJlc29sdmVSTlN0eWxlID0gX3JlZi5yZXNvbHZlUk5TdHlsZSxcbiAgICAgIHJlc29sdmVSTlN0eWxlID0gX3JlZiRyZXNvbHZlUk5TdHlsZSA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkcmVzb2x2ZVJOU3R5bGUsXG4gICAgICBfcmVmJHJldHJ5Q29ubmVjdGlvbkQgPSBfcmVmLnJldHJ5Q29ubmVjdGlvbkRlbGF5LFxuICAgICAgcmV0cnlDb25uZWN0aW9uRGVsYXkgPSBfcmVmJHJldHJ5Q29ubmVjdGlvbkQgPT09IHZvaWQgMCA/IDIwMDAgOiBfcmVmJHJldHJ5Q29ubmVjdGlvbkQsXG4gICAgICBfcmVmJGlzQXBwQWN0aXZlID0gX3JlZi5pc0FwcEFjdGl2ZSxcbiAgICAgIGlzQXBwQWN0aXZlID0gX3JlZiRpc0FwcEFjdGl2ZSA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IDogX3JlZiRpc0FwcEFjdGl2ZTtcblxuICB2YXIgcHJvdG9jb2wgPSB1c2VIdHRwcyA/ICd3c3MnIDogJ3dzJztcbiAgdmFyIHJldHJ5VGltZW91dElEID0gbnVsbDtcblxuICBmdW5jdGlvbiBzY2hlZHVsZVJldHJ5KCkge1xuICAgIGlmIChyZXRyeVRpbWVvdXRJRCA9PT0gbnVsbCkge1xuICAgICAgLy8gVHdvIHNlY29uZHMgYmVjYXVzZSBSTiBoYWQgaXNzdWVzIHdpdGggcXVpY2sgcmV0cmllcy5cbiAgICAgIHJldHJ5VGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb25uZWN0VG9EZXZUb29scyhvcHRpb25zKTtcbiAgICAgIH0sIHJldHJ5Q29ubmVjdGlvbkRlbGF5KTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWlzQXBwQWN0aXZlKCkpIHtcbiAgICAvLyBJZiB0aGUgYXBwIGlzIGluIGJhY2tncm91bmQsIG1heWJlIHJldHJ5IGxhdGVyLlxuICAgIC8vIERvbid0IGFjdHVhbGx5IGF0dGVtcHQgdG8gY29ubmVjdCB1bnRpbCB3ZSdyZSBpbiBmb3JlZ3JvdW5kLlxuICAgIHNjaGVkdWxlUmV0cnkoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYnJpZGdlID0gbnVsbDtcbiAgdmFyIG1lc3NhZ2VMaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIHVyaSA9IHByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgcG9ydDsgLy8gSWYgZXhpc3Rpbmcgd2Vic29ja2V0IGlzIHBhc3NlZCwgdXNlIGl0LlxuICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0IG91ciBjdXN0b20gaW50ZWdyYXRpb25zLlxuICAvLyBTZWUgRDYyNTE3NDQuXG5cbiAgdmFyIHdzID0gd2Vic29ja2V0ID8gd2Vic29ja2V0IDogbmV3IHdpbmRvdy5XZWJTb2NrZXQodXJpKTtcbiAgd3Mub25jbG9zZSA9IGhhbmRsZUNsb3NlO1xuICB3cy5vbmVycm9yID0gaGFuZGxlRmFpbGVkO1xuICB3cy5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlO1xuXG4gIHdzLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBicmlkZ2UgPSBuZXcgc3JjX2JyaWRnZSh7XG4gICAgICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbihmbikge1xuICAgICAgICBtZXNzYWdlTGlzdGVuZXJzLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBpbmRleCA9IG1lc3NhZ2VMaXN0ZW5lcnMuaW5kZXhPZihmbik7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgbWVzc2FnZUxpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBzZW5kOiBmdW5jdGlvbiBzZW5kKGV2ZW50LCBwYXlsb2FkLCB0cmFuc2ZlcmFibGUpIHtcbiAgICAgICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4pIHtcbiAgICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgICBiYWNrZW5kX2RlYnVnKCd3YWxsLnNlbmQoKScsIGV2ZW50LCBwYXlsb2FkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3cy5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHBheWxvYWQ6IHBheWxvYWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgICAgICAgYmFja2VuZF9kZWJ1Zygnd2FsbC5zZW5kKCknLCAnU2h1dHRpbmcgZG93biBicmlkZ2UgYmVjYXVzZSBvZiBjbG9zZWQgV2ViU29ja2V0IGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYnJpZGdlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBicmlkZ2Uuc2h1dGRvd24oKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlZHVsZVJldHJ5KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBicmlkZ2UuYWRkTGlzdGVuZXIoJ2luc3BlY3RFbGVtZW50JywgZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICB2YXIgaWQgPSBfcmVmMi5pZCxcbiAgICAgICAgICByZW5kZXJlcklEID0gX3JlZjIucmVuZGVyZXJJRDtcbiAgICAgIHZhciByZW5kZXJlciA9IGFnZW50LnJlbmRlcmVySW50ZXJmYWNlc1tyZW5kZXJlcklEXTtcblxuICAgICAgaWYgKHJlbmRlcmVyICE9IG51bGwpIHtcbiAgICAgICAgLy8gU2VuZCBldmVudCBmb3IgUk4gdG8gaGlnaGxpZ2h0LlxuICAgICAgICB2YXIgbm9kZXMgPSByZW5kZXJlci5maW5kTmF0aXZlTm9kZXNGb3JGaWJlcklEKGlkKTtcblxuICAgICAgICBpZiAobm9kZXMgIT0gbnVsbCAmJiBub2Rlc1swXSAhPSBudWxsKSB7XG4gICAgICAgICAgYWdlbnQuZW1pdCgnc2hvd05hdGl2ZUhpZ2hsaWdodCcsIG5vZGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIGJyaWRnZS5hZGRMaXN0ZW5lcigndXBkYXRlQ29tcG9uZW50RmlsdGVycycsIGZ1bmN0aW9uIChjb21wb25lbnRGaWx0ZXJzKSB7XG4gICAgICAvLyBTYXZlIGZpbHRlciBjaGFuZ2VzIGluIG1lbW9yeSwgaW4gY2FzZSBEZXZUb29scyBpcyByZWxvYWRlZC5cbiAgICAgIC8vIEluIHRoYXQgY2FzZSwgdGhlIHJlbmRlcmVyIHdpbGwgYWxyZWFkeSBiZSB1c2luZyB0aGUgdXBkYXRlZCB2YWx1ZXMuXG4gICAgICAvLyBXZSdsbCBsb3NlIHRoZXNlIGluIGJldHdlZW4gYmFja2VuZCByZWxvYWRzIGJ1dCB0aGF0IGNhbid0IGJlIGhlbHBlZC5cbiAgICAgIHNhdmVkQ29tcG9uZW50RmlsdGVycyA9IGNvbXBvbmVudEZpbHRlcnM7XG4gICAgfSk7IC8vIFRoZSByZW5kZXJlciBpbnRlcmZhY2UgZG9lc24ndCByZWFkIHNhdmVkIGNvbXBvbmVudCBmaWx0ZXJzIGRpcmVjdGx5LFxuICAgIC8vIGJlY2F1c2UgdGhleSBhcmUgZ2VuZXJhbGx5IHN0b3JlZCBpbiBsb2NhbFN0b3JhZ2Ugd2l0aGluIHRoZSBjb250ZXh0IG9mIHRoZSBleHRlbnNpb24uXG4gICAgLy8gQmVjYXVzZSBvZiB0aGlzIGl0IHJlbGllcyBvbiB0aGUgZXh0ZW5zaW9uIHRvIHBhc3MgZmlsdGVycy5cbiAgICAvLyBJbiB0aGUgY2FzZSBvZiB0aGUgc3RhbmRhbG9uZSBEZXZUb29scyBiZWluZyB1c2VkIHdpdGggYSB3ZWJzaXRlLFxuICAgIC8vIHNhdmVkIGZpbHRlcnMgYXJlIGluamVjdGVkIGFsb25nIHdpdGggdGhlIGJhY2tlbmQgc2NyaXB0IHRhZyBzbyB3ZSBzaG91bGRuJ3Qgb3ZlcnJpZGUgdGhlbSBoZXJlLlxuICAgIC8vIFRoaXMgaW5qZWN0aW9uIHN0cmF0ZWd5IGRvZXNuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIHRob3VnaC5cbiAgICAvLyBJZGVhbGx5IHRoZSBiYWNrZW5kIHdvdWxkIHNhdmUgdGhlIGZpbHRlcnMgaXRzZWxmLCBidXQgUk4gZG9lc24ndCBwcm92aWRlIGEgc3luYyBzdG9yYWdlIHNvbHV0aW9uLlxuICAgIC8vIFNvIGZvciBub3cgd2UganVzdCBmYWxsIGJhY2sgdG8gdXNpbmcgdGhlIGRlZmF1bHQgZmlsdGVycy4uLlxuXG4gICAgaWYgKHdpbmRvdy5fX1JFQUNUX0RFVlRPT0xTX0NPTVBPTkVOVF9GSUxURVJTX18gPT0gbnVsbCkge1xuICAgICAgYnJpZGdlLnNlbmQoJ292ZXJyaWRlQ29tcG9uZW50RmlsdGVycycsIHNhdmVkQ29tcG9uZW50RmlsdGVycyk7XG4gICAgfSAvLyBUT0RPIChucG0tcGFja2FnZXMpIFdhcm4gaWYgXCJpc0JhY2tlbmRTdG9yYWdlQVBJU3VwcG9ydGVkXCJcblxuXG4gICAgdmFyIGFnZW50ID0gbmV3IGFnZW50X0FnZW50KGJyaWRnZSk7XG4gICAgYWdlbnQuYWRkTGlzdGVuZXIoJ3NodXRkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgLy8gSWYgd2UgcmVjZWl2ZWQgJ3NodXRkb3duJyBmcm9tIGBhZ2VudGAsIHdlIGFzc3VtZSB0aGUgYGJyaWRnZWAgaXMgYWxyZWFkeSBzaHV0dGluZyBkb3duLFxuICAgICAgLy8gYW5kIHRoYXQgY2F1c2VkIHRoZSAnc2h1dGRvd24nIGV2ZW50IG9uIHRoZSBgYWdlbnRgLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGNhbGwgYGJyaWRnZS5zaHV0ZG93bigpYCBoZXJlLlxuICAgICAgYmFja2VuZF9ob29rLmVtaXQoJ3NodXRkb3duJyk7XG4gICAgfSk7XG4gICAgaW5pdEJhY2tlbmQoYmFja2VuZF9ob29rLCBhZ2VudCwgd2luZG93KTsgLy8gU2V0dXAgUmVhY3QgTmF0aXZlIHN0eWxlIGVkaXRvciBpZiB0aGUgZW52aXJvbm1lbnQgc3VwcG9ydHMgaXQuXG5cbiAgICBpZiAocmVzb2x2ZVJOU3R5bGUgIT0gbnVsbCB8fCBiYWNrZW5kX2hvb2sucmVzb2x2ZVJOU3R5bGUgIT0gbnVsbCkge1xuICAgICAgc2V0dXBOYXRpdmVTdHlsZUVkaXRvcihicmlkZ2UsIGFnZW50LCByZXNvbHZlUk5TdHlsZSB8fCBiYWNrZW5kX2hvb2sucmVzb2x2ZVJOU3R5bGUsIG5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzIHx8IGJhY2tlbmRfaG9vay5uYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcyB8fCBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gT3RoZXJ3aXNlIGxpc3RlbiB0byBkZXRlY3QgaWYgdGhlIGVudmlyb25tZW50IGxhdGVyIHN1cHBvcnRzIGl0LlxuICAgICAgLy8gRm9yIGV4YW1wbGUsIEZsaXBwZXIgZG9lcyBub3QgZWFnZXJseSBpbmplY3QgdGhlc2UgdmFsdWVzLlxuICAgICAgLy8gSW5zdGVhZCBpdCByZWxpZXMgb24gdGhlIFJlYWN0IE5hdGl2ZSBJbnNwZWN0b3IgdG8gbGF6aWx5IGluamVjdCB0aGVtLlxuICAgICAgdmFyIGxhenlSZXNvbHZlUk5TdHlsZTtcbiAgICAgIHZhciBsYXp5TmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXM7XG5cbiAgICAgIHZhciBpbml0QWZ0ZXJUaWNrID0gZnVuY3Rpb24gaW5pdEFmdGVyVGljaygpIHtcbiAgICAgICAgaWYgKGJyaWRnZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNldHVwTmF0aXZlU3R5bGVFZGl0b3IoYnJpZGdlLCBhZ2VudCwgbGF6eVJlc29sdmVSTlN0eWxlLCBsYXp5TmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWJhY2tlbmRfaG9vay5oYXNPd25Qcm9wZXJ0eSgncmVzb2x2ZVJOU3R5bGUnKSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYmFja2VuZF9ob29rLCAncmVzb2x2ZVJOU3R5bGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF6eVJlc29sdmVSTlN0eWxlO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgICAgICAgIGxhenlSZXNvbHZlUk5TdHlsZSA9IHZhbHVlO1xuICAgICAgICAgICAgaW5pdEFmdGVyVGljaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYmFja2VuZF9ob29rLmhhc093blByb3BlcnR5KCduYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcycpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiYWNrZW5kX2hvb2ssICduYXRpdmVTdHlsZUVkaXRvclZhbGlkQXR0cmlidXRlcycsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXp5TmF0aXZlU3R5bGVFZGl0b3JWYWxpZEF0dHJpYnV0ZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgbGF6eU5hdGl2ZVN0eWxlRWRpdG9yVmFsaWRBdHRyaWJ1dGVzID0gdmFsdWU7XG4gICAgICAgICAgICBpbml0QWZ0ZXJUaWNrKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2xvc2UoKSB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgYmFja2VuZF9kZWJ1ZygnV2ViU29ja2V0Lm9uY2xvc2UnKTtcbiAgICB9XG5cbiAgICBpZiAoYnJpZGdlICE9PSBudWxsKSB7XG4gICAgICBicmlkZ2UuZW1pdCgnc2h1dGRvd24nKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVJldHJ5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVGYWlsZWQoKSB7XG4gICAgaWYgKF9fREVCVUdfXykge1xuICAgICAgYmFja2VuZF9kZWJ1ZygnV2ViU29ja2V0Lm9uZXJyb3InKTtcbiAgICB9XG5cbiAgICBzY2hlZHVsZVJldHJ5KCk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2ZW50KSB7XG4gICAgdmFyIGRhdGE7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiBldmVudC5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShldmVudC5kYXRhKTtcblxuICAgICAgICBpZiAoX19ERUJVR19fKSB7XG4gICAgICAgICAgYmFja2VuZF9kZWJ1ZygnV2ViU29ja2V0Lm9ubWVzc2FnZScsIGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tSZWFjdCBEZXZUb29sc10gRmFpbGVkIHRvIHBhcnNlIEpTT046ICcgKyBldmVudC5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXNzYWdlTGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmbihkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIC8vIGpzYyBkb2Vzbid0IHBsYXkgc28gd2VsbCB3aXRoIHRyYWNlYmFja3MgdGhhdCBnbyBpbnRvIGV2YWwnZCBjb2RlLFxuICAgICAgICAvLyBzbyB0aGUgc3RhY2sgdHJhY2UgaGVyZSB3aWxsIHN0b3AgYXQgdGhlIGAoMCxldmFsKSgpYCBjYWxsLiBHZXR0aW5nIHRoZVxuICAgICAgICAvLyBtZXNzYWdlIHRoYXQgY2F1c2VkIHRoZSBlcnJvciBpcyB0aGUgYmVzdCB3ZSBjYW4gZG8gZm9yIG5vdy5cbiAgICAgICAgY29uc29sZS5sb2coJ1tSZWFjdCBEZXZUb29sc10gRXJyb3IgY2FsbGluZyBsaXN0ZW5lcicsIGRhdGEpO1xuICAgICAgICBjb25zb2xlLmxvZygnZXJyb3I6JywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhY2tlbmQuanMubWFwIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAZmxvd1xuICovXG5cbmNvbnN0IHtjb25uZWN0VG9EZXZUb29sc30gPSByZXF1aXJlKCdyZWFjdC1kZXZ0b29scy1jb3JlL2JhY2tlbmQnKTtcblxuLy8gQ29ubmVjdCBpbW1lZGlhdGVseSB3aXRoIGRlZmF1bHQgb3B0aW9ucy5cbi8vIElmIHlvdSBuZWVkIG1vcmUgY29udHJvbCwgdXNlIGByZWFjdC1kZXZ0b29scy1jb3JlYCBkaXJlY3RseSBpbnN0ZWFkIG9mIGByZWFjdC1kZXZ0b29sc2AuXG5jb25uZWN0VG9EZXZUb29scygpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGlzY291bnRfbG9kYXNoXzEgPSByZXF1aXJlKFwiLi91dGlscy9kaXNjb3VudF9sb2Rhc2hcIik7XG5leHBvcnRzLmlzRmlyZWZveCA9IGRpc2NvdW50X2xvZGFzaF8xLm1lbW9pemUoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAvZmlyZWZveC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59KTtcbmV4cG9ydHMuaXNTYWZhcmkgPSBkaXNjb3VudF9sb2Rhc2hfMS5tZW1vaXplKGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJvb2xlYW4od2luZG93LnNhZmFyaSk7IH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGlzY291bnRfbG9kYXNoXzEgPSByZXF1aXJlKFwiLi91dGlscy9kaXNjb3VudF9sb2Rhc2hcIik7XG52YXIgRW50ZXJMZWF2ZUNvdW50ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRW50ZXJMZWF2ZUNvdW50ZXIoaXNOb2RlSW5Eb2N1bWVudCkge1xuICAgICAgICB0aGlzLmVudGVyZWQgPSBbXTtcbiAgICAgICAgdGhpcy5pc05vZGVJbkRvY3VtZW50ID0gaXNOb2RlSW5Eb2N1bWVudDtcbiAgICB9XG4gICAgRW50ZXJMZWF2ZUNvdW50ZXIucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24gKGVudGVyaW5nTm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJldmlvdXNMZW5ndGggPSB0aGlzLmVudGVyZWQubGVuZ3RoO1xuICAgICAgICB2YXIgaXNOb2RlRW50ZXJlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMuaXNOb2RlSW5Eb2N1bWVudChub2RlKSAmJlxuICAgICAgICAgICAgICAgICghbm9kZS5jb250YWlucyB8fCBub2RlLmNvbnRhaW5zKGVudGVyaW5nTm9kZSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVudGVyZWQgPSBkaXNjb3VudF9sb2Rhc2hfMS51bmlvbih0aGlzLmVudGVyZWQuZmlsdGVyKGlzTm9kZUVudGVyZWQpLCBbZW50ZXJpbmdOb2RlXSk7XG4gICAgICAgIHJldHVybiBwcmV2aW91c0xlbmd0aCA9PT0gMCAmJiB0aGlzLmVudGVyZWQubGVuZ3RoID4gMDtcbiAgICB9O1xuICAgIEVudGVyTGVhdmVDb3VudGVyLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChsZWF2aW5nTm9kZSkge1xuICAgICAgICB2YXIgcHJldmlvdXNMZW5ndGggPSB0aGlzLmVudGVyZWQubGVuZ3RoO1xuICAgICAgICB0aGlzLmVudGVyZWQgPSBkaXNjb3VudF9sb2Rhc2hfMS53aXRob3V0KHRoaXMuZW50ZXJlZC5maWx0ZXIodGhpcy5pc05vZGVJbkRvY3VtZW50KSwgbGVhdmluZ05vZGUpO1xuICAgICAgICByZXR1cm4gcHJldmlvdXNMZW5ndGggPiAwICYmIHRoaXMuZW50ZXJlZC5sZW5ndGggPT09IDA7XG4gICAgfTtcbiAgICBFbnRlckxlYXZlQ291bnRlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW50ZXJlZCA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIEVudGVyTGVhdmVDb3VudGVyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVudGVyTGVhdmVDb3VudGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEVudGVyTGVhdmVDb3VudGVyXzEgPSByZXF1aXJlKFwiLi9FbnRlckxlYXZlQ291bnRlclwiKTtcbnZhciBCcm93c2VyRGV0ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJEZXRlY3RvclwiKTtcbnZhciBPZmZzZXRVdGlsc18xID0gcmVxdWlyZShcIi4vT2Zmc2V0VXRpbHNcIik7XG52YXIgTmF0aXZlRHJhZ1NvdXJjZXNfMSA9IHJlcXVpcmUoXCIuL05hdGl2ZURyYWdTb3VyY2VzXCIpO1xudmFyIE5hdGl2ZVR5cGVzID0gcmVxdWlyZShcIi4vTmF0aXZlVHlwZXNcIik7XG52YXIgSFRNTDVCYWNrZW5kID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhUTUw1QmFja2VuZChtYW5hZ2VyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuc291cmNlUHJldmlld05vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb3VyY2VOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zb3VyY2VOb2RlT3B0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kcmFnU3RhcnRTb3VyY2VJZHMgPSBudWxsO1xuICAgICAgICB0aGlzLmRyb3BUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5kcmFnRW50ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlU291cmNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlSGFuZGxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmFsdEtleVByZXNzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tb3VzZU1vdmVUaW1lb3V0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmFzeW5jRW5kRHJhZ0ZyYW1lSWQgPSBudWxsO1xuICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gbnVsbDtcbiAgICAgICAgdGhpcy5nZXRTb3VyY2VDbGllbnRPZmZzZXQgPSBmdW5jdGlvbiAoc291cmNlSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPZmZzZXRVdGlsc18xLmdldE5vZGVDbGllbnRPZmZzZXQoX3RoaXMuc291cmNlTm9kZXMuZ2V0KHNvdXJjZUlkKSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW5kRHJhZ05hdGl2ZUl0ZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25zLmVuZERyYWcoKTtcbiAgICAgICAgICAgIF90aGlzLnJlZ2lzdHJ5LnJlbW92ZVNvdXJjZShfdGhpcy5jdXJyZW50TmF0aXZlSGFuZGxlKTtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMuY3VycmVudE5hdGl2ZVNvdXJjZSA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaXNOb2RlSW5Eb2N1bWVudCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGUgbm9kZSBlaXRoZXIgaW4gdGhlIG1haW4gZG9jdW1lbnQgb3IgaW4gdGhlIGN1cnJlbnQgY29udGV4dFxuICAgICAgICAgICAgcmV0dXJuICgoISFkb2N1bWVudCAmJiBkb2N1bWVudC5ib2R5LmNvbnRhaW5zKG5vZGUpKSB8fFxuICAgICAgICAgICAgICAgICghIV90aGlzLndpbmRvdyAmJiBfdGhpcy53aW5kb3cuZG9jdW1lbnQuYm9keS5jb250YWlucyhub2RlKSkpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBfdGhpcy5jdXJyZW50RHJhZ1NvdXJjZU5vZGU7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNOb2RlSW5Eb2N1bWVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyQ3VycmVudERyYWdTb3VyY2VOb2RlKCk7XG4gICAgICAgICAgICBfdGhpcy5kcmFnU3RhcnRTb3VyY2VJZHMgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGRyYWdTdGFydFNvdXJjZUlkcyA9IF90aGlzLmRyYWdTdGFydFNvdXJjZUlkcztcbiAgICAgICAgICAgIF90aGlzLmRyYWdTdGFydFNvdXJjZUlkcyA9IG51bGw7XG4gICAgICAgICAgICB2YXIgY2xpZW50T2Zmc2V0ID0gT2Zmc2V0VXRpbHNfMS5nZXRFdmVudENsaWVudE9mZnNldChlKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIGNyYXNoaW5nIGlmIHdlIG1pc3NlZCBhIGRyb3AgZXZlbnQgb3Igb3VyIHByZXZpb3VzIGRyYWcgZGllZFxuICAgICAgICAgICAgaWYgKF90aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEb24ndCBwdWJsaXNoIHRoZSBzb3VyY2UganVzdCB5ZXQgKHNlZSB3aHkgYmVsb3cpXG4gICAgICAgICAgICBfdGhpcy5hY3Rpb25zLmJlZ2luRHJhZyhkcmFnU3RhcnRTb3VyY2VJZHMgfHwgW10sIHtcbiAgICAgICAgICAgICAgICBwdWJsaXNoU291cmNlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBnZXRTb3VyY2VDbGllbnRPZmZzZXQ6IF90aGlzLmdldFNvdXJjZUNsaWVudE9mZnNldCxcbiAgICAgICAgICAgICAgICBjbGllbnRPZmZzZXQ6IGNsaWVudE9mZnNldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGRhdGFUcmFuc2ZlciA9IGUuZGF0YVRyYW5zZmVyO1xuICAgICAgICAgICAgdmFyIG5hdGl2ZVR5cGUgPSBOYXRpdmVEcmFnU291cmNlc18xLm1hdGNoTmF0aXZlSXRlbVR5cGUoZGF0YVRyYW5zZmVyKTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhVHJhbnNmZXIgJiYgdHlwZW9mIGRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGN1c3RvbSBkcmFnIGltYWdlIGlmIHVzZXIgc3BlY2lmaWVzIGl0LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBjaGlsZCBkcmFnIHNvdXJjZSByZWZ1c2VzIGRyYWcgYnV0IHBhcmVudCBhZ3JlZXMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSBwYXJlbnQncyBub2RlIGFzIGRyYWcgaW1hZ2UuIE5laXRoZXIgd29ya3MgaW4gSUUgdGhvdWdoLlxuICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlSWQgPSBfdGhpcy5tb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VOb2RlID0gX3RoaXMuc291cmNlTm9kZXMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRyYWdQcmV2aWV3ID0gX3RoaXMuc291cmNlUHJldmlld05vZGVzLmdldChzb3VyY2VJZCkgfHwgc291cmNlTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRyYWdQcmV2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5nZXRDdXJyZW50U291cmNlUHJldmlld05vZGVPcHRpb25zKCksIGFuY2hvclggPSBfYS5hbmNob3JYLCBhbmNob3JZID0gX2EuYW5jaG9yWSwgb2Zmc2V0WCA9IF9hLm9mZnNldFgsIG9mZnNldFkgPSBfYS5vZmZzZXRZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvclBvaW50ID0geyBhbmNob3JYOiBhbmNob3JYLCBhbmNob3JZOiBhbmNob3JZIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0UG9pbnQgPSB7IG9mZnNldFg6IG9mZnNldFgsIG9mZnNldFk6IG9mZnNldFkgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkcmFnUHJldmlld09mZnNldCA9IE9mZnNldFV0aWxzXzEuZ2V0RHJhZ1ByZXZpZXdPZmZzZXQoc291cmNlTm9kZSwgZHJhZ1ByZXZpZXcsIGNsaWVudE9mZnNldCwgYW5jaG9yUG9pbnQsIG9mZnNldFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoZHJhZ1ByZXZpZXcsIGRyYWdQcmV2aWV3T2Zmc2V0LngsIGRyYWdQcmV2aWV3T2Zmc2V0LnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggd29uJ3QgZHJhZyB3aXRob3V0IHNldHRpbmcgZGF0YVxuICAgICAgICAgICAgICAgICAgICBkYXRhVHJhbnNmZXIuc2V0RGF0YSgnYXBwbGljYXRpb24vanNvbicsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgTUlNRSB0eXBlcyBpbiBzZXREYXRhXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0b3JlIGRyYWcgc291cmNlIG5vZGUgc28gd2UgY2FuIGNoZWNrIHdoZXRoZXJcbiAgICAgICAgICAgICAgICAvLyBpdCBpcyByZW1vdmVkIGZyb20gRE9NIGFuZCB0cmlnZ2VyIGVuZERyYWcgbWFudWFsbHkuXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0Q3VycmVudERyYWdTb3VyY2VOb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAvLyBOb3cgd2UgYXJlIHJlYWR5IHRvIHB1Ymxpc2ggdGhlIGRyYWcgc291cmNlLi4gb3IgYXJlIHdlIG5vdD9cbiAgICAgICAgICAgICAgICB2YXIgY2FwdHVyZURyYWdnaW5nU3RhdGUgPSBfdGhpcy5nZXRDdXJyZW50U291cmNlUHJldmlld05vZGVPcHRpb25zKCkuY2FwdHVyZURyYWdnaW5nU3RhdGU7XG4gICAgICAgICAgICAgICAgaWYgKCFjYXB0dXJlRHJhZ2dpbmdTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc3VhbGx5IHdlIHdhbnQgdG8gcHVibGlzaCBpdCBpbiB0aGUgbmV4dCB0aWNrIHNvIHRoYXQgYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAvLyBpcyBhYmxlIHRvIHNjcmVlbnNob3QgdGhlIGN1cnJlbnQgKG5vdCB5ZXQgZHJhZ2dpbmcpIHN0YXRlLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCBhbHNvIG5lYXRseSBhdm9pZHMgYSBzaXR1YXRpb24gd2hlcmUgcmVuZGVyKCkgcmV0dXJucyBudWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBzYW1lIHRpY2sgZm9yIHRoZSBzb3VyY2UgZWxlbWVudCwgYW5kIGJyb3dzZXIgZnJlYWtzIG91dC5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5hY3Rpb25zLnB1Ymxpc2hEcmFnU291cmNlKCk7IH0sIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gc29tZSBjYXNlcyB0aGUgdXNlciBtYXkgd2FudCB0byBvdmVycmlkZSB0aGlzIGJlaGF2aW9yLCBlLmcuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIHdvcmsgYXJvdW5kIElFIG5vdCBzdXBwb3J0aW5nIGN1c3RvbSBkcmFnIHByZXZpZXdzLlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIHVzaW5nIGEgY3VzdG9tIGRyYWcgbGF5ZXIsIHRoZSBvbmx5IHdheSB0byBwcmV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBkZWZhdWx0IGRyYWcgcHJldmlldyBmcm9tIGRyYXdpbmcgaW4gSUUgaXMgdG8gc2NyZWVuc2hvdFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZHJhZ2dpbmcgc3RhdGUgaW4gd2hpY2ggdGhlIG5vZGUgaXRzZWxmIGhhcyB6ZXJvIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGhlaWdodC4gSW4gdGhpcyBjYXNlLCB0aG91Z2gsIHJldHVybmluZyBudWxsIGZyb20gcmVuZGVyKClcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBhYnJ1cHRseSBlbmQgdGhlIGRyYWdnaW5nLCB3aGljaCBpcyBub3Qgb2J2aW91cy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgcmVhc29uIHN1Y2ggYmVoYXZpb3IgaXMgc3RyaWN0bHkgb3B0LWluLlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3Rpb25zLnB1Ymxpc2hEcmFnU291cmNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobmF0aXZlVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIEEgbmF0aXZlIGl0ZW0gKHN1Y2ggYXMgVVJMKSBkcmFnZ2VkIGZyb20gaW5zaWRlIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIF90aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhVHJhbnNmZXIgJiZcbiAgICAgICAgICAgICAgICAhZGF0YVRyYW5zZmVyLnR5cGVzICYmXG4gICAgICAgICAgICAgICAgKChlLnRhcmdldCAmJiAhZS50YXJnZXQuaGFzQXR0cmlidXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAhZS50YXJnZXQuaGFzQXR0cmlidXRlKCdkcmFnZ2FibGUnKSkpIHtcbiAgICAgICAgICAgICAgICAvLyBMb29rcyBsaWtlIGEgU2FmYXJpIGJ1ZzogZGF0YVRyYW5zZmVyLnR5cGVzIGlzIG51bGwsIGJ1dCB0aGVyZSB3YXMgbm8gZHJhZ2dhYmxlLlxuICAgICAgICAgICAgICAgIC8vIEp1c3QgbGV0IGl0IGRyYWcuIEl0J3MgYSBuYXRpdmUgdHlwZSAoVVJMIG9yIHRleHQpIGFuZCB3aWxsIGJlIHBpY2tlZCB1cCBpblxuICAgICAgICAgICAgICAgIC8vIGRyYWdlbnRlciBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIGJ5IHRoaXMgdGltZSBubyBkcmFnIHNvdXJjZSByZWFjdGVkLCB0ZWxsIGJyb3dzZXIgbm90IHRvIGRyYWcuXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvcERyYWdFbmRDYXB0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmNsZWFyQ3VycmVudERyYWdTb3VyY2VOb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IGNhbiBkaXNwYXRjaCB0aGlzIGV2ZW50IGluIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICAvLyBpZiBkcmFnZW5kIGhhbmRsZXIgZG9lcyBzb21ldGhpbmcgbGlrZSBzaG93aW5nIGFuIGFsZXJ0LlxuICAgICAgICAgICAgICAgIC8vIE9ubHkgcHJvY2VlZCBpZiB3ZSBoYXZlIG5vdCBoYW5kbGVkIGl0IGFscmVhZHkuXG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aW9ucy5lbmREcmFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ0VudGVyQ2FwdHVyZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5kcmFnRW50ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBpc0ZpcnN0RW50ZXIgPSBfdGhpcy5lbnRlckxlYXZlQ291bnRlci5lbnRlcihlLnRhcmdldCk7XG4gICAgICAgICAgICBpZiAoIWlzRmlyc3RFbnRlciB8fCBfdGhpcy5tb25pdG9yLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhVHJhbnNmZXIgPSBlLmRhdGFUcmFuc2ZlcjtcbiAgICAgICAgICAgIHZhciBuYXRpdmVUeXBlID0gTmF0aXZlRHJhZ1NvdXJjZXNfMS5tYXRjaE5hdGl2ZUl0ZW1UeXBlKGRhdGFUcmFuc2Zlcik7XG4gICAgICAgICAgICBpZiAobmF0aXZlVHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIEEgbmF0aXZlIGl0ZW0gKHN1Y2ggYXMgZmlsZSBvciBVUkwpIGRyYWdnZWQgZnJvbSBvdXRzaWRlIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgIF90aGlzLmJlZ2luRHJhZ05hdGl2ZUl0ZW0obmF0aXZlVHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ0VudGVyID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcmFnRW50ZXJUYXJnZXRJZHMgPSBfdGhpcy5kcmFnRW50ZXJUYXJnZXRJZHM7XG4gICAgICAgICAgICBfdGhpcy5kcmFnRW50ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghX3RoaXMubW9uaXRvci5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGEgbmF0aXZlIGl0ZW0gdHlwZSB3ZSBkb24ndCB1bmRlcnN0YW5kLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmFsdEtleVByZXNzZWQgPSBlLmFsdEtleTtcbiAgICAgICAgICAgIGlmICghQnJvd3NlckRldGVjdG9yXzEuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBlbWl0IGhvdmVyIGluIGBkcmFnZW50ZXJgIG9uIEZpcmVmb3ggZHVlIHRvIGFuIGVkZ2UgY2FzZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGNoYW5nZXMgcG9zaXRpb24gYXMgdGhlIHJlc3VsdCBvZiBgZHJhZ2VudGVyYCwgRmlyZWZveFxuICAgICAgICAgICAgICAgIC8vIHdpbGwgc3RpbGwgaGFwcGlseSBkaXNwYXRjaCBgZHJhZ292ZXJgIGRlc3BpdGUgdGFyZ2V0IGJlaW5nIG5vIGxvbmdlclxuICAgICAgICAgICAgICAgIC8vIHRoZXJlLiBUaGUgZWFzeSBzb2x1dGlvbiBpcyB0byBvbmx5IGZpcmUgYGhvdmVyYCBpbiBgZHJhZ292ZXJgIG9uIEZGLlxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGlvbnMuaG92ZXIoZHJhZ0VudGVyVGFyZ2V0SWRzLCB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogT2Zmc2V0VXRpbHNfMS5nZXRFdmVudENsaWVudE9mZnNldChlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjYW5Ecm9wID0gZHJhZ0VudGVyVGFyZ2V0SWRzLnNvbWUoZnVuY3Rpb24gKHRhcmdldElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNhbkRyb3ApIHtcbiAgICAgICAgICAgICAgICAvLyBJRSByZXF1aXJlcyB0aGlzIHRvIGZpcmUgZHJhZ292ZXIgZXZlbnRzXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gX3RoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ092ZXJDYXB0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcmFnT3ZlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ092ZXJUYXJnZXRJZHMgPSBfdGhpcy5kcmFnT3ZlclRhcmdldElkcztcbiAgICAgICAgICAgIF90aGlzLmRyYWdPdmVyVGFyZ2V0SWRzID0gW107XG4gICAgICAgICAgICBpZiAoIV90aGlzLm1vbml0b3IuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBhIG5hdGl2ZSBpdGVtIHR5cGUgd2UgZG9uJ3QgdW5kZXJzdGFuZC5cbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgXCJkcm9wIGFuZCBibG93IGF3YXkgdGhlIHdob2xlIGRvY3VtZW50XCIgYWN0aW9uLlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuYWx0S2V5UHJlc3NlZCA9IGUuYWx0S2V5O1xuICAgICAgICAgICAgX3RoaXMuYWN0aW9ucy5ob3ZlcihkcmFnT3ZlclRhcmdldElkcyB8fCBbXSwge1xuICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogT2Zmc2V0VXRpbHNfMS5nZXRFdmVudENsaWVudE9mZnNldChlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGNhbkRyb3AgPSAoZHJhZ092ZXJUYXJnZXRJZHMgfHwgW10pLnNvbWUoZnVuY3Rpb24gKHRhcmdldElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1vbml0b3IuY2FuRHJvcE9uVGFyZ2V0KHRhcmdldElkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNhbkRyb3ApIHtcbiAgICAgICAgICAgICAgICAvLyBTaG93IHVzZXItc3BlY2lmaWVkIGRyb3AgZWZmZWN0LlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IF90aGlzLmdldEN1cnJlbnREcm9wRWZmZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHNob3cgYSBuaWNlIGN1cnNvciBidXQgc3RpbGwgcHJldmVudCBkZWZhdWx0XG4gICAgICAgICAgICAgICAgLy8gXCJkcm9wIGFuZCBibG93IGF3YXkgdGhlIHdob2xlIGRvY3VtZW50XCIgYWN0aW9uLlxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9ICdub25lJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJhZ0xlYXZlQ2FwdHVyZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBpc0xhc3RMZWF2ZSA9IF90aGlzLmVudGVyTGVhdmVDb3VudGVyLmxlYXZlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaXNMYXN0TGVhdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZ05hdGl2ZUl0ZW0oKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZERyYWdOYXRpdmVJdGVtKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlVG9wRHJvcENhcHR1cmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgX3RoaXMuZHJvcFRhcmdldElkcyA9IFtdO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRHJhZ2dpbmdOYXRpdmVJdGVtKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jdXJyZW50TmF0aXZlU291cmNlLm11dGF0ZUl0ZW1CeVJlYWRpbmdEYXRhVHJhbnNmZXIoZS5kYXRhVHJhbnNmZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW50ZXJMZWF2ZUNvdW50ZXIucmVzZXQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVUb3BEcm9wID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBkcm9wVGFyZ2V0SWRzID0gX3RoaXMuZHJvcFRhcmdldElkcztcbiAgICAgICAgICAgIF90aGlzLmRyb3BUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgICAgIF90aGlzLmFjdGlvbnMuaG92ZXIoZHJvcFRhcmdldElkcywge1xuICAgICAgICAgICAgICAgIGNsaWVudE9mZnNldDogT2Zmc2V0VXRpbHNfMS5nZXRFdmVudENsaWVudE9mZnNldChlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuYWN0aW9ucy5kcm9wKHsgZHJvcEVmZmVjdDogX3RoaXMuZ2V0Q3VycmVudERyb3BFZmZlY3QoKSB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZW5kRHJhZ05hdGl2ZUl0ZW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgLy8gT25seSBJRSByZXF1aXJlcyB1cyB0byBleHBsaWNpdGx5IHNheVxuICAgICAgICAgICAgLy8gd2Ugd2FudCBkcmFnIGRyb3Agb3BlcmF0aW9uIHRvIHN0YXJ0XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldC5kcmFnRHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElucHV0cyBhbmQgdGV4dGFyZWFzIHNob3VsZCBiZSBzZWxlY3RhYmxlXG4gICAgICAgICAgICBpZiAodGFyZ2V0LnRhZ05hbWUgPT09ICdJTlBVVCcgfHxcbiAgICAgICAgICAgICAgICB0YXJnZXQudGFnTmFtZSA9PT0gJ1NFTEVDVCcgfHxcbiAgICAgICAgICAgICAgICB0YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJyB8fFxuICAgICAgICAgICAgICAgIHRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBvdGhlciB0YXJnZXRzLCBhc2sgSUVcbiAgICAgICAgICAgIC8vIHRvIGVuYWJsZSBkcmFnIGFuZCBkcm9wXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB0YXJnZXQuZHJhZ0Ryb3AoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hY3Rpb25zID0gbWFuYWdlci5nZXRBY3Rpb25zKCk7XG4gICAgICAgIHRoaXMubW9uaXRvciA9IG1hbmFnZXIuZ2V0TW9uaXRvcigpO1xuICAgICAgICB0aGlzLnJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBtYW5hZ2VyLmdldENvbnRleHQoKTtcbiAgICAgICAgdGhpcy5lbnRlckxlYXZlQ291bnRlciA9IG5ldyBFbnRlckxlYXZlQ291bnRlcl8xLmRlZmF1bHQodGhpcy5pc05vZGVJbkRvY3VtZW50KTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUw1QmFja2VuZC5wcm90b3R5cGUsIFwid2luZG93XCIsIHtcbiAgICAgICAgLy8gcHVibGljIGZvciB0ZXN0XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGV4dCAmJiB0aGlzLmNvbnRleHQud2luZG93KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC53aW5kb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53aW5kb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLndpbmRvdy5fX2lzUmVhY3REbmRCYWNrZW5kU2V0VXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGhhdmUgdHdvIEhUTUw1IGJhY2tlbmRzIGF0IHRoZSBzYW1lIHRpbWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53aW5kb3cuX19pc1JlYWN0RG5kQmFja2VuZFNldFVwID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycyh0aGlzLndpbmRvdyk7XG4gICAgfTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLnRlYXJkb3duID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy53aW5kb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2luZG93Ll9faXNSZWFjdERuZEJhY2tlbmRTZXRVcCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMud2luZG93KTtcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICBpZiAodGhpcy5hc3luY0VuZERyYWdGcmFtZUlkKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFzeW5jRW5kRHJhZ0ZyYW1lSWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLmNvbm5lY3REcmFnUHJldmlldyA9IGZ1bmN0aW9uIChzb3VyY2VJZCwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2RlT3B0aW9ucy5zZXQoc291cmNlSWQsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNvdXJjZVByZXZpZXdOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc291cmNlUHJldmlld05vZGVzLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICBfdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuZGVsZXRlKHNvdXJjZUlkKTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEhUTUw1QmFja2VuZC5wcm90b3R5cGUuY29ubmVjdERyYWdTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSWQsIG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zb3VyY2VOb2Rlcy5zZXQoc291cmNlSWQsIG5vZGUpO1xuICAgICAgICB0aGlzLnNvdXJjZU5vZGVPcHRpb25zLnNldChzb3VyY2VJZCwgb3B0aW9ucyk7XG4gICAgICAgIHZhciBoYW5kbGVEcmFnU3RhcnQgPSBmdW5jdGlvbiAoZSkgeyByZXR1cm4gX3RoaXMuaGFuZGxlRHJhZ1N0YXJ0KGUsIHNvdXJjZUlkKTsgfTtcbiAgICAgICAgdmFyIGhhbmRsZVNlbGVjdFN0YXJ0ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmhhbmRsZVNlbGVjdFN0YXJ0KGUpOyB9O1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZHJhZ2dhYmxlJywgJ3RydWUnKTtcbiAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCBoYW5kbGVEcmFnU3RhcnQpO1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgaGFuZGxlU2VsZWN0U3RhcnQpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc291cmNlTm9kZXMuZGVsZXRlKHNvdXJjZUlkKTtcbiAgICAgICAgICAgIF90aGlzLnNvdXJjZU5vZGVPcHRpb25zLmRlbGV0ZShzb3VyY2VJZCk7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIGhhbmRsZURyYWdTdGFydCk7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgaGFuZGxlU2VsZWN0U3RhcnQpO1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScsICdmYWxzZScpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgSFRNTDVCYWNrZW5kLnByb3RvdHlwZS5jb25uZWN0RHJvcFRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXRJZCwgbm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGFuZGxlRHJhZ0VudGVyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmhhbmRsZURyYWdFbnRlcihlLCB0YXJnZXRJZCk7IH07XG4gICAgICAgIHZhciBoYW5kbGVEcmFnT3ZlciA9IGZ1bmN0aW9uIChlKSB7IHJldHVybiBfdGhpcy5oYW5kbGVEcmFnT3ZlcihlLCB0YXJnZXRJZCk7IH07XG4gICAgICAgIHZhciBoYW5kbGVEcm9wID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIF90aGlzLmhhbmRsZURyb3AoZSwgdGFyZ2V0SWQpOyB9O1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIGhhbmRsZURyYWdFbnRlcik7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBoYW5kbGVEcmFnT3Zlcik7XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIGhhbmRsZURyb3ApO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCBoYW5kbGVEcmFnRW50ZXIpO1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnb3ZlcicsIGhhbmRsZURyYWdPdmVyKTtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJvcCcsIGhhbmRsZURyb3ApO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgSFRNTDVCYWNrZW5kLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgLy8gU1NSIEZpeCAoaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0LWRuZC9yZWFjdC1kbmQvcHVsbC84MTNcbiAgICAgICAgaWYgKCF0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnc3RhcnQnLCB0aGlzXG4gICAgICAgICAgICAuaGFuZGxlVG9wRHJhZ1N0YXJ0KTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzXG4gICAgICAgICAgICAuaGFuZGxlVG9wRHJhZ0VudGVyKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ0VudGVyQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCB0aGlzLmhhbmRsZVRvcERyYWdMZWF2ZUNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdPdmVyKTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdvdmVyJywgdGhpcy5oYW5kbGVUb3BEcmFnT3ZlckNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZHJvcCcsIHRoaXMuaGFuZGxlVG9wRHJvcCk7XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5oYW5kbGVUb3BEcm9wQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgfTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgICAvLyBTU1IgRml4IChodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9wdWxsLzgxM1xuICAgICAgICBpZiAoIXRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0KTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuaGFuZGxlVG9wRHJhZ1N0YXJ0Q2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgdGhpcy5oYW5kbGVUb3BEcmFnRW5kQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW50ZXInLCB0aGlzXG4gICAgICAgICAgICAuaGFuZGxlVG9wRHJhZ0VudGVyKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdlbnRlcicsIHRoaXMuaGFuZGxlVG9wRHJhZ0VudGVyQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnbGVhdmUnLCB0aGlzLmhhbmRsZVRvcERyYWdMZWF2ZUNhcHR1cmUsIHRydWUpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzXG4gICAgICAgICAgICAuaGFuZGxlVG9wRHJhZ092ZXIpO1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCB0aGlzLmhhbmRsZVRvcERyYWdPdmVyQ2FwdHVyZSwgdHJ1ZSk7XG4gICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdkcm9wJywgdGhpcy5oYW5kbGVUb3BEcm9wKTtcbiAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCB0aGlzLmhhbmRsZVRvcERyb3BDYXB0dXJlLCB0cnVlKTtcbiAgICB9O1xuICAgIEhUTUw1QmFja2VuZC5wcm90b3R5cGUuZ2V0Q3VycmVudFNvdXJjZU5vZGVPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlSWQgPSB0aGlzLm1vbml0b3IuZ2V0U291cmNlSWQoKTtcbiAgICAgICAgdmFyIHNvdXJjZU5vZGVPcHRpb25zID0gdGhpcy5zb3VyY2VOb2RlT3B0aW9ucy5nZXQoc291cmNlSWQpO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oeyBkcm9wRWZmZWN0OiB0aGlzLmFsdEtleVByZXNzZWQgPyAnY29weScgOiAnbW92ZScgfSwgKHNvdXJjZU5vZGVPcHRpb25zIHx8IHt9KSk7XG4gICAgfTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLmdldEN1cnJlbnREcm9wRWZmZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nTmF0aXZlSXRlbSgpKSB7XG4gICAgICAgICAgICAvLyBJdCBtYWtlcyBtb3JlIHNlbnNlIHRvIGRlZmF1bHQgdG8gJ2NvcHknIGZvciBuYXRpdmUgcmVzb3VyY2VzXG4gICAgICAgICAgICByZXR1cm4gJ2NvcHknO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnRTb3VyY2VOb2RlT3B0aW9ucygpLmRyb3BFZmZlY3Q7XG4gICAgfTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLmdldEN1cnJlbnRTb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3VyY2VJZCA9IHRoaXMubW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgICAgICB2YXIgc291cmNlUHJldmlld05vZGVPcHRpb25zID0gdGhpcy5zb3VyY2VQcmV2aWV3Tm9kZU9wdGlvbnMuZ2V0KHNvdXJjZUlkKTtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgYW5jaG9yWDogMC41LCBhbmNob3JZOiAwLjUsIGNhcHR1cmVEcmFnZ2luZ1N0YXRlOiBmYWxzZSB9LCAoc291cmNlUHJldmlld05vZGVPcHRpb25zIHx8IHt9KSk7XG4gICAgfTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLmlzRHJhZ2dpbmdOYXRpdmVJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbVR5cGUgPSB0aGlzLm1vbml0b3IuZ2V0SXRlbVR5cGUoKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKE5hdGl2ZVR5cGVzKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIE5hdGl2ZVR5cGVzW2tleV0gPT09IGl0ZW1UeXBlOyB9KTtcbiAgICB9O1xuICAgIEhUTUw1QmFja2VuZC5wcm90b3R5cGUuYmVnaW5EcmFnTmF0aXZlSXRlbSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHRoaXMuY2xlYXJDdXJyZW50RHJhZ1NvdXJjZU5vZGUoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50TmF0aXZlU291cmNlID0gTmF0aXZlRHJhZ1NvdXJjZXNfMS5jcmVhdGVOYXRpdmVEcmFnU291cmNlKHR5cGUpO1xuICAgICAgICB0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGUgPSB0aGlzLnJlZ2lzdHJ5LmFkZFNvdXJjZSh0eXBlLCB0aGlzLmN1cnJlbnROYXRpdmVTb3VyY2UpO1xuICAgICAgICB0aGlzLmFjdGlvbnMuYmVnaW5EcmFnKFt0aGlzLmN1cnJlbnROYXRpdmVIYW5kbGVdKTtcbiAgICB9O1xuICAgIEhUTUw1QmFja2VuZC5wcm90b3R5cGUuc2V0Q3VycmVudERyYWdTb3VyY2VOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSgpO1xuICAgICAgICB0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSA9IG5vZGU7XG4gICAgICAgIC8vIEEgdGltZW91dCBvZiA+IDAgaXMgbmVjZXNzYXJ5IHRvIHJlc29sdmUgRmlyZWZveCBpc3N1ZSByZWZlcmVuY2VkXG4gICAgICAgIC8vIFNlZTpcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL3B1bGwvOTI4XG4gICAgICAgIC8vICAgKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvODY5XG4gICAgICAgIHZhciBNT1VTRV9NT1ZFX1RJTUVPVVQgPSAxMDAwO1xuICAgICAgICAvLyBSZWNlaXZpbmcgYSBtb3VzZSBldmVudCBpbiB0aGUgbWlkZGxlIG9mIGEgZHJhZ2dpbmcgb3BlcmF0aW9uXG4gICAgICAgIC8vIG1lYW5zIGl0IGhhcyBlbmRlZCBhbmQgdGhlIGRyYWcgc291cmNlIG5vZGUgZGlzYXBwZWFyZWQgZnJvbSBET00sXG4gICAgICAgIC8vIHNvIHRoZSBicm93c2VyIGRpZG4ndCBkaXNwYXRjaCB0aGUgZHJhZ2VuZCBldmVudC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgbmVlZCB0byB3YWl0IGJlZm9yZSB3ZSBzdGFydCBsaXN0ZW5pbmcgZm9yIG1vdXNlbW92ZSBldmVudHMuXG4gICAgICAgIC8vIFRoaXMgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGRyYWcgcHJldmlldyBuZWVkcyB0byBiZSBkcmF3biBvciBlbHNlIGl0IGZpcmVzIGFuICdtb3VzZW1vdmUnIGV2ZW50XG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IGluIHNvbWUgYnJvd3NlcnMuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNlZTpcbiAgICAgICAgLy8gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdC1kbmQvcmVhY3QtZG5kL3B1bGwvOTI4XG4gICAgICAgIC8vICAgKiBodHRwczovL2dpdGh1Yi5jb20vcmVhY3QtZG5kL3JlYWN0LWRuZC9pc3N1ZXMvODY5XG4gICAgICAgIC8vXG4gICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKF90aGlzLndpbmRvdyAmJlxuICAgICAgICAgICAgICAgIF90aGlzLndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfdGhpcy5lbmREcmFnSWZTb3VyY2VXYXNSZW1vdmVkRnJvbURPTSwgdHJ1ZSkpO1xuICAgICAgICB9LCBNT1VTRV9NT1ZFX1RJTUVPVVQpO1xuICAgIH07XG4gICAgSFRNTDVCYWNrZW5kLnByb3RvdHlwZS5jbGVhckN1cnJlbnREcmFnU291cmNlTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWdTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmFnU291cmNlTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodGhpcy53aW5kb3cpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5tb3VzZU1vdmVUaW1lb3V0VGltZXIgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB0aGlzLndpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLmVuZERyYWdJZlNvdXJjZVdhc1JlbW92ZWRGcm9tRE9NLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubW91c2VNb3ZlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIEhUTUw1QmFja2VuZC5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGUsIHNvdXJjZUlkKSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnU3RhcnRTb3VyY2VJZHMpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0U291cmNlSWRzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kcmFnU3RhcnRTb3VyY2VJZHMudW5zaGlmdChzb3VyY2VJZCk7XG4gICAgfTtcbiAgICBIVE1MNUJhY2tlbmQucHJvdG90eXBlLmhhbmRsZURyYWdFbnRlciA9IGZ1bmN0aW9uIChlLCB0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLmRyYWdFbnRlclRhcmdldElkcy51bnNoaWZ0KHRhcmdldElkKTtcbiAgICB9O1xuICAgIEhUTUw1QmFja2VuZC5wcm90b3R5cGUuaGFuZGxlRHJhZ092ZXIgPSBmdW5jdGlvbiAoZSwgdGFyZ2V0SWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ092ZXJUYXJnZXRJZHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdPdmVyVGFyZ2V0SWRzLnVuc2hpZnQodGFyZ2V0SWQpO1xuICAgIH07XG4gICAgSFRNTDVCYWNrZW5kLnByb3RvdHlwZS5oYW5kbGVEcm9wID0gZnVuY3Rpb24gKGUsIHRhcmdldElkKSB7XG4gICAgICAgIHRoaXMuZHJvcFRhcmdldElkcy51bnNoaWZ0KHRhcmdldElkKTtcbiAgICB9O1xuICAgIHJldHVybiBIVE1MNUJhY2tlbmQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gSFRNTDVCYWNrZW5kO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTW9ub3RvbmljSW50ZXJwb2xhbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTW9ub3RvbmljSW50ZXJwb2xhbnQoeHMsIHlzKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSB4cy5sZW5ndGg7XG4gICAgICAgIC8vIFJlYXJyYW5nZSB4cyBhbmQgeXMgc28gdGhhdCB4cyBpcyBzb3J0ZWRcbiAgICAgICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gKHhzW2FdIDwgeHNbYl0gPyAtMSA6IDEpOyB9KTtcbiAgICAgICAgLy8gR2V0IGNvbnNlY3V0aXZlIGRpZmZlcmVuY2VzIGFuZCBzbG9wZXNcbiAgICAgICAgdmFyIGR5cyA9IFtdO1xuICAgICAgICB2YXIgZHhzID0gW107XG4gICAgICAgIHZhciBtcyA9IFtdO1xuICAgICAgICB2YXIgZHg7XG4gICAgICAgIHZhciBkeTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGR4ID0geHNbaSArIDFdIC0geHNbaV07XG4gICAgICAgICAgICBkeSA9IHlzW2kgKyAxXSAtIHlzW2ldO1xuICAgICAgICAgICAgZHhzLnB1c2goZHgpO1xuICAgICAgICAgICAgZHlzLnB1c2goZHkpO1xuICAgICAgICAgICAgbXMucHVzaChkeSAvIGR4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgZGVncmVlLTEgY29lZmZpY2llbnRzXG4gICAgICAgIHZhciBjMXMgPSBbbXNbMF1dO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR4cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtMiA9IG1zW2ldO1xuICAgICAgICAgICAgdmFyIG1OZXh0ID0gbXNbaSArIDFdO1xuICAgICAgICAgICAgaWYgKG0yICogbU5leHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIGMxcy5wdXNoKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZHggPSBkeHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGR4TmV4dCA9IGR4c1tpICsgMV07XG4gICAgICAgICAgICAgICAgdmFyIGNvbW1vbiA9IGR4ICsgZHhOZXh0O1xuICAgICAgICAgICAgICAgIGMxcy5wdXNoKDMgKiBjb21tb24gLyAoKGNvbW1vbiArIGR4TmV4dCkgLyBtMiArIChjb21tb24gKyBkeCkgLyBtTmV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGMxcy5wdXNoKG1zW21zLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgLy8gR2V0IGRlZ3JlZS0yIGFuZCBkZWdyZWUtMyBjb2VmZmljaWVudHNcbiAgICAgICAgdmFyIGMycyA9IFtdO1xuICAgICAgICB2YXIgYzNzID0gW107XG4gICAgICAgIHZhciBtO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGMxcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIG0gPSBtc1tpXTtcbiAgICAgICAgICAgIHZhciBjMSA9IGMxc1tpXTtcbiAgICAgICAgICAgIHZhciBpbnZEeCA9IDEgLyBkeHNbaV07XG4gICAgICAgICAgICB2YXIgY29tbW9uID0gYzEgKyBjMXNbaSArIDFdIC0gbSAtIG07XG4gICAgICAgICAgICBjMnMucHVzaCgobSAtIGMxIC0gY29tbW9uKSAqIGludkR4KTtcbiAgICAgICAgICAgIGMzcy5wdXNoKGNvbW1vbiAqIGludkR4ICogaW52RHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueHMgPSB4cztcbiAgICAgICAgdGhpcy55cyA9IHlzO1xuICAgICAgICB0aGlzLmMxcyA9IGMxcztcbiAgICAgICAgdGhpcy5jMnMgPSBjMnM7XG4gICAgICAgIHRoaXMuYzNzID0gYzNzO1xuICAgIH1cbiAgICBNb25vdG9uaWNJbnRlcnBvbGFudC5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB4cyA9IF9hLnhzLCB5cyA9IF9hLnlzLCBjMXMgPSBfYS5jMXMsIGMycyA9IF9hLmMycywgYzNzID0gX2EuYzNzO1xuICAgICAgICAvLyBUaGUgcmlnaHRtb3N0IHBvaW50IGluIHRoZSBkYXRhc2V0IHNob3VsZCBnaXZlIGFuIGV4YWN0IHJlc3VsdFxuICAgICAgICB2YXIgaSA9IHhzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICh4ID09PSB4c1tpXSkge1xuICAgICAgICAgICAgcmV0dXJuIHlzW2ldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgdGhlIGludGVydmFsIHggaXMgaW4sIHJldHVybmluZyB0aGUgY29ycmVzcG9uZGluZyB5IGlmIHggaXMgb25lIG9mIHRoZSBvcmlnaW5hbCB4c1xuICAgICAgICB2YXIgbG93ID0gMDtcbiAgICAgICAgdmFyIGhpZ2ggPSBjM3MubGVuZ3RoIC0gMTtcbiAgICAgICAgdmFyIG1pZDtcbiAgICAgICAgd2hpbGUgKGxvdyA8PSBoaWdoKSB7XG4gICAgICAgICAgICBtaWQgPSBNYXRoLmZsb29yKDAuNSAqIChsb3cgKyBoaWdoKSk7XG4gICAgICAgICAgICB2YXIgeEhlcmUgPSB4c1ttaWRdO1xuICAgICAgICAgICAgaWYgKHhIZXJlIDwgeCkge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4SGVyZSA+IHgpIHtcbiAgICAgICAgICAgICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB5c1ttaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkgPSBNYXRoLm1heCgwLCBoaWdoKTtcbiAgICAgICAgLy8gSW50ZXJwb2xhdGVcbiAgICAgICAgdmFyIGRpZmYgPSB4IC0geHNbaV07XG4gICAgICAgIHZhciBkaWZmU3EgPSBkaWZmICogZGlmZjtcbiAgICAgICAgcmV0dXJuIHlzW2ldICsgYzFzW2ldICogZGlmZiArIGMyc1tpXSAqIGRpZmZTcSArIGMzc1tpXSAqIGRpZmYgKiBkaWZmU3E7XG4gICAgfTtcbiAgICByZXR1cm4gTW9ub3RvbmljSW50ZXJwb2xhbnQ7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTW9ub3RvbmljSW50ZXJwb2xhbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBOYXRpdmVEcmFnU291cmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdGl2ZURyYWdTb3VyY2UoY29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgICAgICB0aGlzLml0ZW0gPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25maWcuZXhwb3NlUHJvcGVydGllcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpcy5pdGVtLCBwcm9wZXJ0eSwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJCcm93c2VyIGRvZXNuJ3QgYWxsb3cgcmVhZGluZyBcXFwiXCIgKyBwcm9wZXJ0eSArIFwiXFxcIiB1bnRpbCB0aGUgZHJvcCBldmVudC5cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIE5hdGl2ZURyYWdTb3VyY2UucHJvdG90eXBlLm11dGF0ZUl0ZW1CeVJlYWRpbmdEYXRhVHJhbnNmZXIgPSBmdW5jdGlvbiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdQcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGlmIChkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuY29uZmlnLmV4cG9zZVByb3BlcnRpZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgbmV3UHJvcGVydGllc1twcm9wZXJ0eV0gPSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdGhpcy5jb25maWcuZXhwb3NlUHJvcGVydGllc1twcm9wZXJ0eV0oZGF0YVRyYW5zZmVyLCBfdGhpcy5jb25maWcubWF0Y2hlc1R5cGVzKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGhpcy5pdGVtLCBuZXdQcm9wZXJ0aWVzKTtcbiAgICB9O1xuICAgIE5hdGl2ZURyYWdTb3VyY2UucHJvdG90eXBlLmNhbkRyYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgTmF0aXZlRHJhZ1NvdXJjZS5wcm90b3R5cGUuYmVnaW5EcmFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVtO1xuICAgIH07XG4gICAgTmF0aXZlRHJhZ1NvdXJjZS5wcm90b3R5cGUuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uIChtb25pdG9yLCBoYW5kbGUpIHtcbiAgICAgICAgcmV0dXJuIGhhbmRsZSA9PT0gbW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgIH07XG4gICAgTmF0aXZlRHJhZ1NvdXJjZS5wcm90b3R5cGUuZW5kRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gZW1wdHlcbiAgICB9O1xuICAgIHJldHVybiBOYXRpdmVEcmFnU291cmNlO1xufSgpKTtcbmV4cG9ydHMuTmF0aXZlRHJhZ1NvdXJjZSA9IE5hdGl2ZURyYWdTb3VyY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldERhdGFGcm9tRGF0YVRyYW5zZmVyKGRhdGFUcmFuc2ZlciwgdHlwZXNUb1RyeSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHR5cGVzVG9UcnkucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHRTb0ZhciwgdHlwZVRvVHJ5KSB7IHJldHVybiByZXN1bHRTb0ZhciB8fCBkYXRhVHJhbnNmZXIuZ2V0RGF0YSh0eXBlVG9UcnkpOyB9LCAnJyk7XG4gICAgcmV0dXJuIHJlc3VsdCAhPSBudWxsID8gcmVzdWx0IDogZGVmYXVsdFZhbHVlO1xufVxuZXhwb3J0cy5nZXREYXRhRnJvbURhdGFUcmFuc2ZlciA9IGdldERhdGFGcm9tRGF0YVRyYW5zZmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbmF0aXZlVHlwZXNDb25maWdfMSA9IHJlcXVpcmUoXCIuL25hdGl2ZVR5cGVzQ29uZmlnXCIpO1xudmFyIE5hdGl2ZURyYWdTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL05hdGl2ZURyYWdTb3VyY2VcIik7XG5mdW5jdGlvbiBjcmVhdGVOYXRpdmVEcmFnU291cmNlKHR5cGUpIHtcbiAgICByZXR1cm4gbmV3IE5hdGl2ZURyYWdTb3VyY2VfMS5OYXRpdmVEcmFnU291cmNlKG5hdGl2ZVR5cGVzQ29uZmlnXzEubmF0aXZlVHlwZXNDb25maWdbdHlwZV0pO1xufVxuZXhwb3J0cy5jcmVhdGVOYXRpdmVEcmFnU291cmNlID0gY3JlYXRlTmF0aXZlRHJhZ1NvdXJjZTtcbmZ1bmN0aW9uIG1hdGNoTmF0aXZlSXRlbVR5cGUoZGF0YVRyYW5zZmVyKSB7XG4gICAgaWYgKCFkYXRhVHJhbnNmZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBkYXRhVHJhbnNmZXJUeXBlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGFUcmFuc2Zlci50eXBlcyB8fCBbXSk7XG4gICAgcmV0dXJuIChPYmplY3Qua2V5cyhuYXRpdmVUeXBlc0NvbmZpZ18xLm5hdGl2ZVR5cGVzQ29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKG5hdGl2ZUl0ZW1UeXBlKSB7XG4gICAgICAgIHZhciBtYXRjaGVzVHlwZXMgPSBuYXRpdmVUeXBlc0NvbmZpZ18xLm5hdGl2ZVR5cGVzQ29uZmlnW25hdGl2ZUl0ZW1UeXBlXS5tYXRjaGVzVHlwZXM7XG4gICAgICAgIHJldHVybiBtYXRjaGVzVHlwZXMuc29tZShmdW5jdGlvbiAodCkgeyByZXR1cm4gZGF0YVRyYW5zZmVyVHlwZXMuaW5kZXhPZih0KSA+IC0xOyB9KTtcbiAgICB9KVswXSB8fCBudWxsKTtcbn1cbmV4cG9ydHMubWF0Y2hOYXRpdmVJdGVtVHlwZSA9IG1hdGNoTmF0aXZlSXRlbVR5cGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBfYTtcbnZhciBOYXRpdmVUeXBlcyA9IHJlcXVpcmUoXCIuLi9OYXRpdmVUeXBlc1wiKTtcbnZhciBnZXREYXRhRnJvbURhdGFUcmFuc2Zlcl8xID0gcmVxdWlyZShcIi4vZ2V0RGF0YUZyb21EYXRhVHJhbnNmZXJcIik7XG5leHBvcnRzLm5hdGl2ZVR5cGVzQ29uZmlnID0gKF9hID0ge30sXG4gICAgX2FbTmF0aXZlVHlwZXMuRklMRV0gPSB7XG4gICAgICAgIGV4cG9zZVByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGZpbGVzOiBmdW5jdGlvbiAoZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRhdGFUcmFuc2Zlci5maWxlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXRlbXM6IGZ1bmN0aW9uIChkYXRhVHJhbnNmZXIpIHsgcmV0dXJuIGRhdGFUcmFuc2Zlci5pdGVtczsgfSxcbiAgICAgICAgfSxcbiAgICAgICAgbWF0Y2hlc1R5cGVzOiBbJ0ZpbGVzJ10sXG4gICAgfSxcbiAgICBfYVtOYXRpdmVUeXBlcy5VUkxdID0ge1xuICAgICAgICBleHBvc2VQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICB1cmxzOiBmdW5jdGlvbiAoZGF0YVRyYW5zZmVyLCBtYXRjaGVzVHlwZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0RGF0YUZyb21EYXRhVHJhbnNmZXJfMS5nZXREYXRhRnJvbURhdGFUcmFuc2ZlcihkYXRhVHJhbnNmZXIsIG1hdGNoZXNUeXBlcywgJycpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIG1hdGNoZXNUeXBlczogWydVcmwnLCAndGV4dC91cmktbGlzdCddLFxuICAgIH0sXG4gICAgX2FbTmF0aXZlVHlwZXMuVEVYVF0gPSB7XG4gICAgICAgIGV4cG9zZVByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIHRleHQ6IGZ1bmN0aW9uIChkYXRhVHJhbnNmZXIsIG1hdGNoZXNUeXBlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXREYXRhRnJvbURhdGFUcmFuc2Zlcl8xLmdldERhdGFGcm9tRGF0YVRyYW5zZmVyKGRhdGFUcmFuc2ZlciwgbWF0Y2hlc1R5cGVzLCAnJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBtYXRjaGVzVHlwZXM6IFsnVGV4dCcsICd0ZXh0L3BsYWluJ10sXG4gICAgfSxcbiAgICBfYSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRklMRSA9ICdfX05BVElWRV9GSUxFX18nO1xuZXhwb3J0cy5VUkwgPSAnX19OQVRJVkVfVVJMX18nO1xuZXhwb3J0cy5URVhUID0gJ19fTkFUSVZFX1RFWFRfXyc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBCcm93c2VyRGV0ZWN0b3JfMSA9IHJlcXVpcmUoXCIuL0Jyb3dzZXJEZXRlY3RvclwiKTtcbnZhciBNb25vdG9uaWNJbnRlcnBvbGFudF8xID0gcmVxdWlyZShcIi4vTW9ub3RvbmljSW50ZXJwb2xhbnRcIik7XG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbmZ1bmN0aW9uIGdldE5vZGVDbGllbnRPZmZzZXQobm9kZSkge1xuICAgIHZhciBlbCA9IG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSA/IG5vZGUgOiBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgaWYgKCFlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIF9hID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRvcCA9IF9hLnRvcCwgbGVmdCA9IF9hLmxlZnQ7XG4gICAgcmV0dXJuIHsgeDogbGVmdCwgeTogdG9wIH07XG59XG5leHBvcnRzLmdldE5vZGVDbGllbnRPZmZzZXQgPSBnZXROb2RlQ2xpZW50T2Zmc2V0O1xuZnVuY3Rpb24gZ2V0RXZlbnRDbGllbnRPZmZzZXQoZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgeTogZS5jbGllbnRZLFxuICAgIH07XG59XG5leHBvcnRzLmdldEV2ZW50Q2xpZW50T2Zmc2V0ID0gZ2V0RXZlbnRDbGllbnRPZmZzZXQ7XG5mdW5jdGlvbiBpc0ltYWdlTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIChub2RlLm5vZGVOYW1lID09PSAnSU1HJyAmJlxuICAgICAgICAoQnJvd3NlckRldGVjdG9yXzEuaXNGaXJlZm94KCkgfHwgIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyhub2RlKSkpO1xufVxuZnVuY3Rpb24gZ2V0RHJhZ1ByZXZpZXdTaXplKGlzSW1hZ2UsIGRyYWdQcmV2aWV3LCBzb3VyY2VXaWR0aCwgc291cmNlSGVpZ2h0KSB7XG4gICAgdmFyIGRyYWdQcmV2aWV3V2lkdGggPSBpc0ltYWdlID8gZHJhZ1ByZXZpZXcud2lkdGggOiBzb3VyY2VXaWR0aDtcbiAgICB2YXIgZHJhZ1ByZXZpZXdIZWlnaHQgPSBpc0ltYWdlID8gZHJhZ1ByZXZpZXcuaGVpZ2h0IDogc291cmNlSGVpZ2h0O1xuICAgIC8vIFdvcmsgYXJvdW5kIEAyeCBjb29yZGluYXRlIGRpc2NyZXBhbmNpZXMgaW4gYnJvd3NlcnNcbiAgICBpZiAoQnJvd3NlckRldGVjdG9yXzEuaXNTYWZhcmkoKSAmJiBpc0ltYWdlKSB7XG4gICAgICAgIGRyYWdQcmV2aWV3SGVpZ2h0IC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBkcmFnUHJldmlld1dpZHRoIC89IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICByZXR1cm4geyBkcmFnUHJldmlld1dpZHRoOiBkcmFnUHJldmlld1dpZHRoLCBkcmFnUHJldmlld0hlaWdodDogZHJhZ1ByZXZpZXdIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIGdldERyYWdQcmV2aWV3T2Zmc2V0KHNvdXJjZU5vZGUsIGRyYWdQcmV2aWV3LCBjbGllbnRPZmZzZXQsIGFuY2hvclBvaW50LCBvZmZzZXRQb2ludCkge1xuICAgIC8vIFRoZSBicm93c2VycyB3aWxsIHVzZSB0aGUgaW1hZ2UgaW50cmluc2ljIHNpemUgdW5kZXIgZGlmZmVyZW50IGNvbmRpdGlvbnMuXG4gICAgLy8gRmlyZWZveCBvbmx5IGNhcmVzIGlmIGl0J3MgYW4gaW1hZ2UsIGJ1dCBXZWJLaXQgYWxzbyB3YW50cyBpdCB0byBiZSBkZXRhY2hlZC5cbiAgICB2YXIgaXNJbWFnZSA9IGlzSW1hZ2VOb2RlKGRyYWdQcmV2aWV3KTtcbiAgICB2YXIgZHJhZ1ByZXZpZXdOb2RlID0gaXNJbWFnZSA/IHNvdXJjZU5vZGUgOiBkcmFnUHJldmlldztcbiAgICB2YXIgZHJhZ1ByZXZpZXdOb2RlT2Zmc2V0RnJvbUNsaWVudCA9IGdldE5vZGVDbGllbnRPZmZzZXQoZHJhZ1ByZXZpZXdOb2RlKTtcbiAgICB2YXIgb2Zmc2V0RnJvbURyYWdQcmV2aWV3ID0ge1xuICAgICAgICB4OiBjbGllbnRPZmZzZXQueCAtIGRyYWdQcmV2aWV3Tm9kZU9mZnNldEZyb21DbGllbnQueCxcbiAgICAgICAgeTogY2xpZW50T2Zmc2V0LnkgLSBkcmFnUHJldmlld05vZGVPZmZzZXRGcm9tQ2xpZW50LnksXG4gICAgfTtcbiAgICB2YXIgc291cmNlV2lkdGggPSBzb3VyY2VOb2RlLm9mZnNldFdpZHRoLCBzb3VyY2VIZWlnaHQgPSBzb3VyY2VOb2RlLm9mZnNldEhlaWdodDtcbiAgICB2YXIgYW5jaG9yWCA9IGFuY2hvclBvaW50LmFuY2hvclgsIGFuY2hvclkgPSBhbmNob3JQb2ludC5hbmNob3JZO1xuICAgIHZhciBfYSA9IGdldERyYWdQcmV2aWV3U2l6ZShpc0ltYWdlLCBkcmFnUHJldmlldywgc291cmNlV2lkdGgsIHNvdXJjZUhlaWdodCksIGRyYWdQcmV2aWV3V2lkdGggPSBfYS5kcmFnUHJldmlld1dpZHRoLCBkcmFnUHJldmlld0hlaWdodCA9IF9hLmRyYWdQcmV2aWV3SGVpZ2h0O1xuICAgIHZhciBjYWxjdWxhdGVZT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW50ZXJwb2xhbnRZID0gbmV3IE1vbm90b25pY0ludGVycG9sYW50XzEuZGVmYXVsdChbMCwgMC41LCAxXSwgW1xuICAgICAgICAgICAgLy8gRG9jayB0byB0aGUgdG9wXG4gICAgICAgICAgICBvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSxcbiAgICAgICAgICAgIC8vIEFsaWduIGF0IHRoZSBjZW50ZXJcbiAgICAgICAgICAgIChvZmZzZXRGcm9tRHJhZ1ByZXZpZXcueSAvIHNvdXJjZUhlaWdodCkgKiBkcmFnUHJldmlld0hlaWdodCxcbiAgICAgICAgICAgIC8vIERvY2sgdG8gdGhlIGJvdHRvbVxuICAgICAgICAgICAgb2Zmc2V0RnJvbURyYWdQcmV2aWV3LnkgKyBkcmFnUHJldmlld0hlaWdodCAtIHNvdXJjZUhlaWdodCxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciB5ID0gaW50ZXJwb2xhbnRZLmludGVycG9sYXRlKGFuY2hvclkpO1xuICAgICAgICAvLyBXb3JrIGFyb3VuZCBTYWZhcmkgOCBwb3NpdGlvbmluZyBidWdcbiAgICAgICAgaWYgKEJyb3dzZXJEZXRlY3Rvcl8xLmlzU2FmYXJpKCkgJiYgaXNJbWFnZSkge1xuICAgICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byB3YWl0IGZvciBAM3ggdG8gc2VlIGlmIHRoaXMgaXMgZW50aXJlbHkgY29ycmVjdFxuICAgICAgICAgICAgeSArPSAod2luZG93LmRldmljZVBpeGVsUmF0aW8gLSAxKSAqIGRyYWdQcmV2aWV3SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5O1xuICAgIH07XG4gICAgdmFyIGNhbGN1bGF0ZVhPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEludGVycG9sYXRlIGNvb3JkaW5hdGVzIGRlcGVuZGluZyBvbiBhbmNob3IgcG9pbnRcbiAgICAgICAgLy8gSWYgeW91IGtub3cgYSBzaW1wbGVyIHdheSB0byBkbyB0aGlzLCBsZXQgbWUga25vd1xuICAgICAgICB2YXIgaW50ZXJwb2xhbnRYID0gbmV3IE1vbm90b25pY0ludGVycG9sYW50XzEuZGVmYXVsdChbMCwgMC41LCAxXSwgW1xuICAgICAgICAgICAgLy8gRG9jayB0byB0aGUgbGVmdFxuICAgICAgICAgICAgb2Zmc2V0RnJvbURyYWdQcmV2aWV3LngsXG4gICAgICAgICAgICAvLyBBbGlnbiBhdCB0aGUgY2VudGVyXG4gICAgICAgICAgICAob2Zmc2V0RnJvbURyYWdQcmV2aWV3LnggLyBzb3VyY2VXaWR0aCkgKiBkcmFnUHJldmlld1dpZHRoLFxuICAgICAgICAgICAgLy8gRG9jayB0byB0aGUgcmlnaHRcbiAgICAgICAgICAgIG9mZnNldEZyb21EcmFnUHJldmlldy54ICsgZHJhZ1ByZXZpZXdXaWR0aCAtIHNvdXJjZVdpZHRoLFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIGludGVycG9sYW50WC5pbnRlcnBvbGF0ZShhbmNob3JYKTtcbiAgICB9O1xuICAgIC8vIEZvcmNlIG9mZnNldHMgaWYgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zLlxuICAgIHZhciBvZmZzZXRYID0gb2Zmc2V0UG9pbnQub2Zmc2V0WCwgb2Zmc2V0WSA9IG9mZnNldFBvaW50Lm9mZnNldFk7XG4gICAgdmFyIGlzTWFudWFsT2Zmc2V0WCA9IG9mZnNldFggPT09IDAgfHwgb2Zmc2V0WDtcbiAgICB2YXIgaXNNYW51YWxPZmZzZXRZID0gb2Zmc2V0WSA9PT0gMCB8fCBvZmZzZXRZO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGlzTWFudWFsT2Zmc2V0WCA/IG9mZnNldFggOiBjYWxjdWxhdGVYT2Zmc2V0KCksXG4gICAgICAgIHk6IGlzTWFudWFsT2Zmc2V0WSA/IG9mZnNldFkgOiBjYWxjdWxhdGVZT2Zmc2V0KCksXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0RHJhZ1ByZXZpZXdPZmZzZXQgPSBnZXREcmFnUHJldmlld09mZnNldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVtcHR5SW1hZ2U7XG5mdW5jdGlvbiBnZXRFbXB0eUltYWdlKCkge1xuICAgIGlmICghZW1wdHlJbWFnZSkge1xuICAgICAgICBlbXB0eUltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGVtcHR5SW1hZ2Uuc3JjID1cbiAgICAgICAgICAgICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFBQUFDSDVCQUVLQUFFQUxBQUFBQUFCQUFFQUFBSUNUQUVBT3c9PSc7XG4gICAgfVxuICAgIHJldHVybiBlbXB0eUltYWdlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2V0RW1wdHlJbWFnZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEhUTUw1QmFja2VuZF8xID0gcmVxdWlyZShcIi4vSFRNTDVCYWNrZW5kXCIpO1xudmFyIGdldEVtcHR5SW1hZ2VfMSA9IHJlcXVpcmUoXCIuL2dldEVtcHR5SW1hZ2VcIik7XG5leHBvcnRzLmdldEVtcHR5SW1hZ2UgPSBnZXRFbXB0eUltYWdlXzEuZGVmYXVsdDtcbnZhciBOYXRpdmVUeXBlcyA9IHJlcXVpcmUoXCIuL05hdGl2ZVR5cGVzXCIpO1xuZXhwb3J0cy5OYXRpdmVUeXBlcyA9IE5hdGl2ZVR5cGVzO1xuZnVuY3Rpb24gY3JlYXRlSFRNTDVCYWNrZW5kKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gbmV3IEhUTUw1QmFja2VuZF8xLmRlZmF1bHQobWFuYWdlcik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVIVE1MNUJhY2tlbmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICB2YXIgbWVtb2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIG1lbW9pemVkO1xufVxuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcbi8qKlxuICogZHJvcC1pbiByZXBsYWNlbWVudCBmb3IgXy53aXRob3V0XG4gKi9cbmZ1bmN0aW9uIHdpdGhvdXQoaXRlbXMsIGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uIChpKSB7IHJldHVybiBpICE9PSBpdGVtOyB9KTtcbn1cbmV4cG9ydHMud2l0aG91dCA9IHdpdGhvdXQ7XG5mdW5jdGlvbiB1bmlvbihpdGVtc0EsIGl0ZW1zQikge1xuICAgIHZhciBzZXQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGluc2VydEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gc2V0LmFkZChpdGVtKTsgfTtcbiAgICBpdGVtc0EuZm9yRWFjaChpbnNlcnRJdGVtKTtcbiAgICBpdGVtc0IuZm9yRWFjaChpbnNlcnRJdGVtKTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gcmVzdWx0LnB1c2goa2V5KTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMudW5pb24gPSB1bmlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBkbmRfY29yZV8xID0gcmVxdWlyZShcImRuZC1jb3JlXCIpO1xudmFyIGludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbnZhcmlhbnRcIikpO1xudmFyIGhvaXN0X25vbl9yZWFjdF9zdGF0aWNzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImhvaXN0LW5vbi1yZWFjdC1zdGF0aWNzXCIpKTtcbnZhciBjaGVja0RlY29yYXRvckFyZ3VtZW50c18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3V0aWxzL2NoZWNrRGVjb3JhdG9yQXJndW1lbnRzXCIpKTtcbmV4cG9ydHMuQ0hJTERfQ09OVEVYVF9UWVBFUyA9IHtcbiAgICBkcmFnRHJvcE1hbmFnZXI6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9iamVjdC5pc1JlcXVpcmVkLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkQ29udGV4dChiYWNrZW5kLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZHJhZ0Ryb3BNYW5hZ2VyOiBkbmRfY29yZV8xLmNyZWF0ZURyYWdEcm9wTWFuYWdlcihiYWNrZW5kLCBjb250ZXh0KSxcbiAgICB9O1xufVxuZXhwb3J0cy5jcmVhdGVDaGlsZENvbnRleHQgPSBjcmVhdGVDaGlsZENvbnRleHQ7XG5mdW5jdGlvbiBEcmFnRHJvcENvbnRleHQoYmFja2VuZEZhY3RvcnksIGNvbnRleHQpIHtcbiAgICBjaGVja0RlY29yYXRvckFyZ3VtZW50c18xLmRlZmF1bHQoJ0RyYWdEcm9wQ29udGV4dCcsICdiYWNrZW5kJywgYmFja2VuZEZhY3RvcnkpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBjcmVhdGVDaGlsZENvbnRleHQoYmFja2VuZEZhY3RvcnksIGNvbnRleHQpO1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0ZUNvbnRleHQoRGVjb3JhdGVkQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IERlY29yYXRlZENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBEZWNvcmF0ZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgdmFyIERyYWdEcm9wQ29udGV4dENvbnRhaW5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgICAgIF9fZXh0ZW5kcyhEcmFnRHJvcENvbnRleHRDb250YWluZXIsIF9zdXBlcik7XG4gICAgICAgICAgICBmdW5jdGlvbiBEcmFnRHJvcENvbnRleHRDb250YWluZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRHJhZ0Ryb3BDb250ZXh0Q29udGFpbmVyLnByb3RvdHlwZS5nZXREZWNvcmF0ZWRDb21wb25lbnRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KHRoaXMuY2hpbGQsICdJbiBvcmRlciB0byBhY2Nlc3MgYW4gaW5zdGFuY2Ugb2YgdGhlIGRlY29yYXRlZCBjb21wb25lbnQgaXQgY2FuIG5vdCBiZSBhIHN0YXRlbGVzcyBjb21wb25lbnQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRHJhZ0Ryb3BDb250ZXh0Q29udGFpbmVyLnByb3RvdHlwZS5nZXRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZENvbnRleHQuZHJhZ0Ryb3BNYW5hZ2VyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIERyYWdEcm9wQ29udGV4dENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q2hpbGRDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZENvbnRleHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRHJhZ0Ryb3BDb250ZXh0Q29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERlY29yYXRlZENvbXBvbmVudCwgX19hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgcmVmOiBmdW5jdGlvbiAoY2hpbGQpIHsgcmV0dXJuIChfdGhpcy5jaGlsZCA9IGNoaWxkKTsgfSB9KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIERyYWdEcm9wQ29udGV4dENvbnRhaW5lci5EZWNvcmF0ZWRDb21wb25lbnQgPSBEZWNvcmF0ZWRDb21wb25lbnQ7XG4gICAgICAgICAgICBEcmFnRHJvcENvbnRleHRDb250YWluZXIuZGlzcGxheU5hbWUgPSBcIkRyYWdEcm9wQ29udGV4dChcIiArIGRpc3BsYXlOYW1lICsgXCIpXCI7XG4gICAgICAgICAgICBEcmFnRHJvcENvbnRleHRDb250YWluZXIuY2hpbGRDb250ZXh0VHlwZXMgPSBleHBvcnRzLkNISUxEX0NPTlRFWFRfVFlQRVM7XG4gICAgICAgICAgICByZXR1cm4gRHJhZ0Ryb3BDb250ZXh0Q29udGFpbmVyO1xuICAgICAgICB9KHJlYWN0XzEuZGVmYXVsdC5Db21wb25lbnQpKTtcbiAgICAgICAgcmV0dXJuIGhvaXN0X25vbl9yZWFjdF9zdGF0aWNzXzEuZGVmYXVsdChEcmFnRHJvcENvbnRleHRDb250YWluZXIsIERlY29yYXRlZENvbXBvbmVudCk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdEcm9wQ29udGV4dDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdEcm9wQ29udGV4dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBEcmFnRHJvcENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0RyYWdEcm9wQ29udGV4dFwiKTtcbnZhciBEcmFnRHJvcENvbnRleHRQcm92aWRlckltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERyYWdEcm9wQ29udGV4dFByb3ZpZGVySW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEcmFnRHJvcENvbnRleHRQcm92aWRlckltcGwocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJhY2tlbmQgPSBwcm9wcy5iYWNrZW5kO1xuICAgICAgICBfdGhpcy5jaGlsZENvbnRleHQgPSBEcmFnRHJvcENvbnRleHRfMS5jcmVhdGVDaGlsZENvbnRleHQoX3RoaXMuYmFja2VuZCwgX3RoaXMucHJvcHMuY29udGV4dCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXJJbXBsLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xuICAgICAgICBpZiAobmV4dFByb3BzLmJhY2tlbmQgIT09IHRoaXMucHJvcHMuYmFja2VuZCB8fFxuICAgICAgICAgICAgbmV4dFByb3BzLmNvbnRleHQgIT09IHRoaXMucHJvcHMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEcmFnRHJvcENvbnRleHRQcm92aWRlciBiYWNrZW5kIGFuZCBjb250ZXh0IHByb3BzIG11c3Qgbm90IGNoYW5nZS4nKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXJJbXBsLnByb3RvdHlwZS5nZXRDaGlsZENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoaWxkQ29udGV4dDtcbiAgICB9O1xuICAgIERyYWdEcm9wQ29udGV4dFByb3ZpZGVySW1wbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVhY3RfMS5DaGlsZHJlbi5vbmx5KHRoaXMucHJvcHMuY2hpbGRyZW4pO1xuICAgIH07XG4gICAgRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXJJbXBsLnByb3BUeXBlcyA9IHtcbiAgICAgICAgYmFja2VuZDogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2ZUeXBlKFtwcm9wX3R5cGVzXzEuZGVmYXVsdC5mdW5jLCBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3RdKS5pc1JlcXVpcmVkLFxuICAgICAgICBjaGlsZHJlbjogcHJvcF90eXBlc18xLmRlZmF1bHQuZWxlbWVudC5pc1JlcXVpcmVkLFxuICAgICAgICBjb250ZXh0OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3QsXG4gICAgfTtcbiAgICBEcmFnRHJvcENvbnRleHRQcm92aWRlckltcGwuZGVmYXVsdFByb3BzID0ge1xuICAgICAgICBjb250ZXh0OiB1bmRlZmluZWQsXG4gICAgfTtcbiAgICBEcmFnRHJvcENvbnRleHRQcm92aWRlckltcGwuY2hpbGRDb250ZXh0VHlwZXMgPSBEcmFnRHJvcENvbnRleHRfMS5DSElMRF9DT05URVhUX1RZUEVTO1xuICAgIERyYWdEcm9wQ29udGV4dFByb3ZpZGVySW1wbC5kaXNwbGF5TmFtZSA9ICdEcmFnRHJvcENvbnRleHRQcm92aWRlcic7XG4gICAgcmV0dXJuIERyYWdEcm9wQ29udGV4dFByb3ZpZGVySW1wbDtcbn0ocmVhY3RfMS5Db21wb25lbnQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdEcm9wQ29udGV4dFByb3ZpZGVySW1wbDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyYWdEcm9wQ29udGV4dFByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgfVxuICAgIHJldHVybiB0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciByZWFjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpKTtcbnZhciBob2lzdF9ub25fcmVhY3Rfc3RhdGljc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJob2lzdC1ub24tcmVhY3Qtc3RhdGljc1wiKSk7XG52YXIgaXNQbGFpbk9iamVjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSk7XG52YXIgaW52YXJpYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludmFyaWFudFwiKSk7XG52YXIgY2hlY2tEZWNvcmF0b3JBcmd1bWVudHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9jaGVja0RlY29yYXRvckFyZ3VtZW50c1wiKSk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnc2hhbGxvd2VxdWFsJyk7XG5mdW5jdGlvbiBEcmFnTGF5ZXIoY29sbGVjdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgY2hlY2tEZWNvcmF0b3JBcmd1bWVudHNfMS5kZWZhdWx0KCdEcmFnTGF5ZXInLCAnY29sbGVjdFssIG9wdGlvbnNdJywgY29sbGVjdCwgb3B0aW9ucyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgaW52YXJpYW50XzEuZGVmYXVsdCh0eXBlb2YgY29sbGVjdCA9PT0gJ2Z1bmN0aW9uJywgJ0V4cGVjdGVkIFwiY29sbGVjdFwiIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBEcmFnTGF5ZXIgdG8gYmUgYSBmdW5jdGlvbiB0aGF0IGNvbGxlY3RzIHByb3BzIHRvIGluamVjdCBpbnRvIHRoZSBjb21wb25lbnQuICcsICdJbnN0ZWFkLCByZWNlaXZlZCAlcy4gUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcmFnLWxheWVyLmh0bWwnLCBjb2xsZWN0KTtcbiAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KGlzUGxhaW5PYmplY3RfMS5kZWZhdWx0KG9wdGlvbnMpLCAnRXhwZWN0ZWQgXCJvcHRpb25zXCIgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBEcmFnTGF5ZXIgdG8gYmUgYSBwbGFpbiBvYmplY3Qgd2hlbiBzcGVjaWZpZWQuICcgK1xuICAgICAgICAnSW5zdGVhZCwgcmVjZWl2ZWQgJXMuIFJlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1sYXllci5odG1sJywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRlTGF5ZXIoRGVjb3JhdGVkQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBfYSA9IG9wdGlvbnMuYXJlUHJvcHNFcXVhbCwgYXJlUHJvcHNFcXVhbCA9IF9hID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfYTtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gRGVjb3JhdGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IERlY29yYXRlZENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnO1xuICAgICAgICB2YXIgRHJhZ0xheWVyQ29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICAgICAgX19leHRlbmRzKERyYWdMYXllckNvbnRhaW5lciwgX3N1cGVyKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIERyYWdMYXllckNvbnRhaW5lcihwcm9wcywgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xuICAgICAgICAgICAgICAgIF90aGlzLmlzQ3VycmVudGx5TW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUNoYW5nZSA9IF90aGlzLmhhbmRsZUNoYW5nZS5iaW5kKF90aGlzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYW5hZ2VyID0gY29udGV4dC5kcmFnRHJvcE1hbmFnZXI7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50XzEuZGVmYXVsdCh0eXBlb2YgX3RoaXMubWFuYWdlciA9PT0gJ29iamVjdCcsICdDb3VsZCBub3QgZmluZCB0aGUgZHJhZyBhbmQgZHJvcCBtYW5hZ2VyIGluIHRoZSBjb250ZXh0IG9mICVzLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ01ha2Ugc3VyZSB0byB3cmFwIHRoZSB0b3AtbGV2ZWwgY29tcG9uZW50IG9mIHlvdXIgYXBwIHdpdGggRHJhZ0Ryb3BDb250ZXh0LiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtdHJvdWJsZXNob290aW5nLmh0bWwjY291bGQtbm90LWZpbmQtdGhlLWRyYWctYW5kLWRyb3AtbWFuYWdlci1pbi10aGUtY29udGV4dCcsIGRpc3BsYXlOYW1lLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5nZXRDdXJyZW50U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRHJhZ0xheWVyQ29udGFpbmVyLnByb3RvdHlwZSwgXCJEZWNvcmF0ZWRDb21wb25lbnRcIiwge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRGVjb3JhdGVkQ29tcG9uZW50O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgRHJhZ0xheWVyQ29udGFpbmVyLnByb3RvdHlwZS5nZXREZWNvcmF0ZWRDb21wb25lbnRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KHRoaXMuY2hpbGQsICdJbiBvcmRlciB0byBhY2Nlc3MgYW4gaW5zdGFuY2Ugb2YgdGhlIGRlY29yYXRlZCBjb21wb25lbnQgaXQgY2FuIG5vdCBiZSBhIHN0YXRlbGVzcyBjb21wb25lbnQuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRHJhZ0xheWVyQ29udGFpbmVyLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCFhcmVQcm9wc0VxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICAgICAgICAgICAgICAgICAgIXNoYWxsb3dFcXVhbChuZXh0U3RhdGUsIHRoaXMuc3RhdGUpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBEcmFnTGF5ZXJDb250YWluZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbW9uaXRvciA9IHRoaXMubWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZUZyb21PZmZzZXRDaGFuZ2UgPSBtb25pdG9yLnN1YnNjcmliZVRvT2Zmc2V0Q2hhbmdlKHRoaXMuaGFuZGxlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlRnJvbVN0YXRlQ2hhbmdlID0gbW9uaXRvci5zdWJzY3JpYmVUb1N0YXRlQ2hhbmdlKHRoaXMuaGFuZGxlQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIERyYWdMYXllckNvbnRhaW5lci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0N1cnJlbnRseU1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy51bnN1YnNjcmliZUZyb21PZmZzZXRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZUZyb21PZmZzZXRDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZUZyb21PZmZzZXRDaGFuZ2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnVuc3Vic2NyaWJlRnJvbVN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVGcm9tU3RhdGVDaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51bnN1YnNjcmliZUZyb21TdGF0ZUNoYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgRHJhZ0xheWVyQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgICAgICByZXR1cm4gKHJlYWN0XzEuZGVmYXVsdC5jcmVhdGVFbGVtZW50KERlY29yYXRlZENvbXBvbmVudCwgX19hc3NpZ24oe30sIHRoaXMucHJvcHMsIHRoaXMuc3RhdGUsIHsgcmVmOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH0gfSkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBEcmFnTGF5ZXJDb250YWluZXIucHJvdG90eXBlLmhhbmRsZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNDdXJyZW50bHlNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5leHRTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIERyYWdMYXllckNvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q3VycmVudFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBtb25pdG9yID0gdGhpcy5tYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29sbGVjdChtb25pdG9yLCB0aGlzLnByb3BzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBEcmFnTGF5ZXJDb250YWluZXIuZGlzcGxheU5hbWUgPSBcIkRyYWdMYXllcihcIiArIGRpc3BsYXlOYW1lICsgXCIpXCI7XG4gICAgICAgICAgICBEcmFnTGF5ZXJDb250YWluZXIuY29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgICAgIGRyYWdEcm9wTWFuYWdlcjogcHJvcF90eXBlc18xLmRlZmF1bHQub2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIERyYWdMYXllckNvbnRhaW5lcjtcbiAgICAgICAgfShyZWFjdF8xLmRlZmF1bHQuQ29tcG9uZW50KSk7XG4gICAgICAgIHJldHVybiBob2lzdF9ub25fcmVhY3Rfc3RhdGljc18xLmRlZmF1bHQoRHJhZ0xheWVyQ29udGFpbmVyLCBEZWNvcmF0ZWRDb21wb25lbnQpO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnTGF5ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnTGF5ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaW52YXJpYW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImludmFyaWFudFwiKSk7XG52YXIgaXNQbGFpbk9iamVjdF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJsb2Rhc2gvaXNQbGFpbk9iamVjdFwiKSk7XG52YXIgY2hlY2tEZWNvcmF0b3JBcmd1bWVudHNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9jaGVja0RlY29yYXRvckFyZ3VtZW50c1wiKSk7XG52YXIgZGVjb3JhdGVIYW5kbGVyXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vZGVjb3JhdGVIYW5kbGVyXCIpKTtcbnZhciByZWdpc3RlclNvdXJjZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL3JlZ2lzdGVyU291cmNlXCIpKTtcbnZhciBjcmVhdGVTb3VyY2VGYWN0b3J5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vY3JlYXRlU291cmNlRmFjdG9yeVwiKSk7XG52YXIgY3JlYXRlU291cmNlTW9uaXRvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NyZWF0ZVNvdXJjZU1vbml0b3JcIikpO1xudmFyIGNyZWF0ZVNvdXJjZUNvbm5lY3Rvcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NyZWF0ZVNvdXJjZUNvbm5lY3RvclwiKSk7XG52YXIgaXNWYWxpZFR5cGVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi91dGlscy9pc1ZhbGlkVHlwZVwiKSk7XG4vKipcbiAqIERlY29yYXRlcyBhIGNvbXBvbmVudCBhcyBhIGRyYWdzb3VyY2VcbiAqIEBwYXJhbSB0eXBlIFRoZSBkcmFnc291cmNlIHR5cGVcbiAqIEBwYXJhbSBzcGVjIFRoZSBkcmFnIHNvdXJjZSBzcGVjaWZpY2F0aW9uXG4gKiBAcGFyYW0gY29sbGVjdCBUaGUgcHJvcHMgY29sbGVjdG9yIGZ1bmN0aW9uXG4gKiBAcGFyYW0gb3B0aW9ucyBEbkQgb3B0aW5vc1xuICovXG5mdW5jdGlvbiBEcmFnU291cmNlKHR5cGUsIHNwZWMsIGNvbGxlY3QsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIGNoZWNrRGVjb3JhdG9yQXJndW1lbnRzXzEuZGVmYXVsdCgnRHJhZ1NvdXJjZScsICd0eXBlLCBzcGVjLCBjb2xsZWN0Wywgb3B0aW9uc10nLCB0eXBlLCBzcGVjLCBjb2xsZWN0LCBvcHRpb25zKTtcbiAgICB2YXIgZ2V0VHlwZSA9IHR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGludmFyaWFudF8xLmRlZmF1bHQoaXNWYWxpZFR5cGVfMS5kZWZhdWx0KHR5cGUpLCAnRXhwZWN0ZWQgXCJ0eXBlXCIgcHJvdmlkZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIERyYWdTb3VyY2UgdG8gYmUgJyArXG4gICAgICAgICAgICAnYSBzdHJpbmcsIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgc3RyaW5nIGdpdmVuIHRoZSBjdXJyZW50IHByb3BzLiAnICtcbiAgICAgICAgICAgICdJbnN0ZWFkLCByZWNlaXZlZCAlcy4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcmFnLXNvdXJjZS5odG1sJywgdHlwZSk7XG4gICAgICAgIGdldFR5cGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlOyB9O1xuICAgIH1cbiAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KGlzUGxhaW5PYmplY3RfMS5kZWZhdWx0KHNwZWMpLCAnRXhwZWN0ZWQgXCJzcGVjXCIgcHJvdmlkZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byBEcmFnU291cmNlIHRvIGJlICcgK1xuICAgICAgICAnYSBwbGFpbiBvYmplY3QuIEluc3RlYWQsIHJlY2VpdmVkICVzLiAnICtcbiAgICAgICAgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIHNwZWMpO1xuICAgIHZhciBjcmVhdGVTb3VyY2UgPSBjcmVhdGVTb3VyY2VGYWN0b3J5XzEuZGVmYXVsdChzcGVjKTtcbiAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KHR5cGVvZiBjb2xsZWN0ID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgXCJjb2xsZWN0XCIgcHJvdmlkZWQgYXMgdGhlIHRoaXJkIGFyZ3VtZW50IHRvIERyYWdTb3VyY2UgdG8gYmUgJyArXG4gICAgICAgICdhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHBsYWluIG9iamVjdCBvZiBwcm9wcyB0byBpbmplY3QuICcgK1xuICAgICAgICAnSW5zdGVhZCwgcmVjZWl2ZWQgJXMuICcgK1xuICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcmFnLXNvdXJjZS5odG1sJywgY29sbGVjdCk7XG4gICAgaW52YXJpYW50XzEuZGVmYXVsdChpc1BsYWluT2JqZWN0XzEuZGVmYXVsdChvcHRpb25zKSwgJ0V4cGVjdGVkIFwib3B0aW9uc1wiIHByb3ZpZGVkIGFzIHRoZSBmb3VydGggYXJndW1lbnQgdG8gRHJhZ1NvdXJjZSB0byBiZSAnICtcbiAgICAgICAgJ2EgcGxhaW4gb2JqZWN0IHdoZW4gc3BlY2lmaWVkLiAnICtcbiAgICAgICAgJ0luc3RlYWQsIHJlY2VpdmVkICVzLiAnICtcbiAgICAgICAgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIGNvbGxlY3QpO1xuICAgIHJldHVybiBmdW5jdGlvbiBkZWNvcmF0ZVNvdXJjZShEZWNvcmF0ZWRDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIGRlY29yYXRlSGFuZGxlcl8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgY29udGFpbmVyRGlzcGxheU5hbWU6ICdEcmFnU291cmNlJyxcbiAgICAgICAgICAgIGNyZWF0ZUhhbmRsZXI6IGNyZWF0ZVNvdXJjZSxcbiAgICAgICAgICAgIHJlZ2lzdGVySGFuZGxlcjogcmVnaXN0ZXJTb3VyY2VfMS5kZWZhdWx0LFxuICAgICAgICAgICAgY3JlYXRlTW9uaXRvcjogY3JlYXRlU291cmNlTW9uaXRvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjcmVhdGVDb25uZWN0b3I6IGNyZWF0ZVNvdXJjZUNvbm5lY3Rvcl8xLmRlZmF1bHQsXG4gICAgICAgICAgICBEZWNvcmF0ZWRDb21wb25lbnQ6IERlY29yYXRlZENvbXBvbmVudCxcbiAgICAgICAgICAgIGdldFR5cGU6IGdldFR5cGUsXG4gICAgICAgICAgICBjb2xsZWN0OiBjb2xsZWN0LFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdTb3VyY2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1EcmFnU291cmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbnZhcmlhbnRcIikpO1xudmFyIGlzUGxhaW5PYmplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIikpO1xudmFyIGNoZWNrRGVjb3JhdG9yQXJndW1lbnRzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvY2hlY2tEZWNvcmF0b3JBcmd1bWVudHNcIikpO1xudmFyIGRlY29yYXRlSGFuZGxlcl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2RlY29yYXRlSGFuZGxlclwiKSk7XG52YXIgcmVnaXN0ZXJUYXJnZXRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9yZWdpc3RlclRhcmdldFwiKSk7XG52YXIgY3JlYXRlVGFyZ2V0RmFjdG9yeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL2NyZWF0ZVRhcmdldEZhY3RvcnlcIikpO1xudmFyIGNyZWF0ZVRhcmdldE1vbml0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jcmVhdGVUYXJnZXRNb25pdG9yXCIpKTtcbnZhciBjcmVhdGVUYXJnZXRDb25uZWN0b3JfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9jcmVhdGVUYXJnZXRDb25uZWN0b3JcIikpO1xudmFyIGlzVmFsaWRUeXBlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvaXNWYWxpZFR5cGVcIikpO1xuZnVuY3Rpb24gRHJvcFRhcmdldCh0eXBlLCBzcGVjLCBjb2xsZWN0LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBjaGVja0RlY29yYXRvckFyZ3VtZW50c18xLmRlZmF1bHQoJ0Ryb3BUYXJnZXQnLCAndHlwZSwgc3BlYywgY29sbGVjdFssIG9wdGlvbnNdJywgdHlwZSwgc3BlYywgY29sbGVjdCwgb3B0aW9ucyk7XG4gICAgdmFyIGdldFR5cGUgPSB0eXBlO1xuICAgIGlmICh0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KGlzVmFsaWRUeXBlXzEuZGVmYXVsdCh0eXBlLCB0cnVlKSwgJ0V4cGVjdGVkIFwidHlwZVwiIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byBEcm9wVGFyZ2V0IHRvIGJlICcgK1xuICAgICAgICAgICAgJ2Egc3RyaW5nLCBhbiBhcnJheSBvZiBzdHJpbmdzLCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBlaXRoZXIgZ2l2ZW4gJyArXG4gICAgICAgICAgICAndGhlIGN1cnJlbnQgcHJvcHMuIEluc3RlYWQsIHJlY2VpdmVkICVzLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyb3AtdGFyZ2V0Lmh0bWwnLCB0eXBlKTtcbiAgICAgICAgZ2V0VHlwZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHR5cGU7IH07XG4gICAgfVxuICAgIGludmFyaWFudF8xLmRlZmF1bHQoaXNQbGFpbk9iamVjdF8xLmRlZmF1bHQoc3BlYyksICdFeHBlY3RlZCBcInNwZWNcIiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHRvIERyb3BUYXJnZXQgdG8gYmUgJyArXG4gICAgICAgICdhIHBsYWluIG9iamVjdC4gSW5zdGVhZCwgcmVjZWl2ZWQgJXMuICcgK1xuICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcm9wLXRhcmdldC5odG1sJywgc3BlYyk7XG4gICAgdmFyIGNyZWF0ZVRhcmdldCA9IGNyZWF0ZVRhcmdldEZhY3RvcnlfMS5kZWZhdWx0KHNwZWMpO1xuICAgIGludmFyaWFudF8xLmRlZmF1bHQodHlwZW9mIGNvbGxlY3QgPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCBcImNvbGxlY3RcIiBwcm92aWRlZCBhcyB0aGUgdGhpcmQgYXJndW1lbnQgdG8gRHJvcFRhcmdldCB0byBiZSAnICtcbiAgICAgICAgJ2EgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgcGxhaW4gb2JqZWN0IG9mIHByb3BzIHRvIGluamVjdC4gJyArXG4gICAgICAgICdJbnN0ZWFkLCByZWNlaXZlZCAlcy4gJyArXG4gICAgICAgICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyb3AtdGFyZ2V0Lmh0bWwnLCBjb2xsZWN0KTtcbiAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KGlzUGxhaW5PYmplY3RfMS5kZWZhdWx0KG9wdGlvbnMpLCAnRXhwZWN0ZWQgXCJvcHRpb25zXCIgcHJvdmlkZWQgYXMgdGhlIGZvdXJ0aCBhcmd1bWVudCB0byBEcm9wVGFyZ2V0IHRvIGJlICcgK1xuICAgICAgICAnYSBwbGFpbiBvYmplY3Qgd2hlbiBzcGVjaWZpZWQuICcgK1xuICAgICAgICAnSW5zdGVhZCwgcmVjZWl2ZWQgJXMuICcgK1xuICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcm9wLXRhcmdldC5odG1sJywgY29sbGVjdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGRlY29yYXRlVGFyZ2V0KERlY29yYXRlZENvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gZGVjb3JhdGVIYW5kbGVyXzEuZGVmYXVsdCh7XG4gICAgICAgICAgICBjb250YWluZXJEaXNwbGF5TmFtZTogJ0Ryb3BUYXJnZXQnLFxuICAgICAgICAgICAgY3JlYXRlSGFuZGxlcjogY3JlYXRlVGFyZ2V0LFxuICAgICAgICAgICAgcmVnaXN0ZXJIYW5kbGVyOiByZWdpc3RlclRhcmdldF8xLmRlZmF1bHQsXG4gICAgICAgICAgICBjcmVhdGVNb25pdG9yOiBjcmVhdGVUYXJnZXRNb25pdG9yXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIGNyZWF0ZUNvbm5lY3RvcjogY3JlYXRlVGFyZ2V0Q29ubmVjdG9yXzEuZGVmYXVsdCxcbiAgICAgICAgICAgIERlY29yYXRlZENvbXBvbmVudDogRGVjb3JhdGVkQ29tcG9uZW50LFxuICAgICAgICAgICAgZ2V0VHlwZTogZ2V0VHlwZSxcbiAgICAgICAgICAgIGNvbGxlY3Q6IGNvbGxlY3QsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gRHJvcFRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURyb3BUYXJnZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgd3JhcENvbm5lY3Rvckhvb2tzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vd3JhcENvbm5lY3Rvckhvb2tzXCIpKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdzaGFsbG93ZXF1YWwnKTtcbmZ1bmN0aW9uIGNyZWF0ZVNvdXJjZUNvbm5lY3RvcihiYWNrZW5kKSB7XG4gICAgdmFyIGN1cnJlbnRIYW5kbGVySWQ7XG4gICAgdmFyIGN1cnJlbnREcmFnU291cmNlTm9kZTtcbiAgICB2YXIgY3VycmVudERyYWdTb3VyY2VPcHRpb25zO1xuICAgIHZhciBkaXNjb25uZWN0Q3VycmVudERyYWdTb3VyY2U7XG4gICAgdmFyIGN1cnJlbnREcmFnUHJldmlld05vZGU7XG4gICAgdmFyIGN1cnJlbnREcmFnUHJldmlld09wdGlvbnM7XG4gICAgdmFyIGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXc7XG4gICAgZnVuY3Rpb24gcmVjb25uZWN0RHJhZ1NvdXJjZSgpIHtcbiAgICAgICAgaWYgKGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1NvdXJjZSkge1xuICAgICAgICAgICAgZGlzY29ubmVjdEN1cnJlbnREcmFnU291cmNlKCk7XG4gICAgICAgICAgICBkaXNjb25uZWN0Q3VycmVudERyYWdTb3VyY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRIYW5kbGVySWQgJiYgY3VycmVudERyYWdTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0Q3VycmVudERyYWdTb3VyY2UgPSBiYWNrZW5kLmNvbm5lY3REcmFnU291cmNlKGN1cnJlbnRIYW5kbGVySWQsIGN1cnJlbnREcmFnU291cmNlTm9kZSwgY3VycmVudERyYWdTb3VyY2VPcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvbm5lY3REcmFnUHJldmlldygpIHtcbiAgICAgICAgaWYgKGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXcpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXcoKTtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJhZ1ByZXZpZXcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRIYW5kbGVySWQgJiYgY3VycmVudERyYWdQcmV2aWV3Tm9kZSkge1xuICAgICAgICAgICAgZGlzY29ubmVjdEN1cnJlbnREcmFnUHJldmlldyA9IGJhY2tlbmQuY29ubmVjdERyYWdQcmV2aWV3KGN1cnJlbnRIYW5kbGVySWQsIGN1cnJlbnREcmFnUHJldmlld05vZGUsIGN1cnJlbnREcmFnUHJldmlld09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKSB7XG4gICAgICAgIGlmIChoYW5kbGVySWQgPT09IGN1cnJlbnRIYW5kbGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SGFuZGxlcklkID0gaGFuZGxlcklkO1xuICAgICAgICByZWNvbm5lY3REcmFnU291cmNlKCk7XG4gICAgICAgIHJlY29ubmVjdERyYWdQcmV2aWV3KCk7XG4gICAgfVxuICAgIHZhciBob29rcyA9IHdyYXBDb25uZWN0b3JIb29rc18xLmRlZmF1bHQoe1xuICAgICAgICBkcmFnU291cmNlOiBmdW5jdGlvbiBjb25uZWN0RHJhZ1NvdXJjZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gY3VycmVudERyYWdTb3VyY2VOb2RlICYmXG4gICAgICAgICAgICAgICAgc2hhbGxvd0VxdWFsKG9wdGlvbnMsIGN1cnJlbnREcmFnU291cmNlT3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50RHJhZ1NvdXJjZU5vZGUgPSBub2RlO1xuICAgICAgICAgICAgY3VycmVudERyYWdTb3VyY2VPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHJlY29ubmVjdERyYWdTb3VyY2UoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZHJhZ1ByZXZpZXc6IGZ1bmN0aW9uIGNvbm5lY3REcmFnUHJldmlldyhub2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gY3VycmVudERyYWdQcmV2aWV3Tm9kZSAmJlxuICAgICAgICAgICAgICAgIHNoYWxsb3dFcXVhbChvcHRpb25zLCBjdXJyZW50RHJhZ1ByZXZpZXdPcHRpb25zKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnREcmFnUHJldmlld05vZGUgPSBub2RlO1xuICAgICAgICAgICAgY3VycmVudERyYWdQcmV2aWV3T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICByZWNvbm5lY3REcmFnUHJldmlldygpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlY2VpdmVIYW5kbGVySWQ6IHJlY2VpdmVIYW5kbGVySWQsXG4gICAgICAgIGhvb2tzOiBob29rcyxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gY3JlYXRlU291cmNlQ29ubmVjdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU291cmNlQ29ubmVjdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbnZhcmlhbnRcIikpO1xudmFyIGlzUGxhaW5PYmplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIikpO1xudmFyIEFMTE9XRURfU1BFQ19NRVRIT0RTID0gWydjYW5EcmFnJywgJ2JlZ2luRHJhZycsICdpc0RyYWdnaW5nJywgJ2VuZERyYWcnXTtcbnZhciBSRVFVSVJFRF9TUEVDX01FVEhPRFMgPSBbJ2JlZ2luRHJhZyddO1xuZnVuY3Rpb24gY3JlYXRlU291cmNlRmFjdG9yeShzcGVjKSB7XG4gICAgT2JqZWN0LmtleXMoc3BlYykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGludmFyaWFudF8xLmRlZmF1bHQoQUxMT1dFRF9TUEVDX01FVEhPRFMuaW5kZXhPZihrZXkpID4gLTEsICdFeHBlY3RlZCB0aGUgZHJhZyBzb3VyY2Ugc3BlY2lmaWNhdGlvbiB0byBvbmx5IGhhdmUgJyArXG4gICAgICAgICAgICAnc29tZSBvZiB0aGUgZm9sbG93aW5nIGtleXM6ICVzLiAnICtcbiAgICAgICAgICAgICdJbnN0ZWFkIHJlY2VpdmVkIGEgc3BlY2lmaWNhdGlvbiB3aXRoIGFuIHVuZXhwZWN0ZWQgXCIlc1wiIGtleS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcmFnLXNvdXJjZS5odG1sJywgQUxMT1dFRF9TUEVDX01FVEhPRFMuam9pbignLCAnKSwga2V5KTtcbiAgICAgICAgaW52YXJpYW50XzEuZGVmYXVsdCh0eXBlb2Ygc3BlY1trZXldID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgJXMgaW4gdGhlIGRyYWcgc291cmNlIHNwZWNpZmljYXRpb24gdG8gYmUgYSBmdW5jdGlvbi4gJyArXG4gICAgICAgICAgICAnSW5zdGVhZCByZWNlaXZlZCBhIHNwZWNpZmljYXRpb24gd2l0aCAlczogJXMuICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIGtleSwga2V5LCBzcGVjW2tleV0pO1xuICAgIH0pO1xuICAgIFJFUVVJUkVEX1NQRUNfTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaW52YXJpYW50XzEuZGVmYXVsdCh0eXBlb2Ygc3BlY1trZXldID09PSAnZnVuY3Rpb24nLCAnRXhwZWN0ZWQgJXMgaW4gdGhlIGRyYWcgc291cmNlIHNwZWNpZmljYXRpb24gdG8gYmUgYSBmdW5jdGlvbi4gJyArXG4gICAgICAgICAgICAnSW5zdGVhZCByZWNlaXZlZCBhIHNwZWNpZmljYXRpb24gd2l0aCAlczogJXMuICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJhZy1zb3VyY2UuaHRtbCcsIGtleSwga2V5LCBzcGVjW2tleV0pO1xuICAgIH0pO1xuICAgIHZhciBTb3VyY2VJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTb3VyY2VJbXBsKG1vbml0b3IpIHtcbiAgICAgICAgICAgIHRoaXMubW9uaXRvciA9IG1vbml0b3I7XG4gICAgICAgIH1cbiAgICAgICAgU291cmNlSW1wbC5wcm90b3R5cGUucmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIH07XG4gICAgICAgIFNvdXJjZUltcGwucHJvdG90eXBlLnJlY2VpdmVDb21wb25lbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgU291cmNlSW1wbC5wcm90b3R5cGUuY2FuRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3BlYy5jYW5EcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3BlYy5jYW5EcmFnKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIFNvdXJjZUltcGwucHJvdG90eXBlLmlzRHJhZ2dpbmcgPSBmdW5jdGlvbiAoZ2xvYmFsTW9uaXRvciwgc291cmNlSWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3BlYy5pc0RyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZUlkID09PSBnbG9iYWxNb25pdG9yLmdldFNvdXJjZUlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3BlYy5pc0RyYWdnaW5nKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvcik7XG4gICAgICAgIH07XG4gICAgICAgIFNvdXJjZUltcGwucHJvdG90eXBlLmJlZ2luRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcyB8fCAhdGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgaXRlbSA9IHNwZWMuYmVnaW5EcmFnKHRoaXMucHJvcHMsIHRoaXMubW9uaXRvciwgdGhpcy5jb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgaW52YXJpYW50XzEuZGVmYXVsdChpc1BsYWluT2JqZWN0XzEuZGVmYXVsdChpdGVtKSwgJ2JlZ2luRHJhZygpIG11c3QgcmV0dXJuIGEgcGxhaW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZHJhZ2dlZCBpdGVtLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0luc3RlYWQgcmVjZWl2ZWQgJXMuICcgK1xuICAgICAgICAgICAgICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcmFnLXNvdXJjZS5odG1sJywgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgU291cmNlSW1wbC5wcm90b3R5cGUuZW5kRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9wcyB8fCAhdGhpcy5jb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNwZWMuZW5kRHJhZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWMuZW5kRHJhZyh0aGlzLnByb3BzLCB0aGlzLm1vbml0b3IsIHRoaXMuY29tcG9uZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFNvdXJjZUltcGw7XG4gICAgfSgpKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlU291cmNlKG1vbml0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb3VyY2VJbXBsKG1vbml0b3IpO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVTb3VyY2VGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU291cmNlRmFjdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpbnZhcmlhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW52YXJpYW50XCIpKTtcbnZhciBpc0NhbGxpbmdDYW5EcmFnID0gZmFsc2U7XG52YXIgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IGZhbHNlO1xudmFyIFNvdXJjZU1vbml0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU291cmNlTW9uaXRvcihtYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuaW50ZXJuYWxNb25pdG9yID0gbWFuYWdlci5nZXRNb25pdG9yKCk7XG4gICAgfVxuICAgIFNvdXJjZU1vbml0b3IucHJvdG90eXBlLnJlY2VpdmVIYW5kbGVySWQgPSBmdW5jdGlvbiAoc291cmNlSWQpIHtcbiAgICAgICAgdGhpcy5zb3VyY2VJZCA9IHNvdXJjZUlkO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuY2FuRHJhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50XzEuZGVmYXVsdCghaXNDYWxsaW5nQ2FuRHJhZywgJ1lvdSBtYXkgbm90IGNhbGwgbW9uaXRvci5jYW5EcmFnKCkgaW5zaWRlIHlvdXIgY2FuRHJhZygpIGltcGxlbWVudGF0aW9uLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyYWctc291cmNlLW1vbml0b3IuaHRtbCcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNDYWxsaW5nQ2FuRHJhZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuY2FuRHJhZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlzQ2FsbGluZ0NhbkRyYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuaXNEcmFnZ2luZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50XzEuZGVmYXVsdCghaXNDYWxsaW5nSXNEcmFnZ2luZywgJ1lvdSBtYXkgbm90IGNhbGwgbW9uaXRvci5pc0RyYWdnaW5nKCkgaW5zaWRlIHlvdXIgaXNEcmFnZ2luZygpIGltcGxlbWVudGF0aW9uLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyYWctc291cmNlLW1vbml0b3IuaHRtbCcpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaXNDYWxsaW5nSXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNEcmFnZ2luZ1NvdXJjZSh0aGlzLnNvdXJjZUlkKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlzQ2FsbGluZ0lzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZSA9IGZ1bmN0aW9uIChsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3Iuc3Vic2NyaWJlVG9TdGF0ZUNoYW5nZShsaXN0ZW5lciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBTb3VyY2VNb25pdG9yLnByb3RvdHlwZS5pc0RyYWdnaW5nU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc0RyYWdnaW5nU291cmNlKHNvdXJjZUlkKTtcbiAgICB9O1xuICAgIFNvdXJjZU1vbml0b3IucHJvdG90eXBlLmlzT3ZlclRhcmdldCA9IGZ1bmN0aW9uICh0YXJnZXRJZCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuaXNPdmVyVGFyZ2V0KHRhcmdldElkLCBvcHRpb25zKTtcbiAgICB9O1xuICAgIFNvdXJjZU1vbml0b3IucHJvdG90eXBlLmdldFRhcmdldElkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFRhcmdldElkcygpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuaXNTb3VyY2VQdWJsaWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc1NvdXJjZVB1YmxpYygpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuZ2V0U291cmNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRTb3VyY2VJZCgpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuc3Vic2NyaWJlVG9PZmZzZXRDaGFuZ2UgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLnN1YnNjcmliZVRvT2Zmc2V0Q2hhbmdlKGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFNvdXJjZU1vbml0b3IucHJvdG90eXBlLmNhbkRyYWdTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmNhbkRyYWdTb3VyY2Uoc291cmNlSWQpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuY2FuRHJvcE9uVGFyZ2V0ID0gZnVuY3Rpb24gKHRhcmdldElkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5Ecm9wT25UYXJnZXQodGFyZ2V0SWQpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuZ2V0SXRlbVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJdGVtVHlwZSgpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuZ2V0SXRlbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW0oKTtcbiAgICB9O1xuICAgIFNvdXJjZU1vbml0b3IucHJvdG90eXBlLmdldERyb3BSZXN1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREcm9wUmVzdWx0KCk7XG4gICAgfTtcbiAgICBTb3VyY2VNb25pdG9yLnByb3RvdHlwZS5kaWREcm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZGlkRHJvcCgpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuZ2V0SW5pdGlhbENsaWVudE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxDbGllbnRPZmZzZXQoKTtcbiAgICB9O1xuICAgIFNvdXJjZU1vbml0b3IucHJvdG90eXBlLmdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRJbml0aWFsU291cmNlQ2xpZW50T2Zmc2V0KCk7XG4gICAgfTtcbiAgICBTb3VyY2VNb25pdG9yLnByb3RvdHlwZS5nZXRTb3VyY2VDbGllbnRPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXRTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICB9O1xuICAgIFNvdXJjZU1vbml0b3IucHJvdG90eXBlLmdldENsaWVudE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldENsaWVudE9mZnNldCgpO1xuICAgIH07XG4gICAgU291cmNlTW9uaXRvci5wcm90b3R5cGUuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0RGlmZmVyZW5jZUZyb21Jbml0aWFsT2Zmc2V0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU291cmNlTW9uaXRvcjtcbn0oKSk7XG5mdW5jdGlvbiBjcmVhdGVTb3VyY2VNb25pdG9yKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gbmV3IFNvdXJjZU1vbml0b3IobWFuYWdlcik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVTb3VyY2VNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlU291cmNlTW9uaXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB3cmFwQ29ubmVjdG9ySG9va3NfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi93cmFwQ29ubmVjdG9ySG9va3NcIikpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ3NoYWxsb3dlcXVhbCcpO1xuZnVuY3Rpb24gY3JlYXRlVGFyZ2V0Q29ubmVjdG9yKGJhY2tlbmQpIHtcbiAgICB2YXIgY3VycmVudEhhbmRsZXJJZDtcbiAgICB2YXIgY3VycmVudERyb3BUYXJnZXROb2RlO1xuICAgIHZhciBjdXJyZW50RHJvcFRhcmdldE9wdGlvbnM7XG4gICAgdmFyIGRpc2Nvbm5lY3RDdXJyZW50RHJvcFRhcmdldDtcbiAgICBmdW5jdGlvbiByZWNvbm5lY3REcm9wVGFyZ2V0KCkge1xuICAgICAgICBpZiAoZGlzY29ubmVjdEN1cnJlbnREcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0Q3VycmVudERyb3BUYXJnZXQoKTtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJvcFRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudEhhbmRsZXJJZCAmJiBjdXJyZW50RHJvcFRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgIGRpc2Nvbm5lY3RDdXJyZW50RHJvcFRhcmdldCA9IGJhY2tlbmQuY29ubmVjdERyb3BUYXJnZXQoY3VycmVudEhhbmRsZXJJZCwgY3VycmVudERyb3BUYXJnZXROb2RlLCBjdXJyZW50RHJvcFRhcmdldE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlY2VpdmVIYW5kbGVySWQoaGFuZGxlcklkKSB7XG4gICAgICAgIGlmIChoYW5kbGVySWQgPT09IGN1cnJlbnRIYW5kbGVySWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SGFuZGxlcklkID0gaGFuZGxlcklkO1xuICAgICAgICByZWNvbm5lY3REcm9wVGFyZ2V0KCk7XG4gICAgfVxuICAgIHZhciBob29rcyA9IHdyYXBDb25uZWN0b3JIb29rc18xLmRlZmF1bHQoe1xuICAgICAgICBkcm9wVGFyZ2V0OiBmdW5jdGlvbiBjb25uZWN0RHJvcFRhcmdldChub2RlLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAobm9kZSA9PT0gY3VycmVudERyb3BUYXJnZXROb2RlICYmXG4gICAgICAgICAgICAgICAgc2hhbGxvd0VxdWFsKG9wdGlvbnMsIGN1cnJlbnREcm9wVGFyZ2V0T3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50RHJvcFRhcmdldE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgY3VycmVudERyb3BUYXJnZXRPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHJlY29ubmVjdERyb3BUYXJnZXQoKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWNlaXZlSGFuZGxlcklkOiByZWNlaXZlSGFuZGxlcklkLFxuICAgICAgICBob29rczogaG9va3MsXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVRhcmdldENvbm5lY3Rvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyZWF0ZVRhcmdldENvbm5lY3Rvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpbnZhcmlhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW52YXJpYW50XCIpKTtcbnZhciBpc1BsYWluT2JqZWN0XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc1BsYWluT2JqZWN0XCIpKTtcbnZhciBBTExPV0VEX1NQRUNfTUVUSE9EUyA9IFsnY2FuRHJvcCcsICdob3ZlcicsICdkcm9wJ107XG5mdW5jdGlvbiBjcmVhdGVUYXJnZXRGYWN0b3J5KHNwZWMpIHtcbiAgICBPYmplY3Qua2V5cyhzcGVjKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaW52YXJpYW50XzEuZGVmYXVsdChBTExPV0VEX1NQRUNfTUVUSE9EUy5pbmRleE9mKGtleSkgPiAtMSwgJ0V4cGVjdGVkIHRoZSBkcm9wIHRhcmdldCBzcGVjaWZpY2F0aW9uIHRvIG9ubHkgaGF2ZSAnICtcbiAgICAgICAgICAgICdzb21lIG9mIHRoZSBmb2xsb3dpbmcga2V5czogJXMuICcgK1xuICAgICAgICAgICAgJ0luc3RlYWQgcmVjZWl2ZWQgYSBzcGVjaWZpY2F0aW9uIHdpdGggYW4gdW5leHBlY3RlZCBcIiVzXCIga2V5LiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLWRyb3AtdGFyZ2V0Lmh0bWwnLCBBTExPV0VEX1NQRUNfTUVUSE9EUy5qb2luKCcsICcpLCBrZXkpO1xuICAgICAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KHR5cGVvZiBzcGVjW2tleV0gPT09ICdmdW5jdGlvbicsICdFeHBlY3RlZCAlcyBpbiB0aGUgZHJvcCB0YXJnZXQgc3BlY2lmaWNhdGlvbiB0byBiZSBhIGZ1bmN0aW9uLiAnICtcbiAgICAgICAgICAgICdJbnN0ZWFkIHJlY2VpdmVkIGEgc3BlY2lmaWNhdGlvbiB3aXRoICVzOiAlcy4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcm9wLXRhcmdldC5odG1sJywga2V5LCBrZXksIHNwZWNba2V5XSk7XG4gICAgfSk7XG4gICAgdmFyIFRhcmdldEltcGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFRhcmdldEltcGwobW9uaXRvcikge1xuICAgICAgICAgICAgdGhpcy5tb25pdG9yID0gbW9uaXRvcjtcbiAgICAgICAgICAgIHRoaXMucHJvcHMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIFRhcmdldEltcGwucHJvdG90eXBlLnJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB9O1xuICAgICAgICBUYXJnZXRJbXBsLnByb3RvdHlwZS5yZWNlaXZlTW9uaXRvciA9IGZ1bmN0aW9uIChtb25pdG9yKSB7XG4gICAgICAgICAgICB0aGlzLm1vbml0b3IgPSBtb25pdG9yO1xuICAgICAgICB9O1xuICAgICAgICBUYXJnZXRJbXBsLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIFRhcmdldEltcGwucHJvdG90eXBlLmNhbkRyb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNwZWMuY2FuRHJvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNwZWMuY2FuRHJvcCh0aGlzLnByb3BzLCB0aGlzLm1vbml0b3IpO1xuICAgICAgICB9O1xuICAgICAgICBUYXJnZXRJbXBsLnByb3RvdHlwZS5ob3ZlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICghc3BlYy5ob3Zlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNwZWMuaG92ZXIodGhpcy5wcm9wcywgdGhpcy5tb25pdG9yLCB0aGlzLmNvbXBvbmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIFRhcmdldEltcGwucHJvdG90eXBlLmRyb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNwZWMuZHJvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZHJvcFJlc3VsdCA9IHNwZWMuZHJvcCh0aGlzLnByb3BzLCB0aGlzLm1vbml0b3IsIHRoaXMuY29tcG9uZW50KTtcbiAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGludmFyaWFudF8xLmRlZmF1bHQodHlwZW9mIGRyb3BSZXN1bHQgPT09ICd1bmRlZmluZWQnIHx8IGlzUGxhaW5PYmplY3RfMS5kZWZhdWx0KGRyb3BSZXN1bHQpLCAnZHJvcCgpIG11c3QgZWl0aGVyIHJldHVybiB1bmRlZmluZWQsIG9yIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGRyb3AgcmVzdWx0LiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0luc3RlYWQgcmVjZWl2ZWQgJXMuICcgK1xuICAgICAgICAgICAgICAgICAgICAnUmVhZCBtb3JlOiBodHRwOi8vcmVhY3QtZG5kLmdpdGh1Yi5pby9yZWFjdC1kbmQvZG9jcy1kcm9wLXRhcmdldC5odG1sJywgZHJvcFJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZHJvcFJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFRhcmdldEltcGw7XG4gICAgfSgpKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlVGFyZ2V0KG1vbml0b3IpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUYXJnZXRJbXBsKG1vbml0b3IpO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUYXJnZXRGYWN0b3J5O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlVGFyZ2V0RmFjdG9yeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpbnZhcmlhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW52YXJpYW50XCIpKTtcbnZhciBpc0NhbGxpbmdDYW5Ecm9wID0gZmFsc2U7XG52YXIgVGFyZ2V0TW9uaXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYXJnZXRNb25pdG9yKG1hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5pbnRlcm5hbE1vbml0b3IgPSBtYW5hZ2VyLmdldE1vbml0b3IoKTtcbiAgICB9XG4gICAgVGFyZ2V0TW9uaXRvci5wcm90b3R5cGUucmVjZWl2ZUhhbmRsZXJJZCA9IGZ1bmN0aW9uICh0YXJnZXRJZCkge1xuICAgICAgICB0aGlzLnRhcmdldElkID0gdGFyZ2V0SWQ7XG4gICAgfTtcbiAgICBUYXJnZXRNb25pdG9yLnByb3RvdHlwZS5jYW5Ecm9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnRfMS5kZWZhdWx0KCFpc0NhbGxpbmdDYW5Ecm9wLCAnWW91IG1heSBub3QgY2FsbCBtb25pdG9yLmNhbkRyb3AoKSBpbnNpZGUgeW91ciBjYW5Ecm9wKCkgaW1wbGVtZW50YXRpb24uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtZHJvcC10YXJnZXQtbW9uaXRvci5odG1sJyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5Ecm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5jYW5Ecm9wT25UYXJnZXQodGhpcy50YXJnZXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpc0NhbGxpbmdDYW5Ecm9wID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhcmdldE1vbml0b3IucHJvdG90eXBlLmlzT3ZlciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5pc092ZXJUYXJnZXQodGhpcy50YXJnZXRJZCwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBUYXJnZXRNb25pdG9yLnByb3RvdHlwZS5nZXRJdGVtVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEl0ZW1UeXBlKCk7XG4gICAgfTtcbiAgICBUYXJnZXRNb25pdG9yLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SXRlbSgpO1xuICAgIH07XG4gICAgVGFyZ2V0TW9uaXRvci5wcm90b3R5cGUuZ2V0RHJvcFJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldERyb3BSZXN1bHQoKTtcbiAgICB9O1xuICAgIFRhcmdldE1vbml0b3IucHJvdG90eXBlLmRpZERyb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5kaWREcm9wKCk7XG4gICAgfTtcbiAgICBUYXJnZXRNb25pdG9yLnByb3RvdHlwZS5nZXRJbml0aWFsQ2xpZW50T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0SW5pdGlhbENsaWVudE9mZnNldCgpO1xuICAgIH07XG4gICAgVGFyZ2V0TW9uaXRvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFNvdXJjZUNsaWVudE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldEluaXRpYWxTb3VyY2VDbGllbnRPZmZzZXQoKTtcbiAgICB9O1xuICAgIFRhcmdldE1vbml0b3IucHJvdG90eXBlLmdldFNvdXJjZUNsaWVudE9mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxNb25pdG9yLmdldFNvdXJjZUNsaWVudE9mZnNldCgpO1xuICAgIH07XG4gICAgVGFyZ2V0TW9uaXRvci5wcm90b3R5cGUuZ2V0Q2xpZW50T2Zmc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbE1vbml0b3IuZ2V0Q2xpZW50T2Zmc2V0KCk7XG4gICAgfTtcbiAgICBUYXJnZXRNb25pdG9yLnByb3RvdHlwZS5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmludGVybmFsTW9uaXRvci5nZXREaWZmZXJlbmNlRnJvbUluaXRpYWxPZmZzZXQoKTtcbiAgICB9O1xuICAgIHJldHVybiBUYXJnZXRNb25pdG9yO1xufSgpKTtcbmV4cG9ydHMuVGFyZ2V0TW9uaXRvciA9IFRhcmdldE1vbml0b3I7XG5mdW5jdGlvbiBjcmVhdGVUYXJnZXRNb25pdG9yKG1hbmFnZXIpIHtcbiAgICByZXR1cm4gbmV3IFRhcmdldE1vbml0b3IobWFuYWdlcik7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVUYXJnZXRNb25pdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3JlYXRlVGFyZ2V0TW9uaXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xuICAgIHJlc3VsdFtcImRlZmF1bHRcIl0gPSBtb2Q7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVhY3QgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBwcm9wX3R5cGVzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcInByb3AtdHlwZXNcIikpO1xudmFyIGlzUGxhaW5PYmplY3RfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibG9kYXNoL2lzUGxhaW5PYmplY3RcIikpO1xudmFyIGludmFyaWFudF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJpbnZhcmlhbnRcIikpO1xudmFyIGhvaXN0X25vbl9yZWFjdF9zdGF0aWNzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImhvaXN0LW5vbi1yZWFjdC1zdGF0aWNzXCIpKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdzaGFsbG93ZXF1YWwnKTtcbnZhciBfYSA9IHJlcXVpcmUoJ2Rpc3Bvc2FibGVzJyksIERpc3Bvc2FibGUgPSBfYS5EaXNwb3NhYmxlLCBDb21wb3NpdGVEaXNwb3NhYmxlID0gX2EuQ29tcG9zaXRlRGlzcG9zYWJsZSwgU2VyaWFsRGlzcG9zYWJsZSA9IF9hLlNlcmlhbERpc3Bvc2FibGU7XG52YXIgaXNDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChDb21wKSB7XG4gICAgcmV0dXJuICghIUNvbXAgJiYgISFDb21wLnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKTtcbn07XG5mdW5jdGlvbiBkZWNvcmF0ZUhhbmRsZXIoX2EpIHtcbiAgICB2YXIgRGVjb3JhdGVkQ29tcG9uZW50ID0gX2EuRGVjb3JhdGVkQ29tcG9uZW50LCBjcmVhdGVIYW5kbGVyID0gX2EuY3JlYXRlSGFuZGxlciwgY3JlYXRlTW9uaXRvciA9IF9hLmNyZWF0ZU1vbml0b3IsIGNyZWF0ZUNvbm5lY3RvciA9IF9hLmNyZWF0ZUNvbm5lY3RvciwgcmVnaXN0ZXJIYW5kbGVyID0gX2EucmVnaXN0ZXJIYW5kbGVyLCBjb250YWluZXJEaXNwbGF5TmFtZSA9IF9hLmNvbnRhaW5lckRpc3BsYXlOYW1lLCBnZXRUeXBlID0gX2EuZ2V0VHlwZSwgY29sbGVjdCA9IF9hLmNvbGxlY3QsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgIHZhciBfYiA9IG9wdGlvbnMuYXJlUHJvcHNFcXVhbCwgYXJlUHJvcHNFcXVhbCA9IF9iID09PSB2b2lkIDAgPyBzaGFsbG93RXF1YWwgOiBfYjtcbiAgICB2YXIgZGlzcGxheU5hbWUgPSBEZWNvcmF0ZWRDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgRGVjb3JhdGVkQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCc7XG4gICAgdmFyIERyYWdEcm9wQ29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoRHJhZ0Ryb3BDb250YWluZXIsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIERyYWdEcm9wQ29udGFpbmVyKHByb3BzLCBjb250ZXh0KSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkgfHwgdGhpcztcbiAgICAgICAgICAgIF90aGlzLmlzQ3VycmVudGx5TW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2hhbmdlID0gX3RoaXMuaGFuZGxlQ2hhbmdlLmJpbmQoX3RoaXMpO1xuICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2hpbGRSZWYgPSBfdGhpcy5oYW5kbGVDaGlsZFJlZi5iaW5kKF90aGlzKTtcbiAgICAgICAgICAgIGludmFyaWFudF8xLmRlZmF1bHQodHlwZW9mIF90aGlzLmNvbnRleHQuZHJhZ0Ryb3BNYW5hZ2VyID09PSAnb2JqZWN0JywgJ0NvdWxkIG5vdCBmaW5kIHRoZSBkcmFnIGFuZCBkcm9wIG1hbmFnZXIgaW4gdGhlIGNvbnRleHQgb2YgJXMuICcgK1xuICAgICAgICAgICAgICAgICdNYWtlIHN1cmUgdG8gd3JhcCB0aGUgdG9wLWxldmVsIGNvbXBvbmVudCBvZiB5b3VyIGFwcCB3aXRoIERyYWdEcm9wQ29udGV4dC4gJyArXG4gICAgICAgICAgICAgICAgJ1JlYWQgbW9yZTogaHR0cDovL3JlYWN0LWRuZC5naXRodWIuaW8vcmVhY3QtZG5kL2RvY3MtdHJvdWJsZXNob290aW5nLmh0bWwjY291bGQtbm90LWZpbmQtdGhlLWRyYWctYW5kLWRyb3AtbWFuYWdlci1pbi10aGUtY29udGV4dCcsIGRpc3BsYXlOYW1lLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICBfdGhpcy5tYW5hZ2VyID0gX3RoaXMuY29udGV4dC5kcmFnRHJvcE1hbmFnZXI7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVyTW9uaXRvciA9IGNyZWF0ZU1vbml0b3IoX3RoaXMubWFuYWdlcik7XG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVyQ29ubmVjdG9yID0gY3JlYXRlQ29ubmVjdG9yKF90aGlzLm1hbmFnZXIuZ2V0QmFja2VuZCgpKTtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZXIgPSBjcmVhdGVIYW5kbGVyKF90aGlzLmhhbmRsZXJNb25pdG9yKTtcbiAgICAgICAgICAgIF90aGlzLmRpc3Bvc2FibGUgPSBuZXcgU2VyaWFsRGlzcG9zYWJsZSgpO1xuICAgICAgICAgICAgX3RoaXMucmVjZWl2ZVByb3BzKHByb3BzKTtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuZ2V0Q3VycmVudFN0YXRlKCk7XG4gICAgICAgICAgICBfdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgICAgIH1cbiAgICAgICAgRHJhZ0Ryb3BDb250YWluZXIucHJvdG90eXBlLmdldEhhbmRsZXJJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXJJZDtcbiAgICAgICAgfTtcbiAgICAgICAgRHJhZ0Ryb3BDb250YWluZXIucHJvdG90eXBlLmdldERlY29yYXRlZENvbXBvbmVudEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIH07XG4gICAgICAgIERyYWdEcm9wQ29udGFpbmVyLnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiAoIWFyZVByb3BzRXF1YWwobmV4dFByb3BzLCB0aGlzLnByb3BzKSB8fFxuICAgICAgICAgICAgICAgICFzaGFsbG93RXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSk7XG4gICAgICAgIH07XG4gICAgICAgIERyYWdEcm9wQ29udGFpbmVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGlzcG9zYWJsZSA9IG5ldyBTZXJpYWxEaXNwb3NhYmxlKCk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUeXBlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlUHJvcHModGhpcy5wcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICB9O1xuICAgICAgICBEcmFnRHJvcENvbnRhaW5lci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9IGZ1bmN0aW9uIChuZXh0UHJvcHMpIHtcbiAgICAgICAgICAgIGlmICghYXJlUHJvcHNFcXVhbChuZXh0UHJvcHMsIHRoaXMucHJvcHMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNlaXZlUHJvcHMobmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNoYW5nZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBEcmFnRHJvcENvbnRhaW5lci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuaXNDdXJyZW50bHlNb3VudGVkID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICAgIERyYWdEcm9wQ29udGFpbmVyLnByb3RvdHlwZS5yZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlci5yZWNlaXZlUHJvcHMocHJvcHMpO1xuICAgICAgICAgICAgdGhpcy5yZWNlaXZlVHlwZShnZXRUeXBlKHByb3BzKSk7XG4gICAgICAgIH07XG4gICAgICAgIERyYWdEcm9wQ29udGFpbmVyLnByb3RvdHlwZS5yZWNlaXZlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdGhpcy5jdXJyZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdmFyIF9hID0gcmVnaXN0ZXJIYW5kbGVyKHR5cGUsIHRoaXMuaGFuZGxlciwgdGhpcy5tYW5hZ2VyKSwgaGFuZGxlcklkID0gX2EuaGFuZGxlcklkLCB1bnJlZ2lzdGVyID0gX2EudW5yZWdpc3RlcjtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlcklkID0gaGFuZGxlcklkO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyTW9uaXRvci5yZWNlaXZlSGFuZGxlcklkKGhhbmRsZXJJZCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXJDb25uZWN0b3IucmVjZWl2ZUhhbmRsZXJJZChoYW5kbGVySWQpO1xuICAgICAgICAgICAgdmFyIGdsb2JhbE1vbml0b3IgPSB0aGlzLm1hbmFnZXIuZ2V0TW9uaXRvcigpO1xuICAgICAgICAgICAgdmFyIHVuc3Vic2NyaWJlID0gZ2xvYmFsTW9uaXRvci5zdWJzY3JpYmVUb1N0YXRlQ2hhbmdlKHRoaXMuaGFuZGxlQ2hhbmdlLCB7IGhhbmRsZXJJZHM6IFtoYW5kbGVySWRdIH0pO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NhYmxlLnNldERpc3Bvc2FibGUobmV3IENvbXBvc2l0ZURpc3Bvc2FibGUobmV3IERpc3Bvc2FibGUodW5zdWJzY3JpYmUpLCBuZXcgRGlzcG9zYWJsZSh1bnJlZ2lzdGVyKSkpO1xuICAgICAgICB9O1xuICAgICAgICBEcmFnRHJvcENvbnRhaW5lci5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5TW91bnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSB0aGlzLmdldEN1cnJlbnRTdGF0ZSgpO1xuICAgICAgICAgICAgaWYgKCFzaGFsbG93RXF1YWwobmV4dFN0YXRlLCB0aGlzLnN0YXRlKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgRHJhZ0Ryb3BDb250YWluZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3Bvc2FibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVyQ29ubmVjdG9yLnJlY2VpdmVIYW5kbGVySWQobnVsbCk7XG4gICAgICAgIH07XG4gICAgICAgIERyYWdEcm9wQ29udGFpbmVyLnByb3RvdHlwZS5oYW5kbGVDaGlsZFJlZiA9IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVkQ29tcG9uZW50SW5zdGFuY2UgPSBjb21wb25lbnQ7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZXIucmVjZWl2ZUNvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICB9O1xuICAgICAgICBEcmFnRHJvcENvbnRhaW5lci5wcm90b3R5cGUuZ2V0Q3VycmVudFN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGNvbGxlY3QodGhpcy5oYW5kbGVyQ29ubmVjdG9yLmhvb2tzLCB0aGlzLmhhbmRsZXJNb25pdG9yKTtcbiAgICAgICAgICAgIGlmIChcImRldmVsb3BtZW50XCIgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICAgIGludmFyaWFudF8xLmRlZmF1bHQoaXNQbGFpbk9iamVjdF8xLmRlZmF1bHQobmV4dFN0YXRlKSwgJ0V4cGVjdGVkIGBjb2xsZWN0YCBzcGVjaWZpZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgJyVzIGZvciAlcyB0byByZXR1cm4gYSBwbGFpbiBvYmplY3Qgb2YgcHJvcHMgdG8gaW5qZWN0LiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ0luc3RlYWQsIHJlY2VpdmVkICVzLicsIGNvbnRhaW5lckRpc3BsYXlOYW1lLCBkaXNwbGF5TmFtZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXh0U3RhdGU7XG4gICAgICAgIH07XG4gICAgICAgIERyYWdEcm9wQ29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGVjb3JhdGVkQ29tcG9uZW50LCBfX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgdGhpcy5zdGF0ZSwgeyByZWY6IGlzQ2xhc3NDb21wb25lbnQoRGVjb3JhdGVkQ29tcG9uZW50KSA/IHRoaXMuaGFuZGxlQ2hpbGRSZWYgOiBudWxsIH0pKSk7XG4gICAgICAgIH07XG4gICAgICAgIERyYWdEcm9wQ29udGFpbmVyLkRlY29yYXRlZENvbXBvbmVudCA9IERlY29yYXRlZENvbXBvbmVudDtcbiAgICAgICAgRHJhZ0Ryb3BDb250YWluZXIuZGlzcGxheU5hbWUgPSBjb250YWluZXJEaXNwbGF5TmFtZSArIFwiKFwiICsgZGlzcGxheU5hbWUgKyBcIilcIjtcbiAgICAgICAgRHJhZ0Ryb3BDb250YWluZXIuY29udGV4dFR5cGVzID0ge1xuICAgICAgICAgICAgZHJhZ0Ryb3BNYW5hZ2VyOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5vYmplY3QuaXNSZXF1aXJlZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIERyYWdEcm9wQ29udGFpbmVyO1xuICAgIH0oUmVhY3QuQ29tcG9uZW50KSk7XG4gICAgcmV0dXJuIGhvaXN0X25vbl9yZWFjdF9zdGF0aWNzXzEuZGVmYXVsdChEcmFnRHJvcENvbnRhaW5lciwgRGVjb3JhdGVkQ29tcG9uZW50KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlY29yYXRlSGFuZGxlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlY29yYXRlSGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBEcmFnRHJvcENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0RyYWdEcm9wQ29udGV4dFwiKTtcbmV4cG9ydHMuRHJhZ0Ryb3BDb250ZXh0ID0gRHJhZ0Ryb3BDb250ZXh0XzEuZGVmYXVsdDtcbnZhciBEcmFnRHJvcENvbnRleHRQcm92aWRlcl8xID0gcmVxdWlyZShcIi4vRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXJcIik7XG5leHBvcnRzLkRyYWdEcm9wQ29udGV4dFByb3ZpZGVyID0gRHJhZ0Ryb3BDb250ZXh0UHJvdmlkZXJfMS5kZWZhdWx0O1xudmFyIERyYWdMYXllcl8xID0gcmVxdWlyZShcIi4vRHJhZ0xheWVyXCIpO1xuZXhwb3J0cy5EcmFnTGF5ZXIgPSBEcmFnTGF5ZXJfMS5kZWZhdWx0O1xudmFyIERyYWdTb3VyY2VfMSA9IHJlcXVpcmUoXCIuL0RyYWdTb3VyY2VcIik7XG5leHBvcnRzLkRyYWdTb3VyY2UgPSBEcmFnU291cmNlXzEuZGVmYXVsdDtcbnZhciBEcm9wVGFyZ2V0XzEgPSByZXF1aXJlKFwiLi9Ecm9wVGFyZ2V0XCIpO1xuZXhwb3J0cy5Ecm9wVGFyZ2V0ID0gRHJvcFRhcmdldF8xLmRlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHJlZ2lzdGVyU291cmNlKHR5cGUsIHNvdXJjZSwgbWFuYWdlcikge1xuICAgIHZhciByZWdpc3RyeSA9IG1hbmFnZXIuZ2V0UmVnaXN0cnkoKTtcbiAgICB2YXIgc291cmNlSWQgPSByZWdpc3RyeS5hZGRTb3VyY2UodHlwZSwgc291cmNlKTtcbiAgICBmdW5jdGlvbiB1bnJlZ2lzdGVyU291cmNlKCkge1xuICAgICAgICByZWdpc3RyeS5yZW1vdmVTb3VyY2Uoc291cmNlSWQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBoYW5kbGVySWQ6IHNvdXJjZUlkLFxuICAgICAgICB1bnJlZ2lzdGVyOiB1bnJlZ2lzdGVyU291cmNlLFxuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSByZWdpc3RlclNvdXJjZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lzdGVyU291cmNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gcmVnaXN0ZXJUYXJnZXQodHlwZSwgdGFyZ2V0LCBtYW5hZ2VyKSB7XG4gICAgdmFyIHJlZ2lzdHJ5ID0gbWFuYWdlci5nZXRSZWdpc3RyeSgpO1xuICAgIHZhciB0YXJnZXRJZCA9IHJlZ2lzdHJ5LmFkZFRhcmdldCh0eXBlLCB0YXJnZXQpO1xuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXJUYXJnZXQoKSB7XG4gICAgICAgIHJlZ2lzdHJ5LnJlbW92ZVRhcmdldCh0YXJnZXRJZCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhhbmRsZXJJZDogdGFyZ2V0SWQsXG4gICAgICAgIHVucmVnaXN0ZXI6IHVucmVnaXN0ZXJUYXJnZXQsXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHJlZ2lzdGVyVGFyZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnaXN0ZXJUYXJnZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBjaGVja0RlY29yYXRvckFyZ3VtZW50cyhmdW5jdGlvbk5hbWUsIHNpZ25hdHVyZSkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAyOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgaWYgKFwiZGV2ZWxvcG1lbnRcIiAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgYXJnc18xID0gYXJnczsgX2EgPCBhcmdzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgYXJnID0gYXJnc18xW19hXTtcbiAgICAgICAgICAgIGlmIChhcmcgJiYgYXJnLnByb3RvdHlwZSAmJiBhcmcucHJvdG90eXBlLnJlbmRlcikge1xuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignWW91IHNlZW0gdG8gYmUgYXBwbHlpbmcgdGhlIGFyZ3VtZW50cyBpbiB0aGUgd3Jvbmcgb3JkZXIuICcgK1xuICAgICAgICAgICAgICAgICAgICAoXCJJdCBzaG91bGQgYmUgXCIgKyBmdW5jdGlvbk5hbWUgKyBcIihcIiArIHNpZ25hdHVyZSArIFwiKShDb21wb25lbnQpLCBub3QgdGhlIG90aGVyIHdheSBhcm91bmQuIFwiKSArXG4gICAgICAgICAgICAgICAgICAgICdSZWFkIG1vcmU6IGh0dHA6Ly9yZWFjdC1kbmQuZ2l0aHViLmlvL3JlYWN0LWRuZC9kb2NzLXRyb3VibGVzaG9vdGluZy5odG1sI3lvdS1zZWVtLXRvLWJlLWFwcGx5aW5nLXRoZS1hcmd1bWVudHMtaW4tdGhlLXdyb25nLW9yZGVyJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gY2hlY2tEZWNvcmF0b3JBcmd1bWVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja0RlY29yYXRvckFyZ3VtZW50cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpbnZhcmlhbnRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaW52YXJpYW50XCIpKTtcbnZhciByZWFjdF8xID0gcmVxdWlyZShcInJlYWN0XCIpO1xuZnVuY3Rpb24gY2xvbmVXaXRoUmVmKGVsZW1lbnQsIG5ld1JlZikge1xuICAgIHZhciBwcmV2aW91c1JlZiA9IGVsZW1lbnQucmVmO1xuICAgIGludmFyaWFudF8xLmRlZmF1bHQodHlwZW9mIHByZXZpb3VzUmVmICE9PSAnc3RyaW5nJywgJ0Nhbm5vdCBjb25uZWN0IFJlYWN0IERuRCB0byBhbiBlbGVtZW50IHdpdGggYW4gZXhpc3Rpbmcgc3RyaW5nIHJlZi4gJyArXG4gICAgICAgICdQbGVhc2UgY29udmVydCBpdCB0byB1c2UgYSBjYWxsYmFjayByZWYgaW5zdGVhZCwgb3Igd3JhcCBpdCBpbnRvIGEgPHNwYW4+IG9yIDxkaXY+LiAnICtcbiAgICAgICAgJ1JlYWQgbW9yZTogaHR0cHM6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9tb3JlLWFib3V0LXJlZnMuaHRtbCN0aGUtcmVmLWNhbGxiYWNrLWF0dHJpYnV0ZScpO1xuICAgIGlmICghcHJldmlvdXNSZWYpIHtcbiAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBubyByZWYgb24gdGhlIGVsZW1lbnQsIHVzZSB0aGUgbmV3IHJlZiBkaXJlY3RseVxuICAgICAgICByZXR1cm4gcmVhY3RfMS5jbG9uZUVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICAgICAgcmVmOiBuZXdSZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVhY3RfMS5jbG9uZUVsZW1lbnQoZWxlbWVudCwge1xuICAgICAgICByZWY6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBuZXdSZWYobm9kZSk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXNSZWYpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c1JlZihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGNsb25lV2l0aFJlZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb25lV2l0aFJlZi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBpc0FycmF5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpKTtcbmZ1bmN0aW9uIGlzVmFsaWRUeXBlKHR5cGUsIGFsbG93QXJyYXkpIHtcbiAgICByZXR1cm4gKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fFxuICAgICAgICB0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKCEhYWxsb3dBcnJheSAmJiBpc0FycmF5XzEuZGVmYXVsdCh0eXBlKSAmJiB0eXBlLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiBpc1ZhbGlkVHlwZSh0LCBmYWxzZSk7IH0pKSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBpc1ZhbGlkVHlwZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzVmFsaWRUeXBlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHJlYWN0XzEgPSByZXF1aXJlKFwicmVhY3RcIik7XG52YXIgY2xvbmVXaXRoUmVmXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vdXRpbHMvY2xvbmVXaXRoUmVmXCIpKTtcbmZ1bmN0aW9uIHRocm93SWZDb21wb3NpdGVDb21wb25lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAvLyBDdXN0b20gY29tcG9uZW50cyBjYW4gbm8gbG9uZ2VyIGJlIHdyYXBwZWQgZGlyZWN0bHkgaW4gUmVhY3QgRG5EIDIuMFxuICAgIC8vIHNvIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBkZXBlbmQgb24gZmluZERPTU5vZGUoKSBmcm9tIHJlYWN0LWRvbS5cbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZGlzcGxheU5hbWUgPSBlbGVtZW50LnR5cGUuZGlzcGxheU5hbWUgfHwgZWxlbWVudC50eXBlLm5hbWUgfHwgJ3RoZSBjb21wb25lbnQnO1xuICAgIHRocm93IG5ldyBFcnJvcignT25seSBuYXRpdmUgZWxlbWVudCBub2RlcyBjYW4gbm93IGJlIHBhc3NlZCB0byBSZWFjdCBEbkQgY29ubmVjdG9ycy4nICtcbiAgICAgICAgKFwiWW91IGNhbiBlaXRoZXIgd3JhcCBcIiArIGRpc3BsYXlOYW1lICsgXCIgaW50byBhIDxkaXY+LCBvciB0dXJuIGl0IGludG8gYSBcIikgK1xuICAgICAgICAnZHJhZyBzb3VyY2Ugb3IgYSBkcm9wIHRhcmdldCBpdHNlbGYuJyk7XG59XG5mdW5jdGlvbiB3cmFwSG9va1RvUmVjb2duaXplRWxlbWVudChob29rKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50T3JOb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChlbGVtZW50T3JOb2RlID09PSB2b2lkIDApIHsgZWxlbWVudE9yTm9kZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0gbnVsbDsgfVxuICAgICAgICAvLyBXaGVuIHBhc3NlZCBhIG5vZGUsIGNhbGwgdGhlIGhvb2sgc3RyYWlnaHQgYXdheS5cbiAgICAgICAgaWYgKCFyZWFjdF8xLmlzVmFsaWRFbGVtZW50KGVsZW1lbnRPck5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGVsZW1lbnRPck5vZGU7XG4gICAgICAgICAgICBob29rKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBwYXNzZWQgYSBSZWFjdEVsZW1lbnQsIGNsb25lIGl0IGFuZCBhdHRhY2ggdGhpcyBmdW5jdGlvbiBhcyBhIHJlZi5cbiAgICAgICAgLy8gVGhpcyBoZWxwcyB1cyBhY2hpZXZlIGEgbmVhdCBBUEkgd2hlcmUgdXNlciBkb2Vzbid0IGV2ZW4ga25vdyB0aGF0IHJlZnNcbiAgICAgICAgLy8gYXJlIGJlaW5nIHVzZWQgdW5kZXIgdGhlIGhvb2QuXG4gICAgICAgIHZhciBlbGVtZW50ID0gZWxlbWVudE9yTm9kZTtcbiAgICAgICAgdGhyb3dJZkNvbXBvc2l0ZUNvbXBvbmVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIC8vIFdoZW4gbm8gb3B0aW9ucyBhcmUgcGFzc2VkLCB1c2UgdGhlIGhvb2sgZGlyZWN0bHlcbiAgICAgICAgdmFyIHJlZiA9IG9wdGlvbnMgPyBmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gaG9vayhub2RlLCBvcHRpb25zKTsgfSA6IGhvb2s7XG4gICAgICAgIHJldHVybiBjbG9uZVdpdGhSZWZfMS5kZWZhdWx0KGVsZW1lbnQsIHJlZik7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHdyYXBDb25uZWN0b3JIb29rcyhob29rcykge1xuICAgIHZhciB3cmFwcGVkSG9va3MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhob29rcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBob29rID0gaG9va3Nba2V5XTtcbiAgICAgICAgdmFyIHdyYXBwZWRIb29rID0gd3JhcEhvb2tUb1JlY29nbml6ZUVsZW1lbnQoaG9vayk7XG4gICAgICAgIHdyYXBwZWRIb29rc1trZXldID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gd3JhcHBlZEhvb2s7IH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHdyYXBwZWRIb29rcztcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHdyYXBDb25uZWN0b3JIb29rcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyYXBDb25uZWN0b3JIb29rcy5qcy5tYXAiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIFlhaG9vISBJbmMuXG4gKiBDb3B5cmlnaHRzIGxpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIExpY2Vuc2UuIFNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4gKi9cbnZhciBSRUFDVF9TVEFUSUNTID0ge1xuICAgIGNoaWxkQ29udGV4dFR5cGVzOiB0cnVlLFxuICAgIGNvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBkZWZhdWx0UHJvcHM6IHRydWUsXG4gICAgZGlzcGxheU5hbWU6IHRydWUsXG4gICAgZ2V0RGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgY2FsbGVlOiB0cnVlLFxuICAgIGFyZ3VtZW50czogdHJ1ZSxcbiAgICBhcml0eTogdHJ1ZVxufTtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGdldE93blByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG52YXIgb2JqZWN0UHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YgJiYgZ2V0UHJvdG90eXBlT2YoT2JqZWN0KTtcblxuZnVuY3Rpb24gaG9pc3ROb25SZWFjdFN0YXRpY3ModGFyZ2V0Q29tcG9uZW50LCBzb3VyY2VDb21wb25lbnQsIGJsYWNrbGlzdCkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuXG4gICAgICAgIGlmIChvYmplY3RQcm90b3R5cGUpIHtcbiAgICAgICAgICAgIHZhciBpbmhlcml0ZWRDb21wb25lbnQgPSBnZXRQcm90b3R5cGVPZihzb3VyY2VDb21wb25lbnQpO1xuICAgICAgICAgICAgaWYgKGluaGVyaXRlZENvbXBvbmVudCAmJiBpbmhlcml0ZWRDb21wb25lbnQgIT09IG9iamVjdFByb3RvdHlwZSkge1xuICAgICAgICAgICAgICAgIGhvaXN0Tm9uUmVhY3RTdGF0aWNzKHRhcmdldENvbXBvbmVudCwgaW5oZXJpdGVkQ29tcG9uZW50LCBibGFja2xpc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgaWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICAgICAga2V5cyA9IGtleXMuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIVJFQUNUX1NUQVRJQ1Nba2V5XSAmJiAhS05PV05fU1RBVElDU1trZXldICYmICghYmxhY2tsaXN0IHx8ICFibGFja2xpc3Rba2V5XSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2VDb21wb25lbnQsIGtleSk7XG4gICAgICAgICAgICAgICAgdHJ5IHsgLy8gQXZvaWQgZmFpbHVyZXMgZnJvbSByZWFkLW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSh0YXJnZXRDb21wb25lbnQsIGtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldENvbXBvbmVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBob2lzdE5vblJlYWN0U3RhdGljcztcbiJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAifQ==
