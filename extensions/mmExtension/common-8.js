LavaPack.loadBundle([
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\validate.js", {"./regex.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\regex.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uuid\dist\validate.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regex = _interopRequireDefault(require("./regex.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function validate(uuid) {
  return typeof uuid === 'string' && _regex.default.test(uuid);
}

var _default = validate;
exports.default = _default;
      };
    };
  }
}, {package:"uuid",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\version.js", {"./validate.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\validate.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uuid\dist\version.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _validate = _interopRequireDefault(require("./validate.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function version(uuid) {
  if (!(0, _validate.default)(uuid)) {
    throw TypeError('Invalid UUID');
  }

  return parseInt(uuid.substr(14, 1), 16);
}

var _default = version;
exports.default = _default;
      };
    };
  }
}, {package:"uuid",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\valid-url\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\valid-url\index.js
      return function (require, module, exports) {
(function(module) {
    'use strict';

    module.exports.is_uri = is_iri;
    module.exports.is_http_uri = is_http_iri;
    module.exports.is_https_uri = is_https_iri;
    module.exports.is_web_uri = is_web_iri;
    // Create aliases
    module.exports.isUri = is_iri;
    module.exports.isHttpUri = is_http_iri;
    module.exports.isHttpsUri = is_https_iri;
    module.exports.isWebUri = is_web_iri;


    // private function
    // internal URI spitter method - direct from RFC 3986
    var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
    };

    function is_iri(value) {
        if (!value) {
            return;
        }

        // check for illegal characters
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;

        // check for hex escapes that aren't complete
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        // scheme and path are required, though the path can be empty
        if (!(scheme && scheme.length && path.length >= 0)) return;

        // if authority is present, the path must be empty or begin with a /
        if (authority && authority.length) {
            if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
            // if authority is not present, the path must not start with //
            if (/^\/\//.test(path)) return;
        }

        // scheme must begin with a letter, then consist of letters, digits, +, ., or -
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))  return;

        // re-assemble the URL per section 5.3 in RFC 3986
        out += scheme + ':';
        if (authority && authority.length) {
            out += '//' + authority;
        }

        out += path;

        if (query && query.length) {
            out += '?' + query;
        }

        if (fragment && fragment.length) {
            out += '#' + fragment;
        }

        return out;
    }

    function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
            return;
        }

        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var port = '';
        var query = '';
        var fragment = '';
        var out = '';

        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1]; 
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];

        if (!scheme)  return;

        if(allowHttps) {
            if (scheme.toLowerCase() != 'https') return;
        } else {
            if (scheme.toLowerCase() != 'http') return;
        }

        // fully-qualified URIs must have an authority section that is
        // a valid host
        if (!authority) {
            return;
        }

        // enable port component
        if (/:(\d+)$/.test(authority)) {
            port = authority.match(/:(\d+)$/)[0];
            authority = authority.replace(/:\d+$/, '');
        }

        out += scheme + ':';
        out += '//' + authority;
        
        if (port) {
            out += port;
        }
        
        out += path;
        
        if(query && query.length){
            out += '?' + query;
        }

        if(fragment && fragment.length){
            out += '#' + fragment;
        }
        
        return out;
    }

    function is_https_iri(value) {
        return is_http_iri(value, true);
    }

    function is_web_iri(value) {
        return (is_http_iri(value) || is_https_iri(value));
    }

})(module);

      };
    };
  }
}, {package:"valid-url",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\vm-browserify\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\vm-browserify\index.js
      return function (require, module, exports) {
var indexOf = function (xs, item) {
    if (xs.indexOf) return xs.indexOf(item);
    else for (var i = 0; i < xs.length; i++) {
        if (xs[i] === item) return i;
    }
    return -1;
};
var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.(0,eval)() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return (0,eval)(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    if (context) {
        forEach(Object_keys(ctx), function (key) {
            context[key] = ctx[key];
        });
    }

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.isContext = function (context) {
    return context instanceof Context;
};

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

      };
    };
  }
}, {package:"browserify>vm-browserify",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\index.js", {"./util/create-payload.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js","./util/rpc-cache-utils.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\rpc-cache-utils.js","./util/stoplight.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\stoplight.js","async/eachSeries":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\eachSeries.js","async/map":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\map.js","eth-block-tracker":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\polling.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\index.js
      return function (require, module, exports) {
const EventEmitter = require('events').EventEmitter
const inherits = require('util').inherits
const ethUtil = require('ethereumjs-util')
const EthBlockTracker = require('eth-block-tracker')
const map = require('async/map')
const eachSeries = require('async/eachSeries')
const Stoplight = require('./util/stoplight.js')
const cacheUtils = require('./util/rpc-cache-utils.js')
const createPayload = require('./util/create-payload.js')
const noop = function(){}

module.exports = Web3ProviderEngine


inherits(Web3ProviderEngine, EventEmitter)

function Web3ProviderEngine(opts) {
  const self = this
  EventEmitter.call(self)
  self.setMaxListeners(30)
  // parse options
  opts = opts || {}

  // block polling
  const directProvider = { sendAsync: self._handleAsync.bind(self) }
  const blockTrackerProvider = opts.blockTrackerProvider || directProvider
  self._blockTracker = opts.blockTracker || new EthBlockTracker({
    provider: blockTrackerProvider,
    pollingInterval: opts.pollingInterval || 4000,
    setSkipCacheFlag: true,
  })

  // set initialization blocker
  self._ready = new Stoplight()

  // local state
  self.currentBlock = null
  self._providers = []
}

// public

Web3ProviderEngine.prototype.start = function(cb = noop){
  const self = this

  // trigger start
  self._ready.go()

  // on new block, request block body and emit as events
  self._blockTracker.on('latest', (blockNumber) => {
    // get block body
    self._getBlockByNumberWithRetry(blockNumber, (err, block) => {
      if (err) {
        this.emit('error', err)
        return
      }
      if (!block) {
        console.log(block)
        this.emit('error', new Error("Could not find block"))
        return
      }
      const bufferBlock = toBufferBlock(block)
      // set current + emit "block" event
      self._setCurrentBlock(bufferBlock)
      // emit other events
      self.emit('rawBlock', block)
      self.emit('latest', block)
    })
  })

  // forward other events
  self._blockTracker.on('sync', self.emit.bind(self, 'sync'))
  self._blockTracker.on('error', self.emit.bind(self, 'error'))

  // update state
  self._running = true
  // signal that we started
  self.emit('start')
}

Web3ProviderEngine.prototype.stop = function(){
  const self = this
  // stop block polling by removing event listeners
  self._blockTracker.removeAllListeners()
  // update state
  self._running = false
  // signal that we stopped
  self.emit('stop')
}

Web3ProviderEngine.prototype.isRunning = function(){
  const self = this
  return self._running
}

Web3ProviderEngine.prototype.addProvider = function(source, index){
  const self = this
  if (typeof index === 'number') {
    self._providers.splice(index, 0, source)
  } else {
    self._providers.push(source)
  }
  source.setEngine(this)
}

Web3ProviderEngine.prototype.removeProvider = function(source){
  const self = this
  const index = self._providers.indexOf(source)
  if (index < 0) throw new Error('Provider not found.')
  self._providers.splice(index, 1)
}

Web3ProviderEngine.prototype.send = function(payload){
  throw new Error('Web3ProviderEngine does not support synchronous requests.')
}

Web3ProviderEngine.prototype.sendAsync = function(payload, cb){
  const self = this
  self._ready.await(function(){

    if (Array.isArray(payload)) {
      // handle batch
      map(payload, self._handleAsync.bind(self), cb)
    } else {
      // handle single
      self._handleAsync(payload, cb)
    }

  })
}

// private

Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {
  const self = this

  let retriesRemaining = 5

  attemptRequest()
  return

  function attemptRequest () {
    self._getBlockByNumber(blockNumber, afterRequest)
  }

  function afterRequest (err, block) {
    // anomalous error occurred
    if (err) return cb(err)
    // block not ready yet
    if (!block) {
      if (retriesRemaining > 0) {
        // wait 1s then try again
        retriesRemaining--
        setTimeout(function () {
          attemptRequest()
        }, 1000)
        return
      } else {
        // give up, return a null block
        cb(null, null)
        return
      }
    }
    // otherwise return result
    cb(null, block)
    return
  }
}


Web3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {
  const req = createPayload({ method: 'eth_getBlockByNumber', params: [blockNumber, false], skipCache: true })
  this._handleAsync(req, (err, res) => {
    if (err) return cb(err)
    return cb(null, res.result)
  })
}

Web3ProviderEngine.prototype._handleAsync = function(payload, finished) {
  var self = this
  var currentProvider = -1
  var result = null
  var error = null

  var stack = []

  next()

  function next(after) {
    currentProvider += 1
    stack.unshift(after)

    // Bubbled down as far as we could go, and the request wasn't
    // handled. Return an error.
    if (currentProvider >= self._providers.length) {
      end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'))
    } else {
      try {
        var provider = self._providers[currentProvider]
        provider.handleRequest(payload, next, end)
      } catch (e) {
        end(e)
      }
    }
  }

  function end(_error, _result) {
    error = _error
    result = _result

    eachSeries(stack, function(fn, callback) {

      if (fn) {
        fn(error, result, callback)
      } else {
        callback()
      }
    }, function() {

      var resultObj = {
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        result: result
      }

      if (error != null) {
        resultObj.error = {
          message: error.stack || error.message || error,
          code: -32000
        }
        // respond with both error formats
        finished(error, resultObj)
      } else {
        finished(null, resultObj)
      }
    })
  }
}

//
// from remote-data
//

Web3ProviderEngine.prototype._setCurrentBlock = function(block){
  const self = this
  self.currentBlock = block
  self.emit('block', block)
}

// util

function toBufferBlock (jsonBlock) {
  return {
    number:           ethUtil.toBuffer(jsonBlock.number),
    hash:             ethUtil.toBuffer(jsonBlock.hash),
    parentHash:       ethUtil.toBuffer(jsonBlock.parentHash),
    nonce:            ethUtil.toBuffer(jsonBlock.nonce),
    mixHash:          ethUtil.toBuffer(jsonBlock.mixHash),
    sha3Uncles:       ethUtil.toBuffer(jsonBlock.sha3Uncles),
    logsBloom:        ethUtil.toBuffer(jsonBlock.logsBloom),
    transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),
    stateRoot:        ethUtil.toBuffer(jsonBlock.stateRoot),
    receiptsRoot:     ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
    miner:            ethUtil.toBuffer(jsonBlock.miner),
    difficulty:       ethUtil.toBuffer(jsonBlock.difficulty),
    totalDifficulty:  ethUtil.toBuffer(jsonBlock.totalDifficulty),
    size:             ethUtil.toBuffer(jsonBlock.size),
    extraData:        ethUtil.toBuffer(jsonBlock.extraData),
    gasLimit:         ethUtil.toBuffer(jsonBlock.gasLimit),
    gasUsed:          ethUtil.toBuffer(jsonBlock.gasUsed),
    timestamp:        ethUtil.toBuffer(jsonBlock.timestamp),
    transactions:     jsonBlock.transactions,
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\base.js", {"eth-query":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-query\\index.js","pify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\pify\\index.js","safe-event-emitter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-event-emitter\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-block-tracker\src\base.js
      return function (require, module, exports) {
const EthQuery = require('eth-query')
const pify = require('pify')
const SafeEventEmitter = require('safe-event-emitter')

const sec = 1000

const calculateSum = (accumulator, currentValue) => accumulator + currentValue
const blockTrackerEvents = ['sync', 'latest']

class BaseBlockTracker extends SafeEventEmitter {

  //
  // public
  //

  constructor (opts = {}) {
    super()
    // config
    this._blockResetDuration = opts.blockResetDuration || 20 * sec
    // state
    this._blockResetTimeout
    this._currentBlock = null
    this._isRunning = false
    // bind functions for internal use
    this._onNewListener = this._onNewListener.bind(this)
    this._onRemoveListener = this._onRemoveListener.bind(this)
    this._resetCurrentBlock = this._resetCurrentBlock.bind(this)
    // listen for handler changes
    this._setupInternalEvents()
  }

  isRunning () {
    return this._isRunning
  }

  getCurrentBlock () {
    return this._currentBlock
  }

  async getLatestBlock () {
    // return if available
    if (this._currentBlock) return this._currentBlock
    // wait for a new latest block
    const latestBlock = await new Promise(resolve => this.once('latest', resolve))
    // return newly set current block
    return latestBlock
  }

  // dont allow module consumer to remove our internal event listeners
  removeAllListeners (eventName) {
    // perform default behavior, preserve fn arity
    if (eventName) {
      super.removeAllListeners(eventName)
    } else {
      super.removeAllListeners()
    }
    // re-add internal events
    this._setupInternalEvents()
    // trigger stop check just in case
    this._onRemoveListener()
  }

  //
  // to be implemented in subclass
  //

  _start () {
    // default behavior is noop
  }

  _end () {
    // default behavior is noop
  }

  //
  // private
  //

  _setupInternalEvents () {
    // first remove listeners for idempotence
    this.removeListener('newListener', this._onNewListener)
    this.removeListener('removeListener', this._onRemoveListener)
    // then add them
    this.on('newListener', this._onNewListener)
    this.on('removeListener', this._onRemoveListener)
  }

  _onNewListener (eventName, handler) {
    // `newListener` is called *before* the listener is added
    if (!blockTrackerEvents.includes(eventName)) return
    this._maybeStart()
  }

  _onRemoveListener (eventName, handler) {
    // `removeListener` is called *after* the listener is removed
    if (this._getBlockTrackerEventCount() > 0) return
    this._maybeEnd()
  }

  _maybeStart () {
    if (this._isRunning) return
    this._isRunning = true
    // cancel setting latest block to stale
    this._cancelBlockResetTimeout()
    this._start()
  }

  _maybeEnd () {
    if (!this._isRunning) return
    this._isRunning = false
    this._setupBlockResetTimeout()
    this._end()
  }

  _getBlockTrackerEventCount () {
    return blockTrackerEvents
      .map(eventName => this.listenerCount(eventName))
      .reduce(calculateSum)
  }

  _newPotentialLatest (newBlock) {
    const currentBlock = this._currentBlock
    // only update if blok number is higher
    if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) return
    this._setCurrentBlock(newBlock)
  }

  _setCurrentBlock (newBlock) {
    const oldBlock = this._currentBlock
    this._currentBlock = newBlock
    this.emit('latest', newBlock)
    this.emit('sync', { oldBlock, newBlock })
  }

  _setupBlockResetTimeout () {
    // clear any existing timeout
    this._cancelBlockResetTimeout()
    // clear latest block when stale
    this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration)
    // nodejs - dont hold process open
    if (this._blockResetTimeout.unref) {
      this._blockResetTimeout.unref()
    }
  }

  _cancelBlockResetTimeout () {
    clearTimeout(this._blockResetTimeout)
  }

  _resetCurrentBlock () {
    this._currentBlock = null
  }

}

module.exports = BaseBlockTracker

function hexToInt(hexInt) {
  return Number.parseInt(hexInt, 16)
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-block-tracker",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\polling.js", {"./base":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\base.js","pify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\pify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-block-tracker\src\polling.js
      return function (require, module, exports) {
const pify = require('pify')
const BaseBlockTracker = require('./base')

const sec = 1000

class PollingBlockTracker extends BaseBlockTracker {

  constructor (opts = {}) {
    // parse + validate args
    if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.')
    const pollingInterval = opts.pollingInterval || 20 * sec
    const retryTimeout = opts.retryTimeout || pollingInterval / 10
    const keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true
    const setSkipCacheFlag = opts.setSkipCacheFlag || false
    // BaseBlockTracker constructor
    super(Object.assign({
      blockResetDuration: pollingInterval,
    }, opts))
    // config
    this._provider = opts.provider
    this._pollingInterval = pollingInterval
    this._retryTimeout = retryTimeout
    this._keepEventLoopActive = keepEventLoopActive
    this._setSkipCacheFlag = setSkipCacheFlag
  }

  //
  // public
  //

  // trigger block polling
  async checkForLatestBlock () {
    await this._updateLatestBlock()
    return await this.getLatestBlock()
  }

  //
  // private
  //

  _start () {
    this._performSync().catch(err => this.emit('error', err))
  }

  async _performSync () {
    while (this._isRunning) {
      try {
        await this._updateLatestBlock()
        await timeout(this._pollingInterval, !this._keepEventLoopActive)
      } catch (err) {
        const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`)
        try {
          this.emit('error', newErr)
        } catch (emitErr) {
          console.error(newErr)
        }
        await timeout(this._retryTimeout, !this._keepEventLoopActive)
      }
    }
  }

  async _updateLatestBlock () {
    // fetch + set latest block
    const latestBlock = await this._fetchLatestBlock()
    this._newPotentialLatest(latestBlock)
  }

  async _fetchLatestBlock () {
    const req = { jsonrpc: "2.0", id: 1, method: 'eth_blockNumber', params: [] }
    if (this._setSkipCacheFlag) req.skipCache = true
    const res = await pify((cb) => this._provider.sendAsync(req, cb))()
    if (res.error) throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error}`)
    return res.result
  }

}

module.exports = PollingBlockTracker

function timeout (duration, unref) {
  return new Promise(resolve => {
    const timoutRef = setTimeout(resolve, duration)
    // don't keep process open
    if (timoutRef.unref && unref) {
      timoutRef.unref()
    }
  })
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-block-tracker",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\block-cache.js", {"./cache-utils.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\cache-utils.js","json-rpc-engine/src/createAsyncMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\block-cache.js
      return function (require, module, exports) {
const cacheUtils = require('./cache-utils.js')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
const emptyValues = [undefined, null, '\u003cnil\u003e']

module.exports = createBlockCacheMiddleware


function createBlockCacheMiddleware(opts = {}) {
  // validate options
  const { blockTracker } = opts
  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')

  // create caching strategies
  const blockCache = new BlockCacheStrategy()
  const strategies = {
    perma: blockCache,
    block: blockCache,
    fork: blockCache,
  }

  return createAsyncMiddleware(async (req, res, next) => {
    // allow cach to be skipped if so specified
    if (req.skipCache) {
      return next()
    }
    // check type and matching strategy
    const type = cacheUtils.cacheTypeForPayload(req)
    const strategy = strategies[type]
    // If there's no strategy in place, pass it down the chain.
    if (!strategy) {
      return next()
    }
    // If the strategy can't cache this request, ignore it.
    if (!strategy.canCacheRequest(req)) {
      return next()
    }

    // get block reference (number or keyword)
    let blockTag = cacheUtils.blockTagForPayload(req)
    if (!blockTag) blockTag = 'latest'

    // get exact block number
    let requestedBlockNumber
    if (blockTag === 'earliest') {
      // this just exists for symmetry with "latest"
      requestedBlockNumber = '0x00'
    } else if (blockTag === 'latest') {
      // fetch latest block number
      const latestBlockNumber = await blockTracker.getLatestBlock()
      // clear all cache before latest block
      blockCache.clearBefore(latestBlockNumber)
      requestedBlockNumber = latestBlockNumber
    } else {
      // We have a hex number
      requestedBlockNumber = blockTag
    }

    // end on a hit, continue on a miss
    const cacheResult = await strategy.get(req, requestedBlockNumber)
    if (cacheResult === undefined) {
      // cache miss
      // wait for other middleware to handle request
      await next()
      // add result to cache
      await strategy.set(req, requestedBlockNumber, res.result)
    } else {
      // fill in result from cache
      res.result = cacheResult
    }
  })
}


//
// Cache Strategies
//

class BlockCacheStrategy {
  
  constructor () {
    this.cache = {}
  }

  getBlockCacheForPayload (payload, blockNumberHex) {
    const blockNumber = Number.parseInt(blockNumberHex, 16)
    let blockCache = this.cache[blockNumber]
    // create new cache if necesary
    if (!blockCache) {
      const newCache = {}
      this.cache[blockNumber] = newCache
      blockCache = newCache
    }
    return blockCache
  }

  async get (payload, requestedBlockNumber) {
    // lookup block cache
    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)
    if (!blockCache) return
    // lookup payload in block cache
    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)
    const cached = blockCache[identifier]
    // may be undefined
    return cached
  }

  async set (payload, requestedBlockNumber, result) {
    // check if we can cached this result
    const canCache = this.canCacheResult(payload, result)
    if (!canCache) return
    // set the value in the cache
    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)
    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)
    blockCache[identifier] = result
  }

  canCacheRequest (payload) {
    // check request method
    if (!cacheUtils.canCache(payload)) {
      return false
    }
    // check blockTag
    const blockTag = cacheUtils.blockTagForPayload(payload)
    if (blockTag === 'pending') {
      return false
    }
    // can be cached
    return true
  }

  canCacheResult (payload, result) {
    // never cache empty values (e.g. undefined)
    if (emptyValues.includes(result)) return
    // check if transactions have block reference before caching
    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {
        return false
      }
    }
    // otherwise true
    return true
  }

  // removes all block caches with block number lower than `oldBlockHex`
  clearBefore (oldBlockHex){
    const self = this
    const oldBlockNumber = Number.parseInt(oldBlockHex, 16)
    // clear old caches
    Object.keys(self.cache)
      .map(Number)
      .filter(num => num < oldBlockNumber)
      .forEach(num => delete self.cache[num])
  }

}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\cache-utils.js", {"json-stable-stringify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-stable-stringify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\cache-utils.js
      return function (require, module, exports) {
const stringify = require('json-stable-stringify')

module.exports = {
  cacheIdentifierForPayload: cacheIdentifierForPayload,
  canCache: canCache,
  blockTagForPayload: blockTagForPayload,
  paramsWithoutBlockTag: paramsWithoutBlockTag,
  blockTagParamIndex: blockTagParamIndex,
  cacheTypeForPayload: cacheTypeForPayload
}

function cacheIdentifierForPayload (payload, skipBlockRef) {
  const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params
  if (canCache(payload)) {
    return payload.method + ':' + stringify(simpleParams)
  } else {
    return null
  }
}

function canCache (payload) {
  return cacheTypeForPayload(payload) !== 'never'
}

function blockTagForPayload (payload) {
  let index = blockTagParamIndex(payload)

  // Block tag param not passed.
  if (index >= payload.params.length) {
    return null
  }

  return payload.params[index]
}

function paramsWithoutBlockTag (payload) {
  const index = blockTagParamIndex(payload)

  // Block tag param not passed.
  if (index >= payload.params.length) {
    return payload.params
  }

  // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
  if (payload.method === 'eth_getBlockByNumber') {
    return payload.params.slice(1)
  }

  return payload.params.slice(0, index)
}

function blockTagParamIndex (payload) {
  switch (payload.method) {
    // blockTag is at index 2
    case 'eth_getStorageAt':
      return 2
    // blockTag is at index 1
    case 'eth_getBalance':
    case 'eth_getCode':
    case 'eth_getTransactionCount':
    case 'eth_call':
      return 1
    // blockTag is at index 0
    case 'eth_getBlockByNumber':
      return 0
    // there is no blockTag
    default:
      return undefined
  }
}

function cacheTypeForPayload (payload) {
  switch (payload.method) {
    // cache permanently
    case 'web3_clientVersion':
    case 'web3_sha3':
    case 'eth_protocolVersion':
    case 'eth_getBlockTransactionCountByHash':
    case 'eth_getUncleCountByBlockHash':
    case 'eth_getCode':
    case 'eth_getBlockByHash':
    case 'eth_getTransactionByHash':
    case 'eth_getTransactionByBlockHashAndIndex':
    case 'eth_getTransactionReceipt':
    case 'eth_getUncleByBlockHashAndIndex':
    case 'eth_getCompilers':
    case 'eth_compileLLL':
    case 'eth_compileSolidity':
    case 'eth_compileSerpent':
    case 'shh_version':
    case 'test_permaCache':
      return 'perma'

    // cache until fork
    case 'eth_getBlockByNumber':
    case 'eth_getBlockTransactionCountByNumber':
    case 'eth_getUncleCountByBlockNumber':
    case 'eth_getTransactionByBlockNumberAndIndex':
    case 'eth_getUncleByBlockNumberAndIndex':
    case 'test_forkCache':
      return 'fork'

    // cache for block
    case 'eth_gasPrice':
    case 'eth_blockNumber':
    case 'eth_getBalance':
    case 'eth_getStorageAt':
    case 'eth_getTransactionCount':
    case 'eth_call':
    case 'eth_estimateGas':
    case 'eth_getFilterLogs':
    case 'eth_getLogs':
    case 'test_blockCache':
      return 'block'

    // never cache
    case 'net_version':
    case 'net_peerCount':
    case 'net_listening':
    case 'eth_syncing':
    case 'eth_sign':
    case 'eth_coinbase':
    case 'eth_mining':
    case 'eth_hashrate':
    case 'eth_accounts':
    case 'eth_sendTransaction':
    case 'eth_sendRawTransaction':
    case 'eth_newFilter':
    case 'eth_newBlockFilter':
    case 'eth_newPendingTransactionFilter':
    case 'eth_uninstallFilter':
    case 'eth_getFilterChanges':
    case 'eth_getWork':
    case 'eth_submitWork':
    case 'eth_submitHashrate':
    case 'db_putString':
    case 'db_getString':
    case 'db_putHex':
    case 'db_getHex':
    case 'shh_post':
    case 'shh_newIdentity':
    case 'shh_hasIdentity':
    case 'shh_newGroup':
    case 'shh_addToGroup':
    case 'shh_newFilter':
    case 'shh_uninstallFilter':
    case 'shh_getFilterChanges':
    case 'shh_getMessages':
    case 'test_neverCache':
      return 'never'
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\fetch.js", {"btoa":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\btoa\\index.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\index.js","json-rpc-engine/src/createAsyncMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js","node-fetch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\node-fetch\\browser.js","url":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\url\\url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\fetch.js
      return function (require, module, exports) {
const fetch = global.fetch || require('node-fetch')
const url = require('url')
const { ethErrors } = require('eth-rpc-errors')
const btoa = require('btoa')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')


module.exports = createFetchMiddleware
module.exports.createFetchConfigFromReq = createFetchConfigFromReq

const RETRIABLE_ERRORS = [
  // ignore server overload errors
  'Gateway timeout',
  'ETIMEDOUT',
  // ignore server sent html error pages
  // or truncated json responses
  'failed to parse response body',
  // ignore errors where http req failed to establish
  'Failed to fetch',
]

function createFetchMiddleware ({ rpcUrl, originHttpHeaderKey }) {
  return createAsyncMiddleware(async (req, res, next) => {
    const { fetchUrl, fetchParams } = createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey })

    // attempt request multiple times
    const maxAttempts = 5
    const retryInterval = 1000
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      try {
        const fetchRes = await fetch(fetchUrl, fetchParams)
        // check for http errrors
        checkForHttpErrors(fetchRes)
        // parse response body
        const rawBody = await fetchRes.text()
        let fetchBody
        try {
          fetchBody = JSON.parse(rawBody)
        } catch (_) {
          throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`)
        }
        const result = parseResponse(fetchRes, fetchBody)
        // set result and exit retry loop
        res.result = result
        return
      } catch (err) {
        const errMsg = err.toString()
        const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase))
        // re-throw error if not retriable
        if (!isRetriable) throw err
      }
      // delay before retrying
      await timeout(retryInterval)
    }
  })
}

function checkForHttpErrors (fetchRes) {
  // check for errors
  switch (fetchRes.status) {
    case 405:
      throw ethErrors.rpc.methodNotFound()

    case 418:
      throw createRatelimitError()

    case 503:
    case 504:
      throw createTimeoutError()
  }
}

function parseResponse (fetchRes, body) {
  // check for error code
  if (fetchRes.status !== 200) {
    throw ethErrors.rpc.internal({
      message: `Non-200 status code: '${fetchRes.status}'`,
      data: body,
    })
  }
  // check for rpc error
  if (body.error) throw ethErrors.rpc.internal({
    data: body.error,
  })
  // return successful result
  return body.result
}

function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey }) {
  const parsedUrl = url.parse(rpcUrl)
  const fetchUrl = normalizeUrlFromParsed(parsedUrl)

  // prepare payload
  // copy only canonical json rpc properties
  const payload = {
    id: req.id,
    jsonrpc: req.jsonrpc,
    method: req.method,
    params: req.params,
  }

  // extract 'origin' parameter from request
  const originDomain = req.origin

  // serialize request body
  const serializedPayload = JSON.stringify(payload)

  // configure fetch params
  const fetchParams = {
    method: 'POST',
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/json'
    },
    body: serializedPayload,
  }

  // encoded auth details as header (not allowed in fetch url)
  if (parsedUrl.auth) {
    const encodedAuth = btoa(parsedUrl.auth)
    fetchParams.headers['Authorization'] = `Basic ${encodedAuth}`
  }

  // optional: add request origin as header
  if (originHttpHeaderKey && originDomain) {
    fetchParams.headers[originHttpHeaderKey] = originDomain
  }

  return { fetchUrl, fetchParams }
}

function normalizeUrlFromParsed(parsedUrl) {
  let result = ''
  result += parsedUrl.protocol
  if (parsedUrl.slashes) result += '//'
  result += parsedUrl.hostname
  if (parsedUrl.port) {
    result += `:${parsedUrl.port}`
  }
  result += `${parsedUrl.path}`
  return result
}

function createRatelimitError () {
  return ethErrors.rpc.internal({ message: `Request is being rate limited.` })
}

function createTimeoutError () {
  let msg = `Gateway timeout. The request took too long to process. `
  msg += `This can happen when querying logs over too wide a block range.`
  return ethErrors.rpc.internal({ message: msg })
}

function timeout(duration) {
  return new Promise(resolve => setTimeout(resolve, duration))
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\inflight-cache.js", {"./cache-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\cache-utils.js","clone":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\clone\\clone.js","json-rpc-engine/src/createAsyncMiddleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\inflight-cache.js
      return function (require, module, exports) {
const clone = require('clone')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const cacheIdentifierForPayload = require('./cache-utils').cacheIdentifierForPayload

module.exports = createInflightCache


function createInflightCache () {
  const inflightRequests = {}

  return createAsyncMiddleware(async (req, res, next) => {
    // allow cach to be skipped if so specified
    if (req.skipCache) return next()
    // get cacheId, if cacheable
    const cacheId = cacheIdentifierForPayload(req)
    // if not cacheable, skip
    if (!cacheId) return next()
    // check for matching requests
    let activeRequestHandlers = inflightRequests[cacheId]
    // if found, wait for the active request to be handled
    if (activeRequestHandlers) {
      // setup the response listener and wait for it to be called
      // it will handle copying the result and request fields
      await createActiveRequestHandler(res, activeRequestHandlers)
      return
    }
    // setup response handler array for subsequent requests
    activeRequestHandlers = []
    inflightRequests[cacheId] = activeRequestHandlers
    // allow request to be handled normally
    await next()
    // clear inflight requests
    delete inflightRequests[cacheId]
    // schedule activeRequestHandlers to be handled
    handleActiveRequest(res, activeRequestHandlers)
    // complete
    return
  })

  function createActiveRequestHandler(res, activeRequestHandlers) {
    const { resolve, promise } = deferredPromise()
    activeRequestHandlers.push((handledRes) => {
      // append a copy of the result and error to the response
      res.result = clone(handledRes.result)
      res.error = clone(handledRes.error)
      resolve()
    })
    return promise
  }

  function handleActiveRequest(res, activeRequestHandlers) {
    // use setTimeout so we can resolve our original request first
    setTimeout(() => {
      activeRequestHandlers.forEach((handler) => {
        try {
          handler(res)
        } catch (err) {
          // catch error so all requests are handled correctly
          console.error(err)
        }
      })
    })
  }
}

function deferredPromise() {
  let resolve
  const promise = new Promise(_resolve => { resolve = _resolve })
  return { resolve, promise }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\index.js", {"./src/classes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js","./src/errorCodes.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json","./src/errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errors.js","./src/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\index.js
      return function (require, module, exports) {

const { EthereumRpcError, EthereumProviderError } = require('./src/classes')
const {
  serializeError, getMessageFromCode,
} = require('./src/utils')
const ethErrors = require('./src/errors')
const ERROR_CODES = require('./src/errorCodes.json')

module.exports = {
  ethErrors,
  EthereumRpcError,
  EthereumProviderError,
  serializeError,
  getMessageFromCode,

  /** @type ErrorCodes */
  ERROR_CODES,
}

// Types

/**
 * @typedef {Object} EthereumProviderErrorCodes
 * @property {number} userRejectedRequest
 * @property {number} unauthorized
 * @property {number} unsupportedMethod
 * @property {number} disconnected
 * @property {number} chainDisconnected
 */

/**
 * @typedef {Object} EthereumRpcErrorCodes
 * @property {number} parse
 * @property {number} invalidRequest
 * @property {number} invalidParams
 * @property {number} methodNotFound
 * @property {number} limitExceeded
 * @property {number} internal
 * @property {number} invalidInput
 * @property {number} resourceNotFound
 * @property {number} resourceUnavailable
 * @property {number} transactionRejected
 * @property {number} methodNotSupported
 */

/**
 * @typedef ErrorCodes
 * @property {EthereumRpcErrorCodes} rpc
 * @property {EthereumProviderErrorCodes} provider
 */

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-rpc-errors",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js", {"fast-safe-stringify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\fast-safe-stringify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\classes.js
      return function (require, module, exports) {

const safeStringify = require('fast-safe-stringify')

/**
 * @class JsonRpcError
 * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
 * per EIP 1474.
 * Permits any integer error code.
 */
class EthereumRpcError extends Error {

  /**
   * Create an Ethereum JSON RPC error.
   *
   * @param {number} code - The integer error code.
   * @param {string} message - The string message.
   * @param {any} [data] - The error data.
   */
  constructor (code, message, data) {

    if (!Number.isInteger(code)) {
      throw new Error(
        '"code" must be an integer.',
      )
    }
    if (!message || typeof message !== 'string') {
      throw new Error(
        '"message" must be a nonempty string.',
      )
    }

    super(message)
    this.code = code
    if (data !== undefined) {
      this.data = data
    }
  }

  /**
   * Returns a plain object with all public class properties.
   *
   * @returns {object} The serialized error.
   */
  serialize () {
    const serialized = {
      code: this.code,
      message: this.message,
    }
    if (this.data !== undefined) {
      serialized.data = this.data
    }
    if (this.stack) {
      serialized.stack = this.stack
    }
    return serialized
  }

  /**
   * Return a string representation of the serialized error, omitting
   * any circular references.
   *
   * @returns {string} The serialized error as a string.
   */
  toString () {
    return safeStringify(
      this.serialize(),
      stringifyReplacer,
      2,
    )
  }
}

/**
 * @class EthereumRpcError
 * Error subclass implementing Ethereum Provider errors per EIP 1193.
 * Permits integer error codes in the [ 1000 <= 4999 ] range.
 */
class EthereumProviderError extends EthereumRpcError {

  /**
   * Create an Ethereum JSON RPC error.
   *
   * @param {number} code - The integer error code, in the [ 1000 <= 4999 ] range.
   * @param {string} message - The string message.
   * @param {any} [data] - The error data.
   */
  constructor (code, message, data) {

    if (!isValidEthProviderCode(code)) {
      throw new Error(
        '"code" must be an integer such that: 1000 <= code <= 4999',
      )
    }

    super(code, message, data)
  }
}

// Internal

function isValidEthProviderCode (code) {
  return Number.isInteger(code) && code >= 1000 && code <= 4999
}

function stringifyReplacer (_, value) {
  if (value === '[Circular]') {
    return undefined
  }
  return value
}

// Exports

module.exports = {
  EthereumRpcError,
  EthereumProviderError,
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-rpc-errors",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\errorCodes.json
      return function (require, module, exports) {
module.exports={
  "rpc": {
    "invalidInput": -32000,
    "resourceNotFound": -32001,
    "resourceUnavailable": -32002,
    "transactionRejected": -32003,
    "methodNotSupported": -32004,
    "limitExceeded": -32005,
    "parse": -32700,
    "invalidRequest": -32600,
    "methodNotFound": -32601,
    "invalidParams": -32602,
    "internal": -32603
  },
  "provider": {
    "userRejectedRequest": 4001,
    "unauthorized": 4100,
    "unsupportedMethod": 4200,
    "disconnected": 4900,
    "chainDisconnected": 4901
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-rpc-errors",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorValues.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\errorValues.json
      return function (require, module, exports) {
module.exports={
  "-32700": {
    "standard": "JSON RPC 2.0",
    "message": "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
  },
  "-32600": {
    "standard": "JSON RPC 2.0",
    "message": "The JSON sent is not a valid Request object."
  },
  "-32601": {
    "standard": "JSON RPC 2.0",
    "message": "The method does not exist / is not available."
  },
  "-32602": {
    "standard": "JSON RPC 2.0",
    "message": "Invalid method parameter(s)."
  },
  "-32603": {
    "standard": "JSON RPC 2.0",
    "message": "Internal JSON-RPC error."
  },
  "-32000": {
    "standard": "EIP 1474",
    "message": "Invalid input."
  },
  "-32001": {
    "standard": "EIP 1474",
    "message": "Resource not found."
  },
  "-32002": {
    "standard": "EIP 1474",
    "message": "Resource unavailable."
  },
  "-32003": {
    "standard": "EIP 1474",
    "message": "Transaction rejected."
  },
  "-32004": {
    "standard": "EIP 1474",
    "message": "Method not supported."
  },
  "-32005": {
    "standard": "EIP 1474",
    "message": "Request limit exceeded."
  },
  "4001": {
    "standard": "EIP 1193",
    "message": "User rejected the request."
  },
  "4100": {
    "standard": "EIP 1193",
    "message": "The requested account and/or method has not been authorized by the user."
  },
  "4200": {
    "standard": "EIP 1193",
    "message": "The requested method is not supported by this Ethereum provider."
  },
  "4900": {
    "standard": "EIP 1193",
    "message": "The provider is disconnected from all chains."
  },
  "4901": {
    "standard": "EIP 1193",
    "message": "The provider is disconnected from the specified chain."
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-rpc-errors",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errors.js", {"./classes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js","./errorCodes.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json","./utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\errors.js
      return function (require, module, exports) {

const { EthereumRpcError, EthereumProviderError } = require('./classes')
const { getMessageFromCode } = require('./utils')
const ERROR_CODES = require('./errorCodes.json')

module.exports = {
  rpc: {

    /**
     * Get a JSON RPC 2.0 Parse (-32700) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    parse: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.parse, opts,
    ),

    /**
     * Get a JSON RPC 2.0 Invalid Request (-32600) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    invalidRequest: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.invalidRequest, opts,
    ),

    /**
     * Get a JSON RPC 2.0 Invalid Params (-32602) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    invalidParams: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.invalidParams, opts,
    ),

    /**
     * Get a JSON RPC 2.0 Method Not Found (-32601) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    methodNotFound: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.methodNotFound, opts,
    ),

    /**
     * Get a JSON RPC 2.0 Internal (-32603) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    internal: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.internal, opts,
    ),

    /**
     * Get a JSON RPC 2.0 Server error.
     * Permits integer error codes in the [ -32099 <= -32005 ] range.
     * Codes -32000 through -32004 are reserved by EIP 1474.
     *
     * @param {Object|string} opts - Options object
     * @param {number} opts.code - The error code
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    server: (opts) => {
      if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
        throw new Error('Ethereum RPC Server errors must provide single object argument.')
      }
      const { code } = opts
      if (!Number.isInteger(code) || code > -32005 || code < -32099) {
        throw new Error(
          '"code" must be an integer such that: -32099 <= code <= -32005',
        )
      }
      return getEthJsonRpcError(code, opts)
    },

    /**
     * Get an Ethereum JSON RPC Invalid Input (-32000) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    invalidInput: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.invalidInput, opts,
    ),

    /**
     * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    resourceNotFound: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.resourceNotFound, opts,
    ),

    /**
     * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    resourceUnavailable: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.resourceUnavailable, opts,
    ),

    /**
     * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    transactionRejected: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.transactionRejected, opts,
    ),

    /**
     * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    methodNotSupported: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.methodNotSupported, opts,
    ),

    /**
     * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumRpcError} The error
     */
    limitExceeded: (opts) => getEthJsonRpcError(
      ERROR_CODES.rpc.limitExceeded, opts,
    ),
  },

  provider: {

    /**
     * Get an Ethereum Provider User Rejected Request (4001) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumProviderError} The error
     */
    userRejectedRequest: (opts) => {
      return getEthProviderError(
        ERROR_CODES.provider.userRejectedRequest, opts,
      )
    },

    /**
     * Get an Ethereum Provider Unauthorized (4100) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumProviderError} The error
     */
    unauthorized: (opts) => {
      return getEthProviderError(
        ERROR_CODES.provider.unauthorized, opts,
      )
    },

    /**
     * Get an Ethereum Provider Unsupported Method (4200) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumProviderError} The error
     */
    unsupportedMethod: (opts) => {
      return getEthProviderError(
        ERROR_CODES.provider.unsupportedMethod, opts,
      )
    },

    /**
     * Get an Ethereum Provider Not Connected (4900) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumProviderError} The error
     */
    disconnected: (opts) => {
      return getEthProviderError(
        ERROR_CODES.provider.disconnected, opts,
      )
    },

    /**
     * Get an Ethereum Provider Chain Not Connected (4901) error.
     *
     * @param {Object|string} [opts] - Options object or error message string
     * @param {string} [opts.message] - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumProviderError} The error
     */
    chainDisconnected: (opts) => {
      return getEthProviderError(
        ERROR_CODES.provider.chainDisconnected, opts,
      )
    },

    /**
     * Get a custom Ethereum Provider error.
     *
     * @param {Object|string} opts - Options object
     * @param {number} opts.code - The error code
     * @param {string} opts.message - The error message
     * @param {any} [opts.data] - Error data
     * @returns {EthereumProviderError} The error
     */
    custom: (opts) => {
      if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
        throw new Error('Ethereum Provider custom errors must provide single object argument.')
      }
      const { code, message, data } = opts
      if (!message || typeof message !== 'string') {
        throw new Error(
          '"message" must be a nonempty string',
        )
      }
      return new EthereumProviderError(code, message, data)
    },
  },
}

// Internal

function getEthJsonRpcError (code, opts) {
  const [message, data] = validateOpts(opts)
  return new EthereumRpcError(
    code,
    message || getMessageFromCode(code),
    data,
  )
}

function getEthProviderError (code, opts) {
  const [message, data] = validateOpts(opts)
  return new EthereumProviderError(
    code,
    message || getMessageFromCode(code),
    data,
  )
}

function validateOpts (opts) {
  if (opts) {
    if (typeof opts === 'string') {
      return [opts]
    } else if (typeof opts === 'object' && !Array.isArray(opts)) {
      const { message, data } = opts
      return [message, data]
    }
  }
  return []
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-rpc-errors",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\utils.js", {"./classes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js","./errorCodes.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json","./errorValues.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorValues.json"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\utils.js
      return function (require, module, exports) {

const errorValues = require('./errorValues.json')
const FALLBACK_ERROR_CODE = require('./errorCodes.json').rpc.internal
const { EthereumRpcError } = require('./classes')

const JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.'

const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.'

const FALLBACK_ERROR = {
  code: FALLBACK_ERROR_CODE,
  message: getMessageFromCode(FALLBACK_ERROR_CODE),
}

/**
 * Gets the message for a given code, or a fallback message if the code has
 * no corresponding message.
 *
 * @param {number} code - The integer error code
 * @param {string} fallbackMessage - The fallback message
 * @return {string} The corresponding message or the fallback message
 */
function getMessageFromCode (code, fallbackMessage = FALLBACK_MESSAGE) {

  if (Number.isInteger(code)) {

    const codeString = code.toString()

    if (errorValues[codeString]) {
      return errorValues[codeString].message
    }
    if (isJsonRpcServerError(code)) {
      return JSON_RPC_SERVER_ERROR_MESSAGE
    }
  }
  return fallbackMessage
}

/**
 * Returns whether the given code is valid.
 * A code is only valid if it has a message.
 *
 * @param {number} code - The code to check
 * @return {boolean} true if the code is valid, false otherwise.
 */
function isValidCode (code) {

  if (!Number.isInteger(code)) {
    return false
  }

  const codeString = code.toString()
  if (errorValues[codeString]) {
    return true
  }

  if (isJsonRpcServerError(code)) {
    return true
  }

  // TODO: allow valid codes and messages to be extended
  // // EIP 1193 Status Codes
  // if (code >= 4000 && code <= 4999) return true

  return false
}

/**
 * Serializes the given error to an Ethereum JSON RPC-compatible error object.
 * Merely copies the given error's values if it is already compatible.
 * If the given error is not fully compatible, it will be preserved on the
 * returned object's data.originalError property.
 *
 * @param {any} error - The error to serialize.
 * @param {Object} [options] - An options object.
 * @param {Object} [options.fallbackError] - The custom fallback error values if
 * the given error is invalid.
 * @param {boolean} [options.shouldIncludeStack] - Whether the 'stack' property
 * of the given error should be included on the serialized error, if present.
 * @return {Object} A standardized, plain error object.
 */
function serializeError (
  error,
  { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {},
) {

  if (
    !fallbackError ||
    !Number.isInteger(fallbackError.code) ||
    typeof fallbackError.message !== 'string'
  ) {
    throw new Error(
      'Must provide fallback error with integer number code and string message.',
    )
  }

  if (error instanceof EthereumRpcError) {
    return error.serialize()
  }

  const serialized = {}

  if (error && isValidCode(error.code)) {

    serialized.code = error.code

    if (error.message && typeof error.message === 'string') {
      serialized.message = error.message
      if ('data' in error) {
        serialized.data = error.data
      }
    } else {
      serialized.message = getMessageFromCode(serialized.code)
      serialized.data = { originalError: assignOriginalError(error) }
    }

  } else {
    serialized.code = fallbackError.code
    serialized.message = (
      error && error.message
        ? error.message
        : fallbackError.message
    )
    serialized.data = { originalError: assignOriginalError(error) }
  }

  if (shouldIncludeStack && error && typeof error.stack === 'string') {
    serialized.stack = error.stack
  }
  return serialized
}

// Internal

function isJsonRpcServerError (code) {
  return code >= -32099 && code <= -32000
}

function assignOriginalError (error) {
  if (error && typeof error === 'object' && !Array.isArray(error)) {
    return { ...error }
  }
  return error
}

// Exports

module.exports = {
  getMessageFromCode,
  isValidCode,
  serializeError,
  JSON_RPC_SERVER_ERROR_MESSAGE,
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-rpc-errors",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-sig-util\\index.js", {"ethereumjs-abi":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-sig-util\index.js
      return function (require, module, exports) {
const ethUtil = require('ethereumjs-util')
const ethAbi = require('ethereumjs-abi')

module.exports = {

  concatSig: function (v, r, s) {
    const rSig = ethUtil.fromSigned(r)
    const sSig = ethUtil.fromSigned(s)
    const vSig = ethUtil.bufferToInt(v)
    const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
    const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
    const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
    return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
  },

  normalize: function (input) {
    if (!input) return

    if (typeof input === 'number') {
      const buffer = ethUtil.toBuffer(input)
      input = ethUtil.bufferToHex(buffer)
    }

    if (typeof input !== 'string') {
      var msg = 'eth-sig-util.normalize() requires hex string or integer input.'
      msg += ' received ' + (typeof input) + ': ' + input
      throw new Error(msg)
    }

    return ethUtil.addHexPrefix(input.toLowerCase())
  },

  personalSign: function (privateKey, msgParams) {
    var message = ethUtil.toBuffer(msgParams.data)
    var msgHash = ethUtil.hashPersonalMessage(message)
    var sig = ethUtil.ecsign(msgHash, privateKey)
    var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
    return serialized
  },

  recoverPersonalSignature: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    const sender = ethUtil.publicToAddress(publicKey)
    const senderHex = ethUtil.bufferToHex(sender)
    return senderHex
  },

  extractPublicKey: function (msgParams) {
    const publicKey = getPublicKeyFor(msgParams)
    return '0x' + publicKey.toString('hex')
  },

  typedSignatureHash: function (typedData) {
    const hashBuffer = typedSignatureHash(typedData)
    return ethUtil.bufferToHex(hashBuffer)
  },

  signTypedData: function (privateKey, msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const sig = ethUtil.ecsign(msgHash, privateKey)
    return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
  },

  recoverTypedSignature: function (msgParams) {
    const msgHash = typedSignatureHash(msgParams.data)
    const publicKey = recoverPublicKey(msgHash, msgParams.sig)
    const sender = ethUtil.publicToAddress(publicKey)
    return ethUtil.bufferToHex(sender)
  }

}

/**
 * @param typedData - Array of data along with types, as per EIP712.
 * @returns Buffer
 */
function typedSignatureHash(typedData) {
  const error = new Error('Expect argument to be non-empty array')
  if (typeof typedData !== 'object' || !typedData.length) throw error

  const data = typedData.map(function (e) {
    return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
  })
  const types = typedData.map(function (e) { return e.type })
  const schema = typedData.map(function (e) {
    if (!e.name) throw error
    return e.type + ' ' + e.name
  })

  return ethAbi.soliditySHA3(
    ['bytes32', 'bytes32'],
    [
      ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
      ethAbi.soliditySHA3(types, data)
    ]
  )
}

function recoverPublicKey(hash, sig) {
  const signature = ethUtil.toBuffer(sig)
  const sigParams = ethUtil.fromRpcSig(signature)
  return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
}

function getPublicKeyFor (msgParams) {
  const message = ethUtil.toBuffer(msgParams.data)
  const msgHash = ethUtil.hashPersonalMessage(message)
  return recoverPublicKey(msgHash, msgParams.sig)
}


function padWithZeroes (number, length) {
  var myString = '' + number
  while (myString.length < length) {
    myString = '0' + myString
  }
  return myString
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-sig-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js", {"./secp256k1-adapter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js","assert":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\assert\\assert.js","bn.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","create-hash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\create-hash\\browser.js","ethereum-cryptography/keccak":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\keccak.js","ethjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethjs-util\\lib\\index.js","rlp":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js","safe-buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\index.js
      return function (require, module, exports) {
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _require = require('ethereum-cryptography/keccak'),
    keccak224 = _require.keccak224,
    keccak384 = _require.keccak384,
    k256 = _require.keccak256,
    keccak512 = _require.keccak512;

var secp256k1 = require('./secp256k1-adapter');
var assert = require('assert');
var rlp = require('rlp');
var BN = require('bn.js');
var createHash = require('create-hash');
var Buffer = require('safe-buffer').Buffer;
Object.assign(exports, require('ethjs-util'));

/**
 * the max integer that this VM can handle (a ```BN```)
 * @var {BN} MAX_INTEGER
 */
exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

/**
 * 2^256 (a ```BN```)
 * @var {BN} TWO_POW256
 */
exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

/**
 * Keccak-256 hash of null (a ```String```)
 * @var {String} KECCAK256_NULL_S
 */
exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

/**
 * Keccak-256 hash of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_NULL
 */
exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
exports.SHA3_NULL = exports.KECCAK256_NULL;

/**
 * Keccak-256 of an RLP of an empty array (a ```String```)
 * @var {String} KECCAK256_RLP_ARRAY_S
 */
exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

/**
 * Keccak-256 of an RLP of an empty array (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP_ARRAY
 */
exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

/**
 * Keccak-256 hash of the RLP of null  (a ```String```)
 * @var {String} KECCAK256_RLP_S
 */
exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

/**
 * Keccak-256 hash of the RLP of null (a ```Buffer```)
 * @var {Buffer} KECCAK256_RLP
 */
exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
exports.SHA3_RLP = exports.KECCAK256_RLP;

/**
 * [`BN`](https://github.com/indutny/bn.js)
 * @var {Function}
 */
exports.BN = BN;

/**
 * [`rlp`](https://github.com/ethereumjs/rlp)
 * @var {Function}
 */
exports.rlp = rlp;

/**
 * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
 * @var {Object}
 */
exports.secp256k1 = secp256k1;

/**
 * Returns a buffer filled with 0s
 * @method zeros
 * @param {Number} bytes  the number of bytes the buffer should be
 * @return {Buffer}
 */
exports.zeros = function (bytes) {
  return Buffer.allocUnsafe(bytes).fill(0);
};

/**
  * Returns a zero address
  * @method zeroAddress
  * @return {String}
  */
exports.zeroAddress = function () {
  var addressLength = 20;
  var zeroAddress = exports.zeros(addressLength);
  return exports.bufferToHex(zeroAddress);
};

/**
 * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @method lsetLength
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @param {Boolean} [right=false] whether to start padding form the left or right
 * @return {Buffer|Array}
 */
exports.setLengthLeft = exports.setLength = function (msg, length, right) {
  var buf = exports.zeros(length);
  msg = exports.toBuffer(msg);
  if (right) {
    if (msg.length < length) {
      msg.copy(buf);
      return buf;
    }
    return msg.slice(0, length);
  } else {
    if (msg.length < length) {
      msg.copy(buf, length - msg.length);
      return buf;
    }
    return msg.slice(-length);
  }
};

/**
 * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
 * Or it truncates the beginning if it exceeds.
 * @param {Buffer|Array} msg the value to pad
 * @param {Number} length the number of bytes the output should be
 * @return {Buffer|Array}
 */
exports.setLengthRight = function (msg, length) {
  return exports.setLength(msg, length, true);
};

/**
 * Trims leading zeros from a `Buffer` or an `Array`
 * @param {Buffer|Array|String} a
 * @return {Buffer|Array|String}
 */
exports.unpad = exports.stripZeros = function (a) {
  a = exports.stripHexPrefix(a);
  var first = a[0];
  while (a.length > 0 && first.toString() === '0') {
    a = a.slice(1);
    first = a[0];
  }
  return a;
};
/**
 * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
 * @param {*} v the value
 */
exports.toBuffer = function (v) {
  if (!Buffer.isBuffer(v)) {
    if (Array.isArray(v)) {
      v = Buffer.from(v);
    } else if (typeof v === 'string') {
      if (exports.isHexString(v)) {
        v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
      } else {
        v = Buffer.from(v);
      }
    } else if (typeof v === 'number') {
      v = exports.intToBuffer(v);
    } else if (v === null || v === undefined) {
      v = Buffer.allocUnsafe(0);
    } else if (BN.isBN(v)) {
      v = v.toArrayLike(Buffer);
    } else if (v.toArray) {
      // converts a BN to a Buffer
      v = Buffer.from(v.toArray());
    } else {
      throw new Error('invalid type');
    }
  }
  return v;
};

/**
 * Converts a `Buffer` to a `Number`
 * @param {Buffer} buf
 * @return {Number}
 * @throws If the input number exceeds 53 bits.
 */
exports.bufferToInt = function (buf) {
  return new BN(exports.toBuffer(buf)).toNumber();
};

/**
 * Converts a `Buffer` into a hex `String`
 * @param {Buffer} buf
 * @return {String}
 */
exports.bufferToHex = function (buf) {
  buf = exports.toBuffer(buf);
  return '0x' + buf.toString('hex');
};

/**
 * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
 * @param {Buffer} num
 * @return {BN}
 */
exports.fromSigned = function (num) {
  return new BN(num).fromTwos(256);
};

/**
 * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
 * @param {BN} num
 * @return {Buffer}
 */
exports.toUnsigned = function (num) {
  return Buffer.from(num.toTwos(256).toArray());
};

/**
 * Creates Keccak hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the Keccak width
 * @return {Buffer}
 */
exports.keccak = function (a, bits) {
  a = exports.toBuffer(a);
  if (!bits) bits = 256;

  switch (bits) {
    case 224:
      {
        return keccak224(a);
      }
    case 256:
      {
        return k256(a);
      }
    case 384:
      {
        return keccak384(a);
      }
    case 512:
      {
        return keccak512(a);
      }
    default:
      {
        throw new Error('Invald algorithm: keccak' + bits);
      }
  }
};

/**
 * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.keccak256 = function (a) {
  return exports.keccak(a);
};

/**
 * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Number} [bits=256] the SHA-3 width
 * @return {Buffer}
 */
exports.sha3 = exports.keccak;

/**
 * Creates SHA256 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.sha256 = function (a) {
  a = exports.toBuffer(a);
  return createHash('sha256').update(a).digest();
};

/**
 * Creates RIPEMD160 hash of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @param {Boolean} padded whether it should be padded to 256 bits or not
 * @return {Buffer}
 */
exports.ripemd160 = function (a, padded) {
  a = exports.toBuffer(a);
  var hash = createHash('rmd160').update(a).digest();
  if (padded === true) {
    return exports.setLength(hash, 32);
  } else {
    return hash;
  }
};

/**
 * Creates SHA-3 hash of the RLP encoded version of the input
 * @param {Buffer|Array|String|Number} a the input data
 * @return {Buffer}
 */
exports.rlphash = function (a) {
  return exports.keccak(rlp.encode(a));
};

/**
 * Checks if the private key satisfies the rules of the curve secp256k1.
 * @param {Buffer} privateKey
 * @return {Boolean}
 */
exports.isValidPrivate = function (privateKey) {
  return secp256k1.privateKeyVerify(privateKey);
};

/**
 * Checks if the public key satisfies the rules of the curve secp256k1
 * and the requirements of Ethereum.
 * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Boolean}
 */
exports.isValidPublic = function (publicKey, sanitize) {
  if (publicKey.length === 64) {
    // Convert to SEC1 for secp256k1
    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
  }

  if (!sanitize) {
    return false;
  }

  return secp256k1.publicKeyVerify(publicKey);
};

/**
 * Returns the ethereum address of a given public key.
 * Accepts "Ethereum public keys" and SEC1 encoded keys.
 * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
 * @param {Boolean} [sanitize=false] Accept public keys in other formats
 * @return {Buffer}
 */
exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
  pubKey = exports.toBuffer(pubKey);
  if (sanitize && pubKey.length !== 64) {
    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
  }
  assert(pubKey.length === 64);
  // Only take the lower 160bits of the hash
  return exports.keccak(pubKey).slice(-20);
};

/**
 * Returns the ethereum public key of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
var privateToPublic = exports.privateToPublic = function (privateKey) {
  privateKey = exports.toBuffer(privateKey);
  // skip the type flag and use the X, Y points
  return secp256k1.publicKeyCreate(privateKey, false).slice(1);
};

/**
 * Converts a public key to the Ethereum format.
 * @param {Buffer} publicKey
 * @return {Buffer}
 */
exports.importPublic = function (publicKey) {
  publicKey = exports.toBuffer(publicKey);
  if (publicKey.length !== 64) {
    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
  }
  return publicKey;
};

/**
 * ECDSA sign
 * @param {Buffer} msgHash
 * @param {Buffer} privateKey
 * @return {Object}
 */
exports.ecsign = function (msgHash, privateKey) {
  var sig = secp256k1.sign(msgHash, privateKey);

  var ret = {};
  ret.r = sig.signature.slice(0, 32);
  ret.s = sig.signature.slice(32, 64);
  ret.v = sig.recovery + 27;
  return ret;
};

/**
 * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
 * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
 * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
 * used to produce the signature.
 * @param message
 * @returns {Buffer} hash
 */
exports.hashPersonalMessage = function (message) {
  var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
  return exports.keccak(Buffer.concat([prefix, message]));
};

/**
 * ECDSA public key recovery from signature
 * @param {Buffer} msgHash
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {Buffer} publicKey
 */
exports.ecrecover = function (msgHash, v, r, s) {
  var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
  var recovery = v - 27;
  if (recovery !== 0 && recovery !== 1) {
    throw new Error('Invalid signature v value');
  }
  var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
  return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
};

/**
 * Convert signature parameters into the format of `eth_sign` RPC method
 * @param {Number} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @return {String} sig
 */
exports.toRpcSig = function (v, r, s) {
  // NOTE: with potential introduction of chainId this might need to be updated
  if (v !== 27 && v !== 28) {
    throw new Error('Invalid recovery id');
  }

  // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
  // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
  return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
};

/**
 * Convert signature format of the `eth_sign` RPC method to signature parameters
 * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
 * @param {String} sig
 * @return {Object}
 */
exports.fromRpcSig = function (sig) {
  sig = exports.toBuffer(sig);

  // NOTE: with potential introduction of chainId this might need to be updated
  if (sig.length !== 65) {
    throw new Error('Invalid signature length');
  }

  var v = sig[64];
  // support both versions of `eth_sign` responses
  if (v < 27) {
    v += 27;
  }

  return {
    v: v,
    r: sig.slice(0, 32),
    s: sig.slice(32, 64)
  };
};

/**
 * Returns the ethereum address of a given private key
 * @param {Buffer} privateKey A private key must be 256 bits wide
 * @return {Buffer}
 */
exports.privateToAddress = function (privateKey) {
  return exports.publicToAddress(privateToPublic(privateKey));
};

/**
 * Checks if the address is a valid. Accepts checksummed addresses too
 * @param {String} address
 * @return {Boolean}
 */
exports.isValidAddress = function (address) {
  return (/^0x[0-9a-fA-F]{40}$/.test(address)
  );
};

/**
  * Checks if a given address is a zero address
  * @method isZeroAddress
  * @param {String} address
  * @return {Boolean}
  */
exports.isZeroAddress = function (address) {
  var zeroAddress = exports.zeroAddress();
  return zeroAddress === exports.addHexPrefix(address);
};

/**
 * Returns a checksummed address
 * @param {String} address
 * @return {String}
 */
exports.toChecksumAddress = function (address) {
  address = exports.stripHexPrefix(address).toLowerCase();
  var hash = exports.keccak(address).toString('hex');
  var ret = '0x';

  for (var i = 0; i < address.length; i++) {
    if (parseInt(hash[i], 16) >= 8) {
      ret += address[i].toUpperCase();
    } else {
      ret += address[i];
    }
  }

  return ret;
};

/**
 * Checks if the address is a valid checksummed address
 * @param {Buffer} address
 * @return {Boolean}
 */
exports.isValidChecksumAddress = function (address) {
  return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
};

/**
 * Generates an address of a newly created contract
 * @param {Buffer} from the address which is creating this new address
 * @param {Buffer} nonce the nonce of the from account
 * @return {Buffer}
 */
exports.generateAddress = function (from, nonce) {
  from = exports.toBuffer(from);
  nonce = new BN(nonce);

  if (nonce.isZero()) {
    // in RLP we want to encode null in the case of zero nonce
    // read the RLP documentation for an answer if you dare
    nonce = null;
  } else {
    nonce = Buffer.from(nonce.toArray());
  }

  // Only take the lower 160bits of the hash
  return exports.rlphash([from, nonce]).slice(-20);
};

/**
 * Returns true if the supplied address belongs to a precompiled account (Byzantium)
 * @param {Buffer|String} address
 * @return {Boolean}
 */
exports.isPrecompiled = function (address) {
  var a = exports.unpad(address);
  return a.length === 1 && a[0] >= 1 && a[0] <= 8;
};

/**
 * Adds "0x" to a given `String` if it does not already start with "0x"
 * @param {String} str
 * @return {String}
 */
exports.addHexPrefix = function (str) {
  if (typeof str !== 'string') {
    return str;
  }

  return exports.isHexPrefixed(str) ? str : '0x' + str;
};

/**
 * Validate ECDSA signature
 * @method isValidSignature
 * @param {Buffer} v
 * @param {Buffer} r
 * @param {Buffer} s
 * @param {Boolean} [homestead=true]
 * @return {Boolean}
 */

exports.isValidSignature = function (v, r, s, homestead) {
  var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
  var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

  if (r.length !== 32 || s.length !== 32) {
    return false;
  }

  if (v !== 27 && v !== 28) {
    return false;
  }

  r = new BN(r);
  s = new BN(s);

  if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
    return false;
  }

  if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
    return false;
  }

  return true;
};

/**
 * Converts a `Buffer` or `Array` to JSON
 * @param {Buffer|Array} ba
 * @return {Array|String|null}
 */
exports.baToJSON = function (ba) {
  if (Buffer.isBuffer(ba)) {
    return '0x' + ba.toString('hex');
  } else if (ba instanceof Array) {
    var array = [];
    for (var i = 0; i < ba.length; i++) {
      array.push(exports.baToJSON(ba[i]));
    }
    return array;
  }
};

/**
 * Defines properties on a `Object`. It make the assumption that underlying data is binary.
 * @param {Object} self the `Object` to define properties on
 * @param {Array} fields an array fields to define. Fields can contain:
 * * `name` - the name of the properties
 * * `length` - the number of bytes the field can have
 * * `allowLess` - if the field can be less than the length
 * * `allowEmpty`
 * @param {*} data data to be validated against the definitions
 */
exports.defineProperties = function (self, fields, data) {
  self.raw = [];
  self._fields = [];

  // attach the `toJSON`
  self.toJSON = function (label) {
    if (label) {
      var obj = {};
      self._fields.forEach(function (field) {
        obj[field] = '0x' + self[field].toString('hex');
      });
      return obj;
    }
    return exports.baToJSON(this.raw);
  };

  self.serialize = function serialize() {
    return rlp.encode(self.raw);
  };

  fields.forEach(function (field, i) {
    self._fields.push(field.name);
    function getter() {
      return self.raw[i];
    }
    function setter(v) {
      v = exports.toBuffer(v);

      if (v.toString('hex') === '00' && !field.allowZero) {
        v = Buffer.allocUnsafe(0);
      }

      if (field.allowLess && field.length) {
        v = exports.stripZeros(v);
        assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
      } else if (!(field.allowZero && v.length === 0) && field.length) {
        assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
      }

      self.raw[i] = v;
    }

    Object.defineProperty(self, field.name, {
      enumerable: true,
      configurable: true,
      get: getter,
      set: setter
    });

    if (field.default) {
      self[field.name] = field.default;
    }

    // attach alias
    if (field.alias) {
      Object.defineProperty(self, field.alias, {
        enumerable: false,
        configurable: true,
        set: setter,
        get: getter
      });
    }
  });

  // if the constuctor is passed data
  if (data) {
    if (typeof data === 'string') {
      data = Buffer.from(exports.stripHexPrefix(data), 'hex');
    }

    if (Buffer.isBuffer(data)) {
      data = rlp.decode(data);
    }

    if (Array.isArray(data)) {
      if (data.length > self._fields.length) {
        throw new Error('wrong number of fields in data');
      }

      // make sure all the items are buffers
      data.forEach(function (d, i) {
        self[self._fields[i]] = exports.toBuffer(d);
      });
    } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
      var keys = Object.keys(data);
      fields.forEach(function (field) {
        if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
        if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
      });
    } else {
      throw new Error('invalid data');
    }
  }
};
      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", {"./secp256k1-lib/der":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js","./secp256k1-lib/index":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereum-cryptography/secp256k1":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\secp256k1.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\secp256k1-adapter.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var secp256k1 = require('ethereum-cryptography/secp256k1');

var secp256k1v3 = require('./secp256k1-lib/index');
var der = require('./secp256k1-lib/der');

/**
 * Verify an ECDSA privateKey
 * @method privateKeyVerify
 * @param {Buffer} privateKey
 * @return {boolean}
 */
var privateKeyVerify = function privateKeyVerify(privateKey) {
  // secp256k1 v4 version throws when privateKey length is not 32
  if (privateKey.length !== 32) {
    return false;
  }

  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
};

/**
 * Export a privateKey in DER format
 * @method privateKeyExport
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {boolean}
 */
var privateKeyExport = function privateKeyExport(privateKey, compressed) {
  // privateKeyExport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

  return der.privateKeyExport(privateKey, publicKey, compressed);
};

/**
 * Import a privateKey in DER format
 * @method privateKeyImport
 * @param {Buffer} privateKey
 * @return {Buffer}
 */

var privateKeyImport = function privateKeyImport(privateKey) {
  // privateKeyImport method is not part of secp256k1 v4 package
  // this implementation is based on v3
  privateKey = der.privateKeyImport(privateKey);
  if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
    return privateKey;
  }

  throw new Error("couldn't import from DER format");
};

/**
 * Negate a privateKey by subtracting it from the order of the curve's base point
 * @method privateKeyNegate
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyNegate = function privateKeyNegate(privateKey) {
  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
};

/**
 * Compute the inverse of a privateKey (modulo the order of the curve's base point).
 * @method privateKeyModInverse
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var privateKeyModInverse = function privateKeyModInverse(privateKey) {
  if (privateKey.length !== 32) {
    throw new Error('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
};

/**
 * Tweak a privateKey by adding tweak to it.
 * @method privateKeyTweakAdd
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
};

/**
 * Tweak a privateKey by multiplying it by a tweak.
 * @method privateKeyTweakMul
 * @param {Buffer} privateKey
 * @param {Buffer} tweak
 * @return {Buffer}
 */
var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
};

/**
 * Compute the public key for a privateKey.
 * @method publicKeyCreate
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
};

/**
 * Convert a publicKey to compressed or uncompressed form.
 * @method publicKeyConvert
 * @param {Buffer} publicKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
};

/**
 * Verify an ECDSA publicKey.
 * @method publicKeyVerify
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var publicKeyVerify = function publicKeyVerify(publicKey) {
  // secp256k1 v4 version throws when publicKey length is not 33 or 65
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    return false;
  }

  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
};

/**
 * Tweak a publicKey by adding tweak times the generator to it.
 * @method publicKeyTweakAdd
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Tweak a publicKey by multiplying it by a tweak value
 * @method publicKeyTweakMul
 * @param {Buffer} publicKey
 * @param {Buffer} tweak
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
};

/**
 * Add a given publicKeys together.
 * @method publicKeyCombine
 * @param {Array<Buffer>} publicKeys
 * @param {boolean} compressed
 * @return {Buffer}
 */
var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
  var keys = [];
  publicKeys.forEach(function (publicKey) {
    keys.push(Uint8Array.from(publicKey));
  });

  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
};

/**
 * Convert a signature to a normalized lower-S form.
 * @method signatureNormalize
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureNormalize = function signatureNormalize(signature) {
  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
};

/**
 * Serialize an ECDSA signature in DER format.
 * @method signatureExport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureExport = function signatureExport(signature) {
  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImport
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImport = function signatureImport(signature) {
  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
};

/**
 * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
 * @method signatureImportLax
 * @param {Buffer} signature
 * @return {Buffer}
 */
var signatureImportLax = function signatureImportLax(signature) {
  // signatureImportLax method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure that signature is greater than 0
  if (signature.length === 0) {
    throw new RangeError('signature length is invalid');
  }

  var sigObj = der.signatureImportLax(signature);
  if (sigObj === null) {
    throw new Error("couldn't parse DER signature");
  }

  return secp256k1v3.signatureImport(sigObj);
};

/**
 * Create an ECDSA signature. Always return low-S signature.
 * @method sign
 * @param {Buffer} message
 * @param {Buffer} privateKey
 * @param {Object} options
 * @return {Buffer}
 */
var sign = function sign(message, privateKey, options) {
  if (options === null) {
    throw new TypeError('options should be an Object');
  }

  var signOptions = void 0;

  if (options) {
    signOptions = {};

    if (options.data === null) {
      throw new TypeError('options.data should be a Buffer');
    }

    if (options.data) {
      // validate option.data length
      if (options.data.length !== 32) {
        throw new RangeError('options.data length is invalid');
      }

      signOptions.data = new Uint8Array(options.data);
    }

    if (options.noncefn === null) {
      throw new TypeError('options.noncefn should be a Function');
    }

    if (options.noncefn) {
      //  convert option.noncefn function signature
      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
        var bufferAlgo = algo != null ? Buffer.from(algo) : null;
        var bufferData = data != null ? Buffer.from(data) : null;

        var buffer = Buffer.from('');

        if (options.noncefn) {
          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
        }

        return Uint8Array.from(buffer);
      };
    }
  }

  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

  return {
    signature: Buffer.from(sig.signature),
    recovery: sig.recid
  };
};

/**
 * Verify an ECDSA signature.
 * @method verify
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Buffer} publicKey
 * @return {boolean}
 */
var verify = function verify(message, signature, publicKey) {
  // note: secp256k1 v4 verify method has a different argument order
  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
};

/**
 * Recover an ECDSA public key from a signature.
 * @method recover
 * @param {Buffer} message
 * @param {Buffer} signature
 * @param {Number} recid
 * @param {boolean} compressed
 * @return {Buffer}
 */
var recover = function recover(message, signature, recid, compressed) {
  // note: secp256k1 v4 recover method has a different argument order
  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
};

/**
 * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
 * @method ecdh
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @return {Buffer}
 */
var ecdh = function ecdh(publicKey, privateKey) {
  // note: secp256k1 v3 doesn't allow optional parameter
  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
};

/**
 * Compute an EC Diffie-Hellman secret and return public key as result
 * @method ecdhUnsafe
 * @param {Buffer} publicKey
 * @param {Buffer} privateKey
 * @param {boolean} compressed
 * @return {Buffer}
 */
var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
  // ecdhUnsafe method is not part of secp256k1 v4 package
  // this implementation is based on v3
  // ensure valid publicKey length
  if (publicKey.length !== 33 && publicKey.length !== 65) {
    throw new RangeError('public key length is invalid');
  }

  // ensure valid privateKey length
  if (privateKey.length !== 32) {
    throw new RangeError('private key length is invalid');
  }

  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
};

module.exports = {
  privateKeyVerify: privateKeyVerify,
  privateKeyExport: privateKeyExport,
  privateKeyImport: privateKeyImport,
  privateKeyNegate: privateKeyNegate,
  privateKeyModInverse: privateKeyModInverse,
  privateKeyTweakAdd: privateKeyTweakAdd,
  privateKeyTweakMul: privateKeyTweakMul,

  publicKeyCreate: publicKeyCreate,
  publicKeyConvert: publicKeyConvert,
  publicKeyVerify: publicKeyVerify,
  publicKeyTweakAdd: publicKeyTweakAdd,
  publicKeyTweakMul: publicKeyTweakMul,
  publicKeyCombine: publicKeyCombine,

  signatureNormalize: signatureNormalize,
  signatureExport: signatureExport,
  signatureImport: signatureImport,
  signatureImportLax: signatureImportLax,

  sign: sign,
  verify: verify,
  recover: recover,

  ecdh: ecdh,
  ecdhUnsafe: ecdhUnsafe
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\secp256k1-lib\der.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
// begin
0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
// begin
0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
// private key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
// middle
0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
// public key
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

exports.privateKeyExport = function (privateKey, publicKey, compressed) {
  var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
  privateKey.copy(result, compressed ? 8 : 9);
  publicKey.copy(result, compressed ? 181 : 214);
  return result;
};

exports.privateKeyImport = function (privateKey) {
  var length = privateKey.length;

  // sequence header
  var index = 0;
  if (length < index + 1 || privateKey[index] !== 0x30) return null;
  index += 1;

  // sequence length constructor
  if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

  var lenb = privateKey[index] & 0x7f;
  index += 1;
  if (lenb < 1 || lenb > 2) return null;
  if (length < index + lenb) return null;

  // sequence length
  var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
  index += lenb;
  if (length < index + len) return null;

  // sequence element 0: version number (=1)
  if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
    return null;
  }
  index += 3;

  // sequence element 1: octet string, up to 32 bytes
  if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
    return null;
  }

  return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
};

exports.signatureImportLax = function (signature) {
  var r = Buffer.alloc(32, 0);
  var s = Buffer.alloc(32, 0);

  var length = signature.length;
  var index = 0;

  // sequence tag byte
  if (signature[index++] !== 0x30) {
    return null;
  }

  // sequence length byte
  var lenbyte = signature[index++];
  if (lenbyte & 0x80) {
    index += lenbyte - 0x80;
    if (index > length) {
      return null;
    }
  }

  // sequence tag byte for r
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for r
  var rlen = signature[index++];
  if (rlen & 0x80) {
    lenbyte = rlen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      rlen = (rlen << 8) + signature[index];
    }
  }
  if (rlen > length - index) {
    return null;
  }
  var rindex = index;
  index += rlen;

  // sequence tag byte for s
  if (signature[index++] !== 0x02) {
    return null;
  }

  // length for s
  var slen = signature[index++];
  if (slen & 0x80) {
    lenbyte = slen - 0x80;
    if (index + lenbyte > length) {
      return null;
    }
    for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) {}
    for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
      slen = (slen << 8) + signature[index];
    }
  }
  if (slen > length - index) {
    return null;
  }
  var sindex = index;
  index += slen;

  // ignore leading zeros in r
  for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) {}
  // copy r value
  if (rlen > 32) {
    return null;
  }
  var rvalue = signature.slice(rindex, rindex + rlen);
  rvalue.copy(r, 32 - rvalue.length);

  // ignore leading zeros in s
  for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) {}
  // copy s value
  if (slen > 32) {
    return null;
  }
  var svalue = signature.slice(sindex, sindex + slen);
  svalue.copy(s, 32 - svalue.length);

  return { r: r, s: s };
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", {"bn.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","elliptic":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\secp256k1-lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

// This file is imported from secp256k1 v3
// https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

var BN = require('bn.js');
var EC = require('elliptic').ec;

var ec = new EC('secp256k1');
var ecparams = ec.curve;

exports.privateKeyExport = function (privateKey, compressed) {
  var d = new BN(privateKey);
  if (d.ucmp(ecparams.n) >= 0) {
    throw new Error('couldn\'t export to DER format');
  }

  var point = ec.g.mul(d);
  return toPublicKey(point.getX(), point.getY(), compressed);
};

exports.privateKeyModInverse = function (privateKey) {
  var bn = new BN(privateKey);
  if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
    throw new Error('private key range is invalid');
  }

  return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
};

exports.signatureImport = function (sigObj) {
  var r = new BN(sigObj.r);
  if (r.ucmp(ecparams.n) >= 0) {
    r = new BN(0);
  }

  var s = new BN(sigObj.s);
  if (s.ucmp(ecparams.n) >= 0) {
    s = new BN(0);
  }

  return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
};

exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
  var point = ec.keyFromPublic(publicKey);

  var scalar = new BN(privateKey);
  if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
    throw new Error('scalar was invalid (zero or overflow)');
  }

  var shared = point.pub.mul(scalar);
  return toPublicKey(shared.getX(), shared.getY(), compressed);
};

var toPublicKey = function toPublicKey(x, y, compressed) {
  var publicKey = void 0;

  if (compressed) {
    publicKey = Buffer.alloc(33);
    publicKey[0] = y.isOdd() ? 0x03 : 0x02;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
  } else {
    publicKey = Buffer.alloc(65);
    publicKey[0] = 0x04;
    x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
    y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
  }

  return publicKey;
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>ethereumjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethjs-util\\lib\\index.js", {"buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","is-hex-prefixed":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js","strip-hex-prefix":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethjs-util\lib\index.js
      return function (require, module, exports) {
(function (Buffer){(function (){
'use strict';

var isHexPrefixed = require('is-hex-prefixed');
var stripHexPrefix = require('strip-hex-prefix');

/**
 * Pads a `String` to have an even length
 * @param {String} value
 * @return {String} output
 */
function padToEven(value) {
  var a = value; // eslint-disable-line

  if (typeof a !== 'string') {
    throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
  }

  if (a.length % 2) {
    a = '0' + a;
  }

  return a;
}

/**
 * Converts a `Number` into a hex `String`
 * @param {Number} i
 * @return {String}
 */
function intToHex(i) {
  var hex = i.toString(16); // eslint-disable-line

  return '0x' + hex;
}

/**
 * Converts an `Number` to a `Buffer`
 * @param {Number} i
 * @return {Buffer}
 */
function intToBuffer(i) {
  var hex = intToHex(i);

  return new Buffer(padToEven(hex.slice(2)), 'hex');
}

/**
 * Get the binary size of a string
 * @param {String} str
 * @return {Number}
 */
function getBinarySize(str) {
  if (typeof str !== 'string') {
    throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
  }

  return Buffer.byteLength(str, 'utf8');
}

/**
 * Returns TRUE if the first specified array contains all elements
 * from the second one. FALSE otherwise.
 *
 * @param {array} superset
 * @param {array} subset
 *
 * @returns {boolean}
 */
function arrayContainsArray(superset, subset, some) {
  if (Array.isArray(superset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
  }
  if (Array.isArray(subset) !== true) {
    throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
  }

  return subset[Boolean(some) && 'some' || 'every'](function (value) {
    return superset.indexOf(value) >= 0;
  });
}

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toUtf8(hex) {
  var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

  return bufferValue.toString('utf8');
}

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
function toAscii(hex) {
  var str = ''; // eslint-disable-line
  var i = 0,
      l = hex.length; // eslint-disable-line

  if (hex.substring(0, 2) === '0x') {
    i = 2;
  }

  for (; i < l; i += 2) {
    var code = parseInt(hex.substr(i, 2), 16);
    str += String.fromCharCode(code);
  }

  return str;
}

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromUtf8(stringValue) {
  var str = new Buffer(stringValue, 'utf8');

  return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
}

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
function fromAscii(stringValue) {
  var hex = ''; // eslint-disable-line
  for (var i = 0; i < stringValue.length; i++) {
    // eslint-disable-line
    var code = stringValue.charCodeAt(i);
    var n = code.toString(16);
    hex += n.length < 2 ? '0' + n : n;
  }

  return '0x' + hex;
}

/**
 * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
 *
 * @method getKeys get specific key from inner object array of objects
 * @param {String} params
 * @param {String} key
 * @param {Boolean} allowEmpty
 * @returns {Array} output just a simple array of output keys
 */
function getKeys(params, key, allowEmpty) {
  if (!Array.isArray(params)) {
    throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
  }
  if (typeof key !== 'string') {
    throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
  }

  var result = []; // eslint-disable-line

  for (var i = 0; i < params.length; i++) {
    // eslint-disable-line
    var value = params[i][key]; // eslint-disable-line
    if (allowEmpty && !value) {
      value = '';
    } else if (typeof value !== 'string') {
      throw new Error('invalid abi');
    }
    result.push(value);
  }

  return result;
}

/**
 * Is the string a hex string.
 *
 * @method check if string is hex string of specific length
 * @param {String} value
 * @param {Number} length
 * @returns {Boolean} output the string is a hex string
 */
function isHexString(value, length) {
  if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}

module.exports = {
  arrayContainsArray: arrayContainsArray,
  intToBuffer: intToBuffer,
  getBinarySize: getBinarySize,
  isHexPrefixed: isHexPrefixed,
  stripHexPrefix: stripHexPrefix,
  padToEven: padToEven,
  intToHex: intToHex,
  fromAscii: fromAscii,
  fromUtf8: fromUtf8,
  toAscii: toAscii,
  toUtf8: toUtf8,
  getKeys: getKeys,
  isHexString: isHexString
};
}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>ethereumjs-util>ethjs-util",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\json-rpc-engine\src\createAsyncMiddleware.js
      return function (require, module, exports) {
/**
 * JsonRpcEngine only accepts callback-based middleware directly.
 * createAsyncMiddleware exists to enable consumers to pass in async middleware
 * functions.
 *
 * Async middleware have no "end" function. Instead, they "end" if they return
 * without calling "next". Rather than passing in explicit return handlers,
 * async middleware can simply await "next", and perform operations on the
 * response object when execution resumes.
 *
 * To accomplish this, createAsyncMiddleware passes the async middleware a
 * wrapped "next" function. That function calls the internal JsonRpcEngine
 * "next" function with a return handler that resolves a promise when called.
 *
 * The return handler will always be called. Its resolution of the promise
 * enables the control flow described above.
 */

module.exports = function createAsyncMiddleware (asyncMiddleware) {
  return (req, res, next, end) => {

    // nextPromise is the key to the implementation
    // it is resolved by the return handler passed to the
    // "next" function
    let resolveNextPromise
    const nextPromise = new Promise((resolve) => {
      resolveNextPromise = resolve
    })

    let returnHandlerCallback, nextWasCalled

    const asyncNext = async () => {

      nextWasCalled = true

      next((callback) => { // eslint-disable-line callback-return
        returnHandlerCallback = callback
        resolveNextPromise()
      })
      await nextPromise
    }

    asyncMiddleware(req, res, asyncNext)
      .then(async () => {
        if (nextWasCalled) {
          await nextPromise // we must wait until the return handler is called
          returnHandlerCallback(null)
        } else {
          end(null)
        }
      })
      .catch((error) => {
        if (returnHandlerCallback) {
          returnHandlerCallback(error)
        } else {
          end(error)
        }
      })
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware>json-rpc-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\pify\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\pify\index.js
      return function (require, module, exports) {
'use strict';

const processFn = (fn, opts) => function () {
	const P = opts.promiseModule;
	const args = new Array(arguments.length);

	for (let i = 0; i < arguments.length; i++) {
		args[i] = arguments[i];
	}

	return new P((resolve, reject) => {
		if (opts.errorFirst) {
			args.push(function (err, result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 1; i < arguments.length; i++) {
						results[i - 1] = arguments[i];
					}

					if (err) {
						results.unshift(err);
						reject(results);
					} else {
						resolve(results);
					}
				} else if (err) {
					reject(err);
				} else {
					resolve(result);
				}
			});
		} else {
			args.push(function (result) {
				if (opts.multiArgs) {
					const results = new Array(arguments.length - 1);

					for (let i = 0; i < arguments.length; i++) {
						results[i] = arguments[i];
					}

					resolve(results);
				} else {
					resolve(result);
				}
			});
		}

		fn.apply(this, args);
	});
};

module.exports = (obj, opts) => {
	opts = Object.assign({
		exclude: [/.+(Sync|Stream)$/],
		errorFirst: true,
		promiseModule: Promise
	}, opts);

	const filter = key => {
		const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
		return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
	};

	let ret;
	if (typeof obj === 'function') {
		ret = function () {
			if (opts.excludeMain) {
				return obj.apply(this, arguments);
			}

			return processFn(obj, opts).apply(this, arguments);
		};
	} else {
		ret = Object.create(Object.getPrototypeOf(obj));
	}

	for (const key in obj) { // eslint-disable-line guard-for-in
		const x = obj[key];
		ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
	}

	return ret;
};

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine>eth-block-tracker>pify",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\package.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\package.json
      return function (require, module, exports) {
module.exports={
  "name": "web3-provider-engine",
  "version": "16.0.3",
  "description": "A JavaScript library for composing Ethereum provider objects using middleware modules",
  "repository": "https://github.com/MetaMask/web3-provider-engine",
  "main": "index.js",
  "engines": {
    "node": ">=12.0.0"
  },
  "scripts": {
    "test": "node test/index.js && yarn lint",
    "prepublishOnly": "yarn build && yarn bundle",
    "build": "babel zero.js index.js -d dist/es5 && babel subproviders -d dist/es5/subproviders && babel util -d dist/es5/util",
    "bundle": "mkdir -p ./dist && yarn bundle-engine && yarn bundle-zero",
    "bundle-zero": "browserify -s ZeroClientProvider -e zero.js -t [ babelify --presets [ @babel/preset-env ] ] > dist/ZeroClientProvider.js",
    "bundle-engine": "browserify -s ProviderEngine -e index.js -t [ babelify --presets [ @babel/preset-env ] ] > dist/ProviderEngine.js",
    "lint": "eslint --quiet --ignore-path .gitignore ."
  },
  "files": [
    "*.js",
    "dist",
    "subproviders",
    "util"
  ],
  "license": "MIT",
  "resolutions": {
    "ganache-core/**/elliptic": "^6.5.2"
  },
  "dependencies": {
    "@ethereumjs/tx": "^3.3.0",
    "async": "^2.5.0",
    "backoff": "^2.5.0",
    "clone": "^2.0.0",
    "cross-fetch": "^2.1.0",
    "eth-block-tracker": "^4.4.2",
    "eth-json-rpc-filters": "^4.2.1",
    "eth-json-rpc-infura": "^5.1.0",
    "eth-json-rpc-middleware": "^6.0.0",
    "eth-rpc-errors": "^3.0.0",
    "eth-sig-util": "^1.4.2",
    "ethereumjs-block": "^1.2.2",
    "ethereumjs-util": "^5.1.5",
    "ethereumjs-vm": "^2.3.4",
    "json-stable-stringify": "^1.0.1",
    "promise-to-callback": "^1.0.0",
    "readable-stream": "^2.2.9",
    "request": "^2.85.0",
    "semaphore": "^1.0.3",
    "ws": "^5.1.1",
    "xhr": "^2.2.0",
    "xtend": "^4.0.1"
  },
  "devDependencies": {
    "@babel/cli": "^7.5.5",
    "@babel/core": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "babelify": "^10.0.0",
    "browserify": "^16.5.0",
    "eslint": "^6.2.0",
    "ethjs": "^0.3.6",
    "ganache-core": "^2.7.0",
    "tape": "^4.4.0"
  },
  "browser": {
    "request": false,
    "ws": false
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\cache.js", {"./json-rpc-engine-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js","eth-json-rpc-middleware/block-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\block-cache.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\cache.js
      return function (require, module, exports) {
const ProviderSubprovider = require('./json-rpc-engine-middleware')
const createBlockCacheMiddleware = require('eth-json-rpc-middleware/block-cache')

class BlockCacheSubprovider extends ProviderSubprovider {
  constructor(opts) {
    super(({ blockTracker }) => createBlockCacheMiddleware(Object.assign({ blockTracker }, opts)))
  }
}

module.exports = BlockCacheSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\default-fixture.js", {"../package.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\package.json","./fixture.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fixture.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\default-fixture.js
      return function (require, module, exports) {
const inherits = require('util').inherits
const extend = require('xtend')
const FixtureProvider = require('./fixture.js')
const version = require('../package.json').version

module.exports = DefaultFixtures

inherits(DefaultFixtures, FixtureProvider)

function DefaultFixtures(opts) {
  const self = this
  opts = opts || {}
  var responses = extend({
    web3_clientVersion: 'ProviderEngine/v'+version+'/javascript',
    net_listening: true,
    eth_hashrate: '0x00',
    eth_mining: false,
  }, opts)
  FixtureProvider.call(self, responses)
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fetch.js", {"./json-rpc-engine-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js","eth-json-rpc-middleware/fetch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\fetch.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\fetch.js
      return function (require, module, exports) {
const ProviderSubprovider = require('./json-rpc-engine-middleware')
const createFetchMiddleware = require('eth-json-rpc-middleware/fetch')

class FetchSubprovider extends ProviderSubprovider {
  constructor(opts) {
    super(({ blockTracker, provider, engine }) => {
      return createFetchMiddleware(opts)
    })
  }
}

module.exports = FetchSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\filters.js", {"./json-rpc-engine-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js","eth-json-rpc-filters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-filters\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\filters.js
      return function (require, module, exports) {
const ProviderSubprovider = require('./json-rpc-engine-middleware')
const createFilterMiddleware = require('eth-json-rpc-filters')

class SubscriptionsSubprovider extends ProviderSubprovider {
  constructor() {
    super(({ blockTracker, provider, engine }) => {
      return createFilterMiddleware({ blockTracker, provider })
    })
  }
}

module.exports = SubscriptionsSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fixture.js", {"./subprovider.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\fixture.js
      return function (require, module, exports) {
const inherits = require('util').inherits
const Subprovider = require('./subprovider.js')

module.exports = FixtureProvider

inherits(FixtureProvider, Subprovider)

function FixtureProvider(staticResponses){
  const self = this
  staticResponses = staticResponses || {}
  self.staticResponses = staticResponses
}

FixtureProvider.prototype.handleRequest = function(payload, next, end){
  const self = this
  var staticResponse = self.staticResponses[payload.method]
  // async function
  if ('function' === typeof staticResponse) {
    staticResponse(payload, next, end)
  // static response - null is valid response
  } else if (staticResponse !== undefined) {
    // return result asynchronously
    setTimeout(() => end(null, staticResponse))
  // no prepared response - skip
  } else {
    next()
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\hooked-wallet.js", {"../util/estimate-gas.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\estimate-gas.js","./subprovider.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js","async/parallel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\parallel.js","async/waterfall":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\waterfall.js","eth-sig-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-sig-util\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js","semaphore":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\semaphore\\lib\\semaphore.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\hooked-wallet.js
      return function (require, module, exports) {
/*
 * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'
 *
 * The two callbacks a user needs to implement are:
 * - getAccounts() -- array of addresses supported
 * - signTransaction(tx) -- sign a raw transaction object
 */

const waterfall = require('async/waterfall')
const parallel = require('async/parallel')
const inherits = require('util').inherits
const ethUtil = require('ethereumjs-util')
const sigUtil = require('eth-sig-util')
const extend = require('xtend')
const Semaphore = require('semaphore')
const Subprovider = require('./subprovider.js')
const estimateGas = require('../util/estimate-gas.js')
const hexRegex = /^[0-9A-Fa-f]+$/g

module.exports = HookedWalletSubprovider

// handles the following RPC methods:
//   eth_coinbase
//   eth_accounts
//   eth_sendTransaction
//   eth_sign
//   eth_signTypedData
//   eth_signTypedData_v3
//   eth_signTypedData_v4
//   personal_sign
//   eth_decryptMessage
//   encryption_public_key
//   personal_ecRecover
//   parity_postTransaction
//   parity_checkRequest
//   parity_defaultAccount

//
// Tx Signature Flow
//
// handleRequest: eth_sendTransaction
//   validateTransaction (basic validity check)
//     validateSender (checks that sender is in accounts)
//   processTransaction (sign tx and submit to network)
//     approveTransaction (UI approval hook)
//     checkApproval
//     finalizeAndSubmitTx (tx signing)
//       nonceLock.take (bottle neck to ensure atomic nonce)
//         fillInTxExtras (set fallback gasPrice, nonce, etc)
//         signTransaction (perform the signature)
//         publishTransaction (publish signed tx to network)
//


inherits(HookedWalletSubprovider, Subprovider)

function HookedWalletSubprovider(opts){
  const self = this
  // control flow
  self.nonceLock = Semaphore(1)

  // data lookup
  if (opts.getAccounts) self.getAccounts = opts.getAccounts
  // high level override
  if (opts.processTransaction) self.processTransaction = opts.processTransaction
  if (opts.processMessage) self.processMessage = opts.processMessage
  if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage
  if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage
  // approval hooks
  self.approveTransaction = opts.approveTransaction || self.autoApprove
  self.approveMessage = opts.approveMessage || self.autoApprove
  self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove
  self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove
  self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove
  self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove
  // actually perform the signature
  if (opts.signTransaction) self.signTransaction = opts.signTransaction  || mustProvideInConstructor('signTransaction')
  if (opts.signMessage) self.signMessage = opts.signMessage  || mustProvideInConstructor('signMessage')
  if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage  || mustProvideInConstructor('signPersonalMessage')
  if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage  || mustProvideInConstructor('decryptMessage')
  if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey  || mustProvideInConstructor('encryptionPublicKey')
  if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage  || mustProvideInConstructor('signTypedMessage')
  if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature
  // publish to network
  if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction
  // gas options
  self.estimateGas = opts.estimateGas || self.estimateGas
  self.getGasPrice = opts.getGasPrice || self.getGasPrice
}

HookedWalletSubprovider.prototype.handleRequest = function(payload, next, end){
  const self = this
  self._parityRequests = {}
  self._parityRequestCount = 0

  // switch statement is not block scoped
  // sp we cant repeat var declarations
  let txParams, msgParams, extraParams
  let message, address

  switch(payload.method) {

    case 'eth_coinbase':
      // process normally
      self.getAccounts(function(err, accounts){
        if (err) return end(err)
        let result = accounts[0] || null
        end(null, result)
      })
      return

    case 'eth_accounts':
      // process normally
      self.getAccounts(function(err, accounts){
        if (err) return end(err)
        end(null, accounts)
      })
      return

    case 'eth_sendTransaction':
      txParams = payload.params[0]
      waterfall([
        (cb) => self.validateTransaction(txParams, cb),
        (cb) => self.processTransaction(txParams, cb),
      ], end)
      return

    case 'eth_signTransaction':
      txParams = payload.params[0]
      waterfall([
        (cb) => self.validateTransaction(txParams, cb),
        (cb) => self.processSignTransaction(txParams, cb),
      ], end)
      return

    case 'eth_sign':
      // process normally
      address = payload.params[0]
      message = payload.params[1]
      // non-standard "extraParams" to be appended to our "msgParams" obj
      // good place for metadata
      extraParams = payload.params[2] || {}
      msgParams = extend(extraParams, {
        from: address,
        data: message,
      })
      waterfall([
        (cb) => self.validateMessage(msgParams, cb),
        (cb) => self.processMessage(msgParams, cb),
      ], end)
      return

    case 'personal_sign':
      return (function(){
        // process normally
        const first = payload.params[0]
        const second = payload.params[1]

        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        if (resemblesData(second) && resemblesAddress(first)) {
          let warning = `The eth_personalSign method requires params ordered `
          warning += `[message, address]. This was previously handled incorrectly, `
          warning += `and has been corrected automatically. `
          warning += `Please switch this param order for smooth behavior in the future.`
          console.warn(warning)

          address = payload.params[0]
          message = payload.params[1]
        } else {
          message = payload.params[0]
          address = payload.params[1]
        }

        // non-standard "extraParams" to be appended to our "msgParams" obj
        // good place for metadata
        extraParams = payload.params[2] || {}
        msgParams = extend(extraParams, {
          from: address,
          data: message,
        })
        waterfall([
          (cb) => self.validatePersonalMessage(msgParams, cb),
          (cb) => self.processPersonalMessage(msgParams, cb),
        ], end)
      })()

    case 'eth_decryptMessage':
      return (function(){
        // process normally
        const first = payload.params[0]
        const second = payload.params[1]

        // We initially incorrectly ordered these parameters.
        // To gracefully respect users who adopted this API early,
        // we are currently gracefully recovering from the wrong param order
        // when it is clearly identifiable.
        //
        // That means when the first param is definitely an address,
        // and the second param is definitely not, but is hex.
        if (resemblesData(second) && resemblesAddress(first)) {
          let warning = `The eth_decryptMessage method requires params ordered `
          warning += `[message, address]. This was previously handled incorrectly, `
          warning += `and has been corrected automatically. `
          warning += `Please switch this param order for smooth behavior in the future.`
          console.warn(warning)

          address = payload.params[0]
          message = payload.params[1]
        } else {
          message = payload.params[0]
          address = payload.params[1]
        }

        // non-standard "extraParams" to be appended to our "msgParams" obj
        // good place for metadata
        extraParams = payload.params[2] || {}
        msgParams = extend(extraParams, {
          from: address,
          data: message,
        })
        waterfall([
          (cb) => self.validateDecryptMessage(msgParams, cb),
          (cb) => self.processDecryptMessage(msgParams, cb),
        ], end)
      })()
      
    case 'encryption_public_key':
      return (function(){
        const address = payload.params[0]
        
        waterfall([
          (cb) => self.validateEncryptionPublicKey(address, cb),
          (cb) => self.processEncryptionPublicKey(address, cb),
        ], end)
      })()
      
    case 'personal_ecRecover':
      return (function(){    
        message = payload.params[0]
        let signature = payload.params[1]
        // non-standard "extraParams" to be appended to our "msgParams" obj
        // good place for metadata
        extraParams = payload.params[2] || {}
        msgParams = extend(extraParams, {
          sig: signature,
          data: message,
        })
        self.recoverPersonalSignature(msgParams, end)
      })()

    case 'eth_signTypedData':
    case 'eth_signTypedData_v3':
    case 'eth_signTypedData_v4':
      return (function(){ 
        // process normally
      
        const first = payload.params[0]
        const second = payload.params[1]

        if (resemblesAddress(first)) {
          address = first
          message = second
        } else {
          message = first
          address = second
        }

        extraParams = payload.params[2] || {}
        msgParams = extend(extraParams, {
          from: address,
          data: message,
        })
        waterfall([
          (cb) => self.validateTypedMessage(msgParams, cb),
          (cb) => self.processTypedMessage(msgParams, cb),
        ], end)
      })()

    case 'parity_postTransaction':
      txParams = payload.params[0]
      self.parityPostTransaction(txParams, end)
      return

    case 'parity_postSign':
      address = payload.params[0]
      message = payload.params[1]
      self.parityPostSign(address, message, end)
      return

    case 'parity_checkRequest':
      return (function(){
        const requestId = payload.params[0]
        self.parityCheckRequest(requestId, end)
      })()

    case 'parity_defaultAccount':
      self.getAccounts(function(err, accounts){
        if (err) return end(err)
        const account = accounts[0] || null
        end(null, account)
      })
      return

    default:
      next()
      return

  }
}

//
// data lookup
//

HookedWalletSubprovider.prototype.getAccounts = function(cb) {
  cb(null, [])
}


//
// "process" high level flow
//

HookedWalletSubprovider.prototype.processTransaction = function(txParams, cb) {
  const self = this
  waterfall([
    (cb) => self.approveTransaction(txParams, cb),
    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),
    (cb) => self.finalizeAndSubmitTx(txParams, cb),
  ], cb)
}


HookedWalletSubprovider.prototype.processSignTransaction = function(txParams, cb) {
  const self = this
  waterfall([
    (cb) => self.approveTransaction(txParams, cb),
    (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),
    (cb) => self.finalizeTx(txParams, cb),
  ], cb)
}

HookedWalletSubprovider.prototype.processMessage = function(msgParams, cb) {
  const self = this
  waterfall([
    (cb) => self.approveMessage(msgParams, cb),
    (didApprove, cb) => self.checkApproval('message', didApprove, cb),
    (cb) => self.signMessage(msgParams, cb),
  ], cb)
}

HookedWalletSubprovider.prototype.processPersonalMessage = function(msgParams, cb) {
  const self = this
  waterfall([
    (cb) => self.approvePersonalMessage(msgParams, cb),
    (didApprove, cb) => self.checkApproval('message', didApprove, cb),
    (cb) => self.signPersonalMessage(msgParams, cb),
  ], cb)
}

HookedWalletSubprovider.prototype.processDecryptMessage = function(msgParams, cb) {
  const self = this
  waterfall([
    (cb) => self.approveDecryptMessage(msgParams, cb),
    (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb),
    (cb) => self.decryptMessage(msgParams, cb),
  ], cb)
}

HookedWalletSubprovider.prototype.processEncryptionPublicKey = function(msgParams, cb) {
  const self = this
  waterfall([
    (cb) => self.approveEncryptionPublicKey(msgParams, cb),
    (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb),
    (cb) => self.encryptionPublicKey(msgParams, cb),
  ], cb)
}

HookedWalletSubprovider.prototype.processTypedMessage = function(msgParams, cb) {
  const self = this
  waterfall([
    (cb) => self.approveTypedMessage(msgParams, cb),
    (didApprove, cb) => self.checkApproval('message', didApprove, cb),
    (cb) => self.signTypedMessage(msgParams, cb),
  ], cb)
}

//
// approval
//

HookedWalletSubprovider.prototype.autoApprove = function(txParams, cb) {
  cb(null, true)
}

HookedWalletSubprovider.prototype.checkApproval = function(type, didApprove, cb) {
  cb( didApprove ? null : new Error('User denied '+type+' signature.') )
}

//
// parity
//

HookedWalletSubprovider.prototype.parityPostTransaction = function(txParams, cb) {
  const self = this

  // get next id
  const count = self._parityRequestCount
  const reqId = `0x${count.toString(16)}`
  self._parityRequestCount++

  self.emitPayload({
    method: 'eth_sendTransaction',
    params: [txParams],
  }, function(error, res){
    if (error) {
      self._parityRequests[reqId] = { error }
      return
    }
    const txHash = res.result
    self._parityRequests[reqId] = txHash
  })

  cb(null, reqId)
}


HookedWalletSubprovider.prototype.parityPostSign = function(address, message, cb) {
  const self = this

  // get next id
  const count = self._parityRequestCount
  const reqId = `0x${count.toString(16)}`
  self._parityRequestCount++

  self.emitPayload({
    method: 'eth_sign',
    params: [address, message],
  }, function(error, res){
    if (error) {
      self._parityRequests[reqId] = { error }
      return
    }
    const result = res.result
    self._parityRequests[reqId] = result
  })

  cb(null, reqId)
}

HookedWalletSubprovider.prototype.parityCheckRequest = function(reqId, cb) {
  const self = this
  const result = self._parityRequests[reqId] || null
  // tx not handled yet
  if (!result) return cb(null, null)
  // tx was rejected (or other error)
  if (result.error) return cb(result.error)
  // tx sent
  cb(null, result)
}

//
// signature and recovery
//

HookedWalletSubprovider.prototype.recoverPersonalSignature = function(msgParams, cb) {
  let senderHex
  try {
    senderHex = sigUtil.recoverPersonalSignature(msgParams)
  } catch (err) {
    return cb(err)
  }
  cb(null, senderHex)
}

//
// validation
//

HookedWalletSubprovider.prototype.validateTransaction = function(txParams, cb){
  const self = this
  // shortcut: undefined sender is invalid
  if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`))
  self.validateSender(txParams.from, function(err, senderIsValid){
    if (err) return cb(err)
    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: "${txParams.from}"`))
    cb()
  })
}

HookedWalletSubprovider.prototype.validateMessage = function(msgParams, cb){
  const self = this
  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`))
  self.validateSender(msgParams.from, function(err, senderIsValid){
    if (err) return cb(err)
    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`))
    cb()
  })
}

HookedWalletSubprovider.prototype.validatePersonalMessage = function(msgParams, cb){
  const self = this
  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`))
  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`))
  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`))
  self.validateSender(msgParams.from, function(err, senderIsValid){
    if (err) return cb(err)
    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`))
    cb()
  })
}

HookedWalletSubprovider.prototype.validateDecryptMessage = function(msgParams, cb){
  const self = this
  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`))
  if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`))
  if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`))
  self.validateSender(msgParams.from, function(err, senderIsValid){
    if (err) return cb(err)
    if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: "${msgParams.from}"`))
    cb()
  })
}

HookedWalletSubprovider.prototype.validateEncryptionPublicKey = function(address, cb){
  const self = this

  self.validateSender(address, function(err, senderIsValid){
    if (err) return cb(err)
    if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: "${address}"`))
    cb()
  })
}

HookedWalletSubprovider.prototype.validateTypedMessage = function(msgParams, cb){
  if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`))
  if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`))
  this.validateSender(msgParams.from, function(err, senderIsValid){
    if (err) return cb(err)
    if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`))
    cb()
  })
}

HookedWalletSubprovider.prototype.validateSender = function(senderAddress, cb){
  const self = this
  // shortcut: undefined sender is invalid
  if (!senderAddress) return cb(null, false)
  self.getAccounts(function(err, accounts){
    if (err) return cb(err)
    const senderIsValid = (accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1)
    cb(null, senderIsValid)
  })
}

//
// tx helpers
//

HookedWalletSubprovider.prototype.finalizeAndSubmitTx = function(txParams, cb) {
  const self = this
  // can only allow one tx to pass through this flow at a time
  // so we can atomically consume a nonce
  self.nonceLock.take(function(){
    waterfall([
      self.fillInTxExtras.bind(self, txParams),
      self.signTransaction.bind(self),
      self.publishTransaction.bind(self),
    ], function(err, txHash){
      self.nonceLock.leave()
      if (err) return cb(err)
      cb(null, txHash)
    })
  })
}

HookedWalletSubprovider.prototype.finalizeTx = function(txParams, cb) {
  const self = this
  // can only allow one tx to pass through this flow at a time
  // so we can atomically consume a nonce
  self.nonceLock.take(function(){
    waterfall([
      self.fillInTxExtras.bind(self, txParams),
      self.signTransaction.bind(self),
    ], function(err, signedTx){
      self.nonceLock.leave()
      if (err) return cb(err)
      cb(null, {raw: signedTx, tx: txParams})
    })
  })
}

HookedWalletSubprovider.prototype.publishTransaction = function(rawTx, cb) {
  const self = this
  self.emitPayload({
    method: 'eth_sendRawTransaction',
    params: [rawTx],
  }, function(err, res){
    if (err) return cb(err)
    cb(null, res.result)
  })
}

HookedWalletSubprovider.prototype.estimateGas = function(txParams, cb) {
  const self = this
  estimateGas(self.engine, txParams, cb)
}

HookedWalletSubprovider.prototype.getGasPrice = function(cb) {
  const self = this
  self.emitPayload({ method: 'eth_gasPrice', params: [] }, function (err, res) {
    if (err) return cb(err)
    cb(null, res.result)
  })
}

HookedWalletSubprovider.prototype.fillInTxExtras = function(txParams, cb){
  const self = this
  const address = txParams.from
  // console.log('fillInTxExtras - address:', address)

  const tasks = {}

  if (txParams.gasPrice === undefined) {
    // console.log("need to get gasprice")
    tasks.gasPrice = self.getGasPrice.bind(self)
  }

  if (txParams.nonce === undefined) {
    // console.log("need to get nonce")
    tasks.nonce = self.emitPayload.bind(self, { method: 'eth_getTransactionCount', params: [address, 'pending'] })
  }

  if (txParams.gas === undefined) {
    // console.log("need to get gas")
    tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams))
  }

  parallel(tasks, function(err, taskResults) {
    if (err) return cb(err)

    const result = {}
    if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice
    if (taskResults.nonce) result.nonce = taskResults.nonce.result
    if (taskResults.gas) result.gas = taskResults.gas

    cb(null, extend(txParams, result))
  })
}

// util

// we use this to clean any custom params from the txParams
function cloneTxParams(txParams){
  return {
    from: txParams.from,
    to: txParams.to,
    value: txParams.value,
    data: txParams.data,
    gas: txParams.gas,
    gasPrice: txParams.gasPrice,
    nonce: txParams.nonce,
  }
}

function toLowerCase(string){
  return string.toLowerCase()
}

function resemblesAddress (string) {
  const fixed = ethUtil.addHexPrefix(string)
  const isValid = ethUtil.isValidAddress(fixed)
  return isValid
}

// Returns true if resembles hex data
// but definitely not a valid address.
function resemblesData (string) {
  const fixed = ethUtil.addHexPrefix(string)
  const isValidAddress = ethUtil.isValidAddress(fixed)
  return !isValidAddress && isValidHex(string)
}

function isValidHex(data) {
  const isString = typeof data === 'string'
  if (!isString) return false
  const isHexPrefixed = data.slice(0,2) === '0x'
  if (!isHexPrefixed) return false
  const nonPrefixed = data.slice(2)
  const isValid = nonPrefixed.match(hexRegex)
  return isValid
}

function mustProvideInConstructor(methodName) {
  return function(params, cb) {
    cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'))
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\inflight-cache.js", {"./json-rpc-engine-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js","eth-json-rpc-middleware/inflight-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\inflight-cache.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\inflight-cache.js
      return function (require, module, exports) {
const ProviderSubprovider = require('./json-rpc-engine-middleware')
const createInflightCacheMiddleware = require('eth-json-rpc-middleware/inflight-cache')

class InflightCacheSubprovider extends ProviderSubprovider {
  constructor(opts) {
    super(() => createInflightCacheMiddleware(opts))
  }
}

module.exports = InflightCacheSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\infura.js", {"./provider.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\provider.js","eth-json-rpc-infura/src/createProvider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-infura\\src\\createProvider.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\infura.js
      return function (require, module, exports) {
const createInfuraProvider = require('eth-json-rpc-infura/src/createProvider')
const ProviderSubprovider = require('./provider.js')

class InfuraSubprovider extends ProviderSubprovider {
  constructor(opts = {}) {
    const provider = createInfuraProvider(opts)
    super(provider)
  }
}

module.exports = InfuraSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js", {"./subprovider.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\json-rpc-engine-middleware.js
      return function (require, module, exports) {
const Subprovider = require('./subprovider.js')

// wraps a json-rpc-engine middleware in a subprovider interface

class JsonRpcEngineMiddlewareSubprovider extends Subprovider {

  // take a constructorFn to call once we have a reference to the engine
  constructor (constructorFn) {
    super()
    if (!constructorFn) throw new Error('JsonRpcEngineMiddlewareSubprovider - no constructorFn specified')
    this._constructorFn = constructorFn
  }

  // this is called once the subprovider has been added to the provider engine
  setEngine (engine) {
    if (this.middleware) throw new Error('JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice')
    const blockTracker = engine._blockTracker
    const middleware = this._constructorFn({ engine, provider: engine, blockTracker })
    if (!middleware) throw new Error('JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware')
    if (typeof middleware !== 'function') throw new Error('JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function')
    this.middleware = middleware
  }

  handleRequest (req, provEngNext, provEngEnd) {
    const res = { id: req.id }
    this.middleware(req, res, middlewareNext, middlewareEnd)

    function middlewareNext (handler) {
      provEngNext((err, result, cb) => {
        // update response object with result or error
        if (err) {
          delete res.result
          res.error = { message: err.message || err }
        } else {
          res.result = result
        }
        // call middleware's next handler (even if error)
        if (handler) {
          handler(cb)
        } else {
          cb()
        }
      })
    }

    function middlewareEnd (err) {
      if (err) return provEngEnd(err)
      provEngEnd(null, res.result)
    }
  }

}

module.exports = JsonRpcEngineMiddlewareSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\nonce-tracker.js", {"../util/rpc-cache-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\rpc-cache-utils.js","./subprovider.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js","@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\nonce-tracker.js
      return function (require, module, exports) {
(function (Buffer){(function (){
const inherits = require('util').inherits
const { TransactionFactory } = require('@ethereumjs/tx')
const ethUtil = require('ethereumjs-util')
const Subprovider = require('./subprovider.js')
const blockTagForPayload = require('../util/rpc-cache-utils').blockTagForPayload

module.exports = NonceTrackerSubprovider

// handles the following RPC methods:
//   eth_getTransactionCount (pending only)
//
// observes the following RPC methods:
//   eth_sendRawTransaction
//   evm_revert (to clear the nonce cache)

inherits(NonceTrackerSubprovider, Subprovider)

function NonceTrackerSubprovider(){
  const self = this

  self.nonceCache = {}
}

NonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end){
  const self = this

  switch(payload.method) {

    case 'eth_getTransactionCount':
      var blockTag = blockTagForPayload(payload)
      var address = payload.params[0].toLowerCase()
      var cachedResult = self.nonceCache[address]
      // only handle requests against the 'pending' blockTag
      if (blockTag === 'pending') {
        // has a result
        if (cachedResult) {
          end(null, cachedResult)
        // fallthrough then populate cache
        } else {
          next(function(err, result, cb){
            if (err) return cb()
            if (self.nonceCache[address] === undefined) {
              self.nonceCache[address] = result
            }
            cb()
          })
        }
      } else {
        next()
      }
      return

    case 'eth_sendRawTransaction':
      // allow the request to continue normally
      next(function(err, result, cb){
        // only update local nonce if tx was submitted correctly
        if (err) return cb()
        // parse raw tx
        var rawTx = payload.params[0]
        var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex')
        const tx = TransactionFactory.fromSerializedData(rawData)
        // extract address
        var address = tx.getSenderAddress().toString('hex').toLowerCase()
        // extract nonce and increment
        var nonce = ethUtil.bufferToInt(tx.nonce)
        nonce++
        // hexify and normalize
        var hexNonce = nonce.toString(16)
        if (hexNonce.length%2) hexNonce = '0'+hexNonce
        hexNonce = '0x'+hexNonce
        // dont update our record on the nonce until the submit was successful
        // update cache
        self.nonceCache[address] = hexNonce
        cb()
      })
      return

   // Clear cache on a testrpc revert
   case 'evm_revert':
      self.nonceCache = {}
      next()
      return

    default:
      next()
      return

  }
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\provider.js", {"./subprovider.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\provider.js
      return function (require, module, exports) {
const inherits = require('util').inherits
const Subprovider = require('./subprovider.js')

// wraps a provider in a subprovider interface

module.exports = ProviderSubprovider

inherits(ProviderSubprovider, Subprovider)

function ProviderSubprovider(provider){
  if (!provider) throw new Error('ProviderSubprovider - no provider specified')
  if (!provider.sendAsync) throw new Error('ProviderSubprovider - specified provider does not have a sendAsync method')
  this.provider = provider
}

ProviderSubprovider.prototype.handleRequest = function(payload, next, end){
  this.provider.sendAsync(payload, function(err, response) {
    if (err) return end(err)
    if (response.error) return end(new Error(response.error.message))
    end(null, response.result)
  })
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\sanitizer.js", {"./subprovider.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","xtend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\sanitizer.js
      return function (require, module, exports) {
/* Sanitization Subprovider
 * For Parity compatibility
 * removes irregular keys
 */

const inherits = require('util').inherits
const Subprovider = require('./subprovider.js')
const extend = require('xtend')
const ethUtil = require('ethereumjs-util')

module.exports = SanitizerSubprovider

inherits(SanitizerSubprovider, Subprovider)

function SanitizerSubprovider(opts){
  const self = this
}

SanitizerSubprovider.prototype.handleRequest = function(payload, next, end){
  var txParams = payload.params[0]

  if (typeof txParams === 'object' && !Array.isArray(txParams)) {
    var sanitized = cloneTxParams(txParams)
    payload.params[0] = sanitized
  }

  next()
}

// we use this to clean any custom params from the txParams
var permitted = [
  'from',
  'to',
  'value',
  'data',
  'gas',
  'gasPrice',
  'nonce',
  'fromBlock',
  'toBlock',
  'address',
  'topics',
]

function cloneTxParams(txParams){
  var sanitized  =  permitted.reduce(function(copy, permitted) {
    if (permitted in txParams) {
      if (Array.isArray(txParams[permitted])) {
        copy[permitted] = txParams[permitted]
        .map(function(item) {
          return sanitize(item)
        })
      } else {
        copy[permitted] = sanitize(txParams[permitted])
      }
    }
    return copy
  }, {})

  return sanitized
}

function sanitize(value) {
  switch (value) {
    case 'latest':
      return value
    case 'pending':
      return value
    case 'earliest':
      return value
    default:
      if (typeof value === 'string') {
        return ethUtil.addHexPrefix(value.toLowerCase())
      } else {
        return value
      }
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", {"../util/create-payload.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\subprovider.js
      return function (require, module, exports) {
const createPayload = require('../util/create-payload.js')

module.exports = SubProvider

// this is the base class for a subprovider -- mostly helpers


function SubProvider() {

}

SubProvider.prototype.setEngine = function(engine) {
  const self = this
  if (self.engine) return
  self.engine = engine
  engine.on('block', function(block) {
    self.currentBlock = block
  })

  engine.on('start', function () {
    self.start()
  })

  engine.on('stop', function () {
    self.stop()
  })
}

SubProvider.prototype.handleRequest = function(payload, next, end) {
  throw new Error('Subproviders should override `handleRequest`.')
}

SubProvider.prototype.emitPayload = function(payload, cb){
  const self = this
  self.engine.sendAsync(createPayload(payload), cb)
}

// dummies for overriding

SubProvider.prototype.stop = function () {}

SubProvider.prototype.start = function () {}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subscriptions.js", {"./json-rpc-engine-middleware":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js","eth-json-rpc-filters/subscriptionManager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-filters\\subscriptionManager.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\subscriptions.js
      return function (require, module, exports) {
const ProviderSubprovider = require('./json-rpc-engine-middleware')
const createSubscriptionManager = require('eth-json-rpc-filters/subscriptionManager')

class SubscriptionsSubprovider extends ProviderSubprovider {
  constructor() {
    super(({ blockTracker, provider, engine }) => {
      const { events, middleware } = createSubscriptionManager({ blockTracker, provider })
      // forward subscription events on the engine
      events.on('notification', (data) => engine.emit('data', null, data))
      // return the subscription install/remove middleware
      return middleware
    })
  }
}

module.exports = SubscriptionsSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\websocket.js", {"../util/create-payload":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js","./subprovider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js","backoff":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\backoff\\index.js","events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js","ws":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\websocket.js
      return function (require, module, exports) {
const Backoff = require('backoff')
const EventEmitter = require('events')
const inherits = require('util').inherits
const WebSocket = global.WebSocket || require('ws')
const Subprovider = require('./subprovider')
const createPayload = require('../util/create-payload')

class WebsocketSubprovider
 extends Subprovider {
  constructor({ rpcUrl, debug, origin }) {
    super()

    // inherit from EventEmitter
    EventEmitter.call(this)

    Object.defineProperties(this, {
      _backoff: {
        value: Backoff.exponential({
          randomisationFactor: 0.2,
          maxDelay: 5000
        })
      },
      _connectTime: {
        value: null,
        writable: true
      },
      _log: {
        value: debug
          ? (...args) => console.info.apply(console, ['[WSProvider]', ...args])
          : () => { }
      },
      _origin: {
        value: origin
      },
      _pendingRequests: {
        value: new Map()
      },
      _socket: {
        value: null,
        writable: true
      },
      _unhandledRequests: {
        value: []
      },
      _url: {
        value: rpcUrl
      }
    })

    this._handleSocketClose = this._handleSocketClose.bind(this)
    this._handleSocketMessage = this._handleSocketMessage.bind(this)
    this._handleSocketOpen = this._handleSocketOpen.bind(this)

    // Called when a backoff timeout has finished. Time to try reconnecting.
    this._backoff.on('ready', () => {
      this._openSocket()
    })

    this._openSocket()
  }

  handleRequest(payload, next, end) {
    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {
      this._unhandledRequests.push(Array.from(arguments))
      this._log('Socket not open. Request queued.')
      return
    }

    this._pendingRequests.set(payload.id, [payload, end])

    const newPayload = createPayload(payload)
    delete newPayload.origin

    this._socket.send(JSON.stringify(newPayload))
    this._log(`Sent: ${newPayload.method} #${newPayload.id}`)
  }

  _handleSocketClose({ reason, code }) {
    this._log(`Socket closed, code ${code} (${reason || 'no reason'})`)
    // If the socket has been open for longer than 5 seconds, reset the backoff
    if (this._connectTime && Date.now() - this._connectTime > 5000) {
      this._backoff.reset()
    }

    this._socket.removeEventListener('close', this._handleSocketClose)
    this._socket.removeEventListener('message', this._handleSocketMessage)
    this._socket.removeEventListener('open', this._handleSocketOpen)

    this._socket = null
    this._backoff.backoff()
  }

  _handleSocketMessage(message) {
    let payload

    try {
      payload = JSON.parse(message.data)
    } catch (e) {
      this._log('Received a message that is not valid JSON:', payload)
      return
    }

    // check if server-sent notification
    if (payload.id === undefined) {
      return this.engine.emit('data', null, payload)
    }

    // ignore if missing
    if (!this._pendingRequests.has(payload.id)) {
      return
    }

    // retrieve payload + arguments
    const [originalReq, end] = this._pendingRequests.get(payload.id)
    this._pendingRequests.delete(payload.id)

    this._log(`Received: ${originalReq.method} #${payload.id}`)

    // forward response
    if (payload.error) {
      return end(new Error(payload.error.message))
    }
    end(null, payload.result)
  }

  _handleSocketOpen() {
    this._log('Socket open.')
    this._connectTime = Date.now()

    // Any pending requests need to be resent because our session was lost
    // and will not get responses for them in our new session.
    this._pendingRequests.forEach(([payload, end]) => {
      this._unhandledRequests.push([payload, null, end])
    })
    this._pendingRequests.clear()

    const unhandledRequests = this._unhandledRequests.splice(0, this._unhandledRequests.length)
    unhandledRequests.forEach(request => {
      this.handleRequest.apply(this, request)
    })
  }

  _openSocket() {
    this._log('Opening socket...')
    this._socket = new WebSocket(this._url, [], this._origin ? {headers:{origin: this._origin}} : {})
    this._socket.addEventListener('close', this._handleSocketClose)
    this._socket.addEventListener('message', this._handleSocketMessage)
    this._socket.addEventListener('open', this._handleSocketOpen)
  }
}

// multiple inheritance
Object.assign(WebsocketSubprovider.prototype, EventEmitter.prototype)

module.exports = WebsocketSubprovider

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js", {"./random-id.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\random-id.js","xtend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\create-payload.js
      return function (require, module, exports) {
const getRandomId = require('./random-id.js')
const extend = require('xtend')

module.exports = createPayload


function createPayload(data){
  return extend({
    // defaults
    id: getRandomId(),
    jsonrpc: '2.0',
    params: [],
    // user-specified
  }, data)
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\estimate-gas.js", {"./create-payload.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\estimate-gas.js
      return function (require, module, exports) {
const createPayload = require('./create-payload.js')

module.exports = estimateGas

/*

This is a work around for https://github.com/ethereum/go-ethereum/issues/2577

*/


function estimateGas(provider, txParams, cb) {
  provider.sendAsync(createPayload({
    method: 'eth_estimateGas',
    params: [txParams]
  }), function(err, res){
    if (err) {
      // handle simple value transfer case
      if (err.message === 'no contract code at given address') {
        return cb(null, '0xcf08')
      } else {
        return cb(err)        
      }
    }
    cb(null, res.result)
  })
}
      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\random-id.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\random-id.js
      return function (require, module, exports) {
module.exports = createRandomId


function createRandomId () {
  // random id
  return Math.floor(Number.MAX_SAFE_INTEGER * Math.random())
}
      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\rpc-cache-utils.js", {"json-stable-stringify":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-stable-stringify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\rpc-cache-utils.js
      return function (require, module, exports) {
const stringify = require('json-stable-stringify')

module.exports = {
  cacheIdentifierForPayload: cacheIdentifierForPayload,
  canCache: canCache,
  blockTagForPayload: blockTagForPayload,
  paramsWithoutBlockTag: paramsWithoutBlockTag,
  blockTagParamIndex: blockTagParamIndex,
  cacheTypeForPayload: cacheTypeForPayload,
}

function cacheIdentifierForPayload(payload, opts = {}){
  if (!canCache(payload)) return null
  const { includeBlockRef } = opts
  const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload)
  return payload.method + ':' + stringify(params)
}

function canCache(payload){
  return cacheTypeForPayload(payload) !== 'never'
}

function blockTagForPayload(payload){
  var index = blockTagParamIndex(payload);

  // Block tag param not passed.
  if (index >= payload.params.length) {
    return null;
  }

  return payload.params[index];
}

function paramsWithoutBlockTag(payload){
  var index = blockTagParamIndex(payload);

  // Block tag param not passed.
  if (index >= payload.params.length) {
    return payload.params;
  }

  // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
  if (payload.method === 'eth_getBlockByNumber') {
    return payload.params.slice(1);
  }

  return payload.params.slice(0,index);
}

function blockTagParamIndex(payload){
  switch(payload.method) {
    // blockTag is third param
    case 'eth_getStorageAt':
      return 2
    // blockTag is second param
    case 'eth_getBalance':
    case 'eth_getCode':
    case 'eth_getTransactionCount':
    case 'eth_call':
    case 'eth_estimateGas':
      return 1
    // blockTag is first param
    case 'eth_getBlockByNumber':
      return 0
    // there is no blockTag
    default:
      return undefined
  }
}

function cacheTypeForPayload(payload) {
  switch (payload.method) {
    // cache permanently
    case 'web3_clientVersion':
    case 'web3_sha3':
    case 'eth_protocolVersion':
    case 'eth_getBlockTransactionCountByHash':
    case 'eth_getUncleCountByBlockHash':
    case 'eth_getCode':
    case 'eth_getBlockByHash':
    case 'eth_getTransactionByHash':
    case 'eth_getTransactionByBlockHashAndIndex':
    case 'eth_getTransactionReceipt':
    case 'eth_getUncleByBlockHashAndIndex':
    case 'eth_getCompilers':
    case 'eth_compileLLL':
    case 'eth_compileSolidity':
    case 'eth_compileSerpent':
    case 'shh_version':
      return 'perma'

    // cache until fork
    case 'eth_getBlockByNumber':
    case 'eth_getBlockTransactionCountByNumber':
    case 'eth_getUncleCountByBlockNumber':
    case 'eth_getTransactionByBlockNumberAndIndex':
    case 'eth_getUncleByBlockNumberAndIndex':
      return 'fork'

    // cache for block
    case 'eth_gasPrice':
    case 'eth_getBalance':
    case 'eth_getStorageAt':
    case 'eth_getTransactionCount':
    case 'eth_call':
    case 'eth_estimateGas':
    case 'eth_getFilterLogs':
    case 'eth_getLogs':
    case 'eth_blockNumber':
      return 'block'

    // never cache
    case 'net_version':
    case 'net_peerCount':
    case 'net_listening':
    case 'eth_syncing':
    case 'eth_sign':
    case 'eth_coinbase':
    case 'eth_mining':
    case 'eth_hashrate':
    case 'eth_accounts':
    case 'eth_sendTransaction':
    case 'eth_sendRawTransaction':
    case 'eth_newFilter':
    case 'eth_newBlockFilter':
    case 'eth_newPendingTransactionFilter':
    case 'eth_uninstallFilter':
    case 'eth_getFilterChanges':
    case 'eth_getWork':
    case 'eth_submitWork':
    case 'eth_submitHashrate':
    case 'db_putString':
    case 'db_getString':
    case 'db_putHex':
    case 'db_getHex':
    case 'shh_post':
    case 'shh_newIdentity':
    case 'shh_hasIdentity':
    case 'shh_newGroup':
    case 'shh_addToGroup':
    case 'shh_newFilter':
    case 'shh_uninstallFilter':
    case 'shh_getFilterChanges':
    case 'shh_getMessages':
      return 'never'
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\stoplight.js", {"events":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js","util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\stoplight.js
      return function (require, module, exports) {
const EventEmitter = require('events').EventEmitter
const inherits = require('util').inherits

module.exports = Stoplight


inherits(Stoplight, EventEmitter)

function Stoplight(){
  const self = this
  EventEmitter.call(self)
  self.isLocked = true
}

Stoplight.prototype.go = function(){
  const self = this
  self.isLocked = false
  self.emit('unlock')
}

Stoplight.prototype.stop = function(){
  const self = this
  self.isLocked = true
  self.emit('lock')
}

Stoplight.prototype.await = function(fn){
  const self = this
  if (self.isLocked) {
    self.once('unlock', fn)
  } else {
    setTimeout(fn)
  }
}
      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\zero.js", {"./index.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\index.js","./subproviders/cache.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\cache.js","./subproviders/default-fixture.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\default-fixture.js","./subproviders/fetch.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fetch.js","./subproviders/filters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\filters.js","./subproviders/hooked-wallet.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\hooked-wallet.js","./subproviders/inflight-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\inflight-cache.js","./subproviders/infura.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\infura.js","./subproviders/nonce-tracker.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\nonce-tracker.js","./subproviders/sanitizer.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\sanitizer.js","./subproviders/subscriptions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subscriptions.js","./subproviders/websocket.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\websocket.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\zero.js
      return function (require, module, exports) {
const ProviderEngine = require('./index.js')
const DefaultFixture = require('./subproviders/default-fixture.js')
const NonceTrackerSubprovider = require('./subproviders/nonce-tracker.js')
const CacheSubprovider = require('./subproviders/cache.js')
const FilterSubprovider = require('./subproviders/filters')
const SubscriptionSubprovider = require('./subproviders/subscriptions')
const InflightCacheSubprovider = require('./subproviders/inflight-cache')
const HookedWalletSubprovider = require('./subproviders/hooked-wallet.js')
const SanitizingSubprovider = require('./subproviders/sanitizer.js')
const InfuraSubprovider = require('./subproviders/infura.js')
const FetchSubprovider = require('./subproviders/fetch.js')
const WebSocketSubprovider = require('./subproviders/websocket.js')


module.exports = ZeroClientProvider


function ZeroClientProvider(opts = {}){
  const connectionType = getConnectionType(opts)

  const engine = new ProviderEngine(opts.engineParams)

  // static
  const staticSubprovider = new DefaultFixture(opts.static)
  engine.addProvider(staticSubprovider)

  // nonce tracker
  engine.addProvider(new NonceTrackerSubprovider())

  // sanitization
  const sanitizer = new SanitizingSubprovider()
  engine.addProvider(sanitizer)

  // cache layer
  const cacheSubprovider = new CacheSubprovider()
  engine.addProvider(cacheSubprovider)

  // filters + subscriptions
  // only polyfill if not websockets
  if (connectionType !== 'ws') {
    engine.addProvider(new SubscriptionSubprovider())
    engine.addProvider(new FilterSubprovider())
  }

  // inflight cache
  const inflightCache = new InflightCacheSubprovider()
  engine.addProvider(inflightCache)

  // id mgmt
  const idmgmtSubprovider = new HookedWalletSubprovider({
    // accounts
    getAccounts: opts.getAccounts,
    // transactions
    processTransaction: opts.processTransaction,
    approveTransaction: opts.approveTransaction,
    signTransaction: opts.signTransaction,
    publishTransaction: opts.publishTransaction,
    // messages
    // old eth_sign
    processMessage: opts.processMessage,
    approveMessage: opts.approveMessage,
    signMessage: opts.signMessage,
    // new personal_sign
    processPersonalMessage: opts.processPersonalMessage,
    processTypedMessage: opts.processTypedMessage,
    approvePersonalMessage: opts.approvePersonalMessage,
    approveTypedMessage: opts.approveTypedMessage,
    signPersonalMessage: opts.signPersonalMessage,
    signTypedMessage: opts.signTypedMessage,
    personalRecoverSigner: opts.personalRecoverSigner,
  })
  engine.addProvider(idmgmtSubprovider)

  // data source
  const dataSubprovider = opts.dataSubprovider || createDataSubprovider(connectionType, opts)
  engine.addProvider(dataSubprovider)

  // start polling
  if (!opts.stopped) {
    engine.start()
  }

  return engine

}

function createDataSubprovider(connectionType, opts) {
  const { rpcUrl, debug } = opts

  // default to infura
  if (!connectionType) {
    return new InfuraSubprovider()
  }
  if (connectionType === 'http') {
    return new FetchSubprovider({ rpcUrl, debug })
  }
  if (connectionType === 'ws') {
    return new WebSocketSubprovider({ rpcUrl, debug })
  }

  throw new Error(`ProviderEngine - unrecognized connectionType "${connectionType}"`)
}

function getConnectionType({ rpcUrl }) {
  if (!rpcUrl) return undefined

  const protocol = rpcUrl.split(':')[0].toLowerCase()
  switch (protocol) {
    case 'http':
    case 'https':
      return 'http'
    case 'ws':
    case 'wss':
      return 'ws'
    default:
      throw new Error(`ProviderEngine - unrecognized protocol in "${rpcUrl}"`)
  }
}

      };
    };
  }
}, {package:"@metamask/controllers>web3-provider-engine",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\index.js", {"./lib/web3":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\index.js
      return function (require, module, exports) {
var Web3 = require('./lib/web3');

// dont override global variable
if (typeof window !== 'undefined' && typeof window.Web3 === 'undefined') {
    window.Web3 = Web3;
}

module.exports = Web3;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\GlobalRegistrar.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\contracts\GlobalRegistrar.json
      return function (require, module, exports) {
module.exports=[
  {
    "constant": true,
    "inputs": [
      {
        "name": "_owner",
        "type": "address"
      }
    ],
    "name": "name",
    "outputs": [
      {
        "name": "o_name",
        "type": "bytes32"
      }
    ],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "owner",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "content",
    "outputs": [
      {
        "name": "",
        "type": "bytes32"
      }
    ],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "addr",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "reserve",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "subRegistrar",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      },
      {
        "name": "_newOwner",
        "type": "address"
      }
    ],
    "name": "transfer",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      },
      {
        "name": "_registrar",
        "type": "address"
      }
    ],
    "name": "setSubRegistrar",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [],
    "name": "Registrar",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      },
      {
        "name": "_a",
        "type": "address"
      },
      {
        "name": "_primary",
        "type": "bool"
      }
    ],
    "name": "setAddress",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      },
      {
        "name": "_content",
        "type": "bytes32"
      }
    ],
    "name": "setContent",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "disown",
    "outputs": [],
    "type": "function"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "_name",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "name": "_winner",
        "type": "address"
      }
    ],
    "name": "AuctionEnded",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "_name",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "name": "_bidder",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "_value",
        "type": "uint256"
      }
    ],
    "name": "NewBid",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "name",
        "type": "bytes32"
      }
    ],
    "name": "Changed",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "name",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "name": "addr",
        "type": "address"
      }
    ],
    "name": "PrimaryChanged",
    "type": "event"
  }
]

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\ICAPRegistrar.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\contracts\ICAPRegistrar.json
      return function (require, module, exports) {
module.exports=[
  {
    "constant": true,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "owner",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      },
      {
        "name": "_refund",
        "type": "address"
      }
    ],
    "name": "disown",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "addr",
    "outputs": [
      {
        "name": "",
        "type": "address"
      }
    ],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      }
    ],
    "name": "reserve",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      },
      {
        "name": "_newOwner",
        "type": "address"
      }
    ],
    "name": "transfer",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "_name",
        "type": "bytes32"
      },
      {
        "name": "_a",
        "type": "address"
      }
    ],
    "name": "setAddr",
    "outputs": [],
    "type": "function"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "name",
        "type": "bytes32"
      }
    ],
    "name": "Changed",
    "type": "event"
  }
]

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\SmartExchange.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\contracts\SmartExchange.json
      return function (require, module, exports) {
module.exports=[
  {
    "constant": false,
    "inputs": [
      {
        "name": "from",
        "type": "bytes32"
      },
      {
        "name": "to",
        "type": "address"
      },
      {
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "transfer",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "from",
        "type": "bytes32"
      },
      {
        "name": "to",
        "type": "address"
      },
      {
        "name": "indirectId",
        "type": "bytes32"
      },
      {
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "icapTransfer",
    "outputs": [],
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [
      {
        "name": "to",
        "type": "bytes32"
      }
    ],
    "name": "deposit",
    "outputs": [],
    "payable": true,
    "type": "function"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "from",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "AnonymousDeposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "from",
        "type": "address"
      },
      {
        "indexed": true,
        "name": "to",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Deposit",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "from",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "Transfer",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {
        "indexed": true,
        "name": "from",
        "type": "bytes32"
      },
      {
        "indexed": true,
        "name": "to",
        "type": "address"
      },
      {
        "indexed": false,
        "name": "indirectId",
        "type": "bytes32"
      },
      {
        "indexed": false,
        "name": "value",
        "type": "uint256"
      }
    ],
    "name": "IcapTransfer",
    "type": "event"
  }
]

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\address.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\address.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

/**
 * SolidityTypeAddress is a prootype that represents address type
 * It matches:
 * address
 * address[]
 * address[4]
 * address[][]
 * address[3][]
 * address[][6][], ...
 */
var SolidityTypeAddress = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputAddress;
};

SolidityTypeAddress.prototype = new SolidityType({});
SolidityTypeAddress.prototype.constructor = SolidityTypeAddress;

SolidityTypeAddress.prototype.isType = function (name) {
    return !!name.match(/address(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeAddress;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bool.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\bool.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

/**
 * SolidityTypeBool is a prootype that represents bool type
 * It matches:
 * bool
 * bool[]
 * bool[4]
 * bool[][]
 * bool[3][]
 * bool[][6][], ...
 */
var SolidityTypeBool = function () {
    this._inputFormatter = f.formatInputBool;
    this._outputFormatter = f.formatOutputBool;
};

SolidityTypeBool.prototype = new SolidityType({});
SolidityTypeBool.prototype.constructor = SolidityTypeBool;

SolidityTypeBool.prototype.isType = function (name) {
    return !!name.match(/^bool(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBool;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bytes.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\bytes.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

/**
 * SolidityTypeBytes is a prototype that represents the bytes type.
 * It matches:
 * bytes
 * bytes[]
 * bytes[4]
 * bytes[][]
 * bytes[3][]
 * bytes[][6][], ...
 * bytes32
 * bytes8[4]
 * bytes[3][]
 */
var SolidityTypeBytes = function () {
    this._inputFormatter = f.formatInputBytes;
    this._outputFormatter = f.formatOutputBytes;
};

SolidityTypeBytes.prototype = new SolidityType({});
SolidityTypeBytes.prototype.constructor = SolidityTypeBytes;

SolidityTypeBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes([0-9]{1,})(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeBytes;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js", {"./address":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\address.js","./bool":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bool.js","./bytes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bytes.js","./dynamicbytes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\dynamicbytes.js","./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./int":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\int.js","./real":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\real.js","./string":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\string.js","./uint":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\uint.js","./ureal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\ureal.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\coder.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file coder.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var f = require('./formatters');

var SolidityTypeAddress = require('./address');
var SolidityTypeBool = require('./bool');
var SolidityTypeInt = require('./int');
var SolidityTypeUInt = require('./uint');
var SolidityTypeDynamicBytes = require('./dynamicbytes');
var SolidityTypeString = require('./string');
var SolidityTypeReal = require('./real');
var SolidityTypeUReal = require('./ureal');
var SolidityTypeBytes = require('./bytes');

var isDynamic = function (solidityType, type) {
   return solidityType.isDynamicType(type) ||
          solidityType.isDynamicArray(type);
};

/**
 * SolidityCoder prototype should be used to encode/decode solidity params of any type
 */
var SolidityCoder = function (types) {
    this._types = types;
};

/**
 * This method should be used to transform type to SolidityType
 *
 * @method _requireType
 * @param {String} type
 * @returns {SolidityType}
 * @throws {Error} throws if no matching type is found
 */
SolidityCoder.prototype._requireType = function (type) {
    var solidityType = this._types.filter(function (t) {
        return t.isType(type);
    })[0];

    if (!solidityType) {
        throw Error('invalid solidity type!: ' + type);
    }

    return solidityType;
};

/**
 * Should be used to encode plain param
 *
 * @method encodeParam
 * @param {String} type
 * @param {Object} plain param
 * @return {String} encoded plain param
 */
SolidityCoder.prototype.encodeParam = function (type, param) {
    return this.encodeParams([type], [param]);
};

/**
 * Should be used to encode list of params
 *
 * @method encodeParams
 * @param {Array} types
 * @param {Array} params
 * @return {String} encoded list of params
 */
SolidityCoder.prototype.encodeParams = function (types, params) {
    var solidityTypes = this.getSolidityTypes(types);

    var encodeds = solidityTypes.map(function (solidityType, index) {
        return solidityType.encode(params[index], types[index]);
    });

    var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {
        var staticPartLength = solidityType.staticPartLength(types[index]);
        var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;

        return acc + (isDynamic(solidityTypes[index], types[index]) ?
            32 :
            roundedStaticPartLength);
    }, 0);

    var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);

    return result;
};

SolidityCoder.prototype.encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {
    var result = "";
    var self = this;

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            result += f.formatInputInt(dynamicOffset).encode();
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
        } else {
            // don't add length to dynamicOffset. it's already counted
            result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
        }

        // TODO: figure out nested arrays
    });

    types.forEach(function (type, i) {
        if (isDynamic(solidityTypes[i], types[i])) {
            var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
            dynamicOffset += e.length / 2;
            result += e;
        }
    });
    return result;
};

SolidityCoder.prototype.encodeWithOffset = function (type, solidityType, encoded, offset) {
    /* jshint maxcomplexity: 17 */
    /* jshint maxdepth: 5 */

    var self = this;
    var encodingMode={dynamic:1,static:2,other:3};

    var mode=(solidityType.isDynamicArray(type)?encodingMode.dynamic:(solidityType.isStaticArray(type)?encodingMode.static:encodingMode.other));

    if(mode !== encodingMode.other){
        var nestedName = solidityType.nestedName(type);
        var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
        var result = (mode === encodingMode.dynamic ? encoded[0] : '');

        if (solidityType.isDynamicArray(nestedName)) {
            var previousLength = (mode === encodingMode.dynamic ? 2 : 0);

            for (var i = 0; i < encoded.length; i++) {
                // calculate length of previous item
                if(mode === encodingMode.dynamic){
                    previousLength += +(encoded[i - 1])[0] || 0;
                }
                else if(mode === encodingMode.static){
                    previousLength += +(encoded[i - 1] || [])[0] || 0;
                }
                result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
            }
        }

        var len= (mode === encodingMode.dynamic ? encoded.length-1 : encoded.length);
        for (var c = 0; c < len; c++) {
            var additionalOffset = result / 2;
            if(mode === encodingMode.dynamic){
                result += self.encodeWithOffset(nestedName, solidityType, encoded[c + 1], offset +  additionalOffset);
            }
            else if(mode === encodingMode.static){
                result += self.encodeWithOffset(nestedName, solidityType, encoded[c], offset + additionalOffset);
            }
        }

        return result;
    }

    return encoded;
};


/**
 * Should be used to decode bytes to plain param
 *
 * @method decodeParam
 * @param {String} type
 * @param {String} bytes
 * @return {Object} plain param
 */
SolidityCoder.prototype.decodeParam = function (type, bytes) {
    return this.decodeParams([type], bytes)[0];
};

/**
 * Should be used to decode list of params
 *
 * @method decodeParam
 * @param {Array} types
 * @param {String} bytes
 * @return {Array} array of plain params
 */
SolidityCoder.prototype.decodeParams = function (types, bytes) {
    var solidityTypes = this.getSolidityTypes(types);
    var offsets = this.getOffsets(types, solidityTypes);

    return solidityTypes.map(function (solidityType, index) {
        return solidityType.decode(bytes, offsets[index],  types[index], index);
    });
};

SolidityCoder.prototype.getOffsets = function (types, solidityTypes) {
    var lengths =  solidityTypes.map(function (solidityType, index) {
        return solidityType.staticPartLength(types[index]);
    });

    for (var i = 1; i < lengths.length; i++) {
         // sum with length of previous element
        lengths[i] += lengths[i - 1];
    }

    return lengths.map(function (length, index) {
        // remove the current length, so the length is sum of previous elements
        var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
        return length - staticPartLength;
    });
};

SolidityCoder.prototype.getSolidityTypes = function (types) {
    var self = this;
    return types.map(function (type) {
        return self._requireType(type);
    });
};

var coder = new SolidityCoder([
    new SolidityTypeAddress(),
    new SolidityTypeBool(),
    new SolidityTypeInt(),
    new SolidityTypeUInt(),
    new SolidityTypeDynamicBytes(),
    new SolidityTypeBytes(),
    new SolidityTypeString(),
    new SolidityTypeReal(),
    new SolidityTypeUReal()
]);

module.exports = coder;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\dynamicbytes.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\dynamicbytes.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

var SolidityTypeDynamicBytes = function () {
    this._inputFormatter = f.formatInputDynamicBytes;
    this._outputFormatter = f.formatOutputDynamicBytes;
};

SolidityTypeDynamicBytes.prototype = new SolidityType({});
SolidityTypeDynamicBytes.prototype.constructor = SolidityTypeDynamicBytes;

SolidityTypeDynamicBytes.prototype.isType = function (name) {
    return !!name.match(/^bytes(\[([0-9]*)\])*$/);
};

SolidityTypeDynamicBytes.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeDynamicBytes;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", {"../utils/config":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js","../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./param":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\param.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\formatters.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = require('bignumber.js');
var utils = require('../utils/utils');
var c = require('../utils/config');
var SolidityParam = require('./param');


/**
 * Formats input value to byte representation of int
 * If value is negative, return it's two's complement
 * If the value is floating point, round it down
 *
 * @method formatInputInt
 * @param {String|Number|BigNumber} value that needs to be formatted
 * @returns {SolidityParam}
 */
var formatInputInt = function (value) {
    BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
    var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(result);
};

/**
 * Formats input bytes
 *
 * @method formatDynamicInputBytes
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputDynamicBytes = function (value) {
    var result = utils.toHex(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of string
 *
 * @method formatInputString
 * @param {String}
 * @returns {SolidityParam}
 */
var formatInputString = function (value) {
    var result = utils.fromUtf8(value).substr(2);
    var length = result.length / 2;
    var l = Math.floor((result.length + 63) / 64);
    result = utils.padRight(result, l * 64);
    return new SolidityParam(formatInputInt(length).value + result);
};

/**
 * Formats input value to byte representation of bool
 *
 * @method formatInputBool
 * @param {Boolean}
 * @returns {SolidityParam}
 */
var formatInputBool = function (value) {
    var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ?  '1' : '0');
    return new SolidityParam(result);
};

/**
 * Formats input value to byte representation of real
 * Values are multiplied by 2^m and encoded as integers
 *
 * @method formatInputReal
 * @param {String|Number|BigNumber}
 * @returns {SolidityParam}
 */
var formatInputReal = function (value) {
    return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));
};

/**
 * Check if input value is negative
 *
 * @method signedIsNegative
 * @param {String} value is hex format
 * @returns {Boolean} true if it is negative, otherwise false
 */
var signedIsNegative = function (value) {
    return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';
};

/**
 * Formats right-aligned output bytes to int
 *
 * @method formatOutputInt
 * @param {SolidityParam} param
 * @returns {BigNumber} right-aligned output bytes formatted to big number
 */
var formatOutputInt = function (param) {
    var value = param.staticPart() || "0";

    // check if it's negative number
    // it it is, return two's complement
    if (signedIsNegative(value)) {
        return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);
    }
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to uint
 *
 * @method formatOutputUInt
 * @param {SolidityParam}
 * @returns {BigNumeber} right-aligned output bytes formatted to uint
 */
var formatOutputUInt = function (param) {
    var value = param.staticPart() || "0";
    return new BigNumber(value, 16);
};

/**
 * Formats right-aligned output bytes to real
 *
 * @method formatOutputReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to real
 */
var formatOutputReal = function (param) {
    return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Formats right-aligned output bytes to ureal
 *
 * @method formatOutputUReal
 * @param {SolidityParam}
 * @returns {BigNumber} input bytes formatted to ureal
 */
var formatOutputUReal = function (param) {
    return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));
};

/**
 * Should be used to format output bool
 *
 * @method formatOutputBool
 * @param {SolidityParam}
 * @returns {Boolean} right-aligned input bytes formatted to bool
 */
var formatOutputBool = function (param) {
    return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @param {String} name type name
 * @returns {String} hex string
 */
var formatOutputBytes = function (param, name) {
    var matches = name.match(/^bytes([0-9]*)/);
    var size = parseInt(matches[1]);
    return '0x' + param.staticPart().slice(0, 2 * size);
};

/**
 * Should be used to format output bytes
 *
 * @method formatOutputDynamicBytes
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} hex string
 */
var formatOutputDynamicBytes = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return '0x' + param.dynamicPart().substr(64, length);
};

/**
 * Should be used to format output string
 *
 * @method formatOutputString
 * @param {SolidityParam} left-aligned hex representation of string
 * @returns {String} ascii string
 */
var formatOutputString = function (param) {
    var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
    return utils.toUtf8(param.dynamicPart().substr(64, length));
};

/**
 * Should be used to format output address
 *
 * @method formatOutputAddress
 * @param {SolidityParam} right-aligned input bytes
 * @returns {String} address
 */
var formatOutputAddress = function (param) {
    var value = param.staticPart();
    return "0x" + value.slice(value.length - 40, value.length);
};

module.exports = {
    formatInputInt: formatInputInt,
    formatInputBytes: formatInputBytes,
    formatInputDynamicBytes: formatInputDynamicBytes,
    formatInputString: formatInputString,
    formatInputBool: formatInputBool,
    formatInputReal: formatInputReal,
    formatOutputInt: formatOutputInt,
    formatOutputUInt: formatOutputUInt,
    formatOutputReal: formatOutputReal,
    formatOutputUReal: formatOutputUReal,
    formatOutputBool: formatOutputBool,
    formatOutputBytes: formatOutputBytes,
    formatOutputDynamicBytes: formatOutputDynamicBytes,
    formatOutputString: formatOutputString,
    formatOutputAddress: formatOutputAddress
};

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\int.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\int.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

/**
 * SolidityTypeInt is a prootype that represents int type
 * It matches:
 * int
 * int[]
 * int[4]
 * int[][]
 * int[3][]
 * int[][6][], ...
 * int32
 * int64[]
 * int8[4]
 * int256[][]
 * int[3][]
 * int64[][6][], ...
 */
var SolidityTypeInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputInt;
};

SolidityTypeInt.prototype = new SolidityType({});
SolidityTypeInt.prototype.constructor = SolidityTypeInt;

SolidityTypeInt.prototype.isType = function (name) {
    return !!name.match(/^int([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeInt;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\param.js", {"../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\param.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file param.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = require('../utils/utils');

/**
 * SolidityParam object prototype.
 * Should be used when encoding, decoding solidity bytes
 */
var SolidityParam = function (value, offset) {
    this.value = value || '';
    this.offset = offset; // offset in bytes
};

/**
 * This method should be used to get length of params's dynamic part
 * 
 * @method dynamicPartLength
 * @returns {Number} length of dynamic part (in bytes)
 */
SolidityParam.prototype.dynamicPartLength = function () {
    return this.dynamicPart().length / 2;
};

/**
 * This method should be used to create copy of solidity param with different offset
 *
 * @method withOffset
 * @param {Number} offset length in bytes
 * @returns {SolidityParam} new solidity param with applied offset
 */
SolidityParam.prototype.withOffset = function (offset) {
    return new SolidityParam(this.value, offset);
};

/**
 * This method should be used to combine solidity params together
 * eg. when appending an array
 *
 * @method combine
 * @param {SolidityParam} param with which we should combine
 * @param {SolidityParam} result of combination
 */
SolidityParam.prototype.combine = function (param) {
    return new SolidityParam(this.value + param.value); 
};

/**
 * This method should be called to check if param has dynamic size.
 * If it has, it returns true, otherwise false
 *
 * @method isDynamic
 * @returns {Boolean}
 */
SolidityParam.prototype.isDynamic = function () {
    return this.offset !== undefined;
};

/**
 * This method should be called to transform offset to bytes
 *
 * @method offsetAsBytes
 * @returns {String} bytes representation of offset
 */
SolidityParam.prototype.offsetAsBytes = function () {
    return !this.isDynamic() ? '' : utils.padLeft(utils.toTwosComplement(this.offset).toString(16), 64);
};

/**
 * This method should be called to get static part of param
 *
 * @method staticPart
 * @returns {String} offset if it is a dynamic param, otherwise value
 */
SolidityParam.prototype.staticPart = function () {
    if (!this.isDynamic()) {
        return this.value; 
    } 
    return this.offsetAsBytes();
};

/**
 * This method should be called to get dynamic part of param
 *
 * @method dynamicPart
 * @returns {String} returns a value if it is a dynamic param, otherwise empty string
 */
SolidityParam.prototype.dynamicPart = function () {
    return this.isDynamic() ? this.value : '';
};

/**
 * This method should be called to encode param
 *
 * @method encode
 * @returns {String}
 */
SolidityParam.prototype.encode = function () {
    return this.staticPart() + this.dynamicPart();
};

/**
 * This method should be called to encode array of params
 *
 * @method encodeList
 * @param {Array[SolidityParam]} params
 * @returns {String}
 */
SolidityParam.encodeList = function (params) {
    
    // updating offsets
    var totalOffset = params.length * 32;
    var offsetParams = params.map(function (param) {
        if (!param.isDynamic()) {
            return param;
        }
        var offset = totalOffset;
        totalOffset += param.dynamicPartLength();
        return param.withOffset(offset);
    });

    // encode everything!
    return offsetParams.reduce(function (result, param) {
        return result + param.dynamicPart();
    }, offsetParams.reduce(function (result, param) {
        return result + param.staticPart();
    }, ''));
};



module.exports = SolidityParam;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\real.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\real.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

/**
 * SolidityTypeReal is a prootype that represents real type
 * It matches:
 * real
 * real[]
 * real[4]
 * real[][]
 * real[3][]
 * real[][6][], ...
 * real32
 * real64[]
 * real8[4]
 * real256[][]
 * real[3][]
 * real64[][6][], ...
 */
var SolidityTypeReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputReal;
};

SolidityTypeReal.prototype = new SolidityType({});
SolidityTypeReal.prototype.constructor = SolidityTypeReal;

SolidityTypeReal.prototype.isType = function (name) {
    return !!name.match(/real([0-9]*)?(\[([0-9]*)\])?/);
};

module.exports = SolidityTypeReal;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\string.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\string.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

var SolidityTypeString = function () {
    this._inputFormatter = f.formatInputString;
    this._outputFormatter = f.formatOutputString;
};

SolidityTypeString.prototype = new SolidityType({});
SolidityTypeString.prototype.constructor = SolidityTypeString;

SolidityTypeString.prototype.isType = function (name) {
    return !!name.match(/^string(\[([0-9]*)\])*$/);
};

SolidityTypeString.prototype.isDynamicType = function () {
    return true;
};

module.exports = SolidityTypeString;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./param":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\param.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\type.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityParam = require('./param');

/**
 * SolidityType prototype is used to encode/decode solidity params of certain type
 */
var SolidityType = function (config) {
    this._inputFormatter = config.inputFormatter;
    this._outputFormatter = config.outputFormatter;
};

/**
 * Should be used to determine if this SolidityType do match given name
 *
 * @method isType
 * @param {String} name
 * @return {Bool} true if type match this SolidityType, otherwise false
 */
SolidityType.prototype.isType = function (name) {
    throw "this method should be overrwritten for type " + name;
};

/**
 * Should be used to determine what is the length of static part in given type
 *
 * @method staticPartLength
 * @param {String} name
 * @return {Number} length of static part in bytes
 */
SolidityType.prototype.staticPartLength = function (name) {
    // If name isn't an array then treat it like a single element array.
    return (this.nestedTypes(name) || ['[1]'])
        .map(function (type) {
            // the length of the nested array
            return parseInt(type.slice(1, -1), 10) || 1;
        })
        .reduce(function (previous, current) {
            return previous * current;
        // all basic types are 32 bytes long
        }, 32);
};

/**
 * Should be used to determine if type is dynamic array
 * eg:
 * "type[]" => true
 * "type[4]" => false
 *
 * @method isDynamicArray
 * @param {String} name
 * @return {Bool} true if the type is dynamic array
 */
SolidityType.prototype.isDynamicArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should be used to determine if type is static array
 * eg:
 * "type[]" => false
 * "type[4]" => true
 *
 * @method isStaticArray
 * @param {String} name
 * @return {Bool} true if the type is static array
 */
SolidityType.prototype.isStaticArray = function (name) {
    var nestedTypes = this.nestedTypes(name);
    return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
};

/**
 * Should return length of static array
 * eg.
 * "int[32]" => 32
 * "int256[14]" => 14
 * "int[2][3]" => 3
 * "int" => 1
 * "int[1]" => 1
 * "int[]" => 1
 *
 * @method staticArrayLength
 * @param {String} name
 * @return {Number} static array length
 */
SolidityType.prototype.staticArrayLength = function (name) {
    var nestedTypes = this.nestedTypes(name);
    if (nestedTypes) {
       return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);
    }
    return 1;
};

/**
 * Should return nested type
 * eg.
 * "int[32]" => "int"
 * "int256[14]" => "int256"
 * "int[2][3]" => "int[2]"
 * "int" => "int"
 * "int[]" => "int"
 *
 * @method nestedName
 * @param {String} name
 * @return {String} nested name
 */
SolidityType.prototype.nestedName = function (name) {
    // remove last [] in name
    var nestedTypes = this.nestedTypes(name);
    if (!nestedTypes) {
        return name;
    }

    return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);
};

/**
 * Should return true if type has dynamic size by default
 * such types are "string", "bytes"
 *
 * @method isDynamicType
 * @param {String} name
 * @return {Bool} true if is dynamic, otherwise false
 */
SolidityType.prototype.isDynamicType = function () {
    return false;
};

/**
 * Should return array of nested types
 * eg.
 * "int[2][3][]" => ["[2]", "[3]", "[]"]
 * "int[] => ["[]"]
 * "int" => null
 *
 * @method nestedTypes
 * @param {String} name
 * @return {Array} array of nested types
 */
SolidityType.prototype.nestedTypes = function (name) {
    // return list of strings eg. "[]", "[3]", "[]", "[2]"
    return name.match(/(\[[0-9]*\])/g);
};

/**
 * Should be used to encode the value
 *
 * @method encode
 * @param {Object} value
 * @param {String} name
 * @return {String} encoded value
 */
SolidityType.prototype.encode = function (value, name) {
    var self = this;
    if (this.isDynamicArray(name)) {

        return (function () {
            var length = value.length;                          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            result.push(f.formatInputInt(length).encode());

            value.forEach(function (v) {
                result.push(self.encode(v, nestedName));
            });

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);          // in int
            var nestedName = self.nestedName(name);

            var result = [];
            for (var i = 0; i < length; i++) {
                result.push(self.encode(value[i], nestedName));
            }

            return result;
        })();

    }

    return this._inputFormatter(value, name).encode();
};

/**
 * Should be used to decode value from bytes
 *
 * @method decode
 * @param {String} bytes
 * @param {Number} offset in bytes
 * @param {String} name type name
 * @returns {Object} decoded value
 */
SolidityType.prototype.decode = function (bytes, offset, name) {
    var self = this;

    if (this.isDynamicArray(name)) {

        return (function () {
            var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes
            var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int
            var arrayStart = arrayOffset + 32; // array starts after length; // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();

    } else if (this.isStaticArray(name)) {

        return (function () {
            var length = self.staticArrayLength(name);                      // in int
            var arrayStart = offset;                                        // in bytes

            var nestedName = self.nestedName(name);
            var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes
            var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
            var result = [];

            for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                result.push(self.decode(bytes, arrayStart + i, nestedName));
            }

            return result;
        })();
    } else if (this.isDynamicType(name)) {

        return (function () {
            var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes
            var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes
            var roundedLength = Math.floor((length + 31) / 32);                     // in int
            var param = new SolidityParam(bytes.substr(dynamicOffset * 2, ( 1 + roundedLength) * 64), 0);
            return self._outputFormatter(param, name);
        })();
    }

    var length = this.staticPartLength(name);
    var param = new SolidityParam(bytes.substr(offset * 2, length * 2));
    return this._outputFormatter(param, name);
};

module.exports = SolidityType;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\uint.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\uint.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

/**
 * SolidityTypeUInt is a prootype that represents uint type
 * It matches:
 * uint
 * uint[]
 * uint[4]
 * uint[][]
 * uint[3][]
 * uint[][6][], ...
 * uint32
 * uint64[]
 * uint8[4]
 * uint256[][]
 * uint[3][]
 * uint64[][6][], ...
 */
var SolidityTypeUInt = function () {
    this._inputFormatter = f.formatInputInt;
    this._outputFormatter = f.formatOutputUInt;
};

SolidityTypeUInt.prototype = new SolidityType({});
SolidityTypeUInt.prototype.constructor = SolidityTypeUInt;

SolidityTypeUInt.prototype.isType = function (name) {
    return !!name.match(/^uint([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUInt;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\ureal.js", {"./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js","./type":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\ureal.js
      return function (require, module, exports) {
var f = require('./formatters');
var SolidityType = require('./type');

/**
 * SolidityTypeUReal is a prootype that represents ureal type
 * It matches:
 * ureal
 * ureal[]
 * ureal[4]
 * ureal[][]
 * ureal[3][]
 * ureal[][6][], ...
 * ureal32
 * ureal64[]
 * ureal8[4]
 * ureal256[][]
 * ureal[3][]
 * ureal64[][6][], ...
 */
var SolidityTypeUReal = function () {
    this._inputFormatter = f.formatInputReal;
    this._outputFormatter = f.formatOutputUReal;
};

SolidityTypeUReal.prototype = new SolidityType({});
SolidityTypeUReal.prototype.constructor = SolidityTypeUReal;

SolidityTypeUReal.prototype.isType = function (name) {
    return !!name.match(/^ureal([0-9]*)?(\[([0-9]*)\])*$/);
};

module.exports = SolidityTypeUReal;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\browser-xhr.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\browser-xhr.js
      return function (require, module, exports) {
'use strict';

// go env doesn't have and need XMLHttpRequest
if (typeof XMLHttpRequest === 'undefined') {
    exports.XMLHttpRequest = {};
} else {
    exports.XMLHttpRequest = XMLHttpRequest; // jshint ignore:line
}


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js", {"bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\config.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file config.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 * 
 * @module utils
 */

/**
 * Utility functions
 * 
 * @class [utils] config
 * @constructor
 */


/// required to define ETH_BIGNUMBER_ROUNDING_MODE
var BigNumber = require('bignumber.js');

var ETH_UNITS = [
    'wei',
    'kwei',
    'Mwei',
    'Gwei',
    'szabo',
    'finney',
    'femtoether',
    'picoether',
    'nanoether',
    'microether',
    'milliether',
    'nano',
    'micro',
    'milli',
    'ether',
    'grand',
    'Mether',
    'Gether',
    'Tether',
    'Pether',
    'Eether',
    'Zether',
    'Yether',
    'Nether',
    'Dether',
    'Vether',
    'Uether'
];

module.exports = {
    ETH_PADDING: 32,
    ETH_SIGNATURE_LENGTH: 4,
    ETH_UNITS: ETH_UNITS,
    ETH_BIGNUMBER_ROUNDING_MODE: { ROUNDING_MODE: BigNumber.ROUND_DOWN },
    ETH_POLLING_TIMEOUT: 1000/2,
    defaultBlock: 'latest',
    defaultAccount: undefined
};


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js", {"crypto-js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\crypto-js\\index.js","crypto-js/sha3":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\crypto-js\\sha3.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\sha3.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file sha3.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var CryptoJS = require('crypto-js');
var sha3 = require('crypto-js/sha3');

module.exports = function (value, options) {
    if (options && options.encoding === 'hex') {
        if (value.length > 2 && value.substr(0, 2) === '0x') {
            value = value.substr(2);
        }
        value = CryptoJS.enc.Hex.parse(value);
    }

    return sha3(value, {
        outputLength: 256
    }).toString();
};


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", {"./sha3.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js","utf8":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\utf8\\utf8.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\utils.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file utils.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

/**
 * Utils
 *
 * @module utils
 */

/**
 * Utility functions
 *
 * @class [utils] utils
 * @constructor
 */


var BigNumber = require('bignumber.js');
var sha3 = require('./sha3.js');
var utf8 = require('utf8');

var unitMap = {
    'noether':      '0',
    'wei':          '1',
    'kwei':         '1000',
    'Kwei':         '1000',
    'babbage':      '1000',
    'femtoether':   '1000',
    'mwei':         '1000000',
    'Mwei':         '1000000',
    'lovelace':     '1000000',
    'picoether':    '1000000',
    'gwei':         '1000000000',
    'Gwei':         '1000000000',
    'shannon':      '1000000000',
    'nanoether':    '1000000000',
    'nano':         '1000000000',
    'szabo':        '1000000000000',
    'microether':   '1000000000000',
    'micro':        '1000000000000',
    'finney':       '1000000000000000',
    'milliether':   '1000000000000000',
    'milli':        '1000000000000000',
    'ether':        '1000000000000000000',
    'kether':       '1000000000000000000000',
    'grand':        '1000000000000000000000',
    'mether':       '1000000000000000000000000',
    'gether':       '1000000000000000000000000000',
    'tether':       '1000000000000000000000000000000'
};

/**
 * Should be called to pad string to expected length
 *
 * @method padLeft
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padLeft = function (string, chars, sign) {
    return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
};

/**
 * Should be called to pad string to expected length
 *
 * @method padRight
 * @param {String} string to be padded
 * @param {Number} characters that result string should have
 * @param {String} sign, by default 0
 * @returns {String} right aligned string
 */
var padRight = function (string, chars, sign) {
    return string + (new Array(chars - string.length + 1).join(sign ? sign : "0"));
};

/**
 * Should be called to get utf8 from it's hex representation
 *
 * @method toUtf8
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toUtf8 = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        if (code === 0)
            break;
        str += String.fromCharCode(code);
    }

    return utf8.decode(str);
};

/**
 * Should be called to get ascii from it's hex representation
 *
 * @method toAscii
 * @param {String} string in hex
 * @returns {String} ascii string representation of hex value
 */
var toAscii = function(hex) {
// Find termination
    var str = "";
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i+=2) {
        var code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
    }

    return str;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of utf8 string
 *
 * @method fromUtf8
 * @param {String} string
 * @param {Boolean} allowZero to convert code point zero to 00 instead of end of string
 * @returns {String} hex representation of input string
 */
var fromUtf8 = function(str, allowZero) {
    str = utf8.encode(str);
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        if (code === 0) {
            if (allowZero) {
                hex += '00';
            } else {
                break;
            }
        } else {
            var n = code.toString(16);
            hex += n.length < 2 ? '0' + n : n;
        }
    }

    return "0x" + hex;
};

/**
 * Should be called to get hex representation (prefixed by 0x) of ascii string
 *
 * @method fromAscii
 * @param {String} string
 * @param {Number} optional padding
 * @returns {String} hex representation of input string
 */
var fromAscii = function(str, num) {
    var hex = "";
    for(var i = 0; i < str.length; i++) {
        var code = str.charCodeAt(i);
        var n = code.toString(16);
        hex += n.length < 2 ? '0' + n : n;
    }

    return "0x" + hex.padEnd(num,'0');
};

/**
 * Should be used to create full function/event name from json abi
 *
 * @method transformToFullName
 * @param {Object} json-abi
 * @return {String} full fnction/event name
 */
var transformToFullName = function (json) {
    if (json.name.indexOf('(') !== -1) {
        return json.name;
    }

    var typeName = json.inputs.map(function(i){return i.type; }).join();
    return json.name + '(' + typeName + ')';
};

/**
 * Should be called to get display name of contract function
 *
 * @method extractDisplayName
 * @param {String} name of function/event
 * @returns {String} display name for function/event eg. multiply(uint256) -> multiply
 */
var extractDisplayName = function (name) {
    var stBracket = name.indexOf('(');
    var endBracket = name.indexOf(')');
    return (stBracket !== -1 && endBracket !== -1) ? name.substr(0, stBracket) : name;
};

/**
 * Should be called to get type name of contract function
 *
 * @method extractTypeName
 * @param {String} name of function/event
 * @returns {String} type name for function/event eg. multiply(uint256) -> uint256
 */
var extractTypeName = function (name) {
    var stBracket = name.indexOf('(');
    var endBracket = name.indexOf(')');
    return (stBracket !== -1 && endBracket !== -1) ? name.substr(stBracket + 1, endBracket - stBracket - 1).replace(' ', '') : "";
};

/**
 * Converts value to it's decimal representation in string
 *
 * @method toDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var toDecimal = function (value) {
    return toBigNumber(value).toNumber();
};

/**
 * Converts value to it's hex representation
 *
 * @method fromDecimal
 * @param {String|Number|BigNumber}
 * @return {String}
 */
var fromDecimal = function (value) {
    var number = toBigNumber(value);
    var result = number.toString(16);

    return number.lessThan(0) ? '-0x' + result.substr(1) : '0x' + result;
};

/**
 * Auto converts any given value into it's hex representation.
 *
 * And even stringifys objects before.
 *
 * @method toHex
 * @param {String|Number|BigNumber|Object}
 * @return {String}
 */
var toHex = function (val) {
    /*jshint maxcomplexity: 8 */

    if (isBoolean(val))
        return fromDecimal(+val);

    if (isBigNumber(val))
        return fromDecimal(val);

    if (typeof val === 'object')
        return fromUtf8(JSON.stringify(val));

    // if its a negative number, pass it through fromDecimal
    if (isString(val)) {
        if (val.indexOf('-0x') === 0)
            return fromDecimal(val);
        else if(val.indexOf('0x') === 0)
            return val;
        else if (!isFinite(val))
            return fromUtf8(val,1);
    }

    return fromDecimal(val);
};

/**
 * Returns value of unit in Wei
 *
 * @method getValueOfUnit
 * @param {String} unit the unit to convert to, default ether
 * @returns {BigNumber} value of the unit (in Wei)
 * @throws error if the unit is not correct:w
 */
var getValueOfUnit = function (unit) {
    unit = unit ? unit.toLowerCase() : 'ether';
    var unitValue = unitMap[unit];
    if (unitValue === undefined) {
        throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
    }
    return new BigNumber(unitValue, 10);
};

/**
 * Takes a number of wei and converts it to any other ether unit.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method fromWei
 * @param {Number|String} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert to, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var fromWei = function(number, unit) {
    var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes a number of a unit and converts it to wei.
 *
 * Possible units are:
 *   SI Short   SI Full        Effigy       Other
 * - kwei       femtoether     babbage
 * - mwei       picoether      lovelace
 * - gwei       nanoether      shannon      nano
 * - --         microether     szabo        micro
 * - --         milliether     finney       milli
 * - ether      --             --
 * - kether                    --           grand
 * - mether
 * - gether
 * - tether
 *
 * @method toWei
 * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
 * @param {String} unit the unit to convert from, default ether
 * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
*/
var toWei = function(number, unit) {
    var returnValue = toBigNumber(number).times(getValueOfUnit(unit));

    return isBigNumber(number) ? returnValue : returnValue.toString(10);
};

/**
 * Takes an input and transforms it into an bignumber
 *
 * @method toBigNumber
 * @param {Number|String|BigNumber} a number, string, HEX string or BigNumber
 * @return {BigNumber} BigNumber
*/
var toBigNumber = function(number) {
    /*jshint maxcomplexity:5 */
    number = number || 0;
    if (isBigNumber(number))
        return number;

    if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {
        return new BigNumber(number.replace('0x',''), 16);
    }

    return new BigNumber(number.toString(10), 10);
};

/**
 * Takes and input transforms it into bignumber and if it is negative value, into two's complement
 *
 * @method toTwosComplement
 * @param {Number|String|BigNumber}
 * @return {BigNumber}
 */
var toTwosComplement = function (number) {
    var bigNumber = toBigNumber(number).round();
    if (bigNumber.lessThan(0)) {
        return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
    }
    return bigNumber;
};

/**
 * Checks if the given string is strictly an address
 *
 * @method isStrictAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isStrictAddress = function (address) {
    return /^0x[0-9a-f]{40}$/i.test(address);
};

/**
 * Checks if the given string is an address
 *
 * @method isAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isAddress = function (address) {
    if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
        // check if it has the basic requirements of an address
        return false;
    } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
        // If it's all small caps or all all caps, return true
        return true;
    } else {
        // Otherwise check each case
        return isChecksumAddress(address);
    }
};

/**
 * Checks if the given string is a checksummed address
 *
 * @method isChecksumAddress
 * @param {String} address the given HEX adress
 * @return {Boolean}
*/
var isChecksumAddress = function (address) {
    // Check each case
    address = address.replace('0x','');
    var addressHash = sha3(address.toLowerCase());

    for (var i = 0; i < 40; i++ ) {
        // the nth letter should be uppercase if the nth digit of casemap is 1
        if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
            return false;
        }
    }
    return true;
};



/**
 * Makes a checksum address
 *
 * @method toChecksumAddress
 * @param {String} address the given HEX adress
 * @return {String}
*/
var toChecksumAddress = function (address) {
    if (typeof address === 'undefined') return '';

    address = address.toLowerCase().replace('0x','');
    var addressHash = sha3(address);
    var checksumAddress = '0x';

    for (var i = 0; i < address.length; i++ ) {
        // If ith character is 9 to f then make it uppercase
        if (parseInt(addressHash[i], 16) > 7) {
          checksumAddress += address[i].toUpperCase();
        } else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
};

/**
 * Transforms given string to valid 20 bytes-length addres with 0x prefix
 *
 * @method toAddress
 * @param {String} address
 * @return {String} formatted address
 */
var toAddress = function (address) {
    if (isStrictAddress(address)) {
        return address;
    }

    if (/^[0-9a-f]{40}$/.test(address)) {
        return '0x' + address;
    }

    return '0x' + padLeft(toHex(address).substr(2), 40);
};

/**
 * Returns true if object is BigNumber, otherwise false
 *
 * @method isBigNumber
 * @param {Object}
 * @return {Boolean}
 */
var isBigNumber = function (object) {
    return object instanceof BigNumber ||
        (object && object.constructor && object.constructor.name === 'BigNumber');
};

/**
 * Returns true if object is string, otherwise false
 *
 * @method isString
 * @param {Object}
 * @return {Boolean}
 */
var isString = function (object) {
    return typeof object === 'string' ||
        (object && object.constructor && object.constructor.name === 'String');
};

/**
 * Returns true if object is function, otherwise false
 *
 * @method isFunction
 * @param {Object}
 * @return {Boolean}
 */
var isFunction = function (object) {
    return typeof object === 'function';
};

/**
 * Returns true if object is Objet, otherwise false
 *
 * @method isObject
 * @param {Object}
 * @return {Boolean}
 */
var isObject = function (object) {
    return object !== null && !(Array.isArray(object)) && typeof object === 'object';
};

/**
 * Returns true if object is boolean, otherwise false
 *
 * @method isBoolean
 * @param {Object}
 * @return {Boolean}
 */
var isBoolean = function (object) {
    return typeof object === 'boolean';
};

/**
 * Returns true if object is array, otherwise false
 *
 * @method isArray
 * @param {Object}
 * @return {Boolean}
 */
var isArray = function (object) {
    return Array.isArray(object);
};

/**
 * Returns true if given string is valid json object
 *
 * @method isJson
 * @param {String}
 * @return {Boolean}
 */
var isJson = function (str) {
    try {
        return !!JSON.parse(str);
    } catch (e) {
        return false;
    }
};

/**
 * Returns true if given string is a valid Ethereum block header bloom.
 *
 * @method isBloom
 * @param {String} hex encoded bloom filter
 * @return {Boolean}
 */
var isBloom = function (bloom) {
    if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
        return true;
    }
    return false;
};

/**
 * Returns true if given string is a valid log topic.
 *
 * @method isTopic
 * @param {String} hex encoded topic
 * @return {Boolean}
 */
var isTopic = function (topic) {
    if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
        return false;
    } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
        return true;
    }
    return false;
};

module.exports = {
    padLeft: padLeft,
    padRight: padRight,
    toHex: toHex,
    toDecimal: toDecimal,
    fromDecimal: fromDecimal,
    toUtf8: toUtf8,
    toAscii: toAscii,
    fromUtf8: fromUtf8,
    fromAscii: fromAscii,
    transformToFullName: transformToFullName,
    extractDisplayName: extractDisplayName,
    extractTypeName: extractTypeName,
    toWei: toWei,
    fromWei: fromWei,
    toBigNumber: toBigNumber,
    toTwosComplement: toTwosComplement,
    toAddress: toAddress,
    isBigNumber: isBigNumber,
    isStrictAddress: isStrictAddress,
    isAddress: isAddress,
    isChecksumAddress: isChecksumAddress,
    toChecksumAddress: toChecksumAddress,
    isFunction: isFunction,
    isString: isString,
    isObject: isObject,
    isBoolean: isBoolean,
    isArray: isArray,
    isJson: isJson,
    isBloom: isBloom,
    isTopic: isTopic,
};

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\version.json", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\version.json
      return function (require, module, exports) {
module.exports={
    "version": "0.20.7"
}

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3.js", {"./utils/sha3":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js","./utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./version.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\version.json","./web3/batch":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\batch.js","./web3/extend":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\extend.js","./web3/httpprovider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\httpprovider.js","./web3/iban":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js","./web3/ipcprovider":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\ipcprovider.js","./web3/methods/db":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\db.js","./web3/methods/eth":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\eth.js","./web3/methods/net":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\net.js","./web3/methods/personal":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\personal.js","./web3/methods/shh":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\shh.js","./web3/methods/swarm":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\swarm.js","./web3/property":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js","./web3/requestmanager":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\requestmanager.js","./web3/settings":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\settings.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3.js
      return function (require, module, exports) {
/*!
 * web3.js - Ethereum JavaScript API
 *
 * @license lgpl-3.0
 * @see https://github.com/ethereum/web3.js
*/

/*
 * This file is part of web3.js.
 * 
 * web3.js is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * web3.js is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @file web3.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var RequestManager = require('./web3/requestmanager');
var Iban = require('./web3/iban');
var Eth = require('./web3/methods/eth');
var DB = require('./web3/methods/db');
var Shh = require('./web3/methods/shh');
var Net = require('./web3/methods/net');
var Personal = require('./web3/methods/personal');
var Swarm = require('./web3/methods/swarm');
var Settings = require('./web3/settings');
var version = require('./version.json');
var utils = require('./utils/utils');
var sha3 = require('./utils/sha3');
var extend = require('./web3/extend');
var Batch = require('./web3/batch');
var Property = require('./web3/property');
var HttpProvider = require('./web3/httpprovider');
var IpcProvider = require('./web3/ipcprovider');
var BigNumber = require('bignumber.js');



function Web3 (provider) {
    this._requestManager = new RequestManager(provider);
    this.currentProvider = provider;
    this.eth = new Eth(this);
    this.db = new DB(this);
    this.shh = new Shh(this);
    this.net = new Net(this);
    this.personal = new Personal(this);
    this.bzz = new Swarm(this);
    this.settings = new Settings();
    this.version = {
        api: version.version
    };
    this.providers = {
        HttpProvider: HttpProvider,
        IpcProvider: IpcProvider
    };
    this._extend = extend(this);
    this._extend({
        properties: properties()
    });
}

// expose providers on the class
Web3.providers = {
    HttpProvider: HttpProvider,
    IpcProvider: IpcProvider
};

Web3.prototype.setProvider = function (provider) {
    this._requestManager.setProvider(provider);
    this.currentProvider = provider;
};

Web3.prototype.reset = function (keepIsSyncing) {
    this._requestManager.reset(keepIsSyncing);
    this.settings = new Settings();
};

Web3.prototype.BigNumber = BigNumber;
Web3.prototype.toHex = utils.toHex;
Web3.prototype.toAscii = utils.toAscii;
Web3.prototype.toUtf8 = utils.toUtf8;
Web3.prototype.fromAscii = utils.fromAscii;
Web3.prototype.fromUtf8 = utils.fromUtf8;
Web3.prototype.toDecimal = utils.toDecimal;
Web3.prototype.fromDecimal = utils.fromDecimal;
Web3.prototype.toBigNumber = utils.toBigNumber;
Web3.prototype.toWei = utils.toWei;
Web3.prototype.fromWei = utils.fromWei;
Web3.prototype.isAddress = utils.isAddress;
Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
Web3.prototype.isIBAN = utils.isIBAN;
Web3.prototype.padLeft = utils.padLeft;
Web3.prototype.padRight = utils.padRight;


Web3.prototype.sha3 = function(string, options) {
    return '0x' + sha3(string, options);
};

/**
 * Transforms direct icap to address
 */
Web3.prototype.fromICAP = function (icap) {
    var iban = new Iban(icap);
    return iban.address();
};

var properties = function () {
    return [
        new Property({
            name: 'version.node',
            getter: 'web3_clientVersion'
        }),
        new Property({
            name: 'version.network',
            getter: 'net_version',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.ethereum',
            getter: 'eth_protocolVersion',
            inputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'version.whisper',
            getter: 'shh_version',
            inputFormatter: utils.toDecimal
        })
    ];
};

Web3.prototype.isConnected = function(){
    return (this.currentProvider && this.currentProvider.isConnected());
};

Web3.prototype.createBatch = function () {
    return new Batch(this);
};

module.exports = Web3;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\allevents.js", {"../utils/sha3":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js","../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./event":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\event.js","./filter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js","./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js","./methods/watches":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\allevents.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file allevents.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var sha3 = require('../utils/sha3');
var SolidityEvent = require('./event');
var formatters = require('./formatters');
var utils = require('../utils/utils');
var Filter = require('./filter');
var watches = require('./methods/watches');

var AllSolidityEvents = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._json = json;
    this._address = address;
};

AllSolidityEvents.prototype.encode = function (options) {
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.address = this._address;

    return result;
};

AllSolidityEvents.prototype.decode = function (data) {
    data.data = data.data || '';


    var eventTopic = (utils.isArray(data.topics) && utils.isString(data.topics[0])) ? data.topics[0].slice(2) : '';
    var match = this._json.filter(function (j) {
        return eventTopic === sha3(utils.transformToFullName(j));
    })[0];

    if (!match) { // cannot find matching event?
        return formatters.outputLogFormatter(data);
    }

    var event = new SolidityEvent(this._requestManager, match, this._address);
    return event.decode(data);
};

AllSolidityEvents.prototype.execute = function (options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 1)
            options = null;
    }

    var o = this.encode(options);
    var formatter = this.decode.bind(this);
    return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
};

AllSolidityEvents.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    contract.allEvents = execute;
};

module.exports = AllSolidityEvents;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\batch.js", {"./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js","./jsonrpc":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\jsonrpc.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\batch.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file batch.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Jsonrpc = require('./jsonrpc');
var errors = require('./errors');

var Batch = function (web3) {
    this.requestManager = web3._requestManager;
    this.requests = [];
};

/**
 * Should be called to add create new request to batch request
 *
 * @method add
 * @param {Object} jsonrpc requet object
 */
Batch.prototype.add = function (request) {
    this.requests.push(request);
};

/**
 * Should be called to execute batch request
 *
 * @method execute
 */
Batch.prototype.execute = function () {
    var requests = this.requests;
    this.requestManager.sendBatch(requests, function (err, results) {
        results = results || [];
        requests.map(function (request, index) {
            return results[index] || {};
        }).forEach(function (result, index) {
            if (requests[index].callback) {

                if (!Jsonrpc.isValidResponse(result)) {
                    return requests[index].callback(errors.InvalidResponse(result));
                }

                requests[index].callback(null, (requests[index].format ? requests[index].format(result.result) : result.result));
            }
        });
    }); 
};

module.exports = Batch;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\contract.js", {"../solidity/coder":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js","../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./allevents":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\allevents.js","./event":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\event.js","./function":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\function.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\contract.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file contract.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = require('../utils/utils');
var coder = require('../solidity/coder');
var SolidityEvent = require('./event');
var SolidityFunction = require('./function');
var AllEvents = require('./allevents');

/**
 * Should be called to encode constructor params
 *
 * @method encodeConstructorParams
 * @param {Array} abi
 * @param {Array} constructor params
 */
var encodeConstructorParams = function (abi, params) {
    return abi.filter(function (json) {
        return json.type === 'constructor' && json.inputs.length === params.length;
    }).map(function (json) {
        return json.inputs.map(function (input) {
            return input.type;
        });
    }).map(function (types) {
        return coder.encodeParams(types, params);
    })[0] || '';
};

/**
 * Should be called to add functions to contract object
 *
 * @method addFunctionsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addFunctionsToContract = function (contract) {
    contract.abi.filter(function (json) {
        return json.type === 'function';
    }).map(function (json) {
        return new SolidityFunction(contract._eth, json, contract.address);
    }).forEach(function (f) {
        f.attachToContract(contract);
    });
};

/**
 * Should be called to add events to contract object
 *
 * @method addEventsToContract
 * @param {Contract} contract
 * @param {Array} abi
 */
var addEventsToContract = function (contract) {
    var events = contract.abi.filter(function (json) {
        return json.type === 'event';
    });

    var All = new AllEvents(contract._eth._requestManager, events, contract.address);
    All.attachToContract(contract);

    events.map(function (json) {
        return new SolidityEvent(contract._eth._requestManager, json, contract.address);
    }).forEach(function (e) {
        e.attachToContract(contract);
    });
};


/**
 * Should be called to check if the contract gets properly deployed on the blockchain.
 *
 * @method checkForContractAddress
 * @param {Object} contract
 * @param {Function} callback
 * @returns {Undefined}
 */
var checkForContractAddress = function(contract, callback){
    var count = 0,
        callbackFired = false;

    // wait for receipt
    var filter = contract._eth.filter('latest', function(e){
        if (!e && !callbackFired) {
            count++;

            // stop watching after 50 blocks (timeout)
            if (count > 50) {

                filter.stopWatching(function() {});
                callbackFired = true;

                if (callback)
                    callback(new Error('Contract transaction couldn\'t be found after 50 blocks'));
                else
                    throw new Error('Contract transaction couldn\'t be found after 50 blocks');


            } else {

                contract._eth.getTransactionReceipt(contract.transactionHash, function(e, receipt){
                    if(receipt && receipt.blockHash && !callbackFired) {

                        contract._eth.getCode(receipt.contractAddress, function(e, code){
                            /*jshint maxcomplexity: 6 */

                            if(callbackFired || !code)
                                return;

                            filter.stopWatching(function() {});
                            callbackFired = true;

                            if(code.length > 3) {

                                // console.log('Contract code deployed!');

                                contract.address = receipt.contractAddress;

                                // attach events and methods again after we have
                                addFunctionsToContract(contract);
                                addEventsToContract(contract);

                                // call callback for the second time
                                if(callback)
                                    callback(null, contract);

                            } else {
                                if(callback)
                                    callback(new Error('The contract code couldn\'t be stored, please check your gas amount.'));
                                else
                                    throw new Error('The contract code couldn\'t be stored, please check your gas amount.');
                            }
                        });
                    }
                });
            }
        }
    });
};

/**
 * Should be called to create new ContractFactory instance
 *
 * @method ContractFactory
 * @param {Array} abi
 */
var ContractFactory = function (eth, abi) {
    this.eth = eth;
    this.abi = abi;

    /**
     * Should be called to create new contract on a blockchain
     *
     * @method new
     * @param {Any} contract constructor param1 (optional)
     * @param {Any} contract constructor param2 (optional)
     * @param {Object} contract transaction object (required)
     * @param {Function} callback
     * @returns {Contract} returns contract instance
     */
    this.new = function () {
        /*jshint maxcomplexity: 7 */

        var contract = new Contract(this.eth, this.abi);

        // parse arguments
        var options = {}; // required!
        var callback;

        var args = Array.prototype.slice.call(arguments);
        if (utils.isFunction(args[args.length - 1])) {
            callback = args.pop();
        }

        var last = args[args.length - 1];
        if (utils.isObject(last) && !utils.isArray(last)) {
            options = args.pop();
        }

        if (options.value > 0) {
            var constructorAbi = abi.filter(function (json) {
                return json.type === 'constructor' && json.inputs.length === args.length;
            })[0] || {};

            if (!constructorAbi.payable) {
                throw new Error('Cannot send value to non-payable constructor');
            }
        }

        var bytes = encodeConstructorParams(this.abi, args);
        options.data += bytes;

        if (callback) {

            // wait for the contract address and check if the code was deployed
            this.eth.sendTransaction(options, function (err, hash) {
                if (err) {
                    callback(err);
                } else {
                    // add the transaction hash
                    contract.transactionHash = hash;

                    // call callback for the first time
                    callback(null, contract);

                    checkForContractAddress(contract, callback);
                }
            });
        } else {
            var hash = this.eth.sendTransaction(options);
            // add the transaction hash
            contract.transactionHash = hash;
            checkForContractAddress(contract);
        }

        return contract;
    };

    this.new.getData = this.getData.bind(this);
};

/**
 * Should be called to create new ContractFactory
 *
 * @method contract
 * @param {Array} abi
 * @returns {ContractFactory} new contract factory
 */
//var contract = function (abi) {
    //return new ContractFactory(abi);
//};



/**
 * Should be called to get access to existing contract on a blockchain
 *
 * @method at
 * @param {Address} contract address (required)
 * @param {Function} callback {optional)
 * @returns {Contract} returns contract if no callback was passed,
 * otherwise calls callback function (err, contract)
 */
ContractFactory.prototype.at = function (address, callback) {
    var contract = new Contract(this.eth, this.abi, address);

    // this functions are not part of prototype,
    // because we dont want to spoil the interface
    addFunctionsToContract(contract);
    addEventsToContract(contract);

    if (callback) {
        callback(null, contract);
    }
    return contract;
};

/**
 * Gets the data, which is data to deploy plus constructor params
 *
 * @method getData
 */
ContractFactory.prototype.getData = function () {
    var options = {}; // required!
    var args = Array.prototype.slice.call(arguments);

    var last = args[args.length - 1];
    if (utils.isObject(last) && !utils.isArray(last)) {
        options = args.pop();
    }

    var bytes = encodeConstructorParams(this.abi, args);
    options.data += bytes;

    return options.data;
};

/**
 * Should be called to create new contract instance
 *
 * @method Contract
 * @param {Array} abi
 * @param {Address} contract address
 */
var Contract = function (eth, abi, address) {
    this._eth = eth;
    this.transactionHash = null;
    this.address = address;
    this.abi = abi;
};

module.exports = ContractFactory;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\errors.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file errors.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

module.exports = {
    InvalidNumberOfSolidityArgs: function () {
        return new Error('Invalid number of arguments to Solidity function');
    },
    InvalidNumberOfRPCParams: function () {
        return new Error('Invalid number of input parameters to RPC method');
    },
    InvalidConnection: function (host){
        return new Error('CONNECTION ERROR: Couldn\'t connect to node '+ host +'.');
    },
    InvalidProvider: function () {
        return new Error('Provider not set or invalid');
    },
    InvalidResponse: function (result){
        var message = !!result && !!result.error && !!result.error.message ? result.error.message : 'Invalid JSON RPC response: ' + JSON.stringify(result);
        return new Error(message);
    },
    ConnectionTimeout: function (ms){
        return new Error('CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');
    }
};

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\event.js", {"../solidity/coder":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js","../utils/sha3":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js","../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./filter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js","./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js","./methods/watches":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\event.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file event.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2014
 */

var utils = require('../utils/utils');
var coder = require('../solidity/coder');
var formatters = require('./formatters');
var sha3 = require('../utils/sha3');
var Filter = require('./filter');
var watches = require('./methods/watches');

/**
 * This prototype should be used to create event filters
 */
var SolidityEvent = function (requestManager, json, address) {
    this._requestManager = requestManager;
    this._params = json.inputs;
    this._name = utils.transformToFullName(json);
    this._address = address;
    this._anonymous = json.anonymous;
};

/**
 * Should be used to get filtered param types
 *
 * @method types
 * @param {Bool} decide if returned typed should be indexed
 * @return {Array} array of types
 */
SolidityEvent.prototype.types = function (indexed) {
    return this._params.filter(function (i) {
        return i.indexed === indexed;
    }).map(function (i) {
        return i.type;
    });
};

/**
 * Should be used to get event display name
 *
 * @method displayName
 * @return {String} event display name
 */
SolidityEvent.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get event type name
 *
 * @method typeName
 * @return {String} event type name
 */
SolidityEvent.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be used to get event signature
 *
 * @method signature
 * @return {String} event signature
 */
SolidityEvent.prototype.signature = function () {
    return sha3(this._name);
};

/**
 * Should be used to encode indexed params and options to one final object
 *
 * @method encode
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} everything combined together and encoded
 */
SolidityEvent.prototype.encode = function (indexed, options) {
    indexed = indexed || {};
    options = options || {};
    var result = {};

    ['fromBlock', 'toBlock'].filter(function (f) {
        return options[f] !== undefined;
    }).forEach(function (f) {
        result[f] = formatters.inputBlockNumberFormatter(options[f]);
    });

    result.topics = [];

    result.address = this._address;
    if (!this._anonymous) {
        result.topics.push('0x' + this.signature());
    }

    var indexedTopics = this._params.filter(function (i) {
        return i.indexed === true;
    }).map(function (i) {
        var value = indexed[i.name];
        if (value === undefined || value === null) {
            return null;
        }

        if (utils.isArray(value)) {
            return value.map(function (v) {
                return '0x' + coder.encodeParam(i.type, v);
            });
        }
        return '0x' + coder.encodeParam(i.type, value);
    });

    result.topics = result.topics.concat(indexedTopics);

    return result;
};

/**
 * Should be used to decode indexed params and options
 *
 * @method decode
 * @param {Object} data
 * @return {Object} result object with decoded indexed && not indexed params
 */
SolidityEvent.prototype.decode = function (data) {

    data.data = data.data || '';
    data.topics = data.topics || [];


    var argTopics = this._anonymous ? data.topics : data.topics.slice(1);
    var indexedData = argTopics.map(function (topics) { return topics.slice(2); }).join("");
    var indexedParams = coder.decodeParams(this.types(true), indexedData);

    var notIndexedData = data.data.slice(2);
    var notIndexedParams = coder.decodeParams(this.types(false), notIndexedData);

    var result = formatters.outputLogFormatter(data);
    result.event = this.displayName();
    result.address = data.address;

    result.args = this._params.reduce(function (acc, current) {
        acc[current.name] = current.indexed ? indexedParams.shift() : notIndexedParams.shift();
        return acc;
    }, {});

    delete result.data;
    delete result.topics;

    return result;
};

/**
 * Should be used to create new filter object from event
 *
 * @method execute
 * @param {Object} indexed
 * @param {Object} options
 * @return {Object} filter object
 */
SolidityEvent.prototype.execute = function (indexed, options, callback) {

    if (utils.isFunction(arguments[arguments.length - 1])) {
        callback = arguments[arguments.length - 1];
        if(arguments.length === 2)
            options = null;
        if(arguments.length === 1) {
            options = null;
            indexed = {};
        }
    }

    var o = this.encode(indexed, options);
    var formatter = this.decode.bind(this);
    return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
};

/**
 * Should be used to attach event to contract object
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityEvent.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = this.execute.bind(this, contract);
};

module.exports = SolidityEvent;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\extend.js", {"./../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js","./method":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js","./property":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\extend.js
      return function (require, module, exports) {
var formatters = require('./formatters');
var utils = require('./../utils/utils');
var Method = require('./method');
var Property = require('./property');

// TODO: refactor, so the input params are not altered.
// it's necessary to make same 'extension' work with multiple providers
var extend = function (web3) {
    /* jshint maxcomplexity:5 */
    var ex = function (extension) {

        var extendedObject;
        if (extension.property) {
            if (!web3[extension.property]) {
                web3[extension.property] = {};
            }
            extendedObject = web3[extension.property];
        } else {
            extendedObject = web3;
        }

        if (extension.methods) {
            extension.methods.forEach(function (method) {
                method.attachToObject(extendedObject);
                method.setRequestManager(web3._requestManager);
            });
        }

        if (extension.properties) {
            extension.properties.forEach(function (property) {
                property.attachToObject(extendedObject);
                property.setRequestManager(web3._requestManager);
            });
        }
    };

    ex.formatters = formatters; 
    ex.utils = utils;
    ex.Method = Method;
    ex.Property = Property;

    return ex;
};



module.exports = extend;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js", {"../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\filter.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file filter.js
 * @authors:
 *   Jeffrey Wilcke <jeff@ethdev.com>
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 *   Gav Wood <g@ethdev.com>
 * @date 2014
 */

var formatters = require('./formatters');
var utils = require('../utils/utils');

/**
* Converts a given topic to a hex string, but also allows null values.
*
* @param {Mixed} value
* @return {String}
*/
var toTopic = function(value){

    if(value === null || typeof value === 'undefined')
        return null;

    value = String(value);

    if(value.indexOf('0x') === 0)
        return value;
    else
        return utils.fromUtf8(value);
};

/// This method should be called on options object, to verify deprecated properties && lazy load dynamic ones
/// @param should be string or object
/// @returns options string or object
var getOptions = function (options, type) {
    /*jshint maxcomplexity: 6 */

    if (utils.isString(options)) {
        return options;
    }

    options = options || {};


    switch(type) {
        case 'eth':

            // make sure topics, get converted to hex
            options.topics = options.topics || [];
            options.topics = options.topics.map(function(topic){
                return (utils.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);
            });

            return {
                topics: options.topics,
                from: options.from,
                to: options.to,
                address: options.address,
                fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),
                toBlock: formatters.inputBlockNumberFormatter(options.toBlock)
            };
        case 'shh':
            return options;
    }
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method getLogsAtStart
@param {Object} self
@param {function} callback
*/
var getLogsAtStart = function(self, callback){
    // call getFilterLogs for the first watch callback start
    if (!utils.isString(self.options)) {
        self.get(function (err, messages) {
            // don't send all the responses to all the watches again... just to self one
            if (err) {
                callback(err);
            }

            if(utils.isArray(messages)) {
                messages.forEach(function (message) {
                    callback(null, message);
                });
            }
        });
    }
};

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollFilter
@param {Object} self
*/
var pollFilter = function(self) {

    var onMessage = function (error, messages) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isArray(messages)) {
            messages.forEach(function (message) {
                message = self.formatter ? self.formatter(message) : message;
                self.callbacks.forEach(function (callback) {
                    callback(null, message);
                });
            });
        }
    };

    self.requestManager.startPolling({
        method: self.implementation.poll.call,
        params: [self.filterId],
    }, self.filterId, onMessage, self.stopWatching.bind(self));

};

var Filter = function (options, type, requestManager, methods, formatter, callback, filterCreationErrorCallback) {
    var self = this;
    var implementation = {};
    methods.forEach(function (method) {
        method.setRequestManager(requestManager);
        method.attachToObject(implementation);
    });
    this.requestManager = requestManager;
    this.options = getOptions(options, type);
    this.implementation = implementation;
    this.filterId = null;
    this.callbacks = [];
    this.getLogsCallbacks = [];
    this.pollFilters = [];
    this.formatter = formatter;
    this.implementation.newFilter(this.options, function(error, id){
        if(error) {
            self.callbacks.forEach(function(cb){
                cb(error);
            });
            if (typeof filterCreationErrorCallback === 'function') {
              filterCreationErrorCallback(error);
            }
        } else {
            self.filterId = id;

            // check if there are get pending callbacks as a consequence
            // of calling get() with filterId unassigned.
            self.getLogsCallbacks.forEach(function (cb){
                self.get(cb);
            });
            self.getLogsCallbacks = [];

            // get filter logs for the already existing watch calls
            self.callbacks.forEach(function(cb){
                getLogsAtStart(self, cb);
            });
            if(self.callbacks.length > 0)
                pollFilter(self);

            // start to watch immediately
            if(typeof callback === 'function') {
                return self.watch(callback);
            }
        }
    });

    return this;
};

Filter.prototype.watch = function (callback) {
    this.callbacks.push(callback);

    if(this.filterId) {
        getLogsAtStart(this, callback);
        pollFilter(this);
    }

    return this;
};

Filter.prototype.stopWatching = function (callback) {
    this.requestManager.stopPolling(this.filterId);
    this.callbacks = [];
    // remove filter async
    if (callback) {
        this.implementation.uninstallFilter(this.filterId, callback);
    } else {
        return this.implementation.uninstallFilter(this.filterId);
    }
};

Filter.prototype.get = function (callback) {
    var self = this;
    if (utils.isFunction(callback)) {
        if (this.filterId === null) {
            // If filterId is not set yet, call it back
            // when newFilter() assigns it.
            this.getLogsCallbacks.push(callback);
        } else {
            this.implementation.getLogs(this.filterId, function(err, res){
                if (err) {
                    callback(err);
                } else {
                    callback(null, res.map(function (log) {
                        return self.formatter ? self.formatter(log) : log;
                    }));
                }
            });
        }
    } else {
        if (this.filterId === null) {
            throw new Error('Filter ID Error: filter().get() can\'t be chained synchronous, please provide a callback for the get() method.');
        }
        var logs = this.implementation.getLogs(this.filterId);
        return logs.map(function (log) {
            return self.formatter ? self.formatter(log) : log;
        });
    }

    return this;
};

module.exports = Filter;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js", {"../utils/config":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js","../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./iban":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\formatters.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file formatters.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

'use strict';


var utils = require('../utils/utils');
var config = require('../utils/config');
var Iban = require('./iban');

/**
 * Should the format output to a big number
 *
 * @method outputBigNumberFormatter
 * @param {String|Number|BigNumber}
 * @returns {BigNumber} object
 */
var outputBigNumberFormatter = function (number) {
    return utils.toBigNumber(number);
};

var isPredefinedBlockNumber = function (blockNumber) {
    return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';
};

var inputDefaultBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return config.defaultBlock;
    }
    return inputBlockNumberFormatter(blockNumber);
};

var inputBlockNumberFormatter = function (blockNumber) {
    if (blockNumber === undefined) {
        return undefined;
    } else if (isPredefinedBlockNumber(blockNumber)) {
        return blockNumber;
    }
    return utils.toHex(blockNumber);
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputCallFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputCallFormatter = function (options){

    options.from = options.from || config.defaultAccount;

    if (options.from) {
        options.from = inputAddressFormatter(options.from);
    }

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the input of a transaction and converts all values to HEX
 *
 * @method inputTransactionFormatter
 * @param {Object} transaction options
 * @returns object
*/
var inputTransactionFormatter = function (options){

    options.from = options.from || config.defaultAccount;
    options.from = inputAddressFormatter(options.from);

    if (options.to) { // it might be contract creation
        options.to = inputAddressFormatter(options.to);
    }

    ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
        return options[key] !== undefined;
    }).forEach(function(key){
        options[key] = utils.fromDecimal(options[key]);
    });

    return options;
};

/**
 * Formats the output of a transaction to its proper values
 *
 * @method outputTransactionFormatter
 * @param {Object} tx
 * @returns {Object}
*/
var outputTransactionFormatter = function (tx){
    if(tx.blockNumber !== null)
        tx.blockNumber = utils.toDecimal(tx.blockNumber);
    if(tx.transactionIndex !== null)
        tx.transactionIndex = utils.toDecimal(tx.transactionIndex);
    tx.nonce = utils.toDecimal(tx.nonce);
    tx.gas = utils.toDecimal(tx.gas);
    tx.gasPrice = utils.toBigNumber(tx.gasPrice);
    tx.value = utils.toBigNumber(tx.value);
    return tx;
};

/**
 * Formats the output of a transaction receipt to its proper values
 *
 * @method outputTransactionReceiptFormatter
 * @param {Object} receipt
 * @returns {Object}
*/
var outputTransactionReceiptFormatter = function (receipt){
    if(receipt.blockNumber !== null)
        receipt.blockNumber = utils.toDecimal(receipt.blockNumber);
    if(receipt.transactionIndex !== null)
        receipt.transactionIndex = utils.toDecimal(receipt.transactionIndex);
    receipt.cumulativeGasUsed = utils.toDecimal(receipt.cumulativeGasUsed);
    receipt.gasUsed = utils.toDecimal(receipt.gasUsed);

    if(utils.isArray(receipt.logs)) {
        receipt.logs = receipt.logs.map(function(log){
            return outputLogFormatter(log);
        });
    }

    return receipt;
};

/**
 * Formats the output of a block to its proper values
 *
 * @method outputBlockFormatter
 * @param {Object} block
 * @returns {Object}
*/
var outputBlockFormatter = function(block) {

    // transform to number
    block.gasLimit = utils.toDecimal(block.gasLimit);
    block.gasUsed = utils.toDecimal(block.gasUsed);
    block.size = utils.toDecimal(block.size);
    block.timestamp = utils.toDecimal(block.timestamp);
    if(block.number !== null)
        block.number = utils.toDecimal(block.number);

    block.difficulty = utils.toBigNumber(block.difficulty);
    block.totalDifficulty = utils.toBigNumber(block.totalDifficulty);

    if (utils.isArray(block.transactions)) {
        block.transactions.forEach(function(item){
            if(!utils.isString(item))
                return outputTransactionFormatter(item);
        });
    }

    return block;
};

/**
 * Formats the output of a log
 *
 * @method outputLogFormatter
 * @param {Object} log object
 * @returns {Object} log
*/
var outputLogFormatter = function(log) {
    if(log.blockNumber)
        log.blockNumber = utils.toDecimal(log.blockNumber);
    if(log.transactionIndex)
        log.transactionIndex = utils.toDecimal(log.transactionIndex);
    if(log.logIndex)
        log.logIndex = utils.toDecimal(log.logIndex);

    return log;
};

/**
 * Formats the input of a whisper post and converts all values to HEX
 *
 * @method inputPostFormatter
 * @param {Object} transaction object
 * @returns {Object}
*/
var inputPostFormatter = function(post) {

    // post.payload = utils.toHex(post.payload);
    post.ttl = utils.fromDecimal(post.ttl);
    post.workToProve = utils.fromDecimal(post.workToProve);
    post.priority = utils.fromDecimal(post.priority);

    // fallback
    if (!utils.isArray(post.topics)) {
        post.topics = post.topics ? [post.topics] : [];
    }

    // format the following options
    post.topics = post.topics.map(function(topic){
        // convert only if not hex
        return (topic.indexOf('0x') === 0) ? topic : utils.fromUtf8(topic);
    });

    return post;
};

/**
 * Formats the output of a received post message
 *
 * @method outputPostFormatter
 * @param {Object}
 * @returns {Object}
 */
var outputPostFormatter = function(post){

    post.expiry = utils.toDecimal(post.expiry);
    post.sent = utils.toDecimal(post.sent);
    post.ttl = utils.toDecimal(post.ttl);
    post.workProved = utils.toDecimal(post.workProved);
    // post.payloadRaw = post.payload;
    // post.payload = utils.toAscii(post.payload);

    // if (utils.isJson(post.payload)) {
    //     post.payload = JSON.parse(post.payload);
    // }

    // format the following options
    if (!post.topics) {
        post.topics = [];
    }
    post.topics = post.topics.map(function(topic){
        return utils.toAscii(topic);
    });

    return post;
};

var inputAddressFormatter = function (address) {
    var iban = new Iban(address);
    if (iban.isValid() && iban.isDirect()) {
        return '0x' + iban.address();
    } else if (utils.isStrictAddress(address)) {
        return address;
    } else if (utils.isAddress(address)) {
        return '0x' + address;
    }
    throw new Error('invalid address');
};


var outputSyncingFormatter = function(result) {
    if (!result) {
        return result;
    }

    result.startingBlock = utils.toDecimal(result.startingBlock);
    result.currentBlock = utils.toDecimal(result.currentBlock);
    result.highestBlock = utils.toDecimal(result.highestBlock);
    if (result.knownStates) {
        result.knownStates = utils.toDecimal(result.knownStates);
        result.pulledStates = utils.toDecimal(result.pulledStates);
    }

    return result;
};

module.exports = {
    inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,
    inputBlockNumberFormatter: inputBlockNumberFormatter,
    inputCallFormatter: inputCallFormatter,
    inputTransactionFormatter: inputTransactionFormatter,
    inputAddressFormatter: inputAddressFormatter,
    inputPostFormatter: inputPostFormatter,
    outputBigNumberFormatter: outputBigNumberFormatter,
    outputTransactionFormatter: outputTransactionFormatter,
    outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,
    outputBlockFormatter: outputBlockFormatter,
    outputLogFormatter: outputLogFormatter,
    outputPostFormatter: outputPostFormatter,
    outputSyncingFormatter: outputSyncingFormatter
};


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\function.js", {"../solidity/coder":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js","../utils/sha3":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js","../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js","./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\function.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file function.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var coder = require('../solidity/coder');
var utils = require('../utils/utils');
var errors = require('./errors');
var formatters = require('./formatters');
var sha3 = require('../utils/sha3');

/**
 * This prototype should be used to call/sendTransaction to solidity functions
 */
var SolidityFunction = function (eth, json, address) {
    this._eth = eth;
    this._inputTypes = json.inputs.map(function (i) {
        return i.type;
    });
    this._outputTypes = json.outputs.map(function (i) {
        return i.type;
    });
    this._constant = (json.stateMutability === "view" || json.stateMutability === "pure" || json.constant);
    this._payable = (json.stateMutability === "payable" || json.payable);
    this._name = utils.transformToFullName(json);
    this._address = address;
};

SolidityFunction.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

SolidityFunction.prototype.extractDefaultBlock = function (args) {
    if (args.length > this._inputTypes.length && !utils.isObject(args[args.length -1])) {
        return formatters.inputDefaultBlockNumberFormatter(args.pop()); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 *
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
SolidityFunction.prototype.validateArgs = function (args) {
    var inputArgs = args.filter(function (a) {
      // filter the options object but not arguments that are arrays
      return !( (utils.isObject(a) === true) &&
                (utils.isArray(a) === false) &&
                (utils.isBigNumber(a) === false)
              );
    });
    if (inputArgs.length !== this._inputTypes.length) {
        throw errors.InvalidNumberOfSolidityArgs();
    }
};

/**
 * Should be used to create payload from arguments
 *
 * @method toPayload
 * @param {Array} solidity function params
 * @param {Object} optional payload options
 */
SolidityFunction.prototype.toPayload = function (args) {
    var options = {};
    if (args.length > this._inputTypes.length && utils.isObject(args[args.length -1])) {
        options = args[args.length - 1];
    }
    this.validateArgs(args);
    options.to = this._address;
    options.data = '0x' + this.signature() + coder.encodeParams(this._inputTypes, args);
    return options;
};

/**
 * Should be used to get function signature
 *
 * @method signature
 * @return {String} function signature
 */
SolidityFunction.prototype.signature = function () {
    return sha3(this._name).slice(0, 8);
};


SolidityFunction.prototype.unpackOutput = function (output) {
    if (!output) {
        return;
    }

    output = output.length >= 2 ? output.slice(2) : output;
    var result = coder.decodeParams(this._outputTypes, output);
    return result.length === 1 ? result[0] : result;
};

/**
 * Calls a contract function.
 *
 * @method call
 * @param {...Object} Contract function arguments
 * @param {function} If the last argument is a function, the contract function
 *   call will be asynchronous, and the callback will be passed the
 *   error and result.
 * @return {String} output bytes
 */
SolidityFunction.prototype.call = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var defaultBlock = this.extractDefaultBlock(args);
    var payload = this.toPayload(args);


    if (!callback) {
        var output = this._eth.call(payload, defaultBlock);
        return this.unpackOutput(output);
    }

    var self = this;
    this._eth.call(payload, defaultBlock, function (error, output) {
        if (error) return callback(error, null);

        var unpacked = null;
        try {
            unpacked = self.unpackOutput(output);
        }
        catch (e) {
            error = e;
        }

        callback(error, unpacked);
    });
};

/**
 * Should be used to sendTransaction to solidity function
 *
 * @method sendTransaction
 */
SolidityFunction.prototype.sendTransaction = function () {
    var args = Array.prototype.slice.call(arguments).filter(function (a) {return a !== undefined; });
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (payload.value > 0 && !this._payable) {
        throw new Error('Cannot send value to non-payable function');
    }

    if (!callback) {
        return this._eth.sendTransaction(payload);
    }

    this._eth.sendTransaction(payload, callback);
};

/**
 * Should be used to estimateGas of solidity function
 *
 * @method estimateGas
 */
SolidityFunction.prototype.estimateGas = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);

    if (!callback) {
        return this._eth.estimateGas(payload);
    }

    this._eth.estimateGas(payload, callback);
};

/**
 * Return the encoded data of the call
 *
 * @method getData
 * @return {String} the encoded data
 */
SolidityFunction.prototype.getData = function () {
    var args = Array.prototype.slice.call(arguments);
    var payload = this.toPayload(args);

    return payload.data;
};

/**
 * Should be used to get function display name
 *
 * @method displayName
 * @return {String} display name of the function
 */
SolidityFunction.prototype.displayName = function () {
    return utils.extractDisplayName(this._name);
};

/**
 * Should be used to get function type name
 *
 * @method typeName
 * @return {String} type name of the function
 */
SolidityFunction.prototype.typeName = function () {
    return utils.extractTypeName(this._name);
};

/**
 * Should be called to get rpc requests from solidity function
 *
 * @method request
 * @returns {Object}
 */
SolidityFunction.prototype.request = function () {
    var args = Array.prototype.slice.call(arguments);
    var callback = this.extractCallback(args);
    var payload = this.toPayload(args);
    var format = this.unpackOutput.bind(this);

    return {
        method: this._constant ? 'eth_call' : 'eth_sendTransaction',
        callback: callback,
        params: [payload],
        format: format
    };
};

/**
 * Should be called to execute function
 *
 * @method execute
 */
SolidityFunction.prototype.execute = function () {
    var transaction = !this._constant;

    // send transaction
    if (transaction) {
        return this.sendTransaction.apply(this, Array.prototype.slice.call(arguments));
    }

    // call
    return this.call.apply(this, Array.prototype.slice.call(arguments));
};

/**
 * Should be called to attach function to contract
 *
 * @method attachToContract
 * @param {Contract}
 */
SolidityFunction.prototype.attachToContract = function (contract) {
    var execute = this.execute.bind(this);
    execute.request = this.request.bind(this);
    Reflect.defineProperty(execute, 'call', this.call.bind(this));
    execute.sendTransaction = this.sendTransaction.bind(this);
    execute.estimateGas = this.estimateGas.bind(this);
    execute.getData = this.getData.bind(this);
    var displayName = this.displayName();
    if (!contract[displayName]) {
        contract[displayName] = execute;
    }
    contract[displayName][this.typeName()] = execute; // circular!!!!
};

module.exports = SolidityFunction;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\httpprovider.js", {"./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","xhr2-cookies":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\index.js","xmlhttprequest":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\browser-xhr.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\httpprovider.js
      return function (require, module, exports) {
(function (Buffer){(function (){
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file httpprovider.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Marian Oancea <marian@ethdev.com>
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var errors = require('./errors');

// workaround to use httpprovider in different envs

// browser
if (typeof window !== 'undefined' && window.XMLHttpRequest) {
  XMLHttpRequest = window.XMLHttpRequest; // jshint ignore: line
// node
} else {
  XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest; // jshint ignore: line
}

var XHR2 = require('xhr2-cookies').XMLHttpRequest; // jshint ignore: line

/**
 * HttpProvider should be used to send rpc calls over http
 */
var HttpProvider = function (host, timeout, user, password, headers) {
  this.host = host || 'http://localhost:8545';
  this.timeout = timeout || 0;
  this.user = user;
  this.password = password;
  this.headers = headers;
};

/**
 * Should be called to prepare new XMLHttpRequest
 *
 * @method prepareRequest
 * @param {Boolean} true if request should be async
 * @return {XMLHttpRequest} object
 */
HttpProvider.prototype.prepareRequest = function (async) {
  var request;

  if (async) {
    request = new XHR2();
    request.timeout = this.timeout;
  } else {
    request = new XMLHttpRequest();
  }
  request.withCredentials = true;

  request.open('POST', this.host, async);
  if (this.user && this.password) {
    var auth = 'Basic ' + new Buffer(this.user + ':' + this.password).toString('base64');
    request.setRequestHeader('Authorization', auth);
  } request.setRequestHeader('Content-Type', 'application/json');
  if(this.headers) {
      this.headers.forEach(function(header) {
          request.setRequestHeader(header.name, header.value);
      });
  }
  return request;
};

/**
 * Should be called to make sync request
 *
 * @method send
 * @param {Object} payload
 * @return {Object} result
 */
HttpProvider.prototype.send = function (payload) {
  var request = this.prepareRequest(false);

  try {
    request.send(JSON.stringify(payload));
  } catch (error) {
    throw errors.InvalidConnection(this.host);
  }

  var result = request.responseText;

  try {
    result = JSON.parse(result);
  } catch (e) {
    throw errors.InvalidResponse(request.responseText);
  }

  return result;
};

/**
 * Should be used to make async request
 *
 * @method sendAsync
 * @param {Object} payload
 * @param {Function} callback triggered on end with (err, result)
 */
HttpProvider.prototype.sendAsync = function (payload, callback) {
  var request = this.prepareRequest(true);

  request.onreadystatechange = function () {
    if (request.readyState === 4 && request.timeout !== 1) {
      var result = request.responseText;
      var error = null;

      try {
        result = JSON.parse(result);
      } catch (e) {
        error = errors.InvalidResponse(request.responseText);
      }

      callback(error, result);
    }
  };

  request.ontimeout = function () {
    callback(errors.ConnectionTimeout(this.timeout));
  };

  try {
    request.send(JSON.stringify(payload));
  } catch (error) {
    callback(errors.InvalidConnection(this.host));
  }
};

/**
 * Synchronously tries to make Http request
 *
 * @method isConnected
 * @return {Boolean} returns true if request haven't failed. Otherwise false
 */
HttpProvider.prototype.isConnected = function () {
  try {
    this.send({
      id: 9999999999,
      jsonrpc: '2.0',
      method: 'net_listening',
      params: []
    });
    return true;
  } catch (e) {
    return false;
  }
};

module.exports = HttpProvider;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js", {"bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\iban.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file iban.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var BigNumber = require('bignumber.js');

var padLeft = function (string, bytes) {
    var result = string;
    while (result.length < bytes * 2) {
        result = '0' + result;
    }
    return result;
};

/**
 * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
 * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
 *
 * @method iso13616Prepare
 * @param {String} iban the IBAN
 * @returns {String} the prepared IBAN
 */
var iso13616Prepare = function (iban) {
    var A = 'A'.charCodeAt(0);
    var Z = 'Z'.charCodeAt(0);

    iban = iban.toUpperCase();
    iban = iban.substr(4) + iban.substr(0,4);

    return iban.split('').map(function(n){
        var code = n.charCodeAt(0);
        if (code >= A && code <= Z){
            // A = 10, B = 11, ... Z = 35
            return code - A + 10;
        } else {
            return n;
        }
    }).join('');
};

/**
 * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
 *
 * @method mod9710
 * @param {String} iban
 * @returns {Number}
 */
var mod9710 = function (iban) {
    var remainder = iban,
        block;

    while (remainder.length > 2){
        block = remainder.slice(0, 9);
        remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
    }

    return parseInt(remainder, 10) % 97;
};

/**
 * This prototype should be used to create iban object from iban correct string
 *
 * @param {String} iban
 */
var Iban = function (iban) {
    this._iban = iban;
};

/**
 * This method should be used to create iban object from ethereum address
 *
 * @method fromAddress
 * @param {String} address
 * @return {Iban} the IBAN object
 */
Iban.fromAddress = function (address) {
    var asBn = new BigNumber(address, 16);
    var base36 = asBn.toString(36);
    var padded = padLeft(base36, 15);
    return Iban.fromBban(padded.toUpperCase());
};

/**
 * Convert the passed BBAN to an IBAN for this country specification.
 * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
 * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
 *
 * @method fromBban
 * @param {String} bban the BBAN to convert to IBAN
 * @returns {Iban} the IBAN object
 */
Iban.fromBban = function (bban) {
    var countryCode = 'XE';

    var remainder = mod9710(iso13616Prepare(countryCode + '00' + bban));
    var checkDigit = ('0' + (98 - remainder)).slice(-2);

    return new Iban(countryCode + checkDigit + bban);
};

/**
 * Should be used to create IBAN object for given institution and identifier
 *
 * @method createIndirect
 * @param {Object} options, required options are "institution" and "identifier"
 * @return {Iban} the IBAN object
 */
Iban.createIndirect = function (options) {
    return Iban.fromBban('ETH' + options.institution + options.identifier);
};

/**
 * Thos method should be used to check if given string is valid iban object
 *
 * @method isValid
 * @param {String} iban string
 * @return {Boolean} true if it is valid IBAN
 */
Iban.isValid = function (iban) {
    var i = new Iban(iban);
    return i.isValid();
};

/**
 * Should be called to check if iban is correct
 *
 * @method isValid
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isValid = function () {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) &&
        mod9710(iso13616Prepare(this._iban)) === 1;
};

/**
 * Should be called to check if iban number is direct
 *
 * @method isDirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isDirect = function () {
    return this._iban.length === 34 || this._iban.length === 35;
};

/**
 * Should be called to check if iban number if indirect
 *
 * @method isIndirect
 * @returns {Boolean} true if it is, otherwise false
 */
Iban.prototype.isIndirect = function () {
    return this._iban.length === 20;
};

/**
 * Should be called to get iban checksum
 * Uses the mod-97-10 checksumming protocol (ISO/IEC 7064:2003)
 *
 * @method checksum
 * @returns {String} checksum
 */
Iban.prototype.checksum = function () {
    return this._iban.substr(2, 2);
};

/**
 * Should be called to get institution identifier
 * eg. XREG
 *
 * @method institution
 * @returns {String} institution identifier
 */
Iban.prototype.institution = function () {
    return this.isIndirect() ? this._iban.substr(7, 4) : '';
};

/**
 * Should be called to get client identifier within institution
 * eg. GAVOFYORK
 *
 * @method client
 * @returns {String} client identifier
 */
Iban.prototype.client = function () {
    return this.isIndirect() ? this._iban.substr(11) : '';
};

/**
 * Should be called to get client direct address
 *
 * @method address
 * @returns {String} client direct address
 */
Iban.prototype.address = function () {
    if (this.isDirect()) {
        var base36 = this._iban.substr(4);
        var asBn = new BigNumber(base36, 36);
        return padLeft(asBn.toString(16), 20);
    } 

    return '';
};

Iban.prototype.toString = function () {
    return this._iban;
};

module.exports = Iban;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\ipcprovider.js", {"../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\ipcprovider.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file ipcprovider.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

"use strict";

var utils = require('../utils/utils');
var errors = require('./errors');


var IpcProvider = function (path, net) {
    var _this = this;
    this.responseCallbacks = {};
    this.path = path;
    
    this.connection = net.connect({path: this.path});

    this.connection.on('error', function(e){
        console.error('IPC Connection Error', e);
        _this._timeout();
    });

    this.connection.on('end', function(){
        _this._timeout();
    }); 


    // LISTEN FOR CONNECTION RESPONSES
    this.connection.on('data', function(data) {
        /*jshint maxcomplexity: 6 */

        _this._parseResponse(data.toString()).forEach(function(result){

            var id = null;

            // get the id which matches the returned id
            if(utils.isArray(result)) {
                result.forEach(function(load){
                    if(_this.responseCallbacks[load.id])
                        id = load.id;
                });
            } else {
                id = result.id;
            }

            // fire the callback
            if(_this.responseCallbacks[id]) {
                _this.responseCallbacks[id](null, result);
                delete _this.responseCallbacks[id];
            }
        });
    });
};

/**
Will parse the response and make an array out of it.

@method _parseResponse
@param {String} data
*/
IpcProvider.prototype._parseResponse = function(data) {
    var _this = this,
        returnValues = [];
    
    // DE-CHUNKER
    var dechunkedData = data
        .replace(/\}[\n\r]?\{/g,'}|--|{') // }{
        .replace(/\}\][\n\r]?\[\{/g,'}]|--|[{') // }][{
        .replace(/\}[\n\r]?\[\{/g,'}|--|[{') // }[{
        .replace(/\}\][\n\r]?\{/g,'}]|--|{') // }]{
        .split('|--|');

    dechunkedData.forEach(function(data){

        // prepend the last chunk
        if(_this.lastChunk)
            data = _this.lastChunk + data;

        var result = null;

        try {
            result = JSON.parse(data);

        } catch(e) {

            _this.lastChunk = data;

            // start timeout to cancel all requests
            clearTimeout(_this.lastChunkTimeout);
            _this.lastChunkTimeout = setTimeout(function(){
                _this._timeout();
                throw errors.InvalidResponse(data);
            }, 1000 * 15);

            return;
        }

        // cancel timeout and set chunk to null
        clearTimeout(_this.lastChunkTimeout);
        _this.lastChunk = null;

        if(result)
            returnValues.push(result);
    });

    return returnValues;
};


/**
Get the adds a callback to the responseCallbacks object,
which will be called if a response matching the response Id will arrive.

@method _addResponseCallback
*/
IpcProvider.prototype._addResponseCallback = function(payload, callback) {
    var id = payload.id || payload[0].id;
    var method = payload.method || payload[0].method;

    this.responseCallbacks[id] = callback;
    this.responseCallbacks[id].method = method;
};

/**
Timeout all requests when the end/error event is fired

@method _timeout
*/
IpcProvider.prototype._timeout = function() {
    for(var key in this.responseCallbacks) {
        if(this.responseCallbacks.hasOwnProperty(key)){
            this.responseCallbacks[key](errors.InvalidConnection('on IPC'));
            delete this.responseCallbacks[key];
        }
    }
};


/**
Check if the current connection is still valid.

@method isConnected
*/
IpcProvider.prototype.isConnected = function() {
    var _this = this;

    // try reconnect, when connection is gone
    if(!_this.connection.writable)
        _this.connection.connect({path: _this.path});

    return !!this.connection.writable;
};

IpcProvider.prototype.send = function (payload) {

    if(this.connection.writeSync) {
        var result;

        // try reconnect, when connection is gone
        if(!this.connection.writable)
            this.connection.connect({path: this.path});

        var data = this.connection.writeSync(JSON.stringify(payload));

        try {
            result = JSON.parse(data);
        } catch(e) {
            throw errors.InvalidResponse(data);                
        }

        return result;

    } else {
        throw new Error('You tried to send "'+ payload.method +'" synchronously. Synchronous requests are not supported by the IPC provider.');
    }
};

IpcProvider.prototype.sendAsync = function (payload, callback) {
    // try reconnect, when connection is gone
    if(!this.connection.writable)
        this.connection.connect({path: this.path});


    this.connection.write(JSON.stringify(payload));
    this._addResponseCallback(payload, callback);
};

module.exports = IpcProvider;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\jsonrpc.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\jsonrpc.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file jsonrpc.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 *   Aaron Kumavis <aaron@kumavis.me>
 * @date 2015
 */

// Initialize Jsonrpc as a simple object with utility functions.
var Jsonrpc = {
    messageId: 0
};

/**
 * Should be called to valid json create payload object
 *
 * @method toPayload
 * @param {Function} method of jsonrpc call, required
 * @param {Array} params, an array of method params, optional
 * @returns {Object} valid jsonrpc payload object
 */
Jsonrpc.toPayload = function (method, params) {
    if (!method)
        console.error('jsonrpc method should be specified!');

    // advance message ID
    Jsonrpc.messageId++;

    return {
        jsonrpc: '2.0',
        id: Jsonrpc.messageId,
        method: method,
        params: params || []
    };
};

/**
 * Should be called to check if jsonrpc response is valid
 *
 * @method isValidResponse
 * @param {Object}
 * @returns {Boolean} true if response is valid, otherwise false
 */
Jsonrpc.isValidResponse = function (response) {
    return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);

    function validateSingleMessage(message){
      return !!message &&
        !message.error &&
        message.jsonrpc === '2.0' &&
        typeof message.id === 'number' &&
        message.result !== undefined; // only undefined is not valid json object
    }
};

/**
 * Should be called to create batch payload object
 *
 * @method toBatchPayload
 * @param {Array} messages, an array of objects with method (required) and params (optional) fields
 * @returns {Array} batch payload
 */
Jsonrpc.toBatchPayload = function (messages) {
    return messages.map(function (message) {
        return Jsonrpc.toPayload(message.method, message.params);
    });
};

module.exports = Jsonrpc;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js", {"../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\method.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file method.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = require('../utils/utils');
var errors = require('./errors');

var Method = function (options) {
    this.name = options.name;
    this.call = options.call;
    this.params = options.params || 0;
    this.inputFormatter = options.inputFormatter;
    this.outputFormatter = options.outputFormatter;
    this.requestManager = null;
};

Method.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be used to determine name of the jsonrpc method based on arguments
 *
 * @method getCall
 * @param {Array} arguments
 * @return {String} name of jsonrpc method
 */
Method.prototype.getCall = function (args) {
    return utils.isFunction(this.call) ? this.call(args) : this.call;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Method.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};

/**
 * Should be called to check if the number of arguments is correct
 * 
 * @method validateArgs
 * @param {Array} arguments
 * @throws {Error} if it is not
 */
Method.prototype.validateArgs = function (args) {
    if (args.length !== this.params) {
        throw errors.InvalidNumberOfRPCParams();
    }
};

/**
 * Should be called to format input args of method
 * 
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Method.prototype.formatInput = function (args) {
    if (!this.inputFormatter) {
        return args;
    }

    return this.inputFormatter.map(function (formatter, index) {
        return formatter ? formatter(args[index]) : args[index];
    });
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Method.prototype.formatOutput = function (result) {
    return this.outputFormatter && result ? this.outputFormatter(result) : result;
};

/**
 * Should create payload from given input args
 *
 * @method toPayload
 * @param {Array} args
 * @return {Object}
 */
Method.prototype.toPayload = function (args) {
    var call = this.getCall(args);
    var callback = this.extractCallback(args);
    var params = this.formatInput(args);
    this.validateArgs(params);

    return {
        method: call,
        params: params,
        callback: callback
    };
};

Method.prototype.attachToObject = function (obj) {
    var func = this.buildCall();
    Reflect.defineProperty(func, 'call', { value: this.call })
    var name = this.name.split('.');
    if (name.length > 1) {
        obj[name[0]] = obj[name[0]] || {};
        obj[name[0]][name[1]] = func;
    } else {
        obj[name[0]] = func; 
    }
};

Method.prototype.buildCall = function() {
    var method = this;
    var send = function () {
        var payload = method.toPayload(Array.prototype.slice.call(arguments));
        if (payload.callback) {
            return method.requestManager.sendAsync(payload, function (err, result) {
                payload.callback(err, method.formatOutput(result));
            });
        }
        return method.formatOutput(method.requestManager.send(payload));
    };
    send.request = this.request.bind(this);
    return send;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Method.prototype.request = function () {
    var payload = this.toPayload(Array.prototype.slice.call(arguments));
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Method;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\db.js", {"../method":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\db.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file db.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = require('../method');

var DB = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;
    
    methods().forEach(function(method) { 
        method.attachToObject(self);
        method.setRequestManager(web3._requestManager);
    });
};

var methods = function () {
    var putString = new Method({
        name: 'putString',
        call: 'db_putString',
        params: 3
    });

    var getString = new Method({
        name: 'getString',
        call: 'db_getString',
        params: 2
    });

    var putHex = new Method({
        name: 'putHex',
        call: 'db_putHex',
        params: 3
    });

    var getHex = new Method({
        name: 'getHex',
        call: 'db_getHex',
        params: 2
    });

    return [
        putString, getString, putHex, getHex
    ];
};

module.exports = DB;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\eth.js", {"../../utils/config":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js","../../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","../contract":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\contract.js","../filter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js","../formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js","../iban":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js","../method":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js","../namereg":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\namereg.js","../property":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js","../syncing":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\syncing.js","../transfer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\transfer.js","./watches":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\eth.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

"use strict";

var formatters = require('../formatters');
var utils = require('../../utils/utils');
var Method = require('../method');
var Property = require('../property');
var c = require('../../utils/config');
var Contract = require('../contract');
var watches = require('./watches');
var Filter = require('../filter');
var IsSyncing = require('../syncing');
var namereg = require('../namereg');
var Iban = require('../iban');
var transfer = require('../transfer');

var blockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? "eth_getBlockByHash" : "eth_getBlockByNumber";
};

var transactionFromBlockCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getTransactionByBlockHashAndIndex' : 'eth_getTransactionByBlockNumberAndIndex';
};

var uncleCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleByBlockHashAndIndex' : 'eth_getUncleByBlockNumberAndIndex';
};

var getBlockTransactionCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getBlockTransactionCountByHash' : 'eth_getBlockTransactionCountByNumber';
};

var uncleCountCall = function (args) {
    return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleCountByBlockHash' : 'eth_getUncleCountByBlockNumber';
};

function Eth(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });


    this.iban = Iban;
    this.sendIBANTransaction = transfer.bind(null, this);
}

Object.defineProperty(Eth.prototype, 'defaultBlock', {
    get: function () {
        return c.defaultBlock;
    },
    set: function (val) {
        c.defaultBlock = val;
        return val;
    }
});

Object.defineProperty(Eth.prototype, 'defaultAccount', {
    get: function () {
        return c.defaultAccount;
    },
    set: function (val) {
        c.defaultAccount = val;
        return val;
    }
});

var methods = function () {
    var getBalance = new Method({
        name: 'getBalance',
        call: 'eth_getBalance',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: formatters.outputBigNumberFormatter
    });

    var getStorageAt = new Method({
        name: 'getStorageAt',
        call: 'eth_getStorageAt',
        params: 3,
        inputFormatter: [null, utils.toHex, formatters.inputDefaultBlockNumberFormatter]
    });

    var getCode = new Method({
        name: 'getCode',
        call: 'eth_getCode',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var getBlock = new Method({
        name: 'getBlock',
        call: blockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, function (val) { return !!val; }],
        outputFormatter: formatters.outputBlockFormatter
    });

    var getUncle = new Method({
        name: 'getUncle',
        call: uncleCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputBlockFormatter,

    });

    var getCompilers = new Method({
        name: 'getCompilers',
        call: 'eth_getCompilers',
        params: 0
    });

    var getBlockTransactionCount = new Method({
        name: 'getBlockTransactionCount',
        call: getBlockTransactionCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getBlockUncleCount = new Method({
        name: 'getBlockUncleCount',
        call: uncleCountCall,
        params: 1,
        inputFormatter: [formatters.inputBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var getTransaction = new Method({
        name: 'getTransaction',
        call: 'eth_getTransactionByHash',
        params: 1,
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionFromBlock = new Method({
        name: 'getTransactionFromBlock',
        call: transactionFromBlockCall,
        params: 2,
        inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
        outputFormatter: formatters.outputTransactionFormatter
    });

    var getTransactionReceipt = new Method({
        name: 'getTransactionReceipt',
        call: 'eth_getTransactionReceipt',
        params: 1,
        outputFormatter: formatters.outputTransactionReceiptFormatter
    });

    var getTransactionCount = new Method({
        name: 'getTransactionCount',
        call: 'eth_getTransactionCount',
        params: 2,
        inputFormatter: [null, formatters.inputDefaultBlockNumberFormatter],
        outputFormatter: utils.toDecimal
    });

    var sendRawTransaction = new Method({
        name: 'sendRawTransaction',
        call: 'eth_sendRawTransaction',
        params: 1,
        inputFormatter: [null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'eth_sendTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var signTransaction = new Method({
        name: 'signTransaction',
        call: 'eth_signTransaction',
        params: 1,
        inputFormatter: [formatters.inputTransactionFormatter]
    });

    var sign = new Method({
        name: 'sign',
        call: 'eth_sign',
        params: 2,
        inputFormatter: [formatters.inputAddressFormatter, null]
    });

    var call = new Method({
        name: 'call',
        call: 'eth_call',
        params: 2,
        inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter]
    });

    var estimateGas = new Method({
        name: 'estimateGas',
        call: 'eth_estimateGas',
        params: 1,
        inputFormatter: [formatters.inputCallFormatter],
        outputFormatter: utils.toDecimal
    });

    var compileSolidity = new Method({
        name: 'compile.solidity',
        call: 'eth_compileSolidity',
        params: 1
    });

    var compileLLL = new Method({
        name: 'compile.lll',
        call: 'eth_compileLLL',
        params: 1
    });

    var compileSerpent = new Method({
        name: 'compile.serpent',
        call: 'eth_compileSerpent',
        params: 1
    });

    var submitWork = new Method({
        name: 'submitWork',
        call: 'eth_submitWork',
        params: 3
    });

    var getWork = new Method({
        name: 'getWork',
        call: 'eth_getWork',
        params: 0
    });

    return [
        getBalance,
        getStorageAt,
        getCode,
        getBlock,
        getUncle,
        getCompilers,
        getBlockTransactionCount,
        getBlockUncleCount,
        getTransaction,
        getTransactionFromBlock,
        getTransactionReceipt,
        getTransactionCount,
        call,
        estimateGas,
        sendRawTransaction,
        signTransaction,
        sendTransaction,
        sign,
        compileSolidity,
        compileLLL,
        compileSerpent,
        submitWork,
        getWork
    ];
};


var properties = function () {
    return [
        new Property({
            name: 'coinbase',
            getter: 'eth_coinbase'
        }),
        new Property({
            name: 'mining',
            getter: 'eth_mining'
        }),
        new Property({
            name: 'hashrate',
            getter: 'eth_hashrate',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'syncing',
            getter: 'eth_syncing',
            outputFormatter: formatters.outputSyncingFormatter
        }),
        new Property({
            name: 'gasPrice',
            getter: 'eth_gasPrice',
            outputFormatter: formatters.outputBigNumberFormatter
        }),
        new Property({
            name: 'accounts',
            getter: 'eth_accounts'
        }),
        new Property({
            name: 'blockNumber',
            getter: 'eth_blockNumber',
            outputFormatter: utils.toDecimal
        }),
        new Property({
            name: 'protocolVersion',
            getter: 'eth_protocolVersion'
        })
    ];
};

Eth.prototype.contract = function (abi) {
    var factory = new Contract(this, abi);
    return factory;
};

Eth.prototype.filter = function (options, callback, filterCreationErrorCallback) {
    return new Filter(options, 'eth', this._requestManager, watches.eth(), formatters.outputLogFormatter, callback, filterCreationErrorCallback);
};

Eth.prototype.namereg = function () {
    return this.contract(namereg.global.abi).at(namereg.global.address);
};

Eth.prototype.icapNamereg = function () {
    return this.contract(namereg.icap.abi).at(namereg.icap.address);
};

Eth.prototype.isSyncing = function (callback) {
    return new IsSyncing(this._requestManager, callback);
};

module.exports = Eth;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\net.js", {"../../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","../property":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\net.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file eth.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = require('../../utils/utils');
var Property = require('../property');

var Net = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    properties().forEach(function(p) { 
        p.attachToObject(self);
        p.setRequestManager(web3._requestManager);
    });
};

/// @returns an array of objects describing web3.eth api properties
var properties = function () {
    return [
        new Property({
            name: 'listening',
            getter: 'net_listening'
        }),
        new Property({
            name: 'peerCount',
            getter: 'net_peerCount',
            outputFormatter: utils.toDecimal
        })
    ];
};

module.exports = Net;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\personal.js", {"../formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js","../method":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js","../property":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\personal.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file eth.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

"use strict";

var Method = require('../method');
var Property = require('../property');
var formatters = require('../formatters');

function Personal(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var newAccount = new Method({
        name: 'newAccount',
        call: 'personal_newAccount',
        params: 1,
        inputFormatter: [null]
    });

    var importRawKey = new Method({
        name: 'importRawKey',
		call: 'personal_importRawKey',
		params: 2
    });

    var sign = new Method({
        name: 'sign',
		call: 'personal_sign',
		params: 3,
		inputFormatter: [null, formatters.inputAddressFormatter, null]
    });

    var ecRecover = new Method({
        name: 'ecRecover',
		call: 'personal_ecRecover',
		params: 2
    });

    var unlockAccount = new Method({
        name: 'unlockAccount',
        call: 'personal_unlockAccount',
        params: 3,
        inputFormatter: [formatters.inputAddressFormatter, null, null]
    });

    var sendTransaction = new Method({
        name: 'sendTransaction',
        call: 'personal_sendTransaction',
        params: 2,
        inputFormatter: [formatters.inputTransactionFormatter, null]
    });

    var lockAccount = new Method({
        name: 'lockAccount',
        call: 'personal_lockAccount',
        params: 1,
        inputFormatter: [formatters.inputAddressFormatter]
    });

    return [
        newAccount,
        importRawKey,
        unlockAccount,
        ecRecover,
        sign,
        sendTransaction,
        lockAccount
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'listAccounts',
            getter: 'personal_listAccounts'
        })
    ];
};


module.exports = Personal;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\shh.js", {"../filter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js","../method":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js","./watches":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\shh.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file shh.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethereum.org>
 *   Marek Kotewicz <marek@ethcore.io>
 * @date 2017
 */

var Method = require('../method');
var Filter = require('../filter');
var watches = require('./watches');

var Shh = function (web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });
};

Shh.prototype.newMessageFilter = function (options, callback, filterCreationErrorCallback) {
    return new Filter(options, 'shh', this._requestManager, watches.shh(), null, callback, filterCreationErrorCallback);
};

var methods = function () {

    return [
        new Method({
            name: 'version',
            call: 'shh_version',
            params: 0
        }),
        new Method({
            name: 'info',
            call: 'shh_info',
            params: 0
        }),
        new Method({
            name: 'setMaxMessageSize',
            call: 'shh_setMaxMessageSize',
            params: 1
        }),
        new Method({
            name: 'setMinPoW',
            call: 'shh_setMinPoW',
            params: 1
        }),
        new Method({
            name: 'markTrustedPeer',
            call: 'shh_markTrustedPeer',
            params: 1
        }),
        new Method({
            name: 'newKeyPair',
            call: 'shh_newKeyPair',
            params: 0
        }),
        new Method({
            name: 'addPrivateKey',
            call: 'shh_addPrivateKey',
            params: 1
        }),
        new Method({
            name: 'deleteKeyPair',
            call: 'shh_deleteKeyPair',
            params: 1
        }),
        new Method({
            name: 'hasKeyPair',
            call: 'shh_hasKeyPair',
            params: 1
        }),
        new Method({
            name: 'getPublicKey',
            call: 'shh_getPublicKey',
            params: 1
        }),
        new Method({
            name: 'getPrivateKey',
            call: 'shh_getPrivateKey',
            params: 1
        }),
        new Method({
            name: 'newSymKey',
            call: 'shh_newSymKey',
            params: 0
        }),
        new Method({
            name: 'addSymKey',
            call: 'shh_addSymKey',
            params: 1
        }),
        new Method({
            name: 'generateSymKeyFromPassword',
            call: 'shh_generateSymKeyFromPassword',
            params: 1
        }),
        new Method({
            name: 'hasSymKey',
            call: 'shh_hasSymKey',
            params: 1
        }),
        new Method({
            name: 'getSymKey',
            call: 'shh_getSymKey',
            params: 1
        }),
        new Method({
            name: 'deleteSymKey',
            call: 'shh_deleteSymKey',
            params: 1
        }),

        // subscribe and unsubscribe missing

        new Method({
            name: 'post',
            call: 'shh_post',
            params: 1,
            inputFormatter: [null]
        })
    ];
};

module.exports = Shh;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\swarm.js", {"../method":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js","../property":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\swarm.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file bzz.js
 * @author Alex Beregszaszi <alex@rtfs.hu>
 * @date 2016
 *
 * Reference: https://github.com/ethereum/go-ethereum/blob/swarm/internal/web3ext/web3ext.go#L33
 */

"use strict";

var Method = require('../method');
var Property = require('../property');

function Swarm(web3) {
    this._requestManager = web3._requestManager;

    var self = this;

    methods().forEach(function(method) {
        method.attachToObject(self);
        method.setRequestManager(self._requestManager);
    });

    properties().forEach(function(p) {
        p.attachToObject(self);
        p.setRequestManager(self._requestManager);
    });
}

var methods = function () {
    var blockNetworkRead = new Method({
        name: 'blockNetworkRead',
        call: 'bzz_blockNetworkRead',
        params: 1,
        inputFormatter: [null]
    });

    var syncEnabled = new Method({
        name: 'syncEnabled',
        call: 'bzz_syncEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var swapEnabled = new Method({
        name: 'swapEnabled',
        call: 'bzz_swapEnabled',
        params: 1,
        inputFormatter: [null]
    });

    var download = new Method({
        name: 'download',
        call: 'bzz_download',
        params: 2,
        inputFormatter: [null, null]
    });

    var upload = new Method({
        name: 'upload',
        call: 'bzz_upload',
        params: 2,
        inputFormatter: [null, null]
    });

    var retrieve = new Method({
        name: 'retrieve',
        call: 'bzz_retrieve',
        params: 1,
        inputFormatter: [null]
    });

    var store = new Method({
        name: 'store',
        call: 'bzz_store',
        params: 2,
        inputFormatter: [null, null]
    });

    var get = new Method({
        name: 'get',
        call: 'bzz_get',
        params: 1,
        inputFormatter: [null]
    });

    var put = new Method({
        name: 'put',
        call: 'bzz_put',
        params: 2,
        inputFormatter: [null, null]
    });

    var modify = new Method({
        name: 'modify',
        call: 'bzz_modify',
        params: 4,
        inputFormatter: [null, null, null, null]
    });

    return [
        blockNetworkRead,
        syncEnabled,
        swapEnabled,
        download,
        upload,
        retrieve,
        store,
        get,
        put,
        modify
    ];
};

var properties = function () {
    return [
        new Property({
            name: 'hive',
            getter: 'bzz_hive'
        }),
        new Property({
            name: 'info',
            getter: 'bzz_info'
        })
    ];
};


module.exports = Swarm;

      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js", {"../method":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\watches.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file watches.js
 * @authors:
 *   Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Method = require('../method');

/// @returns an array of objects describing web3.eth.filter api methods
var eth = function () {
    var newFilterCall = function (args) {
        var type = args[0];

        switch(type) {
            case 'latest':
                args.shift();
                this.params = 0;
                return 'eth_newBlockFilter';
            case 'pending':
                args.shift();
                this.params = 0;
                return 'eth_newPendingTransactionFilter';
            default:
                return 'eth_newFilter';
        }
    };

    var newFilter = new Method({
        name: 'newFilter',
        call: newFilterCall,
        params: 1
    });

    var uninstallFilter = new Method({
        name: 'uninstallFilter',
        call: 'eth_uninstallFilter',
        params: 1
    });

    var getLogs = new Method({
        name: 'getLogs',
        call: 'eth_getFilterLogs',
        params: 1
    });

    var poll = new Method({
        name: 'poll',
        call: 'eth_getFilterChanges',
        params: 1
    });

    return [
        newFilter,
        uninstallFilter,
        getLogs,
        poll
    ];
};

/// @returns an array of objects describing web3.shh.watch api methods
var shh = function () {

    return [
        new Method({
            name: 'newFilter',
            call: 'shh_newMessageFilter',
            params: 1
        }),
        new Method({
            name: 'uninstallFilter',
            call: 'shh_deleteMessageFilter',
            params: 1
        }),
        new Method({
            name: 'getLogs',
            call: 'shh_getFilterMessages',
            params: 1
        }),
        new Method({
            name: 'poll',
            call: 'shh_getFilterMessages',
            params: 1
        })
    ];
};

module.exports = {
    eth: eth,
    shh: shh
};


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\namereg.js", {"../contracts/GlobalRegistrar.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\GlobalRegistrar.json","../contracts/ICAPRegistrar.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\ICAPRegistrar.json"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\namereg.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file namereg.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var globalRegistrarAbi = require('../contracts/GlobalRegistrar.json');
var icapRegistrarAbi= require('../contracts/ICAPRegistrar.json');

var globalNameregAddress = '0xc6d9d2cd449a754c494264e1809c50e34d64562b';
var icapNameregAddress = '0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00';

module.exports = {
    global: {
        abi: globalRegistrarAbi,
        address: globalNameregAddress
    },
    icap: {
        abi: icapRegistrarAbi,
        address: icapNameregAddress
    }
};


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js", {"../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\property.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/**
 * @file property.js
 * @author Fabian Vogelsteller <fabian@frozeman.de>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var utils = require('../utils/utils');

var Property = function (options) {
    this.name = options.name;
    this.getter = options.getter;
    this.setter = options.setter;
    this.outputFormatter = options.outputFormatter;
    this.inputFormatter = options.inputFormatter;
    this.requestManager = null;
};

Property.prototype.setRequestManager = function (rm) {
    this.requestManager = rm;
};

/**
 * Should be called to format input args of method
 *
 * @method formatInput
 * @param {Array}
 * @return {Array}
 */
Property.prototype.formatInput = function (arg) {
    return this.inputFormatter ? this.inputFormatter(arg) : arg;
};

/**
 * Should be called to format output(result) of method
 *
 * @method formatOutput
 * @param {Object}
 * @return {Object}
 */
Property.prototype.formatOutput = function (result) {
    return this.outputFormatter && result !== null && result !== undefined ? this.outputFormatter(result) : result;
};

/**
 * Should be used to extract callback from array of arguments. Modifies input param
 *
 * @method extractCallback
 * @param {Array} arguments
 * @return {Function|Null} callback, if exists
 */
Property.prototype.extractCallback = function (args) {
    if (utils.isFunction(args[args.length - 1])) {
        return args.pop(); // modify the args array!
    }
};


/**
 * Should attach function to method
 *
 * @method attachToObject
 * @param {Object}
 * @param {Function}
 */
Property.prototype.attachToObject = function (obj) {
    var proto = {
        get: this.buildGet(),
        enumerable: true
    };

    var names = this.name.split('.');
    var name = names[0];
    if (names.length > 1) {
        obj[names[0]] = obj[names[0]] || {};
        obj = obj[names[0]];
        name = names[1];
    }

    Object.defineProperty(obj, name, proto);
    obj[asyncGetterName(name)] = this.buildAsyncGet();
};

var asyncGetterName = function (name) {
    return 'get' + name.charAt(0).toUpperCase() + name.slice(1);
};

Property.prototype.buildGet = function () {
    var property = this;
    return function get() {
        return property.formatOutput(property.requestManager.send({
            method: property.getter
        }));
    };
};

Property.prototype.buildAsyncGet = function () {
    var property = this;
    var get = function (callback) {
        property.requestManager.sendAsync({
            method: property.getter
        }, function (err, result) {
            callback(err, property.formatOutput(result));
        });
    };
    get.request = this.request.bind(this);
    return get;
};

/**
 * Should be called to create pure JSONRPC request which can be used in batch request
 *
 * @method request
 * @param {...} params
 * @return {Object} jsonrpc request
 */
Property.prototype.request = function () {
    var payload = {
        method: this.getter,
        params: [],
        callback: this.extractCallback(Array.prototype.slice.call(arguments))
    };
    payload.format = this.formatOutput.bind(this);
    return payload;
};

module.exports = Property;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\requestmanager.js", {"../utils/config":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js","../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js","./jsonrpc":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\jsonrpc.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\requestmanager.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file requestmanager.js
 * @author Jeffrey Wilcke <jeff@ethdev.com>
 * @author Marek Kotewicz <marek@ethdev.com>
 * @author Marian Oancea <marian@ethdev.com>
 * @author Fabian Vogelsteller <fabian@ethdev.com>
 * @author Gav Wood <g@ethdev.com>
 * @date 2014
 */

var Jsonrpc = require('./jsonrpc');
var utils = require('../utils/utils');
var c = require('../utils/config');
var errors = require('./errors');

/**
 * It's responsible for passing messages to providers
 * It's also responsible for polling the ethereum node for incoming messages
 * Default poll timeout is 1 second
 * Singleton
 */
var RequestManager = function (provider) {
    this.provider = provider;
    this.polls = {};
    this.timeout = null;
};

/**
 * Should be used to synchronously send request
 *
 * @method send
 * @param {Object} data
 * @return {Object}
 */
RequestManager.prototype.send = function (data) {
    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return null;
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    var result = this.provider.send(payload);

    if (!Jsonrpc.isValidResponse(result)) {
        throw errors.InvalidResponse(result);
    }

    return result.result;
};

/**
 * Should be used to asynchronously send request
 *
 * @method sendAsync
 * @param {Object} data
 * @param {Function} callback
 */
RequestManager.prototype.sendAsync = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toPayload(data.method, data.params);
    this.provider.sendAsync(payload, function (err, result) {
        if (err) {
            return callback(err);
        }
        
        if (!Jsonrpc.isValidResponse(result)) {
            return callback(errors.InvalidResponse(result));
        }

        callback(null, result.result);
    });
};

/**
 * Should be called to asynchronously send batch request
 *
 * @method sendBatch
 * @param {Array} batch data
 * @param {Function} callback
 */
RequestManager.prototype.sendBatch = function (data, callback) {
    if (!this.provider) {
        return callback(errors.InvalidProvider());
    }

    var payload = Jsonrpc.toBatchPayload(data);

    this.provider.sendAsync(payload, function (err, results) {
        if (err) {
            return callback(err);
        }

        if (!utils.isArray(results)) {
            return callback(errors.InvalidResponse(results));
        }

        callback(err, results);
    }); 
};

/**
 * Should be used to set provider of request manager
 *
 * @method setProvider
 * @param {Object}
 */
RequestManager.prototype.setProvider = function (p) {
    this.provider = p;
};

/**
 * Should be used to start polling
 *
 * @method startPolling
 * @param {Object} data
 * @param {Number} pollId
 * @param {Function} callback
 * @param {Function} uninstall
 *
 * @todo cleanup number of params
 */
RequestManager.prototype.startPolling = function (data, pollId, callback, uninstall) {
    this.polls[pollId] = {data: data, id: pollId, callback: callback, uninstall: uninstall};


    // start polling
    if (!this.timeout) {
        this.poll();
    }
};

/**
 * Should be used to stop polling for filter with given id
 *
 * @method stopPolling
 * @param {Number} pollId
 */
RequestManager.prototype.stopPolling = function (pollId) {
    delete this.polls[pollId];

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to reset the polling mechanism of the request manager
 *
 * @method reset
 */
RequestManager.prototype.reset = function (keepIsSyncing) {
    /*jshint maxcomplexity:5 */

    for (var key in this.polls) {
        // remove all polls, except sync polls,
        // they need to be removed manually by calling syncing.stopWatching()
        if(!keepIsSyncing || key.indexOf('syncPoll_') === -1) {
            this.polls[key].uninstall();
            delete this.polls[key];
        }
    }

    // stop polling
    if(Object.keys(this.polls).length === 0 && this.timeout) {
        clearTimeout(this.timeout);
        this.timeout = null;
    }
};

/**
 * Should be called to poll for changes on filter with given id
 *
 * @method poll
 */
RequestManager.prototype.poll = function () {
    /*jshint maxcomplexity: 6 */
    this.timeout = setTimeout(this.poll.bind(this), c.ETH_POLLING_TIMEOUT);

    if (Object.keys(this.polls).length === 0) {
        return;
    }

    if (!this.provider) {
        console.error(errors.InvalidProvider());
        return;
    }

    var pollsData = [];
    var pollsIds = [];
    for (var key in this.polls) {
        pollsData.push(this.polls[key].data);
        pollsIds.push(key);
    }

    if (pollsData.length === 0) {
        return;
    }

    var payload = Jsonrpc.toBatchPayload(pollsData);
    
    // map the request id to they poll id
    var pollsIdMap = {};
    payload.forEach(function(load, index){
        pollsIdMap[load.id] = pollsIds[index];
    });


    var self = this;
    this.provider.sendAsync(payload, function (error, results) {


        // TODO: console log?
        if (error) {
            return;
        }

        if (!utils.isArray(results)) {
            throw errors.InvalidResponse(results);
        }
        results.map(function (result) {
            var id = pollsIdMap[result.id];

            // make sure the filter is still installed after arrival of the request
            if (self.polls[id]) {
                result.callback = self.polls[id].callback;
                return result;
            } else
                return false;
        }).filter(function (result) {
            return !!result; 
        }).filter(function (result) {
            var valid = Jsonrpc.isValidResponse(result);
            if (!valid) {
                result.callback(errors.InvalidResponse(result));
            }
            return valid;
        }).forEach(function (result) {
            result.callback(null, result.result);
        });
    });
};

module.exports = RequestManager;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\settings.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\settings.js
      return function (require, module, exports) {


var Settings = function () {
    this.defaultBlock = 'latest';
    this.defaultAccount = undefined;
};

module.exports = Settings;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\syncing.js", {"../utils/utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js","./formatters":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\syncing.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** @file syncing.js
 * @authors:
 *   Fabian Vogelsteller <fabian@ethdev.com>
 * @date 2015
 */

var formatters = require('./formatters');
var utils = require('../utils/utils');

var count = 1;

/**
Adds the callback and sets up the methods, to iterate over the results.

@method pollSyncing
@param {Object} self
*/
var pollSyncing = function(self) {

    var onMessage = function (error, sync) {
        if (error) {
            return self.callbacks.forEach(function (callback) {
                callback(error);
            });
        }

        if(utils.isObject(sync) && sync.startingBlock)
            sync = formatters.outputSyncingFormatter(sync);

        self.callbacks.forEach(function (callback) {
            if (self.lastSyncState !== sync) {
                
                // call the callback with true first so the app can stop anything, before receiving the sync data
                if(!self.lastSyncState && utils.isObject(sync))
                    callback(null, true);
                
                // call on the next CPU cycle, so the actions of the sync stop can be processes first
                setTimeout(function() {
                    callback(null, sync);
                }, 0);
                
                self.lastSyncState = sync;
            }
        });
    };

    self.requestManager.startPolling({
        method: 'eth_syncing',
        params: [],
    }, self.pollId, onMessage, self.stopWatching.bind(self));

};

var IsSyncing = function (requestManager, callback) {
    this.requestManager = requestManager;
    this.pollId = 'syncPoll_'+ count++;
    this.callbacks = [];
    this.addCallback(callback);
    this.lastSyncState = false;
    pollSyncing(this);

    return this;
};

IsSyncing.prototype.addCallback = function (callback) {
    if(callback)
        this.callbacks.push(callback);
    return this;
};

IsSyncing.prototype.stopWatching = function () {
    this.requestManager.stopPolling(this.pollId);
    this.callbacks = [];
};

module.exports = IsSyncing;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\transfer.js", {"../contracts/SmartExchange.json":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\SmartExchange.json","./iban":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\transfer.js
      return function (require, module, exports) {
/*
    This file is part of web3.js.

    web3.js is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    web3.js is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
*/
/** 
 * @file transfer.js
 * @author Marek Kotewicz <marek@ethdev.com>
 * @date 2015
 */

var Iban = require('./iban');
var exchangeAbi = require('../contracts/SmartExchange.json');

/**
 * Should be used to make Iban transfer
 *
 * @method transfer
 * @param {String} from
 * @param {String} to iban
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transfer = function (eth, from, to, value, callback) {
    var iban = new Iban(to); 
    if (!iban.isValid()) {
        throw new Error('invalid iban address');
    }

    if (iban.isDirect()) {
        return transferToAddress(eth, from, iban.address(), value, callback);
    }
    
    if (!callback) {
        var address = eth.icapNamereg().addr(iban.institution());
        return deposit(eth, from, address, value, iban.client());
    }

    eth.icapNamereg().addr(iban.institution(), function (err, address) {
        return deposit(eth, from, address, value, iban.client(), callback);
    });
    
};

/**
 * Should be used to transfer funds to certain address
 *
 * @method transferToAddress
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be tranfered
 * @param {Function} callback, callback
 */
var transferToAddress = function (eth, from, to, value, callback) {
    return eth.sendTransaction({
        address: to,
        from: from,
        value: value
    }, callback);
};

/**
 * Should be used to deposit funds to generic Exchange contract (must implement deposit(bytes32) method!)
 *
 * @method deposit
 * @param {String} from
 * @param {String} to
 * @param {Value} value to be transfered
 * @param {String} client unique identifier
 * @param {Function} callback, callback
 */
var deposit = function (eth, from, to, value, client, callback) {
    var abi = exchangeAbi;
    return eth.contract(abi).at(to).deposit(client, {
        from: from,
        value: value
    }, callback);
};

module.exports = transfer;


      };
    };
  }
}, {package:"@metamask/controllers>web3",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js", {"crypto":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\crypto-browserify\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\node_modules\bignumber.js\bignumber.js
      return function (require, module, exports) {
/*! bignumber.js v2.0.7 https://github.com/MikeMcl/bignumber.js/LICENCE */

;(function (global) {
    'use strict';

    /*
      bignumber.js v2.0.7
      A JavaScript library for arbitrary-precision arithmetic.
      https://github.com/MikeMcl/bignumber.js
      Copyright (c) 2015 Michael Mclaughlin <M8ch88l@gmail.com>
      MIT Expat Licence
    */


    var BigNumber, crypto, parseNumeric,
        isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
        mathceil = Math.ceil,
        mathfloor = Math.floor,
        notBool = ' not a boolean or binary digit',
        roundingMode = 'rounding mode',
        tooManyDigits = 'number type has more than 15 significant digits',
        ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
        BASE = 1e14,
        LOG_BASE = 14,
        MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
        // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
        POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
        SQRT_BASE = 1e7,

        /*
         * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
         * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
         * exception is thrown (if ERRORS is true).
         */
        MAX = 1E9;                                   // 0 to MAX_INT32


    /*
     * Create and return a BigNumber constructor.
     */
    function another(configObj) {
        var div,

            // id tracks the caller function, so its name can be included in error messages.
            id = 0,
            P = BigNumber.prototype,
            ONE = new BigNumber(1),


            /********************************* EDITABLE DEFAULTS **********************************/


            /*
             * The default values below must be integers within the inclusive ranges stated.
             * The values can also be changed at run-time using BigNumber.config.
             */

            // The maximum number of decimal places for operations involving division.
            DECIMAL_PLACES = 20,                     // 0 to MAX

            /*
             * The rounding mode used when rounding to the above decimal places, and when using
             * toExponential, toFixed, toFormat and toPrecision, and round (default value).
             * UP         0 Away from zero.
             * DOWN       1 Towards zero.
             * CEIL       2 Towards +Infinity.
             * FLOOR      3 Towards -Infinity.
             * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
             * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
             * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
             * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
             * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
             */
            ROUNDING_MODE = 4,                       // 0 to 8

            // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

            // The exponent value at and beneath which toString returns exponential notation.
            // Number type: -7
            TO_EXP_NEG = -7,                         // 0 to -MAX

            // The exponent value at and above which toString returns exponential notation.
            // Number type: 21
            TO_EXP_POS = 21,                         // 0 to MAX

            // RANGE : [MIN_EXP, MAX_EXP]

            // The minimum exponent value, beneath which underflow to zero occurs.
            // Number type: -324  (5e-324)
            MIN_EXP = -1e7,                          // -1 to -MAX

            // The maximum exponent value, above which overflow to Infinity occurs.
            // Number type:  308  (1.7976931348623157e+308)
            // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
            MAX_EXP = 1e7,                           // 1 to MAX

            // Whether BigNumber Errors are ever thrown.
            ERRORS = true,                           // true or false

            // Change to intValidatorNoErrors if ERRORS is false.
            isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

            // Whether to use cryptographically-secure random number generation, if available.
            CRYPTO = false,                          // true or false

            /*
             * The modulo mode used when calculating the modulus: a mod n.
             * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
             * The remainder (r) is calculated as: r = a - n * q.
             *
             * UP        0 The remainder is positive if the dividend is negative, else is negative.
             * DOWN      1 The remainder has the same sign as the dividend.
             *             This modulo mode is commonly known as 'truncated division' and is
             *             equivalent to (a % n) in JavaScript.
             * FLOOR     3 The remainder has the same sign as the divisor (Python %).
             * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
             * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
             *             The remainder is always positive.
             *
             * The truncated division, floored division, Euclidian division and IEEE 754 remainder
             * modes are commonly used for the modulus operation.
             * Although the other rounding modes can also be used, they may not give useful results.
             */
            MODULO_MODE = 1,                         // 0 to 9

            // The maximum number of significant digits of the result of the toPower operation.
            // If POW_PRECISION is 0, there will be unlimited significant digits.
            POW_PRECISION = 100,                     // 0 to MAX

            // The format specification used by the BigNumber.prototype.toFormat method.
            FORMAT = {
                decimalSeparator: '.',
                groupSeparator: ',',
                groupSize: 3,
                secondaryGroupSize: 0,
                fractionGroupSeparator: '\xA0',      // non-breaking space
                fractionGroupSize: 0
            };


        /******************************************************************************************/


        // CONSTRUCTOR


        /*
         * The BigNumber constructor and exported function.
         * Create and return a new instance of a BigNumber object.
         *
         * n {number|string|BigNumber} A numeric value.
         * [b] {number} The base of n. Integer, 2 to 64 inclusive.
         */
        function BigNumber( n, b ) {
            var c, e, i, num, len, str,
                x = this;

            // Enable constructor usage without new.
            if ( !( x instanceof BigNumber ) ) {

                // 'BigNumber() constructor call without new: {n}'
                if (ERRORS) raise( 26, 'constructor call without new', n );
                return new BigNumber( n, b );
            }

            // 'new BigNumber() base not an integer: {b}'
            // 'new BigNumber() base out of range: {b}'
            if ( b == null || !isValidInt( b, 2, 64, id, 'base' ) ) {

                // Duplicate.
                if ( n instanceof BigNumber ) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = ( n = n.c ) ? n.slice() : n;
                    id = 0;
                    return;
                }

                if ( ( num = typeof n == 'number' ) && n * 0 == 0 ) {
                    x.s = 1 / n < 0 ? ( n = -n, -1 ) : 1;

                    // Fast path for integers.
                    if ( n === ~~n ) {
                        for ( e = 0, i = n; i >= 10; i /= 10, e++ );
                        x.e = e;
                        x.c = [n];
                        id = 0;
                        return;
                    }

                    str = n + '';
                } else {
                    if ( !isNumeric.test( str = n + '' ) ) return parseNumeric( x, str, num );
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }
            } else {
                b = b | 0;
                str = n + '';

                // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                // Allow exponential notation to be used with base 10 argument.
                if ( b == 10 ) {
                    x = new BigNumber( n instanceof BigNumber ? n : str );
                    return round( x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE );
                }

                // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                // Any number in exponential form will fail due to the [Ee][+-].
                if ( ( num = typeof n == 'number' ) && n * 0 != 0 ||
                  !( new RegExp( '^-?' + ( c = '[' + ALPHABET.slice( 0, b ) + ']+' ) +
                    '(?:\\.' + c + ')?$',b < 37 ? 'i' : '' ) ).test(str) ) {
                    return parseNumeric( x, str, num, b );
                }

                if (num) {
                    x.s = 1 / n < 0 ? ( str = str.slice(1), -1 ) : 1;

                    if ( ERRORS && str.replace( /^0\.0*|\./, '' ).length > 15 ) {

                        // 'new BigNumber() number type has more than 15 significant digits: {n}'
                        raise( id, tooManyDigits, n );
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                } else {
                    x.s = str.charCodeAt(0) === 45 ? ( str = str.slice(1), -1 ) : 1;
                }

                str = convertBase( str, 10, b, x.s );
            }

            // Decimal point?
            if ( ( e = str.indexOf('.') ) > -1 ) str = str.replace( '.', '' );

            // Exponential form?
            if ( ( i = str.search( /e/i ) ) > 0 ) {

                // Determine exponent.
                if ( e < 0 ) e = i;
                e += +str.slice( i + 1 );
                str = str.substring( 0, i );
            } else if ( e < 0 ) {

                // Integer.
                e = str.length;
            }

            // Determine leading zeros.
            for ( i = 0; str.charCodeAt(i) === 48; i++ );

            // Determine trailing zeros.
            for ( len = str.length; str.charCodeAt(--len) === 48; );
            str = str.slice( i, len + 1 );

            if (str) {
                len = str.length;

                // Disallow numbers with over 15 significant digits if number type.
                // 'new BigNumber() number type has more than 15 significant digits: {n}'
                if ( num && ERRORS && len > 15 ) raise( id, tooManyDigits, x.s * n );

                e = e - i - 1;

                 // Overflow?
                if ( e > MAX_EXP ) {

                    // Infinity.
                    x.c = x.e = null;

                // Underflow?
                } else if ( e < MIN_EXP ) {

                    // Zero.
                    x.c = [ x.e = 0 ];
                } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = ( e + 1 ) % LOG_BASE;
                    if ( e < 0 ) i += LOG_BASE;

                    if ( i < len ) {
                        if (i) x.c.push( +str.slice( 0, i ) );

                        for ( len -= LOG_BASE; i < len; ) {
                            x.c.push( +str.slice( i, i += LOG_BASE ) );
                        }

                        str = str.slice(i);
                        i = LOG_BASE - str.length;
                    } else {
                        i -= len;
                    }

                    for ( ; i--; str += '0' );
                    x.c.push( +str );
                }
            } else {

                // Zero.
                x.c = [ x.e = 0 ];
            }

            id = 0;
        }


        // CONSTRUCTOR PROPERTIES


        BigNumber.another = another;

        BigNumber.ROUND_UP = 0;
        BigNumber.ROUND_DOWN = 1;
        BigNumber.ROUND_CEIL = 2;
        BigNumber.ROUND_FLOOR = 3;
        BigNumber.ROUND_HALF_UP = 4;
        BigNumber.ROUND_HALF_DOWN = 5;
        BigNumber.ROUND_HALF_EVEN = 6;
        BigNumber.ROUND_HALF_CEIL = 7;
        BigNumber.ROUND_HALF_FLOOR = 8;
        BigNumber.EUCLID = 9;


        /*
         * Configure infrequently-changing library-wide settings.
         *
         * Accept an object or an argument list, with one or many of the following properties or
         * parameters respectively:
         *
         *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
         *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
         *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
         *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
         *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
         *   ERRORS          {boolean|number}   true, false, 1 or 0
         *   CRYPTO          {boolean|number}   true, false, 1 or 0
         *   MODULO_MODE     {number}           0 to 9 inclusive
         *   POW_PRECISION   {number}           0 to MAX inclusive
         *   FORMAT          {object}           See BigNumber.prototype.toFormat
         *      decimalSeparator       {string}
         *      groupSeparator         {string}
         *      groupSize              {number}
         *      secondaryGroupSize     {number}
         *      fractionGroupSeparator {string}
         *      fractionGroupSize      {number}
         *
         * (The values assigned to the above FORMAT object properties are not checked for validity.)
         *
         * E.g.
         * BigNumber.config(20, 4) is equivalent to
         * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
         *
         * Ignore properties/parameters set to null or undefined.
         * Return an object with the properties current values.
         */
        BigNumber.config = function () {
            var v, p,
                i = 0,
                r = {},
                a = arguments,
                o = a[0],
                has = o && typeof o == 'object'
                  ? function () { if ( o.hasOwnProperty(p) ) return ( v = o[p] ) != null; }
                  : function () { if ( a.length > i ) return ( v = a[i++] ) != null; };

            // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
            // 'config() DECIMAL_PLACES not an integer: {v}'
            // 'config() DECIMAL_PLACES out of range: {v}'
            if ( has( p = 'DECIMAL_PLACES' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                DECIMAL_PLACES = v | 0;
            }
            r[p] = DECIMAL_PLACES;

            // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
            // 'config() ROUNDING_MODE not an integer: {v}'
            // 'config() ROUNDING_MODE out of range: {v}'
            if ( has( p = 'ROUNDING_MODE' ) && isValidInt( v, 0, 8, 2, p ) ) {
                ROUNDING_MODE = v | 0;
            }
            r[p] = ROUNDING_MODE;

            // EXPONENTIAL_AT {number|number[]}
            // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
            // 'config() EXPONENTIAL_AT not an integer: {v}'
            // 'config() EXPONENTIAL_AT out of range: {v}'
            if ( has( p = 'EXPONENTIAL_AT' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, 0, 2, p ) && isValidInt( v[1], 0, MAX, 2, p ) ) {
                        TO_EXP_NEG = v[0] | 0;
                        TO_EXP_POS = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    TO_EXP_NEG = -( TO_EXP_POS = ( v < 0 ? -v : v ) | 0 );
                }
            }
            r[p] = [ TO_EXP_NEG, TO_EXP_POS ];

            // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
            // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
            // 'config() RANGE not an integer: {v}'
            // 'config() RANGE cannot be zero: {v}'
            // 'config() RANGE out of range: {v}'
            if ( has( p = 'RANGE' ) ) {

                if ( isArray(v) ) {
                    if ( isValidInt( v[0], -MAX, -1, 2, p ) && isValidInt( v[1], 1, MAX, 2, p ) ) {
                        MIN_EXP = v[0] | 0;
                        MAX_EXP = v[1] | 0;
                    }
                } else if ( isValidInt( v, -MAX, MAX, 2, p ) ) {
                    if ( v | 0 ) MIN_EXP = -( MAX_EXP = ( v < 0 ? -v : v ) | 0 );
                    else if (ERRORS) raise( 2, p + ' cannot be zero', v );
                }
            }
            r[p] = [ MIN_EXP, MAX_EXP ];

            // ERRORS {boolean|number} true, false, 1 or 0.
            // 'config() ERRORS not a boolean or binary digit: {v}'
            if ( has( p = 'ERRORS' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    id = 0;
                    isValidInt = ( ERRORS = !!v ) ? intValidatorWithErrors : intValidatorNoErrors;
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = ERRORS;

            // CRYPTO {boolean|number} true, false, 1 or 0.
            // 'config() CRYPTO not a boolean or binary digit: {v}'
            // 'config() crypto unavailable: {crypto}'
            if ( has( p = 'CRYPTO' ) ) {

                if ( v === !!v || v === 1 || v === 0 ) {
                    CRYPTO = !!( v && crypto && typeof crypto == 'object' );
                    if ( v && !CRYPTO && ERRORS ) raise( 2, 'crypto unavailable', crypto );
                } else if (ERRORS) {
                    raise( 2, p + notBool, v );
                }
            }
            r[p] = CRYPTO;

            // MODULO_MODE {number} Integer, 0 to 9 inclusive.
            // 'config() MODULO_MODE not an integer: {v}'
            // 'config() MODULO_MODE out of range: {v}'
            if ( has( p = 'MODULO_MODE' ) && isValidInt( v, 0, 9, 2, p ) ) {
                MODULO_MODE = v | 0;
            }
            r[p] = MODULO_MODE;

            // POW_PRECISION {number} Integer, 0 to MAX inclusive.
            // 'config() POW_PRECISION not an integer: {v}'
            // 'config() POW_PRECISION out of range: {v}'
            if ( has( p = 'POW_PRECISION' ) && isValidInt( v, 0, MAX, 2, p ) ) {
                POW_PRECISION = v | 0;
            }
            r[p] = POW_PRECISION;

            // FORMAT {object}
            // 'config() FORMAT not an object: {v}'
            if ( has( p = 'FORMAT' ) ) {

                if ( typeof v == 'object' ) {
                    FORMAT = v;
                } else if (ERRORS) {
                    raise( 2, p + ' not an object', v );
                }
            }
            r[p] = FORMAT;

            return r;
        };


        /*
         * Return a new BigNumber whose value is the maximum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.max = function () { return maxOrMin( arguments, P.lt ); };


        /*
         * Return a new BigNumber whose value is the minimum of the arguments.
         *
         * arguments {number|string|BigNumber}
         */
        BigNumber.min = function () { return maxOrMin( arguments, P.gt ); };


        /*
         * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
         * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
         * zeros are produced).
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         *
         * 'random() decimal places not an integer: {dp}'
         * 'random() decimal places out of range: {dp}'
         * 'random() crypto unavailable: {crypto}'
         */
        BigNumber.random = (function () {
            var pow2_53 = 0x20000000000000;

            // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
            // Check if Math.random() produces more than 32 bits of randomness.
            // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
            // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
            var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
              ? function () { return mathfloor( Math.random() * pow2_53 ); }
              : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                  (Math.random() * 0x800000 | 0); };

            return function (dp) {
                var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                dp = dp == null || !isValidInt( dp, 0, MAX, 14 ) ? DECIMAL_PLACES : dp | 0;
                k = mathceil( dp / LOG_BASE );

                if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if ( crypto && crypto.getRandomValues ) {

                        a = crypto.getRandomValues( new Uint32Array( k *= 2 ) );

                        for ( ; i < k; ) {

                            // 53 bits:
                            // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                            // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                            // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                            //                                     11111 11111111 11111111
                            // 0x20000 is 2^21.
                            v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                            // Rejection sampling:
                            // 0 <= v < 9007199254740992
                            // Probability that v >= 9e15, is
                            // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                            if ( v >= 9e15 ) {
                                b = crypto.getRandomValues( new Uint32Array(2) );
                                a[i] = b[0];
                                a[i + 1] = b[1];
                            } else {

                                // 0 <= v <= 8999999999999999
                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 2;
                            }
                        }
                        i = k / 2;

                    // Node.js supporting crypto.randomBytes.
                    } else if ( crypto && crypto.randomBytes ) {

                        // buffer
                        a = crypto.randomBytes( k *= 7 );

                        for ( ; i < k; ) {

                            // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                            // 0x100000000 is 2^32, 0x1000000 is 2^24
                            // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                            // 0 <= v < 9007199254740992
                            v = ( ( a[i] & 31 ) * 0x1000000000000 ) + ( a[i + 1] * 0x10000000000 ) +
                                  ( a[i + 2] * 0x100000000 ) + ( a[i + 3] * 0x1000000 ) +
                                  ( a[i + 4] << 16 ) + ( a[i + 5] << 8 ) + a[i + 6];

                            if ( v >= 9e15 ) {
                                crypto.randomBytes(7).copy( a, i );
                            } else {

                                // 0 <= (v % 1e14) <= 99999999999999
                                c.push( v % 1e14 );
                                i += 7;
                            }
                        }
                        i = k / 7;
                    } else if (ERRORS) {
                        raise( 14, 'crypto unavailable', crypto );
                    }
                }

                // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
                if (!i) {

                    for ( ; i < k; ) {
                        v = random53bitInt();
                        if ( v < 9e15 ) c[i++] = v % 1e14;
                    }
                }

                k = c[--i];
                dp %= LOG_BASE;

                // Convert trailing digits to zeros according to dp.
                if ( k && dp ) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor( k / v ) * v;
                }

                // Remove trailing elements which are zero.
                for ( ; c[i] === 0; c.pop(), i-- );

                // Zero?
                if ( i < 0 ) {
                    c = [ e = 0 ];
                } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for ( e = -1 ; c[0] === 0; c.shift(), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for ( i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if ( i < LOG_BASE ) e -= LOG_BASE - i;
                }

                rand.e = e;
                rand.c = c;
                return rand;
            };
        })();


        // PRIVATE FUNCTIONS


        // Convert a numeric string of baseIn to a numeric string of baseOut.
        function convertBase( str, baseOut, baseIn, sign ) {
            var d, e, k, r, x, xc, y,
                i = str.indexOf( '.' ),
                dp = DECIMAL_PLACES,
                rm = ROUNDING_MODE;

            if ( baseIn < 37 ) str = str.toLowerCase();

            // Non-integer.
            if ( i >= 0 ) {
                k = POW_PRECISION;

                // Unlimited precision.
                POW_PRECISION = 0;
                str = str.replace( '.', '' );
                y = new BigNumber(baseIn);
                x = y.pow( str.length - i );
                POW_PRECISION = k;

                // Convert str as if an integer, then restore the fraction part by dividing the
                // result by its base raised to a power.
                y.c = toBaseOut( toFixedPoint( coeffToString( x.c ), x.e ), 10, baseOut );
                y.e = y.c.length;
            }

            // Convert the number as integer.
            xc = toBaseOut( str, baseIn, baseOut );
            e = k = xc.length;

            // Remove trailing zeros.
            for ( ; xc[--k] == 0; xc.pop() );
            if ( !xc[0] ) return '0';

            if ( i < 0 ) {
                --e;
            } else {
                x.c = xc;
                x.e = e;

                // sign is needed for correct rounding.
                x.s = sign;
                x = div( x, y, dp, rm, baseOut );
                xc = x.c;
                r = x.r;
                e = x.e;
            }

            d = e + dp + 1;

            // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;

            r = rm < 4 ? ( i != null || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                       : i > k || i == k &&( rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                         rm == ( x.s < 0 ? 8 : 7 ) );

            if ( d < 1 || !xc[0] ) {

                // 1^-dp or 0.
                str = r ? toFixedPoint( '1', -dp ) : '0';
            } else {
                xc.length = d;

                if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for ( --baseOut; ++xc[--d] > baseOut; ) {
                        xc[d] = 0;

                        if ( !d ) {
                            ++e;
                            xc.unshift(1);
                        }
                    }
                }

                // Determine trailing zeros.
                for ( k = xc.length; !xc[--k]; );

                // E.g. [4, 11, 15] becomes 4bf.
                for ( i = 0, str = ''; i <= k; str += ALPHABET.charAt( xc[i++] ) );
                str = toFixedPoint( str, e );
            }

            // The caller will add the sign.
            return str;
        }


        // Perform division in the specified base. Called by div and convertBase.
        div = (function () {

            // Assume non-zero x and k.
            function multiply( x, k, base ) {
                var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                for ( x = x.slice(); i--; ) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ( ( m % SQRT_BASE ) * SQRT_BASE ) + carry;
                    carry = ( temp / base | 0 ) + ( m / SQRT_BASE | 0 ) + khi * xhi;
                    x[i] = temp % base;
                }

                if (carry) x.unshift(carry);

                return x;
            }

            function compare( a, b, aL, bL ) {
                var i, cmp;

                if ( aL != bL ) {
                    cmp = aL > bL ? 1 : -1;
                } else {

                    for ( i = cmp = 0; i < aL; i++ ) {

                        if ( a[i] != b[i] ) {
                            cmp = a[i] > b[i] ? 1 : -1;
                            break;
                        }
                    }
                }
                return cmp;
            }

            function subtract( a, b, aL, base ) {
                var i = 0;

                // Subtract b from a.
                for ( ; aL--; ) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                }

                // Remove leading zeros.
                for ( ; !a[0] && a.length > 1; a.shift() );
            }

            // x: dividend, y: divisor.
            return function ( x, y, dp, rm, base ) {
                var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                // Either NaN, Infinity or 0?
                if ( !xc || !xc[0] || !yc || !yc[0] ) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || ( xc ? yc && xc[0] == yc[0] : !yc ) ? NaN :

                        // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                }

                q = new BigNumber(s);
                qc = q.c = [];
                e = x.e - y.e;
                s = dp + e + 1;

                if ( !base ) {
                    base = BASE;
                    e = bitFloor( x.e / LOG_BASE ) - bitFloor( y.e / LOG_BASE );
                    s = s / LOG_BASE | 0;
                }

                // Result exponent may be one less then the current value of e.
                // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                for ( i = 0; yc[i] == ( xc[i] || 0 ); i++ );
                if ( yc[i] > ( xc[i] || 0 ) ) e--;

                if ( s < 0 ) {
                    qc.push(1);
                    more = true;
                } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor( base / ( yc[0] + 1 ) );

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if ( n > 1 ) {
                        yc = multiply( yc, n, base );
                        xc = multiply( xc, n, base );
                        yL = yc.length;
                        xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice( 0, yL );
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for ( ; remL < yL; rem[remL++] = 0 );
                    yz = yc.slice();
                    yz.unshift(0);
                    yc0 = yc[0];
                    if ( yc[1] >= base / 2 ) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                        n = 0;

                        // Compare divisor and remainder.
                        cmp = compare( yc, rem, yL, remL );

                        // If divisor < remainder.
                        if ( cmp < 0 ) {

                            // Calculate trial digit, n.

                            rem0 = rem[0];
                            if ( yL != remL ) rem0 = rem0 * base + ( rem[1] || 0 );

                            // n is how many times the divisor goes into the current remainder.
                            n = mathfloor( rem0 / yc0 );

                            //  Algorithm:
                            //  1. product = divisor * trial digit (n)
                            //  2. if product > remainder: product -= divisor, n--
                            //  3. remainder -= product
                            //  4. if product was < remainder at 2:
                            //    5. compare new remainder and divisor
                            //    6. If remainder > divisor: remainder -= divisor, n++

                            if ( n > 1 ) {

                                // n may be > base only when base is 3.
                                if (n >= base) n = base - 1;

                                // product = divisor * trial digit.
                                prod = multiply( yc, n, base );
                                prodL = prod.length;
                                remL = rem.length;

                                // Compare product and remainder.
                                // If product > remainder.
                                // Trial digit n too high.
                                // n is 1 too high about 5% of the time, and is not known to have
                                // ever been more than 1 too high.
                                while ( compare( prod, rem, prodL, remL ) == 1 ) {
                                    n--;

                                    // Subtract divisor from product.
                                    subtract( prod, yL < prodL ? yz : yc, prodL, base );
                                    prodL = prod.length;
                                    cmp = 1;
                                }
                            } else {

                                // n is 0 or 1, cmp is -1.
                                // If n is 0, there is no need to compare yc and rem again below,
                                // so change cmp to 1 to avoid it.
                                // If n is 1, leave cmp as -1, so yc and rem are compared again.
                                if ( n == 0 ) {

                                    // divisor < remainder, so n must be at least 1.
                                    cmp = n = 1;
                                }

                                // product = divisor
                                prod = yc.slice();
                                prodL = prod.length;
                            }

                            if ( prodL < remL ) prod.unshift(0);

                            // Subtract product from remainder.
                            subtract( rem, prod, remL, base );
                            remL = rem.length;

                             // If product was < remainder.
                            if ( cmp == -1 ) {

                                // Compare divisor and new remainder.
                                // If divisor < new remainder, subtract divisor from remainder.
                                // Trial digit n too low.
                                // n is 1 too low about 5% of the time, and very rarely 2 too low.
                                while ( compare( yc, rem, yL, remL ) < 1 ) {
                                    n++;

                                    // Subtract divisor from remainder.
                                    subtract( rem, yL < remL ? yz : yc, remL, base );
                                    remL = rem.length;
                                }
                            }
                        } else if ( cmp === 0 ) {
                            n++;
                            rem = [0];
                        } // else cmp === 1 and n will be 0

                        // Add the next digit, n, to the result array.
                        qc[i++] = n;

                        // Update the remainder.
                        if ( rem[0] ) {
                            rem[remL++] = xc[xi] || 0;
                        } else {
                            rem = [ xc[xi] ];
                            remL = 1;
                        }
                    } while ( ( xi++ < xL || rem[0] != null ) && s-- );

                    more = rem[0] != null;

                    // Leading zero?
                    if ( !qc[0] ) qc.shift();
                }

                if ( base == BASE ) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for ( i = 1, s = qc[0]; s >= 10; s /= 10, i++ );
                    round( q, dp + ( q.e = i + e * LOG_BASE - 1 ) + 1, rm, more );

                // Caller is convertBase.
                } else {
                    q.e = e;
                    q.r = +more;
                }

                return q;
            };
        })();


        /*
         * Return a string representing the value of BigNumber n in fixed-point or exponential
         * notation rounded to the specified decimal places or significant digits.
         *
         * n is a BigNumber.
         * i is the index of the last digit required (i.e. the digit that may be rounded up).
         * rm is the rounding mode.
         * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
         */
        function format( n, i, rm, caller ) {
            var c0, e, ne, len, str;

            rm = rm != null && isValidInt( rm, 0, 8, caller, roundingMode )
              ? rm | 0 : ROUNDING_MODE;

            if ( !n.c ) return n.toString();
            c0 = n.c[0];
            ne = n.e;

            if ( i == null ) {
                str = coeffToString( n.c );
                str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                  ? toExponential( str, ne )
                  : toFixedPoint( str, ne );
            } else {
                n = round( new BigNumber(n), i, rm );

                // n.e may have changed if the value was rounded up.
                e = n.e;

                str = coeffToString( n.c );
                len = str.length;

                // toPrecision returns exponential notation if the number of significant digits
                // specified is less than the number of digits necessary to represent the integer
                // part of the value in fixed-point notation.

                // Exponential notation.
                if ( caller == 19 || caller == 24 && ( i <= e || e <= TO_EXP_NEG ) ) {

                    // Append zeros?
                    for ( ; len < i; str += '0', len++ );
                    str = toExponential( str, e );

                // Fixed-point notation.
                } else {
                    i -= ne;
                    str = toFixedPoint( str, e );

                    // Append zeros?
                    if ( e + 1 > len ) {
                        if ( --i > 0 ) for ( str += '.'; i--; str += '0' );
                    } else {
                        i += e - len;
                        if ( i > 0 ) {
                            if ( e + 1 == len ) str += '.';
                            for ( ; i--; str += '0' );
                        }
                    }
                }
            }

            return n.s < 0 && c0 ? '-' + str : str;
        }


        // Handle BigNumber.max and BigNumber.min.
        function maxOrMin( args, method ) {
            var m, n,
                i = 0;

            if ( isArray( args[0] ) ) args = args[0];
            m = new BigNumber( args[0] );

            for ( ; ++i < args.length; ) {
                n = new BigNumber( args[i] );

                // If any number is NaN, return NaN.
                if ( !n.s ) {
                    m = n;
                    break;
                } else if ( method.call( m, n ) ) {
                    m = n;
                }
            }

            return m;
        }


        /*
         * Return true if n is an integer in range, otherwise throw.
         * Use for argument validation when ERRORS is true.
         */
        function intValidatorWithErrors( n, min, max, caller, name ) {
            if ( n < min || n > max || n != truncate(n) ) {
                raise( caller, ( name || 'decimal places' ) +
                  ( n < min || n > max ? ' out of range' : ' not an integer' ), n );
            }

            return true;
        }


        /*
         * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
         * Called by minus, plus and times.
         */
        function normalise( n, c, e ) {
            var i = 1,
                j = c.length;

             // Remove trailing zeros.
            for ( ; !c[--j]; c.pop() );

            // Calculate the base 10 exponent. First get the number of digits of c[0].
            for ( j = c[0]; j >= 10; j /= 10, i++ );

            // Overflow?
            if ( ( e = i + e * LOG_BASE - 1 ) > MAX_EXP ) {

                // Infinity.
                n.c = n.e = null;

            // Underflow?
            } else if ( e < MIN_EXP ) {

                // Zero.
                n.c = [ n.e = 0 ];
            } else {
                n.e = e;
                n.c = c;
            }

            return n;
        }


        // Handle values that fail the validity test in BigNumber.
        parseNumeric = (function () {
            var basePrefix = /^(-?)0([xbo])/i,
                dotAfter = /^([^.]+)\.$/,
                dotBefore = /^\.([^.]+)$/,
                isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                whitespaceOrPlus = /^\s*\+|^\s+|\s+$/g;

            return function ( x, str, num, b ) {
                var base,
                    s = num ? str : str.replace( whitespaceOrPlus, '' );

                // No exception on Infinity or NaN.
                if ( isInfinityOrNaN.test(s) ) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                } else {
                    if ( !num ) {

                        // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                        s = s.replace( basePrefix, function ( m, p1, p2 ) {
                            base = ( p2 = p2.toLowerCase() ) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                            return !b || b == base ? p1 : m;
                        });

                        if (b) {
                            base = b;

                            // E.g. '1.' to '1', '.1' to '0.1'
                            s = s.replace( dotAfter, '$1' ).replace( dotBefore, '0.$1' );
                        }

                        if ( str != s ) return new BigNumber( s, base );
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise( id, 'not a' + ( b ? ' base ' + b : '' ) + ' number', str );
                    x.s = null;
                }

                x.c = x.e = null;
                id = 0;
            }
        })();


        // Throw a BigNumber Error.
        function raise( caller, msg, val ) {
            var error = new Error( [
                'new BigNumber',     // 0
                'cmp',               // 1
                'config',            // 2
                'div',               // 3
                'divToInt',          // 4
                'eq',                // 5
                'gt',                // 6
                'gte',               // 7
                'lt',                // 8
                'lte',               // 9
                'minus',             // 10
                'mod',               // 11
                'plus',              // 12
                'precision',         // 13
                'random',            // 14
                'round',             // 15
                'shift',             // 16
                'times',             // 17
                'toDigits',          // 18
                'toExponential',     // 19
                'toFixed',           // 20
                'toFormat',          // 21
                'toFraction',        // 22
                'pow',               // 23
                'toPrecision',       // 24
                'toString',          // 25
                'BigNumber'          // 26
            ][caller] + '() ' + msg + ': ' + val );

            error.name = 'BigNumber Error';
            id = 0;
            throw error;
        }


        /*
         * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
         * If r is truthy, it is known that there are more digits after the rounding digit.
         */
        function round( x, sd, rm, r ) {
            var d, i, j, k, n, ni, rd,
                xc = x.c,
                pows10 = POWS_TEN;

            // if x is not Infinity or NaN...
            if (xc) {

                // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                // n is a base 1e14 number, the value of the element of array x.c containing rd.
                // ni is the index of n within x.c.
                // d is the number of digits of n.
                // i is the index of rd within n including leading zeros.
                // j is the actual index of rd within n (if < 0, rd is a leading zero).
                out: {

                    // Get the number of digits of the first element of xc.
                    for ( d = 1, k = xc[0]; k >= 10; k /= 10, d++ );
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if ( i < 0 ) {
                        i += LOG_BASE;
                        j = sd;
                        n = xc[ ni = 0 ];

                        // Get the rounding digit at index j of n.
                        rd = n / pows10[ d - j - 1 ] % 10 | 0;
                    } else {
                        ni = mathceil( ( i + 1 ) / LOG_BASE );

                        if ( ni >= xc.length ) {

                            if (r) {

                                // Needed by sqrt.
                                for ( ; xc.length <= ni; xc.push(0) );
                                n = rd = 0;
                                d = 1;
                                i %= LOG_BASE;
                                j = i - LOG_BASE + 1;
                            } else {
                                break out;
                            }
                        } else {
                            n = k = xc[ni];

                            // Get the number of digits of n.
                            for ( d = 1; k >= 10; k /= 10, d++ );

                            // Get the index of rd within n.
                            i %= LOG_BASE;

                            // Get the index of rd within n, adjusted for leading zeros.
                            // The number of leading zeros of n is given by LOG_BASE - d.
                            j = i - LOG_BASE + d;

                            // Get the rounding digit at index j of n.
                            rd = j < 0 ? 0 : n / pows10[ d - j - 1 ] % 10 | 0;
                        }
                    }

                    r = r || sd < 0 ||

                    // Are there any non-zero digits after the rounding digit?
                    // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                    // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || ( j < 0 ? n : n % pows10[ d - j - 1 ] );

                    r = rm < 4
                      ? ( rd || r ) && ( rm == 0 || rm == ( x.s < 0 ? 3 : 2 ) )
                      : rd > 5 || rd == 5 && ( rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ( ( i > 0 ? j > 0 ? n / pows10[ d - j ] : 0 : xc[ni - 1] ) % 10 ) & 1 ||
                          rm == ( x.s < 0 ? 8 : 7 ) );

                    if ( sd < 1 || !xc[0] ) {
                        xc.length = 0;

                        if (r) {

                            // Convert sd to decimal places.
                            sd -= x.e + 1;

                            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                            xc[0] = pows10[ sd % LOG_BASE ];
                            x.e = -sd || 0;
                        } else {

                            // Zero.
                            xc[0] = x.e = 0;
                        }

                        return x;
                    }

                    // Remove excess digits.
                    if ( i == 0 ) {
                        xc.length = ni;
                        k = 1;
                        ni--;
                    } else {
                        xc.length = ni + 1;
                        k = pows10[ LOG_BASE - i ];

                        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                        // j > 0 means i > number of leading zeros of n.
                        xc[ni] = j > 0 ? mathfloor( n / pows10[ d - j ] % pows10[j] ) * k : 0;
                    }

                    // Round up?
                    if (r) {

                        for ( ; ; ) {

                            // If the digit to be rounded up is in the first element of xc...
                            if ( ni == 0 ) {

                                // i will be the length of xc[0] before k is added.
                                for ( i = 1, j = xc[0]; j >= 10; j /= 10, i++ );
                                j = xc[0] += k;
                                for ( k = 1; j >= 10; j /= 10, k++ );

                                // if i != k the length has increased.
                                if ( i != k ) {
                                    x.e++;
                                    if ( xc[0] == BASE ) xc[0] = 1;
                                }

                                break;
                            } else {
                                xc[ni] += k;
                                if ( xc[ni] != BASE ) break;
                                xc[ni--] = 0;
                                k = 1;
                            }
                        }
                    }

                    // Remove trailing zeros.
                    for ( i = xc.length; xc[--i] === 0; xc.pop() );
                }

                // Overflow? Infinity.
                if ( x.e > MAX_EXP ) {
                    x.c = x.e = null;

                // Underflow? Zero.
                } else if ( x.e < MIN_EXP ) {
                    x.c = [ x.e = 0 ];
                }
            }

            return x;
        }


        // PROTOTYPE/INSTANCE METHODS


        /*
         * Return a new BigNumber whose value is the absolute value of this BigNumber.
         */
        P.absoluteValue = P.abs = function () {
            var x = new BigNumber(this);
            if ( x.s < 0 ) x.s = 1;
            return x;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of Infinity.
         */
        P.ceil = function () {
            return round( new BigNumber(this), this.e + 1, 2 );
        };


        /*
         * Return
         * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
         * 0 if they have the same value,
         * or null if the value of either is NaN.
         */
        P.comparedTo = P.cmp = function ( y, b ) {
            id = 1;
            return compare( this, new BigNumber( y, b ) );
        };


        /*
         * Return the number of decimal places of the value of this BigNumber, or null if the value
         * of this BigNumber is Infinity or NaN.
         */
        P.decimalPlaces = P.dp = function () {
            var n, v,
                c = this.c;

            if ( !c ) return null;
            n = ( ( v = c.length - 1 ) - bitFloor( this.e / LOG_BASE ) ) * LOG_BASE;

            // Subtract the number of trailing zeros of the last number.
            if ( v = c[v] ) for ( ; v % 10 == 0; v /= 10, n-- );
            if ( n < 0 ) n = 0;

            return n;
        };


        /*
         *  n / 0 = I
         *  n / N = N
         *  n / I = 0
         *  0 / n = 0
         *  0 / 0 = N
         *  0 / N = N
         *  0 / I = 0
         *  N / n = N
         *  N / 0 = N
         *  N / N = N
         *  N / I = N
         *  I / n = I
         *  I / 0 = I
         *  I / N = N
         *  I / I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
         * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.dividedBy = P.div = function ( y, b ) {
            id = 3;
            return div( this, new BigNumber( y, b ), DECIMAL_PLACES, ROUNDING_MODE );
        };


        /*
         * Return a new BigNumber whose value is the integer part of dividing the value of this
         * BigNumber by the value of BigNumber(y, b).
         */
        P.dividedToIntegerBy = P.divToInt = function ( y, b ) {
            id = 4;
            return div( this, new BigNumber( y, b ), 0, 1 );
        };


        /*
         * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.equals = P.eq = function ( y, b ) {
            id = 5;
            return compare( this, new BigNumber( y, b ) ) === 0;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
         * number in the direction of -Infinity.
         */
        P.floor = function () {
            return round( new BigNumber(this), this.e + 1, 3 );
        };


        /*
         * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.greaterThan = P.gt = function ( y, b ) {
            id = 6;
            return compare( this, new BigNumber( y, b ) ) > 0;
        };


        /*
         * Return true if the value of this BigNumber is greater than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.greaterThanOrEqualTo = P.gte = function ( y, b ) {
            id = 7;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === 1 || b === 0;

        };


        /*
         * Return true if the value of this BigNumber is a finite number, otherwise returns false.
         */
        P.isFinite = function () {
            return !!this.c;
        };


        /*
         * Return true if the value of this BigNumber is an integer, otherwise return false.
         */
        P.isInteger = P.isInt = function () {
            return !!this.c && bitFloor( this.e / LOG_BASE ) > this.c.length - 2;
        };


        /*
         * Return true if the value of this BigNumber is NaN, otherwise returns false.
         */
        P.isNaN = function () {
            return !this.s;
        };


        /*
         * Return true if the value of this BigNumber is negative, otherwise returns false.
         */
        P.isNegative = P.isNeg = function () {
            return this.s < 0;
        };


        /*
         * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
         */
        P.isZero = function () {
            return !!this.c && this.c[0] == 0;
        };


        /*
         * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
         * otherwise returns false.
         */
        P.lessThan = P.lt = function ( y, b ) {
            id = 8;
            return compare( this, new BigNumber( y, b ) ) < 0;
        };


        /*
         * Return true if the value of this BigNumber is less than or equal to the value of
         * BigNumber(y, b), otherwise returns false.
         */
        P.lessThanOrEqualTo = P.lte = function ( y, b ) {
            id = 9;
            return ( b = compare( this, new BigNumber( y, b ) ) ) === -1 || b === 0;
        };


        /*
         *  n - 0 = n
         *  n - N = N
         *  n - I = -I
         *  0 - n = -n
         *  0 - 0 = 0
         *  0 - N = N
         *  0 - I = -I
         *  N - n = N
         *  N - 0 = N
         *  N - N = N
         *  N - I = N
         *  I - n = I
         *  I - 0 = I
         *  I - N = N
         *  I - I = N
         *
         * Return a new BigNumber whose value is the value of this BigNumber minus the value of
         * BigNumber(y, b).
         */
        P.minus = P.sub = function ( y, b ) {
            var i, j, t, xLTy,
                x = this,
                a = x.s;

            id = 10;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
            if ( a != b ) {
                y.s = -b;
                return x.plus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Either Infinity?
                if ( !xc || !yc ) return xc ? ( y.s = -b, y ) : new BigNumber( yc ? x : NaN );

                // Either zero?
                if ( !xc[0] || !yc[0] ) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? ( y.s = -b, y ) : new BigNumber( xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0 );
                }
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Determine which is the bigger number.
            if ( a = xe - ye ) {

                if ( xLTy = a < 0 ) {
                    a = -a;
                    t = xc;
                } else {
                    ye = xe;
                    t = yc;
                }

                t.reverse();

                // Prepend zeros to equalise exponents.
                for ( b = a; b--; t.push(0) );
                t.reverse();
            } else {

                // Exponents equal. Check digit by digit.
                j = ( xLTy = ( a = xc.length ) < ( b = yc.length ) ) ? a : b;

                for ( a = b = 0; b < j; b++ ) {

                    if ( xc[b] != yc[b] ) {
                        xLTy = xc[b] < yc[b];
                        break;
                    }
                }
            }

            // x < y? Point xc to the array of the bigger number.
            if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

            b = ( j = yc.length ) - ( i = xc.length );

            // Append zeros to xc if shorter.
            // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
            if ( b > 0 ) for ( ; b--; xc[i++] = 0 );
            b = BASE - 1;

            // Subtract yc from xc.
            for ( ; j > a; ) {

                if ( xc[--j] < yc[j] ) {
                    for ( i = j; i && !xc[--i]; xc[i] = b );
                    --xc[i];
                    xc[j] += BASE;
                }

                xc[j] -= yc[j];
            }

            // Remove leading zeros and adjust exponent accordingly.
            for ( ; xc[0] == 0; xc.shift(), --ye );

            // Zero?
            if ( !xc[0] ) {

                // Following IEEE 754 (2008) 6.3,
                // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                y.s = ROUNDING_MODE == 3 ? -1 : 1;
                y.c = [ y.e = 0 ];
                return y;
            }

            // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
            // for finite x and y.
            return normalise( y, xc, ye );
        };


        /*
         *   n % 0 =  N
         *   n % N =  N
         *   n % I =  n
         *   0 % n =  0
         *  -0 % n = -0
         *   0 % 0 =  N
         *   0 % N =  N
         *   0 % I =  0
         *   N % n =  N
         *   N % 0 =  N
         *   N % N =  N
         *   N % I =  N
         *   I % n =  N
         *   I % 0 =  N
         *   I % N =  N
         *   I % I =  N
         *
         * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
         * BigNumber(y, b). The result depends on the value of MODULO_MODE.
         */
        P.modulo = P.mod = function ( y, b ) {
            var q, s,
                x = this;

            id = 11;
            y = new BigNumber( y, b );

            // Return NaN if x is Infinity or NaN, or y is NaN or zero.
            if ( !x.c || !y.s || y.c && !y.c[0] ) {
                return new BigNumber(NaN);

            // Return x if y is Infinity or x is zero.
            } else if ( !y.c || x.c && !x.c[0] ) {
                return new BigNumber(x);
            }

            if ( MODULO_MODE == 9 ) {

                // Euclidian division: q = sign(y) * floor(x / abs(y))
                // r = x - qy    where  0 <= r < abs(y)
                s = y.s;
                y.s = 1;
                q = div( x, y, 0, 3 );
                y.s = s;
                q.s *= s;
            } else {
                q = div( x, y, 0, MODULO_MODE );
            }

            return x.minus( q.times(y) );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber negated,
         * i.e. multiplied by -1.
         */
        P.negated = P.neg = function () {
            var x = new BigNumber(this);
            x.s = -x.s || null;
            return x;
        };


        /*
         *  n + 0 = n
         *  n + N = N
         *  n + I = I
         *  0 + n = n
         *  0 + 0 = 0
         *  0 + N = N
         *  0 + I = I
         *  N + n = N
         *  N + 0 = N
         *  N + N = N
         *  N + I = N
         *  I + n = I
         *  I + 0 = I
         *  I + N = N
         *  I + I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber plus the value of
         * BigNumber(y, b).
         */
        P.plus = P.add = function ( y, b ) {
            var t,
                x = this,
                a = x.s;

            id = 12;
            y = new BigNumber( y, b );
            b = y.s;

            // Either NaN?
            if ( !a || !b ) return new BigNumber(NaN);

            // Signs differ?
             if ( a != b ) {
                y.s = -b;
                return x.minus(y);
            }

            var xe = x.e / LOG_BASE,
                ye = y.e / LOG_BASE,
                xc = x.c,
                yc = y.c;

            if ( !xe || !ye ) {

                // Return Infinity if either Infinity.
                if ( !xc || !yc ) return new BigNumber( a / 0 );

                // Either zero?
                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                if ( !xc[0] || !yc[0] ) return yc[0] ? y : new BigNumber( xc[0] ? x : a * 0 );
            }

            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();

            // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
            if ( a = xe - ye ) {
                if ( a > 0 ) {
                    ye = xe;
                    t = yc;
                } else {
                    a = -a;
                    t = xc;
                }

                t.reverse();
                for ( ; a--; t.push(0) );
                t.reverse();
            }

            a = xc.length;
            b = yc.length;

            // Point xc to the longer array, and b to the shorter length.
            if ( a - b < 0 ) t = yc, yc = xc, xc = t, b = a;

            // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
            for ( a = 0; b; ) {
                a = ( xc[--b] = xc[b] + yc[b] + a ) / BASE | 0;
                xc[b] %= BASE;
            }

            if (a) {
                xc.unshift(a);
                ++ye;
            }

            // No need to check for zero, as +x + +y != 0 && -x + -y != 0
            // ye = MAX_EXP + 1 possible
            return normalise( y, xc, ye );
        };


        /*
         * Return the number of significant digits of the value of this BigNumber.
         *
         * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
         */
        P.precision = P.sd = function (z) {
            var n, v,
                x = this,
                c = x.c;

            // 'precision() argument not a boolean or binary digit: {z}'
            if ( z != null && z !== !!z && z !== 1 && z !== 0 ) {
                if (ERRORS) raise( 13, 'argument' + notBool, z );
                if ( z != !!z ) z = null;
            }

            if ( !c ) return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;

            if ( v = c[v] ) {

                // Subtract the number of trailing zeros of the last element.
                for ( ; v % 10 == 0; v /= 10, n-- );

                // Add the number of digits of the first element.
                for ( v = c[0]; v >= 10; v /= 10, n++ );
            }

            if ( z && x.e + 1 > n ) n = x.e + 1;

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
         * omitted.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'round() decimal places out of range: {dp}'
         * 'round() decimal places not an integer: {dp}'
         * 'round() rounding mode not an integer: {rm}'
         * 'round() rounding mode out of range: {rm}'
         */
        P.round = function ( dp, rm ) {
            var n = new BigNumber(this);

            if ( dp == null || isValidInt( dp, 0, MAX, 15 ) ) {
                round( n, ~~dp + this.e + 1, rm == null ||
                  !isValidInt( rm, 0, 8, 15, roundingMode ) ? ROUNDING_MODE : rm | 0 );
            }

            return n;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
         * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
         *
         * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
         *
         * If k is out of range and ERRORS is false, the result will be 0 if k < 0, or Infinity
         * otherwise.
         *
         * 'shift() argument not an integer: {k}'
         * 'shift() argument out of range: {k}'
         */
        P.shift = function (k) {
            var n = this;
            return isValidInt( k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument' )

              // k < 1e+21, or truncate(k) will produce exponential notation.
              ? n.times( '1e' + truncate(k) )
              : new BigNumber( n.c && n.c[0] && ( k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER )
                ? n.s * ( k < 0 ? 0 : 1 / 0 )
                : n );
        };


        /*
         *  sqrt(-n) =  N
         *  sqrt( N) =  N
         *  sqrt(-I) =  N
         *  sqrt( I) =  I
         *  sqrt( 0) =  0
         *  sqrt(-0) = -0
         *
         * Return a new BigNumber whose value is the square root of the value of this BigNumber,
         * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
         */
        P.squareRoot = P.sqrt = function () {
            var m, n, r, rep, t,
                x = this,
                c = x.c,
                s = x.s,
                e = x.e,
                dp = DECIMAL_PLACES + 4,
                half = new BigNumber('0.5');

            // Negative/NaN/Infinity/zero?
            if ( s !== 1 || !c || !c[0] ) {
                return new BigNumber( !s || s < 0 && ( !c || c[0] ) ? NaN : c ? x : 1 / 0 );
            }

            // Initial estimate.
            s = Math.sqrt( +x );

            // Math.sqrt underflow/overflow?
            // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
            if ( s == 0 || s == 1 / 0 ) {
                n = coeffToString(c);
                if ( ( n.length + e ) % 2 == 0 ) n += '0';
                s = Math.sqrt(n);
                e = bitFloor( ( e + 1 ) / 2 ) - ( e < 0 || e % 2 );

                if ( s == 1 / 0 ) {
                    n = '1e' + e;
                } else {
                    n = s.toExponential();
                    n = n.slice( 0, n.indexOf('e') + 1 ) + e;
                }

                r = new BigNumber(n);
            } else {
                r = new BigNumber( s + '' );
            }

            // Check for zero.
            // r could be zero if MIN_EXP is changed after the this value was created.
            // This would cause a division by zero (x/t) and hence Infinity below, which would cause
            // coeffToString to throw.
            if ( r.c[0] ) {
                e = r.e;
                s = e + dp;
                if ( s < 3 ) s = 0;

                // Newton-Raphson iteration.
                for ( ; ; ) {
                    t = r;
                    r = half.times( t.plus( div( x, t, dp, 1 ) ) );

                    if ( coeffToString( t.c   ).slice( 0, s ) === ( n =
                         coeffToString( r.c ) ).slice( 0, s ) ) {

                        // The exponent of r may here be one less than the final result exponent,
                        // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
                        // are indexed correctly.
                        if ( r.e < e ) --s;
                        n = n.slice( s - 3, s + 1 );

                        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                        // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                        // iteration.
                        if ( n == '9999' || !rep && n == '4999' ) {

                            // On the first iteration only, check to see if rounding up gives the
                            // exact result as the nines may infinitely repeat.
                            if ( !rep ) {
                                round( t, t.e + DECIMAL_PLACES + 2, 0 );

                                if ( t.times(t).eq(x) ) {
                                    r = t;
                                    break;
                                }
                            }

                            dp += 4;
                            s += 4;
                            rep = 1;
                        } else {

                            // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                            // result. If not, then there are further digits and m will be truthy.
                            if ( !+n || !+n.slice(1) && n.charAt(0) == '5' ) {

                                // Truncate to the first rounding digit.
                                round( r, r.e + DECIMAL_PLACES + 2, 1 );
                                m = !r.times(r).eq(x);
                            }

                            break;
                        }
                    }
                }
            }

            return round( r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m );
        };


        /*
         *  n * 0 = 0
         *  n * N = N
         *  n * I = I
         *  0 * n = 0
         *  0 * 0 = 0
         *  0 * N = N
         *  0 * I = N
         *  N * n = N
         *  N * 0 = N
         *  N * N = N
         *  N * I = N
         *  I * n = I
         *  I * 0 = N
         *  I * N = N
         *  I * I = I
         *
         * Return a new BigNumber whose value is the value of this BigNumber times the value of
         * BigNumber(y, b).
         */
        P.times = P.mul = function ( y, b ) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                base, sqrtBase,
                x = this,
                xc = x.c,
                yc = ( id = 17, y = new BigNumber( y, b ) ).c;

            // Either NaN, Infinity or 0?
            if ( !xc || !yc || !xc[0] || !yc[0] ) {

                // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                if ( !x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc ) {
                    y.c = y.e = y.s = null;
                } else {
                    y.s *= x.s;

                    // Return Infinity if either is Infinity.
                    if ( !xc || !yc ) {
                        y.c = y.e = null;

                    // Return 0 if either is 0.
                    } else {
                        y.c = [0];
                        y.e = 0;
                    }
                }

                return y;
            }

            e = bitFloor( x.e / LOG_BASE ) + bitFloor( y.e / LOG_BASE );
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;

            // Ensure xc points to longer array and xcL to its length.
            if ( xcL < ycL ) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

            // Initialise the result array with zeros.
            for ( i = xcL + ycL, zc = []; i--; zc.push(0) );

            base = BASE;
            sqrtBase = SQRT_BASE;

            for ( i = ycL; --i >= 0; ) {
                c = 0;
                ylo = yc[i] % sqrtBase;
                yhi = yc[i] / sqrtBase | 0;

                for ( k = xcL, j = i + k; j > i; ) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ( ( m % sqrtBase ) * sqrtBase ) + zc[j] + c;
                    c = ( xlo / base | 0 ) + ( m / sqrtBase | 0 ) + yhi * xhi;
                    zc[j--] = xlo % base;
                }

                zc[j] = c;
            }

            if (c) {
                ++e;
            } else {
                zc.shift();
            }

            return normalise( y, zc, e );
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
         * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toDigits() precision out of range: {sd}'
         * 'toDigits() precision not an integer: {sd}'
         * 'toDigits() rounding mode not an integer: {rm}'
         * 'toDigits() rounding mode out of range: {rm}'
         */
        P.toDigits = function ( sd, rm ) {
            var n = new BigNumber(this);
            sd = sd == null || !isValidInt( sd, 1, MAX, 18, 'precision' ) ? null : sd | 0;
            rm = rm == null || !isValidInt( rm, 0, 8, 18, roundingMode ) ? ROUNDING_MODE : rm | 0;
            return sd ? round( n, sd, rm ) : n;
        };


        /*
         * Return a string representing the value of this BigNumber in exponential notation and
         * rounded using ROUNDING_MODE to dp fixed decimal places.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toExponential() decimal places not an integer: {dp}'
         * 'toExponential() decimal places out of range: {dp}'
         * 'toExponential() rounding mode not an integer: {rm}'
         * 'toExponential() rounding mode out of range: {rm}'
         */
        P.toExponential = function ( dp, rm ) {
            return format( this,
              dp != null && isValidInt( dp, 0, MAX, 19 ) ? ~~dp + 1 : null, rm, 19 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounding
         * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
         *
         * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
         * but e.g. (-0.00001).toFixed(0) is '-0'.
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFixed() decimal places not an integer: {dp}'
         * 'toFixed() decimal places out of range: {dp}'
         * 'toFixed() rounding mode not an integer: {rm}'
         * 'toFixed() rounding mode out of range: {rm}'
         */
        P.toFixed = function ( dp, rm ) {
            return format( this, dp != null && isValidInt( dp, 0, MAX, 20 )
              ? ~~dp + this.e + 1 : null, rm, 20 );
        };


        /*
         * Return a string representing the value of this BigNumber in fixed-point notation rounded
         * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
         * of the FORMAT object (see BigNumber.config).
         *
         * FORMAT = {
         *      decimalSeparator : '.',
         *      groupSeparator : ',',
         *      groupSize : 3,
         *      secondaryGroupSize : 0,
         *      fractionGroupSeparator : '\xA0',    // non-breaking space
         *      fractionGroupSize : 0
         * };
         *
         * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toFormat() decimal places not an integer: {dp}'
         * 'toFormat() decimal places out of range: {dp}'
         * 'toFormat() rounding mode not an integer: {rm}'
         * 'toFormat() rounding mode out of range: {rm}'
         */
        P.toFormat = function ( dp, rm ) {
            var str = format( this, dp != null && isValidInt( dp, 0, MAX, 21 )
              ? ~~dp + this.e + 1 : null, rm, 21 );

            if ( this.c ) {
                var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                if ( g1 > 0 && len > 0 ) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr( 0, i );

                    for ( ; i < len; i += g1 ) {
                        intPart += groupSeparator + intDigits.substr( i, g1 );
                    }

                    if ( g2 > 0 ) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                }

                str = fractionPart
                  ? intPart + FORMAT.decimalSeparator + ( ( g2 = +FORMAT.fractionGroupSize )
                    ? fractionPart.replace( new RegExp( '\\d{' + g2 + '}\\B', 'g' ),
                      '$&' + FORMAT.fractionGroupSeparator )
                    : fractionPart )
                  : intPart;
            }

            return str;
        };


        /*
         * Return a string array representing the value of this BigNumber as a simple fraction with
         * an integer numerator and an integer denominator. The denominator will be a positive
         * non-zero value less than or equal to the specified maximum denominator. If a maximum
         * denominator is not specified, the denominator will be the lowest value necessary to
         * represent the number exactly.
         *
         * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
         *
         * 'toFraction() max denominator not an integer: {md}'
         * 'toFraction() max denominator out of range: {md}'
         */
        P.toFraction = function (md) {
            var arr, d0, d2, e, exp, n, n0, q, s,
                k = ERRORS,
                x = this,
                xc = x.c,
                d = new BigNumber(ONE),
                n1 = d0 = new BigNumber(ONE),
                d1 = n0 = new BigNumber(ONE);

            if ( md != null ) {
                ERRORS = false;
                n = new BigNumber(md);
                ERRORS = k;

                if ( !( k = n.isInt() ) || n.lt(ONE) ) {

                    if (ERRORS) {
                        raise( 22,
                          'max denominator ' + ( k ? 'out of range' : 'not an integer' ), md );
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round( n, n.e + 1, 1 ).gte(ONE) ? n : null;
                }
            }

            if ( !xc ) return x.toString();
            s = coeffToString(xc);

            // Determine initial denominator.
            // d is a power of 10 and the minimum max denominator that specifies the value exactly.
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[ ( exp = e % LOG_BASE ) < 0 ? LOG_BASE + exp : exp ];
            md = !md || n.cmp(d) > 0 ? ( e > 0 ? d : n1 ) : n;

            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber(s);

            // n0 = d1 = 0
            n0.c[0] = 0;

            for ( ; ; )  {
                q = div( n, d, 0, 1 );
                d2 = d0.plus( q.times(d1) );
                if ( d2.cmp(md) == 1 ) break;
                d0 = d1;
                d1 = d2;
                n1 = n0.plus( q.times( d2 = n1 ) );
                n0 = d2;
                d = n.minus( q.times( d2 = d ) );
                n = d2;
            }

            d2 = div( md.minus(d0), d1, 0, 1 );
            n0 = n0.plus( d2.times(n1) );
            d0 = d0.plus( d2.times(d1) );
            n0.s = n1.s = x.s;
            e *= 2;

            // Determine which fraction is closer to x, n0/d0 or n1/d1
            arr = div( n1, d1, e, ROUNDING_MODE ).minus(x).abs().cmp(
                  div( n0, d0, e, ROUNDING_MODE ).minus(x).abs() ) < 1
                    ? [ n1.toString(), d1.toString() ]
                    : [ n0.toString(), d0.toString() ];

            MAX_EXP = exp;
            return arr;
        };


        /*
         * Return the value of this BigNumber converted to a number primitive.
         */
        P.toNumber = function () {
            var x = this;

            // Ensure zero has correct sign.
            return +x || ( x.s ? x.s * 0 : NaN );
        };


        /*
         * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
         * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
         * If POW_PRECISION is not 0, round to POW_PRECISION using ROUNDING_MODE.
         *
         * n {number} Integer, -9007199254740992 to 9007199254740992 inclusive.
         * (Performs 54 loop iterations for n of 9007199254740992.)
         *
         * 'pow() exponent not an integer: {n}'
         * 'pow() exponent out of range: {n}'
         */
        P.toPower = P.pow = function (n) {
            var k, y,
                i = mathfloor( n < 0 ? -n : +n ),
                x = this;

            // Pass Infinity to Math.pow if exponent is out of range.
            if ( !isValidInt( n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent' ) &&
              ( !isFinite(n) || i > MAX_SAFE_INTEGER && ( n /= 0 ) ||
                parseFloat(n) != n && !( n = NaN ) ) ) {
                return new BigNumber( Math.pow( +x, n ) );
            }

            // Truncating each coefficient array to a length of k after each multiplication equates
            // to truncating significant digits to POW_PRECISION + [28, 41], i.e. there will be a
            // minimum of 28 guard digits retained. (Using + 1.5 would give [9, 21] guard digits.)
            k = POW_PRECISION ? mathceil( POW_PRECISION / LOG_BASE + 2 ) : 0;
            y = new BigNumber(ONE);

            for ( ; ; ) {

                if ( i % 2 ) {
                    y = y.times(x);
                    if ( !y.c ) break;
                    if ( k && y.c.length > k ) y.c.length = k;
                }

                i = mathfloor( i / 2 );
                if ( !i ) break;

                x = x.times(x);
                if ( k && x.c && x.c.length > k ) x.c.length = k;
            }

            if ( n < 0 ) y = ONE.div(y);
            return k ? round( y, POW_PRECISION, ROUNDING_MODE ) : y;
        };


        /*
         * Return a string representing the value of this BigNumber rounded to sd significant digits
         * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
         * necessary to represent the integer part of the value in fixed-point notation, then use
         * exponential notation.
         *
         * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
         * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
         *
         * 'toPrecision() precision not an integer: {sd}'
         * 'toPrecision() precision out of range: {sd}'
         * 'toPrecision() rounding mode not an integer: {rm}'
         * 'toPrecision() rounding mode out of range: {rm}'
         */
        P.toPrecision = function ( sd, rm ) {
            return format( this, sd != null && isValidInt( sd, 1, MAX, 24, 'precision' )
              ? sd | 0 : null, rm, 24 );
        };


        /*
         * Return a string representing the value of this BigNumber in base b, or base 10 if b is
         * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
         * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
         * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
         * TO_EXP_NEG, return exponential notation.
         *
         * [b] {number} Integer, 2 to 64 inclusive.
         *
         * 'toString() base not an integer: {b}'
         * 'toString() base out of range: {b}'
         */
        P.toString = function (b) {
            var str,
                n = this,
                s = n.s,
                e = n.e;

            // Infinity or NaN?
            if ( e === null ) {

                if (s) {
                    str = 'Infinity';
                    if ( s < 0 ) str = '-' + str;
                } else {
                    str = 'NaN';
                }
            } else {
                str = coeffToString( n.c );

                if ( b == null || !isValidInt( b, 2, 64, 25, 'base' ) ) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential( str, e )
                      : toFixedPoint( str, e );
                } else {
                    str = convertBase( toFixedPoint( str, e ), b | 0, 10, s );
                }

                if ( s < 0 && n.c[0] ) str = '-' + str;
            }

            return str;
        };


        /*
         * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
         * number.
         */
        P.truncated = P.trunc = function () {
            return round( new BigNumber(this), this.e + 1, 1 );
        };



        /*
         * Return as toString, but do not accept a base argument.
         */
        P.valueOf = P.toJSON = function () {
            return this.toString();
        };


        // Aliases for BigDecimal methods.
        //P.add = P.plus;         // P.add included above
        //P.subtract = P.minus;   // P.sub included above
        //P.multiply = P.times;   // P.mul included above
        //P.divide = P.div;
        //P.remainder = P.mod;
        //P.compareTo = P.cmp;
        //P.negate = P.neg;


        if ( configObj != null ) BigNumber.config(configObj);

        return BigNumber;
    }


    // PRIVATE HELPER FUNCTIONS


    function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
    }


    // Return a coefficient array as a string of base 10 digits.
    function coeffToString(a) {
        var s, z,
            i = 1,
            j = a.length,
            r = a[0] + '';

        for ( ; i < j; ) {
            s = a[i++] + '';
            z = LOG_BASE - s.length;
            for ( ; z--; s = '0' + s );
            r += s;
        }

        // Determine trailing zeros.
        for ( j = r.length; r.charCodeAt(--j) === 48; );
        return r.slice( 0, j + 1 || 1 );
    }


    // Compare the value of BigNumbers x and y.
    function compare( x, y ) {
        var a, b,
            xc = x.c,
            yc = y.c,
            i = x.s,
            j = y.s,
            k = x.e,
            l = y.e;

        // Either NaN?
        if ( !i || !j ) return null;

        a = xc && !xc[0];
        b = yc && !yc[0];

        // Either zero?
        if ( a || b ) return a ? b ? 0 : -j : i;

        // Signs differ?
        if ( i != j ) return i;

        a = i < 0;
        b = k == l;

        // Either Infinity?
        if ( !xc || !yc ) return b ? 0 : !xc ^ a ? 1 : -1;

        // Compare exponents.
        if ( !b ) return k > l ^ a ? 1 : -1;

        j = ( k = xc.length ) < ( l = yc.length ) ? k : l;

        // Compare digit by digit.
        for ( i = 0; i < j; i++ ) if ( xc[i] != yc[i] ) return xc[i] > yc[i] ^ a ? 1 : -1;

        // Compare lengths.
        return k == l ? 0 : k > l ^ a ? 1 : -1;
    }


    /*
     * Return true if n is a valid number in range, otherwise false.
     * Use for argument validation when ERRORS is false.
     * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
     */
    function intValidatorNoErrors( n, min, max ) {
        return ( n = truncate(n) ) >= min && n <= max;
    }


    function isArray(obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
    }


    /*
     * Convert string of baseIn to an array of numbers of baseOut.
     * Eg. convertBase('255', 10, 16) returns [15, 15].
     * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
     */
    function toBaseOut( str, baseIn, baseOut ) {
        var j,
            arr = [0],
            arrL,
            i = 0,
            len = str.length;

        for ( ; i < len; ) {
            for ( arrL = arr.length; arrL--; arr[arrL] *= baseIn );
            arr[ j = 0 ] += ALPHABET.indexOf( str.charAt( i++ ) );

            for ( ; j < arr.length; j++ ) {

                if ( arr[j] > baseOut - 1 ) {
                    if ( arr[j + 1] == null ) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                }
            }
        }

        return arr.reverse();
    }


    function toExponential( str, e ) {
        return ( str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str ) +
          ( e < 0 ? 'e' : 'e+' ) + e;
    }


    function toFixedPoint( str, e ) {
        var len, z;

        // Negative exponent?
        if ( e < 0 ) {

            // Prepend zeros.
            for ( z = '0.'; ++e; z += '0' );
            str = z + str;

        // Positive exponent
        } else {
            len = str.length;

            // Append zeros.
            if ( ++e > len ) {
                for ( z = '0', e -= len; --e; z += '0' );
                str += z;
            } else if ( e < len ) {
                str = str.slice( 0, e ) + '.' + str.slice(e);
            }
        }

        return str;
    }


    function truncate(n) {
        n = parseFloat(n);
        return n < 0 ? mathceil(n) : mathfloor(n);
    }


    // EXPORT


    BigNumber = another();

    // AMD.
    if ( typeof define == 'function' && define.amd ) {
        define( function () { return BigNumber; } );

    // Node and other environments that support module.exports.
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = BigNumber;
        if ( !crypto ) try { crypto = require('crypto'); } catch (e) {}

    // Browser.
    } else {
        global.BigNumber = BigNumber;
    }
})(this);

      };
    };
  }
}, {package:"@metamask/controllers>web3>bignumber.js",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\utf8\\utf8.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\node_modules\utf8\utf8.js
      return function (require, module, exports) {
/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, its not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

      };
    };
  }
}, {package:"@metamask/controllers>web3>utf8",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\webextension-polyfill\dist\browser-polyfill.js
      return function (require, module, exports) {
(function (global, factory) {
  if (typeof define === "function" && define.amd) {
    define("webextension-polyfill", ["module"], factory);
  } else if (typeof exports !== "undefined") {
    factory(module);
  } else {
    var mod = {
      exports: {}
    };
    factory(mod);
    global.browser = mod.exports;
  }
})(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
  /* webextension-polyfill - v0.8.0 - Tue Apr 20 2021 11:27:38 */

  /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

  /* vim: set sts=2 sw=2 et tw=80: */

  /* This Source Code Form is subject to the terms of the Mozilla Public
   * License, v. 2.0. If a copy of the MPL was not distributed with this
   * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  "use strict";

  if (typeof browser === "undefined" || Object.getPrototypeOf(browser) !== Object.prototype) {
    const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
    const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
    // optimization for Firefox. Since Spidermonkey does not fully parse the
    // contents of a function until the first time it's called, and since it will
    // never actually need to be called, this allows the polyfill to be included
    // in Firefox nearly for free.

    const wrapAPIs = extensionAPIs => {
      // NOTE: apiMetadata is associated to the content of the api-metadata.json file
      // at build time by replacing the following "include" with the content of the
      // JSON file.
      const apiMetadata = {
        "alarms": {
          "clear": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "clearAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "get": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "bookmarks": {
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getChildren": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getRecent": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getSubTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTree": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeTree": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "browserAction": {
          "disable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "enable": {
            "minArgs": 0,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "getBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getBadgeText": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "openPopup": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setBadgeBackgroundColor": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setBadgeText": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "browsingData": {
          "remove": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "removeCache": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCookies": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeDownloads": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFormData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeHistory": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeLocalStorage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePasswords": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removePluginData": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "settings": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "commands": {
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "contextMenus": {
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "cookies": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAllCookieStores": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "set": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "devtools": {
          "inspectedWindow": {
            "eval": {
              "minArgs": 1,
              "maxArgs": 2,
              "singleCallbackArg": false
            }
          },
          "panels": {
            "create": {
              "minArgs": 3,
              "maxArgs": 3,
              "singleCallbackArg": true
            },
            "elements": {
              "createSidebarPane": {
                "minArgs": 1,
                "maxArgs": 1
              }
            }
          }
        },
        "downloads": {
          "cancel": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "download": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "erase": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFileIcon": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "open": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "pause": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeFile": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "resume": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "extension": {
          "isAllowedFileSchemeAccess": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "isAllowedIncognitoAccess": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "history": {
          "addUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "deleteRange": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "deleteUrl": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getVisits": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "search": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "i18n": {
          "detectLanguage": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAcceptLanguages": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "identity": {
          "launchWebAuthFlow": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "idle": {
          "queryState": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "management": {
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getSelf": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "setEnabled": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "uninstallSelf": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "notifications": {
          "clear": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPermissionLevel": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        },
        "pageAction": {
          "getPopup": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getTitle": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "hide": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setIcon": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "setPopup": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "setTitle": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          },
          "show": {
            "minArgs": 1,
            "maxArgs": 1,
            "fallbackToNoCallback": true
          }
        },
        "permissions": {
          "contains": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "request": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "runtime": {
          "getBackgroundPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getPlatformInfo": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "openOptionsPage": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "requestUpdateCheck": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "sendMessage": {
            "minArgs": 1,
            "maxArgs": 3
          },
          "sendNativeMessage": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "setUninstallURL": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "sessions": {
          "getDevices": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getRecentlyClosed": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "restore": {
            "minArgs": 0,
            "maxArgs": 1
          }
        },
        "storage": {
          "local": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          },
          "managed": {
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            }
          },
          "sync": {
            "clear": {
              "minArgs": 0,
              "maxArgs": 0
            },
            "get": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "getBytesInUse": {
              "minArgs": 0,
              "maxArgs": 1
            },
            "remove": {
              "minArgs": 1,
              "maxArgs": 1
            },
            "set": {
              "minArgs": 1,
              "maxArgs": 1
            }
          }
        },
        "tabs": {
          "captureVisibleTab": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "create": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "detectLanguage": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "discard": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "duplicate": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "executeScript": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 0
          },
          "getZoom": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getZoomSettings": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goBack": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "goForward": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "highlight": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "insertCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "move": {
            "minArgs": 2,
            "maxArgs": 2
          },
          "query": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "reload": {
            "minArgs": 0,
            "maxArgs": 2
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "removeCSS": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "sendMessage": {
            "minArgs": 2,
            "maxArgs": 3
          },
          "setZoom": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "setZoomSettings": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "update": {
            "minArgs": 1,
            "maxArgs": 2
          }
        },
        "topSites": {
          "get": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "webNavigation": {
          "getAllFrames": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "getFrame": {
            "minArgs": 1,
            "maxArgs": 1
          }
        },
        "webRequest": {
          "handlerBehaviorChanged": {
            "minArgs": 0,
            "maxArgs": 0
          }
        },
        "windows": {
          "create": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "get": {
            "minArgs": 1,
            "maxArgs": 2
          },
          "getAll": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getCurrent": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "getLastFocused": {
            "minArgs": 0,
            "maxArgs": 1
          },
          "remove": {
            "minArgs": 1,
            "maxArgs": 1
          },
          "update": {
            "minArgs": 2,
            "maxArgs": 2
          }
        }
      };

      if (Object.keys(apiMetadata).length === 0) {
        throw new Error("api-metadata.json has not been included in browser-polyfill");
      }
      /**
       * A WeakMap subclass which creates and stores a value for any key which does
       * not exist when accessed, but behaves exactly as an ordinary WeakMap
       * otherwise.
       *
       * @param {function} createItem
       *        A function which will be called in order to create the value for any
       *        key which does not exist, the first time it is accessed. The
       *        function receives, as its only argument, the key being created.
       */


      class DefaultWeakMap extends WeakMap {
        constructor(createItem, items = undefined) {
          super(items);
          this.createItem = createItem;
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.createItem(key));
          }

          return super.get(key);
        }

      }
      /**
       * Returns true if the given object is an object with a `then` method, and can
       * therefore be assumed to behave as a Promise.
       *
       * @param {*} value The value to test.
       * @returns {boolean} True if the value is thenable.
       */


      const isThenable = value => {
        return value && typeof value === "object" && typeof value.then === "function";
      };
      /**
       * Creates and returns a function which, when called, will resolve or reject
       * the given promise based on how it is called:
       *
       * - If, when called, `chrome.runtime.lastError` contains a non-null object,
       *   the promise is rejected with that value.
       * - If the function is called with exactly one argument, the promise is
       *   resolved to that value.
       * - Otherwise, the promise is resolved to an array containing all of the
       *   function's arguments.
       *
       * @param {object} promise
       *        An object containing the resolution and rejection functions of a
       *        promise.
       * @param {function} promise.resolve
       *        The promise's resolution function.
       * @param {function} promise.reject
       *        The promise's rejection function.
       * @param {object} metadata
       *        Metadata about the wrapped method which has created the callback.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function}
       *        The generated callback function.
       */


      const makeCallback = (promise, metadata) => {
        return (...callbackArgs) => {
          if (extensionAPIs.runtime.lastError) {
            promise.reject(new Error(extensionAPIs.runtime.lastError.message));
          } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
            promise.resolve(callbackArgs[0]);
          } else {
            promise.resolve(callbackArgs);
          }
        };
      };

      const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
      /**
       * Creates a wrapper function for a method with the given name and metadata.
       *
       * @param {string} name
       *        The name of the method which is being wrapped.
       * @param {object} metadata
       *        Metadata about the method being wrapped.
       * @param {integer} metadata.minArgs
       *        The minimum number of arguments which must be passed to the
       *        function. If called with fewer than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {integer} metadata.maxArgs
       *        The maximum number of arguments which may be passed to the
       *        function. If called with more than this number of arguments, the
       *        wrapper will raise an exception.
       * @param {boolean} metadata.singleCallbackArg
       *        Whether or not the promise is resolved with only the first
       *        argument of the callback, alternatively an array of all the
       *        callback arguments is resolved. By default, if the callback
       *        function is invoked with only a single argument, that will be
       *        resolved to the promise, while all arguments will be resolved as
       *        an array if multiple are given.
       *
       * @returns {function(object, ...*)}
       *       The generated wrapper function.
       */


      const wrapAsyncFunction = (name, metadata) => {
        return function asyncFunctionWrapper(target, ...args) {
          if (args.length < metadata.minArgs) {
            throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
          }

          if (args.length > metadata.maxArgs) {
            throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
          }

          return new Promise((resolve, reject) => {
            if (metadata.fallbackToNoCallback) {
              // This API method has currently no callback on Chrome, but it return a promise on Firefox,
              // and so the polyfill will try to call it with a callback first, and it will fallback
              // to not passing the callback if the first call fails.
              try {
                target[name](...args, makeCallback({
                  resolve,
                  reject
                }, metadata));
              } catch (cbError) {
                console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                // use the unsupported callback anymore.

                metadata.fallbackToNoCallback = false;
                metadata.noCallback = true;
                resolve();
              }
            } else if (metadata.noCallback) {
              target[name](...args);
              resolve();
            } else {
              target[name](...args, makeCallback({
                resolve,
                reject
              }, metadata));
            }
          });
        };
      };
      /**
       * Wraps an existing method of the target object, so that calls to it are
       * intercepted by the given wrapper function. The wrapper function receives,
       * as its first argument, the original `target` object, followed by each of
       * the arguments passed to the original method.
       *
       * @param {object} target
       *        The original target object that the wrapped method belongs to.
       * @param {function} method
       *        The method being wrapped. This is used as the target of the Proxy
       *        object which is created to wrap the method.
       * @param {function} wrapper
       *        The wrapper function which is called in place of a direct invocation
       *        of the wrapped method.
       *
       * @returns {Proxy<function>}
       *        A Proxy object for the given method, which invokes the given wrapper
       *        method in its place.
       */


      const wrapMethod = (target, method, wrapper) => {
        return new Proxy(method, {
          apply(targetMethod, thisObj, args) {
            return wrapper.call(thisObj, target, ...args);
          }

        });
      };

      let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
      /**
       * Wraps an object in a Proxy which intercepts and wraps certain methods
       * based on the given `wrappers` and `metadata` objects.
       *
       * @param {object} target
       *        The target object to wrap.
       *
       * @param {object} [wrappers = {}]
       *        An object tree containing wrapper functions for special cases. Any
       *        function present in this object tree is called in place of the
       *        method in the same location in the `target` object tree. These
       *        wrapper methods are invoked as described in {@see wrapMethod}.
       *
       * @param {object} [metadata = {}]
       *        An object tree containing metadata used to automatically generate
       *        Promise-based wrapper functions for asynchronous. Any function in
       *        the `target` object tree which has a corresponding metadata object
       *        in the same location in the `metadata` tree is replaced with an
       *        automatically-generated wrapper function, as described in
       *        {@see wrapAsyncFunction}
       *
       * @returns {Proxy<object>}
       */

      const wrapObject = (target, wrappers = {}, metadata = {}) => {
        let cache = Object.create(null);
        let handlers = {
          has(proxyTarget, prop) {
            return prop in target || prop in cache;
          },

          get(proxyTarget, prop, receiver) {
            if (prop in cache) {
              return cache[prop];
            }

            if (!(prop in target)) {
              return undefined;
            }

            let value = target[prop];

            if (typeof value === "function") {
              // This is a method on the underlying object. Check if we need to do
              // any wrapping.
              if (typeof wrappers[prop] === "function") {
                // We have a special-case wrapper for this method.
                value = wrapMethod(target, target[prop], wrappers[prop]);
              } else if (hasOwnProperty(metadata, prop)) {
                // This is an async method that we have metadata for. Create a
                // Promise wrapper for it.
                let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                value = wrapMethod(target, target[prop], wrapper);
              } else {
                // This is a method that we don't know or care about. Return the
                // original method, bound to the underlying object.
                value = value.bind(target);
              }
            } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
              // This is an object that we need to do some wrapping for the children
              // of. Create a sub-object wrapper for it with the appropriate child
              // metadata.
              value = wrapObject(value, wrappers[prop], metadata[prop]);
            } else if (hasOwnProperty(metadata, "*")) {
              // Wrap all properties in * namespace.
              value = wrapObject(value, wrappers[prop], metadata["*"]);
            } else {
              // We don't need to do any wrapping for this property,
              // so just forward all access to the underlying object.
              Object.defineProperty(cache, prop, {
                configurable: true,
                enumerable: true,

                get() {
                  return target[prop];
                },

                set(value) {
                  target[prop] = value;
                }

              });
              return value;
            }

            cache[prop] = value;
            return value;
          },

          set(proxyTarget, prop, value, receiver) {
            if (prop in cache) {
              cache[prop] = value;
            } else {
              target[prop] = value;
            }

            return true;
          },

          defineProperty(proxyTarget, prop, desc) {
            return Reflect.defineProperty(cache, prop, desc);
          },

          deleteProperty(proxyTarget, prop) {
            return Reflect.deleteProperty(cache, prop);
          }

        }; // Per contract of the Proxy API, the "get" proxy handler must return the
        // original value of the target if that value is declared read-only and
        // non-configurable. For this reason, we create an object with the
        // prototype set to `target` instead of using `target` directly.
        // Otherwise we cannot return a custom object for APIs that
        // are declared read-only and non-configurable, such as `chrome.devtools`.
        //
        // The proxy handlers themselves will still use the original `target`
        // instead of the `proxyTarget`, so that the methods and properties are
        // dereferenced via the original targets.

        let proxyTarget = Object.create(target);
        return new Proxy(proxyTarget, handlers);
      };
      /**
       * Creates a set of wrapper functions for an event object, which handles
       * wrapping of listener functions that those messages are passed.
       *
       * A single wrapper is created for each listener function, and stored in a
       * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
       * retrieve the original wrapper, so that  attempts to remove a
       * previously-added listener work as expected.
       *
       * @param {DefaultWeakMap<function, function>} wrapperMap
       *        A DefaultWeakMap object which will create the appropriate wrapper
       *        for a given listener function when one does not exist, and retrieve
       *        an existing one when it does.
       *
       * @returns {object}
       */


      const wrapEvent = wrapperMap => ({
        addListener(target, listener, ...args) {
          target.addListener(wrapperMap.get(listener), ...args);
        },

        hasListener(target, listener) {
          return target.hasListener(wrapperMap.get(listener));
        },

        removeListener(target, listener) {
          target.removeListener(wrapperMap.get(listener));
        }

      });

      const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps an onRequestFinished listener function so that it will return a
         * `getContent()` property which returns a `Promise` rather than using a
         * callback API.
         *
         * @param {object} req
         *        The HAR entry object representing the network request.
         */


        return function onRequestFinished(req) {
          const wrappedReq = wrapObject(req, {}
          /* wrappers */
          , {
            getContent: {
              minArgs: 0,
              maxArgs: 0
            }
          });
          listener(wrappedReq);
        };
      }); // Keep track if the deprecation warning has been logged at least once.

      let loggedSendResponseDeprecationWarning = false;
      const onMessageWrappers = new DefaultWeakMap(listener => {
        if (typeof listener !== "function") {
          return listener;
        }
        /**
         * Wraps a message listener function so that it may send responses based on
         * its return value, rather than by returning a sentinel value and calling a
         * callback. If the listener function returns a Promise, the response is
         * sent when the promise either resolves or rejects.
         *
         * @param {*} message
         *        The message sent by the other end of the channel.
         * @param {object} sender
         *        Details about the sender of the message.
         * @param {function(*)} sendResponse
         *        A callback which, when called with an arbitrary argument, sends
         *        that value as a response.
         * @returns {boolean}
         *        True if the wrapped listener returned a Promise, which will later
         *        yield a response. False otherwise.
         */


        return function onMessage(message, sender, sendResponse) {
          let didCallSendResponse = false;
          let wrappedSendResponse;
          let sendResponsePromise = new Promise(resolve => {
            wrappedSendResponse = function (response) {
              if (!loggedSendResponseDeprecationWarning) {
                console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                loggedSendResponseDeprecationWarning = true;
              }

              didCallSendResponse = true;
              resolve(response);
            };
          });
          let result;

          try {
            result = listener(message, sender, wrappedSendResponse);
          } catch (err) {
            result = Promise.reject(err);
          }

          const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
          // wrappedSendResponse synchronously, we can exit earlier
          // because there will be no response sent from this listener.

          if (result !== true && !isResultThenable && !didCallSendResponse) {
            return false;
          } // A small helper to send the message if the promise resolves
          // and an error if the promise rejects (a wrapped sendMessage has
          // to translate the message into a resolved promise or a rejected
          // promise).


          const sendPromisedResult = promise => {
            promise.then(msg => {
              // send the message value.
              sendResponse(msg);
            }, error => {
              // Send a JSON representation of the error if the rejected value
              // is an instance of error, or the object itself otherwise.
              let message;

              if (error && (error instanceof Error || typeof error.message === "string")) {
                message = error.message;
              } else {
                message = "An unexpected error occurred";
              }

              sendResponse({
                __mozWebExtensionPolyfillReject__: true,
                message
              });
            }).catch(err => {
              // Print an error on the console if unable to send the response.
              console.error("Failed to send onMessage rejected reply", err);
            });
          }; // If the listener returned a Promise, send the resolved value as a
          // result, otherwise wait the promise related to the wrappedSendResponse
          // callback to resolve and send it as a response.


          if (isResultThenable) {
            sendPromisedResult(result);
          } else {
            sendPromisedResult(sendResponsePromise);
          } // Let Chrome know that the listener is replying.


          return true;
        };
      });

      const wrappedSendMessageCallback = ({
        reject,
        resolve
      }, reply) => {
        if (extensionAPIs.runtime.lastError) {
          // Detect when none of the listeners replied to the sendMessage call and resolve
          // the promise to undefined as in Firefox.
          // See https://github.com/mozilla/webextension-polyfill/issues/130
          if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
            resolve();
          } else {
            reject(new Error(extensionAPIs.runtime.lastError.message));
          }
        } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
          // Convert back the JSON representation of the error into
          // an Error instance.
          reject(new Error(reply.message));
        } else {
          resolve(reply);
        }
      };

      const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
        if (args.length < metadata.minArgs) {
          throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
        }

        if (args.length > metadata.maxArgs) {
          throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
        }

        return new Promise((resolve, reject) => {
          const wrappedCb = wrappedSendMessageCallback.bind(null, {
            resolve,
            reject
          });
          args.push(wrappedCb);
          apiNamespaceObj.sendMessage(...args);
        });
      };

      const staticWrappers = {
        devtools: {
          network: {
            onRequestFinished: wrapEvent(onRequestFinishedWrappers)
          }
        },
        runtime: {
          onMessage: wrapEvent(onMessageWrappers),
          onMessageExternal: wrapEvent(onMessageWrappers),
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 1,
            maxArgs: 3
          })
        },
        tabs: {
          sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
            minArgs: 2,
            maxArgs: 3
          })
        }
      };
      const settingMetadata = {
        clear: {
          minArgs: 1,
          maxArgs: 1
        },
        get: {
          minArgs: 1,
          maxArgs: 1
        },
        set: {
          minArgs: 1,
          maxArgs: 1
        }
      };
      apiMetadata.privacy = {
        network: {
          "*": settingMetadata
        },
        services: {
          "*": settingMetadata
        },
        websites: {
          "*": settingMetadata
        }
      };
      return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
    };

    if (typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
      throw new Error("This script should only be loaded in a browser extension.");
    } // The build process adds a UMD wrapper around this file, which makes the
    // `module` variable available.


    module.exports = wrapAPIs(chrome);
  } else {
    module.exports = browser;
  }
});
//# sourceMappingURL=browser-polyfill.js.map

      };
    };
  }
}, {package:"webextension-polyfill",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\whatwg-fetch\\dist\\fetch.umd.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\whatwg-fetch\dist\fetch.umd.js
      return function (require, module, exports) {
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (factory((global.WHATWGFetch = {})));
}(this, (function (exports) { 'use strict';

  var global =
    (typeof globalThis !== 'undefined' && globalThis) ||
    (typeof self !== 'undefined' && self) ||
    (typeof global !== 'undefined' && global);

  var support = {
    searchParams: 'URLSearchParams' in global,
    iterable: 'Symbol' in global && 'iterator' in Symbol,
    blob:
      'FileReader' in global &&
      'Blob' in global &&
      (function() {
        try {
          new Blob();
          return true
        } catch (e) {
          return false
        }
      })(),
    formData: 'FormData' in global,
    arrayBuffer: 'ArrayBuffer' in global
  };

  function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj)
  }

  if (support.arrayBuffer) {
    var viewClasses = [
      '[object Int8Array]',
      '[object Uint8Array]',
      '[object Uint8ClampedArray]',
      '[object Int16Array]',
      '[object Uint16Array]',
      '[object Int32Array]',
      '[object Uint32Array]',
      '[object Float32Array]',
      '[object Float64Array]'
    ];

    var isArrayBufferView =
      ArrayBuffer.isView ||
      function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
      };
  }

  function normalizeName(name) {
    if (typeof name !== 'string') {
      name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
      throw new TypeError('Invalid character in header field name: "' + name + '"')
    }
    return name.toLowerCase()
  }

  function normalizeValue(value) {
    if (typeof value !== 'string') {
      value = String(value);
    }
    return value
  }

  // Build a destructive iterator for the value list
  function iteratorFor(items) {
    var iterator = {
      next: function() {
        var value = items.shift();
        return {done: value === undefined, value: value}
      }
    };

    if (support.iterable) {
      iterator[Symbol.iterator] = function() {
        return iterator
      };
    }

    return iterator
  }

  function Headers(headers) {
    this.map = {};

    if (headers instanceof Headers) {
      headers.forEach(function(value, name) {
        this.append(name, value);
      }, this);
    } else if (Array.isArray(headers)) {
      headers.forEach(function(header) {
        this.append(header[0], header[1]);
      }, this);
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function(name) {
        this.append(name, headers[name]);
      }, this);
    }
  }

  Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ', ' + value : value;
  };

  Headers.prototype['delete'] = function(name) {
    delete this.map[normalizeName(name)];
  };

  Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null
  };

  Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name))
  };

  Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
  };

  Headers.prototype.forEach = function(callback, thisArg) {
    for (var name in this.map) {
      if (this.map.hasOwnProperty(name)) {
        callback.call(thisArg, this.map[name], name, this);
      }
    }
  };

  Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push(name);
    });
    return iteratorFor(items)
  };

  Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
      items.push(value);
    });
    return iteratorFor(items)
  };

  Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
      items.push([name, value]);
    });
    return iteratorFor(items)
  };

  if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
  }

  function consumed(body) {
    if (body.bodyUsed) {
      return Promise.reject(new TypeError('Already read'))
    }
    body.bodyUsed = true;
  }

  function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
      reader.onload = function() {
        resolve(reader.result);
      };
      reader.onerror = function() {
        reject(reader.error);
      };
    })
  }

  function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise
  }

  function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsText(blob);
    return promise
  }

  function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);

    for (var i = 0; i < view.length; i++) {
      chars[i] = String.fromCharCode(view[i]);
    }
    return chars.join('')
  }

  function bufferClone(buf) {
    if (buf.slice) {
      return buf.slice(0)
    } else {
      var view = new Uint8Array(buf.byteLength);
      view.set(new Uint8Array(buf));
      return view.buffer
    }
  }

  function Body() {
    this.bodyUsed = false;

    this._initBody = function(body) {
      /*
        fetch-mock wraps the Response object in an ES6 Proxy to
        provide useful test harness features such as flush. However, on
        ES5 browsers without fetch or Proxy support pollyfills must be used;
        the proxy-pollyfill is unable to proxy an attribute unless it exists
        on the object before the Proxy is created. This change ensures
        Response.bodyUsed exists on the instance, while maintaining the
        semantic of setting Request.bodyUsed in the constructor before
        _initBody is called.
      */
      this.bodyUsed = this.bodyUsed;
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
        this._bodyBlob = body;
      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
        this._bodyFormData = body;
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this._bodyText = body.toString();
      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
        this._bodyArrayBuffer = bufferClone(body.buffer);
        // IE 10-11 can't handle a DataView body.
        this._bodyInit = new Blob([this._bodyArrayBuffer]);
      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
        this._bodyArrayBuffer = bufferClone(body);
      } else {
        this._bodyText = body = Object.prototype.toString.call(body);
      }

      if (!this.headers.get('content-type')) {
        if (typeof body === 'string') {
          this.headers.set('content-type', 'text/plain;charset=UTF-8');
        } else if (this._bodyBlob && this._bodyBlob.type) {
          this.headers.set('content-type', this._bodyBlob.type);
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
        }
      }
    };

    if (support.blob) {
      this.blob = function() {
        var rejected = consumed(this);
        if (rejected) {
          return rejected
        }

        if (this._bodyBlob) {
          return Promise.resolve(this._bodyBlob)
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as blob')
        } else {
          return Promise.resolve(new Blob([this._bodyText]))
        }
      };

      this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
          var isConsumed = consumed(this);
          if (isConsumed) {
            return isConsumed
          }
          if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
            return Promise.resolve(
              this._bodyArrayBuffer.buffer.slice(
                this._bodyArrayBuffer.byteOffset,
                this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
              )
            )
          } else {
            return Promise.resolve(this._bodyArrayBuffer)
          }
        } else {
          return this.blob().then(readBlobAsArrayBuffer)
        }
      };
    }

    this.text = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return readBlobAsText(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as text')
      } else {
        return Promise.resolve(this._bodyText)
      }
    };

    if (support.formData) {
      this.formData = function() {
        return this.text().then(decode)
      };
    }

    this.json = function() {
      return this.text().then(JSON.parse)
    };

    return this
  }

  // HTTP methods whose capitalization should be normalized
  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

  function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method
  }

  function Request(input, options) {
    if (!(this instanceof Request)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }

    options = options || {};
    var body = options.body;

    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read')
      }
      this.url = input.url;
      this.credentials = input.credentials;
      if (!options.headers) {
        this.headers = new Headers(input.headers);
      }
      this.method = input.method;
      this.mode = input.mode;
      this.signal = input.signal;
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.bodyUsed = true;
      }
    } else {
      this.url = String(input);
    }

    this.credentials = options.credentials || this.credentials || 'same-origin';
    if (options.headers || !this.headers) {
      this.headers = new Headers(options.headers);
    }
    this.method = normalizeMethod(options.method || this.method || 'GET');
    this.mode = options.mode || this.mode || null;
    this.signal = options.signal || this.signal;
    this.referrer = null;

    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests')
    }
    this._initBody(body);

    if (this.method === 'GET' || this.method === 'HEAD') {
      if (options.cache === 'no-store' || options.cache === 'no-cache') {
        // Search for a '_' parameter in the query string
        var reParamSearch = /([?&])_=[^&]*/;
        if (reParamSearch.test(this.url)) {
          // If it already exists then set the value with the current time
          this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
        } else {
          // Otherwise add a new '_' parameter to the end with the current time
          var reQueryString = /\?/;
          this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
        }
      }
    }
  }

  Request.prototype.clone = function() {
    return new Request(this, {body: this._bodyInit})
  };

  function decode(body) {
    var form = new FormData();
    body
      .trim()
      .split('&')
      .forEach(function(bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
    return form
  }

  function parseHeaders(rawHeaders) {
    var headers = new Headers();
    // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
    // https://tools.ietf.org/html/rfc7230#section-3.2
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
    // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
    // https://github.com/github/fetch/issues/748
    // https://github.com/zloirock/core-js/issues/751
    preProcessedHeaders
      .split('\r')
      .map(function(header) {
        return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
      })
      .forEach(function(line) {
        var parts = line.split(':');
        var key = parts.shift().trim();
        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
    return headers
  }

  Body.call(Request.prototype);

  function Response(bodyInit, options) {
    if (!(this instanceof Response)) {
      throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
    }
    if (!options) {
      options = {};
    }

    this.type = 'default';
    this.status = options.status === undefined ? 200 : options.status;
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
    this.headers = new Headers(options.headers);
    this.url = options.url || '';
    this._initBody(bodyInit);
  }

  Body.call(Response.prototype);

  Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
      status: this.status,
      statusText: this.statusText,
      headers: new Headers(this.headers),
      url: this.url
    })
  };

  Response.error = function() {
    var response = new Response(null, {status: 0, statusText: ''});
    response.type = 'error';
    return response
  };

  var redirectStatuses = [301, 302, 303, 307, 308];

  Response.redirect = function(url, status) {
    if (redirectStatuses.indexOf(status) === -1) {
      throw new RangeError('Invalid status code')
    }

    return new Response(null, {status: status, headers: {location: url}})
  };

  exports.DOMException = global.DOMException;
  try {
    new exports.DOMException();
  } catch (err) {
    exports.DOMException = function(message, name) {
      this.message = message;
      this.name = name;
      var error = Error(message);
      this.stack = error.stack;
    };
    exports.DOMException.prototype = Object.create(Error.prototype);
    exports.DOMException.prototype.constructor = exports.DOMException;
  }

  function fetch(input, init) {
    return new Promise(function(resolve, reject) {
      var request = new Request(input, init);

      if (request.signal && request.signal.aborted) {
        return reject(new exports.DOMException('Aborted', 'AbortError'))
      }

      var xhr = new XMLHttpRequest();

      function abortXhr() {
        xhr.abort();
      }

      xhr.onload = function() {
        var options = {
          status: xhr.status,
          statusText: xhr.statusText,
          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
        };
        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
        var body = 'response' in xhr ? xhr.response : xhr.responseText;
        setTimeout(function() {
          resolve(new Response(body, options));
        }, 0);
      };

      xhr.onerror = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.ontimeout = function() {
        setTimeout(function() {
          reject(new TypeError('Network request failed'));
        }, 0);
      };

      xhr.onabort = function() {
        setTimeout(function() {
          reject(new exports.DOMException('Aborted', 'AbortError'));
        }, 0);
      };

      function fixUrl(url) {
        try {
          return url === '' && global.location.href ? global.location.href : url
        } catch (e) {
          return url
        }
      }

      xhr.open(request.method, fixUrl(request.url), true);

      if (request.credentials === 'include') {
        xhr.withCredentials = true;
      } else if (request.credentials === 'omit') {
        xhr.withCredentials = false;
      }

      if ('responseType' in xhr) {
        if (support.blob) {
          xhr.responseType = 'blob';
        } else if (
          support.arrayBuffer &&
          request.headers.get('Content-Type') &&
          request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
        ) {
          xhr.responseType = 'arraybuffer';
        }
      }

      if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
        Object.getOwnPropertyNames(init.headers).forEach(function(name) {
          xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
        });
      } else {
        request.headers.forEach(function(value, name) {
          xhr.setRequestHeader(name, value);
        });
      }

      if (request.signal) {
        request.signal.addEventListener('abort', abortXhr);

        xhr.onreadystatechange = function() {
          // DONE (success or failure)
          if (xhr.readyState === 4) {
            request.signal.removeEventListener('abort', abortXhr);
          }
        };
      }

      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
    })
  }

  fetch.polyfill = true;

  if (!global.fetch) {
    global.fetch = fetch;
    global.Headers = Headers;
    global.Request = Request;
    global.Response = Response;
  }

  exports.Headers = Headers;
  exports.Request = Request;
  exports.Response = Response;
  exports.fetch = fetch;

  Object.defineProperty(exports, '__esModule', { value: true });

})));

      };
    };
  }
}, {package:"@metamask/controllers>isomorphic-fetch>whatwg-fetch",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\wrappy\\wrappy.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\wrappy\wrappy.js
      return function (require, module, exports) {
// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}

      };
    };
  }
}, {package:"pump>once>wrappy",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\errors.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\errors.js
      return function (require, module, exports) {
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var SecurityError = /** @class */ (function (_super) {
    __extends(SecurityError, _super);
    function SecurityError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SecurityError;
}(Error));
exports.SecurityError = SecurityError;
var InvalidStateError = /** @class */ (function (_super) {
    __extends(InvalidStateError, _super);
    function InvalidStateError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return InvalidStateError;
}(Error));
exports.InvalidStateError = InvalidStateError;
var NetworkError = /** @class */ (function (_super) {
    __extends(NetworkError, _super);
    function NetworkError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NetworkError;
}(Error));
exports.NetworkError = NetworkError;
var SyntaxError = /** @class */ (function (_super) {
    __extends(SyntaxError, _super);
    function SyntaxError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return SyntaxError;
}(Error));
exports.SyntaxError = SyntaxError;
//# sourceMappingURL=errors.js.map
      };
    };
  }
}, {package:"@metamask/controllers>web3>xhr2-cookies",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\index.js", {"./xml-http-request":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request.js","./xml-http-request-event-target":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\index.js
      return function (require, module, exports) {
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(require("./xml-http-request"));
var xml_http_request_event_target_1 = require("./xml-http-request-event-target");
exports.XMLHttpRequestEventTarget = xml_http_request_event_target_1.XMLHttpRequestEventTarget;
//# sourceMappingURL=index.js.map
      };
    };
  }
}, {package:"@metamask/controllers>web3>xhr2-cookies",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\progress-event.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\progress-event.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ProgressEvent = /** @class */ (function () {
    function ProgressEvent(type) {
        this.type = type;
        this.bubbles = false;
        this.cancelable = false;
        this.loaded = 0;
        this.lengthComputable = false;
        this.total = 0;
    }
    return ProgressEvent;
}());
exports.ProgressEvent = ProgressEvent;
//# sourceMappingURL=progress-event.js.map
      };
    };
  }
}, {package:"@metamask/controllers>web3>xhr2-cookies",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\xml-http-request-event-target.js
      return function (require, module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var XMLHttpRequestEventTarget = /** @class */ (function () {
    function XMLHttpRequestEventTarget() {
        this.listeners = {};
    }
    XMLHttpRequestEventTarget.prototype.addEventListener = function (eventType, listener) {
        eventType = eventType.toLowerCase();
        this.listeners[eventType] = this.listeners[eventType] || [];
        this.listeners[eventType].push(listener.handleEvent || listener);
    };
    XMLHttpRequestEventTarget.prototype.removeEventListener = function (eventType, listener) {
        eventType = eventType.toLowerCase();
        if (!this.listeners[eventType]) {
            return;
        }
        var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
        if (index < 0) {
            return;
        }
        this.listeners[eventType].splice(index, 1);
    };
    XMLHttpRequestEventTarget.prototype.dispatchEvent = function (event) {
        var eventType = event.type.toLowerCase();
        event.target = this; // TODO: set event.currentTarget?
        if (this.listeners[eventType]) {
            for (var _i = 0, _a = this.listeners[eventType]; _i < _a.length; _i++) {
                var listener_1 = _a[_i];
                listener_1.call(this, event);
            }
        }
        var listener = this["on" + eventType];
        if (listener) {
            listener.call(this, event);
        }
        return true;
    };
    return XMLHttpRequestEventTarget;
}());
exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
//# sourceMappingURL=xml-http-request-event-target.js.map
      };
    };
  }
}, {package:"@metamask/controllers>web3>xhr2-cookies",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-upload.js", {"./xml-http-request-event-target":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\xml-http-request-upload.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var xml_http_request_event_target_1 = require("./xml-http-request-event-target");
var XMLHttpRequestUpload = /** @class */ (function (_super) {
    __extends(XMLHttpRequestUpload, _super);
    function XMLHttpRequestUpload() {
        var _this = _super.call(this) || this;
        _this._contentType = null;
        _this._body = null;
        _this._reset();
        return _this;
    }
    XMLHttpRequestUpload.prototype._reset = function () {
        this._contentType = null;
        this._body = null;
    };
    XMLHttpRequestUpload.prototype._setData = function (data) {
        if (data == null) {
            return;
        }
        if (typeof data === 'string') {
            if (data.length !== 0) {
                this._contentType = 'text/plain;charset=UTF-8';
            }
            this._body = new Buffer(data, 'utf-8');
        }
        else if (Buffer.isBuffer(data)) {
            this._body = data;
        }
        else if (data instanceof ArrayBuffer) {
            var body = new Buffer(data.byteLength);
            var view = new Uint8Array(data);
            for (var i = 0; i < data.byteLength; i++) {
                body[i] = view[i];
            }
            this._body = body;
        }
        else if (data.buffer && data.buffer instanceof ArrayBuffer) {
            var body = new Buffer(data.byteLength);
            var offset = data.byteOffset;
            var view = new Uint8Array(data.buffer);
            for (var i = 0; i < data.byteLength; i++) {
                body[i] = view[i + offset];
            }
            this._body = body;
        }
        else {
            throw new Error("Unsupported send() data " + data);
        }
    };
    XMLHttpRequestUpload.prototype._finalizeHeaders = function (headers, loweredHeaders) {
        if (this._contentType && !loweredHeaders['content-type']) {
            headers['Content-Type'] = this._contentType;
        }
        if (this._body) {
            headers['Content-Length'] = this._body.length.toString();
        }
    };
    XMLHttpRequestUpload.prototype._startUpload = function (request) {
        if (this._body) {
            request.write(this._body);
        }
        request.end();
    };
    return XMLHttpRequestUpload;
}(xml_http_request_event_target_1.XMLHttpRequestEventTarget));
exports.XMLHttpRequestUpload = XMLHttpRequestUpload;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3>xhr2-cookies",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request.js", {"./errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\errors.js","./progress-event":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\progress-event.js","./xml-http-request-event-target":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js","./xml-http-request-upload":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-upload.js","_process":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\process\\browser.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","cookiejar":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\cookiejar\\cookiejar.js","http":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\stream-http\\index.js","https":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\https-browserify\\index.js","os":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\os-browserify\\browser.js","url":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\url\\url.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\xml-http-request.js
      return function (require, module, exports) {
(function (process,Buffer){(function (){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var http = require("http");
var https = require("https");
var os = require("os");
var url = require("url");
var progress_event_1 = require("./progress-event");
var errors_1 = require("./errors");
var xml_http_request_event_target_1 = require("./xml-http-request-event-target");
var xml_http_request_upload_1 = require("./xml-http-request-upload");
var Cookie = require("cookiejar");
var XMLHttpRequest = /** @class */ (function (_super) {
    __extends(XMLHttpRequest, _super);
    function XMLHttpRequest(options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.UNSENT = XMLHttpRequest.UNSENT;
        _this.OPENED = XMLHttpRequest.OPENED;
        _this.HEADERS_RECEIVED = XMLHttpRequest.HEADERS_RECEIVED;
        _this.LOADING = XMLHttpRequest.LOADING;
        _this.DONE = XMLHttpRequest.DONE;
        _this.onreadystatechange = null;
        _this.readyState = XMLHttpRequest.UNSENT;
        _this.response = null;
        _this.responseText = '';
        _this.responseType = '';
        _this.status = 0; // TODO: UNSENT?
        _this.statusText = '';
        _this.timeout = 0;
        _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
        _this.responseUrl = '';
        _this.withCredentials = false;
        _this._method = null;
        _this._url = null;
        _this._sync = false;
        _this._headers = {};
        _this._loweredHeaders = {};
        _this._mimeOverride = null; // TODO: is type right?
        _this._request = null;
        _this._response = null;
        _this._responseParts = null;
        _this._responseHeaders = null;
        _this._aborting = null; // TODO: type?
        _this._error = null; // TODO: type?
        _this._loadedBytes = 0;
        _this._totalBytes = 0;
        _this._lengthComputable = false;
        _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
        _this._restrictedHeaders = {
            'accept-charset': true,
            'accept-encoding': true,
            'access-control-request-headers': true,
            'access-control-request-method': true,
            connection: true,
            'content-length': true,
            cookie: true,
            cookie2: true,
            date: true,
            dnt: true,
            expect: true,
            host: true,
            'keep-alive': true,
            origin: true,
            referer: true,
            te: true,
            trailer: true,
            'transfer-encoding': true,
            upgrade: true,
            'user-agent': true,
            via: true
        };
        _this._privateHeaders = { 'set-cookie': true, 'set-cookie2': true };
        _this._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
        _this._anonymous = options.anon || false;
        return _this;
    }
    XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
        if (async === void 0) { async = true; }
        method = method.toUpperCase();
        if (this._restrictedMethods[method]) {
            throw new XMLHttpRequest.SecurityError("HTTP method " + method + " is not allowed in XHR");
        }
        ;
        var xhrUrl = this._parseUrl(url, user, password);
        if (this.readyState === XMLHttpRequest.HEADERS_RECEIVED || this.readyState === XMLHttpRequest.LOADING) {
            // TODO(pwnall): terminate abort(), terminate send()
        }
        this._method = method;
        this._url = xhrUrl;
        this._sync = !async;
        this._headers = {};
        this._loweredHeaders = {};
        this._mimeOverride = null;
        this._setReadyState(XMLHttpRequest.OPENED);
        this._request = null;
        this._response = null;
        this.status = 0;
        this.statusText = '';
        this._responseParts = [];
        this._responseHeaders = null;
        this._loadedBytes = 0;
        this._totalBytes = 0;
        this._lengthComputable = false;
    };
    XMLHttpRequest.prototype.setRequestHeader = function (name, value) {
        if (this.readyState !== XMLHttpRequest.OPENED) {
            throw new XMLHttpRequest.InvalidStateError('XHR readyState must be OPENED');
        }
        var loweredName = name.toLowerCase();
        if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
            console.warn("Refused to set unsafe header \"" + name + "\"");
            return;
        }
        value = value.toString();
        if (this._loweredHeaders[loweredName] != null) {
            name = this._loweredHeaders[loweredName];
            this._headers[name] = this._headers[name] + ", " + value;
        }
        else {
            this._loweredHeaders[loweredName] = name;
            this._headers[name] = value;
        }
    };
    XMLHttpRequest.prototype.send = function (data) {
        if (this.readyState !== XMLHttpRequest.OPENED) {
            throw new XMLHttpRequest.InvalidStateError('XHR readyState must be OPENED');
        }
        if (this._request) {
            throw new XMLHttpRequest.InvalidStateError('send() already called');
        }
        switch (this._url.protocol) {
            case 'file:':
                return this._sendFile(data);
            case 'http:':
            case 'https:':
                return this._sendHttp(data);
            default:
                throw new XMLHttpRequest.NetworkError("Unsupported protocol " + this._url.protocol);
        }
    };
    XMLHttpRequest.prototype.abort = function () {
        if (this._request == null) {
            return;
        }
        this._request.abort();
        this._setError();
        this._dispatchProgress('abort');
        this._dispatchProgress('loadend');
    };
    XMLHttpRequest.prototype.getResponseHeader = function (name) {
        if (this._responseHeaders == null || name == null) {
            return null;
        }
        var loweredName = name.toLowerCase();
        return this._responseHeaders.hasOwnProperty(loweredName)
            ? this._responseHeaders[name.toLowerCase()]
            : null;
    };
    XMLHttpRequest.prototype.getAllResponseHeaders = function () {
        var _this = this;
        if (this._responseHeaders == null) {
            return '';
        }
        return Object.keys(this._responseHeaders).map(function (key) { return key + ": " + _this._responseHeaders[key]; }).join('\r\n');
    };
    XMLHttpRequest.prototype.overrideMimeType = function (mimeType) {
        if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
            throw new XMLHttpRequest.InvalidStateError('overrideMimeType() not allowed in LOADING or DONE');
        }
        this._mimeOverride = mimeType.toLowerCase();
    };
    XMLHttpRequest.prototype.nodejsSet = function (options) {
        this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
        this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
        if (options.hasOwnProperty('baseUrl')) {
            if (options.baseUrl != null) {
                var parsedUrl = url.parse(options.baseUrl, false, true);
                if (!parsedUrl.protocol) {
                    throw new XMLHttpRequest.SyntaxError("baseUrl must be an absolute URL");
                }
            }
            this.nodejsBaseUrl = options.baseUrl;
        }
    };
    XMLHttpRequest.nodejsSet = function (options) {
        XMLHttpRequest.prototype.nodejsSet(options);
    };
    XMLHttpRequest.prototype._setReadyState = function (readyState) {
        this.readyState = readyState;
        this.dispatchEvent(new progress_event_1.ProgressEvent('readystatechange'));
    };
    XMLHttpRequest.prototype._sendFile = function (data) {
        // TODO
        throw new Error('Protocol file: not implemented');
    };
    XMLHttpRequest.prototype._sendHttp = function (data) {
        if (this._sync) {
            throw new Error('Synchronous XHR processing not implemented');
        }
        if (data && (this._method === 'GET' || this._method === 'HEAD')) {
            console.warn("Discarding entity body for " + this._method + " requests");
            data = null;
        }
        else {
            data = data || '';
        }
        this.upload._setData(data);
        this._finalizeHeaders();
        this._sendHxxpRequest();
    };
    XMLHttpRequest.prototype._sendHxxpRequest = function () {
        var _this = this;
        if (this.withCredentials) {
            var cookie = XMLHttpRequest.cookieJar
                .getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === 'https:')).toValueString();
            this._headers.cookie = this._headers.cookie2 = cookie;
        }
        var _a = this._url.protocol === 'http:' ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a[0], agent = _a[1];
        var requestMethod = hxxp.request.bind(hxxp);
        var request = requestMethod({
            hostname: this._url.hostname,
            port: +this._url.port,
            path: this._url.path,
            auth: this._url.auth,
            method: this._method,
            headers: this._headers,
            agent: agent
        });
        this._request = request;
        if (this.timeout) {
            request.setTimeout(this.timeout, function () { return _this._onHttpTimeout(request); });
        }
        request.on('response', function (response) { return _this._onHttpResponse(request, response); });
        request.on('error', function (error) { return _this._onHttpRequestError(request, error); });
        this.upload._startUpload(request);
        if (this._request === request) {
            this._dispatchProgress('loadstart');
        }
    };
    XMLHttpRequest.prototype._finalizeHeaders = function () {
        this._headers = __assign({}, this._headers, { Connection: 'keep-alive', Host: this._url.host, 'User-Agent': this._userAgent }, this._anonymous ? { Referer: 'about:blank' } : {});
        this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
    };
    XMLHttpRequest.prototype._onHttpResponse = function (request, response) {
        var _this = this;
        if (this._request !== request) {
            return;
        }
        if (this.withCredentials && (response.headers['set-cookie'] || response.headers['set-cookie2'])) {
            XMLHttpRequest.cookieJar
                .setCookies(response.headers['set-cookie'] || response.headers['set-cookie2']);
        }
        if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
            this._url = this._parseUrl(response.headers.location);
            this._method = 'GET';
            if (this._loweredHeaders['content-type']) {
                delete this._headers[this._loweredHeaders['content-type']];
                delete this._loweredHeaders['content-type'];
            }
            if (this._headers['Content-Type'] != null) {
                delete this._headers['Content-Type'];
            }
            delete this._headers['Content-Length'];
            this.upload._reset();
            this._finalizeHeaders();
            this._sendHxxpRequest();
            return;
        }
        this._response = response;
        this._response.on('data', function (data) { return _this._onHttpResponseData(response, data); });
        this._response.on('end', function () { return _this._onHttpResponseEnd(response); });
        this._response.on('close', function () { return _this._onHttpResponseClose(response); });
        this.responseUrl = this._url.href.split('#')[0];
        this.status = response.statusCode;
        this.statusText = http.STATUS_CODES[this.status];
        this._parseResponseHeaders(response);
        var lengthString = this._responseHeaders['content-length'] || '';
        this._totalBytes = +lengthString;
        this._lengthComputable = !!lengthString;
        this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
    };
    XMLHttpRequest.prototype._onHttpResponseData = function (response, data) {
        if (this._response !== response) {
            return;
        }
        this._responseParts.push(new Buffer(data));
        this._loadedBytes += data.length;
        if (this.readyState !== XMLHttpRequest.LOADING) {
            this._setReadyState(XMLHttpRequest.LOADING);
        }
        this._dispatchProgress('progress');
    };
    XMLHttpRequest.prototype._onHttpResponseEnd = function (response) {
        if (this._response !== response) {
            return;
        }
        this._parseResponse();
        this._request = null;
        this._response = null;
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress('load');
        this._dispatchProgress('loadend');
    };
    XMLHttpRequest.prototype._onHttpResponseClose = function (response) {
        if (this._response !== response) {
            return;
        }
        var request = this._request;
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress('error');
        this._dispatchProgress('loadend');
    };
    XMLHttpRequest.prototype._onHttpTimeout = function (request) {
        if (this._request !== request) {
            return;
        }
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress('timeout');
        this._dispatchProgress('loadend');
    };
    XMLHttpRequest.prototype._onHttpRequestError = function (request, error) {
        if (this._request !== request) {
            return;
        }
        this._setError();
        request.abort();
        this._setReadyState(XMLHttpRequest.DONE);
        this._dispatchProgress('error');
        this._dispatchProgress('loadend');
    };
    XMLHttpRequest.prototype._dispatchProgress = function (eventType) {
        var event = new XMLHttpRequest.ProgressEvent(eventType);
        event.lengthComputable = this._lengthComputable;
        event.loaded = this._loadedBytes;
        event.total = this._totalBytes;
        this.dispatchEvent(event);
    };
    XMLHttpRequest.prototype._setError = function () {
        this._request = null;
        this._response = null;
        this._responseHeaders = null;
        this._responseParts = null;
    };
    XMLHttpRequest.prototype._parseUrl = function (urlString, user, password) {
        var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
        var xhrUrl = url.parse(absoluteUrl, false, true);
        xhrUrl.hash = null;
        var _a = (xhrUrl.auth || '').split(':'), xhrUser = _a[0], xhrPassword = _a[1];
        if (xhrUser || xhrPassword || user || password) {
            xhrUrl.auth = (user || xhrUser || '') + ":" + (password || xhrPassword || '');
        }
        return xhrUrl;
    };
    XMLHttpRequest.prototype._parseResponseHeaders = function (response) {
        this._responseHeaders = {};
        for (var name_1 in response.headers) {
            var loweredName = name_1.toLowerCase();
            if (this._privateHeaders[loweredName]) {
                continue;
            }
            this._responseHeaders[loweredName] = response.headers[name_1];
        }
        if (this._mimeOverride != null) {
            this._responseHeaders['content-type'] = this._mimeOverride;
        }
    };
    XMLHttpRequest.prototype._parseResponse = function () {
        var buffer = Buffer.concat(this._responseParts);
        this._responseParts = null;
        switch (this.responseType) {
            case 'json':
                this.responseText = null;
                try {
                    this.response = JSON.parse(buffer.toString('utf-8'));
                }
                catch (_a) {
                    this.response = null;
                }
                return;
            case 'buffer':
                this.responseText = null;
                this.response = buffer;
                return;
            case 'arraybuffer':
                this.responseText = null;
                var arrayBuffer = new ArrayBuffer(buffer.length);
                var view = new Uint8Array(arrayBuffer);
                for (var i = 0; i < buffer.length; i++) {
                    view[i] = buffer[i];
                }
                this.response = arrayBuffer;
                return;
            case 'text':
            default:
                try {
                    this.responseText = buffer.toString(this._parseResponseEncoding());
                }
                catch (_b) {
                    this.responseText = buffer.toString('binary');
                }
                this.response = this.responseText;
        }
    };
    XMLHttpRequest.prototype._parseResponseEncoding = function () {
        return /;\s*charset=(.*)$/.exec(this._responseHeaders['content-type'] || '')[1] || 'utf-8';
    };
    XMLHttpRequest.ProgressEvent = progress_event_1.ProgressEvent;
    XMLHttpRequest.InvalidStateError = errors_1.InvalidStateError;
    XMLHttpRequest.NetworkError = errors_1.NetworkError;
    XMLHttpRequest.SecurityError = errors_1.SecurityError;
    XMLHttpRequest.SyntaxError = errors_1.SyntaxError;
    XMLHttpRequest.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
    XMLHttpRequest.UNSENT = 0;
    XMLHttpRequest.OPENED = 1;
    XMLHttpRequest.HEADERS_RECEIVED = 2;
    XMLHttpRequest.LOADING = 3;
    XMLHttpRequest.DONE = 4;
    XMLHttpRequest.cookieJar = Cookie.CookieJar();
    return XMLHttpRequest;
}(xml_http_request_event_target_1.XMLHttpRequestEventTarget));
exports.XMLHttpRequest = XMLHttpRequest;
XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;
XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;
XMLHttpRequest.prototype.nodejsBaseUrl = null;

}).call(this)}).call(this,require('_process'),require("buffer").Buffer)

      };
    };
  }
}, {package:"@metamask/controllers>web3>xhr2-cookies",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2\\lib\\browser.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2\lib\browser.js
      return function (require, module, exports) {
module.exports = XMLHttpRequest;

      };
    };
  }
}, {package:"ethjs>ethjs-provider-http>xhr2",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xtend\immutable.js
      return function (require, module, exports) {
module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

      };
    };
  }
}, {package:"watchify>xtend",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\alerts.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\alerts.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEB3_SHIM_USAGE_ALERT_STATES = exports.TOGGLEABLE_ALERT_TYPES = exports.ALERT_TYPES = void 0;
const ALERT_TYPES = {
  unconnectedAccount: 'unconnectedAccount',
  web3ShimUsage: 'web3ShimUsage',
  invalidCustomNetwork: 'invalidCustomNetwork'
};
/**
 * Alerts that can be enabled or disabled by the user.
 */

exports.ALERT_TYPES = ALERT_TYPES;
const TOGGLEABLE_ALERT_TYPES = [ALERT_TYPES.unconnectedAccount, ALERT_TYPES.web3ShimUsage];
exports.TOGGLEABLE_ALERT_TYPES = TOGGLEABLE_ALERT_TYPES;
const WEB3_SHIM_USAGE_ALERT_STATES = {
  RECORDED: 1,
  DISMISSED: 2
};
exports.WEB3_SHIM_USAGE_ALERT_STATES = WEB3_SHIM_USAGE_ALERT_STATES;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts", {"./permissions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\permissions.ts"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\app.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNKNOWN_TICKER_SYMBOL = exports.SUBJECT_TYPES = exports.POLLING_TOKEN_ENVIRONMENT_TYPES = exports.PLATFORM_OPERA = exports.PLATFORM_FIREFOX = exports.PLATFORM_EDGE = exports.PLATFORM_CHROME = exports.PLATFORM_BRAVE = exports.ORIGIN_METAMASK = exports.METAMASK_PROD_CHROME_ID = exports.METAMASK_FLASK_CHROME_ID = exports.METAMASK_BETA_CHROME_ID = exports.MESSAGE_TYPE = exports.FIREFOX_BUILD_IDS = exports.ENVIRONMENT_TYPE_POPUP = exports.ENVIRONMENT_TYPE_NOTIFICATION = exports.ENVIRONMENT_TYPE_FULLSCREEN = exports.ENVIRONMENT_TYPE_BACKGROUND = exports.CHROME_BUILD_IDS = exports.BuildType = void 0;

var _permissions = require("./permissions");

const ENVIRONMENT_TYPE_POPUP = 'popup';
exports.ENVIRONMENT_TYPE_POPUP = ENVIRONMENT_TYPE_POPUP;
const ENVIRONMENT_TYPE_NOTIFICATION = 'notification';
exports.ENVIRONMENT_TYPE_NOTIFICATION = ENVIRONMENT_TYPE_NOTIFICATION;
const ENVIRONMENT_TYPE_FULLSCREEN = 'fullscreen';
exports.ENVIRONMENT_TYPE_FULLSCREEN = ENVIRONMENT_TYPE_FULLSCREEN;
const ENVIRONMENT_TYPE_BACKGROUND = 'background';
/**
 * The distribution this build is intended for.
 *
 * This should be kept in-sync with the `BuildType` map in `development/build/utils.js`.
 */

exports.ENVIRONMENT_TYPE_BACKGROUND = ENVIRONMENT_TYPE_BACKGROUND;
const BuildType = {
  beta: 'beta',
  flask: 'flask',
  main: 'main'
};
exports.BuildType = BuildType;
const PLATFORM_BRAVE = 'Brave';
exports.PLATFORM_BRAVE = PLATFORM_BRAVE;
const PLATFORM_CHROME = 'Chrome';
exports.PLATFORM_CHROME = PLATFORM_CHROME;
const PLATFORM_EDGE = 'Edge';
exports.PLATFORM_EDGE = PLATFORM_EDGE;
const PLATFORM_FIREFOX = 'Firefox';
exports.PLATFORM_FIREFOX = PLATFORM_FIREFOX;
const PLATFORM_OPERA = 'Opera';
exports.PLATFORM_OPERA = PLATFORM_OPERA;
const MESSAGE_TYPE = {
  ADD_ETHEREUM_CHAIN: 'wallet_addEthereumChain',
  ETH_ACCOUNTS: _permissions.RestrictedMethods.eth_accounts,
  ETH_DECRYPT: 'eth_decrypt',
  ETH_GET_ENCRYPTION_PUBLIC_KEY: 'eth_getEncryptionPublicKey',
  ETH_REQUEST_ACCOUNTS: 'eth_requestAccounts',
  ETH_SIGN: 'eth_sign',
  ETH_SIGN_TYPED_DATA: 'eth_signTypedData',
  ETH_SIGN_TYPED_DATA_V3: 'eth_signTypedData_v3',
  ETH_SIGN_TYPED_DATA_V4: 'eth_signTypedData_v4',
  GET_PROVIDER_STATE: 'metamask_getProviderState',
  LOG_WEB3_SHIM_USAGE: 'metamask_logWeb3ShimUsage',
  PERSONAL_SIGN: 'personal_sign',
  SEND_METADATA: 'metamask_sendDomainMetadata',
  SWITCH_ETHEREUM_CHAIN: 'wallet_switchEthereumChain',
  WALLET_REQUEST_PERMISSIONS: 'wallet_requestPermissions',
  WATCH_ASSET: 'wallet_watchAsset',
  WATCH_ASSET_LEGACY: 'metamask_watchAsset',
  ///: BEGIN:ONLY_INCLUDE_IN(flask)
  SNAP_CONFIRM: _permissions.RestrictedMethods.snap_confirm ///: END:ONLY_INCLUDE_IN

};
/**
 * The different kinds of subjects that MetaMask may interact with, including
 * third parties and itself (e.g. when the background communicated with the UI).
 */

exports.MESSAGE_TYPE = MESSAGE_TYPE;
const SUBJECT_TYPES = {
  EXTENSION: 'extension',
  INTERNAL: 'internal',
  UNKNOWN: 'unknown',
  WEBSITE: 'website',
  ///: BEGIN:ONLY_INCLUDE_IN(flask)
  SNAP: 'snap' ///: END:ONLY_INCLUDE_IN

};
exports.SUBJECT_TYPES = SUBJECT_TYPES;
const POLLING_TOKEN_ENVIRONMENT_TYPES = {
  [ENVIRONMENT_TYPE_POPUP]: 'popupGasPollTokens',
  [ENVIRONMENT_TYPE_NOTIFICATION]: 'notificationGasPollTokens',
  [ENVIRONMENT_TYPE_FULLSCREEN]: 'fullScreenGasPollTokens'
};
exports.POLLING_TOKEN_ENVIRONMENT_TYPES = POLLING_TOKEN_ENVIRONMENT_TYPES;
const ORIGIN_METAMASK = 'metamask';
exports.ORIGIN_METAMASK = ORIGIN_METAMASK;
const METAMASK_BETA_CHROME_ID = 'pbbkamfgmaedccnfkmjcofcecjhfgldn';
exports.METAMASK_BETA_CHROME_ID = METAMASK_BETA_CHROME_ID;
const METAMASK_PROD_CHROME_ID = 'nkbihfbeogaeaoehlefnkodbefgpgknn';
exports.METAMASK_PROD_CHROME_ID = METAMASK_PROD_CHROME_ID;
const METAMASK_FLASK_CHROME_ID = 'ljfoeinjpaedjfecbmggjgodbgkmjkjk';
exports.METAMASK_FLASK_CHROME_ID = METAMASK_FLASK_CHROME_ID;
const CHROME_BUILD_IDS = [METAMASK_BETA_CHROME_ID, METAMASK_PROD_CHROME_ID, METAMASK_FLASK_CHROME_ID];
exports.CHROME_BUILD_IDS = CHROME_BUILD_IDS;
const METAMASK_BETA_FIREFOX_ID = 'webextension-beta@metamask.io';
const METAMASK_PROD_FIREFOX_ID = 'webextension@metamask.io';
const METAMASK_FLASK_FIREFOX_ID = 'webextension-flask@metamask.io';
const FIREFOX_BUILD_IDS = [METAMASK_BETA_FIREFOX_ID, METAMASK_PROD_FIREFOX_ID, METAMASK_FLASK_FIREFOX_ID];
exports.FIREFOX_BUILD_IDS = FIREFOX_BUILD_IDS;
const UNKNOWN_TICKER_SYMBOL = 'UNKNOWN';
exports.UNKNOWN_TICKER_SYMBOL = UNKNOWN_TICKER_SYMBOL;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js", {"ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\gas.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PRIORITY_LEVELS = exports.NETWORK_CONGESTION_THRESHOLDS = exports.MIN_GAS_LIMIT_HEX = exports.GAS_RECOMMENDATIONS = exports.GAS_LIMITS = exports.GAS_ESTIMATE_TYPES = exports.EDIT_GAS_MODES = exports.CUSTOM_GAS_ESTIMATE = void 0;

var _ethereumjsUtil = require("ethereumjs-util");

const ONE_HUNDRED_THOUSAND = 100000;
const MIN_GAS_LIMIT_DEC = '21000';
const MIN_GAS_LIMIT_HEX = parseInt(MIN_GAS_LIMIT_DEC, 10).toString(16);
exports.MIN_GAS_LIMIT_HEX = MIN_GAS_LIMIT_HEX;
const GAS_LIMITS = {
  // maximum gasLimit of a simple send
  SIMPLE: (0, _ethereumjsUtil.addHexPrefix)(MIN_GAS_LIMIT_HEX),
  // a base estimate for token transfers.
  BASE_TOKEN_ESTIMATE: (0, _ethereumjsUtil.addHexPrefix)(ONE_HUNDRED_THOUSAND.toString(16))
};
/**
 * @typedef {object} GasEstimateTypes
 * @property {'fee-market'} FEE_MARKET - A gas estimate for a fee market
 *  transaction generated by our gas estimation API.
 * @property {'legacy'} LEGACY - A gas estimate for a legacy Transaction
 *  generated by our gas estimation API.
 * @property {'eth_gasPrice'} ETH_GAS_PRICE - A gas estimate provided by the
 *  Ethereum node via eth_gasPrice.
 * @property {'none'} NONE - No gas estimate available.
 */

/**
 * These are already declared in @metamask/controllers but importing them from
 * that module and re-exporting causes the UI bundle size to expand beyond 4MB
 *
 * @type {GasEstimateTypes}
 */

exports.GAS_LIMITS = GAS_LIMITS;
const GAS_ESTIMATE_TYPES = {
  FEE_MARKET: 'fee-market',
  LEGACY: 'legacy',
  ETH_GASPRICE: 'eth_gasPrice',
  NONE: 'none'
};
/**
 * These represent gas recommendation levels presented in the UI
 */

exports.GAS_ESTIMATE_TYPES = GAS_ESTIMATE_TYPES;
const GAS_RECOMMENDATIONS = {
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high'
};
/**
 * These represent types of gas estimation
 */

exports.GAS_RECOMMENDATIONS = GAS_RECOMMENDATIONS;
const PRIORITY_LEVELS = {
  TEN_PERCENT_INCREASED: 'tenPercentIncreased',
  LOW: 'low',
  MEDIUM: 'medium',
  HIGH: 'high',
  CUSTOM: 'custom',
  DAPP_SUGGESTED: 'dappSuggested'
};
/**
 * Represents the user customizing their gas preference
 */

exports.PRIORITY_LEVELS = PRIORITY_LEVELS;
const CUSTOM_GAS_ESTIMATE = 'custom';
/**
 * These represent the different edit modes presented in the UI
 */

exports.CUSTOM_GAS_ESTIMATE = CUSTOM_GAS_ESTIMATE;
const EDIT_GAS_MODES = {
  SPEED_UP: 'speed-up',
  CANCEL: 'cancel',
  MODIFY_IN_PLACE: 'modify-in-place',
  SWAPS: 'swaps'
};
/**
 * Represents levels for `networkCongestion` (calculated along with gas fee
 * estimates; represents a number between 0 and 1) that we use to render the
 * network status slider on the send transaction screen and inform users when
 * gas fees are high
 */

exports.EDIT_GAS_MODES = EDIT_GAS_MODES;
const NETWORK_CONGESTION_THRESHOLDS = {
  NOT_BUSY: 0,
  STABLE: 0.33,
  BUSY: 0.66
};
exports.NETWORK_CONGESTION_THRESHOLDS = NETWORK_CONGESTION_THRESHOLDS;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\hardware-wallets.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEBHID_CONNECTED_STATUSES = exports.TRANSPORT_STATES = exports.LEDGER_USB_VENDOR_ID = exports.LEDGER_TRANSPORT_TYPES = exports.KEYRING_TYPES = exports.KEYRING_NAMES = exports.DEVICE_NAMES = exports.AFFILIATE_TUTORIAL_LINKS = exports.AFFILIATE_LINKS = void 0;

/**
 * Accounts can be instantiated from simple, HD or the multiple hardware wallet
 * keyring types. Both simple and HD are treated as default but we do special
 * case accounts managed by a hardware wallet.
 */
const KEYRING_TYPES = {
  LEDGER: 'Ledger Hardware',
  TREZOR: 'Trezor Hardware',
  LATTICE: 'Lattice Hardware',
  QR: 'QR Hardware Wallet Device',
  IMPORTED: 'Simple Key Pair'
};
exports.KEYRING_TYPES = KEYRING_TYPES;
const DEVICE_NAMES = {
  LEDGER: 'ledger',
  TREZOR: 'trezor',
  QR: 'QR Hardware',
  LATTICE: 'lattice'
};
exports.DEVICE_NAMES = DEVICE_NAMES;
const KEYRING_NAMES = {
  LEDGER: 'Ledger',
  TREZOR: 'Trezor',
  QR: 'QR',
  LATTICE: 'Lattice1'
};
/**
 * Used for setting the users preference for ledger transport type
 */

exports.KEYRING_NAMES = KEYRING_NAMES;
const LEDGER_TRANSPORT_TYPES = {
  LIVE: 'ledgerLive',
  WEBHID: 'webhid',
  U2F: 'u2f'
};
exports.LEDGER_TRANSPORT_TYPES = LEDGER_TRANSPORT_TYPES;
const LEDGER_USB_VENDOR_ID = '0x2c97';
exports.LEDGER_USB_VENDOR_ID = LEDGER_USB_VENDOR_ID;
const WEBHID_CONNECTED_STATUSES = {
  CONNECTED: 'connected',
  NOT_CONNECTED: 'notConnected',
  UNKNOWN: 'unknown'
};
exports.WEBHID_CONNECTED_STATUSES = WEBHID_CONNECTED_STATUSES;
const TRANSPORT_STATES = {
  NONE: 'NONE',
  VERIFIED: 'VERIFIED',
  DEVICE_OPEN_FAILURE: 'DEVICE_OPEN_FAILURE',
  UNKNOWN_FAILURE: 'UNKNOWN_FAILURE'
};
exports.TRANSPORT_STATES = TRANSPORT_STATES;
const AFFILIATE_LINKS = {
  LEDGER: 'https://shop.ledger.com/?r=17c4991a03fa',
  GRIDPLUS: 'https://gridplus.io/?afmc=7p',
  TREZOR: 'https://shop.trezor.io/product/trezor-one-black?offer_id=35&aff_id=11009',
  KEYSTONE: 'https://shop.keyst.one/?rfsn=6088257.656b3e9&utm_source=refersion&utm_medium=affiliate&utm_campaign=6088257.656b3e9',
  AIRGAP: 'https://airgap.it/',
  COOLWALLET: 'https://www.coolwallet.io/',
  DCENT: 'https://dcentwallet.com/'
};
exports.AFFILIATE_LINKS = AFFILIATE_LINKS;
const AFFILIATE_TUTORIAL_LINKS = {
  LEDGER: 'https://support.ledger.com/hc/en-us/articles/4404366864657-Set-up-and-use-MetaMask-to-access-your-Ledger-Ethereum-ETH-account?docs=true',
  GRIDPLUS: 'https://docs.gridplus.io/setup/metamask',
  TREZOR: 'https://wiki.trezor.io/Apps:MetaMask',
  KEYSTONE: 'https://support.keyst.one/3rd-party-wallets/eth-and-web3-wallets-keystone/bind-metamask-with-keystone',
  AIRGAP: 'https://support.airgap.it/guides/metamask/',
  COOLWALLET: 'https://www.coolwallet.io/metamask-step-by-step-guides/',
  DCENT: 'https://medium.com/dcentwallet/dcent-wallet-now-supports-qr-based-protocol-to-link-with-metamask-57555f02603f'
};
exports.AFFILIATE_TUTORIAL_LINKS = AFFILIATE_TUTORIAL_LINKS;


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\labels.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\labels.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRUNCATED_NAME_CHAR_LIMIT = exports.TRUNCATED_ADDRESS_START_CHARS = exports.TRUNCATED_ADDRESS_END_CHARS = void 0;
// The character limit on ENS names, nicknames and addresses before we truncate
const TRUNCATED_NAME_CHAR_LIMIT = 11; // The number of characters to slice from the beginning of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`

exports.TRUNCATED_NAME_CHAR_LIMIT = TRUNCATED_NAME_CHAR_LIMIT;
const TRUNCATED_ADDRESS_START_CHARS = 5; // The number of characters to slice from the end of an address for truncated format:
// `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`

exports.TRUNCATED_ADDRESS_START_CHARS = TRUNCATED_ADDRESS_START_CHARS;
const TRUNCATED_ADDRESS_END_CHARS = 4;
exports.TRUNCATED_ADDRESS_END_CHARS = TRUNCATED_ADDRESS_END_CHARS;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\metametrics.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\metametrics.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRAITS = exports.REJECT_NOTFICIATION_CLOSE_SIG = exports.REJECT_NOTFICIATION_CLOSE = exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = exports.METAMETRICS_ANONYMOUS_ID = exports.EVENT_NAMES = exports.EVENT = exports.CONTEXT_PROPS = void 0;
// Type Imports

/**
 * @typedef {__import__('../../shared/constants/app').EnvironmentType} EnvironmentType
 */
// Type Declarations

/**
 * Used to attach context of where the user was at in the application when the
 * event was triggered. Also included as full details of the current page in
 * page events.
 *
 * @typedef {object} MetaMetricsPageObject
 * @property {string} [path] - the path of the current page (e.g /home)
 * @property {string} [title] - the title of the current page (e.g 'home')
 * @property {string} [url] - the fully qualified url of the current page
 */

/**
 * For metamask, this is the dapp that triggered an interaction
 *
 * @typedef {object} MetaMetricsReferrerObject
 * @property {string} [url] - the origin of the dapp issuing the
 *  notification
 */

/**
 * We attach context to every meta metrics event that help to qualify our
 * analytics. This type has all optional values because it represents a
 * returned object from a method call. Ideally app and userAgent are
 * defined on every event. This is confirmed in the getTrackMetaMetricsEvent
 * function, but still provides the consumer a way to override these values if
 * necessary.
 *
 * @typedef {object} MetaMetricsContext
 * @property {object} app - Application metadata.
 * @property {string} app.name - the name of the application tracking the event
 * @property {string} app.version - the version of the application
 * @property {string} userAgent - the useragent string of the user
 * @property {MetaMetricsPageObject} [page] - an object representing details of
 *  the current page
 * @property {MetaMetricsReferrerObject} [referrer] - for metamask, this is the
 *  dapp that triggered an interaction
 */

/**
 * @typedef {object} MetaMetricsEventPayload
 * @property {string} event - event name to track
 * @property {string} category - category to associate event to
 * @property {string} [environmentType] - The type of environment this event
 *  occurred in. Defaults to the background process type
 * @property {object} [properties] - object of custom values to track, keys
 *  in this object must be in snake_case
 * @property {object} [sensitiveProperties] - Object of sensitive values to
 *  track. Keys in this object must be in snake_case. These properties will be
 *  sent in an additional event that excludes the user's metaMetricsId
 * @property {number} [revenue] - amount of currency that event creates in
 *  revenue for MetaMask
 * @property {string} [currency] - ISO 4127 format currency for events with
 *  revenue, defaults to US dollars
 * @property {number} [value] - Abstract business "value" attributable to
 *  customers who trigger this event
 * @property {MetaMetricsPageObject} [page] - the page/route that the event
 *  occurred on
 * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp
 *  that triggered the event
 */

/**
 * @typedef {object} MetaMetricsEventOptions
 * @property {boolean} [isOptIn] - happened during opt in/out workflow
 * @property {boolean} [flushImmediately] - When true will automatically flush
 *  the segment queue after tracking the event. Recommended if the result of
 *  tracking the event must be known before UI transition or update
 * @property {boolean} [excludeMetaMetricsId] - whether to exclude the user's
 *  metametrics id for anonymity
 * @property {string} [metaMetricsId] - an override for the metaMetricsId in
 *  the event one is created as part of an asynchronous workflow, such as
 *  awaiting the result of the metametrics opt-in function that generates the
 *  user's metametrics id
 * @property {boolean} [matomoEvent] - is this event a holdover from matomo
 *  that needs further migration? when true, sends the data to a special
 *  segment source that marks the event data as not conforming to our schema
 */

/**
 * @typedef {object} MetaMetricsEventFragment
 * @property {string} successEvent - The event name to fire when the fragment
 *  is closed in an affirmative action.
 * @property {string} [failureEvent] - The event name to fire when the fragment
 *  is closed with a rejection.
 * @property {string} [initialEvent] - An event name to fire immediately upon
 *  fragment creation. This is useful for building funnels in mixpanel and for
 *  reduction of code duplication.
 * @property {string} category - the event category to use for both the success
 *  and failure events
 * @property {boolean} [persist] - Should this fragment be persisted in
 *  state and progressed after the extension is locked and unlocked.
 * @property {number} [timeout] - Time in seconds the event should be persisted
 *  for. After the timeout the fragment will be closed as abandoned. if not
 *  supplied the fragment is stored indefinitely.
 * @property {number} [lastUpdated] - Date.now() when the fragment was last
 *  updated. Used to determine if the timeout has expired and the fragment
 *  should be closed.
 * @property {object} [properties] - Object of custom values to track, keys in
 *  this object must be in snake_case.
 * @property {object} [sensitiveProperties] - Object of sensitive values to
 *  track. Keys in this object must be in snake_case. These properties will be
 *  sent in an additional event that excludes the user's metaMetricsId
 * @property {number} [revenue] - amount of currency that event creates in
 *  revenue for MetaMask if fragment is successful.
 * @property {string} [currency] - ISO 4127 format currency for events with
 *  revenue, defaults to US dollars
 * @property {number} [value] - Abstract business "value" attributable to
 *  customers who successfully complete this fragment
 * @property {MetaMetricsPageObject} [page] - the page/route that the event
 *  occurred on
 * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp
 *  that initiated the event fragment.
 * @property {string} [uniqueIdentifier] - optional argument to override the
 *  automatic generation of UUID for the event fragment. This is useful when
 *  tracking events for subsystems that already generate UUIDs so to avoid
 *  unnecessary lookups and reduce accidental duplication.
 */

/**
 * Represents the shape of data sent to the segment.track method.
 *
 * @typedef {object} SegmentEventPayload
 * @property {string} [userId] - The metametrics id for the user
 * @property {string} [anonymousId] - An anonymousId that is used to track
 *  sensitive data while preserving anonymity.
 * @property {string} event - name of the event to track
 * @property {object} properties - properties to attach to the event
 * @property {MetaMetricsContext} context - the context the event occurred in
 */

/**
 * @typedef {object} MetaMetricsPagePayload
 * @property {string} name - The name of the page that was viewed
 * @property {object} [params] - The variadic parts of the page url
 *  example (route: `/asset/:asset`, path: `/asset/ETH`)
 *  params: { asset: 'ETH' }
 * @property {EnvironmentType} environmentType - the environment type that the
 *  page was viewed in
 * @property {MetaMetricsPageObject} [page] - the details of the page
 * @property {MetaMetricsReferrerObject} [referrer] - dapp that triggered the page
 *  view
 */

/**
 * @typedef {object} MetaMetricsPageOptions
 * @property {boolean} [isOptInPath] - is the current path one of the pages in
 *  the onboarding workflow? If true and participateInMetaMetrics is null track
 *  the page view
 */

/**
 * @typedef {object} Traits
 * @property {'address_book_entries'} ADDRESS_BOOK_ENTRIES - When the user
 *  adds or modifies addresses in address book the address_book_entries trait
 *  is identified.
 * @property {'ledger_connection_type'} LEDGER_CONNECTION_TYPE - when ledger
 *  live connnection type is changed we identify the ledger_connection_type
 *  trait
 * @property {'networks_added'} NETWORKS_ADDED - when user modifies networks
 *  we identify the networks_added trait
 * @property {'networks_without_ticker'} NETWORKS_WITHOUT_TICKER - when user
 *  modifies networks we identify the networks_without_ticker trait for
 *  networks without a ticker.
 * @property {'nft_autodetection_enabled'} NFT_AUTODETECTION_ENABLED - when Autodetect NFTs
 * feature is toggled we identify the nft_autodetection_enabled trait
 * @property {'number_of_accounts'} NUMBER_OF_ACCOUNTS - when identities
 *  change, we identify the new number_of_accounts trait
 * @property {'number_of_nft_collections'} NUMBER_OF_NFT_COLLECTIONS - user
 *  trait for number of unique NFT addresses
 * @property {'number_of_nfts'} NUMBER_OF_NFTS - user trait for number of all NFT addresses
 * @property {'number_of_tokens'} NUMBER_OF_TOKENS - when the number of tokens change, we
 * identify the new number_of_tokens trait
 * @property {'opensea_api_enabled'} OPENSEA_API_ENABLED - when the OpenSea API is enabled
 * we identify the opensea_api_enabled trait
 * @property {'three_box_enabled'} THREE_BOX_ENABLED - When 3Box feature is
 *  toggled we identify the 3box_enabled trait. This trait has been deprecated.
 * @property {'theme'} THEME - when the user's theme changes we identify the theme trait
 * @property {'token_detection_enabled'} TOKEN_DETECTION_ENABLED - when token detection feature is toggled we
 * identify the token_detection_enabled trait
 * @property {'install_date_ext'} INSTALL_DATE_EXT - when the user installed the extension
 */

/**
 *
 * @type {Traits}
 */
const TRAITS = {
  ADDRESS_BOOK_ENTRIES: 'address_book_entries',
  INSTALL_DATE_EXT: 'install_date_ext',
  LEDGER_CONNECTION_TYPE: 'ledger_connection_type',
  NETWORKS_ADDED: 'networks_added',
  NETWORKS_WITHOUT_TICKER: 'networks_without_ticker',
  NFT_AUTODETECTION_ENABLED: 'nft_autodetection_enabled',
  NUMBER_OF_ACCOUNTS: 'number_of_accounts',
  NUMBER_OF_NFT_COLLECTIONS: 'number_of_nft_collections',
  NUMBER_OF_NFTS: 'number_of_nfts',
  NUMBER_OF_TOKENS: 'number_of_tokens',
  OPENSEA_API_ENABLED: 'opensea_api_enabled',
  THEME: 'theme',
  THREE_BOX_ENABLED: 'three_box_enabled',
  TOKEN_DETECTION_ENABLED: 'token_detection_enabled'
};
/**
 * @typedef {object} MetaMetricsTraits
 * @property {number} [address_book_entries] - The number of entries in the
 *  user's address book.
 * @property {'ledgerLive' | 'webhid' | 'u2f'} [ledger_connection_type] - the
 *  type of ledger connection set by user preference.
 * @property {Array<string>} [networks_added] - An array consisting of chainIds
 *  that indicate the networks a user has added to their MetaMask.
 * @property {Array<string>} [networks_without_ticker] - An array consisting of
 *  chainIds that indicate the networks added by the user that do not have a
 *  ticker.
 * @property {number} [nft_autodetection_enabled] - does the user have the
 * use collection/nft detection enabled?
 * @property {number} [number_of_accounts] - A number representing the number
 *  of identities(accounts) added to the user's MetaMask.
 * @property {number} [number_of_nft_collections] - A number representing the
 *  amount of different NFT collections the user possesses an NFT from.
 * @property {number} [number_of_nfts] - A number representing the
 *  amount of all NFTs the user possesses across all networks and accounts.
 * @property {number} [number_of_tokens] - The total number of token contracts
 *  the user has across all networks and accounts.
 * @property {boolean} [opensea_api_enabled] - does the user have the OpenSea
 *  API enabled?
 * @property {boolean} [three_box_enabled] - Does the user have 3box sync
 *  enabled? (deprecated)
 * @property {string} [theme] - which theme the user has selected
 * @property {boolean} [token_detection_enabled] - does the user have token detection is enabled?
 */
// Mixpanel converts the zero address value to a truly anonymous event, which
// speeds up reporting

exports.TRAITS = TRAITS;
const METAMETRICS_ANONYMOUS_ID = '0x0000000000000000';
/**
 * This object is used to identify events that are triggered by the background
 * process.
 *
 * @type {MetaMetricsPageObject}
 */

exports.METAMETRICS_ANONYMOUS_ID = METAMETRICS_ANONYMOUS_ID;
const METAMETRICS_BACKGROUND_PAGE_OBJECT = {
  path: '/background-process',
  title: 'Background Process',
  url: '/background-process'
};
/**
 * @typedef {object} SegmentInterface
 * @property {SegmentEventPayload[]} queue - A queue of events to be sent when
 *  the flushAt limit has been reached, or flushInterval occurs
 * @property {() => void} flush - Immediately flush the queue, resetting it to
 *  an empty array and sending the pending events to Segment
 * @property {(
 *  payload: SegmentEventPayload,
 *  callback: (err?: Error) => void
 * ) => void} track - Track an event with Segment, using the internal batching
 *  mechanism to optimize network requests
 * @property {(payload: object) => void} page - Track a page view with Segment
 * @property {() => void} identify - Identify an anonymous user. We do not
 *  currently use this method.
 */

exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = METAMETRICS_BACKGROUND_PAGE_OBJECT;
const REJECT_NOTFICIATION_CLOSE = 'Cancel Via Notification Close';
exports.REJECT_NOTFICIATION_CLOSE = REJECT_NOTFICIATION_CLOSE;
const REJECT_NOTFICIATION_CLOSE_SIG = 'Cancel Sig Request Via Notification Close';
/**
 * EVENTS
 */

exports.REJECT_NOTFICIATION_CLOSE_SIG = REJECT_NOTFICIATION_CLOSE_SIG;
const EVENT_NAMES = {
  ACCOUNT_ADDED: 'Account Added',
  ACCOUNT_ADD_SELECTED: 'Account Add Selected',
  ACCOUNT_ADD_FAILED: 'Account Add Failed',
  ACCOUNT_PASSWORD_CREATED: 'Wallet Password Created',
  ACCOUNT_RESET: 'Account Reset',
  APP_INSTALLED: 'App Installed',
  APP_UNLOCKED: 'App Unlocked',
  APP_UNLOCKED_FAILED: 'App Unlocked Failed',
  APP_WINDOW_EXPANDED: 'App Window Expanded',
  DECRYPTION_APPROVED: 'Decryption Approved',
  DECRYPTION_REJECTED: 'Decryption Rejected',
  DECRYPTION_REQUESTED: 'Decryption Requested',
  ENCRYPTION_PUBLIC_KEY_APPROVED: 'Encryption Approved',
  ENCRYPTION_PUBLIC_KEY_REJECTED: 'Encryption Rejected',
  ENCRYPTION_PUBLIC_KEY_REQUESTED: 'Encryption Requested',
  EXTERNAL_LINK_CLICKED: 'External Link Clicked',
  KEY_EXPORT_SELECTED: 'Key Export Selected',
  KEY_EXPORT_REQUESTED: 'Key Export Requested',
  KEY_EXPORT_FAILED: 'Key Export Failed',
  KEY_EXPORT_CANCELED: 'Key Export Canceled',
  KEY_EXPORT_REVEALED: 'Key Material Revealed',
  KEY_EXPORT_COPIED: 'Key Material Copied',
  METRICS_OPT_IN: 'Metrics Opt In',
  METRICS_OPT_OUT: 'Metrics Opt Out',
  NAV_ACCOUNT_MENU_OPENED: 'Account Menu Opened',
  NAV_ACCOUNT_DETAILS_OPENED: 'Account Details Opened',
  NAV_CONNECTED_SITES_OPENED: 'Connected Sites Opened',
  NAV_MAIN_MENU_OPENED: 'Main Menu Opened',
  NAV_NETWORK_MENU_OPENED: 'Network Menu Opened',
  NAV_SETTINGS_OPENED: 'Settings Opened',
  NAV_ACCOUNT_SWITCHED: 'Account Switched',
  NAV_NETWORK_SWITCHED: 'Network Switched',
  NAV_BUY_BUTTON_CLICKED: 'Buy Button Clicked',
  NAV_SEND_BUTTON_CLICKED: 'Send Button Clicked',
  NAV_SWAP_BUTTON_CLICKED: 'Swap Button Clicked',
  SRP_TO_CONFIRM_BACKUP: 'SRP Backup Confirm Displayed',
  WALLET_SETUP_STARTED: 'Wallet Setup Selected',
  WALLET_SETUP_CANCELED: 'Wallet Setup Canceled',
  WALLET_SETUP_FAILED: 'Wallet Setup Failed',
  WALLET_CREATED: 'Wallet Created',
  NFT_ADDED: 'NFT Added',
  ONRAMP_PROVIDER_SELECTED: 'On-ramp Provider Selected',
  PERMISSIONS_APPROVED: 'Permissions Approved',
  PERMISSIONS_REJECTED: 'Permissions Rejected',
  PERMISSIONS_REQUESTED: 'Permissions Requested',
  PORTFOLIO_LINK_CLICKED: 'Portfolio Link Clicked',
  PUBLIC_ADDRESS_COPIED: 'Public Address Copied',
  PROVIDER_METHOD_CALLED: 'Provider Method Called',
  SIGNATURE_APPROVED: 'Signature Approved',
  SIGNATURE_REJECTED: 'Signature Rejected',
  SIGNATURE_REQUESTED: 'Signature Requested',
  TOKEN_IMPORT_BUTTON_CLICKED: 'Import Token Button Clicked',
  TOKEN_SCREEN_OPENED: 'Token Screen Opened',
  SUPPORT_LINK_CLICKED: 'Support Link Clicked',
  TOKEN_ADDED: 'Token Added',
  TOKEN_DETECTED: 'Token Detected',
  TOKEN_HIDDEN: 'Token Hidden',
  TOKEN_IMPORT_CANCELED: 'Token Import Canceled',
  TOKEN_IMPORT_CLICKED: 'Token Import Clicked'
};
exports.EVENT_NAMES = EVENT_NAMES;
const EVENT = {
  ACCOUNT_TYPES: {
    DEFAULT: 'metamask',
    IMPORTED: 'imported',
    HARDWARE: 'hardware'
  },
  ACCOUNT_IMPORT_TYPES: {
    JSON: 'json',
    PRIVATE_KEY: 'private_key',
    SRP: 'srp'
  },
  CATEGORIES: {
    ACCOUNTS: 'Accounts',
    APP: 'App',
    AUTH: 'Auth',
    BACKGROUND: 'Background',
    ERROR: 'Error',
    FOOTER: 'Footer',
    HOME: 'Home',
    INPAGE_PROVIDER: 'inpage_provider',
    KEYS: 'Keys',
    MESSAGES: 'Messages',
    NAVIGATION: 'Navigation',
    NETWORK: 'Network',
    ONBOARDING: 'Onboarding',
    RETENTION: 'Retention',
    SETTINGS: 'Settings',
    SNAPS: 'Snaps',
    SWAPS: 'Swaps',
    TRANSACTIONS: 'Transactions',
    WALLET: 'Wallet'
  },
  EXTERNAL_LINK_TYPES: {
    TRANSACTION_BLOCK_EXPLORER: 'Transaction Block Explorer',
    BLOCK_EXPLORER: 'Block Explorer',
    ACCOUNT_TRACKER: 'Account Tracker',
    TOKEN_TRACKER: 'Token Tracker'
  },
  KEY_TYPES: {
    PKEY: 'private_key',
    SRP: 'srp'
  },
  ONRAMP_PROVIDER_TYPES: {
    COINBASE: 'coinbase',
    MOONPAY: 'moonpay',
    WYRE: 'wyre',
    TRANSAK: 'transak',
    SELF_DEPOSIT: 'direct_deposit'
  },
  SOURCE: {
    NETWORK: {
      CUSTOM_NETWORK_FORM: 'custom_network_form',
      POPULAR_NETWORK_LIST: 'popular_network_list'
    },
    SWAPS: {
      MAIN_VIEW: 'Main View',
      TOKEN_VIEW: 'Token View'
    },
    TOKEN: {
      CUSTOM: 'custom',
      DAPP: 'dapp',
      DETECTED: 'detected',
      LIST: 'list'
    },
    TRANSACTION: {
      DAPP: 'dapp',
      USER: 'user'
    }
  },
  LOCATION: {
    TOKEN_DETAILS: 'token_details',
    TOKEN_DETECTION: 'token_detection',
    TOKEN_MENU: 'token_menu'
  }
}; // Values below (e.g. 'location') can be used in the "properties"
// tracking object as keys, e.g. { location: 'Home' }

exports.EVENT = EVENT;
const CONTEXT_PROPS = {
  PAGE_TITLE: 'location'
};
exports.CONTEXT_PROPS = CONTEXT_PROPS;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\network.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.infuraProjectId = exports.getRpcUrl = exports.UNSUPPORTED_RPC_METHODS = exports.TEST_NETWORK_TICKER_MAP = exports.TEST_ETH_TOKEN_IMAGE_URL = exports.TEST_CHAINS = exports.SEPOLIA_RPC_URL = exports.SEPOLIA_DISPLAY_NAME = exports.POLYGON_DISPLAY_NAME = exports.PALM_TOKEN_IMAGE_URL = exports.PALM_DISPLAY_NAME = exports.OPTIMISM_TOKEN_IMAGE_URL = exports.OPTIMISM_DISPLAY_NAME = exports.NETWORK_TYPES = exports.NETWORK_TO_NAME_MAP = exports.NETWORK_NAMES = exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = exports.NETWORK_IDS = exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = exports.MAX_SAFE_CHAIN_ID = exports.MATIC_TOKEN_IMAGE_URL = exports.MAINNET_RPC_URL = exports.MAINNET_DISPLAY_NAME = exports.LOCALHOST_RPC_URL = exports.LOCALHOST_DISPLAY_NAME = exports.IPFS_DEFAULT_GATEWAY_URL = exports.INFURA_PROVIDER_TYPES = exports.INFURA_BLOCKED_KEY = exports.HARMONY_ONE_TOKEN_IMAGE_URL = exports.HARMONY_DISPLAY_NAME = exports.HARDFORKS = exports.GOERLI_RPC_URL = exports.GOERLI_DISPLAY_NAME = exports.FTM_TOKEN_IMAGE_URL = exports.FEATURED_RPCS = exports.FANTOM_DISPLAY_NAME = exports.ETH_TOKEN_IMAGE_URL = exports.CURRENCY_SYMBOLS = exports.CHAIN_ID_TO_TYPE_MAP = exports.CHAIN_ID_TO_RPC_URL_MAP = exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = exports.CHAIN_ID_TO_NETWORK_ID_MAP = exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = exports.CHAIN_IDS = exports.BUYABLE_CHAINS_MAP = exports.BUILT_IN_NETWORKS = exports.BSC_DISPLAY_NAME = exports.BNB_TOKEN_IMAGE_URL = exports.BNB_DISPLAY_NAME = exports.AVAX_TOKEN_IMAGE_URL = exports.AVALANCHE_DISPLAY_NAME = exports.AURORA_TOKEN_IMAGE_URL = exports.AURORA_DISPLAY_NAME = exports.ARBITRUM_DISPLAY_NAME = exports.AETH_TOKEN_IMAGE_URL = void 0;

var _lodash = require("lodash");

/**
 * Throughout the extension we set the current provider by referencing its
 * "type", which can be any of the values in the below object. These values
 * represent the built-in networks of MetaMask, including test nets, as well
 * as "rpc" which is the "type" of a custom network added by the user or via
 * wallet_addEthereumChain.
 */
const NETWORK_TYPES = {
  GOERLI: 'goerli',
  LOCALHOST: 'localhost',
  MAINNET: 'mainnet',
  RPC: 'rpc',
  SEPOLIA: 'sepolia'
};
/**
 * An object containing shortcut names for any non-builtin network. We need
 * this to be able to differentiate between networks that require custom
 * sections of code for our various features, such as swaps or token lists.
 */

exports.NETWORK_TYPES = NETWORK_TYPES;
const NETWORK_NAMES = {
  HOMESTEAD: 'homestead'
};
/**
 * The Network ID for our builtin networks. This is the decimal equivalent of
 * the chain id for the network, but is expresssed as a string. Many moons ago
 * the decision was made on the extension team to expressly use chainId with
 * hex encoding over network id. Consider that when accessing this object. Note
 * for cross product purposes: alignment with mobile on this matter has not
 * been fully achieved, thus it is possible for some dependencies to still
 * ask for or require network id.
 */

exports.NETWORK_NAMES = NETWORK_NAMES;
const NETWORK_IDS = {
  MAINNET: '1',
  GOERLI: '5',
  LOCALHOST: '1337',
  SEPOLIA: '11155111'
};
/**
 * An object containing all of the chain ids for networks both built in and
 * those that we have added custom code to support our feature set.
 */

exports.NETWORK_IDS = NETWORK_IDS;
const CHAIN_IDS = {
  MAINNET: '0x1',
  GOERLI: '0x5',
  LOCALHOST: '0x539',
  BSC: '0x38',
  OPTIMISM: '0xa',
  OPTIMISM_TESTNET: '0x1a4',
  POLYGON: '0x89',
  AVALANCHE: '0xa86a',
  FANTOM: '0xfa',
  CELO: '0xa4ec',
  ARBITRUM: '0xa4b1',
  HARMONY: '0x63564c40',
  PALM: '0x2a15c308d',
  SEPOLIA: '0xaa36a7',
  AURORA: '0x4e454152'
};
/**
 * The largest possible chain ID we can handle.
 * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553
 */

exports.CHAIN_IDS = CHAIN_IDS;
const MAX_SAFE_CHAIN_ID = 4503599627370476;
exports.MAX_SAFE_CHAIN_ID = MAX_SAFE_CHAIN_ID;
const MAINNET_DISPLAY_NAME = 'Ethereum Mainnet';
exports.MAINNET_DISPLAY_NAME = MAINNET_DISPLAY_NAME;
const GOERLI_DISPLAY_NAME = 'Goerli';
exports.GOERLI_DISPLAY_NAME = GOERLI_DISPLAY_NAME;
const SEPOLIA_DISPLAY_NAME = 'Sepolia';
exports.SEPOLIA_DISPLAY_NAME = SEPOLIA_DISPLAY_NAME;
const LOCALHOST_DISPLAY_NAME = 'Localhost 8545';
exports.LOCALHOST_DISPLAY_NAME = LOCALHOST_DISPLAY_NAME;
const BSC_DISPLAY_NAME = 'Binance Smart Chain';
exports.BSC_DISPLAY_NAME = BSC_DISPLAY_NAME;
const POLYGON_DISPLAY_NAME = 'Polygon';
exports.POLYGON_DISPLAY_NAME = POLYGON_DISPLAY_NAME;
const AVALANCHE_DISPLAY_NAME = 'Avalanche Network C-Chain';
exports.AVALANCHE_DISPLAY_NAME = AVALANCHE_DISPLAY_NAME;
const ARBITRUM_DISPLAY_NAME = 'Arbitrum One';
exports.ARBITRUM_DISPLAY_NAME = ARBITRUM_DISPLAY_NAME;
const BNB_DISPLAY_NAME = 'BNB Smart Chain (previously Binance Smart Chain Mainnet)';
exports.BNB_DISPLAY_NAME = BNB_DISPLAY_NAME;
const OPTIMISM_DISPLAY_NAME = 'Optimism';
exports.OPTIMISM_DISPLAY_NAME = OPTIMISM_DISPLAY_NAME;
const FANTOM_DISPLAY_NAME = 'Fantom Opera';
exports.FANTOM_DISPLAY_NAME = FANTOM_DISPLAY_NAME;
const HARMONY_DISPLAY_NAME = 'Harmony Mainnet Shard 0';
exports.HARMONY_DISPLAY_NAME = HARMONY_DISPLAY_NAME;
const PALM_DISPLAY_NAME = 'Palm';
exports.PALM_DISPLAY_NAME = PALM_DISPLAY_NAME;
const AURORA_DISPLAY_NAME = 'Aurora Mainnet';
exports.AURORA_DISPLAY_NAME = AURORA_DISPLAY_NAME;
const infuraProjectId = "bde1e349aa3c4803a5c3a71f5623ecce";
exports.infuraProjectId = infuraProjectId;

const getRpcUrl = ({
  network,
  excludeProjectId = false
}) => `https://${network}.infura.io/v3/${excludeProjectId ? '' : infuraProjectId}`;

exports.getRpcUrl = getRpcUrl;
const MAINNET_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.MAINNET
});
exports.MAINNET_RPC_URL = MAINNET_RPC_URL;
const GOERLI_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.GOERLI
});
exports.GOERLI_RPC_URL = GOERLI_RPC_URL;
const SEPOLIA_RPC_URL = getRpcUrl({
  network: NETWORK_TYPES.SEPOLIA
});
exports.SEPOLIA_RPC_URL = SEPOLIA_RPC_URL;
const LOCALHOST_RPC_URL = 'http://localhost:8545';
/**
 * An object containing the token symbols for various tokens that are either
 * native currencies or those that have been special cased by the extension
 * for supporting our feature set.
 */

exports.LOCALHOST_RPC_URL = LOCALHOST_RPC_URL;
const CURRENCY_SYMBOLS = {
  ARBITRUM: 'ETH',
  AURORA: 'Aurora ETH',
  AVALANCHE: 'AVAX',
  BNB: 'BNB',
  BUSD: 'BUSD',
  CELO: 'CELO',
  DAI: 'DAI',
  ETH: 'ETH',
  FANTOM: 'FTM',
  HARMONY: 'ONE',
  PALM: 'PALM',
  MATIC: 'MATIC',
  TEST_ETH: 'TESTETH',
  USDC: 'USDC',
  USDT: 'USDT',
  WETH: 'WETH'
};
/**
 * An object containing the token symbols for various tokens that are supported
 * on different on ramp providers. This object is meant for internal consumption,
 * hence why it is not exported.
 */

exports.CURRENCY_SYMBOLS = CURRENCY_SYMBOLS;
const SUPPORTED_CURRENCY_SYMBOLS = { ...CURRENCY_SYMBOLS,
  '1INCH': '1INCH',
  AAVE: 'AAVE',
  ABT: 'ABT',
  ACH: 'ACH',
  AGEUR: 'AGEUR',
  AGLD: 'AGLD',
  AMP: 'AMP',
  ANKR: 'ANKR',
  APE: 'APE',
  ARPA: 'ARPA',
  ASM: 'ASM',
  AUCTION: 'AUCTION',
  AXS: 'AXS',
  AVAX: 'AVAX',
  AVAXC: 'AVAXC',
  AVAXCUSDC: 'AVAXCUSDC',
  BADGER: 'BADGER',
  BAL: 'BAL',
  BAND: 'BAND',
  BAT: 'BAT',
  BNT: 'BNT',
  BOBA: 'BOBA',
  BOND: 'BOND',
  BTRST: 'BTRST',
  CHAIN: 'CHAIN',
  CHZ: 'CHZ',
  CLV: 'CLV',
  COMP: 'COMP',
  COTI: 'COTI',
  CRO: 'CRO',
  CRV: 'CRV',
  CTSI: 'CTSI',
  CVC: 'CVC',
  DAO: 'DAO',
  DDX: 'DDX',
  DNT: 'DNT',
  ENJ: 'ENJ',
  ENS: 'ENS',
  EURT: 'EURT',
  FARM: 'FARM',
  FET: 'FET',
  FORTH: 'FORTH',
  FX: 'FX',
  GNO: 'GNO',
  GRT: 'GRT',
  GTC: 'GTC',
  GTH: 'GTH',
  GUSD: 'GUSD',
  GYEN: 'GYEN',
  HEX: 'HEX',
  IOTX: 'IOTX',
  IMX: 'IMX',
  JASMY: 'JASMY',
  KEEP: 'KEEP',
  KNC: 'KNC',
  KRL: 'KRL',
  LCX: 'LCX',
  LINK: 'LINK',
  LPT: 'LPT',
  LRC: 'LRC',
  MANA: 'MANA',
  MASK: 'MASK',
  MINDS: 'MINDS',
  MIR: 'MIR',
  MKR: 'MKR',
  MLN: 'MLN',
  MTL: 'MTL',
  MUSDC: 'mUSDC',
  NKN: 'NKN',
  NMR: 'NMR',
  NU: 'NU',
  OGN: 'OGN',
  OMG: 'OMG',
  ORN: 'ORN',
  OXT: 'OXT',
  PAX: 'PAX',
  PERP: 'PERP',
  PLA: 'PLA',
  POLS: 'POLS',
  POLY: 'POLY',
  QNT: 'QNT',
  QUICK: 'QUICK',
  RAD: 'RAD',
  RAI: 'RAI',
  RARI: 'RARI',
  REN: 'REN',
  REP: 'REP',
  REQ: 'REQ',
  RLC: 'RLC',
  RLY: 'RLY',
  SAND: 'SAND',
  SHIB: 'SHIB',
  SKL: 'SKL',
  SNX: 'SNX',
  SPA: 'SPA',
  STETH: 'STETH',
  STORJ: 'STORJ',
  SUKU: 'SUKU',
  SUSHI: 'SUSHI',
  SWAP: 'SWAP',
  SWFTC: 'SWFTC',
  TRAC: 'TRAC',
  TRB: 'TRB',
  TRIBE: 'TRIBE',
  TRU: 'TRU',
  TXL: 'TXL',
  UMA: 'UMA',
  UNI: 'UNI',
  USDS: 'USDS',
  VRA: 'VRA',
  WBTC: 'WBTC',
  WCFG: 'WCFG',
  XYO: 'XYO',
  YFII: 'YFII',
  YFI: 'YFI',
  YLD: 'YLD',
  ZRX: 'ZRX',
  ZUSD: 'ZUSD'
};
const ETH_TOKEN_IMAGE_URL = './images/eth_logo.svg';
exports.ETH_TOKEN_IMAGE_URL = ETH_TOKEN_IMAGE_URL;
const TEST_ETH_TOKEN_IMAGE_URL = './images/black-eth-logo.svg';
exports.TEST_ETH_TOKEN_IMAGE_URL = TEST_ETH_TOKEN_IMAGE_URL;
const BNB_TOKEN_IMAGE_URL = './images/bnb.png';
exports.BNB_TOKEN_IMAGE_URL = BNB_TOKEN_IMAGE_URL;
const MATIC_TOKEN_IMAGE_URL = './images/matic-token.png';
exports.MATIC_TOKEN_IMAGE_URL = MATIC_TOKEN_IMAGE_URL;
const AVAX_TOKEN_IMAGE_URL = './images/avax-token.png';
exports.AVAX_TOKEN_IMAGE_URL = AVAX_TOKEN_IMAGE_URL;
const AETH_TOKEN_IMAGE_URL = './images/arbitrum.svg';
exports.AETH_TOKEN_IMAGE_URL = AETH_TOKEN_IMAGE_URL;
const FTM_TOKEN_IMAGE_URL = './images/fantom-opera.svg';
exports.FTM_TOKEN_IMAGE_URL = FTM_TOKEN_IMAGE_URL;
const HARMONY_ONE_TOKEN_IMAGE_URL = './images/harmony-one.svg';
exports.HARMONY_ONE_TOKEN_IMAGE_URL = HARMONY_ONE_TOKEN_IMAGE_URL;
const OPTIMISM_TOKEN_IMAGE_URL = './images/optimism.svg';
exports.OPTIMISM_TOKEN_IMAGE_URL = OPTIMISM_TOKEN_IMAGE_URL;
const PALM_TOKEN_IMAGE_URL = './images/palm.svg';
exports.PALM_TOKEN_IMAGE_URL = PALM_TOKEN_IMAGE_URL;
const AURORA_TOKEN_IMAGE_URL = './images/aurora.png';
exports.AURORA_TOKEN_IMAGE_URL = AURORA_TOKEN_IMAGE_URL;
const INFURA_PROVIDER_TYPES = [NETWORK_TYPES.MAINNET, NETWORK_TYPES.GOERLI, NETWORK_TYPES.SEPOLIA];
exports.INFURA_PROVIDER_TYPES = INFURA_PROVIDER_TYPES;
const TEST_CHAINS = [CHAIN_IDS.GOERLI, CHAIN_IDS.SEPOLIA, CHAIN_IDS.LOCALHOST];
exports.TEST_CHAINS = TEST_CHAINS;

const typedCapitalize = k => (0, _lodash.capitalize)(k);

const TEST_NETWORK_TICKER_MAP = {
  [NETWORK_TYPES.GOERLI]: `${typedCapitalize(NETWORK_TYPES.GOERLI)}${CURRENCY_SYMBOLS.ETH}`,
  [NETWORK_TYPES.SEPOLIA]: `${typedCapitalize(NETWORK_TYPES.SEPOLIA)}${CURRENCY_SYMBOLS.ETH}`
};
/**
 * Map of all build-in Infura networks to their network, ticker and chain IDs.
 */

exports.TEST_NETWORK_TICKER_MAP = TEST_NETWORK_TICKER_MAP;
const BUILT_IN_NETWORKS = {
  [NETWORK_TYPES.GOERLI]: {
    networkId: NETWORK_IDS.GOERLI,
    chainId: CHAIN_IDS.GOERLI,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.GOERLI]
  },
  [NETWORK_TYPES.SEPOLIA]: {
    networkId: NETWORK_IDS.SEPOLIA,
    chainId: CHAIN_IDS.SEPOLIA,
    ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA]
  },
  [NETWORK_TYPES.MAINNET]: {
    networkId: NETWORK_IDS.MAINNET,
    chainId: CHAIN_IDS.MAINNET
  },
  [NETWORK_TYPES.LOCALHOST]: {
    networkId: NETWORK_IDS.LOCALHOST,
    chainId: CHAIN_IDS.LOCALHOST
  }
};
exports.BUILT_IN_NETWORKS = BUILT_IN_NETWORKS;
const NETWORK_TO_NAME_MAP = {
  [NETWORK_TYPES.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_TYPES.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_TYPES.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_TYPES.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [NETWORK_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [NETWORK_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [NETWORK_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [NETWORK_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
  [CHAIN_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
  [CHAIN_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME
};
exports.NETWORK_TO_NAME_MAP = NETWORK_TO_NAME_MAP;
const CHAIN_ID_TO_TYPE_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_TYPES.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [CHAIN_IDS.LOCALHOST]: NETWORK_TYPES.LOCALHOST
};
exports.CHAIN_ID_TO_TYPE_MAP = CHAIN_ID_TO_TYPE_MAP;
const CHAIN_ID_TO_RPC_URL_MAP = {
  [CHAIN_IDS.GOERLI]: GOERLI_RPC_URL,
  [CHAIN_IDS.SEPOLIA]: SEPOLIA_RPC_URL,
  [CHAIN_IDS.MAINNET]: MAINNET_RPC_URL,
  [CHAIN_IDS.LOCALHOST]: LOCALHOST_RPC_URL
};
exports.CHAIN_ID_TO_RPC_URL_MAP = CHAIN_ID_TO_RPC_URL_MAP;
const CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = {
  [CHAIN_IDS.MAINNET]: ETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
  [CHAIN_IDS.BSC]: BNB_TOKEN_IMAGE_URL,
  [CHAIN_IDS.POLYGON]: MATIC_TOKEN_IMAGE_URL,
  [CHAIN_IDS.ARBITRUM]: AETH_TOKEN_IMAGE_URL,
  [CHAIN_IDS.FANTOM]: FTM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.HARMONY]: HARMONY_ONE_TOKEN_IMAGE_URL,
  [CHAIN_IDS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.PALM]: PALM_TOKEN_IMAGE_URL,
  [CHAIN_IDS.AURORA]: AURORA_TOKEN_IMAGE_URL
};
exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP;
const NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = {
  [NETWORK_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
  [NETWORK_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
  [NETWORK_IDS.MAINNET]: NETWORK_NAMES.HOMESTEAD
};
exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP;
const CHAIN_ID_TO_NETWORK_ID_MAP = {
  [CHAIN_IDS.MAINNET]: NETWORK_IDS.MAINNET,
  [CHAIN_IDS.GOERLI]: NETWORK_IDS.GOERLI,
  [CHAIN_IDS.SEPOLIA]: NETWORK_IDS.SEPOLIA,
  [CHAIN_IDS.LOCALHOST]: NETWORK_IDS.LOCALHOST
};
exports.CHAIN_ID_TO_NETWORK_ID_MAP = CHAIN_ID_TO_NETWORK_ID_MAP;
const NATIVE_CURRENCY_TOKEN_IMAGE_MAP = {
  [CURRENCY_SYMBOLS.ETH]: ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.TEST_ETH]: TEST_ETH_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.BNB]: BNB_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.MATIC]: MATIC_TOKEN_IMAGE_URL,
  [CURRENCY_SYMBOLS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL
};
exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = NATIVE_CURRENCY_TOKEN_IMAGE_MAP;
const INFURA_BLOCKED_KEY = 'countryBlocked';
/**
 * Hardforks are points in the chain where logic is changed significantly
 * enough where there is a fork and the new fork becomes the active chain.
 * These constants are presented in chronological order starting with BERLIN
 * because when we first needed to track the hardfork we had launched support
 * for EIP-2718 (where transactions can have types and different shapes) and
 * EIP-2930 (optional access lists), which were included in BERLIN.
 *
 * BERLIN - forked at block number 12,244,000, included typed transactions and
 * optional access lists
 * LONDON - future, upcoming fork that introduces the baseFeePerGas, an amount
 * of the ETH transaction fees that will be burned instead of given to the
 * miner. This change necessitated the third type of transaction envelope to
 * specify maxFeePerGas and maxPriorityFeePerGas moving the fee bidding system
 * to a second price auction model.
 */

exports.INFURA_BLOCKED_KEY = INFURA_BLOCKED_KEY;
const HARDFORKS = {
  BERLIN: 'berlin',
  LONDON: 'london'
};
exports.HARDFORKS = HARDFORKS;
const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
  [CHAIN_IDS.OPTIMISM]: 1,
  [CHAIN_IDS.OPTIMISM_TESTNET]: 1
};
/**
 * Ethereum JSON-RPC methods that are known to exist but that we intentionally
 * do not support.
 */

exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP;
const UNSUPPORTED_RPC_METHODS = new Set([// This is implemented later in our middleware stack  specifically, in
// eth-json-rpc-middleware  but our UI does not support it.
'eth_signTransaction']);
exports.UNSUPPORTED_RPC_METHODS = UNSUPPORTED_RPC_METHODS;
const IPFS_DEFAULT_GATEWAY_URL = 'dweb.link'; // The first item in transakCurrencies must be the
// default crypto currency for the network

exports.IPFS_DEFAULT_GATEWAY_URL = IPFS_DEFAULT_GATEWAY_URL;
const BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME = 'ethereum';
const BUYABLE_CHAINS_MAP = {
  [CHAIN_IDS.MAINNET]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME,
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS['1INCH'], SUPPORTED_CURRENCY_SYMBOLS.AAVE, SUPPORTED_CURRENCY_SYMBOLS.AGEUR, SUPPORTED_CURRENCY_SYMBOLS.BUSD, SUPPORTED_CURRENCY_SYMBOLS.CHAIN, SUPPORTED_CURRENCY_SYMBOLS.CLV, SUPPORTED_CURRENCY_SYMBOLS.COMP, SUPPORTED_CURRENCY_SYMBOLS.CTSI, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.DAO, SUPPORTED_CURRENCY_SYMBOLS.ENJ, SUPPORTED_CURRENCY_SYMBOLS.EURT, SUPPORTED_CURRENCY_SYMBOLS.GTH, SUPPORTED_CURRENCY_SYMBOLS.HEX, SUPPORTED_CURRENCY_SYMBOLS.LINK, SUPPORTED_CURRENCY_SYMBOLS.MANA, SUPPORTED_CURRENCY_SYMBOLS.MASK, SUPPORTED_CURRENCY_SYMBOLS.MINDS, SUPPORTED_CURRENCY_SYMBOLS.MKR, SUPPORTED_CURRENCY_SYMBOLS.PLA, SUPPORTED_CURRENCY_SYMBOLS.POLS, SUPPORTED_CURRENCY_SYMBOLS.SAND, SUPPORTED_CURRENCY_SYMBOLS.STETH, SUPPORTED_CURRENCY_SYMBOLS.SUSHI, SUPPORTED_CURRENCY_SYMBOLS.SWAP, SUPPORTED_CURRENCY_SYMBOLS.TXL, SUPPORTED_CURRENCY_SYMBOLS.UNI, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.VRA, SUPPORTED_CURRENCY_SYMBOLS.WBTC, SUPPORTED_CURRENCY_SYMBOLS.YLD],
    moonPay: {
      defaultCurrencyCode: SUPPORTED_CURRENCY_SYMBOLS.ETH,
      showOnlyCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.ORN, SUPPORTED_CURRENCY_SYMBOLS.WETH, SUPPORTED_CURRENCY_SYMBOLS.IMX]
    },
    wyre: {
      srn: 'ethereum',
      currencyCode: CURRENCY_SYMBOLS.ETH,
      currencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS.AAVE, SUPPORTED_CURRENCY_SYMBOLS.BAT, SUPPORTED_CURRENCY_SYMBOLS.BUSD, SUPPORTED_CURRENCY_SYMBOLS.COMP, SUPPORTED_CURRENCY_SYMBOLS.CRV, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.GUSD, SUPPORTED_CURRENCY_SYMBOLS.GYEN, SUPPORTED_CURRENCY_SYMBOLS.LINK, SUPPORTED_CURRENCY_SYMBOLS.MKR, SUPPORTED_CURRENCY_SYMBOLS.PAX, SUPPORTED_CURRENCY_SYMBOLS.RAI, SUPPORTED_CURRENCY_SYMBOLS.SNX, SUPPORTED_CURRENCY_SYMBOLS.UMA, SUPPORTED_CURRENCY_SYMBOLS.UNI, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDS, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.WBTC, SUPPORTED_CURRENCY_SYMBOLS.WETH, SUPPORTED_CURRENCY_SYMBOLS.YFI, SUPPORTED_CURRENCY_SYMBOLS.ZUSD]
    },
    coinbasePayCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS['1INCH'], SUPPORTED_CURRENCY_SYMBOLS.AAVE, SUPPORTED_CURRENCY_SYMBOLS.ABT, SUPPORTED_CURRENCY_SYMBOLS.ACH, SUPPORTED_CURRENCY_SYMBOLS.AGLD, SUPPORTED_CURRENCY_SYMBOLS.AMP, SUPPORTED_CURRENCY_SYMBOLS.ANKR, SUPPORTED_CURRENCY_SYMBOLS.APE, SUPPORTED_CURRENCY_SYMBOLS.ARPA, SUPPORTED_CURRENCY_SYMBOLS.ASM, SUPPORTED_CURRENCY_SYMBOLS.AUCTION, SUPPORTED_CURRENCY_SYMBOLS.AXS, SUPPORTED_CURRENCY_SYMBOLS.BADGER, SUPPORTED_CURRENCY_SYMBOLS.BAL, SUPPORTED_CURRENCY_SYMBOLS.BAND, SUPPORTED_CURRENCY_SYMBOLS.BAT, SUPPORTED_CURRENCY_SYMBOLS.BNT, SUPPORTED_CURRENCY_SYMBOLS.BOBA, SUPPORTED_CURRENCY_SYMBOLS.BOND, SUPPORTED_CURRENCY_SYMBOLS.BTRST, SUPPORTED_CURRENCY_SYMBOLS.CHZ, SUPPORTED_CURRENCY_SYMBOLS.CLV, SUPPORTED_CURRENCY_SYMBOLS.COMP, SUPPORTED_CURRENCY_SYMBOLS.COTI, SUPPORTED_CURRENCY_SYMBOLS.CRO, SUPPORTED_CURRENCY_SYMBOLS.CRV, SUPPORTED_CURRENCY_SYMBOLS.CTSI, SUPPORTED_CURRENCY_SYMBOLS.CVC, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.DDX, SUPPORTED_CURRENCY_SYMBOLS.DNT, SUPPORTED_CURRENCY_SYMBOLS.ENJ, SUPPORTED_CURRENCY_SYMBOLS.ENS, SUPPORTED_CURRENCY_SYMBOLS.FARM, SUPPORTED_CURRENCY_SYMBOLS.FET, SUPPORTED_CURRENCY_SYMBOLS.FORTH, SUPPORTED_CURRENCY_SYMBOLS.FX, SUPPORTED_CURRENCY_SYMBOLS.GNO, SUPPORTED_CURRENCY_SYMBOLS.GRT, SUPPORTED_CURRENCY_SYMBOLS.GTC, SUPPORTED_CURRENCY_SYMBOLS.IOTX, SUPPORTED_CURRENCY_SYMBOLS.JASMY, SUPPORTED_CURRENCY_SYMBOLS.KEEP, SUPPORTED_CURRENCY_SYMBOLS.KNC, SUPPORTED_CURRENCY_SYMBOLS.KRL, SUPPORTED_CURRENCY_SYMBOLS.LCX, SUPPORTED_CURRENCY_SYMBOLS.LINK, SUPPORTED_CURRENCY_SYMBOLS.LPT, SUPPORTED_CURRENCY_SYMBOLS.LRC, SUPPORTED_CURRENCY_SYMBOLS.MANA, SUPPORTED_CURRENCY_SYMBOLS.MASK, SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.MIR, SUPPORTED_CURRENCY_SYMBOLS.MKR, SUPPORTED_CURRENCY_SYMBOLS.MLN, SUPPORTED_CURRENCY_SYMBOLS.MTL, SUPPORTED_CURRENCY_SYMBOLS.NKN, SUPPORTED_CURRENCY_SYMBOLS.NMR, SUPPORTED_CURRENCY_SYMBOLS.NU, SUPPORTED_CURRENCY_SYMBOLS.OGN, SUPPORTED_CURRENCY_SYMBOLS.OMG, SUPPORTED_CURRENCY_SYMBOLS.OXT, SUPPORTED_CURRENCY_SYMBOLS.PAX, SUPPORTED_CURRENCY_SYMBOLS.PERP, SUPPORTED_CURRENCY_SYMBOLS.PLA, SUPPORTED_CURRENCY_SYMBOLS.POLY, SUPPORTED_CURRENCY_SYMBOLS.QNT, SUPPORTED_CURRENCY_SYMBOLS.QUICK, SUPPORTED_CURRENCY_SYMBOLS.RAD, SUPPORTED_CURRENCY_SYMBOLS.RAI, SUPPORTED_CURRENCY_SYMBOLS.RARI, SUPPORTED_CURRENCY_SYMBOLS.REN, SUPPORTED_CURRENCY_SYMBOLS.REP, SUPPORTED_CURRENCY_SYMBOLS.REQ, SUPPORTED_CURRENCY_SYMBOLS.RLC, SUPPORTED_CURRENCY_SYMBOLS.RLY, SUPPORTED_CURRENCY_SYMBOLS.SAND, SUPPORTED_CURRENCY_SYMBOLS.SHIB, SUPPORTED_CURRENCY_SYMBOLS.SKL, SUPPORTED_CURRENCY_SYMBOLS.SNX, SUPPORTED_CURRENCY_SYMBOLS.STORJ, SUPPORTED_CURRENCY_SYMBOLS.SUKU, SUPPORTED_CURRENCY_SYMBOLS.SUSHI, SUPPORTED_CURRENCY_SYMBOLS.SWFTC, SUPPORTED_CURRENCY_SYMBOLS.TRAC, SUPPORTED_CURRENCY_SYMBOLS.TRB, SUPPORTED_CURRENCY_SYMBOLS.TRIBE, SUPPORTED_CURRENCY_SYMBOLS.TRU, SUPPORTED_CURRENCY_SYMBOLS.UMA, SUPPORTED_CURRENCY_SYMBOLS.UNI, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.WBTC, SUPPORTED_CURRENCY_SYMBOLS.WCFG, SUPPORTED_CURRENCY_SYMBOLS.XYO, SUPPORTED_CURRENCY_SYMBOLS.YFII, SUPPORTED_CURRENCY_SYMBOLS.ZRX]
  },
  [CHAIN_IDS.GOERLI]: {
    nativeCurrency: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.GOERLI],
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.SEPOLIA]: {
    nativeCurrency: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
    network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
  },
  [CHAIN_IDS.BSC]: {
    nativeCurrency: CURRENCY_SYMBOLS.BNB,
    network: 'bsc',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.BNB, SUPPORTED_CURRENCY_SYMBOLS.BUSD],
    moonPay: {
      defaultCurrencyCode: `${SUPPORTED_CURRENCY_SYMBOLS.BNB}_BSC`,
      showOnlyCurrencies: [`${SUPPORTED_CURRENCY_SYMBOLS.BNB}_BSC`, `${SUPPORTED_CURRENCY_SYMBOLS.BUSD}_BSC`]
    }
  },
  [CHAIN_IDS.POLYGON]: {
    nativeCurrency: CURRENCY_SYMBOLS.MATIC,
    network: 'polygon',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.DAI],
    moonPay: {
      defaultCurrencyCode: `${SUPPORTED_CURRENCY_SYMBOLS.BNB}_POLYGON`,
      showOnlyCurrencies: [`${SUPPORTED_CURRENCY_SYMBOLS.MATIC}_POLYGON`, `${SUPPORTED_CURRENCY_SYMBOLS.USDC}_POLYGON`]
    },
    wyre: {
      srn: 'matic',
      currencyCode: CURRENCY_SYMBOLS.MATIC,
      currencies: [SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.MUSDC]
    }
  },
  [CHAIN_IDS.AVALANCHE]: {
    nativeCurrency: CURRENCY_SYMBOLS.AVALANCHE,
    network: 'avaxcchain',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.AVALANCHE],
    moonPay: {
      defaultCurrencyCode: `${SUPPORTED_CURRENCY_SYMBOLS.AVAX}_CCHAIN`,
      showOnlyCurrencies: [`${SUPPORTED_CURRENCY_SYMBOLS.AVAX}_CCHAIN`]
    },
    wyre: {
      srn: 'avalanche',
      currencyCode: CURRENCY_SYMBOLS.AVALANCHE,
      currencies: [SUPPORTED_CURRENCY_SYMBOLS.AVALANCHE, SUPPORTED_CURRENCY_SYMBOLS.AVAXC, SUPPORTED_CURRENCY_SYMBOLS.AVAXCUSDC]
    },
    coinbasePayCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.AVALANCHE]
  },
  [CHAIN_IDS.FANTOM]: {
    nativeCurrency: CURRENCY_SYMBOLS.FANTOM,
    network: 'fantom',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.FANTOM]
  },
  [CHAIN_IDS.CELO]: {
    nativeCurrency: CURRENCY_SYMBOLS.CELO,
    network: 'celo',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.CELO],
    moonPay: {
      defaultCurrencyCode: SUPPORTED_CURRENCY_SYMBOLS.CELO,
      showOnlyCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.CELO]
    }
  },
  [CHAIN_IDS.OPTIMISM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ETH,
    network: 'optimism',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS.USDC]
  },
  [CHAIN_IDS.ARBITRUM]: {
    nativeCurrency: CURRENCY_SYMBOLS.ARBITRUM,
    network: 'arbitrum',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ARBITRUM, SUPPORTED_CURRENCY_SYMBOLS.SPA, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDS]
  },
  [CHAIN_IDS.AURORA]: {
    nativeCurrency: CURRENCY_SYMBOLS.AURORA,
    network: 'aurora',
    transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.AURORA]
  }
};
exports.BUYABLE_CHAINS_MAP = BUYABLE_CHAINS_MAP;
const FEATURED_RPCS = [{
  chainId: CHAIN_IDS.ARBITRUM,
  nickname: ARBITRUM_DISPLAY_NAME,
  rpcUrl: `https://arbitrum-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ARBITRUM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.arbitrum.io',
    imageUrl: AETH_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AURORA,
  nickname: AURORA_DISPLAY_NAME,
  rpcUrl: `https://aurora-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AURORA,
  rpcPrefs: {
    blockExplorerUrl: 'https://aurorascan.dev/',
    imageUrl: AURORA_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.AVALANCHE,
  nickname: AVALANCHE_DISPLAY_NAME,
  rpcUrl: `https://avalanche-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.AVALANCHE,
  rpcPrefs: {
    blockExplorerUrl: 'https://snowtrace.io/',
    imageUrl: AVAX_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.BSC,
  nickname: BNB_DISPLAY_NAME,
  rpcUrl: 'https://bsc-dataseed.binance.org/',
  ticker: CURRENCY_SYMBOLS.BNB,
  rpcPrefs: {
    blockExplorerUrl: 'https://bscscan.com/',
    imageUrl: BNB_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.FANTOM,
  nickname: FANTOM_DISPLAY_NAME,
  rpcUrl: 'https://rpc.ftm.tools/',
  ticker: CURRENCY_SYMBOLS.FANTOM,
  rpcPrefs: {
    blockExplorerUrl: 'https://ftmscan.com/',
    imageUrl: FTM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.HARMONY,
  nickname: HARMONY_DISPLAY_NAME,
  rpcUrl: 'https://api.harmony.one/',
  ticker: CURRENCY_SYMBOLS.HARMONY,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.harmony.one/',
    imageUrl: HARMONY_ONE_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.OPTIMISM,
  nickname: OPTIMISM_DISPLAY_NAME,
  rpcUrl: `https://optimism-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.ETH,
  rpcPrefs: {
    blockExplorerUrl: 'https://optimistic.etherscan.io/',
    imageUrl: OPTIMISM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.PALM,
  nickname: PALM_DISPLAY_NAME,
  rpcUrl: `https://palm-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.PALM,
  rpcPrefs: {
    blockExplorerUrl: 'https://explorer.palm.io/',
    imageUrl: PALM_TOKEN_IMAGE_URL
  }
}, {
  chainId: CHAIN_IDS.POLYGON,
  nickname: `${POLYGON_DISPLAY_NAME} ${(0, _lodash.capitalize)(NETWORK_TYPES.MAINNET)}`,
  rpcUrl: `https://polygon-mainnet.infura.io/v3/${infuraProjectId}`,
  ticker: CURRENCY_SYMBOLS.MATIC,
  rpcPrefs: {
    blockExplorerUrl: 'https://polygonscan.com/',
    imageUrl: MATIC_TOKEN_IMAGE_URL
  }
}];
exports.FEATURED_RPCS = FEATURED_RPCS;


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\permissions.ts", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\permissions.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RestrictedMethods = exports.PermissionNamespaces = exports.ExcludedSnapPermissions = exports.ExcludedSnapEndowments = exports.EndowmentPermissions = exports.CaveatTypes = void 0;
const CaveatTypes = Object.freeze({
  restrictReturnedAccounts: 'restrictReturnedAccounts'
});
exports.CaveatTypes = CaveatTypes;
const RestrictedMethods = Object.freeze({
  eth_accounts: 'eth_accounts',
  ///: BEGIN:ONLY_INCLUDE_IN(flask)
  snap_confirm: 'snap_confirm',
  snap_notify: 'snap_notify',
  snap_manageState: 'snap_manageState',
  snap_getBip32PublicKey: 'snap_getBip32PublicKey',
  snap_getBip32Entropy: 'snap_getBip32Entropy',
  snap_getBip44Entropy: 'snap_getBip44Entropy',
  'wallet_snap_*': 'wallet_snap_*' ///: END:ONLY_INCLUDE_IN

}); ///: BEGIN:ONLY_INCLUDE_IN(flask)

exports.RestrictedMethods = RestrictedMethods;
const PermissionNamespaces = Object.freeze({
  wallet_snap_: 'wallet_snap_*'
});
exports.PermissionNamespaces = PermissionNamespaces;
const EndowmentPermissions = Object.freeze({
  'endowment:network-access': 'endowment:network-access',
  'endowment:long-running': 'endowment:long-running',
  'endowment:transaction-insight': 'endowment:transaction-insight'
}); // Methods / permissions in external packages that we are temporarily excluding.

exports.EndowmentPermissions = EndowmentPermissions;
const ExcludedSnapPermissions = new Set(['snap_dialog']);
exports.ExcludedSnapPermissions = ExcludedSnapPermissions;
const ExcludedSnapEndowments = new Set(['endowment:keyring']); ///: END:ONLY_INCLUDE_IN

exports.ExcludedSnapEndowments = ExcludedSnapEndowments;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\swaps.js", {"./network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\swaps.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WMATIC_CONTRACT_ADDRESS = exports.WETH_GOERLI_CONTRACT_ADDRESS = exports.WETH_CONTRACT_ADDRESS = exports.WBNB_CONTRACT_ADDRESS = exports.WAVAX_CONTRACT_ADDRESS = exports.TOKEN_BUCKET_PRIORITY = exports.TEST_ETH_SWAPS_TOKEN_OBJECT = exports.SWAP_FAILED_ERROR = exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = exports.SWAPS_FETCH_ORDER_CONFLICT = exports.SWAPS_DEV_API_V2_BASE_URL = exports.SWAPS_CLIENT_ID = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = exports.SWAPS_API_V2_BASE_URL = exports.SLIPPAGE = exports.QUOTES_NOT_AVAILABLE_ERROR = exports.QUOTES_EXPIRED_ERROR = exports.POLYGON = exports.OFFLINE_FOR_MAINTENANCE = exports.MATIC_SWAPS_TOKEN_OBJECT = exports.GOERLI_SWAPS_TOKEN_OBJECT = exports.GOERLI = exports.GAS_DEV_API_BASE_URL = exports.GAS_API_BASE_URL = exports.ETH_SWAPS_TOKEN_OBJECT = exports.ETHEREUM = exports.ERROR_FETCHING_QUOTES = exports.DEFAULT_ERC20_APPROVE_GAS = exports.CONTRACT_DATA_DISABLED_ERROR = exports.BSC = exports.BNB_SWAPS_TOKEN_OBJECT = exports.AVAX_SWAPS_TOKEN_OBJECT = exports.AVALANCHE = exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = exports.ALLOWED_CONTRACT_ADDRESSES = void 0;

var _network = require("./network");

const QUOTES_EXPIRED_ERROR = 'quotes-expired';
exports.QUOTES_EXPIRED_ERROR = QUOTES_EXPIRED_ERROR;
const SWAP_FAILED_ERROR = 'swap-failed-error';
exports.SWAP_FAILED_ERROR = SWAP_FAILED_ERROR;
const ERROR_FETCHING_QUOTES = 'error-fetching-quotes';
exports.ERROR_FETCHING_QUOTES = ERROR_FETCHING_QUOTES;
const QUOTES_NOT_AVAILABLE_ERROR = 'quotes-not-avilable';
exports.QUOTES_NOT_AVAILABLE_ERROR = QUOTES_NOT_AVAILABLE_ERROR;
const CONTRACT_DATA_DISABLED_ERROR = 'contract-data-disabled';
exports.CONTRACT_DATA_DISABLED_ERROR = CONTRACT_DATA_DISABLED_ERROR;
const OFFLINE_FOR_MAINTENANCE = 'offline-for-maintenance';
exports.OFFLINE_FOR_MAINTENANCE = OFFLINE_FOR_MAINTENANCE;
const SWAPS_FETCH_ORDER_CONFLICT = 'swaps-fetch-order-conflict'; // An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have

exports.SWAPS_FETCH_ORDER_CONFLICT = SWAPS_FETCH_ORDER_CONFLICT;
const DEFAULT_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000';
const ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: './images/black-eth-logo.svg'
};
exports.ETH_SWAPS_TOKEN_OBJECT = ETH_SWAPS_TOKEN_OBJECT;
const BNB_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.BNB,
  name: 'Binance Coin',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.BNB_TOKEN_IMAGE_URL
};
exports.BNB_SWAPS_TOKEN_OBJECT = BNB_SWAPS_TOKEN_OBJECT;
const MATIC_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.MATIC,
  name: 'Matic',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.MATIC_TOKEN_IMAGE_URL
};
exports.MATIC_SWAPS_TOKEN_OBJECT = MATIC_SWAPS_TOKEN_OBJECT;
const AVAX_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.AVALANCHE,
  name: 'Avalanche',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.AVAX_TOKEN_IMAGE_URL
};
exports.AVAX_SWAPS_TOKEN_OBJECT = AVAX_SWAPS_TOKEN_OBJECT;
const TEST_ETH_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.TEST_ETH,
  name: 'Test Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
};
exports.TEST_ETH_SWAPS_TOKEN_OBJECT = TEST_ETH_SWAPS_TOKEN_OBJECT;
const GOERLI_SWAPS_TOKEN_OBJECT = {
  symbol: _network.CURRENCY_SYMBOLS.ETH,
  name: 'Ether',
  address: DEFAULT_TOKEN_ADDRESS,
  decimals: 18,
  iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
}; // A gas value for ERC20 approve calls that should be sufficient for all ERC20 approve implementations

exports.GOERLI_SWAPS_TOKEN_OBJECT = GOERLI_SWAPS_TOKEN_OBJECT;
const DEFAULT_ERC20_APPROVE_GAS = '0x1d4c0';
exports.DEFAULT_ERC20_APPROVE_GAS = DEFAULT_ERC20_APPROVE_GAS;
const MAINNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const TESTNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
const BSC_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31'; // It's the same as we use for BSC.

const POLYGON_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const AVALANCHE_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
const WETH_CONTRACT_ADDRESS = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';
exports.WETH_CONTRACT_ADDRESS = WETH_CONTRACT_ADDRESS;
const WETH_GOERLI_CONTRACT_ADDRESS = '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6';
exports.WETH_GOERLI_CONTRACT_ADDRESS = WETH_GOERLI_CONTRACT_ADDRESS;
const WBNB_CONTRACT_ADDRESS = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c';
exports.WBNB_CONTRACT_ADDRESS = WBNB_CONTRACT_ADDRESS;
const WMATIC_CONTRACT_ADDRESS = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';
exports.WMATIC_CONTRACT_ADDRESS = WMATIC_CONTRACT_ADDRESS;
const WAVAX_CONTRACT_ADDRESS = '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7';
exports.WAVAX_CONTRACT_ADDRESS = WAVAX_CONTRACT_ADDRESS;
const SWAPS_TESTNET_CHAIN_ID = '0x539';
const SWAPS_API_V2_BASE_URL = 'https://swap.metaswap.codefi.network';
exports.SWAPS_API_V2_BASE_URL = SWAPS_API_V2_BASE_URL;
const SWAPS_DEV_API_V2_BASE_URL = 'https://swap.metaswap-dev.codefi.network';
exports.SWAPS_DEV_API_V2_BASE_URL = SWAPS_DEV_API_V2_BASE_URL;
const GAS_API_BASE_URL = 'https://gas-api.metaswap.codefi.network';
exports.GAS_API_BASE_URL = GAS_API_BASE_URL;
const GAS_DEV_API_BASE_URL = 'https://gas-api.metaswap-dev.codefi.network';
exports.GAS_DEV_API_BASE_URL = GAS_DEV_API_BASE_URL;
const BSC_DEFAULT_BLOCK_EXPLORER_URL = 'https://bscscan.com/';
const MAINNET_DEFAULT_BLOCK_EXPLORER_URL = 'https://etherscan.io/';
const GOERLI_DEFAULT_BLOCK_EXPLORER_URL = 'https://goerli.etherscan.io/';
const POLYGON_DEFAULT_BLOCK_EXPLORER_URL = 'https://polygonscan.com/';
const AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL = 'https://snowtrace.io/';
const ALLOWED_PROD_SWAPS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, SWAPS_TESTNET_CHAIN_ID, _network.CHAIN_IDS.BSC, _network.CHAIN_IDS.POLYGON, _network.CHAIN_IDS.AVALANCHE];
exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = ALLOWED_PROD_SWAPS_CHAIN_IDS;
const ALLOWED_DEV_SWAPS_CHAIN_IDS = [...ALLOWED_PROD_SWAPS_CHAIN_IDS, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = ALLOWED_DEV_SWAPS_CHAIN_IDS;
const ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI];
exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS;
const SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = {
  [_network.CHAIN_IDS.MAINNET]: MAINNET_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: BSC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: TESTNET_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_CONTRACT_ADDRESS
};
exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = SWAPS_CHAINID_CONTRACT_ADDRESS_MAP;
const SWAPS_WRAPPED_TOKENS_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: WETH_CONTRACT_ADDRESS,
  [SWAPS_TESTNET_CHAIN_ID]: WETH_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.BSC]: WBNB_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.POLYGON]: WMATIC_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.GOERLI]: WETH_GOERLI_CONTRACT_ADDRESS,
  [_network.CHAIN_IDS.AVALANCHE]: WAVAX_CONTRACT_ADDRESS
};
exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = SWAPS_WRAPPED_TOKENS_ADDRESSES;
const ALLOWED_CONTRACT_ADDRESSES = {
  [_network.CHAIN_IDS.MAINNET]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.MAINNET], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.MAINNET]],
  [SWAPS_TESTNET_CHAIN_ID]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[SWAPS_TESTNET_CHAIN_ID], SWAPS_WRAPPED_TOKENS_ADDRESSES[SWAPS_TESTNET_CHAIN_ID]],
  [_network.CHAIN_IDS.GOERLI]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.GOERLI], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.GOERLI]],
  [_network.CHAIN_IDS.BSC]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.BSC], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.BSC]],
  [_network.CHAIN_IDS.POLYGON]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.POLYGON], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.POLYGON]],
  [_network.CHAIN_IDS.AVALANCHE]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.AVALANCHE], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.AVALANCHE]]
};
exports.ALLOWED_CONTRACT_ADDRESSES = ALLOWED_CONTRACT_ADDRESSES;
const SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
  [_network.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
  [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
  [_network.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT
};
exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = SWAPS_CHAINID_DEFAULT_TOKEN_MAP;
const SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = {
  [_network.CHAIN_IDS.BSC]: BSC_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.MAINNET]: MAINNET_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.POLYGON]: POLYGON_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.GOERLI]: GOERLI_DEFAULT_BLOCK_EXPLORER_URL,
  [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL
};
exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP;
const ETHEREUM = 'ethereum';
exports.ETHEREUM = ETHEREUM;
const POLYGON = 'polygon';
exports.POLYGON = POLYGON;
const BSC = 'bsc';
exports.BSC = BSC;
const GOERLI = 'goerli';
exports.GOERLI = GOERLI;
const AVALANCHE = 'avalanche';
exports.AVALANCHE = AVALANCHE;
const SWAPS_CLIENT_ID = 'extension';
exports.SWAPS_CLIENT_ID = SWAPS_CLIENT_ID;
const TOKEN_BUCKET_PRIORITY = {
  OWNED: 'owned',
  TOP: 'top'
};
exports.TOKEN_BUCKET_PRIORITY = TOKEN_BUCKET_PRIORITY;
const SLIPPAGE = {
  DEFAULT: 2,
  HIGH: 3
};
exports.SLIPPAGE = SLIPPAGE;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\time.ts
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SECOND = exports.MINUTE = exports.MILLISECOND = exports.HOUR = exports.DAY = void 0;
const MILLISECOND = 1;
exports.MILLISECOND = MILLISECOND;
const SECOND = MILLISECOND * 1000;
exports.SECOND = SECOND;
const MINUTE = SECOND * 60;
exports.MINUTE = MINUTE;
const HOUR = MINUTE * 60;
exports.HOUR = HOUR;
const DAY = HOUR * 24;
exports.DAY = DAY;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\tokens.js", {"@metamask/contract-metadata":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\contract-metadata\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\tokens.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOKEN_API_METASWAP_CODEFI_URL = exports.STATIC_MAINNET_TOKEN_LIST = exports.LISTED_CONTRACT_ADDRESSES = void 0;

var _contractMetadata = _interopRequireDefault(require("@metamask/contract-metadata"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A normalized list of addresses exported as part of the contractMap in
 * `@metamask/contract-metadata`. Used primarily to validate if manually entered
 * contract addresses do not match one of our listed tokens
 */
const LISTED_CONTRACT_ADDRESSES = Object.keys(_contractMetadata.default).map(address => address.toLowerCase());
/**
 * @typedef {object} TokenDetails
 * @property {string} address - The address of the selected 'TOKEN' or
 *  'COLLECTIBLE' contract.
 * @property {string} [symbol] - The symbol of the token.
 * @property {number} [decimals] - The number of decimals of the selected
 *  'ERC20' asset.
 * @property {number} [tokenId] - The id of the selected 'COLLECTIBLE' asset.
 * @property {TokenStandardStrings} [standard] - The standard of the selected
 *  asset.
 * @property {boolean} [isERC721] - True when the asset is a ERC721 token.
 */

exports.LISTED_CONTRACT_ADDRESSES = LISTED_CONTRACT_ADDRESSES;
const STATIC_MAINNET_TOKEN_LIST = Object.keys(_contractMetadata.default).reduce((acc, base) => {
  const {
    logo,
    ...tokenMetadata
  } = _contractMetadata.default[base];
  return { ...acc,
    [base.toLowerCase()]: { ...tokenMetadata,
      address: base.toLowerCase(),
      iconUrl: `images/contract/${logo}`,
      aggregators: []
    }
  };
}, {});
exports.STATIC_MAINNET_TOKEN_LIST = STATIC_MAINNET_TOKEN_LIST;
const TOKEN_API_METASWAP_CODEFI_URL = 'https://token-api.metaswap.codefi.network/tokens/';
exports.TOKEN_API_METASWAP_CODEFI_URL = TOKEN_API_METASWAP_CODEFI_URL;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", {"./app":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\transaction.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRANSACTION_TYPES = exports.TRANSACTION_STATUSES = exports.TRANSACTION_GROUP_STATUSES = exports.TRANSACTION_GROUP_CATEGORIES = exports.TRANSACTION_EVENTS = exports.TRANSACTION_ENVELOPE_TYPES = exports.TRANSACTION_APPROVAL_AMOUNT_TYPE = exports.TOKEN_STANDARDS = exports.SMART_TRANSACTION_STATUSES = exports.IN_PROGRESS_TRANSACTION_STATUSES = exports.ERC721 = exports.ERC20 = exports.ERC1155 = exports.ASSET_TYPES = void 0;

var _app = require("./app");

/**
 * Transaction Type is a MetaMask construct used internally
 *
 * @typedef {object} TransactionTypes
 * @property {'transfer'} TOKEN_METHOD_TRANSFER - A token transaction where the user
 *  is sending tokens that they own to another address
 * @property {'transferfrom'} TOKEN_METHOD_TRANSFER_FROM - A token transaction
 *  transferring tokens from an account that the sender has an allowance of.
 *  For more information on allowances, see the approve type.
 * @property {'safetransferfrom'} TOKEN_METHOD_SAFE_TRANSFER_FROM - A token transaction
 *  transferring tokens from an account that the sender has an allowance of.
 *  The method is prefixed with safe because when calling this method the contract checks
 *  to ensure that the receiver is an address capable of handling with the token being sent.
 * @property {'approve'} TOKEN_METHOD_APPROVE - A token transaction requesting an
 *  allowance of the token to spend on behalf of the user
 * @property {'setapprovalforall'} TOKEN_METHOD_SET_APPROVAL_FOR_ALL - A token transaction requesting an
 *  allowance of all of a user's token to spend on behalf of the user
 * @property {'incoming'} INCOMING - An incoming (deposit) transaction
 * @property {'simpleSend'} SIMPLE_SEND - A transaction sending a network's native asset to a recipient
 * @property {'contractInteraction'} CONTRACT_INTERACTION - A transaction that is
 *  interacting with a smart contract's methods that we have not treated as a special
 *  case, such as approve, transfer, and transferfrom
 * @property {'contractDeployment'} DEPLOY_CONTRACT - A transaction that deployed
 *  a smart contract
 * @property {'swap'} SWAP - A transaction swapping one token for another through
 *  MetaMask Swaps
 * @property {'swapApproval'} SWAP_APPROVAL - Similar to the approve type, a swap
 *  approval is a special case of ERC20 approve method that requests an allowance of
 *  the token to spend on behalf of the user for the MetaMask Swaps contract. The first
 *  swap for any token will have an accompanying swapApproval transaction.
 * @property {'cancel'} CANCEL - A transaction submitted with the same nonce as a
 *  previous transaction, a higher gas price and a zeroed out send amount. Useful
 *  for users who accidentally send to erroneous addresses or if they send too much.
 * @property {'retry'} RETRY - When a transaction is failed it can be retried by
 *  resubmitting the same transaction with a higher gas fee. This type is also used
 *  to speed up pending transactions. This is accomplished by creating a new tx with
 *  the same nonce and higher gas fees.
 */

/**
 * This type will work anywhere you expect a string that can be one of the
 * above transaction types.
 *
 * @typedef {TransactionTypes[keyof TransactionTypes]} TransactionTypeString
 */

/**
 * @type {TransactionTypes}
 */
const TRANSACTION_TYPES = {
  CANCEL: 'cancel',
  CONTRACT_INTERACTION: 'contractInteraction',
  DEPLOY_CONTRACT: 'contractDeployment',
  ETH_DECRYPT: _app.MESSAGE_TYPE.ETH_DECRYPT,
  ETH_GET_ENCRYPTION_PUBLIC_KEY: _app.MESSAGE_TYPE.ETH_GET_ENCRYPTION_PUBLIC_KEY,
  INCOMING: 'incoming',
  PERSONAL_SIGN: _app.MESSAGE_TYPE.PERSONAL_SIGN,
  RETRY: 'retry',
  SIGN: _app.MESSAGE_TYPE.ETH_SIGN,
  SIGN_TYPED_DATA: _app.MESSAGE_TYPE.ETH_SIGN_TYPED_DATA,
  SIMPLE_SEND: 'simpleSend',
  SMART: 'smart',
  SWAP: 'swap',
  SWAP_APPROVAL: 'swapApproval',
  TOKEN_METHOD_APPROVE: 'approve',
  TOKEN_METHOD_SAFE_TRANSFER_FROM: 'safetransferfrom',
  TOKEN_METHOD_TRANSFER: 'transfer',
  TOKEN_METHOD_TRANSFER_FROM: 'transferfrom',
  TOKEN_METHOD_SET_APPROVAL_FOR_ALL: 'setapprovalforall'
};
/**
 * In EIP-2718 typed transaction envelopes were specified, with the very first
 * typed envelope being 'legacy' and describing the shape of the base
 * transaction params that were hitherto the only transaction type sent on
 * Ethereum.
 *
 * @typedef {object} TransactionEnvelopeTypes
 * @property {'0x0'} LEGACY - A legacy transaction, the very first type.
 * @property {'0x1'} ACCESS_LIST - EIP-2930 defined the access list transaction
 *  type that allowed for specifying the state that a transaction would act
 *  upon in advance and theoretically save on gas fees.
 * @property {'0x2'} FEE_MARKET - The type introduced comes from EIP-1559,
 *  Fee Market describes the addition of a baseFee to blocks that will be
 *  burned instead of distributed to miners. Transactions of this type have
 *  both a maxFeePerGas (maximum total amount in gwei per gas to spend on the
 *  transaction) which is inclusive of the maxPriorityFeePerGas (maximum amount
 *  of gwei per gas from the transaction fee to distribute to miner).
 */

/**
 * @type {TransactionEnvelopeTypes}
 */

exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
const TRANSACTION_ENVELOPE_TYPES = {
  LEGACY: '0x0',
  ACCESS_LIST: '0x1',
  FEE_MARKET: '0x2'
};
/**
 * Transaction Status is a mix of Ethereum and MetaMask terminology, used internally
 * for transaction processing.
 *
 * @typedef {object} TransactionStatuses
 * @property {'unapproved'} UNAPPROVED - A new transaction that the user has not
 *  approved or rejected
 * @property {'approved'} APPROVED - The user has approved the transaction in the
 *  MetaMask UI
 * @property {'rejected'} REJECTED - The user has rejected the transaction in the
 *  MetaMask UI
 * @property {'signed'} SIGNED - The transaction has been signed
 * @property {'submitted'} SUBMITTED - The transaction has been submitted to network
 * @property {'failed'} FAILED - The transaction has failed for some reason
 * @property {'dropped'} DROPPED - The transaction was dropped due to a tx with same
 *  nonce being accepted
 * @property {'confirmed'} CONFIRMED - The transaction was confirmed by the network
 */

/**
 * This type will work anywhere you expect a string that can be one of the
 * above transaction statuses.
 *
 * @typedef {TransactionStatuses[keyof TransactionStatuses]} TransactionStatusString
 */

/**
 * @type {TransactionStatuses}
 */

exports.TRANSACTION_ENVELOPE_TYPES = TRANSACTION_ENVELOPE_TYPES;
const TRANSACTION_STATUSES = {
  UNAPPROVED: 'unapproved',
  APPROVED: 'approved',
  REJECTED: 'rejected',
  SIGNED: 'signed',
  SUBMITTED: 'submitted',
  FAILED: 'failed',
  DROPPED: 'dropped',
  CONFIRMED: 'confirmed',
  PENDING: 'pending'
};
/**
 * With this list we can detect if a transaction is still in progress.
 */

exports.TRANSACTION_STATUSES = TRANSACTION_STATUSES;
const IN_PROGRESS_TRANSACTION_STATUSES = [TRANSACTION_STATUSES.UNAPPROVED, TRANSACTION_STATUSES.APPROVED, TRANSACTION_STATUSES.SIGNED, TRANSACTION_STATUSES.SUBMITTED, TRANSACTION_STATUSES.PENDING];
/**
 * Transaction Group Status is a MetaMask construct to track the status of groups
 * of transactions.
 *
 * @typedef {object} TransactionGroupStatuses
 * @property {'cancelled'} CANCELLED - A cancel type transaction in the group was
 *  confirmed
 * @property {'pending'} PENDING - The primaryTransaction of the group has a status
 *  that is one of TRANSACTION_STATUSES.APPROVED, TRANSACTION_STATUSES.UNAPPROVED
 *  or TRANSACTION_STATUSES.SUBMITTED
 */

/**
 * @type {TransactionGroupStatuses}
 */

exports.IN_PROGRESS_TRANSACTION_STATUSES = IN_PROGRESS_TRANSACTION_STATUSES;
const TRANSACTION_GROUP_STATUSES = {
  CANCELLED: 'cancelled',
  PENDING: 'pending'
};
/**
 * Statuses that are specific to Smart Transactions.
 *
 * @typedef {object} SmartTransactionStatuses
 * @property {'cancelled'} CANCELLED - It can be cancelled for various reasons.
 * @property {'pending'} PENDING - Smart transaction is being processed.
 * @property {'success'} SUCCESS - Smart transaction was successfully mined.
 */

/**
 * @type {SmartTransactionStatuses}
 */

exports.TRANSACTION_GROUP_STATUSES = TRANSACTION_GROUP_STATUSES;
const SMART_TRANSACTION_STATUSES = {
  CANCELLED: 'cancelled',
  PENDING: 'pending',
  SUCCESS: 'success'
};
/**
 * Types that are specific to the transaction approval amount.
 *
 * @typedef {object} TransactionApprovalAmountType
 * @property {'custom'} CUSTOM - The user has edited the token amount.
 * @property {'revoke'} REVOKE - The selected amount (either CUSTOM or DAPP_PROPOSED) is 0.
 * @property {'dapp_proposed'} DAPP_PROPOSED - The dapp proposed token amount.
 */

/**
 * @type {TransactionApprovalAmountType}
 */

exports.SMART_TRANSACTION_STATUSES = SMART_TRANSACTION_STATUSES;
const TRANSACTION_APPROVAL_AMOUNT_TYPE = {
  CUSTOM: 'custom',
  REVOKE: 'revoke',
  DAPP_PROPOSED: 'dapp_proposed'
};
/**
 * Transaction Group Category is a MetaMask construct to categorize the intent
 * of a group of transactions for purposes of displaying in the UI
 *
 * @typedef {object} TransactionGroupCategories
 * @property {'send'} SEND - Transaction group representing ether being sent from
 *  the user.
 * @property {'receive'} RECEIVE - Transaction group representing a deposit/incoming
 *  transaction. This category maps 1:1 with TRANSACTION_CATEGORIES.INCOMING.
 * @property {'interaction'} INTERACTION - Transaction group representing
 *  an interaction with a smart contract's methods.
 * @property {'approval'} APPROVAL - Transaction group representing a request for an
 *  allowance of a token to spend on the user's behalf.
 * @property {'signature-request'} SIGNATURE_REQUEST - Transaction group representing
 *  a signature request This currently only shows up in the UI when its pending user
 *  approval in the UI. Once the user approves or rejects it will no longer show in
 *  activity.
 * @property {'swap'} SWAP - Transaction group representing a token swap through
 *  MetaMask Swaps. This transaction group's primary currency changes depending
 *  on context. If the user is viewing an asset page for a token received from a swap,
 *  the primary currency will be the received token. Otherwise the token exchanged
 *  will be shown.
 */

/**
 * @type {TransactionGroupCategories}
 */

exports.TRANSACTION_APPROVAL_AMOUNT_TYPE = TRANSACTION_APPROVAL_AMOUNT_TYPE;
const TRANSACTION_GROUP_CATEGORIES = {
  APPROVAL: 'approval',
  INTERACTION: 'interaction',
  RECEIVE: 'receive',
  SEND: 'send',
  SIGNATURE_REQUEST: 'signature-request',
  SWAP: 'swap'
};
/**
 * @typedef {object} TxParams
 * @property {string} from - The address the transaction is sent from
 * @property {string} to - The address the transaction is sent to
 * @property {string} value - The amount of wei, in hexadecimal, to send
 * @property {number} nonce - The transaction count for the current account/network
 * @property {string} gasPrice - The amount of gwei, in hexadecimal, per unit of gas
 * @property {string} gas - The max amount of gwei, in hexadecimal, the user is willing to pay
 * @property {string} [data] - Hexadecimal encoded string representing calls to the EVM's ABI
 */

/**
 * @typedef {object} TxError
 * @property {string} message - The message from the encountered error.
 * @property {any} rpc - The "value" of the error.
 * @property {string} [stack] - the stack trace from the error, if available.
 */

/**
 * An object representing a transaction, in whatever state it is in.
 *
 * @typedef {object} TransactionMeta
 * @property {string} [blockNumber] - The block number this transaction was
 *  included in. Currently only present on incoming transactions!
 * @property {number} id - An internally unique tx identifier.
 * @property {number} time - Time the transaction was first suggested, in unix
 *  epoch time (ms).
 * @property {string} contractMethodName - A string representing a name of
 * transaction contract method.
 * @property {string} customTokenAmount - The custom token amount is the amount
 * set by the user
 * @property {string} dappProposedTokenAmount - The dapp proposed token amount
 * @property {string} currentTokenBalance - The balance of the token that is
 * being send
 * @property {string} originalApprovalAmount - The original approval amount
 * is the originally dapp proposed token amount
 * @property {string} finalApprovalAmount - The chosen amount which will be the
 * same as the originally proposed token amount if the user does not edit the
 * amount or will be a custom token amount set by the user
 * @property {TransactionTypeString} type - The type of transaction this txMeta
 *  represents.
 * @property {string} originalType - When we speed up a transaction,
 *  we set the type as Retry and we lose information about type of transaction
 *  that is being set up, so we use original type to track that information.
 * @property {TransactionStatusString} status - The current status of the
 *  transaction.
 * @property {string} metamaskNetworkId - The transaction's network ID, used
 *  for EIP-155 compliance.
 * @property {boolean} loadingDefaults - TODO: Document
 * @property {TxParams} txParams - The transaction params as passed to the
 *  network provider.
 * @property {object[]} history - A history of mutations to this
 *  TransactionMeta object.
 * @property {string} origin - A string representing the interface that
 *  suggested the transaction.
 * @property {string} originalGasEstimate - A string representing the original
 * gas estimation on the transaction metadata.
 * @property {boolean} userEditedGasLimit - A boolean representing when the
 * user manually edited the gas limit.
 * @property {object} nonceDetails - A metadata object containing information
 *  used to derive the suggested nonce, useful for debugging nonce issues.
 * @property {string} rawTx - A hex string of the final signed transaction,
 *  ready to submit to the network.
 * @property {string} hash - A hex string of the transaction hash, used to
 *  identify the transaction on the network.
 * @property {number} [submittedTime] - The time the transaction was submitted to
 *  the network, in Unix epoch time (ms).
 * @property {TxError} [err] - The error encountered during the transaction
 */

/**
 * Defines the possible types
 *
 * @typedef {object} TransactionMetaMetricsEvents
 * @property {'Transaction Added'} ADDED - All transactions, except incoming
 *  ones, are added to the controller state in an unapproved status. When this
 *  happens we fire the Transaction Added event to show that the transaction
 *  has been added to the user's MetaMask.
 * @property {'Transaction Approved'} APPROVED - When an unapproved transaction
 *  is in the controller state, MetaMask will render a confirmation screen for
 *  that transaction. If the user approves the transaction we fire this event
 *  to indicate that the user has approved the transaction for submission to
 *  the network.
 * @property {'Transaction Rejected'} REJECTED - When an unapproved transaction
 *  is in the controller state, MetaMask will render a confirmation screen for
 *  that transaction. If the user rejects the transaction we fire this event
 *  to indicate that the user has rejected the transaction. It will be removed
 *  from state as a result.
 * @property {'Transaction Submitted'} SUBMITTED - After a transaction is
 *  approved by the user, it is then submitted to the network for inclusion in
 *  a block. When this happens we fire the Transaction Submitted event to
 *  indicate that MetaMask is submitting a transaction at the user's request.
 * @property {'Transaction Finalized'} FINALIZED - All transactions that are
 *  submitted will finalized (eventually) by either being dropped, failing
 *  or being confirmed. When this happens we track this event, along with the
 *  status.
 */

/**
 * This type will work anywhere you expect a string that can be one of the
 * above transaction event types.
 *
 * @typedef {TransactionMetaMetricsEvents[keyof TransactionMetaMetricsEvents]} TransactionMetaMetricsEventString
 */

/**
 * @type {TransactionMetaMetricsEvents}
 */

exports.TRANSACTION_GROUP_CATEGORIES = TRANSACTION_GROUP_CATEGORIES;
const TRANSACTION_EVENTS = {
  ADDED: 'Transaction Added',
  APPROVED: 'Transaction Approved',
  FINALIZED: 'Transaction Finalized',
  REJECTED: 'Transaction Rejected',
  SUBMITTED: 'Transaction Submitted'
};
/**
 * @typedef {object} AssetTypes
 * @property {'NATIVE'} NATIVE - The native asset for the current network, such
 *  as ETH
 * @property {'TOKEN'} TOKEN - An ERC20 token.
 * @property {'COLLECTIBLE'} COLLECTIBLE - An ERC721 or ERC1155 token.
 * @property {'UNKNOWN'} UNKNOWN - A transaction interacting with a contract
 *  that isn't a token method interaction will be marked as dealing with an
 *  unknown asset type.
 */

/**
 * This type will work anywhere you expect a string that can be one of the
 * above asset types
 *
 * @typedef {AssetTypes[keyof AssetTypes]} AssetTypesString
 */

/**
 * The types of assets that a user can send
 *
 * @type {AssetTypes}
 */

exports.TRANSACTION_EVENTS = TRANSACTION_EVENTS;
const ASSET_TYPES = {
  NATIVE: 'NATIVE',
  TOKEN: 'TOKEN',
  COLLECTIBLE: 'COLLECTIBLE',
  UNKNOWN: 'UNKNOWN'
};
exports.ASSET_TYPES = ASSET_TYPES;
const ERC20 = 'ERC20';
exports.ERC20 = ERC20;
const ERC721 = 'ERC721';
exports.ERC721 = ERC721;
const ERC1155 = 'ERC1155';
/**
 * @typedef {object} TokenStandards
 * @property {'ERC20'} ERC20 - A token that conforms to the ERC20 standard.
 * @property {'ERC721'} ERC721 - A token that conforms to the ERC721 standard.
 * @property {'ERC1155'} ERC1155 - A token that conforms to the ERC1155
 *  standard.
 * @property {'NONE'} NONE - Not a token, but rather the base asset of the
 *  selected chain.
 */

/**
 * This type will work anywhere you expect a string that can be one of the
 * above statuses
 *
 * @typedef {TokenStandards[keyof TokenStandards]} TokenStandardStrings
 */

/**
 * Describes the standard which a token conforms to.
 *
 * @type {TokenStandards}
 */

exports.ERC1155 = ERC1155;
const TOKEN_STANDARDS = {
  ERC20,
  ERC721,
  ERC1155,
  NONE: 'NONE'
};
exports.TOKEN_STANDARDS = TOKEN_STANDARDS;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js", {"../constants/time":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts","../modules/fetch-with-timeout":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js","./storage-helpers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\storage-helpers.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\fetch-with-cache.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _time = require("../constants/time");

var _fetchWithTimeout = _interopRequireDefault(require("../modules/fetch-with-timeout"));

var _storageHelpers = require("./storage-helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const fetchWithCache = async (url, fetchOptions = {}, {
  cacheRefreshTime = _time.MINUTE * 6,
  timeout = _time.SECOND * 30
} = {}) => {
  if (fetchOptions.body || fetchOptions.method && fetchOptions.method !== 'GET') {
    throw new Error('fetchWithCache only supports GET requests');
  }

  if (!(fetchOptions.headers instanceof window.Headers)) {
    fetchOptions.headers = new window.Headers(fetchOptions.headers);
  }

  if (fetchOptions.headers.has('Content-Type') && fetchOptions.headers.get('Content-Type') !== 'application/json') {
    throw new Error('fetchWithCache only supports JSON responses');
  }

  const currentTime = Date.now();
  const cacheKey = `cachedFetch:${url}`;
  const {
    cachedResponse,
    cachedTime
  } = (await (0, _storageHelpers.getStorageItem)(cacheKey)) || {};

  if (cachedResponse && currentTime - cachedTime < cacheRefreshTime) {
    return cachedResponse;
  }

  fetchOptions.headers.set('Content-Type', 'application/json');
  const fetchWithTimeout = (0, _fetchWithTimeout.default)(timeout);
  const response = await fetchWithTimeout(url, {
    referrerPolicy: 'no-referrer-when-downgrade',
    body: null,
    method: 'GET',
    mode: 'cors',
    ...fetchOptions
  });

  if (!response.ok) {
    throw new Error(`Fetch failed with status '${response.status}': '${response.statusText}'`);
  }

  const responseJson = await response.json();
  const cacheEntry = {
    cachedResponse: responseJson,
    cachedTime: currentTime
  };
  await (0, _storageHelpers.setStorageItem)(cacheKey, cacheEntry);
  return responseJson;
};

var _default = fetchWithCache;
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\metamask-controller-utils.js", {"../modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\metamask-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTokenValueParam = getTokenValueParam;
exports.hexToDecimal = hexToDecimal;

var _conversion = require("../modules/conversion.utils");

function hexToDecimal(hexValue) {
  return (0, _conversion.conversionUtil)(hexValue, {
    fromNumericBase: 'hex',
    toNumericBase: 'dec'
  });
}

function getTokenValueParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args$_valu;

  return tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_valu = _tokenData$args._value) === null || _tokenData$args$_valu === void 0 ? void 0 : _tokenData$args$_valu.toString();
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\storage-helpers.js", {"localforage":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\localforage\\dist\\localforage.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\storage-helpers.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getStorageItem = getStorageItem;
exports.setStorageItem = setStorageItem;

var _localforage = _interopRequireDefault(require("localforage"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function getStorageItem(key) {
  try {
    const serializedData = await _localforage.default.getItem(key);

    if (serializedData === null) {
      return undefined;
    }

    return JSON.parse(serializedData);
  } catch (err) {
    return undefined;
  }
}

async function setStorageItem(key, value) {
  try {
    const serializedData = JSON.stringify(value);
    await _localforage.default.setItem(key, serializedData);
  } catch (err) {
    console.warn(err);
  }
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\swaps-utils.js", {"../../app/scripts/lib/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js","../constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","../constants/swaps":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\swaps.js","../constants/time":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts","../modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","./fetch-with-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js","./transactions-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\swaps-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.QUOTE_VALIDATORS = void 0;
exports.addHexPrefixToObjectValues = addHexPrefixToObjectValues;
exports.calcTokenValue = calcTokenValue;
exports.constructTxParams = constructTxParams;
exports.fetchTradesInfo = fetchTradesInfo;
exports.validHex = exports.truthyString = exports.truthyDigitString = exports.shouldEnableDirectWrapping = exports.getBaseApi = void 0;
exports.validateData = validateData;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var _network = require("../constants/network");

var _swaps = require("../constants/swaps");

var _time = require("../constants/time");

var _hexstringUtils = require("../modules/hexstring-utils");

var _util = require("../../app/scripts/lib/util");

var _fetchWithCache = _interopRequireDefault(require("./fetch-with-cache"));

var _transactionsControllerUtils = require("./transactions-controller-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TEST_CHAIN_IDS = [_network.CHAIN_IDS.GOERLI, _network.CHAIN_IDS.LOCALHOST];
const clientIdHeader = {
  'X-Client-Id': _swaps.SWAPS_CLIENT_ID
};

const validHex = string => Boolean(string === null || string === void 0 ? void 0 : string.match(/^0x[a-f0-9]+$/u));

exports.validHex = validHex;

const truthyString = string => Boolean(string === null || string === void 0 ? void 0 : string.length);

exports.truthyString = truthyString;

const truthyDigitString = string => truthyString(string) && Boolean(string.match(/^\d+$/u));

exports.truthyDigitString = truthyDigitString;

function validateData(validators, object, urlUsed, logError = true) {
  return validators.every(({
    property,
    type,
    validator
  }) => {
    const types = type.split('|');
    const valid = types.some(_type => typeof object[property] === _type) && (!validator || validator(object[property]));

    if (!valid && logError) {
      _loglevel.default.error(`response to GET ${urlUsed} invalid for property ${property}; value was:`, object[property], '| type was: ', typeof object[property]);
    }

    return valid;
  });
}

const QUOTE_VALIDATORS = [{
  property: 'trade',
  type: 'object',
  validator: trade => trade && validHex(trade.data) && (0, _hexstringUtils.isValidHexAddress)(trade.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(trade.from, {
    allowNonPrefixed: false
  }) && truthyString(trade.value)
}, {
  property: 'approvalNeeded',
  type: 'object',
  validator: approvalTx => approvalTx === null || approvalTx && validHex(approvalTx.data) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.to, {
    allowNonPrefixed: false
  }) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.from, {
    allowNonPrefixed: false
  })
}, {
  property: 'sourceAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'destinationAmount',
  type: 'string',
  validator: truthyDigitString
}, {
  property: 'sourceToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'destinationToken',
  type: 'string',
  validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
    allowNonPrefixed: false
  })
}, {
  property: 'aggregator',
  type: 'string',
  validator: truthyString
}, {
  property: 'aggType',
  type: 'string',
  validator: truthyString
}, {
  property: 'error',
  type: 'object',
  validator: error => error === null || typeof error === 'object'
}, {
  property: 'averageGas',
  type: 'number'
}, {
  property: 'maxGas',
  type: 'number'
}, {
  property: 'gasEstimate',
  type: 'number|undefined',
  validator: gasEstimate => gasEstimate === undefined || gasEstimate > 0
}, {
  property: 'fee',
  type: 'number'
}];
/**
 * @param {string} type - Type of an API call, e.g. "tokens"
 * @param {string} chainId
 * @returns string
 */

exports.QUOTE_VALIDATORS = QUOTE_VALIDATORS;

const getBaseUrlForNewSwapsApi = (type, chainId) => {
  const useDevApis = false;
  const v2ApiBaseUrl = useDevApis ? _swaps.SWAPS_DEV_API_V2_BASE_URL : _swaps.SWAPS_API_V2_BASE_URL;
  const gasApiBaseUrl = useDevApis ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
  const noNetworkSpecificTypes = ['refreshTime']; // These types don't need network info in the URL.

  if (noNetworkSpecificTypes.includes(type)) {
    return v2ApiBaseUrl;
  }

  const chainIdDecimal = chainId && parseInt(chainId, 16);
  const gasApiTypes = ['gasPrices'];

  if (gasApiTypes.includes(type)) {
    return `${gasApiBaseUrl}/networks/${chainIdDecimal}`; // Gas calculations are in its own repo.
  }

  return `${v2ApiBaseUrl}/networks/${chainIdDecimal}`;
};

const getBaseApi = function (type, chainId = _network.CHAIN_IDS.MAINNET) {
  // eslint-disable-next-line no-param-reassign
  chainId = TEST_CHAIN_IDS.includes(chainId) ? _network.CHAIN_IDS.MAINNET : chainId;
  const baseUrl = getBaseUrlForNewSwapsApi(type, chainId);
  const chainIdDecimal = chainId && parseInt(chainId, 16);

  if (!baseUrl) {
    throw new Error(`Swaps API calls are disabled for chainId: ${chainId}`);
  }

  switch (type) {
    case 'trade':
      return `${baseUrl}/trades?`;

    case 'tokens':
      return `${baseUrl}/tokens`;

    case 'token':
      return `${baseUrl}/token`;

    case 'topAssets':
      return `${baseUrl}/topAssets`;

    case 'aggregatorMetadata':
      return `${baseUrl}/aggregatorMetadata`;

    case 'gasPrices':
      return `${baseUrl}/gasPrices`;

    case 'network':
      // Only use v2 for this endpoint.
      return `${_swaps.SWAPS_API_V2_BASE_URL}/networks/${chainIdDecimal}`;

    default:
      throw new Error('getBaseApi requires an api call type');
  }
};

exports.getBaseApi = getBaseApi;

function calcTokenValue(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).times(multiplier);
}

const shouldEnableDirectWrapping = (chainId, sourceToken, destinationToken) => {
  var _SWAPS_CHAINID_DEFAUL;

  if (!sourceToken || !destinationToken) {
    return false;
  }

  const wrappedToken = _swaps.SWAPS_WRAPPED_TOKENS_ADDRESSES[chainId];
  const nativeToken = (_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address;
  const sourceTokenLowerCase = sourceToken.toLowerCase();
  const destinationTokenLowerCase = destinationToken.toLowerCase();
  return sourceTokenLowerCase === wrappedToken && destinationTokenLowerCase === nativeToken || sourceTokenLowerCase === nativeToken && destinationTokenLowerCase === wrappedToken;
};
/**
 * Given and object where all values are strings, returns the same object with all values
 * now prefixed with '0x'
 *
 * @param obj
 */


exports.shouldEnableDirectWrapping = shouldEnableDirectWrapping;

function addHexPrefixToObjectValues(obj) {
  return Object.keys(obj).reduce((newObj, key) => {
    return { ...newObj,
      [key]: (0, _util.addHexPrefix)(obj[key])
    };
  }, {});
}
/**
 * Given the standard set of information about a transaction, returns a transaction properly formatted for
 * publishing via JSON RPC and web3
 *
 * @param {object} options
 * @param {boolean} [options.sendToken] - Indicates whether or not the transaciton is a token transaction
 * @param {string} options.data - A hex string containing the data to include in the transaction
 * @param {string} options.to - A hex address of the tx recipient address
 * @param options.amount
 * @param {string} options.from - A hex address of the tx sender address
 * @param {string} options.gas - A hex representation of the gas value for the transaction
 * @param {string} options.gasPrice - A hex representation of the gas price for the transaction
 * @returns {object} An object ready for submission to the blockchain, with all values appropriately hex prefixed
 */


function constructTxParams({
  sendToken,
  data,
  to,
  amount,
  from,
  gas,
  gasPrice
}) {
  const txParams = {
    data,
    from,
    value: '0',
    gas,
    gasPrice
  };

  if (!sendToken) {
    txParams.value = amount;
    txParams.to = to;
  }

  return addHexPrefixToObjectValues(txParams);
}

async function fetchTradesInfo({
  slippage,
  sourceToken,
  sourceDecimals,
  destinationToken,
  value,
  fromAddress,
  exchangeList
}, {
  chainId
}) {
  const urlParams = {
    destinationToken,
    sourceToken,
    sourceAmount: calcTokenValue(value, sourceDecimals).toString(10),
    slippage,
    timeout: _time.SECOND * 10,
    walletAddress: fromAddress
  };

  if (exchangeList) {
    urlParams.exchangeList = exchangeList;
  }

  if (shouldEnableDirectWrapping(chainId, sourceToken, destinationToken)) {
    urlParams.enableDirectWrapping = true;
  }

  const queryString = new URLSearchParams(urlParams).toString();
  const tradeURL = `${getBaseApi('trade', chainId)}${queryString}`;
  const tradesResponse = await (0, _fetchWithCache.default)(tradeURL, {
    method: 'GET',
    headers: clientIdHeader
  }, {
    cacheRefreshTime: 0,
    timeout: _time.SECOND * 15
  });
  const newQuotes = tradesResponse.reduce((aggIdTradeMap, quote) => {
    if (quote.trade && !quote.error && validateData(QUOTE_VALIDATORS, quote, tradeURL)) {
      const constructedTrade = constructTxParams({
        to: quote.trade.to,
        from: quote.trade.from,
        data: quote.trade.data,
        amount: (0, _transactionsControllerUtils.decimalToHex)(quote.trade.value),
        gas: (0, _transactionsControllerUtils.decimalToHex)(quote.maxGas)
      });
      let {
        approvalNeeded
      } = quote;

      if (approvalNeeded) {
        approvalNeeded = constructTxParams({ ...approvalNeeded
        });
      }

      return { ...aggIdTradeMap,
        [quote.aggregator]: { ...quote,
          slippage,
          trade: constructedTrade,
          approvalNeeded
        }
      };
    }

    return aggIdTradeMap;
  }, {});
  return newQuotes;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\switch-direction.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\switch-direction.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
 * Switch the CSS stylesheet used between 'rtl' and 'ltr'
 *
 * @param {('ltr' | 'rtl' | 'auto')} direction - Text direction, either left-to-right (ltr) or right-to-left (rtl)
 * @returns {Promise<void>}
 */
const switchDirection = async direction => {
  if (direction === 'auto') {
    // eslint-disable-next-line no-param-reassign
    direction = 'ltr';
  }

  let updatedLink;
  [...document.querySelectorAll('link[rel=stylesheet]')].forEach(link => {
    if (link.title === direction && link.disabled) {
      link.disabled = false;
      updatedLink = link;
    } else if (link.title !== direction && !link.disabled) {
      link.disabled = true;
    }
  });

  if (updatedLink) {
    return new Promise((resolve, reject) => {
      updatedLink.onload = () => {
        resolve();
      };

      updatedLink.onerror = () => reject(new Error(`Failed to load '${direction}' stylesheet`));
    });
  }

  return undefined;
};

var _default = switchDirection;
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", {"../constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","../modules/swaps.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\swaps.utils.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\transactions-controller-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = exports.TRANSACTION_ENVELOPE_TYPE_NAMES = exports.TEN_SECONDS_IN_MILLISECONDS = void 0;
exports.calcGasTotal = calcGasTotal;
exports.calcTokenAmount = calcTokenAmount;
exports.decimalToHex = decimalToHex;
exports.getSwapsTokensReceivedFromTxMeta = getSwapsTokensReceivedFromTxMeta;
exports.hexWEIToDecETH = hexWEIToDecETH;
exports.hexWEIToDecGWEI = hexWEIToDecGWEI;
exports.toPrecisionWithoutTrailingZeros = toPrecisionWithoutTrailingZeros;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _transaction = require("../constants/transaction");

var _conversion = require("../modules/conversion.utils");

var _swaps = require("../modules/swaps.utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const TOKEN_TRANSFER_LOG_TOPIC_HASH = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
const TRANSACTION_NO_CONTRACT_ERROR_KEY = 'transactionErrorNoContract';
exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = TRANSACTION_NO_CONTRACT_ERROR_KEY;
const TEN_SECONDS_IN_MILLISECONDS = 10000;
exports.TEN_SECONDS_IN_MILLISECONDS = TEN_SECONDS_IN_MILLISECONDS;

function calcGasTotal(gasLimit = '0', gasPrice = '0') {
  return (0, _conversion.multiplyCurrencies)(gasLimit, gasPrice, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 16
  });
}
/**
 * Given a number and specified precision, returns that number in base 10 with a maximum of precision
 * significant digits, but without any trailing zeros after the decimal point To be used when wishing
 * to display only as much digits to the user as necessary
 *
 * @param {string | number | BigNumber} n - The number to format
 * @param {number} precision - The maximum number of significant digits in the return value
 * @returns {string} The number in decimal form, with <= precision significant digits and no decimal trailing zeros
 */


function toPrecisionWithoutTrailingZeros(n, precision) {
  return new _bignumber.default(n).toPrecision(precision).replace(/(\.[0-9]*[1-9])0*|(\.0*)/u, '$1');
}

function calcTokenAmount(value, decimals) {
  const multiplier = Math.pow(10, Number(decimals || 0));
  return new _bignumber.default(String(value)).div(multiplier);
}

function getSwapsTokensReceivedFromTxMeta(tokenSymbol, txMeta, tokenAddress, accountAddress, tokenDecimals, approvalTxMeta, chainId) {
  var _txMeta$txReceipt;

  const txReceipt = txMeta === null || txMeta === void 0 ? void 0 : txMeta.txReceipt;
  const networkAndAccountSupports1559 = (txMeta === null || txMeta === void 0 ? void 0 : (_txMeta$txReceipt = txMeta.txReceipt) === null || _txMeta$txReceipt === void 0 ? void 0 : _txMeta$txReceipt.type) === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;

  if ((0, _swaps.isSwapsDefaultTokenSymbol)(tokenSymbol, chainId)) {
    if (!txReceipt || !txMeta || !txMeta.postTxBalance || !txMeta.preTxBalance) {
      return null;
    }

    if (txMeta.swapMetaData && txMeta.preTxBalance === txMeta.postTxBalance) {
      // If preTxBalance and postTxBalance are equal, postTxBalance hasn't been updated on time
      // because of the RPC provider delay, so we return an estimated receiving amount instead.
      return txMeta.swapMetaData.token_to_amount;
    }

    let approvalTxGasCost = '0x0';

    if (approvalTxMeta && approvalTxMeta.txReceipt) {
      approvalTxGasCost = calcGasTotal(approvalTxMeta.txReceipt.gasUsed, networkAndAccountSupports1559 ? approvalTxMeta.txReceipt.effectiveGasPrice // Base fee + priority fee.
      : approvalTxMeta.txParams.gasPrice);
    }

    const gasCost = calcGasTotal(txReceipt.gasUsed, networkAndAccountSupports1559 ? txReceipt.effectiveGasPrice : txMeta.txParams.gasPrice);
    const totalGasCost = new _bignumber.default(gasCost, 16).plus(approvalTxGasCost, 16).toString(16);
    const preTxBalanceLessGasCost = (0, _conversion.subtractCurrencies)(txMeta.preTxBalance, totalGasCost, {
      aBase: 16,
      bBase: 16,
      toNumericBase: 'hex'
    });
    const ethReceived = (0, _conversion.subtractCurrencies)(txMeta.postTxBalance, preTxBalanceLessGasCost, {
      aBase: 16,
      bBase: 16,
      fromDenomination: 'WEI',
      toDenomination: 'ETH',
      toNumericBase: 'dec',
      numberOfDecimals: 6
    });
    return ethReceived;
  }

  const txReceiptLogs = txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.logs;

  if (txReceiptLogs && (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) !== '0x0') {
    const tokenTransferLog = txReceiptLogs.find(txReceiptLog => {
      const isTokenTransfer = txReceiptLog.topics && txReceiptLog.topics[0] === TOKEN_TRANSFER_LOG_TOPIC_HASH;
      const isTransferFromGivenToken = txReceiptLog.address === tokenAddress;
      const isTransferFromGivenAddress = txReceiptLog.topics && txReceiptLog.topics[2] && txReceiptLog.topics[2].match(accountAddress.slice(2));
      return isTokenTransfer && isTransferFromGivenToken && isTransferFromGivenAddress;
    });
    return tokenTransferLog ? toPrecisionWithoutTrailingZeros(calcTokenAmount(tokenTransferLog.data, tokenDecimals).toString(10), 6) : '';
  }

  return null;
}

const TRANSACTION_ENVELOPE_TYPE_NAMES = {
  FEE_MARKET: 'fee-market',
  LEGACY: 'legacy'
};
exports.TRANSACTION_ENVELOPE_TYPE_NAMES = TRANSACTION_ENVELOPE_TYPE_NAMES;

function hexWEIToDecGWEI(decGWEI) {
  return (0, _conversion.conversionUtil)(decGWEI, {
    fromNumericBase: 'hex',
    toNumericBase: 'dec',
    fromDenomination: 'WEI',
    toDenomination: 'GWEI'
  });
}

function decimalToHex(decimal) {
  return (0, _conversion.conversionUtil)(decimal, {
    fromNumericBase: 'dec',
    toNumericBase: 'hex'
  });
}

function hexWEIToDecETH(hexWEI) {
  return (0, _conversion.conversionUtil)(hexWEI, {
    fromNumericBase: 'hex',
    toNumericBase: 'dec',
    fromDenomination: 'WEI',
    toDenomination: 'ETH'
  });
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\contract-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readAddressAsContract = void 0;

const readAddressAsContract = async (ethQuery, address) => {
  let contractCode;

  try {
    contractCode = await ethQuery.getCode(address);
  } catch (e) {
    contractCode = null;
  }

  const isContractAddress = contractCode && contractCode !== '0x' && contractCode !== '0x0';
  return {
    contractCode,
    isContractAddress
  };
};

exports.readAddressAsContract = readAddressAsContract;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", {"./hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\conversion.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conversionUtil = exports.conversionMax = exports.conversionLessThan = exports.conversionLTE = exports.conversionGreaterThan = exports.conversionGTE = exports.addCurrencies = void 0;
exports.decGWEIToHexWEI = decGWEIToHexWEI;
exports.toNormalizedDenomination = exports.toNegative = exports.toBigNumber = exports.subtractCurrencies = exports.multiplyCurrencies = exports.divideCurrencies = void 0;

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _ethereumjsUtil = require("ethereumjs-util");

var _hexstringUtils = require("./hexstring-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Currency Conversion Utility
 * This utility function can be used for converting currency related values within metamask.
 * The caller should be able to pass it a value, along with information about the value's
 * numeric base, denomination and currency, and the desired numeric base, denomination and
 * currency. It should return a single value.
 *
 * @param {(number | string | BN)} value - The value to convert.
 * @param {object} [options] - Options to specify details of the conversion
 * @param {string} [options.fromCurrency = 'ETH' | 'USD'] - The currency of the passed value
 * @param {string} [options.toCurrency = 'ETH' | 'USD'] - The desired currency of the result
 * @param {string} [options.fromNumericBase = 'hex' | 'dec' | 'BN'] - The numeric basic of the passed value.
 * @param {string} [options.toNumericBase = 'hex' | 'dec' | 'BN'] - The desired numeric basic of the result.
 * @param {string} [options.fromDenomination = 'WEI'] - The denomination of the passed value
 * @param {string} [options.numberOfDecimals] - The desired number of decimals in the result
 * @param {string} [options.roundDown] - The desired number of decimals to round down to
 * @param {number} [options.conversionRate] - The rate to use to make the fromCurrency -> toCurrency conversion
 * @returns {(number | string | BN)}
 *
 * The utility passes value along with the options as a single object to the `converter` function.
 * `converter` conditional modifies the supplied `value` property, depending
 * on the accompanying options.
 */
// Big Number Constants
const BIG_NUMBER_WEI_MULTIPLIER = new _bignumber.default('1000000000000000000');
const BIG_NUMBER_GWEI_MULTIPLIER = new _bignumber.default('1000000000');
const BIG_NUMBER_ETH_MULTIPLIER = new _bignumber.default('1'); // Setter Maps

const toBigNumber = {
  hex: n => new _bignumber.default((0, _hexstringUtils.stripHexPrefix)(n), 16),
  dec: n => new _bignumber.default(String(n), 10),
  BN: n => new _bignumber.default(n.toString(16), 16)
};
exports.toBigNumber = toBigNumber;
const toNormalizedDenomination = {
  WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
  GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
  ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
};
exports.toNormalizedDenomination = toNormalizedDenomination;
const toSpecifiedDenomination = {
  WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).round(),
  GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).round(9),
  ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).round(9)
};
const baseChange = {
  hex: n => n.toString(16),
  dec: n => new _bignumber.default(n).toString(10),
  BN: n => new _ethereumjsUtil.BN(n.toString(16))
}; // Utility function for checking base types

const isValidBase = base => {
  return Number.isInteger(base) && base > 1;
};
/**
 * Defines the base type of numeric value
 *
 * @typedef {('hex' | 'dec' | 'BN')} NumericBase
 */

/**
 * Defines which type of denomination a value is in
 *
 * @typedef {('WEI' | 'GWEI' | 'ETH')} EthDenomination
 */

/**
 * Utility method to convert a value between denominations, formats and currencies.
 *
 * @param {object} input
 * @param {string | BigNumber} input.value
 * @param {NumericBase} input.fromNumericBase
 * @param {EthDenomination} [input.fromDenomination]
 * @param {string} [input.fromCurrency]
 * @param {NumericBase} input.toNumericBase
 * @param {EthDenomination} [input.toDenomination]
 * @param {string} [input.toCurrency]
 * @param {number} [input.numberOfDecimals]
 * @param {number} [input.conversionRate]
 * @param {boolean} [input.invertConversionRate]
 * @param {string} [input.roundDown]
 */


const converter = ({
  value,
  fromNumericBase,
  fromDenomination,
  fromCurrency,
  toNumericBase,
  toDenomination,
  toCurrency,
  numberOfDecimals,
  conversionRate,
  invertConversionRate,
  roundDown
}) => {
  let convertedValue = fromNumericBase ? toBigNumber[fromNumericBase](value) : value;

  if (fromDenomination) {
    convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
  }

  if (fromCurrency !== toCurrency) {
    if (conversionRate === null || conversionRate === undefined) {
      throw new Error(`Converting from ${fromCurrency} to ${toCurrency} requires a conversionRate, but one was not provided`);
    }

    let rate = toBigNumber.dec(conversionRate);

    if (invertConversionRate) {
      rate = new _bignumber.default(1.0).div(conversionRate);
    }

    convertedValue = convertedValue.times(rate);
  }

  if (toDenomination) {
    convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
  }

  if (numberOfDecimals !== undefined && numberOfDecimals !== null) {
    convertedValue = convertedValue.round(numberOfDecimals, _bignumber.default.ROUND_HALF_DOWN);
  }

  if (roundDown) {
    convertedValue = convertedValue.round(roundDown, _bignumber.default.ROUND_DOWN);
  }

  if (toNumericBase) {
    convertedValue = baseChange[toNumericBase](convertedValue);
  }

  return convertedValue;
};

const conversionUtil = (value, {
  fromCurrency = null,
  toCurrency = fromCurrency,
  fromNumericBase,
  toNumericBase,
  fromDenomination,
  toDenomination,
  numberOfDecimals,
  conversionRate,
  invertConversionRate
}) => {
  if (fromCurrency !== toCurrency && !conversionRate) {
    return 0;
  }

  return converter({
    fromCurrency,
    toCurrency,
    fromNumericBase,
    toNumericBase,
    fromDenomination,
    toDenomination,
    numberOfDecimals,
    conversionRate,
    invertConversionRate,
    value: value || '0'
  });
};

exports.conversionUtil = conversionUtil;

const getBigNumber = (value, base) => {
  if (!isValidBase(base)) {
    throw new Error('Must specify valid base');
  } // We don't include 'number' here, because BigNumber will throw if passed
  // a number primitive it considers unsafe.


  if (typeof value === 'string' || value instanceof _bignumber.default) {
    return new _bignumber.default(value, base);
  }

  return new _bignumber.default(String(value), base);
};

const addCurrencies = (a, b, options = {}) => {
  const {
    aBase,
    bBase,
    ...conversionOptions
  } = options;

  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error('Must specify valid aBase and bBase');
  }

  const value = getBigNumber(a, aBase).add(getBigNumber(b, bBase));
  return converter({
    value,
    ...conversionOptions
  });
};

exports.addCurrencies = addCurrencies;

const subtractCurrencies = (a, b, options = {}) => {
  const {
    aBase,
    bBase,
    ...conversionOptions
  } = options;

  if (!isValidBase(aBase) || !isValidBase(bBase)) {
    throw new Error('Must specify valid aBase and bBase');
  }

  const value = getBigNumber(a, aBase).minus(getBigNumber(b, bBase));
  return converter({
    value,
    ...conversionOptions
  });
};

exports.subtractCurrencies = subtractCurrencies;

const multiplyCurrencies = (a, b, options = {}) => {
  const {
    multiplicandBase,
    multiplierBase,
    ...conversionOptions
  } = options;

  if (!isValidBase(multiplicandBase) || !isValidBase(multiplierBase)) {
    throw new Error('Must specify valid multiplicandBase and multiplierBase');
  }

  const value = getBigNumber(a, multiplicandBase).times(getBigNumber(b, multiplierBase));
  return converter({
    value,
    ...conversionOptions
  });
};

exports.multiplyCurrencies = multiplyCurrencies;

const divideCurrencies = (a, b, options = {}) => {
  const {
    dividendBase,
    divisorBase,
    ...conversionOptions
  } = options;

  if (!isValidBase(dividendBase) || !isValidBase(divisorBase)) {
    throw new Error('Must specify valid dividendBase and divisorBase');
  }

  const value = getBigNumber(a, dividendBase).div(getBigNumber(b, divisorBase));
  return converter({
    value,
    ...conversionOptions
  });
};

exports.divideCurrencies = divideCurrencies;

const conversionGreaterThan = ({ ...firstProps
}, { ...secondProps
}) => {
  const firstValue = converter({ ...firstProps
  });
  const secondValue = converter({ ...secondProps
  });
  return firstValue.gt(secondValue);
};

exports.conversionGreaterThan = conversionGreaterThan;

const conversionLessThan = ({ ...firstProps
}, { ...secondProps
}) => {
  const firstValue = converter({ ...firstProps
  });
  const secondValue = converter({ ...secondProps
  });
  return firstValue.lt(secondValue);
};

exports.conversionLessThan = conversionLessThan;

const conversionMax = ({ ...firstProps
}, { ...secondProps
}) => {
  const firstIsGreater = conversionGreaterThan({ ...firstProps
  }, { ...secondProps
  });
  return firstIsGreater ? firstProps.value : secondProps.value;
};

exports.conversionMax = conversionMax;

const conversionGTE = ({ ...firstProps
}, { ...secondProps
}) => {
  const firstValue = converter({ ...firstProps
  });
  const secondValue = converter({ ...secondProps
  });
  return firstValue.greaterThanOrEqualTo(secondValue);
};

exports.conversionGTE = conversionGTE;

const conversionLTE = ({ ...firstProps
}, { ...secondProps
}) => {
  const firstValue = converter({ ...firstProps
  });
  const secondValue = converter({ ...secondProps
  });
  return firstValue.lessThanOrEqualTo(secondValue);
};

exports.conversionLTE = conversionLTE;

const toNegative = (n, options = {}) => {
  return multiplyCurrencies(n, -1, options);
};

exports.toNegative = toNegative;

function decGWEIToHexWEI(decGWEI) {
  return conversionUtil(decGWEI, {
    fromNumericBase: 'dec',
    toNumericBase: 'hex',
    fromDenomination: 'GWEI',
    toDenomination: 'WEI'
  });
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js", {"../constants/time":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\fetch-with-timeout.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _lodash = require("lodash");

var _time = require("../constants/time");

const getFetchWithTimeout = (0, _lodash.memoize)((timeout = _time.SECOND * 30) => {
  if (!Number.isInteger(timeout) || timeout < 1) {
    throw new Error('Must specify positive integer timeout.');
  }

  return async function _fetch(url, opts) {
    const abortController = new window.AbortController();
    const {
      signal
    } = abortController;
    const f = window.fetch(url, { ...opts,
      signal
    });
    const timer = setTimeout(() => abortController.abort(), timeout);

    try {
      const res = await f;
      clearTimeout(timer);
      return res;
    } catch (e) {
      clearTimeout(timer);
      throw e;
    }
  };
});
var _default = getFetchWithTimeout;
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\gas.utils.js", {"./conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\gas.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMaximumGasTotalInHexWei = getMaximumGasTotalInHexWei;
exports.getMinimumGasTotalInHexWei = getMinimumGasTotalInHexWei;

var _ethereumjsUtil = require("ethereumjs-util");

var _conversion = require("./conversion.utils");

/**
 * Accepts an options bag containing gas fee parameters in hex format and
 * returns a gasTotal parameter representing the maximum amount of wei the
 * transaction will cost.
 *
 * @param {object} options - gas fee parameters object
 * @param {string} [options.gasLimit] - the maximum amount of gas to allow this
 *  transaction to consume. Value is a hex string
 * @param {string} [options.gasPrice] - The fee in wei to pay per gas used.
 *  gasPrice is only set on Legacy type transactions. Value is hex string
 * @param {string} [options.maxFeePerGas] - The maximum fee in wei to pay per
 *  gas used. maxFeePerGas is introduced in EIP 1559 and represents the max
 *  total a user will pay per gas. Actual cost is determined by baseFeePerGas
 *  on the block + maxPriorityFeePerGas. Value is hex string
 * @returns {string} The maximum total cost of transaction in hex wei string
 */
function getMaximumGasTotalInHexWei({
  gasLimit = '0x0',
  gasPrice,
  maxFeePerGas
} = {}) {
  if (maxFeePerGas) {
    return (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit, maxFeePerGas, {
      toNumericBase: 'hex',
      multiplicandBase: 16,
      multiplierBase: 16
    }));
  }

  if (!gasPrice) {
    throw new Error('getMaximumGasTotalInHexWei requires gasPrice be provided to calculate legacy gas total');
  }

  return (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit, gasPrice, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 16
  }));
}
/**
 * Accepts an options bag containing gas fee parameters in hex format and
 * returns a gasTotal parameter representing the minimum amount of wei the
 * transaction will cost. For gasPrice types this is the same as max.
 *
 * @param {object} options - gas fee parameters object
 * @param {string} [options.gasLimit] - the maximum amount of gas to allow this
 *  transaction to consume. Value is a hex string
 * @param {string} [options.gasPrice] - The fee in wei to pay per gas used.
 *  gasPrice is only set on Legacy type transactions. Value is hex string
 * @param {string} [options.maxFeePerGas] - The maximum fee in wei to pay per
 *  gas used. maxFeePerGas is introduced in EIP 1559 and represents the max
 *  total a user will pay per gas. Actual cost is determined by baseFeePerGas
 *  on the block + maxPriorityFeePerGas. Value is hex string
 * @param {string} [options.maxPriorityFeePerGas] - The maximum fee in wei to
 *  pay a miner to include this transaction.
 * @param {string} [options.baseFeePerGas] - The estimated block baseFeePerGas
 *  that will be burned. Introduced in EIP 1559. Value in hex wei.
 * @returns {string} The minimum total cost of transaction in hex wei string
 */


function getMinimumGasTotalInHexWei({
  gasLimit = '0x0',
  gasPrice,
  maxPriorityFeePerGas,
  maxFeePerGas,
  baseFeePerGas
} = {}) {
  const isEIP1559Estimate = Boolean(maxFeePerGas || maxPriorityFeePerGas || baseFeePerGas);

  if (isEIP1559Estimate && gasPrice) {
    throw new Error(`getMinimumGasTotalInHexWei expects either gasPrice OR the EIP-1559 gas fields, but both were provided`);
  }

  if (isEIP1559Estimate === false && !gasPrice) {
    throw new Error(`getMinimumGasTotalInHexWei expects either gasPrice OR the EIP-1559 gas fields, but neither were provided`);
  }

  if (isEIP1559Estimate && !baseFeePerGas) {
    throw new Error(`getMinimumGasTotalInHexWei requires baseFeePerGas be provided when calculating EIP-1559 totals`);
  }

  if (isEIP1559Estimate && (!maxFeePerGas || !maxPriorityFeePerGas)) {
    throw new Error(`getMinimumGasTotalInHexWei requires maxFeePerGas and maxPriorityFeePerGas be provided when calculating EIP-1559 totals`);
  }

  if (isEIP1559Estimate === false) {
    return getMaximumGasTotalInHexWei({
      gasLimit,
      gasPrice
    });
  }

  const minimumFeePerGas = (0, _conversion.addCurrencies)(baseFeePerGas, maxPriorityFeePerGas, {
    toNumericBase: 'hex',
    aBase: 16,
    bBase: 16
  });

  if ((0, _conversion.conversionGreaterThan)({
    value: minimumFeePerGas,
    fromNumericBase: 'hex'
  }, {
    value: maxFeePerGas,
    fromNumericBase: 'hex'
  })) {
    return getMaximumGasTotalInHexWei({
      gasLimit,
      maxFeePerGas
    });
  }

  return (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit, minimumFeePerGas, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 16
  }));
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", {"ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\hexstring-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BURN_ADDRESS = void 0;
exports.isBurnAddress = isBurnAddress;
exports.isValidHexAddress = isValidHexAddress;
exports.stripHexPrefix = stripHexPrefix;
exports.toChecksumHexAddress = toChecksumHexAddress;

var _ethereumjsUtil = require("ethereumjs-util");

const BURN_ADDRESS = (0, _ethereumjsUtil.zeroAddress)();
exports.BURN_ADDRESS = BURN_ADDRESS;

function isBurnAddress(address) {
  return address === BURN_ADDRESS;
}
/**
 * Validates that the input is a hex address. This utility method is a thin
 * wrapper around ethereumjs-util.isValidAddress, with the exception that it
 * does not throw an error when provided values that are not hex strings. In
 * addition, and by default, this method will return true for hex strings that
 * meet the length requirement of a hex address, but are not prefixed with `0x`
 * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
 * provided this method will validate it has the proper checksum formatting.
 *
 * @param {string} possibleAddress - Input parameter to check against
 * @param {object} [options] - options bag
 * @param {boolean} [options.allowNonPrefixed] - If true will first ensure '0x'
 *  is prepended to the string
 * @param {boolean} [options.mixedCaseUseChecksum] - If true will treat mixed
 *  case addresses as checksum addresses and validate that proper checksum
 *  format is used
 * @returns {boolean} whether or not the input is a valid hex address
 */


function isValidHexAddress(possibleAddress, {
  allowNonPrefixed = true,
  mixedCaseUseChecksum = false
} = {}) {
  const addressToCheck = allowNonPrefixed ? (0, _ethereumjsUtil.addHexPrefix)(possibleAddress) : possibleAddress;

  if (!(0, _ethereumjsUtil.isHexString)(addressToCheck)) {
    return false;
  }

  if (mixedCaseUseChecksum) {
    const prefixRemoved = addressToCheck.slice(2);
    const lower = prefixRemoved.toLowerCase();
    const upper = prefixRemoved.toUpperCase();
    const allOneCase = prefixRemoved === lower || prefixRemoved === upper;

    if (!allOneCase) {
      return (0, _ethereumjsUtil.isValidChecksumAddress)(addressToCheck);
    }
  }

  return (0, _ethereumjsUtil.isValidAddress)(addressToCheck);
}

function toChecksumHexAddress(address) {
  if (!address) {
    // our internal checksumAddress function that this method replaces would
    // return an empty string for nullish input. If any direct usages of
    // ethereumjs-util.toChecksumAddress were called with nullish input it
    // would have resulted in an error on version 5.1.
    return '';
  }

  const hexPrefixed = (0, _ethereumjsUtil.addHexPrefix)(address);

  if (!(0, _ethereumjsUtil.isHexString)(hexPrefixed)) {
    // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
    // but we shouldn't waste effort trying to change case on a clearly invalid
    // string. Instead just return the hex prefixed original string which most
    // closely mimics the original behavior.
    return hexPrefixed;
  }

  return (0, _ethereumjsUtil.toChecksumAddress)(hexPrefixed);
}

function stripHexPrefix(str) {
  if (typeof str !== 'string') {
    return str;
  }

  return (0, _ethereumjsUtil.isHexPrefixed)(str) ? str.slice(2) : str;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\mv3.utils.js", {"webextension-polyfill":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\mv3.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isManifestV3 = void 0;

var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isManifestV3 = _webextensionPolyfill.default.runtime.getManifest().manifest_version === 3;
exports.isManifestV3 = isManifestV3;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\network.utils.js", {"../constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\network.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPrefixedFormattedHexString = isPrefixedFormattedHexString;
exports.isSafeChainId = isSafeChainId;
exports.isTokenDetectionEnabledForNetwork = isTokenDetectionEnabledForNetwork;

var _network = require("../constants/network");

/**
 * Checks whether the given number primitive chain ID is safe.
 * Because some cryptographic libraries we use expect the chain ID to be a
 * number primitive, it must not exceed a certain size.
 *
 * @param {number} chainId - The chain ID to check for safety.
 * @returns {boolean} Whether the given chain ID is safe.
 */
function isSafeChainId(chainId) {
  return Number.isSafeInteger(chainId) && chainId > 0 && chainId <= _network.MAX_SAFE_CHAIN_ID;
}
/**
 * Checks whether the given value is a 0x-prefixed, non-zero, non-zero-padded,
 * hexadecimal string.
 *
 * @param {any} value - The value to check.
 * @returns {boolean} True if the value is a correctly formatted hex string,
 * false otherwise.
 */


function isPrefixedFormattedHexString(value) {
  if (typeof value !== 'string') {
    return false;
  }

  return /^0x[1-9a-f]+[0-9a-f]*$/iu.test(value);
}
/**
 * Check if token detection is enabled for certain networks
 *
 * @param chainId - ChainID of network
 * @returns Whether the current network supports token detection
 */


function isTokenDetectionEnabledForNetwork(chainId) {
  switch (chainId) {
    case _network.CHAIN_IDS.MAINNET:
    case _network.CHAIN_IDS.BSC:
    case _network.CHAIN_IDS.POLYGON:
    case _network.CHAIN_IDS.AVALANCHE:
      return true;

    default:
      return false;
  }
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\object.utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\object.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.maskObject = maskObject;

/**
 * Return a "masked" copy of the given object.
 *
 * The returned object includes only the properties present in the mask. The
 * mask is an object that mirrors the structure of the given object, except
 * the only values are `true` or a sub-mask. `true` implies the property
 * should be included, and a sub-mask implies the property should be further
 * masked according to that sub-mask.
 *
 * @param {object} object - The object to mask
 * @param {Object<object | boolean>} mask - The mask to apply to the object
 */
function maskObject(object, mask) {
  return Object.keys(object).reduce((state, key) => {
    if (mask[key] === true) {
      state[key] = object[key];
    } else if (mask[key]) {
      state[key] = maskObject(object[key], mask[key]);
    }

    return state;
  }, {});
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\random-id.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\random-id.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createRandomId;
const MAX = Number.MAX_SAFE_INTEGER;
let idCounter = Math.round(Math.random() * MAX);

function createRandomId() {
  idCounter %= MAX; // eslint-disable-next-line no-plusplus

  return idCounter++;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\rpc.utils.js", {"./fetch-with-timeout":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\rpc.utils.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.jsonRpcRequest = jsonRpcRequest;

var _fetchWithTimeout = _interopRequireDefault(require("./fetch-with-timeout"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const fetchWithTimeout = (0, _fetchWithTimeout.default)();
/**
 * Makes a JSON RPC request to the given URL, with the given RPC method and params.
 *
 * @param {string} rpcUrl - The RPC endpoint URL to target.
 * @param {string} rpcMethod - The RPC method to request.
 * @param {Array<unknown>} [rpcParams] - The RPC method params.
 * @returns {Promise<unknown|undefined>} Returns the result of the RPC method call,
 * or throws an error in case of failure.
 */

async function jsonRpcRequest(rpcUrl, rpcMethod, rpcParams = []) {
  let fetchUrl = rpcUrl;
  const headers = {
    'Content-Type': 'application/json'
  }; // Convert basic auth URL component to Authorization header

  const {
    origin,
    pathname,
    username,
    password,
    search
  } = new URL(rpcUrl); // URLs containing username and password needs special processing

  if (username && password) {
    const encodedAuth = Buffer.from(`${username}:${password}`).toString('base64');
    headers.Authorization = `Basic ${encodedAuth}`;
    fetchUrl = `${origin}${pathname}${search}`;
  }

  const jsonRpcResponse = await fetchWithTimeout(fetchUrl, {
    method: 'POST',
    body: JSON.stringify({
      id: Date.now().toString(),
      jsonrpc: '2.0',
      method: rpcMethod,
      params: rpcParams
    }),
    headers,
    cache: 'default'
  }).then(httpResponse => httpResponse.json());

  if (!jsonRpcResponse || Array.isArray(jsonRpcResponse) || typeof jsonRpcResponse !== 'object') {
    throw new Error(`RPC endpoint ${rpcUrl} returned non-object response.`);
  }

  const {
    error,
    result
  } = jsonRpcResponse;

  if (error) {
    throw new Error((error === null || error === void 0 ? void 0 : error.message) || error);
  }

  return result;
}

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\siwe.js", {"./hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","@spruceid/siwe-parser":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@spruceid\\siwe-parser\\dist\\parsers.js","buffer":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\siwe.js
      return function (require, module, exports) {
(function (Buffer){(function (){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatMessageParams = exports.detectSIWE = void 0;

var _siweParser = require("@spruceid/siwe-parser");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _hexstringUtils = require("./hexstring-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const msgHexToText = hex => {
  try {
    const stripped = (0, _hexstringUtils.stripHexPrefix)(hex);
    const buff = Buffer.from(stripped, 'hex');
    return buff.length === 32 ? hex : buff.toString('utf8');
  } catch (e) {
    _loglevel.default.error(e);

    return hex;
  }
};
/**
 * A locally defined object used to provide data to identify a Sign-In With Ethereum (SIWE)(EIP-4361) message and provide the parsed message
 *
 * @typedef localSIWEObject
 * @param {boolean} isSIWEMessage - Does the intercepted message conform to the SIWE specification?
 * @param {ParsedMessage} parsedMessage - The data parsed out of the message
 */

/**
 * This function intercepts a sign message, detects if it's a
 * Sign-In With Ethereum (SIWE)(EIP-4361) message, and returns an object with
 * relevant SIWE data.
 *
 * {@see {@link https://eips.ethereum.org/EIPS/eip-4361}}
 *
 * @param {object} msgParams - The params of the message to sign
 * @returns {localSIWEObject}
 */


const detectSIWE = msgParams => {
  try {
    const {
      data
    } = msgParams;
    const message = msgHexToText(data);
    const parsedMessage = new _siweParser.ParsedMessage(message);
    return {
      isSIWEMessage: true,
      parsedMessage
    };
  } catch (error) {
    // ignore error, it's not a valid SIWE message
    return {
      isSIWEMessage: false,
      parsedMessage: null
    };
  }
};
/**
 * Takes in a parsed Sign-In with Ethereum Message (EIP-4361)
 * and generates an array of label-value pairs
 *
 * @param {object} parsedMessage - A parsed SIWE message with message contents
 * @param {Function} t - i18n function
 * @returns {Array} An array of label-value pairs with the type of the value as the label
 */


exports.detectSIWE = detectSIWE;

const formatMessageParams = (parsedMessage, t) => {
  const output = [];
  const {
    statement,
    uri,
    version,
    chainId,
    nonce,
    issuedAt,
    expirationTime,
    notBefore,
    requestId,
    resources
  } = parsedMessage;

  if (statement) {
    output.push({
      label: t('SIWELabelMessage'),
      value: statement
    });
  }

  if (uri) {
    output.push({
      label: t('SIWELabelURI'),
      value: uri
    });
  }

  if (version) {
    output.push({
      label: t('SIWELabelVersion'),
      value: version
    });
  }

  if (chainId) {
    output.push({
      label: t('SIWELabelChainID'),
      value: chainId
    });
  }

  if (nonce) {
    output.push({
      label: t('SIWELabelNonce'),
      value: nonce
    });
  }

  if (issuedAt) {
    output.push({
      label: t('SIWELabelIssuedAt'),
      value: issuedAt
    });
  }

  if (expirationTime) {
    output.push({
      label: t('SIWELabelExpirationTime'),
      value: expirationTime
    });
  }

  if (notBefore) {
    output.push({
      label: t('SIWELabelNotBefore'),
      value: notBefore
    });
  }

  if (requestId) {
    output.push({
      label: t('SIWELabelRequestID'),
      value: requestId
    });
  }

  if (resources && resources.length > 0) {
    output.push({
      label: t('SIWELabelResources', [resources.length]),
      value: resources.reduce((previous, resource) => `${previous}${resource}\n`, '').trim()
    });
  }

  return output;
};

exports.formatMessageParams = formatMessageParams;

}).call(this)}).call(this,require("buffer").Buffer)

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\string-utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isEqualCaseInsensitive = isEqualCaseInsensitive;
exports.prependZero = prependZero;

function isEqualCaseInsensitive(value1, value2) {
  if (typeof value1 !== 'string' || typeof value2 !== 'string') {
    return false;
  }

  return value1.toLowerCase() === value2.toLowerCase();
}

function prependZero(num, maxLength) {
  return num.toString().padStart(maxLength, '0');
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\swaps.utils.js", {"../constants/swaps":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\swaps.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\swaps.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwapsDefaultTokenAddress = isSwapsDefaultTokenAddress;
exports.isSwapsDefaultTokenSymbol = isSwapsDefaultTokenSymbol;

var _swaps = require("../constants/swaps");

/**
 * Checks whether the provided address is strictly equal to the address for
 * the default swaps token of the provided chain.
 *
 * @param {string} address - The string to compare to the default token address
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the address is the provided chain's default token address
 */
function isSwapsDefaultTokenAddress(address, chainId) {
  var _SWAPS_CHAINID_DEFAUL;

  if (!address || !chainId) {
    return false;
  }

  return address === ((_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address);
}
/**
 * Checks whether the provided symbol is strictly equal to the symbol for
 * the default swaps token of the provided chain.
 *
 * @param {string} symbol - The string to compare to the default token symbol
 * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
 * @returns {boolean} Whether the symbl is the provided chain's default token symbol
 */


function isSwapsDefaultTokenSymbol(symbol, chainId) {
  var _SWAPS_CHAINID_DEFAUL2;

  if (!symbol || !chainId) {
    return false;
  }

  return symbol === ((_SWAPS_CHAINID_DEFAUL2 = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL2 === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL2.symbol);
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js", {"../constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","./contract-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js","./string-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js","@metamask/metamask-eth-abis":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\index.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\transaction.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.determineTransactionAssetType = determineTransactionAssetType;
exports.determineTransactionContractCode = determineTransactionContractCode;
exports.determineTransactionType = determineTransactionType;
exports.isEIP1559Transaction = isEIP1559Transaction;
exports.isLegacyTransaction = isLegacyTransaction;
exports.parseStandardTokenTransactionData = parseStandardTokenTransactionData;
exports.transactionMatchesNetwork = transactionMatchesNetwork;
exports.txParamsAreDappSuggested = txParamsAreDappSuggested;

var _ethereumjsUtil = require("ethereumjs-util");

var _ethers = require("ethers");

var _metamaskEthAbis = require("@metamask/metamask-eth-abis");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _transaction = require("../constants/transaction");

var _contractUtils = require("./contract-utils");

var _stringUtils = require("./string-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef { 'transfer' | 'approve' | 'setapprovalforall' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes
 */

/**
 * @typedef {object} InferTransactionTypeResult
 * @property {InferrableTransactionTypes} type - The type of transaction
 * @property {string} getCodeResponse - The contract code, in hex format if
 *  it exists. '0x0' or '0x' are also indicators of non-existent contract
 *  code
 */

/**
 * @typedef EthersContractCall
 * @type object
 * @property {any[]} args - The args/params to the function call.
 * An array-like object with numerical and string indices.
 * @property {string} name - The name of the function.
 * @property {string} signature - The function signature.
 * @property {string} sighash - The function signature hash.
 * @property {EthersBigNumber} value - The ETH value associated with the call.
 * @property {FunctionFragment} functionFragment - The Ethers function fragment
 * representation of the function.
 */
const erc20Interface = new _ethers.ethers.utils.Interface(_metamaskEthAbis.abiERC20);
const erc721Interface = new _ethers.ethers.utils.Interface(_metamaskEthAbis.abiERC721);
const erc1155Interface = new _ethers.ethers.utils.Interface(_metamaskEthAbis.abiERC1155);

function transactionMatchesNetwork(transaction, chainId, networkId) {
  if (typeof transaction.chainId !== 'undefined') {
    return transaction.chainId === chainId;
  }

  return transaction.metamaskNetworkId === networkId;
}
/**
 * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
 * and valid inputs. This will return false for non hex string inputs.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid EIP1559 fields
 */


function isEIP1559Transaction(transaction) {
  var _transaction$txParams, _transaction$txParams2;

  return (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams = transaction.txParams) === null || _transaction$txParams === void 0 ? void 0 : _transaction$txParams.maxFeePerGas) && (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams2 = transaction.txParams) === null || _transaction$txParams2 === void 0 ? void 0 : _transaction$txParams2.maxPriorityFeePerGas);
}
/**
 * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
 * supplied and that the gasPrice field is valid if it is provided. This will
 * return false if gasPrice is a non hex string.
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if transaction uses valid Legacy fields OR lacks
 *  EIP1559 fields
 */


function isLegacyTransaction(transaction) {
  return typeof transaction.txParams.maxFeePerGas === 'undefined' && typeof transaction.txParams.maxPriorityFeePerGas === 'undefined' && (typeof transaction.txParams.gasPrice === 'undefined' || (0, _ethereumjsUtil.isHexString)(transaction.txParams.gasPrice));
}
/**
 * Determine if a transactions gas fees in txParams match those in its dappSuggestedGasFees property
 *
 * @param {__import__("../constants/transaction").TransactionMeta} transaction -
 *  the transaction to check
 * @returns {boolean} true if both the txParams and dappSuggestedGasFees are objects with truthy gas fee properties,
 *   and those properties are strictly equal
 */


function txParamsAreDappSuggested(transaction) {
  var _transaction$dappSugg, _transaction$dappSugg2, _transaction$dappSugg3;

  const {
    gasPrice,
    maxPriorityFeePerGas,
    maxFeePerGas
  } = (transaction === null || transaction === void 0 ? void 0 : transaction.txParams) || {};
  return gasPrice && gasPrice === (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg === void 0 ? void 0 : _transaction$dappSugg.gasPrice) || maxPriorityFeePerGas && maxFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg2 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg2 === void 0 ? void 0 : _transaction$dappSugg2.maxPriorityFeePerGas) === maxPriorityFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg3 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg3 === void 0 ? void 0 : _transaction$dappSugg3.maxFeePerGas) === maxFeePerGas;
}
/**
 * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.
 * The data will decode correctly if the transaction is an interaction with a contract that matches one of these
 * contract standards
 *
 * @param data - encoded transaction data
 * @returns {EthersContractCall | undefined}
 */


function parseStandardTokenTransactionData(data) {
  try {
    return erc20Interface.parseTransaction({
      data
    });
  } catch {// ignore and next try to parse with erc721 ABI
  }

  try {
    return erc721Interface.parseTransaction({
      data
    });
  } catch {// ignore and next try to parse with erc1155 ABI
  }

  try {
    return erc1155Interface.parseTransaction({
      data
    });
  } catch {// ignore and return undefined
  }

  return undefined;
}
/**
 * Determines the contractCode of the transaction by analyzing the txParams.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */


async function determineTransactionContractCode(txParams, query) {
  const {
    to
  } = txParams;
  const {
    contractCode
  } = await (0, _contractUtils.readAddressAsContract)(query, to);
  return contractCode;
}
/**
 * Determines the type of the transaction by analyzing the txParams.
 * This method will return one of the types defined in shared/constants/transactions
 * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
 * represent specific events that we control from the extension and are added manually
 * at transaction creation.
 *
 * @param {object} txParams - Parameters for the transaction
 * @param {EthQuery} query - EthQuery instance
 * @returns {InferTransactionTypeResult}
 */


async function determineTransactionType(txParams, query) {
  const {
    data,
    to
  } = txParams;
  let name;

  try {
    ({
      name
    } = data && parseStandardTokenTransactionData(data));
  } catch (error) {
    _loglevel.default.debug('Failed to parse transaction data.', error, data);
  }

  let result;
  let contractCode;

  if (data && !to) {
    result = _transaction.TRANSACTION_TYPES.DEPLOY_CONTRACT;
  } else {
    const {
      contractCode: resultCode,
      isContractAddress
    } = await (0, _contractUtils.readAddressAsContract)(query, to);
    contractCode = resultCode;

    if (isContractAddress) {
      const tokenMethodName = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM].find(methodName => (0, _stringUtils.isEqualCaseInsensitive)(methodName, name));
      result = data && tokenMethodName ? tokenMethodName : _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION;
    } else {
      result = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
    }
  }

  return {
    type: result,
    getCodeResponse: contractCode
  };
}

const INFERRABLE_TRANSACTION_TYPES = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION, _transaction.TRANSACTION_TYPES.SIMPLE_SEND];
/**
 * Given a transaction meta object, determine the asset type that the
 * transaction is dealing with, as well as the standard for the token if it
 * is a token transaction.
 *
 * @param {__import__('../constants/transaction').TransactionMeta} txMeta -
 *  transaction meta object
 * @param {EthQuery} query - EthQuery instance
 * @param {Function} getTokenStandardAndDetails - function to get token
 *  standards and details.
 * @returns {{ assetType: string, tokenStandard: string}}
 */

async function determineTransactionAssetType(txMeta, query, getTokenStandardAndDetails) {
  // If the transaction type is already one of the inferrable types, then we do
  // not need to re-establish the type.
  let inferrableType = txMeta.type;

  if (INFERRABLE_TRANSACTION_TYPES.includes(txMeta.type) === false) {
    // Because we will deal with all types of transactions (including swaps)
    // we want to get an inferrable type of transaction that isn't special cased
    // that way we can narrow the number of logic gates required.
    const result = await determineTransactionType(txMeta.txParams, query);
    inferrableType = result.type;
  } // If the inferred type of the transaction is one of those that are part of
  // the token contract standards, we can use the getTokenStandardAndDetails
  // method to get the asset type.


  const isTokenMethod = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM].find(methodName => methodName === inferrableType);

  if (isTokenMethod || // We can also check any contract interaction type to see if the to address
  // is a token contract. If it isn't, then the method will throw and we can
  // fall through to the other checks.
  inferrableType === _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION) {
    try {
      // We don't need a balance check, so the second parameter to
      // getTokenStandardAndDetails is omitted.
      const details = await getTokenStandardAndDetails(txMeta.txParams.to);

      if (details.standard) {
        return {
          assetType: details.standard === _transaction.TOKEN_STANDARDS.ERC20 ? _transaction.ASSET_TYPES.TOKEN : _transaction.ASSET_TYPES.COLLECTIBLE,
          tokenStandard: details.standard
        };
      }
    } catch {// noop, We expect errors here but we don't need to report them or do
      // anything in response.
    }
  } // If the transaction is interacting with a contract but isn't a token method
  // we use the 'UNKNOWN' value to show that it isn't a transaction sending any
  // particular asset.


  if (inferrableType === _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION) {
    return {
      assetType: _transaction.ASSET_TYPES.UNKNOWN,
      tokenStandard: _transaction.TOKEN_STANDARDS.NONE
    };
  }

  return {
    assetType: _transaction.ASSET_TYPES.NATIVE,
    tokenStandard: _transaction.TOKEN_STANDARDS.NONE
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\notifications\\index.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\notifications\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTranslatedUINotifications = exports.UI_NOTIFICATIONS = void 0;
// Messages and descriptions for these locale keys are in app/_locales/en/messages.json
const UI_NOTIFICATIONS = {
  1: {
    id: 1,
    date: '2021-03-17',
    image: {
      src: 'images/mobile-link-qr.svg',
      height: '230px',
      width: '230px',
      placeImageBelowDescription: true
    }
  },
  3: {
    id: 3,
    date: '2021-03-08'
  },
  4: {
    id: 4,
    date: '2021-05-11',
    image: {
      src: 'images/source-logos-bsc.svg',
      width: '100%'
    }
  },
  5: {
    id: 5,
    date: '2021-06-09'
  },
  6: {
    id: 6,
    date: '2021-05-26'
  },
  7: {
    id: 7,
    date: '2021-09-17'
  },
  8: {
    id: 8,
    date: '2021-11-01'
  },
  9: {
    id: 9,
    date: '2021-12-07',
    image: {
      src: 'images/txinsights.png',
      width: '80%'
    }
  },
  10: {
    id: 10,
    date: '2022-09-15',
    image: {
      src: 'images/token-detection.svg',
      width: '100%'
    }
  },
  11: {
    id: 11,
    date: '2022-09-15'
  },
  12: {
    id: 12,
    date: '2022-05-18',
    image: {
      src: 'images/darkmode-banner.png',
      width: '100%'
    }
  },
  13: {
    id: 13,
    date: '2022-09-15'
  },
  14: {
    id: 14,
    date: '2022-09-15'
  },
  15: {
    id: 15,
    date: '2022-09-15'
  }
};
exports.UI_NOTIFICATIONS = UI_NOTIFICATIONS;

const getTranslatedUINotifications = (t, locale) => {
  const formattedLocale = locale.replace('_', '-');
  return {
    1: { ...UI_NOTIFICATIONS[1],
      title: t('notifications1Title'),
      description: t('notifications1Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[1].date))
    },
    3: { ...UI_NOTIFICATIONS[3],
      title: t('notifications3Title'),
      description: t('notifications3Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[3].date))
    },
    4: { ...UI_NOTIFICATIONS[4],
      title: t('notifications4Title'),
      description: t('notifications4Description'),
      actionText: t('notifications4ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[4].date))
    },
    5: { ...UI_NOTIFICATIONS[5],
      title: t('secretRecoveryPhrase'),
      description: t('notifications5Description'),
      actionText: t('notifications3ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[5].date))
    },
    6: { ...UI_NOTIFICATIONS[6],
      title: t('notifications6Title'),
      description: [t('notifications6DescriptionOne'), t('notifications6DescriptionTwo'), t('notifications6DescriptionThree')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[6].date))
    },
    7: { ...UI_NOTIFICATIONS[7],
      title: t('notifications7Title'),
      description: [t('notifications7DescriptionOne'), t('notifications7DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[7].date))
    },
    8: { ...UI_NOTIFICATIONS[8],
      title: t('notifications8Title'),
      description: [t('notifications8DescriptionOne'), t('notifications8DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[8].date)),
      actionText: t('notifications8ActionText')
    },
    9: { ...UI_NOTIFICATIONS[9],
      title: t('notifications9Title'),
      description: [t('notifications9DescriptionOne'), t('notifications9DescriptionTwo')],
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[9].date))
    },
    10: { ...UI_NOTIFICATIONS[10],
      title: t('notifications10Title'),
      description: [t('notifications10DescriptionOne'), t('notifications10DescriptionTwo'), t('notifications10DescriptionThree')],
      actionText: t('notifications10ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[10].date))
    },
    11: { ...UI_NOTIFICATIONS[11],
      title: t('notifications11Title'),
      description: t('notifications11Description'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[11].date))
    },
    12: { ...UI_NOTIFICATIONS[12],
      title: t('notifications12Title'),
      description: t('notifications12Description'),
      actionText: t('notifications12ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[12].date))
    },
    13: { ...UI_NOTIFICATIONS[13],
      title: t('notifications13Title'),
      description: t('notifications13Description'),
      actionText: t('notifications13ActionText'),
      date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[13].date))
    },
    14: { ...UI_NOTIFICATIONS[14],
      title: t('notifications14Title'),
      description: t('notifications14Description'),
      actionText: t('notifications14ActionText'),
      date: UI_NOTIFICATIONS[14].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[14].date)) : ''
    },
    15: { ...UI_NOTIFICATIONS[15],
      title: t('notifications15Title'),
      description: t('notifications15Description'),
      date: UI_NOTIFICATIONS[15].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[15].date)) : ''
    }
  };
};

exports.getTranslatedUINotifications = getTranslatedUINotifications;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\alerts\\enums.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\alerts\enums.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ALERT_STATE = void 0;
const ALERT_STATE = {
  CLOSED: 'CLOSED',
  ERROR: 'ERROR',
  LOADING: 'LOADING',
  OPEN: 'OPEN'
};
exports.ALERT_STATE = ALERT_STATE;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\alerts\\unconnected-account.js", {"../../../shared/constants/alerts":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\alerts.js","../../selectors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js","../../store/actionConstants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js","../../store/actions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js","./enums":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\alerts\\enums.js","@reduxjs/toolkit":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@reduxjs\\toolkit\\dist\\index.js","@sentry/browser":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@sentry\\browser\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\alerts\unconnected-account.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.switchedToUnconnectedAccount = exports.switchToAccount = exports.getAlertState = exports.dismissAndDisableAlert = exports.dismissAlert = exports.default = exports.connectAccount = exports.alertIsOpen = void 0;

var _toolkit = require("@reduxjs/toolkit");

var _browser = require("@sentry/browser");

var _alerts = require("../../../shared/constants/alerts");

var actionConstants = _interopRequireWildcard(require("../../store/actionConstants"));

var _actions = require("../../store/actions");

var _selectors = require("../../selectors");

var _enums = require("./enums");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Constants
const name = _alerts.ALERT_TYPES.unconnectedAccount;
const initialState = {
  state: _enums.ALERT_STATE.CLOSED
}; // Slice (reducer plus auto-generated actions and action creators)

const slice = (0, _toolkit.createSlice)({
  name,
  initialState,
  reducers: {
    connectAccountFailed: state => {
      state.state = _enums.ALERT_STATE.ERROR;
    },
    connectAccountRequested: state => {
      state.state = _enums.ALERT_STATE.LOADING;
    },
    connectAccountSucceeded: state => {
      state.state = _enums.ALERT_STATE.CLOSED;
    },
    disableAlertFailed: state => {
      state.state = _enums.ALERT_STATE.ERROR;
    },
    disableAlertRequested: state => {
      state.state = _enums.ALERT_STATE.LOADING;
    },
    disableAlertSucceeded: state => {
      state.state = _enums.ALERT_STATE.CLOSED;
    },
    dismissAlert: state => {
      state.state = _enums.ALERT_STATE.CLOSED;
    },
    switchAccountFailed: state => {
      state.state = _enums.ALERT_STATE.ERROR;
    },
    switchAccountRequested: state => {
      state.state = _enums.ALERT_STATE.LOADING;
    },
    switchAccountSucceeded: state => {
      state.state = _enums.ALERT_STATE.CLOSED;
    },
    switchedToUnconnectedAccount: state => {
      state.state = _enums.ALERT_STATE.OPEN;
    }
  },
  extraReducers: {
    [actionConstants.SELECTED_ADDRESS_CHANGED]: state => {
      // close the alert if the account is switched while it's open
      if (state.state === _enums.ALERT_STATE.OPEN) {
        state.state = _enums.ALERT_STATE.CLOSED;
      }
    }
  }
});
const {
  actions,
  reducer
} = slice;
var _default = reducer; // Selectors

exports.default = _default;

const getAlertState = state => state[name].state;

exports.getAlertState = getAlertState;

const alertIsOpen = state => state[name].state !== _enums.ALERT_STATE.CLOSED; // Actions / action-creators


exports.alertIsOpen = alertIsOpen;
const {
  connectAccountFailed,
  connectAccountRequested,
  connectAccountSucceeded,
  disableAlertFailed,
  disableAlertRequested,
  disableAlertSucceeded,
  dismissAlert,
  switchAccountFailed,
  switchAccountRequested,
  switchAccountSucceeded,
  switchedToUnconnectedAccount
} = actions;
exports.switchedToUnconnectedAccount = switchedToUnconnectedAccount;
exports.dismissAlert = dismissAlert;

const dismissAndDisableAlert = () => {
  return async dispatch => {
    try {
      await dispatch(disableAlertRequested());
      await (0, _actions.setAlertEnabledness)(name, false);
      await dispatch(disableAlertSucceeded());
    } catch (error) {
      console.error(error);
      (0, _browser.captureException)(error);
      await dispatch(disableAlertFailed());
    }
  };
};

exports.dismissAndDisableAlert = dismissAndDisableAlert;

const switchToAccount = address => {
  return async dispatch => {
    try {
      await dispatch(switchAccountRequested());
      await dispatch((0, _actions.setSelectedAddress)(address));
      await dispatch(switchAccountSucceeded());
    } catch (error) {
      console.error(error);
      (0, _browser.captureException)(error);
      await dispatch(switchAccountFailed());
    }
  };
};

exports.switchToAccount = switchToAccount;

const connectAccount = () => {
  return async (dispatch, getState) => {
    const state = getState();
    const selectedAddress = (0, _selectors.getSelectedAddress)(state);
    const origin = (0, _selectors.getOriginOfCurrentTab)(state);

    try {
      await dispatch(connectAccountRequested());
      await dispatch((0, _actions.addPermittedAccount)(origin, selectedAddress));
      await dispatch(connectAccountSucceeded());
    } catch (error) {
      console.error(error);
      (0, _browser.captureException)(error);
      await dispatch(connectAccountFailed());
    }
  };
};

exports.connectAccount = connectAccount;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\app\\app.js", {"../../../shared/constants/hardware-wallets":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js","../../store/actionConstants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\app\app.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reduceApp;
exports.getGasLoadingAnimationIsShowing = getGasLoadingAnimationIsShowing;
exports.getLedgerTransportStatus = getLedgerTransportStatus;
exports.getLedgerWebHidConnectedStatus = getLedgerWebHidConnectedStatus;
exports.getPortfolioTooltipWasShownInThisSession = getPortfolioTooltipWasShownInThisSession;
exports.getQrCodeData = getQrCodeData;
exports.hideWhatsNewPopup = hideWhatsNewPopup;
exports.setLedgerTransportStatus = setLedgerTransportStatus;
exports.setLedgerWebHidConnectedStatus = setLedgerWebHidConnectedStatus;
exports.setNewCustomNetworkAdded = setNewCustomNetworkAdded;
exports.setOnBoardedInThisUISession = setOnBoardedInThisUISession;
exports.setPortfolioTooltipWasShownInThisSession = setPortfolioTooltipWasShownInThisSession;
exports.toggleCurrencySwitch = toggleCurrencySwitch;
exports.toggleGasLoadingAnimation = toggleGasLoadingAnimation;

var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

var actionConstants = _interopRequireWildcard(require("../../store/actionConstants"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function reduceApp(state = {}, action) {
  // default state
  const appState = {
    shouldClose: false,
    menuOpen: false,
    modal: {
      open: false,
      modalState: {
        name: null,
        props: {}
      },
      previousModalState: {
        name: null
      }
    },
    alertOpen: false,
    alertMessage: null,
    qrCodeData: null,
    networkDropdownOpen: false,
    accountDetail: {
      subview: 'transactions'
    },
    // Used to display loading indicator
    isLoading: false,
    // Used to display error text
    warning: null,
    buyView: {},
    isMouseUser: false,
    defaultHdPaths: {
      trezor: `m/44'/60'/0'/0`,
      ledger: `m/44'/60'/0'/0/0`,
      lattice: `m/44'/60'/0'/0`
    },
    networksTabSelectedRpcUrl: '',
    loadingMethodData: false,
    requestAccountTabs: {},
    openMetaMaskTabs: {},
    currentWindowTab: {},
    showWhatsNewPopup: true,
    singleExceptions: {
      testKey: null
    },
    gasLoadingAnimationIsShowing: false,
    smartTransactionsError: null,
    smartTransactionsErrorMessageDismissed: false,
    ledgerWebHidConnectedStatus: _hardwareWallets.WEBHID_CONNECTED_STATUSES.UNKNOWN,
    ledgerTransportStatus: _hardwareWallets.TRANSPORT_STATES.NONE,
    newNetworkAdded: '',
    newCollectibleAddedMessage: '',
    portfolioTooltipWasShownInThisSession: false,
    sendInputCurrencySwitched: false,
    newTokensImported: '',
    newCustomNetworkAdded: {},
    onboardedInThisUISession: false,
    ...state
  };

  switch (action.type) {
    // dropdown methods
    case actionConstants.NETWORK_DROPDOWN_OPEN:
      return { ...appState,
        networkDropdownOpen: true
      };

    case actionConstants.NETWORK_DROPDOWN_CLOSE:
      return { ...appState,
        networkDropdownOpen: false
      };
    // alert methods

    case actionConstants.ALERT_OPEN:
      return { ...appState,
        alertOpen: true,
        alertMessage: action.value
      };

    case actionConstants.ALERT_CLOSE:
      return { ...appState,
        alertOpen: false,
        alertMessage: null
      };
    // qr scanner methods

    case actionConstants.QR_CODE_DETECTED:
      return { ...appState,
        qrCodeData: action.value
      };
    // Smart Transactions errors.

    case actionConstants.SET_SMART_TRANSACTIONS_ERROR:
      return { ...appState,
        smartTransactionsError: action.payload
      };

    case actionConstants.DISMISS_SMART_TRANSACTIONS_ERROR_MESSAGE:
      return { ...appState,
        smartTransactionsErrorMessageDismissed: true
      };
    // modal methods:

    case actionConstants.MODAL_OPEN:
      {
        const {
          name,
          ...modalProps
        } = action.payload;
        return { ...appState,
          modal: {
            open: true,
            modalState: {
              name,
              props: { ...modalProps
              }
            },
            previousModalState: { ...appState.modal.modalState
            }
          }
        };
      }

    case actionConstants.MODAL_CLOSE:
      return { ...appState,
        modal: Object.assign(appState.modal, {
          open: false
        }, {
          modalState: {
            name: null,
            props: {}
          }
        }, {
          previousModalState: appState.modal.modalState
        })
      };

    case actionConstants.CLEAR_ACCOUNT_DETAILS:
      return { ...appState,
        accountDetail: {}
      };

    case actionConstants.FORGOT_PASSWORD:
      return { ...appState,
        forgottenPassword: action.value
      };

    case actionConstants.SHOW_SEND_TOKEN_PAGE:
      return { ...appState,
        warning: null
      };

    case actionConstants.LOCK_METAMASK:
      return { ...appState,
        warning: null
      };
    // accounts

    case actionConstants.GO_HOME:
      return { ...appState,
        accountDetail: {
          subview: 'transactions',
          accountExport: 'none',
          privateKey: ''
        },
        warning: null
      };

    case actionConstants.SHOW_ACCOUNT_DETAIL:
      return { ...appState,
        forgottenPassword: appState.forgottenPassword ? !appState.forgottenPassword : null,
        accountDetail: {
          subview: 'transactions',
          accountExport: 'none',
          privateKey: ''
        }
      };

    case actionConstants.SHOW_ACCOUNTS_PAGE:
      return { ...appState,
        isLoading: false,
        warning: null,
        scrollToBottom: false,
        forgottenPassword: false
      };

    case actionConstants.SHOW_CONF_TX_PAGE:
      return { ...appState,
        txId: action.id,
        warning: null,
        isLoading: false
      };

    case actionConstants.COMPLETED_TX:
      if (action.value.unconfirmedActionsCount > 0) {
        return { ...appState,
          txId: null,
          warning: null
        };
      }

      return { ...appState,
        // indicate notification should close
        shouldClose: true,
        warning: null,
        txId: null,
        accountDetail: {
          subview: 'transactions'
        }
      };

    case actionConstants.TRANSACTION_ERROR:
      return { ...appState
      };

    case actionConstants.UNLOCK_FAILED:
      return { ...appState,
        warning: action.value || 'Incorrect password. Try again.'
      };

    case actionConstants.UNLOCK_SUCCEEDED:
      return { ...appState,
        warning: ''
      };

    case actionConstants.SET_HARDWARE_WALLET_DEFAULT_HD_PATH:
      {
        const {
          device,
          path
        } = action.value;
        const newDefaults = { ...appState.defaultHdPaths
        };
        newDefaults[device] = path;
        return { ...appState,
          defaultHdPaths: newDefaults
        };
      }

    case actionConstants.SHOW_LOADING:
      return { ...appState,
        isLoading: true,
        loadingMessage: action.value
      };

    case actionConstants.HIDE_LOADING:
      return { ...appState,
        isLoading: false
      };

    case actionConstants.DISPLAY_WARNING:
      return { ...appState,
        warning: action.value,
        isLoading: false
      };

    case actionConstants.HIDE_WARNING:
      return { ...appState,
        warning: undefined
      };

    case actionConstants.SHOW_PRIVATE_KEY:
      return { ...appState,
        accountDetail: {
          subview: 'export',
          accountExport: 'completed',
          privateKey: action.value
        }
      };

    case actionConstants.SET_MOUSE_USER_STATE:
      return { ...appState,
        isMouseUser: action.value
      };

    case actionConstants.SET_SELECTED_SETTINGS_RPC_URL:
      return { ...appState,
        networksTabSelectedRpcUrl: action.value
      };

    case actionConstants.SET_NEW_NETWORK_ADDED:
      return { ...appState,
        newNetworkAdded: action.value
      };

    case actionConstants.SET_NEW_TOKENS_IMPORTED:
      return { ...appState,
        newTokensImported: action.value
      };

    case actionConstants.SET_NEW_COLLECTIBLE_ADDED_MESSAGE:
      return { ...appState,
        newCollectibleAddedMessage: action.value
      };

    case actionConstants.PORTFOLIO_TOOLTIP_WAS_SHOWN_IN_THIS_SESSION:
      return { ...appState,
        portfolioTooltipWasShownInThisSession: true
      };

    case actionConstants.LOADING_METHOD_DATA_STARTED:
      return { ...appState,
        loadingMethodData: true
      };

    case actionConstants.LOADING_METHOD_DATA_FINISHED:
      return { ...appState,
        loadingMethodData: false
      };

    case actionConstants.SET_REQUEST_ACCOUNT_TABS:
      return { ...appState,
        requestAccountTabs: action.value
      };

    case actionConstants.SET_OPEN_METAMASK_TAB_IDS:
      return { ...appState,
        openMetaMaskTabs: action.value
      };

    case actionConstants.SET_CURRENT_WINDOW_TAB:
      return { ...appState,
        currentWindowTab: action.value
      };

    case actionConstants.HIDE_WHATS_NEW_POPUP:
      return { ...appState,
        showWhatsNewPopup: false
      };

    case actionConstants.CAPTURE_SINGLE_EXCEPTION:
      return { ...appState,
        singleExceptions: { ...appState.singleExceptions,
          [action.value]: null
        }
      };

    case actionConstants.TOGGLE_GAS_LOADING_ANIMATION:
      return { ...appState,
        gasLoadingAnimationIsShowing: action.value
      };

    case actionConstants.SET_WEBHID_CONNECTED_STATUS:
      return { ...appState,
        ledgerWebHidConnectedStatus: action.value
      };

    case actionConstants.SET_LEDGER_TRANSPORT_STATUS:
      return { ...appState,
        ledgerTransportStatus: action.value
      };

    case actionConstants.TOGGLE_CURRENCY_INPUT_SWITCH:
      return { ...appState,
        sendInputCurrencySwitched: !appState.sendInputCurrencySwitched
      };

    case actionConstants.SET_NEW_CUSTOM_NETWORK_ADDED:
      return { ...appState,
        newCustomNetworkAdded: action.value
      };

    case actionConstants.ONBOARDED_IN_THIS_UI_SESSION:
      return { ...appState,
        onboardedInThisUISession: action.value
      };

    default:
      return appState;
  }
} // Action Creators


function hideWhatsNewPopup() {
  return {
    type: actionConstants.HIDE_WHATS_NEW_POPUP
  };
}

function setPortfolioTooltipWasShownInThisSession() {
  return {
    type: actionConstants.PORTFOLIO_TOOLTIP_WAS_SHOWN_IN_THIS_SESSION
  };
}

function toggleGasLoadingAnimation(value) {
  return {
    type: actionConstants.TOGGLE_GAS_LOADING_ANIMATION,
    value
  };
}

function setLedgerWebHidConnectedStatus(value) {
  return {
    type: actionConstants.SET_WEBHID_CONNECTED_STATUS,
    value
  };
}

function setLedgerTransportStatus(value) {
  return {
    type: actionConstants.SET_LEDGER_TRANSPORT_STATUS,
    value
  };
} // Selectors


function getQrCodeData(state) {
  return state.appState.qrCodeData;
}

function getGasLoadingAnimationIsShowing(state) {
  return state.appState.gasLoadingAnimationIsShowing;
}

function getLedgerWebHidConnectedStatus(state) {
  return state.appState.ledgerWebHidConnectedStatus;
}

function getLedgerTransportStatus(state) {
  return state.appState.ledgerTransportStatus;
}

function getPortfolioTooltipWasShownInThisSession(state) {
  return state.appState.portfolioTooltipWasShownInThisSession;
}

function toggleCurrencySwitch() {
  return {
    type: actionConstants.TOGGLE_CURRENCY_INPUT_SWITCH
  };
}

function setNewCustomNetworkAdded(value) {
  return {
    type: actionConstants.SET_NEW_CUSTOM_NETWORK_ADDED,
    value
  };
}

function setOnBoardedInThisUISession(value) {
  return {
    type: actionConstants.ONBOARDED_IN_THIS_UI_SESSION,
    value
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\ens.js", {"../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","../../shared/modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","../helpers/utils/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js","../pages/send/send.constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js","../selectors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js","../store/actionConstants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js","@reduxjs/toolkit":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@reduxjs\\toolkit\\dist\\index.js","ethereum-ens-network-map":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-ens-network-map\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","ethers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\index.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js","unicode-confusables":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\unicode-confusables\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\ens.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ensInitialState = exports.default = void 0;
exports.getEnsError = getEnsError;
exports.getEnsResolution = getEnsResolution;
exports.getEnsWarning = getEnsWarning;
exports.initializeEnsSlice = initializeEnsSlice;
exports.lookupEnsName = lookupEnsName;
exports.resetEnsResolution = void 0;

var _toolkit = require("@reduxjs/toolkit");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _ethereumEnsNetworkMap = _interopRequireDefault(require("ethereum-ens-network-map"));

var _unicodeConfusables = require("unicode-confusables");

var _ethereumjsUtil = require("ethereumjs-util");

var _ethers = require("ethers");

var _selectors = require("../selectors");

var _network = require("../../shared/constants/network");

var _send = require("../pages/send/send.constants");

var _util = require("../helpers/utils/util");

var _actionConstants = require("../store/actionConstants");

var _hexstringUtils = require("../../shared/modules/hexstring-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Local Constants
const ZERO_X_ERROR_ADDRESS = '0x';
const initialState = {
  stage: 'UNINITIALIZED',
  resolution: null,
  error: null,
  warning: null,
  network: null
};
const ensInitialState = initialState;
exports.ensInitialState = ensInitialState;
const name = 'ENS';
let web3Provider = null;
const slice = (0, _toolkit.createSlice)({
  name,
  initialState,
  reducers: {
    ensLookup: (state, action) => {
      // first clear out the previous state
      state.resolution = null;
      state.error = null;
      state.warning = null;
      const {
        address,
        ensName,
        error,
        network
      } = action.payload;

      if (error) {
        if ((0, _util.isValidDomainName)(ensName) && error.message === 'ENS name not defined.') {
          state.error = network === _network.NETWORK_IDS.MAINNET ? _send.ENS_NO_ADDRESS_FOR_NAME : _send.ENS_NOT_FOUND_ON_NETWORK;
        } else if (error.message === 'Illegal character for ENS.') {
          state.error = _send.ENS_ILLEGAL_CHARACTER;
        } else {
          _loglevel.default.error(error);

          state.error = _send.ENS_UNKNOWN_ERROR;
        }
      } else if (address) {
        if (address === _hexstringUtils.BURN_ADDRESS) {
          state.error = _send.ENS_NO_ADDRESS_FOR_NAME;
        } else if (address === ZERO_X_ERROR_ADDRESS) {
          state.error = _send.ENS_REGISTRATION_ERROR;
        } else {
          state.resolution = address;
        }

        if ((0, _util.isValidDomainName)(address) && (0, _unicodeConfusables.isConfusing)(address)) {
          state.warning = _send.CONFUSING_ENS_ERROR;
        }
      } else {
        state.error = _send.ENS_NO_ADDRESS_FOR_NAME;
      }
    },
    enableEnsLookup: (state, action) => {
      state.stage = 'INITIALIZED';
      state.error = null;
      state.resolution = null;
      state.warning = null;
      state.network = action.payload;
    },
    disableEnsLookup: state => {
      state.stage = 'NO_NETWORK_SUPPORT';
      state.error = null;
      state.warning = null;
      state.resolution = null;
      state.network = null;
    },
    ensNotSupported: state => {
      state.resolution = null;
      state.warning = null;
      state.error = _send.ENS_NOT_SUPPORTED_ON_NETWORK;
    },
    resetEnsResolution: state => {
      state.resolution = null;
      state.warning = null;
      state.error = null;
    }
  },
  extraReducers: builder => {
    builder.addCase(_actionConstants.CHAIN_CHANGED, (state, action) => {
      if (action.payload !== state.currentChainId) {
        state.stage = 'UNINITIALIZED';
        web3Provider = null;
      }
    });
  }
});
const {
  reducer,
  actions
} = slice;
var _default = reducer;
exports.default = _default;
const {
  disableEnsLookup,
  ensLookup,
  enableEnsLookup,
  ensNotSupported,
  resetEnsResolution
} = actions;
exports.resetEnsResolution = resetEnsResolution;

function initializeEnsSlice() {
  return (dispatch, getState) => {
    const state = getState();
    const chainId = (0, _selectors.getCurrentChainId)(state);
    const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];
    const networkName = _network.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP[network];
    const ensAddress = _ethereumEnsNetworkMap.default[network];
    const networkIsSupported = Boolean(ensAddress);

    if (networkIsSupported) {
      web3Provider = new _ethers.ethers.providers.Web3Provider(global.ethereumProvider, {
        chainId: parseInt(network, 10),
        name: networkName,
        ensAddress
      });
      dispatch(enableEnsLookup(network));
    } else {
      web3Provider = null;
      dispatch(disableEnsLookup());
    }
  };
}

function lookupEnsName(ensName) {
  return async (dispatch, getState) => {
    const trimmedEnsName = ensName.trim();
    let state = getState();

    if (state[name].stage === 'UNINITIALIZED') {
      await dispatch(initializeEnsSlice());
    }

    state = getState();

    if (state[name].stage === 'NO_NETWORK_SUPPORT' && !((0, _hexstringUtils.isBurnAddress)(trimmedEnsName) === false && (0, _hexstringUtils.isValidHexAddress)(trimmedEnsName, {
      mixedCaseUseChecksum: true
    })) && !(0, _ethereumjsUtil.isHexString)(trimmedEnsName)) {
      await dispatch(ensNotSupported());
    } else {
      _loglevel.default.info(`ENS attempting to resolve name: ${trimmedEnsName}`);

      let address;
      let error;

      try {
        var _web3Provider$provide;

        // the writable property on the 'provider' object on the 'web3Provider' flips to false when stale
        // This helps handle the case where the provider is becomes unresponsive if/when, in MV3, the service worker dies after the ENS slice is instantiated
        const isProviderActive = (_web3Provider$provide = web3Provider.provider) === null || _web3Provider$provide === void 0 ? void 0 : _web3Provider$provide.writable;

        if (!isProviderActive) {
          await dispatch(initializeEnsSlice());
        }

        address = await web3Provider.resolveName(trimmedEnsName);
      } catch (err) {
        error = err;
      }

      const chainId = (0, _selectors.getCurrentChainId)(state);
      const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];
      await dispatch(ensLookup({
        ensName: trimmedEnsName,
        address,
        error,
        chainId,
        network
      }));
    }
  };
}

function getEnsResolution(state) {
  return state[name].resolution;
}

function getEnsError(state) {
  return state[name].error;
}

function getEnsWarning(state) {
  return state[name].warning;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas-action-constants.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\gas\gas-action-constants.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SET_CUSTOM_GAS_PRICE = exports.SET_CUSTOM_GAS_LIMIT = exports.RESET_CUSTOM_DATA = void 0;
// This file has been separated because it is required in both the gas and send
// slices. This created a circular dependency problem as both slices also
// import from the actions and selectors files. This easiest path for
// untangling is having the constants separate.
// Actions
const RESET_CUSTOM_DATA = 'metamask/gas/RESET_CUSTOM_DATA';
exports.RESET_CUSTOM_DATA = RESET_CUSTOM_DATA;
const SET_CUSTOM_GAS_LIMIT = 'metamask/gas/SET_CUSTOM_GAS_LIMIT';
exports.SET_CUSTOM_GAS_LIMIT = SET_CUSTOM_GAS_LIMIT;
const SET_CUSTOM_GAS_PRICE = 'metamask/gas/SET_CUSTOM_GAS_PRICE';
exports.SET_CUSTOM_GAS_PRICE = SET_CUSTOM_GAS_PRICE;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas.duck.js", {"./gas-action-constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas-action-constants.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\gas\gas.duck.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reducer;
exports.setCustomGasLimit = setCustomGasLimit;
exports.setCustomGasPrice = setCustomGasPrice;

var _lodash = require("lodash");

var _gasActionConstants = require("./gas-action-constants");

const initState = {
  customData: {
    price: null,
    limit: null
  }
}; // Reducer

function reducer(state = initState, action) {
  switch (action.type) {
    case _gasActionConstants.SET_CUSTOM_GAS_PRICE:
      return { ...state,
        customData: { ...state.customData,
          price: action.value
        }
      };

    case _gasActionConstants.SET_CUSTOM_GAS_LIMIT:
      return { ...state,
        customData: { ...state.customData,
          limit: action.value
        }
      };

    case _gasActionConstants.RESET_CUSTOM_DATA:
      return { ...state,
        customData: (0, _lodash.cloneDeep)(initState.customData)
      };

    default:
      return state;
  }
}

function setCustomGasPrice(newPrice) {
  return {
    type: _gasActionConstants.SET_CUSTOM_GAS_PRICE,
    value: newPrice
  };
}

function setCustomGasLimit(newLimit) {
  return {
    type: _gasActionConstants.SET_CUSTOM_GAS_LIMIT,
    value: newLimit
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\metamask\\metamask.js", {"../../../shared/constants/alerts":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\alerts.js","../../../shared/constants/gas":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js","../../../shared/constants/hardware-wallets":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js","../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","../../../shared/modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","../../../shared/modules/string-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js","../../helpers/utils/conversions.util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\conversions.util.js","../../selectors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js","../../store/actionConstants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js","../../store/actions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js","../gas/gas.duck":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas.duck.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\metamask\metamask.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = reduceMetamask;
exports.doesUserHaveALedgerAccount = doesUserHaveALedgerAccount;
exports.findKeyringForAddress = findKeyringForAddress;
exports.getAlertEnabledness = void 0;
exports.getBlockGasLimit = getBlockGasLimit;
exports.getCollectibles = exports.getCollectibleContracts = void 0;
exports.getCollectiblesDetectionNoticeDismissed = getCollectiblesDetectionNoticeDismissed;
exports.getCollectiblesDropdownState = getCollectiblesDropdownState;
exports.getCompletedOnboarding = getCompletedOnboarding;
exports.getConversionRate = getConversionRate;
exports.getCurrentLocale = void 0;
exports.getEnableEIP1559V2NoticeDismissed = getEnableEIP1559V2NoticeDismissed;
exports.getEstimatedGasFeeTimeBounds = getEstimatedGasFeeTimeBounds;
exports.getGasEstimateType = getGasEstimateType;
exports.getGasFeeEstimates = getGasFeeEstimates;
exports.getIsGasEstimatesLoading = getIsGasEstimatesLoading;
exports.getIsInitialized = getIsInitialized;
exports.getIsNetworkBusy = getIsNetworkBusy;
exports.getIsUnlocked = getIsUnlocked;
exports.getLedgerTransportType = getLedgerTransportType;
exports.getNativeCurrency = getNativeCurrency;
exports.getPendingTokens = void 0;
exports.getSeedPhraseBackedUp = getSeedPhraseBackedUp;
exports.getSendHexDataFeatureFlagState = getSendHexDataFeatureFlagState;
exports.getSendToAccounts = getSendToAccounts;
exports.getTokens = void 0;
exports.getUnapprovedTxs = getUnapprovedTxs;
exports.getWeb3ShimUsageAlertEnabledness = exports.getUnconnectedAccountAlertShown = exports.getUnconnectedAccountAlertEnabledness = void 0;
exports.isAddressLedger = isAddressLedger;
exports.isEIP1559Network = isEIP1559Network;
exports.isNotEIP1559Network = isNotEIP1559Network;
exports.updateGasFees = updateGasFees;

var _ethereumjsUtil = require("ethereumjs-util");

var actionConstants = _interopRequireWildcard(require("../../store/actionConstants"));

var _alerts = require("../../../shared/constants/alerts");

var _gas = require("../../../shared/constants/gas");

var _network = require("../../../shared/constants/network");

var _selectors = require("../../selectors");

var _actions = require("../../store/actions");

var _gas2 = require("../gas/gas.duck");

var _conversions = require("../../helpers/utils/conversions.util");

var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

var _stringUtils = require("../../../shared/modules/string-utils");

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function reduceMetamask(state = {}, action) {
  const metamaskState = {
    isInitialized: false,
    isUnlocked: false,
    isAccountMenuOpen: false,
    identities: {},
    unapprovedTxs: {},
    frequentRpcList: [],
    addressBook: [],
    contractExchangeRates: {},
    pendingTokens: {},
    customNonceValue: '',
    useBlockie: false,
    featureFlags: {},
    welcomeScreenSeen: false,
    currentLocale: '',
    currentBlockGasLimit: '',
    preferences: {
      autoLockTimeLimit: undefined,
      showFiatInTestnets: false,
      showTestNetworks: false,
      useNativeCurrencyAsPrimaryCurrency: true
    },
    firstTimeFlowType: null,
    completedOnboarding: false,
    knownMethodData: {},
    participateInMetaMetrics: null,
    nextNonce: null,
    conversionRate: null,
    nativeCurrency: 'ETH',
    ...state
  };

  switch (action.type) {
    case actionConstants.UPDATE_METAMASK_STATE:
      return { ...metamaskState,
        ...action.value
      };

    case actionConstants.LOCK_METAMASK:
      return { ...metamaskState,
        isUnlocked: false
      };

    case actionConstants.SET_RPC_TARGET:
      return { ...metamaskState,
        provider: {
          type: _network.NETWORK_TYPES.RPC,
          rpcUrl: action.value
        }
      };

    case actionConstants.SET_PROVIDER_TYPE:
      return { ...metamaskState,
        provider: {
          type: action.value
        }
      };

    case actionConstants.SHOW_ACCOUNT_DETAIL:
      return { ...metamaskState,
        isUnlocked: true,
        isInitialized: true,
        selectedAddress: action.value
      };

    case actionConstants.SET_ACCOUNT_LABEL:
      {
        const {
          account
        } = action.value;
        const name = action.value.label;
        const id = {};
        id[account] = { ...metamaskState.identities[account],
          name
        };
        const identities = { ...metamaskState.identities,
          ...id
        };
        return Object.assign(metamaskState, {
          identities
        });
      }

    case actionConstants.UPDATE_CUSTOM_NONCE:
      return { ...metamaskState,
        customNonceValue: action.value
      };

    case actionConstants.TOGGLE_ACCOUNT_MENU:
      return { ...metamaskState,
        isAccountMenuOpen: !metamaskState.isAccountMenuOpen
      };

    case actionConstants.UPDATE_TRANSACTION_PARAMS:
      {
        const {
          id: txId,
          value
        } = action;
        let {
          currentNetworkTxList
        } = metamaskState;
        currentNetworkTxList = currentNetworkTxList.map(tx => {
          if (tx.id === txId) {
            const newTx = { ...tx
            };
            newTx.txParams = value;
            return newTx;
          }

          return tx;
        });
        return { ...metamaskState,
          currentNetworkTxList
        };
      }

    case actionConstants.SET_PARTICIPATE_IN_METAMETRICS:
      return { ...metamaskState,
        participateInMetaMetrics: action.value
      };

    case actionConstants.SET_USE_BLOCKIE:
      return { ...metamaskState,
        useBlockie: action.value
      };

    case actionConstants.UPDATE_FEATURE_FLAGS:
      return { ...metamaskState,
        featureFlags: action.value
      };

    case actionConstants.CLOSE_WELCOME_SCREEN:
      return { ...metamaskState,
        welcomeScreenSeen: true
      };

    case actionConstants.SET_CURRENT_LOCALE:
      return { ...metamaskState,
        currentLocale: action.value.locale
      };

    case actionConstants.SET_PENDING_TOKENS:
      return { ...metamaskState,
        pendingTokens: { ...action.payload
        }
      };

    case actionConstants.CLEAR_PENDING_TOKENS:
      {
        return { ...metamaskState,
          pendingTokens: {}
        };
      }

    case actionConstants.UPDATE_PREFERENCES:
      {
        return { ...metamaskState,
          preferences: { ...metamaskState.preferences,
            ...action.payload
          }
        };
      }

    case actionConstants.COMPLETE_ONBOARDING:
      {
        return { ...metamaskState,
          completedOnboarding: true
        };
      }

    case actionConstants.SET_FIRST_TIME_FLOW_TYPE:
      {
        return { ...metamaskState,
          firstTimeFlowType: action.value
        };
      }

    case actionConstants.SET_NEXT_NONCE:
      {
        return { ...metamaskState,
          nextNonce: action.value
        };
      }

    default:
      return metamaskState;
  }
}

const toHexWei = (value, expectHexWei) => {
  return (0, _ethereumjsUtil.addHexPrefix)(expectHexWei ? value : (0, _conversions.decGWEIToHexWEI)(value));
}; // Action Creators


function updateGasFees({
  gasPrice,
  gasLimit,
  maxPriorityFeePerGas,
  maxFeePerGas,
  transaction,
  expectHexWei = false
}) {
  return async dispatch => {
    const txParamsCopy = { ...transaction.txParams,
      gas: gasLimit
    };

    if (gasPrice) {
      dispatch((0, _gas2.setCustomGasPrice)(toHexWei(txParamsCopy.gasPrice, expectHexWei)));
      txParamsCopy.gasPrice = toHexWei(gasPrice, expectHexWei);
    } else if (maxFeePerGas && maxPriorityFeePerGas) {
      txParamsCopy.maxFeePerGas = toHexWei(maxFeePerGas, expectHexWei);
      txParamsCopy.maxPriorityFeePerGas = (0, _ethereumjsUtil.addHexPrefix)((0, _conversions.decGWEIToHexWEI)(maxPriorityFeePerGas));
    }

    const updatedTx = { ...transaction,
      txParams: txParamsCopy
    };
    const customGasLimit = (0, _ethereumjsUtil.isHexString)((0, _ethereumjsUtil.addHexPrefix)(gasLimit)) ? (0, _ethereumjsUtil.addHexPrefix)(gasLimit) : (0, _ethereumjsUtil.addHexPrefix)(gasLimit.toString(16));
    dispatch((0, _gas2.setCustomGasLimit)(customGasLimit));
    await dispatch((0, _actions.updateTransactionGasFees)(updatedTx.id, updatedTx));
  };
} // Selectors


const getCurrentLocale = state => state.metamask.currentLocale;

exports.getCurrentLocale = getCurrentLocale;

const getAlertEnabledness = state => state.metamask.alertEnabledness;

exports.getAlertEnabledness = getAlertEnabledness;

const getUnconnectedAccountAlertEnabledness = state => getAlertEnabledness(state)[_alerts.ALERT_TYPES.unconnectedAccount];

exports.getUnconnectedAccountAlertEnabledness = getUnconnectedAccountAlertEnabledness;

const getWeb3ShimUsageAlertEnabledness = state => getAlertEnabledness(state)[_alerts.ALERT_TYPES.web3ShimUsage];

exports.getWeb3ShimUsageAlertEnabledness = getWeb3ShimUsageAlertEnabledness;

const getUnconnectedAccountAlertShown = state => state.metamask.unconnectedAccountAlertShownOrigins;

exports.getUnconnectedAccountAlertShown = getUnconnectedAccountAlertShown;

const getPendingTokens = state => state.metamask.pendingTokens;

exports.getPendingTokens = getPendingTokens;

const getTokens = state => state.metamask.tokens;

exports.getTokens = getTokens;

function getCollectiblesDetectionNoticeDismissed(state) {
  return state.metamask.collectiblesDetectionNoticeDismissed;
}

function getCollectiblesDropdownState(state) {
  return state.metamask.collectiblesDropdownState;
}

function getEnableEIP1559V2NoticeDismissed(state) {
  return state.metamask.enableEIP1559V2NoticeDismissed;
}

const getCollectibles = state => {
  var _allCollectibles$sele, _allCollectibles$sele2;

  const {
    metamask: {
      allCollectibles,
      provider: {
        chainId
      },
      selectedAddress
    }
  } = state;
  return (_allCollectibles$sele = allCollectibles === null || allCollectibles === void 0 ? void 0 : (_allCollectibles$sele2 = allCollectibles[selectedAddress]) === null || _allCollectibles$sele2 === void 0 ? void 0 : _allCollectibles$sele2[chainId]) !== null && _allCollectibles$sele !== void 0 ? _allCollectibles$sele : [];
};

exports.getCollectibles = getCollectibles;

const getCollectibleContracts = state => {
  var _allCollectibleContra, _allCollectibleContra2;

  const {
    metamask: {
      allCollectibleContracts,
      provider: {
        chainId
      },
      selectedAddress
    }
  } = state;
  return (_allCollectibleContra = allCollectibleContracts === null || allCollectibleContracts === void 0 ? void 0 : (_allCollectibleContra2 = allCollectibleContracts[selectedAddress]) === null || _allCollectibleContra2 === void 0 ? void 0 : _allCollectibleContra2[chainId]) !== null && _allCollectibleContra !== void 0 ? _allCollectibleContra : [];
};

exports.getCollectibleContracts = getCollectibleContracts;

function getBlockGasLimit(state) {
  return state.metamask.currentBlockGasLimit;
}

function getConversionRate(state) {
  return state.metamask.conversionRate;
}

function getNativeCurrency(state) {
  return state.metamask.nativeCurrency;
}

function getSendHexDataFeatureFlagState(state) {
  return state.metamask.featureFlags.sendHexData;
}

function getSendToAccounts(state) {
  const fromAccounts = (0, _selectors.accountsWithSendEtherInfoSelector)(state);
  const addressBookAccounts = (0, _selectors.getAddressBook)(state);
  return [...fromAccounts, ...addressBookAccounts];
}

function getUnapprovedTxs(state) {
  return state.metamask.unapprovedTxs;
}
/**
 * Function returns true if network details are fetched and it is found to not support EIP-1559
 *
 * @param state
 */


function isNotEIP1559Network(state) {
  var _state$metamask$netwo;

  return ((_state$metamask$netwo = state.metamask.networkDetails) === null || _state$metamask$netwo === void 0 ? void 0 : _state$metamask$netwo.EIPS[1559]) === false;
}
/**
 * Function returns true if network details are fetched and it is found to support EIP-1559
 *
 * @param state
 */


function isEIP1559Network(state) {
  var _state$metamask$netwo2;

  return ((_state$metamask$netwo2 = state.metamask.networkDetails) === null || _state$metamask$netwo2 === void 0 ? void 0 : _state$metamask$netwo2.EIPS[1559]) === true;
}

function getGasEstimateType(state) {
  return state.metamask.gasEstimateType;
}

function getGasFeeEstimates(state) {
  return state.metamask.gasFeeEstimates;
}

function getEstimatedGasFeeTimeBounds(state) {
  return state.metamask.estimatedGasFeeTimeBounds;
}

function getIsGasEstimatesLoading(state) {
  const networkAndAccountSupports1559 = (0, _selectors.checkNetworkAndAccountSupports1559)(state);
  const gasEstimateType = getGasEstimateType(state); // We consider the gas estimate to be loading if the gasEstimateType is
  // 'NONE' or if the current gasEstimateType cannot be supported by the current
  // network

  const isEIP1559TolerableEstimateType = gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET || gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE;
  const isGasEstimatesLoading = gasEstimateType === _gas.GAS_ESTIMATE_TYPES.NONE || networkAndAccountSupports1559 && !isEIP1559TolerableEstimateType || !networkAndAccountSupports1559 && gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET;
  return isGasEstimatesLoading;
}

function getIsNetworkBusy(state) {
  const gasFeeEstimates = getGasFeeEstimates(state);
  return (gasFeeEstimates === null || gasFeeEstimates === void 0 ? void 0 : gasFeeEstimates.networkCongestion) >= _gas.NETWORK_CONGESTION_THRESHOLDS.BUSY;
}

function getCompletedOnboarding(state) {
  return state.metamask.completedOnboarding;
}

function getIsInitialized(state) {
  return state.metamask.isInitialized;
}

function getIsUnlocked(state) {
  return state.metamask.isUnlocked;
}

function getSeedPhraseBackedUp(state) {
  return state.metamask.seedPhraseBackedUp;
}
/**
 * Given the redux state object and an address, finds a keyring that contains that address, if one exists
 *
 * @param {object} state - the redux state object
 * @param {string} address - the address to search for among the keyring addresses
 * @returns {object | undefined} The keyring which contains the passed address, or undefined
 */


function findKeyringForAddress(state, address) {
  const keyring = state.metamask.keyrings.find(kr => {
    return kr.accounts.some(account => {
      return (0, _stringUtils.isEqualCaseInsensitive)(account, (0, _ethereumjsUtil.addHexPrefix)(address)) || (0, _stringUtils.isEqualCaseInsensitive)(account, (0, _hexstringUtils.stripHexPrefix)(address));
    });
  });
  return keyring;
}
/**
 * Given the redux state object, returns the users preferred ledger transport type
 *
 * @param {object} state - the redux state object
 * @returns {string} The users preferred ledger transport type. One of'ledgerLive', 'webhid' or 'u2f'
 */


function getLedgerTransportType(state) {
  return state.metamask.ledgerTransportType;
}
/**
 * Given the redux state object and an address, returns a boolean indicating whether the passed address is part of a Ledger keyring
 *
 * @param {object} state - the redux state object
 * @param {string} address - the address to search for among all keyring addresses
 * @returns {boolean} true if the passed address is part of a ledger keyring, and false otherwise
 */


function isAddressLedger(state, address) {
  const keyring = findKeyringForAddress(state, address);
  return (keyring === null || keyring === void 0 ? void 0 : keyring.type) === _hardwareWallets.KEYRING_TYPES.LEDGER;
}
/**
 * Given the redux state object, returns a boolean indicating whether the user has any Ledger accounts added to MetaMask (i.e. Ledger keyrings
 * in state)
 *
 * @param {object} state - the redux state object
 * @returns {boolean} true if the user has a Ledger account and false otherwise
 */


function doesUserHaveALedgerAccount(state) {
  return state.metamask.keyrings.some(kr => {
    return kr.type === _hardwareWallets.KEYRING_TYPES.LEDGER;
  });
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\helpers.js", {"../../../shared/constants/gas":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js","../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../../../shared/lib/transactions-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js","../../../shared/modules/contract-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","../../helpers/constants/common":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js","../../pages/send/send.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.utils.js","../../selectors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js","../../store/actions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","human-standard-token-abi":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\human-standard-token-abi\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\send\helpers.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.estimateGasLimitForSend = estimateGasLimitForSend;
exports.generateTransactionParams = generateTransactionParams;
exports.getERC20Balance = getERC20Balance;
exports.getRoundedGasPrice = getRoundedGasPrice;

var _ethereumjsUtil = require("ethereumjs-util");

var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

var _gas = require("../../../shared/constants/gas");

var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

var _network = require("../../../shared/constants/network");

var _transaction = require("../../../shared/constants/transaction");

var _contractUtils = require("../../../shared/modules/contract-utils");

var _conversion = require("../../../shared/modules/conversion.utils");

var _common = require("../../helpers/constants/common");

var _send = require("../../pages/send/send.utils");

var _selectors = require("../../selectors");

var _actions = require("../../store/actions");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function estimateGasLimitForSend({
  selectedAddress,
  value,
  gasPrice,
  sendToken,
  to,
  data,
  isNonStandardEthChain,
  chainId,
  gasLimit,
  ...options
}) {
  let isSimpleSendOnNonStandardNetwork = false; // blockGasLimit may be a falsy, but defined, value when we receive it from
  // state, so we use logical or to fall back to MIN_GAS_LIMIT_HEX. Some
  // network implementations check the gas parameter supplied to
  // eth_estimateGas for validity. For this reason, we set token sends
  // blockGasLimit default to a higher number. Note that the current gasLimit
  // on a BLOCK is 15,000,000 and will be 30,000,000 on mainnet after London.
  // Meanwhile, MIN_GAS_LIMIT_HEX is 0x5208.

  let blockGasLimit = _gas.MIN_GAS_LIMIT_HEX;

  if (options.blockGasLimit) {
    blockGasLimit = options.blockGasLimit;
  } else if (sendToken) {
    blockGasLimit = _gas.GAS_LIMITS.BASE_TOKEN_ESTIMATE;
  } // The parameters below will be sent to our background process to estimate
  // how much gas will be used for a transaction. That background process is
  // located in tx-gas-utils.js in the transaction controller folder.


  const paramsForGasEstimate = {
    from: selectedAddress,
    value,
    gasPrice
  };

  if (sendToken) {
    if (!to) {
      // If no to address is provided, we cannot generate the token transfer
      // hexData. hexData in a transaction largely dictates how much gas will
      // be consumed by a transaction. We must use our best guess, which is
      // represented in the gas shared constants.
      return _gas.GAS_LIMITS.BASE_TOKEN_ESTIMATE;
    }

    paramsForGasEstimate.value = '0x0'; // We have to generate the erc20/erc721 contract call to transfer tokens in
    // order to get a proper estimate for gasLimit.

    paramsForGasEstimate.data = (0, _send.getAssetTransferData)({
      sendToken,
      fromAddress: selectedAddress,
      toAddress: to,
      amount: value
    });
    paramsForGasEstimate.to = sendToken.address;
  } else {
    if (!data) {
      // eth.getCode will return the compiled smart contract code at the
      // address. If this returns 0x, 0x0 or a nullish value then the address
      // is an externally owned account (NOT a contract account). For these
      // types of transactions the gasLimit will always be 21,000 or 0x5208
      const {
        isContractAddress
      } = to ? await (0, _contractUtils.readAddressAsContract)(global.eth, to) : {};

      if (!isContractAddress && !isNonStandardEthChain) {
        return _gas.GAS_LIMITS.SIMPLE;
      } else if (!isContractAddress && isNonStandardEthChain) {
        isSimpleSendOnNonStandardNetwork = true;
      }
    }

    paramsForGasEstimate.data = data;

    if (to) {
      paramsForGasEstimate.to = to;
    }

    if (!value || value === '0') {
      // TODO: Figure out what's going on here. According to eth_estimateGas
      // docs this value can be zero, or undefined, yet we are setting it to a
      // value here when the value is undefined or zero. For more context:
      // https://github.com/MetaMask/metamask-extension/pull/6195
      paramsForGasEstimate.value = '0xff';
    }
  }

  if (!isSimpleSendOnNonStandardNetwork) {
    // If we do not yet have a gasLimit, we must call into our background
    // process to get an estimate for gasLimit based on known parameters.
    paramsForGasEstimate.gas = (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(blockGasLimit, 0.95, {
      multiplicandBase: 16,
      multiplierBase: 10,
      roundDown: '0',
      toNumericBase: 'hex'
    }));
  } // The buffer multipler reduces transaction failures by ensuring that the
  // estimated gas is always sufficient. Without the multiplier, estimates
  // for contract interactions can become inaccurate over time. This is because
  // gas estimation is non-deterministic. The gas required for the exact same
  // transaction call can change based on state of a contract or changes in the
  // contracts environment (blockchain data or contracts it interacts with).
  // Applying the 1.5 buffer has proven to be a useful guard against this non-
  // deterministic behaviour.
  //
  // Gas estimation of simple sends should, however, be deterministic. As such
  // no buffer is needed in those cases.


  let bufferMultiplier = 1.5;

  if (isSimpleSendOnNonStandardNetwork) {
    bufferMultiplier = 1;
  } else if (_network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId]) {
    bufferMultiplier = _network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
  }

  try {
    // Call into the background process that will simulate transaction
    // execution on the node and return an estimate of gasLimit
    const estimatedGasLimit = await (0, _actions.estimateGas)(paramsForGasEstimate);
    const estimateWithBuffer = (0, _send.addGasBuffer)(estimatedGasLimit, blockGasLimit, bufferMultiplier);
    return (0, _ethereumjsUtil.addHexPrefix)(estimateWithBuffer);
  } catch (error) {
    const simulationFailed = error.message.includes('Transaction execution error.') || error.message.includes('gas required exceeds allowance or always failing transaction') || _network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId] && error.message.includes('gas required exceeds allowance');

    if (simulationFailed) {
      var _paramsForGasEstimate;

      const estimateWithBuffer = (0, _send.addGasBuffer)((_paramsForGasEstimate = paramsForGasEstimate === null || paramsForGasEstimate === void 0 ? void 0 : paramsForGasEstimate.gas) !== null && _paramsForGasEstimate !== void 0 ? _paramsForGasEstimate : gasLimit, blockGasLimit, bufferMultiplier);
      return (0, _ethereumjsUtil.addHexPrefix)(estimateWithBuffer);
    }

    throw error;
  }
}
/**
 * Generates a txParams from the send slice.
 *
 * @param {__import__('.').SendState} sendState - the state of the send slice
 * @returns {__import__(
 *  '../../../shared/constants/transaction'
 * ).TxParams} A txParams object that can be used to create a transaction or
 *  update an existing transaction.
 */


function generateTransactionParams(sendState) {
  var _draftTransaction$fro, _draftTransaction$fro2, _draftTransaction$fro3, _draftTransaction$use;

  const draftTransaction = sendState.draftTransactions[sendState.currentTransactionUUID];
  const txParams = {
    // If the fromAccount has been specified we use that, if not we use the
    // selected account.
    from: ((_draftTransaction$fro = draftTransaction.fromAccount) === null || _draftTransaction$fro === void 0 ? void 0 : _draftTransaction$fro.address) || sendState.selectedAccount.address,
    // gasLimit always needs to be set regardless of the asset being sent
    // or the type of transaction.
    gas: draftTransaction.gas.gasLimit
  };

  switch (draftTransaction.asset.type) {
    case _transaction.ASSET_TYPES.TOKEN:
      // When sending a token the to address is the contract address of
      // the token being sent. The value is set to '0x0' and the data
      // is generated from the recipient address, token being sent and
      // amount.
      txParams.to = draftTransaction.asset.details.address;
      txParams.value = '0x0';
      txParams.data = (0, _send.generateERC20TransferData)({
        toAddress: draftTransaction.recipient.address,
        amount: draftTransaction.amount.value,
        sendToken: draftTransaction.asset.details
      });
      break;

    case _transaction.ASSET_TYPES.COLLECTIBLE:
      // When sending a token the to address is the contract address of
      // the token being sent. The value is set to '0x0' and the data
      // is generated from the recipient address, token being sent and
      // amount.
      txParams.to = draftTransaction.asset.details.address;
      txParams.value = '0x0';
      txParams.data = (0, _send.generateERC721TransferData)({
        toAddress: draftTransaction.recipient.address,
        fromAddress: (_draftTransaction$fro2 = (_draftTransaction$fro3 = draftTransaction.fromAccount) === null || _draftTransaction$fro3 === void 0 ? void 0 : _draftTransaction$fro3.address) !== null && _draftTransaction$fro2 !== void 0 ? _draftTransaction$fro2 : sendState.selectedAccount.address,
        tokenId: draftTransaction.asset.details.tokenId
      });
      break;

    case _transaction.ASSET_TYPES.NATIVE:
    default:
      // When sending native currency the to and value fields use the
      // recipient and amount values and the data key is either null or
      // populated with the user input provided in hex field.
      txParams.to = draftTransaction.recipient.address;
      txParams.value = draftTransaction.amount.value;
      txParams.data = (_draftTransaction$use = draftTransaction.userInputHexData) !== null && _draftTransaction$use !== void 0 ? _draftTransaction$use : undefined;
  } // We need to make sure that we only include the right gas fee fields
  // based on the type of transaction the network supports. We will also set
  // the type param here.


  if (sendState.eip1559support) {
    txParams.type = _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
    txParams.maxFeePerGas = draftTransaction.gas.maxFeePerGas;
    txParams.maxPriorityFeePerGas = draftTransaction.gas.maxPriorityFeePerGas;

    if (!txParams.maxFeePerGas || txParams.maxFeePerGas === '0x0') {
      txParams.maxFeePerGas = draftTransaction.gas.gasPrice;
    }

    if (!txParams.maxPriorityFeePerGas || txParams.maxPriorityFeePerGas === '0x0') {
      txParams.maxPriorityFeePerGas = txParams.maxFeePerGas;
    }
  } else {
    txParams.gasPrice = draftTransaction.gas.gasPrice;
    txParams.type = _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
  }

  return txParams;
}
/**
 * This method is used to keep the original logic from the gas.duck.js file
 * after receiving a gasPrice from eth_gasPrice. First, the returned gasPrice
 * was converted to GWEI, then it was converted to a Number, then in the send
 * duck (here) we would use getGasPriceInHexWei to get back to hexWei. Now that
 * we receive a GWEI estimate from the controller, we still need to do this
 * weird conversion to get the proper rounding.
 *
 * @param {string} gasPriceEstimate
 * @returns {string}
 */


function getRoundedGasPrice(gasPriceEstimate) {
  const gasPriceInDecGwei = (0, _conversion.conversionUtil)(gasPriceEstimate, {
    numberOfDecimals: 9,
    toDenomination: _common.GWEI,
    fromNumericBase: 'dec',
    toNumericBase: 'dec',
    fromCurrency: _common.ETH,
    fromDenomination: _common.GWEI
  });
  const gasPriceAsNumber = Number(gasPriceInDecGwei);
  return (0, _selectors.getGasPriceInHexWei)(gasPriceAsNumber);
}

async function getERC20Balance(token, accountAddress) {
  var _await$contract$balan;

  const contract = global.eth.contract(_humanStandardTokenAbi.default).at(token.address);
  const usersToken = (_await$contract$balan = await contract.balanceOf(accountAddress)) !== null && _await$contract$balan !== void 0 ? _await$contract$balan : null;

  if (!usersToken) {
    return '0x0';
  }

  const amount = (0, _transactionsControllerUtils.calcTokenAmount)(usersToken.balance.toString(), token.decimals).toString(16);
  return (0, _ethereumjsUtil.addHexPrefix)(amount);
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\index.js", {"./send":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\send.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\send\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _send = require("./send");

Object.keys(_send).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (key in exports && exports[key] === _send[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _send[key];
    }
  });
});

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\send.js", {"../../../shared/constants/gas":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js","../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../../../shared/lib/metamask-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\metamask-controller-utils.js","../../../shared/lib/transactions-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","../../../shared/modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","../../../shared/modules/string-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js","../../../shared/modules/transaction.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js","../../helpers/constants/common":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js","../../helpers/constants/error-keys":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\error-keys.js","../../helpers/utils/confirm-tx.util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js","../../helpers/utils/optimism/fetchEstimatedL1Fee":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js","../../helpers/utils/token-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\token-util.js","../../helpers/utils/transactions.util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\transactions.util.js","../../helpers/utils/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js","../../pages/send/send.constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js","../../pages/send/send.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.utils.js","../../selectors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js","../../store/actionConstants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js","../../store/actions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js","../ens":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\ens.js","../gas/gas.duck":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas.duck.js","../metamask/metamask":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\metamask\\metamask.js","./helpers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\helpers.js","@reduxjs/toolkit":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@reduxjs\\toolkit\\dist\\index.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js","uuid":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\send\send.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.draftTransactionInitialState = exports.default = exports.computeEstimatedGasLimit = exports.addHistoryEntry = exports.acknowledgeRecipientWarning = exports.SEND_STATUSES = exports.SEND_STAGES = exports.RECIPIENT_SEARCH_MODES = exports.GAS_INPUT_MODES = exports.AMOUNT_MODES = void 0;
exports.editExistingTransaction = editExistingTransaction;
exports.gasFeeIsInError = gasFeeIsInError;
exports.getAssetError = getAssetError;
exports.getCurrentDraftTransaction = getCurrentDraftTransaction;
exports.getCurrentTransactionUUID = getCurrentTransactionUUID;
exports.getDraftTransactionExists = getDraftTransactionExists;
exports.getDraftTransactionID = getDraftTransactionID;
exports.getGasInputMode = getGasInputMode;
exports.getGasLimit = getGasLimit;
exports.getGasPrice = getGasPrice;
exports.getGasTotal = getGasTotal;
exports.getIsAssetSendable = getIsAssetSendable;
exports.getIsBalanceInsufficient = getIsBalanceInsufficient;
exports.getIsUsingMyAccountForRecipientSearch = getIsUsingMyAccountForRecipientSearch;
exports.getMinimumGasLimitForSend = getMinimumGasLimitForSend;
exports.getRecipient = getRecipient;
exports.getRecipientUserInput = getRecipientUserInput;
exports.getRecipientWarningAcknowledgement = getRecipientWarningAcknowledgement;
exports.getSendAmount = getSendAmount;
exports.getSendAsset = getSendAsset;
exports.getSendAssetAddress = getSendAssetAddress;
exports.getSendErrors = getSendErrors;
exports.getSendHexData = getSendHexData;
exports.getSendMaxModeState = getSendMaxModeState;
exports.getSendStage = getSendStage;
exports.getSendTo = getSendTo;
exports.initializeSendState = exports.initialState = void 0;
exports.isSendFormInvalid = isSendFormInvalid;
exports.isSendStateInitialized = isSendStateInitialized;
exports.resetRecipientInput = resetRecipientInput;
exports.resetSendState = resetSendState;
exports.sendAmountIsInError = sendAmountIsInError;
exports.signTransaction = signTransaction;
exports.startNewDraftTransaction = startNewDraftTransaction;
exports.toggleSendMaxMode = toggleSendMaxMode;
exports.updateGasLimit = void 0;
exports.updateGasPrice = updateGasPrice;
exports.updateRecipient = updateRecipient;
exports.updateRecipientUserInput = updateRecipientUserInput;
exports.updateSendAmount = updateSendAmount;
exports.updateSendAsset = updateSendAsset;
exports.updateSendHexData = updateSendHexData;
exports.useContactListForRecipientSearch = useContactListForRecipientSearch;
exports.useDefaultGas = exports.useCustomGas = void 0;
exports.useMyAccountsForRecipientSearch = useMyAccountsForRecipientSearch;

var _toolkit = require("@reduxjs/toolkit");

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _ethereumjsUtil = require("ethereumjs-util");

var _lodash = require("lodash");

var _uuid = require("uuid");

var _conversion = require("../../../shared/modules/conversion.utils");

var _gas = require("../../../shared/constants/gas");

var _send = require("../../pages/send/send.constants");

var _send2 = require("../../pages/send/send.utils");

var _selectors = require("../../selectors");

var _actions = require("../../store/actions");

var _gas2 = require("../gas/gas.duck");

var _actionConstants = require("../../store/actionConstants");

var _tokenUtil = require("../../helpers/utils/token-util");

var _util = require("../../helpers/utils/util");

var _metamask = require("../metamask/metamask");

var _ens = require("../ens");

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

var _transactions = require("../../helpers/utils/transactions.util");

var _fetchEstimatedL1Fee = _interopRequireDefault(require("../../helpers/utils/optimism/fetchEstimatedL1Fee"));

var _common = require("../../helpers/constants/common");

var _transaction = require("../../../shared/constants/transaction");

var _errorKeys = require("../../helpers/constants/error-keys");

var _stringUtils = require("../../../shared/modules/string-utils");

var _confirmTx = require("../../helpers/utils/confirm-tx.util");

var _transaction2 = require("../../../shared/modules/transaction.utils");

var _metamaskControllerUtils = require("../../../shared/lib/metamask-controller-utils");

var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

var _helpers = require("./helpers");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// typedef import statements

/**
 * @typedef {(
 *  __import__('immer/dist/internal').WritableDraft<SendState>
 * )} SendStateDraft
 * @typedef {(
 *  __import__('../../../shared/constants/transaction').AssetTypesString
 * )} AssetTypesString
 * @typedef {(
 *  __import__( '../../helpers/constants/common').TokenStandardStrings
 * )} TokenStandardStrings
 * @typedef {(
 *  __import__( '../../../shared/constants/tokens').TokenDetails
 * )} TokenDetails
 * @typedef {(
 *  __import__('../../../shared/constants/transaction').TransactionTypeString
 * )} TransactionTypeString
 * @typedef {(
 *  __import__('@metamask/controllers').LegacyGasPriceEstimate
 * )} LegacyGasPriceEstimate
 * @typedef {(
 *  __import__('@metamask/controllers').GasFeeEstimates
 * )} GasFeeEstimates
 * @typedef {(
 *  __import__('@metamask/controllers').EthGasPriceEstimate
 * )} EthGasPriceEstimate
 * @typedef {(
 *  __import__('@metamask/controllers').GasEstimateType
 * )} GasEstimateType
 * @typedef {(
 *  __import__('redux').AnyAction
 * )} AnyAction
 */

/**
 * @template R - Return type of the async function
 * @typedef {(
 *  __import__('redux-thunk').ThunkAction<R, MetaMaskState, unknown, AnyAction>
 * )} ThunkAction<R>
 */

/**
 * This type will take a typical constant string mapped object and turn it into
 * a union type of the values.
 *
 * @template O - The object to make strings out of
 * @typedef {O[keyof O]} MapValuesToUnion<O>
 */

/**
 * @typedef {object} SendStateStages
 * @property {'ADD_RECIPIENT'} ADD_RECIPIENT - The user is selecting which
 *  address to send an asset to.
 * @property {'DRAFT'} DRAFT - The send form is shown for a transaction yet to
 *  be sent to the Transaction Controller.
 * @property {'EDIT'} EDIT - The send form is shown for a transaction already
 *  submitted to the Transaction Controller but not yet confirmed. This happens
 *  when a confirmation is shown for a transaction and the 'edit' button in the
 *  header is clicked.
 * @property {'INACTIVE'} INACTIVE - The send state is idle, and hasn't yet
 *  fetched required data for gasPrice and gasLimit estimations, etc.
 */

/**
 * The Stages that the send slice can be in
 *
 * @type {SendStateStages}
 */
const SEND_STAGES = {
  ADD_RECIPIENT: 'ADD_RECIPIENT',
  DRAFT: 'DRAFT',
  EDIT: 'EDIT',
  INACTIVE: 'INACTIVE'
};
/**
 * @typedef {object} DraftTxStatus
 * @property {'INVALID'} INVALID - The transaction is invalid and cannot be
 *  submitted. There are a number of cases that would result in an invalid
 *  send state:
 *  1. The recipient is not yet defined
 *  2. The amount + gasTotal is greater than the user's balance when sending
 *     native currency
 *  3. The gasTotal is greater than the user's *native* balance
 *  4. The amount of sent asset is greater than the user's *asset* balance
 *  5. Gas price estimates failed to load entirely
 *  6. The gasLimit is less than 21000 (0x5208)
 * @property {'VALID'} VALID - The transaction is valid and can be submitted.
 */

/**
 * The status of the send slice
 *
 * @type {DraftTxStatus}
 */

exports.SEND_STAGES = SEND_STAGES;
const SEND_STATUSES = {
  INVALID: 'INVALID',
  VALID: 'VALID'
};
/**
 * @typedef {object} SendStateGasModes
 * @property {'BASIC'} BASIC - Shows the basic estimate slow/avg/fast buttons
 *  when on mainnet and the metaswaps API request is successful.
 * @property {'CUSTOM'} CUSTOM - Shows GasFeeDisplay component that is a read
 *  only display of the values the user has set in the advanced gas modal
 *  (stored in the gas duck under the customData key).
 * @property {'INLINE'} INLINE - Shows inline gasLimit/gasPrice fields when on
 *  any other network or metaswaps API fails and we use eth_gasPrice.
 */

/**
 * Controls what is displayed in the send-gas-row component.
 *
 * @type {SendStateGasModes}
 */

exports.SEND_STATUSES = SEND_STATUSES;
const GAS_INPUT_MODES = {
  BASIC: 'BASIC',
  CUSTOM: 'CUSTOM',
  INLINE: 'INLINE'
};
/**
 * @typedef {object} SendStateAmountModes
 * @property {'INPUT'} INPUT - the user provides the amount by typing in the
 *  field.
 * @property {'MAX'} MAX - The user selects the MAX button and amount is
 *  calculated based on balance - (amount + gasTotal).
 */

/**
 * The modes that the amount field can be set by
 *
 * @type {SendStateAmountModes}
 */

exports.GAS_INPUT_MODES = GAS_INPUT_MODES;
const AMOUNT_MODES = {
  INPUT: 'INPUT',
  MAX: 'MAX'
};
/**
 * @typedef {object} SendStateRecipientModes
 * @property {'CONTACT_LIST'} CONTACT_LIST - The user is displayed a list of
 *  their contacts and addresses they have recently send to.
 * @property {'MY_ACCOUNTS'} MY_ACCOUNTS - the user is displayed a list of
 *  their own accounts to send to.
 */

/**
 * The type of recipient list that is displayed to user
 *
 * @type {SendStateRecipientModes}
 */

exports.AMOUNT_MODES = AMOUNT_MODES;
const RECIPIENT_SEARCH_MODES = {
  CONTACT_LIST: 'CONTACT_LIST',
  MY_ACCOUNTS: 'MY_ACCOUNTS'
};
/**
 * @typedef {object} Account
 * @property {string} address - The hex address of the account.
 * @property {string} balance - Hex string representing the native asset
 *  balance of the account the transaction will be sent from.
 */

/**
 * @typedef {object} Amount
 * @property {string} [error] - Error to display for the amount field.
 * @property {string} value - A hex string representing the amount of the
 *  selected currency to send.
 */

/**
 * @typedef {object} Asset
 * @property {string} balance - A hex string representing the balance
 *  that the user holds of the asset that they are attempting to send.
 * @property {TokenDetails} [details] - An object that describes the
 *  selected asset in the case that the user is sending a token or collectibe.
 *  Will be null when asset.type is 'NATIVE'.
 * @property {string} [error] - Error to display when there is an issue
 *  with the asset.
 * @property {AssetTypesString} type - The type of asset that the user
 *  is attempting to send. Defaults to 'NATIVE' which represents the native
 *  asset of the chain. Can also be 'TOKEN' or 'COLLECTIBLE'.
 */

/**
 * @typedef {object} GasFees
 * @property {string} [error] - error to display for gas fields.
 * @property {string} gasLimit - maximum gas needed for tx.
 * @property {string} gasPrice - price in wei to pay per gas.
 * @property {string} gasTotal - maximum total price in wei to pay.
 * @property {string} maxFeePerGas - Maximum price in wei to pay per gas.
 * @property {string} maxPriorityFeePerGas - Maximum priority fee in wei to pay
 *  per gas.
 */

/**
 * An object that describes the intended recipient of a transaction.
 *
 * @typedef {object} Recipient
 * @property {string} address - The fully qualified address of the recipient.
 *  This is set after the recipient.userInput is validated, the userInput field
 *  is quickly updated to avoid delay between keystrokes and seeing the input
 *  field updated. After a debounce the address typed is validated and then the
 *  address field is updated. The address field is also set when the user
 *  selects a contact or account from the list, or an ENS resolution when
 *  typing ENS names.
 * @property {string} [error] - Error to display on the address field.
 * @property {string} nickname - The nickname that the user has added to their
 *  address book for the recipient.address.
 * @property {string} [warning] - Warning to display on the address field.
 */

/**
 * @typedef {object} DraftTransaction
 * @property {Amount} amount - An object containing information about the
 *  amount of currency to send.
 * @property {Asset} asset - An object that describes the asset that the user
 *  has selected to send.
 * @property {Account} [fromAccount] - The send flow is usually only relative to
 *  the currently selected account. When editing a transaction, however, the
 *  account may differ. In that case, the details of that account will be
 *  stored in this object within the draftTransaction.
 * @property {GasFees} gas - Details about the current gas settings
 * @property {Array<{event: string, timestamp: number}>} history - An array of
 *  entries that describe the user's journey through the send flow. This is
 *  sent to the controller for attaching to state logs for troubleshooting and
 *  support.
 * @property {string} [id] - If the transaction has already been added to the
 *  TransactionController this field will be populated with its id from the
 *  TransactionController state. This is required to be able to update the
 *  transaction in the controller.
 * @property {Recipient} recipient - An object that describes the intended
 *  recipient of the transaction.
 * @property {MapValuesToUnion<DraftTxStatus>} status - Describes the
 *  validity of the draft transaction, which will be either 'VALID' or
 *  'INVALID', depending on our ability to generate a valid txParams object for
 *  submission.
 * @property {string} transactionType - Determines type of transaction being
 *  sent, defaulted to 0x0 (legacy).
 * @property {string} [userInputHexData] - When a user has enabled custom hex
 *  data field in advanced options, they can supply data to the field which is
 *  stored under this key.
 */

/**
 * @type {DraftTransaction}
 */

exports.RECIPIENT_SEARCH_MODES = RECIPIENT_SEARCH_MODES;
const draftTransactionInitialState = {
  amount: {
    error: null,
    value: '0x0'
  },
  asset: {
    balance: '0x0',
    details: null,
    error: null,
    type: _transaction.ASSET_TYPES.NATIVE
  },
  fromAccount: null,
  gas: {
    error: null,
    gasLimit: '0x0',
    gasPrice: '0x0',
    gasTotal: '0x0',
    maxFeePerGas: '0x0',
    maxPriorityFeePerGas: '0x0',
    wasManuallyEdited: false
  },
  history: [],
  id: null,
  recipient: {
    address: '',
    error: null,
    nickname: '',
    warning: null,
    type: '',
    recipientWarningAcknowledged: false
  },
  status: SEND_STATUSES.VALID,
  transactionType: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
  userInputHexData: null
};
/**
 * Describes the state tree of the send slice
 *
 * @typedef {object} SendState
 * @property {MapValuesToUnion<SendStateAmountModes>} amountMode - Describe
 *  whether the user has manually input an amount or if they have selected max
 *  to send the maximum amount of the selected currency.
 * @property {string} currentTransactionUUID - The UUID of the transaction
 *  currently being modified by the send flow. This UUID is generated upon
 *  initialization of the send flow, any previous UUIDs are discarded at
 *  clean up AND during initialization. When a transaction is edited a new UUID
 *  is generated for it and the state of that transaction is copied into a new
 *  entry in the draftTransactions object.
 * @property {Object<string, DraftTransaction>} draftTransactions - An object keyed
 *  by UUID with draftTransactions as the values.
 * @property {boolean} eip1559support - tracks whether the current network
 *  supports EIP 1559 transactions.
 * @property {boolean} gasEstimateIsLoading - Indicates whether the gas
 *  estimate is loading.
 * @property {string} [gasEstimatePollToken] - String token identifying a
 *  listener for polling on the gasFeeController
 * @property {boolean} gasIsSetInModal - true if the user set custom gas in the
 *  custom gas modal
 * @property {string} gasLimitMinimum - minimum supported gasLimit.
 * @property {string} gasPriceEstimate - Expected price in wei necessary to
 *  pay per gas used for a transaction to be included in a reasonable timeframe.
 *  Comes from the GasFeeController.
 * @property {string} gasTotalForLayer1 -  Layer 1 gas fee total on multi-layer
 *  fee networks
 * @property {string} recipientInput - The user input of the recipient
 *  which is updated quickly to avoid delays in the UI reflecting manual entry
 *  of addresses.
 * @property {MapValuesToUnion<SendStateRecipientModes>} recipientMode -
 *  Describes which list of recipients the user is shown on the add recipient
 *  screen. When this key is set to 'MY_ACCOUNTS' the user is shown the list of
 *  accounts they own. When it is 'CONTACT_LIST' the user is shown the list of
 *  contacts they have saved in MetaMask and any addresses they have recently
 *  sent to.
 * @property {Account} selectedAccount - The currently selected account in
 *  MetaMask. Native balance and address will be pulled from this account if a
 *  fromAccount is not specified in the draftTransaction object. During an edit
 *  the fromAccount is specified.
 * @property {MapValuesToUnion<SendStateStages>} stage - The stage of the
 *  send flow that the user has progressed to. Defaults to 'INACTIVE' which
 *  results in the send screen not being shown.
 */

/**
 * @type {SendState}
 */

exports.draftTransactionInitialState = draftTransactionInitialState;
const initialState = {
  amountMode: AMOUNT_MODES.INPUT,
  currentTransactionUUID: null,
  draftTransactions: {},
  eip1559support: false,
  gasEstimateIsLoading: true,
  gasEstimatePollToken: null,
  gasIsSetInModal: false,
  gasPriceEstimate: '0x0',
  gasLimitMinimum: _gas.GAS_LIMITS.SIMPLE,
  gasTotalForLayer1: '0x0',
  recipientMode: RECIPIENT_SEARCH_MODES.CONTACT_LIST,
  recipientInput: '',
  selectedAccount: {
    address: null,
    balance: '0x0'
  },
  stage: SEND_STAGES.INACTIVE
};
/**
 * TODO: We really need to start creating the metamask state type, and the
 * entire state tree of redux. Would be *extremely* valuable in future
 * typescript conversions. The metamask key is typed as an object on purpose
 * here because I cannot go so far in this work as to type that entire object.
 *
 * @typedef {object} MetaMaskState
 * @property {SendState} send - The state of the send flow.
 * @property {object} metamask - The state of the metamask store.
 */

exports.initialState = initialState;
const name = 'send'; // After modification of specific fields in specific circumstances we must
// recompute the gasLimit estimate to be as accurate as possible. the cases
// that necessitate this logic are listed below:
// 1. when the amount sent changes when sending a token due to the amount being
//    part of the hex encoded data property of the transaction.
// 2. when updating the data property while sending NATIVE currency (ex: ETH)
//    because the data parameter defines function calls that the EVM will have
//    to execute which is where a large chunk of gas is potentially consumed.
// 3. when the recipient changes while sending a token due to the recipient's
//    address being included in the hex encoded data property of the
//    transaction
// 4. when the asset being sent changes due to the contract address and details
//    of the token being included in the hex encoded data property of the
//    transaction. If switching to NATIVE currency (ex: ETH), the gasLimit will
//    change due to hex data being removed (unless supplied by user).
// This method computes the gasLimit estimate which is written to state in an
// action handler in extraReducers.

const computeEstimatedGasLimit = (0, _toolkit.createAsyncThunk)('send/computeEstimatedGasLimit', async (_, thunkApi) => {
  var _transaction$dappSugg;

  const state = thunkApi.getState();
  const {
    send,
    metamask
  } = state;
  const draftTransaction = send.draftTransactions[send.currentTransactionUUID];
  const unapprovedTxs = (0, _metamask.getUnapprovedTxs)(state);
  const isMultiLayerFeeNetwork = (0, _selectors.getIsMultiLayerFeeNetwork)(state);
  const transaction = unapprovedTxs[draftTransaction.id];
  const isNonStandardEthChain = (0, _selectors.getIsNonStandardEthChain)(state);
  const chainId = (0, _selectors.getCurrentChainId)(state);
  let gasTotalForLayer1;

  if (isMultiLayerFeeNetwork) {
    var _draftTransaction$rec;

    gasTotalForLayer1 = await (0, _fetchEstimatedL1Fee.default)(global.eth, {
      txParams: {
        gasPrice: draftTransaction.gas.gasPrice,
        gas: draftTransaction.gas.gasLimit,
        to: (_draftTransaction$rec = draftTransaction.recipient.address) === null || _draftTransaction$rec === void 0 ? void 0 : _draftTransaction$rec.toLowerCase(),
        value: send.amountMode === AMOUNT_MODES.MAX ? send.selectedAccount.balance : draftTransaction.amount.value,
        from: send.selectedAccount.address,
        data: draftTransaction.userInputHexData,
        type: '0x0'
      }
    });
  }

  if (send.stage !== SEND_STAGES.EDIT || !((_transaction$dappSugg = transaction.dappSuggestedGasFees) !== null && _transaction$dappSugg !== void 0 && _transaction$dappSugg.gas) || !transaction.userEditedGasLimit) {
    var _draftTransaction$rec2;

    const gasLimit = await (0, _helpers.estimateGasLimitForSend)({
      gasPrice: draftTransaction.gas.gasPrice,
      blockGasLimit: metamask.currentBlockGasLimit,
      selectedAddress: metamask.selectedAddress,
      sendToken: draftTransaction.asset.details,
      to: (_draftTransaction$rec2 = draftTransaction.recipient.address) === null || _draftTransaction$rec2 === void 0 ? void 0 : _draftTransaction$rec2.toLowerCase(),
      value: draftTransaction.amount.value,
      data: draftTransaction.userInputHexData,
      isNonStandardEthChain,
      chainId,
      gasLimit: draftTransaction.gas.gasLimit
    });
    await thunkApi.dispatch((0, _gas2.setCustomGasLimit)(gasLimit));
    return {
      gasLimit,
      gasTotalForLayer1
    };
  }

  return null;
});
/**
 * @typedef {object} Asset
 * @property {AssetTypesString} type - The type of asset that the user
 *  is attempting to send. Defaults to 'NATIVE' which represents the native
 *  asset of the chain. Can also be 'TOKEN' or 'COLLECTIBLE'.
 * @property {string} balance - A hex string representing the balance
 *  that the user holds of the asset that they are attempting to send.
 * @property {TokenDetails} [details] - An object that describes the
 *  selected asset in the case that the user is sending a token or collectibe.
 *  Will be null when asset.type is 'NATIVE'.
 * @property {string} [error] - Error to display when there is an issue
 *  with the asset.
 */

/**
 * Responsible for initializing required state for the send slice.
 * This method is dispatched from the send page in the componentDidMount
 * method. It is also dispatched anytime the network changes to ensure that
 * the slice remains valid with changing token and account balances. To do so
 * it keys into state to get necessary values and computes a starting point for
 * the send slice. It returns the values that might change from this action and
 * those values are written to the slice in the `initializeSendState.fulfilled`
 * action handler.
 */

exports.computeEstimatedGasLimit = computeEstimatedGasLimit;
const initializeSendState = (0, _toolkit.createAsyncThunk)('send/initializeSendState', async ({
  chainHasChanged = false
} = {}, thunkApi) => {
  /**
   * @typedef {object} ReduxState
   * @property {object} metamask - Half baked type for the MetaMask object
   * @property {SendState} send - the send state
   */

  /**
   * @type {ReduxState}
   */
  const state = thunkApi.getState();
  const isNonStandardEthChain = (0, _selectors.getIsNonStandardEthChain)(state);
  const chainId = (0, _selectors.getCurrentChainId)(state);
  const eip1559support = (0, _selectors.checkNetworkAndAccountSupports1559)(state);
  const account = (0, _selectors.getSelectedAccount)(state);
  const {
    send: sendState,
    metamask
  } = state;
  const draftTransaction = sendState.draftTransactions[sendState.currentTransactionUUID]; // If the draft transaction is not present, then this action has been
  // dispatched out of sync with the intended flow. This is not always a bug.
  // For instance, in the actions.js file we dispatch this action anytime the
  // chain changes.

  if (!draftTransaction) {
    return thunkApi.rejectWithValue('draftTransaction not found, possibly not on send flow');
  } // Default gasPrice to 1 gwei if all estimation fails, this is only used
  // for gasLimit estimation and won't be set directly in state. Instead, we
  // will return the gasFeeEstimates and gasEstimateType so that the reducer
  // can set the appropriate gas fees in state.


  let gasPrice = sendState.stage === SEND_STAGES.EDIT ? draftTransaction.gas.gasPrice : '0x1';
  let gasEstimatePollToken = null; // Instruct the background process that polling for gas prices should begin

  gasEstimatePollToken = await (0, _actions.getGasFeeEstimatesAndStartPolling)();
  (0, _actions.addPollingTokenToAppState)(gasEstimatePollToken);
  const {
    metamask: {
      gasFeeEstimates,
      gasEstimateType
    }
  } = thunkApi.getState();

  if (sendState.stage !== SEND_STAGES.EDIT) {
    // Because we are only interested in getting a gasLimit estimation we only
    // need to worry about gasPrice. So we use maxFeePerGas as gasPrice if we
    // have a fee market estimation.
    if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.LEGACY) {
      gasPrice = (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium);
    } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
      gasPrice = (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice);
    } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET) {
      gasPrice = (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium.suggestedMaxFeePerGas);
    } else {
      gasPrice = gasFeeEstimates.gasPrice ? (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice) : '0x0';
    }
  } // Set a basic gasLimit in the event that other estimation fails


  let {
    gasLimit
  } = draftTransaction.gas;

  if (gasEstimateType !== _gas.GAS_ESTIMATE_TYPES.NONE && sendState.stage !== SEND_STAGES.EDIT && draftTransaction.recipient.address) {
    var _draftTransaction$fro, _draftTransaction$fro2;

    gasLimit = draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN || draftTransaction.asset.type === _transaction.ASSET_TYPES.COLLECTIBLE ? _gas.GAS_LIMITS.BASE_TOKEN_ESTIMATE : _gas.GAS_LIMITS.SIMPLE; // Run our estimateGasLimit logic to get a more accurate estimation of
    // required gas. If this value isn't nullish, set it as the new gasLimit

    const estimatedGasLimit = await (0, _helpers.estimateGasLimitForSend)({
      gasPrice,
      blockGasLimit: metamask.currentBlockGasLimit,
      selectedAddress: (_draftTransaction$fro = (_draftTransaction$fro2 = draftTransaction.fromAccount) === null || _draftTransaction$fro2 === void 0 ? void 0 : _draftTransaction$fro2.address) !== null && _draftTransaction$fro !== void 0 ? _draftTransaction$fro : sendState.selectedAccount.address,
      sendToken: draftTransaction.asset.details,
      to: draftTransaction.recipient.address.toLowerCase(),
      value: draftTransaction.amount.value,
      data: draftTransaction.userInputHexData,
      isNonStandardEthChain,
      chainId
    });
    gasLimit = estimatedGasLimit || gasLimit;
  } // We have to keep the gas slice in sync with the send slice state
  // so that it'll be initialized correctly if the gas modal is opened.


  await thunkApi.dispatch((0, _gas2.setCustomGasLimit)(gasLimit)); // There may be a case where the send has been canceled by the user while
  // the gas estimate is being computed. So we check again to make sure that
  // a currentTransactionUUID exists and matches the previous tx.

  const newState = thunkApi.getState();

  if (newState.send.currentTransactionUUID !== sendState.currentTransactionUUID) {
    return thunkApi.rejectWithValue(`draftTransaction changed during initialization.
        A new initializeSendState action must be dispatched.`);
  }

  return {
    account,
    chainId: (0, _selectors.getCurrentChainId)(state),
    tokens: (0, _metamask.getTokens)(state),
    chainHasChanged,
    gasFeeEstimates,
    gasEstimateType,
    gasLimit,
    gasTotal: (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcGasTotal)(gasLimit, gasPrice)),
    gasEstimatePollToken,
    eip1559support,
    useTokenDetection: (0, _selectors.getUseTokenDetection)(state),
    tokenAddressList: Object.keys((0, _selectors.getTokenList)(state))
  };
}); // Action Payload Typedefs

/**
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<string>
 * )} SimpleStringPayload
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<MapValuesToUnion<SendStateAmountModes>>
 * )} SendStateAmountModePayload
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<DraftTransaction['asset']>
 * )} UpdateAssetPayload
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<Partial<
 *   Pick<DraftTransaction['recipient'], 'address' | 'nickname'>>
 *  >
 * )} updateRecipientPayload
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<SendState['recipientMode']>
 * )} UpdateRecipientModePayload
 */

/**
 * @typedef {object} GasFeeUpdateParams
 * @property {TransactionTypeString} transactionType - The transaction type
 * @property {string} [maxFeePerGas] - The maximum amount in hex wei to pay
 *  per gas on a FEE_MARKET transaction.
 * @property {string} [maxPriorityFeePerGas] - The maximum amount in hex
 *  wei to pay per gas as an incentive to miners on a FEE_MARKET
 *  transaction.
 * @property {string} [gasPrice] - The amount in hex wei to pay per gas on
 *  a LEGACY transaction.
 * @property {boolean} [isAutomaticUpdate] - true if the update is the
 *  result of a gas estimate update from the controller.
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<GasFeeUpdateParams>
 * )} GasFeeUpdatePayload
 */

/**
 * @typedef {object} GasEstimateUpdateParams
 * @property {GasEstimateType} gasEstimateType - The type of gas estimation
 *  provided by the controller.
 * @property {(
 *  EthGasPriceEstimate | LegacyGasPriceEstimate | GasFeeEstimates
 * )} gasFeeEstimates - The gas fee estimates provided by the controller.
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<GasEstimateUpdateParams>
 * )} GasEstimateUpdatePayload
 */

/**
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<DraftTransaction['asset']>
 * )} UpdateAssetPayload
 * @typedef {(
 *  __import__('@reduxjs/toolkit').PayloadAction<DraftTransaction>
 * )} DraftTransactionPayload
 */

exports.initializeSendState = initializeSendState;
const slice = (0, _toolkit.createSlice)({
  name,
  initialState,
  reducers: {
    /**
     * Adds a new draft transaction to state, first generating a new UUID for
     * the transaction and setting that as the currentTransactionUUID. If the
     * draft has an id property set, the stage is set to EDIT.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {DraftTransactionPayload} action - An action with payload that is
     *  a new draft transaction that will be added to state.
     * @returns {void}
     */
    addNewDraft: (state, action) => {
      state.currentTransactionUUID = (0, _uuid.v4)();
      state.draftTransactions[state.currentTransactionUUID] = action.payload;

      if (action.payload.id) {
        state.stage = SEND_STAGES.EDIT;
      } else {
        state.stage = SEND_STAGES.ADD_RECIPIENT;
      }
    },

    /**
     * Adds an entry, with timestamp, to the draftTransaction history.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {SimpleStringPayload} action - An action with payload that is
     *  a string to be added to the history of the draftTransaction
     * @returns {void}
     */
    addHistoryEntry: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (draftTransaction) {
        draftTransaction.history.push({
          entry: action.payload,
          timestamp: Date.now()
        });
      }
    },

    /**
     * gasTotal is computed based on gasPrice and gasLimit and set in state
     * recomputes the maximum amount if the current amount mode is 'MAX' and
     * sending the native token. ERC20 assets max amount is unaffected by
     * gasTotal so does not need to be recomputed. Finally, validates the gas
     * field and send state.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    calculateGasTotal: state => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID]; // use maxFeePerGas as the multiplier if working with a FEE_MARKET transaction
      // otherwise use gasPrice

      if (draftTransaction.transactionType === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
        draftTransaction.gas.gasTotal = (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcGasTotal)(draftTransaction.gas.gasLimit, draftTransaction.gas.maxFeePerGas));
      } else {
        draftTransaction.gas.gasTotal = (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcGasTotal)(draftTransaction.gas.gasLimit, draftTransaction.gas.gasPrice));
      }

      if (state.amountMode === AMOUNT_MODES.MAX && draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
        slice.caseReducers.updateAmountToMax(state);
      }

      slice.caseReducers.validateAmountField(state);
      slice.caseReducers.validateGasField(state); // validate send state

      slice.caseReducers.validateSendState(state);
    },

    /**
     * Clears all drafts from send state and drops the currentTransactionUUID.
     * This is an important first step before adding a new draft transaction to
     * avoid possible collision.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    clearPreviousDrafts: state => {
      state.currentTransactionUUID = null;
      state.draftTransactions = {};
    },

    /**
     * Clears the send state by setting it to the initial value
     *
     * @returns {SendState}
     */
    resetSendState: () => initialState,

    /**
     * sets the amount mode to the provided value as long as it is one of the
     * supported modes (MAX|INPUT)
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {SendStateAmountModePayload} action - The amount mode
     *  to set the state to.
     * @returns {void}
     */
    updateAmountMode: (state, action) => {
      if (Object.values(AMOUNT_MODES).includes(action.payload)) {
        state.amountMode = action.payload;
      }
    },

    /**
     * computes the maximum amount of asset that can be sent and then calls
     * the updateSendAmount action above with the computed value, which will
     * revalidate the field and form.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    updateAmountToMax: state => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      let amount = '0x0';

      if (draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN) {
        var _draftTransaction$ass, _draftTransaction$ass2;

        const decimals = (_draftTransaction$ass = (_draftTransaction$ass2 = draftTransaction.asset.details) === null || _draftTransaction$ass2 === void 0 ? void 0 : _draftTransaction$ass2.decimals) !== null && _draftTransaction$ass !== void 0 ? _draftTransaction$ass : 0;
        const multiplier = Math.pow(10, Number(decimals));
        amount = (0, _conversion.multiplyCurrencies)(draftTransaction.asset.balance, multiplier, {
          toNumericBase: 'hex',
          multiplicandBase: 16,
          multiplierBase: 10
        });
      } else {
        const _gasTotal = (0, _transactions.sumHexes)(draftTransaction.gas.gasTotal || '0x0', state.gasTotalForLayer1 || '0x0');

        amount = (0, _conversion.subtractCurrencies)((0, _ethereumjsUtil.addHexPrefix)(draftTransaction.asset.balance), (0, _ethereumjsUtil.addHexPrefix)(_gasTotal), {
          toNumericBase: 'hex',
          aBase: 16,
          bBase: 16
        });
      }

      slice.caseReducers.updateSendAmount(state, {
        payload: amount
      });
    },

    /**
     * Updates the currently selected asset
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {UpdateAssetPayload} action - The asset to set in the
     *  draftTransaction.
     * @returns {void}
     */
    updateAsset: (state, action) => {
      const {
        asset,
        initialAssetSet
      } = action.payload;
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.asset.type = asset.type;
      draftTransaction.asset.balance = asset.balance;
      draftTransaction.asset.error = asset.error;

      if (draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN || draftTransaction.asset.type === _transaction.ASSET_TYPES.COLLECTIBLE) {
        draftTransaction.asset.details = asset.details;
      } else {
        // clear the details object when sending native currency
        draftTransaction.asset.details = null;

        if (draftTransaction.recipient.error === _send.CONTRACT_ADDRESS_ERROR) {
          // Errors related to sending tokens to their own contract address
          // are no longer valid when sending native currency.
          draftTransaction.recipient.error = null;
        }
      } // if amount mode is MAX update amount to max of new asset, otherwise set
      // to zero. This will revalidate the send amount field.


      if (state.amountMode === AMOUNT_MODES.MAX) {
        slice.caseReducers.updateAmountToMax(state);
      } else if (initialAssetSet === false) {
        slice.caseReducers.updateSendAmount(state, {
          payload: '0x0'
        });
      } // validate send state


      slice.caseReducers.validateSendState(state);
    },

    /**
     * Sets the appropriate gas fees in state after receiving new estimates.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {GasEstimateUpdatePayload)} action - The gas fee update payload
     * @returns {void}
     */
    updateGasFeeEstimates: (state, action) => {
      const {
        gasFeeEstimates,
        gasEstimateType
      } = action.payload;
      let gasPriceEstimate = '0x0';

      switch (gasEstimateType) {
        case _gas.GAS_ESTIMATE_TYPES.FEE_MARKET:
          slice.caseReducers.updateGasFees(state, {
            payload: {
              transactionType: _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET,
              maxFeePerGas: (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium.suggestedMaxFeePerGas),
              maxPriorityFeePerGas: (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium.suggestedMaxPriorityFeePerGas)
            }
          });
          break;

        case _gas.GAS_ESTIMATE_TYPES.LEGACY:
          gasPriceEstimate = (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.medium);
          slice.caseReducers.updateGasFees(state, {
            payload: {
              gasPrice: gasPriceEstimate,
              type: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
              isAutomaticUpdate: true
            }
          });
          break;

        case _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE:
          gasPriceEstimate = (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice);
          slice.caseReducers.updateGasFees(state, {
            payload: {
              gasPrice: (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice),
              type: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
              isAutomaticUpdate: true
            }
          });
          break;

        case _gas.GAS_ESTIMATE_TYPES.NONE:
        default:
          break;
      } // Record the latest gasPriceEstimate for future comparisons


      state.gasPriceEstimate = (0, _ethereumjsUtil.addHexPrefix)(gasPriceEstimate);
    },

    /**
     * Sets the appropriate gas fees in state and determines and sets the
     * appropriate transactionType based on gas fee fields received.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {GasFeeUpdatePayload} action - The gas fees to update with
     * @returns {void}
     */
    updateGasFees: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (draftTransaction) {
        if (action.payload.transactionType === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
          draftTransaction.gas.maxFeePerGas = (0, _ethereumjsUtil.addHexPrefix)(action.payload.maxFeePerGas);
          draftTransaction.gas.maxPriorityFeePerGas = (0, _ethereumjsUtil.addHexPrefix)(action.payload.maxPriorityFeePerGas);
          draftTransaction.transactionType = _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
        } else {
          if (action.payload.manuallyEdited) {
            draftTransaction.gas.wasManuallyEdited = true;
          } // Update the gas price if it has not been manually edited,
          // or if this current action is a manual edit.


          if (!draftTransaction.gas.wasManuallyEdited || action.payload.manuallyEdited) {
            draftTransaction.gas.gasPrice = (0, _ethereumjsUtil.addHexPrefix)(action.payload.gasPrice);
          }

          draftTransaction.transactionType = _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
        }

        slice.caseReducers.calculateGasTotal(state);
      }
    },

    /**
     * sets the provided gasLimit in state and then recomputes the gasTotal.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {SimpleStringPayload} action - The
     *  gasLimit in hex to set in state.
     * @returns {void}
     */
    updateGasLimit: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (draftTransaction) {
        draftTransaction.gas.gasLimit = (0, _ethereumjsUtil.addHexPrefix)(action.payload);
        slice.caseReducers.calculateGasTotal(state);
      }
    },

    /**
     * sets the layer 1 fees total (for a multi-layer fee network)
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {SimpleStringPayload} action - the
     *  gasTotalForLayer1 to set in hex wei.
     * @returns {void}
     */
    updateLayer1Fees: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      state.gasTotalForLayer1 = action.payload;

      if (state.amountMode === AMOUNT_MODES.MAX && draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
        slice.caseReducers.updateAmountToMax(state);
      }
    },

    /**
     * Updates the recipient of the draftTransaction
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {updateRecipientPayload} action - The recipient to set in the
     *  draftTransaction.
     * @returns {void}
     */
    updateRecipient: (state, action) => {
      var _action$payload$addre, _action$payload$nickn;

      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.recipient.error = null;
      state.recipientInput = '';
      draftTransaction.recipient.address = (_action$payload$addre = action.payload.address) !== null && _action$payload$addre !== void 0 ? _action$payload$addre : '';
      draftTransaction.recipient.nickname = (_action$payload$nickn = action.payload.nickname) !== null && _action$payload$nickn !== void 0 ? _action$payload$nickn : '';

      if (draftTransaction.recipient.address === '') {
        // If address is null we are clearing the recipient and must return
        // to the ADD_RECIPIENT stage.
        state.stage = SEND_STAGES.ADD_RECIPIENT;
      } else {
        // if an address is provided and an id exists, we progress to the EDIT
        // stage, otherwise we progress to the DRAFT stage. We also reset the
        // search mode for recipient search.
        state.stage = draftTransaction.id === null ? SEND_STAGES.DRAFT : SEND_STAGES.EDIT;
        state.recipientMode = RECIPIENT_SEARCH_MODES.CONTACT_LIST;
      } // validate send state


      slice.caseReducers.validateSendState(state);
    },

    /**
     * Clears the user input and changes the recipient search mode to the
     * specified value
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {UpdateRecipientModePayload} action - The mode to set the
     *  recipient search to
     * @returns {void}
     */
    updateRecipientSearchMode: (state, action) => {
      state.recipientInput = '';
      state.recipientMode = action.payload;
    },
    updateRecipientWarning: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.recipient.warning = action.payload;
    },
    updateRecipientType: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.recipient.type = action.payload;
    },
    updateDraftTransactionStatus: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.status = action.payload;
    },
    acknowledgeRecipientWarning: state => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.recipient.recipientWarningAcknowledged = true;
      slice.caseReducers.validateSendState(state);
    },

    /**
     * Updates the value of the recipientInput key with what the user has
     * typed into the recipient input field in the UI.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {SimpleStringPayload} action - the value the user has typed into
     *  the recipient field.
     * @returns {void}
     */
    updateRecipientUserInput: (state, action) => {
      // Update the value in state to match what the user is typing into the
      // input field
      state.recipientInput = action.payload;
    },

    /**
     * update current amount.value in state and run post update validation of
     * the amount field and the send state.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {SimpleStringPayload} action - The hex string to be set as the
     *  amount value.
     * @returns {void}
     */
    updateSendAmount: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.amount.value = (0, _ethereumjsUtil.addHexPrefix)(action.payload); // Once amount has changed, validate the field

      slice.caseReducers.validateAmountField(state);

      if (draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
        // if sending the native asset the amount being sent will impact the
        // gas field as well because the gas validation takes into
        // consideration the available balance minus amount sent before
        // checking if there is enough left to cover the gas fee.
        slice.caseReducers.validateGasField(state);
      } // validate send state


      slice.caseReducers.validateSendState(state);
    },

    /**
     * updates the userInputHexData state key
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @param {SimpleStringPayload} action - The hex string to be set as the
     *  userInputHexData value.
     * @returns {void}
     */
    updateUserInputHexData: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      draftTransaction.userInputHexData = action.payload;
    },

    /**
     * Updates the gasIsSetInModal property to true which results in showing
     * the gas fees from the custom gas modal in the send page.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    useCustomGas: state => {
      state.gasIsSetInModal = true;
    },

    /**
     * Updates the gasIsSetInModal property to false which results in showing
     * the default gas price/limit fields in the send page.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    useDefaultGas: state => {
      state.gasIsSetInModal = false;
    },

    /**
     * Checks for the validity of the draftTransactions selected amount to send
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    validateAmountField: state => {
      var _draftTransaction$gas, _draftTransaction$ass3;

      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      switch (true) {
        // set error to INSUFFICIENT_FUNDS_ERROR if the account balance is lower
        // than the total price of the transaction inclusive of gas fees.
        case draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE && !(0, _send2.isBalanceSufficient)({
          amount: draftTransaction.amount.value,
          balance: draftTransaction.asset.balance,
          gasTotal: (_draftTransaction$gas = draftTransaction.gas.gasTotal) !== null && _draftTransaction$gas !== void 0 ? _draftTransaction$gas : '0x0'
        }):
          draftTransaction.amount.error = _send.INSUFFICIENT_FUNDS_ERROR;
          break;
        // set error to INSUFFICIENT_FUNDS_ERROR if the token balance is lower
        // than the amount of token the user is attempting to send.

        case draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN && !(0, _send2.isTokenBalanceSufficient)({
          tokenBalance: (_draftTransaction$ass3 = draftTransaction.asset.balance) !== null && _draftTransaction$ass3 !== void 0 ? _draftTransaction$ass3 : '0x0',
          amount: draftTransaction.amount.value,
          decimals: draftTransaction.asset.details.decimals
        }):
          draftTransaction.amount.error = _send.INSUFFICIENT_TOKENS_ERROR;
          break;
        // if the amount is negative, set error to NEGATIVE_ETH_ERROR
        // TODO: change this to NEGATIVE_ERROR and remove the currency bias.

        case (0, _conversion.conversionGreaterThan)({
          value: 0,
          fromNumericBase: 'dec'
        }, {
          value: draftTransaction.amount.value,
          fromNumericBase: 'hex'
        }):
          draftTransaction.amount.error = _send.NEGATIVE_ETH_ERROR;
          break;
        // If none of the above are true, set error to null

        default:
          draftTransaction.amount.error = null;
      }
    },

    /**
     * Checks if the user has enough funds to cover the cost of gas, always
     * uses the native currency and does not take into account the amount
     * being sent. If the user has enough to cover cost of gas but not gas
     * + amount then the error will be displayed on the amount field.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    validateGasField: state => {
      var _draftTransaction$fro3, _draftTransaction$fro4, _draftTransaction$gas2;

      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
      const insufficientFunds = !(0, _send2.isBalanceSufficient)({
        amount: draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE ? draftTransaction.amount.value : '0x0',
        balance: (_draftTransaction$fro3 = (_draftTransaction$fro4 = draftTransaction.fromAccount) === null || _draftTransaction$fro4 === void 0 ? void 0 : _draftTransaction$fro4.balance) !== null && _draftTransaction$fro3 !== void 0 ? _draftTransaction$fro3 : state.selectedAccount.balance,
        gasTotal: (_draftTransaction$gas2 = draftTransaction.gas.gasTotal) !== null && _draftTransaction$gas2 !== void 0 ? _draftTransaction$gas2 : '0x0'
      });
      draftTransaction.gas.error = insufficientFunds ? _send.INSUFFICIENT_FUNDS_ERROR : null;
    },
    validateRecipientUserInput: (state, action) => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (draftTransaction) {
        if (state.recipientMode === RECIPIENT_SEARCH_MODES.MY_ACCOUNTS || state.recipientInput === '' || state.recipientInput === null) {
          draftTransaction.recipient.error = null;
          draftTransaction.recipient.warning = null;
        } else {
          var _draftTransaction$ass4, _draftTransaction$ass5;

          const {
            chainId,
            tokens,
            tokenAddressList,
            isProbablyAnAssetContract
          } = action.payload;

          if ((0, _hexstringUtils.isBurnAddress)(state.recipientInput) || !(0, _hexstringUtils.isValidHexAddress)(state.recipientInput, {
            mixedCaseUseChecksum: true
          }) && !(0, _util.isValidDomainName)(state.recipientInput)) {
            draftTransaction.recipient.error = (0, _util.isDefaultMetaMaskChain)(chainId) ? _send.INVALID_RECIPIENT_ADDRESS_ERROR : _send.INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR;
          } else if ((0, _util.isOriginContractAddress)(state.recipientInput, (_draftTransaction$ass4 = draftTransaction.asset) === null || _draftTransaction$ass4 === void 0 ? void 0 : (_draftTransaction$ass5 = _draftTransaction$ass4.details) === null || _draftTransaction$ass5 === void 0 ? void 0 : _draftTransaction$ass5.address)) {
            draftTransaction.recipient.error = _send.CONTRACT_ADDRESS_ERROR;
          } else {
            draftTransaction.recipient.error = null;
          }

          if ((0, _hexstringUtils.isValidHexAddress)(state.recipientInput) && (tokenAddressList.find(address => (0, _stringUtils.isEqualCaseInsensitive)(address, state.recipientInput)) || (0, _util.checkExistingAddresses)(state.recipientInput, tokens)) || isProbablyAnAssetContract) {
            draftTransaction.recipient.warning = _send.KNOWN_RECIPIENT_ADDRESS_WARNING;
          } else {
            draftTransaction.recipient.warning = null;
          }
        }
      }

      slice.caseReducers.validateSendState(state);
    },

    /**
     * Checks if the draftTransaction is currently valid. The following list of
     * cases from the switch statement in this function describe when the
     * transaction is invalid. Please keep this comment updated.
     *
     * case 1: State is invalid when amount field has an error.
     * case 2: State is invalid when gas field has an error.
     * case 3: State is invalid when asset field has an error.
     * case 4: State is invalid if asset type is a token and the token details
     *  are unknown.
     * case 5: State is invalid if no recipient has been added.
     * case 6: State is invalid if the send state is uninitialized.
     * case 7: State is invalid if gas estimates are loading.
     * case 8: State is invalid if gasLimit is less than the gasLimitMinimum.
     *
     * @param {SendStateDraft} state - A writable draft of the send state to be
     *  updated.
     * @returns {void}
     */
    validateSendState: state => {
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (draftTransaction) {
        switch (true) {
          case Boolean(draftTransaction.amount.error):
          case Boolean(draftTransaction.gas.error):
          case Boolean(draftTransaction.asset.error):
          case draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN && draftTransaction.asset.details === null:
          case state.stage === SEND_STAGES.ADD_RECIPIENT:
          case state.stage === SEND_STAGES.INACTIVE:
          case state.gasEstimateIsLoading:
          case new _bignumber.default(draftTransaction.gas.gasLimit, 16).lessThan(new _bignumber.default(state.gasLimitMinimum)):
            draftTransaction.status = SEND_STATUSES.INVALID;
            break;

          case draftTransaction.recipient.warning === 'loading':
          case draftTransaction.recipient.warning === _send.KNOWN_RECIPIENT_ADDRESS_WARNING && draftTransaction.recipient.recipientWarningAcknowledged === false:
            draftTransaction.status = SEND_STATUSES.INVALID;
            break;

          default:
            draftTransaction.status = SEND_STATUSES.VALID;
        }
      }
    }
  },
  extraReducers: builder => {
    builder.addCase(_actionConstants.ACCOUNT_CHANGED, (state, action) => {
      // This event occurs when the user's account details update due to
      // background state changes. If the account that is being updated is
      // the current from account on the edit flow we need to update
      // the balance for the account and revalidate the send state.
      if (state.stage === SEND_STAGES.EDIT && action.payload.account) {
        const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

        if (draftTransaction && draftTransaction.fromAccount && draftTransaction.fromAccount.address === action.payload.account.address) {
          draftTransaction.fromAccount.balance = action.payload.account.balance; // We need to update the asset balance if the asset is the native
          // network asset. Once we update the balance we recompute error state.

          if (draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
            draftTransaction.asset.balance = action.payload.account.balance;
          }

          slice.caseReducers.validateAmountField(state);
          slice.caseReducers.validateGasField(state);
          slice.caseReducers.validateSendState(state);
        }
      }
    }).addCase(_actionConstants.ADDRESS_BOOK_UPDATED, (state, action) => {
      var _addressBook$draftTra;

      // When the address book updates from background state changes we need
      // to check to see if an entry exists for the current address or if the
      // entry changed.
      const {
        addressBook
      } = action.payload;
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (draftTransaction && (_addressBook$draftTra = addressBook[draftTransaction.recipient.address]) !== null && _addressBook$draftTra !== void 0 && _addressBook$draftTra.name) {
        draftTransaction.recipient.nickname = addressBook[draftTransaction.recipient.address].name;
      }
    }).addCase(computeEstimatedGasLimit.pending, state => {
      // When we begin to fetch gasLimit we should indicate we are loading
      // a gas estimate.
      state.gasEstimateIsLoading = true;
    }).addCase(computeEstimatedGasLimit.fulfilled, (state, action) => {
      var _action$payload, _action$payload2;

      // When we receive a new gasLimit from the computeEstimatedGasLimit
      // thunk we need to update our gasLimit in the slice. We call into the
      // caseReducer updateGasLimit to tap into the appropriate follow up
      // checks and gasTotal calculation. First set gasEstimateIsLoading to
      // false.
      state.gasEstimateIsLoading = false;

      if ((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.gasLimit) {
        slice.caseReducers.updateGasLimit(state, {
          payload: action.payload.gasLimit
        });
      }

      if ((_action$payload2 = action.payload) !== null && _action$payload2 !== void 0 && _action$payload2.gasTotalForLayer1) {
        slice.caseReducers.updateLayer1Fees(state, {
          payload: action.payload.gasTotalForLayer1
        });
      }
    }).addCase(computeEstimatedGasLimit.rejected, state => {
      // If gas estimation fails, we should set the loading state to false,
      // because it is no longer loading
      state.gasEstimateIsLoading = false;
    }).addCase(_actionConstants.GAS_FEE_ESTIMATES_UPDATED, (state, action) => {
      // When the gasFeeController updates its gas fee estimates we need to
      // update and validate state based on those new values
      slice.caseReducers.updateGasFeeEstimates(state, {
        payload: action.payload
      });
    }).addCase(initializeSendState.pending, state => {
      // when we begin initializing state, which can happen when switching
      // chains even after loading the send flow, we set gasEstimateIsLoading
      // as initialization will trigger a fetch for gasPrice estimates.
      state.gasEstimateIsLoading = true;
    }).addCase(initializeSendState.fulfilled, (state, action) => {
      // writes the computed initialized state values into the slice and then
      // calculates slice validity using the caseReducers.
      state.eip1559support = action.payload.eip1559support;
      state.selectedAccount.address = action.payload.account.address;
      state.selectedAccount.balance = action.payload.account.balance;
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (draftTransaction) {
        draftTransaction.gas.gasLimit = action.payload.gasLimit;
        draftTransaction.gas.gasTotal = action.payload.gasTotal;

        if (action.payload.chainHasChanged) {
          var _draftTransaction$fro5, _draftTransaction$fro6;

          // If the state was reinitialized as a result of the user changing
          // the network from the network dropdown, then the selected asset is
          // no longer valid and should be set to the native asset for the
          // network.
          draftTransaction.asset.type = _transaction.ASSET_TYPES.NATIVE;
          draftTransaction.asset.balance = (_draftTransaction$fro5 = (_draftTransaction$fro6 = draftTransaction.fromAccount) === null || _draftTransaction$fro6 === void 0 ? void 0 : _draftTransaction$fro6.balance) !== null && _draftTransaction$fro5 !== void 0 ? _draftTransaction$fro5 : state.selectedAccount.balance;
          draftTransaction.asset.details = null;
        }
      }

      slice.caseReducers.updateGasFeeEstimates(state, {
        payload: {
          gasFeeEstimates: action.payload.gasFeeEstimates,
          gasEstimateType: action.payload.gasEstimateType
        }
      });
      state.gasEstimatePollToken = action.payload.gasEstimatePollToken;

      if (action.payload.gasEstimatePollToken) {
        state.gasEstimateIsLoading = false;
      }

      if (state.stage !== SEND_STAGES.INACTIVE) {
        slice.caseReducers.validateRecipientUserInput(state, {
          payload: {
            chainId: action.payload.chainId,
            tokens: action.payload.tokens,
            useTokenDetection: action.payload.useTokenDetection,
            tokenAddressList: action.payload.tokenAddressList
          }
        });
      }

      if (state.amountMode === AMOUNT_MODES.MAX) {
        slice.caseReducers.updateAmountToMax(state);
      }

      slice.caseReducers.validateAmountField(state);
      slice.caseReducers.validateGasField(state);
      slice.caseReducers.validateSendState(state);
    }).addCase(_actionConstants.SELECTED_ACCOUNT_CHANGED, (state, action) => {
      // This event occurs when the user selects a new account from the
      // account menu, or the currently active account's balance updates.
      // We only care about new transactions, not edits, here, because we use
      // the fromAccount and ACCOUNT_CHANGED action for that.
      if (state.stage !== SEND_STAGES.EDIT && action.payload.account) {
        state.selectedAccount.balance = action.payload.account.balance;
        state.selectedAccount.address = action.payload.account.address;
        const draftTransaction = state.draftTransactions[state.currentTransactionUUID]; // This action will occur even when we aren't on the send flow, which
        // is okay as it keeps the selectedAccount details up to date. We do
        // not need to validate anything if there isn't a current draft
        // transaction. If there is, we need to update the asset balance if
        // the asset is set to the native network asset, and then validate
        // the transaction.

        if (draftTransaction) {
          if ((draftTransaction === null || draftTransaction === void 0 ? void 0 : draftTransaction.asset.type) === _transaction.ASSET_TYPES.NATIVE) {
            draftTransaction.asset.balance = action.payload.account.balance;
          }

          slice.caseReducers.validateAmountField(state);
          slice.caseReducers.validateGasField(state);
          slice.caseReducers.validateSendState(state);
        }
      }
    }).addCase(_actionConstants.QR_CODE_DETECTED, (state, action) => {
      // When data is received from the QR Code Scanner we set the recipient
      // as long as a valid address can be pulled from the data. If an
      // address is pulled but it is invalid, we display an error.
      const qrCodeData = action.value;
      const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

      if (qrCodeData && draftTransaction) {
        if (qrCodeData.type === 'address') {
          const scannedAddress = qrCodeData.values.address.toLowerCase();

          if ((0, _hexstringUtils.isValidHexAddress)(scannedAddress, {
            allowNonPrefixed: false
          })) {
            if (draftTransaction.recipient.address !== scannedAddress) {
              slice.caseReducers.updateRecipient(state, {
                payload: {
                  address: scannedAddress
                }
              });
            }
          } else {
            draftTransaction.recipient.error = _send.INVALID_RECIPIENT_ADDRESS_ERROR;
          }
        }
      }
    });
  }
});
const {
  actions,
  reducer
} = slice;
var _default = reducer;
exports.default = _default;
const {
  useDefaultGas,
  useCustomGas,
  updateGasLimit,
  validateRecipientUserInput,
  updateRecipientSearchMode,
  addHistoryEntry,
  acknowledgeRecipientWarning
} = actions;
exports.acknowledgeRecipientWarning = acknowledgeRecipientWarning;
exports.addHistoryEntry = addHistoryEntry;
exports.updateGasLimit = updateGasLimit;
exports.useCustomGas = useCustomGas;
exports.useDefaultGas = useDefaultGas;
// Action Creators

/**
 * This method is for usage when validating user input so that validation
 * is only run after a delay in typing of 300ms. Usage at callsites requires
 * passing in both the dispatch method and the payload to dispatch, which makes
 * it only applicable for use within action creators.
 */
const debouncedValidateRecipientUserInput = (0, _lodash.debounce)((dispatch, payload, resolve) => {
  dispatch(addHistoryEntry(`sendFlow - user typed ${payload.userInput} into recipient input field`));
  dispatch(validateRecipientUserInput(payload));
  resolve();
}, 300);
/**
 * Begins a new draft transaction, derived from the txParams of an existing
 * transaction in the TransactionController. This action will first clear out
 * the previous draft transactions and currentTransactionUUID from state. This
 * action is one of the two entry points into the send flow. NOTE: You must
 * route to the send page *after* dispatching this action resolves to ensure
 * that the draftTransaction is properly created.
 *
 * @param {AssetTypesString} assetType - The type of asset the transaction
 *  being edited was sending. The details of the asset will be retrieved from
 *  the transaction data in state.
 * @param {string} transactionId - The id of the transaction being edited.
 * @returns {ThunkAction<void>}
 */

function editExistingTransaction(assetType, transactionId) {
  return async (dispatch, getState) => {
    await dispatch(actions.clearPreviousDrafts());
    const state = getState();
    const unapprovedTransactions = (0, _metamask.getUnapprovedTxs)(state);
    const transaction = unapprovedTransactions[transactionId];
    const account = (0, _selectors.getTargetAccount)(state, transaction.txParams.from);

    if (assetType === _transaction.ASSET_TYPES.NATIVE) {
      var _getAddressBookEntryO;

      await dispatch(actions.addNewDraft({ ...draftTransactionInitialState,
        id: transactionId,
        fromAccount: account,
        gas: { ...draftTransactionInitialState.gas,
          gasLimit: transaction.txParams.gas,
          gasPrice: transaction.txParams.gasPrice
        },
        userInputHexData: transaction.txParams.data,
        recipient: { ...draftTransactionInitialState.recipient,
          address: transaction.txParams.to,
          nickname: (_getAddressBookEntryO = (0, _selectors.getAddressBookEntryOrAccountName)(state, transaction.txParams.to)) !== null && _getAddressBookEntryO !== void 0 ? _getAddressBookEntryO : ''
        },
        amount: { ...draftTransactionInitialState.amount,
          value: transaction.txParams.value
        },
        history: [`sendFlow - user clicked edit on transaction with id ${transactionId}`]
      }));
      await dispatch(updateSendAsset({
        type: _transaction.ASSET_TYPES.NATIVE
      }, {
        initialAssetSet: true
      }));
    } else {
      var _getAddressBookEntryO2, _getTokenIdParam;

      const tokenData = (0, _transaction2.parseStandardTokenTransactionData)(transaction.txParams.data);
      const tokenAmountInDec = assetType === _transaction.ASSET_TYPES.TOKEN ? (0, _metamaskControllerUtils.getTokenValueParam)(tokenData) : '1';
      const address = (0, _tokenUtil.getTokenAddressParam)(tokenData);
      const nickname = (_getAddressBookEntryO2 = (0, _selectors.getAddressBookEntryOrAccountName)(state, address)) !== null && _getAddressBookEntryO2 !== void 0 ? _getAddressBookEntryO2 : '';
      const tokenAmountInHex = (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.conversionUtil)(tokenAmountInDec, {
        fromNumericBase: 'dec',
        toNumericBase: 'hex'
      }));
      await dispatch(actions.addNewDraft({ ...draftTransactionInitialState,
        id: transactionId,
        fromAccount: account,
        gas: { ...draftTransactionInitialState.gas,
          gasLimit: transaction.txParams.gas,
          gasPrice: transaction.txParams.gasPrice
        },
        userInputHexData: transaction.txParams.data,
        recipient: { ...draftTransactionInitialState.recipient,
          address,
          nickname
        },
        amount: { ...draftTransactionInitialState.amount,
          value: tokenAmountInHex
        },
        history: [`sendFlow - user clicked edit on transaction with id ${transactionId}`]
      }));
      await dispatch(updateSendAsset({
        type: assetType,
        details: {
          address: transaction.txParams.to,
          ...(assetType === _transaction.ASSET_TYPES.COLLECTIBLE ? {
            tokenId: (_getTokenIdParam = (0, _tokenUtil.getTokenIdParam)(tokenData)) !== null && _getTokenIdParam !== void 0 ? _getTokenIdParam : (0, _metamaskControllerUtils.getTokenValueParam)(tokenData)
          } : {})
        }
      }, {
        initialAssetSet: true
      }));
    }

    await dispatch(initializeSendState());
  };
}
/**
 * This method is a temporary placeholder to support the old UI in both the
 * gas modal and the send flow. Soon we won't need to modify gasPrice from the
 * send flow based on user input, it'll just be a shallow copy of the current
 * estimate. This method is necessary because the internal structure of this
 * slice has been changed such that it is agnostic to transaction envelope
 * type, and this method calls into the new structure in the appropriate way.
 *
 * @deprecated - don't extend the usage of this temporary method
 * @param {string} gasPrice - new gas price in hex wei
 * @returns {ThunkAction<void>}
 */


function updateGasPrice(gasPrice) {
  return dispatch => {
    dispatch(addHistoryEntry(`sendFlow - user set legacy gasPrice to ${gasPrice}`));
    dispatch(actions.updateGasFees({
      gasPrice,
      transactionType: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
      manuallyEdited: true
    }));
  };
}
/**
 * Updates the recipient in state based on the input provided, and then will
 * recompute gas limit when sending a TOKEN asset type. Changing the recipient
 * address results in hex data changing because the recipient address is
 * encoded in the data instead of being in the 'to' field. The to field in a
 * token send will always be the token contract address.
 * If no nickname is provided, the address book state will be checked to see if
 * a nickname for the passed address has already been saved. This ensures the
 * (temporary) send state recipient nickname is consistent with the address book
 * nickname which has already been persisted to state.
 *
 * @param {object} recipient - Recipient information
 * @param {string} recipient.address - hex address to send the transaction to
 * @param {string} [recipient.nickname] - Alias for the address to display
 *  to the user
 * @returns {ThunkAction<void>}
 */


function updateRecipient({
  address,
  nickname
}) {
  return async (dispatch, getState) => {
    var _getAddressBookEntryO3;

    // Do not addHistoryEntry here as this is called from a number of places
    // each with significance to the user and transaction history.
    const state = getState();
    const nicknameFromAddressBookEntryOrAccountName = (_getAddressBookEntryO3 = (0, _selectors.getAddressBookEntryOrAccountName)(state, address)) !== null && _getAddressBookEntryO3 !== void 0 ? _getAddressBookEntryO3 : '';
    await dispatch(actions.updateRecipient({
      address,
      nickname: nickname || nicknameFromAddressBookEntryOrAccountName
    }));
    await dispatch(computeEstimatedGasLimit());
  };
}
/**
 * This method is called to update the user's input into the ENS input field.
 * Once the field is updated, the field will be validated using a debounced
 * version of the validateRecipientUserInput action. This way validation only
 * occurs once the user has stopped typing.
 *
 * @param {string} userInput - the value that the user is typing into the field
 */


function updateRecipientUserInput(userInput) {
  return async (dispatch, getState) => {
    var _ref, _draftTransaction$fro7, _draftTransaction$fro8;

    dispatch(actions.updateRecipientWarning('loading'));
    dispatch(actions.updateDraftTransactionStatus(SEND_STATUSES.INVALID));
    await dispatch(actions.updateRecipientUserInput(userInput));
    const state = getState();
    const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];
    const sendingAddress = (_ref = (_draftTransaction$fro7 = (_draftTransaction$fro8 = draftTransaction.fromAccount) === null || _draftTransaction$fro8 === void 0 ? void 0 : _draftTransaction$fro8.address) !== null && _draftTransaction$fro7 !== void 0 ? _draftTransaction$fro7 : state[name].selectedAccount.address) !== null && _ref !== void 0 ? _ref : (0, _selectors.getSelectedAddress)(state);
    const chainId = (0, _selectors.getCurrentChainId)(state);
    const tokens = (0, _metamask.getTokens)(state);
    const useTokenDetection = (0, _selectors.getUseTokenDetection)(state);
    const tokenMap = (0, _selectors.getTokenList)(state);
    const tokenAddressList = Object.keys(tokenMap);
    const inputIsValidHexAddress = (0, _hexstringUtils.isValidHexAddress)(userInput);
    let isProbablyAnAssetContract = false;

    if (inputIsValidHexAddress) {
      const smartContractAddress = await (0, _transactions.isSmartContractAddress)(userInput);

      if (smartContractAddress) {
        dispatch(actions.updateRecipientType(_send.RECIPIENT_TYPES.SMART_CONTRACT));
        const {
          symbol,
          decimals
        } = (0, _tokenUtil.getTokenMetadata)(userInput, tokenMap) || {};
        isProbablyAnAssetContract = symbol && decimals !== undefined;

        if (!isProbablyAnAssetContract) {
          try {
            const {
              standard
            } = await (0, _actions.getTokenStandardAndDetails)(userInput, sendingAddress);
            isProbablyAnAssetContract = Boolean(standard);
          } catch (e) {
            console.log(e);
          }
        }
      }
    }

    return new Promise(resolve => {
      debouncedValidateRecipientUserInput(dispatch, {
        userInput,
        chainId,
        tokens,
        useTokenDetection,
        tokenAddressList,
        isProbablyAnAssetContract
      }, resolve);
    });
  };
}
/**
 * Updates the amount the user intends to send and performs side effects.
 * 1. If the current mode is MAX change to INPUT
 * 2. If sending a token, recompute the gasLimit estimate
 *
 * @param {string} amount - hex string representing value
 * @returns {ThunkAction<void>}
 */


function updateSendAmount(amount) {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      metamask
    } = state;
    const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];
    let logAmount = amount;

    if (draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN) {
      var _draftTransaction$ass6, _draftTransaction$ass7, _draftTransaction$ass8;

      const multiplier = Math.pow(10, Number(((_draftTransaction$ass6 = draftTransaction.asset.details) === null || _draftTransaction$ass6 === void 0 ? void 0 : _draftTransaction$ass6.decimals) || 0));
      const decimalValueString = (0, _conversion.conversionUtil)((0, _ethereumjsUtil.addHexPrefix)(amount), {
        fromNumericBase: 'hex',
        toNumericBase: 'dec',
        toCurrency: (_draftTransaction$ass7 = draftTransaction.asset.details) === null || _draftTransaction$ass7 === void 0 ? void 0 : _draftTransaction$ass7.symbol,
        conversionRate: multiplier,
        invertConversionRate: true
      });
      logAmount = `${Number(decimalValueString) ? decimalValueString : ''} ${(_draftTransaction$ass8 = draftTransaction.asset.details) === null || _draftTransaction$ass8 === void 0 ? void 0 : _draftTransaction$ass8.symbol}`;
    } else {
      var _metamask$provider;

      const ethValue = (0, _confirmTx.getValueFromWeiHex)({
        value: amount,
        toCurrency: _common.ETH,
        numberOfDecimals: 8
      });
      logAmount = `${ethValue} ${(metamask === null || metamask === void 0 ? void 0 : (_metamask$provider = metamask.provider) === null || _metamask$provider === void 0 ? void 0 : _metamask$provider.ticker) || _common.ETH}`;
    }

    await dispatch(addHistoryEntry(`sendFlow - user set amount to ${logAmount}`));
    await dispatch(actions.updateSendAmount(amount));

    if (state[name].amountMode === AMOUNT_MODES.MAX) {
      await dispatch(actions.updateAmountMode(AMOUNT_MODES.INPUT));
    }

    await dispatch(computeEstimatedGasLimit());
  };
}
/**
 * updates the asset to send to one of NATIVE or TOKEN and ensures that the
 * asset balance is set. If sending a TOKEN also updates the asset details
 * object with the appropriate ERC20 details including address, symbol and
 * decimals.
 *
 * @param {object} payload - action payload
 * @param {string} payload.type - type of asset to send
 * @param {TokenDetails} [payload.details] - ERC20 details if sending TOKEN asset
 * @returns {ThunkAction<void>}
 */


function updateSendAsset({
  type,
  details: providedDetails
}, {
  initialAssetSet = false
} = {}) {
  return async (dispatch, getState) => {
    var _ref2, _draftTransaction$fro9, _draftTransaction$fro10;

    const state = getState();
    const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];
    const sendingAddress = (_ref2 = (_draftTransaction$fro9 = (_draftTransaction$fro10 = draftTransaction.fromAccount) === null || _draftTransaction$fro10 === void 0 ? void 0 : _draftTransaction$fro10.address) !== null && _draftTransaction$fro9 !== void 0 ? _draftTransaction$fro9 : state[name].selectedAccount.address) !== null && _ref2 !== void 0 ? _ref2 : (0, _selectors.getSelectedAddress)(state);
    const account = (0, _selectors.getTargetAccount)(state, sendingAddress);

    if (type === _transaction.ASSET_TYPES.NATIVE) {
      var _state$metamask$provi, _state$metamask$provi2;

      const unapprovedTxs = (0, _metamask.getUnapprovedTxs)(state);
      const unapprovedTx = unapprovedTxs === null || unapprovedTxs === void 0 ? void 0 : unapprovedTxs[draftTransaction.id];
      await dispatch(addHistoryEntry(`sendFlow - user set asset of type ${_transaction.ASSET_TYPES.NATIVE} with symbol ${(_state$metamask$provi = (_state$metamask$provi2 = state.metamask.provider) === null || _state$metamask$provi2 === void 0 ? void 0 : _state$metamask$provi2.ticker) !== null && _state$metamask$provi !== void 0 ? _state$metamask$provi : _common.ETH}`));
      await dispatch(actions.updateAsset({
        asset: {
          type,
          details: null,
          balance: account.balance,
          error: null
        },
        initialAssetSet
      })); // This is meant to handle cases where we are editing an unapprovedTx from the background state
      // and its type is a token method. In such a case, the hex data will be the necessary hex data
      // for calling the contract transfer method.
      // Now that we are updating the transaction to be a send of a native asset type, we should
      // set the hex data of the transaction being editing to be empty.
      // then the user will not want to send any hex data now that they have change the

      if ((unapprovedTx === null || unapprovedTx === void 0 ? void 0 : unapprovedTx.type) === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM || (unapprovedTx === null || unapprovedTx === void 0 ? void 0 : unapprovedTx.type) === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER || (unapprovedTx === null || unapprovedTx === void 0 ? void 0 : unapprovedTx.type) === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM) {
        await dispatch(actions.updateUserInputHexData(''));
      }
    } else {
      await dispatch((0, _actions.showLoadingIndication)());
      const details = { ...providedDetails,
        ...(await (0, _actions.getTokenStandardAndDetails)(providedDetails.address, sendingAddress, providedDetails.tokenId))
      };
      await dispatch((0, _actions.hideLoadingIndication)());
      const asset = {
        type,
        details,
        error: null
      };

      if (details.standard === _transaction.TOKEN_STANDARDS.ERC20) {
        asset.balance = (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcTokenAmount)(details.balance, details.decimals).toString(16));
        await dispatch(addHistoryEntry(`sendFlow - user set asset to ERC20 token with symbol ${details.symbol} and address ${details.address}`));
      } else if (details.standard === _transaction.TOKEN_STANDARDS.ERC1155 && type === _transaction.ASSET_TYPES.COLLECTIBLE) {
        throw new Error('Sends of ERC1155 tokens are not currently supported');
      } else if (details.standard === _transaction.TOKEN_STANDARDS.ERC1155 || details.standard === _transaction.TOKEN_STANDARDS.ERC721) {
        if (type === _transaction.ASSET_TYPES.TOKEN && false) {
          dispatch((0, _actions.showModal)({
            name: 'CONVERT_TOKEN_TO_NFT',
            tokenAddress: details.address
          }));
          asset.error = _errorKeys.INVALID_ASSET_TYPE;
          throw new Error(_errorKeys.INVALID_ASSET_TYPE);
        } else {
          let isCurrentOwner = true;

          try {
            isCurrentOwner = await (0, _actions.isCollectibleOwner)(sendingAddress, details.address, details.tokenId);
          } catch (err) {
            if (err.message.includes('Unable to verify ownership.')) {// this would indicate that either our attempts to verify ownership failed because of network issues,
              // or, somehow a token has been added to collectibles state with an incorrect chainId.
            } else {
              // Any other error is unexpected and should be surfaced.
              dispatch((0, _actions.displayWarning)(err.message));
            }
          }

          if (isCurrentOwner) {
            asset.error = null;
            asset.balance = '0x1';
          } else {
            throw new Error('Send slice initialized as collectible send with a collectible not currently owned by the select account');
          }

          await dispatch(addHistoryEntry(`sendFlow - user set asset to NFT with tokenId ${details.tokenId} and address ${details.address}`));
        }
      }

      await dispatch(actions.updateAsset({
        asset,
        initialAssetSet
      }));
    }

    if (initialAssetSet === false) {
      await dispatch(computeEstimatedGasLimit());
    }
  };
}
/**
 * When a user has enabled hex data field in advanced settings they will be
 * able to supply hex data on a transaction. This method updates the user
 * supplied data. Note, when sending native assets this will result in
 * recomputing estimated gasLimit. When sending a ERC20 asset this is not done
 * because the data sent in the transaction will be determined by the asset,
 * recipient and value, NOT what the user has supplied.
 *
 * @param {string} hexData - hex encoded string representing transaction data.
 * @returns {ThunkAction<void>}
 */


function updateSendHexData(hexData) {
  return async (dispatch, getState) => {
    await dispatch(addHistoryEntry(`sendFlow - user added custom hexData ${hexData}`));
    await dispatch(actions.updateUserInputHexData(hexData));
    const state = getState();
    const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];

    if (draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
      await dispatch(computeEstimatedGasLimit());
    }
  };
}
/**
 * Sets the recipient search mode to show a list of the user's contacts and
 * recently interacted with addresses.
 *
 * @returns {ThunkAction<void>}
 */


function useContactListForRecipientSearch() {
  return dispatch => {
    dispatch(addHistoryEntry(`sendFlow - user selected back to all on recipient screen`));
    dispatch(updateRecipientSearchMode(RECIPIENT_SEARCH_MODES.CONTACT_LIST));
  };
}
/**
 * Sets the recipient search mode to show a list of the user's own accounts.
 *
 * @returns {ThunkAction<void>}
 */


function useMyAccountsForRecipientSearch() {
  return dispatch => {
    dispatch(addHistoryEntry(`sendFlow - user selected transfer to my accounts on recipient screen`));
    dispatch(updateRecipientSearchMode(RECIPIENT_SEARCH_MODES.MY_ACCOUNTS));
  };
}
/**
 * Clears out the recipient user input, ENS resolution and recipient validation.
 *
 * @returns {ThunkAction<void>}
 */


function resetRecipientInput() {
  return async (dispatch, getState) => {
    const state = getState();
    const chainId = (0, _selectors.getCurrentChainId)(state);
    await dispatch(addHistoryEntry(`sendFlow - user cleared recipient input`));
    await dispatch(updateRecipientUserInput(''));
    await dispatch(updateRecipient({
      address: '',
      nickname: ''
    }));
    await dispatch((0, _ens.resetEnsResolution)());
    await dispatch(validateRecipientUserInput({
      chainId
    }));
  };
}
/**
 * Resets the entire send state tree to the initial state. It also disconnects
 * polling from the gas controller if the token is present in state.
 *
 * @returns {ThunkAction<void>}
 */


function resetSendState() {
  return async (dispatch, getState) => {
    const state = getState();
    dispatch(actions.resetSendState());

    if (state[name].gasEstimatePollToken) {
      await (0, _actions.disconnectGasFeeEstimatePoller)(state[name].gasEstimatePollToken);
      (0, _actions.removePollingTokenFromAppState)(state[name].gasEstimatePollToken);
    }
  };
}
/**
 * Signs a transaction or updates a transaction in state if editing.
 * This method is called when a user clicks the next button in the footer of
 * the send page, signaling that a transaction should be executed. This method
 * will create the transaction in state (by way of the various global provider
 * constructs) which will eventually (and fairly quickly from user perspective)
 * result in a confirmation window being displayed for the transaction.
 *
 * @returns {ThunkAction<void>}
 */


function signTransaction() {
  return async (dispatch, getState) => {
    const state = getState();
    const {
      stage,
      eip1559support
    } = state[name];
    const txParams = (0, _helpers.generateTransactionParams)(state[name]);
    const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];

    if (stage === SEND_STAGES.EDIT) {
      var _unapprovedTx$sendFlo;

      // When dealing with the edit flow there is already a transaction in
      // state that we must update, this branch is responsible for that logic.
      // We first must grab the previous transaction object from state and then
      // merge in the modified txParams. Once the transaction has been modified
      // we can send that to the background to update the transaction in state.
      const unapprovedTxs = (0, _metamask.getUnapprovedTxs)(state);
      const unapprovedTx = unapprovedTxs[draftTransaction.id]; // We only update the tx params that can be changed via the edit flow UX

      const eip1559OnlyTxParamsToUpdate = {
        data: txParams.data,
        from: txParams.from,
        to: txParams.to,
        value: txParams.value,
        gas: unapprovedTx.userEditedGasLimit ? unapprovedTx.txParams.gas : txParams.gas
      };
      unapprovedTx.originalGasEstimate = eip1559OnlyTxParamsToUpdate.gas;
      const editingTx = { ...unapprovedTx,
        txParams: Object.assign(unapprovedTx.txParams, eip1559support ? eip1559OnlyTxParamsToUpdate : txParams)
      };
      await dispatch(addHistoryEntry(`sendFlow - user clicked next and transaction should be updated in controller`));
      await dispatch((0, _actions.updateTransactionSendFlowHistory)(draftTransaction.id, ((_unapprovedTx$sendFlo = unapprovedTx.sendFlowHistory) === null || _unapprovedTx$sendFlo === void 0 ? void 0 : _unapprovedTx$sendFlo.length) || 0, draftTransaction.history));
      await dispatch((0, _actions.updateEditableParams)(draftTransaction.id, editingTx.txParams));
      await dispatch((0, _actions.updateTransactionGasFees)(draftTransaction.id, editingTx.txParams));
    } else {
      let transactionType = draftTransaction.recipient.type === _send.RECIPIENT_TYPES.SMART_CONTRACT ? _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION : _transaction.TRANSACTION_TYPES.SIMPLE_SEND;

      if (draftTransaction.asset.type !== _transaction.ASSET_TYPES.NATIVE) {
        transactionType = draftTransaction.asset.type === _transaction.ASSET_TYPES.COLLECTIBLE ? _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM : _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER;
      }

      await dispatch(addHistoryEntry(`sendFlow - user clicked next and transaction should be added to controller`));
      dispatch((0, _actions.addUnapprovedTransactionAndRouteToConfirmationPage)(txParams, transactionType, draftTransaction.history));
    }
  };
}
/**
 * Toggles the amount.mode between INPUT and MAX modes.
 * As a result, the amount.value will change to either '0x0' when moving from
 * MAX to INPUT, or to the maximum allowable amount based on current asset when
 * moving from INPUT to MAX.
 *
 * @returns {ThunkAction<void>}
 */


function toggleSendMaxMode() {
  return async (dispatch, getState) => {
    const state = getState();

    if (state[name].amountMode === AMOUNT_MODES.MAX) {
      await dispatch(actions.updateAmountMode(AMOUNT_MODES.INPUT));
      await dispatch(actions.updateSendAmount('0x0'));
      await dispatch(addHistoryEntry(`sendFlow - user toggled max mode off`));
    } else {
      await dispatch(actions.updateAmountMode(AMOUNT_MODES.MAX));
      await dispatch(actions.updateAmountToMax());
      await dispatch(addHistoryEntry(`sendFlow - user toggled max mode on`));
    }

    await dispatch(computeEstimatedGasLimit());
  };
}
/**
 * Begins a new draft transaction, clearing out the previous draft transactions
 * from state, and clearing the currentTransactionUUID. This action is one of
 * the two entry points into the send flow. NOTE: You must route to the send
 * page *after* dispatching this action resolves to ensure that the
 * draftTransaction is properly created.
 *
 * @param {Pick<Asset, 'type' | 'details'>} asset - A partial asset
 *  object containing at least the asset type. If specifying a non-native asset
 *  then the asset details must be included with at least the address.
 * @returns {ThunkAction<void>}
 */


function startNewDraftTransaction(asset) {
  return async dispatch => {
    var _asset$type;

    await dispatch(actions.clearPreviousDrafts());
    await dispatch(actions.addNewDraft({ ...draftTransactionInitialState,
      history: [`sendFlow - User started new draft transaction`]
    }));
    await dispatch(updateSendAsset({
      type: (_asset$type = asset.type) !== null && _asset$type !== void 0 ? _asset$type : _transaction.ASSET_TYPES.NATIVE,
      details: asset.details
    }));
    await dispatch(initializeSendState());
  };
} // Selectors

/**
 * The following typedef is a shortcut for typing selectors below. It uses a
 * generic type, T, so that each selector can specify it's return type.
 *
 * @template T
 * @typedef {(state: MetaMaskState) => T} Selector
 */

/**
 * Selector that returns the current draft transaction's UUID.
 *
 * @type {Selector<string>}
 */


function getCurrentTransactionUUID(state) {
  return state[name].currentTransactionUUID;
}
/**
 * Selector that returns the current draft transaction.
 *
 * @type {Selector<DraftTransaction>}
 */


function getCurrentDraftTransaction(state) {
  var _state$name$draftTran;

  return (_state$name$draftTran = state[name].draftTransactions[getCurrentTransactionUUID(state)]) !== null && _state$name$draftTran !== void 0 ? _state$name$draftTran : {};
}
/**
 * Selector that returns true if a draft transaction exists.
 *
 * @type {Selector<boolean>}
 */


function getDraftTransactionExists(state) {
  const draftTransaction = getCurrentDraftTransaction(state);

  if (Object.keys(draftTransaction).length === 0) {
    return false;
  }

  return true;
} // Gas selectors

/**
 * Selector that returns the current draft transaction's gasLimit.
 *
 * @type {Selector<?string>}
 */


function getGasLimit(state) {
  var _getCurrentDraftTrans;

  return (_getCurrentDraftTrans = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans === void 0 ? void 0 : _getCurrentDraftTrans.gasLimit;
}
/**
 * Selector that returns the current draft transaction's gasPrice.
 *
 * @type {Selector<?string>}
 */


function getGasPrice(state) {
  var _getCurrentDraftTrans2;

  return (_getCurrentDraftTrans2 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans2 === void 0 ? void 0 : _getCurrentDraftTrans2.gasPrice;
}
/**
 * Selector that returns the current draft transaction's gasTotal.
 *
 * @type {Selector<?string>}
 */


function getGasTotal(state) {
  var _getCurrentDraftTrans3;

  return (_getCurrentDraftTrans3 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans3 === void 0 ? void 0 : _getCurrentDraftTrans3.gasTotal;
}
/**
 * Selector that returns the error, if present, for the gas fields.
 *
 * @type {Selector<?string>}
 */


function gasFeeIsInError(state) {
  var _getCurrentDraftTrans4;

  return Boolean((_getCurrentDraftTrans4 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans4 === void 0 ? void 0 : _getCurrentDraftTrans4.error);
}
/**
 * Selector that returns the minimum gasLimit for the current network.
 *
 * @type {Selector<string>}
 */


function getMinimumGasLimitForSend(state) {
  return state[name].gasLimitMinimum;
}
/**
 * Selector that returns the current draft transaction's gasLimit.
 *
 * @type {Selector<MapValuesToUnion<SendStateGasModes>>}
 */


function getGasInputMode(state) {
  const isMainnet = (0, _selectors.getIsMainnet)(state);
  const gasEstimateType = (0, _metamask.getGasEstimateType)(state);
  const showAdvancedGasFields = (0, _selectors.getAdvancedInlineGasShown)(state);

  if (state[name].gasIsSetInModal) {
    return GAS_INPUT_MODES.CUSTOM;
  }

  if (!isMainnet && !false || showAdvancedGasFields) {
    return GAS_INPUT_MODES.INLINE;
  } // We get eth_gasPrice estimation if the legacy API fails but we need to
  // instruct the UI to render the INLINE inputs in this case, only on
  // mainnet or IN_TEST.


  if ((isMainnet || false) && gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
    return GAS_INPUT_MODES.INLINE;
  }

  return GAS_INPUT_MODES.BASIC;
} // Asset Selectors

/**
 * Selector that returns the asset the current draft transaction is sending.
 *
 * @type {Selector<?Asset>}
 */


function getSendAsset(state) {
  return getCurrentDraftTransaction(state).asset;
}
/**
 * Selector that returns the contract address of the non-native asset that
 * the current transaction is sending, if it exists.
 *
 * @type {Selector<?string>}
 */


function getSendAssetAddress(state) {
  var _getSendAsset, _getSendAsset$details;

  return (_getSendAsset = getSendAsset(state)) === null || _getSendAsset === void 0 ? void 0 : (_getSendAsset$details = _getSendAsset.details) === null || _getSendAsset$details === void 0 ? void 0 : _getSendAsset$details.address;
}
/**
 * Selector that returns a boolean value describing whether the currently
 * selected asset is sendable, based upon the standard of the token.
 *
 * @type {Selector<boolean>}
 */


function getIsAssetSendable(state) {
  var _getSendAsset2, _getSendAsset3, _getSendAsset3$detail;

  if (((_getSendAsset2 = getSendAsset(state)) === null || _getSendAsset2 === void 0 ? void 0 : _getSendAsset2.type) === _transaction.ASSET_TYPES.NATIVE) {
    return true;
  }

  return ((_getSendAsset3 = getSendAsset(state)) === null || _getSendAsset3 === void 0 ? void 0 : (_getSendAsset3$detail = _getSendAsset3.details) === null || _getSendAsset3$detail === void 0 ? void 0 : _getSendAsset3$detail.isERC721) === false;
}
/**
 * Selector that returns the asset error if it exists.
 *
 * @type {Selector<?string>}
 */


function getAssetError(state) {
  return getSendAsset(state).error;
} // Amount Selectors

/**
 * Selector that returns the amount that current draft transaction is sending.
 *
 * @type {Selector<?string>}
 */


function getSendAmount(state) {
  var _getCurrentDraftTrans5;

  return (_getCurrentDraftTrans5 = getCurrentDraftTransaction(state).amount) === null || _getCurrentDraftTrans5 === void 0 ? void 0 : _getCurrentDraftTrans5.value;
}
/**
 * Selector that returns true if the user has enough native asset balance to
 * cover the cost of the transaction.
 *
 * @type {Selector<boolean>}
 */


function getIsBalanceInsufficient(state) {
  var _getCurrentDraftTrans6;

  return ((_getCurrentDraftTrans6 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans6 === void 0 ? void 0 : _getCurrentDraftTrans6.error) === _send.INSUFFICIENT_FUNDS_ERROR;
}
/**
 * Selector that returns the amoung send mode, either MAX or INPUT.
 *
 * @type {Selector<boolean>}
 */


function getSendMaxModeState(state) {
  return state[name].amountMode === AMOUNT_MODES.MAX;
}
/**
 * Selector that returns the current draft transaction's data field.
 *
 * @type {Selector<?string>}
 */


function getSendHexData(state) {
  return getCurrentDraftTransaction(state).userInputHexData;
}
/**
 * Selector that returns the current draft transaction's id, if present.
 *
 * @type {Selector<?string>}
 */


function getDraftTransactionID(state) {
  return getCurrentDraftTransaction(state).id;
}
/**
 * Selector that returns true if there is an error on the amount field.
 *
 * @type {Selector<boolean>}
 */


function sendAmountIsInError(state) {
  var _getCurrentDraftTrans7;

  return Boolean((_getCurrentDraftTrans7 = getCurrentDraftTransaction(state).amount) === null || _getCurrentDraftTrans7 === void 0 ? void 0 : _getCurrentDraftTrans7.error);
} // Recipient Selectors

/**
 * Selector that returns the current draft transaction's recipient.
 *
 * @type {Selector<DraftTransaction['recipient']>}
 */


function getRecipient(state) {
  const draft = getCurrentDraftTransaction(state);

  if (!draft.recipient) {
    return {
      address: '',
      nickname: '',
      error: null,
      warning: null
    };
  }

  const checksummedAddress = (0, _hexstringUtils.toChecksumHexAddress)(draft.recipient.address);

  if (state.metamask.ensResolutionsByAddress) {
    return { ...draft.recipient,
      nickname: draft.recipient.nickname || (0, _selectors.getEnsResolutionByAddress)(state, checksummedAddress)
    };
  }

  return draft.recipient;
}
/**
 * Selector that returns the addres of the current draft transaction's
 * recipient.
 *
 * @type {Selector<?string>}
 */


function getSendTo(state) {
  var _getRecipient;

  return (_getRecipient = getRecipient(state)) === null || _getRecipient === void 0 ? void 0 : _getRecipient.address;
}
/**
 * Selector that returns true if the current recipientMode is MY_ACCOUNTS
 *
 * @type {Selector<boolean>}
 */


function getIsUsingMyAccountForRecipientSearch(state) {
  return state[name].recipientMode === RECIPIENT_SEARCH_MODES.MY_ACCOUNTS;
}
/**
 * Selector that returns the value that the user has typed into the recipient
 * input field.
 *
 * @type {Selector<?string>}
 */


function getRecipientUserInput(state) {
  return state[name].recipientInput;
}

function getRecipientWarningAcknowledgement(state) {
  var _getCurrentDraftTrans8, _getCurrentDraftTrans9;

  return (_getCurrentDraftTrans8 = (_getCurrentDraftTrans9 = getCurrentDraftTransaction(state).recipient) === null || _getCurrentDraftTrans9 === void 0 ? void 0 : _getCurrentDraftTrans9.recipientWarningAcknowledged) !== null && _getCurrentDraftTrans8 !== void 0 ? _getCurrentDraftTrans8 : false;
} // Overall validity and stage selectors

/**
 * Selector that returns the gasFee and amount errors, if they exist.
 *
 * @type {Selector<{ gasFee?: string, amount?: string}>}
 */


function getSendErrors(state) {
  var _getCurrentDraftTrans10, _getCurrentDraftTrans11;

  return {
    gasFee: (_getCurrentDraftTrans10 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans10 === void 0 ? void 0 : _getCurrentDraftTrans10.error,
    amount: (_getCurrentDraftTrans11 = getCurrentDraftTransaction(state).amount) === null || _getCurrentDraftTrans11 === void 0 ? void 0 : _getCurrentDraftTrans11.error
  };
}
/**
 * Selector that returns true if the stage is anything except INACTIVE
 *
 * @type {Selector<boolean>}
 */


function isSendStateInitialized(state) {
  return state[name].stage !== SEND_STAGES.INACTIVE;
}
/**
 * Selector that returns true if the current draft transaction is valid and in
 * a sendable state.
 *
 * @type {Selector<boolean>}
 */


function isSendFormInvalid(state) {
  const draftTransaction = getCurrentDraftTransaction(state);

  if (!draftTransaction) {
    return true;
  }

  return draftTransaction.status === SEND_STATUSES.INVALID;
}
/**
 * Selector that returns the current stage of the send flow
 *
 * @type {Selector<MapValuesToUnion<SendStateStages>>}
 */


function getSendStage(state) {
  return state[name].stage;
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\common.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WEI = exports.SUPPORT_REQUEST_LINK = exports.SECONDARY = exports.PRIMARY = exports.GWEI = exports.GAS_ESTIMATE_TYPES = exports.ETH = exports.CONTRACT_ADDRESS_LINK = void 0;
const ETH = 'ETH';
exports.ETH = ETH;
const GWEI = 'GWEI';
exports.GWEI = GWEI;
const WEI = 'WEI';
exports.WEI = WEI;
const PRIMARY = 'PRIMARY';
exports.PRIMARY = PRIMARY;
const SECONDARY = 'SECONDARY';
exports.SECONDARY = SECONDARY;
const GAS_ESTIMATE_TYPES = {
  SLOW: 'SLOW',
  AVERAGE: 'AVERAGE',
  FAST: 'FAST',
  FASTEST: 'FASTEST'
};
exports.GAS_ESTIMATE_TYPES = GAS_ESTIMATE_TYPES;
let _supportRequestLink = 'https://metamask.zendesk.com/hc/en-us';
const _contractAddressLink = 'https://metamask.zendesk.com/hc/en-us/articles/360020028092-What-is-the-known-contract-address-warning-';
const SUPPORT_REQUEST_LINK = _supportRequestLink;
exports.SUPPORT_REQUEST_LINK = SUPPORT_REQUEST_LINK;
const CONTRACT_ADDRESS_LINK = _contractAddressLink;
exports.CONTRACT_ADDRESS_LINK = CONTRACT_ADDRESS_LINK;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\design-system.js", {"lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\design-system.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TYPOGRAPHY = exports.TEXT_TRANSFORM = exports.TEXT_COLORS = exports.TEXT_ALIGN = exports.TEXT = exports.SIZES = exports.SEVERITIES = exports.RESIZE = exports.OVERFLOW_WRAP = exports.JUSTIFY_CONTENT = exports.ICON_COLORS = exports.FRACTIONS = exports.FONT_WEIGHT = exports.FONT_STYLE = exports.FLEX_WRAP = exports.FLEX_DIRECTION = exports.DISPLAY = exports.COLORS = exports.BREAKPOINTS = exports.BORDER_STYLE = exports.BORDER_RADIUS = exports.BORDER_COLORS = exports.BLOCK_SIZES = exports.BACKGROUND_COLORS = exports.ALIGN_ITEMS = void 0;

var _lodash = require("lodash");

/**
 * A note about the existence of both singular and plural variable names here:
 * When dealing with a literal property name, e.g. ALIGN_ITEMS, the constant
 * should match the property. When detailing a collection of things, it should
 * match the plural form of the thing. e.g. COLORS, TYPOGRAPHY
 */
const COLORS = {
  BACKGROUND_DEFAULT: 'background-default',
  BACKGROUND_ALTERNATIVE: 'background-alternative',
  TEXT_DEFAULT: 'text-default',
  TEXT_ALTERNATIVE: 'text-alternative',
  TEXT_MUTED: 'text-muted',
  ICON_DEFAULT: 'icon-default',
  ICON_ALTERNATIVE: 'icon-alternative',
  ICON_MUTED: 'icon-muted',
  BORDER_DEFAULT: 'border-default',
  BORDER_MUTED: 'border-muted',
  OVERLAY_DEFAULT: 'overlay-default',
  OVERLAY_INVERSE: 'overlay-inverse',
  PRIMARY_DEFAULT: 'primary-default',
  PRIMARY_ALTERNATIVE: 'primary-alternative',
  PRIMARY_MUTED: 'primary-muted',
  PRIMARY_INVERSE: 'primary-inverse',
  PRIMARY_DISABLED: 'primary-disabled',
  ERROR_DEFAULT: 'error-default',
  ERROR_ALTERNATIVE: 'error-alternative',
  ERROR_MUTED: 'error-muted',
  ERROR_INVERSE: 'error-inverse',
  ERROR_DISABLED: 'error-disabled',
  WARNING_DEFAULT: 'warning-default',
  WARNING_ALTERNATIVE: 'warning-alternative',
  WARNING_MUTED: 'warning-muted',
  WARNING_INVERSE: 'warning-inverse',
  WARNING_DISABLED: 'warning-disabled',
  SUCCESS_DEFAULT: 'success-default',
  SUCCESS_ALTERNATIVE: 'success-alternative',
  SUCCESS_MUTED: 'success-muted',
  SUCCESS_INVERSE: 'success-inverse',
  SUCCESS_DISABLED: 'success-disabled',
  INFO_DEFAULT: 'info-default',
  INFO_ALTERNATIVE: 'info-alternative',
  INFO_MUTED: 'info-muted',
  INFO_INVERSE: 'info-inverse',
  INFO_DISABLED: 'info-disabled',
  MAINNET: 'mainnet',
  GOERLI: 'goerli',
  SEPOLIA: 'sepolia',
  LOCALHOST: 'localhost',
  TRANSPARENT: 'transparent',
  INHERIT: 'inherit'
};
exports.COLORS = COLORS;
const BACKGROUND_COLORS = (0, _lodash.pick)(COLORS, ['BACKGROUND_DEFAULT', 'BACKGROUND_ALTERNATIVE', 'OVERLAY_DEFAULT', 'PRIMARY_DEFAULT', 'PRIMARY_ALTERNATIVE', 'PRIMARY_MUTED', 'ERROR_DEFAULT', 'ERROR_ALTERNATIVE', 'ERROR_MUTED', 'WARNING_DEFAULT', 'WARNING_ALTERNATIVE', 'WARNING_MUTED', 'SUCCESS_DEFAULT', 'SUCCESS_ALTERNATIVE', 'SUCCESS_MUTED', 'INFO_DEFAULT', 'INFO_ALTERNATIVE', 'INFO_MUTED', 'MAINNET', 'GOERLI', 'SEPOLIA', 'TRANSPARENT', 'LOCALHOST']);
exports.BACKGROUND_COLORS = BACKGROUND_COLORS;
const BORDER_COLORS = (0, _lodash.pick)(COLORS, ['BORDER_DEFAULT', 'BORDER_MUTED', 'PRIMARY_DEFAULT', 'PRIMARY_ALTERNATIVE', 'PRIMARY_MUTED', 'ERROR_DEFAULT', 'ERROR_ALTERNATIVE', 'ERROR_MUTED', 'WARNING_DEFAULT', 'WARNING_ALTERNATIVE', 'WARNING_MUTED', 'SUCCESS_DEFAULT', 'SUCCESS_ALTERNATIVE', 'SUCCESS_MUTED', 'INFO_DEFAULT', 'INFO_ALTERNATIVE', 'INFO_MUTED', 'MAINNET', 'GOERLI', 'SEPOLIA', 'TRANSPARENT', 'LOCALHOST']);
exports.BORDER_COLORS = BORDER_COLORS;
const TEXT_COLORS = (0, _lodash.pick)(COLORS, ['TEXT_DEFAULT', 'TEXT_ALTERNATIVE', 'TEXT_MUTED', 'OVERLAY_INVERSE', 'PRIMARY_DEFAULT', 'PRIMARY_INVERSE', 'ERROR_DEFAULT', 'ERROR_INVERSE', 'SUCCESS_DEFAULT', 'SUCCESS_INVERSE', 'WARNING_DEFAULT', 'WARNING_INVERSE', 'INFO_DEFAULT', 'INFO_INVERSE', 'INHERIT']);
exports.TEXT_COLORS = TEXT_COLORS;
const ICON_COLORS = (0, _lodash.pick)(COLORS, ['ICON_DEFAULT', 'ICON_ALTERNATIVE', 'ICON_MUTED', 'OVERLAY_INVERSE', 'PRIMARY_DEFAULT', 'PRIMARY_INVERSE', 'ERROR_DEFAULT', 'ERROR_INVERSE', 'SUCCESS_DEFAULT', 'SUCCESS_INVERSE', 'WARNING_DEFAULT', 'WARNING_INVERSE', 'INFO_DEFAULT', 'INFO_INVERSE', 'INHERIT']);
exports.ICON_COLORS = ICON_COLORS;
const TYPOGRAPHY = {
  H1: 'h1',
  H2: 'h2',
  H3: 'h3',
  H4: 'h4',
  H5: 'h5',
  H6: 'h6',
  H7: 'h7',
  H8: 'h8',
  H9: 'h9',
  Paragraph: 'p'
};
exports.TYPOGRAPHY = TYPOGRAPHY;
const TEXT = {
  DISPLAY_MD: 'display-md',
  HEADING_LG: 'heading-lg',
  HEADING_MD: 'heading-md',
  HEADING_SM: 'heading-sm',
  BODY_LG: 'body-lg-medium',
  BODY_MD: 'body-md',
  BODY_SM: 'body-sm',
  BODY_XS: 'body-xs',
  INHERIT: 'inherit'
};
exports.TEXT = TEXT;
const NONE = 'none';
const SIZES = {
  XXS: 'xxs',
  XS: 'xs',
  SM: 'sm',
  MD: 'md',
  LG: 'lg',
  XL: 'xl',
  AUTO: 'auto',
  // Used for Text, Icon, and Button components to inherit the parent elements font-size
  NONE
};
exports.SIZES = SIZES;
const BORDER_STYLE = {
  DASHED: 'dashed',
  SOLID: 'solid',
  DOTTED: 'dotted',
  DOUBLE: 'double',
  NONE
};
exports.BORDER_STYLE = BORDER_STYLE;
const BORDER_RADIUS = {
  XS: SIZES.XS,
  SM: SIZES.SM,
  MD: SIZES.MD,
  LG: SIZES.LG,
  XL: SIZES.XL,
  NONE,
  PILL: 'pill'
};
exports.BORDER_RADIUS = BORDER_RADIUS;
const FLEX_END = 'flex-end';
const FLEX_START = 'flex-start';
const CENTER = 'center';
const ALIGN_ITEMS = {
  FLEX_START,
  FLEX_END,
  CENTER,
  BASELINE: 'baseline',
  STRETCH: 'stretch'
};
exports.ALIGN_ITEMS = ALIGN_ITEMS;
const JUSTIFY_CONTENT = {
  FLEX_START,
  FLEX_END,
  CENTER,
  SPACE_AROUND: 'space-around',
  SPACE_BETWEEN: 'space-between',
  SPACE_EVENLY: 'space-evenly'
};
exports.JUSTIFY_CONTENT = JUSTIFY_CONTENT;
const FLEX_DIRECTION = {
  ROW: 'row',
  ROW_REVERSE: 'row-reverse',
  COLUMN: 'column',
  COLUMN_REVERSE: 'column-reverse'
};
exports.FLEX_DIRECTION = FLEX_DIRECTION;
const FLEX_WRAP = {
  WRAP: 'wrap',
  WRAP_REVERSE: 'wrap-reverse',
  NO_WRAP: 'nowrap'
};
exports.FLEX_WRAP = FLEX_WRAP;
const DISPLAY = {
  BLOCK: 'block',
  FLEX: 'flex',
  GRID: 'grid',
  INLINE_BLOCK: 'inline-block',
  INLINE: 'inline',
  INLINE_FLEX: 'inline-flex',
  INLINE_GRID: 'inline-grid',
  LIST_ITEM: 'list-item',
  NONE: 'none'
};
exports.DISPLAY = DISPLAY;
const FRACTIONS = {
  HALF: '1/2',
  ONE_THIRD: '1/3',
  TWO_THIRDS: '2/3',
  ONE_FOURTH: '1/4',
  TWO_FOURTHS: '2/4',
  THREE_FOURTHS: '3/4',
  ONE_FIFTH: '1/5',
  TWO_FIFTHS: '2/5',
  THREE_FIFTHS: '3/5',
  FOUR_FIFTHS: '4/5',
  ONE_SIXTH: '1/6',
  TWO_SIXTHS: '2/6',
  THREE_SIXTHS: '3/6',
  FOUR_SIXTHS: '4/6',
  FIVE_SIXTHS: '5/6',
  ONE_TWELFTH: '1/12',
  TWO_TWELFTHS: '2/12',
  THREE_TWELFTHS: '3/12',
  FOUR_TWELFTHS: '4/12',
  FIVE_TWELFTHS: '5/12',
  SIX_TWELFTHS: '6/12',
  SEVEN_TWELFTHS: '7/12',
  EIGHT_TWELFTHS: '8/12',
  NINE_TWELFTHS: '9/12',
  TEN_TWELFTHS: '10/12',
  ELEVEN_TWELFTHS: '11/12'
};
exports.FRACTIONS = FRACTIONS;
const BLOCK_SIZES = { ...FRACTIONS,
  SCREEN: 'screen',
  MAX: 'max',
  MIN: 'min',
  FULL: 'full'
};
exports.BLOCK_SIZES = BLOCK_SIZES;
const TEXT_ALIGN = {
  LEFT: 'left',
  CENTER: 'center',
  RIGHT: 'right',
  JUSTIFY: 'justify',
  END: 'end'
};
exports.TEXT_ALIGN = TEXT_ALIGN;
const TEXT_TRANSFORM = {
  UPPERCASE: 'uppercase',
  LOWERCASE: 'lowercase',
  CAPITALIZE: 'capitalize'
};
exports.TEXT_TRANSFORM = TEXT_TRANSFORM;
const FONT_WEIGHT = {
  BOLD: 'bold',
  MEDIUM: 'medium',
  NORMAL: 'normal'
};
exports.FONT_WEIGHT = FONT_WEIGHT;
const OVERFLOW_WRAP = {
  BREAK_WORD: 'break-word',
  NORMAL: 'normal'
};
exports.OVERFLOW_WRAP = OVERFLOW_WRAP;
const FONT_STYLE = {
  ITALIC: 'italic',
  NORMAL: 'normal'
};
exports.FONT_STYLE = FONT_STYLE;
const SEVERITIES = {
  DANGER: 'danger',
  WARNING: 'warning',
  INFO: 'info',
  SUCCESS: 'success'
};
exports.SEVERITIES = SEVERITIES;
const RESIZE = {
  NONE: 'none',
  BOTH: 'both',
  HORIZONTAL: 'horizontal',
  VERTICAL: 'vertical',
  INITIAL: 'initial',
  INHERIT: 'inherit'
};
exports.RESIZE = RESIZE;
const BREAKPOINTS = ['base', 'sm', 'md', 'lg'];
exports.BREAKPOINTS = BREAKPOINTS;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\error-keys.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\error-keys.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.UNSENDABLE_ASSET_ERROR_KEY = exports.TRANSACTION_ERROR_KEY = exports.INVALID_ASSET_TYPE = exports.INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = exports.INSUFFICIENT_FUNDS_ERROR_KEY = exports.GAS_PRICE_FETCH_FAILURE_ERROR_KEY = exports.GAS_PRICE_EXCESSIVE_ERROR_KEY = exports.GAS_LIMIT_TOO_LOW_ERROR_KEY = exports.ETH_GAS_PRICE_FETCH_WARNING_KEY = void 0;
const INSUFFICIENT_FUNDS_ERROR_KEY = 'insufficientFunds';
exports.INSUFFICIENT_FUNDS_ERROR_KEY = INSUFFICIENT_FUNDS_ERROR_KEY;
const GAS_LIMIT_TOO_LOW_ERROR_KEY = 'gasLimitTooLow';
exports.GAS_LIMIT_TOO_LOW_ERROR_KEY = GAS_LIMIT_TOO_LOW_ERROR_KEY;
const TRANSACTION_ERROR_KEY = 'transactionError';
exports.TRANSACTION_ERROR_KEY = TRANSACTION_ERROR_KEY;
const ETH_GAS_PRICE_FETCH_WARNING_KEY = 'ethGasPriceFetchWarning';
exports.ETH_GAS_PRICE_FETCH_WARNING_KEY = ETH_GAS_PRICE_FETCH_WARNING_KEY;
const GAS_PRICE_FETCH_FAILURE_ERROR_KEY = 'gasPriceFetchFailed';
exports.GAS_PRICE_FETCH_FAILURE_ERROR_KEY = GAS_PRICE_FETCH_FAILURE_ERROR_KEY;
const GAS_PRICE_EXCESSIVE_ERROR_KEY = 'gasPriceExcessive';
exports.GAS_PRICE_EXCESSIVE_ERROR_KEY = GAS_PRICE_EXCESSIVE_ERROR_KEY;
const UNSENDABLE_ASSET_ERROR_KEY = 'unsendableAsset';
exports.UNSENDABLE_ASSET_ERROR_KEY = UNSENDABLE_ASSET_ERROR_KEY;
const INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = 'insufficientFundsForGas';
exports.INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY;
const INVALID_ASSET_TYPE = 'invalidAssetType';
exports.INVALID_ASSET_TYPE = INVALID_ASSET_TYPE;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\routes.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\routes.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.VIEW_QUOTE_ROUTE = exports.UNLOCK_ROUTE = exports.TOKEN_DETAILS = exports.SWAPS_ROUTE = exports.SWAPS_MAINTENANCE_ROUTE = exports.SWAPS_ERROR_ROUTE = exports.SNAPS_VIEW_ROUTE = exports.SNAPS_LIST_ROUTE = exports.SMART_TRANSACTION_STATUS_ROUTE = exports.SIGNATURE_REQUEST_PATH = exports.SETTINGS_ROUTE = exports.SEND_ROUTE = exports.SECURITY_ROUTE = exports.REVEAL_SEED_ROUTE = exports.RESTORE_VAULT_ROUTE = exports.PATH_NAME_MAP = exports.ONBOARDING_WELCOME_ROUTE = exports.ONBOARDING_UNLOCK_ROUTE = exports.ONBOARDING_SECURE_YOUR_WALLET_ROUTE = exports.ONBOARDING_ROUTE = exports.ONBOARDING_REVIEW_SRP_ROUTE = exports.ONBOARDING_PRIVACY_SETTINGS_ROUTE = exports.ONBOARDING_PIN_EXTENSION_ROUTE = exports.ONBOARDING_METAMETRICS = exports.ONBOARDING_IMPORT_WITH_SRP_ROUTE = exports.ONBOARDING_IMPORT_MOBILE_ROUTE = exports.ONBOARDING_HELP_US_IMPROVE_ROUTE = exports.ONBOARDING_CREATE_PASSWORD_ROUTE = exports.ONBOARDING_CONFIRM_SRP_ROUTE = exports.ONBOARDING_COMPLETION_ROUTE = exports.NEW_ACCOUNT_ROUTE = exports.NETWORKS_ROUTE = exports.NETWORKS_FORM_ROUTE = exports.MOBILE_SYNC_ROUTE = exports.LOCK_ROUTE = exports.LOADING_QUOTES_ROUTE = exports.INITIALIZE_WELCOME_ROUTE = exports.INITIALIZE_UNLOCK_ROUTE = exports.INITIALIZE_SELECT_ACTION_ROUTE = exports.INITIALIZE_SEED_PHRASE_ROUTE = exports.INITIALIZE_SEED_PHRASE_INTRO_ROUTE = exports.INITIALIZE_ROUTE = exports.INITIALIZE_METAMETRICS_OPT_IN_ROUTE = exports.INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE = exports.INITIALIZE_END_OF_FLOW_ROUTE = exports.INITIALIZE_CREATE_PASSWORD_ROUTE = exports.INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE = exports.INITIALIZE_BACKUP_SEED_PHRASE_ROUTE = exports.IMPORT_TOKEN_ROUTE = exports.IMPORT_ACCOUNT_ROUTE = exports.GENERAL_ROUTE = exports.EXPERIMENTAL_ROUTE = exports.ENCRYPTION_PUBLIC_KEY_REQUEST_PATH = exports.DEFAULT_ROUTE = exports.DECRYPT_MESSAGE_REQUEST_PATH = exports.CONTACT_VIEW_ROUTE = exports.CONTACT_LIST_ROUTE = exports.CONTACT_EDIT_ROUTE = exports.CONTACT_ADD_ROUTE = exports.CONNECT_ROUTE = exports.CONNECT_HARDWARE_ROUTE = exports.CONNECT_CONFIRM_PERMISSIONS_ROUTE = exports.CONNECTED_ROUTE = exports.CONNECTED_ACCOUNTS_ROUTE = exports.CONFIRM_TRANSFER_FROM_PATH = exports.CONFIRM_TRANSACTION_ROUTE = exports.CONFIRM_TOKEN_METHOD_PATH = exports.CONFIRM_SET_APPROVAL_FOR_ALL_PATH = exports.CONFIRM_SEND_TOKEN_PATH = exports.CONFIRM_SEND_ETHER_PATH = exports.CONFIRM_SAFE_TRANSFER_FROM_PATH = exports.CONFIRM_IMPORT_TOKEN_ROUTE = exports.CONFIRM_DEPLOY_CONTRACT_PATH = exports.CONFIRM_APPROVE_PATH = exports.CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE = exports.CONFIRMATION_V_NEXT_ROUTE = exports.BUILD_QUOTE_ROUTE = exports.AWAITING_SWAP_ROUTE = exports.AWAITING_SIGNATURES_ROUTE = exports.ASSET_ROUTE = exports.ALERTS_ROUTE = exports.ADVANCED_ROUTE = exports.ADD_POPULAR_CUSTOM_NETWORK = exports.ADD_NETWORK_ROUTE = exports.ADD_COLLECTIBLE_ROUTE = exports.ABOUT_US_ROUTE = void 0;
const DEFAULT_ROUTE = '/';
exports.DEFAULT_ROUTE = DEFAULT_ROUTE;
const UNLOCK_ROUTE = '/unlock';
exports.UNLOCK_ROUTE = UNLOCK_ROUTE;
const LOCK_ROUTE = '/lock';
exports.LOCK_ROUTE = LOCK_ROUTE;
const ASSET_ROUTE = '/asset';
exports.ASSET_ROUTE = ASSET_ROUTE;
const SETTINGS_ROUTE = '/settings';
exports.SETTINGS_ROUTE = SETTINGS_ROUTE;
const GENERAL_ROUTE = '/settings/general';
exports.GENERAL_ROUTE = GENERAL_ROUTE;
const ADVANCED_ROUTE = '/settings/advanced';
exports.ADVANCED_ROUTE = ADVANCED_ROUTE;
const EXPERIMENTAL_ROUTE = '/settings/experimental';
exports.EXPERIMENTAL_ROUTE = EXPERIMENTAL_ROUTE;
const SECURITY_ROUTE = '/settings/security';
exports.SECURITY_ROUTE = SECURITY_ROUTE;
const ABOUT_US_ROUTE = '/settings/about-us';
exports.ABOUT_US_ROUTE = ABOUT_US_ROUTE;
const ALERTS_ROUTE = '/settings/alerts';
exports.ALERTS_ROUTE = ALERTS_ROUTE;
const NETWORKS_ROUTE = '/settings/networks';
exports.NETWORKS_ROUTE = NETWORKS_ROUTE;
const NETWORKS_FORM_ROUTE = '/settings/networks/form';
exports.NETWORKS_FORM_ROUTE = NETWORKS_FORM_ROUTE;
const ADD_NETWORK_ROUTE = '/settings/networks/add-network';
exports.ADD_NETWORK_ROUTE = ADD_NETWORK_ROUTE;
const ADD_POPULAR_CUSTOM_NETWORK = '/settings/networks/add-popular-custom-network';
exports.ADD_POPULAR_CUSTOM_NETWORK = ADD_POPULAR_CUSTOM_NETWORK;
const SNAPS_LIST_ROUTE = '/settings/snaps-list';
exports.SNAPS_LIST_ROUTE = SNAPS_LIST_ROUTE;
const SNAPS_VIEW_ROUTE = '/settings/snaps-view';
exports.SNAPS_VIEW_ROUTE = SNAPS_VIEW_ROUTE;
const CONTACT_LIST_ROUTE = '/settings/contact-list';
exports.CONTACT_LIST_ROUTE = CONTACT_LIST_ROUTE;
const CONTACT_EDIT_ROUTE = '/settings/contact-list/edit-contact';
exports.CONTACT_EDIT_ROUTE = CONTACT_EDIT_ROUTE;
const CONTACT_ADD_ROUTE = '/settings/contact-list/add-contact';
exports.CONTACT_ADD_ROUTE = CONTACT_ADD_ROUTE;
const CONTACT_VIEW_ROUTE = '/settings/contact-list/view-contact';
exports.CONTACT_VIEW_ROUTE = CONTACT_VIEW_ROUTE;
const REVEAL_SEED_ROUTE = '/seed';
exports.REVEAL_SEED_ROUTE = REVEAL_SEED_ROUTE;
const MOBILE_SYNC_ROUTE = '/mobile-sync';
exports.MOBILE_SYNC_ROUTE = MOBILE_SYNC_ROUTE;
const RESTORE_VAULT_ROUTE = '/restore-vault';
exports.RESTORE_VAULT_ROUTE = RESTORE_VAULT_ROUTE;
const IMPORT_TOKEN_ROUTE = '/import-token';
exports.IMPORT_TOKEN_ROUTE = IMPORT_TOKEN_ROUTE;
const CONFIRM_IMPORT_TOKEN_ROUTE = '/confirm-import-token';
exports.CONFIRM_IMPORT_TOKEN_ROUTE = CONFIRM_IMPORT_TOKEN_ROUTE;
const CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE = '/confirm-add-suggested-token';
exports.CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE = CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE;
const NEW_ACCOUNT_ROUTE = '/new-account';
exports.NEW_ACCOUNT_ROUTE = NEW_ACCOUNT_ROUTE;
const IMPORT_ACCOUNT_ROUTE = '/new-account/import';
exports.IMPORT_ACCOUNT_ROUTE = IMPORT_ACCOUNT_ROUTE;
const CONNECT_HARDWARE_ROUTE = '/new-account/connect';
exports.CONNECT_HARDWARE_ROUTE = CONNECT_HARDWARE_ROUTE;
const SEND_ROUTE = '/send';
exports.SEND_ROUTE = SEND_ROUTE;
const TOKEN_DETAILS = '/token-details';
exports.TOKEN_DETAILS = TOKEN_DETAILS;
const CONNECT_ROUTE = '/connect';
exports.CONNECT_ROUTE = CONNECT_ROUTE;
const CONNECT_CONFIRM_PERMISSIONS_ROUTE = '/confirm-permissions';
exports.CONNECT_CONFIRM_PERMISSIONS_ROUTE = CONNECT_CONFIRM_PERMISSIONS_ROUTE;
const CONNECTED_ROUTE = '/connected';
exports.CONNECTED_ROUTE = CONNECTED_ROUTE;
const CONNECTED_ACCOUNTS_ROUTE = '/connected/accounts';
exports.CONNECTED_ACCOUNTS_ROUTE = CONNECTED_ACCOUNTS_ROUTE;
const SWAPS_ROUTE = '/swaps';
exports.SWAPS_ROUTE = SWAPS_ROUTE;
const BUILD_QUOTE_ROUTE = '/swaps/build-quote';
exports.BUILD_QUOTE_ROUTE = BUILD_QUOTE_ROUTE;
const VIEW_QUOTE_ROUTE = '/swaps/view-quote';
exports.VIEW_QUOTE_ROUTE = VIEW_QUOTE_ROUTE;
const LOADING_QUOTES_ROUTE = '/swaps/loading-quotes';
exports.LOADING_QUOTES_ROUTE = LOADING_QUOTES_ROUTE;
const AWAITING_SIGNATURES_ROUTE = '/swaps/awaiting-signatures';
exports.AWAITING_SIGNATURES_ROUTE = AWAITING_SIGNATURES_ROUTE;
const SMART_TRANSACTION_STATUS_ROUTE = '/swaps/smart-transaction-status';
exports.SMART_TRANSACTION_STATUS_ROUTE = SMART_TRANSACTION_STATUS_ROUTE;
const AWAITING_SWAP_ROUTE = '/swaps/awaiting-swap';
exports.AWAITING_SWAP_ROUTE = AWAITING_SWAP_ROUTE;
const SWAPS_ERROR_ROUTE = '/swaps/swaps-error';
exports.SWAPS_ERROR_ROUTE = SWAPS_ERROR_ROUTE;
const SWAPS_MAINTENANCE_ROUTE = '/swaps/maintenance';
exports.SWAPS_MAINTENANCE_ROUTE = SWAPS_MAINTENANCE_ROUTE;
const ADD_COLLECTIBLE_ROUTE = '/add-collectible';
exports.ADD_COLLECTIBLE_ROUTE = ADD_COLLECTIBLE_ROUTE;
const INITIALIZE_ROUTE = '/initialize';
exports.INITIALIZE_ROUTE = INITIALIZE_ROUTE;
const INITIALIZE_WELCOME_ROUTE = '/initialize/welcome';
exports.INITIALIZE_WELCOME_ROUTE = INITIALIZE_WELCOME_ROUTE;
const INITIALIZE_UNLOCK_ROUTE = '/initialize/unlock';
exports.INITIALIZE_UNLOCK_ROUTE = INITIALIZE_UNLOCK_ROUTE;
const INITIALIZE_CREATE_PASSWORD_ROUTE = '/initialize/create-password';
exports.INITIALIZE_CREATE_PASSWORD_ROUTE = INITIALIZE_CREATE_PASSWORD_ROUTE;
const INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE = '/initialize/create-password/import-with-seed-phrase';
exports.INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE = INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE;
const INITIALIZE_SELECT_ACTION_ROUTE = '/initialize/select-action';
exports.INITIALIZE_SELECT_ACTION_ROUTE = INITIALIZE_SELECT_ACTION_ROUTE;
const INITIALIZE_SEED_PHRASE_ROUTE = '/initialize/seed-phrase';
exports.INITIALIZE_SEED_PHRASE_ROUTE = INITIALIZE_SEED_PHRASE_ROUTE;
const INITIALIZE_BACKUP_SEED_PHRASE_ROUTE = '/initialize/backup-seed-phrase';
exports.INITIALIZE_BACKUP_SEED_PHRASE_ROUTE = INITIALIZE_BACKUP_SEED_PHRASE_ROUTE;
const INITIALIZE_SEED_PHRASE_INTRO_ROUTE = '/initialize/seed-phrase-intro';
exports.INITIALIZE_SEED_PHRASE_INTRO_ROUTE = INITIALIZE_SEED_PHRASE_INTRO_ROUTE;
const INITIALIZE_END_OF_FLOW_ROUTE = '/initialize/end-of-flow';
exports.INITIALIZE_END_OF_FLOW_ROUTE = INITIALIZE_END_OF_FLOW_ROUTE;
const INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE = '/initialize/seed-phrase/confirm';
exports.INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE = INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE;
const INITIALIZE_METAMETRICS_OPT_IN_ROUTE = '/initialize/metametrics-opt-in';
exports.INITIALIZE_METAMETRICS_OPT_IN_ROUTE = INITIALIZE_METAMETRICS_OPT_IN_ROUTE;
const ONBOARDING_ROUTE = '/onboarding';
exports.ONBOARDING_ROUTE = ONBOARDING_ROUTE;
const ONBOARDING_REVIEW_SRP_ROUTE = '/onboarding/review-recovery-phrase';
exports.ONBOARDING_REVIEW_SRP_ROUTE = ONBOARDING_REVIEW_SRP_ROUTE;
const ONBOARDING_CONFIRM_SRP_ROUTE = '/onboarding/confirm-recovery-phrase';
exports.ONBOARDING_CONFIRM_SRP_ROUTE = ONBOARDING_CONFIRM_SRP_ROUTE;
const ONBOARDING_CREATE_PASSWORD_ROUTE = '/onboarding/create-password';
exports.ONBOARDING_CREATE_PASSWORD_ROUTE = ONBOARDING_CREATE_PASSWORD_ROUTE;
const ONBOARDING_COMPLETION_ROUTE = '/onboarding/completion';
exports.ONBOARDING_COMPLETION_ROUTE = ONBOARDING_COMPLETION_ROUTE;
const ONBOARDING_UNLOCK_ROUTE = '/onboarding/unlock';
exports.ONBOARDING_UNLOCK_ROUTE = ONBOARDING_UNLOCK_ROUTE;
const ONBOARDING_HELP_US_IMPROVE_ROUTE = '/onboarding/help-us-improve';
exports.ONBOARDING_HELP_US_IMPROVE_ROUTE = ONBOARDING_HELP_US_IMPROVE_ROUTE;
const ONBOARDING_IMPORT_WITH_SRP_ROUTE = '/onboarding/import-with-recovery-phrase';
exports.ONBOARDING_IMPORT_WITH_SRP_ROUTE = ONBOARDING_IMPORT_WITH_SRP_ROUTE;
const ONBOARDING_IMPORT_MOBILE_ROUTE = '/onboarding/import-mobile';
exports.ONBOARDING_IMPORT_MOBILE_ROUTE = ONBOARDING_IMPORT_MOBILE_ROUTE;
const ONBOARDING_SECURE_YOUR_WALLET_ROUTE = '/onboarding/secure-your-wallet';
exports.ONBOARDING_SECURE_YOUR_WALLET_ROUTE = ONBOARDING_SECURE_YOUR_WALLET_ROUTE;
const ONBOARDING_PRIVACY_SETTINGS_ROUTE = '/onboarding/privacy-settings';
exports.ONBOARDING_PRIVACY_SETTINGS_ROUTE = ONBOARDING_PRIVACY_SETTINGS_ROUTE;
const ONBOARDING_PIN_EXTENSION_ROUTE = '/onboarding/pin-extension';
exports.ONBOARDING_PIN_EXTENSION_ROUTE = ONBOARDING_PIN_EXTENSION_ROUTE;
const ONBOARDING_WELCOME_ROUTE = '/onboarding/welcome';
exports.ONBOARDING_WELCOME_ROUTE = ONBOARDING_WELCOME_ROUTE;
const ONBOARDING_METAMETRICS = '/onboarding/metametrics';
exports.ONBOARDING_METAMETRICS = ONBOARDING_METAMETRICS;
const CONFIRM_TRANSACTION_ROUTE = '/confirm-transaction';
exports.CONFIRM_TRANSACTION_ROUTE = CONFIRM_TRANSACTION_ROUTE;
const CONFIRM_SEND_ETHER_PATH = '/send-ether';
exports.CONFIRM_SEND_ETHER_PATH = CONFIRM_SEND_ETHER_PATH;
const CONFIRM_SEND_TOKEN_PATH = '/send-token';
exports.CONFIRM_SEND_TOKEN_PATH = CONFIRM_SEND_TOKEN_PATH;
const CONFIRM_DEPLOY_CONTRACT_PATH = '/deploy-contract';
exports.CONFIRM_DEPLOY_CONTRACT_PATH = CONFIRM_DEPLOY_CONTRACT_PATH;
const CONFIRM_APPROVE_PATH = '/approve';
exports.CONFIRM_APPROVE_PATH = CONFIRM_APPROVE_PATH;
const CONFIRM_SET_APPROVAL_FOR_ALL_PATH = '/set-approval-for-all';
exports.CONFIRM_SET_APPROVAL_FOR_ALL_PATH = CONFIRM_SET_APPROVAL_FOR_ALL_PATH;
const CONFIRM_TRANSFER_FROM_PATH = '/transfer-from';
exports.CONFIRM_TRANSFER_FROM_PATH = CONFIRM_TRANSFER_FROM_PATH;
const CONFIRM_SAFE_TRANSFER_FROM_PATH = '/safe-transfer-from';
exports.CONFIRM_SAFE_TRANSFER_FROM_PATH = CONFIRM_SAFE_TRANSFER_FROM_PATH;
const CONFIRM_TOKEN_METHOD_PATH = '/token-method';
exports.CONFIRM_TOKEN_METHOD_PATH = CONFIRM_TOKEN_METHOD_PATH;
const SIGNATURE_REQUEST_PATH = '/signature-request';
exports.SIGNATURE_REQUEST_PATH = SIGNATURE_REQUEST_PATH;
const DECRYPT_MESSAGE_REQUEST_PATH = '/decrypt-message-request';
exports.DECRYPT_MESSAGE_REQUEST_PATH = DECRYPT_MESSAGE_REQUEST_PATH;
const ENCRYPTION_PUBLIC_KEY_REQUEST_PATH = '/encryption-public-key-request';
exports.ENCRYPTION_PUBLIC_KEY_REQUEST_PATH = ENCRYPTION_PUBLIC_KEY_REQUEST_PATH;
const CONFIRMATION_V_NEXT_ROUTE = '/confirmation'; // Used to pull a convenient name for analytics tracking events. The key must
// be react-router ready path, and can include params such as :id for popup windows

exports.CONFIRMATION_V_NEXT_ROUTE = CONFIRMATION_V_NEXT_ROUTE;
const PATH_NAME_MAP = {
  [DEFAULT_ROUTE]: 'Home',
  [UNLOCK_ROUTE]: 'Unlock Page',
  [LOCK_ROUTE]: 'Lock Page',
  [`${ASSET_ROUTE}/:asset/:id`]: `Asset Page`,
  [SETTINGS_ROUTE]: 'Settings Page',
  [GENERAL_ROUTE]: 'General Settings Page',
  [ADVANCED_ROUTE]: 'Advanced Settings Page',
  [EXPERIMENTAL_ROUTE]: 'Experimental Settings Page',
  [SECURITY_ROUTE]: 'Security Settings Page',
  [ABOUT_US_ROUTE]: 'About Us Page',
  [ALERTS_ROUTE]: 'Alerts Settings Page',
  [NETWORKS_ROUTE]: 'Network Settings Page',
  [NETWORKS_FORM_ROUTE]: 'Network Settings Page Form',
  [ADD_NETWORK_ROUTE]: 'Add Network From Settings Page Form',
  [ADD_POPULAR_CUSTOM_NETWORK]: 'Add Network From A List Of Popular Custom Networks',
  [CONTACT_LIST_ROUTE]: 'Contact List Settings Page',
  [`${CONTACT_EDIT_ROUTE}/:address`]: 'Edit Contact Settings Page',
  [CONTACT_ADD_ROUTE]: 'Add Contact Settings Page',
  [`${CONTACT_VIEW_ROUTE}/:address`]: 'View Contact Settings Page',
  [REVEAL_SEED_ROUTE]: 'Reveal Secret Recovery Phrase Page',
  [MOBILE_SYNC_ROUTE]: 'Sync With Mobile Page',
  [RESTORE_VAULT_ROUTE]: 'Restore Vault Page',
  [IMPORT_TOKEN_ROUTE]: 'Import Token Page',
  [CONFIRM_IMPORT_TOKEN_ROUTE]: 'Confirm Import Token Page',
  [CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE]: 'Confirm Add Suggested Token Page',
  [NEW_ACCOUNT_ROUTE]: 'New Account Page',
  [IMPORT_ACCOUNT_ROUTE]: 'Import Account Page',
  [CONNECT_HARDWARE_ROUTE]: 'Connect Hardware Wallet Page',
  [SEND_ROUTE]: 'Send Page',
  [`${TOKEN_DETAILS}/:address`]: 'Token Details Page',
  [`${CONNECT_ROUTE}/:id`]: 'Connect To Site Confirmation Page',
  [`${CONNECT_ROUTE}/:id${CONNECT_CONFIRM_PERMISSIONS_ROUTE}`]: 'Grant Connected Site Permissions Confirmation Page',
  [CONNECTED_ROUTE]: 'Sites Connected To This Account Page',
  [CONNECTED_ACCOUNTS_ROUTE]: 'Accounts Connected To This Site Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id`]: 'Confirmation Root Page',
  [CONFIRM_TRANSACTION_ROUTE]: 'Confirmation Root Page',
  // TODO: rename when this is the only confirmation page
  [CONFIRMATION_V_NEXT_ROUTE]: 'New Confirmation Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_TOKEN_METHOD_PATH}`]: 'Confirm Token Method Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SEND_ETHER_PATH}`]: 'Confirm Send Ether Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SEND_TOKEN_PATH}`]: 'Confirm Send Token Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_DEPLOY_CONTRACT_PATH}`]: 'Confirm Deploy Contract Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_APPROVE_PATH}`]: 'Confirm Approve Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SET_APPROVAL_FOR_ALL_PATH}`]: 'Confirm Set Approval For All Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_TRANSFER_FROM_PATH}`]: 'Confirm Transfer From Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SAFE_TRANSFER_FROM_PATH}`]: 'Confirm Safe Transfer From Transaction Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${SIGNATURE_REQUEST_PATH}`]: 'Signature Request Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${DECRYPT_MESSAGE_REQUEST_PATH}`]: 'Decrypt Message Request Page',
  [`${CONFIRM_TRANSACTION_ROUTE}/:id${ENCRYPTION_PUBLIC_KEY_REQUEST_PATH}`]: 'Encryption Public Key Request Page',
  [INITIALIZE_ROUTE]: 'Initialization Page',
  [INITIALIZE_WELCOME_ROUTE]: 'Install Welcome Page',
  [INITIALIZE_UNLOCK_ROUTE]: 'Initialization Unlock page',
  [INITIALIZE_CREATE_PASSWORD_ROUTE]: 'Initialization Create Password Page',
  [INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE]: 'Initialization Import Account With Secret Recovery Phrase Page',
  [INITIALIZE_SELECT_ACTION_ROUTE]: 'Initialization Choose Restore or New Account Page',
  [INITIALIZE_SEED_PHRASE_ROUTE]: 'Initialization Secret Recovery Phrase Page',
  [INITIALIZE_BACKUP_SEED_PHRASE_ROUTE]: 'Initialization Backup Secret Recovery Phrase Page',
  [INITIALIZE_SEED_PHRASE_INTRO_ROUTE]: 'Initialization Secret Recovery Phrase Intro Page',
  [INITIALIZE_END_OF_FLOW_ROUTE]: 'End of Initialization Page',
  [INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE]: 'Initialization Confirm Secret Recovery Phrase Page',
  [INITIALIZE_METAMETRICS_OPT_IN_ROUTE]: 'MetaMetrics Opt In Page',
  [BUILD_QUOTE_ROUTE]: 'Swaps Build Quote Page',
  [VIEW_QUOTE_ROUTE]: 'Swaps View Quotes Page',
  [LOADING_QUOTES_ROUTE]: 'Swaps Loading Quotes Page',
  [AWAITING_SWAP_ROUTE]: 'Swaps Awaiting Swaps Page',
  [SWAPS_ERROR_ROUTE]: 'Swaps Error Page'
};
exports.PATH_NAME_MAP = PATH_NAME_MAP;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\transactions.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\transactions.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOKEN_CATEGORY_HASH = exports.PRIORITY_STATUS_HASH = exports.PENDING_STATUS_HASH = void 0;

var _transaction = require("../../../shared/constants/transaction");

const PENDING_STATUS_HASH = {
  [_transaction.TRANSACTION_STATUSES.UNAPPROVED]: true,
  [_transaction.TRANSACTION_STATUSES.APPROVED]: true,
  [_transaction.TRANSACTION_STATUSES.SUBMITTED]: true,
  [_transaction.TRANSACTION_STATUSES.PENDING]: true
};
exports.PENDING_STATUS_HASH = PENDING_STATUS_HASH;
const PRIORITY_STATUS_HASH = { ...PENDING_STATUS_HASH,
  [_transaction.TRANSACTION_STATUSES.CONFIRMED]: true
};
exports.PRIORITY_STATUS_HASH = PRIORITY_STATUS_HASH;
const TOKEN_CATEGORY_HASH = {
  [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE]: true,
  [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL]: true,
  [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER]: true,
  [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM]: true
};
exports.TOKEN_CATEGORY_HASH = TOKEN_CATEGORY_HASH;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\zendesk-url.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\zendesk-url.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
const ZENDESK_URLS = {
  ADD_CUSTOM_TOKENS: 'https://metamask.zendesk.com/hc/en-us/articles/360015489031',
  ADD_MISSING_ACCOUNTS: 'https://metamask.zendesk.com/hc/en-us/articles/360015489271',
  BASIC_SAFETY: 'https://metamask.zendesk.com/hc/en-us/articles/360015489591-Basic-Safety-Tips',
  CUSTOMIZE_NONCE: 'https://metamask.zendesk.com/hc/en-us/articles/7417499333531-How-to-customize-a-transaction-nonce',
  HARDWARE_CONNECTION: 'https://metamask.zendesk.com/hc/en-us/articles/360020394612-How-to-connect-a-Trezor-or-Ledger-Hardware-Wallet',
  IMPORT_ACCOUNTS: 'https://metamask.zendesk.com/hc/en-us/articles/360015489331',
  IMPORTED_ACCOUNTS: 'https://metamask.zendesk.com/hc/en-us/articles/360015289932',
  INFURA_BLOCKAGE: 'https://metamask.zendesk.com/hc/en-us/articles/360059386712',
  LEGACY_WEB3: 'https://metamask.zendesk.com/hc/en-us/articles/360053147012',
  NFT_TOKENS: 'https://metamask.zendesk.com/hc/en-us/articles/360058238591-NFT-tokens-in-MetaMask-wallet',
  PASSWORD_ARTICLE: 'https://metamask.zendesk.com/hc/en-us/articles/4404722782107',
  SECRET_RECOVERY_PHRASE: 'https://metamask.zendesk.com/hc/en-us/articles/360060826432-What-is-a-Secret-Recovery-Phrase-and-how-to-keep-your-crypto-wallet-secure',
  SPEEDUP_CANCEL: 'https://metamask.zendesk.com/hc/en-us/articles/360015489251-How-to-speed-up-or-cancel-a-pending-transaction',
  TOKEN_SAFETY_PRACTICES: 'https://metamask.zendesk.com/hc/en-us/articles/4403988839451',
  UNKNOWN_NETWORK: 'https://metamask.zendesk.com/hc/en-us/articles/4417500466971',
  USER_GUIDE_CUSTOM_NETWORKS: 'https://metamask.zendesk.com/hc/en-us/articles/4404424659995',
  USER_GUIDE_DAPPS: 'https://metamask.zendesk.com/hc/en-us/articles/4405506066331-User-guide-Dapps',
  USER_GUIDE_GAS: 'https://metamask.zendesk.com/hc/en-us/articles/4404600179227-User-Guide-Gas',
  VERIFY_CUSTOM_NETWORK: 'https://metamask.zendesk.com/hc/en-us/articles/360057142392'
};
var _default = ZENDESK_URLS;
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js", {"../../../app/scripts/lib/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","../../selectors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","currency-formatter":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\currency-formatter\\index.js","currency-formatter/currencies":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\currency-formatter\\currencies.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\confirm-tx.util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addEth = addEth;
exports.addFiat = addFiat;
exports.areDappSuggestedAndTxParamGasFeesTheSame = areDappSuggestedAndTxParamGasFeesTheSame;
exports.convertTokenToFiat = convertTokenToFiat;
exports.formatCurrency = formatCurrency;
exports.getHexGasTotal = getHexGasTotal;
exports.getTransactionFee = getTransactionFee;
exports.getValueFromWeiHex = getValueFromWeiHex;
exports.hasUnconfirmedTransactions = hasUnconfirmedTransactions;
exports.hexGreaterThan = hexGreaterThan;
exports.increaseLastGasPrice = increaseLastGasPrice;
exports.roundExponential = roundExponential;

var _currencyFormatter = _interopRequireDefault(require("currency-formatter"));

var _currencies = _interopRequireDefault(require("currency-formatter/currencies"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var _util = require("../../../app/scripts/lib/util");

var _selectors = require("../../selectors");

var _conversion = require("../../../shared/modules/conversion.utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function increaseLastGasPrice(lastGasPrice) {
  return (0, _util.addHexPrefix)((0, _conversion.multiplyCurrencies)(lastGasPrice || '0x0', 1.1, {
    multiplicandBase: 16,
    multiplierBase: 10,
    toNumericBase: 'hex'
  }));
}

function hexGreaterThan(a, b) {
  return (0, _conversion.conversionGreaterThan)({
    value: a,
    fromNumericBase: 'hex'
  }, {
    value: b,
    fromNumericBase: 'hex'
  });
}

function getHexGasTotal({
  gasLimit,
  gasPrice
}) {
  return (0, _util.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit || '0x0', gasPrice || '0x0', {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 16
  }));
}

function addEth(...args) {
  return args.reduce((acc, ethAmount) => {
    return (0, _conversion.addCurrencies)(acc, ethAmount, {
      toNumericBase: 'dec',
      numberOfDecimals: 6,
      aBase: 10,
      bBase: 10
    });
  });
}

function addFiat(...args) {
  return args.reduce((acc, fiatAmount) => {
    return (0, _conversion.addCurrencies)(acc, fiatAmount, {
      toNumericBase: 'dec',
      numberOfDecimals: 2,
      aBase: 10,
      bBase: 10
    });
  });
}

function getValueFromWeiHex({
  value,
  fromCurrency = 'ETH',
  toCurrency,
  conversionRate,
  numberOfDecimals,
  toDenomination
}) {
  return (0, _conversion.conversionUtil)(value, {
    fromNumericBase: 'hex',
    toNumericBase: 'dec',
    fromCurrency,
    toCurrency,
    numberOfDecimals,
    fromDenomination: 'WEI',
    toDenomination,
    conversionRate
  });
}

function getTransactionFee({
  value,
  fromCurrency = 'ETH',
  toCurrency,
  conversionRate,
  numberOfDecimals
}) {
  return (0, _conversion.conversionUtil)(value, {
    fromNumericBase: 'BN',
    toNumericBase: 'dec',
    fromDenomination: 'WEI',
    fromCurrency,
    toCurrency,
    numberOfDecimals,
    conversionRate
  });
}

function formatCurrency(value, currencyCode) {
  const upperCaseCurrencyCode = currencyCode.toUpperCase();
  return _currencies.default.find(currency => currency.code === upperCaseCurrencyCode) ? _currencyFormatter.default.format(Number(value), {
    code: upperCaseCurrencyCode,
    style: 'currency'
  }) : value;
}

function convertTokenToFiat({
  value,
  fromCurrency = 'ETH',
  toCurrency,
  conversionRate,
  contractExchangeRate
}) {
  const totalExchangeRate = conversionRate * contractExchangeRate;
  return (0, _conversion.conversionUtil)(value, {
    fromNumericBase: 'dec',
    toNumericBase: 'dec',
    fromCurrency,
    toCurrency,
    numberOfDecimals: 2,
    conversionRate: totalExchangeRate
  });
}

function hasUnconfirmedTransactions(state) {
  return (0, _selectors.unconfirmedTransactionsCountSelector)(state) > 0;
}
/**
 * Rounds the given decimal string to 4 significant digits.
 *
 * @param {string} decimalString - The base-ten number to round.
 * @returns {string} The rounded number, or the original number if no
 * rounding was necessary.
 */


function roundExponential(decimalString) {
  const PRECISION = 4;
  const bigNumberValue = new _bignumber.default(decimalString); // In JS, numbers with exponentials greater than 20 get displayed as an exponential.

  return bigNumberValue.e > 20 ? bigNumberValue.toPrecision(PRECISION) : decimalString;
}

function areDappSuggestedAndTxParamGasFeesTheSame(txData = {}) {
  const {
    txParams,
    dappSuggestedGasFees
  } = txData;
  const {
    gasPrice: txParamsGasPrice,
    maxFeePerGas: txParamsMaxFeePerGas,
    maxPriorityFeePerGas: txParamsMaxPriorityFeePerGas
  } = txParams || {};
  const {
    gasPrice: dappGasPrice,
    maxFeePerGas: dappMaxFeePerGas,
    maxPriorityFeePerGas: dappMaxPriorityFeePerGas
  } = dappSuggestedGasFees || {};
  const txParamsDoesNotHaveFeeProperties = !txParamsGasPrice && !txParamsMaxFeePerGas && !txParamsMaxPriorityFeePerGas;
  const dappDidNotSuggestFeeProperties = !dappGasPrice && !dappMaxFeePerGas && !dappMaxPriorityFeePerGas;

  if (txParamsDoesNotHaveFeeProperties || dappDidNotSuggestFeeProperties) {
    return false;
  }

  const txParamsGasPriceMatchesDappSuggestedGasPrice = txParamsGasPrice && txParamsGasPrice === dappGasPrice;
  const txParamsEIP1559FeesMatchDappSuggestedGasPrice = [txParamsMaxFeePerGas, txParamsMaxPriorityFeePerGas].every(fee => fee === dappGasPrice);
  const txParamsEIP1559FeesMatchDappSuggestedEIP1559Fees = txParamsMaxFeePerGas && txParamsMaxFeePerGas === dappMaxFeePerGas && txParamsMaxPriorityFeePerGas === dappMaxPriorityFeePerGas;
  return txParamsGasPriceMatchesDappSuggestedGasPrice || txParamsEIP1559FeesMatchDappSuggestedGasPrice || txParamsEIP1559FeesMatchDappSuggestedEIP1559Fees;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\conversions.util.js", {"../../../app/scripts/lib/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","../constants/common":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js","./confirm-tx.util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\conversions.util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addHexWEIsToDec = addHexWEIsToDec;
exports.addHexes = addHexes;
exports.bnToHex = bnToHex;
exports.decETHToDecWEI = decETHToDecWEI;
exports.decEthToConvertedCurrency = decEthToConvertedCurrency;
exports.decGWEIToHexWEI = decGWEIToHexWEI;
exports.decWEIToDecETH = decWEIToDecETH;
exports.getEthConversionFromWeiHex = getEthConversionFromWeiHex;
exports.getValueFromWeiHex = getValueFromWeiHex;
exports.getWeiHexFromDecimalValue = getWeiHexFromDecimalValue;
exports.hexWEIToDecETH = hexWEIToDecETH;
exports.subtractHexWEIsToDec = subtractHexWEIsToDec;
exports.subtractHexes = subtractHexes;
exports.sumHexWEIs = sumHexWEIs;
exports.sumHexWEIsToRenderableFiat = sumHexWEIsToRenderableFiat;
exports.sumHexWEIsToUnformattedFiat = sumHexWEIsToUnformattedFiat;

var _common = require("../constants/common");

var _util = require("../../../app/scripts/lib/util");

var _conversion = require("../../../shared/modules/conversion.utils");

var _confirmTx = require("./confirm-tx.util");

function bnToHex(inputBn) {
  return (0, _util.addHexPrefix)(inputBn.toString(16));
}

function getEthConversionFromWeiHex({
  value,
  fromCurrency = _common.ETH,
  conversionRate,
  numberOfDecimals = 6
}) {
  const denominations = [fromCurrency, _common.GWEI, _common.WEI];
  let nonZeroDenomination;

  for (let i = 0; i < denominations.length; i++) {
    const convertedValue = getValueFromWeiHex({
      value,
      conversionRate,
      fromCurrency,
      toCurrency: fromCurrency,
      numberOfDecimals,
      toDenomination: denominations[i]
    });

    if (convertedValue !== '0' || i === denominations.length - 1) {
      nonZeroDenomination = `${convertedValue} ${denominations[i]}`;
      break;
    }
  }

  return nonZeroDenomination;
}

function getValueFromWeiHex({
  value,
  fromCurrency = _common.ETH,
  toCurrency,
  conversionRate,
  numberOfDecimals,
  toDenomination
}) {
  return (0, _conversion.conversionUtil)(value, {
    fromNumericBase: 'hex',
    toNumericBase: 'dec',
    fromCurrency,
    toCurrency,
    numberOfDecimals,
    fromDenomination: _common.WEI,
    toDenomination,
    conversionRate
  });
}

function getWeiHexFromDecimalValue({
  value,
  fromCurrency,
  conversionRate,
  fromDenomination,
  invertConversionRate
}) {
  return (0, _conversion.conversionUtil)(value, {
    fromNumericBase: 'dec',
    toNumericBase: 'hex',
    toCurrency: _common.ETH,
    fromCurrency,
    conversionRate,
    invertConversionRate,
    fromDenomination,
    toDenomination: _common.WEI
  });
}

function addHexWEIsToDec(aHexWEI, bHexWEI) {
  return (0, _conversion.addCurrencies)(aHexWEI, bHexWEI, {
    aBase: 16,
    bBase: 16,
    fromDenomination: 'WEI',
    numberOfDecimals: 6
  });
}

function subtractHexWEIsToDec(aHexWEI, bHexWEI) {
  return (0, _conversion.subtractCurrencies)(aHexWEI, bHexWEI, {
    aBase: 16,
    bBase: 16,
    fromDenomination: 'WEI',
    numberOfDecimals: 6
  });
}

function decEthToConvertedCurrency(ethTotal, convertedCurrency, conversionRate) {
  return (0, _conversion.conversionUtil)(ethTotal, {
    fromNumericBase: 'dec',
    toNumericBase: 'dec',
    fromCurrency: 'ETH',
    toCurrency: convertedCurrency,
    numberOfDecimals: 2,
    conversionRate
  });
}

function decGWEIToHexWEI(decGWEI) {
  return (0, _conversion.conversionUtil)(decGWEI, {
    fromNumericBase: 'dec',
    toNumericBase: 'hex',
    fromDenomination: 'GWEI',
    toDenomination: 'WEI'
  });
}

function decETHToDecWEI(decEth) {
  return (0, _conversion.conversionUtil)(decEth, {
    fromNumericBase: 'dec',
    toNumericBase: 'dec',
    fromDenomination: 'ETH',
    toDenomination: 'WEI'
  });
}

function hexWEIToDecETH(hexWEI) {
  return (0, _conversion.conversionUtil)(hexWEI, {
    fromNumericBase: 'hex',
    toNumericBase: 'dec',
    fromDenomination: 'WEI',
    toDenomination: 'ETH'
  });
}

function decWEIToDecETH(hexWEI) {
  return (0, _conversion.conversionUtil)(hexWEI, {
    fromNumericBase: 'dec',
    toNumericBase: 'dec',
    fromDenomination: 'WEI',
    toDenomination: 'ETH'
  });
}

function addHexes(aHexWEI, bHexWEI) {
  return (0, _conversion.addCurrencies)(aHexWEI, bHexWEI, {
    aBase: 16,
    bBase: 16,
    toNumericBase: 'hex',
    numberOfDecimals: 6
  });
}

function subtractHexes(aHexWEI, bHexWEI) {
  return (0, _conversion.subtractCurrencies)(aHexWEI, bHexWEI, {
    aBase: 16,
    bBase: 16,
    toNumericBase: 'hex',
    numberOfDecimals: 6
  });
}

function sumHexWEIs(hexWEIs) {
  return hexWEIs.filter(Boolean).reduce(addHexes);
}

function sumHexWEIsToUnformattedFiat(hexWEIs, convertedCurrency, conversionRate) {
  const hexWEIsSum = sumHexWEIs(hexWEIs);
  const convertedTotal = decEthToConvertedCurrency(getValueFromWeiHex({
    value: hexWEIsSum,
    toCurrency: 'ETH',
    numberOfDecimals: 4
  }), convertedCurrency, conversionRate);
  return convertedTotal;
}

function sumHexWEIsToRenderableFiat(hexWEIs, convertedCurrency, conversionRate) {
  const convertedTotal = sumHexWEIsToUnformattedFiat(hexWEIs, convertedCurrency, conversionRate);
  return (0, _confirmTx.formatCurrency)(convertedTotal, convertedCurrency);
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\formatters.js", {}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\formatters.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatETHFee = formatETHFee;

// TODO: Rename to reflect that this function is used for more cases than ETH, and update all uses.
function formatETHFee(ethFee, currencySymbol = 'ETH') {
  return `${ethFee} ${currencySymbol}`;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\i18n-helper.js", {"../../../shared/modules/fetch-with-timeout":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js","@sentry/browser":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@sentry\\browser\\dist\\index.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\i18n-helper.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchLocale = fetchLocale;
exports.getMessage = void 0;
exports.loadRelativeTimeFormatLocaleData = loadRelativeTimeFormatLocaleData;

var _react = _interopRequireDefault(require("react"));

var _loglevel = _interopRequireDefault(require("loglevel"));

var Sentry = _interopRequireWildcard(require("@sentry/browser"));

var _fetchWithTimeout = _interopRequireDefault(require("../../../shared/modules/fetch-with-timeout"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// cross-browser connection to extension i18n API
const fetchWithTimeout = (0, _fetchWithTimeout.default)();
const warned = {};
const missingMessageErrors = {};
const missingSubstitutionErrors = {};
/**
 * Returns a localized message for the given key
 *
 * @param {string} localeCode - The code for the current locale
 * @param {object} localeMessages - The map of messages for the current locale
 * @param {string} key - The message key
 * @param {string[]} substitutions - A list of message substitution replacements
 * @returns {null|string} The localized message
 */

const getMessage = (localeCode, localeMessages, key, substitutions) => {
  if (!localeMessages) {
    return null;
  }

  if (!localeMessages[key]) {
    if (localeCode === 'en') {
      if (!missingMessageErrors[key]) {
        missingMessageErrors[key] = new Error(`Unable to find value of key "${key}" for locale "${localeCode}"`);
        Sentry.captureException(missingMessageErrors[key]);

        _loglevel.default.error(missingMessageErrors[key]);

        if (false) {
          throw missingMessageErrors[key];
        }
      }
    } else if (!warned[localeCode] || !warned[localeCode][key]) {
      if (!warned[localeCode]) {
        warned[localeCode] = {};
      }

      warned[localeCode][key] = true;

      _loglevel.default.warn(`Translator - Unable to find value of key "${key}" for locale "${localeCode}"`);
    }

    return null;
  }

  const entry = localeMessages[key];
  let phrase = entry.message;
  const hasSubstitutions = Boolean(substitutions && substitutions.length);
  const hasReactSubstitutions = hasSubstitutions && substitutions.some(element => element !== null && (typeof element === 'function' || typeof element === 'object')); // perform substitutions

  if (hasSubstitutions) {
    const parts = phrase.split(/(\$\d)/gu);
    const substitutedParts = parts.map(part => {
      var _missingSubstitutionE;

      const subMatch = part.match(/\$(\d)/u);

      if (!subMatch) {
        return part;
      }

      const substituteIndex = Number(subMatch[1]) - 1;

      if ((substitutions[substituteIndex] === null || substitutions[substituteIndex] === undefined) && !((_missingSubstitutionE = missingSubstitutionErrors[localeCode]) !== null && _missingSubstitutionE !== void 0 && _missingSubstitutionE[key])) {
        if (!missingSubstitutionErrors[localeCode]) {
          missingSubstitutionErrors[localeCode] = {};
        }

        missingSubstitutionErrors[localeCode][key] = true;
        const error = new Error(`Insufficient number of substitutions for key "${key}" with locale "${localeCode}"`);

        _loglevel.default.error(error);

        Sentry.captureException(error);
      }

      return substitutions[substituteIndex];
    });
    phrase = hasReactSubstitutions ? /*#__PURE__*/_react.default.createElement("span", null, " ", substitutedParts, " ") : substitutedParts.join('');
  }

  return phrase;
};

exports.getMessage = getMessage;

async function fetchLocale(localeCode) {
  try {
    const response = await fetchWithTimeout(`./_locales/${localeCode}/messages.json`);
    return await response.json();
  } catch (error) {
    _loglevel.default.error(`failed to fetch ${localeCode} locale because of ${error}`);

    return {};
  }
}

const relativeTimeFormatLocaleData = new Set();

async function loadRelativeTimeFormatLocaleData(localeCode) {
  const languageTag = localeCode.split('_')[0];

  if (Intl.RelativeTimeFormat && typeof Intl.RelativeTimeFormat.__addLocaleData === 'function' && !relativeTimeFormatLocaleData.has(languageTag)) {
    const localeData = await fetchRelativeTimeFormatData(languageTag);

    Intl.RelativeTimeFormat.__addLocaleData(localeData);
  }
}

async function fetchRelativeTimeFormatData(languageTag) {
  const response = await fetchWithTimeout(`./intl/${languageTag}/relative-time-format-data.json`);
  return await response.json();
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\moonpay.js", {"../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\moonpay.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatMoonpaySymbol = void 0;

var _network = require("../../../shared/constants/network");

const formatMoonpaySymbol = (symbol, chainId = _network.CHAIN_IDS.MAINNET) => {
  if (!symbol) {
    return symbol;
  }

  let _symbol = symbol;

  if (chainId === _network.CHAIN_IDS.POLYGON || chainId === _network.CHAIN_IDS.BSC) {
    var _BUYABLE_CHAINS_MAP$c;

    _symbol = `${_symbol}_${_network.BUYABLE_CHAINS_MAP === null || _network.BUYABLE_CHAINS_MAP === void 0 ? void 0 : (_BUYABLE_CHAINS_MAP$c = _network.BUYABLE_CHAINS_MAP[chainId]) === null || _BUYABLE_CHAINS_MAP$c === void 0 ? void 0 : _BUYABLE_CHAINS_MAP$c.network.toUpperCase()}`;
  } else if (chainId === _network.CHAIN_IDS.AVALANCHE) {
    _symbol = `${_symbol}_CCHAIN`;
  }

  return _symbol;
};

exports.formatMoonpaySymbol = formatMoonpaySymbol;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js", {"../../../../shared/modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","@ethereumjs/common":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js","@ethereumjs/tx":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\optimism\buildUnserializedTransaction.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = buildUnserializedTransaction;

var _lodash = require("lodash");

var _ethereumjsUtil = require("ethereumjs-util");

var _common = _interopRequireWildcard(require("@ethereumjs/common"));

var _tx = require("@ethereumjs/tx");

var _hexstringUtils = require("../../../../shared/modules/hexstring-utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function buildTxParams(txMeta) {
  return { ...(0, _lodash.omit)(txMeta.txParams, 'gas'),
    gasLimit: txMeta.txParams.gas
  };
}

function buildTransactionCommon(txMeta) {
  // This produces a transaction whose information does not completely match an
  // Optimism transaction  for instance, DEFAULT_CHAIN is still 'mainnet' and
  // genesis points to the mainnet genesis, not the Optimism genesis  but
  // considering that all we want to do is serialize a transaction, this works
  // fine for our use case.
  return _common.default.forCustomChain(_common.Chain.Mainnet, {
    chainId: new _ethereumjsUtil.BN((0, _hexstringUtils.stripHexPrefix)(txMeta.chainId), 16),
    networkId: new _ethereumjsUtil.BN(txMeta.metamaskNetworkId, 10),
    // Optimism only supports type-0 transactions; it does not support any of
    // the newer EIPs since EIP-155. Source:
    // <https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md>
    defaultHardfork: _common.Hardfork.SpuriousDragon
  });
}

function buildUnserializedTransaction(txMeta) {
  const txParams = buildTxParams(txMeta);
  const common = buildTransactionCommon(txMeta);
  return _tx.TransactionFactory.fromTxData(txParams, {
    common
  });
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js", {"./buildUnserializedTransaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js","@eth-optimism/contracts/dist/contract-defs":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@eth-optimism\\contracts\\dist\\contract-defs.js","@eth-optimism/contracts/dist/predeploys":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@eth-optimism\\contracts\\dist\\predeploys.js","ethers":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\optimism\fetchEstimatedL1Fee.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = fetchEstimatedL1Fee;

var ethers = _interopRequireWildcard(require("ethers"));

var _contractDefs = require("@eth-optimism/contracts/dist/contract-defs");

var _predeploys = require("@eth-optimism/contracts/dist/predeploys");

var _buildUnserializedTransaction = _interopRequireDefault(require("./buildUnserializedTransaction"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// The code in this file is largely drawn from https://community.optimism.io/docs/developers/l2/new-fees.html#for-frontend-and-wallet-developers
function buildOVMGasPriceOracleContract(eth) {
  const OVMGasPriceOracle = (0, _contractDefs.getContractFactory)('OVM_GasPriceOracle').attach(_predeploys.predeploys.OVM_GasPriceOracle);
  const abi = JSON.parse(OVMGasPriceOracle.interface.format(ethers.utils.FormatTypes.json));
  return eth.contract(abi).at(OVMGasPriceOracle.address);
}

async function fetchEstimatedL1Fee(eth, txMeta) {
  var _result$;

  const contract = buildOVMGasPriceOracleContract(eth);
  const serializedTransaction = (0, _buildUnserializedTransaction.default)(txMeta).serialize();
  const result = await contract.getL1Fee(serializedTransaction);
  return result === null || result === void 0 ? void 0 : (_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.toString(16);
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\token-util.js", {"../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../../../shared/lib/metamask-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\metamask-controller-utils.js","../../../shared/lib/transactions-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","../../../shared/modules/string-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js","../../../shared/modules/transaction.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js","../../store/actions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js","./confirm-tx.util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js","./util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\token-util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAssetDetails = getAssetDetails;
exports.getSymbolAndDecimals = getSymbolAndDecimals;
exports.getTokenAddressParam = getTokenAddressParam;
exports.getTokenApprovedParam = getTokenApprovedParam;
exports.getTokenFiatAmount = getTokenFiatAmount;
exports.getTokenIdParam = getTokenIdParam;
exports.getTokenMetadata = getTokenMetadata;
exports.tokenInfoGetter = tokenInfoGetter;

var _loglevel = _interopRequireDefault(require("loglevel"));

var _conversion = require("../../../shared/modules/conversion.utils");

var _actions = require("../../store/actions");

var _stringUtils = require("../../../shared/modules/string-utils");

var _transaction = require("../../../shared/modules/transaction.utils");

var _transaction2 = require("../../../shared/constants/transaction");

var _metamaskControllerUtils = require("../../../shared/lib/metamask-controller-utils");

var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

var util = _interopRequireWildcard(require("./util"));

var _confirmTx = require("./confirm-tx.util");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const DEFAULT_SYMBOL = '';

async function getSymbolFromContract(tokenAddress) {
  const token = util.getContractAtAddress(tokenAddress);

  try {
    const result = await token.symbol();
    return result[0];
  } catch (error) {
    _loglevel.default.warn(`symbol() call for token at address ${tokenAddress} resulted in error:`, error);

    return undefined;
  }
}

async function getDecimalsFromContract(tokenAddress) {
  const token = util.getContractAtAddress(tokenAddress);

  try {
    const result = await token.decimals();
    const decimalsBN = result[0];
    return decimalsBN === null || decimalsBN === void 0 ? void 0 : decimalsBN.toString();
  } catch (error) {
    _loglevel.default.warn(`decimals() call for token at address ${tokenAddress} resulted in error:`, error);

    return undefined;
  }
}

function getTokenMetadata(tokenAddress, tokenList) {
  return tokenAddress && tokenList[tokenAddress.toLowerCase()];
}

async function getSymbol(tokenAddress, tokenList) {
  let symbol = await getSymbolFromContract(tokenAddress);

  if (!symbol) {
    const contractMetadataInfo = getTokenMetadata(tokenAddress, tokenList);

    if (contractMetadataInfo) {
      symbol = contractMetadataInfo.symbol;
    }
  }

  return symbol;
}

async function getDecimals(tokenAddress, tokenList) {
  let decimals = await getDecimalsFromContract(tokenAddress);

  if (!decimals || decimals === '0') {
    const contractMetadataInfo = getTokenMetadata(tokenAddress, tokenList);

    if (contractMetadataInfo) {
      var _contractMetadataInfo;

      decimals = (_contractMetadataInfo = contractMetadataInfo.decimals) === null || _contractMetadataInfo === void 0 ? void 0 : _contractMetadataInfo.toString();
    }
  }

  return decimals;
}

async function getSymbolAndDecimals(tokenAddress, tokenList) {
  let symbol, decimals;

  try {
    symbol = await getSymbol(tokenAddress, tokenList);
    decimals = await getDecimals(tokenAddress, tokenList);
  } catch (error) {
    _loglevel.default.warn(`symbol() and decimal() calls for token at address ${tokenAddress} resulted in error:`, error);
  }

  return {
    symbol: symbol || DEFAULT_SYMBOL,
    decimals
  };
}

function tokenInfoGetter() {
  const tokens = {};
  return async (address, tokenList) => {
    if (tokens[address]) {
      return tokens[address];
    }

    tokens[address] = await getSymbolAndDecimals(address, tokenList);
    return tokens[address];
  };
}
/**
 * Attempts to get the address parameter of the given token transaction data
 * (i.e. function call) per the Human Standard Token ABI, in the following
 * order:
 *   - The '_to' parameter, if present
 *   - The first parameter, if present
 *
 * @param {object} tokenData - ethers Interface token data.
 * @returns {string | undefined} A lowercase address string.
 */


function getTokenAddressParam(tokenData = {}) {
  var _tokenData$args, _tokenData$args2, _tokenData$args3;

  const value = (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : _tokenData$args._to) || (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args2 = tokenData.args) === null || _tokenData$args2 === void 0 ? void 0 : _tokenData$args2.to) || (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args3 = tokenData.args) === null || _tokenData$args3 === void 0 ? void 0 : _tokenData$args3[0]);
  return value === null || value === void 0 ? void 0 : value.toString().toLowerCase();
}
/**
 * Gets the '_value' parameter of the given token transaction data
 * (i.e function call) per the Human Standard Token ABI, if present.
 *
 * @param {object} tokenData - ethers Interface token data.
 * @returns {string | undefined} A decimal string value.
 */

/**
 * Gets either the '_tokenId' parameter or the 'id' param of the passed token transaction data.,
 * These are the parsed tokenId values returned by `parseStandardTokenTransactionData` as defined
 * in the ERC721 and ERC1155 ABIs from metamask-eth-abis (https://github.com/MetaMask/metamask-eth-abis/tree/main/src/abis)
 *
 * @param {object} tokenData - ethers Interface token data.
 * @returns {string | undefined} A decimal string value.
 */


function getTokenIdParam(tokenData = {}) {
  var _tokenData$args$_toke, _tokenData$args4, _tokenData$args4$_tok, _tokenData$args5, _tokenData$args5$id;

  return (_tokenData$args$_toke = tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args4 = tokenData.args) === null || _tokenData$args4 === void 0 ? void 0 : (_tokenData$args4$_tok = _tokenData$args4._tokenId) === null || _tokenData$args4$_tok === void 0 ? void 0 : _tokenData$args4$_tok.toString()) !== null && _tokenData$args$_toke !== void 0 ? _tokenData$args$_toke : tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args5 = tokenData.args) === null || _tokenData$args5 === void 0 ? void 0 : (_tokenData$args5$id = _tokenData$args5.id) === null || _tokenData$args5$id === void 0 ? void 0 : _tokenData$args5$id.toString();
}
/**
 * Gets the '_approved' parameter of the given token transaction data
 * (i.e function call) per the Human Standard Token ABI, if present.
 *
 * @param {object} tokenData - ethers Interface token data.
 * @returns {boolean | undefined} A boolean indicating whether the function is being called to approve or revoke access.
 */


function getTokenApprovedParam(tokenData = {}) {
  var _tokenData$args6;

  return tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args6 = tokenData.args) === null || _tokenData$args6 === void 0 ? void 0 : _tokenData$args6._approved;
}
/**
 * Get the token balance converted to fiat and optionally formatted for display
 *
 * @param {number} [contractExchangeRate] - The exchange rate between the current token and the native currency
 * @param {number} conversionRate - The exchange rate between the current fiat currency and the native currency
 * @param {string} currentCurrency - The currency code for the user's chosen fiat currency
 * @param {string} [tokenAmount] - The current token balance
 * @param {string} [tokenSymbol] - The token symbol
 * @param {boolean} [formatted] - Whether the return value should be formatted or not
 * @param {boolean} [hideCurrencySymbol] - excludes the currency symbol in the result if true
 * @returns {string|undefined} The token amount in the user's chosen fiat currency, optionally formatted and localize
 */


function getTokenFiatAmount(contractExchangeRate, conversionRate, currentCurrency, tokenAmount, tokenSymbol, formatted = true, hideCurrencySymbol = false) {
  // If the conversionRate is 0 (i.e. unknown) or the contract exchange rate
  // is currently unknown, the fiat amount cannot be calculated so it is not
  // shown to the user
  if (conversionRate <= 0 || !contractExchangeRate || tokenAmount === undefined) {
    return undefined;
  }

  const currentTokenToFiatRate = (0, _conversion.multiplyCurrencies)(contractExchangeRate, conversionRate, {
    multiplicandBase: 10,
    multiplierBase: 10
  });
  const currentTokenInFiat = (0, _conversion.conversionUtil)(tokenAmount, {
    fromNumericBase: 'dec',
    fromCurrency: tokenSymbol,
    toCurrency: currentCurrency.toUpperCase(),
    numberOfDecimals: 2,
    conversionRate: currentTokenToFiatRate
  });
  let result;

  if (hideCurrencySymbol) {
    result = (0, _confirmTx.formatCurrency)(currentTokenInFiat, currentCurrency);
  } else if (formatted) {
    result = `${(0, _confirmTx.formatCurrency)(currentTokenInFiat, currentCurrency)} ${currentCurrency.toUpperCase()}`;
  } else {
    result = currentTokenInFiat;
  }

  return result;
}

async function getAssetDetails(tokenAddress, currentUserAddress, transactionData, existingCollectibles) {
  var _getTokenIdParam$toSt, _getTokenIdParam, _tokenDetails, _tokenDetails2, _tokenDetails3, _tokenDetails$decimal, _tokenDetails4;

  const tokenData = (0, _transaction.parseStandardTokenTransactionData)(transactionData);

  if (!tokenData) {
    throw new Error('Unable to detect valid token data');
  } // Sometimes the tokenId value is parsed as "_value" param. Not seeing this often any more, but still occasionally:
  // i.e. call approve() on BAYC contract - https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#writeContract, and tokenId shows up as _value,
  // not sure why since it doesn't match the ERC721 ABI spec we use to parse these transactions - https://github.com/MetaMask/metamask-eth-abis/blob/d0474308a288f9252597b7c93a3a8deaad19e1b2/src/abis/abiERC721.ts#L62.


  let tokenId = (_getTokenIdParam$toSt = (_getTokenIdParam = getTokenIdParam(tokenData)) === null || _getTokenIdParam === void 0 ? void 0 : _getTokenIdParam.toString()) !== null && _getTokenIdParam$toSt !== void 0 ? _getTokenIdParam$toSt : (0, _metamaskControllerUtils.getTokenValueParam)(tokenData);
  const toAddress = getTokenAddressParam(tokenData);
  let tokenDetails; // if a tokenId is present check if there is a collectible in state matching the address/tokenId
  // and avoid unnecessary network requests to query token details we already have

  if (existingCollectibles !== null && existingCollectibles !== void 0 && existingCollectibles.length && tokenId) {
    const existingCollectible = existingCollectibles.find(({
      address,
      tokenId: _tokenId
    }) => (0, _stringUtils.isEqualCaseInsensitive)(tokenAddress, address) && _tokenId === tokenId);

    if (existingCollectible) {
      return {
        toAddress,
        ...existingCollectible
      };
    }
  }

  try {
    tokenDetails = await (0, _actions.getTokenStandardAndDetails)(tokenAddress, currentUserAddress, tokenId);
  } catch (error) {
    _loglevel.default.warn(error); // if we can't determine any token standard or details return the data we can extract purely from the parsed transaction data


    return {
      toAddress,
      tokenId
    };
  }

  const tokenAmount = tokenData && ((_tokenDetails = tokenDetails) === null || _tokenDetails === void 0 ? void 0 : _tokenDetails.decimals) && (0, _transactionsControllerUtils.calcTokenAmount)((0, _metamaskControllerUtils.getTokenValueParam)(tokenData), (_tokenDetails2 = tokenDetails) === null || _tokenDetails2 === void 0 ? void 0 : _tokenDetails2.decimals).toString(10);
  const decimals = ((_tokenDetails3 = tokenDetails) === null || _tokenDetails3 === void 0 ? void 0 : _tokenDetails3.decimals) && Number((_tokenDetails$decimal = tokenDetails.decimals) === null || _tokenDetails$decimal === void 0 ? void 0 : _tokenDetails$decimal.toString(10));

  if (((_tokenDetails4 = tokenDetails) === null || _tokenDetails4 === void 0 ? void 0 : _tokenDetails4.standard) === _transaction2.ERC20) {
    tokenId = undefined;
  } // else if not a collectible already in state or standard === ERC20 return tokenDetails and tokenId


  return {
    tokenAmount,
    toAddress,
    decimals,
    tokenId,
    ...tokenDetails
  };
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\transactions.util.js", {"../../../app/scripts/lib/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js","../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../../../shared/lib/fetch-with-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js","../../../shared/modules/contract-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","eth-method-registry":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-method-registry\\dist\\index.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\transactions.util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getFourBytePrefix = getFourBytePrefix;
exports.getLatestSubmittedTxWithNonce = getLatestSubmittedTxWithNonce;
exports.getMethodDataAsync = getMethodDataAsync;
exports.getStatusKey = getStatusKey;
exports.getTransactionTypeTitle = getTransactionTypeTitle;
exports.isLegacyTransaction = isLegacyTransaction;
exports.isSmartContractAddress = isSmartContractAddress;
exports.isTokenMethodAction = isTokenMethodAction;
exports.sumHexes = sumHexes;

var _ethMethodRegistry = require("eth-method-registry");

var _loglevel = _interopRequireDefault(require("loglevel"));

var _util = require("../../../app/scripts/lib/util");

var _transaction = require("../../../shared/constants/transaction");

var _conversion = require("../../../shared/modules/conversion.utils");

var _contractUtils = require("../../../shared/modules/contract-utils");

var _fetchWithCache = _interopRequireDefault(require("../../../shared/lib/fetch-with-cache"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef EthersContractCall
 * @type object
 * @property {any[]} args - The args/params to the function call.
 * An array-like object with numerical and string indices.
 * @property {string} name - The name of the function.
 * @property {string} signature - The function signature.
 * @property {string} sighash - The function signature hash.
 * @property {EthersBigNumber} value - The ETH value associated with the call.
 * @property {FunctionFragment} functionFragment - The Ethers function fragment
 * representation of the function.
 */
async function getMethodFrom4Byte(fourBytePrefix) {
  const fourByteResponse = await (0, _fetchWithCache.default)(`https://www.4byte.directory/api/v1/signatures/?hex_signature=${fourBytePrefix}`, {
    referrerPolicy: 'no-referrer-when-downgrade',
    body: null,
    method: 'GET',
    mode: 'cors'
  });
  fourByteResponse.results.sort((a, b) => {
    return new Date(a.created_at).getTime() < new Date(b.created_at).getTime() ? -1 : 1;
  });
  return fourByteResponse.results[0].text_signature;
}

let registry;
/**
 * Attempts to return the method data from the MethodRegistry library, the message registry library and the token abi, in that order of preference
 *
 * @param {string} fourBytePrefix - The prefix from the method code associated with the data
 * @returns {object}
 */

async function getMethodDataAsync(fourBytePrefix) {
  try {
    const fourByteSig = await getMethodFrom4Byte(fourBytePrefix).catch(e => {
      _loglevel.default.error(e);

      return null;
    });

    if (!registry) {
      registry = new _ethMethodRegistry.MethodRegistry({
        provider: global.ethereumProvider
      });
    }

    if (!fourByteSig) {
      return {};
    }

    const parsedResult = registry.parse(fourByteSig);
    return {
      name: parsedResult.name,
      params: parsedResult.args
    };
  } catch (error) {
    _loglevel.default.error(error);

    return {};
  }
}
/**
 * Returns four-byte method signature from data
 *
 * @param {string} data - The hex data (@code txParams.data) of a transaction
 * @returns {string} The four-byte method signature
 */


function getFourBytePrefix(data = '') {
  const prefixedData = (0, _util.addHexPrefix)(data);
  const fourBytePrefix = prefixedData.slice(0, 10);
  return fourBytePrefix;
}
/**
 * Given an transaction category, returns a boolean which indicates whether the transaction is calling an erc20 token method
 *
 * @param {TRANSACTION_TYPES[keyof TRANSACTION_TYPES]} type - The type of transaction being evaluated
 * @returns {boolean} whether the transaction is calling an erc20 token method
 */


function isTokenMethodAction(type) {
  return [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM].includes(type);
}

function getLatestSubmittedTxWithNonce(transactions = [], nonce = '0x0') {
  if (!transactions.length) {
    return {};
  }

  return transactions.reduce((acc, current) => {
    const {
      submittedTime,
      txParams: {
        nonce: currentNonce
      } = {}
    } = current;

    if (currentNonce === nonce) {
      if (!acc.submittedTime) {
        return current;
      }

      return submittedTime > acc.submittedTime ? current : acc;
    }

    return acc;
  }, {});
}

async function isSmartContractAddress(address) {
  const {
    isContractAddress
  } = await (0, _contractUtils.readAddressAsContract)(global.eth, address);
  return isContractAddress;
}

function sumHexes(...args) {
  const total = args.reduce((acc, hexAmount) => {
    return (0, _conversion.addCurrencies)(acc, hexAmount, {
      toNumericBase: 'hex',
      aBase: 16,
      bBase: 16
    });
  });
  return (0, _util.addHexPrefix)(total);
}

function isLegacyTransaction(txParams) {
  return (txParams === null || txParams === void 0 ? void 0 : txParams.type) === _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
}
/**
 * Returns a status key for a transaction. Requires parsing the txMeta.txReceipt on top of
 * txMeta.status because txMeta.status does not reflect on-chain errors.
 *
 * @param {object} transaction - The txMeta object of a transaction.
 * @param {object} transaction.txReceipt - The transaction receipt.
 * @returns {string}
 */


function getStatusKey(transaction) {
  const {
    txReceipt: {
      status: receiptStatus
    } = {},
    type,
    status
  } = transaction; // There was an on-chain failure

  if (receiptStatus === '0x0') {
    return _transaction.TRANSACTION_STATUSES.FAILED;
  }

  if (status === _transaction.TRANSACTION_STATUSES.CONFIRMED && type === _transaction.TRANSACTION_TYPES.CANCEL) {
    return _transaction.TRANSACTION_GROUP_STATUSES.CANCELLED;
  }

  return transaction.status;
}
/**
 * Returns a title for the given transaction category.
 *
 * This will throw an error if the transaction category is unrecognized and no default is provided.
 *
 * @param {Function} t - The translation function
 * @param {TRANSACTION_TYPES[keyof TRANSACTION_TYPES]} type - The transaction type constant
 * @param {string} nativeCurrency - The native currency of the currently selected network
 * @returns {string} The transaction category title
 */


function getTransactionTypeTitle(t, type, nativeCurrency = 'ETH') {
  switch (type) {
    case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER:
      {
        return t('transfer');
      }

    case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM:
      {
        return t('transferFrom');
      }

    case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM:
      {
        return t('safeTransferFrom');
      }

    case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE:
      {
        return t('approve');
      }

    case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL:
      {
        return t('setApprovalForAll');
      }

    case _transaction.TRANSACTION_TYPES.SIMPLE_SEND:
      {
        return t('sendingNativeAsset', [nativeCurrency]);
      }

    case _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION:
      {
        return t('contractInteraction');
      }

    case _transaction.TRANSACTION_TYPES.DEPLOY_CONTRACT:
      {
        return t('contractDeployment');
      }

    case _transaction.TRANSACTION_TYPES.SWAP:
      {
        return t('swap');
      }

    case _transaction.TRANSACTION_TYPES.SWAP_APPROVAL:
      {
        return t('swapApproval');
      }

    default:
      {
        throw new Error(`Unrecognized transaction type: ${type}`);
      }
  }
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\tx-helper.js", {"../../../shared/modules/transaction.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js","./util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js","loglevel":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\tx-helper.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = txHelper;

var _loglevel = _interopRequireDefault(require("loglevel"));

var _transaction = require("../../../shared/modules/transaction.utils");

var _util = require("./util");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function txHelper(unapprovedTxs, unapprovedMsgs, personalMsgs, decryptMsgs, encryptionPublicKeyMsgs, typedMessages, network, chainId) {
  _loglevel.default.debug('tx-helper called with params:');

  _loglevel.default.debug({
    unapprovedTxs,
    unapprovedMsgs,
    personalMsgs,
    decryptMsgs,
    encryptionPublicKeyMsgs,
    typedMessages,
    network,
    chainId
  });

  const txValues = network ? (0, _util.valuesFor)(unapprovedTxs).filter(txMeta => (0, _transaction.transactionMatchesNetwork)(txMeta, chainId, network)) : (0, _util.valuesFor)(unapprovedTxs);

  _loglevel.default.debug(`tx helper found ${txValues.length} unapproved txs`);

  const msgValues = (0, _util.valuesFor)(unapprovedMsgs);

  _loglevel.default.debug(`tx helper found ${msgValues.length} unsigned messages`);

  let allValues = txValues.concat(msgValues);
  const personalValues = (0, _util.valuesFor)(personalMsgs);

  _loglevel.default.debug(`tx helper found ${personalValues.length} unsigned personal messages`);

  allValues = allValues.concat(personalValues);
  const decryptValues = (0, _util.valuesFor)(decryptMsgs);

  _loglevel.default.debug(`tx helper found ${decryptValues.length} decrypt requests`);

  allValues = allValues.concat(decryptValues);
  const encryptionPublicKeyValues = (0, _util.valuesFor)(encryptionPublicKeyMsgs);

  _loglevel.default.debug(`tx helper found ${encryptionPublicKeyValues.length} encryptionPublicKey requests`);

  allValues = allValues.concat(encryptionPublicKeyValues);
  const typedValues = (0, _util.valuesFor)(typedMessages);

  _loglevel.default.debug(`tx helper found ${typedValues.length} unsigned typed messages`);

  allValues = allValues.concat(typedValues);
  allValues = allValues.sort((a, b) => {
    return a.time - b.time;
  });
  return allValues;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js", {"../../../shared/constants/labels":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\labels.js","../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","../../../shared/modules/hexstring-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js","@metamask/controllers/dist/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\controllers\\dist\\util.js","@metamask/slip44":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\slip44\\slip44.json","bignumber.js":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js","ethereumjs-util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js","human-standard-token-abi":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\human-standard-token-abi\\index.js","luxon":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\luxon\\build\\cjs-browser\\luxon.js","punycode/punycode":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\punycode\\punycode.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\util.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addressSummary = addressSummary;
exports.bnGreaterThan = bnGreaterThan;
exports.bnGreaterThanEqualTo = bnGreaterThanEqualTo;
exports.bnLessThan = bnLessThan;
exports.bnLessThanEqualTo = bnLessThanEqualTo;
exports.checkExistingAddresses = checkExistingAddresses;
exports.clearClipboard = clearClipboard;
exports.coinTypeToProtocolName = coinTypeToProtocolName;
exports.formatBalance = formatBalance;
exports.formatDate = formatDate;
exports.formatDateWithYearContext = formatDateWithYearContext;
exports.getAccountByAddress = getAccountByAddress;
exports.getAssetImageURL = getAssetImageURL;
exports.getContractAtAddress = getContractAtAddress;
exports.getRandomFileName = getRandomFileName;
exports.getURL = getURL;
exports.getURLHost = getURLHost;
exports.getURLHostName = getURLHostName;
exports.isDefaultMetaMaskChain = isDefaultMetaMaskChain;
exports.isExtensionUrl = isExtensionUrl;
exports.isNullish = isNullish;
exports.isOriginContractAddress = isOriginContractAddress;
exports.isValidDomainName = isValidDomainName;
exports.numericBalance = numericBalance;
exports.parseBalance = parseBalance;
exports.roundToDecimalPlacesRemovingExtraZeroes = roundToDecimalPlacesRemovingExtraZeroes;
exports.sanitizeMessage = void 0;
exports.shortenAddress = shortenAddress;
exports.stripHttpSchemes = stripHttpSchemes;
exports.stripHttpsScheme = stripHttpsScheme;
exports.stripHttpsSchemeWithoutPort = stripHttpsSchemeWithoutPort;
exports.toHumanReadableTime = void 0;
exports.valuesFor = valuesFor;

var _punycode = _interopRequireDefault(require("punycode/punycode"));

var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

var _bignumber = _interopRequireDefault(require("bignumber.js"));

var ethUtil = _interopRequireWildcard(require("ethereumjs-util"));

var _luxon = require("luxon");

var _util = require("@metamask/controllers/dist/util");

var _slip = _interopRequireDefault(require("@metamask/slip44"));

var _network = require("../../../shared/constants/network");

var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

var _labels = require("../../../shared/constants/labels");

var _conversion = require("../../../shared/modules/conversion.utils");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// formatData :: ( date: <Unix Timestamp> ) -> String
function formatDate(date, format = "M/d/y 'at' T") {
  if (!date) {
    return '';
  }

  return _luxon.DateTime.fromMillis(date).toFormat(format);
}

function formatDateWithYearContext(date, formatThisYear = 'MMM d', fallback = 'MMM d, y') {
  if (!date) {
    return '';
  }

  const dateTime = _luxon.DateTime.fromMillis(date);

  const now = _luxon.DateTime.local();

  return dateTime.toFormat(now.year === dateTime.year ? formatThisYear : fallback);
}
/**
 * Determines if the provided chainId is a default MetaMask chain
 *
 * @param {string} chainId - chainId to check
 */


function isDefaultMetaMaskChain(chainId) {
  if (!chainId || chainId === _network.CHAIN_IDS.MAINNET || chainId === _network.CHAIN_IDS.GOERLI || chainId === _network.CHAIN_IDS.SEPOLIA || chainId === _network.CHAIN_IDS.LOCALHOST) {
    return true;
  }

  return false;
}

function valuesFor(obj) {
  if (!obj) {
    return [];
  }

  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

function addressSummary(address, firstSegLength = 10, lastSegLength = 4, includeHex = true) {
  if (!address) {
    return '';
  }

  let checked = (0, _hexstringUtils.toChecksumHexAddress)(address);

  if (!includeHex) {
    checked = (0, _hexstringUtils.stripHexPrefix)(checked);
  }

  return checked ? `${checked.slice(0, firstSegLength)}...${checked.slice(checked.length - lastSegLength)}` : '...';
}

function isValidDomainName(address) {
  const match = _punycode.default.toASCII(address).toLowerCase() // Checks that the domain consists of at least one valid domain pieces separated by periods, followed by a tld
  // Each piece of domain name has only the characters a-z, 0-9, and a hyphen (but not at the start or end of chunk)
  // A chunk has minimum length of 1, but minimum tld is set to 2 for now (no 1-character tlds exist yet)
  .match(/^(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z0-9][-a-z0-9]*[a-z0-9]$/u);

  return match !== null;
}

function isOriginContractAddress(to, sendTokenAddress) {
  if (!to || !sendTokenAddress) {
    return false;
  }

  return to.toLowerCase() === sendTokenAddress.toLowerCase();
} // Takes wei Hex, returns wei BN, even if input is null


function numericBalance(balance) {
  if (!balance) {
    return new ethUtil.BN(0, 16);
  }

  const stripped = (0, _hexstringUtils.stripHexPrefix)(balance);
  return new ethUtil.BN(stripped, 16);
} // Takes  hex, returns [beforeDecimal, afterDecimal]


function parseBalance(balance) {
  let afterDecimal;
  const wei = numericBalance(balance);
  const weiString = wei.toString();
  const trailingZeros = /0+$/u;
  const beforeDecimal = weiString.length > 18 ? weiString.slice(0, weiString.length - 18) : '0';
  afterDecimal = `000000000000000000${wei}`.slice(-18).replace(trailingZeros, '');

  if (afterDecimal === '') {
    afterDecimal = '0';
  }

  return [beforeDecimal, afterDecimal];
} // Takes wei hex, returns an object with three properties.
// Its "formatted" property is what we generally use to render values.


function formatBalance(balance, decimalsToKeep, needsParse = true, ticker = 'ETH') {
  const parsed = needsParse ? parseBalance(balance) : balance.split('.');
  const beforeDecimal = parsed[0];
  let afterDecimal = parsed[1];
  let formatted = 'None';

  if (decimalsToKeep === undefined) {
    if (beforeDecimal === '0') {
      if (afterDecimal !== '0') {
        const sigFigs = afterDecimal.match(/^0*(.{2})/u); // default: grabs 2 most significant digits

        if (sigFigs) {
          afterDecimal = sigFigs[0];
        }

        formatted = `0.${afterDecimal} ${ticker}`;
      }
    } else {
      formatted = `${beforeDecimal}.${afterDecimal.slice(0, 3)} ${ticker}`;
    }
  } else {
    afterDecimal += Array(decimalsToKeep).join('0');
    formatted = `${beforeDecimal}.${afterDecimal.slice(0, decimalsToKeep)} ${ticker}`;
  }

  return formatted;
}

function getContractAtAddress(tokenAddress) {
  return global.eth.contract(_humanStandardTokenAbi.default).at(tokenAddress);
}

function getRandomFileName() {
  let fileName = '';
  const charBank = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'];
  const fileNameLength = Math.floor(Math.random() * 7 + 6);

  for (let i = 0; i < fileNameLength; i++) {
    fileName += charBank[Math.floor(Math.random() * charBank.length)];
  }

  return fileName;
}
/**
 * Shortens an Ethereum address for display, preserving the beginning and end.
 * Returns the given address if it is no longer than 10 characters.
 * Shortened addresses are 13 characters long.
 *
 * Example output: 0xabcd...1234
 *
 * @param {string} address - The address to shorten.
 * @returns {string} The shortened address, or the original if it was no longer
 * than 10 characters.
 */


function shortenAddress(address = '') {
  if (address.length < _labels.TRUNCATED_NAME_CHAR_LIMIT) {
    return address;
  }

  return `${address.slice(0, _labels.TRUNCATED_ADDRESS_START_CHARS)}...${address.slice(-_labels.TRUNCATED_ADDRESS_END_CHARS)}`;
}

function getAccountByAddress(accounts = [], targetAddress) {
  return accounts.find(({
    address
  }) => address === targetAddress);
}
/**
 * Strips the following schemes from URL strings:
 * - http
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */


function stripHttpSchemes(urlString) {
  return urlString.replace(/^https?:\/\//u, '');
}
/**
 * Strips the following schemes from URL strings:
 * - https
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */


function stripHttpsScheme(urlString) {
  return urlString.replace(/^https:\/\//u, '');
}
/**
 * Strips `https` schemes from URL strings, if the URL does not have a port.
 * This is useful
 *
 * @param {string} urlString - The URL string to strip the scheme from.
 * @returns {string} The URL string, without the scheme, if it was stripped.
 */


function stripHttpsSchemeWithoutPort(urlString) {
  if (getURL(urlString).port) {
    return urlString;
  }

  return stripHttpsScheme(urlString);
}
/**
 * Checks whether a URL-like value (object or string) is an extension URL.
 *
 * @param {string | URL | object} urlLike - The URL-like value to test.
 * @returns {boolean} Whether the URL-like value is an extension URL.
 */


function isExtensionUrl(urlLike) {
  const EXT_PROTOCOLS = ['chrome-extension:', 'moz-extension:'];

  if (typeof urlLike === 'string') {
    for (const protocol of EXT_PROTOCOLS) {
      if (urlLike.startsWith(protocol)) {
        return true;
      }
    }
  }

  if (urlLike !== null && urlLike !== void 0 && urlLike.protocol) {
    return EXT_PROTOCOLS.includes(urlLike.protocol);
  }

  return false;
}
/**
 * Checks whether an address is in a passed list of objects with address properties. The check is performed on the
 * lowercased version of the addresses.
 *
 * @param {string} address - The hex address to check
 * @param {Array} list - The array of objects to check
 * @returns {boolean} Whether or not the address is in the list
 */


function checkExistingAddresses(address, list = []) {
  if (!address) {
    return false;
  }

  const matchesAddress = obj => {
    return obj.address.toLowerCase() === address.toLowerCase();
  };

  return list.some(matchesAddress);
}

function bnGreaterThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }

  return new _bignumber.default(a, 10).gt(b, 10);
}

function bnLessThan(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }

  return new _bignumber.default(a, 10).lt(b, 10);
}

function bnGreaterThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }

  return new _bignumber.default(a, 10).gte(b, 10);
}

function bnLessThanEqualTo(a, b) {
  if (a === null || a === undefined || b === null || b === undefined) {
    return null;
  }

  return new _bignumber.default(a, 10).lte(b, 10);
}

function getURL(url) {
  try {
    return new URL(url);
  } catch (err) {
    return '';
  }
}

function getURLHost(url) {
  var _getURL;

  return ((_getURL = getURL(url)) === null || _getURL === void 0 ? void 0 : _getURL.host) || '';
}

function getURLHostName(url) {
  var _getURL2;

  return ((_getURL2 = getURL(url)) === null || _getURL2 === void 0 ? void 0 : _getURL2.hostname) || '';
} // Once we reach this threshold, we switch to higher unit


const MINUTE_CUTOFF = 90 * 60;
const SECOND_CUTOFF = 90;

const toHumanReadableTime = (t, milliseconds) => {
  if (milliseconds === undefined || milliseconds === null) {
    return '';
  }

  const seconds = Math.ceil(milliseconds / 1000);

  if (seconds <= SECOND_CUTOFF) {
    return t('gasTimingSecondsShort', [seconds]);
  }

  if (seconds <= MINUTE_CUTOFF) {
    return t('gasTimingMinutesShort', [Math.ceil(seconds / 60)]);
  }

  return t('gasTimingHoursShort', [Math.ceil(seconds / 3600)]);
};

exports.toHumanReadableTime = toHumanReadableTime;

function clearClipboard() {
  window.navigator.clipboard.writeText('');
}

const solidityTypes = () => {
  const types = ['bool', 'address', 'string', 'bytes', 'int', 'uint', 'fixed', 'ufixed'];
  const ints = Array.from(new Array(32)).map((_, index) => `int${(index + 1) * 8}`);
  const uints = Array.from(new Array(32)).map((_, index) => `uint${(index + 1) * 8}`);
  const bytes = Array.from(new Array(32)).map((_, index) => `bytes${index + 1}`);
  /**
   * fixed and ufixed
   * This value type also can be declared keywords such as ufixedMxN and fixedMxN.
   * The M represents the amount of bits that the type takes,
   * with N representing the number of decimal points that are available.
   *  M has to be divisible by 8, and a number from 8 to 256.
   * N has to be a value between 0 and 80, also being inclusive.
   */

  const fixedM = Array.from(new Array(32)).map((_, index) => `fixed${(index + 1) * 8}`);
  const ufixedM = Array.from(new Array(32)).map((_, index) => `ufixed${(index + 1) * 8}`);
  const fixed = Array.from(new Array(80)).map((_, index) => fixedM.map(aFixedM => `${aFixedM}x${index + 1}`));
  const ufixed = Array.from(new Array(80)).map((_, index) => ufixedM.map(auFixedM => `${auFixedM}x${index + 1}`));
  return [...types, ...ints, ...uints, ...bytes, ...fixed.flat(), ...ufixed.flat()];
};

const sanitizeMessage = (msg, baseType, types) => {
  if (!types) {
    throw new Error(`Invalid types definition`);
  }

  const baseTypeDefinitions = types[baseType];

  if (!baseTypeDefinitions) {
    throw new Error(`Invalid primary type definition`);
  }

  const sanitizedMessage = {};
  const msgKeys = Object.keys(msg);
  msgKeys.forEach(msgKey => {
    const definedType = Object.values(baseTypeDefinitions).find(baseTypeDefinition => baseTypeDefinition.name === msgKey);

    if (!definedType) {
      return;
    } // key has a type. check if the definedType is also a type


    const nestedType = definedType.type.replace(/\[\]$/u, '');
    const nestedTypeDefinition = types[nestedType];

    if (nestedTypeDefinition) {
      if (definedType.type.endsWith('[]') > 0) {
        // nested array
        sanitizedMessage[msgKey] = msg[msgKey].map(value => sanitizeMessage(value, nestedType, types));
      } else {
        // nested object
        sanitizedMessage[msgKey] = sanitizeMessage(msg[msgKey], definedType.type, types);
      }
    } else {
      // check if it's a valid solidity type
      const isSolidityType = solidityTypes().includes(nestedType);

      if (isSolidityType) {
        sanitizedMessage[msgKey] = msg[msgKey];
      }
    }
  });
  return sanitizedMessage;
};

exports.sanitizeMessage = sanitizeMessage;

function getAssetImageURL(image, ipfsGateway) {
  if (!image || !ipfsGateway || typeof image !== 'string') {
    return '';
  }

  if (image.startsWith('ipfs://')) {
    return (0, _util.getFormattedIpfsUrl)(ipfsGateway, image, true);
  }

  return image;
}

function roundToDecimalPlacesRemovingExtraZeroes(numberish, numberOfDecimalPlaces) {
  if (numberish === undefined || numberish === null) {
    return '';
  }

  return _conversion.toBigNumber.dec(_conversion.toBigNumber.dec(numberish).toFixed(numberOfDecimalPlaces)).toNumber();
}
/**
 * Gets the name of the SLIP-44 protocol corresponding to the specified
 * `coin_type`.
 *
 * @param {string | number} coinType - The SLIP-44 `coin_type` value whose name
 * to retrieve.
 * @returns {string | undefined} The name of the protocol if found.
 */


function coinTypeToProtocolName(coinType) {
  var _slip44$coinType;

  if (String(coinType) === '1') {
    return 'Test Networks';
  }

  return ((_slip44$coinType = _slip.default[coinType]) === null || _slip44$coinType === void 0 ? void 0 : _slip44$coinType.name) || undefined;
}
/**
 * Tests "nullishness". Used to guard a section of a component from being
 * rendered based on a value.
 *
 * @param {any} value - A value (literally anything).
 * @returns `true` if the value is null or undefined, `false` otherwise.
 */


function isNullish(value) {
  return value === null || value === undefined;
}


      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\add-ethereum-chain.js", {"../../../../shared/constants/network":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts","../../../../shared/lib/fetch-with-cache":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js","../../../helpers/constants/design-system":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\design-system.js","../../../helpers/constants/routes":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\routes.js","../../../helpers/constants/zendesk-url":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\zendesk-url.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js","react":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\confirmation\templates\add-ethereum-chain.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _react = _interopRequireDefault(require("react"));

var _network = require("../../../../shared/constants/network");

var _designSystem = require("../../../helpers/constants/design-system");

var _routes = require("../../../helpers/constants/routes");

var _zendeskUrl = _interopRequireDefault(require("../../../helpers/constants/zendesk-url"));

var _fetchWithCache = _interopRequireDefault(require("../../../../shared/lib/fetch-with-cache"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const UNRECOGNIZED_CHAIN = {
  id: 'UNRECOGNIZED_CHAIN',
  severity: _designSystem.SEVERITIES.WARNING,
  content: {
    element: 'span',
    children: {
      element: 'MetaMaskTranslation',
      props: {
        translationKey: 'unrecognizedChain'
      }
    }
  }
};
const MISMATCHED_CHAIN_RECOMMENDATION = {
  id: 'MISMATCHED_CHAIN_RECOMMENDATION',
  content: {
    element: 'span',
    children: {
      element: 'MetaMaskTranslation',
      props: {
        translationKey: 'mismatchedChainRecommendation',
        variables: [{
          element: 'a',
          key: 'mismatchedChainLink',
          props: {
            href: _zendeskUrl.default.VERIFY_CUSTOM_NETWORK,
            target: '__blank',
            tabIndex: 0
          },
          children: {
            element: 'MetaMaskTranslation',
            props: {
              translationKey: 'mismatchedChainLinkText'
            }
          }
        }]
      }
    }
  }
};
const MISMATCHED_NETWORK_NAME = {
  id: 'MISMATCHED_NETWORK_NAME',
  severity: _designSystem.SEVERITIES.WARNING,
  content: {
    element: 'span',
    children: {
      element: 'MetaMaskTranslation',
      props: {
        translationKey: 'mismatchedNetworkName'
      }
    }
  }
};
const MISMATCHED_NETWORK_SYMBOL = {
  id: 'MISMATCHED_NETWORK_SYMBOL',
  severity: _designSystem.SEVERITIES.DANGER,
  content: {
    element: 'span',
    children: {
      element: 'MetaMaskTranslation',
      props: {
        translationKey: 'mismatchedNetworkSymbol'
      }
    }
  }
};
const MISMATCHED_NETWORK_RPC = {
  id: 'MISMATCHED_NETWORK_RPC',
  severity: _designSystem.SEVERITIES.DANGER,
  content: {
    element: 'span',
    children: {
      element: 'MetaMaskTranslation',
      props: {
        translationKey: 'mismatchedRpcUrl'
      }
    }
  }
};

async function getAlerts(pendingApproval) {
  const alerts = [];
  const safeChainsList = (await (0, _fetchWithCache.default)('https://chainid.network/chains.json')) || [];
  const matchedChain = safeChainsList.find(chain => chain.chainId === parseInt(pendingApproval.requestData.chainId, 16));
  const originIsMetaMask = pendingApproval.origin === 'metamask';

  if (originIsMetaMask && Boolean(matchedChain)) {
    return [];
  }

  if (matchedChain) {
    var _matchedChain$nativeC;

    if (matchedChain.name.toLowerCase() !== pendingApproval.requestData.chainName.toLowerCase()) {
      alerts.push(MISMATCHED_NETWORK_NAME);
    }

    if (((_matchedChain$nativeC = matchedChain.nativeCurrency) === null || _matchedChain$nativeC === void 0 ? void 0 : _matchedChain$nativeC.symbol) !== pendingApproval.requestData.ticker) {
      alerts.push(MISMATCHED_NETWORK_SYMBOL);
    }

    const {
      origin
    } = new URL(pendingApproval.requestData.rpcUrl);

    if (!matchedChain.rpc.map(rpc => new URL(rpc).origin).includes(origin)) {
      alerts.push(MISMATCHED_NETWORK_RPC);
    }
  }

  if (!matchedChain) {
    alerts.push(UNRECOGNIZED_CHAIN);
  }

  if (alerts.length) {
    alerts.push(MISMATCHED_CHAIN_RECOMMENDATION);
  }

  return alerts;
}

function getValues(pendingApproval, t, actions, history) {
  var _pendingApproval$requ;

  const originIsMetaMask = pendingApproval.origin === 'metamask';
  return {
    content: [{
      hide: !originIsMetaMask,
      element: 'Box',
      key: 'network-box',
      props: {
        textAlign: _designSystem.TEXT_ALIGN.CENTER,
        display: _designSystem.DISPLAY.FLEX,
        justifyContent: _designSystem.JUSTIFY_CONTENT.CENTER,
        marginTop: 4,
        marginBottom: 2
      },
      children: [{
        element: 'Chip',
        key: 'network-chip',
        props: {
          label: pendingApproval.requestData.chainName,
          backgroundColor: _designSystem.COLORS.BACKGROUND_ALTERNATIVE,
          leftIconUrl: pendingApproval.requestData.imageUrl
        }
      }]
    }, {
      element: 'Typography',
      key: 'title',
      children: originIsMetaMask ? t('wantToAddThisNetwork') : t('addEthereumChainConfirmationTitle'),
      props: {
        variant: _designSystem.TYPOGRAPHY.H3,
        align: 'center',
        fontWeight: 'bold',
        boxProps: {
          margin: [0, 0, 4]
        }
      }
    }, {
      element: 'Typography',
      key: 'description',
      children: t('addEthereumChainConfirmationDescription'),
      props: {
        variant: _designSystem.TYPOGRAPHY.H7,
        align: 'center',
        boxProps: {
          margin: originIsMetaMask ? [0, 8, 4] : [0, 0, 4]
        }
      }
    }, {
      element: 'Typography',
      key: 'only-add-networks-you-trust',
      children: [{
        element: 'b',
        key: 'bolded-text',
        props: {
          style: {
            display: originIsMetaMask && '-webkit-box'
          }
        },
        children: [`${t('addEthereumChainConfirmationRisks')} `, {
          hide: !originIsMetaMask,
          element: 'Tooltip',
          key: 'tooltip-info',
          props: {
            position: 'bottom',
            interactive: true,
            trigger: 'mouseenter',
            html: /*#__PURE__*/_react.default.createElement("div", {
              style: {
                width: '180px',
                margin: '16px',
                textAlign: 'left'
              }
            }, t('someNetworksMayPoseSecurity'), ' ', /*#__PURE__*/_react.default.createElement("a", {
              key: "zendesk_page_link",
              href: _zendeskUrl.default.UNKNOWN_NETWORK,
              rel: "noreferrer",
              target: "_blank",
              style: {
                color: 'var(--color-primary-default)'
              }
            }, t('learnMoreUpperCase')))
          },
          children: [{
            element: 'i',
            key: 'info-circle',
            props: {
              className: 'fas fa-info-circle',
              style: {
                marginLeft: '4px',
                color: 'var(--color-icon-default)'
              }
            }
          }]
        }]
      }, {
        element: 'MetaMaskTranslation',
        key: 'learn-about-risks',
        props: {
          translationKey: 'addEthereumChainConfirmationRisksLearnMore',
          variables: [{
            element: 'a',
            children: t('addEthereumChainConfirmationRisksLearnMoreLink'),
            key: 'addEthereumChainConfirmationRisksLearnMoreLink',
            props: {
              href: _zendeskUrl.default.USER_GUIDE_CUSTOM_NETWORKS,
              target: '__blank'
            }
          }]
        }
      }],
      props: {
        variant: _designSystem.TYPOGRAPHY.H7,
        boxProps: {
          margin: originIsMetaMask ? [0, 8] : 0,
          display: _designSystem.DISPLAY.FLEX,
          flexDirection: _designSystem.FLEX_DIRECTION.COLUMN,
          alignItems: _designSystem.ALIGN_ITEMS.CENTER
        }
      }
    }, {
      element: 'TruncatedDefinitionList',
      key: 'network-details',
      props: {
        title: t('networkDetails'),
        tooltips: {
          [t('networkName')]: t('networkNameDefinition'),
          [t('networkURL')]: t('networkURLDefinition'),
          [t('chainId')]: t('chainIdDefinition'),
          [t('currencySymbol')]: t('currencySymbolDefinition'),
          [t('blockExplorerUrl')]: t('blockExplorerUrlDefinition')
        },
        dictionary: {
          [t('networkName')]: pendingApproval.requestData.chainName,
          [t('networkURL')]: (_pendingApproval$requ = pendingApproval.requestData.rpcUrl) !== null && _pendingApproval$requ !== void 0 && _pendingApproval$requ.includes(`/v3/${_network.infuraProjectId}`) ? pendingApproval.requestData.rpcUrl.replace(`/v3/${_network.infuraProjectId}`, '') : pendingApproval.requestData.rpcUrl,
          [t('chainId')]: parseInt(pendingApproval.requestData.chainId, 16),
          [t('currencySymbol')]: pendingApproval.requestData.ticker,
          [t('blockExplorerUrl')]: pendingApproval.requestData.blockExplorerUrl
        },
        prefaceKeys: [t('networkName'), t('networkURL'), t('chainId'), t('currencySymbol')]
      }
    }],
    approvalText: t('approveButtonText'),
    cancelText: t('cancel'),
    onApprove: async () => {
      await actions.resolvePendingApproval(pendingApproval.id, pendingApproval.requestData);

      if (originIsMetaMask) {
        actions.addCustomNetwork(pendingApproval.requestData);
        history.push(_routes.DEFAULT_ROUTE);
      }
    },
    onCancel: () => actions.rejectPendingApproval(pendingApproval.id, _ethRpcErrors.ethErrors.provider.userRejectedRequest().serialize()),
    networkDisplay: !originIsMetaMask
  };
}

const addEthereumChain = {
  getAlerts,
  getValues
};
var _default = addEthereumChain;
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\index.js", {"../../../../shared/constants/app":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts","../../../store/actions":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js","./add-ethereum-chain":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\add-ethereum-chain.js","./switch-ethereum-chain":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\switch-ethereum-chain.js","lodash":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\confirmation\templates\index.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TEMPLATED_CONFIRMATION_MESSAGE_TYPES = void 0;
exports.getTemplateAlerts = getTemplateAlerts;
exports.getTemplateState = getTemplateState;
exports.getTemplateValues = getTemplateValues;

var _lodash = require("lodash");

var _app = require("../../../../shared/constants/app");

var _actions = require("../../../store/actions");

var _addEthereumChain = _interopRequireDefault(require("./add-ethereum-chain"));

var _switchEthereumChain = _interopRequireDefault(require("./switch-ethereum-chain"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const APPROVAL_TEMPLATES = {
  [_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN]: _addEthereumChain.default,
  [_app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN]: _switchEthereumChain.default
};
const TEMPLATED_CONFIRMATION_MESSAGE_TYPES = Object.keys(APPROVAL_TEMPLATES);
exports.TEMPLATED_CONFIRMATION_MESSAGE_TYPES = TEMPLATED_CONFIRMATION_MESSAGE_TYPES;
const ALLOWED_TEMPLATE_KEYS = ['content', 'approvalText', 'cancelText', 'onApprove', 'onCancel', 'networkDisplay'];
/**
 * @typedef {object} PendingApproval
 * @property {string} id - The randomly generated id of the approval
 * @property {string} origin - The origin of the site requesting this approval
 * @property {number} time - The time the approval was requested
 * @property {string} type - The type of approval being requested
 * @property {object} requestData - The data submitted with the request
 */

/**
 * getTemplateAlerts calls the getAlerts function exported by the template if
 * it exists, and then returns the result of that function. In the confirmation
 * page the alerts returned from the getAlerts method will be set into the
 * alertState state object.
 *
 * @param {object} pendingApproval - the object representing the confirmation
 */

async function getTemplateAlerts(pendingApproval) {
  var _APPROVAL_TEMPLATES$p;

  const fn = (_APPROVAL_TEMPLATES$p = APPROVAL_TEMPLATES[pendingApproval.type]) === null || _APPROVAL_TEMPLATES$p === void 0 ? void 0 : _APPROVAL_TEMPLATES$p.getAlerts;
  const results = fn ? await fn(pendingApproval) : [];

  if (!Array.isArray(results)) {
    throw new Error(`Template alerts must be an array, received: ${results}`);
  }

  if (results.some(result => (result === null || result === void 0 ? void 0 : result.id) === undefined)) {
    throw new Error(`Template alert entries must be objects with an id key. Received: ${results}`);
  }

  return results;
}
/**
 * The function call to return state must be a promise returning function
 * this "NOOP" is here to conform to the requirements for templates without
 * state.
 */


async function emptyState() {
  return {};
}
/**
 * getTemplateState calls the getState function exported by the template if
 * it exists, and then returns the result of that function. In the confirmation
 * page the object returned from the getState method will be set into the
 * confirmationState state object. Note, this state is not consumed by the page
 * itself.
 *
 * @param {object} pendingApproval - the object representing the confirmation
 */


async function getTemplateState(pendingApproval) {
  var _APPROVAL_TEMPLATES$p2, _APPROVAL_TEMPLATES$p3;

  const fn = (_APPROVAL_TEMPLATES$p2 = (_APPROVAL_TEMPLATES$p3 = APPROVAL_TEMPLATES[pendingApproval.type]) === null || _APPROVAL_TEMPLATES$p3 === void 0 ? void 0 : _APPROVAL_TEMPLATES$p3.getState) !== null && _APPROVAL_TEMPLATES$p2 !== void 0 ? _APPROVAL_TEMPLATES$p2 : emptyState;
  const result = await fn(pendingApproval);

  if (typeof result !== 'object' || Array.isArray(result)) {
    throw new Error(`Template state must be an object, received: ${result}`);
  } else if (result === null || result === undefined) {
    return {};
  }

  return result;
}
/**
 * We do not want to pass the entire dispatch function to the template.
 * This function should return an object of actions that we generally consider
 * to be safe for templates to invoke. In the future we could put these behind
 * permission sets so that snaps that wish to manipulate state must ask for
 * explicit permission to do so.
 *
 * @param {Function} dispatch - Redux dispatch function
 */


function getAttenuatedDispatch(dispatch) {
  return {
    rejectPendingApproval: (...args) => dispatch((0, _actions.rejectPendingApproval)(...args)),
    resolvePendingApproval: (...args) => dispatch((0, _actions.resolvePendingApproval)(...args)),
    addCustomNetwork: (...args) => dispatch((0, _actions.addCustomNetwork)(...args))
  };
}
/**
 * Returns the templated values to be consumed in the confirmation page
 *
 * @param {object} pendingApproval - The pending confirmation object
 * @param {Function} t - Translation function
 * @param {Function} dispatch - Redux dispatch function
 * @param history
 */


function getTemplateValues(pendingApproval, t, dispatch, history) {
  var _APPROVAL_TEMPLATES$p4;

  const fn = (_APPROVAL_TEMPLATES$p4 = APPROVAL_TEMPLATES[pendingApproval.type]) === null || _APPROVAL_TEMPLATES$p4 === void 0 ? void 0 : _APPROVAL_TEMPLATES$p4.getValues;

  if (!fn) {
    throw new Error(`MESSAGE_TYPE: '${pendingApproval.type}' is not specified in approval templates`);
  }

  const safeActions = getAttenuatedDispatch(dispatch);
  const values = fn(pendingApproval, t, safeActions, history);
  const extraneousKeys = (0, _lodash.omit)(values, ALLOWED_TEMPLATE_KEYS);
  const safeValues = (0, _lodash.pick)(values, ALLOWED_TEMPLATE_KEYS);

  if (extraneousKeys.length > 0) {
    throw new Error(`Received extraneous keys from ${pendingApproval.type}.getValues. These keys are not passed to the confirmation page: ${Object.keys(extraneousKeys)}`);
  }

  return safeValues;
}

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\switch-ethereum-chain.js", {"../../../helpers/constants/design-system":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\design-system.js","eth-rpc-errors":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\confirmation\templates\switch-ethereum-chain.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ethRpcErrors = require("eth-rpc-errors");

var _designSystem = require("../../../helpers/constants/design-system");

const PENDING_TX_DROP_NOTICE = {
  id: 'PENDING_TX_DROP_NOTICE',
  severity: _designSystem.SEVERITIES.WARNING,
  content: {
    element: 'span',
    children: {
      element: 'MetaMaskTranslation',
      props: {
        translationKey: 'switchingNetworksCancelsPendingConfirmations'
      }
    }
  }
};

async function getAlerts() {
  return [PENDING_TX_DROP_NOTICE];
}

function getValues(pendingApproval, t, actions) {
  return {
    content: [{
      element: 'Typography',
      key: 'title',
      children: t('switchEthereumChainConfirmationTitle'),
      props: {
        variant: _designSystem.TYPOGRAPHY.H3,
        align: 'center',
        fontWeight: 'normal',
        boxProps: {
          margin: [0, 0, 2],
          padding: [0, 4, 0, 4]
        }
      }
    }, {
      element: 'Typography',
      key: 'description',
      children: t('switchEthereumChainConfirmationDescription'),
      props: {
        variant: _designSystem.TYPOGRAPHY.H7,
        color: _designSystem.COLORS.TEXT_ALTERNATIVE,
        align: 'center',
        boxProps: {
          padding: [0, 4, 0, 4]
        }
      }
    }, {
      element: 'Box',
      key: 'status-box',
      props: {
        justifyContent: _designSystem.JUSTIFY_CONTENT.CENTER
      },
      children: {
        element: 'ConfirmationNetworkSwitch',
        key: 'network-being-switched',
        props: {
          newNetwork: {
            chainId: pendingApproval.requestData.chainId,
            name: pendingApproval.requestData.nickname
          }
        }
      }
    }],
    approvalText: t('switchNetwork'),
    cancelText: t('cancel'),
    onApprove: () => actions.resolvePendingApproval(pendingApproval.id, pendingApproval.requestData),
    onCancel: () => actions.rejectPendingApproval(pendingApproval.id, _ethRpcErrors.ethErrors.provider.userRejectedRequest().serialize()),
    networkDisplay: true
  };
}

const switchEthereumChain = {
  getAlerts,
  getValues
};
var _default = switchEthereumChain;
exports.default = _default;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js", {"../../../app/scripts/lib/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js","../../../shared/constants/gas":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\send\send.constants.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TOKEN_TRANSFER_FUNCTION_SIGNATURE = exports.REQUIRED_ERROR = exports.RECIPIENT_TYPES = exports.NEGATIVE_ETH_ERROR = exports.MIN_GAS_TOTAL = exports.MIN_GAS_PRICE_HEX = exports.MIN_GAS_PRICE_GWEI = exports.MIN_GAS_PRICE_DEC = exports.MIN_GAS_LIMIT_DEC = exports.MAX_GAS_LIMIT_DEC = exports.KNOWN_RECIPIENT_ADDRESS_WARNING = exports.INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR = exports.INVALID_RECIPIENT_ADDRESS_ERROR = exports.INSUFFICIENT_TOKENS_ERROR = exports.INSUFFICIENT_FUNDS_ERROR = exports.HIGH_FEE_WARNING_MULTIPLIER = exports.ENS_UNKNOWN_ERROR = exports.ENS_REGISTRATION_ERROR = exports.ENS_NO_ADDRESS_FOR_NAME = exports.ENS_NOT_SUPPORTED_ON_NETWORK = exports.ENS_NOT_FOUND_ON_NETWORK = exports.ENS_ILLEGAL_CHARACTER = exports.CONTRACT_ADDRESS_ERROR = exports.CONFUSING_ENS_ERROR = exports.COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE = void 0;

var _conversion = require("../../../shared/modules/conversion.utils");

var _util = require("../../../app/scripts/lib/util");

var _gas = require("../../../shared/constants/gas");

const MIN_GAS_PRICE_DEC = '0';
exports.MIN_GAS_PRICE_DEC = MIN_GAS_PRICE_DEC;
const MIN_GAS_PRICE_HEX = parseInt(MIN_GAS_PRICE_DEC, 10).toString(16);
exports.MIN_GAS_PRICE_HEX = MIN_GAS_PRICE_HEX;
const MIN_GAS_LIMIT_DEC = '21000';
exports.MIN_GAS_LIMIT_DEC = MIN_GAS_LIMIT_DEC;
const MAX_GAS_LIMIT_DEC = '7920027';
exports.MAX_GAS_LIMIT_DEC = MAX_GAS_LIMIT_DEC;
const HIGH_FEE_WARNING_MULTIPLIER = 1.5;
exports.HIGH_FEE_WARNING_MULTIPLIER = HIGH_FEE_WARNING_MULTIPLIER;
const MIN_GAS_PRICE_GWEI = (0, _util.addHexPrefix)((0, _conversion.conversionUtil)(MIN_GAS_PRICE_HEX, {
  fromDenomination: 'WEI',
  toDenomination: 'GWEI',
  fromNumericBase: 'hex',
  toNumericBase: 'hex',
  numberOfDecimals: 1
}));
exports.MIN_GAS_PRICE_GWEI = MIN_GAS_PRICE_GWEI;
const MIN_GAS_TOTAL = (0, _conversion.multiplyCurrencies)(_gas.MIN_GAS_LIMIT_HEX, MIN_GAS_PRICE_HEX, {
  toNumericBase: 'hex',
  multiplicandBase: 16,
  multiplierBase: 16
});
exports.MIN_GAS_TOTAL = MIN_GAS_TOTAL;
const TOKEN_TRANSFER_FUNCTION_SIGNATURE = '0xa9059cbb';
exports.TOKEN_TRANSFER_FUNCTION_SIGNATURE = TOKEN_TRANSFER_FUNCTION_SIGNATURE;
const COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE = '0x23b872dd';
exports.COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE = COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE;
const INSUFFICIENT_FUNDS_ERROR = 'insufficientFunds';
exports.INSUFFICIENT_FUNDS_ERROR = INSUFFICIENT_FUNDS_ERROR;
const INSUFFICIENT_TOKENS_ERROR = 'insufficientTokens';
exports.INSUFFICIENT_TOKENS_ERROR = INSUFFICIENT_TOKENS_ERROR;
const NEGATIVE_ETH_ERROR = 'negativeETH';
exports.NEGATIVE_ETH_ERROR = NEGATIVE_ETH_ERROR;
const INVALID_RECIPIENT_ADDRESS_ERROR = 'invalidAddressRecipient';
exports.INVALID_RECIPIENT_ADDRESS_ERROR = INVALID_RECIPIENT_ADDRESS_ERROR;
const INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR = 'invalidAddressRecipientNotEthNetwork';
exports.INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR = INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR;
const REQUIRED_ERROR = 'required';
exports.REQUIRED_ERROR = REQUIRED_ERROR;
const KNOWN_RECIPIENT_ADDRESS_WARNING = 'knownAddressRecipient';
exports.KNOWN_RECIPIENT_ADDRESS_WARNING = KNOWN_RECIPIENT_ADDRESS_WARNING;
const CONTRACT_ADDRESS_ERROR = 'contractAddressError';
exports.CONTRACT_ADDRESS_ERROR = CONTRACT_ADDRESS_ERROR;
const CONFUSING_ENS_ERROR = 'confusingEnsDomain';
exports.CONFUSING_ENS_ERROR = CONFUSING_ENS_ERROR;
const ENS_NO_ADDRESS_FOR_NAME = 'noAddressForName';
exports.ENS_NO_ADDRESS_FOR_NAME = ENS_NO_ADDRESS_FOR_NAME;
const ENS_NOT_FOUND_ON_NETWORK = 'ensNotFoundOnCurrentNetwork';
exports.ENS_NOT_FOUND_ON_NETWORK = ENS_NOT_FOUND_ON_NETWORK;
const ENS_NOT_SUPPORTED_ON_NETWORK = 'ensNotSupportedOnNetwork';
exports.ENS_NOT_SUPPORTED_ON_NETWORK = ENS_NOT_SUPPORTED_ON_NETWORK;
const ENS_ILLEGAL_CHARACTER = 'ensIllegalCharacter';
exports.ENS_ILLEGAL_CHARACTER = ENS_ILLEGAL_CHARACTER;
const ENS_UNKNOWN_ERROR = 'ensUnknownError';
exports.ENS_UNKNOWN_ERROR = ENS_UNKNOWN_ERROR;
const ENS_REGISTRATION_ERROR = 'ensRegistrationError';
exports.ENS_REGISTRATION_ERROR = ENS_REGISTRATION_ERROR;
const RECIPIENT_TYPES = {
  SMART_CONTRACT: 'SMART_CONTRACT',
  NON_CONTRACT: 'NON_CONTRACT'
};
exports.RECIPIENT_TYPES = RECIPIENT_TYPES;

      };
    };
  }
}, {package:"$root$",}],
["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.utils.js", {"../../../app/scripts/lib/util":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js","../../../shared/constants/transaction":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js","../../../shared/lib/transactions-controller-utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js","../../../shared/modules/conversion.utils":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js","./send.constants":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js","ethereumjs-abi":"C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js"}, function(){
  with (this) {
    return function() {
      'use strict';
      // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\send\send.utils.js
      return function (require, module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addGasBuffer = addGasBuffer;
exports.ellipsify = ellipsify;
exports.generateERC20TransferData = generateERC20TransferData;
exports.generateERC721TransferData = generateERC721TransferData;
exports.getAssetTransferData = getAssetTransferData;
exports.isBalanceSufficient = isBalanceSufficient;
exports.isTokenBalanceSufficient = isTokenBalanceSufficient;

var _ethereumjsAbi = _interopRequireDefault(require("ethereumjs-abi"));

var _conversion = require("../../../shared/modules/conversion.utils");

var _util = require("../../../app/scripts/lib/util");

var _transaction = require("../../../shared/constants/transaction");

var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

var _send = require("./send.constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBalanceSufficient({
  amount = '0x0',
  balance = '0x0',
  conversionRate = 1,
  gasTotal = '0x0',
  primaryCurrency
}) {
  const totalAmount = (0, _conversion.addCurrencies)(amount, gasTotal, {
    aBase: 16,
    bBase: 16,
    toNumericBase: 'hex'
  });
  const balanceIsSufficient = (0, _conversion.conversionGTE)({
    value: balance,
    fromNumericBase: 'hex',
    fromCurrency: primaryCurrency,
    conversionRate
  }, {
    value: totalAmount,
    fromNumericBase: 'hex',
    conversionRate,
    fromCurrency: primaryCurrency
  });
  return balanceIsSufficient;
}

function isTokenBalanceSufficient({
  amount = '0x0',
  tokenBalance,
  decimals
}) {
  const amountInDec = (0, _conversion.conversionUtil)(amount, {
    fromNumericBase: 'hex'
  });
  const tokenBalanceIsSufficient = (0, _conversion.conversionGTE)({
    value: tokenBalance,
    fromNumericBase: 'hex'
  }, {
    value: (0, _transactionsControllerUtils.calcTokenAmount)(amountInDec, decimals)
  });
  return tokenBalanceIsSufficient;
}

function addGasBuffer(initialGasLimitHex, blockGasLimitHex, bufferMultiplier = 1.5) {
  const upperGasLimit = (0, _conversion.multiplyCurrencies)(blockGasLimitHex, 0.9, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 10,
    numberOfDecimals: '0'
  });
  const bufferedGasLimit = (0, _conversion.multiplyCurrencies)(initialGasLimitHex, bufferMultiplier, {
    toNumericBase: 'hex',
    multiplicandBase: 16,
    multiplierBase: 10,
    numberOfDecimals: '0'
  }); // if initialGasLimit is above blockGasLimit, dont modify it

  if ((0, _conversion.conversionGreaterThan)({
    value: initialGasLimitHex,
    fromNumericBase: 'hex'
  }, {
    value: upperGasLimit,
    fromNumericBase: 'hex'
  })) {
    return initialGasLimitHex;
  } // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit


  if ((0, _conversion.conversionLessThan)({
    value: bufferedGasLimit,
    fromNumericBase: 'hex'
  }, {
    value: upperGasLimit,
    fromNumericBase: 'hex'
  })) {
    return bufferedGasLimit;
  } // otherwise use blockGasLimit


  return upperGasLimit;
}

function generateERC20TransferData({
  toAddress = '0x0',
  amount = '0x0',
  sendToken
}) {
  if (!sendToken) {
    return undefined;
  }

  return _send.TOKEN_TRANSFER_FUNCTION_SIGNATURE + Array.prototype.map.call(_ethereumjsAbi.default.rawEncode(['address', 'uint256'], [(0, _util.addHexPrefix)(toAddress), (0, _util.addHexPrefix)(amount)]), x => `00${x.toString(16)}`.slice(-2)).join('');
}

function generateERC721TransferData({
  toAddress = '0x0',
  fromAddress = '0x0',
  tokenId
}) {
  if (!tokenId) {
    return undefined;
  }

  return _send.COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE + Array.prototype.map.call(_ethereumjsAbi.default.rawEncode(['address', 'address', 'uint256'], [(0, _util.addHexPrefix)(fromAddress), (0, _util.addHexPrefix)(toAddress), tokenId]), x => `00${x.toString(16)}`.slice(-2)).join('');
}

function getAssetTransferData({
  sendToken,
  fromAddress,
  toAddress,
  amount
}) {
  switch (sendToken.standard) {
    case _transaction.ERC721:
      return generateERC721TransferData({
        toAddress,
        fromAddress,
        tokenId: sendToken.tokenId
      });

    case _transaction.ERC20:
    default:
      return generateERC20TransferData({
        toAddress,
        amount,
        sendToken
      });
  }
}

function ellipsify(text, first = 6, last = 4) {
  return `${text.slice(0, first)}...${text.slice(-last)}`;
}

      };
    };
  }
}, {package:"$root$",}]],[],{})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvdmFsaWQtdXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL3NyYy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9zcmMvcG9sbGluZy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvYmxvY2stY2FjaGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2NhY2hlLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvaW5mbGlnaHQtY2FjaGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGgtcnBjLWVycm9ycy9zcmMvY2xhc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvc3JjL2Vycm9yQ29kZXMuanNvbiIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvc3JjL2Vycm9yVmFsdWVzLmpzb24iLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL3NyYy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1saWIvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvanNvbi1ycGMtZW5naW5lL3NyYy9jcmVhdGVBc3luY01pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvZGVmYXVsdC1maXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvZmlsdGVycy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvZml4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvaG9va2VkLXdhbGxldC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvaW5mbGlnaHQtY2FjaGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL2luZnVyYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvanNvbi1ycGMtZW5naW5lLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL25vbmNlLXRyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9zYW5pdGl6ZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL3N1YnByb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9zdWJzY3JpcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy93ZWJzb2NrZXQuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvdXRpbC9jcmVhdGUtcGF5bG9hZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL2VzdGltYXRlLWdhcy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL3JhbmRvbS1pZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL3JwYy1jYWNoZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL3N0b3BsaWdodC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS96ZXJvLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb24iLCJub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9hZGRyZXNzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Jvb2wuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvY29kZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvZHluYW1pY2J5dGVzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Zvcm1hdHRlcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvaW50LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3BhcmFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3JlYWwuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3R5cGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdWludC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91cmVhbC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9icm93c2VyLXhoci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9jb25maWcuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvc2hhMy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi92ZXJzaW9uLmpzb24iLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2FsbGV2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2JhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvY29udHJhY3QuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9ldmVudC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Zvcm1hdHRlcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2h0dHBwcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2liYW4uanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9pcGNwcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2pzb25ycGMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2QuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2RiLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9ldGguanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL25ldC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvcGVyc29uYWwuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3NoaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvc3dhcm0uanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3dhdGNoZXMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9uYW1lcmVnLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9yZXF1ZXN0bWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3NldHRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3RyYW5zZmVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy9ub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIiwibm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2Rpc3QvZmV0Y2gudW1kLmpzIiwibm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJub2RlX21vZHVsZXMveGhyMi1jb29raWVzL2Rpc3QvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3Byb2dyZXNzLWV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3htbC1odHRwLXJlcXVlc3QtZXZlbnQtdGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3htbC1odHRwLXJlcXVlc3QtdXBsb2FkLmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3htbC1odHRwLXJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMveGhyMi9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzaGFyZWQvY29uc3RhbnRzL2FsZXJ0cy5qcyIsInNoYXJlZC9jb25zdGFudHMvYXBwLnRzIiwic2hhcmVkL2NvbnN0YW50cy9nYXMuanMiLCJzaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMuanMiLCJzaGFyZWQvY29uc3RhbnRzL2xhYmVscy5qcyIsInNoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MuanMiLCJzaGFyZWQvY29uc3RhbnRzL25ldHdvcmsudHMiLCJzaGFyZWQvY29uc3RhbnRzL3Blcm1pc3Npb25zLnRzIiwic2hhcmVkL2NvbnN0YW50cy9zd2Fwcy5qcyIsInNoYXJlZC9jb25zdGFudHMvdGltZS50cyIsInNoYXJlZC9jb25zdGFudHMvdG9rZW5zLmpzIiwic2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbi5qcyIsInNoYXJlZC9saWIvZmV0Y2gtd2l0aC1jYWNoZS5qcyIsInNoYXJlZC9saWIvbWV0YW1hc2stY29udHJvbGxlci11dGlscy5qcyIsInNoYXJlZC9saWIvc3RvcmFnZS1oZWxwZXJzLmpzIiwic2hhcmVkL2xpYi9zd2Fwcy11dGlscy5qcyIsInNoYXJlZC9saWIvc3dpdGNoLWRpcmVjdGlvbi5qcyIsInNoYXJlZC9saWIvdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9mZXRjaC13aXRoLXRpbWVvdXQuanMiLCJzaGFyZWQvbW9kdWxlcy9nYXMudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9tdjMudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvb2JqZWN0LnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkLmpzIiwic2hhcmVkL21vZHVsZXMvcnBjLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvc2l3ZS5qcyIsInNoYXJlZC9tb2R1bGVzL3N0cmluZy11dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL3N3YXBzLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvdHJhbnNhY3Rpb24udXRpbHMuanMiLCJzaGFyZWQvbm90aWZpY2F0aW9ucy9pbmRleC5qcyIsInVpL2R1Y2tzL2FsZXJ0cy9lbnVtcy5qcyIsInVpL2R1Y2tzL2FsZXJ0cy91bmNvbm5lY3RlZC1hY2NvdW50LmpzIiwidWkvZHVja3MvYXBwL2FwcC5qcyIsInVpL2R1Y2tzL2Vucy5qcyIsInVpL2R1Y2tzL2dhcy9nYXMtYWN0aW9uLWNvbnN0YW50cy5qcyIsInVpL2R1Y2tzL2dhcy9nYXMuZHVjay5qcyIsInVpL2R1Y2tzL21ldGFtYXNrL21ldGFtYXNrLmpzIiwidWkvZHVja3Mvc2VuZC9oZWxwZXJzLmpzIiwidWkvZHVja3Mvc2VuZC9pbmRleC5qcyIsInVpL2R1Y2tzL3NlbmQvc2VuZC5qcyIsInVpL2hlbHBlcnMvY29uc3RhbnRzL2NvbW1vbi5qcyIsInVpL2hlbHBlcnMvY29uc3RhbnRzL2Rlc2lnbi1zeXN0ZW0uanMiLCJ1aS9oZWxwZXJzL2NvbnN0YW50cy9lcnJvci1rZXlzLmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvcm91dGVzLmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvdHJhbnNhY3Rpb25zLmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvemVuZGVzay11cmwuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL2NvbmZpcm0tdHgudXRpbC5qcyIsInVpL2hlbHBlcnMvdXRpbHMvY29udmVyc2lvbnMudXRpbC5qcyIsInVpL2hlbHBlcnMvdXRpbHMvZm9ybWF0dGVycy5qcyIsInVpL2hlbHBlcnMvdXRpbHMvaTE4bi1oZWxwZXIuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL21vb25wYXkuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL29wdGltaXNtL2J1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24uanMiLCJ1aS9oZWxwZXJzL3V0aWxzL29wdGltaXNtL2ZldGNoRXN0aW1hdGVkTDFGZWUuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL3Rva2VuLXV0aWwuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL3RyYW5zYWN0aW9ucy51dGlsLmpzIiwidWkvaGVscGVycy91dGlscy90eC1oZWxwZXIuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL3V0aWwuanMiLCJ1aS9wYWdlcy9jb25maXJtYXRpb24vdGVtcGxhdGVzL2FkZC1ldGhlcmV1bS1jaGFpbi5qcyIsInVpL3BhZ2VzL2NvbmZpcm1hdGlvbi90ZW1wbGF0ZXMvaW5kZXguanMiLCJ1aS9wYWdlcy9jb25maXJtYXRpb24vdGVtcGxhdGVzL3N3aXRjaC1ldGhlcmV1bS1jaGFpbi5qcyIsInVpL3BhZ2VzL3NlbmQvc2VuZC5jb25zdGFudHMuanMiLCJ1aS9wYWdlcy9zZW5kL3NlbmQudXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDam9CQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzd2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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dEMsVUFDRSx1R0FOb0M7RUFPdEMsUUFBUSw0Q0FQOEI7RUFRdEMsWUFBWSx5REFSMEI7RUFTdEMsT0FDRSwrR0FBQTtDQVZHLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0RQO0FBQ08sTUFBTSx5QkFBeUIsR0FBRyxFQUFsQyxDLENBRVA7QUFDQTs7O0FBQ08sTUFBTSw2QkFBNkIsR0FBRyxDQUF0QyxDLENBRVA7QUFDQTs7O0FBQ08sTUFBTSwyQkFBMkIsR0FBRyxDQUFwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RQOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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SSxDQUFDLENBQUMsUUFBRixDQUFXLEVBQVgsQ0FBZSxFQUFwQixDQUFzQixLQUF0QixDQUE0QixDQUFDLENBQTdCLENBTlgsRUFRRyxJQVJILENBUVEsRUFSUixDQUZGO0FBWUQ7O0FBRUQsU0FBUyxvQkFBVCxDQUE4QjtFQUFFLFNBQUY7RUFBYSxXQUFiO0VBQTBCLFNBQTFCO0VBQXFDO0FBQXJDLENBQTlCLEVBQTZFO0VBQzNFLFFBQVEsU0FBUyxDQUFDLFFBQWxCO0lBQ0UsS0FBSyxtQkFBTDtNQUNFLE9BQU8sMEJBQTBCLENBQUM7UUFDaEMsU0FEZ0M7UUFFaEMsV0FGZ0M7UUFHaEMsT0FBTyxFQUFFLFNBQVMsQ0FBQztNQUhhLENBQUQsQ0FBakM7O0lBS0YsS0FBSyxrQkFBTDtJQUNBO01BQ0UsT0FBTyx5QkFBeUIsQ0FBQztRQUMvQixTQUQrQjtRQUUvQixNQUYrQjtRQUcvQjtNQUgrQixDQUFELENBQWhDO0VBVEo7QUFlRDs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsRUFBeUIsS0FBSyxHQUFHLENBQWpDLEVBQW9DLElBQUksR0FBRyxDQUEzQyxFQUE4QztFQUM1QyxPQUFRLEdBQUUsSUFBSSxDQUFDLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFxQixNQUFLLElBQUksQ0FBQyxLQUFMLENBQVcsQ0FBQyxJQUFaLENBQWtCLEVBQXREO0FBQ0QiLCJmaWxlIjoiY29tbW9uLTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVnZXguanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgX3JlZ2V4LmRlZmF1bHQudGVzdCh1dWlkKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmFsaWRhdGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCEoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnN1YnN0cigxNCwgMSksIDE2KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmVyc2lvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIihmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5pc191cmkgPSBpc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfaHR0cF91cmkgPSBpc19odHRwX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc19odHRwc191cmkgPSBpc19odHRwc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfd2ViX3VyaSA9IGlzX3dlYl9pcmk7XG4gICAgLy8gQ3JlYXRlIGFsaWFzZXNcbiAgICBtb2R1bGUuZXhwb3J0cy5pc1VyaSA9IGlzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc0h0dHBVcmkgPSBpc19odHRwX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc0h0dHBzVXJpID0gaXNfaHR0cHNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzV2ViVXJpID0gaXNfd2ViX2lyaTtcblxuXG4gICAgLy8gcHJpdmF0ZSBmdW5jdGlvblxuICAgIC8vIGludGVybmFsIFVSSSBzcGl0dGVyIG1ldGhvZCAtIGRpcmVjdCBmcm9tIFJGQyAzOTg2XG4gICAgdmFyIHNwbGl0VXJpID0gZnVuY3Rpb24odXJpKSB7XG4gICAgICAgIHZhciBzcGxpdHRlZCA9IHVyaS5tYXRjaCgvKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IyguKikpPy8pO1xuICAgICAgICByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzX2lyaSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgICAgIGlmICgvW15hLXowLTlcXDpcXC9cXD9cXCNcXFtcXF1cXEBcXCFcXCRcXCZcXCdcXChcXClcXCpcXCtcXCxcXDtcXD1cXC5cXC1cXF9cXH5cXCVdL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcblxuICAgICAgICAvLyBjaGVjayBmb3IgaGV4IGVzY2FwZXMgdGhhdCBhcmVuJ3QgY29tcGxldGVcbiAgICAgICAgaWYgKC8lW14wLTlhLWZdL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgaWYgKC8lWzAtOWEtZl0oOj9bXjAtOWEtZl18JCkvaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1lID0gJyc7XG4gICAgICAgIHZhciBhdXRob3JpdHkgPSAnJztcbiAgICAgICAgdmFyIHBhdGggPSAnJztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gJyc7XG4gICAgICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgICAgLy8gZnJvbSBSRkMgMzk4NlxuICAgICAgICBzcGxpdHRlZCA9IHNwbGl0VXJpKHZhbHVlKTtcbiAgICAgICAgc2NoZW1lID0gc3BsaXR0ZWRbMV07IFxuICAgICAgICBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgICAgICAgcGF0aCA9IHNwbGl0dGVkWzNdO1xuICAgICAgICBxdWVyeSA9IHNwbGl0dGVkWzRdO1xuICAgICAgICBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuXG4gICAgICAgIC8vIHNjaGVtZSBhbmQgcGF0aCBhcmUgcmVxdWlyZWQsIHRob3VnaCB0aGUgcGF0aCBjYW4gYmUgZW1wdHlcbiAgICAgICAgaWYgKCEoc2NoZW1lICYmIHNjaGVtZS5sZW5ndGggJiYgcGF0aC5sZW5ndGggPj0gMCkpIHJldHVybjtcblxuICAgICAgICAvLyBpZiBhdXRob3JpdHkgaXMgcHJlc2VudCwgdGhlIHBhdGggbXVzdCBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgL1xuICAgICAgICBpZiAoYXV0aG9yaXR5ICYmIGF1dGhvcml0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGgubGVuZ3RoID09PSAwIHx8IC9eXFwvLy50ZXN0KHBhdGgpKSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgYXV0aG9yaXR5IGlzIG5vdCBwcmVzZW50LCB0aGUgcGF0aCBtdXN0IG5vdCBzdGFydCB3aXRoIC8vXG4gICAgICAgICAgICBpZiAoL15cXC9cXC8vLnRlc3QocGF0aCkpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjaGVtZSBtdXN0IGJlZ2luIHdpdGggYSBsZXR0ZXIsIHRoZW4gY29uc2lzdCBvZiBsZXR0ZXJzLCBkaWdpdHMsICssIC4sIG9yIC1cbiAgICAgICAgaWYgKCEvXlthLXpdW2EtejAtOVxcK1xcLVxcLl0qJC8udGVzdChzY2hlbWUudG9Mb3dlckNhc2UoKSkpICByZXR1cm47XG5cbiAgICAgICAgLy8gcmUtYXNzZW1ibGUgdGhlIFVSTCBwZXIgc2VjdGlvbiA1LjMgaW4gUkZDIDM5ODZcbiAgICAgICAgb3V0ICs9IHNjaGVtZSArICc6JztcbiAgICAgICAgaWYgKGF1dGhvcml0eSAmJiBhdXRob3JpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQgKz0gJy8vJyArIGF1dGhvcml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBwYXRoO1xuXG4gICAgICAgIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnIycgKyBmcmFnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfaHR0cF9pcmkodmFsdWUsIGFsbG93SHR0cHMpIHtcbiAgICAgICAgaWYgKCFpc19pcmkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BsaXR0ZWQgPSBbXTtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICcnO1xuICAgICAgICB2YXIgYXV0aG9yaXR5ID0gJyc7XG4gICAgICAgIHZhciBwYXRoID0gJyc7XG4gICAgICAgIHZhciBwb3J0ID0gJyc7XG4gICAgICAgIHZhciBxdWVyeSA9ICcnO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuXG4gICAgICAgIC8vIGZyb20gUkZDIDM5ODZcbiAgICAgICAgc3BsaXR0ZWQgPSBzcGxpdFVyaSh2YWx1ZSk7XG4gICAgICAgIHNjaGVtZSA9IHNwbGl0dGVkWzFdOyBcbiAgICAgICAgYXV0aG9yaXR5ID0gc3BsaXR0ZWRbMl07XG4gICAgICAgIHBhdGggPSBzcGxpdHRlZFszXTtcbiAgICAgICAgcXVlcnkgPSBzcGxpdHRlZFs0XTtcbiAgICAgICAgZnJhZ21lbnQgPSBzcGxpdHRlZFs1XTtcblxuICAgICAgICBpZiAoIXNjaGVtZSkgIHJldHVybjtcblxuICAgICAgICBpZihhbGxvd0h0dHBzKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2h0dHBzJykgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjaGVtZS50b0xvd2VyQ2FzZSgpICE9ICdodHRwJykgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVsbHktcXVhbGlmaWVkIFVSSXMgbXVzdCBoYXZlIGFuIGF1dGhvcml0eSBzZWN0aW9uIHRoYXQgaXNcbiAgICAgICAgLy8gYSB2YWxpZCBob3N0XG4gICAgICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmFibGUgcG9ydCBjb21wb25lbnRcbiAgICAgICAgaWYgKC86KFxcZCspJC8udGVzdChhdXRob3JpdHkpKSB7XG4gICAgICAgICAgICBwb3J0ID0gYXV0aG9yaXR5Lm1hdGNoKC86KFxcZCspJC8pWzBdO1xuICAgICAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnJlcGxhY2UoLzpcXGQrJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBzY2hlbWUgKyAnOic7XG4gICAgICAgIG91dCArPSAnLy8nICsgYXV0aG9yaXR5O1xuICAgICAgICBcbiAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgIG91dCArPSBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBvdXQgKz0gcGF0aDtcbiAgICAgICAgXG4gICAgICAgIGlmKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCl7XG4gICAgICAgICAgICBvdXQgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGgpe1xuICAgICAgICAgICAgb3V0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2h0dHBzX2lyaSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNfaHR0cF9pcmkodmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX3dlYl9pcmkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChpc19odHRwX2lyaSh2YWx1ZSkgfHwgaXNfaHR0cHNfaXJpKHZhbHVlKSk7XG4gICAgfVxuXG59KShtb2R1bGUpO1xuIiwidmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoeHMsIGl0ZW0pIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoaXRlbSk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG52YXIgT2JqZWN0X2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxudmFyIGRlZmluZVByb3AgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnXycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcblxudmFyIGdsb2JhbHMgPSBbJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdFcnJvcicsICdFdmFsRXJyb3InLCAnRnVuY3Rpb24nLFxuJ0luZmluaXR5JywgJ0pTT04nLCAnTWF0aCcsICdOYU4nLCAnTnVtYmVyJywgJ09iamVjdCcsICdSYW5nZUVycm9yJyxcbidSZWZlcmVuY2VFcnJvcicsICdSZWdFeHAnLCAnU3RyaW5nJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvcicsXG4nZGVjb2RlVVJJJywgJ2RlY29kZVVSSUNvbXBvbmVudCcsICdlbmNvZGVVUkknLCAnZW5jb2RlVVJJQ29tcG9uZW50JywgJ2VzY2FwZScsXG4nZXZhbCcsICdpc0Zpbml0ZScsICdpc05hTicsICdwYXJzZUZsb2F0JywgJ3BhcnNlSW50JywgJ3VuZGVmaW5lZCcsICd1bmVzY2FwZSddO1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge31cbkNvbnRleHQucHJvdG90eXBlID0ge307XG5cbnZhciBTY3JpcHQgPSBleHBvcnRzLlNjcmlwdCA9IGZ1bmN0aW9uIE5vZGVTY3JpcHQgKGNvZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NyaXB0KSkgcmV0dXJuIG5ldyBTY3JpcHQoY29kZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5Db250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoIShjb250ZXh0IGluc3RhbmNlb2YgQ29udGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5lZWRzIGEgJ2NvbnRleHQnIGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmICghaWZyYW1lLnN0eWxlKSBpZnJhbWUuc3R5bGUgPSB7fTtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgdmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHZhciB3RXZhbCA9IHdpbi5ldmFsLCB3RXhlY1NjcmlwdCA9IHdpbi5leGVjU2NyaXB0O1xuXG4gICAgaWYgKCF3RXZhbCAmJiB3RXhlY1NjcmlwdCkge1xuICAgICAgICAvLyB3aW4uKDAsZXZhbCkoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKDAsZXZhbCkodGhpcy5jb2RlKTsgLy8gbWF5YmUuLi5cbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5OZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY3R4ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQoY29udGV4dCk7XG4gICAgdmFyIHJlcyA9IHRoaXMucnVuSW5Db250ZXh0KGN0eCk7XG5cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGN0eCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IGN0eFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufTtcblxuZm9yRWFjaChPYmplY3Rfa2V5cyhTY3JpcHQucHJvdG90eXBlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBleHBvcnRzW25hbWVdID0gU2NyaXB0W25hbWVdID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIHMgPSBTY3JpcHQoY29kZSk7XG4gICAgICAgIHJldHVybiBzW25hbWVdLmFwcGx5KHMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfTtcbn0pO1xuXG5leHBvcnRzLmlzQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0O1xufTtcblxuZXhwb3J0cy5jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBleHBvcnRzLlNjcmlwdChjb2RlKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY29weSA9IG5ldyBDb250ZXh0KCk7XG4gICAgaWYodHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufTtcbiIsImNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IGV0aFV0aWwgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKVxuY29uc3QgRXRoQmxvY2tUcmFja2VyID0gcmVxdWlyZSgnZXRoLWJsb2NrLXRyYWNrZXInKVxuY29uc3QgbWFwID0gcmVxdWlyZSgnYXN5bmMvbWFwJylcbmNvbnN0IGVhY2hTZXJpZXMgPSByZXF1aXJlKCdhc3luYy9lYWNoU2VyaWVzJylcbmNvbnN0IFN0b3BsaWdodCA9IHJlcXVpcmUoJy4vdXRpbC9zdG9wbGlnaHQuanMnKVxuY29uc3QgY2FjaGVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbC9ycGMtY2FjaGUtdXRpbHMuanMnKVxuY29uc3QgY3JlYXRlUGF5bG9hZCA9IHJlcXVpcmUoJy4vdXRpbC9jcmVhdGUtcGF5bG9hZC5qcycpXG5jb25zdCBub29wID0gZnVuY3Rpb24oKXt9XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViM1Byb3ZpZGVyRW5naW5lXG5cblxuaW5oZXJpdHMoV2ViM1Byb3ZpZGVyRW5naW5lLCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIFdlYjNQcm92aWRlckVuZ2luZShvcHRzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG4gIHNlbGYuc2V0TWF4TGlzdGVuZXJzKDMwKVxuICAvLyBwYXJzZSBvcHRpb25zXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgLy8gYmxvY2sgcG9sbGluZ1xuICBjb25zdCBkaXJlY3RQcm92aWRlciA9IHsgc2VuZEFzeW5jOiBzZWxmLl9oYW5kbGVBc3luYy5iaW5kKHNlbGYpIH1cbiAgY29uc3QgYmxvY2tUcmFja2VyUHJvdmlkZXIgPSBvcHRzLmJsb2NrVHJhY2tlclByb3ZpZGVyIHx8IGRpcmVjdFByb3ZpZGVyXG4gIHNlbGYuX2Jsb2NrVHJhY2tlciA9IG9wdHMuYmxvY2tUcmFja2VyIHx8IG5ldyBFdGhCbG9ja1RyYWNrZXIoe1xuICAgIHByb3ZpZGVyOiBibG9ja1RyYWNrZXJQcm92aWRlcixcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IG9wdHMucG9sbGluZ0ludGVydmFsIHx8IDQwMDAsXG4gICAgc2V0U2tpcENhY2hlRmxhZzogdHJ1ZSxcbiAgfSlcblxuICAvLyBzZXQgaW5pdGlhbGl6YXRpb24gYmxvY2tlclxuICBzZWxmLl9yZWFkeSA9IG5ldyBTdG9wbGlnaHQoKVxuXG4gIC8vIGxvY2FsIHN0YXRlXG4gIHNlbGYuY3VycmVudEJsb2NrID0gbnVsbFxuICBzZWxmLl9wcm92aWRlcnMgPSBbXVxufVxuXG4vLyBwdWJsaWNcblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNiID0gbm9vcCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgLy8gdHJpZ2dlciBzdGFydFxuICBzZWxmLl9yZWFkeS5nbygpXG5cbiAgLy8gb24gbmV3IGJsb2NrLCByZXF1ZXN0IGJsb2NrIGJvZHkgYW5kIGVtaXQgYXMgZXZlbnRzXG4gIHNlbGYuX2Jsb2NrVHJhY2tlci5vbignbGF0ZXN0JywgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgLy8gZ2V0IGJsb2NrIGJvZHlcbiAgICBzZWxmLl9nZXRCbG9ja0J5TnVtYmVyV2l0aFJldHJ5KGJsb2NrTnVtYmVyLCAoZXJyLCBibG9jaykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coYmxvY2spXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJCbG9jayA9IHRvQnVmZmVyQmxvY2soYmxvY2spXG4gICAgICAvLyBzZXQgY3VycmVudCArIGVtaXQgXCJibG9ja1wiIGV2ZW50XG4gICAgICBzZWxmLl9zZXRDdXJyZW50QmxvY2soYnVmZmVyQmxvY2spXG4gICAgICAvLyBlbWl0IG90aGVyIGV2ZW50c1xuICAgICAgc2VsZi5lbWl0KCdyYXdCbG9jaycsIGJsb2NrKVxuICAgICAgc2VsZi5lbWl0KCdsYXRlc3QnLCBibG9jaylcbiAgICB9KVxuICB9KVxuXG4gIC8vIGZvcndhcmQgb3RoZXIgZXZlbnRzXG4gIHNlbGYuX2Jsb2NrVHJhY2tlci5vbignc3luYycsIHNlbGYuZW1pdC5iaW5kKHNlbGYsICdzeW5jJykpXG4gIHNlbGYuX2Jsb2NrVHJhY2tlci5vbignZXJyb3InLCBzZWxmLmVtaXQuYmluZChzZWxmLCAnZXJyb3InKSlcblxuICAvLyB1cGRhdGUgc3RhdGVcbiAgc2VsZi5fcnVubmluZyA9IHRydWVcbiAgLy8gc2lnbmFsIHRoYXQgd2Ugc3RhcnRlZFxuICBzZWxmLmVtaXQoJ3N0YXJ0Jylcbn1cblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLy8gc3RvcCBibG9jayBwb2xsaW5nIGJ5IHJlbW92aW5nIGV2ZW50IGxpc3RlbmVyc1xuICBzZWxmLl9ibG9ja1RyYWNrZXIucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgLy8gdXBkYXRlIHN0YXRlXG4gIHNlbGYuX3J1bm5pbmcgPSBmYWxzZVxuICAvLyBzaWduYWwgdGhhdCB3ZSBzdG9wcGVkXG4gIHNlbGYuZW1pdCgnc3RvcCcpXG59XG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuaXNSdW5uaW5nID0gZnVuY3Rpb24oKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHNlbGYuX3J1bm5pbmdcbn1cblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5hZGRQcm92aWRlciA9IGZ1bmN0aW9uKHNvdXJjZSwgaW5kZXgpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgIHNlbGYuX3Byb3ZpZGVycy5zcGxpY2UoaW5kZXgsIDAsIHNvdXJjZSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9wcm92aWRlcnMucHVzaChzb3VyY2UpXG4gIH1cbiAgc291cmNlLnNldEVuZ2luZSh0aGlzKVxufVxuXG5XZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLnJlbW92ZVByb3ZpZGVyID0gZnVuY3Rpb24oc291cmNlKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgaW5kZXggPSBzZWxmLl9wcm92aWRlcnMuaW5kZXhPZihzb3VyY2UpXG4gIGlmIChpbmRleCA8IDApIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgbm90IGZvdW5kLicpXG4gIHNlbGYuX3Byb3ZpZGVycy5zcGxpY2UoaW5kZXgsIDEpXG59XG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBheWxvYWQpe1xuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYjNQcm92aWRlckVuZ2luZSBkb2VzIG5vdCBzdXBwb3J0IHN5bmNocm9ub3VzIHJlcXVlc3RzLicpXG59XG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24ocGF5bG9hZCwgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLl9yZWFkeS5hd2FpdChmdW5jdGlvbigpe1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgIC8vIGhhbmRsZSBiYXRjaFxuICAgICAgbWFwKHBheWxvYWQsIHNlbGYuX2hhbmRsZUFzeW5jLmJpbmQoc2VsZiksIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgc2luZ2xlXG4gICAgICBzZWxmLl9oYW5kbGVBc3luYyhwYXlsb2FkLCBjYilcbiAgICB9XG5cbiAgfSlcbn1cblxuLy8gcHJpdmF0ZVxuXG5XZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLl9nZXRCbG9ja0J5TnVtYmVyV2l0aFJldHJ5ID0gZnVuY3Rpb24oYmxvY2tOdW1iZXIsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgbGV0IHJldHJpZXNSZW1haW5pbmcgPSA1XG5cbiAgYXR0ZW1wdFJlcXVlc3QoKVxuICByZXR1cm5cblxuICBmdW5jdGlvbiBhdHRlbXB0UmVxdWVzdCAoKSB7XG4gICAgc2VsZi5fZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlciwgYWZ0ZXJSZXF1ZXN0KVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJSZXF1ZXN0IChlcnIsIGJsb2NrKSB7XG4gICAgLy8gYW5vbWFsb3VzIGVycm9yIG9jY3VycmVkXG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAvLyBibG9jayBub3QgcmVhZHkgeWV0XG4gICAgaWYgKCFibG9jaykge1xuICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgIC8vIHdhaXQgMXMgdGhlbiB0cnkgYWdhaW5cbiAgICAgICAgcmV0cmllc1JlbWFpbmluZy0tXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGF0dGVtcHRSZXF1ZXN0KClcbiAgICAgICAgfSwgMTAwMClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnaXZlIHVwLCByZXR1cm4gYSBudWxsIGJsb2NrXG4gICAgICAgIGNiKG51bGwsIG51bGwpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgcmV0dXJuIHJlc3VsdFxuICAgIGNiKG51bGwsIGJsb2NrKVxuICAgIHJldHVyblxuICB9XG59XG5cblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5fZ2V0QmxvY2tCeU51bWJlciA9IGZ1bmN0aW9uKGJsb2NrTnVtYmVyLCBjYikge1xuICBjb25zdCByZXEgPSBjcmVhdGVQYXlsb2FkKHsgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBwYXJhbXM6IFtibG9ja051bWJlciwgZmFsc2VdLCBza2lwQ2FjaGU6IHRydWUgfSlcbiAgdGhpcy5faGFuZGxlQXN5bmMocmVxLCAoZXJyLCByZXMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBjYihudWxsLCByZXMucmVzdWx0KVxuICB9KVxufVxuXG5XZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLl9oYW5kbGVBc3luYyA9IGZ1bmN0aW9uKHBheWxvYWQsIGZpbmlzaGVkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgY3VycmVudFByb3ZpZGVyID0gLTFcbiAgdmFyIHJlc3VsdCA9IG51bGxcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIHZhciBzdGFjayA9IFtdXG5cbiAgbmV4dCgpXG5cbiAgZnVuY3Rpb24gbmV4dChhZnRlcikge1xuICAgIGN1cnJlbnRQcm92aWRlciArPSAxXG4gICAgc3RhY2sudW5zaGlmdChhZnRlcilcblxuICAgIC8vIEJ1YmJsZWQgZG93biBhcyBmYXIgYXMgd2UgY291bGQgZ28sIGFuZCB0aGUgcmVxdWVzdCB3YXNuJ3RcbiAgICAvLyBoYW5kbGVkLiBSZXR1cm4gYW4gZXJyb3IuXG4gICAgaWYgKGN1cnJlbnRQcm92aWRlciA+PSBzZWxmLl9wcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICBlbmQobmV3IEVycm9yKCdSZXF1ZXN0IGZvciBtZXRob2QgXCInICsgcGF5bG9hZC5tZXRob2QgKyAnXCIgbm90IGhhbmRsZWQgYnkgYW55IHN1YnByb3ZpZGVyLiBQbGVhc2UgY2hlY2sgeW91ciBzdWJwcm92aWRlciBjb25maWd1cmF0aW9uIHRvIGVuc3VyZSB0aGlzIG1ldGhvZCBpcyBoYW5kbGVkLicpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSBzZWxmLl9wcm92aWRlcnNbY3VycmVudFByb3ZpZGVyXVxuICAgICAgICBwcm92aWRlci5oYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kKGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kKF9lcnJvciwgX3Jlc3VsdCkge1xuICAgIGVycm9yID0gX2Vycm9yXG4gICAgcmVzdWx0ID0gX3Jlc3VsdFxuXG4gICAgZWFjaFNlcmllcyhzdGFjaywgZnVuY3Rpb24oZm4sIGNhbGxiYWNrKSB7XG5cbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihlcnJvciwgcmVzdWx0LCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlc3VsdE9iaiA9IHtcbiAgICAgICAgaWQ6IHBheWxvYWQuaWQsXG4gICAgICAgIGpzb25ycGM6IHBheWxvYWQuanNvbnJwYyxcbiAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0T2JqLmVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLnN0YWNrIHx8IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IsXG4gICAgICAgICAgY29kZTogLTMyMDAwXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzcG9uZCB3aXRoIGJvdGggZXJyb3IgZm9ybWF0c1xuICAgICAgICBmaW5pc2hlZChlcnJvciwgcmVzdWx0T2JqKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoZWQobnVsbCwgcmVzdWx0T2JqKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLy9cbi8vIGZyb20gcmVtb3RlLWRhdGFcbi8vXG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuX3NldEN1cnJlbnRCbG9jayA9IGZ1bmN0aW9uKGJsb2NrKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgc2VsZi5jdXJyZW50QmxvY2sgPSBibG9ja1xuICBzZWxmLmVtaXQoJ2Jsb2NrJywgYmxvY2spXG59XG5cbi8vIHV0aWxcblxuZnVuY3Rpb24gdG9CdWZmZXJCbG9jayAoanNvbkJsb2NrKSB7XG4gIHJldHVybiB7XG4gICAgbnVtYmVyOiAgICAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2subnVtYmVyKSxcbiAgICBoYXNoOiAgICAgICAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5oYXNoKSxcbiAgICBwYXJlbnRIYXNoOiAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5wYXJlbnRIYXNoKSxcbiAgICBub25jZTogICAgICAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5ub25jZSksXG4gICAgbWl4SGFzaDogICAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2subWl4SGFzaCksXG4gICAgc2hhM1VuY2xlczogICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2suc2hhM1VuY2xlcyksXG4gICAgbG9nc0Jsb29tOiAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2subG9nc0Jsb29tKSxcbiAgICB0cmFuc2FjdGlvbnNSb290OiBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay50cmFuc2FjdGlvbnNSb290KSxcbiAgICBzdGF0ZVJvb3Q6ICAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5zdGF0ZVJvb3QpLFxuICAgIHJlY2VpcHRzUm9vdDogICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLnJlY2VpcHRSb290IHx8IGpzb25CbG9jay5yZWNlaXB0c1Jvb3QpLFxuICAgIG1pbmVyOiAgICAgICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLm1pbmVyKSxcbiAgICBkaWZmaWN1bHR5OiAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5kaWZmaWN1bHR5KSxcbiAgICB0b3RhbERpZmZpY3VsdHk6ICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay50b3RhbERpZmZpY3VsdHkpLFxuICAgIHNpemU6ICAgICAgICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLnNpemUpLFxuICAgIGV4dHJhRGF0YTogICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLmV4dHJhRGF0YSksXG4gICAgZ2FzTGltaXQ6ICAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2suZ2FzTGltaXQpLFxuICAgIGdhc1VzZWQ6ICAgICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLmdhc1VzZWQpLFxuICAgIHRpbWVzdGFtcDogICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLnRpbWVzdGFtcCksXG4gICAgdHJhbnNhY3Rpb25zOiAgICAganNvbkJsb2NrLnRyYW5zYWN0aW9ucyxcbiAgfVxufVxuIiwiY29uc3QgRXRoUXVlcnkgPSByZXF1aXJlKCdldGgtcXVlcnknKVxuY29uc3QgcGlmeSA9IHJlcXVpcmUoJ3BpZnknKVxuY29uc3QgU2FmZUV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ3NhZmUtZXZlbnQtZW1pdHRlcicpXG5cbmNvbnN0IHNlYyA9IDEwMDBcblxuY29uc3QgY2FsY3VsYXRlU3VtID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlXG5jb25zdCBibG9ja1RyYWNrZXJFdmVudHMgPSBbJ3N5bmMnLCAnbGF0ZXN0J11cblxuY2xhc3MgQmFzZUJsb2NrVHJhY2tlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuXG4gIC8vXG4gIC8vIHB1YmxpY1xuICAvL1xuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgLy8gY29uZmlnXG4gICAgdGhpcy5fYmxvY2tSZXNldER1cmF0aW9uID0gb3B0cy5ibG9ja1Jlc2V0RHVyYXRpb24gfHwgMjAgKiBzZWNcbiAgICAvLyBzdGF0ZVxuICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0XG4gICAgdGhpcy5fY3VycmVudEJsb2NrID0gbnVsbFxuICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlXG4gICAgLy8gYmluZCBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICAgIHRoaXMuX29uTmV3TGlzdGVuZXIgPSB0aGlzLl9vbk5ld0xpc3RlbmVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpXG4gICAgLy8gbGlzdGVuIGZvciBoYW5kbGVyIGNoYW5nZXNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgfVxuXG4gIGlzUnVubmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZ1xuICB9XG5cbiAgZ2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrXG4gIH1cblxuICBhc3luYyBnZXRMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gcmV0dXJuIGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLl9jdXJyZW50QmxvY2spIHJldHVybiB0aGlzLl9jdXJyZW50QmxvY2tcbiAgICAvLyB3YWl0IGZvciBhIG5ldyBsYXRlc3QgYmxvY2tcbiAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5vbmNlKCdsYXRlc3QnLCByZXNvbHZlKSlcbiAgICAvLyByZXR1cm4gbmV3bHkgc2V0IGN1cnJlbnQgYmxvY2tcbiAgICByZXR1cm4gbGF0ZXN0QmxvY2tcbiAgfVxuXG4gIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUFsbExpc3RlbmVycyAoZXZlbnROYW1lKSB7XG4gICAgLy8gcGVyZm9ybSBkZWZhdWx0IGJlaGF2aW9yLCBwcmVzZXJ2ZSBmbiBhcml0eVxuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpXG4gICAgfVxuICAgIC8vIHJlLWFkZCBpbnRlcm5hbCBldmVudHNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgICAvLyB0cmlnZ2VyIHN0b3AgY2hlY2sganVzdCBpbiBjYXNlXG4gICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpXG4gIH1cblxuICAvL1xuICAvLyB0byBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAvL1xuXG4gIF9zdGFydCAoKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gIH1cblxuICBfZW5kICgpIHtcbiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc2V0dXBJbnRlcm5hbEV2ZW50cyAoKSB7XG4gICAgLy8gZmlyc3QgcmVtb3ZlIGxpc3RlbmVycyBmb3IgaWRlbXBvdGVuY2VcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICB9XG5cbiAgX29uTmV3TGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGBuZXdMaXN0ZW5lcmAgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgIGlmICghYmxvY2tUcmFja2VyRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHJldHVyblxuICAgIHRoaXMuX21heWJlU3RhcnQoKVxuICB9XG5cbiAgX29uUmVtb3ZlTGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGByZW1vdmVMaXN0ZW5lcmAgaXMgY2FsbGVkICphZnRlciogdGhlIGxpc3RlbmVyIGlzIHJlbW92ZWRcbiAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkgcmV0dXJuXG4gICAgdGhpcy5fbWF5YmVFbmQoKVxuICB9XG5cbiAgX21heWJlU3RhcnQgKCkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHJldHVyblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWVcbiAgICAvLyBjYW5jZWwgc2V0dGluZyBsYXRlc3QgYmxvY2sgdG8gc3RhbGVcbiAgICB0aGlzLl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCgpXG4gICAgdGhpcy5fc3RhcnQoKVxuICB9XG5cbiAgX21heWJlRW5kICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzUnVubmluZykgcmV0dXJuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KClcbiAgICB0aGlzLl9lbmQoKVxuICB9XG5cbiAgX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQgKCkge1xuICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHNcbiAgICAgIC5tYXAoZXZlbnROYW1lID0+IHRoaXMubGlzdGVuZXJDb3VudChldmVudE5hbWUpKVxuICAgICAgLnJlZHVjZShjYWxjdWxhdGVTdW0pXG4gIH1cblxuICBfbmV3UG90ZW50aWFsTGF0ZXN0IChuZXdCbG9jaykge1xuICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIC8vIG9ubHkgdXBkYXRlIGlmIGJsb2sgbnVtYmVyIGlzIGhpZ2hlclxuICAgIGlmIChjdXJyZW50QmxvY2sgJiYgKGhleFRvSW50KG5ld0Jsb2NrKSA8PSBoZXhUb0ludChjdXJyZW50QmxvY2spKSkgcmV0dXJuXG4gICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKVxuICB9XG5cbiAgX3NldEN1cnJlbnRCbG9jayAobmV3QmxvY2spIHtcbiAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIHRoaXMuX2N1cnJlbnRCbG9jayA9IG5ld0Jsb2NrXG4gICAgdGhpcy5lbWl0KCdsYXRlc3QnLCBuZXdCbG9jaylcbiAgICB0aGlzLmVtaXQoJ3N5bmMnLCB7IG9sZEJsb2NrLCBuZXdCbG9jayB9KVxuICB9XG5cbiAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQgKCkge1xuICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKVxuICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24pXG4gICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfVxuXG4gIF9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KVxuICB9XG5cbiAgX3Jlc2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VCbG9ja1RyYWNrZXJcblxuZnVuY3Rpb24gaGV4VG9JbnQoaGV4SW50KSB7XG4gIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaGV4SW50LCAxNilcbn1cbiIsImNvbnN0IHBpZnkgPSByZXF1aXJlKCdwaWZ5JylcbmNvbnN0IEJhc2VCbG9ja1RyYWNrZXIgPSByZXF1aXJlKCcuL2Jhc2UnKVxuXG5jb25zdCBzZWMgPSAxMDAwXG5cbmNsYXNzIFBvbGxpbmdCbG9ja1RyYWNrZXIgZXh0ZW5kcyBCYXNlQmxvY2tUcmFja2VyIHtcblxuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJylcbiAgICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSBvcHRzLnBvbGxpbmdJbnRlcnZhbCB8fCAyMCAqIHNlY1xuICAgIGNvbnN0IHJldHJ5VGltZW91dCA9IG9wdHMucmV0cnlUaW1lb3V0IHx8IHBvbGxpbmdJbnRlcnZhbCAvIDEwXG4gICAgY29uc3Qga2VlcEV2ZW50TG9vcEFjdGl2ZSA9IG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5rZWVwRXZlbnRMb29wQWN0aXZlIDogdHJ1ZVxuICAgIGNvbnN0IHNldFNraXBDYWNoZUZsYWcgPSBvcHRzLnNldFNraXBDYWNoZUZsYWcgfHwgZmFsc2VcbiAgICAvLyBCYXNlQmxvY2tUcmFja2VyIGNvbnN0cnVjdG9yXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7XG4gICAgICBibG9ja1Jlc2V0RHVyYXRpb246IHBvbGxpbmdJbnRlcnZhbCxcbiAgICB9LCBvcHRzKSlcbiAgICAvLyBjb25maWdcbiAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWxcbiAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSByZXRyeVRpbWVvdXRcbiAgICB0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlID0ga2VlcEV2ZW50TG9vcEFjdGl2ZVxuICAgIHRoaXMuX3NldFNraXBDYWNoZUZsYWcgPSBzZXRTa2lwQ2FjaGVGbGFnXG4gIH1cblxuICAvL1xuICAvLyBwdWJsaWNcbiAgLy9cblxuICAvLyB0cmlnZ2VyIGJsb2NrIHBvbGxpbmdcbiAgYXN5bmMgY2hlY2tGb3JMYXRlc3RCbG9jayAoKSB7XG4gICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKClcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc3RhcnQgKCkge1xuICAgIHRoaXMuX3BlcmZvcm1TeW5jKCkuY2F0Y2goZXJyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKVxuICB9XG5cbiAgYXN5bmMgX3BlcmZvcm1TeW5jICgpIHtcbiAgICB3aGlsZSAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVMYXRlc3RCbG9jaygpXG4gICAgICAgIGF3YWl0IHRpbWVvdXQodGhpcy5fcG9sbGluZ0ludGVydmFsLCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBuZXdFcnIgPSBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBsYXRlc3QgYmxvY2s6XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3RXJyKVxuICAgICAgICB9IGNhdGNoIChlbWl0RXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihuZXdFcnIpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF91cGRhdGVMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gZmV0Y2ggKyBzZXQgbGF0ZXN0IGJsb2NrXG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCB0aGlzLl9mZXRjaExhdGVzdEJsb2NrKClcbiAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QobGF0ZXN0QmxvY2spXG4gIH1cblxuICBhc3luYyBfZmV0Y2hMYXRlc3RCbG9jayAoKSB7XG4gICAgY29uc3QgcmVxID0geyBqc29ucnBjOiBcIjIuMFwiLCBpZDogMSwgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJywgcGFyYW1zOiBbXSB9XG4gICAgaWYgKHRoaXMuX3NldFNraXBDYWNoZUZsYWcpIHJlcS5za2lwQ2FjaGUgPSB0cnVlXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcGlmeSgoY2IpID0+IHRoaXMuX3Byb3ZpZGVyLnNlbmRBc3luYyhyZXEsIGNiKSkoKVxuICAgIGlmIChyZXMuZXJyb3IpIHRocm93IG5ldyBFcnJvcihgUG9sbGluZ0Jsb2NrVHJhY2tlciAtIGVuY291bnRlcmVkIGVycm9yIGZldGNoaW5nIGJsb2NrOlxcbiR7cmVzLmVycm9yfWApXG4gICAgcmV0dXJuIHJlcy5yZXN1bHRcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZ0Jsb2NrVHJhY2tlclxuXG5mdW5jdGlvbiB0aW1lb3V0IChkdXJhdGlvbiwgdW5yZWYpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbW91dFJlZiA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pXG4gICAgLy8gZG9uJ3Qga2VlcCBwcm9jZXNzIG9wZW5cbiAgICBpZiAodGltb3V0UmVmLnVucmVmICYmIHVucmVmKSB7XG4gICAgICB0aW1vdXRSZWYudW5yZWYoKVxuICAgIH1cbiAgfSlcbn1cbiIsImNvbnN0IGNhY2hlVXRpbHMgPSByZXF1aXJlKCcuL2NhY2hlLXV0aWxzLmpzJylcbmNvbnN0IGNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2pzb24tcnBjLWVuZ2luZS9zcmMvY3JlYXRlQXN5bmNNaWRkbGV3YXJlJylcbi8vIGA8bmlsPmAgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE2OTI1XG5jb25zdCBlbXB0eVZhbHVlcyA9IFt1bmRlZmluZWQsIG51bGwsICdcXHUwMDNjbmlsXFx1MDAzZSddXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmVcblxuXG5mdW5jdGlvbiBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZShvcHRzID0ge30pIHtcbiAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICBjb25zdCB7IGJsb2NrVHJhY2tlciB9ID0gb3B0c1xuICBpZiAoIWJsb2NrVHJhY2tlcikgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSAtIE5vIEJsb2NrVHJhY2tlciBzcGVjaWZpZWQnKVxuXG4gIC8vIGNyZWF0ZSBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAgY29uc3QgYmxvY2tDYWNoZSA9IG5ldyBCbG9ja0NhY2hlU3RyYXRlZ3koKVxuICBjb25zdCBzdHJhdGVnaWVzID0ge1xuICAgIHBlcm1hOiBibG9ja0NhY2hlLFxuICAgIGJsb2NrOiBibG9ja0NhY2hlLFxuICAgIGZvcms6IGJsb2NrQ2FjaGUsXG4gIH1cblxuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgIC8vIGFsbG93IGNhY2ggdG8gYmUgc2tpcHBlZCBpZiBzbyBzcGVjaWZpZWRcbiAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cbiAgICAvLyBjaGVjayB0eXBlIGFuZCBtYXRjaGluZyBzdHJhdGVneVxuICAgIGNvbnN0IHR5cGUgPSBjYWNoZVV0aWxzLmNhY2hlVHlwZUZvclBheWxvYWQocmVxKVxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gc3RyYXRlZ2llc1t0eXBlXVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gc3RyYXRlZ3kgaW4gcGxhY2UsIHBhc3MgaXQgZG93biB0aGUgY2hhaW4uXG4gICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3RyYXRlZ3kgY2FuJ3QgY2FjaGUgdGhpcyByZXF1ZXN0LCBpZ25vcmUgaXQuXG4gICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZVJlcXVlc3QocmVxKSkge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cblxuICAgIC8vIGdldCBibG9jayByZWZlcmVuY2UgKG51bWJlciBvciBrZXl3b3JkKVxuICAgIGxldCBibG9ja1RhZyA9IGNhY2hlVXRpbHMuYmxvY2tUYWdGb3JQYXlsb2FkKHJlcSlcbiAgICBpZiAoIWJsb2NrVGFnKSBibG9ja1RhZyA9ICdsYXRlc3QnXG5cbiAgICAvLyBnZXQgZXhhY3QgYmxvY2sgbnVtYmVyXG4gICAgbGV0IHJlcXVlc3RlZEJsb2NrTnVtYmVyXG4gICAgaWYgKGJsb2NrVGFnID09PSAnZWFybGllc3QnKSB7XG4gICAgICAvLyB0aGlzIGp1c3QgZXhpc3RzIGZvciBzeW1tZXRyeSB3aXRoIFwibGF0ZXN0XCJcbiAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gJzB4MDAnXG4gICAgfSBlbHNlIGlmIChibG9ja1RhZyA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgIC8vIGZldGNoIGxhdGVzdCBibG9jayBudW1iZXJcbiAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKClcbiAgICAgIC8vIGNsZWFyIGFsbCBjYWNoZSBiZWZvcmUgbGF0ZXN0IGJsb2NrXG4gICAgICBibG9ja0NhY2hlLmNsZWFyQmVmb3JlKGxhdGVzdEJsb2NrTnVtYmVyKVxuICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBoYXZlIGEgaGV4IG51bWJlclxuICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBibG9ja1RhZ1xuICAgIH1cblxuICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgY29uc3QgY2FjaGVSZXN1bHQgPSBhd2FpdCBzdHJhdGVneS5nZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlcilcbiAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2FjaGUgbWlzc1xuICAgICAgLy8gd2FpdCBmb3Igb3RoZXIgbWlkZGxld2FyZSB0byBoYW5kbGUgcmVxdWVzdFxuICAgICAgYXdhaXQgbmV4dCgpXG4gICAgICAvLyBhZGQgcmVzdWx0IHRvIGNhY2hlXG4gICAgICBhd2FpdCBzdHJhdGVneS5zZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzLnJlc3VsdClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmlsbCBpbiByZXN1bHQgZnJvbSBjYWNoZVxuICAgICAgcmVzLnJlc3VsdCA9IGNhY2hlUmVzdWx0XG4gICAgfVxuICB9KVxufVxuXG5cbi8vXG4vLyBDYWNoZSBTdHJhdGVnaWVzXG4vL1xuXG5jbGFzcyBCbG9ja0NhY2hlU3RyYXRlZ3kge1xuICBcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fVxuICB9XG5cbiAgZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQgKHBheWxvYWQsIGJsb2NrTnVtYmVySGV4KSB7XG4gICAgY29uc3QgYmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tOdW1iZXJIZXgsIDE2KVxuICAgIGxldCBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl1cbiAgICAvLyBjcmVhdGUgbmV3IGNhY2hlIGlmIG5lY2VzYXJ5XG4gICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICBjb25zdCBuZXdDYWNoZSA9IHt9XG4gICAgICB0aGlzLmNhY2hlW2Jsb2NrTnVtYmVyXSA9IG5ld0NhY2hlXG4gICAgICBibG9ja0NhY2hlID0gbmV3Q2FjaGVcbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrQ2FjaGVcbiAgfVxuXG4gIGFzeW5jIGdldCAocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpIHtcbiAgICAvLyBsb29rdXAgYmxvY2sgY2FjaGVcbiAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcilcbiAgICBpZiAoIWJsb2NrQ2FjaGUpIHJldHVyblxuICAgIC8vIGxvb2t1cCBwYXlsb2FkIGluIGJsb2NrIGNhY2hlXG4gICAgY29uc3QgaWRlbnRpZmllciA9IGNhY2hlVXRpbHMuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkLCB0cnVlKVxuICAgIGNvbnN0IGNhY2hlZCA9IGJsb2NrQ2FjaGVbaWRlbnRpZmllcl1cbiAgICAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gICAgcmV0dXJuIGNhY2hlZFxuICB9XG5cbiAgYXN5bmMgc2V0IChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzdWx0KSB7XG4gICAgLy8gY2hlY2sgaWYgd2UgY2FuIGNhY2hlZCB0aGlzIHJlc3VsdFxuICAgIGNvbnN0IGNhbkNhY2hlID0gdGhpcy5jYW5DYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQpXG4gICAgaWYgKCFjYW5DYWNoZSkgcmV0dXJuXG4gICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcilcbiAgICBjb25zdCBpZGVudGlmaWVyID0gY2FjaGVVdGlscy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHRydWUpXG4gICAgYmxvY2tDYWNoZVtpZGVudGlmaWVyXSA9IHJlc3VsdFxuICB9XG5cbiAgY2FuQ2FjaGVSZXF1ZXN0IChwYXlsb2FkKSB7XG4gICAgLy8gY2hlY2sgcmVxdWVzdCBtZXRob2RcbiAgICBpZiAoIWNhY2hlVXRpbHMuY2FuQ2FjaGUocGF5bG9hZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBjaGVjayBibG9ja1RhZ1xuICAgIGNvbnN0IGJsb2NrVGFnID0gY2FjaGVVdGlscy5ibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZClcbiAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIGNhbiBiZSBjYWNoZWRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY2FuQ2FjaGVSZXN1bHQgKHBheWxvYWQsIHJlc3VsdCkge1xuICAgIC8vIG5ldmVyIGNhY2hlIGVtcHR5IHZhbHVlcyAoZS5nLiB1bmRlZmluZWQpXG4gICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkpIHJldHVyblxuICAgIC8vIGNoZWNrIGlmIHRyYW5zYWN0aW9ucyBoYXZlIGJsb2NrIHJlZmVyZW5jZSBiZWZvcmUgY2FjaGluZ1xuICAgIGlmIChbJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0J10uaW5jbHVkZXMocGF5bG9hZC5tZXRob2QpKSB7XG4gICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmJsb2NrSGFzaCB8fCByZXN1bHQuYmxvY2tIYXNoID09PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHRydWVcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcmVtb3ZlcyBhbGwgYmxvY2sgY2FjaGVzIHdpdGggYmxvY2sgbnVtYmVyIGxvd2VyIHRoYW4gYG9sZEJsb2NrSGV4YFxuICBjbGVhckJlZm9yZSAob2xkQmxvY2tIZXgpe1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3Qgb2xkQmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQob2xkQmxvY2tIZXgsIDE2KVxuICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICBPYmplY3Qua2V5cyhzZWxmLmNhY2hlKVxuICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAuZmlsdGVyKG51bSA9PiBudW0gPCBvbGRCbG9ja051bWJlcilcbiAgICAgIC5mb3JFYWNoKG51bSA9PiBkZWxldGUgc2VsZi5jYWNoZVtudW1dKVxuICB9XG5cbn1cbiIsImNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkOiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkLFxuICBjYW5DYWNoZTogY2FuQ2FjaGUsXG4gIGJsb2NrVGFnRm9yUGF5bG9hZDogYmxvY2tUYWdGb3JQYXlsb2FkLFxuICBwYXJhbXNXaXRob3V0QmxvY2tUYWc6IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyxcbiAgYmxvY2tUYWdQYXJhbUluZGV4OiBibG9ja1RhZ1BhcmFtSW5kZXgsXG4gIGNhY2hlVHlwZUZvclBheWxvYWQ6IGNhY2hlVHlwZUZvclBheWxvYWRcbn1cblxuZnVuY3Rpb24gY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZCAocGF5bG9hZCwgc2tpcEJsb2NrUmVmKSB7XG4gIGNvbnN0IHNpbXBsZVBhcmFtcyA9IHNraXBCbG9ja1JlZiA/IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKSA6IHBheWxvYWQucGFyYW1zXG4gIGlmIChjYW5DYWNoZShwYXlsb2FkKSkge1xuICAgIHJldHVybiBwYXlsb2FkLm1ldGhvZCArICc6JyArIHN0cmluZ2lmeShzaW1wbGVQYXJhbXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5DYWNoZSAocGF5bG9hZCkge1xuICByZXR1cm4gY2FjaGVUeXBlRm9yUGF5bG9hZChwYXlsb2FkKSAhPT0gJ25ldmVyJ1xufVxuXG5mdW5jdGlvbiBibG9ja1RhZ0ZvclBheWxvYWQgKHBheWxvYWQpIHtcbiAgbGV0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpXG5cbiAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gIGlmIChpbmRleCA+PSBwYXlsb2FkLnBhcmFtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHBheWxvYWQucGFyYW1zW2luZGV4XVxufVxuXG5mdW5jdGlvbiBwYXJhbXNXaXRob3V0QmxvY2tUYWcgKHBheWxvYWQpIHtcbiAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZClcblxuICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgaWYgKGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtc1xuICB9XG5cbiAgLy8gZXRoX2dldEJsb2NrQnlOdW1iZXIgaGFzIHRoZSBibG9jayB0YWcgZmlyc3QsIHRoZW4gdGhlIG9wdGlvbmFsIGluY2x1ZGVUeD8gcGFyYW1cbiAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDEpXG4gIH1cblxuICByZXR1cm4gcGF5bG9hZC5wYXJhbXMuc2xpY2UoMCwgaW5kZXgpXG59XG5cbmZ1bmN0aW9uIGJsb2NrVGFnUGFyYW1JbmRleCAocGF5bG9hZCkge1xuICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMlxuICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgcmV0dXJuIDJcbiAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAxXG4gICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgcmV0dXJuIDFcbiAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAwXG4gICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgICAgcmV0dXJuIDBcbiAgICAvLyB0aGVyZSBpcyBubyBibG9ja1RhZ1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVUeXBlRm9yUGF5bG9hZCAocGF5bG9hZCkge1xuICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgLy8gY2FjaGUgcGVybWFuZW50bHlcbiAgICBjYXNlICd3ZWIzX2NsaWVudFZlcnNpb24nOlxuICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgY2FzZSAnZXRoX3Byb3RvY29sVmVyc2lvbic6XG4gICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5SGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JzpcbiAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICBjYXNlICdldGhfZ2V0Q29tcGlsZXJzJzpcbiAgICBjYXNlICdldGhfY29tcGlsZUxMTCc6XG4gICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgY2FzZSAnZXRoX2NvbXBpbGVTZXJwZW50JzpcbiAgICBjYXNlICdzaGhfdmVyc2lvbic6XG4gICAgY2FzZSAndGVzdF9wZXJtYUNhY2hlJzpcbiAgICAgIHJldHVybiAncGVybWEnXG5cbiAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgnOlxuICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgY2FzZSAndGVzdF9mb3JrQ2FjaGUnOlxuICAgICAgcmV0dXJuICdmb3JrJ1xuXG4gICAgLy8gY2FjaGUgZm9yIGJsb2NrXG4gICAgY2FzZSAnZXRoX2dhc1ByaWNlJzpcbiAgICBjYXNlICdldGhfYmxvY2tOdW1iZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZUdhcyc6XG4gICAgY2FzZSAnZXRoX2dldEZpbHRlckxvZ3MnOlxuICAgIGNhc2UgJ2V0aF9nZXRMb2dzJzpcbiAgICBjYXNlICd0ZXN0X2Jsb2NrQ2FjaGUnOlxuICAgICAgcmV0dXJuICdibG9jaydcblxuICAgIC8vIG5ldmVyIGNhY2hlXG4gICAgY2FzZSAnbmV0X3ZlcnNpb24nOlxuICAgIGNhc2UgJ25ldF9wZWVyQ291bnQnOlxuICAgIGNhc2UgJ25ldF9saXN0ZW5pbmcnOlxuICAgIGNhc2UgJ2V0aF9zeW5jaW5nJzpcbiAgICBjYXNlICdldGhfc2lnbic6XG4gICAgY2FzZSAnZXRoX2NvaW5iYXNlJzpcbiAgICBjYXNlICdldGhfbWluaW5nJzpcbiAgICBjYXNlICdldGhfaGFzaHJhdGUnOlxuICAgIGNhc2UgJ2V0aF9hY2NvdW50cyc6XG4gICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgY2FzZSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbic6XG4gICAgY2FzZSAnZXRoX25ld0ZpbHRlcic6XG4gICAgY2FzZSAnZXRoX25ld0Jsb2NrRmlsdGVyJzpcbiAgICBjYXNlICdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJzpcbiAgICBjYXNlICdldGhfdW5pbnN0YWxsRmlsdGVyJzpcbiAgICBjYXNlICdldGhfZ2V0RmlsdGVyQ2hhbmdlcyc6XG4gICAgY2FzZSAnZXRoX2dldFdvcmsnOlxuICAgIGNhc2UgJ2V0aF9zdWJtaXRXb3JrJzpcbiAgICBjYXNlICdldGhfc3VibWl0SGFzaHJhdGUnOlxuICAgIGNhc2UgJ2RiX3B1dFN0cmluZyc6XG4gICAgY2FzZSAnZGJfZ2V0U3RyaW5nJzpcbiAgICBjYXNlICdkYl9wdXRIZXgnOlxuICAgIGNhc2UgJ2RiX2dldEhleCc6XG4gICAgY2FzZSAnc2hoX3Bvc3QnOlxuICAgIGNhc2UgJ3NoaF9uZXdJZGVudGl0eSc6XG4gICAgY2FzZSAnc2hoX2hhc0lkZW50aXR5JzpcbiAgICBjYXNlICdzaGhfbmV3R3JvdXAnOlxuICAgIGNhc2UgJ3NoaF9hZGRUb0dyb3VwJzpcbiAgICBjYXNlICdzaGhfbmV3RmlsdGVyJzpcbiAgICBjYXNlICdzaGhfdW5pbnN0YWxsRmlsdGVyJzpcbiAgICBjYXNlICdzaGhfZ2V0RmlsdGVyQ2hhbmdlcyc6XG4gICAgY2FzZSAnc2hoX2dldE1lc3NhZ2VzJzpcbiAgICBjYXNlICd0ZXN0X25ldmVyQ2FjaGUnOlxuICAgICAgcmV0dXJuICduZXZlcidcbiAgfVxufVxuIiwiY29uc3QgZmV0Y2ggPSBnbG9iYWwuZmV0Y2ggfHwgcmVxdWlyZSgnbm9kZS1mZXRjaCcpXG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKVxuY29uc3QgeyBldGhFcnJvcnMgfSA9IHJlcXVpcmUoJ2V0aC1ycGMtZXJyb3JzJylcbmNvbnN0IGJ0b2EgPSByZXF1aXJlKCdidG9hJylcbmNvbnN0IGNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2pzb24tcnBjLWVuZ2luZS9zcmMvY3JlYXRlQXN5bmNNaWRkbGV3YXJlJylcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZldGNoTWlkZGxld2FyZVxubW9kdWxlLmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxXG5cbmNvbnN0IFJFVFJJQUJMRV9FUlJPUlMgPSBbXG4gIC8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG4gICdHYXRld2F5IHRpbWVvdXQnLFxuICAnRVRJTUVET1VUJyxcbiAgLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbiAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICdmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keScsXG4gIC8vIGlnbm9yZSBlcnJvcnMgd2hlcmUgaHR0cCByZXEgZmFpbGVkIHRvIGVzdGFibGlzaFxuICAnRmFpbGVkIHRvIGZldGNoJyxcbl1cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlICh7IHJwY1VybCwgb3JpZ2luSHR0cEhlYWRlcktleSB9KSB7XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgeyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7IHJlcSwgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5IH0pXG5cbiAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDVcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmV0Y2hSZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwgZmV0Y2hQYXJhbXMpXG4gICAgICAgIC8vIGNoZWNrIGZvciBodHRwIGVycnJvcnNcbiAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKVxuICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgIGNvbnN0IHJhd0JvZHkgPSBhd2FpdCBmZXRjaFJlcy50ZXh0KClcbiAgICAgICAgbGV0IGZldGNoQm9keVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZldGNoQm9keSA9IEpTT04ucGFyc2UocmF3Qm9keSlcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2hNaWRkbGV3YXJlIC0gZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHk6IFwiJHtyYXdCb2R5fVwiYClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBmZXRjaEJvZHkpXG4gICAgICAgIC8vIHNldCByZXN1bHQgYW5kIGV4aXQgcmV0cnkgbG9vcFxuICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0XG4gICAgICAgIHJldHVyblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGVyci50b1N0cmluZygpXG4gICAgICAgIGNvbnN0IGlzUmV0cmlhYmxlID0gUkVUUklBQkxFX0VSUk9SUy5zb21lKHBocmFzZSA9PiBlcnJNc2cuaW5jbHVkZXMocGhyYXNlKSlcbiAgICAgICAgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxuICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICAgIC8vIGRlbGF5IGJlZm9yZSByZXRyeWluZ1xuICAgICAgYXdhaXQgdGltZW91dChyZXRyeUludGVydmFsKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzIChmZXRjaFJlcykge1xuICAvLyBjaGVjayBmb3IgZXJyb3JzXG4gIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDU6XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKClcblxuICAgIGNhc2UgNDE4OlxuICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKVxuXG4gICAgY2FzZSA1MDM6XG4gICAgY2FzZSA1MDQ6XG4gICAgICB0aHJvdyBjcmVhdGVUaW1lb3V0RXJyb3IoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UgKGZldGNoUmVzLCBib2R5KSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvciBjb2RlXG4gIGlmIChmZXRjaFJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgbWVzc2FnZTogYE5vbi0yMDAgc3RhdHVzIGNvZGU6ICcke2ZldGNoUmVzLnN0YXR1c30nYCxcbiAgICAgIGRhdGE6IGJvZHksXG4gICAgfSlcbiAgfVxuICAvLyBjaGVjayBmb3IgcnBjIGVycm9yXG4gIGlmIChib2R5LmVycm9yKSB0aHJvdyBldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICBkYXRhOiBib2R5LmVycm9yLFxuICB9KVxuICAvLyByZXR1cm4gc3VjY2Vzc2Z1bCByZXN1bHRcbiAgcmV0dXJuIGJvZHkucmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7IHJlcSwgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5IH0pIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHJwY1VybClcbiAgY29uc3QgZmV0Y2hVcmwgPSBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybClcblxuICAvLyBwcmVwYXJlIHBheWxvYWRcbiAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgaWQ6IHJlcS5pZCxcbiAgICBqc29ucnBjOiByZXEuanNvbnJwYyxcbiAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICB9XG5cbiAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gIGNvbnN0IG9yaWdpbkRvbWFpbiA9IHJlcS5vcmlnaW5cblxuICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcblxuICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfSxcbiAgICBib2R5OiBzZXJpYWxpemVkUGF5bG9hZCxcbiAgfVxuXG4gIC8vIGVuY29kZWQgYXV0aCBkZXRhaWxzIGFzIGhlYWRlciAobm90IGFsbG93ZWQgaW4gZmV0Y2ggdXJsKVxuICBpZiAocGFyc2VkVXJsLmF1dGgpIHtcbiAgICBjb25zdCBlbmNvZGVkQXV0aCA9IGJ0b2EocGFyc2VkVXJsLmF1dGgpXG4gICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7ZW5jb2RlZEF1dGh9YFxuICB9XG5cbiAgLy8gb3B0aW9uYWw6IGFkZCByZXF1ZXN0IG9yaWdpbiBhcyBoZWFkZXJcbiAgaWYgKG9yaWdpbkh0dHBIZWFkZXJLZXkgJiYgb3JpZ2luRG9tYWluKSB7XG4gICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1tvcmlnaW5IdHRwSGVhZGVyS2V5XSA9IG9yaWdpbkRvbWFpblxuICB9XG5cbiAgcmV0dXJuIHsgZmV0Y2hVcmwsIGZldGNoUGFyYW1zIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpIHtcbiAgbGV0IHJlc3VsdCA9ICcnXG4gIHJlc3VsdCArPSBwYXJzZWRVcmwucHJvdG9jb2xcbiAgaWYgKHBhcnNlZFVybC5zbGFzaGVzKSByZXN1bHQgKz0gJy8vJ1xuICByZXN1bHQgKz0gcGFyc2VkVXJsLmhvc3RuYW1lXG4gIGlmIChwYXJzZWRVcmwucG9ydCkge1xuICAgIHJlc3VsdCArPSBgOiR7cGFyc2VkVXJsLnBvcnR9YFxuICB9XG4gIHJlc3VsdCArPSBgJHtwYXJzZWRVcmwucGF0aH1gXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IgKCkge1xuICByZXR1cm4gZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRFcnJvciAoKSB7XG4gIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGBcbiAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gXG4gIHJldHVybiBldGhFcnJvcnMucnBjLmludGVybmFsKHsgbWVzc2FnZTogbXNnIH0pXG59XG5cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpXG59XG4iLCJjb25zdCBjbG9uZSA9IHJlcXVpcmUoJ2Nsb25lJylcbmNvbnN0IGNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2pzb24tcnBjLWVuZ2luZS9zcmMvY3JlYXRlQXN5bmNNaWRkbGV3YXJlJylcbmNvbnN0IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQgPSByZXF1aXJlKCcuL2NhY2hlLXV0aWxzJykuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZFxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUluZmxpZ2h0Q2FjaGVcblxuXG5mdW5jdGlvbiBjcmVhdGVJbmZsaWdodENhY2hlICgpIHtcbiAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0cyA9IHt9XG5cbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgaWYgKHJlcS5za2lwQ2FjaGUpIHJldHVybiBuZXh0KClcbiAgICAvLyBnZXQgY2FjaGVJZCwgaWYgY2FjaGVhYmxlXG4gICAgY29uc3QgY2FjaGVJZCA9IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocmVxKVxuICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICBpZiAoIWNhY2hlSWQpIHJldHVybiBuZXh0KClcbiAgICAvLyBjaGVjayBmb3IgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICBsZXQgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXVxuICAgIC8vIGlmIGZvdW5kLCB3YWl0IGZvciB0aGUgYWN0aXZlIHJlcXVlc3QgdG8gYmUgaGFuZGxlZFxuICAgIGlmIChhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lciBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgY2FsbGVkXG4gICAgICAvLyBpdCB3aWxsIGhhbmRsZSBjb3B5aW5nIHRoZSByZXN1bHQgYW5kIHJlcXVlc3QgZmllbGRzXG4gICAgICBhd2FpdCBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBzZXR1cCByZXNwb25zZSBoYW5kbGVyIGFycmF5IGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW11cbiAgICBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdID0gYWN0aXZlUmVxdWVzdEhhbmRsZXJzXG4gICAgLy8gYWxsb3cgcmVxdWVzdCB0byBiZSBoYW5kbGVkIG5vcm1hbGx5XG4gICAgYXdhaXQgbmV4dCgpXG4gICAgLy8gY2xlYXIgaW5mbGlnaHQgcmVxdWVzdHNcbiAgICBkZWxldGUgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXVxuICAgIC8vIHNjaGVkdWxlIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyB0byBiZSBoYW5kbGVkXG4gICAgaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycylcbiAgICAvLyBjb21wbGV0ZVxuICAgIHJldHVyblxuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgY29uc3QgeyByZXNvbHZlLCBwcm9taXNlIH0gPSBkZWZlcnJlZFByb21pc2UoKVxuICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5wdXNoKChoYW5kbGVkUmVzKSA9PiB7XG4gICAgICAvLyBhcHBlbmQgYSBjb3B5IG9mIHRoZSByZXN1bHQgYW5kIGVycm9yIHRvIHRoZSByZXNwb25zZVxuICAgICAgcmVzLnJlc3VsdCA9IGNsb25lKGhhbmRsZWRSZXMucmVzdWx0KVxuICAgICAgcmVzLmVycm9yID0gY2xvbmUoaGFuZGxlZFJlcy5lcnJvcilcbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAvLyB1c2Ugc2V0VGltZW91dCBzbyB3ZSBjYW4gcmVzb2x2ZSBvdXIgb3JpZ2luYWwgcmVxdWVzdCBmaXJzdFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoYW5kbGVyKHJlcylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gY2F0Y2ggZXJyb3Igc28gYWxsIHJlcXVlc3RzIGFyZSBoYW5kbGVkIGNvcnJlY3RseVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmZXJyZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZVxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoX3Jlc29sdmUgPT4geyByZXNvbHZlID0gX3Jlc29sdmUgfSlcbiAgcmV0dXJuIHsgcmVzb2x2ZSwgcHJvbWlzZSB9XG59XG4iLCJcbmNvbnN0IHsgRXRoZXJldW1ScGNFcnJvciwgRXRoZXJldW1Qcm92aWRlckVycm9yIH0gPSByZXF1aXJlKCcuL3NyYy9jbGFzc2VzJylcbmNvbnN0IHtcbiAgc2VyaWFsaXplRXJyb3IsIGdldE1lc3NhZ2VGcm9tQ29kZSxcbn0gPSByZXF1aXJlKCcuL3NyYy91dGlscycpXG5jb25zdCBldGhFcnJvcnMgPSByZXF1aXJlKCcuL3NyYy9lcnJvcnMnKVxuY29uc3QgRVJST1JfQ09ERVMgPSByZXF1aXJlKCcuL3NyYy9lcnJvckNvZGVzLmpzb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXRoRXJyb3JzLFxuICBFdGhlcmV1bVJwY0Vycm9yLFxuICBFdGhlcmV1bVByb3ZpZGVyRXJyb3IsXG4gIHNlcmlhbGl6ZUVycm9yLFxuICBnZXRNZXNzYWdlRnJvbUNvZGUsXG5cbiAgLyoqIEB0eXBlIEVycm9yQ29kZXMgKi9cbiAgRVJST1JfQ09ERVMsXG59XG5cbi8vIFR5cGVzXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRXRoZXJldW1Qcm92aWRlckVycm9yQ29kZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1c2VyUmVqZWN0ZWRSZXF1ZXN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hdXRob3JpemVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5zdXBwb3J0ZWRNZXRob2RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXNjb25uZWN0ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGFpbkRpc2Nvbm5lY3RlZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRXRoZXJldW1ScGNFcnJvckNvZGVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGFyc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnZhbGlkUmVxdWVzdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludmFsaWRQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtZXRob2ROb3RGb3VuZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbWl0RXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlcm5hbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludmFsaWRJbnB1dFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc291cmNlTm90Rm91bmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNvdXJjZVVuYXZhaWxhYmxlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHJhbnNhY3Rpb25SZWplY3RlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ldGhvZE5vdFN1cHBvcnRlZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRXJyb3JDb2Rlc1xuICogQHByb3BlcnR5IHtFdGhlcmV1bVJwY0Vycm9yQ29kZXN9IHJwY1xuICogQHByb3BlcnR5IHtFdGhlcmV1bVByb3ZpZGVyRXJyb3JDb2Rlc30gcHJvdmlkZXJcbiAqL1xuIiwiXG5jb25zdCBzYWZlU3RyaW5naWZ5ID0gcmVxdWlyZSgnZmFzdC1zYWZlLXN0cmluZ2lmeScpXG5cbi8qKlxuICogQGNsYXNzIEpzb25ScGNFcnJvclxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEpTT04gUlBDIDIuMCBlcnJvcnMgYW5kIEV0aGVyZXVtIFJQQyBlcnJvcnNcbiAqIHBlciBFSVAgMTQ3NC5cbiAqIFBlcm1pdHMgYW55IGludGVnZXIgZXJyb3IgY29kZS5cbiAqL1xuY2xhc3MgRXRoZXJldW1ScGNFcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIEpTT04gUlBDIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIFRoZSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIHN0cmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge2FueX0gW2RhdGFdIC0gVGhlIGVycm9yIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIuJyxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbmVtcHR5IHN0cmluZy4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHBsYWluIG9iamVjdCB3aXRoIGFsbCBwdWJsaWMgY2xhc3MgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gVGhlIHNlcmlhbGl6ZWQgZXJyb3IuXG4gICAqL1xuICBzZXJpYWxpemUgKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VyaWFsaXplZC5kYXRhID0gdGhpcy5kYXRhXG4gICAgfVxuICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFja1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvciwgb21pdHRpbmdcbiAgICogYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZXJpYWxpemVkIGVycm9yIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KFxuICAgICAgdGhpcy5zZXJpYWxpemUoKSxcbiAgICAgIHN0cmluZ2lmeVJlcGxhY2VyLFxuICAgICAgMixcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgRXRoZXJldW1ScGNFcnJvclxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9ycyBwZXIgRUlQIDExOTMuXG4gKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gKi9cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXJFcnJvciBleHRlbmRzIEV0aGVyZXVtUnBjRXJyb3Ige1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRXRoZXJldW0gSlNPTiBSUEMgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gVGhlIGludGVnZXIgZXJyb3IgY29kZSwgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIHN0cmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge2FueX0gW2RhdGFdIC0gVGhlIGVycm9yIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuXG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAxMDAwIDw9IGNvZGUgPD0gNDk5OScsXG4gICAgICApXG4gICAgfVxuXG4gICAgc3VwZXIoY29kZSwgbWVzc2FnZSwgZGF0YSlcbiAgfVxufVxuXG4vLyBJbnRlcm5hbFxuXG5mdW5jdGlvbiBpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlIChjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpICYmIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDQ5OTlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIgKF8sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gJ1tDaXJjdWxhcl0nKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdGhlcmV1bVJwY0Vycm9yLFxuICBFdGhlcmV1bVByb3ZpZGVyRXJyb3IsXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwicnBjXCI6IHtcbiAgICBcImludmFsaWRJbnB1dFwiOiAtMzIwMDAsXG4gICAgXCJyZXNvdXJjZU5vdEZvdW5kXCI6IC0zMjAwMSxcbiAgICBcInJlc291cmNlVW5hdmFpbGFibGVcIjogLTMyMDAyLFxuICAgIFwidHJhbnNhY3Rpb25SZWplY3RlZFwiOiAtMzIwMDMsXG4gICAgXCJtZXRob2ROb3RTdXBwb3J0ZWRcIjogLTMyMDA0LFxuICAgIFwibGltaXRFeGNlZWRlZFwiOiAtMzIwMDUsXG4gICAgXCJwYXJzZVwiOiAtMzI3MDAsXG4gICAgXCJpbnZhbGlkUmVxdWVzdFwiOiAtMzI2MDAsXG4gICAgXCJtZXRob2ROb3RGb3VuZFwiOiAtMzI2MDEsXG4gICAgXCJpbnZhbGlkUGFyYW1zXCI6IC0zMjYwMixcbiAgICBcImludGVybmFsXCI6IC0zMjYwM1xuICB9LFxuICBcInByb3ZpZGVyXCI6IHtcbiAgICBcInVzZXJSZWplY3RlZFJlcXVlc3RcIjogNDAwMSxcbiAgICBcInVuYXV0aG9yaXplZFwiOiA0MTAwLFxuICAgIFwidW5zdXBwb3J0ZWRNZXRob2RcIjogNDIwMCxcbiAgICBcImRpc2Nvbm5lY3RlZFwiOiA0OTAwLFxuICAgIFwiY2hhaW5EaXNjb25uZWN0ZWRcIjogNDkwMVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiLTMyNzAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgXCJtZXNzYWdlXCI6IFwiSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC5cIlxuICB9LFxuICBcIi0zMjYwMFwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIlRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuXCJcbiAgfSxcbiAgXCItMzI2MDFcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJKU09OIFJQQyAyLjBcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS5cIlxuICB9LFxuICBcIi0zMjYwMlwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIkludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKS5cIlxuICB9LFxuICBcIi0zMjYwM1wiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIkludGVybmFsIEpTT04tUlBDIGVycm9yLlwiXG4gIH0sXG4gIFwiLTMyMDAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDE0NzRcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJJbnZhbGlkIGlucHV0LlwiXG4gIH0sXG4gIFwiLTMyMDAxXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDE0NzRcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJSZXNvdXJjZSBub3QgZm91bmQuXCJcbiAgfSxcbiAgXCItMzIwMDJcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJFSVAgMTQ3NFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIlJlc291cmNlIHVuYXZhaWxhYmxlLlwiXG4gIH0sXG4gIFwiLTMyMDAzXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDE0NzRcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUcmFuc2FjdGlvbiByZWplY3RlZC5cIlxuICB9LFxuICBcIi0zMjAwNFwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkVJUCAxNDc0XCIsXG4gICAgXCJtZXNzYWdlXCI6IFwiTWV0aG9kIG5vdCBzdXBwb3J0ZWQuXCJcbiAgfSxcbiAgXCItMzIwMDVcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJFSVAgMTQ3NFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIlJlcXVlc3QgbGltaXQgZXhjZWVkZWQuXCJcbiAgfSxcbiAgXCI0MDAxXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDExOTNcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LlwiXG4gIH0sXG4gIFwiNDEwMFwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkVJUCAxMTkzXCIsXG4gICAgXCJtZXNzYWdlXCI6IFwiVGhlIHJlcXVlc3RlZCBhY2NvdW50IGFuZC9vciBtZXRob2QgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuXCJcbiAgfSxcbiAgXCI0MjAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDExOTNcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuXCJcbiAgfSxcbiAgXCI0OTAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDExOTNcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy5cIlxuICB9LFxuICBcIjQ5MDFcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJFSVAgMTE5M1wiLFxuICAgIFwibWVzc2FnZVwiOiBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGNoYWluLlwiXG4gIH1cbn1cbiIsIlxuY29uc3QgeyBFdGhlcmV1bVJwY0Vycm9yLCBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgfSA9IHJlcXVpcmUoJy4vY2xhc3NlcycpXG5jb25zdCB7IGdldE1lc3NhZ2VGcm9tQ29kZSB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBFUlJPUl9DT0RFUyA9IHJlcXVpcmUoJy4vZXJyb3JDb2Rlcy5qc29uJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJwYzoge1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFBhcnNlICgtMzI3MDApIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0c10gLSBPcHRpb25zIG9iamVjdCBvciBlcnJvciBtZXNzYWdlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tZXNzYWdlXSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVJwY0Vycm9yfSBUaGUgZXJyb3JcbiAgICAgKi9cbiAgICBwYXJzZTogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5wYXJzZSwgb3B0cyxcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgaW52YWxpZFJlcXVlc3Q6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMuaW52YWxpZFJlcXVlc3QsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFBhcmFtcyAoLTMyNjAyKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgaW52YWxpZFBhcmFtczogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5pbnZhbGlkUGFyYW1zLCBvcHRzLFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgbWV0aG9kTm90Rm91bmQ6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMubWV0aG9kTm90Rm91bmQsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgaW50ZXJuYWw6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMuaW50ZXJuYWwsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBTZXJ2ZXIgZXJyb3IuXG4gICAgICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIC0zMjA5OSA8PSAtMzIwMDUgXSByYW5nZS5cbiAgICAgKiBDb2RlcyAtMzIwMDAgdGhyb3VnaCAtMzIwMDQgYXJlIHJlc2VydmVkIGJ5IEVJUCAxNDc0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvcHRzIC0gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5jb2RlIC0gVGhlIGVycm9yIGNvZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgc2VydmVyOiAob3B0cykgPT4ge1xuICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUlBDIFNlcnZlciBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuJylcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29kZSB9ID0gb3B0c1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IC0zMjA5OSA8PSBjb2RlIDw9IC0zMjAwNScsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoY29kZSwgb3B0cylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUnBjRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIGludmFsaWRJbnB1dDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5pbnZhbGlkSW5wdXQsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUnBjRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIHJlc291cmNlTm90Rm91bmQ6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgb3B0cyxcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIFVuYXZhaWxhYmxlICgtMzIwMDIpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0c10gLSBPcHRpb25zIG9iamVjdCBvciBlcnJvciBtZXNzYWdlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tZXNzYWdlXSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVJwY0Vycm9yfSBUaGUgZXJyb3JcbiAgICAgKi9cbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAob3B0cykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKFxuICAgICAgRVJST1JfQ09ERVMucnBjLnJlc291cmNlVW5hdmFpbGFibGUsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy50cmFuc2FjdGlvblJlamVjdGVkLCBvcHRzLFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUnBjRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgbGltaXRFeGNlZWRlZDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5saW1pdEV4Y2VlZGVkLCBvcHRzLFxuICAgICksXG4gIH0sXG5cbiAgcHJvdmlkZXI6IHtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVc2VyIFJlamVjdGVkIFJlcXVlc3QgKDQwMDEpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0c10gLSBPcHRpb25zIG9iamVjdCBvciBlcnJvciBtZXNzYWdlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tZXNzYWdlXSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCwgb3B0cyxcbiAgICAgIClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUHJvdmlkZXJFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgdW5hdXRob3JpemVkOiAob3B0cykgPT4ge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoXG4gICAgICAgIEVSUk9SX0NPREVTLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgb3B0cyxcbiAgICAgIClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuc3VwcG9ydGVkIE1ldGhvZCAoNDIwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUHJvdmlkZXJFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgdW5zdXBwb3J0ZWRNZXRob2Q6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIG9wdHMsXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBOb3QgQ29ubmVjdGVkICg0OTAwKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1Qcm92aWRlckVycm9yfSBUaGUgZXJyb3JcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWQ6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIuZGlzY29ubmVjdGVkLCBvcHRzLFxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUHJvdmlkZXJFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIuY2hhaW5EaXNjb25uZWN0ZWQsIG9wdHMsXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb3B0cyAtIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuY29kZSAtIFRoZSBlcnJvciBjb2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIGN1c3RvbTogKG9wdHMpID0+IHtcbiAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFByb3ZpZGVyIGN1c3RvbSBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuJylcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gb3B0c1xuICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKVxuICAgIH0sXG4gIH0sXG59XG5cbi8vIEludGVybmFsXG5cbmZ1bmN0aW9uIGdldEV0aEpzb25ScGNFcnJvciAoY29kZSwgb3B0cykge1xuICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSB2YWxpZGF0ZU9wdHMob3B0cylcbiAgcmV0dXJuIG5ldyBFdGhlcmV1bVJwY0Vycm9yKFxuICAgIGNvZGUsXG4gICAgbWVzc2FnZSB8fCBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksXG4gICAgZGF0YSxcbiAgKVxufVxuXG5mdW5jdGlvbiBnZXRFdGhQcm92aWRlckVycm9yIChjb2RlLCBvcHRzKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHZhbGlkYXRlT3B0cyhvcHRzKVxuICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2UgfHwgZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLFxuICAgIGRhdGEsXG4gIClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzIChvcHRzKSB7XG4gIGlmIChvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtvcHRzXVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2UsIGRhdGEgfSA9IG9wdHNcbiAgICAgIHJldHVybiBbbWVzc2FnZSwgZGF0YV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdXG59XG4iLCJcbmNvbnN0IGVycm9yVmFsdWVzID0gcmVxdWlyZSgnLi9lcnJvclZhbHVlcy5qc29uJylcbmNvbnN0IEZBTExCQUNLX0VSUk9SX0NPREUgPSByZXF1aXJlKCcuL2Vycm9yQ29kZXMuanNvbicpLnJwYy5pbnRlcm5hbFxuY29uc3QgeyBFdGhlcmV1bVJwY0Vycm9yIH0gPSByZXF1aXJlKCcuL2NsYXNzZXMnKVxuXG5jb25zdCBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJ1xuXG5jb25zdCBGQUxMQkFDS19NRVNTQUdFID0gJ1Vuc3BlY2lmaWVkIGVycm9yIG1lc3NhZ2UuIFRoaXMgaXMgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQuJ1xuXG5jb25zdCBGQUxMQkFDS19FUlJPUiA9IHtcbiAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgbWVzc2FnZTogZ2V0TWVzc2FnZUZyb21Db2RlKEZBTExCQUNLX0VSUk9SX0NPREUpLFxufVxuXG4vKipcbiAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICogbm8gY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gVGhlIGludGVnZXIgZXJyb3IgY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IGZhbGxiYWNrTWVzc2FnZSAtIFRoZSBmYWxsYmFjayBtZXNzYWdlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2Ugb3IgdGhlIGZhbGxiYWNrIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gZ2V0TWVzc2FnZUZyb21Db2RlIChjb2RlLCBmYWxsYmFja01lc3NhZ2UgPSBGQUxMQkFDS19NRVNTQUdFKSB7XG5cbiAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcblxuICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKClcblxuICAgIGlmIChlcnJvclZhbHVlc1tjb2RlU3RyaW5nXSkge1xuICAgICAgcmV0dXJuIGVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2VcbiAgICB9XG4gICAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgICByZXR1cm4gSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrTWVzc2FnZVxufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cbiAqIEEgY29kZSBpcyBvbmx5IHZhbGlkIGlmIGl0IGhhcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSBUaGUgY29kZSB0byBjaGVja1xuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY29kZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29kZSAoY29kZSkge1xuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKVxuICBpZiAoZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFRPRE86IGFsbG93IHZhbGlkIGNvZGVzIGFuZCBtZXNzYWdlcyB0byBiZSBleHRlbmRlZFxuICAvLyAvLyBFSVAgMTE5MyBTdGF0dXMgQ29kZXNcbiAgLy8gaWYgKGNvZGUgPj0gNDAwMCAmJiBjb2RlIDw9IDQ5OTkpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gZXJyb3IgdG8gYW4gRXRoZXJldW0gSlNPTiBSUEMtY29tcGF0aWJsZSBlcnJvciBvYmplY3QuXG4gKiBNZXJlbHkgY29waWVzIHRoZSBnaXZlbiBlcnJvcidzIHZhbHVlcyBpZiBpdCBpcyBhbHJlYWR5IGNvbXBhdGlibGUuXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICogcmV0dXJuZWQgb2JqZWN0J3MgZGF0YS5vcmlnaW5hbEVycm9yIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7YW55fSBlcnJvciAtIFRoZSBlcnJvciB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmFsbGJhY2tFcnJvcl0gLSBUaGUgY3VzdG9tIGZhbGxiYWNrIGVycm9yIHZhbHVlcyBpZlxuICogdGhlIGdpdmVuIGVycm9yIGlzIGludmFsaWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3VsZEluY2x1ZGVTdGFja10gLSBXaGV0aGVyIHRoZSAnc3RhY2snIHByb3BlcnR5XG4gKiBvZiB0aGUgZ2l2ZW4gZXJyb3Igc2hvdWxkIGJlIGluY2x1ZGVkIG9uIHRoZSBzZXJpYWxpemVkIGVycm9yLCBpZiBwcmVzZW50LlxuICogQHJldHVybiB7T2JqZWN0fSBBIHN0YW5kYXJkaXplZCwgcGxhaW4gZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvciAoXG4gIGVycm9yLFxuICB7IGZhbGxiYWNrRXJyb3IgPSBGQUxMQkFDS19FUlJPUiwgc2hvdWxkSW5jbHVkZVN0YWNrID0gZmFsc2UgfSA9IHt9LFxuKSB7XG5cbiAgaWYgKFxuICAgICFmYWxsYmFja0Vycm9yIHx8XG4gICAgIU51bWJlci5pc0ludGVnZXIoZmFsbGJhY2tFcnJvci5jb2RlKSB8fFxuICAgIHR5cGVvZiBmYWxsYmFja0Vycm9yLm1lc3NhZ2UgIT09ICdzdHJpbmcnXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdNdXN0IHByb3ZpZGUgZmFsbGJhY2sgZXJyb3Igd2l0aCBpbnRlZ2VyIG51bWJlciBjb2RlIGFuZCBzdHJpbmcgbWVzc2FnZS4nLFxuICAgIClcbiAgfVxuXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEV0aGVyZXVtUnBjRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKClcbiAgfVxuXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fVxuXG4gIGlmIChlcnJvciAmJiBpc1ZhbGlkQ29kZShlcnJvci5jb2RlKSkge1xuXG4gICAgc2VyaWFsaXplZC5jb2RlID0gZXJyb3IuY29kZVxuXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlXG4gICAgICBpZiAoJ2RhdGEnIGluIGVycm9yKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IGVycm9yLmRhdGFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gZ2V0TWVzc2FnZUZyb21Db2RlKHNlcmlhbGl6ZWQuY29kZSlcbiAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHsgb3JpZ2luYWxFcnJvcjogYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWQuY29kZSA9IGZhbGxiYWNrRXJyb3IuY29kZVxuICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IChcbiAgICAgIGVycm9yICYmIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgIDogZmFsbGJhY2tFcnJvci5tZXNzYWdlXG4gICAgKVxuICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHsgb3JpZ2luYWxFcnJvcjogYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikgfVxuICB9XG5cbiAgaWYgKHNob3VsZEluY2x1ZGVTdGFjayAmJiBlcnJvciAmJiB0eXBlb2YgZXJyb3Iuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VyaWFsaXplZC5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWRcbn1cblxuLy8gSW50ZXJuYWxcblxuZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwXG59XG5cbmZ1bmN0aW9uIGFzc2lnbk9yaWdpbmFsRXJyb3IgKGVycm9yKSB7XG4gIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgIHJldHVybiB7IC4uLmVycm9yIH1cbiAgfVxuICByZXR1cm4gZXJyb3Jcbn1cblxuLy8gRXhwb3J0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0TWVzc2FnZUZyb21Db2RlLFxuICBpc1ZhbGlkQ29kZSxcbiAgc2VyaWFsaXplRXJyb3IsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFLFxufVxuIiwiY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBldGhBYmkgPSByZXF1aXJlKCdldGhlcmV1bWpzLWFiaScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGNvbmNhdFNpZzogZnVuY3Rpb24gKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpXG4gICAgY29uc3Qgc1NpZyA9IGV0aFV0aWwuZnJvbVNpZ25lZChzKVxuICAgIGNvbnN0IHZTaWcgPSBldGhVdGlsLmJ1ZmZlclRvSW50KHYpXG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3Qgc1N0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3QgdlN0ciA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZXRoVXRpbC5pbnRUb0hleCh2U2lnKSlcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuXG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gJyByZWNlaXZlZCAnICsgKHR5cGVvZiBpbnB1dCkgKyAnOiAnICsgaW5wdXRcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KGlucHV0LnRvTG93ZXJDYXNlKCkpXG4gIH0sXG5cbiAgcGVyc29uYWxTaWduOiBmdW5jdGlvbiAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIHZhciBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gICAgdmFyIHNpZyA9IGV0aFV0aWwuZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlOiBmdW5jdGlvbiAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgY29uc3Qgc2VuZGVySGV4ID0gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gICAgcmV0dXJuIHNlbmRlckhleFxuICB9LFxuXG4gIGV4dHJhY3RQdWJsaWNLZXk6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIHJldHVybiAnMHgnICsgcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIHR5cGVkU2lnbmF0dXJlSGFzaDogZnVuY3Rpb24gKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YTogZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmU6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKVxuICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHwgIXR5cGVkRGF0YS5sZW5ndGgpIHRocm93IGVycm9yXG5cbiAgY29uc3QgZGF0YSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlID09PSAnYnl0ZXMnID8gZXRoVXRpbC50b0J1ZmZlcihlLnZhbHVlKSA6IGUudmFsdWVcbiAgfSlcbiAgY29uc3QgdHlwZXMgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnR5cGUgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBlLnR5cGUgKyAnICcgKyBlLm5hbWVcbiAgfSlcblxuICByZXR1cm4gZXRoQWJpLnNvbGlkaXR5U0hBMyhcbiAgICBbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLFxuICAgIFtcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTMobmV3IEFycmF5KHR5cGVkRGF0YS5sZW5ndGgpLmZpbGwoJ3N0cmluZycpLCBzY2hlbWEpLFxuICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyh0eXBlcywgZGF0YSlcbiAgICBdXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShoYXNoLCBzaWcpIHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gZXRoVXRpbC50b0J1ZmZlcihzaWcpXG4gIGNvbnN0IHNpZ1BhcmFtcyA9IGV0aFV0aWwuZnJvbVJwY1NpZyhzaWduYXR1cmUpXG4gIHJldHVybiBldGhVdGlsLmVjcmVjb3ZlcihoYXNoLCBzaWdQYXJhbXMudiwgc2lnUGFyYW1zLnIsIHNpZ1BhcmFtcy5zKVxufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3IgKG1zZ1BhcmFtcykge1xuICBjb25zdCBtZXNzYWdlID0gZXRoVXRpbC50b0J1ZmZlcihtc2dQYXJhbXMuZGF0YSlcbiAgY29uc3QgbXNnSGFzaCA9IGV0aFV0aWwuaGFzaFBlcnNvbmFsTWVzc2FnZShtZXNzYWdlKVxuICByZXR1cm4gcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoLCBtc2dQYXJhbXMuc2lnKVxufVxuXG5cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMgKG51bWJlciwgbGVuZ3RoKSB7XG4gIHZhciBteVN0cmluZyA9ICcnICsgbnVtYmVyXG4gIHdoaWxlIChteVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBteVN0cmluZyA9ICcwJyArIG15U3RyaW5nXG4gIH1cbiAgcmV0dXJuIG15U3RyaW5nXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhaycpLFxuICAgIGtlY2NhazIyNCA9IF9yZXF1aXJlLmtlY2NhazIyNCxcbiAgICBrZWNjYWszODQgPSBfcmVxdWlyZS5rZWNjYWszODQsXG4gICAgazI1NiA9IF9yZXF1aXJlLmtlY2NhazI1NixcbiAgICBrZWNjYWs1MTIgPSBfcmVxdWlyZS5rZWNjYWs1MTI7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1hZGFwdGVyJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgcmxwID0gcmVxdWlyZSgncmxwJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCByZXF1aXJlKCdldGhqcy11dGlsJykpO1xuXG4vKipcbiAqIHRoZSBtYXggaW50ZWdlciB0aGF0IHRoaXMgVk0gY2FuIGhhbmRsZSAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBNQVhfSU5URUdFUlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuXG4vKipcbiAqIDJeMjU2IChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IFRXT19QT1cyNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9OVUxMX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuZXhwb3J0cy5TSEEzX05VTExfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9OVUxMXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTDtcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfQVJSQVlfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3JztcbmV4cG9ydHMuU0hBM19STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUF9BUlJBWVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsICAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbmV4cG9ydHMuU0hBM19STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQO1xuXG4vKipcbiAqIFtgQk5gXShodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcylcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLkJOID0gQk47XG5cbi8qKlxuICogW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5ybHAgPSBybHA7XG5cbi8qKlxuICogW2BzZWNwMjU2azFgXShodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlLylcbiAqIEB2YXIge09iamVjdH1cbiAqL1xuZXhwb3J0cy5zZWNwMjU2azEgPSBzZWNwMjU2azE7XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwc1xuICogQG1ldGhvZCB6ZXJvc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5cbi8qKlxuICAqIFJldHVybnMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIHplcm9BZGRyZXNzXG4gICogQHJldHVybiB7U3RyaW5nfVxuICAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoemVyb0FkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBMZWZ0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQG1ldGhvZCBsc2V0TGVuZ3RoXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHtCb29sZWFufSBbcmlnaHQ9ZmFsc2VdIHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICBtc2cgPSBleHBvcnRzLnRvQnVmZmVyKG1zZyk7XG4gIGlmIChyaWdodCkge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSaWdodCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAgb3IgYW4gYEFycmF5YFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfSBhXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfVxuICovXG5leHBvcnRzLnVucGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYSk7XG4gIHZhciBmaXJzdCA9IGFbMF07XG4gIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgZmlyc3QgPSBhWzBdO1xuICB9XG4gIHJldHVybiBhO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC4gQXMgaW5wdXQgaXQgc3VwcG9ydHMgYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB7Kn0gdiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGV4cG9ydHMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMucGFkVG9FdmVuKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHYgPSBleHBvcnRzLmludFRvQnVmZmVyKHYpO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfSBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gbmV3IEJOKGV4cG9ydHMudG9CdWZmZXIoYnVmKSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGJ1ZiA9IGV4cG9ydHMudG9CdWZmZXIoYnVmKTtcbiAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IG51bVxuICogQHJldHVybiB7Qk59XG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG5ldyBCTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCTn0gbnVtXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIEtlY2NhayB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICBpZiAoIWJpdHMpIGJpdHMgPSAyNTY7XG5cbiAgc3dpdGNoIChiaXRzKSB7XG4gICAgY2FzZSAyMjQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyMjQoYSk7XG4gICAgICB9XG4gICAgY2FzZSAyNTY6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrMjU2KGEpO1xuICAgICAgfVxuICAgIGNhc2UgMzg0OlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrMzg0KGEpO1xuICAgICAgfVxuICAgIGNhc2UgNTEyOlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrNTEyKGEpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxkIGFsZ29yaXRobToga2VjY2FrJyArIGJpdHMpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKGEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIChLZWNjYWspIGhhc2ggb2YgdGhlIGlucHV0IFtPQlNPTEVURV1cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBTSEEtMyB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTMgPSBleHBvcnRzLmtlY2NhaztcblxuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtCb29sZWFufSBwYWRkZWQgd2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKGhhc2gsIDMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhybHAuZW5jb2RlKGEpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICB9XG5cbiAgaWYgKCFzYW5pdGl6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICBwdWJLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YktleSk7XG4gIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIGFzc2VydChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHByaXZhdGVLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHByaXZhdGVLZXkpO1xuICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHB1YmxpY0tleSA9IGV4cG9ydHMudG9CdWZmZXIocHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogRUNEU0Egc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZWNzaWduID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuXG4gIHZhciByZXQgPSB7fTtcbiAgcmV0LnIgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgcmV0LnMgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCk7XG4gIHJldC52ID0gc2lnLnJlY292ZXJ5ICsgMjc7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGhhc2hcbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgdmFyIHByZWZpeCA9IGV4cG9ydHMudG9CdWZmZXIoJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJyArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcblxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqL1xuZXhwb3J0cy5lY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcykge1xuICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGgociwgMzIpLCBleHBvcnRzLnNldExlbmd0aChzLCAzMildLCA2NCk7XG4gIHZhciByZWNvdmVyeSA9IHYgLSAyNztcbiAgaWYgKHJlY292ZXJ5ICE9PSAwICYmIHJlY292ZXJ5ICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gIH1cbiAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7U3RyaW5nfSBzaWdcbiAqL1xuZXhwb3J0cy50b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzKSB7XG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWNvdmVyeSBpZCcpO1xuICB9XG5cbiAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgLy8gRklYTUU6IHRoaXMgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUgLSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgZXhwb3J0cy50b0J1ZmZlcih2IC0gMjcpXSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgc2lnID0gZXhwb3J0cy50b0J1ZmZlcihzaWcpO1xuXG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmIChzaWcubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgdiA9IHNpZ1s2NF07XG4gIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICBpZiAodiA8IDI3KSB7XG4gICAgdiArPSAyNztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdjogdixcbiAgICByOiBzaWcuc2xpY2UoMCwgMzIpLFxuICAgIHM6IHNpZy5zbGljZSgzMiwgNjQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKHByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b29cbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuICgvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChhZGRyZXNzKVxuICApO1xufTtcblxuLyoqXG4gICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgaXNaZXJvQWRkcmVzc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MoKTtcbiAgcmV0dXJuIHplcm9BZGRyZXNzID09PSBleHBvcnRzLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBhZGRyZXNzID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzaCA9IGV4cG9ydHMua2VjY2FrKGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIHJldCA9ICcweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gZnJvbSB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbm9uY2UgdGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgZnJvbSA9IGV4cG9ydHMudG9CdWZmZXIoZnJvbSk7XG4gIG5vbmNlID0gbmV3IEJOKG5vbmNlKTtcblxuICBpZiAobm9uY2UuaXNaZXJvKCkpIHtcbiAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgIG5vbmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub25jZSA9IEJ1ZmZlci5mcm9tKG5vbmNlLnRvQXJyYXkoKSk7XG4gIH1cblxuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMucmxwaGFzaChbZnJvbSwgbm9uY2VdKS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSlcbiAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIGEgPSBleHBvcnRzLnVucGFkKGFkZHJlc3MpO1xuICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA+PSAxICYmIGFbMF0gPD0gODtcbn07XG5cbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgRUNEU0Egc2lnbmF0dXJlXG4gKiBAbWV0aG9kIGlzVmFsaWRTaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hvbWVzdGVhZD10cnVlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkKSB7XG4gIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuXG4gIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgciA9IG5ldyBCTihyKTtcbiAgcyA9IG5ldyBCTihzKTtcblxuICBpZiAoci5pc1plcm8oKSB8fCByLmd0KFNFQ1AyNTZLMV9OKSB8fCBzLmlzWmVybygpIHx8IHMuZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhvbWVzdGVhZCA9PT0gZmFsc2UgJiYgbmV3IEJOKHMpLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT05cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBiYVxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydHMuYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICByZXR1cm4gJzB4JyArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIHsqfSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgc2VsZi5yYXcgPSBbXTtcbiAgc2VsZi5fZmllbGRzID0gW107XG5cbiAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIG9ialtmaWVsZF0gPSAnMHgnICsgc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5iYVRvSlNPTih0aGlzLnJhdyk7XG4gIH07XG5cbiAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICB9O1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgIHYgPSBleHBvcnRzLnRvQnVmZmVyKHYpO1xuXG4gICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICB2ID0gZXhwb3J0cy5zdHJpcFplcm9zKHYpO1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IG5vdCBoYXZlIG1vcmUgJyArIGZpZWxkLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgICAgIH0gZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICcgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIHNldDogc2V0dGVyXG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoZGF0YSksICdoZXgnKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gcmxwLmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGV4cG9ydHMudG9CdWZmZXIoZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSkgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSkgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgIH1cbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG5cbnZhciBzZWNwMjU2azF2MyA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9pbmRleCcpO1xudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9kZXInKTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHJpdmF0ZUtleSBsZW5ndGggaXMgbm90IDMyXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogRXhwb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIC8vIHByaXZhdGVLZXlFeHBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMXYzLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZCk7XG5cbiAgcmV0dXJuIGRlci5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCk7XG59O1xuXG4vKipcbiAqIEltcG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5SW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5cbnZhciBwcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KSB7XG4gIC8vIHByaXZhdGVLZXlJbXBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgcHJpdmF0ZUtleSA9IGRlci5wcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpO1xuICBpZiAocHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgcHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBwcml2YXRlS2V5O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgaW1wb3J0IGZyb20gREVSIGZvcm1hdFwiKTtcbn07XG5cbi8qKlxuICogTmVnYXRlIGEgcHJpdmF0ZUtleSBieSBzdWJ0cmFjdGluZyBpdCBmcm9tIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlOZWdhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5TmVnYXRlID0gZnVuY3Rpb24gcHJpdmF0ZUtleU5lZ2F0ZShwcml2YXRlS2V5KSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHByaXZhdGVLZXkgKG1vZHVsbyB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludCkuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlNb2RJbnZlcnNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiBwcml2YXRlS2V5TW9kSW52ZXJzZShwcml2YXRlS2V5KSB7XG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMucHJpdmF0ZUtleU1vZEludmVyc2UoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBhZGRpbmcgdHdlYWsgdG8gaXQuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgdHdlYWspKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrTXVsID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciBhIHByaXZhdGVLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNyZWF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwdWJsaWNLZXkgdG8gY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgZm9ybS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29udmVydFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gcHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwdWJsaWNLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIHB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHVibGljS2V5IGxlbmd0aCBpcyBub3QgMzMgb3IgNjVcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBhZGRpbmcgdHdlYWsgdGltZXMgdGhlIGdlbmVyYXRvciB0byBpdC5cbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrQWRkKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrIHZhbHVlXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb21iaW5lKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgcHVibGljS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICBrZXlzLnB1c2goVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xuICB9KTtcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbWJpbmUoa2V5cywgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmF0dXJlIHRvIGEgbm9ybWFsaXplZCBsb3dlci1TIGZvcm0uXG4gKiBAbWV0aG9kIHNpZ25hdHVyZU5vcm1hbGl6ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gc2lnbmF0dXJlTm9ybWFsaXplKHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKG5vdCBmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRMYXhcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpIHtcbiAgLy8gc2lnbmF0dXJlSW1wb3J0TGF4IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHZhciBzaWdPYmogPSBkZXIuc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSk7XG4gIGlmIChzaWdPYmogPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBwYXJzZSBERVIgc2lnbmF0dXJlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMXYzLnNpZ25hdHVyZUltcG9ydChzaWdPYmopO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRUNEU0Egc2lnbmF0dXJlLiBBbHdheXMgcmV0dXJuIGxvdy1TIHNpZ25hdHVyZS5cbiAqIEBtZXRob2Qgc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIE9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHNpZ25PcHRpb25zID0gdm9pZCAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc2lnbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXInKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBvcHRpb24uZGF0YSBsZW5ndGhcbiAgICAgIGlmIChvcHRpb25zLmRhdGEubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3B0aW9ucy5kYXRhIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25PcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgIC8vICBjb252ZXJ0IG9wdGlvbi5ub25jZWZuIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgc2lnbk9wdGlvbnMubm9uY2VmbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBhbGdvLCBkYXRhLCBhdHRlbXB0KSB7XG4gICAgICAgIHZhciBidWZmZXJBbGdvID0gYWxnbyAhPSBudWxsID8gQnVmZmVyLmZyb20oYWxnbykgOiBudWxsO1xuICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGEgIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGRhdGEpIDogbnVsbDtcblxuICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oJycpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICBidWZmZXIgPSBvcHRpb25zLm5vbmNlZm4oQnVmZmVyLmZyb20obWVzc2FnZSksIEJ1ZmZlci5mcm9tKHByaXZhdGVLZXkpLCBidWZmZXJBbGdvLCBidWZmZXJEYXRhLCBhdHRlbXB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5lY2RzYVNpZ24oVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHNpZ25PcHRpb25zKTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnNpZ25hdHVyZSksXG4gICAgcmVjb3Zlcnk6IHNpZy5yZWNpZFxuICB9O1xufTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0Egc2lnbmF0dXJlLlxuICogQG1ldGhvZCB2ZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgdmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2NCB2ZXJpZnkgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJlY292ZXIgYW4gRUNEU0EgcHVibGljIGtleSBmcm9tIGEgc2lnbmF0dXJlLlxuICogQG1ldGhvZCByZWNvdmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJlY2lkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHJlY292ZXIgPSBmdW5jdGlvbiByZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjaWQsIGNvbXByZXNzZWQpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHY0IHJlY292ZXIgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgcmVjaWQsIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgYXBwbGllZCBzaGEyNTYgdG8gY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICogQG1ldGhvZCBlY2RoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgZWNkaCA9IGZ1bmN0aW9uIGVjZGgocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2MyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIHBhcmFtZXRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZGgoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwge30pKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIHJldHVybiBwdWJsaWMga2V5IGFzIHJlc3VsdFxuICogQG1ldGhvZCBlY2RoVW5zYWZlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBlY2RoVW5zYWZlID0gZnVuY3Rpb24gZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgLy8gZWNkaFVuc2FmZSBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAvLyBlbnN1cmUgdmFsaWQgcHVibGljS2V5IGxlbmd0aFxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHVibGljIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbGlkIHByaXZhdGVLZXkgbGVuZ3RoXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5lY2RoVW5zYWZlKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwcml2YXRlS2V5VmVyaWZ5OiBwcml2YXRlS2V5VmVyaWZ5LFxuICBwcml2YXRlS2V5RXhwb3J0OiBwcml2YXRlS2V5RXhwb3J0LFxuICBwcml2YXRlS2V5SW1wb3J0OiBwcml2YXRlS2V5SW1wb3J0LFxuICBwcml2YXRlS2V5TmVnYXRlOiBwcml2YXRlS2V5TmVnYXRlLFxuICBwcml2YXRlS2V5TW9kSW52ZXJzZTogcHJpdmF0ZUtleU1vZEludmVyc2UsXG4gIHByaXZhdGVLZXlUd2Vha0FkZDogcHJpdmF0ZUtleVR3ZWFrQWRkLFxuICBwcml2YXRlS2V5VHdlYWtNdWw6IHByaXZhdGVLZXlUd2Vha011bCxcblxuICBwdWJsaWNLZXlDcmVhdGU6IHB1YmxpY0tleUNyZWF0ZSxcbiAgcHVibGljS2V5Q29udmVydDogcHVibGljS2V5Q29udmVydCxcbiAgcHVibGljS2V5VmVyaWZ5OiBwdWJsaWNLZXlWZXJpZnksXG4gIHB1YmxpY0tleVR3ZWFrQWRkOiBwdWJsaWNLZXlUd2Vha0FkZCxcbiAgcHVibGljS2V5VHdlYWtNdWw6IHB1YmxpY0tleVR3ZWFrTXVsLFxuICBwdWJsaWNLZXlDb21iaW5lOiBwdWJsaWNLZXlDb21iaW5lLFxuXG4gIHNpZ25hdHVyZU5vcm1hbGl6ZTogc2lnbmF0dXJlTm9ybWFsaXplLFxuICBzaWduYXR1cmVFeHBvcnQ6IHNpZ25hdHVyZUV4cG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0OiBzaWduYXR1cmVJbXBvcnQsXG4gIHNpZ25hdHVyZUltcG9ydExheDogc2lnbmF0dXJlSW1wb3J0TGF4LFxuXG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5LFxuICByZWNvdmVyOiByZWNvdmVyLFxuXG4gIGVjZGg6IGVjZGgsXG4gIGVjZGhVbnNhZmU6IGVjZGhVbnNhZmVcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbi8vIGJlZ2luXG4weDMwLCAweDgxLCAweGQzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuLy8gcHJpdmF0ZSBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4vLyBtaWRkbGVcbjB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsIDB4Y2UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsIDB4MjEsIDB4MDIsIDB4NzksIDB4YmUsIDB4NjYsIDB4N2UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y2UsIDB4ODcsIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y2UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4YmEsIDB4YWUsIDB4ZGMsIDB4ZTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NWUsIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4vLyBwdWJsaWMga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXSk7XG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuLy8gYmVnaW5cbjB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4vLyBwcml2YXRlIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbi8vIG1pZGRsZVxuMHhhMCwgMHg4MSwgMHhhNSwgMHgzMCwgMHg4MSwgMHhhMiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCwgMHg0MSwgMHgwNCwgMHg3OSwgMHhiZSwgMHg2NiwgMHg3ZSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjZSwgMHg4NywgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjZSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCwgMHgxNywgMHg5OCwgMHg0OCwgMHgzYSwgMHhkYSwgMHg3NywgMHgyNiwgMHhhMywgMHhjNCwgMHg2NSwgMHg1ZCwgMHhhNCwgMHhmYiwgMHhmYywgMHgwZSwgMHgxMSwgMHgwOCwgMHhhOCwgMHhmZCwgMHgxNywgMHhiNCwgMHg0OCwgMHhhNiwgMHg4NSwgMHg1NCwgMHgxOSwgMHg5YywgMHg0NywgMHhkMCwgMHg4ZiwgMHhmYiwgMHgxMCwgMHhkNCwgMHhiOCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhiYSwgMHhhZSwgMHhkYywgMHhlNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1ZSwgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHg0NCwgMHgwMywgMHg0MiwgMHgwMCxcbi8vIHB1YmxpYyBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oY29tcHJlc3NlZCA/IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEIDogRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCk7XG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gIHB1YmxpY0tleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDE4MSA6IDIxNCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgbGVuZ3RoID0gcHJpdmF0ZUtleS5sZW5ndGg7XG5cbiAgLy8gc2VxdWVuY2UgaGVhZGVyXG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVybiBudWxsO1xuICBpbmRleCArPSAxO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aCBjb25zdHJ1Y3RvclxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gIGluZGV4ICs9IDE7XG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuIG51bGw7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApO1xuICBpbmRleCArPSBsZW5iO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDAyIHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fCBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpbmRleCArPSAzO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHwgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5cbiAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChsZW5ieXRlICYgMHg4MCkge1xuICAgIGluZGV4ICs9IGxlbmJ5dGUgLSAweDgwO1xuICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gcmxlbiAtIDB4ODA7XG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWduYXR1cmVbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHt9XG4gICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge1xuICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByaW5kZXggPSBpbmRleDtcbiAgaW5kZXggKz0gcmxlbjtcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChzbGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBzbGVuIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge31cbiAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7XG4gICAgICBzbGVuID0gKHNsZW4gPDwgOCkgKyBzaWduYXR1cmVbaW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAoc2xlbiA+IGxlbmd0aCAtIGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNpbmRleCA9IGluZGV4O1xuICBpbmRleCArPSBzbGVuO1xuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ25hdHVyZVtyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKSB7fVxuICAvLyBjb3B5IHIgdmFsdWVcbiAgaWYgKHJsZW4gPiAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKTtcblxuICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiBzXG4gIGZvciAoOyBzbGVuID4gMCAmJiBzaWduYXR1cmVbc2luZGV4XSA9PT0gMHgwMDsgc2xlbiAtPSAxLCBzaW5kZXggKz0gMSkge31cbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gIHN2YWx1ZS5jb3B5KHMsIDMyIC0gc3ZhbHVlLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjO1xuXG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkblxcJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXQnKTtcbiAgfVxuXG4gIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICByZXR1cm4gdG9QdWJsaWNLZXkocG9pbnQuZ2V0WCgpLCBwb2ludC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGJuLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgcmFuZ2UgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMik7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpO1xuICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICByID0gbmV3IEJOKDApO1xuICB9XG5cbiAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICBpZiAocy51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICBzID0gbmV3IEJOKDApO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3IudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMildKTtcbn07XG5cbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChzY2FsYXIudWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICB9XG5cbiAgdmFyIHNoYXJlZCA9IHBvaW50LnB1Yi5tdWwoc2NhbGFyKTtcbiAgcmV0dXJuIHRvUHVibGljS2V5KHNoYXJlZC5nZXRYKCksIHNoYXJlZC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxudmFyIHRvUHVibGljS2V5ID0gZnVuY3Rpb24gdG9QdWJsaWNLZXkoeCwgeSwgY29tcHJlc3NlZCkge1xuICB2YXIgcHVibGljS2V5ID0gdm9pZCAwO1xuXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICBwdWJsaWNLZXlbMF0gPSB5LmlzT2RkKCkgPyAweDAzIDogMHgwMjtcbiAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoNjUpO1xuICAgIHB1YmxpY0tleVswXSA9IDB4MDQ7XG4gICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgeS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMzMpO1xuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCIvKipcbiAqIEpzb25ScGNFbmdpbmUgb25seSBhY2NlcHRzIGNhbGxiYWNrLWJhc2VkIG1pZGRsZXdhcmUgZGlyZWN0bHkuXG4gKiBjcmVhdGVBc3luY01pZGRsZXdhcmUgZXhpc3RzIHRvIGVuYWJsZSBjb25zdW1lcnMgdG8gcGFzcyBpbiBhc3luYyBtaWRkbGV3YXJlXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQXN5bmMgbWlkZGxld2FyZSBoYXZlIG5vIFwiZW5kXCIgZnVuY3Rpb24uIEluc3RlYWQsIHRoZXkgXCJlbmRcIiBpZiB0aGV5IHJldHVyblxuICogd2l0aG91dCBjYWxsaW5nIFwibmV4dFwiLiBSYXRoZXIgdGhhbiBwYXNzaW5nIGluIGV4cGxpY2l0IHJldHVybiBoYW5kbGVycyxcbiAqIGFzeW5jIG1pZGRsZXdhcmUgY2FuIHNpbXBseSBhd2FpdCBcIm5leHRcIiwgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVcbiAqIHJlc3BvbnNlIG9iamVjdCB3aGVuIGV4ZWN1dGlvbiByZXN1bWVzLlxuICpcbiAqIFRvIGFjY29tcGxpc2ggdGhpcywgY3JlYXRlQXN5bmNNaWRkbGV3YXJlIHBhc3NlcyB0aGUgYXN5bmMgbWlkZGxld2FyZSBhXG4gKiB3cmFwcGVkIFwibmV4dFwiIGZ1bmN0aW9uLiBUaGF0IGZ1bmN0aW9uIGNhbGxzIHRoZSBpbnRlcm5hbCBKc29uUnBjRW5naW5lXG4gKiBcIm5leHRcIiBmdW5jdGlvbiB3aXRoIGEgcmV0dXJuIGhhbmRsZXIgdGhhdCByZXNvbHZlcyBhIHByb21pc2Ugd2hlbiBjYWxsZWQuXG4gKlxuICogVGhlIHJldHVybiBoYW5kbGVyIHdpbGwgYWx3YXlzIGJlIGNhbGxlZC4gSXRzIHJlc29sdXRpb24gb2YgdGhlIHByb21pc2VcbiAqIGVuYWJsZXMgdGhlIGNvbnRyb2wgZmxvdyBkZXNjcmliZWQgYWJvdmUuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVBc3luY01pZGRsZXdhcmUgKGFzeW5jTWlkZGxld2FyZSkge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcblxuICAgIC8vIG5leHRQcm9taXNlIGlzIHRoZSBrZXkgdG8gdGhlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gaXQgaXMgcmVzb2x2ZWQgYnkgdGhlIHJldHVybiBoYW5kbGVyIHBhc3NlZCB0byB0aGVcbiAgICAvLyBcIm5leHRcIiBmdW5jdGlvblxuICAgIGxldCByZXNvbHZlTmV4dFByb21pc2VcbiAgICBjb25zdCBuZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlTmV4dFByb21pc2UgPSByZXNvbHZlXG4gICAgfSlcblxuICAgIGxldCByZXR1cm5IYW5kbGVyQ2FsbGJhY2ssIG5leHRXYXNDYWxsZWRcblxuICAgIGNvbnN0IGFzeW5jTmV4dCA9IGFzeW5jICgpID0+IHtcblxuICAgICAgbmV4dFdhc0NhbGxlZCA9IHRydWVcblxuICAgICAgbmV4dCgoY2FsbGJhY2spID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICAgICAgcmVzb2x2ZU5leHRQcm9taXNlKClcbiAgICAgIH0pXG4gICAgICBhd2FpdCBuZXh0UHJvbWlzZVxuICAgIH1cblxuICAgIGFzeW5jTWlkZGxld2FyZShyZXEsIHJlcywgYXN5bmNOZXh0KVxuICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAobmV4dFdhc0NhbGxlZCkge1xuICAgICAgICAgIGF3YWl0IG5leHRQcm9taXNlIC8vIHdlIG11c3Qgd2FpdCB1bnRpbCB0aGUgcmV0dXJuIGhhbmRsZXIgaXMgY2FsbGVkXG4gICAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrKG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChyZXR1cm5IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2soZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kKGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwid2ViMy1wcm92aWRlci1lbmdpbmVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMTYuMC4zXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgY29tcG9zaW5nIEV0aGVyZXVtIHByb3ZpZGVyIG9iamVjdHMgdXNpbmcgbWlkZGxld2FyZSBtb2R1bGVzXCIsXG4gIFwicmVwb3NpdG9yeVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay93ZWIzLXByb3ZpZGVyLWVuZ2luZVwiLFxuICBcIm1haW5cIjogXCJpbmRleC5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MTIuMC4wXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJub2RlIHRlc3QvaW5kZXguanMgJiYgeWFybiBsaW50XCIsXG4gICAgXCJwcmVwdWJsaXNoT25seVwiOiBcInlhcm4gYnVpbGQgJiYgeWFybiBidW5kbGVcIixcbiAgICBcImJ1aWxkXCI6IFwiYmFiZWwgemVyby5qcyBpbmRleC5qcyAtZCBkaXN0L2VzNSAmJiBiYWJlbCBzdWJwcm92aWRlcnMgLWQgZGlzdC9lczUvc3VicHJvdmlkZXJzICYmIGJhYmVsIHV0aWwgLWQgZGlzdC9lczUvdXRpbFwiLFxuICAgIFwiYnVuZGxlXCI6IFwibWtkaXIgLXAgLi9kaXN0ICYmIHlhcm4gYnVuZGxlLWVuZ2luZSAmJiB5YXJuIGJ1bmRsZS16ZXJvXCIsXG4gICAgXCJidW5kbGUtemVyb1wiOiBcImJyb3dzZXJpZnkgLXMgWmVyb0NsaWVudFByb3ZpZGVyIC1lIHplcm8uanMgLXQgWyBiYWJlbGlmeSAtLXByZXNldHMgWyBAYmFiZWwvcHJlc2V0LWVudiBdIF0gPiBkaXN0L1plcm9DbGllbnRQcm92aWRlci5qc1wiLFxuICAgIFwiYnVuZGxlLWVuZ2luZVwiOiBcImJyb3dzZXJpZnkgLXMgUHJvdmlkZXJFbmdpbmUgLWUgaW5kZXguanMgLXQgWyBiYWJlbGlmeSAtLXByZXNldHMgWyBAYmFiZWwvcHJlc2V0LWVudiBdIF0gPiBkaXN0L1Byb3ZpZGVyRW5naW5lLmpzXCIsXG4gICAgXCJsaW50XCI6IFwiZXNsaW50IC0tcXVpZXQgLS1pZ25vcmUtcGF0aCAuZ2l0aWdub3JlIC5cIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcIiouanNcIixcbiAgICBcImRpc3RcIixcbiAgICBcInN1YnByb3ZpZGVyc1wiLFxuICAgIFwidXRpbFwiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcInJlc29sdXRpb25zXCI6IHtcbiAgICBcImdhbmFjaGUtY29yZS8qKi9lbGxpcHRpY1wiOiBcIl42LjUuMlwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBldGhlcmV1bWpzL3R4XCI6IFwiXjMuMy4wXCIsXG4gICAgXCJhc3luY1wiOiBcIl4yLjUuMFwiLFxuICAgIFwiYmFja29mZlwiOiBcIl4yLjUuMFwiLFxuICAgIFwiY2xvbmVcIjogXCJeMi4wLjBcIixcbiAgICBcImNyb3NzLWZldGNoXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJldGgtYmxvY2stdHJhY2tlclwiOiBcIl40LjQuMlwiLFxuICAgIFwiZXRoLWpzb24tcnBjLWZpbHRlcnNcIjogXCJeNC4yLjFcIixcbiAgICBcImV0aC1qc29uLXJwYy1pbmZ1cmFcIjogXCJeNS4xLjBcIixcbiAgICBcImV0aC1qc29uLXJwYy1taWRkbGV3YXJlXCI6IFwiXjYuMC4wXCIsXG4gICAgXCJldGgtcnBjLWVycm9yc1wiOiBcIl4zLjAuMFwiLFxuICAgIFwiZXRoLXNpZy11dGlsXCI6IFwiXjEuNC4yXCIsXG4gICAgXCJldGhlcmV1bWpzLWJsb2NrXCI6IFwiXjEuMi4yXCIsXG4gICAgXCJldGhlcmV1bWpzLXV0aWxcIjogXCJeNS4xLjVcIixcbiAgICBcImV0aGVyZXVtanMtdm1cIjogXCJeMi4zLjRcIixcbiAgICBcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiOiBcIl4xLjAuMVwiLFxuICAgIFwicHJvbWlzZS10by1jYWxsYmFja1wiOiBcIl4xLjAuMFwiLFxuICAgIFwicmVhZGFibGUtc3RyZWFtXCI6IFwiXjIuMi45XCIsXG4gICAgXCJyZXF1ZXN0XCI6IFwiXjIuODUuMFwiLFxuICAgIFwic2VtYXBob3JlXCI6IFwiXjEuMC4zXCIsXG4gICAgXCJ3c1wiOiBcIl41LjEuMVwiLFxuICAgIFwieGhyXCI6IFwiXjIuMi4wXCIsXG4gICAgXCJ4dGVuZFwiOiBcIl40LjAuMVwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBiYWJlbC9jbGlcIjogXCJeNy41LjVcIixcbiAgICBcIkBiYWJlbC9jb3JlXCI6IFwiXjcuNS41XCIsXG4gICAgXCJAYmFiZWwvcHJlc2V0LWVudlwiOiBcIl43LjUuNVwiLFxuICAgIFwiYmFiZWxpZnlcIjogXCJeMTAuMC4wXCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjE2LjUuMFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjYuMi4wXCIsXG4gICAgXCJldGhqc1wiOiBcIl4wLjMuNlwiLFxuICAgIFwiZ2FuYWNoZS1jb3JlXCI6IFwiXjIuNy4wXCIsXG4gICAgXCJ0YXBlXCI6IFwiXjQuNC4wXCJcbiAgfSxcbiAgXCJicm93c2VyXCI6IHtcbiAgICBcInJlcXVlc3RcIjogZmFsc2UsXG4gICAgXCJ3c1wiOiBmYWxzZVxuICB9XG59XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Jsb2NrLWNhY2hlJylcblxuY2xhc3MgQmxvY2tDYWNoZVN1YnByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcigoeyBibG9ja1RyYWNrZXIgfSkgPT4gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoT2JqZWN0LmFzc2lnbih7IGJsb2NrVHJhY2tlciB9LCBvcHRzKSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCbG9ja0NhY2hlU3VicHJvdmlkZXJcbiIsImNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5jb25zdCBGaXh0dXJlUHJvdmlkZXIgPSByZXF1aXJlKCcuL2ZpeHR1cmUuanMnKVxuY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0Rml4dHVyZXNcblxuaW5oZXJpdHMoRGVmYXVsdEZpeHR1cmVzLCBGaXh0dXJlUHJvdmlkZXIpXG5cbmZ1bmN0aW9uIERlZmF1bHRGaXh0dXJlcyhvcHRzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHZhciByZXNwb25zZXMgPSBleHRlbmQoe1xuICAgIHdlYjNfY2xpZW50VmVyc2lvbjogJ1Byb3ZpZGVyRW5naW5lL3YnK3ZlcnNpb24rJy9qYXZhc2NyaXB0JyxcbiAgICBuZXRfbGlzdGVuaW5nOiB0cnVlLFxuICAgIGV0aF9oYXNocmF0ZTogJzB4MDAnLFxuICAgIGV0aF9taW5pbmc6IGZhbHNlLFxuICB9LCBvcHRzKVxuICBGaXh0dXJlUHJvdmlkZXIuY2FsbChzZWxmLCByZXNwb25zZXMpXG59XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVGZXRjaE1pZGRsZXdhcmUgPSByZXF1aXJlKCdldGgtanNvbi1ycGMtbWlkZGxld2FyZS9mZXRjaCcpXG5cbmNsYXNzIEZldGNoU3VicHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlclN1YnByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCh7IGJsb2NrVHJhY2tlciwgcHJvdmlkZXIsIGVuZ2luZSB9KSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKG9wdHMpXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZldGNoU3VicHJvdmlkZXJcbiIsImNvbnN0IFByb3ZpZGVyU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL2pzb24tcnBjLWVuZ2luZS1taWRkbGV3YXJlJylcbmNvbnN0IGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUgPSByZXF1aXJlKCdldGgtanNvbi1ycGMtZmlsdGVycycpXG5cbmNsYXNzIFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlciBleHRlbmRzIFByb3ZpZGVyU3VicHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyLCBlbmdpbmUgfSkgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0pXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlclxuIiwiY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gRml4dHVyZVByb3ZpZGVyXG5cbmluaGVyaXRzKEZpeHR1cmVQcm92aWRlciwgU3VicHJvdmlkZXIpXG5cbmZ1bmN0aW9uIEZpeHR1cmVQcm92aWRlcihzdGF0aWNSZXNwb25zZXMpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzdGF0aWNSZXNwb25zZXMgPSBzdGF0aWNSZXNwb25zZXMgfHwge31cbiAgc2VsZi5zdGF0aWNSZXNwb25zZXMgPSBzdGF0aWNSZXNwb25zZXNcbn1cblxuRml4dHVyZVByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCwgbmV4dCwgZW5kKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgdmFyIHN0YXRpY1Jlc3BvbnNlID0gc2VsZi5zdGF0aWNSZXNwb25zZXNbcGF5bG9hZC5tZXRob2RdXG4gIC8vIGFzeW5jIGZ1bmN0aW9uXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygc3RhdGljUmVzcG9uc2UpIHtcbiAgICBzdGF0aWNSZXNwb25zZShwYXlsb2FkLCBuZXh0LCBlbmQpXG4gIC8vIHN0YXRpYyByZXNwb25zZSAtIG51bGwgaXMgdmFsaWQgcmVzcG9uc2VcbiAgfSBlbHNlIGlmIChzdGF0aWNSZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gcmV0dXJuIHJlc3VsdCBhc3luY2hyb25vdXNseVxuICAgIHNldFRpbWVvdXQoKCkgPT4gZW5kKG51bGwsIHN0YXRpY1Jlc3BvbnNlKSlcbiAgLy8gbm8gcHJlcGFyZWQgcmVzcG9uc2UgLSBza2lwXG4gIH0gZWxzZSB7XG4gICAgbmV4dCgpXG4gIH1cbn1cbiIsIi8qXG4gKiBFbXVsYXRlICdldGhfYWNjb3VudHMnIC8gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHVzaW5nICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJ1xuICpcbiAqIFRoZSB0d28gY2FsbGJhY2tzIGEgdXNlciBuZWVkcyB0byBpbXBsZW1lbnQgYXJlOlxuICogLSBnZXRBY2NvdW50cygpIC0tIGFycmF5IG9mIGFkZHJlc3NlcyBzdXBwb3J0ZWRcbiAqIC0gc2lnblRyYW5zYWN0aW9uKHR4KSAtLSBzaWduIGEgcmF3IHRyYW5zYWN0aW9uIG9iamVjdFxuICovXG5cbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IHNpZ1V0aWwgPSByZXF1aXJlKCdldGgtc2lnLXV0aWwnKVxuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuY29uc3QgU2VtYXBob3JlID0gcmVxdWlyZSgnc2VtYXBob3JlJylcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5jb25zdCBlc3RpbWF0ZUdhcyA9IHJlcXVpcmUoJy4uL3V0aWwvZXN0aW1hdGUtZ2FzLmpzJylcbmNvbnN0IGhleFJlZ2V4ID0gL15bMC05QS1GYS1mXSskL2dcblxubW9kdWxlLmV4cG9ydHMgPSBIb29rZWRXYWxsZXRTdWJwcm92aWRlclxuXG4vLyBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgUlBDIG1ldGhvZHM6XG4vLyAgIGV0aF9jb2luYmFzZVxuLy8gICBldGhfYWNjb3VudHNcbi8vICAgZXRoX3NlbmRUcmFuc2FjdGlvblxuLy8gICBldGhfc2lnblxuLy8gICBldGhfc2lnblR5cGVkRGF0YVxuLy8gICBldGhfc2lnblR5cGVkRGF0YV92M1xuLy8gICBldGhfc2lnblR5cGVkRGF0YV92NFxuLy8gICBwZXJzb25hbF9zaWduXG4vLyAgIGV0aF9kZWNyeXB0TWVzc2FnZVxuLy8gICBlbmNyeXB0aW9uX3B1YmxpY19rZXlcbi8vICAgcGVyc29uYWxfZWNSZWNvdmVyXG4vLyAgIHBhcml0eV9wb3N0VHJhbnNhY3Rpb25cbi8vICAgcGFyaXR5X2NoZWNrUmVxdWVzdFxuLy8gICBwYXJpdHlfZGVmYXVsdEFjY291bnRcblxuLy9cbi8vIFR4IFNpZ25hdHVyZSBGbG93XG4vL1xuLy8gaGFuZGxlUmVxdWVzdDogZXRoX3NlbmRUcmFuc2FjdGlvblxuLy8gICB2YWxpZGF0ZVRyYW5zYWN0aW9uIChiYXNpYyB2YWxpZGl0eSBjaGVjaylcbi8vICAgICB2YWxpZGF0ZVNlbmRlciAoY2hlY2tzIHRoYXQgc2VuZGVyIGlzIGluIGFjY291bnRzKVxuLy8gICBwcm9jZXNzVHJhbnNhY3Rpb24gKHNpZ24gdHggYW5kIHN1Ym1pdCB0byBuZXR3b3JrKVxuLy8gICAgIGFwcHJvdmVUcmFuc2FjdGlvbiAoVUkgYXBwcm92YWwgaG9vaylcbi8vICAgICBjaGVja0FwcHJvdmFsXG4vLyAgICAgZmluYWxpemVBbmRTdWJtaXRUeCAodHggc2lnbmluZylcbi8vICAgICAgIG5vbmNlTG9jay50YWtlIChib3R0bGUgbmVjayB0byBlbnN1cmUgYXRvbWljIG5vbmNlKVxuLy8gICAgICAgICBmaWxsSW5UeEV4dHJhcyAoc2V0IGZhbGxiYWNrIGdhc1ByaWNlLCBub25jZSwgZXRjKVxuLy8gICAgICAgICBzaWduVHJhbnNhY3Rpb24gKHBlcmZvcm0gdGhlIHNpZ25hdHVyZSlcbi8vICAgICAgICAgcHVibGlzaFRyYW5zYWN0aW9uIChwdWJsaXNoIHNpZ25lZCB0eCB0byBuZXR3b3JrKVxuLy9cblxuXG5pbmhlcml0cyhIb29rZWRXYWxsZXRTdWJwcm92aWRlciwgU3VicHJvdmlkZXIpXG5cbmZ1bmN0aW9uIEhvb2tlZFdhbGxldFN1YnByb3ZpZGVyKG9wdHMpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvLyBjb250cm9sIGZsb3dcbiAgc2VsZi5ub25jZUxvY2sgPSBTZW1hcGhvcmUoMSlcblxuICAvLyBkYXRhIGxvb2t1cFxuICBpZiAob3B0cy5nZXRBY2NvdW50cykgc2VsZi5nZXRBY2NvdW50cyA9IG9wdHMuZ2V0QWNjb3VudHNcbiAgLy8gaGlnaCBsZXZlbCBvdmVycmlkZVxuICBpZiAob3B0cy5wcm9jZXNzVHJhbnNhY3Rpb24pIHNlbGYucHJvY2Vzc1RyYW5zYWN0aW9uID0gb3B0cy5wcm9jZXNzVHJhbnNhY3Rpb25cbiAgaWYgKG9wdHMucHJvY2Vzc01lc3NhZ2UpIHNlbGYucHJvY2Vzc01lc3NhZ2UgPSBvcHRzLnByb2Nlc3NNZXNzYWdlXG4gIGlmIChvcHRzLnByb2Nlc3NQZXJzb25hbE1lc3NhZ2UpIHNlbGYucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSA9IG9wdHMucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZVxuICBpZiAob3B0cy5wcm9jZXNzVHlwZWRNZXNzYWdlKSBzZWxmLnByb2Nlc3NUeXBlZE1lc3NhZ2UgPSBvcHRzLnByb2Nlc3NUeXBlZE1lc3NhZ2VcbiAgLy8gYXBwcm92YWwgaG9va3NcbiAgc2VsZi5hcHByb3ZlVHJhbnNhY3Rpb24gPSBvcHRzLmFwcHJvdmVUcmFuc2FjdGlvbiB8fCBzZWxmLmF1dG9BcHByb3ZlXG4gIHNlbGYuYXBwcm92ZU1lc3NhZ2UgPSBvcHRzLmFwcHJvdmVNZXNzYWdlIHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgc2VsZi5hcHByb3ZlUGVyc29uYWxNZXNzYWdlID0gb3B0cy5hcHByb3ZlUGVyc29uYWxNZXNzYWdlIHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgc2VsZi5hcHByb3ZlRGVjcnlwdE1lc3NhZ2UgPSBvcHRzLmFwcHJvdmVEZWNyeXB0TWVzc2FnZSB8fCBzZWxmLmF1dG9BcHByb3ZlXG4gIHNlbGYuYXBwcm92ZUVuY3J5cHRpb25QdWJsaWNLZXkgPSBvcHRzLmFwcHJvdmVFbmNyeXB0aW9uUHVibGljS2V5IHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgc2VsZi5hcHByb3ZlVHlwZWRNZXNzYWdlID0gb3B0cy5hcHByb3ZlVHlwZWRNZXNzYWdlIHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgLy8gYWN0dWFsbHkgcGVyZm9ybSB0aGUgc2lnbmF0dXJlXG4gIGlmIChvcHRzLnNpZ25UcmFuc2FjdGlvbikgc2VsZi5zaWduVHJhbnNhY3Rpb24gPSBvcHRzLnNpZ25UcmFuc2FjdGlvbiAgfHwgbXVzdFByb3ZpZGVJbkNvbnN0cnVjdG9yKCdzaWduVHJhbnNhY3Rpb24nKVxuICBpZiAob3B0cy5zaWduTWVzc2FnZSkgc2VsZi5zaWduTWVzc2FnZSA9IG9wdHMuc2lnbk1lc3NhZ2UgIHx8IG11c3RQcm92aWRlSW5Db25zdHJ1Y3Rvcignc2lnbk1lc3NhZ2UnKVxuICBpZiAob3B0cy5zaWduUGVyc29uYWxNZXNzYWdlKSBzZWxmLnNpZ25QZXJzb25hbE1lc3NhZ2UgPSBvcHRzLnNpZ25QZXJzb25hbE1lc3NhZ2UgIHx8IG11c3RQcm92aWRlSW5Db25zdHJ1Y3Rvcignc2lnblBlcnNvbmFsTWVzc2FnZScpXG4gIGlmIChvcHRzLmRlY3J5cHRNZXNzYWdlKSBzZWxmLmRlY3J5cHRNZXNzYWdlID0gb3B0cy5kZWNyeXB0TWVzc2FnZSAgfHwgbXVzdFByb3ZpZGVJbkNvbnN0cnVjdG9yKCdkZWNyeXB0TWVzc2FnZScpXG4gIGlmIChvcHRzLmVuY3J5cHRpb25QdWJsaWNLZXkpIHNlbGYuZW5jcnlwdGlvblB1YmxpY0tleSA9IG9wdHMuZW5jcnlwdGlvblB1YmxpY0tleSAgfHwgbXVzdFByb3ZpZGVJbkNvbnN0cnVjdG9yKCdlbmNyeXB0aW9uUHVibGljS2V5JylcbiAgaWYgKG9wdHMuc2lnblR5cGVkTWVzc2FnZSkgc2VsZi5zaWduVHlwZWRNZXNzYWdlID0gb3B0cy5zaWduVHlwZWRNZXNzYWdlICB8fCBtdXN0UHJvdmlkZUluQ29uc3RydWN0b3IoJ3NpZ25UeXBlZE1lc3NhZ2UnKVxuICBpZiAob3B0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUpIHNlbGYucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlID0gb3B0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmVcbiAgLy8gcHVibGlzaCB0byBuZXR3b3JrXG4gIGlmIChvcHRzLnB1Ymxpc2hUcmFuc2FjdGlvbikgc2VsZi5wdWJsaXNoVHJhbnNhY3Rpb24gPSBvcHRzLnB1Ymxpc2hUcmFuc2FjdGlvblxuICAvLyBnYXMgb3B0aW9uc1xuICBzZWxmLmVzdGltYXRlR2FzID0gb3B0cy5lc3RpbWF0ZUdhcyB8fCBzZWxmLmVzdGltYXRlR2FzXG4gIHNlbGYuZ2V0R2FzUHJpY2UgPSBvcHRzLmdldEdhc1ByaWNlIHx8IHNlbGYuZ2V0R2FzUHJpY2Vcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbihwYXlsb2FkLCBuZXh0LCBlbmQpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLl9wYXJpdHlSZXF1ZXN0cyA9IHt9XG4gIHNlbGYuX3Bhcml0eVJlcXVlc3RDb3VudCA9IDBcblxuICAvLyBzd2l0Y2ggc3RhdGVtZW50IGlzIG5vdCBibG9jayBzY29wZWRcbiAgLy8gc3Agd2UgY2FudCByZXBlYXQgdmFyIGRlY2xhcmF0aW9uc1xuICBsZXQgdHhQYXJhbXMsIG1zZ1BhcmFtcywgZXh0cmFQYXJhbXNcbiAgbGV0IG1lc3NhZ2UsIGFkZHJlc3NcblxuICBzd2l0Y2gocGF5bG9hZC5tZXRob2QpIHtcblxuICAgIGNhc2UgJ2V0aF9jb2luYmFzZSc6XG4gICAgICAvLyBwcm9jZXNzIG5vcm1hbGx5XG4gICAgICBzZWxmLmdldEFjY291bnRzKGZ1bmN0aW9uKGVyciwgYWNjb3VudHMpe1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZW5kKGVycilcbiAgICAgICAgbGV0IHJlc3VsdCA9IGFjY291bnRzWzBdIHx8IG51bGxcbiAgICAgICAgZW5kKG51bGwsIHJlc3VsdClcbiAgICAgIH0pXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgJ2V0aF9hY2NvdW50cyc6XG4gICAgICAvLyBwcm9jZXNzIG5vcm1hbGx5XG4gICAgICBzZWxmLmdldEFjY291bnRzKGZ1bmN0aW9uKGVyciwgYWNjb3VudHMpe1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZW5kKGVycilcbiAgICAgICAgZW5kKG51bGwsIGFjY291bnRzKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgICB0eFBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAoY2IpID0+IHNlbGYudmFsaWRhdGVUcmFuc2FjdGlvbih0eFBhcmFtcywgY2IpLFxuICAgICAgICAoY2IpID0+IHNlbGYucHJvY2Vzc1RyYW5zYWN0aW9uKHR4UGFyYW1zLCBjYiksXG4gICAgICBdLCBlbmQpXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgJ2V0aF9zaWduVHJhbnNhY3Rpb24nOlxuICAgICAgdHhQYXJhbXMgPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgKGNiKSA9PiBzZWxmLnZhbGlkYXRlVHJhbnNhY3Rpb24odHhQYXJhbXMsIGNiKSxcbiAgICAgICAgKGNiKSA9PiBzZWxmLnByb2Nlc3NTaWduVHJhbnNhY3Rpb24odHhQYXJhbXMsIGNiKSxcbiAgICAgIF0sIGVuZClcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAnZXRoX3NpZ24nOlxuICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgYWRkcmVzcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAvLyBnb29kIHBsYWNlIGZvciBtZXRhZGF0YVxuICAgICAgZXh0cmFQYXJhbXMgPSBwYXlsb2FkLnBhcmFtc1syXSB8fCB7fVxuICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICB9KVxuICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgKGNiKSA9PiBzZWxmLnZhbGlkYXRlTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgKGNiKSA9PiBzZWxmLnByb2Nlc3NNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICAgICAgXSwgZW5kKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdwZXJzb25hbF9zaWduJzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgICBjb25zdCBmaXJzdCA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHBheWxvYWQucGFyYW1zWzFdXG5cbiAgICAgICAgLy8gV2UgaW5pdGlhbGx5IGluY29ycmVjdGx5IG9yZGVyZWQgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgICAgLy8gVG8gZ3JhY2VmdWxseSByZXNwZWN0IHVzZXJzIHdobyBhZG9wdGVkIHRoaXMgQVBJIGVhcmx5LFxuICAgICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGdyYWNlZnVsbHkgcmVjb3ZlcmluZyBmcm9tIHRoZSB3cm9uZyBwYXJhbSBvcmRlclxuICAgICAgICAvLyB3aGVuIGl0IGlzIGNsZWFybHkgaWRlbnRpZmlhYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGF0IG1lYW5zIHdoZW4gdGhlIGZpcnN0IHBhcmFtIGlzIGRlZmluaXRlbHkgYW4gYWRkcmVzcyxcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgcGFyYW0gaXMgZGVmaW5pdGVseSBub3QsIGJ1dCBpcyBoZXguXG4gICAgICAgIGlmIChyZXNlbWJsZXNEYXRhKHNlY29uZCkgJiYgcmVzZW1ibGVzQWRkcmVzcyhmaXJzdCkpIHtcbiAgICAgICAgICBsZXQgd2FybmluZyA9IGBUaGUgZXRoX3BlcnNvbmFsU2lnbiBtZXRob2QgcmVxdWlyZXMgcGFyYW1zIG9yZGVyZWQgYFxuICAgICAgICAgIHdhcm5pbmcgKz0gYFttZXNzYWdlLCBhZGRyZXNzXS4gVGhpcyB3YXMgcHJldmlvdXNseSBoYW5kbGVkIGluY29ycmVjdGx5LCBgXG4gICAgICAgICAgd2FybmluZyArPSBgYW5kIGhhcyBiZWVuIGNvcnJlY3RlZCBhdXRvbWF0aWNhbGx5LiBgXG4gICAgICAgICAgd2FybmluZyArPSBgUGxlYXNlIHN3aXRjaCB0aGlzIHBhcmFtIG9yZGVyIGZvciBzbW9vdGggYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5gXG4gICAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpXG5cbiAgICAgICAgICBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgICBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAgIC8vIGdvb2QgcGxhY2UgZm9yIG1ldGFkYXRhXG4gICAgICAgIGV4dHJhUGFyYW1zID0gcGF5bG9hZC5wYXJhbXNbMl0gfHwge31cbiAgICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICB9KVxuICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgIChjYikgPT4gc2VsZi52YWxpZGF0ZVBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgICAoY2IpID0+IHNlbGYucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgXSwgZW5kKVxuICAgICAgfSkoKVxuXG4gICAgY2FzZSAnZXRoX2RlY3J5cHRNZXNzYWdlJzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgICBjb25zdCBmaXJzdCA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHBheWxvYWQucGFyYW1zWzFdXG5cbiAgICAgICAgLy8gV2UgaW5pdGlhbGx5IGluY29ycmVjdGx5IG9yZGVyZWQgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgICAgLy8gVG8gZ3JhY2VmdWxseSByZXNwZWN0IHVzZXJzIHdobyBhZG9wdGVkIHRoaXMgQVBJIGVhcmx5LFxuICAgICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGdyYWNlZnVsbHkgcmVjb3ZlcmluZyBmcm9tIHRoZSB3cm9uZyBwYXJhbSBvcmRlclxuICAgICAgICAvLyB3aGVuIGl0IGlzIGNsZWFybHkgaWRlbnRpZmlhYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGF0IG1lYW5zIHdoZW4gdGhlIGZpcnN0IHBhcmFtIGlzIGRlZmluaXRlbHkgYW4gYWRkcmVzcyxcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgcGFyYW0gaXMgZGVmaW5pdGVseSBub3QsIGJ1dCBpcyBoZXguXG4gICAgICAgIGlmIChyZXNlbWJsZXNEYXRhKHNlY29uZCkgJiYgcmVzZW1ibGVzQWRkcmVzcyhmaXJzdCkpIHtcbiAgICAgICAgICBsZXQgd2FybmluZyA9IGBUaGUgZXRoX2RlY3J5cHRNZXNzYWdlIG1ldGhvZCByZXF1aXJlcyBwYXJhbXMgb3JkZXJlZCBgXG4gICAgICAgICAgd2FybmluZyArPSBgW21lc3NhZ2UsIGFkZHJlc3NdLiBUaGlzIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW5jb3JyZWN0bHksIGBcbiAgICAgICAgICB3YXJuaW5nICs9IGBhbmQgaGFzIGJlZW4gY29ycmVjdGVkIGF1dG9tYXRpY2FsbHkuIGBcbiAgICAgICAgICB3YXJuaW5nICs9IGBQbGVhc2Ugc3dpdGNoIHRoaXMgcGFyYW0gb3JkZXIgZm9yIHNtb290aCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLmBcbiAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZylcblxuICAgICAgICAgIGFkZHJlc3MgPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICAgIG1lc3NhZ2UgPSBwYXlsb2FkLnBhcmFtc1sxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICAgIGFkZHJlc3MgPSBwYXlsb2FkLnBhcmFtc1sxXVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9uLXN0YW5kYXJkIFwiZXh0cmFQYXJhbXNcIiB0byBiZSBhcHBlbmRlZCB0byBvdXIgXCJtc2dQYXJhbXNcIiBvYmpcbiAgICAgICAgLy8gZ29vZCBwbGFjZSBmb3IgbWV0YWRhdGFcbiAgICAgICAgZXh0cmFQYXJhbXMgPSBwYXlsb2FkLnBhcmFtc1syXSB8fCB7fVxuICAgICAgICBtc2dQYXJhbXMgPSBleHRlbmQoZXh0cmFQYXJhbXMsIHtcbiAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgIH0pXG4gICAgICAgIHdhdGVyZmFsbChbXG4gICAgICAgICAgKGNiKSA9PiBzZWxmLnZhbGlkYXRlRGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zLCBjYiksXG4gICAgICAgICAgKGNiKSA9PiBzZWxmLnByb2Nlc3NEZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgXSwgZW5kKVxuICAgICAgfSkoKVxuICAgICAgXG4gICAgY2FzZSAnZW5jcnlwdGlvbl9wdWJsaWNfa2V5JzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIFxuICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgIChjYikgPT4gc2VsZi52YWxpZGF0ZUVuY3J5cHRpb25QdWJsaWNLZXkoYWRkcmVzcywgY2IpLFxuICAgICAgICAgIChjYikgPT4gc2VsZi5wcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleShhZGRyZXNzLCBjYiksXG4gICAgICAgIF0sIGVuZClcbiAgICAgIH0pKClcbiAgICAgIFxuICAgIGNhc2UgJ3BlcnNvbmFsX2VjUmVjb3Zlcic6XG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKCl7ICAgIFxuICAgICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHBheWxvYWQucGFyYW1zWzFdXG4gICAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAgIC8vIGdvb2QgcGxhY2UgZm9yIG1ldGFkYXRhXG4gICAgICAgIGV4dHJhUGFyYW1zID0gcGF5bG9hZC5wYXJhbXNbMl0gfHwge31cbiAgICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgICAgc2lnOiBzaWduYXR1cmUsXG4gICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgfSlcbiAgICAgICAgc2VsZi5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUobXNnUGFyYW1zLCBlbmQpXG4gICAgICB9KSgpXG5cbiAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YSc6XG4gICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjMnOlxuICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXsgXG4gICAgICAgIC8vIHByb2Nlc3Mgbm9ybWFsbHlcbiAgICAgIFxuICAgICAgICBjb25zdCBmaXJzdCA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHBheWxvYWQucGFyYW1zWzFdXG5cbiAgICAgICAgaWYgKHJlc2VtYmxlc0FkZHJlc3MoZmlyc3QpKSB7XG4gICAgICAgICAgYWRkcmVzcyA9IGZpcnN0XG4gICAgICAgICAgbWVzc2FnZSA9IHNlY29uZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSBmaXJzdFxuICAgICAgICAgIGFkZHJlc3MgPSBzZWNvbmRcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhUGFyYW1zID0gcGF5bG9hZC5wYXJhbXNbMl0gfHwge31cbiAgICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICB9KVxuICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgIChjYikgPT4gc2VsZi52YWxpZGF0ZVR5cGVkTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgICAoY2IpID0+IHNlbGYucHJvY2Vzc1R5cGVkTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgXSwgZW5kKVxuICAgICAgfSkoKVxuXG4gICAgY2FzZSAncGFyaXR5X3Bvc3RUcmFuc2FjdGlvbic6XG4gICAgICB0eFBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICBzZWxmLnBhcml0eVBvc3RUcmFuc2FjdGlvbih0eFBhcmFtcywgZW5kKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdwYXJpdHlfcG9zdFNpZ24nOlxuICAgICAgYWRkcmVzcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgIHNlbGYucGFyaXR5UG9zdFNpZ24oYWRkcmVzcywgbWVzc2FnZSwgZW5kKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdwYXJpdHlfY2hlY2tSZXF1ZXN0JzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgc2VsZi5wYXJpdHlDaGVja1JlcXVlc3QocmVxdWVzdElkLCBlbmQpXG4gICAgICB9KSgpXG5cbiAgICBjYXNlICdwYXJpdHlfZGVmYXVsdEFjY291bnQnOlxuICAgICAgc2VsZi5nZXRBY2NvdW50cyhmdW5jdGlvbihlcnIsIGFjY291bnRzKXtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVuZChlcnIpXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50c1swXSB8fCBudWxsXG4gICAgICAgIGVuZChudWxsLCBhY2NvdW50KVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuXG4gICAgZGVmYXVsdDpcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG5cbiAgfVxufVxuXG4vL1xuLy8gZGF0YSBsb29rdXBcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5nZXRBY2NvdW50cyA9IGZ1bmN0aW9uKGNiKSB7XG4gIGNiKG51bGwsIFtdKVxufVxuXG5cbi8vXG4vLyBcInByb2Nlc3NcIiBoaWdoIGxldmVsIGZsb3dcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzVHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IHNlbGYuYXBwcm92ZVRyYW5zYWN0aW9uKHR4UGFyYW1zLCBjYiksXG4gICAgKGRpZEFwcHJvdmUsIGNiKSA9PiBzZWxmLmNoZWNrQXBwcm92YWwoJ3RyYW5zYWN0aW9uJywgZGlkQXBwcm92ZSwgY2IpLFxuICAgIChjYikgPT4gc2VsZi5maW5hbGl6ZUFuZFN1Ym1pdFR4KHR4UGFyYW1zLCBjYiksXG4gIF0sIGNiKVxufVxuXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzU2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHdhdGVyZmFsbChbXG4gICAgKGNiKSA9PiBzZWxmLmFwcHJvdmVUcmFuc2FjdGlvbih0eFBhcmFtcywgY2IpLFxuICAgIChkaWRBcHByb3ZlLCBjYikgPT4gc2VsZi5jaGVja0FwcHJvdmFsKCd0cmFuc2FjdGlvbicsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuZmluYWxpemVUeCh0eFBhcmFtcywgY2IpLFxuICBdLCBjYilcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnByb2Nlc3NNZXNzYWdlID0gZnVuY3Rpb24obXNnUGFyYW1zLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gc2VsZi5hcHByb3ZlTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnbWVzc2FnZScsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuc2lnbk1lc3NhZ2UobXNnUGFyYW1zLCBjYiksXG4gIF0sIGNiKVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZ1BhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IHNlbGYuYXBwcm92ZVBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnbWVzc2FnZScsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuc2lnblBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgXSwgY2IpXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzRGVjcnlwdE1lc3NhZ2UgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHdhdGVyZmFsbChbXG4gICAgKGNiKSA9PiBzZWxmLmFwcHJvdmVEZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnZGVjcnlwdE1lc3NhZ2UnLCBkaWRBcHByb3ZlLCBjYiksXG4gICAgKGNiKSA9PiBzZWxmLmRlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICBdLCBjYilcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5ID0gZnVuY3Rpb24obXNnUGFyYW1zLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gc2VsZi5hcHByb3ZlRW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnZW5jcnlwdGlvblB1YmxpY0tleScsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuZW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMsIGNiKSxcbiAgXSwgY2IpXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzVHlwZWRNZXNzYWdlID0gZnVuY3Rpb24obXNnUGFyYW1zLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gc2VsZi5hcHByb3ZlVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICAgIChkaWRBcHByb3ZlLCBjYikgPT4gc2VsZi5jaGVja0FwcHJvdmFsKCdtZXNzYWdlJywgZGlkQXBwcm92ZSwgY2IpLFxuICAgIChjYikgPT4gc2VsZi5zaWduVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICBdLCBjYilcbn1cblxuLy9cbi8vIGFwcHJvdmFsXG4vL1xuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUuYXV0b0FwcHJvdmUgPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY2IobnVsbCwgdHJ1ZSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmNoZWNrQXBwcm92YWwgPSBmdW5jdGlvbih0eXBlLCBkaWRBcHByb3ZlLCBjYikge1xuICBjYiggZGlkQXBwcm92ZSA/IG51bGwgOiBuZXcgRXJyb3IoJ1VzZXIgZGVuaWVkICcrdHlwZSsnIHNpZ25hdHVyZS4nKSApXG59XG5cbi8vXG4vLyBwYXJpdHlcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wYXJpdHlQb3N0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICAvLyBnZXQgbmV4dCBpZFxuICBjb25zdCBjb3VudCA9IHNlbGYuX3Bhcml0eVJlcXVlc3RDb3VudFxuICBjb25zdCByZXFJZCA9IGAweCR7Y291bnQudG9TdHJpbmcoMTYpfWBcbiAgc2VsZi5fcGFyaXR5UmVxdWVzdENvdW50KytcblxuICBzZWxmLmVtaXRQYXlsb2FkKHtcbiAgICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICBwYXJhbXM6IFt0eFBhcmFtc10sXG4gIH0sIGZ1bmN0aW9uKGVycm9yLCByZXMpe1xuICAgIGlmIChlcnJvcikge1xuICAgICAgc2VsZi5fcGFyaXR5UmVxdWVzdHNbcmVxSWRdID0geyBlcnJvciB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgdHhIYXNoID0gcmVzLnJlc3VsdFxuICAgIHNlbGYuX3Bhcml0eVJlcXVlc3RzW3JlcUlkXSA9IHR4SGFzaFxuICB9KVxuXG4gIGNiKG51bGwsIHJlcUlkKVxufVxuXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wYXJpdHlQb3N0U2lnbiA9IGZ1bmN0aW9uKGFkZHJlc3MsIG1lc3NhZ2UsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgLy8gZ2V0IG5leHQgaWRcbiAgY29uc3QgY291bnQgPSBzZWxmLl9wYXJpdHlSZXF1ZXN0Q291bnRcbiAgY29uc3QgcmVxSWQgPSBgMHgke2NvdW50LnRvU3RyaW5nKDE2KX1gXG4gIHNlbGYuX3Bhcml0eVJlcXVlc3RDb3VudCsrXG5cbiAgc2VsZi5lbWl0UGF5bG9hZCh7XG4gICAgbWV0aG9kOiAnZXRoX3NpZ24nLFxuICAgIHBhcmFtczogW2FkZHJlc3MsIG1lc3NhZ2VdLFxuICB9LCBmdW5jdGlvbihlcnJvciwgcmVzKXtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuX3Bhcml0eVJlcXVlc3RzW3JlcUlkXSA9IHsgZXJyb3IgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHRcbiAgICBzZWxmLl9wYXJpdHlSZXF1ZXN0c1tyZXFJZF0gPSByZXN1bHRcbiAgfSlcblxuICBjYihudWxsLCByZXFJZClcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnBhcml0eUNoZWNrUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcUlkLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCByZXN1bHQgPSBzZWxmLl9wYXJpdHlSZXF1ZXN0c1tyZXFJZF0gfHwgbnVsbFxuICAvLyB0eCBub3QgaGFuZGxlZCB5ZXRcbiAgaWYgKCFyZXN1bHQpIHJldHVybiBjYihudWxsLCBudWxsKVxuICAvLyB0eCB3YXMgcmVqZWN0ZWQgKG9yIG90aGVyIGVycm9yKVxuICBpZiAocmVzdWx0LmVycm9yKSByZXR1cm4gY2IocmVzdWx0LmVycm9yKVxuICAvLyB0eCBzZW50XG4gIGNiKG51bGwsIHJlc3VsdClcbn1cblxuLy9cbi8vIHNpZ25hdHVyZSBhbmQgcmVjb3Zlcnlcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKSB7XG4gIGxldCBzZW5kZXJIZXhcbiAgdHJ5IHtcbiAgICBzZW5kZXJIZXggPSBzaWdVdGlsLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZShtc2dQYXJhbXMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYihlcnIpXG4gIH1cbiAgY2IobnVsbCwgc2VuZGVySGV4KVxufVxuXG4vL1xuLy8gdmFsaWRhdGlvblxuLy9cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnZhbGlkYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0eFBhcmFtcywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvLyBzaG9ydGN1dDogdW5kZWZpbmVkIHNlbmRlciBpcyBpbnZhbGlkXG4gIGlmICh0eFBhcmFtcy5mcm9tID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBhZGRyZXNzIC0gZnJvbSBhZGRyZXNzIHJlcXVpcmVkIHRvIHNpZ24gdHJhbnNhY3Rpb24uYCkpXG4gIHNlbGYudmFsaWRhdGVTZW5kZXIodHhQYXJhbXMuZnJvbSwgZnVuY3Rpb24oZXJyLCBzZW5kZXJJc1ZhbGlkKXtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmICghc2VuZGVySXNWYWxpZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5rbm93biBhZGRyZXNzIC0gdW5hYmxlIHRvIHNpZ24gdHJhbnNhY3Rpb24gZm9yIHRoaXMgYWRkcmVzczogXCIke3R4UGFyYW1zLmZyb219XCJgKSlcbiAgICBjYigpXG4gIH0pXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS52YWxpZGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgaWYgKG1zZ1BhcmFtcy5mcm9tID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBhZGRyZXNzIC0gZnJvbSBhZGRyZXNzIHJlcXVpcmVkIHRvIHNpZ24gbWVzc2FnZS5gKSlcbiAgc2VsZi52YWxpZGF0ZVNlbmRlcihtc2dQYXJhbXMuZnJvbSwgZnVuY3Rpb24oZXJyLCBzZW5kZXJJc1ZhbGlkKXtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmICghc2VuZGVySXNWYWxpZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5rbm93biBhZGRyZXNzIC0gdW5hYmxlIHRvIHNpZ24gbWVzc2FnZSBmb3IgdGhpcyBhZGRyZXNzOiBcIiR7bXNnUGFyYW1zLmZyb219XCJgKSlcbiAgICBjYigpXG4gIH0pXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS52YWxpZGF0ZVBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZ1BhcmFtcywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAobXNnUGFyYW1zLmZyb20gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIGFkZHJlc3MgLSBmcm9tIGFkZHJlc3MgcmVxdWlyZWQgdG8gc2lnbiBwZXJzb25hbCBtZXNzYWdlLmApKVxuICBpZiAobXNnUGFyYW1zLmRhdGEgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIG1lc3NhZ2UgLSBtZXNzYWdlIHJlcXVpcmVkIHRvIHNpZ24gcGVyc29uYWwgbWVzc2FnZS5gKSlcbiAgaWYgKCFpc1ZhbGlkSGV4KG1zZ1BhcmFtcy5kYXRhKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgSG9va2VkV2FsbGV0U3VicHJvdmlkZXIgLSB2YWxpZGF0ZU1lc3NhZ2UgLSBtZXNzYWdlIHdhcyBub3QgZW5jb2RlZCBhcyBoZXguYCkpXG4gIHNlbGYudmFsaWRhdGVTZW5kZXIobXNnUGFyYW1zLmZyb20sIGZ1bmN0aW9uKGVyciwgc2VuZGVySXNWYWxpZCl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXNlbmRlcklzVmFsaWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gYWRkcmVzcyAtIHVuYWJsZSB0byBzaWduIG1lc3NhZ2UgZm9yIHRoaXMgYWRkcmVzczogXCIke21zZ1BhcmFtcy5mcm9tfVwiYCkpXG4gICAgY2IoKVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUudmFsaWRhdGVEZWNyeXB0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZ1BhcmFtcywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAobXNnUGFyYW1zLmZyb20gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIGFkZHJlc3MgLSBmcm9tIGFkZHJlc3MgcmVxdWlyZWQgdG8gZGVjcnlwdCBtZXNzYWdlLmApKVxuICBpZiAobXNnUGFyYW1zLmRhdGEgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIG1lc3NhZ2UgLSBtZXNzYWdlIHJlcXVpcmVkIHRvIGRlY3J5cHQgbWVzc2FnZS5gKSlcbiAgaWYgKCFpc1ZhbGlkSGV4KG1zZ1BhcmFtcy5kYXRhKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgSG9va2VkV2FsbGV0U3VicHJvdmlkZXIgLSB2YWxpZGF0ZURlY3J5cHRNZXNzYWdlIC0gbWVzc2FnZSB3YXMgbm90IGVuY29kZWQgYXMgaGV4LmApKVxuICBzZWxmLnZhbGlkYXRlU2VuZGVyKG1zZ1BhcmFtcy5mcm9tLCBmdW5jdGlvbihlcnIsIHNlbmRlcklzVmFsaWQpe1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKCFzZW5kZXJJc1ZhbGlkKSByZXR1cm4gY2IobmV3IEVycm9yKGBVbmtub3duIGFkZHJlc3MgLSB1bmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlIGZvciB0aGlzIGFkZHJlc3M6IFwiJHttc2dQYXJhbXMuZnJvbX1cImApKVxuICAgIGNiKClcbiAgfSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnZhbGlkYXRlRW5jcnlwdGlvblB1YmxpY0tleSA9IGZ1bmN0aW9uKGFkZHJlc3MsIGNiKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICBzZWxmLnZhbGlkYXRlU2VuZGVyKGFkZHJlc3MsIGZ1bmN0aW9uKGVyciwgc2VuZGVySXNWYWxpZCl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXNlbmRlcklzVmFsaWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gYWRkcmVzcyAtIHVuYWJsZSB0byBvYnRhaW4gZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvciB0aGlzIGFkZHJlc3M6IFwiJHthZGRyZXNzfVwiYCkpXG4gICAgY2IoKVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUudmFsaWRhdGVUeXBlZE1lc3NhZ2UgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKXtcbiAgaWYgKG1zZ1BhcmFtcy5mcm9tID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBhZGRyZXNzIC0gZnJvbSBhZGRyZXNzIHJlcXVpcmVkIHRvIHNpZ24gdHlwZWQgZGF0YS5gKSlcbiAgaWYgKG1zZ1BhcmFtcy5kYXRhID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBkYXRhIC0gbWVzc2FnZSByZXF1aXJlZCB0byBzaWduIHR5cGVkIGRhdGEuYCkpXG4gIHRoaXMudmFsaWRhdGVTZW5kZXIobXNnUGFyYW1zLmZyb20sIGZ1bmN0aW9uKGVyciwgc2VuZGVySXNWYWxpZCl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXNlbmRlcklzVmFsaWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gYWRkcmVzcyAtIHVuYWJsZSB0byBzaWduIG1lc3NhZ2UgZm9yIHRoaXMgYWRkcmVzczogXCIke21zZ1BhcmFtcy5mcm9tfVwiYCkpXG4gICAgY2IoKVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUudmFsaWRhdGVTZW5kZXIgPSBmdW5jdGlvbihzZW5kZXJBZGRyZXNzLCBjYil7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8vIHNob3J0Y3V0OiB1bmRlZmluZWQgc2VuZGVyIGlzIGludmFsaWRcbiAgaWYgKCFzZW5kZXJBZGRyZXNzKSByZXR1cm4gY2IobnVsbCwgZmFsc2UpXG4gIHNlbGYuZ2V0QWNjb3VudHMoZnVuY3Rpb24oZXJyLCBhY2NvdW50cyl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCBzZW5kZXJJc1ZhbGlkID0gKGFjY291bnRzLm1hcCh0b0xvd2VyQ2FzZSkuaW5kZXhPZihzZW5kZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkpICE9PSAtMSlcbiAgICBjYihudWxsLCBzZW5kZXJJc1ZhbGlkKVxuICB9KVxufVxuXG4vL1xuLy8gdHggaGVscGVyc1xuLy9cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmZpbmFsaXplQW5kU3VibWl0VHggPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLy8gY2FuIG9ubHkgYWxsb3cgb25lIHR4IHRvIHBhc3MgdGhyb3VnaCB0aGlzIGZsb3cgYXQgYSB0aW1lXG4gIC8vIHNvIHdlIGNhbiBhdG9taWNhbGx5IGNvbnN1bWUgYSBub25jZVxuICBzZWxmLm5vbmNlTG9jay50YWtlKGZ1bmN0aW9uKCl7XG4gICAgd2F0ZXJmYWxsKFtcbiAgICAgIHNlbGYuZmlsbEluVHhFeHRyYXMuYmluZChzZWxmLCB0eFBhcmFtcyksXG4gICAgICBzZWxmLnNpZ25UcmFuc2FjdGlvbi5iaW5kKHNlbGYpLFxuICAgICAgc2VsZi5wdWJsaXNoVHJhbnNhY3Rpb24uYmluZChzZWxmKSxcbiAgICBdLCBmdW5jdGlvbihlcnIsIHR4SGFzaCl7XG4gICAgICBzZWxmLm5vbmNlTG9jay5sZWF2ZSgpXG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgY2IobnVsbCwgdHhIYXNoKVxuICAgIH0pXG4gIH0pXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5maW5hbGl6ZVR4ID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8vIGNhbiBvbmx5IGFsbG93IG9uZSB0eCB0byBwYXNzIHRocm91Z2ggdGhpcyBmbG93IGF0IGEgdGltZVxuICAvLyBzbyB3ZSBjYW4gYXRvbWljYWxseSBjb25zdW1lIGEgbm9uY2VcbiAgc2VsZi5ub25jZUxvY2sudGFrZShmdW5jdGlvbigpe1xuICAgIHdhdGVyZmFsbChbXG4gICAgICBzZWxmLmZpbGxJblR4RXh0cmFzLmJpbmQoc2VsZiwgdHhQYXJhbXMpLFxuICAgICAgc2VsZi5zaWduVHJhbnNhY3Rpb24uYmluZChzZWxmKSxcbiAgICBdLCBmdW5jdGlvbihlcnIsIHNpZ25lZFR4KXtcbiAgICAgIHNlbGYubm9uY2VMb2NrLmxlYXZlKClcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBjYihudWxsLCB7cmF3OiBzaWduZWRUeCwgdHg6IHR4UGFyYW1zfSlcbiAgICB9KVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUucHVibGlzaFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmF3VHgsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuZW1pdFBheWxvYWQoe1xuICAgIG1ldGhvZDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLFxuICAgIHBhcmFtczogW3Jhd1R4XSxcbiAgfSwgZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY2IobnVsbCwgcmVzLnJlc3VsdClcbiAgfSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmVzdGltYXRlR2FzID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGVzdGltYXRlR2FzKHNlbGYuZW5naW5lLCB0eFBhcmFtcywgY2IpXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5nZXRHYXNQcmljZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuZW1pdFBheWxvYWQoeyBtZXRob2Q6ICdldGhfZ2FzUHJpY2UnLCBwYXJhbXM6IFtdIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY2IobnVsbCwgcmVzLnJlc3VsdClcbiAgfSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmZpbGxJblR4RXh0cmFzID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgYWRkcmVzcyA9IHR4UGFyYW1zLmZyb21cbiAgLy8gY29uc29sZS5sb2coJ2ZpbGxJblR4RXh0cmFzIC0gYWRkcmVzczonLCBhZGRyZXNzKVxuXG4gIGNvbnN0IHRhc2tzID0ge31cblxuICBpZiAodHhQYXJhbXMuZ2FzUHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwibmVlZCB0byBnZXQgZ2FzcHJpY2VcIilcbiAgICB0YXNrcy5nYXNQcmljZSA9IHNlbGYuZ2V0R2FzUHJpY2UuYmluZChzZWxmKVxuICB9XG5cbiAgaWYgKHR4UGFyYW1zLm5vbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIm5lZWQgdG8gZ2V0IG5vbmNlXCIpXG4gICAgdGFza3Mubm9uY2UgPSBzZWxmLmVtaXRQYXlsb2FkLmJpbmQoc2VsZiwgeyBtZXRob2Q6ICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsIHBhcmFtczogW2FkZHJlc3MsICdwZW5kaW5nJ10gfSlcbiAgfVxuXG4gIGlmICh0eFBhcmFtcy5nYXMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwibmVlZCB0byBnZXQgZ2FzXCIpXG4gICAgdGFza3MuZ2FzID0gc2VsZi5lc3RpbWF0ZUdhcy5iaW5kKHNlbGYsIGNsb25lVHhQYXJhbXModHhQYXJhbXMpKVxuICB9XG5cbiAgcGFyYWxsZWwodGFza3MsIGZ1bmN0aW9uKGVyciwgdGFza1Jlc3VsdHMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge31cbiAgICBpZiAodGFza1Jlc3VsdHMuZ2FzUHJpY2UpIHJlc3VsdC5nYXNQcmljZSA9IHRhc2tSZXN1bHRzLmdhc1ByaWNlXG4gICAgaWYgKHRhc2tSZXN1bHRzLm5vbmNlKSByZXN1bHQubm9uY2UgPSB0YXNrUmVzdWx0cy5ub25jZS5yZXN1bHRcbiAgICBpZiAodGFza1Jlc3VsdHMuZ2FzKSByZXN1bHQuZ2FzID0gdGFza1Jlc3VsdHMuZ2FzXG5cbiAgICBjYihudWxsLCBleHRlbmQodHhQYXJhbXMsIHJlc3VsdCkpXG4gIH0pXG59XG5cbi8vIHV0aWxcblxuLy8gd2UgdXNlIHRoaXMgdG8gY2xlYW4gYW55IGN1c3RvbSBwYXJhbXMgZnJvbSB0aGUgdHhQYXJhbXNcbmZ1bmN0aW9uIGNsb25lVHhQYXJhbXModHhQYXJhbXMpe1xuICByZXR1cm4ge1xuICAgIGZyb206IHR4UGFyYW1zLmZyb20sXG4gICAgdG86IHR4UGFyYW1zLnRvLFxuICAgIHZhbHVlOiB0eFBhcmFtcy52YWx1ZSxcbiAgICBkYXRhOiB0eFBhcmFtcy5kYXRhLFxuICAgIGdhczogdHhQYXJhbXMuZ2FzLFxuICAgIGdhc1ByaWNlOiB0eFBhcmFtcy5nYXNQcmljZSxcbiAgICBub25jZTogdHhQYXJhbXMubm9uY2UsXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9Mb3dlckNhc2Uoc3RyaW5nKXtcbiAgcmV0dXJuIHN0cmluZy50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIHJlc2VtYmxlc0FkZHJlc3MgKHN0cmluZykge1xuICBjb25zdCBmaXhlZCA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHN0cmluZylcbiAgY29uc3QgaXNWYWxpZCA9IGV0aFV0aWwuaXNWYWxpZEFkZHJlc3MoZml4ZWQpXG4gIHJldHVybiBpc1ZhbGlkXG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiByZXNlbWJsZXMgaGV4IGRhdGFcbi8vIGJ1dCBkZWZpbml0ZWx5IG5vdCBhIHZhbGlkIGFkZHJlc3MuXG5mdW5jdGlvbiByZXNlbWJsZXNEYXRhIChzdHJpbmcpIHtcbiAgY29uc3QgZml4ZWQgPSBldGhVdGlsLmFkZEhleFByZWZpeChzdHJpbmcpXG4gIGNvbnN0IGlzVmFsaWRBZGRyZXNzID0gZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyhmaXhlZClcbiAgcmV0dXJuICFpc1ZhbGlkQWRkcmVzcyAmJiBpc1ZhbGlkSGV4KHN0cmluZylcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEhleChkYXRhKSB7XG4gIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnXG4gIGlmICghaXNTdHJpbmcpIHJldHVybiBmYWxzZVxuICBjb25zdCBpc0hleFByZWZpeGVkID0gZGF0YS5zbGljZSgwLDIpID09PSAnMHgnXG4gIGlmICghaXNIZXhQcmVmaXhlZCkgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IG5vblByZWZpeGVkID0gZGF0YS5zbGljZSgyKVxuICBjb25zdCBpc1ZhbGlkID0gbm9uUHJlZml4ZWQubWF0Y2goaGV4UmVnZXgpXG4gIHJldHVybiBpc1ZhbGlkXG59XG5cbmZ1bmN0aW9uIG11c3RQcm92aWRlSW5Db25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihwYXJhbXMsIGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdQcm92aWRlckVuZ2luZSAtIEhvb2tlZFdhbGxldFN1YnByb3ZpZGVyIC0gTXVzdCBwcm92aWRlIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgZm4gaW4gY29uc3RydWN0b3Igb3B0aW9ucycpKVxuICB9XG59XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2luZmxpZ2h0LWNhY2hlJylcblxuY2xhc3MgSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcigoKSA9PiBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZShvcHRzKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlclxuIiwiY29uc3QgY3JlYXRlSW5mdXJhUHJvdmlkZXIgPSByZXF1aXJlKCdldGgtanNvbi1ycGMtaW5mdXJhL3NyYy9jcmVhdGVQcm92aWRlcicpXG5jb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9wcm92aWRlci5qcycpXG5cbmNsYXNzIEluZnVyYVN1YnByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gY3JlYXRlSW5mdXJhUHJvdmlkZXIob3B0cylcbiAgICBzdXBlcihwcm92aWRlcilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZnVyYVN1YnByb3ZpZGVyXG4iLCJjb25zdCBTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXIuanMnKVxuXG4vLyB3cmFwcyBhIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIGluIGEgc3VicHJvdmlkZXIgaW50ZXJmYWNlXG5cbmNsYXNzIEpzb25ScGNFbmdpbmVNaWRkbGV3YXJlU3VicHJvdmlkZXIgZXh0ZW5kcyBTdWJwcm92aWRlciB7XG5cbiAgLy8gdGFrZSBhIGNvbnN0cnVjdG9yRm4gdG8gY2FsbCBvbmNlIHdlIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGVuZ2luZVxuICBjb25zdHJ1Y3RvciAoY29uc3RydWN0b3JGbikge1xuICAgIHN1cGVyKClcbiAgICBpZiAoIWNvbnN0cnVjdG9yRm4pIHRocm93IG5ldyBFcnJvcignSnNvblJwY0VuZ2luZU1pZGRsZXdhcmVTdWJwcm92aWRlciAtIG5vIGNvbnN0cnVjdG9yRm4gc3BlY2lmaWVkJylcbiAgICB0aGlzLl9jb25zdHJ1Y3RvckZuID0gY29uc3RydWN0b3JGblxuICB9XG5cbiAgLy8gdGhpcyBpcyBjYWxsZWQgb25jZSB0aGUgc3VicHJvdmlkZXIgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHByb3ZpZGVyIGVuZ2luZVxuICBzZXRFbmdpbmUgKGVuZ2luZSkge1xuICAgIGlmICh0aGlzLm1pZGRsZXdhcmUpIHRocm93IG5ldyBFcnJvcignSnNvblJwY0VuZ2luZU1pZGRsZXdhcmVTdWJwcm92aWRlciAtIHN1YnByb3ZpZGVyIGFkZGVkIHRvIGVuZ2luZSB0d2ljZScpXG4gICAgY29uc3QgYmxvY2tUcmFja2VyID0gZW5naW5lLl9ibG9ja1RyYWNrZXJcbiAgICBjb25zdCBtaWRkbGV3YXJlID0gdGhpcy5fY29uc3RydWN0b3JGbih7IGVuZ2luZSwgcHJvdmlkZXI6IGVuZ2luZSwgYmxvY2tUcmFja2VyIH0pXG4gICAgaWYgKCFtaWRkbGV3YXJlKSB0aHJvdyBuZXcgRXJyb3IoJ0pzb25ScGNFbmdpbmVNaWRkbGV3YXJlU3VicHJvdmlkZXIgLSBfY29uc3RydWN0b3JGbiBkaWQgbm90IHJldHVybiBtaWRkbGV3YXJlJylcbiAgICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignSnNvblJwY0VuZ2luZU1pZGRsZXdhcmVTdWJwcm92aWRlciAtIHNwZWNpZmllZCBtaWRkbGV3YXJlIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAgICB0aGlzLm1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlXG4gIH1cblxuICBoYW5kbGVSZXF1ZXN0IChyZXEsIHByb3ZFbmdOZXh0LCBwcm92RW5nRW5kKSB7XG4gICAgY29uc3QgcmVzID0geyBpZDogcmVxLmlkIH1cbiAgICB0aGlzLm1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmVOZXh0LCBtaWRkbGV3YXJlRW5kKVxuXG4gICAgZnVuY3Rpb24gbWlkZGxld2FyZU5leHQgKGhhbmRsZXIpIHtcbiAgICAgIHByb3ZFbmdOZXh0KChlcnIsIHJlc3VsdCwgY2IpID0+IHtcbiAgICAgICAgLy8gdXBkYXRlIHJlc3BvbnNlIG9iamVjdCB3aXRoIHJlc3VsdCBvciBlcnJvclxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVsZXRlIHJlcy5yZXN1bHRcbiAgICAgICAgICByZXMuZXJyb3IgPSB7IG1lc3NhZ2U6IGVyci5tZXNzYWdlIHx8IGVyciB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdFxuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGwgbWlkZGxld2FyZSdzIG5leHQgaGFuZGxlciAoZXZlbiBpZiBlcnJvcilcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVyKGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaWRkbGV3YXJlRW5kIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBwcm92RW5nRW5kKGVycilcbiAgICAgIHByb3ZFbmdFbmQobnVsbCwgcmVzLnJlc3VsdClcbiAgICB9XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25ScGNFbmdpbmVNaWRkbGV3YXJlU3VicHJvdmlkZXJcbiIsImNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKVxuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXIuanMnKVxuY29uc3QgYmxvY2tUYWdGb3JQYXlsb2FkID0gcmVxdWlyZSgnLi4vdXRpbC9ycGMtY2FjaGUtdXRpbHMnKS5ibG9ja1RhZ0ZvclBheWxvYWRcblxubW9kdWxlLmV4cG9ydHMgPSBOb25jZVRyYWNrZXJTdWJwcm92aWRlclxuXG4vLyBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgUlBDIG1ldGhvZHM6XG4vLyAgIGV0aF9nZXRUcmFuc2FjdGlvbkNvdW50IChwZW5kaW5nIG9ubHkpXG4vL1xuLy8gb2JzZXJ2ZXMgdGhlIGZvbGxvd2luZyBSUEMgbWV0aG9kczpcbi8vICAgZXRoX3NlbmRSYXdUcmFuc2FjdGlvblxuLy8gICBldm1fcmV2ZXJ0ICh0byBjbGVhciB0aGUgbm9uY2UgY2FjaGUpXG5cbmluaGVyaXRzKE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyLCBTdWJwcm92aWRlcilcblxuZnVuY3Rpb24gTm9uY2VUcmFja2VyU3VicHJvdmlkZXIoKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICBzZWxmLm5vbmNlQ2FjaGUgPSB7fVxufVxuXG5Ob25jZVRyYWNrZXJTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uKHBheWxvYWQsIG5leHQsIGVuZCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgc3dpdGNoKHBheWxvYWQubWV0aG9kKSB7XG5cbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgICB2YXIgYmxvY2tUYWcgPSBibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZClcbiAgICAgIHZhciBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMF0udG9Mb3dlckNhc2UoKVxuICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IHNlbGYubm9uY2VDYWNoZVthZGRyZXNzXVxuICAgICAgLy8gb25seSBoYW5kbGUgcmVxdWVzdHMgYWdhaW5zdCB0aGUgJ3BlbmRpbmcnIGJsb2NrVGFnXG4gICAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAvLyBoYXMgYSByZXN1bHRcbiAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgIGVuZChudWxsLCBjYWNoZWRSZXN1bHQpXG4gICAgICAgIC8vIGZhbGx0aHJvdWdoIHRoZW4gcG9wdWxhdGUgY2FjaGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KGZ1bmN0aW9uKGVyciwgcmVzdWx0LCBjYil7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoKVxuICAgICAgICAgICAgaWYgKHNlbGYubm9uY2VDYWNoZVthZGRyZXNzXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9uY2VDYWNoZVthZGRyZXNzXSA9IHJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJzpcbiAgICAgIC8vIGFsbG93IHRoZSByZXF1ZXN0IHRvIGNvbnRpbnVlIG5vcm1hbGx5XG4gICAgICBuZXh0KGZ1bmN0aW9uKGVyciwgcmVzdWx0LCBjYil7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIGxvY2FsIG5vbmNlIGlmIHR4IHdhcyBzdWJtaXR0ZWQgY29ycmVjdGx5XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYigpXG4gICAgICAgIC8vIHBhcnNlIHJhdyB0eFxuICAgICAgICB2YXIgcmF3VHggPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICB2YXIgcmF3RGF0YSA9IEJ1ZmZlci5mcm9tKGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgocmF3VHgpLCAnaGV4JylcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVNlcmlhbGl6ZWREYXRhKHJhd0RhdGEpXG4gICAgICAgIC8vIGV4dHJhY3QgYWRkcmVzc1xuICAgICAgICB2YXIgYWRkcmVzcyA9IHR4LmdldFNlbmRlckFkZHJlc3MoKS50b1N0cmluZygnaGV4JykudG9Mb3dlckNhc2UoKVxuICAgICAgICAvLyBleHRyYWN0IG5vbmNlIGFuZCBpbmNyZW1lbnRcbiAgICAgICAgdmFyIG5vbmNlID0gZXRoVXRpbC5idWZmZXJUb0ludCh0eC5ub25jZSlcbiAgICAgICAgbm9uY2UrK1xuICAgICAgICAvLyBoZXhpZnkgYW5kIG5vcm1hbGl6ZVxuICAgICAgICB2YXIgaGV4Tm9uY2UgPSBub25jZS50b1N0cmluZygxNilcbiAgICAgICAgaWYgKGhleE5vbmNlLmxlbmd0aCUyKSBoZXhOb25jZSA9ICcwJytoZXhOb25jZVxuICAgICAgICBoZXhOb25jZSA9ICcweCcraGV4Tm9uY2VcbiAgICAgICAgLy8gZG9udCB1cGRhdGUgb3VyIHJlY29yZCBvbiB0aGUgbm9uY2UgdW50aWwgdGhlIHN1Ym1pdCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAvLyB1cGRhdGUgY2FjaGVcbiAgICAgICAgc2VsZi5ub25jZUNhY2hlW2FkZHJlc3NdID0gaGV4Tm9uY2VcbiAgICAgICAgY2IoKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuXG4gICAvLyBDbGVhciBjYWNoZSBvbiBhIHRlc3RycGMgcmV2ZXJ0XG4gICBjYXNlICdldm1fcmV2ZXJ0JzpcbiAgICAgIHNlbGYubm9uY2VDYWNoZSA9IHt9XG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuXG4gICAgZGVmYXVsdDpcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG5cbiAgfVxufVxuIiwiY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5cbi8vIHdyYXBzIGEgcHJvdmlkZXIgaW4gYSBzdWJwcm92aWRlciBpbnRlcmZhY2VcblxubW9kdWxlLmV4cG9ydHMgPSBQcm92aWRlclN1YnByb3ZpZGVyXG5cbmluaGVyaXRzKFByb3ZpZGVyU3VicHJvdmlkZXIsIFN1YnByb3ZpZGVyKVxuXG5mdW5jdGlvbiBQcm92aWRlclN1YnByb3ZpZGVyKHByb3ZpZGVyKXtcbiAgaWYgKCFwcm92aWRlcikgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlclN1YnByb3ZpZGVyIC0gbm8gcHJvdmlkZXIgc3BlY2lmaWVkJylcbiAgaWYgKCFwcm92aWRlci5zZW5kQXN5bmMpIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXJTdWJwcm92aWRlciAtIHNwZWNpZmllZCBwcm92aWRlciBkb2VzIG5vdCBoYXZlIGEgc2VuZEFzeW5jIG1ldGhvZCcpXG4gIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlclxufVxuXG5Qcm92aWRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCwgbmV4dCwgZW5kKXtcbiAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBlbmQoZXJyKVxuICAgIGlmIChyZXNwb25zZS5lcnJvcikgcmV0dXJuIGVuZChuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSkpXG4gICAgZW5kKG51bGwsIHJlc3BvbnNlLnJlc3VsdClcbiAgfSlcbn1cbiIsIi8qIFNhbml0aXphdGlvbiBTdWJwcm92aWRlclxuICogRm9yIFBhcml0eSBjb21wYXRpYmlsaXR5XG4gKiByZW1vdmVzIGlycmVndWxhciBrZXlzXG4gKi9cblxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSBTYW5pdGl6ZXJTdWJwcm92aWRlclxuXG5pbmhlcml0cyhTYW5pdGl6ZXJTdWJwcm92aWRlciwgU3VicHJvdmlkZXIpXG5cbmZ1bmN0aW9uIFNhbml0aXplclN1YnByb3ZpZGVyKG9wdHMpe1xuICBjb25zdCBzZWxmID0gdGhpc1xufVxuXG5TYW5pdGl6ZXJTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uKHBheWxvYWQsIG5leHQsIGVuZCl7XG4gIHZhciB0eFBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzBdXG5cbiAgaWYgKHR5cGVvZiB0eFBhcmFtcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodHhQYXJhbXMpKSB7XG4gICAgdmFyIHNhbml0aXplZCA9IGNsb25lVHhQYXJhbXModHhQYXJhbXMpXG4gICAgcGF5bG9hZC5wYXJhbXNbMF0gPSBzYW5pdGl6ZWRcbiAgfVxuXG4gIG5leHQoKVxufVxuXG4vLyB3ZSB1c2UgdGhpcyB0byBjbGVhbiBhbnkgY3VzdG9tIHBhcmFtcyBmcm9tIHRoZSB0eFBhcmFtc1xudmFyIHBlcm1pdHRlZCA9IFtcbiAgJ2Zyb20nLFxuICAndG8nLFxuICAndmFsdWUnLFxuICAnZGF0YScsXG4gICdnYXMnLFxuICAnZ2FzUHJpY2UnLFxuICAnbm9uY2UnLFxuICAnZnJvbUJsb2NrJyxcbiAgJ3RvQmxvY2snLFxuICAnYWRkcmVzcycsXG4gICd0b3BpY3MnLFxuXVxuXG5mdW5jdGlvbiBjbG9uZVR4UGFyYW1zKHR4UGFyYW1zKXtcbiAgdmFyIHNhbml0aXplZCAgPSAgcGVybWl0dGVkLnJlZHVjZShmdW5jdGlvbihjb3B5LCBwZXJtaXR0ZWQpIHtcbiAgICBpZiAocGVybWl0dGVkIGluIHR4UGFyYW1zKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eFBhcmFtc1twZXJtaXR0ZWRdKSkge1xuICAgICAgICBjb3B5W3Blcm1pdHRlZF0gPSB0eFBhcmFtc1twZXJtaXR0ZWRdXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBzYW5pdGl6ZShpdGVtKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weVtwZXJtaXR0ZWRdID0gc2FuaXRpemUodHhQYXJhbXNbcGVybWl0dGVkXSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHlcbiAgfSwge30pXG5cbiAgcmV0dXJuIHNhbml0aXplZFxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSAnbGF0ZXN0JzpcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgY2FzZSAnZWFybGllc3QnOlxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeCh2YWx1ZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gIH1cbn1cbiIsImNvbnN0IGNyZWF0ZVBheWxvYWQgPSByZXF1aXJlKCcuLi91dGlsL2NyZWF0ZS1wYXlsb2FkLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBTdWJQcm92aWRlclxuXG4vLyB0aGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhIHN1YnByb3ZpZGVyIC0tIG1vc3RseSBoZWxwZXJzXG5cblxuZnVuY3Rpb24gU3ViUHJvdmlkZXIoKSB7XG5cbn1cblxuU3ViUHJvdmlkZXIucHJvdG90eXBlLnNldEVuZ2luZSA9IGZ1bmN0aW9uKGVuZ2luZSkge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5lbmdpbmUpIHJldHVyblxuICBzZWxmLmVuZ2luZSA9IGVuZ2luZVxuICBlbmdpbmUub24oJ2Jsb2NrJywgZnVuY3Rpb24oYmxvY2spIHtcbiAgICBzZWxmLmN1cnJlbnRCbG9jayA9IGJsb2NrXG4gIH0pXG5cbiAgZW5naW5lLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnN0YXJ0KClcbiAgfSlcblxuICBlbmdpbmUub24oJ3N0b3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5zdG9wKClcbiAgfSlcbn1cblxuU3ViUHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbihwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdWJwcm92aWRlcnMgc2hvdWxkIG92ZXJyaWRlIGBoYW5kbGVSZXF1ZXN0YC4nKVxufVxuXG5TdWJQcm92aWRlci5wcm90b3R5cGUuZW1pdFBheWxvYWQgPSBmdW5jdGlvbihwYXlsb2FkLCBjYil7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuZW5naW5lLnNlbmRBc3luYyhjcmVhdGVQYXlsb2FkKHBheWxvYWQpLCBjYilcbn1cblxuLy8gZHVtbWllcyBmb3Igb3ZlcnJpZGluZ1xuXG5TdWJQcm92aWRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHt9XG5cblN1YlByb3ZpZGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHt9XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVTdWJzY3JpcHRpb25NYW5hZ2VyID0gcmVxdWlyZSgnZXRoLWpzb24tcnBjLWZpbHRlcnMvc3Vic2NyaXB0aW9uTWFuYWdlcicpXG5cbmNsYXNzIFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlciBleHRlbmRzIFByb3ZpZGVyU3VicHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyLCBlbmdpbmUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBldmVudHMsIG1pZGRsZXdhcmUgfSA9IGNyZWF0ZVN1YnNjcmlwdGlvbk1hbmFnZXIoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0pXG4gICAgICAvLyBmb3J3YXJkIHN1YnNjcmlwdGlvbiBldmVudHMgb24gdGhlIGVuZ2luZVxuICAgICAgZXZlbnRzLm9uKCdub3RpZmljYXRpb24nLCAoZGF0YSkgPT4gZW5naW5lLmVtaXQoJ2RhdGEnLCBudWxsLCBkYXRhKSlcbiAgICAgIC8vIHJldHVybiB0aGUgc3Vic2NyaXB0aW9uIGluc3RhbGwvcmVtb3ZlIG1pZGRsZXdhcmVcbiAgICAgIHJldHVybiBtaWRkbGV3YXJlXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlclxuIiwiY29uc3QgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvZmYnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCBXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IHJlcXVpcmUoJ3dzJylcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcicpXG5jb25zdCBjcmVhdGVQYXlsb2FkID0gcmVxdWlyZSgnLi4vdXRpbC9jcmVhdGUtcGF5bG9hZCcpXG5cbmNsYXNzIFdlYnNvY2tldFN1YnByb3ZpZGVyXG4gZXh0ZW5kcyBTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHsgcnBjVXJsLCBkZWJ1Zywgb3JpZ2luIH0pIHtcbiAgICBzdXBlcigpXG5cbiAgICAvLyBpbmhlcml0IGZyb20gRXZlbnRFbWl0dGVyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIF9iYWNrb2ZmOiB7XG4gICAgICAgIHZhbHVlOiBCYWNrb2ZmLmV4cG9uZW50aWFsKHtcbiAgICAgICAgICByYW5kb21pc2F0aW9uRmFjdG9yOiAwLjIsXG4gICAgICAgICAgbWF4RGVsYXk6IDUwMDBcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBfY29ubmVjdFRpbWU6IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgX2xvZzoge1xuICAgICAgICB2YWx1ZTogZGVidWdcbiAgICAgICAgICA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgWydbV1NQcm92aWRlcl0nLCAuLi5hcmdzXSlcbiAgICAgICAgICA6ICgpID0+IHsgfVxuICAgICAgfSxcbiAgICAgIF9vcmlnaW46IHtcbiAgICAgICAgdmFsdWU6IG9yaWdpblxuICAgICAgfSxcbiAgICAgIF9wZW5kaW5nUmVxdWVzdHM6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgfSxcbiAgICAgIF9zb2NrZXQ6IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgX3VuaGFuZGxlZFJlcXVlc3RzOiB7XG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfSxcbiAgICAgIF91cmw6IHtcbiAgICAgICAgdmFsdWU6IHJwY1VybFxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9oYW5kbGVTb2NrZXRDbG9zZSA9IHRoaXMuX2hhbmRsZVNvY2tldENsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVTb2NrZXRNZXNzYWdlID0gdGhpcy5faGFuZGxlU29ja2V0TWVzc2FnZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5faGFuZGxlU29ja2V0T3BlbiA9IHRoaXMuX2hhbmRsZVNvY2tldE9wZW4uYmluZCh0aGlzKVxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBiYWNrb2ZmIHRpbWVvdXQgaGFzIGZpbmlzaGVkLiBUaW1lIHRvIHRyeSByZWNvbm5lY3RpbmcuXG4gICAgdGhpcy5fYmFja29mZi5vbigncmVhZHknLCAoKSA9PiB7XG4gICAgICB0aGlzLl9vcGVuU29ja2V0KClcbiAgICB9KVxuXG4gICAgdGhpcy5fb3BlblNvY2tldCgpXG4gIH1cblxuICBoYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0IHx8IHRoaXMuX3NvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdGhpcy5fdW5oYW5kbGVkUmVxdWVzdHMucHVzaChBcnJheS5mcm9tKGFyZ3VtZW50cykpXG4gICAgICB0aGlzLl9sb2coJ1NvY2tldCBub3Qgb3Blbi4gUmVxdWVzdCBxdWV1ZWQuJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zZXQocGF5bG9hZC5pZCwgW3BheWxvYWQsIGVuZF0pXG5cbiAgICBjb25zdCBuZXdQYXlsb2FkID0gY3JlYXRlUGF5bG9hZChwYXlsb2FkKVxuICAgIGRlbGV0ZSBuZXdQYXlsb2FkLm9yaWdpblxuXG4gICAgdGhpcy5fc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobmV3UGF5bG9hZCkpXG4gICAgdGhpcy5fbG9nKGBTZW50OiAke25ld1BheWxvYWQubWV0aG9kfSAjJHtuZXdQYXlsb2FkLmlkfWApXG4gIH1cblxuICBfaGFuZGxlU29ja2V0Q2xvc2UoeyByZWFzb24sIGNvZGUgfSkge1xuICAgIHRoaXMuX2xvZyhgU29ja2V0IGNsb3NlZCwgY29kZSAke2NvZGV9ICgke3JlYXNvbiB8fCAnbm8gcmVhc29uJ30pYClcbiAgICAvLyBJZiB0aGUgc29ja2V0IGhhcyBiZWVuIG9wZW4gZm9yIGxvbmdlciB0aGFuIDUgc2Vjb25kcywgcmVzZXQgdGhlIGJhY2tvZmZcbiAgICBpZiAodGhpcy5fY29ubmVjdFRpbWUgJiYgRGF0ZS5ub3coKSAtIHRoaXMuX2Nvbm5lY3RUaW1lID4gNTAwMCkge1xuICAgICAgdGhpcy5fYmFja29mZi5yZXNldCgpXG4gICAgfVxuXG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5faGFuZGxlU29ja2V0Q2xvc2UpXG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9oYW5kbGVTb2NrZXRNZXNzYWdlKVxuICAgIHRoaXMuX3NvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5faGFuZGxlU29ja2V0T3BlbilcblxuICAgIHRoaXMuX3NvY2tldCA9IG51bGxcbiAgICB0aGlzLl9iYWNrb2ZmLmJhY2tvZmYoKVxuICB9XG5cbiAgX2hhbmRsZVNvY2tldE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGxldCBwYXlsb2FkXG5cbiAgICB0cnkge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuX2xvZygnUmVjZWl2ZWQgYSBtZXNzYWdlIHRoYXQgaXMgbm90IHZhbGlkIEpTT046JywgcGF5bG9hZClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHNlcnZlci1zZW50IG5vdGlmaWNhdGlvblxuICAgIGlmIChwYXlsb2FkLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZ2luZS5lbWl0KCdkYXRhJywgbnVsbCwgcGF5bG9hZClcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgaWYgbWlzc2luZ1xuICAgIGlmICghdGhpcy5fcGVuZGluZ1JlcXVlc3RzLmhhcyhwYXlsb2FkLmlkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV0cmlldmUgcGF5bG9hZCArIGFyZ3VtZW50c1xuICAgIGNvbnN0IFtvcmlnaW5hbFJlcSwgZW5kXSA9IHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5nZXQocGF5bG9hZC5pZClcbiAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKHBheWxvYWQuaWQpXG5cbiAgICB0aGlzLl9sb2coYFJlY2VpdmVkOiAke29yaWdpbmFsUmVxLm1ldGhvZH0gIyR7cGF5bG9hZC5pZH1gKVxuXG4gICAgLy8gZm9yd2FyZCByZXNwb25zZVxuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICByZXR1cm4gZW5kKG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpKVxuICAgIH1cbiAgICBlbmQobnVsbCwgcGF5bG9hZC5yZXN1bHQpXG4gIH1cblxuICBfaGFuZGxlU29ja2V0T3BlbigpIHtcbiAgICB0aGlzLl9sb2coJ1NvY2tldCBvcGVuLicpXG4gICAgdGhpcy5fY29ubmVjdFRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICAvLyBBbnkgcGVuZGluZyByZXF1ZXN0cyBuZWVkIHRvIGJlIHJlc2VudCBiZWNhdXNlIG91ciBzZXNzaW9uIHdhcyBsb3N0XG4gICAgLy8gYW5kIHdpbGwgbm90IGdldCByZXNwb25zZXMgZm9yIHRoZW0gaW4gb3VyIG5ldyBzZXNzaW9uLlxuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5mb3JFYWNoKChbcGF5bG9hZCwgZW5kXSkgPT4ge1xuICAgICAgdGhpcy5fdW5oYW5kbGVkUmVxdWVzdHMucHVzaChbcGF5bG9hZCwgbnVsbCwgZW5kXSlcbiAgICB9KVxuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5jbGVhcigpXG5cbiAgICBjb25zdCB1bmhhbmRsZWRSZXF1ZXN0cyA9IHRoaXMuX3VuaGFuZGxlZFJlcXVlc3RzLnNwbGljZSgwLCB0aGlzLl91bmhhbmRsZWRSZXF1ZXN0cy5sZW5ndGgpXG4gICAgdW5oYW5kbGVkUmVxdWVzdHMuZm9yRWFjaChyZXF1ZXN0ID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlUmVxdWVzdC5hcHBseSh0aGlzLCByZXF1ZXN0KVxuICAgIH0pXG4gIH1cblxuICBfb3BlblNvY2tldCgpIHtcbiAgICB0aGlzLl9sb2coJ09wZW5pbmcgc29ja2V0Li4uJylcbiAgICB0aGlzLl9zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMuX3VybCwgW10sIHRoaXMuX29yaWdpbiA/IHtoZWFkZXJzOntvcmlnaW46IHRoaXMuX29yaWdpbn19IDoge30pXG4gICAgdGhpcy5fc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5faGFuZGxlU29ja2V0Q2xvc2UpXG4gICAgdGhpcy5fc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9oYW5kbGVTb2NrZXRNZXNzYWdlKVxuICAgIHRoaXMuX3NvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5faGFuZGxlU29ja2V0T3BlbilcbiAgfVxufVxuXG4vLyBtdWx0aXBsZSBpbmhlcml0YW5jZVxuT2JqZWN0LmFzc2lnbihXZWJzb2NrZXRTdWJwcm92aWRlci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbm1vZHVsZS5leHBvcnRzID0gV2Vic29ja2V0U3VicHJvdmlkZXJcbiIsImNvbnN0IGdldFJhbmRvbUlkID0gcmVxdWlyZSgnLi9yYW5kb20taWQuanMnKVxuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVBheWxvYWRcblxuXG5mdW5jdGlvbiBjcmVhdGVQYXlsb2FkKGRhdGEpe1xuICByZXR1cm4gZXh0ZW5kKHtcbiAgICAvLyBkZWZhdWx0c1xuICAgIGlkOiBnZXRSYW5kb21JZCgpLFxuICAgIGpzb25ycGM6ICcyLjAnLFxuICAgIHBhcmFtczogW10sXG4gICAgLy8gdXNlci1zcGVjaWZpZWRcbiAgfSwgZGF0YSlcbn1cbiIsImNvbnN0IGNyZWF0ZVBheWxvYWQgPSByZXF1aXJlKCcuL2NyZWF0ZS1wYXlsb2FkLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBlc3RpbWF0ZUdhc1xuXG4vKlxuXG5UaGlzIGlzIGEgd29yayBhcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjU3N1xuXG4qL1xuXG5cbmZ1bmN0aW9uIGVzdGltYXRlR2FzKHByb3ZpZGVyLCB0eFBhcmFtcywgY2IpIHtcbiAgcHJvdmlkZXIuc2VuZEFzeW5jKGNyZWF0ZVBheWxvYWQoe1xuICAgIG1ldGhvZDogJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICAgcGFyYW1zOiBbdHhQYXJhbXNdXG4gIH0pLCBmdW5jdGlvbihlcnIsIHJlcyl7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gaGFuZGxlIHNpbXBsZSB2YWx1ZSB0cmFuc2ZlciBjYXNlXG4gICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09ICdubyBjb250cmFjdCBjb2RlIGF0IGdpdmVuIGFkZHJlc3MnKSB7XG4gICAgICAgIHJldHVybiBjYihudWxsLCAnMHhjZjA4JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpICAgICAgICBcbiAgICAgIH1cbiAgICB9XG4gICAgY2IobnVsbCwgcmVzLnJlc3VsdClcbiAgfSlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJhbmRvbUlkXG5cblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tSWQgKCkge1xuICAvLyByYW5kb20gaWRcbiAgcmV0dXJuIE1hdGguZmxvb3IoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKiBNYXRoLnJhbmRvbSgpKVxufSIsImNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkOiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkLFxuICBjYW5DYWNoZTogY2FuQ2FjaGUsXG4gIGJsb2NrVGFnRm9yUGF5bG9hZDogYmxvY2tUYWdGb3JQYXlsb2FkLFxuICBwYXJhbXNXaXRob3V0QmxvY2tUYWc6IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyxcbiAgYmxvY2tUYWdQYXJhbUluZGV4OiBibG9ja1RhZ1BhcmFtSW5kZXgsXG4gIGNhY2hlVHlwZUZvclBheWxvYWQ6IGNhY2hlVHlwZUZvclBheWxvYWQsXG59XG5cbmZ1bmN0aW9uIGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCwgb3B0cyA9IHt9KXtcbiAgaWYgKCFjYW5DYWNoZShwYXlsb2FkKSkgcmV0dXJuIG51bGxcbiAgY29uc3QgeyBpbmNsdWRlQmxvY2tSZWYgfSA9IG9wdHNcbiAgY29uc3QgcGFyYW1zID0gaW5jbHVkZUJsb2NrUmVmID8gcGF5bG9hZC5wYXJhbXMgOiBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZClcbiAgcmV0dXJuIHBheWxvYWQubWV0aG9kICsgJzonICsgc3RyaW5naWZ5KHBhcmFtcylcbn1cblxuZnVuY3Rpb24gY2FuQ2FjaGUocGF5bG9hZCl7XG4gIHJldHVybiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpICE9PSAnbmV2ZXInXG59XG5cbmZ1bmN0aW9uIGJsb2NrVGFnRm9yUGF5bG9hZChwYXlsb2FkKXtcbiAgdmFyIGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuXG4gIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICBpZiAoaW5kZXggPj0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF5bG9hZC5wYXJhbXNbaW5kZXhdO1xufVxuXG5mdW5jdGlvbiBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZCl7XG4gIHZhciBpbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleChwYXlsb2FkKTtcblxuICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgaWYgKGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcztcbiAgfVxuXG4gIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJykge1xuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgwLGluZGV4KTtcbn1cblxuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpe1xuICBzd2l0Y2gocGF5bG9hZC5tZXRob2QpIHtcbiAgICAvLyBibG9ja1RhZyBpcyB0aGlyZCBwYXJhbVxuICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgcmV0dXJuIDJcbiAgICAvLyBibG9ja1RhZyBpcyBzZWNvbmQgcGFyYW1cbiAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgY2FzZSAnZXRoX2VzdGltYXRlR2FzJzpcbiAgICAgIHJldHVybiAxXG4gICAgLy8gYmxvY2tUYWcgaXMgZmlyc3QgcGFyYW1cbiAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICByZXR1cm4gMFxuICAgIC8vIHRoZXJlIGlzIG5vIGJsb2NrVGFnXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgIC8vIGNhY2hlIHBlcm1hbmVudGx5XG4gICAgY2FzZSAnd2ViM19jbGllbnRWZXJzaW9uJzpcbiAgICBjYXNlICd3ZWIzX3NoYTMnOlxuICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnOlxuICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2gnOlxuICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICBjYXNlICdldGhfZ2V0QmxvY2tCeUhhc2gnOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCc6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgY2FzZSAnZXRoX2NvbXBpbGVMTEwnOlxuICAgIGNhc2UgJ2V0aF9jb21waWxlU29saWRpdHknOlxuICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgY2FzZSAnc2hoX3ZlcnNpb24nOlxuICAgICAgcmV0dXJuICdwZXJtYSdcblxuICAgIC8vIGNhY2hlIHVudGlsIGZvcmtcbiAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICBjYXNlICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgIHJldHVybiAnZm9yaydcblxuICAgIC8vIGNhY2hlIGZvciBibG9ja1xuICAgIGNhc2UgJ2V0aF9nYXNQcmljZSc6XG4gICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgY2FzZSAnZXRoX2VzdGltYXRlR2FzJzpcbiAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgY2FzZSAnZXRoX2dldExvZ3MnOlxuICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICByZXR1cm4gJ2Jsb2NrJ1xuXG4gICAgLy8gbmV2ZXIgY2FjaGVcbiAgICBjYXNlICduZXRfdmVyc2lvbic6XG4gICAgY2FzZSAnbmV0X3BlZXJDb3VudCc6XG4gICAgY2FzZSAnbmV0X2xpc3RlbmluZyc6XG4gICAgY2FzZSAnZXRoX3N5bmNpbmcnOlxuICAgIGNhc2UgJ2V0aF9zaWduJzpcbiAgICBjYXNlICdldGhfY29pbmJhc2UnOlxuICAgIGNhc2UgJ2V0aF9taW5pbmcnOlxuICAgIGNhc2UgJ2V0aF9oYXNocmF0ZSc6XG4gICAgY2FzZSAnZXRoX2FjY291bnRzJzpcbiAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICBjYXNlICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJzpcbiAgICBjYXNlICdldGhfbmV3RmlsdGVyJzpcbiAgICBjYXNlICdldGhfbmV3QmxvY2tGaWx0ZXInOlxuICAgIGNhc2UgJ2V0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXInOlxuICAgIGNhc2UgJ2V0aF91bmluc3RhbGxGaWx0ZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRGaWx0ZXJDaGFuZ2VzJzpcbiAgICBjYXNlICdldGhfZ2V0V29yayc6XG4gICAgY2FzZSAnZXRoX3N1Ym1pdFdvcmsnOlxuICAgIGNhc2UgJ2V0aF9zdWJtaXRIYXNocmF0ZSc6XG4gICAgY2FzZSAnZGJfcHV0U3RyaW5nJzpcbiAgICBjYXNlICdkYl9nZXRTdHJpbmcnOlxuICAgIGNhc2UgJ2RiX3B1dEhleCc6XG4gICAgY2FzZSAnZGJfZ2V0SGV4JzpcbiAgICBjYXNlICdzaGhfcG9zdCc6XG4gICAgY2FzZSAnc2hoX25ld0lkZW50aXR5JzpcbiAgICBjYXNlICdzaGhfaGFzSWRlbnRpdHknOlxuICAgIGNhc2UgJ3NoaF9uZXdHcm91cCc6XG4gICAgY2FzZSAnc2hoX2FkZFRvR3JvdXAnOlxuICAgIGNhc2UgJ3NoaF9uZXdGaWx0ZXInOlxuICAgIGNhc2UgJ3NoaF91bmluc3RhbGxGaWx0ZXInOlxuICAgIGNhc2UgJ3NoaF9nZXRGaWx0ZXJDaGFuZ2VzJzpcbiAgICBjYXNlICdzaGhfZ2V0TWVzc2FnZXMnOlxuICAgICAgcmV0dXJuICduZXZlcidcbiAgfVxufVxuIiwiY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3BsaWdodFxuXG5cbmluaGVyaXRzKFN0b3BsaWdodCwgRXZlbnRFbWl0dGVyKVxuXG5mdW5jdGlvbiBTdG9wbGlnaHQoKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcbiAgc2VsZi5pc0xvY2tlZCA9IHRydWVcbn1cblxuU3RvcGxpZ2h0LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuaXNMb2NrZWQgPSBmYWxzZVxuICBzZWxmLmVtaXQoJ3VubG9jaycpXG59XG5cblN0b3BsaWdodC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuaXNMb2NrZWQgPSB0cnVlXG4gIHNlbGYuZW1pdCgnbG9jaycpXG59XG5cblN0b3BsaWdodC5wcm90b3R5cGUuYXdhaXQgPSBmdW5jdGlvbihmbil7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmlzTG9ja2VkKSB7XG4gICAgc2VsZi5vbmNlKCd1bmxvY2snLCBmbilcbiAgfSBlbHNlIHtcbiAgICBzZXRUaW1lb3V0KGZuKVxuICB9XG59IiwiY29uc3QgUHJvdmlkZXJFbmdpbmUgPSByZXF1aXJlKCcuL2luZGV4LmpzJylcbmNvbnN0IERlZmF1bHRGaXh0dXJlID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvZGVmYXVsdC1maXh0dXJlLmpzJylcbmNvbnN0IE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvbm9uY2UtdHJhY2tlci5qcycpXG5jb25zdCBDYWNoZVN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvY2FjaGUuanMnKVxuY29uc3QgRmlsdGVyU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL3N1YnByb3ZpZGVycy9maWx0ZXJzJylcbmNvbnN0IFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvc3Vic2NyaXB0aW9ucycpXG5jb25zdCBJbmZsaWdodENhY2hlU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL3N1YnByb3ZpZGVycy9pbmZsaWdodC1jYWNoZScpXG5jb25zdCBIb29rZWRXYWxsZXRTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXJzL2hvb2tlZC13YWxsZXQuanMnKVxuY29uc3QgU2FuaXRpemluZ1N1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvc2FuaXRpemVyLmpzJylcbmNvbnN0IEluZnVyYVN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvaW5mdXJhLmpzJylcbmNvbnN0IEZldGNoU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL3N1YnByb3ZpZGVycy9mZXRjaC5qcycpXG5jb25zdCBXZWJTb2NrZXRTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXJzL3dlYnNvY2tldC5qcycpXG5cblxubW9kdWxlLmV4cG9ydHMgPSBaZXJvQ2xpZW50UHJvdmlkZXJcblxuXG5mdW5jdGlvbiBaZXJvQ2xpZW50UHJvdmlkZXIob3B0cyA9IHt9KXtcbiAgY29uc3QgY29ubmVjdGlvblR5cGUgPSBnZXRDb25uZWN0aW9uVHlwZShvcHRzKVxuXG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBQcm92aWRlckVuZ2luZShvcHRzLmVuZ2luZVBhcmFtcylcblxuICAvLyBzdGF0aWNcbiAgY29uc3Qgc3RhdGljU3VicHJvdmlkZXIgPSBuZXcgRGVmYXVsdEZpeHR1cmUob3B0cy5zdGF0aWMpXG4gIGVuZ2luZS5hZGRQcm92aWRlcihzdGF0aWNTdWJwcm92aWRlcilcblxuICAvLyBub25jZSB0cmFja2VyXG4gIGVuZ2luZS5hZGRQcm92aWRlcihuZXcgTm9uY2VUcmFja2VyU3VicHJvdmlkZXIoKSlcblxuICAvLyBzYW5pdGl6YXRpb25cbiAgY29uc3Qgc2FuaXRpemVyID0gbmV3IFNhbml0aXppbmdTdWJwcm92aWRlcigpXG4gIGVuZ2luZS5hZGRQcm92aWRlcihzYW5pdGl6ZXIpXG5cbiAgLy8gY2FjaGUgbGF5ZXJcbiAgY29uc3QgY2FjaGVTdWJwcm92aWRlciA9IG5ldyBDYWNoZVN1YnByb3ZpZGVyKClcbiAgZW5naW5lLmFkZFByb3ZpZGVyKGNhY2hlU3VicHJvdmlkZXIpXG5cbiAgLy8gZmlsdGVycyArIHN1YnNjcmlwdGlvbnNcbiAgLy8gb25seSBwb2x5ZmlsbCBpZiBub3Qgd2Vic29ja2V0c1xuICBpZiAoY29ubmVjdGlvblR5cGUgIT09ICd3cycpIHtcbiAgICBlbmdpbmUuYWRkUHJvdmlkZXIobmV3IFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyKCkpXG4gICAgZW5naW5lLmFkZFByb3ZpZGVyKG5ldyBGaWx0ZXJTdWJwcm92aWRlcigpKVxuICB9XG5cbiAgLy8gaW5mbGlnaHQgY2FjaGVcbiAgY29uc3QgaW5mbGlnaHRDYWNoZSA9IG5ldyBJbmZsaWdodENhY2hlU3VicHJvdmlkZXIoKVxuICBlbmdpbmUuYWRkUHJvdmlkZXIoaW5mbGlnaHRDYWNoZSlcblxuICAvLyBpZCBtZ210XG4gIGNvbnN0IGlkbWdtdFN1YnByb3ZpZGVyID0gbmV3IEhvb2tlZFdhbGxldFN1YnByb3ZpZGVyKHtcbiAgICAvLyBhY2NvdW50c1xuICAgIGdldEFjY291bnRzOiBvcHRzLmdldEFjY291bnRzLFxuICAgIC8vIHRyYW5zYWN0aW9uc1xuICAgIHByb2Nlc3NUcmFuc2FjdGlvbjogb3B0cy5wcm9jZXNzVHJhbnNhY3Rpb24sXG4gICAgYXBwcm92ZVRyYW5zYWN0aW9uOiBvcHRzLmFwcHJvdmVUcmFuc2FjdGlvbixcbiAgICBzaWduVHJhbnNhY3Rpb246IG9wdHMuc2lnblRyYW5zYWN0aW9uLFxuICAgIHB1Ymxpc2hUcmFuc2FjdGlvbjogb3B0cy5wdWJsaXNoVHJhbnNhY3Rpb24sXG4gICAgLy8gbWVzc2FnZXNcbiAgICAvLyBvbGQgZXRoX3NpZ25cbiAgICBwcm9jZXNzTWVzc2FnZTogb3B0cy5wcm9jZXNzTWVzc2FnZSxcbiAgICBhcHByb3ZlTWVzc2FnZTogb3B0cy5hcHByb3ZlTWVzc2FnZSxcbiAgICBzaWduTWVzc2FnZTogb3B0cy5zaWduTWVzc2FnZSxcbiAgICAvLyBuZXcgcGVyc29uYWxfc2lnblxuICAgIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2U6IG9wdHMucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSxcbiAgICBwcm9jZXNzVHlwZWRNZXNzYWdlOiBvcHRzLnByb2Nlc3NUeXBlZE1lc3NhZ2UsXG4gICAgYXBwcm92ZVBlcnNvbmFsTWVzc2FnZTogb3B0cy5hcHByb3ZlUGVyc29uYWxNZXNzYWdlLFxuICAgIGFwcHJvdmVUeXBlZE1lc3NhZ2U6IG9wdHMuYXBwcm92ZVR5cGVkTWVzc2FnZSxcbiAgICBzaWduUGVyc29uYWxNZXNzYWdlOiBvcHRzLnNpZ25QZXJzb25hbE1lc3NhZ2UsXG4gICAgc2lnblR5cGVkTWVzc2FnZTogb3B0cy5zaWduVHlwZWRNZXNzYWdlLFxuICAgIHBlcnNvbmFsUmVjb3ZlclNpZ25lcjogb3B0cy5wZXJzb25hbFJlY292ZXJTaWduZXIsXG4gIH0pXG4gIGVuZ2luZS5hZGRQcm92aWRlcihpZG1nbXRTdWJwcm92aWRlcilcblxuICAvLyBkYXRhIHNvdXJjZVxuICBjb25zdCBkYXRhU3VicHJvdmlkZXIgPSBvcHRzLmRhdGFTdWJwcm92aWRlciB8fCBjcmVhdGVEYXRhU3VicHJvdmlkZXIoY29ubmVjdGlvblR5cGUsIG9wdHMpXG4gIGVuZ2luZS5hZGRQcm92aWRlcihkYXRhU3VicHJvdmlkZXIpXG5cbiAgLy8gc3RhcnQgcG9sbGluZ1xuICBpZiAoIW9wdHMuc3RvcHBlZCkge1xuICAgIGVuZ2luZS5zdGFydCgpXG4gIH1cblxuICByZXR1cm4gZW5naW5lXG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YVN1YnByb3ZpZGVyKGNvbm5lY3Rpb25UeXBlLCBvcHRzKSB7XG4gIGNvbnN0IHsgcnBjVXJsLCBkZWJ1ZyB9ID0gb3B0c1xuXG4gIC8vIGRlZmF1bHQgdG8gaW5mdXJhXG4gIGlmICghY29ubmVjdGlvblR5cGUpIHtcbiAgICByZXR1cm4gbmV3IEluZnVyYVN1YnByb3ZpZGVyKClcbiAgfVxuICBpZiAoY29ubmVjdGlvblR5cGUgPT09ICdodHRwJykge1xuICAgIHJldHVybiBuZXcgRmV0Y2hTdWJwcm92aWRlcih7IHJwY1VybCwgZGVidWcgfSlcbiAgfVxuICBpZiAoY29ubmVjdGlvblR5cGUgPT09ICd3cycpIHtcbiAgICByZXR1cm4gbmV3IFdlYlNvY2tldFN1YnByb3ZpZGVyKHsgcnBjVXJsLCBkZWJ1ZyB9KVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlckVuZ2luZSAtIHVucmVjb2duaXplZCBjb25uZWN0aW9uVHlwZSBcIiR7Y29ubmVjdGlvblR5cGV9XCJgKVxufVxuXG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uVHlwZSh7IHJwY1VybCB9KSB7XG4gIGlmICghcnBjVXJsKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgcHJvdG9jb2wgPSBycGNVcmwuc3BsaXQoJzonKVswXS50b0xvd2VyQ2FzZSgpXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICdodHRwcyc6XG4gICAgICByZXR1cm4gJ2h0dHAnXG4gICAgY2FzZSAnd3MnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgICByZXR1cm4gJ3dzJ1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVyRW5naW5lIC0gdW5yZWNvZ25pemVkIHByb3RvY29sIGluIFwiJHtycGNVcmx9XCJgKVxuICB9XG59XG4iLCJ2YXIgV2ViMyA9IHJlcXVpcmUoJy4vbGliL3dlYjMnKTtcblxuLy8gZG9udCBvdmVycmlkZSBnbG9iYWwgdmFyaWFibGVcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LldlYjMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LldlYjMgPSBXZWIzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYjM7XG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfb3duZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJuYW1lXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwib19uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiY29udGVudFwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiYWRkclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcInJlc2VydmVcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJzdWJSZWdpc3RyYXJcIixcbiAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmV3T3duZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJ0cmFuc2ZlclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfcmVnaXN0cmFyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwic2V0U3ViUmVnaXN0cmFyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW10sXG4gICAgXCJuYW1lXCI6IFwiUmVnaXN0cmFyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9hXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX3ByaW1hcnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJzZXRBZGRyZXNzXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9jb250ZW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwic2V0Q29udGVudFwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJkaXNvd25cIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXG4gICAgICAgIFwibmFtZVwiOiBcIl93aW5uZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJBdWN0aW9uRW5kZWRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiX2JpZGRlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiX3ZhbHVlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiTmV3QmlkXCIsXG4gICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwibmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkNoYW5nZWRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJuYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgIFwibmFtZVwiOiBcImFkZHJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJQcmltYXJ5Q2hhbmdlZFwiLFxuICAgIFwidHlwZVwiOiBcImV2ZW50XCJcbiAgfVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9yZWZ1bmRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJkaXNvd25cIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJhZGRyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwicmVzZXJ2ZVwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmV3T3duZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJ0cmFuc2ZlclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcInNldEFkZHJcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwibmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkNoYW5nZWRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcInRyYW5zZmVyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJpbmRpcmVjdElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidmFsdWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJpY2FwVHJhbnNmZXJcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiZGVwb3NpdFwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInBheWFibGVcIjogdHJ1ZSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkFub255bW91c0RlcG9zaXRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgIFwibmFtZVwiOiBcInRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkRlcG9zaXRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgIFwibmFtZVwiOiBcInRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIlRyYW5zZmVyXCIsXG4gICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiZnJvbVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJ0b1wiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiaW5kaXJlY3RJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwidmFsdWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJJY2FwVHJhbnNmZXJcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH1cbl1cbiIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlQWRkcmVzcyBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyBhZGRyZXNzIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBhZGRyZXNzXG4gKiBhZGRyZXNzW11cbiAqIGFkZHJlc3NbNF1cbiAqIGFkZHJlc3NbXVtdXG4gKiBhZGRyZXNzWzNdW11cbiAqIGFkZHJlc3NbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0SW50O1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0QWRkcmVzcztcbn07XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVBZGRyZXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvYWRkcmVzcyhcXFsoWzAtOV0qKVxcXSk/Lyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZUJvb2wgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgYm9vbCB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogYm9vbFxuICogYm9vbFtdXG4gKiBib29sWzRdXG4gKiBib29sW11bXVxuICogYm9vbFszXVtdXG4gKiBib29sW11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVCb29sID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEJvb2w7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRCb29sO1xufTtcblxuU29saWRpdHlUeXBlQm9vbC5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZUJvb2wucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlQm9vbDtcblxuU29saWRpdHlUeXBlQm9vbC5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9eYm9vbChcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVCb29sO1xuIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVCeXRlcyBpcyBhIHByb3RvdHlwZSB0aGF0IHJlcHJlc2VudHMgdGhlIGJ5dGVzIHR5cGUuXG4gKiBJdCBtYXRjaGVzOlxuICogYnl0ZXNcbiAqIGJ5dGVzW11cbiAqIGJ5dGVzWzRdXG4gKiBieXRlc1tdW11cbiAqIGJ5dGVzWzNdW11cbiAqIGJ5dGVzW11bNl1bXSwgLi4uXG4gKiBieXRlczMyXG4gKiBieXRlczhbNF1cbiAqIGJ5dGVzWzNdW11cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEJ5dGVzO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0Qnl0ZXM7XG59O1xuXG5Tb2xpZGl0eVR5cGVCeXRlcy5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZUJ5dGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUJ5dGVzO1xuXG5Tb2xpZGl0eVR5cGVCeXRlcy5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9eYnl0ZXMoWzAtOV17MSx9KShcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVCeXRlcztcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGNvZGVyLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG52YXIgU29saWRpdHlUeXBlQm9vbCA9IHJlcXVpcmUoJy4vYm9vbCcpO1xudmFyIFNvbGlkaXR5VHlwZUludCA9IHJlcXVpcmUoJy4vaW50Jyk7XG52YXIgU29saWRpdHlUeXBlVUludCA9IHJlcXVpcmUoJy4vdWludCcpO1xudmFyIFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcyA9IHJlcXVpcmUoJy4vZHluYW1pY2J5dGVzJyk7XG52YXIgU29saWRpdHlUeXBlU3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbnZhciBTb2xpZGl0eVR5cGVSZWFsID0gcmVxdWlyZSgnLi9yZWFsJyk7XG52YXIgU29saWRpdHlUeXBlVVJlYWwgPSByZXF1aXJlKCcuL3VyZWFsJyk7XG52YXIgU29saWRpdHlUeXBlQnl0ZXMgPSByZXF1aXJlKCcuL2J5dGVzJyk7XG5cbnZhciBpc0R5bmFtaWMgPSBmdW5jdGlvbiAoc29saWRpdHlUeXBlLCB0eXBlKSB7XG4gICByZXR1cm4gc29saWRpdHlUeXBlLmlzRHluYW1pY1R5cGUodHlwZSkgfHxcbiAgICAgICAgICBzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkodHlwZSk7XG59O1xuXG4vKipcbiAqIFNvbGlkaXR5Q29kZXIgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGFueSB0eXBlXG4gKi9cbnZhciBTb2xpZGl0eUNvZGVyID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdGhpcy5fdHlwZXMgPSB0eXBlcztcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHR5cGUgdG8gU29saWRpdHlUeXBlXG4gKlxuICogQG1ldGhvZCBfcmVxdWlyZVR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJucyB7U29saWRpdHlUeXBlfVxuICogQHRocm93cyB7RXJyb3J9IHRocm93cyBpZiBubyBtYXRjaGluZyB0eXBlIGlzIGZvdW5kXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLl9yZXF1aXJlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZSA9IHRoaXMuX3R5cGVzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pc1R5cGUodHlwZSk7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoIXNvbGlkaXR5VHlwZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBzb2xpZGl0eSB0eXBlITogJyArIHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzb2xpZGl0eVR5cGU7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBwbGFpbiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFyYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gcGxhaW4gcGFyYW1cbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBwbGFpbiBwYXJhbVxuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJhbSkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZVBhcmFtcyhbdHlwZV0sIFtwYXJhbV0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVBhcmFtc1xuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtc1xuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGxpc3Qgb2YgcGFyYW1zXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZVBhcmFtcyA9IGZ1bmN0aW9uICh0eXBlcywgcGFyYW1zKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZXMgPSB0aGlzLmdldFNvbGlkaXR5VHlwZXModHlwZXMpO1xuXG4gICAgdmFyIGVuY29kZWRzID0gc29saWRpdHlUeXBlcy5tYXAoZnVuY3Rpb24gKHNvbGlkaXR5VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHNvbGlkaXR5VHlwZS5lbmNvZGUocGFyYW1zW2luZGV4XSwgdHlwZXNbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gc29saWRpdHlUeXBlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICB2YXIgc3RhdGljUGFydExlbmd0aCA9IHNvbGlkaXR5VHlwZS5zdGF0aWNQYXJ0TGVuZ3RoKHR5cGVzW2luZGV4XSk7XG4gICAgICAgIHZhciByb3VuZGVkU3RhdGljUGFydExlbmd0aCA9IE1hdGguZmxvb3IoKHN0YXRpY1BhcnRMZW5ndGggKyAzMSkgLyAzMikgKiAzMjtcblxuICAgICAgICByZXR1cm4gYWNjICsgKGlzRHluYW1pYyhzb2xpZGl0eVR5cGVzW2luZGV4XSwgdHlwZXNbaW5kZXhdKSA/XG4gICAgICAgICAgICAzMiA6XG4gICAgICAgICAgICByb3VuZGVkU3RhdGljUGFydExlbmd0aCk7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5lbmNvZGVNdWx0aVdpdGhPZmZzZXQodHlwZXMsIHNvbGlkaXR5VHlwZXMsIGVuY29kZWRzLCBkeW5hbWljT2Zmc2V0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVNdWx0aVdpdGhPZmZzZXQgPSBmdW5jdGlvbiAodHlwZXMsIHNvbGlkaXR5VHlwZXMsIGVuY29kZWRzLCBkeW5hbWljT2Zmc2V0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICBpZiAoaXNEeW5hbWljKHNvbGlkaXR5VHlwZXNbaV0sIHR5cGVzW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGYuZm9ybWF0SW5wdXRJbnQoZHluYW1pY09mZnNldCkuZW5jb2RlKCk7XG4gICAgICAgICAgICB2YXIgZSA9IHNlbGYuZW5jb2RlV2l0aE9mZnNldCh0eXBlc1tpXSwgc29saWRpdHlUeXBlc1tpXSwgZW5jb2RlZHNbaV0sIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgZHluYW1pY09mZnNldCArPSBlLmxlbmd0aCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkb24ndCBhZGQgbGVuZ3RoIHRvIGR5bmFtaWNPZmZzZXQuIGl0J3MgYWxyZWFkeSBjb3VudGVkXG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IG5lc3RlZCBhcnJheXNcbiAgICB9KTtcblxuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICAgICAgaWYgKGlzRHluYW1pYyhzb2xpZGl0eVR5cGVzW2ldLCB0eXBlc1tpXSkpIHtcbiAgICAgICAgICAgIHZhciBlID0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICBkeW5hbWljT2Zmc2V0ICs9IGUubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZVdpdGhPZmZzZXQgPSBmdW5jdGlvbiAodHlwZSwgc29saWRpdHlUeXBlLCBlbmNvZGVkLCBvZmZzZXQpIHtcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTcgKi9cbiAgICAvKiBqc2hpbnQgbWF4ZGVwdGg6IDUgKi9cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZW5jb2RpbmdNb2RlPXtkeW5hbWljOjEsc3RhdGljOjIsb3RoZXI6M307XG5cbiAgICB2YXIgbW9kZT0oc29saWRpdHlUeXBlLmlzRHluYW1pY0FycmF5KHR5cGUpP2VuY29kaW5nTW9kZS5keW5hbWljOihzb2xpZGl0eVR5cGUuaXNTdGF0aWNBcnJheSh0eXBlKT9lbmNvZGluZ01vZGUuc3RhdGljOmVuY29kaW5nTW9kZS5vdGhlcikpO1xuXG4gICAgaWYobW9kZSAhPT0gZW5jb2RpbmdNb2RlLm90aGVyKXtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzb2xpZGl0eVR5cGUubmVzdGVkTmFtZSh0eXBlKTtcbiAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGUuc3RhdGljUGFydExlbmd0aChuZXN0ZWROYW1lKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IChtb2RlID09PSBlbmNvZGluZ01vZGUuZHluYW1pYyA/IGVuY29kZWRbMF0gOiAnJyk7XG5cbiAgICAgICAgaWYgKHNvbGlkaXR5VHlwZS5pc0R5bmFtaWNBcnJheShuZXN0ZWROYW1lKSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzTGVuZ3RoID0gKG1vZGUgPT09IGVuY29kaW5nTW9kZS5keW5hbWljID8gMiA6IDApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgbGVuZ3RoIG9mIHByZXZpb3VzIGl0ZW1cbiAgICAgICAgICAgICAgICBpZihtb2RlID09PSBlbmNvZGluZ01vZGUuZHluYW1pYyl7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTGVuZ3RoICs9ICsoZW5jb2RlZFtpIC0gMV0pWzBdIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYobW9kZSA9PT0gZW5jb2RpbmdNb2RlLnN0YXRpYyl7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTGVuZ3RoICs9ICsoZW5jb2RlZFtpIC0gMV0gfHwgW10pWzBdIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmLmZvcm1hdElucHV0SW50KG9mZnNldCArIGkgKiBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgcHJldmlvdXNMZW5ndGggKiAzMikuZW5jb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuPSAobW9kZSA9PT0gZW5jb2RpbmdNb2RlLmR5bmFtaWMgPyBlbmNvZGVkLmxlbmd0aC0xIDogZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGxlbjsgYysrKSB7XG4gICAgICAgICAgICB2YXIgYWRkaXRpb25hbE9mZnNldCA9IHJlc3VsdCAvIDI7XG4gICAgICAgICAgICBpZihtb2RlID09PSBlbmNvZGluZ01vZGUuZHluYW1pYyl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNlbGYuZW5jb2RlV2l0aE9mZnNldChuZXN0ZWROYW1lLCBzb2xpZGl0eVR5cGUsIGVuY29kZWRbYyArIDFdLCBvZmZzZXQgKyAgYWRkaXRpb25hbE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG1vZGUgPT09IGVuY29kaW5nTW9kZS5zdGF0aWMpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQobmVzdGVkTmFtZSwgc29saWRpdHlUeXBlLCBlbmNvZGVkW2NdLCBvZmZzZXQgKyBhZGRpdGlvbmFsT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGJ5dGVzIHRvIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbSA9IGZ1bmN0aW9uICh0eXBlLCBieXRlcykge1xuICAgIHJldHVybiB0aGlzLmRlY29kZVBhcmFtcyhbdHlwZV0sIGJ5dGVzKVswXTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbVxuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbXMgPSBmdW5jdGlvbiAodHlwZXMsIGJ5dGVzKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZXMgPSB0aGlzLmdldFNvbGlkaXR5VHlwZXModHlwZXMpO1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5nZXRPZmZzZXRzKHR5cGVzLCBzb2xpZGl0eVR5cGVzKTtcblxuICAgIHJldHVybiBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLmRlY29kZShieXRlcywgb2Zmc2V0c1tpbmRleF0sICB0eXBlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9KTtcbn07XG5cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmdldE9mZnNldHMgPSBmdW5jdGlvbiAodHlwZXMsIHNvbGlkaXR5VHlwZXMpIHtcbiAgICB2YXIgbGVuZ3RocyA9ICBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLnN0YXRpY1BhcnRMZW5ndGgodHlwZXNbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3Rocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgLy8gc3VtIHdpdGggbGVuZ3RoIG9mIHByZXZpb3VzIGVsZW1lbnRcbiAgICAgICAgbGVuZ3Roc1tpXSArPSBsZW5ndGhzW2kgLSAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuZ3Rocy5tYXAoZnVuY3Rpb24gKGxlbmd0aCwgaW5kZXgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGxlbmd0aCwgc28gdGhlIGxlbmd0aCBpcyBzdW0gb2YgcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgdmFyIHN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGVzW2luZGV4XS5zdGF0aWNQYXJ0TGVuZ3RoKHR5cGVzW2luZGV4XSk7XG4gICAgICAgIHJldHVybiBsZW5ndGggLSBzdGF0aWNQYXJ0TGVuZ3RoO1xuICAgIH0pO1xufTtcblxuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZ2V0U29saWRpdHlUeXBlcyA9IGZ1bmN0aW9uICh0eXBlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1aXJlVHlwZSh0eXBlKTtcbiAgICB9KTtcbn07XG5cbnZhciBjb2RlciA9IG5ldyBTb2xpZGl0eUNvZGVyKFtcbiAgICBuZXcgU29saWRpdHlUeXBlQWRkcmVzcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVCb29sKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUludCgpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVVSW50KCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVCeXRlcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVTdHJpbmcoKSxcbiAgICBuZXcgU29saWRpdHlUeXBlUmVhbCgpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVVUmVhbCgpXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb2RlcjtcbiIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0RHluYW1pY0J5dGVzO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzO1xufTtcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcztcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15ieXRlcyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXM7XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmb3JtYXR0ZXJzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgYyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbmZpZycpO1xudmFyIFNvbGlkaXR5UGFyYW0gPSByZXF1aXJlKCcuL3BhcmFtJyk7XG5cblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgaW50XG4gKiBJZiB2YWx1ZSBpcyBuZWdhdGl2ZSwgcmV0dXJuIGl0J3MgdHdvJ3MgY29tcGxlbWVudFxuICogSWYgdGhlIHZhbHVlIGlzIGZsb2F0aW5nIHBvaW50LCByb3VuZCBpdCBkb3duXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dEludFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn0gdmFsdWUgdGhhdCBuZWVkcyB0byBiZSBmb3JtYXR0ZWRcbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXRJbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBCaWdOdW1iZXIuY29uZmlnKGMuRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFKTtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbHMucGFkTGVmdCh1dGlscy50b1R3b3NDb21wbGVtZW50KHZhbHVlKS50b1N0cmluZygxNiksIDY0KTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0ocmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRCeXRlc1xuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0Qnl0ZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbHMudG9IZXgodmFsdWUpLnN1YnN0cigyKTtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IoKHJlc3VsdC5sZW5ndGggKyA2MykgLyA2NCk7XG4gICAgcmVzdWx0ID0gdXRpbHMucGFkUmlnaHQocmVzdWx0LCBsICogNjQpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShyZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IGJ5dGVzXG4gKlxuICogQG1ldGhvZCBmb3JtYXREeW5hbWljSW5wdXRCeXRlc1xuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0RHluYW1pY0J5dGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLnRvSGV4KHZhbHVlKS5zdWJzdHIoMik7XG4gICAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGggLyAyO1xuICAgIHZhciBsID0gTWF0aC5mbG9vcigocmVzdWx0Lmxlbmd0aCArIDYzKSAvIDY0KTtcbiAgICByZXN1bHQgPSB1dGlscy5wYWRSaWdodChyZXN1bHQsIGwgKiA2NCk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKGZvcm1hdElucHV0SW50KGxlbmd0aCkudmFsdWUgKyByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2Ygc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0U3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLmZyb21VdGY4KHZhbHVlKS5zdWJzdHIoMik7XG4gICAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGggLyAyO1xuICAgIHZhciBsID0gTWF0aC5mbG9vcigocmVzdWx0Lmxlbmd0aCArIDYzKSAvIDY0KTtcbiAgICByZXN1bHQgPSB1dGlscy5wYWRSaWdodChyZXN1bHQsIGwgKiA2NCk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKGZvcm1hdElucHV0SW50KGxlbmd0aCkudmFsdWUgKyByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgYm9vbFxuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRCb29sXG4gKiBAcGFyYW0ge0Jvb2xlYW59XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0Qm9vbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyArICh2YWx1ZSA/ICAnMScgOiAnMCcpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShyZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgcmVhbFxuICogVmFsdWVzIGFyZSBtdWx0aXBsaWVkIGJ5IDJebSBhbmQgZW5jb2RlZCBhcyBpbnRlZ2Vyc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRSZWFsXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dFJlYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0SW5wdXRJbnQobmV3IEJpZ051bWJlcih2YWx1ZSkudGltZXMobmV3IEJpZ051bWJlcigyKS5wb3coMTI4KSkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpbnB1dCB2YWx1ZSBpcyBuZWdhdGl2ZVxuICpcbiAqIEBtZXRob2Qgc2lnbmVkSXNOZWdhdGl2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGlzIGhleCBmb3JtYXRcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIHNpZ25lZElzTmVnYXRpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKG5ldyBCaWdOdW1iZXIodmFsdWUuc3Vic3RyKDAsIDEpLCAxNikudG9TdHJpbmcoMikuc3Vic3RyKDAsIDEpKSA9PT0gJzEnO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIHRvIGludFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0SW50XG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IHBhcmFtXG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gYmlnIG51bWJlclxuICovXG52YXIgZm9ybWF0T3V0cHV0SW50ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyYW0uc3RhdGljUGFydCgpIHx8IFwiMFwiO1xuXG4gICAgLy8gY2hlY2sgaWYgaXQncyBuZWdhdGl2ZSBudW1iZXJcbiAgICAvLyBpdCBpdCBpcywgcmV0dXJuIHR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAoc2lnbmVkSXNOZWdhdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDE2KS5taW51cyhuZXcgQmlnTnVtYmVyKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpKS5taW51cygxKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDE2KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byB1aW50XG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRVSW50XG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7QmlnTnVtZWJlcn0gcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIHVpbnRcbiAqL1xudmFyIGZvcm1hdE91dHB1dFVJbnQgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJhbS5zdGF0aWNQYXJ0KCkgfHwgXCIwXCI7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDE2KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byByZWFsXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRSZWFsXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBpbnB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gcmVhbFxuICovXG52YXIgZm9ybWF0T3V0cHV0UmVhbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBmb3JtYXRPdXRwdXRJbnQocGFyYW0pLmRpdmlkZWRCeShuZXcgQmlnTnVtYmVyKDIpLnBvdygxMjgpKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byB1cmVhbFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0VVJlYWxcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX1cbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGlucHV0IGJ5dGVzIGZvcm1hdHRlZCB0byB1cmVhbFxuICovXG52YXIgZm9ybWF0T3V0cHV0VVJlYWwgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gZm9ybWF0T3V0cHV0VUludChwYXJhbSkuZGl2aWRlZEJ5KG5ldyBCaWdOdW1iZXIoMikucG93KDEyOCkpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IGJvb2xcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dEJvb2xcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX1cbiAqIEByZXR1cm5zIHtCb29sZWFufSByaWdodC1hbGlnbmVkIGlucHV0IGJ5dGVzIGZvcm1hdHRlZCB0byBib29sXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRCb29sID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLnN0YXRpY1BhcnQoKSA9PT0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IGJ5dGVzXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRCeXRlc1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBsZWZ0LWFsaWduZWQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdHlwZSBuYW1lXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggc3RyaW5nXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRCeXRlcyA9IGZ1bmN0aW9uIChwYXJhbSwgbmFtZSkge1xuICAgIHZhciBtYXRjaGVzID0gbmFtZS5tYXRjaCgvXmJ5dGVzKFswLTldKikvKTtcbiAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoZXNbMV0pO1xuICAgIHJldHVybiAnMHgnICsgcGFyYW0uc3RhdGljUGFydCgpLnNsaWNlKDAsIDIgKiBzaXplKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IGxlZnQtYWxpZ25lZCBoZXggcmVwcmVzZW50YXRpb24gb2Ygc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggc3RyaW5nXG4gKi9cbnZhciBmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gKG5ldyBCaWdOdW1iZXIocGFyYW0uZHluYW1pY1BhcnQoKS5zbGljZSgwLCA2NCksIDE2KSkudG9OdW1iZXIoKSAqIDI7XG4gICAgcmV0dXJuICcweCcgKyBwYXJhbS5keW5hbWljUGFydCgpLnN1YnN0cig2NCwgbGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFN0cmluZ1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBsZWZ0LWFsaWduZWQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRTdHJpbmcgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gKG5ldyBCaWdOdW1iZXIocGFyYW0uZHluYW1pY1BhcnQoKS5zbGljZSgwLCA2NCksIDE2KSkudG9OdW1iZXIoKSAqIDI7XG4gICAgcmV0dXJuIHV0aWxzLnRvVXRmOChwYXJhbS5keW5hbWljUGFydCgpLnN1YnN0cig2NCwgbGVuZ3RoKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0QWRkcmVzc1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSByaWdodC1hbGlnbmVkIGlucHV0IGJ5dGVzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhZGRyZXNzXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRBZGRyZXNzID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyYW0uc3RhdGljUGFydCgpO1xuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSA0MCwgdmFsdWUubGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdElucHV0SW50OiBmb3JtYXRJbnB1dEludCxcbiAgICBmb3JtYXRJbnB1dEJ5dGVzOiBmb3JtYXRJbnB1dEJ5dGVzLFxuICAgIGZvcm1hdElucHV0RHluYW1pY0J5dGVzOiBmb3JtYXRJbnB1dER5bmFtaWNCeXRlcyxcbiAgICBmb3JtYXRJbnB1dFN0cmluZzogZm9ybWF0SW5wdXRTdHJpbmcsXG4gICAgZm9ybWF0SW5wdXRCb29sOiBmb3JtYXRJbnB1dEJvb2wsXG4gICAgZm9ybWF0SW5wdXRSZWFsOiBmb3JtYXRJbnB1dFJlYWwsXG4gICAgZm9ybWF0T3V0cHV0SW50OiBmb3JtYXRPdXRwdXRJbnQsXG4gICAgZm9ybWF0T3V0cHV0VUludDogZm9ybWF0T3V0cHV0VUludCxcbiAgICBmb3JtYXRPdXRwdXRSZWFsOiBmb3JtYXRPdXRwdXRSZWFsLFxuICAgIGZvcm1hdE91dHB1dFVSZWFsOiBmb3JtYXRPdXRwdXRVUmVhbCxcbiAgICBmb3JtYXRPdXRwdXRCb29sOiBmb3JtYXRPdXRwdXRCb29sLFxuICAgIGZvcm1hdE91dHB1dEJ5dGVzOiBmb3JtYXRPdXRwdXRCeXRlcyxcbiAgICBmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXM6IGZvcm1hdE91dHB1dER5bmFtaWNCeXRlcyxcbiAgICBmb3JtYXRPdXRwdXRTdHJpbmc6IGZvcm1hdE91dHB1dFN0cmluZyxcbiAgICBmb3JtYXRPdXRwdXRBZGRyZXNzOiBmb3JtYXRPdXRwdXRBZGRyZXNzXG59O1xuIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVJbnQgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgaW50IHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBpbnRcbiAqIGludFtdXG4gKiBpbnRbNF1cbiAqIGludFtdW11cbiAqIGludFszXVtdXG4gKiBpbnRbXVs2XVtdLCAuLi5cbiAqIGludDMyXG4gKiBpbnQ2NFtdXG4gKiBpbnQ4WzRdXG4gKiBpbnQyNTZbXVtdXG4gKiBpbnRbM11bXVxuICogaW50NjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUludCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRJbnQ7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRJbnQ7XG59O1xuXG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlSW50O1xuXG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXmludChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVJbnQ7XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgcGFyYW0uanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVBhcmFtIG9iamVjdCBwcm90b3R5cGUuXG4gKiBTaG91bGQgYmUgdXNlZCB3aGVuIGVuY29kaW5nLCBkZWNvZGluZyBzb2xpZGl0eSBieXRlc1xuICovXG52YXIgU29saWRpdHlQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0OyAvLyBvZmZzZXQgaW4gYnl0ZXNcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGxlbmd0aCBvZiBwYXJhbXMncyBkeW5hbWljIHBhcnRcbiAqIFxuICogQG1ldGhvZCBkeW5hbWljUGFydExlbmd0aFxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGR5bmFtaWMgcGFydCAoaW4gYnl0ZXMpXG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmR5bmFtaWNQYXJ0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmR5bmFtaWNQYXJ0KCkubGVuZ3RoIC8gMjtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGNvcHkgb2Ygc29saWRpdHkgcGFyYW0gd2l0aCBkaWZmZXJlbnQgb2Zmc2V0XG4gKlxuICogQG1ldGhvZCB3aXRoT2Zmc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IGxlbmd0aCBpbiBieXRlc1xuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19IG5ldyBzb2xpZGl0eSBwYXJhbSB3aXRoIGFwcGxpZWQgb2Zmc2V0XG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLndpdGhPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKHRoaXMudmFsdWUsIG9mZnNldCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNvbWJpbmUgc29saWRpdHkgcGFyYW1zIHRvZ2V0aGVyXG4gKiBlZy4gd2hlbiBhcHBlbmRpbmcgYW4gYXJyYXlcbiAqXG4gKiBAbWV0aG9kIGNvbWJpbmVcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gcGFyYW0gd2l0aCB3aGljaCB3ZSBzaG91bGQgY29tYmluZVxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSByZXN1bHQgb2YgY29tYmluYXRpb25cbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbSh0aGlzLnZhbHVlICsgcGFyYW0udmFsdWUpOyBcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBwYXJhbSBoYXMgZHluYW1pYyBzaXplLlxuICogSWYgaXQgaGFzLCBpdCByZXR1cm5zIHRydWUsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNEeW5hbWljXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuaXNEeW5hbWljID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIHRyYW5zZm9ybSBvZmZzZXQgdG8gYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIG9mZnNldEFzQnl0ZXNcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIG9mZnNldFxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5vZmZzZXRBc0J5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0R5bmFtaWMoKSA/ICcnIDogdXRpbHMucGFkTGVmdCh1dGlscy50b1R3b3NDb21wbGVtZW50KHRoaXMub2Zmc2V0KS50b1N0cmluZygxNiksIDY0KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgc3RhdGljIHBhcnQgb2YgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIHN0YXRpY1BhcnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IG9mZnNldCBpZiBpdCBpcyBhIGR5bmFtaWMgcGFyYW0sIG90aGVyd2lzZSB2YWx1ZVxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5zdGF0aWNQYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTsgXG4gICAgfSBcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRBc0J5dGVzKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGR5bmFtaWMgcGFydCBvZiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZHluYW1pY1BhcnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJldHVybnMgYSB2YWx1ZSBpZiBpdCBpcyBhIGR5bmFtaWMgcGFyYW0sIG90aGVyd2lzZSBlbXB0eSBzdHJpbmdcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuZHluYW1pY1BhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEeW5hbWljKCkgPyB0aGlzLnZhbHVlIDogJyc7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZW5jb2RlIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWNQYXJ0KCkgKyB0aGlzLmR5bmFtaWNQYXJ0KCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZW5jb2RlIGFycmF5IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlTGlzdFxuICogQHBhcmFtIHtBcnJheVtTb2xpZGl0eVBhcmFtXX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5Tb2xpZGl0eVBhcmFtLmVuY29kZUxpc3QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgXG4gICAgLy8gdXBkYXRpbmcgb2Zmc2V0c1xuICAgIHZhciB0b3RhbE9mZnNldCA9IHBhcmFtcy5sZW5ndGggKiAzMjtcbiAgICB2YXIgb2Zmc2V0UGFyYW1zID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgaWYgKCFwYXJhbS5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSB0b3RhbE9mZnNldDtcbiAgICAgICAgdG90YWxPZmZzZXQgKz0gcGFyYW0uZHluYW1pY1BhcnRMZW5ndGgoKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtLndpdGhPZmZzZXQob2Zmc2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGVuY29kZSBldmVyeXRoaW5nIVxuICAgIHJldHVybiBvZmZzZXRQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhcmFtKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBwYXJhbS5keW5hbWljUGFydCgpO1xuICAgIH0sIG9mZnNldFBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHBhcmFtLnN0YXRpY1BhcnQoKTtcbiAgICB9LCAnJykpO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlQYXJhbTtcblxuIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVSZWFsIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIHJlYWwgdHlwZVxuICogSXQgbWF0Y2hlczpcbiAqIHJlYWxcbiAqIHJlYWxbXVxuICogcmVhbFs0XVxuICogcmVhbFtdW11cbiAqIHJlYWxbM11bXVxuICogcmVhbFtdWzZdW10sIC4uLlxuICogcmVhbDMyXG4gKiByZWFsNjRbXVxuICogcmVhbDhbNF1cbiAqIHJlYWwyNTZbXVtdXG4gKiByZWFsWzNdW11cbiAqIHJlYWw2NFtdWzZdW10sIC4uLlxuICovXG52YXIgU29saWRpdHlUeXBlUmVhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRSZWFsO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0UmVhbDtcbn07XG5cblNvbGlkaXR5VHlwZVJlYWwucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVSZWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZVJlYWw7XG5cblNvbGlkaXR5VHlwZVJlYWwucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvcmVhbChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSk/Lyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVJlYWw7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG52YXIgU29saWRpdHlUeXBlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFN0cmluZztcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFN0cmluZztcbn07XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVTdHJpbmc7XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9ec3RyaW5nKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5Tb2xpZGl0eVR5cGVTdHJpbmcucHJvdG90eXBlLmlzRHluYW1pY1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVN0cmluZztcbiIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlQYXJhbSA9IHJlcXVpcmUoJy4vcGFyYW0nKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGUgcHJvdG90eXBlIGlzIHVzZWQgdG8gZW5jb2RlL2RlY29kZSBzb2xpZGl0eSBwYXJhbXMgb2YgY2VydGFpbiB0eXBlXG4gKi9cbnZhciBTb2xpZGl0eVR5cGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBjb25maWcuaW5wdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gY29uZmlnLm91dHB1dEZvcm1hdHRlcjtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgU29saWRpdHlUeXBlIGRvIG1hdGNoIGdpdmVuIG5hbWVcbiAqXG4gKiBAbWV0aG9kIGlzVHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgdHlwZSBtYXRjaCB0aGlzIFNvbGlkaXR5VHlwZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBcInRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycndyaXR0ZW4gZm9yIHR5cGUgXCIgKyBuYW1lO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hhdCBpcyB0aGUgbGVuZ3RoIG9mIHN0YXRpYyBwYXJ0IGluIGdpdmVuIHR5cGVcbiAqXG4gKiBAbWV0aG9kIHN0YXRpY1BhcnRMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBzdGF0aWMgcGFydCBpbiBieXRlc1xuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLnN0YXRpY1BhcnRMZW5ndGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIElmIG5hbWUgaXNuJ3QgYW4gYXJyYXkgdGhlbiB0cmVhdCBpdCBsaWtlIGEgc2luZ2xlIGVsZW1lbnQgYXJyYXkuXG4gICAgcmV0dXJuICh0aGlzLm5lc3RlZFR5cGVzKG5hbWUpIHx8IFsnWzFdJ10pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBsZW5ndGggb2YgdGhlIG5lc3RlZCBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHR5cGUuc2xpY2UoMSwgLTEpLCAxMCkgfHwgMTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyAqIGN1cnJlbnQ7XG4gICAgICAgIC8vIGFsbCBiYXNpYyB0eXBlcyBhcmUgMzIgYnl0ZXMgbG9uZ1xuICAgICAgICB9LCAzMik7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0eXBlIGlzIGR5bmFtaWMgYXJyYXlcbiAqIGVnOlxuICogXCJ0eXBlW11cIiA9PiB0cnVlXG4gKiBcInR5cGVbNF1cIiA9PiBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNEeW5hbWljQXJyYXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIHRoZSB0eXBlIGlzIGR5bmFtaWMgYXJyYXlcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5pc0R5bmFtaWNBcnJheSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG5lc3RlZFR5cGVzID0gdGhpcy5uZXN0ZWRUeXBlcyhuYW1lKTtcbiAgICByZXR1cm4gISFuZXN0ZWRUeXBlcyAmJiAhbmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1swLTldezEsfS9nKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHR5cGUgaXMgc3RhdGljIGFycmF5XG4gKiBlZzpcbiAqIFwidHlwZVtdXCIgPT4gZmFsc2VcbiAqIFwidHlwZVs0XVwiID0+IHRydWVcbiAqXG4gKiBAbWV0aG9kIGlzU3RhdGljQXJyYXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIHRoZSB0eXBlIGlzIHN0YXRpYyBhcnJheVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmlzU3RhdGljQXJyYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBuZXN0ZWRUeXBlcyA9IHRoaXMubmVzdGVkVHlwZXMobmFtZSk7XG4gICAgcmV0dXJuICEhbmVzdGVkVHlwZXMgJiYgISFuZXN0ZWRUeXBlc1tuZXN0ZWRUeXBlcy5sZW5ndGggLSAxXS5tYXRjaCgvWzAtOV17MSx9L2cpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIGxlbmd0aCBvZiBzdGF0aWMgYXJyYXlcbiAqIGVnLlxuICogXCJpbnRbMzJdXCIgPT4gMzJcbiAqIFwiaW50MjU2WzE0XVwiID0+IDE0XG4gKiBcImludFsyXVszXVwiID0+IDNcbiAqIFwiaW50XCIgPT4gMVxuICogXCJpbnRbMV1cIiA9PiAxXG4gKiBcImludFtdXCIgPT4gMVxuICpcbiAqIEBtZXRob2Qgc3RhdGljQXJyYXlMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHN0YXRpYyBhcnJheSBsZW5ndGhcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5zdGF0aWNBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG5lc3RlZFR5cGVzID0gdGhpcy5uZXN0ZWRUeXBlcyhuYW1lKTtcbiAgICBpZiAobmVzdGVkVHlwZXMpIHtcbiAgICAgICByZXR1cm4gcGFyc2VJbnQobmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1swLTldezEsfS9nKSB8fCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gbmVzdGVkIHR5cGVcbiAqIGVnLlxuICogXCJpbnRbMzJdXCIgPT4gXCJpbnRcIlxuICogXCJpbnQyNTZbMTRdXCIgPT4gXCJpbnQyNTZcIlxuICogXCJpbnRbMl1bM11cIiA9PiBcImludFsyXVwiXG4gKiBcImludFwiID0+IFwiaW50XCJcbiAqIFwiaW50W11cIiA9PiBcImludFwiXG4gKlxuICogQG1ldGhvZCBuZXN0ZWROYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBuZXN0ZWQgbmFtZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLm5lc3RlZE5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIHJlbW92ZSBsYXN0IFtdIGluIG5hbWVcbiAgICB2YXIgbmVzdGVkVHlwZXMgPSB0aGlzLm5lc3RlZFR5cGVzKG5hbWUpO1xuICAgIGlmICghbmVzdGVkVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gbmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiB0cnVlIGlmIHR5cGUgaGFzIGR5bmFtaWMgc2l6ZSBieSBkZWZhdWx0XG4gKiBzdWNoIHR5cGVzIGFyZSBcInN0cmluZ1wiLCBcImJ5dGVzXCJcbiAqXG4gKiBAbWV0aG9kIGlzRHluYW1pY1R5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIGlzIGR5bmFtaWMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmlzRHluYW1pY1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIGFycmF5IG9mIG5lc3RlZCB0eXBlc1xuICogZWcuXG4gKiBcImludFsyXVszXVtdXCIgPT4gW1wiWzJdXCIsIFwiWzNdXCIsIFwiW11cIl1cbiAqIFwiaW50W10gPT4gW1wiW11cIl1cbiAqIFwiaW50XCIgPT4gbnVsbFxuICpcbiAqIEBtZXRob2QgbmVzdGVkVHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgbmVzdGVkIHR5cGVzXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUubmVzdGVkVHlwZXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIHJldHVybiBsaXN0IG9mIHN0cmluZ3MgZWcuIFwiW11cIiwgXCJbM11cIiwgXCJbXVwiLCBcIlsyXVwiXG4gICAgcmV0dXJuIG5hbWUubWF0Y2goLyhcXFtbMC05XSpcXF0pL2cpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgdGhlIHZhbHVlXG4gKlxuICogQG1ldGhvZCBlbmNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCB2YWx1ZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5pc0R5bmFtaWNBcnJheShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGludFxuICAgICAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzZWxmLm5lc3RlZE5hbWUobmFtZSk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYuZm9ybWF0SW5wdXRJbnQobGVuZ3RoKS5lbmNvZGUoKSk7XG5cbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLmVuY29kZSh2LCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcblxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRpY0FycmF5KG5hbWUpKSB7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gc2VsZi5zdGF0aWNBcnJheUxlbmd0aChuYW1lKTsgICAgICAgICAgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNlbGYubmVzdGVkTmFtZShuYW1lKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuZW5jb2RlKHZhbHVlW2ldLCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faW5wdXRGb3JtYXR0ZXIodmFsdWUsIG5hbWUpLmVuY29kZSgpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgdmFsdWUgZnJvbSBieXRlc1xuICpcbiAqIEBtZXRob2QgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gYnl0ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgaW4gYnl0ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHR5cGUgbmFtZVxuICogQHJldHVybnMge09iamVjdH0gZGVjb2RlZCB2YWx1ZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChieXRlcywgb2Zmc2V0LCBuYW1lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNEeW5hbWljQXJyYXkobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheU9mZnNldCA9IHBhcnNlSW50KCcweCcgKyBieXRlcy5zdWJzdHIob2Zmc2V0ICogMiwgNjQpKTsgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKGFycmF5T2Zmc2V0ICogMiwgNjQpKTsgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgYXJyYXlTdGFydCA9IGFycmF5T2Zmc2V0ICsgMzI7IC8vIGFycmF5IHN0YXJ0cyBhZnRlciBsZW5ndGg7IC8vIGluIGJ5dGVzXG5cbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc2VsZi5uZXN0ZWROYW1lKG5hbWUpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzZWxmLnN0YXRpY1BhcnRMZW5ndGgobmVzdGVkTmFtZSk7ICAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gTWF0aC5mbG9vcigobmVzdGVkU3RhdGljUGFydExlbmd0aCArIDMxKSAvIDMyKSAqIDMyO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAqIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoOyBpICs9IHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5kZWNvZGUoYnl0ZXMsIGFycmF5U3RhcnQgKyBpLCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdGF0aWNBcnJheShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHNlbGYuc3RhdGljQXJyYXlMZW5ndGgobmFtZSk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGludFxuICAgICAgICAgICAgdmFyIGFycmF5U3RhcnQgPSBvZmZzZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGJ5dGVzXG5cbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc2VsZi5uZXN0ZWROYW1lKG5hbWUpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzZWxmLnN0YXRpY1BhcnRMZW5ndGgobmVzdGVkTmFtZSk7IC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBNYXRoLmZsb29yKChuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgMzEpIC8gMzIpICogMzI7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICogcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGg7IGkgKz0gcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLmRlY29kZShieXRlcywgYXJyYXlTdGFydCArIGksIG5lc3RlZE5hbWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNEeW5hbWljVHlwZShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGR5bmFtaWNPZmZzZXQgPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKG9mZnNldCAqIDIsIDY0KSk7ICAgICAgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKGR5bmFtaWNPZmZzZXQgKiAyLCA2NCkpOyAgICAgIC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgcm91bmRlZExlbmd0aCA9IE1hdGguZmxvb3IoKGxlbmd0aCArIDMxKSAvIDMyKTsgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IG5ldyBTb2xpZGl0eVBhcmFtKGJ5dGVzLnN1YnN0cihkeW5hbWljT2Zmc2V0ICogMiwgKCAxICsgcm91bmRlZExlbmd0aCkgKiA2NCksIDApO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX291dHB1dEZvcm1hdHRlcihwYXJhbSwgbmFtZSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RhdGljUGFydExlbmd0aChuYW1lKTtcbiAgICB2YXIgcGFyYW0gPSBuZXcgU29saWRpdHlQYXJhbShieXRlcy5zdWJzdHIob2Zmc2V0ICogMiwgbGVuZ3RoICogMikpO1xuICAgIHJldHVybiB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIocGFyYW0sIG5hbWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGU7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVVJbnQgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgdWludCB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogdWludFxuICogdWludFtdXG4gKiB1aW50WzRdXG4gKiB1aW50W11bXVxuICogdWludFszXVtdXG4gKiB1aW50W11bNl1bXSwgLi4uXG4gKiB1aW50MzJcbiAqIHVpbnQ2NFtdXG4gKiB1aW50OFs0XVxuICogdWludDI1NltdW11cbiAqIHVpbnRbM11bXVxuICogdWludDY0W11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVVSW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEludDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFVJbnQ7XG59O1xuXG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlVUludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVVSW50O1xuXG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL151aW50KFswLTldKik/KFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVVJbnQ7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVVSZWFsIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIHVyZWFsIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiB1cmVhbFxuICogdXJlYWxbXVxuICogdXJlYWxbNF1cbiAqIHVyZWFsW11bXVxuICogdXJlYWxbM11bXVxuICogdXJlYWxbXVs2XVtdLCAuLi5cbiAqIHVyZWFsMzJcbiAqIHVyZWFsNjRbXVxuICogdXJlYWw4WzRdXG4gKiB1cmVhbDI1NltdW11cbiAqIHVyZWFsWzNdW11cbiAqIHVyZWFsNjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVVSZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFJlYWw7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRVUmVhbDtcbn07XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlVVJlYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlVVJlYWw7XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL151cmVhbChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVVUmVhbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZ28gZW52IGRvZXNuJ3QgaGF2ZSBhbmQgbmVlZCBYTUxIdHRwUmVxdWVzdFxuaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0ge307XG59IGVsc2Uge1xuICAgIGV4cG9ydHMuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgY29uZmlnLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuLyoqXG4gKiBVdGlsc1xuICogXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICogXG4gKiBAY2xhc3MgW3V0aWxzXSBjb25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxuLy8vIHJlcXVpcmVkIHRvIGRlZmluZSBFVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREVcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxudmFyIEVUSF9VTklUUyA9IFtcbiAgICAnd2VpJyxcbiAgICAna3dlaScsXG4gICAgJ013ZWknLFxuICAgICdHd2VpJyxcbiAgICAnc3phYm8nLFxuICAgICdmaW5uZXknLFxuICAgICdmZW10b2V0aGVyJyxcbiAgICAncGljb2V0aGVyJyxcbiAgICAnbmFub2V0aGVyJyxcbiAgICAnbWljcm9ldGhlcicsXG4gICAgJ21pbGxpZXRoZXInLFxuICAgICduYW5vJyxcbiAgICAnbWljcm8nLFxuICAgICdtaWxsaScsXG4gICAgJ2V0aGVyJyxcbiAgICAnZ3JhbmQnLFxuICAgICdNZXRoZXInLFxuICAgICdHZXRoZXInLFxuICAgICdUZXRoZXInLFxuICAgICdQZXRoZXInLFxuICAgICdFZXRoZXInLFxuICAgICdaZXRoZXInLFxuICAgICdZZXRoZXInLFxuICAgICdOZXRoZXInLFxuICAgICdEZXRoZXInLFxuICAgICdWZXRoZXInLFxuICAgICdVZXRoZXInXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFVEhfUEFERElORzogMzIsXG4gICAgRVRIX1NJR05BVFVSRV9MRU5HVEg6IDQsXG4gICAgRVRIX1VOSVRTOiBFVEhfVU5JVFMsXG4gICAgRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFOiB7IFJPVU5ESU5HX01PREU6IEJpZ051bWJlci5ST1VORF9ET1dOIH0sXG4gICAgRVRIX1BPTExJTkdfVElNRU9VVDogMTAwMC8yLFxuICAgIGRlZmF1bHRCbG9jazogJ2xhdGVzdCcsXG4gICAgZGVmYXVsdEFjY291bnQ6IHVuZGVmaW5lZFxufTtcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIHNoYTMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIENyeXB0b0pTID0gcmVxdWlyZSgnY3J5cHRvLWpzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJ2NyeXB0by1qcy9zaGEzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgJiYgdmFsdWUuc3Vic3RyKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigyKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGEzKHZhbHVlLCB7XG4gICAgICAgIG91dHB1dExlbmd0aDogMjU2XG4gICAgfSkudG9TdHJpbmcoKTtcbn07XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIHV0aWxzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbi8qKlxuICogVXRpbHNcbiAqXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICpcbiAqIEBjbGFzcyBbdXRpbHNdIHV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi9zaGEzLmpzJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxudmFyIHVuaXRNYXAgPSB7XG4gICAgJ25vZXRoZXInOiAgICAgICcwJyxcbiAgICAnd2VpJzogICAgICAgICAgJzEnLFxuICAgICdrd2VpJzogICAgICAgICAnMTAwMCcsXG4gICAgJ0t3ZWknOiAgICAgICAgICcxMDAwJyxcbiAgICAnYmFiYmFnZSc6ICAgICAgJzEwMDAnLFxuICAgICdmZW10b2V0aGVyJzogICAnMTAwMCcsXG4gICAgJ213ZWknOiAgICAgICAgICcxMDAwMDAwJyxcbiAgICAnTXdlaSc6ICAgICAgICAgJzEwMDAwMDAnLFxuICAgICdsb3ZlbGFjZSc6ICAgICAnMTAwMDAwMCcsXG4gICAgJ3BpY29ldGhlcic6ICAgICcxMDAwMDAwJyxcbiAgICAnZ3dlaSc6ICAgICAgICAgJzEwMDAwMDAwMDAnLFxuICAgICdHd2VpJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3NoYW5ub24nOiAgICAgICcxMDAwMDAwMDAwJyxcbiAgICAnbmFub2V0aGVyJzogICAgJzEwMDAwMDAwMDAnLFxuICAgICduYW5vJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3N6YWJvJzogICAgICAgICcxMDAwMDAwMDAwMDAwJyxcbiAgICAnbWljcm9ldGhlcic6ICAgJzEwMDAwMDAwMDAwMDAnLFxuICAgICdtaWNybyc6ICAgICAgICAnMTAwMDAwMDAwMDAwMCcsXG4gICAgJ2Zpbm5leSc6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWlsbGlldGhlcic6ICAgJzEwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdtaWxsaSc6ICAgICAgICAnMTAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2V0aGVyJzogICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAna2V0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdncmFuZCc6ICAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ21ldGhlcic6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnZ2V0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICd0ZXRoZXInOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcGFkTGVmdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFyYWN0ZXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIHBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGFycywgc2lnbikge1xuICAgIHJldHVybiBuZXcgQXJyYXkoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSkuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSArIHN0cmluZztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcGFkUmlnaHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gYmUgcGFkZGVkXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhcmFjdGVycyB0aGF0IHJlc3VsdCBzdHJpbmcgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduLCBieSBkZWZhdWx0IDBcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJpZ2h0IGFsaWduZWQgc3RyaW5nXG4gKi9cbnZhciBwYWRSaWdodCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgcmV0dXJuIHN0cmluZyArIChuZXcgQXJyYXkoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSkuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgdG9VdGY4ID0gZnVuY3Rpb24oaGV4KSB7XG4vLyBGaW5kIHRlcm1pbmF0aW9uXG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwLCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICBpID0gMjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsOyBpKz0yKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmOC5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xudmFyIHRvQXNjaWkgPSBmdW5jdGlvbihoZXgpIHtcbi8vIEZpbmQgdGVybWluYXRpb25cbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDAsIGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgIGkgPSAyO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkrPTIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd1plcm8gdG8gY29udmVydCBjb2RlIHBvaW50IHplcm8gdG8gMDAgaW5zdGVhZCBvZiBlbmQgb2Ygc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbnZhciBmcm9tVXRmOCA9IGZ1bmN0aW9uKHN0ciwgYWxsb3daZXJvKSB7XG4gICAgc3RyID0gdXRmOC5lbmNvZGUoc3RyKTtcbiAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3daZXJvKSB7XG4gICAgICAgICAgICAgICAgaGV4ICs9ICcwMCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgZnJvbUFzY2lpID0gZnVuY3Rpb24oc3RyLCBudW0pIHtcbiAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCIweFwiICsgaGV4LnBhZEVuZChudW0sJzAnKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZSBmcm9tIGpzb24gYWJpXG4gKlxuICogQG1ldGhvZCB0cmFuc2Zvcm1Ub0Z1bGxOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbi1hYmlcbiAqIEByZXR1cm4ge1N0cmluZ30gZnVsbCBmbmN0aW9uL2V2ZW50IG5hbWVcbiAqL1xudmFyIHRyYW5zZm9ybVRvRnVsbE5hbWUgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIGlmIChqc29uLm5hbWUuaW5kZXhPZignKCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ganNvbi5uYW1lO1xuICAgIH1cblxuICAgIHZhciB0eXBlTmFtZSA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gaS50eXBlOyB9KS5qb2luKCk7XG4gICAgcmV0dXJuIGpzb24ubmFtZSArICcoJyArIHR5cGVOYW1lICsgJyknO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBkaXNwbGF5IG5hbWUgb2YgY29udHJhY3QgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3REaXNwbGF5TmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgZnVuY3Rpb24vZXZlbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGRpc3BsYXkgbmFtZSBmb3IgZnVuY3Rpb24vZXZlbnQgZWcuIG11bHRpcGx5KHVpbnQyNTYpIC0+IG11bHRpcGx5XG4gKi9cbnZhciBleHRyYWN0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdEJyYWNrZXQgPSBuYW1lLmluZGV4T2YoJygnKTtcbiAgICB2YXIgZW5kQnJhY2tldCA9IG5hbWUuaW5kZXhPZignKScpO1xuICAgIHJldHVybiAoc3RCcmFja2V0ICE9PSAtMSAmJiBlbmRCcmFja2V0ICE9PSAtMSkgPyBuYW1lLnN1YnN0cigwLCBzdEJyYWNrZXQpIDogbmFtZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdHlwZSBuYW1lIG9mIGNvbnRyYWN0IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBleHRyYWN0VHlwZU5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIGZ1bmN0aW9uL2V2ZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0eXBlIG5hbWUgZm9yIGZ1bmN0aW9uL2V2ZW50IGVnLiBtdWx0aXBseSh1aW50MjU2KSAtPiB1aW50MjU2XG4gKi9cbnZhciBleHRyYWN0VHlwZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdEJyYWNrZXQgPSBuYW1lLmluZGV4T2YoJygnKTtcbiAgICB2YXIgZW5kQnJhY2tldCA9IG5hbWUuaW5kZXhPZignKScpO1xuICAgIHJldHVybiAoc3RCcmFja2V0ICE9PSAtMSAmJiBlbmRCcmFja2V0ICE9PSAtMSkgPyBuYW1lLnN1YnN0cihzdEJyYWNrZXQgKyAxLCBlbmRCcmFja2V0IC0gc3RCcmFja2V0IC0gMSkucmVwbGFjZSgnICcsICcnKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBpbiBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIHRvRGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvRGVjaW1hbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0b0JpZ051bWJlcih2YWx1ZSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGZyb21EZWNpbWFsXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgZnJvbURlY2ltYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgbnVtYmVyID0gdG9CaWdOdW1iZXIodmFsdWUpO1xuICAgIHZhciByZXN1bHQgPSBudW1iZXIudG9TdHJpbmcoMTYpO1xuXG4gICAgcmV0dXJuIG51bWJlci5sZXNzVGhhbigwKSA/ICctMHgnICsgcmVzdWx0LnN1YnN0cigxKSA6ICcweCcgKyByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEF1dG8gY29udmVydHMgYW55IGdpdmVuIHZhbHVlIGludG8gaXQncyBoZXggcmVwcmVzZW50YXRpb24uXG4gKlxuICogQW5kIGV2ZW4gc3RyaW5naWZ5cyBvYmplY3RzIGJlZm9yZS5cbiAqXG4gKiBAbWV0aG9kIHRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfE9iamVjdH1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvSGV4ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDggKi9cblxuICAgIGlmIChpc0Jvb2xlYW4odmFsKSlcbiAgICAgICAgcmV0dXJuIGZyb21EZWNpbWFsKCt2YWwpO1xuXG4gICAgaWYgKGlzQmlnTnVtYmVyKHZhbCkpXG4gICAgICAgIHJldHVybiBmcm9tRGVjaW1hbCh2YWwpO1xuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gZnJvbVV0ZjgoSlNPTi5zdHJpbmdpZnkodmFsKSk7XG5cbiAgICAvLyBpZiBpdHMgYSBuZWdhdGl2ZSBudW1iZXIsIHBhc3MgaXQgdGhyb3VnaCBmcm9tRGVjaW1hbFxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICAgIGlmICh2YWwuaW5kZXhPZignLTB4JykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcbiAgICAgICAgZWxzZSBpZih2YWwuaW5kZXhPZignMHgnKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21VdGY4KHZhbCwxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZSBvZiB1bml0IGluIFdlaVxuICpcbiAqIEBtZXRob2QgZ2V0VmFsdWVPZlVuaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHZhbHVlIG9mIHRoZSB1bml0IChpbiBXZWkpXG4gKiBAdGhyb3dzIGVycm9yIGlmIHRoZSB1bml0IGlzIG5vdCBjb3JyZWN0OndcbiAqL1xudmFyIGdldFZhbHVlT2ZVbml0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB1bml0ID0gdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6ICdldGhlcic7XG4gICAgdmFyIHVuaXRWYWx1ZSA9IHVuaXRNYXBbdW5pdF07XG4gICAgaWYgKHVuaXRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IGRvZXNuXFwndCBleGlzdHMsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzJyArIEpTT04uc3RyaW5naWZ5KHVuaXRNYXAsIG51bGwsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodW5pdFZhbHVlLCAxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIHdlaSBhbmQgY29udmVydHMgaXQgdG8gYW55IG90aGVyIGV0aGVyIHVuaXQuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIGZyb21XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9IFdoZW4gZ2l2ZW4gYSBCaWdOdW1iZXIgb2JqZWN0IGl0IHJldHVybnMgb25lIGFzIHdlbGwsIG90aGVyd2lzZSBhIG51bWJlclxuKi9cbnZhciBmcm9tV2VpID0gZnVuY3Rpb24obnVtYmVyLCB1bml0KSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gdG9CaWdOdW1iZXIobnVtYmVyKS5kaXZpZGVkQnkoZ2V0VmFsdWVPZlVuaXQodW5pdCkpO1xuXG4gICAgcmV0dXJuIGlzQmlnTnVtYmVyKG51bWJlcikgPyByZXR1cm5WYWx1ZSA6IHJldHVyblZhbHVlLnRvU3RyaW5nKDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYSB1bml0IGFuZCBjb252ZXJ0cyBpdCB0byB3ZWkuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIHRvV2VpXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8QmlnTnVtYmVyfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCBmcm9tLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSBXaGVuIGdpdmVuIGEgQmlnTnVtYmVyIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiovXG52YXIgdG9XZWkgPSBmdW5jdGlvbihudW1iZXIsIHVuaXQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSB0b0JpZ051bWJlcihudW1iZXIpLnRpbWVzKGdldFZhbHVlT2ZVbml0KHVuaXQpKTtcblxuICAgIHJldHVybiBpc0JpZ051bWJlcihudW1iZXIpID8gcmV0dXJuVmFsdWUgOiByZXR1cm5WYWx1ZS50b1N0cmluZygxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGlucHV0IGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gYW4gYmlnbnVtYmVyXG4gKlxuICogQG1ldGhvZCB0b0JpZ051bWJlclxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJpZ051bWJlcn0gYSBudW1iZXIsIHN0cmluZywgSEVYIHN0cmluZyBvciBCaWdOdW1iZXJcbiAqIEByZXR1cm4ge0JpZ051bWJlcn0gQmlnTnVtYmVyXG4qL1xudmFyIHRvQmlnTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG4gICAgbnVtYmVyID0gbnVtYmVyIHx8IDA7XG4gICAgaWYgKGlzQmlnTnVtYmVyKG51bWJlcikpXG4gICAgICAgIHJldHVybiBudW1iZXI7XG5cbiAgICBpZiAoaXNTdHJpbmcobnVtYmVyKSAmJiAobnVtYmVyLmluZGV4T2YoJzB4JykgPT09IDAgfHwgbnVtYmVyLmluZGV4T2YoJy0weCcpID09PSAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihudW1iZXIucmVwbGFjZSgnMHgnLCcnKSwgMTYpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG51bWJlci50b1N0cmluZygxMCksIDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW5kIGlucHV0IHRyYW5zZm9ybXMgaXQgaW50byBiaWdudW1iZXIgYW5kIGlmIGl0IGlzIG5lZ2F0aXZlIHZhbHVlLCBpbnRvIHR3bydzIGNvbXBsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIHRvVHdvc0NvbXBsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCaWdOdW1iZXJ9XG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9XG4gKi9cbnZhciB0b1R3b3NDb21wbGVtZW50ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHZhciBiaWdOdW1iZXIgPSB0b0JpZ051bWJlcihudW1iZXIpLnJvdW5kKCk7XG4gICAgaWYgKGJpZ051bWJlci5sZXNzVGhhbigwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIiwgMTYpLnBsdXMoYmlnTnVtYmVyKS5wbHVzKDEpO1xuICAgIH1cbiAgICByZXR1cm4gYmlnTnVtYmVyO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBzdHJpY3RseSBhbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc1N0cmljdEFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cbnZhciBpc1N0cmljdEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHJldHVybiAvXjB4WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xudmFyIGlzQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaGFzIHRoZSBiYXNpYyByZXF1aXJlbWVudHMgb2YgYW4gYWRkcmVzc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NDB9JC8udGVzdChhZGRyZXNzKSB8fCAvXigweCk/WzAtOUEtRl17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICAvLyBJZiBpdCdzIGFsbCBzbWFsbCBjYXBzIG9yIGFsbCBhbGwgY2FwcywgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGVhY2ggY2FzZVxuICAgICAgICByZXR1cm4gaXNDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiovXG52YXIgaXNDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIC8vIENoZWNrIGVhY2ggY2FzZVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrICkge1xuICAgICAgICAvLyB0aGUgbnRoIGxldHRlciBzaG91bGQgYmUgdXBwZXJjYXNlIGlmIHRoZSBudGggZGlnaXQgb2YgY2FzZW1hcCBpcyAxXG4gICAgICAgIGlmICgocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcgJiYgYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpICE9PSBhZGRyZXNzW2ldKSB8fCAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA8PSA3ICYmIGFkZHJlc3NbaV0udG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vKipcbiAqIE1ha2VzIGEgY2hlY2tzdW0gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgdG9DaGVja3N1bUFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4qL1xudmFyIHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG5cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzKTtcbiAgICB2YXIgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA5IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtQWRkcmVzcztcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBnaXZlbiBzdHJpbmcgdG8gdmFsaWQgMjAgYnl0ZXMtbGVuZ3RoIGFkZHJlcyB3aXRoIDB4IHByZWZpeFxuICpcbiAqIEBtZXRob2QgdG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgYWRkcmVzc1xuICovXG52YXIgdG9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNTdHJpY3RBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cblxuICAgIGlmICgvXlswLTlhLWZdezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBhZGRyZXNzO1xuICAgIH1cblxuICAgIHJldHVybiAnMHgnICsgcGFkTGVmdCh0b0hleChhZGRyZXNzKS5zdWJzdHIoMiksIDQwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBCaWdOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCaWdOdW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBCaWdOdW1iZXIgfHxcbiAgICAgICAgKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCaWdOdW1iZXInKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNTdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAob2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvciAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ1N0cmluZycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgT2JqZXQsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgIT09IG51bGwgJiYgIShBcnJheS5pc0FycmF5KG9iamVjdCkpICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdib29sZWFuJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0FycmF5XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgdmFsaWQganNvbiBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGlzSnNvblxuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNKc29uID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIUpTT04ucGFyc2Uoc3RyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBFdGhlcmV1bSBibG9jayBoZWFkZXIgYmxvb20uXG4gKlxuICogQG1ldGhvZCBpc0Jsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNCbG9vbSA9IGZ1bmN0aW9uIChibG9vbSkge1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezUxMn0kL2kudGVzdChibG9vbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoL14oMHgpP1swLTlhLWZdezUxMn0kLy50ZXN0KGJsb29tKSB8fCAvXigweCk/WzAtOUEtRl17NTEyfSQvLnRlc3QoYmxvb20pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBsb2cgdG9waWMuXG4gKlxuICogQG1ldGhvZCBpc1RvcGljXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IGVuY29kZWQgdG9waWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1RvcGljID0gZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NjR9JC9pLnRlc3QodG9waWMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKC9eKDB4KT9bMC05YS1mXXs2NH0kLy50ZXN0KHRvcGljKSB8fCAvXigweCk/WzAtOUEtRl17NjR9JC8udGVzdCh0b3BpYykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhZExlZnQ6IHBhZExlZnQsXG4gICAgcGFkUmlnaHQ6IHBhZFJpZ2h0LFxuICAgIHRvSGV4OiB0b0hleCxcbiAgICB0b0RlY2ltYWw6IHRvRGVjaW1hbCxcbiAgICBmcm9tRGVjaW1hbDogZnJvbURlY2ltYWwsXG4gICAgdG9VdGY4OiB0b1V0ZjgsXG4gICAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gICAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gICAgdHJhbnNmb3JtVG9GdWxsTmFtZTogdHJhbnNmb3JtVG9GdWxsTmFtZSxcbiAgICBleHRyYWN0RGlzcGxheU5hbWU6IGV4dHJhY3REaXNwbGF5TmFtZSxcbiAgICBleHRyYWN0VHlwZU5hbWU6IGV4dHJhY3RUeXBlTmFtZSxcbiAgICB0b1dlaTogdG9XZWksXG4gICAgZnJvbVdlaTogZnJvbVdlaSxcbiAgICB0b0JpZ051bWJlcjogdG9CaWdOdW1iZXIsXG4gICAgdG9Ud29zQ29tcGxlbWVudDogdG9Ud29zQ29tcGxlbWVudCxcbiAgICB0b0FkZHJlc3M6IHRvQWRkcmVzcyxcbiAgICBpc0JpZ051bWJlcjogaXNCaWdOdW1iZXIsXG4gICAgaXNTdHJpY3RBZGRyZXNzOiBpc1N0cmljdEFkZHJlc3MsXG4gICAgaXNBZGRyZXNzOiBpc0FkZHJlc3MsXG4gICAgaXNDaGVja3N1bUFkZHJlc3M6IGlzQ2hlY2tzdW1BZGRyZXNzLFxuICAgIHRvQ2hlY2tzdW1BZGRyZXNzOiB0b0NoZWNrc3VtQWRkcmVzcyxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpc0pzb246IGlzSnNvbixcbiAgICBpc0Jsb29tOiBpc0Jsb29tLFxuICAgIGlzVG9waWM6IGlzVG9waWMsXG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwidmVyc2lvblwiOiBcIjAuMjAuN1wiXG59XG4iLCIvKiFcbiAqIHdlYjMuanMgLSBFdGhlcmV1bSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIEBsaWNlbnNlIGxncGwtMy4wXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93ZWIzLmpzXG4qL1xuXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cbiAqIFxuICogd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICogXG4gKiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKiBcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICpcbiAqIEBmaWxlIHdlYjMuanNcbiAqIEBhdXRob3JzOlxuICogICBKZWZmcmV5IFdpbGNrZSA8amVmZkBldGhkZXYuY29tPlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqICAgTWFyaWFuIE9hbmNlYSA8bWFyaWFuQGV0aGRldi5jb20+XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogICBHYXYgV29vZCA8Z0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciBSZXF1ZXN0TWFuYWdlciA9IHJlcXVpcmUoJy4vd2ViMy9yZXF1ZXN0bWFuYWdlcicpO1xudmFyIEliYW4gPSByZXF1aXJlKCcuL3dlYjMvaWJhbicpO1xudmFyIEV0aCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL2V0aCcpO1xudmFyIERCID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvZGInKTtcbnZhciBTaGggPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9zaGgnKTtcbnZhciBOZXQgPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9uZXQnKTtcbnZhciBQZXJzb25hbCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL3BlcnNvbmFsJyk7XG52YXIgU3dhcm0gPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9zd2FybScpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi93ZWIzL3NldHRpbmdzJyk7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbi5qc29uJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3V0aWxzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJy4vdXRpbHMvc2hhMycpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vd2ViMy9leHRlbmQnKTtcbnZhciBCYXRjaCA9IHJlcXVpcmUoJy4vd2ViMy9iYXRjaCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi93ZWIzL3Byb3BlcnR5Jyk7XG52YXIgSHR0cFByb3ZpZGVyID0gcmVxdWlyZSgnLi93ZWIzL2h0dHBwcm92aWRlcicpO1xudmFyIElwY1Byb3ZpZGVyID0gcmVxdWlyZSgnLi93ZWIzL2lwY3Byb3ZpZGVyJyk7XG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5cblxuXG5mdW5jdGlvbiBXZWIzIChwcm92aWRlcikge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gbmV3IFJlcXVlc3RNYW5hZ2VyKHByb3ZpZGVyKTtcbiAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHRoaXMuZXRoID0gbmV3IEV0aCh0aGlzKTtcbiAgICB0aGlzLmRiID0gbmV3IERCKHRoaXMpO1xuICAgIHRoaXMuc2hoID0gbmV3IFNoaCh0aGlzKTtcbiAgICB0aGlzLm5ldCA9IG5ldyBOZXQodGhpcyk7XG4gICAgdGhpcy5wZXJzb25hbCA9IG5ldyBQZXJzb25hbCh0aGlzKTtcbiAgICB0aGlzLmJ6eiA9IG5ldyBTd2FybSh0aGlzKTtcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgdGhpcy52ZXJzaW9uID0ge1xuICAgICAgICBhcGk6IHZlcnNpb24udmVyc2lvblxuICAgIH07XG4gICAgdGhpcy5wcm92aWRlcnMgPSB7XG4gICAgICAgIEh0dHBQcm92aWRlcjogSHR0cFByb3ZpZGVyLFxuICAgICAgICBJcGNQcm92aWRlcjogSXBjUHJvdmlkZXJcbiAgICB9O1xuICAgIHRoaXMuX2V4dGVuZCA9IGV4dGVuZCh0aGlzKTtcbiAgICB0aGlzLl9leHRlbmQoe1xuICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzKClcbiAgICB9KTtcbn1cblxuLy8gZXhwb3NlIHByb3ZpZGVycyBvbiB0aGUgY2xhc3NcbldlYjMucHJvdmlkZXJzID0ge1xuICAgIEh0dHBQcm92aWRlcjogSHR0cFByb3ZpZGVyLFxuICAgIElwY1Byb3ZpZGVyOiBJcGNQcm92aWRlclxufTtcblxuV2ViMy5wcm90b3R5cGUuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlci5zZXRQcm92aWRlcihwcm92aWRlcik7XG4gICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSBwcm92aWRlcjtcbn07XG5cbldlYjMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGtlZXBJc1N5bmNpbmcpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlci5yZXNldChrZWVwSXNTeW5jaW5nKTtcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG59O1xuXG5XZWIzLnByb3RvdHlwZS5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XG5XZWIzLnByb3RvdHlwZS50b0hleCA9IHV0aWxzLnRvSGV4O1xuV2ViMy5wcm90b3R5cGUudG9Bc2NpaSA9IHV0aWxzLnRvQXNjaWk7XG5XZWIzLnByb3RvdHlwZS50b1V0ZjggPSB1dGlscy50b1V0Zjg7XG5XZWIzLnByb3RvdHlwZS5mcm9tQXNjaWkgPSB1dGlscy5mcm9tQXNjaWk7XG5XZWIzLnByb3RvdHlwZS5mcm9tVXRmOCA9IHV0aWxzLmZyb21VdGY4O1xuV2ViMy5wcm90b3R5cGUudG9EZWNpbWFsID0gdXRpbHMudG9EZWNpbWFsO1xuV2ViMy5wcm90b3R5cGUuZnJvbURlY2ltYWwgPSB1dGlscy5mcm9tRGVjaW1hbDtcbldlYjMucHJvdG90eXBlLnRvQmlnTnVtYmVyID0gdXRpbHMudG9CaWdOdW1iZXI7XG5XZWIzLnByb3RvdHlwZS50b1dlaSA9IHV0aWxzLnRvV2VpO1xuV2ViMy5wcm90b3R5cGUuZnJvbVdlaSA9IHV0aWxzLmZyb21XZWk7XG5XZWIzLnByb3RvdHlwZS5pc0FkZHJlc3MgPSB1dGlscy5pc0FkZHJlc3M7XG5XZWIzLnByb3RvdHlwZS5pc0NoZWNrc3VtQWRkcmVzcyA9IHV0aWxzLmlzQ2hlY2tzdW1BZGRyZXNzO1xuV2ViMy5wcm90b3R5cGUudG9DaGVja3N1bUFkZHJlc3MgPSB1dGlscy50b0NoZWNrc3VtQWRkcmVzcztcbldlYjMucHJvdG90eXBlLmlzSUJBTiA9IHV0aWxzLmlzSUJBTjtcbldlYjMucHJvdG90eXBlLnBhZExlZnQgPSB1dGlscy5wYWRMZWZ0O1xuV2ViMy5wcm90b3R5cGUucGFkUmlnaHQgPSB1dGlscy5wYWRSaWdodDtcblxuXG5XZWIzLnByb3RvdHlwZS5zaGEzID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICcweCcgKyBzaGEzKHN0cmluZywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgZGlyZWN0IGljYXAgdG8gYWRkcmVzc1xuICovXG5XZWIzLnByb3RvdHlwZS5mcm9tSUNBUCA9IGZ1bmN0aW9uIChpY2FwKSB7XG4gICAgdmFyIGliYW4gPSBuZXcgSWJhbihpY2FwKTtcbiAgICByZXR1cm4gaWJhbi5hZGRyZXNzKCk7XG59O1xuXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24ubm9kZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICd3ZWIzX2NsaWVudFZlcnNpb24nXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24ubmV0d29yaycsXG4gICAgICAgICAgICBnZXR0ZXI6ICduZXRfdmVyc2lvbicsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24uZXRoZXJldW0nLFxuICAgICAgICAgICAgZ2V0dGVyOiAnZXRoX3Byb3RvY29sVmVyc2lvbicsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24ud2hpc3BlcicsXG4gICAgICAgICAgICBnZXR0ZXI6ICdzaGhfdmVyc2lvbicsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pXG4gICAgXTtcbn07XG5cbldlYjMucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFByb3ZpZGVyICYmIHRoaXMuY3VycmVudFByb3ZpZGVyLmlzQ29ubmVjdGVkKCkpO1xufTtcblxuV2ViMy5wcm90b3R5cGUuY3JlYXRlQmF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBCYXRjaCh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViMztcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgYWxsZXZlbnRzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xudmFyIFNvbGlkaXR5RXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIHdhdGNoZXMgPSByZXF1aXJlKCcuL21ldGhvZHMvd2F0Y2hlcycpO1xuXG52YXIgQWxsU29saWRpdHlFdmVudHMgPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMuX2pzb24gPSBqc29uO1xuICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgWydmcm9tQmxvY2snLCAndG9CbG9jayddLmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gb3B0aW9uc1tmXSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmVzdWx0W2ZdID0gZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKG9wdGlvbnNbZl0pO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0LmFkZHJlc3MgPSB0aGlzLl9hZGRyZXNzO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkFsbFNvbGlkaXR5RXZlbnRzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCAnJztcblxuXG4gICAgdmFyIGV2ZW50VG9waWMgPSAodXRpbHMuaXNBcnJheShkYXRhLnRvcGljcykgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YS50b3BpY3NbMF0pKSA/IGRhdGEudG9waWNzWzBdLnNsaWNlKDIpIDogJyc7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5fanNvbi5maWx0ZXIoZnVuY3Rpb24gKGopIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50VG9waWMgPT09IHNoYTModXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqKSk7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoIW1hdGNoKSB7IC8vIGNhbm5vdCBmaW5kIG1hdGNoaW5nIGV2ZW50P1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50ID0gbmV3IFNvbGlkaXR5RXZlbnQodGhpcy5fcmVxdWVzdE1hbmFnZXIsIG1hdGNoLCB0aGlzLl9hZGRyZXNzKTtcbiAgICByZXR1cm4gZXZlbnQuZGVjb2RlKGRhdGEpO1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUob3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIobywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXIsIGNhbGxiYWNrKTtcbn07XG5cbkFsbFNvbGlkaXR5RXZlbnRzLnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV4ZWN1dGUgPSB0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtcbiAgICBjb250cmFjdC5hbGxFdmVudHMgPSBleGVjdXRlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxTb2xpZGl0eUV2ZW50cztcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGJhdGNoLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBKc29ucnBjID0gcmVxdWlyZSgnLi9qc29ucnBjJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxudmFyIEJhdGNoID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5yZXF1ZXN0cyA9IFtdO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFkZCBjcmVhdGUgbmV3IHJlcXVlc3QgdG8gYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbnJwYyByZXF1ZXQgb2JqZWN0XG4gKi9cbkJhdGNoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHRoaXMucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBleGVjdXRlIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqL1xuQmF0Y2gucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcXVlc3RzID0gdGhpcy5yZXF1ZXN0cztcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyLnNlbmRCYXRjaChyZXF1ZXN0cywgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgICAgICAgcmVxdWVzdHMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0LCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbaW5kZXhdIHx8IHt9O1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdHNbaW5kZXhdLmNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RzW2luZGV4XS5jYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcXVlc3RzW2luZGV4XS5jYWxsYmFjayhudWxsLCAocmVxdWVzdHNbaW5kZXhdLmZvcm1hdCA/IHJlcXVlc3RzW2luZGV4XS5mb3JtYXQocmVzdWx0LnJlc3VsdCkgOiByZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pOyBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmF0Y2g7XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGNvbnRyYWN0LmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIFNvbGlkaXR5RXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgU29saWRpdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24nKTtcbnZhciBBbGxFdmVudHMgPSByZXF1aXJlKCcuL2FsbGV2ZW50cycpO1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZW5jb2RlIGNvbnN0cnVjdG9yIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlQ29uc3RydWN0b3JQYXJhbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICogQHBhcmFtIHtBcnJheX0gY29uc3RydWN0b3IgcGFyYW1zXG4gKi9cbnZhciBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtcyA9IGZ1bmN0aW9uIChhYmksIHBhcmFtcykge1xuICAgIHJldHVybiBhYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicgJiYganNvbi5pbnB1dHMubGVuZ3RoID09PSBwYXJhbXMubGVuZ3RoO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4ganNvbi5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnR5cGU7XG4gICAgICAgIH0pO1xuICAgIH0pLm1hcChmdW5jdGlvbiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmVuY29kZVBhcmFtcyh0eXBlcywgcGFyYW1zKTtcbiAgICB9KVswXSB8fCAnJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgZnVuY3Rpb25zIHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYWRkRnVuY3Rpb25zVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgYWRkRnVuY3Rpb25zVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIGNvbnRyYWN0LmFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb2xpZGl0eUZ1bmN0aW9uKGNvbnRyYWN0Ll9ldGgsIGpzb24sIGNvbnRyYWN0LmFkZHJlc3MpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgZi5hdHRhY2hUb0NvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgZXZlbnRzIHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYWRkRXZlbnRzVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgYWRkRXZlbnRzVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBldmVudHMgPSBjb250cmFjdC5hYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdldmVudCc7XG4gICAgfSk7XG5cbiAgICB2YXIgQWxsID0gbmV3IEFsbEV2ZW50cyhjb250cmFjdC5fZXRoLl9yZXF1ZXN0TWFuYWdlciwgZXZlbnRzLCBjb250cmFjdC5hZGRyZXNzKTtcbiAgICBBbGwuYXR0YWNoVG9Db250cmFjdChjb250cmFjdCk7XG5cbiAgICBldmVudHMubWFwKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29saWRpdHlFdmVudChjb250cmFjdC5fZXRoLl9yZXF1ZXN0TWFuYWdlciwganNvbiwgY29udHJhY3QuYWRkcmVzcyk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmF0dGFjaFRvQ29udHJhY3QoY29udHJhY3QpO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIGNvbnRyYWN0IGdldHMgcHJvcGVybHkgZGVwbG95ZWQgb24gdGhlIGJsb2NrY2hhaW4uXG4gKlxuICogQG1ldGhvZCBjaGVja0ZvckNvbnRyYWN0QWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRyYWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge1VuZGVmaW5lZH1cbiAqL1xudmFyIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzID0gZnVuY3Rpb24oY29udHJhY3QsIGNhbGxiYWNrKXtcbiAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICBjYWxsYmFja0ZpcmVkID0gZmFsc2U7XG5cbiAgICAvLyB3YWl0IGZvciByZWNlaXB0XG4gICAgdmFyIGZpbHRlciA9IGNvbnRyYWN0Ll9ldGguZmlsdGVyKCdsYXRlc3QnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYgKCFlICYmICFjYWxsYmFja0ZpcmVkKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHdhdGNoaW5nIGFmdGVyIDUwIGJsb2NrcyAodGltZW91dClcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDUwKSB7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXIuc3RvcFdhdGNoaW5nKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0NvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkblxcJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzJykpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCB0cmFuc2FjdGlvbiBjb3VsZG5cXCd0IGJlIGZvdW5kIGFmdGVyIDUwIGJsb2NrcycpO1xuXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjb250cmFjdC5fZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdChjb250cmFjdC50cmFuc2FjdGlvbkhhc2gsIGZ1bmN0aW9uKGUsIHJlY2VpcHQpe1xuICAgICAgICAgICAgICAgICAgICBpZihyZWNlaXB0ICYmIHJlY2VpcHQuYmxvY2tIYXNoICYmICFjYWxsYmFja0ZpcmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0Ll9ldGguZ2V0Q29kZShyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcywgZnVuY3Rpb24oZSwgY29kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2tGaXJlZCB8fCAhY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnN0b3BXYXRjaGluZyhmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0ZpcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvZGUubGVuZ3RoID4gMykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDb250cmFjdCBjb2RlIGRlcGxveWVkIScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0LmFkZHJlc3MgPSByZWNlaXB0LmNvbnRyYWN0QWRkcmVzcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2ggZXZlbnRzIGFuZCBtZXRob2RzIGFnYWluIGFmdGVyIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRnVuY3Rpb25zVG9Db250cmFjdChjb250cmFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50c1RvQ29udHJhY3QoY29udHJhY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgY2FsbGJhY2sgZm9yIHRoZSBzZWNvbmQgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRyYWN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY29udHJhY3QgY29kZSBjb3VsZG5cXCd0IGJlIHN0b3JlZCwgcGxlYXNlIGNoZWNrIHlvdXIgZ2FzIGFtb3VudC4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRyYWN0IGNvZGUgY291bGRuXFwndCBiZSBzdG9yZWQsIHBsZWFzZSBjaGVjayB5b3VyIGdhcyBhbW91bnQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgQ29udHJhY3RGYWN0b3J5IGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBDb250cmFjdEZhY3RvcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKGV0aCwgYWJpKSB7XG4gICAgdGhpcy5ldGggPSBldGg7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgY29udHJhY3Qgb24gYSBibG9ja2NoYWluXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5ld1xuICAgICAqIEBwYXJhbSB7QW55fSBjb250cmFjdCBjb25zdHJ1Y3RvciBwYXJhbTEgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSB7QW55fSBjb250cmFjdCBjb25zdHJ1Y3RvciBwYXJhbTIgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250cmFjdCB0cmFuc2FjdGlvbiBvYmplY3QgKHJlcXVpcmVkKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0NvbnRyYWN0fSByZXR1cm5zIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5uZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDcgKi9cblxuICAgICAgICB2YXIgY29udHJhY3QgPSBuZXcgQ29udHJhY3QodGhpcy5ldGgsIHRoaXMuYWJpKTtcblxuICAgICAgICAvLyBwYXJzZSBhcmd1bWVudHNcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gcmVxdWlyZWQhXG4gICAgICAgIHZhciBjYWxsYmFjaztcblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodXRpbHMuaXNPYmplY3QobGFzdCkgJiYgIXV0aWxzLmlzQXJyYXkobGFzdCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmdzLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudmFsdWUgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3JBYmkgPSBhYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiBqc29uLmlucHV0cy5sZW5ndGggPT09IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgfSlbMF0gfHwge307XG5cbiAgICAgICAgICAgIGlmICghY29uc3RydWN0b3JBYmkucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgY29uc3RydWN0b3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBieXRlcyA9IGVuY29kZUNvbnN0cnVjdG9yUGFyYW1zKHRoaXMuYWJpLCBhcmdzKTtcbiAgICAgICAgb3B0aW9ucy5kYXRhICs9IGJ5dGVzO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuXG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgY29udHJhY3QgYWRkcmVzcyBhbmQgY2hlY2sgaWYgdGhlIGNvZGUgd2FzIGRlcGxveWVkXG4gICAgICAgICAgICB0aGlzLmV0aC5zZW5kVHJhbnNhY3Rpb24ob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgaGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3QudHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGNhbGxiYWNrIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjb250cmFjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGb3JDb250cmFjdEFkZHJlc3MoY29udHJhY3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5ldGguc2VuZFRyYW5zYWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gYWRkIHRoZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgICAgICBjb250cmFjdC50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgY2hlY2tGb3JDb250cmFjdEFkZHJlc3MoY29udHJhY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH07XG5cbiAgICB0aGlzLm5ldy5nZXREYXRhID0gdGhpcy5nZXREYXRhLmJpbmQodGhpcyk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBDb250cmFjdEZhY3RvcnlcbiAqXG4gKiBAbWV0aG9kIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhYmlcbiAqIEByZXR1cm5zIHtDb250cmFjdEZhY3Rvcnl9IG5ldyBjb250cmFjdCBmYWN0b3J5XG4gKi9cbi8vdmFyIGNvbnRyYWN0ID0gZnVuY3Rpb24gKGFiaSkge1xuICAgIC8vcmV0dXJuIG5ldyBDb250cmFjdEZhY3RvcnkoYWJpKTtcbi8vfTtcblxuXG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYWNjZXNzIHRvIGV4aXN0aW5nIGNvbnRyYWN0IG9uIGEgYmxvY2tjaGFpblxuICpcbiAqIEBtZXRob2QgYXRcbiAqIEBwYXJhbSB7QWRkcmVzc30gY29udHJhY3QgYWRkcmVzcyAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB7b3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7Q29udHJhY3R9IHJldHVybnMgY29udHJhY3QgaWYgbm8gY2FsbGJhY2sgd2FzIHBhc3NlZCxcbiAqIG90aGVyd2lzZSBjYWxscyBjYWxsYmFjayBmdW5jdGlvbiAoZXJyLCBjb250cmFjdClcbiAqL1xuQ29udHJhY3RGYWN0b3J5LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChhZGRyZXNzLCBjYWxsYmFjaykge1xuICAgIHZhciBjb250cmFjdCA9IG5ldyBDb250cmFjdCh0aGlzLmV0aCwgdGhpcy5hYmksIGFkZHJlc3MpO1xuXG4gICAgLy8gdGhpcyBmdW5jdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIHByb3RvdHlwZSxcbiAgICAvLyBiZWNhdXNlIHdlIGRvbnQgd2FudCB0byBzcG9pbCB0aGUgaW50ZXJmYWNlXG4gICAgYWRkRnVuY3Rpb25zVG9Db250cmFjdChjb250cmFjdCk7XG4gICAgYWRkRXZlbnRzVG9Db250cmFjdChjb250cmFjdCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY29udHJhY3QpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJhY3Q7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEsIHdoaWNoIGlzIGRhdGEgdG8gZGVwbG95IHBsdXMgY29uc3RydWN0b3IgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBnZXREYXRhXG4gKi9cbkNvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9OyAvLyByZXF1aXJlZCFcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBpZiAodXRpbHMuaXNPYmplY3QobGFzdCkgJiYgIXV0aWxzLmlzQXJyYXkobGFzdCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3MucG9wKCk7XG4gICAgfVxuXG4gICAgdmFyIGJ5dGVzID0gZW5jb2RlQ29uc3RydWN0b3JQYXJhbXModGhpcy5hYmksIGFyZ3MpO1xuICAgIG9wdGlvbnMuZGF0YSArPSBieXRlcztcblxuICAgIHJldHVybiBvcHRpb25zLmRhdGE7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBjb250cmFjdCBpbnN0YW5jZVxuICpcbiAqIEBtZXRob2QgQ29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICogQHBhcmFtIHtBZGRyZXNzfSBjb250cmFjdCBhZGRyZXNzXG4gKi9cbnZhciBDb250cmFjdCA9IGZ1bmN0aW9uIChldGgsIGFiaSwgYWRkcmVzcykge1xuICAgIHRoaXMuX2V0aCA9IGV0aDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uSGFzaCA9IG51bGw7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmFiaSA9IGFiaTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJhY3RGYWN0b3J5O1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGVycm9ycy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBJbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIFNvbGlkaXR5IGZ1bmN0aW9uJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgaW5wdXQgcGFyYW1ldGVycyB0byBSUEMgbWV0aG9kJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkQ29ubmVjdGlvbjogZnVuY3Rpb24gKGhvc3Qpe1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdDT05ORUNUSU9OIEVSUk9SOiBDb3VsZG5cXCd0IGNvbm5lY3QgdG8gbm9kZSAnKyBob3N0ICsnLicpO1xuICAgIH0sXG4gICAgSW52YWxpZFByb3ZpZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1Byb3ZpZGVyIG5vdCBzZXQgb3IgaW52YWxpZCcpO1xuICAgIH0sXG4gICAgSW52YWxpZFJlc3BvbnNlOiBmdW5jdGlvbiAocmVzdWx0KXtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAhIXJlc3VsdCAmJiAhIXJlc3VsdC5lcnJvciAmJiAhIXJlc3VsdC5lcnJvci5tZXNzYWdlID8gcmVzdWx0LmVycm9yLm1lc3NhZ2UgOiAnSW52YWxpZCBKU09OIFJQQyByZXNwb25zZTogJyArIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSxcbiAgICBDb25uZWN0aW9uVGltZW91dDogZnVuY3Rpb24gKG1zKXtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignQ09OTkVDVElPTiBUSU1FT1VUOiB0aW1lb3V0IG9mICcgKyBtcyArICcgbXMgYWNoaXZlZCcpO1xuICAgIH1cbn07XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBldmVudC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIGNvZGVyID0gcmVxdWlyZSgnLi4vc29saWRpdHkvY29kZXInKTtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NoYTMnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIHdhdGNoZXMgPSByZXF1aXJlKCcuL21ldGhvZHMvd2F0Y2hlcycpO1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBldmVudCBmaWx0ZXJzXG4gKi9cbnZhciBTb2xpZGl0eUV2ZW50ID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBqc29uLCBhZGRyZXNzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSByZXF1ZXN0TWFuYWdlcjtcbiAgICB0aGlzLl9wYXJhbXMgPSBqc29uLmlucHV0cztcbiAgICB0aGlzLl9uYW1lID0gdXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqc29uKTtcbiAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLl9hbm9ueW1vdXMgPSBqc29uLmFub255bW91cztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZpbHRlcmVkIHBhcmFtIHR5cGVzXG4gKlxuICogQG1ldGhvZCB0eXBlc1xuICogQHBhcmFtIHtCb29sfSBkZWNpZGUgaWYgcmV0dXJuZWQgdHlwZWQgc2hvdWxkIGJlIGluZGV4ZWRcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiB0eXBlc1xuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS50eXBlcyA9IGZ1bmN0aW9uIChpbmRleGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkuaW5kZXhlZCA9PT0gaW5kZXhlZDtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkudHlwZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGV2ZW50IGRpc3BsYXkgbmFtZVxuICpcbiAqIEBtZXRob2QgZGlzcGxheU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZXZlbnQgZGlzcGxheSBuYW1lXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5leHRyYWN0RGlzcGxheU5hbWUodGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBldmVudCB0eXBlIG5hbWVcbiAqXG4gKiBAbWV0aG9kIHR5cGVOYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGV2ZW50IHR5cGUgbmFtZVxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdFR5cGVOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZXZlbnQgc2lnbmF0dXJlXG4gKlxuICogQG1ldGhvZCBzaWduYXR1cmVcbiAqIEByZXR1cm4ge1N0cmluZ30gZXZlbnQgc2lnbmF0dXJlXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLnNpZ25hdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2hhMyh0aGlzLl9uYW1lKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGluZGV4ZWQgcGFyYW1zIGFuZCBvcHRpb25zIHRvIG9uZSBmaW5hbCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGluZGV4ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGV2ZXJ5dGhpbmcgY29tYmluZWQgdG9nZXRoZXIgYW5kIGVuY29kZWRcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGluZGV4ZWQsIG9wdGlvbnMpIHtcbiAgICBpbmRleGVkID0gaW5kZXhlZCB8fCB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBbJ2Zyb21CbG9jaycsICd0b0Jsb2NrJ10uZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2ZdICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXN1bHRbZl0gPSBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9uc1tmXSk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQudG9waWNzID0gW107XG5cbiAgICByZXN1bHQuYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3M7XG4gICAgaWYgKCF0aGlzLl9hbm9ueW1vdXMpIHtcbiAgICAgICAgcmVzdWx0LnRvcGljcy5wdXNoKCcweCcgKyB0aGlzLnNpZ25hdHVyZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhlZFRvcGljcyA9IHRoaXMuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkuaW5kZXhlZCA9PT0gdHJ1ZTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXhlZFtpLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzB4JyArIGNvZGVyLmVuY29kZVBhcmFtKGkudHlwZSwgdik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzB4JyArIGNvZGVyLmVuY29kZVBhcmFtKGkudHlwZSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0LnRvcGljcyA9IHJlc3VsdC50b3BpY3MuY29uY2F0KGluZGV4ZWRUb3BpY3MpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGluZGV4ZWQgcGFyYW1zIGFuZCBvcHRpb25zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCBvYmplY3Qgd2l0aCBkZWNvZGVkIGluZGV4ZWQgJiYgbm90IGluZGV4ZWQgcGFyYW1zXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwgJyc7XG4gICAgZGF0YS50b3BpY3MgPSBkYXRhLnRvcGljcyB8fCBbXTtcblxuXG4gICAgdmFyIGFyZ1RvcGljcyA9IHRoaXMuX2Fub255bW91cyA/IGRhdGEudG9waWNzIDogZGF0YS50b3BpY3Muc2xpY2UoMSk7XG4gICAgdmFyIGluZGV4ZWREYXRhID0gYXJnVG9waWNzLm1hcChmdW5jdGlvbiAodG9waWNzKSB7IHJldHVybiB0b3BpY3Muc2xpY2UoMik7IH0pLmpvaW4oXCJcIik7XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBjb2Rlci5kZWNvZGVQYXJhbXModGhpcy50eXBlcyh0cnVlKSwgaW5kZXhlZERhdGEpO1xuXG4gICAgdmFyIG5vdEluZGV4ZWREYXRhID0gZGF0YS5kYXRhLnNsaWNlKDIpO1xuICAgIHZhciBub3RJbmRleGVkUGFyYW1zID0gY29kZXIuZGVjb2RlUGFyYW1zKHRoaXMudHlwZXMoZmFsc2UpLCBub3RJbmRleGVkRGF0YSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIoZGF0YSk7XG4gICAgcmVzdWx0LmV2ZW50ID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIHJlc3VsdC5hZGRyZXNzID0gZGF0YS5hZGRyZXNzO1xuXG4gICAgcmVzdWx0LmFyZ3MgPSB0aGlzLl9wYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnJlbnQpIHtcbiAgICAgICAgYWNjW2N1cnJlbnQubmFtZV0gPSBjdXJyZW50LmluZGV4ZWQgPyBpbmRleGVkUGFyYW1zLnNoaWZ0KCkgOiBub3RJbmRleGVkUGFyYW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgZGVsZXRlIHJlc3VsdC5kYXRhO1xuICAgIGRlbGV0ZSByZXN1bHQudG9waWNzO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIG5ldyBmaWx0ZXIgb2JqZWN0IGZyb20gZXZlbnRcbiAqXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmRleGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSBmaWx0ZXIgb2JqZWN0XG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoaW5kZXhlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIGluZGV4ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUoaW5kZXhlZCwgb3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIobywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXIsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gYXR0YWNoIGV2ZW50IHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH1cbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIGlmICghY29udHJhY3RbZGlzcGxheU5hbWVdKSB7XG4gICAgICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXSA9IGV4ZWN1dGU7XG4gICAgfVxuICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXVt0aGlzLnR5cGVOYW1lKCldID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcywgY29udHJhY3QpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eUV2ZW50O1xuXG4iLCJ2YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscy91dGlscycpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4vbWV0aG9kJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8vIFRPRE86IHJlZmFjdG9yLCBzbyB0aGUgaW5wdXQgcGFyYW1zIGFyZSBub3QgYWx0ZXJlZC5cbi8vIGl0J3MgbmVjZXNzYXJ5IHRvIG1ha2Ugc2FtZSAnZXh0ZW5zaW9uJyB3b3JrIHdpdGggbXVsdGlwbGUgcHJvdmlkZXJzXG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG4gICAgdmFyIGV4ID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXG4gICAgICAgIHZhciBleHRlbmRlZE9iamVjdDtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKCF3ZWIzW2V4dGVuc2lvbi5wcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICB3ZWIzW2V4dGVuc2lvbi5wcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZGVkT2JqZWN0ID0gd2ViM1tleHRlbnNpb24ucHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0ZW5kZWRPYmplY3QgPSB3ZWIzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbi5tZXRob2RzKSB7XG4gICAgICAgICAgICBleHRlbnNpb24ubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3QoZXh0ZW5kZWRPYmplY3QpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcih3ZWIzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb24ucHJvcGVydGllcykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5hdHRhY2hUb09iamVjdChleHRlbmRlZE9iamVjdCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkuc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZXguZm9ybWF0dGVycyA9IGZvcm1hdHRlcnM7IFxuICAgIGV4LnV0aWxzID0gdXRpbHM7XG4gICAgZXguTWV0aG9kID0gTWV0aG9kO1xuICAgIGV4LlByb3BlcnR5ID0gUHJvcGVydHk7XG5cbiAgICByZXR1cm4gZXg7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgZmlsdGVyLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiAgIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqICAgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxuLyoqXG4qIENvbnZlcnRzIGEgZ2l2ZW4gdG9waWMgdG8gYSBoZXggc3RyaW5nLCBidXQgYWxzbyBhbGxvd3MgbnVsbCB2YWx1ZXMuXG4qXG4qIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4qIEByZXR1cm4ge1N0cmluZ31cbiovXG52YXIgdG9Ub3BpYyA9IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXG4gICAgaWYodmFsdWUuaW5kZXhPZignMHgnKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHV0aWxzLmZyb21VdGY4KHZhbHVlKTtcbn07XG5cbi8vLyBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uIG9wdGlvbnMgb2JqZWN0LCB0byB2ZXJpZnkgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzICYmIGxhenkgbG9hZCBkeW5hbWljIG9uZXNcbi8vLyBAcGFyYW0gc2hvdWxkIGJlIHN0cmluZyBvciBvYmplY3Rcbi8vLyBAcmV0dXJucyBvcHRpb25zIHN0cmluZyBvciBvYmplY3RcbnZhciBnZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHR5cGUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA2ICovXG5cbiAgICBpZiAodXRpbHMuaXNTdHJpbmcob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2V0aCc6XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0b3BpY3MsIGdldCBjb252ZXJ0ZWQgdG8gaGV4XG4gICAgICAgICAgICBvcHRpb25zLnRvcGljcyA9IG9wdGlvbnMudG9waWNzIHx8IFtdO1xuICAgICAgICAgICAgb3B0aW9ucy50b3BpY3MgPSBvcHRpb25zLnRvcGljcy5tYXAoZnVuY3Rpb24odG9waWMpe1xuICAgICAgICAgICAgICAgIHJldHVybiAodXRpbHMuaXNBcnJheSh0b3BpYykpID8gdG9waWMubWFwKHRvVG9waWMpIDogdG9Ub3BpYyh0b3BpYyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3BpY3M6IG9wdGlvbnMudG9waWNzLFxuICAgICAgICAgICAgICAgIGZyb206IG9wdGlvbnMuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogb3B0aW9ucy50byxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBvcHRpb25zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZnJvbUJsb2NrOiBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9ucy5mcm9tQmxvY2spLFxuICAgICAgICAgICAgICAgIHRvQmxvY2s6IGZvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihvcHRpb25zLnRvQmxvY2spXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdzaGgnOlxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxufTtcblxuLyoqXG5BZGRzIHRoZSBjYWxsYmFjayBhbmQgc2V0cyB1cCB0aGUgbWV0aG9kcywgdG8gaXRlcmF0ZSBvdmVyIHRoZSByZXN1bHRzLlxuXG5AbWV0aG9kIGdldExvZ3NBdFN0YXJ0XG5AcGFyYW0ge09iamVjdH0gc2VsZlxuQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiovXG52YXIgZ2V0TG9nc0F0U3RhcnQgPSBmdW5jdGlvbihzZWxmLCBjYWxsYmFjayl7XG4gICAgLy8gY2FsbCBnZXRGaWx0ZXJMb2dzIGZvciB0aGUgZmlyc3Qgd2F0Y2ggY2FsbGJhY2sgc3RhcnRcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHNlbGYub3B0aW9ucykpIHtcbiAgICAgICAgc2VsZi5nZXQoZnVuY3Rpb24gKGVyciwgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHNlbmQgYWxsIHRoZSByZXNwb25zZXMgdG8gYWxsIHRoZSB3YXRjaGVzIGFnYWluLi4uIGp1c3QgdG8gc2VsZiBvbmVcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih1dGlscy5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuQWRkcyB0aGUgY2FsbGJhY2sgYW5kIHNldHMgdXAgdGhlIG1ldGhvZHMsIHRvIGl0ZXJhdGUgb3ZlciB0aGUgcmVzdWx0cy5cblxuQG1ldGhvZCBwb2xsRmlsdGVyXG5AcGFyYW0ge09iamVjdH0gc2VsZlxuKi9cbnZhciBwb2xsRmlsdGVyID0gZnVuY3Rpb24oc2VsZikge1xuXG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uIChlcnJvciwgbWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHV0aWxzLmlzQXJyYXkobWVzc2FnZXMpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobWVzc2FnZSkgOiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe1xuICAgICAgICBtZXRob2Q6IHNlbGYuaW1wbGVtZW50YXRpb24ucG9sbC5jYWxsLFxuICAgICAgICBwYXJhbXM6IFtzZWxmLmZpbHRlcklkXSxcbiAgICB9LCBzZWxmLmZpbHRlcklkLCBvbk1lc3NhZ2UsIHNlbGYuc3RvcFdhdGNoaW5nLmJpbmQoc2VsZikpO1xuXG59O1xuXG52YXIgRmlsdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIHR5cGUsIHJlcXVlc3RNYW5hZ2VyLCBtZXRob2RzLCBmb3JtYXR0ZXIsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0ge307XG4gICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHJlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KGltcGxlbWVudGF0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zLCB0eXBlKTtcbiAgICB0aGlzLmltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb247XG4gICAgdGhpcy5maWx0ZXJJZCA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmdldExvZ3NDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBvbGxGaWx0ZXJzID0gW107XG4gICAgdGhpcy5mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbi5uZXdGaWx0ZXIodGhpcy5vcHRpb25zLCBmdW5jdGlvbihlcnJvciwgaWQpe1xuICAgICAgICBpZihlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYil7XG4gICAgICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJJZCA9IGlkO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZ2V0IHBlbmRpbmcgY2FsbGJhY2tzIGFzIGEgY29uc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIG9mIGNhbGxpbmcgZ2V0KCkgd2l0aCBmaWx0ZXJJZCB1bmFzc2lnbmVkLlxuICAgICAgICAgICAgc2VsZi5nZXRMb2dzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKXtcbiAgICAgICAgICAgICAgICBzZWxmLmdldChjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuZ2V0TG9nc0NhbGxiYWNrcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBnZXQgZmlsdGVyIGxvZ3MgZm9yIHRoZSBhbHJlYWR5IGV4aXN0aW5nIHdhdGNoIGNhbGxzXG4gICAgICAgICAgICBzZWxmLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKXtcbiAgICAgICAgICAgICAgICBnZXRMb2dzQXRTdGFydChzZWxmLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKHNlbGYuY2FsbGJhY2tzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcG9sbEZpbHRlcihzZWxmKTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgdG8gd2F0Y2ggaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLndhdGNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cbiAgICBpZih0aGlzLmZpbHRlcklkKSB7XG4gICAgICAgIGdldExvZ3NBdFN0YXJ0KHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgICAgcG9sbEZpbHRlcih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuc3RvcFdhdGNoaW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5zdG9wUG9sbGluZyh0aGlzLmZpbHRlcklkKTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIC8vIHJlbW92ZSBmaWx0ZXIgYXN5bmNcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbXBsZW1lbnRhdGlvbi51bmluc3RhbGxGaWx0ZXIodGhpcy5maWx0ZXJJZCwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkKTtcbiAgICB9XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIGZpbHRlcklkIGlzIG5vdCBzZXQgeWV0LCBjYWxsIGl0IGJhY2tcbiAgICAgICAgICAgIC8vIHdoZW4gbmV3RmlsdGVyKCkgYXNzaWducyBpdC5cbiAgICAgICAgICAgIHRoaXMuZ2V0TG9nc0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24uZ2V0TG9ncyh0aGlzLmZpbHRlcklkLCBmdW5jdGlvbihlcnIsIHJlcyl7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcy5tYXAoZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobG9nKSA6IGxvZztcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsdGVyIElEIEVycm9yOiBmaWx0ZXIoKS5nZXQoKSBjYW5cXCd0IGJlIGNoYWluZWQgc3luY2hyb25vdXMsIHBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIHRoZSBnZXQoKSBtZXRob2QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ3MgPSB0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCk7XG4gICAgICAgIHJldHVybiBsb2dzLm1hcChmdW5jdGlvbiAobG9nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXR0ZXIgPyBzZWxmLmZvcm1hdHRlcihsb2cpIDogbG9nO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmb3JtYXR0ZXJzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi91dGlscy9jb25maWcnKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnLi9pYmFuJyk7XG5cbi8qKlxuICogU2hvdWxkIHRoZSBmb3JtYXQgb3V0cHV0IHRvIGEgYmlnIG51bWJlclxuICpcbiAqIEBtZXRob2Qgb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfVxuICogQHJldHVybnMge0JpZ051bWJlcn0gb2JqZWN0XG4gKi9cbnZhciBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgcmV0dXJuIHV0aWxzLnRvQmlnTnVtYmVyKG51bWJlcik7XG59O1xuXG52YXIgaXNQcmVkZWZpbmVkQmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICByZXR1cm4gYmxvY2tOdW1iZXIgPT09ICdsYXRlc3QnIHx8IGJsb2NrTnVtYmVyID09PSAncGVuZGluZycgfHwgYmxvY2tOdW1iZXIgPT09ICdlYXJsaWVzdCc7XG59O1xuXG52YXIgaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICBpZiAoYmxvY2tOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmRlZmF1bHRCbG9jaztcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIoYmxvY2tOdW1iZXIpO1xufTtcblxudmFyIGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICBpZiAoYmxvY2tOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoaXNQcmVkZWZpbmVkQmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpKSB7XG4gICAgICAgIHJldHVybiBibG9ja051bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4KGJsb2NrTnVtYmVyKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB0cmFuc2FjdGlvbiBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0Q2FsbEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIG9iamVjdFxuKi9cbnZhciBpbnB1dENhbGxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucyl7XG5cbiAgICBvcHRpb25zLmZyb20gPSBvcHRpb25zLmZyb20gfHwgY29uZmlnLmRlZmF1bHRBY2NvdW50O1xuXG4gICAgaWYgKG9wdGlvbnMuZnJvbSkge1xuICAgICAgICBvcHRpb25zLmZyb20gPSBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy5mcm9tKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bykgeyAvLyBpdCBtaWdodCBiZSBjb250cmFjdCBjcmVhdGlvblxuICAgICAgICBvcHRpb25zLnRvID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMudG8pO1xuICAgIH1cblxuICAgIFsnZ2FzUHJpY2UnLCAnZ2FzJywgJ3ZhbHVlJywgJ25vbmNlJ10uZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgb3B0aW9uc1trZXldID0gdXRpbHMuZnJvbURlY2ltYWwob3B0aW9uc1trZXldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBpbnB1dCBvZiBhIHRyYW5zYWN0aW9uIGFuZCBjb252ZXJ0cyBhbGwgdmFsdWVzIHRvIEhFWFxuICpcbiAqIEBtZXRob2QgaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIG9iamVjdFxuKi9cbnZhciBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpe1xuXG4gICAgb3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tIHx8IGNvbmZpZy5kZWZhdWx0QWNjb3VudDtcbiAgICBvcHRpb25zLmZyb20gPSBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy5mcm9tKTtcblxuICAgIGlmIChvcHRpb25zLnRvKSB7IC8vIGl0IG1pZ2h0IGJlIGNvbnRyYWN0IGNyZWF0aW9uXG4gICAgICAgIG9wdGlvbnMudG8gPSBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy50byk7XG4gICAgfVxuXG4gICAgWydnYXNQcmljZScsICdnYXMnLCAndmFsdWUnLCAnbm9uY2UnXS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgICBvcHRpb25zW2tleV0gPSB1dGlscy5mcm9tRGVjaW1hbChvcHRpb25zW2tleV0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIHRyYW5zYWN0aW9uIHRvIGl0cyBwcm9wZXIgdmFsdWVzXG4gKlxuICogQG1ldGhvZCBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHR4XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbnZhciBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlciA9IGZ1bmN0aW9uICh0eCl7XG4gICAgaWYodHguYmxvY2tOdW1iZXIgIT09IG51bGwpXG4gICAgICAgIHR4LmJsb2NrTnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKHR4LmJsb2NrTnVtYmVyKTtcbiAgICBpZih0eC50cmFuc2FjdGlvbkluZGV4ICE9PSBudWxsKVxuICAgICAgICB0eC50cmFuc2FjdGlvbkluZGV4ID0gdXRpbHMudG9EZWNpbWFsKHR4LnRyYW5zYWN0aW9uSW5kZXgpO1xuICAgIHR4Lm5vbmNlID0gdXRpbHMudG9EZWNpbWFsKHR4Lm5vbmNlKTtcbiAgICB0eC5nYXMgPSB1dGlscy50b0RlY2ltYWwodHguZ2FzKTtcbiAgICB0eC5nYXNQcmljZSA9IHV0aWxzLnRvQmlnTnVtYmVyKHR4Lmdhc1ByaWNlKTtcbiAgICB0eC52YWx1ZSA9IHV0aWxzLnRvQmlnTnVtYmVyKHR4LnZhbHVlKTtcbiAgICByZXR1cm4gdHg7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIHRyYW5zYWN0aW9uIHJlY2VpcHQgdG8gaXRzIHByb3BlciB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kIG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHJlY2VpcHRcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4qL1xudmFyIG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlciA9IGZ1bmN0aW9uIChyZWNlaXB0KXtcbiAgICBpZihyZWNlaXB0LmJsb2NrTnVtYmVyICE9PSBudWxsKVxuICAgICAgICByZWNlaXB0LmJsb2NrTnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKHJlY2VpcHQuYmxvY2tOdW1iZXIpO1xuICAgIGlmKHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCAhPT0gbnVsbClcbiAgICAgICAgcmVjZWlwdC50cmFuc2FjdGlvbkluZGV4ID0gdXRpbHMudG9EZWNpbWFsKHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCk7XG4gICAgcmVjZWlwdC5jdW11bGF0aXZlR2FzVXNlZCA9IHV0aWxzLnRvRGVjaW1hbChyZWNlaXB0LmN1bXVsYXRpdmVHYXNVc2VkKTtcbiAgICByZWNlaXB0Lmdhc1VzZWQgPSB1dGlscy50b0RlY2ltYWwocmVjZWlwdC5nYXNVc2VkKTtcblxuICAgIGlmKHV0aWxzLmlzQXJyYXkocmVjZWlwdC5sb2dzKSkge1xuICAgICAgICByZWNlaXB0LmxvZ3MgPSByZWNlaXB0LmxvZ3MubWFwKGZ1bmN0aW9uKGxvZyl7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TG9nRm9ybWF0dGVyKGxvZyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZWNlaXB0O1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSBibG9jayB0byBpdHMgcHJvcGVyIHZhbHVlc1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBibG9ja1xuICogQHJldHVybnMge09iamVjdH1cbiovXG52YXIgb3V0cHV0QmxvY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihibG9jaykge1xuXG4gICAgLy8gdHJhbnNmb3JtIHRvIG51bWJlclxuICAgIGJsb2NrLmdhc0xpbWl0ID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLmdhc0xpbWl0KTtcbiAgICBibG9jay5nYXNVc2VkID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLmdhc1VzZWQpO1xuICAgIGJsb2NrLnNpemUgPSB1dGlscy50b0RlY2ltYWwoYmxvY2suc2l6ZSk7XG4gICAgYmxvY2sudGltZXN0YW1wID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLnRpbWVzdGFtcCk7XG4gICAgaWYoYmxvY2subnVtYmVyICE9PSBudWxsKVxuICAgICAgICBibG9jay5udW1iZXIgPSB1dGlscy50b0RlY2ltYWwoYmxvY2subnVtYmVyKTtcblxuICAgIGJsb2NrLmRpZmZpY3VsdHkgPSB1dGlscy50b0JpZ051bWJlcihibG9jay5kaWZmaWN1bHR5KTtcbiAgICBibG9jay50b3RhbERpZmZpY3VsdHkgPSB1dGlscy50b0JpZ051bWJlcihibG9jay50b3RhbERpZmZpY3VsdHkpO1xuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoYmxvY2sudHJhbnNhY3Rpb25zKSkge1xuICAgICAgICBibG9jay50cmFuc2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgIGlmKCF1dGlscy5pc1N0cmluZyhpdGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBibG9jaztcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgbG9nXG4gKlxuICogQG1ldGhvZCBvdXRwdXRMb2dGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2cgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2dcbiovXG52YXIgb3V0cHV0TG9nRm9ybWF0dGVyID0gZnVuY3Rpb24obG9nKSB7XG4gICAgaWYobG9nLmJsb2NrTnVtYmVyKVxuICAgICAgICBsb2cuYmxvY2tOdW1iZXIgPSB1dGlscy50b0RlY2ltYWwobG9nLmJsb2NrTnVtYmVyKTtcbiAgICBpZihsb2cudHJhbnNhY3Rpb25JbmRleClcbiAgICAgICAgbG9nLnRyYW5zYWN0aW9uSW5kZXggPSB1dGlscy50b0RlY2ltYWwobG9nLnRyYW5zYWN0aW9uSW5kZXgpO1xuICAgIGlmKGxvZy5sb2dJbmRleClcbiAgICAgICAgbG9nLmxvZ0luZGV4ID0gdXRpbHMudG9EZWNpbWFsKGxvZy5sb2dJbmRleCk7XG5cbiAgICByZXR1cm4gbG9nO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBpbnB1dCBvZiBhIHdoaXNwZXIgcG9zdCBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0UG9zdEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH1cbiovXG52YXIgaW5wdXRQb3N0Rm9ybWF0dGVyID0gZnVuY3Rpb24ocG9zdCkge1xuXG4gICAgLy8gcG9zdC5wYXlsb2FkID0gdXRpbHMudG9IZXgocG9zdC5wYXlsb2FkKTtcbiAgICBwb3N0LnR0bCA9IHV0aWxzLmZyb21EZWNpbWFsKHBvc3QudHRsKTtcbiAgICBwb3N0LndvcmtUb1Byb3ZlID0gdXRpbHMuZnJvbURlY2ltYWwocG9zdC53b3JrVG9Qcm92ZSk7XG4gICAgcG9zdC5wcmlvcml0eSA9IHV0aWxzLmZyb21EZWNpbWFsKHBvc3QucHJpb3JpdHkpO1xuXG4gICAgLy8gZmFsbGJhY2tcbiAgICBpZiAoIXV0aWxzLmlzQXJyYXkocG9zdC50b3BpY3MpKSB7XG4gICAgICAgIHBvc3QudG9waWNzID0gcG9zdC50b3BpY3MgPyBbcG9zdC50b3BpY3NdIDogW107XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IHRoZSBmb2xsb3dpbmcgb3B0aW9uc1xuICAgIHBvc3QudG9waWNzID0gcG9zdC50b3BpY3MubWFwKGZ1bmN0aW9uKHRvcGljKXtcbiAgICAgICAgLy8gY29udmVydCBvbmx5IGlmIG5vdCBoZXhcbiAgICAgICAgcmV0dXJuICh0b3BpYy5pbmRleE9mKCcweCcpID09PSAwKSA/IHRvcGljIDogdXRpbHMuZnJvbVV0ZjgodG9waWMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvc3Q7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIHJlY2VpdmVkIHBvc3QgbWVzc2FnZVxuICpcbiAqIEBtZXRob2Qgb3V0cHV0UG9zdEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG52YXIgb3V0cHV0UG9zdEZvcm1hdHRlciA9IGZ1bmN0aW9uKHBvc3Qpe1xuXG4gICAgcG9zdC5leHBpcnkgPSB1dGlscy50b0RlY2ltYWwocG9zdC5leHBpcnkpO1xuICAgIHBvc3Quc2VudCA9IHV0aWxzLnRvRGVjaW1hbChwb3N0LnNlbnQpO1xuICAgIHBvc3QudHRsID0gdXRpbHMudG9EZWNpbWFsKHBvc3QudHRsKTtcbiAgICBwb3N0LndvcmtQcm92ZWQgPSB1dGlscy50b0RlY2ltYWwocG9zdC53b3JrUHJvdmVkKTtcbiAgICAvLyBwb3N0LnBheWxvYWRSYXcgPSBwb3N0LnBheWxvYWQ7XG4gICAgLy8gcG9zdC5wYXlsb2FkID0gdXRpbHMudG9Bc2NpaShwb3N0LnBheWxvYWQpO1xuXG4gICAgLy8gaWYgKHV0aWxzLmlzSnNvbihwb3N0LnBheWxvYWQpKSB7XG4gICAgLy8gICAgIHBvc3QucGF5bG9hZCA9IEpTT04ucGFyc2UocG9zdC5wYXlsb2FkKTtcbiAgICAvLyB9XG5cbiAgICAvLyBmb3JtYXQgdGhlIGZvbGxvd2luZyBvcHRpb25zXG4gICAgaWYgKCFwb3N0LnRvcGljcykge1xuICAgICAgICBwb3N0LnRvcGljcyA9IFtdO1xuICAgIH1cbiAgICBwb3N0LnRvcGljcyA9IHBvc3QudG9waWNzLm1hcChmdW5jdGlvbih0b3BpYyl7XG4gICAgICAgIHJldHVybiB1dGlscy50b0FzY2lpKHRvcGljKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwb3N0O1xufTtcblxudmFyIGlucHV0QWRkcmVzc0Zvcm1hdHRlciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgdmFyIGliYW4gPSBuZXcgSWJhbihhZGRyZXNzKTtcbiAgICBpZiAoaWJhbi5pc1ZhbGlkKCkgJiYgaWJhbi5pc0RpcmVjdCgpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgaWJhbi5hZGRyZXNzKCk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmljdEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBhZGRyZXNzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcmVzcycpO1xufTtcblxuXG52YXIgb3V0cHV0U3luY2luZ0Zvcm1hdHRlciA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnN0YXJ0aW5nQmxvY2sgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0LnN0YXJ0aW5nQmxvY2spO1xuICAgIHJlc3VsdC5jdXJyZW50QmxvY2sgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0LmN1cnJlbnRCbG9jayk7XG4gICAgcmVzdWx0LmhpZ2hlc3RCbG9jayA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQuaGlnaGVzdEJsb2NrKTtcbiAgICBpZiAocmVzdWx0Lmtub3duU3RhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5rbm93blN0YXRlcyA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQua25vd25TdGF0ZXMpO1xuICAgICAgICByZXN1bHQucHVsbGVkU3RhdGVzID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5wdWxsZWRTdGF0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcjogaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsXG4gICAgaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcjogaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixcbiAgICBpbnB1dENhbGxGb3JtYXR0ZXI6IGlucHV0Q2FsbEZvcm1hdHRlcixcbiAgICBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOiBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLFxuICAgIGlucHV0QWRkcmVzc0Zvcm1hdHRlcjogaW5wdXRBZGRyZXNzRm9ybWF0dGVyLFxuICAgIGlucHV0UG9zdEZvcm1hdHRlcjogaW5wdXRQb3N0Rm9ybWF0dGVyLFxuICAgIG91dHB1dEJpZ051bWJlckZvcm1hdHRlcjogb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyLFxuICAgIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOiBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcixcbiAgICBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXI6IG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlcixcbiAgICBvdXRwdXRCbG9ja0Zvcm1hdHRlcjogb3V0cHV0QmxvY2tGb3JtYXR0ZXIsXG4gICAgb3V0cHV0TG9nRm9ybWF0dGVyOiBvdXRwdXRMb2dGb3JtYXR0ZXIsXG4gICAgb3V0cHV0UG9zdEZvcm1hdHRlcjogb3V0cHV0UG9zdEZvcm1hdHRlcixcbiAgICBvdXRwdXRTeW5jaW5nRm9ybWF0dGVyOiBvdXRwdXRTeW5jaW5nRm9ybWF0dGVyXG59O1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmdW5jdGlvbi5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNhbGwvc2VuZFRyYW5zYWN0aW9uIHRvIHNvbGlkaXR5IGZ1bmN0aW9uc1xuICovXG52YXIgU29saWRpdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIChldGgsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9ldGggPSBldGg7XG4gICAgdGhpcy5faW5wdXRUeXBlcyA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX291dHB1dFR5cGVzID0ganNvbi5vdXRwdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX2NvbnN0YW50ID0gKGpzb24uc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBqc29uLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIgfHwganNvbi5jb25zdGFudCk7XG4gICAgdGhpcy5fcGF5YWJsZSA9IChqc29uLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIgfHwganNvbi5wYXlhYmxlKTtcbiAgICB0aGlzLl9uYW1lID0gdXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqc29uKTtcbiAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbn07XG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gYXJncy5wb3AoKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4dHJhY3REZWZhdWx0QmxvY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoICYmICF1dGlscy5pc09iamVjdChhcmdzW2FyZ3MubGVuZ3RoIC0xXSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIoYXJncy5wb3AoKSk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgY29ycmVjdFxuICpcbiAqIEBtZXRob2QgdmFsaWRhdGVBcmdzXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBub3RcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRBcmdzID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgIC8vIGZpbHRlciB0aGUgb3B0aW9ucyBvYmplY3QgYnV0IG5vdCBhcmd1bWVudHMgdGhhdCBhcmUgYXJyYXlzXG4gICAgICByZXR1cm4gISggKHV0aWxzLmlzT2JqZWN0KGEpID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICh1dGlscy5pc0FycmF5KGEpID09PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgICAodXRpbHMuaXNCaWdOdW1iZXIoYSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICApO1xuICAgIH0pO1xuICAgIGlmIChpbnB1dEFyZ3MubGVuZ3RoICE9PSB0aGlzLl9pbnB1dFR5cGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZE51bWJlck9mU29saWRpdHlBcmdzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgcGF5bG9hZCBmcm9tIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBzb2xpZGl0eSBmdW5jdGlvbiBwYXJhbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25hbCBwYXlsb2FkIG9wdGlvbnNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudG9QYXlsb2FkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoICYmIHV0aWxzLmlzT2JqZWN0KGFyZ3NbYXJncy5sZW5ndGggLTFdKSkge1xuICAgICAgICBvcHRpb25zID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlQXJncyhhcmdzKTtcbiAgICBvcHRpb25zLnRvID0gdGhpcy5fYWRkcmVzcztcbiAgICBvcHRpb25zLmRhdGEgPSAnMHgnICsgdGhpcy5zaWduYXR1cmUoKSArIGNvZGVyLmVuY29kZVBhcmFtcyh0aGlzLl9pbnB1dFR5cGVzLCBhcmdzKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZ1bmN0aW9uIHNpZ25hdHVyZVxuICpcbiAqIEBtZXRob2Qgc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5zaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNoYTModGhpcy5fbmFtZSkuc2xpY2UoMCwgOCk7XG59O1xuXG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnVucGFja091dHB1dCA9IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3V0cHV0ID0gb3V0cHV0Lmxlbmd0aCA+PSAyID8gb3V0cHV0LnNsaWNlKDIpIDogb3V0cHV0O1xuICAgIHZhciByZXN1bHQgPSBjb2Rlci5kZWNvZGVQYXJhbXModGhpcy5fb3V0cHV0VHlwZXMsIG91dHB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgY29udHJhY3QgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBjYWxsXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gQ29udHJhY3QgZnVuY3Rpb24gYXJndW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBJZiB0aGUgbGFzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCB0aGUgY29udHJhY3QgZnVuY3Rpb25cbiAqICAgY2FsbCB3aWxsIGJlIGFzeW5jaHJvbm91cywgYW5kIHRoZSBjYWxsYmFjayB3aWxsIGJlIHBhc3NlZCB0aGVcbiAqICAgZXJyb3IgYW5kIHJlc3VsdC5cbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0IGJ5dGVzXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZpbHRlcihmdW5jdGlvbiAoYSkge3JldHVybiBhICE9PSB1bmRlZmluZWQ7IH0pO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBkZWZhdWx0QmxvY2sgPSB0aGlzLmV4dHJhY3REZWZhdWx0QmxvY2soYXJncyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcblxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fZXRoLmNhbGwocGF5bG9hZCwgZGVmYXVsdEJsb2NrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrT3V0cHV0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2V0aC5jYWxsKHBheWxvYWQsIGRlZmF1bHRCbG9jaywgZnVuY3Rpb24gKGVycm9yLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuXG4gICAgICAgIHZhciB1bnBhY2tlZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1bnBhY2tlZCA9IHNlbGYudW5wYWNrT3V0cHV0KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB1bnBhY2tlZCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHNlbmRUcmFuc2FjdGlvbiB0byBzb2xpZGl0eSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2Qgc2VuZFRyYW5zYWN0aW9uXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChhKSB7cmV0dXJuIGEgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcblxuICAgIGlmIChwYXlsb2FkLnZhbHVlID4gMCAmJiAhdGhpcy5fcGF5YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXRoLnNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKHBheWxvYWQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZXN0aW1hdGVHYXMgb2Ygc29saWRpdHkgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIGVzdGltYXRlR2FzXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmVzdGltYXRlR2FzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXRoLmVzdGltYXRlR2FzKHBheWxvYWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2V0aC5lc3RpbWF0ZUdhcyhwYXlsb2FkLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZW5jb2RlZCBkYXRhIG9mIHRoZSBjYWxsXG4gKlxuICogQG1ldGhvZCBnZXREYXRhXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBlbmNvZGVkIGRhdGFcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcblxuICAgIHJldHVybiBwYXlsb2FkLmRhdGE7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBmdW5jdGlvbiBkaXNwbGF5IG5hbWVcbiAqXG4gKiBAbWV0aG9kIGRpc3BsYXlOYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRpc3BsYXkgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmV4dHJhY3REaXNwbGF5TmFtZSh0aGlzLl9uYW1lKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZ1bmN0aW9uIHR5cGUgbmFtZVxuICpcbiAqIEBtZXRob2QgdHlwZU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdFR5cGVOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBycGMgcmVxdWVzdHMgZnJvbSBzb2xpZGl0eSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy51bnBhY2tPdXRwdXQuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZDogdGhpcy5fY29uc3RhbnQgPyAnZXRoX2NhbGwnIDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIHBhcmFtczogW3BheWxvYWRdLFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdFxuICAgIH07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZXhlY3V0ZSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgZXhlY3V0ZVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cmFuc2FjdGlvbiA9ICF0aGlzLl9jb25zdGFudDtcblxuICAgIC8vIHNlbmQgdHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIC8vIGNhbGxcbiAgICByZXR1cm4gdGhpcy5jYWxsLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGF0dGFjaCBmdW5jdGlvbiB0byBjb250cmFjdFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH1cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgZXhlY3V0ZS5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShleGVjdXRlLCAnY2FsbCcsIHRoaXMuY2FsbC5iaW5kKHRoaXMpKTtcclxuICAgIGV4ZWN1dGUuc2VuZFRyYW5zYWN0aW9uID0gdGhpcy5zZW5kVHJhbnNhY3Rpb24uYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmVzdGltYXRlR2FzID0gdGhpcy5lc3RpbWF0ZUdhcy5iaW5kKHRoaXMpO1xuICAgIGV4ZWN1dGUuZ2V0RGF0YSA9IHRoaXMuZ2V0RGF0YS5iaW5kKHRoaXMpO1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IHRoaXMuZGlzcGxheU5hbWUoKTtcbiAgICBpZiAoIWNvbnRyYWN0W2Rpc3BsYXlOYW1lXSkge1xuICAgICAgICBjb250cmFjdFtkaXNwbGF5TmFtZV0gPSBleGVjdXRlO1xuICAgIH1cbiAgICBjb250cmFjdFtkaXNwbGF5TmFtZV1bdGhpcy50eXBlTmFtZSgpXSA9IGV4ZWN1dGU7IC8vIGNpcmN1bGFyISEhIVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eUZ1bmN0aW9uO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBodHRwcHJvdmlkZXIuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqICAgTWFyaWFuIE9hbmNlYSA8bWFyaWFuQGV0aGRldi5jb20+XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vLyB3b3JrYXJvdW5kIHRvIHVzZSBodHRwcHJvdmlkZXIgaW4gZGlmZmVyZW50IGVudnNcblxuLy8gYnJvd3NlclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICBYTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDsgLy8ganNoaW50IGlnbm9yZTogbGluZVxuLy8gbm9kZVxufSBlbHNlIHtcbiAgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpLlhNTEh0dHBSZXF1ZXN0OyAvLyBqc2hpbnQgaWdub3JlOiBsaW5lXG59XG5cbnZhciBYSFIyID0gcmVxdWlyZSgneGhyMi1jb29raWVzJykuWE1MSHR0cFJlcXVlc3Q7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcblxuLyoqXG4gKiBIdHRwUHJvdmlkZXIgc2hvdWxkIGJlIHVzZWQgdG8gc2VuZCBycGMgY2FsbHMgb3ZlciBodHRwXG4gKi9cbnZhciBIdHRwUHJvdmlkZXIgPSBmdW5jdGlvbiAoaG9zdCwgdGltZW91dCwgdXNlciwgcGFzc3dvcmQsIGhlYWRlcnMpIHtcbiAgdGhpcy5ob3N0ID0gaG9zdCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JztcbiAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCAwO1xuICB0aGlzLnVzZXIgPSB1c2VyO1xuICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcHJlcGFyZSBuZXcgWE1MSHR0cFJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHByZXBhcmVSZXF1ZXN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUgaWYgcmVxdWVzdCBzaG91bGQgYmUgYXN5bmNcbiAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fSBvYmplY3RcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5wcmVwYXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChhc3luYykge1xuICB2YXIgcmVxdWVzdDtcblxuICBpZiAoYXN5bmMpIHtcbiAgICByZXF1ZXN0ID0gbmV3IFhIUjIoKTtcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG4gIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICByZXF1ZXN0Lm9wZW4oJ1BPU1QnLCB0aGlzLmhvc3QsIGFzeW5jKTtcbiAgaWYgKHRoaXMudXNlciAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgdmFyIGF1dGggPSAnQmFzaWMgJyArIG5ldyBCdWZmZXIodGhpcy51c2VyICsgJzonICsgdGhpcy5wYXNzd29yZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsIGF1dGgpO1xuICB9IHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgaWYodGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLm5hbWUsIGhlYWRlci52YWx1ZSk7XG4gICAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBtYWtlIHN5bmMgcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gKi9cbkh0dHBQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gIHZhciByZXF1ZXN0ID0gdGhpcy5wcmVwYXJlUmVxdWVzdChmYWxzZSk7XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0LnNlbmQoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBtYWtlIGFzeW5jIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHNlbmRBc3luY1xuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBlbmQgd2l0aCAoZXJyLCByZXN1bHQpXG4gKi9cbkh0dHBQcm92aWRlci5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24gKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0gdGhpcy5wcmVwYXJlUmVxdWVzdCh0cnVlKTtcblxuICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICYmIHJlcXVlc3QudGltZW91dCAhPT0gMSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICAgICAgdmFyIGVycm9yID0gbnVsbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvciA9IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25UaW1lb3V0KHRoaXMudGltZW91dCkpO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgcmVxdWVzdC5zZW5kKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3luY2hyb25vdXNseSB0cmllcyB0byBtYWtlIEh0dHAgcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgaXNDb25uZWN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiByZXF1ZXN0IGhhdmVuJ3QgZmFpbGVkLiBPdGhlcndpc2UgZmFsc2VcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLnNlbmQoe1xuICAgICAgaWQ6IDk5OTk5OTk5OTksXG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgIG1ldGhvZDogJ25ldF9saXN0ZW5pbmcnLFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBQcm92aWRlcjtcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBpYmFuLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxudmFyIHBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBieXRlcykge1xuICAgIHZhciByZXN1bHQgPSBzdHJpbmc7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBieXRlcyAqIDIpIHtcbiAgICAgICAgcmVzdWx0ID0gJzAnICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIGFuIElCQU4gZm9yIG1vZCA5NyBjb21wdXRhdGlvbiBieSBtb3ZpbmcgdGhlIGZpcnN0IDQgY2hhcnMgdG8gdGhlIGVuZCBhbmQgdHJhbnNmb3JtaW5nIHRoZSBsZXR0ZXJzIHRvXG4gKiBudW1iZXJzIChBID0gMTAsIEIgPSAxMSwgLi4uLCBaID0gMzUpLCBhcyBzcGVjaWZpZWQgaW4gSVNPMTM2MTYuXG4gKlxuICogQG1ldGhvZCBpc28xMzYxNlByZXBhcmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuIHRoZSBJQkFOXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcHJlcGFyZWQgSUJBTlxuICovXG52YXIgaXNvMTM2MTZQcmVwYXJlID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICB2YXIgQSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBaID0gJ1onLmNoYXJDb2RlQXQoMCk7XG5cbiAgICBpYmFuID0gaWJhbi50b1VwcGVyQ2FzZSgpO1xuICAgIGliYW4gPSBpYmFuLnN1YnN0cig0KSArIGliYW4uc3Vic3RyKDAsNCk7XG5cbiAgICByZXR1cm4gaWJhbi5zcGxpdCgnJykubWFwKGZ1bmN0aW9uKG4pe1xuICAgICAgICB2YXIgY29kZSA9IG4uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGNvZGUgPj0gQSAmJiBjb2RlIDw9IFope1xuICAgICAgICAgICAgLy8gQSA9IDEwLCBCID0gMTEsIC4uLiBaID0gMzVcbiAgICAgICAgICAgIHJldHVybiBjb2RlIC0gQSArIDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9KS5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgTU9EIDk3IDEwIG9mIHRoZSBwYXNzZWQgSUJBTiBhcyBzcGVjaWZpZWQgaW4gSVNPNzA2NC5cbiAqXG4gKiBAbWV0aG9kIG1vZDk3MTBcbiAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG52YXIgbW9kOTcxMCA9IGZ1bmN0aW9uIChpYmFuKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IGliYW4sXG4gICAgICAgIGJsb2NrO1xuXG4gICAgd2hpbGUgKHJlbWFpbmRlci5sZW5ndGggPiAyKXtcbiAgICAgICAgYmxvY2sgPSByZW1haW5kZXIuc2xpY2UoMCwgOSk7XG4gICAgICAgIHJlbWFpbmRlciA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIHJlbWFpbmRlci5zbGljZShibG9jay5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUludChyZW1haW5kZXIsIDEwKSAlIDk3O1xufTtcblxuLyoqXG4gKiBUaGlzIHByb3RvdHlwZSBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgaWJhbiBvYmplY3QgZnJvbSBpYmFuIGNvcnJlY3Qgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGliYW5cbiAqL1xudmFyIEliYW4gPSBmdW5jdGlvbiAoaWJhbikge1xuICAgIHRoaXMuX2liYW4gPSBpYmFuO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgaWJhbiBvYmplY3QgZnJvbSBldGhlcmV1bSBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBmcm9tQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0liYW59IHRoZSBJQkFOIG9iamVjdFxuICovXG5JYmFuLmZyb21BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgYXNCbiA9IG5ldyBCaWdOdW1iZXIoYWRkcmVzcywgMTYpO1xuICAgIHZhciBiYXNlMzYgPSBhc0JuLnRvU3RyaW5nKDM2KTtcbiAgICB2YXIgcGFkZGVkID0gcGFkTGVmdChiYXNlMzYsIDE1KTtcbiAgICByZXR1cm4gSWJhbi5mcm9tQmJhbihwYWRkZWQudG9VcHBlckNhc2UoKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhc3NlZCBCQkFOIHRvIGFuIElCQU4gZm9yIHRoaXMgY291bnRyeSBzcGVjaWZpY2F0aW9uLlxuICogUGxlYXNlIG5vdGUgdGhhdCA8aT5cImdlbmVyYXRpb24gb2YgdGhlIElCQU4gc2hhbGwgYmUgdGhlIGV4Y2x1c2l2ZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgYmFuay9icmFuY2ggc2VydmljaW5nIHRoZSBhY2NvdW50XCI8L2k+LlxuICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgcHJlZmVycmVkIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXIjR2VuZXJhdGluZ19JQkFOX2NoZWNrX2RpZ2l0c1xuICpcbiAqIEBtZXRob2QgZnJvbUJiYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYmFuIHRoZSBCQkFOIHRvIGNvbnZlcnQgdG8gSUJBTlxuICogQHJldHVybnMge0liYW59IHRoZSBJQkFOIG9iamVjdFxuICovXG5JYmFuLmZyb21CYmFuID0gZnVuY3Rpb24gKGJiYW4pIHtcbiAgICB2YXIgY291bnRyeUNvZGUgPSAnWEUnO1xuXG4gICAgdmFyIHJlbWFpbmRlciA9IG1vZDk3MTAoaXNvMTM2MTZQcmVwYXJlKGNvdW50cnlDb2RlICsgJzAwJyArIGJiYW4pKTtcbiAgICB2YXIgY2hlY2tEaWdpdCA9ICgnMCcgKyAoOTggLSByZW1haW5kZXIpKS5zbGljZSgtMik7XG5cbiAgICByZXR1cm4gbmV3IEliYW4oY291bnRyeUNvZGUgKyBjaGVja0RpZ2l0ICsgYmJhbik7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBJQkFOIG9iamVjdCBmb3IgZ2l2ZW4gaW5zdGl0dXRpb24gYW5kIGlkZW50aWZpZXJcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUluZGlyZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucywgcmVxdWlyZWQgb3B0aW9ucyBhcmUgXCJpbnN0aXR1dGlvblwiIGFuZCBcImlkZW50aWZpZXJcIlxuICogQHJldHVybiB7SWJhbn0gdGhlIElCQU4gb2JqZWN0XG4gKi9cbkliYW4uY3JlYXRlSW5kaXJlY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBJYmFuLmZyb21CYmFuKCdFVEgnICsgb3B0aW9ucy5pbnN0aXR1dGlvbiArIG9wdGlvbnMuaWRlbnRpZmllcik7XG59O1xuXG4vKipcbiAqIFRob3MgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNoZWNrIGlmIGdpdmVuIHN0cmluZyBpcyB2YWxpZCBpYmFuIG9iamVjdFxuICpcbiAqIEBtZXRob2QgaXNWYWxpZFxuICogQHBhcmFtIHtTdHJpbmd9IGliYW4gc3RyaW5nXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzIHZhbGlkIElCQU5cbiAqL1xuSWJhbi5pc1ZhbGlkID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICB2YXIgaSA9IG5ldyBJYmFuKGliYW4pO1xuICAgIHJldHVybiBpLmlzVmFsaWQoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIGlzIGNvcnJlY3RcbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuSWJhbi5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gL15YRVswLTldezJ9KEVUSFswLTlBLVpdezEzfXxbMC05QS1aXXszMCwzMX0pJC8udGVzdCh0aGlzLl9pYmFuKSAmJlxuICAgICAgICBtb2Q5NzEwKGlzbzEzNjE2UHJlcGFyZSh0aGlzLl9pYmFuKSkgPT09IDE7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgaWJhbiBudW1iZXIgaXMgZGlyZWN0XG4gKlxuICogQG1ldGhvZCBpc0RpcmVjdFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5JYmFuLnByb3RvdHlwZS5pc0RpcmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWJhbi5sZW5ndGggPT09IDM0IHx8IHRoaXMuX2liYW4ubGVuZ3RoID09PSAzNTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIG51bWJlciBpZiBpbmRpcmVjdFxuICpcbiAqIEBtZXRob2QgaXNJbmRpcmVjdFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5JYmFuLnByb3RvdHlwZS5pc0luZGlyZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pYmFuLmxlbmd0aCA9PT0gMjA7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGliYW4gY2hlY2tzdW1cbiAqIFVzZXMgdGhlIG1vZC05Ny0xMCBjaGVja3N1bW1pbmcgcHJvdG9jb2wgKElTTy9JRUMgNzA2NDoyMDAzKVxuICpcbiAqIEBtZXRob2QgY2hlY2tzdW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGNoZWNrc3VtXG4gKi9cbkliYW4ucHJvdG90eXBlLmNoZWNrc3VtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pYmFuLnN1YnN0cigyLCAyKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaW5zdGl0dXRpb24gaWRlbnRpZmllclxuICogZWcuIFhSRUdcbiAqXG4gKiBAbWV0aG9kIGluc3RpdHV0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBpbnN0aXR1dGlvbiBpZGVudGlmaWVyXG4gKi9cbkliYW4ucHJvdG90eXBlLmluc3RpdHV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5kaXJlY3QoKSA/IHRoaXMuX2liYW4uc3Vic3RyKDcsIDQpIDogJyc7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGNsaWVudCBpZGVudGlmaWVyIHdpdGhpbiBpbnN0aXR1dGlvblxuICogZWcuIEdBVk9GWU9SS1xuICpcbiAqIEBtZXRob2QgY2xpZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBjbGllbnQgaWRlbnRpZmllclxuICovXG5JYmFuLnByb3RvdHlwZS5jbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpID8gdGhpcy5faWJhbi5zdWJzdHIoMTEpIDogJyc7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGNsaWVudCBkaXJlY3QgYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgYWRkcmVzc1xuICogQHJldHVybnMge1N0cmluZ30gY2xpZW50IGRpcmVjdCBhZGRyZXNzXG4gKi9cbkliYW4ucHJvdG90eXBlLmFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXJlY3QoKSkge1xuICAgICAgICB2YXIgYmFzZTM2ID0gdGhpcy5faWJhbi5zdWJzdHIoNCk7XG4gICAgICAgIHZhciBhc0JuID0gbmV3IEJpZ051bWJlcihiYXNlMzYsIDM2KTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYXNCbi50b1N0cmluZygxNiksIDIwKTtcbiAgICB9IFxuXG4gICAgcmV0dXJuICcnO1xufTtcblxuSWJhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2liYW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEliYW47XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgaXBjcHJvdmlkZXIuanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbnZhciBJcGNQcm92aWRlciA9IGZ1bmN0aW9uIChwYXRoLCBuZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIFxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldC5jb25uZWN0KHtwYXRoOiB0aGlzLnBhdGh9KTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICAgICAgY29uc29sZS5lcnJvcignSVBDIENvbm5lY3Rpb24gRXJyb3InLCBlKTtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTsgXG5cblxuICAgIC8vIExJU1RFTiBGT1IgQ09OTkVDVElPTiBSRVNQT05TRVNcbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDYgKi9cblxuICAgICAgICBfdGhpcy5fcGFyc2VSZXNwb25zZShkYXRhLnRvU3RyaW5nKCkpLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0KXtcblxuICAgICAgICAgICAgdmFyIGlkID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBpZCB3aGljaCBtYXRjaGVzIHRoZSByZXR1cm5lZCBpZFxuICAgICAgICAgICAgaWYodXRpbHMuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24obG9hZCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2xvYWQuaWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBsb2FkLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3VsdC5pZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmKF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXShudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG5XaWxsIHBhcnNlIHRoZSByZXNwb25zZSBhbmQgbWFrZSBhbiBhcnJheSBvdXQgb2YgaXQuXG5cbkBtZXRob2QgX3BhcnNlUmVzcG9uc2VcbkBwYXJhbSB7U3RyaW5nfSBkYXRhXG4qL1xuSXBjUHJvdmlkZXIucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHJldHVyblZhbHVlcyA9IFtdO1xuICAgIFxuICAgIC8vIERFLUNIVU5LRVJcbiAgICB2YXIgZGVjaHVua2VkRGF0YSA9IGRhdGFcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcey9nLCd9fC0tfHsnKSAvLyB9e1xuICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFxbXFx7L2csJ31dfC0tfFt7JykgLy8gfV1be1xuICAgICAgICAucmVwbGFjZSgvXFx9W1xcblxccl0/XFxbXFx7L2csJ318LS18W3snKSAvLyB9W3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcey9nLCd9XXwtLXx7JykgLy8gfV17XG4gICAgICAgIC5zcGxpdCgnfC0tfCcpO1xuXG4gICAgZGVjaHVua2VkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpe1xuXG4gICAgICAgIC8vIHByZXBlbmQgdGhlIGxhc3QgY2h1bmtcbiAgICAgICAgaWYoX3RoaXMubGFzdENodW5rKVxuICAgICAgICAgICAgZGF0YSA9IF90aGlzLmxhc3RDaHVuayArIGRhdGE7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVuayA9IGRhdGE7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRpbWVvdXQgdG8gY2FuY2VsIGFsbCByZXF1ZXN0c1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMubGFzdENodW5rVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGltZW91dCgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgICAgICB9LCAxMDAwICogMTUpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYW5jZWwgdGltZW91dCBhbmQgc2V0IGNodW5rIHRvIG51bGxcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBudWxsO1xuXG4gICAgICAgIGlmKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVyblZhbHVlcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufTtcblxuXG4vKipcbkdldCB0aGUgYWRkcyBhIGNhbGxiYWNrIHRvIHRoZSByZXNwb25zZUNhbGxiYWNrcyBvYmplY3QsXG53aGljaCB3aWxsIGJlIGNhbGxlZCBpZiBhIHJlc3BvbnNlIG1hdGNoaW5nIHRoZSByZXNwb25zZSBJZCB3aWxsIGFycml2ZS5cblxuQG1ldGhvZCBfYWRkUmVzcG9uc2VDYWxsYmFja1xuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fYWRkUmVzcG9uc2VDYWxsYmFjayA9IGZ1bmN0aW9uKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gcGF5bG9hZC5pZCB8fCBwYXlsb2FkWzBdLmlkO1xuICAgIHZhciBtZXRob2QgPSBwYXlsb2FkLm1ldGhvZCB8fCBwYXlsb2FkWzBdLm1ldGhvZDtcblxuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0ubWV0aG9kID0gbWV0aG9kO1xufTtcblxuLyoqXG5UaW1lb3V0IGFsbCByZXF1ZXN0cyB3aGVuIHRoZSBlbmQvZXJyb3IgZXZlbnQgaXMgZmlyZWRcblxuQG1ldGhvZCBfdGltZW91dFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fdGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIga2V5IGluIHRoaXMucmVzcG9uc2VDYWxsYmFja3MpIHtcbiAgICAgICAgaWYodGhpcy5yZXNwb25zZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3Nba2V5XShlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24oJ29uIElQQycpKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpcyBzdGlsbCB2YWxpZC5cblxuQG1ldGhvZCBpc0Nvbm5lY3RlZFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyB0cnkgcmVjb25uZWN0LCB3aGVuIGNvbm5lY3Rpb24gaXMgZ29uZVxuICAgIGlmKCFfdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICBfdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IF90aGlzLnBhdGh9KTtcblxuICAgIHJldHVybiAhIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZTtcbn07XG5cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcblxuICAgIGlmKHRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB0cnkgcmVjb25uZWN0LCB3aGVuIGNvbm5lY3Rpb24gaXMgZ29uZVxuICAgICAgICBpZighdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IHRoaXMucGF0aH0pO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jb25uZWN0aW9uLndyaXRlU3luYyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShkYXRhKTsgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgdHJpZWQgdG8gc2VuZCBcIicrIHBheWxvYWQubWV0aG9kICsnXCIgc3luY2hyb25vdXNseS4gU3luY2hyb25vdXMgcmVxdWVzdHMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQQyBwcm92aWRlci4nKTtcbiAgICB9XG59O1xuXG5JcGNQcm92aWRlci5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24gKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICBpZighdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCh7cGF0aDogdGhpcy5wYXRofSk7XG5cblxuICAgIHRoaXMuY29ubmVjdGlvbi53cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgdGhpcy5fYWRkUmVzcG9uc2VDYWxsYmFjayhwYXlsb2FkLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElwY1Byb3ZpZGVyO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGpzb25ycGMuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqICAgQWFyb24gS3VtYXZpcyA8YWFyb25Aa3VtYXZpcy5tZT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG4vLyBJbml0aWFsaXplIEpzb25ycGMgYXMgYSBzaW1wbGUgb2JqZWN0IHdpdGggdXRpbGl0eSBmdW5jdGlvbnMuXG52YXIgSnNvbnJwYyA9IHtcbiAgICBtZXNzYWdlSWQ6IDBcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byB2YWxpZCBqc29uIGNyZWF0ZSBwYXlsb2FkIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2Qgb2YganNvbnJwYyBjYWxsLCByZXF1aXJlZFxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zLCBhbiBhcnJheSBvZiBtZXRob2QgcGFyYW1zLCBvcHRpb25hbFxuICogQHJldHVybnMge09iamVjdH0gdmFsaWQganNvbnJwYyBwYXlsb2FkIG9iamVjdFxuICovXG5Kc29ucnBjLnRvUGF5bG9hZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgIGlmICghbWV0aG9kKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdqc29ucnBjIG1ldGhvZCBzaG91bGQgYmUgc3BlY2lmaWVkIScpO1xuXG4gICAgLy8gYWR2YW5jZSBtZXNzYWdlIElEXG4gICAgSnNvbnJwYy5tZXNzYWdlSWQrKztcblxuICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogSnNvbnJwYy5tZXNzYWdlSWQsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXVxuICAgIH07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYganNvbnJwYyByZXNwb25zZSBpcyB2YWxpZFxuICpcbiAqIEBtZXRob2QgaXNWYWxpZFJlc3BvbnNlXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHJlc3BvbnNlIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXNwb25zZSkgPyByZXNwb25zZS5ldmVyeSh2YWxpZGF0ZVNpbmdsZU1lc3NhZ2UpIDogdmFsaWRhdGVTaW5nbGVNZXNzYWdlKHJlc3BvbnNlKTtcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2luZ2xlTWVzc2FnZShtZXNzYWdlKXtcbiAgICAgIHJldHVybiAhIW1lc3NhZ2UgJiZcbiAgICAgICAgIW1lc3NhZ2UuZXJyb3IgJiZcbiAgICAgICAgbWVzc2FnZS5qc29ucnBjID09PSAnMi4wJyAmJlxuICAgICAgICB0eXBlb2YgbWVzc2FnZS5pZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZDsgLy8gb25seSB1bmRlZmluZWQgaXMgbm90IHZhbGlkIGpzb24gb2JqZWN0XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBiYXRjaCBwYXlsb2FkIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdG9CYXRjaFBheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2VzLCBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggbWV0aG9kIChyZXF1aXJlZCkgYW5kIHBhcmFtcyAob3B0aW9uYWwpIGZpZWxkc1xuICogQHJldHVybnMge0FycmF5fSBiYXRjaCBwYXlsb2FkXG4gKi9cbkpzb25ycGMudG9CYXRjaFBheWxvYWQgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBKc29ucnBjLnRvUGF5bG9hZChtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZS5wYXJhbXMpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucnBjO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBtZXRob2QuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG52YXIgTWV0aG9kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5jYWxsID0gb3B0aW9ucy5jYWxsO1xuICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwgMDtcbiAgICB0aGlzLmlucHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLm91dHB1dEZvcm1hdHRlciA9IG9wdGlvbnMub3V0cHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBudWxsO1xufTtcblxuTWV0aG9kLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChybSkge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBybTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIG5hbWUgb2YgdGhlIGpzb25ycGMgbWV0aG9kIGJhc2VkIG9uIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgZ2V0Q2FsbFxuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG5hbWUgb2YganNvbnJwYyBtZXRob2RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5nZXRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNGdW5jdGlvbih0aGlzLmNhbGwpID8gdGhpcy5jYWxsKGFyZ3MpIDogdGhpcy5jYWxsO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBleHRyYWN0IGNhbGxiYWNrIGZyb20gYXJyYXkgb2YgYXJndW1lbnRzLiBNb2RpZmllcyBpbnB1dCBwYXJhbVxuICpcbiAqIEBtZXRob2QgZXh0cmFjdENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufE51bGx9IGNhbGxiYWNrLCBpZiBleGlzdHNcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MucG9wKCk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgY29ycmVjdFxuICogXG4gKiBAbWV0aG9kIHZhbGlkYXRlQXJnc1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgbm90XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IHRoaXMucGFyYW1zKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IGlucHV0IGFyZ3Mgb2YgbWV0aG9kXG4gKiBcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5mb3JtYXRJbnB1dCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKCF0aGlzLmlucHV0Rm9ybWF0dGVyKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyLm1hcChmdW5jdGlvbiAoZm9ybWF0dGVyLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyID8gZm9ybWF0dGVyKGFyZ3NbaW5kZXhdKSA6IGFyZ3NbaW5kZXhdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBvdXRwdXQocmVzdWx0KSBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciAmJiByZXN1bHQgPyB0aGlzLm91dHB1dEZvcm1hdHRlcihyZXN1bHQpIDogcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIHBheWxvYWQgZnJvbSBnaXZlbiBpbnB1dCBhcmdzXG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBjYWxsID0gdGhpcy5nZXRDYWxsKGFyZ3MpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmZvcm1hdElucHV0KGFyZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVBcmdzKHBhcmFtcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2Q6IGNhbGwsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xufTtcblxuTWV0aG9kLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuYnVpbGRDYWxsKCk7XG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jLCAnY2FsbCcsIHsgdmFsdWU6IHRoaXMuY2FsbCB9KVxyXG4gICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUuc3BsaXQoJy4nKTtcbiAgICBpZiAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIG9ialtuYW1lWzBdXSA9IG9ialtuYW1lWzBdXSB8fCB7fTtcbiAgICAgICAgb2JqW25hbWVbMF1dW25hbWVbMV1dID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbbmFtZVswXV0gPSBmdW5jOyBcbiAgICB9XG59O1xuXG5NZXRob2QucHJvdG90eXBlLmJ1aWxkQ2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzO1xuICAgIHZhciBzZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IG1ldGhvZC50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmRBc3luYyhwYXlsb2FkLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGxiYWNrKGVyciwgbWV0aG9kLmZvcm1hdE91dHB1dChyZXN1bHQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuZm9ybWF0T3V0cHV0KG1ldGhvZC5yZXF1ZXN0TWFuYWdlci5zZW5kKHBheWxvYWQpKTtcbiAgICB9O1xuICAgIHNlbmQucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBzZW5kO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBwdXJlIEpTT05SUEMgcmVxdWVzdCB3aGljaCBjYW4gYmUgdXNlZCBpbiBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcGFyYW0gey4uLn0gcGFyYW1zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb25ycGMgcmVxdWVzdFxuICovXG5NZXRob2QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICBwYXlsb2FkLmZvcm1hdCA9IHRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZDtcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgZGIuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZSgnLi4vbWV0aG9kJyk7XG5cbnZhciBEQiA9IGZ1bmN0aW9uICh3ZWIzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHsgXG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHdlYjMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn07XG5cbnZhciBtZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwdXRTdHJpbmcgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3B1dFN0cmluZycsXG4gICAgICAgIGNhbGw6ICdkYl9wdXRTdHJpbmcnLFxuICAgICAgICBwYXJhbXM6IDNcbiAgICB9KTtcblxuICAgIHZhciBnZXRTdHJpbmcgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFN0cmluZycsXG4gICAgICAgIGNhbGw6ICdkYl9nZXRTdHJpbmcnLFxuICAgICAgICBwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHZhciBwdXRIZXggPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3B1dEhleCcsXG4gICAgICAgIGNhbGw6ICdkYl9wdXRIZXgnLFxuICAgICAgICBwYXJhbXM6IDNcbiAgICB9KTtcblxuICAgIHZhciBnZXRIZXggPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldEhleCcsXG4gICAgICAgIGNhbGw6ICdkYl9nZXRIZXgnLFxuICAgICAgICBwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHB1dFN0cmluZywgZ2V0U3RyaW5nLCBwdXRIZXgsIGdldEhleFxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERCO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZXRoLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuLi9mb3JtYXR0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlscycpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcbnZhciBjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgQ29udHJhY3QgPSByZXF1aXJlKCcuLi9jb250cmFjdCcpO1xudmFyIHdhdGNoZXMgPSByZXF1aXJlKCcuL3dhdGNoZXMnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuLi9maWx0ZXInKTtcbnZhciBJc1N5bmNpbmcgPSByZXF1aXJlKCcuLi9zeW5jaW5nJyk7XG52YXIgbmFtZXJlZyA9IHJlcXVpcmUoJy4uL25hbWVyZWcnKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnLi4vaWJhbicpO1xudmFyIHRyYW5zZmVyID0gcmVxdWlyZSgnLi4vdHJhbnNmZXInKTtcblxudmFyIGJsb2NrQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiA6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIjtcbn07XG5cbnZhciB0cmFuc2FjdGlvbkZyb21CbG9ja0NhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JyA6ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgnO1xufTtcblxudmFyIHVuY2xlQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgnIDogJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc7XG59O1xuXG52YXIgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50Q2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnIDogJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic7XG59O1xuXG52YXIgdW5jbGVDb3VudENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tIYXNoJyA6ICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInO1xufTtcblxuZnVuY3Rpb24gRXRoKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcblxuICAgIHByb3BlcnRpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgcC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG5cblxuICAgIHRoaXMuaWJhbiA9IEliYW47XG4gICAgdGhpcy5zZW5kSUJBTlRyYW5zYWN0aW9uID0gdHJhbnNmZXIuYmluZChudWxsLCB0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0aC5wcm90b3R5cGUsICdkZWZhdWx0QmxvY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjLmRlZmF1bHRCbG9jaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBjLmRlZmF1bHRCbG9jayA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0aC5wcm90b3R5cGUsICdkZWZhdWx0QWNjb3VudCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGMuZGVmYXVsdEFjY291bnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgYy5kZWZhdWx0QWNjb3VudCA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdldEJhbGFuY2UgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldEJhbGFuY2UnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldEJhbGFuY2UnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0U3RvcmFnZUF0ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRTdG9yYWdlQXQnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCB1dGlscy50b0hleCwgZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBnZXRDb2RlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRDb2RlJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRDb2RlJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCbG9jaycsXG4gICAgICAgIGNhbGw6IGJsb2NrQ2FsbCxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciwgZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gISF2YWw7IH1dLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRVbmNsZSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VW5jbGUnLFxuICAgICAgICBjYWxsOiB1bmNsZUNhbGwsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsIHV0aWxzLnRvSGV4XSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyLFxuXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0Q29tcGlsZXJzID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRDb21waWxlcnMnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldENvbXBpbGVycycsXG4gICAgICAgIHBhcmFtczogMFxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgY2FsbDogZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50Q2FsbCxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0QmxvY2tVbmNsZUNvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCbG9ja1VuY2xlQ291bnQnLFxuICAgICAgICBjYWxsOiB1bmNsZUNvdW50Q2FsbCxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb25Gcm9tQmxvY2sgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uRnJvbUJsb2NrJyxcbiAgICAgICAgY2FsbDogdHJhbnNhY3Rpb25Gcm9tQmxvY2tDYWxsLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCB1dGlscy50b0hleF0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgIH0pO1xuXG4gICAgdmFyIGdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRUcmFuc2FjdGlvbkNvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIHNlbmRSYXdUcmFuc2FjdGlvbiA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgICAgICAgY2FsbDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzZW5kVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBzaWduVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2lnblRyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBzaWduID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduJyxcbiAgICAgICAgY2FsbDogJ2V0aF9zaWduJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGNhbGwgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2NhbGwnLFxuICAgICAgICBjYWxsOiAnZXRoX2NhbGwnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgZXN0aW1hdGVHYXMgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2VzdGltYXRlR2FzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0Q2FsbEZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgY29tcGlsZVNvbGlkaXR5ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLnNvbGlkaXR5JyxcbiAgICAgICAgY2FsbDogJ2V0aF9jb21waWxlU29saWRpdHknLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBjb21waWxlTExMID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLmxsbCcsXG4gICAgICAgIGNhbGw6ICdldGhfY29tcGlsZUxMTCcsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIGNvbXBpbGVTZXJwZW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLnNlcnBlbnQnLFxuICAgICAgICBjYWxsOiAnZXRoX2NvbXBpbGVTZXJwZW50JyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgc3VibWl0V29yayA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3VibWl0V29yaycsXG4gICAgICAgIGNhbGw6ICdldGhfc3VibWl0V29yaycsXG4gICAgICAgIHBhcmFtczogM1xuICAgIH0pO1xuXG4gICAgdmFyIGdldFdvcmsgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFdvcmsnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldFdvcmsnLFxuICAgICAgICBwYXJhbXM6IDBcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGdldEJhbGFuY2UsXG4gICAgICAgIGdldFN0b3JhZ2VBdCxcbiAgICAgICAgZ2V0Q29kZSxcbiAgICAgICAgZ2V0QmxvY2ssXG4gICAgICAgIGdldFVuY2xlLFxuICAgICAgICBnZXRDb21waWxlcnMsXG4gICAgICAgIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCxcbiAgICAgICAgZ2V0QmxvY2tVbmNsZUNvdW50LFxuICAgICAgICBnZXRUcmFuc2FjdGlvbixcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb25Gcm9tQmxvY2ssXG4gICAgICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdCxcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb25Db3VudCxcbiAgICAgICAgY2FsbCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHNlbmRSYXdUcmFuc2FjdGlvbixcbiAgICAgICAgc2lnblRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgIHNpZ24sXG4gICAgICAgIGNvbXBpbGVTb2xpZGl0eSxcbiAgICAgICAgY29tcGlsZUxMTCxcbiAgICAgICAgY29tcGlsZVNlcnBlbnQsXG4gICAgICAgIHN1Ym1pdFdvcmssXG4gICAgICAgIGdldFdvcmtcbiAgICBdO1xufTtcblxuXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2NvaW5iYXNlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9jb2luYmFzZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbWluaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9taW5pbmcnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc2hyYXRlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9oYXNocmF0ZScsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdzeW5jaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9zeW5jaW5nJyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2dhc1ByaWNlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9nYXNQcmljZScsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2FjY291bnRzJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9hY2NvdW50cydcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnYmxvY2tOdW1iZXInLFxuICAgICAgICAgICAgZ2V0dGVyOiAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3Byb3RvY29sVmVyc2lvbicsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfcHJvdG9jb2xWZXJzaW9uJ1xuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5FdGgucHJvdG90eXBlLmNvbnRyYWN0ID0gZnVuY3Rpb24gKGFiaSkge1xuICAgIHZhciBmYWN0b3J5ID0gbmV3IENvbnRyYWN0KHRoaXMsIGFiaSk7XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5FdGgucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIob3B0aW9ucywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXJzLm91dHB1dExvZ0Zvcm1hdHRlciwgY2FsbGJhY2ssIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjayk7XG59O1xuXG5FdGgucHJvdG90eXBlLm5hbWVyZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QobmFtZXJlZy5nbG9iYWwuYWJpKS5hdChuYW1lcmVnLmdsb2JhbC5hZGRyZXNzKTtcbn07XG5cbkV0aC5wcm90b3R5cGUuaWNhcE5hbWVyZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QobmFtZXJlZy5pY2FwLmFiaSkuYXQobmFtZXJlZy5pY2FwLmFkZHJlc3MpO1xufTtcblxuRXRoLnByb3RvdHlwZS5pc1N5bmNpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IElzU3luY2luZyh0aGlzLl9yZXF1ZXN0TWFuYWdlciwgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdGg7XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuLi9wcm9wZXJ0eScpO1xuXG52YXIgTmV0ID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkgeyBcbiAgICAgICAgcC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgcC5zZXRSZXF1ZXN0TWFuYWdlcih3ZWIzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG59O1xuXG4vLy8gQHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIHdlYjMuZXRoIGFwaSBwcm9wZXJ0aWVzXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2xpc3RlbmluZycsXG4gICAgICAgICAgICBnZXR0ZXI6ICduZXRfbGlzdGVuaW5nJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdwZWVyQ291bnQnLFxuICAgICAgICAgICAgZ2V0dGVyOiAnbmV0X3BlZXJDb3VudCcsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldDtcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4uL2Zvcm1hdHRlcnMnKTtcblxuZnVuY3Rpb24gUGVyc29uYWwod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfbmV3QWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGltcG9ydFJhd0tleSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnaW1wb3J0UmF3S2V5Jyxcblx0XHRjYWxsOiAncGVyc29uYWxfaW1wb3J0UmF3S2V5Jyxcblx0XHRwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHZhciBzaWduID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduJyxcblx0XHRjYWxsOiAncGVyc29uYWxfc2lnbicsXG5cdFx0cGFyYW1zOiAzLFxuXHRcdGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgZWNSZWNvdmVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdlY1JlY292ZXInLFxuXHRcdGNhbGw6ICdwZXJzb25hbF9lY1JlY292ZXInLFxuXHRcdHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgdmFyIHVubG9ja0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VubG9ja0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfdW5sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzZW5kVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGxvY2tBY2NvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdsb2NrQWNjb3VudCcsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ld0FjY291bnQsXG4gICAgICAgIGltcG9ydFJhd0tleSxcbiAgICAgICAgdW5sb2NrQWNjb3VudCxcbiAgICAgICAgZWNSZWNvdmVyLFxuICAgICAgICBzaWduLFxuICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgIGxvY2tBY2NvdW50XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbGlzdEFjY291bnRzJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3BlcnNvbmFsX2xpc3RBY2NvdW50cydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnNvbmFsO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBzaGguanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoY29yZS5pbz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZSgnLi4vbWV0aG9kJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyJyk7XG52YXIgd2F0Y2hlcyA9IHJlcXVpcmUoJy4vd2F0Y2hlcycpO1xuXG52YXIgU2hoID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn07XG5cblNoaC5wcm90b3R5cGUubmV3TWVzc2FnZUZpbHRlciA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIob3B0aW9ucywgJ3NoaCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLnNoaCgpLCBudWxsLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKTtcbn07XG5cbnZhciBtZXRob2RzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3ZlcnNpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiAwXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmZvJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfaW5mbycsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3NldE1heE1lc3NhZ2VTaXplJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfc2V0TWF4TWVzc2FnZVNpemUnLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdzZXRNaW5Qb1cnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9zZXRNaW5Qb1cnLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdtYXJrVHJ1c3RlZFBlZXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9tYXJrVHJ1c3RlZFBlZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICduZXdLZXlQYWlyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfbmV3S2V5UGFpcicsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2FkZFByaXZhdGVLZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9hZGRQcml2YXRlS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZGVsZXRlS2V5UGFpcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2RlbGV0ZUtleVBhaXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdoYXNLZXlQYWlyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfaGFzS2V5UGFpcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFB1YmxpY0tleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldFB1YmxpY0tleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFByaXZhdGVLZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZXRQcml2YXRlS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnbmV3U3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfbmV3U3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnYWRkU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfYWRkU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2VuZXJhdGVTeW1LZXlGcm9tUGFzc3dvcmQnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCcsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc1N5bUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2hhc1N5bUtleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFN5bUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldFN5bUtleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2RlbGV0ZVN5bUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2RlbGV0ZVN5bUtleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIGFuZCB1bnN1YnNjcmliZSBtaXNzaW5nXG5cbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAncG9zdCcsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3Bvc3QnLFxuICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoaDtcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgYnp6LmpzXG4gKiBAYXV0aG9yIEFsZXggQmVyZWdzemFzemkgPGFsZXhAcnRmcy5odT5cbiAqIEBkYXRlIDIwMTZcbiAqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9ibG9iL3N3YXJtL2ludGVybmFsL3dlYjNleHQvd2ViM2V4dC5nbyNMMzNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcblxuZnVuY3Rpb24gU3dhcm0od2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJsb2NrTmV0d29ya1JlYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBjYWxsOiAnYnp6X2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzeW5jRW5hYmxlZCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3luY0VuYWJsZWQnLFxuICAgICAgICBjYWxsOiAnYnp6X3N5bmNFbmFibGVkJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgc3dhcEVuYWJsZWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3N3YXBFbmFibGVkJyxcbiAgICAgICAgY2FsbDogJ2J6el9zd2FwRW5hYmxlZCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGRvd25sb2FkID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdkb3dubG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfZG93bmxvYWQnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciB1cGxvYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VwbG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfdXBsb2FkJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcmV0cmlldmUgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3JldHJpZXZlJyxcbiAgICAgICAgY2FsbDogJ2J6el9yZXRyaWV2ZScsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIHN0b3JlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzdG9yZScsXG4gICAgICAgIGNhbGw6ICdienpfc3RvcmUnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBnZXQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldCcsXG4gICAgICAgIGNhbGw6ICdienpfZ2V0JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcHV0ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgICBjYWxsOiAnYnp6X3B1dCcsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIG1vZGlmeSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnbW9kaWZ5JyxcbiAgICAgICAgY2FsbDogJ2J6el9tb2RpZnknLFxuICAgICAgICBwYXJhbXM6IDQsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGJsb2NrTmV0d29ya1JlYWQsXG4gICAgICAgIHN5bmNFbmFibGVkLFxuICAgICAgICBzd2FwRW5hYmxlZCxcbiAgICAgICAgZG93bmxvYWQsXG4gICAgICAgIHVwbG9hZCxcbiAgICAgICAgcmV0cmlldmUsXG4gICAgICAgIHN0b3JlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHB1dCxcbiAgICAgICAgbW9kaWZ5XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaGl2ZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaGl2ZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaW5mbycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaW5mbydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN3YXJtO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSB3YXRjaGVzLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xuXG4vLy8gQHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIHdlYjMuZXRoLmZpbHRlciBhcGkgbWV0aG9kc1xudmFyIGV0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3RmlsdGVyQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciB0eXBlID0gYXJnc1swXTtcblxuICAgICAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbGF0ZXN0JzpcbiAgICAgICAgICAgICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZXRoX25ld0Jsb2NrRmlsdGVyJztcbiAgICAgICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICAgICAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdldGhfbmV3RmlsdGVyJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbmV3RmlsdGVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICduZXdGaWx0ZXInLFxuICAgICAgICBjYWxsOiBuZXdGaWx0ZXJDYWxsLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciB1bmluc3RhbGxGaWx0ZXIgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VuaW5zdGFsbEZpbHRlcicsXG4gICAgICAgIGNhbGw6ICdldGhfdW5pbnN0YWxsRmlsdGVyJyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0TG9ncyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0TG9ncycsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0RmlsdGVyTG9ncycsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIHBvbGwgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3BvbGwnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldEZpbHRlckNoYW5nZXMnLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ld0ZpbHRlcixcbiAgICAgICAgdW5pbnN0YWxsRmlsdGVyLFxuICAgICAgICBnZXRMb2dzLFxuICAgICAgICBwb2xsXG4gICAgXTtcbn07XG5cbi8vLyBAcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgd2ViMy5zaGgud2F0Y2ggYXBpIG1ldGhvZHNcbnZhciBzaGggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICduZXdGaWx0ZXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdNZXNzYWdlRmlsdGVyJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAndW5pbnN0YWxsRmlsdGVyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlTWVzc2FnZUZpbHRlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldExvZ3MnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZXRGaWx0ZXJNZXNzYWdlcycsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3BvbGwnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZXRGaWx0ZXJNZXNzYWdlcycsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXRoOiBldGgsXG4gICAgc2hoOiBzaGhcbn07XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBuYW1lcmVnLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBnbG9iYWxSZWdpc3RyYXJBYmkgPSByZXF1aXJlKCcuLi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb24nKTtcbnZhciBpY2FwUmVnaXN0cmFyQWJpPSByZXF1aXJlKCcuLi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uJyk7XG5cbnZhciBnbG9iYWxOYW1lcmVnQWRkcmVzcyA9ICcweGM2ZDlkMmNkNDQ5YTc1NGM0OTQyNjRlMTgwOWM1MGUzNGQ2NDU2MmInO1xudmFyIGljYXBOYW1lcmVnQWRkcmVzcyA9ICcweGExYTExMWJjMDc0YzljZmE3ODFmMGMzOGU2M2JkNTFjOTFiOGFmMDAnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnbG9iYWw6IHtcbiAgICAgICAgYWJpOiBnbG9iYWxSZWdpc3RyYXJBYmksXG4gICAgICAgIGFkZHJlc3M6IGdsb2JhbE5hbWVyZWdBZGRyZXNzXG4gICAgfSxcbiAgICBpY2FwOiB7XG4gICAgICAgIGFiaTogaWNhcFJlZ2lzdHJhckFiaSxcbiAgICAgICAgYWRkcmVzczogaWNhcE5hbWVyZWdBZGRyZXNzXG4gICAgfVxufTtcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgcHJvcGVydHkuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGZyb3plbWFuLmRlPlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xuXG52YXIgUHJvcGVydHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLmdldHRlciA9IG9wdGlvbnMuZ2V0dGVyO1xuICAgIHRoaXMuc2V0dGVyID0gb3B0aW9ucy5zZXR0ZXI7XG4gICAgdGhpcy5vdXRwdXRGb3JtYXR0ZXIgPSBvcHRpb25zLm91dHB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLmlucHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gbnVsbDtcbn07XG5cblByb3BlcnR5LnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChybSkge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBybTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgaW5wdXQgYXJncyBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0XG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5mb3JtYXRJbnB1dCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEZvcm1hdHRlciA/IHRoaXMuaW5wdXRGb3JtYXR0ZXIoYXJnKSA6IGFyZztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgb3V0cHV0KHJlc3VsdCkgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUuZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciAmJiByZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQgPyB0aGlzLm91dHB1dEZvcm1hdHRlcihyZXN1bHQpIDogcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBleHRyYWN0IGNhbGxiYWNrIGZyb20gYXJyYXkgb2YgYXJndW1lbnRzLiBNb2RpZmllcyBpbnB1dCBwYXJhbVxuICpcbiAqIEBtZXRob2QgZXh0cmFjdENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufE51bGx9IGNhbGxiYWNrLCBpZiBleGlzdHNcbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gYXJncy5wb3AoKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBTaG91bGQgYXR0YWNoIGZ1bmN0aW9uIHRvIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9PYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLmF0dGFjaFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBwcm90byA9IHtcbiAgICAgICAgZ2V0OiB0aGlzLmJ1aWxkR2V0KCksXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9O1xuXG4gICAgdmFyIG5hbWVzID0gdGhpcy5uYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1swXTtcbiAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBvYmpbbmFtZXNbMF1dID0gb2JqW25hbWVzWzBdXSB8fCB7fTtcbiAgICAgICAgb2JqID0gb2JqW25hbWVzWzBdXTtcbiAgICAgICAgbmFtZSA9IG5hbWVzWzFdO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHByb3RvKTtcbiAgICBvYmpbYXN5bmNHZXR0ZXJOYW1lKG5hbWUpXSA9IHRoaXMuYnVpbGRBc3luY0dldCgpO1xufTtcblxudmFyIGFzeW5jR2V0dGVyTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICdnZXQnICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG59O1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuYnVpbGRHZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkuZm9ybWF0T3V0cHV0KHByb3BlcnR5LnJlcXVlc3RNYW5hZ2VyLnNlbmQoe1xuICAgICAgICAgICAgbWV0aG9kOiBwcm9wZXJ0eS5nZXR0ZXJcbiAgICAgICAgfSkpO1xuICAgIH07XG59O1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuYnVpbGRBc3luY0dldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydHkgPSB0aGlzO1xuICAgIHZhciBnZXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcHJvcGVydHkucmVxdWVzdE1hbmFnZXIuc2VuZEFzeW5jKHtcbiAgICAgICAgICAgIG1ldGhvZDogcHJvcGVydHkuZ2V0dGVyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBwcm9wZXJ0eS5mb3JtYXRPdXRwdXQocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZ2V0LnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gZ2V0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBwdXJlIEpTT05SUEMgcmVxdWVzdCB3aGljaCBjYW4gYmUgdXNlZCBpbiBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcGFyYW0gey4uLn0gcGFyYW1zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb25ycGMgcmVxdWVzdFxuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLmdldHRlcixcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgY2FsbGJhY2s6IHRoaXMuZXh0cmFjdENhbGxiYWNrKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgfTtcbiAgICBwYXlsb2FkLmZvcm1hdCA9IHRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BlcnR5O1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgcmVxdWVzdG1hbmFnZXIuanNcbiAqIEBhdXRob3IgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAYXV0aG9yIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgSnNvbnJwYyA9IHJlcXVpcmUoJy4vanNvbnJwYycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjID0gcmVxdWlyZSgnLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuLyoqXG4gKiBJdCdzIHJlc3BvbnNpYmxlIGZvciBwYXNzaW5nIG1lc3NhZ2VzIHRvIHByb3ZpZGVyc1xuICogSXQncyBhbHNvIHJlc3BvbnNpYmxlIGZvciBwb2xsaW5nIHRoZSBldGhlcmV1bSBub2RlIGZvciBpbmNvbWluZyBtZXNzYWdlc1xuICogRGVmYXVsdCBwb2xsIHRpbWVvdXQgaXMgMSBzZWNvbmRcbiAqIFNpbmdsZXRvblxuICovXG52YXIgUmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5wb2xscyA9IHt9O1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN5bmNocm9ub3VzbHkgc2VuZCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvUGF5bG9hZChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnByb3ZpZGVyLnNlbmQocGF5bG9hZCk7XG5cbiAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBhc3luY2hyb25vdXNseSBzZW5kIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHNlbmRBc3luY1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUHJvdmlkZXIoKSk7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvUGF5bG9hZChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFzeW5jaHJvbm91c2x5IHNlbmQgYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZEJhdGNoXG4gKiBAcGFyYW0ge0FycmF5fSBiYXRjaCBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZEJhdGNoID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgIH1cblxuICAgIHZhciBwYXlsb2FkID0gSnNvbnJwYy50b0JhdGNoUGF5bG9hZChkYXRhKTtcblxuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgfSk7IFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBzZXQgcHJvdmlkZXIgb2YgcmVxdWVzdCBtYW5hZ2VyXG4gKlxuICogQG1ldGhvZCBzZXRQcm92aWRlclxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZXRQcm92aWRlciA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdGhpcy5wcm92aWRlciA9IHA7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN0YXJ0IHBvbGxpbmdcbiAqXG4gKiBAbWV0aG9kIHN0YXJ0UG9sbGluZ1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb2xsSWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1bmluc3RhbGxcbiAqXG4gKiBAdG9kbyBjbGVhbnVwIG51bWJlciBvZiBwYXJhbXNcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChkYXRhLCBwb2xsSWQsIGNhbGxiYWNrLCB1bmluc3RhbGwpIHtcbiAgICB0aGlzLnBvbGxzW3BvbGxJZF0gPSB7ZGF0YTogZGF0YSwgaWQ6IHBvbGxJZCwgY2FsbGJhY2s6IGNhbGxiYWNrLCB1bmluc3RhbGw6IHVuaW5zdGFsbH07XG5cblxuICAgIC8vIHN0YXJ0IHBvbGxpbmdcbiAgICBpZiAoIXRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN0b3AgcG9sbGluZyBmb3IgZmlsdGVyIHdpdGggZ2l2ZW4gaWRcbiAqXG4gKiBAbWV0aG9kIHN0b3BQb2xsaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gcG9sbElkXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSWQpIHtcbiAgICBkZWxldGUgdGhpcy5wb2xsc1twb2xsSWRdO1xuXG4gICAgLy8gc3RvcCBwb2xsaW5nXG4gICAgaWYoT2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoID09PSAwICYmIHRoaXMudGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcmVzZXQgdGhlIHBvbGxpbmcgbWVjaGFuaXNtIG9mIHRoZSByZXF1ZXN0IG1hbmFnZXJcbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChrZWVwSXNTeW5jaW5nKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wb2xscykge1xuICAgICAgICAvLyByZW1vdmUgYWxsIHBvbGxzLCBleGNlcHQgc3luYyBwb2xscyxcbiAgICAgICAgLy8gdGhleSBuZWVkIHRvIGJlIHJlbW92ZWQgbWFudWFsbHkgYnkgY2FsbGluZyBzeW5jaW5nLnN0b3BXYXRjaGluZygpXG4gICAgICAgIGlmKCFrZWVwSXNTeW5jaW5nIHx8IGtleS5pbmRleE9mKCdzeW5jUG9sbF8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9sbHNba2V5XS51bmluc3RhbGwoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvbGxzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdG9wIHBvbGxpbmdcbiAgICBpZihPYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGggPT09IDAgJiYgdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwb2xsIGZvciBjaGFuZ2VzIG9uIGZpbHRlciB3aXRoIGdpdmVuIGlkXG4gKlxuICogQG1ldGhvZCBwb2xsXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDYgKi9cbiAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucG9sbC5iaW5kKHRoaXMpLCBjLkVUSF9QT0xMSU5HX1RJTUVPVVQpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2xsc0RhdGEgPSBbXTtcbiAgICB2YXIgcG9sbHNJZHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wb2xscykge1xuICAgICAgICBwb2xsc0RhdGEucHVzaCh0aGlzLnBvbGxzW2tleV0uZGF0YSk7XG4gICAgICAgIHBvbGxzSWRzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAocG9sbHNEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvQmF0Y2hQYXlsb2FkKHBvbGxzRGF0YSk7XG4gICAgXG4gICAgLy8gbWFwIHRoZSByZXF1ZXN0IGlkIHRvIHRoZXkgcG9sbCBpZFxuICAgIHZhciBwb2xsc0lkTWFwID0ge307XG4gICAgcGF5bG9hZC5mb3JFYWNoKGZ1bmN0aW9uKGxvYWQsIGluZGV4KXtcbiAgICAgICAgcG9sbHNJZE1hcFtsb2FkLmlkXSA9IHBvbGxzSWRzW2luZGV4XTtcbiAgICB9KTtcblxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0cykge1xuXG5cbiAgICAgICAgLy8gVE9ETzogY29uc29sZSBsb2c/XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHBvbGxzSWRNYXBbcmVzdWx0LmlkXTtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmaWx0ZXIgaXMgc3RpbGwgaW5zdGFsbGVkIGFmdGVyIGFycml2YWwgb2YgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGlmIChzZWxmLnBvbGxzW2lkXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayA9IHNlbGYucG9sbHNbaWRdLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7IFxuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0TWFuYWdlcjtcblxuIiwiXG5cbnZhciBTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRCbG9jayA9ICdsYXRlc3QnO1xuICAgIHRoaXMuZGVmYXVsdEFjY291bnQgPSB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdzO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIHN5bmNpbmcuanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxudmFyIGNvdW50ID0gMTtcblxuLyoqXG5BZGRzIHRoZSBjYWxsYmFjayBhbmQgc2V0cyB1cCB0aGUgbWV0aG9kcywgdG8gaXRlcmF0ZSBvdmVyIHRoZSByZXN1bHRzLlxuXG5AbWV0aG9kIHBvbGxTeW5jaW5nXG5AcGFyYW0ge09iamVjdH0gc2VsZlxuKi9cbnZhciBwb2xsU3luY2luZyA9IGZ1bmN0aW9uKHNlbGYpIHtcblxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyb3IsIHN5bmMpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHV0aWxzLmlzT2JqZWN0KHN5bmMpICYmIHN5bmMuc3RhcnRpbmdCbG9jaylcbiAgICAgICAgICAgIHN5bmMgPSBmb3JtYXR0ZXJzLm91dHB1dFN5bmNpbmdGb3JtYXR0ZXIoc3luYyk7XG5cbiAgICAgICAgc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxhc3RTeW5jU3RhdGUgIT09IHN5bmMpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRydWUgZmlyc3Qgc28gdGhlIGFwcCBjYW4gc3RvcCBhbnl0aGluZywgYmVmb3JlIHJlY2VpdmluZyB0aGUgc3luYyBkYXRhXG4gICAgICAgICAgICAgICAgaWYoIXNlbGYubGFzdFN5bmNTdGF0ZSAmJiB1dGlscy5pc09iamVjdChzeW5jKSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBvbiB0aGUgbmV4dCBDUFUgY3ljbGUsIHNvIHRoZSBhY3Rpb25zIG9mIHRoZSBzeW5jIHN0b3AgY2FuIGJlIHByb2Nlc3NlcyBmaXJzdFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN5bmMpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNlbGYubGFzdFN5bmNTdGF0ZSA9IHN5bmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzZWxmLnJlcXVlc3RNYW5hZ2VyLnN0YXJ0UG9sbGluZyh7XG4gICAgICAgIG1ldGhvZDogJ2V0aF9zeW5jaW5nJyxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICB9LCBzZWxmLnBvbGxJZCwgb25NZXNzYWdlLCBzZWxmLnN0b3BXYXRjaGluZy5iaW5kKHNlbGYpKTtcblxufTtcblxudmFyIElzU3luY2luZyA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5wb2xsSWQgPSAnc3luY1BvbGxfJysgY291bnQrKztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuYWRkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIHRoaXMubGFzdFN5bmNTdGF0ZSA9IGZhbHNlO1xuICAgIHBvbGxTeW5jaW5nKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Jc1N5bmNpbmcucHJvdG90eXBlLmFkZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYoY2FsbGJhY2spXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuSXNTeW5jaW5nLnByb3RvdHlwZS5zdG9wV2F0Y2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5zdG9wUG9sbGluZyh0aGlzLnBvbGxJZCk7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXNTeW5jaW5nO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgdHJhbnNmZXIuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEliYW4gPSByZXF1aXJlKCcuL2liYW4nKTtcbnZhciBleGNoYW5nZUFiaSA9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb24nKTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBtYWtlIEliYW4gdHJhbnNmZXJcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvIGliYW5cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5mZXJlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2ssIGNhbGxiYWNrXG4gKi9cbnZhciB0cmFuc2ZlciA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKHRvKTsgXG4gICAgaWYgKCFpYmFuLmlzVmFsaWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaWJhbiBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKGliYW4uaXNEaXJlY3QoKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmZXJUb0FkZHJlc3MoZXRoLCBmcm9tLCBpYmFuLmFkZHJlc3MoKSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB2YXIgYWRkcmVzcyA9IGV0aC5pY2FwTmFtZXJlZygpLmFkZHIoaWJhbi5pbnN0aXR1dGlvbigpKTtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSk7XG4gICAgfVxuXG4gICAgZXRoLmljYXBOYW1lcmVnKCkuYWRkcihpYmFuLmluc3RpdHV0aW9uKCksIGZ1bmN0aW9uIChlcnIsIGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byB0cmFuc2ZlciBmdW5kcyB0byBjZXJ0YWluIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyVG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSB0byBiZSB0cmFuZmVyZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgdHJhbnNmZXJUb0FkZHJlc3MgPSBmdW5jdGlvbiAoZXRoLCBmcm9tLCB0bywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV0aC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICBhZGRyZXNzOiB0byxcbiAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXBvc2l0IGZ1bmRzIHRvIGdlbmVyaWMgRXhjaGFuZ2UgY29udHJhY3QgKG11c3QgaW1wbGVtZW50IGRlcG9zaXQoYnl0ZXMzMikgbWV0aG9kISlcbiAqXG4gKiBAbWV0aG9kIGRlcG9zaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5zZmVyZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGllbnQgdW5pcXVlIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgZGVwb3NpdCA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2xpZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBhYmkgPSBleGNoYW5nZUFiaTtcbiAgICByZXR1cm4gZXRoLmNvbnRyYWN0KGFiaSkuYXQodG8pLmRlcG9zaXQoY2xpZW50LCB7XG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmZXI7XG5cbiIsIi8qISBiaWdudW1iZXIuanMgdjIuMC43IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qcy9MSUNFTkNFICovXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKlxyXG4gICAgICBiaWdudW1iZXIuanMgdjIuMC43XHJcbiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gICAgICBDb3B5cmlnaHQgKGMpIDIwMTUgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICAgICAgTUlUIEV4cGF0IExpY2VuY2VcclxuICAgICovXHJcblxyXG5cclxuICAgIHZhciBCaWdOdW1iZXIsIGNyeXB0bywgcGFyc2VOdW1lcmljLFxyXG4gICAgICAgIGlzTnVtZXJpYyA9IC9eLT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgICAgICAgbm90Qm9vbCA9ICcgbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQnLFxyXG4gICAgICAgIHJvdW5kaW5nTW9kZSA9ICdyb3VuZGluZyBtb2RlJyxcclxuICAgICAgICB0b29NYW55RGlnaXRzID0gJ251bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzJyxcclxuICAgICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJyxcclxuICAgICAgICBCQVNFID0gMWUxNCxcclxuICAgICAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAgICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgICAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgICAgICAgKiB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24sIGJleW9uZCB3aGljaCBhblxyXG4gICAgICAgICAqIGV4Y2VwdGlvbiBpcyB0aHJvd24gKGlmIEVSUk9SUyBpcyB0cnVlKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFub3RoZXIoY29uZmlnT2JqKSB7XHJcbiAgICAgICAgdmFyIGRpdixcclxuXHJcbiAgICAgICAgICAgIC8vIGlkIHRyYWNrcyB0aGUgY2FsbGVyIGZ1bmN0aW9uLCBzbyBpdHMgbmFtZSBjYW4gYmUgaW5jbHVkZWQgaW4gZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgICAgICAgIGlkID0gMCxcclxuICAgICAgICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRElUQUJMRSBERUZBVUxUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuY29uZmlnLlxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgICAgICAgICAqIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgICAgICAgICogVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAgICAgICAgKiBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAgICAgICAgKiBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICAgICAgICogSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgICAgICAgICogSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAgICAgICAgKiBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgICAgICAgICAqIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICAgICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAgICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgICAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgQmlnTnVtYmVyIEVycm9ycyBhcmUgZXZlciB0aHJvd24uXHJcbiAgICAgICAgICAgIEVSUk9SUyA9IHRydWUsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRvIGludFZhbGlkYXRvck5vRXJyb3JzIGlmIEVSUk9SUyBpcyBmYWxzZS5cclxuICAgICAgICAgICAgaXNWYWxpZEludCA9IGludFZhbGlkYXRvcldpdGhFcnJvcnMsICAgICAvLyBpbnRWYWxpZGF0b3JXaXRoRXJyb3JzL2ludFZhbGlkYXRvck5vRXJyb3JzXHJcblxyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgICAgICAgICogVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgICAgICAgICAqIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICAgKiBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgICAgICAgICogICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgICAgICAgICAqIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgICAgICAgICogSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAqIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgICAgICAgICogICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgICAgICAgICAqIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgICAgICAgICAqIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIHRvUG93ZXIgb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDEwMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICAgICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgICAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwXHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgICAgICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygbi4gSW50ZWdlciwgMiB0byA2NCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQmlnTnVtYmVyKCBuLCBiICkge1xyXG4gICAgICAgICAgICB2YXIgYywgZSwgaSwgbnVtLCBsZW4sIHN0cixcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIHVzYWdlIHdpdGhvdXQgbmV3LlxyXG4gICAgICAgICAgICBpZiAoICEoIHggaW5zdGFuY2VvZiBCaWdOdW1iZXIgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAnQmlnTnVtYmVyKCkgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IG5ldzoge259J1xyXG4gICAgICAgICAgICAgICAgaWYgKEVSUk9SUykgcmFpc2UoIDI2LCAnY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IG5ldycsIG4gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCBuLCBiICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgYmFzZSBub3QgYW4gaW50ZWdlcjoge2J9J1xyXG4gICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIGJhc2Ugb3V0IG9mIHJhbmdlOiB7Yn0nXHJcbiAgICAgICAgICAgIGlmICggYiA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBiLCAyLCA2NCwgaWQsICdiYXNlJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIER1cGxpY2F0ZS5cclxuICAgICAgICAgICAgICAgIGlmICggbiBpbnN0YW5jZW9mIEJpZ051bWJlciApIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSBuLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5lID0gbi5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9ICggbiA9IG4uYyApID8gbi5zbGljZSgpIDogbjtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKCBudW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJyApICYmIG4gKiAwID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gMSAvIG4gPCAwID8gKCBuID0gLW4sIC0xICkgOiAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbiA9PT0gfn5uICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBlID0gMCwgaSA9IG47IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LmMgPSBbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gbiArICcnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFpc051bWVyaWMudGVzdCggc3RyID0gbiArICcnICkgKSByZXR1cm4gcGFyc2VOdW1lcmljKCB4LCBzdHIsIG51bSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/ICggc3RyID0gc3RyLnNsaWNlKDEpLCAtMSApIDogMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiIHwgMDtcclxuICAgICAgICAgICAgICAgIHN0ciA9IG4gKyAnJztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgcmV0dXJuIHZhbHVlIGlzIHJvdW5kZWQgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICAgICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgaWYgKCBiID09IDEwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKCBuIGluc3RhbmNlb2YgQmlnTnVtYmVyID8gbiA6IHN0ciApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCggeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgLy8gQW55IG51bWJlciBpbiBleHBvbmVudGlhbCBmb3JtIHdpbGwgZmFpbCBkdWUgdG8gdGhlIFtFZV1bKy1dLlxyXG4gICAgICAgICAgICAgICAgaWYgKCAoIG51bSA9IHR5cGVvZiBuID09ICdudW1iZXInICkgJiYgbiAqIDAgIT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAhKCBuZXcgUmVnRXhwKCAnXi0/JyArICggYyA9ICdbJyArIEFMUEhBQkVULnNsaWNlKCAwLCBiICkgKyAnXSsnICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBjICsgJyk/JCcsYiA8IDM3ID8gJ2knIDogJycgKSApLnRlc3Qoc3RyKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKCB4LCBzdHIsIG51bSwgYiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChudW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSAxIC8gbiA8IDAgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggRVJST1JTICYmIHN0ci5yZXBsYWNlKCAvXjBcXC4wKnxcXC4vLCAnJyApLmxlbmd0aCA+IDE1ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSggaWQsIHRvb01hbnlEaWdpdHMsIG4gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3RyID0gY29udmVydEJhc2UoIHN0ciwgMTAsIGIsIHgucyApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgICAgICBpZiAoICggZSA9IHN0ci5pbmRleE9mKCcuJykgKSA+IC0xICkgc3RyID0gc3RyLnJlcGxhY2UoICcuJywgJycgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgICAgIGlmICggKCBpID0gc3RyLnNlYXJjaCggL2UvaSApICkgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgICAgICAgIGlmICggZSA8IDAgKSBlID0gaTtcclxuICAgICAgICAgICAgICAgIGUgKz0gK3N0ci5zbGljZSggaSArIDEgKTtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoIDAsIGkgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrICk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7ICk7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggaSwgbGVuICsgMSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0cikge1xyXG4gICAgICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEaXNhbGxvdyBudW1iZXJzIHdpdGggb3ZlciAxNSBzaWduaWZpY2FudCBkaWdpdHMgaWYgbnVtYmVyIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG51bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICAgICAgICBpZiAoIG51bSAmJiBFUlJPUlMgJiYgbGVuID4gMTUgKSByYWlzZSggaWQsIHRvb01hbnlEaWdpdHMsIHgucyAqIG4gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBlID0gZSAtIGkgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICAgICAgICAgIGlmICggZSA+IE1BWF9FWFAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IE1JTl9FWFAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICBpID0gKCBlICsgMSApICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlIDwgMCApIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IGxlbiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCArc3RyLnNsaWNlKCAwLCBpICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmMucHVzaCggK3N0ci5zbGljZSggaSwgaSArPSBMT0dfQkFTRSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaS0tOyBzdHIgKz0gJzAnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jLnB1c2goICtzdHIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgICAgICBCaWdOdW1iZXIuYW5vdGhlciA9IGFub3RoZXI7XHJcblxyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICAgICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQWNjZXB0IGFuIG9iamVjdCBvciBhbiBhcmd1bWVudCBsaXN0LCB3aXRoIG9uZSBvciBtYW55IG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBvclxyXG4gICAgICAgICAqIHBhcmFtZXRlcnMgcmVzcGVjdGl2ZWx5OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICBERUNJTUFMX1BMQUNFUyAge251bWJlcn0gIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZVxyXG4gICAgICAgICAqICAgUk9VTkRJTkdfTU9ERSAgIHtudW1iZXJ9ICBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlXHJcbiAgICAgICAgICogICBFWFBPTkVOVElBTF9BVCAge251bWJlcnxudW1iZXJbXX0gIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbC4sIDAgdG8gTUFYIGluY2wuXVxyXG4gICAgICAgICAqICAgUkFOR0UgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsLiwgaW50ZWdlciAxIHRvIE1BWCBpbmNsLl1cclxuICAgICAgICAgKiAgIEVSUk9SUyAgICAgICAgICB7Ym9vbGVhbnxudW1iZXJ9ICAgdHJ1ZSwgZmFsc2UsIDEgb3IgMFxyXG4gICAgICAgICAqICAgQ1JZUFRPICAgICAgICAgIHtib29sZWFufG51bWJlcn0gICB0cnVlLCBmYWxzZSwgMSBvciAwXHJcbiAgICAgICAgICogICBNT0RVTE9fTU9ERSAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOSBpbmNsdXNpdmVcclxuICAgICAgICAgKiAgIFBPV19QUkVDSVNJT04gICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVggaW5jbHVzaXZlXHJcbiAgICAgICAgICogICBGT1JNQVQgICAgICAgICAge29iamVjdH0gICAgICAgICAgIFNlZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0XHJcbiAgICAgICAgICogICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRS5nLlxyXG4gICAgICAgICAqIEJpZ051bWJlci5jb25maWcoMjAsIDQpIGlzIGVxdWl2YWxlbnQgdG9cclxuICAgICAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIuY29uZmlnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdiwgcCxcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgciA9IHt9LFxyXG4gICAgICAgICAgICAgICAgYSA9IGFyZ3VtZW50cyxcclxuICAgICAgICAgICAgICAgIG8gPSBhWzBdLFxyXG4gICAgICAgICAgICAgICAgaGFzID0gbyAmJiB0eXBlb2YgbyA9PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgaWYgKCBvLmhhc093blByb3BlcnR5KHApICkgcmV0dXJuICggdiA9IG9bcF0gKSAhPSBudWxsOyB9XHJcbiAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyBpZiAoIGEubGVuZ3RoID4gaSApIHJldHVybiAoIHYgPSBhW2krK10gKSAhPSBudWxsOyB9O1xyXG5cclxuICAgICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgREVDSU1BTF9QTEFDRVMgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIERFQ0lNQUxfUExBQ0VTIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdERUNJTUFMX1BMQUNFUycgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdiB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IERFQ0lNQUxfUExBQ0VTO1xyXG5cclxuICAgICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUk9VTkRJTkdfTU9ERSBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUk9VTkRJTkdfTU9ERSBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnUk9VTkRJTkdfTU9ERScgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCA4LCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICBST1VORElOR19NT0RFID0gdiB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3IgW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIEVYUE9ORU5USUFMX0FUIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBFWFBPTkVOVElBTF9BVCBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnRVhQT05FTlRJQUxfQVQnICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpc0FycmF5KHYpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNWYWxpZEludCggdlswXSwgLU1BWCwgMCwgMiwgcCApICYmIGlzVmFsaWRJbnQoIHZbMV0sIDAsIE1BWCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpc1ZhbGlkSW50KCB2LCAtTUFYLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLSggVE9fRVhQX1BPUyA9ICggdiA8IDAgPyAtdiA6IHYgKSB8IDAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gWyBUT19FWFBfTkVHLCBUT19FWFBfUE9TIF07XHJcblxyXG4gICAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJBTkdFIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBSQU5HRSBjYW5ub3QgYmUgemVybzoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0Ugb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ1JBTkdFJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSh2KSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzVmFsaWRJbnQoIHZbMF0sIC1NQVgsIC0xLCAyLCBwICkgJiYgaXNWYWxpZEludCggdlsxXSwgMSwgTUFYLCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV0gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzVmFsaWRJbnQoIHYsIC1NQVgsIE1BWCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdiB8IDAgKSBNSU5fRVhQID0gLSggTUFYX0VYUCA9ICggdiA8IDAgPyAtdiA6IHYgKSB8IDAgKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChFUlJPUlMpIHJhaXNlKCAyLCBwICsgJyBjYW5ub3QgYmUgemVybycsIHYgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gWyBNSU5fRVhQLCBNQVhfRVhQIF07XHJcblxyXG4gICAgICAgICAgICAvLyBFUlJPUlMge2Jvb2xlYW58bnVtYmVyfSB0cnVlLCBmYWxzZSwgMSBvciAwLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVJST1JTIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0VSUk9SUycgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHYgPT09ICEhdiB8fCB2ID09PSAxIHx8IHYgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWRJbnQgPSAoIEVSUk9SUyA9ICEhdiApID8gaW50VmFsaWRhdG9yV2l0aEVycm9ycyA6IGludFZhbGlkYXRvck5vRXJyb3JzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZSggMiwgcCArIG5vdEJvb2wsIHYgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gRVJST1JTO1xyXG5cclxuICAgICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufG51bWJlcn0gdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIENSWVBUTyBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgY3J5cHRvIHVuYXZhaWxhYmxlOiB7Y3J5cHRvfSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnQ1JZUFRPJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdiA9PT0gISF2IHx8IHYgPT09IDEgfHwgdiA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBDUllQVE8gPSAhISggdiAmJiBjcnlwdG8gJiYgdHlwZW9mIGNyeXB0byA9PSAnb2JqZWN0JyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdiAmJiAhQ1JZUFRPICYmIEVSUk9SUyApIHJhaXNlKCAyLCAnY3J5cHRvIHVuYXZhaWxhYmxlJywgY3J5cHRvICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVSUk9SUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlKCAyLCBwICsgbm90Qm9vbCwgdiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBDUllQVE87XHJcblxyXG4gICAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgTU9EVUxPX01PREUgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIE1PRFVMT19NT0RFIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdNT0RVTE9fTU9ERScgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCA5LCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHYgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBNT0RVTE9fTU9ERTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUE9XX1BSRUNJU0lPTiBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUE9XX1BSRUNJU0lPTiBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnUE9XX1BSRUNJU0lPTicgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2IHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnRk9STUFUJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHYgPT0gJ29iamVjdCcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsIHAgKyAnIG5vdCBhbiBvYmplY3QnLCB2ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IEZPUk1BVDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heE9yTWluKCBhcmd1bWVudHMsIFAubHQgKTsgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4T3JNaW4oIGFyZ3VtZW50cywgUC5ndCApOyB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAncmFuZG9tKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3JhbmRvbSgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAncmFuZG9tKCkgY3J5cHRvIHVuYXZhaWxhYmxlOiB7Y3J5cHRvfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAgICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoIE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzICk7IH1cclxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRwID0gZHAgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMTQgKSA/IERFQ0lNQUxfUExBQ0VTIDogZHAgfCAwO1xyXG4gICAgICAgICAgICAgICAgayA9IG1hdGhjZWlsKCBkcCAvIExPR19CQVNFICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCBuZXcgVWludDMyQXJyYXkoIGsgKj0gMiApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBrOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA+PSA5ZTE1ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCBuZXcgVWludDMyQXJyYXkoMikgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMucHVzaCggdiAlIDFlMTQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyggayAqPSA3ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBrOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSAoICggYVtpXSAmIDMxICkgKiAweDEwMDAwMDAwMDAwMDAgKSArICggYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhW2kgKyAyXSAqIDB4MTAwMDAwMDAwICkgKyAoIGFbaSArIDNdICogMHgxMDAwMDAwICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhW2kgKyA0XSA8PCAxNiApICsgKCBhW2kgKyA1XSA8PCA4ICkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHYgPj0gOWUxNSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weSggYSwgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKCB2ICUgMWUxNCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDE0LCAnY3J5cHRvIHVuYXZhaWxhYmxlJywgY3J5cHRvICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbTogQ1JZUFRPIGlzIGZhbHNlIG9yIGNyeXB0byBpcyB1bmF2YWlsYWJsZSBhbmQgRVJST1JTIGlzIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGs7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2IDwgOWUxNSApIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgICAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBrICYmIGRwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgICAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKCBrIC8gdiApICogdjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbIGUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc2hpZnQoKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IExPR19CQVNFICkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICAgICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRCYXNlKCBzdHIsIGJhc2VPdXQsIGJhc2VJbiwgc2lnbiApIHtcclxuICAgICAgICAgICAgdmFyIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCAnLicgKSxcclxuICAgICAgICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGJhc2VJbiA8IDM3ICkgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICAgICAgaWYgKCBpID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSggJy4nLCAnJyApO1xyXG4gICAgICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgICAgICAgIHggPSB5LnBvdyggc3RyLmxlbmd0aCAtIGkgKTtcclxuICAgICAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuICAgICAgICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCggdG9GaXhlZFBvaW50KCBjb2VmZlRvU3RyaW5nKCB4LmMgKSwgeC5lICksIDEwLCBiYXNlT3V0ICk7XHJcbiAgICAgICAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuICAgICAgICAgICAgeGMgPSB0b0Jhc2VPdXQoIHN0ciwgYmFzZUluLCBiYXNlT3V0ICk7XHJcbiAgICAgICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKCA7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkgKTtcclxuICAgICAgICAgICAgaWYgKCAheGNbMF0gKSByZXR1cm4gJzAnO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpIDwgMCApIHtcclxuICAgICAgICAgICAgICAgIC0tZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICAgICAgICB4ID0gZGl2KCB4LCB5LCBkcCwgcm0sIGJhc2VPdXQgKTtcclxuICAgICAgICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgICAgIGkgPSB4Y1tkXTtcclxuICAgICAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHIgPSBybSA8IDQgPyAoIGkgIT0gbnVsbCB8fCByICkgJiYgKCBybSA9PSAwIHx8IHJtID09ICggeC5zIDwgMCA/IDMgOiAyICkgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKCBybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBybSA9PSAoIHgucyA8IDAgPyA4IDogNyApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGQgPCAxIHx8ICF4Y1swXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAxXi1kcCBvciAwLlxyXG4gICAgICAgICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludCggJzEnLCAtZHAgKSA6ICcwJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCAtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGMudW5zaGlmdCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBrID0geGMubGVuZ3RoOyAheGNbLS1rXTsgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoIHhjW2krK10gKSApO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICAgICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtdWx0aXBseSggeCwgaywgYmFzZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICAgICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggeCA9IHguc2xpY2UoKTsgaS0tOyApIHtcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICggKCBtICUgU1FSVF9CQVNFICkgKiBTUVJUX0JBU0UgKSArIGNhcnJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gKCB0ZW1wIC8gYmFzZSB8IDAgKSArICggbSAvIFNRUlRfQkFTRSB8IDAgKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgICAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNhcnJ5KSB4LnVuc2hpZnQoY2FycnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wYXJlKCBhLCBiLCBhTCwgYkwgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYUwgIT0gYkwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYVtpXSAhPSBiW2ldICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KCBhLCBiLCBhTCwgYmFzZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICAgICAgICAgIGZvciAoIDsgYUwtLTsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc2hpZnQoKSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggeCwgeSwgZHAsIHJtLCBiYXNlICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgICAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICggeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YyApID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICAgICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgICAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhYmFzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgICAgICAgICAgICBlID0gYml0Rmxvb3IoIHguZSAvIExPR19CQVNFICkgLSBiaXRGbG9vciggeS5lIC8gTE9HX0JBU0UgKTtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyB5Y1tpXSA9PSAoIHhjW2ldIHx8IDAgKTsgaSsrICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHljW2ldID4gKCB4Y1tpXSB8fCAwICkgKSBlLS07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggYmFzZSAvICggeWNbMF0gKyAxICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKCBiYXNlIC8gMiApIC0gMS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuID4gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWMgPSBtdWx0aXBseSggeWMsIG4sIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMgPSBtdWx0aXBseSggeGMsIG4sIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSB4Yy5zbGljZSggMCwgeUwgKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHl6LnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB5Y1sxXSA+PSBiYXNlIC8gMiApIHljMCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmICggYmFzZSA9PSAzICYmIHljMCA9PSAxICkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoIHljLCByZW0sIHlMLCByZW1MICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNtcCA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHlMICE9IHJlbUwgKSByZW0wID0gcmVtMCAqIGJhc2UgKyAoIHJlbVsxXSB8fCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggcmVtMCAvIHljMCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMS4gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdCAobilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAyLiBpZiBwcm9kdWN0ID4gcmVtYWluZGVyOiBwcm9kdWN0IC09IGRpdmlzb3IsIG4tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDMuIHJlbWFpbmRlciAtPSBwcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgNC4gaWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIgYXQgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDUuIGNvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgNi4gSWYgcmVtYWluZGVyID4gZGl2aXNvcjogcmVtYWluZGVyIC09IGRpdmlzb3IsIG4rK1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoIHljLCBuLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY29tcGFyZSggcHJvZCwgcmVtLCBwcm9kTCwgcmVtTCApID09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuID09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9kTCA8IHJlbUwgKSBwcm9kLnVuc2hpZnQoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KCByZW0sIHByb2QsIHJlbUwsIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY21wID09IC0xICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY29tcGFyZSggeWMsIHJlbSwgeUwsIHJlbUwgKSA8IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KCByZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjbXAgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVtWzBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IFsgeGNbeGldIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCAoIHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCApICYmIHMtLSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFxY1swXSApIHFjLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBiYXNlID09IEJBU0UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKysgKTtcclxuICAgICAgICAgICAgICAgICAgICByb3VuZCggcSwgZHAgKyAoIHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxICkgKyAxLCBybSwgbW9yZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIGlzIGEgQmlnTnVtYmVyLlxyXG4gICAgICAgICAqIGkgaXMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAgICAgKiBybSBpcyB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAgICAgKiBjYWxsZXIgaXMgY2FsbGVyIGlkOiB0b0V4cG9uZW50aWFsIDE5LCB0b0ZpeGVkIDIwLCB0b0Zvcm1hdCAyMSwgdG9QcmVjaXNpb24gMjQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0KCBuLCBpLCBybSwgY2FsbGVyICkge1xyXG4gICAgICAgICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgICAgICAgIHJtID0gcm0gIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBybSwgMCwgOCwgY2FsbGVyLCByb3VuZGluZ01vZGUgKVxyXG4gICAgICAgICAgICAgID8gcm0gfCAwIDogUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgICAgIGlmICggIW4uYyApIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICAgICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaSA9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyggbi5jICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBjYWxsZXIgPT0gMTkgfHwgY2FsbGVyID09IDI0ICYmIG5lIDw9IFRPX0VYUF9ORUdcclxuICAgICAgICAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKCBzdHIsIG5lIClcclxuICAgICAgICAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoIHN0ciwgbmUgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG4gPSByb3VuZCggbmV3IEJpZ051bWJlcihuKSwgaSwgcm0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xyXG4gICAgICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBjYWxsZXIgPT0gMTkgfHwgY2FsbGVyID09IDI0ICYmICggaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoIHN0ciwgZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludCggc3RyLCBlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGUgKyAxID4gbGVuICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIC0taSA+IDAgKSBmb3IgKCBzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGUgKyAxID09IGxlbiApIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGktLTsgc3RyICs9ICcwJyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgICAgICBmdW5jdGlvbiBtYXhPck1pbiggYXJncywgbWV0aG9kICkge1xyXG4gICAgICAgICAgICB2YXIgbSwgbixcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpc0FycmF5KCBhcmdzWzBdICkgKSBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoIGFyZ3NbMF0gKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgKytpIDwgYXJncy5sZW5ndGg7ICkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoIGFyZ3NbaV0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICAgICAgICAgIGlmICggIW4ucyApIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1ldGhvZC5jYWxsKCBtLCBuICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgbiBpcyBhbiBpbnRlZ2VyIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICAgICAgICogVXNlIGZvciBhcmd1bWVudCB2YWxpZGF0aW9uIHdoZW4gRVJST1JTIGlzIHRydWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaW50VmFsaWRhdG9yV2l0aEVycm9ycyggbiwgbWluLCBtYXgsIGNhbGxlciwgbmFtZSApIHtcclxuICAgICAgICAgICAgaWYgKCBuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPSB0cnVuY2F0ZShuKSApIHtcclxuICAgICAgICAgICAgICAgIHJhaXNlKCBjYWxsZXIsICggbmFtZSB8fCAnZGVjaW1hbCBwbGFjZXMnICkgK1xyXG4gICAgICAgICAgICAgICAgICAoIG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlJyA6ICcgbm90IGFuIGludGVnZXInICksIG4gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGlzZSggbiwgYywgZSApIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgICAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggOyAhY1stLWpdOyBjLnBvcCgpICk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgICBmb3IgKCBqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrICk7XHJcblxyXG4gICAgICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICAgICAgaWYgKCAoIGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSApID4gTUFYX0VYUCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBNSU5fRVhQICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICBuLmMgPSBbIG4uZSA9IDAgXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgICAgICAgICBuLmMgPSBjO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICAgICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKS9pLFxyXG4gICAgICAgICAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICAgICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgICAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB4LCBzdHIsIG51bSwgYiApIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBudW0gPyBzdHIgOiBzdHIucmVwbGFjZSggd2hpdGVzcGFjZU9yUGx1cywgJycgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgICAgICAgICBpZiAoIGlzSW5maW5pdHlPck5hTi50ZXN0KHMpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFudW0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBiYXNlUHJlZml4LCBmdW5jdGlvbiAoIG0sIHAxLCBwMiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSAoIHAyID0gcDIudG9Mb3dlckNhc2UoKSApID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBkb3RBZnRlciwgJyQxJyApLnJlcGxhY2UoIGRvdEJlZm9yZSwgJzAuJDEnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RyICE9IHMgKSByZXR1cm4gbmV3IEJpZ051bWJlciggcywgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBub3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCBpZCwgJ25vdCBhJyArICggYiA/ICcgYmFzZSAnICsgYiA6ICcnICkgKyAnIG51bWJlcicsIHN0ciApO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcblxyXG5cclxuICAgICAgICAvLyBUaHJvdyBhIEJpZ051bWJlciBFcnJvci5cclxuICAgICAgICBmdW5jdGlvbiByYWlzZSggY2FsbGVyLCBtc2csIHZhbCApIHtcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCBbXHJcbiAgICAgICAgICAgICAgICAnbmV3IEJpZ051bWJlcicsICAgICAvLyAwXHJcbiAgICAgICAgICAgICAgICAnY21wJywgICAgICAgICAgICAgICAvLyAxXHJcbiAgICAgICAgICAgICAgICAnY29uZmlnJywgICAgICAgICAgICAvLyAyXHJcbiAgICAgICAgICAgICAgICAnZGl2JywgICAgICAgICAgICAgICAvLyAzXHJcbiAgICAgICAgICAgICAgICAnZGl2VG9JbnQnLCAgICAgICAgICAvLyA0XHJcbiAgICAgICAgICAgICAgICAnZXEnLCAgICAgICAgICAgICAgICAvLyA1XHJcbiAgICAgICAgICAgICAgICAnZ3QnLCAgICAgICAgICAgICAgICAvLyA2XHJcbiAgICAgICAgICAgICAgICAnZ3RlJywgICAgICAgICAgICAgICAvLyA3XHJcbiAgICAgICAgICAgICAgICAnbHQnLCAgICAgICAgICAgICAgICAvLyA4XHJcbiAgICAgICAgICAgICAgICAnbHRlJywgICAgICAgICAgICAgICAvLyA5XHJcbiAgICAgICAgICAgICAgICAnbWludXMnLCAgICAgICAgICAgICAvLyAxMFxyXG4gICAgICAgICAgICAgICAgJ21vZCcsICAgICAgICAgICAgICAgLy8gMTFcclxuICAgICAgICAgICAgICAgICdwbHVzJywgICAgICAgICAgICAgIC8vIDEyXHJcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJywgICAgICAgICAvLyAxM1xyXG4gICAgICAgICAgICAgICAgJ3JhbmRvbScsICAgICAgICAgICAgLy8gMTRcclxuICAgICAgICAgICAgICAgICdyb3VuZCcsICAgICAgICAgICAgIC8vIDE1XHJcbiAgICAgICAgICAgICAgICAnc2hpZnQnLCAgICAgICAgICAgICAvLyAxNlxyXG4gICAgICAgICAgICAgICAgJ3RpbWVzJywgICAgICAgICAgICAgLy8gMTdcclxuICAgICAgICAgICAgICAgICd0b0RpZ2l0cycsICAgICAgICAgIC8vIDE4XHJcbiAgICAgICAgICAgICAgICAndG9FeHBvbmVudGlhbCcsICAgICAvLyAxOVxyXG4gICAgICAgICAgICAgICAgJ3RvRml4ZWQnLCAgICAgICAgICAgLy8gMjBcclxuICAgICAgICAgICAgICAgICd0b0Zvcm1hdCcsICAgICAgICAgIC8vIDIxXHJcbiAgICAgICAgICAgICAgICAndG9GcmFjdGlvbicsICAgICAgICAvLyAyMlxyXG4gICAgICAgICAgICAgICAgJ3BvdycsICAgICAgICAgICAgICAgLy8gMjNcclxuICAgICAgICAgICAgICAgICd0b1ByZWNpc2lvbicsICAgICAgIC8vIDI0XHJcbiAgICAgICAgICAgICAgICAndG9TdHJpbmcnLCAgICAgICAgICAvLyAyNVxyXG4gICAgICAgICAgICAgICAgJ0JpZ051bWJlcicgICAgICAgICAgLy8gMjZcclxuICAgICAgICAgICAgXVtjYWxsZXJdICsgJygpICcgKyBtc2cgKyAnOiAnICsgdmFsICk7XHJcblxyXG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ0JpZ051bWJlciBFcnJvcic7XHJcbiAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcm91bmQoIHgsIHNkLCBybSwgciApIHtcclxuICAgICAgICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgICAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgICAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKysgKTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB4Y1sgbmkgPSAwIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwWyBkIC0gaiAtIDEgXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaSA9IG1hdGhjZWlsKCAoIGkgKyAxICkgLyBMT0dfQkFTRSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuaSA+PSB4Yy5sZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbIGQgLSBqIC0gMSBdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwWyBkIC0gaiAtIDEgXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8ICggaiA8IDAgPyBuIDogbiAlIHBvd3MxMFsgZCAtIGogLSAxIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoIHJkIHx8IHIgKSAmJiAoIHJtID09IDAgfHwgcm0gPT0gKCB4LnMgPCAwID8gMyA6IDIgKSApXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmICggcm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggKCBpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFsgZCAtIGogXSA6IDAgOiB4Y1tuaSAtIDFdICkgJSAxMCApICYgMSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJtID09ICggeC5zIDwgMCA/IDggOiA3ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZCA8IDEgfHwgIXhjWzBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbIHNkICUgTE9HX0JBU0UgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBwb3dzMTBbIExPR19CQVNFIC0gaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IoIG4gLyBwb3dzMTBbIGQgLSBqIF0gJSBwb3dzMTBbal0gKSAqIGsgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuaSA9PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKysgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9IGsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHhjWzBdID09IEJBU0UgKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1tuaV0gIT0gQkFTRSApIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgaWYgKCB4LmUgPiBNQVhfRVhQICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeC5lIDwgTUlOX0VYUCApIHtcclxuICAgICAgICAgICAgICAgICAgICB4LmMgPSBbIHguZSA9IDAgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCB4LnMgPCAwICkgeC5zID0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhIHdob2xlXHJcbiAgICAgICAgICogbnVtYmVyIGluIHRoZSBkaXJlY3Rpb24gb2YgSW5maW5pdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5jZWlsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIG5ldyBCaWdOdW1iZXIodGhpcyksIHRoaXMuZSArIDEsIDIgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm5cclxuICAgICAgICAgKiAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAgICAgKiAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgICAgICogMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgICAgICogb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmNvbXBhcmVkVG8gPSBQLmNtcCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZVxyXG4gICAgICAgICAqIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuLCB2LFxyXG4gICAgICAgICAgICAgICAgYyA9IHRoaXMuYztcclxuXHJcbiAgICAgICAgICAgIGlmICggIWMgKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgbiA9ICggKCB2ID0gYy5sZW5ndGggLSAxICkgLSBiaXRGbG9vciggdGhpcy5lIC8gTE9HX0JBU0UgKSApICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgICAgICAgaWYgKCB2ID0gY1t2XSApIGZvciAoIDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSApO1xyXG4gICAgICAgICAgICBpZiAoIG4gPCAwICkgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgICAgICogIG4gLyBOID0gTlxyXG4gICAgICAgICAqICBuIC8gSSA9IDBcclxuICAgICAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgICAgICogIDAgLyAwID0gTlxyXG4gICAgICAgICAqICAwIC8gTiA9IE5cclxuICAgICAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgICAgICogIE4gLyBuID0gTlxyXG4gICAgICAgICAqICBOIC8gMCA9IE5cclxuICAgICAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgICAgICogIE4gLyBJID0gTlxyXG4gICAgICAgICAqICBJIC8gbiA9IElcclxuICAgICAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgICAgICogIEkgLyBOID0gTlxyXG4gICAgICAgICAqICBJIC8gSSA9IE5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDM7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuZGl2VG9JbnQgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gNDtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdiggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApLCAwLCAxICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5lcXVhbHMgPSBQLmVxID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDU7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA9PT0gMDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgd2hvbGVcclxuICAgICAgICAgKiBudW1iZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiAtSW5maW5pdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5mbG9vciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCBuZXcgQmlnTnVtYmVyKHRoaXMpLCB0aGlzLmUgKyAxLCAzICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZ3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDY7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA+IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZ3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA3O1xyXG4gICAgICAgICAgICByZXR1cm4gKCBiID0gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IoIHRoaXMuZSAvIExPR19CQVNFICkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMucztcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA4O1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgPCAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gOTtcclxuICAgICAgICAgICAgcmV0dXJuICggYiA9IGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApICkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIG4gLSAwID0gblxyXG4gICAgICAgICAqICBuIC0gTiA9IE5cclxuICAgICAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgICAgICogIDAgLSAwID0gMFxyXG4gICAgICAgICAqICAwIC0gTiA9IE5cclxuICAgICAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICAgICAqICBOIC0gbiA9IE5cclxuICAgICAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgICAgICogIE4gLSBOID0gTlxyXG4gICAgICAgICAqICBOIC0gSSA9IE5cclxuICAgICAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgICAgICogIEkgLSAwID0gSVxyXG4gICAgICAgICAqICBJIC0gTiA9IE5cclxuICAgICAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgICAgICAgIGlkID0gMTA7XHJcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XHJcbiAgICAgICAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgICAgICBpZiAoICFhIHx8ICFiICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICAgICAgaWYgKCBhICE9IGIgKSB7XHJcbiAgICAgICAgICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgICAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgICAgICBpZiAoICF4ZSB8fCAheWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljICkgcmV0dXJuIHhjID8gKCB5LnMgPSAtYiwgeSApIDogbmV3IEJpZ051bWJlciggeWMgPyB4IDogTmFOICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgICAgICAgICBpZiAoICF4Y1swXSB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5Y1swXSA/ICggeS5zID0gLWIsIHkgKSA6IG5ldyBCaWdOdW1iZXIoIHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICAgICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICAgICAgICBpZiAoIGEgPSB4ZSAtIHllICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggeExUeSA9IGEgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgICAgICAgICAgZm9yICggYiA9IGE7IGItLTsgdC5wdXNoKDApICk7XHJcbiAgICAgICAgICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgaiA9ICggeExUeSA9ICggYSA9IHhjLmxlbmd0aCApIDwgKCBiID0geWMubGVuZ3RoICkgKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIGEgPSBiID0gMDsgYiA8IGo7IGIrKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1tiXSAhPSB5Y1tiXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgICAgICAgYiA9ICggaiA9IHljLmxlbmd0aCApIC0gKCBpID0geGMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgICAgICAgaWYgKCBiID4gMCApIGZvciAoIDsgYi0tOyB4Y1tpKytdID0gMCApO1xyXG4gICAgICAgICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICAgICAgICBmb3IgKCA7IGogPiBhOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHhjWy0tal0gPCB5Y1tqXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICBmb3IgKCA7IHhjWzBdID09IDA7IHhjLnNoaWZ0KCksIC0teWUgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgICAgIGlmICggIXhjWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgICAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgeS5jID0gWyB5LmUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgICAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGlzZSggeSwgeGMsIHllICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZCA9IDExO1xyXG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlciggeSwgYiApO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgICAgICAgaWYgKCAheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICF5LmMgfHwgeC5jICYmICF4LmNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBNT0RVTE9fTU9ERSA9PSA5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgICAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgICAgICAgICBzID0geS5zO1xyXG4gICAgICAgICAgICAgICAgeS5zID0gMTtcclxuICAgICAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIDMgKTtcclxuICAgICAgICAgICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgICAgICAgICBxLnMgKj0gcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIE1PRFVMT19NT0RFICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4Lm1pbnVzKCBxLnRpbWVzKHkpICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgICAgICogIG4gKyBOID0gTlxyXG4gICAgICAgICAqICBuICsgSSA9IElcclxuICAgICAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgICAgICogIDAgKyAwID0gMFxyXG4gICAgICAgICAqICAwICsgTiA9IE5cclxuICAgICAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgICAgICogIE4gKyBuID0gTlxyXG4gICAgICAgICAqICBOICsgMCA9IE5cclxuICAgICAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgICAgICogIE4gKyBJID0gTlxyXG4gICAgICAgICAqICBJICsgbiA9IElcclxuICAgICAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgICAgICogIEkgKyBOID0gTlxyXG4gICAgICAgICAqICBJICsgSSA9IElcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgdCxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgICAgICAgIGlkID0gMTI7XHJcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XHJcbiAgICAgICAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgICAgICBpZiAoICFhIHx8ICFiICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICAgICAgIGlmICggYSAhPSBiICkge1xyXG4gICAgICAgICAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgICAgIGlmICggIXhlIHx8ICF5ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiBuZXcgQmlnTnVtYmVyKCBhIC8gMCApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICAgICAgICBpZiAoICF4Y1swXSB8fCAheWNbMF0gKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlciggeGNbMF0gPyB4IDogYSAqIDAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgICAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICAgICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgICAgICAgIGlmICggYSA9IHhlIC0geWUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGEgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICggOyBhLS07IHQucHVzaCgwKSApO1xyXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgICAgICAgIGlmICggYSAtIGIgPCAwICkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgICAgICAgIGZvciAoIGEgPSAwOyBiOyApIHtcclxuICAgICAgICAgICAgICAgIGEgPSAoIHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSApIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4Y1tiXSAlPSBCQVNFO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICAgICAgeGMudW5zaGlmdChhKTtcclxuICAgICAgICAgICAgICAgICsreWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB4YywgeWUgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW3pdIHtib29sZWFufG51bWJlcn0gV2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUsIGZhbHNlLCAxIG9yIDAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHopIHtcclxuICAgICAgICAgICAgdmFyIG4sIHYsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGMgPSB4LmM7XHJcblxyXG4gICAgICAgICAgICAvLyAncHJlY2lzaW9uKCkgYXJndW1lbnQgbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQ6IHt6fSdcclxuICAgICAgICAgICAgaWYgKCB6ICE9IG51bGwgJiYgeiAhPT0gISF6ICYmIHogIT09IDEgJiYgeiAhPT0gMCApIHtcclxuICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCAxMywgJ2FyZ3VtZW50JyArIG5vdEJvb2wsIHogKTtcclxuICAgICAgICAgICAgICAgIGlmICggeiAhPSAhIXogKSB6ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAhYyApIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdiA9IGNbdl0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgZm9yICggdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHogJiYgeC5lICsgMSA+IG4gKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mXHJcbiAgICAgICAgICogZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgdG8gMCBhbmQgUk9VTkRJTkdfTU9ERSByZXNwZWN0aXZlbHkgaWZcclxuICAgICAgICAgKiBvbWl0dGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICdyb3VuZCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAncm91bmQoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAgICAgKiAncm91bmQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICdyb3VuZCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAucm91bmQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkcCA9PSBudWxsIHx8IGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDE1ICkgKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCggbiwgfn5kcCArIHRoaXMuZSArIDEsIHJtID09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgIWlzVmFsaWRJbnQoIHJtLCAwLCA4LCAxNSwgcm91bmRpbmdNb2RlICkgPyBST1VORElOR19NT0RFIDogcm0gfCAwICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSWYgayBpcyBvdXQgb2YgcmFuZ2UgYW5kIEVSUk9SUyBpcyBmYWxzZSwgdGhlIHJlc3VsdCB3aWxsIGJlIMKxMCBpZiBrIDwgMCwgb3IgwrFJbmZpbml0eVxyXG4gICAgICAgICAqIG90aGVyd2lzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICdzaGlmdCgpIGFyZ3VtZW50IG5vdCBhbiBpbnRlZ2VyOiB7a30nXHJcbiAgICAgICAgICogJ3NoaWZ0KCkgYXJndW1lbnQgb3V0IG9mIHJhbmdlOiB7a30nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5zaGlmdCA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRJbnQoIGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSLCAxNiwgJ2FyZ3VtZW50JyApXHJcblxyXG4gICAgICAgICAgICAgIC8vIGsgPCAxZSsyMSwgb3IgdHJ1bmNhdGUoaykgd2lsbCBwcm9kdWNlIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAgID8gbi50aW1lcyggJzFlJyArIHRydW5jYXRlKGspIClcclxuICAgICAgICAgICAgICA6IG5ldyBCaWdOdW1iZXIoIG4uYyAmJiBuLmNbMF0gJiYgKCBrIDwgLU1BWF9TQUZFX0lOVEVHRVIgfHwgayA+IE1BWF9TQUZFX0lOVEVHRVIgKVxyXG4gICAgICAgICAgICAgICAgPyBuLnMgKiAoIGsgPCAwID8gMCA6IDEgLyAwIClcclxuICAgICAgICAgICAgICAgIDogbiApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgICAgICogIHNxcnQoIE4pID0gIE5cclxuICAgICAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICAgICAqICBzcXJ0KCBJKSA9ICBJXHJcbiAgICAgICAgICogIHNxcnQoIDApID0gIDBcclxuICAgICAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYyA9IHguYyxcclxuICAgICAgICAgICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgICAgICAgICBlID0geC5lLFxyXG4gICAgICAgICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgICAgICAgaWYgKCBzICE9PSAxIHx8ICFjIHx8ICFjWzBdICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoICFzIHx8IHMgPCAwICYmICggIWMgfHwgY1swXSApID8gTmFOIDogYyA/IHggOiAxIC8gMCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICAgICAgICBzID0gTWF0aC5zcXJ0KCAreCApO1xyXG5cclxuICAgICAgICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgaWYgKCBzID09IDAgfHwgcyA9PSAxIC8gMCApIHtcclxuICAgICAgICAgICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAoIG4ubGVuZ3RoICsgZSApICUgMiA9PSAwICkgbiArPSAnMCc7XHJcbiAgICAgICAgICAgICAgICBzID0gTWF0aC5zcXJ0KG4pO1xyXG4gICAgICAgICAgICAgICAgZSA9IGJpdEZsb29yKCAoIGUgKyAxICkgLyAyICkgLSAoIGUgPCAwIHx8IGUgJSAyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzID09IDEgLyAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSAnMWUnICsgZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLnNsaWNlKCAwLCBuLmluZGV4T2YoJ2UnKSArIDEgKSArIGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByID0gbmV3IEJpZ051bWJlciggcyArICcnICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAgICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgICAgICAgIGlmICggci5jWzBdICkge1xyXG4gICAgICAgICAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICAgICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHMgPCAzICkgcyA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyA7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKCB0LnBsdXMoIGRpdiggeCwgdCwgZHAsIDEgKSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29lZmZUb1N0cmluZyggdC5jICAgKS5zbGljZSggMCwgcyApID09PSAoIG4gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZUb1N0cmluZyggci5jICkgKS5zbGljZSggMCwgcyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tID4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHIuZSA8IGUgKSAtLXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuLnNsaWNlKCBzIC0gMywgcyArIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCB0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0LnRpbWVzKHQpLmVxKHgpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCByLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggciwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIG4gKiAwID0gMFxyXG4gICAgICAgICAqICBuICogTiA9IE5cclxuICAgICAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgICAgICogIDAgKiBuID0gMFxyXG4gICAgICAgICAqICAwICogMCA9IDBcclxuICAgICAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgICAgICogIDAgKiBJID0gTlxyXG4gICAgICAgICAqICBOICogbiA9IE5cclxuICAgICAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgICAgICogIE4gKiBOID0gTlxyXG4gICAgICAgICAqICBOICogSSA9IE5cclxuICAgICAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgICAgICogIEkgKiAwID0gTlxyXG4gICAgICAgICAqICBJICogTiA9IE5cclxuICAgICAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciB0aW1lcyB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICB5YyA9ICggaWQgPSAxNywgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKSApLmM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgaWYgKCAheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGUgPSBiaXRGbG9vciggeC5lIC8gTE9HX0JBU0UgKSArIGJpdEZsb29yKCB5LmUgLyBMT0dfQkFTRSApO1xyXG4gICAgICAgICAgICB5LnMgKj0geC5zO1xyXG4gICAgICAgICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgICAgICAgaWYgKCB4Y0wgPCB5Y0wgKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApICk7XHJcblxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0geWNMOyAtLWkgPj0gMDsgKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gMDtcclxuICAgICAgICAgICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBrID0geGNMLCBqID0gaSArIGs7IGogPiBpOyApIHtcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoICggbSAlIHNxcnRCYXNlICkgKiBzcXJ0QmFzZSApICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAoIHhsbyAvIGJhc2UgfCAwICkgKyAoIG0gLyBzcXJ0QmFzZSB8IDAgKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgICAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB6Yy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB6YywgZSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mXHJcbiAgICAgICAgICogc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcHJlY2lzaW9uIG91dCBvZiByYW5nZToge3NkfSdcclxuICAgICAgICAgKiAndG9EaWdpdHMoKSBwcmVjaXNpb24gbm90IGFuIGludGVnZXI6IHtzZH0nXHJcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAgICAgKiAndG9EaWdpdHMoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvRGlnaXRzID0gZnVuY3Rpb24gKCBzZCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgICAgICAgc2QgPSBzZCA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBzZCwgMSwgTUFYLCAxOCwgJ3ByZWNpc2lvbicgKSA/IG51bGwgOiBzZCB8IDA7XHJcbiAgICAgICAgICAgIHJtID0gcm0gPT0gbnVsbCB8fCAhaXNWYWxpZEludCggcm0sIDAsIDgsIDE4LCByb3VuZGluZ01vZGUgKSA/IFJPVU5ESU5HX01PREUgOiBybSB8IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBzZCA/IHJvdW5kKCBuLCBzZCwgcm0gKSA6IG47XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRXhwb25lbnRpYWwoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRXhwb25lbnRpYWwoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsXHJcbiAgICAgICAgICAgICAgZHAgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAxOSApID8gfn5kcCArIDEgOiBudWxsLCBybSwgMTkgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0ZpeGVkKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRml4ZWQoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRml4ZWQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b0ZpeGVkKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsIGRwICE9IG51bGwgJiYgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMjAgKVxyXG4gICAgICAgICAgICAgID8gfn5kcCArIHRoaXMuZSArIDEgOiBudWxsLCBybSwgMjAgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAgICAgKiBvZiB0aGUgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5jb25maWcpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRk9STUFUID0ge1xyXG4gICAgICAgICAqICAgICAgZGVjaW1hbFNlcGFyYXRvciA6ICcuJyxcclxuICAgICAgICAgKiAgICAgIGdyb3VwU2VwYXJhdG9yIDogJywnLFxyXG4gICAgICAgICAqICAgICAgZ3JvdXBTaXplIDogMyxcclxuICAgICAgICAgKiAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZSA6IDAsXHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIDogJ1xceEEwJywgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2l6ZSA6IDBcclxuICAgICAgICAgKiB9O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xyXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAndG9Gb3JtYXQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcclxuICAgICAgICAgICAgdmFyIHN0ciA9IGZvcm1hdCggdGhpcywgZHAgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAyMSApXHJcbiAgICAgICAgICAgICAgPyB+fmRwICsgdGhpcy5lICsgMSA6IG51bGwsIHJtLCAyMSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmMgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgICAgICBnMSA9ICtGT1JNQVQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGcyID0gK0ZPUk1BVC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBGT1JNQVQuZ3JvdXBTZXBhcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgaXNOZWcgPSB0aGlzLnMgPCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZzIpIGkgPSBnMSwgZzEgPSBnMiwgZzIgPSBpLCBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGcxID4gMCAmJiBsZW4gPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgICAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0ciggMCwgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkgKz0gZzEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKCBpLCBnMSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBnMiA+IDAgKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgICAgICAgICAgID8gaW50UGFydCArIEZPUk1BVC5kZWNpbWFsU2VwYXJhdG9yICsgKCAoIGcyID0gK0ZPUk1BVC5mcmFjdGlvbkdyb3VwU2l6ZSApXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZSggbmV3IFJlZ0V4cCggJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICckJicgKyBGT1JNQVQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciApXHJcbiAgICAgICAgICAgICAgICAgICAgOiBmcmFjdGlvblBhcnQgKVxyXG4gICAgICAgICAgICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIGFycmF5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGUgZnJhY3Rpb24gd2l0aFxyXG4gICAgICAgICAqIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlXHJcbiAgICAgICAgICogbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtXHJcbiAgICAgICAgICogZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG9cclxuICAgICAgICAgKiByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSBhbmQgPCBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9GcmFjdGlvbigpIG1heCBkZW5vbWluYXRvciBub3QgYW4gaW50ZWdlcjoge21kfSdcclxuICAgICAgICAgKiAndG9GcmFjdGlvbigpIG1heCBkZW5vbWluYXRvciBvdXQgb2YgcmFuZ2U6IHttZH0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnIsIGQwLCBkMiwgZSwgZXhwLCBuLCBuMCwgcSwgcyxcclxuICAgICAgICAgICAgICAgIGsgPSBFUlJPUlMsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKSxcclxuICAgICAgICAgICAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSksXHJcbiAgICAgICAgICAgICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtZCAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgRVJST1JTID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcbiAgICAgICAgICAgICAgICBFUlJPUlMgPSBrO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISggayA9IG4uaXNJbnQoKSApIHx8IG4ubHQoT05FKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVSUk9SUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSggMjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ21heCBkZW5vbWluYXRvciAnICsgKCBrID8gJ291dCBvZiByYW5nZScgOiAnbm90IGFuIGludGVnZXInICksIG1kICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFUlJPUlMgaXMgZmFsc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbWQgaXMgYSBmaW5pdGUgbm9uLWludGVnZXIgPj0gMSwgcm91bmQgaXQgdG8gYW4gaW50ZWdlciBhbmQgdXNlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIG1kID0gIWsgJiYgbi5jICYmIHJvdW5kKCBuLCBuLmUgKyAxLCAxICkuZ3RlKE9ORSkgPyBuIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAheGMgKSByZXR1cm4geC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgICAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgICAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyAoIGV4cCA9IGUgJSBMT0dfQkFTRSApIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwIF07XHJcbiAgICAgICAgICAgIG1kID0gIW1kIHx8IG4uY21wKGQpID4gMCA/ICggZSA+IDAgPyBkIDogbjEgKSA6IG47XHJcblxyXG4gICAgICAgICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICAgICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7IDsgKSAge1xyXG4gICAgICAgICAgICAgICAgcSA9IGRpdiggbiwgZCwgMCwgMSApO1xyXG4gICAgICAgICAgICAgICAgZDIgPSBkMC5wbHVzKCBxLnRpbWVzKGQxKSApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkMi5jbXAobWQpID09IDEgKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgICAgICAgICAgbjEgPSBuMC5wbHVzKCBxLnRpbWVzKCBkMiA9IG4xICkgKTtcclxuICAgICAgICAgICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgICAgICAgICBkID0gbi5taW51cyggcS50aW1lcyggZDIgPSBkICkgKTtcclxuICAgICAgICAgICAgICAgIG4gPSBkMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZDIgPSBkaXYoIG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEgKTtcclxuICAgICAgICAgICAgbjAgPSBuMC5wbHVzKCBkMi50aW1lcyhuMSkgKTtcclxuICAgICAgICAgICAgZDAgPSBkMC5wbHVzKCBkMi50aW1lcyhkMSkgKTtcclxuICAgICAgICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgICAgICAgIGUgKj0gMjtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgICAgICAgYXJyID0gZGl2KCBuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUgKS5taW51cyh4KS5hYnMoKS5jbXAoXHJcbiAgICAgICAgICAgICAgICAgIGRpdiggbjAsIGQwLCBlLCBST1VORElOR19NT0RFICkubWludXMoeCkuYWJzKCkgKSA8IDFcclxuICAgICAgICAgICAgICAgICAgICA/IFsgbjEudG9TdHJpbmcoKSwgZDEudG9TdHJpbmcoKSBdXHJcbiAgICAgICAgICAgICAgICAgICAgOiBbIG4wLnRvU3RyaW5nKCksIGQwLnRvU3RyaW5nKCkgXTtcclxuXHJcbiAgICAgICAgICAgIE1BWF9FWFAgPSBleHA7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB6ZXJvIGhhcyBjb3JyZWN0IHNpZ24uXHJcbiAgICAgICAgICAgIHJldHVybiAreCB8fCAoIHgucyA/IHgucyAqIDAgOiBOYU4gKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJhaXNlZCB0byB0aGUgcG93ZXIgbi5cclxuICAgICAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vdCAwLCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIHtudW1iZXJ9IEludGVnZXIsIC05MDA3MTk5MjU0NzQwOTkyIHRvIDkwMDcxOTkyNTQ3NDA5OTIgaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIChQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5Mi4pXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAncG93KCkgZXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAgICAgKiAncG93KCkgZXhwb25lbnQgb3V0IG9mIHJhbmdlOiB7bn0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b1Bvd2VyID0gUC5wb3cgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICB2YXIgaywgeSxcclxuICAgICAgICAgICAgICAgIGkgPSBtYXRoZmxvb3IoIG4gPCAwID8gLW4gOiArbiApLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBQYXNzIMKxSW5maW5pdHkgdG8gTWF0aC5wb3cgaWYgZXhwb25lbnQgaXMgb3V0IG9mIHJhbmdlLlxyXG4gICAgICAgICAgICBpZiAoICFpc1ZhbGlkSW50KCBuLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUiwgMjMsICdleHBvbmVudCcgKSAmJlxyXG4gICAgICAgICAgICAgICggIWlzRmluaXRlKG4pIHx8IGkgPiBNQVhfU0FGRV9JTlRFR0VSICYmICggbiAvPSAwICkgfHxcclxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQobikgIT0gbiAmJiAhKCBuID0gTmFOICkgKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCBNYXRoLnBvdyggK3gsIG4gKSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uIGVxdWF0ZXNcclxuICAgICAgICAgICAgLy8gdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLCBpLmUuIHRoZXJlIHdpbGwgYmUgYVxyXG4gICAgICAgICAgICAvLyBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC4gKFVzaW5nICsgMS41IHdvdWxkIGdpdmUgWzksIDIxXSBndWFyZCBkaWdpdHMuKVxyXG4gICAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTiA/IG1hdGhjZWlsKCBQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyICkgOiAwO1xyXG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyA7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaSAlIDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAheS5jICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrICYmIHkuYy5sZW5ndGggPiBrICkgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaSA9IG1hdGhmbG9vciggaSAvIDIgKTtcclxuICAgICAgICAgICAgICAgIGlmICggIWkgKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuICAgICAgICAgICAgICAgIGlmICggayAmJiB4LmMgJiYgeC5jLmxlbmd0aCA+IGsgKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBuIDwgMCApIHkgPSBPTkUuZGl2KHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gayA/IHJvdW5kKCB5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFICkgOiB5O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSBwcmVjaXNpb24gbm90IGFuIGludGVnZXI6IHtzZH0nXHJcbiAgICAgICAgICogJ3RvUHJlY2lzaW9uKCkgcHJlY2lzaW9uIG91dCBvZiByYW5nZToge3NkfSdcclxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b1ByZWNpc2lvbigpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoIHNkLCBybSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCggdGhpcywgc2QgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBzZCwgMSwgTUFYLCAyNCwgJ3ByZWNpc2lvbicgKVxyXG4gICAgICAgICAgICAgID8gc2QgfCAwIDogbnVsbCwgcm0sIDI0ICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIDY0IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b1N0cmluZygpIGJhc2Ugbm90IGFuIGludGVnZXI6IHtifSdcclxuICAgICAgICAgKiAndG9TdHJpbmcoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICB2YXIgc3RyLFxyXG4gICAgICAgICAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgICAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgICAgICAgaWYgKCBlID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMgPCAwICkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYiA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBiLCAyLCA2NCwgMjUsICdiYXNlJyApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICAgICAgICAgICAgID8gdG9FeHBvbmVudGlhbCggc3RyLCBlIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gY29udmVydEJhc2UoIHRvRml4ZWRQb2ludCggc3RyLCBlICksIGIgfCAwLCAxMCwgcyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcyA8IDAgJiYgbi5jWzBdICkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHRydW5jYXRlZCB0byBhIHdob2xlXHJcbiAgICAgICAgICogbnVtYmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCBuZXcgQmlnTnVtYmVyKHRoaXMpLCB0aGlzLmUgKyAxLCAxICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvLyBBbGlhc2VzIGZvciBCaWdEZWNpbWFsIG1ldGhvZHMuXHJcbiAgICAgICAgLy9QLmFkZCA9IFAucGx1czsgICAgICAgICAvLyBQLmFkZCBpbmNsdWRlZCBhYm92ZVxyXG4gICAgICAgIC8vUC5zdWJ0cmFjdCA9IFAubWludXM7ICAgLy8gUC5zdWIgaW5jbHVkZWQgYWJvdmVcclxuICAgICAgICAvL1AubXVsdGlwbHkgPSBQLnRpbWVzOyAgIC8vIFAubXVsIGluY2x1ZGVkIGFib3ZlXHJcbiAgICAgICAgLy9QLmRpdmlkZSA9IFAuZGl2O1xyXG4gICAgICAgIC8vUC5yZW1haW5kZXIgPSBQLm1vZDtcclxuICAgICAgICAvL1AuY29tcGFyZVRvID0gUC5jbXA7XHJcbiAgICAgICAgLy9QLm5lZ2F0ZSA9IFAubmVnO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKCBjb25maWdPYmogIT0gbnVsbCApIEJpZ051bWJlci5jb25maWcoY29uZmlnT2JqKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgICAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICAgIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgICAgIHZhciBzLCB6LFxyXG4gICAgICAgICAgICBpID0gMSxcclxuICAgICAgICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgICAgICBmb3IgKCA7IGkgPCBqOyApIHtcclxuICAgICAgICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICAgICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICggOyB6LS07IHMgPSAnMCcgKyBzICk7XHJcbiAgICAgICAgICAgIHIgKz0gcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKCBqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODsgKTtcclxuICAgICAgICByZXR1cm4gci5zbGljZSggMCwgaiArIDEgfHwgMSApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKCB4LCB5ICkge1xyXG4gICAgICAgIHZhciBhLCBiLFxyXG4gICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgeWMgPSB5LmMsXHJcbiAgICAgICAgICAgIGkgPSB4LnMsXHJcbiAgICAgICAgICAgIGogPSB5LnMsXHJcbiAgICAgICAgICAgIGsgPSB4LmUsXHJcbiAgICAgICAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgICAgaWYgKCAhaSB8fCAhaiApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICggYSB8fCBiICkgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgIGlmICggaSAhPSBqICkgcmV0dXJuIGk7XHJcblxyXG4gICAgICAgIGEgPSBpIDwgMDtcclxuICAgICAgICBiID0gayA9PSBsO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCAheGMgfHwgIXljICkgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICAgICAgaWYgKCAhYiApIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgICAgIGogPSAoIGsgPSB4Yy5sZW5ndGggKSA8ICggbCA9IHljLmxlbmd0aCApID8gayA6IGw7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBqOyBpKysgKSBpZiAoIHhjW2ldICE9IHljW2ldICkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICAgICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBuIGlzIGEgdmFsaWQgbnVtYmVyIGluIHJhbmdlLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAgKiBVc2UgZm9yIGFyZ3VtZW50IHZhbGlkYXRpb24gd2hlbiBFUlJPUlMgaXMgZmFsc2UuXHJcbiAgICAgKiBOb3RlOiBwYXJzZUludCgnMWUrMScpID09IDEgYnV0IHBhcnNlRmxvYXQoJzFlKzEnKSA9PSAxMC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW50VmFsaWRhdG9yTm9FcnJvcnMoIG4sIG1pbiwgbWF4ICkge1xyXG4gICAgICAgIHJldHVybiAoIG4gPSB0cnVuY2F0ZShuKSApID49IG1pbiAmJiBuIDw9IG1heDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgKiBFZy4gY29udmVydEJhc2UoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAqIEVnLiBjb252ZXJ0QmFzZSgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoIHN0ciwgYmFzZUluLCBiYXNlT3V0ICkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKCA7IGkgPCBsZW47ICkge1xyXG4gICAgICAgICAgICBmb3IgKCBhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluICk7XHJcbiAgICAgICAgICAgIGFyclsgaiA9IDAgXSArPSBBTFBIQUJFVC5pbmRleE9mKCBzdHIuY2hhckF0KCBpKysgKSApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyBqIDwgYXJyLmxlbmd0aDsgaisrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYXJyW2pdID4gYmFzZU91dCAtIDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJbaiArIDFdID09IG51bGwgKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbCggc3RyLCBlICkge1xyXG4gICAgICAgIHJldHVybiAoIHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0ciApICtcclxuICAgICAgICAgICggZSA8IDAgPyAnZScgOiAnZSsnICkgKyBlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApIHtcclxuICAgICAgICB2YXIgbGVuLCB6O1xyXG5cclxuICAgICAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgICAgICBpZiAoIGUgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggeiA9ICcwLic7ICsrZTsgeiArPSAnMCcgKTtcclxuICAgICAgICAgICAgc3RyID0geiArIHN0cjtcclxuXHJcbiAgICAgICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICAgICAgICBpZiAoICsrZSA+IGxlbiApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIHogPSAnMCcsIGUgLT0gbGVuOyAtLWU7IHogKz0gJzAnICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gejtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IGxlbiApIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggMCwgZSApICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShuKSB7XHJcbiAgICAgICAgbiA9IHBhcnNlRmxvYXQobik7XHJcbiAgICAgICAgcmV0dXJuIG4gPCAwID8gbWF0aGNlaWwobikgOiBtYXRoZmxvb3Iobik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIgPSBhbm90aGVyKCk7XHJcblxyXG4gICAgLy8gQU1ELlxyXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuICAgICAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSApO1xyXG5cclxuICAgIC8vIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG4gICAgICAgIGlmICggIWNyeXB0byApIHRyeSB7IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpOyB9IGNhdGNoIChlKSB7fVxyXG5cclxuICAgIC8vIEJyb3dzZXIuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsb2JhbC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4xLjInLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShcIndlYmV4dGVuc2lvbi1wb2x5ZmlsbFwiLCBbXCJtb2R1bGVcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZmFjdG9yeShtb2R1bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QpO1xuICAgIGdsb2JhbC5icm93c2VyID0gbW9kLmV4cG9ydHM7XG4gIH1cbn0pKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLyogd2ViZXh0ZW5zaW9uLXBvbHlmaWxsIC0gdjAuOC4wIC0gVHVlIEFwciAyMCAyMDIxIDExOjI3OjM4ICovXG5cbiAgLyogLSotIE1vZGU6IGluZGVudC10YWJzLW1vZGU6IG5pbDsganMtaW5kZW50LWxldmVsOiAyIC0qLSAqL1xuXG4gIC8qIHZpbTogc2V0IHN0cz0yIHN3PTIgZXQgdHc9ODA6ICovXG5cbiAgLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICAgKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gICAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmICh0eXBlb2YgYnJvd3NlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYnJvd3NlcikgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UgPSBcIlRoZSBtZXNzYWdlIHBvcnQgY2xvc2VkIGJlZm9yZSBhIHJlc3BvbnNlIHdhcyByZWNlaXZlZC5cIjtcbiAgICBjb25zdCBTRU5EX1JFU1BPTlNFX0RFUFJFQ0FUSU9OX1dBUk5JTkcgPSBcIlJldHVybmluZyBhIFByb21pc2UgaXMgdGhlIHByZWZlcnJlZCB3YXkgdG8gc2VuZCBhIHJlcGx5IGZyb20gYW4gb25NZXNzYWdlL29uTWVzc2FnZUV4dGVybmFsIGxpc3RlbmVyLCBhcyB0aGUgc2VuZFJlc3BvbnNlIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBzcGVjcyAoU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvTW96aWxsYS9BZGQtb25zL1dlYkV4dGVuc2lvbnMvQVBJL3J1bnRpbWUvb25NZXNzYWdlKVwiOyAvLyBXcmFwcGluZyB0aGUgYnVsayBvZiB0aGlzIHBvbHlmaWxsIGluIGEgb25lLXRpbWUtdXNlIGZ1bmN0aW9uIGlzIGEgbWlub3JcbiAgICAvLyBvcHRpbWl6YXRpb24gZm9yIEZpcmVmb3guIFNpbmNlIFNwaWRlcm1vbmtleSBkb2VzIG5vdCBmdWxseSBwYXJzZSB0aGVcbiAgICAvLyBjb250ZW50cyBvZiBhIGZ1bmN0aW9uIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgc2luY2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGFjdHVhbGx5IG5lZWQgdG8gYmUgY2FsbGVkLCB0aGlzIGFsbG93cyB0aGUgcG9seWZpbGwgdG8gYmUgaW5jbHVkZWRcbiAgICAvLyBpbiBGaXJlZm94IG5lYXJseSBmb3IgZnJlZS5cblxuICAgIGNvbnN0IHdyYXBBUElzID0gZXh0ZW5zaW9uQVBJcyA9PiB7XG4gICAgICAvLyBOT1RFOiBhcGlNZXRhZGF0YSBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZW50IG9mIHRoZSBhcGktbWV0YWRhdGEuanNvbiBmaWxlXG4gICAgICAvLyBhdCBidWlsZCB0aW1lIGJ5IHJlcGxhY2luZyB0aGUgZm9sbG93aW5nIFwiaW5jbHVkZVwiIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgICAvLyBKU09OIGZpbGUuXG4gICAgICBjb25zdCBhcGlNZXRhZGF0YSA9IHtcbiAgICAgICAgXCJhbGFybXNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjbGVhckFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJvb2ttYXJrc1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDaGlsZHJlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFJlY2VudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFN1YlRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJicm93c2VyQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImRpc2FibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlbmFibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuUG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnJvd3NpbmdEYXRhXCI6IHtcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNhY2hlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ29va2llc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZURvd25sb2Fkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUZvcm1EYXRhXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlSGlzdG9yeVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUxvY2FsU3RvcmFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBhc3N3b3Jkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBsdWdpbkRhdGFcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbW1hbmRzXCI6IHtcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbnRleHRNZW51c1wiOiB7XG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb29raWVzXCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbENvb2tpZVN0b3Jlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRldnRvb2xzXCI6IHtcbiAgICAgICAgICBcImluc3BlY3RlZFdpbmRvd1wiOiB7XG4gICAgICAgICAgICBcImV2YWxcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDIsXG4gICAgICAgICAgICAgIFwic2luZ2xlQ2FsbGJhY2tBcmdcIjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicGFuZWxzXCI6IHtcbiAgICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDMsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzLFxuICAgICAgICAgICAgICBcInNpbmdsZUNhbGxiYWNrQXJnXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJjcmVhdGVTaWRlYmFyUGFuZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJkb3dubG9hZHNcIjoge1xuICAgICAgICAgIFwiY2FuY2VsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZG93bmxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlcmFzZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZpbGVJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3BlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInBhdXNlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRmlsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlc3VtZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRlbnNpb25cIjoge1xuICAgICAgICAgIFwiaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImlzQWxsb3dlZEluY29nbml0b0FjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImhpc3RvcnlcIjoge1xuICAgICAgICAgIFwiYWRkVXJsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlUmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVVcmxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRWaXNpdHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpMThuXCI6IHtcbiAgICAgICAgICBcImRldGVjdExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWNjZXB0TGFuZ3VhZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRlbnRpdHlcIjoge1xuICAgICAgICAgIFwibGF1bmNoV2ViQXV0aEZsb3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpZGxlXCI6IHtcbiAgICAgICAgICBcInF1ZXJ5U3RhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYW5hZ2VtZW50XCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFNlbGZcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidW5pbnN0YWxsU2VsZlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm5vdGlmaWNhdGlvbnNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQZXJtaXNzaW9uTGV2ZWxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYWdlQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0SWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGVybWlzc2lvbnNcIjoge1xuICAgICAgICAgIFwiY29udGFpbnNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicnVudGltZVwiOiB7XG4gICAgICAgICAgXCJnZXRCYWNrZ3JvdW5kUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBsYXRmb3JtSW5mb1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5PcHRpb25zUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVlc3RVcGRhdGVDaGVja1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmRNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE5hdGl2ZU1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRVbmluc3RhbGxVUkxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXNzaW9uc1wiOiB7XG4gICAgICAgICAgXCJnZXREZXZpY2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UmVjZW50bHlDbG9zZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic3RvcmFnZVwiOiB7XG4gICAgICAgICAgXCJsb2NhbFwiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1hbmFnZWRcIjoge1xuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic3luY1wiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRhYnNcIjoge1xuICAgICAgICAgIFwiY2FwdHVyZVZpc2libGVUYWJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZXRlY3RMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRpc2NhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkdXBsaWNhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJleGVjdXRlU2NyaXB0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q3VycmVudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0JhY2tcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0ZvcndhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWdobGlnaHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpbnNlcnRDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicXVlcnlcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZWxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0b3BTaXRlc1wiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3ZWJOYXZpZ2F0aW9uXCI6IHtcbiAgICAgICAgICBcImdldEFsbEZyYW1lc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZyYW1lXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2ViUmVxdWVzdFwiOiB7XG4gICAgICAgICAgXCJoYW5kbGVyQmVoYXZpb3JDaGFuZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2luZG93c1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDdXJyZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0TGFzdEZvY3VzZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGFwaU1ldGFkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXBpLW1ldGFkYXRhLmpzb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIGluIGJyb3dzZXItcG9seWZpbGxcIik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEEgV2Vha01hcCBzdWJjbGFzcyB3aGljaCBjcmVhdGVzIGFuZCBzdG9yZXMgYSB2YWx1ZSBmb3IgYW55IGtleSB3aGljaCBkb2VzXG4gICAgICAgKiBub3QgZXhpc3Qgd2hlbiBhY2Nlc3NlZCwgYnV0IGJlaGF2ZXMgZXhhY3RseSBhcyBhbiBvcmRpbmFyeSBXZWFrTWFwXG4gICAgICAgKiBvdGhlcndpc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY3JlYXRlSXRlbVxuICAgICAgICogICAgICAgIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSB2YWx1ZSBmb3IgYW55XG4gICAgICAgKiAgICAgICAga2V5IHdoaWNoIGRvZXMgbm90IGV4aXN0LCB0aGUgZmlyc3QgdGltZSBpdCBpcyBhY2Nlc3NlZC4gVGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZXMsIGFzIGl0cyBvbmx5IGFyZ3VtZW50LCB0aGUga2V5IGJlaW5nIGNyZWF0ZWQuXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzcyBEZWZhdWx0V2Vha01hcCBleHRlbmRzIFdlYWtNYXAge1xuICAgICAgICBjb25zdHJ1Y3RvcihjcmVhdGVJdGVtLCBpdGVtcyA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN1cGVyKGl0ZW1zKTtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB0aGlzLmNyZWF0ZUl0ZW0oa2V5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdpdGggYSBgdGhlbmAgbWV0aG9kLCBhbmQgY2FuXG4gICAgICAgKiB0aGVyZWZvcmUgYmUgYXNzdW1lZCB0byBiZWhhdmUgYXMgYSBQcm9taXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdGhlbmFibGUuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBpc1RoZW5hYmxlID0gdmFsdWUgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIHdoZW4gY2FsbGVkLCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0XG4gICAgICAgKiB0aGUgZ2l2ZW4gcHJvbWlzZSBiYXNlZCBvbiBob3cgaXQgaXMgY2FsbGVkOlxuICAgICAgICpcbiAgICAgICAqIC0gSWYsIHdoZW4gY2FsbGVkLCBgY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yYCBjb250YWlucyBhIG5vbi1udWxsIG9iamVjdCxcbiAgICAgICAqICAgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCB0aGF0IHZhbHVlLlxuICAgICAgICogLSBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZXhhY3RseSBvbmUgYXJndW1lbnQsIHRoZSBwcm9taXNlIGlzXG4gICAgICAgKiAgIHJlc29sdmVkIHRvIHRoYXQgdmFsdWUuXG4gICAgICAgKiAtIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgdG8gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlXG4gICAgICAgKiAgIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9taXNlXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc29sdXRpb24gYW5kIHJlamVjdGlvbiBmdW5jdGlvbnMgb2YgYVxuICAgICAgICogICAgICAgIHByb21pc2UuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlc29sdmVcbiAgICAgICAqICAgICAgICBUaGUgcHJvbWlzZSdzIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlamVjdFxuICAgICAgICogICAgICAgIFRoZSBwcm9taXNlJ3MgcmVqZWN0aW9uIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIHdyYXBwZWQgbWV0aG9kIHdoaWNoIGhhcyBjcmVhdGVkIHRoZSBjYWxsYmFjay5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmdcbiAgICAgICAqICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIG9ubHkgdGhlIGZpcnN0XG4gICAgICAgKiAgICAgICAgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrLCBhbHRlcm5hdGl2ZWx5IGFuIGFycmF5IG9mIGFsbCB0aGVcbiAgICAgICAqICAgICAgICBjYWxsYmFjayBhcmd1bWVudHMgaXMgcmVzb2x2ZWQuIEJ5IGRlZmF1bHQsIGlmIHRoZSBjYWxsYmFja1xuICAgICAgICogICAgICAgIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCBvbmx5IGEgc2luZ2xlIGFyZ3VtZW50LCB0aGF0IHdpbGwgYmVcbiAgICAgICAqICAgICAgICByZXNvbHZlZCB0byB0aGUgcHJvbWlzZSwgd2hpbGUgYWxsIGFyZ3VtZW50cyB3aWxsIGJlIHJlc29sdmVkIGFzXG4gICAgICAgKiAgICAgICAgYW4gYXJyYXkgaWYgbXVsdGlwbGUgYXJlIGdpdmVuLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICAgICAqICAgICAgICBUaGUgZ2VuZXJhdGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgbWFrZUNhbGxiYWNrID0gKHByb21pc2UsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uY2FsbGJhY2tBcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnIHx8IGNhbGxiYWNrQXJncy5sZW5ndGggPD0gMSAmJiBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3NbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoY2FsbGJhY2tBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwbHVyYWxpemVBcmd1bWVudHMgPSBudW1BcmdzID0+IG51bUFyZ3MgPT0gMSA/IFwiYXJndW1lbnRcIiA6IFwiYXJndW1lbnRzXCI7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBtZXRob2Qgd2hpY2ggaXMgYmVpbmcgd3JhcHBlZC5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YVxuICAgICAgICogICAgICAgIE1ldGFkYXRhIGFib3V0IHRoZSBtZXRob2QgYmVpbmcgd3JhcHBlZC5cbiAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gbWV0YWRhdGEubWluQXJnc1xuICAgICAgICogICAgICAgIFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIGZld2VyIHRoYW4gdGhpcyBudW1iZXIgb2YgYXJndW1lbnRzLCB0aGVcbiAgICAgICAqICAgICAgICB3cmFwcGVyIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5tYXhBcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uLiBJZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gdGhpcyBudW1iZXIgb2YgYXJndW1lbnRzLCB0aGVcbiAgICAgICAqICAgICAgICB3cmFwcGVyIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZ1xuICAgICAgICogICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggb25seSB0aGUgZmlyc3RcbiAgICAgICAqICAgICAgICBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2ssIGFsdGVybmF0aXZlbHkgYW4gYXJyYXkgb2YgYWxsIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGFyZ3VtZW50cyBpcyByZXNvbHZlZC4gQnkgZGVmYXVsdCwgaWYgdGhlIGNhbGxiYWNrXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIG9ubHkgYSBzaW5nbGUgYXJndW1lbnQsIHRoYXQgd2lsbCBiZVxuICAgICAgICogICAgICAgIHJlc29sdmVkIHRvIHRoZSBwcm9taXNlLCB3aGlsZSBhbGwgYXJndW1lbnRzIHdpbGwgYmUgcmVzb2x2ZWQgYXNcbiAgICAgICAqICAgICAgICBhbiBhcnJheSBpZiBtdWx0aXBsZSBhcmUgZ2l2ZW4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKG9iamVjdCwgLi4uKil9XG4gICAgICAgKiAgICAgICBUaGUgZ2VuZXJhdGVkIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwQXN5bmNGdW5jdGlvbiA9IChuYW1lLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXN5bmNGdW5jdGlvbldyYXBwZXIodGFyZ2V0LCAuLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgbWV0YWRhdGEubWluQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBtZXRhZGF0YS5tYXhBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5mYWxsYmFja1RvTm9DYWxsYmFjaykge1xuICAgICAgICAgICAgICAvLyBUaGlzIEFQSSBtZXRob2QgaGFzIGN1cnJlbnRseSBubyBjYWxsYmFjayBvbiBDaHJvbWUsIGJ1dCBpdCByZXR1cm4gYSBwcm9taXNlIG9uIEZpcmVmb3gsXG4gICAgICAgICAgICAgIC8vIGFuZCBzbyB0aGUgcG9seWZpbGwgd2lsbCB0cnkgdG8gY2FsbCBpdCB3aXRoIGEgY2FsbGJhY2sgZmlyc3QsIGFuZCBpdCB3aWxsIGZhbGxiYWNrXG4gICAgICAgICAgICAgIC8vIHRvIG5vdCBwYXNzaW5nIHRoZSBjYWxsYmFjayBpZiB0aGUgZmlyc3QgY2FsbCBmYWlscy5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChjYkVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IEFQSSBtZXRob2QgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciwgYCArIFwiZmFsbGluZyBiYWNrIHRvIGNhbGwgaXQgd2l0aG91dCBhIGNhbGxiYWNrOiBcIiwgY2JFcnJvcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpOyAvLyBVcGRhdGUgdGhlIEFQSSBtZXRob2QgbWV0YWRhdGEsIHNvIHRoYXQgdGhlIG5leHQgQVBJIGNhbGxzIHdpbGwgbm90IHRyeSB0b1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgdW5zdXBwb3J0ZWQgY2FsbGJhY2sgYW55bW9yZS5cblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmZhbGxiYWNrVG9Ob0NhbGxiYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubm9DYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLm5vQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgYW4gZXhpc3RpbmcgbWV0aG9kIG9mIHRoZSB0YXJnZXQgb2JqZWN0LCBzbyB0aGF0IGNhbGxzIHRvIGl0IGFyZVxuICAgICAgICogaW50ZXJjZXB0ZWQgYnkgdGhlIGdpdmVuIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHJlY2VpdmVzLFxuICAgICAgICogYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCB0aGUgb3JpZ2luYWwgYHRhcmdldGAgb2JqZWN0LCBmb2xsb3dlZCBieSBlYWNoIG9mXG4gICAgICAgKiB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAgICAgICAqICAgICAgICBUaGUgb3JpZ2luYWwgdGFyZ2V0IG9iamVjdCB0aGF0IHRoZSB3cmFwcGVkIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kXG4gICAgICAgKiAgICAgICAgVGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLiBUaGlzIGlzIHVzZWQgYXMgdGhlIHRhcmdldCBvZiB0aGUgUHJveHlcbiAgICAgICAqICAgICAgICBvYmplY3Qgd2hpY2ggaXMgY3JlYXRlZCB0byB3cmFwIHRoZSBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgVGhlIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGluIHBsYWNlIG9mIGEgZGlyZWN0IGludm9jYXRpb25cbiAgICAgICAqICAgICAgICBvZiB0aGUgd3JhcHBlZCBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PGZ1bmN0aW9uPn1cbiAgICAgICAqICAgICAgICBBIFByb3h5IG9iamVjdCBmb3IgdGhlIGdpdmVuIG1ldGhvZCwgd2hpY2ggaW52b2tlcyB0aGUgZ2l2ZW4gd3JhcHBlclxuICAgICAgICogICAgICAgIG1ldGhvZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwTWV0aG9kID0gKHRhcmdldCwgbWV0aG9kLCB3cmFwcGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkobWV0aG9kLCB7XG4gICAgICAgICAgYXBwbHkodGFyZ2V0TWV0aG9kLCB0aGlzT2JqLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5jYWxsKHRoaXNPYmosIHRhcmdldCwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGV0IGhhc093blByb3BlcnR5ID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBhbiBvYmplY3QgaW4gYSBQcm94eSB3aGljaCBpbnRlcmNlcHRzIGFuZCB3cmFwcyBjZXJ0YWluIG1ldGhvZHNcbiAgICAgICAqIGJhc2VkIG9uIHRoZSBnaXZlbiBgd3JhcHBlcnNgIGFuZCBgbWV0YWRhdGFgIG9iamVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICAgICAgICogICAgICAgIFRoZSB0YXJnZXQgb2JqZWN0IHRvIHdyYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFt3cmFwcGVycyA9IHt9XVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCB0cmVlIGNvbnRhaW5pbmcgd3JhcHBlciBmdW5jdGlvbnMgZm9yIHNwZWNpYWwgY2FzZXMuIEFueVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uIHByZXNlbnQgaW4gdGhpcyBvYmplY3QgdHJlZSBpcyBjYWxsZWQgaW4gcGxhY2Ugb2YgdGhlXG4gICAgICAgKiAgICAgICAgbWV0aG9kIGluIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBgdGFyZ2V0YCBvYmplY3QgdHJlZS4gVGhlc2VcbiAgICAgICAqICAgICAgICB3cmFwcGVyIG1ldGhvZHMgYXJlIGludm9rZWQgYXMgZGVzY3JpYmVkIGluIHtAc2VlIHdyYXBNZXRob2R9LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbbWV0YWRhdGEgPSB7fV1cbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgdHJlZSBjb250YWluaW5nIG1ldGFkYXRhIHVzZWQgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZVxuICAgICAgICogICAgICAgIFByb21pc2UtYmFzZWQgd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFzeW5jaHJvbm91cy4gQW55IGZ1bmN0aW9uIGluXG4gICAgICAgKiAgICAgICAgdGhlIGB0YXJnZXRgIG9iamVjdCB0cmVlIHdoaWNoIGhhcyBhIGNvcnJlc3BvbmRpbmcgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiAgICAgICAgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIGBtZXRhZGF0YWAgdHJlZSBpcyByZXBsYWNlZCB3aXRoIGFuXG4gICAgICAgKiAgICAgICAgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgd3JhcHBlciBmdW5jdGlvbiwgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgKiAgICAgICAge0BzZWUgd3JhcEFzeW5jRnVuY3Rpb259XG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PG9iamVjdD59XG4gICAgICAgKi9cblxuICAgICAgY29uc3Qgd3JhcE9iamVjdCA9ICh0YXJnZXQsIHdyYXBwZXJzID0ge30sIG1ldGFkYXRhID0ge30pID0+IHtcbiAgICAgICAgbGV0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0ge1xuICAgICAgICAgIGhhcyhwcm94eVRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0IHx8IHByb3AgaW4gY2FjaGU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldChwcm94eVRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZVtwcm9wXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2Qgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LiBDaGVjayBpZiB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAgIC8vIGFueSB3cmFwcGluZy5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVyc1twcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNwZWNpYWwtY2FzZSB3cmFwcGVyIGZvciB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBNZXRob2QodGFyZ2V0LCB0YXJnZXRbcHJvcF0sIHdyYXBwZXJzW3Byb3BdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIG1ldGhvZCB0aGF0IHdlIGhhdmUgbWV0YWRhdGEgZm9yLiBDcmVhdGUgYVxuICAgICAgICAgICAgICAgIC8vIFByb21pc2Ugd3JhcHBlciBmb3IgaXQuXG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSB3cmFwQXN5bmNGdW5jdGlvbihwcm9wLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwTWV0aG9kKHRhcmdldCwgdGFyZ2V0W3Byb3BdLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIHRoYXQgd2UgZG9uJ3Qga25vdyBvciBjYXJlIGFib3V0LiBSZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgbWV0aG9kLCBib3VuZCB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5iaW5kKHRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIChoYXNPd25Qcm9wZXJ0eSh3cmFwcGVycywgcHJvcCkgfHwgaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIHByb3ApKSkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG9iamVjdCB0aGF0IHdlIG5lZWQgdG8gZG8gc29tZSB3cmFwcGluZyBmb3IgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgIC8vIG9mLiBDcmVhdGUgYSBzdWItb2JqZWN0IHdyYXBwZXIgZm9yIGl0IHdpdGggdGhlIGFwcHJvcHJpYXRlIGNoaWxkXG4gICAgICAgICAgICAgIC8vIG1ldGFkYXRhLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBPYmplY3QodmFsdWUsIHdyYXBwZXJzW3Byb3BdLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBcIipcIikpIHtcbiAgICAgICAgICAgICAgLy8gV3JhcCBhbGwgcHJvcGVydGllcyBpbiAqIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwT2JqZWN0KHZhbHVlLCB3cmFwcGVyc1twcm9wXSwgbWV0YWRhdGFbXCIqXCJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gYW55IHdyYXBwaW5nIGZvciB0aGlzIHByb3BlcnR5LFxuICAgICAgICAgICAgICAvLyBzbyBqdXN0IGZvcndhcmQgYWxsIGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2V0KHByb3h5VGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIGNhY2hlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wLCBkZXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwgZGVzYyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShjYWNoZSwgcHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07IC8vIFBlciBjb250cmFjdCBvZiB0aGUgUHJveHkgQVBJLCB0aGUgXCJnZXRcIiBwcm94eSBoYW5kbGVyIG11c3QgcmV0dXJuIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgdGFyZ2V0IGlmIHRoYXQgdmFsdWUgaXMgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZFxuICAgICAgICAvLyBub24tY29uZmlndXJhYmxlLiBGb3IgdGhpcyByZWFzb24sIHdlIGNyZWF0ZSBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgICAgLy8gcHJvdG90eXBlIHNldCB0byBgdGFyZ2V0YCBpbnN0ZWFkIG9mIHVzaW5nIGB0YXJnZXRgIGRpcmVjdGx5LlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY2Fubm90IHJldHVybiBhIGN1c3RvbSBvYmplY3QgZm9yIEFQSXMgdGhhdFxuICAgICAgICAvLyBhcmUgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZCBub24tY29uZmlndXJhYmxlLCBzdWNoIGFzIGBjaHJvbWUuZGV2dG9vbHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcHJveHkgaGFuZGxlcnMgdGhlbXNlbHZlcyB3aWxsIHN0aWxsIHVzZSB0aGUgb3JpZ2luYWwgYHRhcmdldGBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgYHByb3h5VGFyZ2V0YCwgc28gdGhhdCB0aGUgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBhcmVcbiAgICAgICAgLy8gZGVyZWZlcmVuY2VkIHZpYSB0aGUgb3JpZ2luYWwgdGFyZ2V0cy5cblxuICAgICAgICBsZXQgcHJveHlUYXJnZXQgPSBPYmplY3QuY3JlYXRlKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIGhhbmRsZXJzKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzZXQgb2Ygd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IG9iamVjdCwgd2hpY2ggaGFuZGxlc1xuICAgICAgICogd3JhcHBpbmcgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRoYXQgdGhvc2UgbWVzc2FnZXMgYXJlIHBhc3NlZC5cbiAgICAgICAqXG4gICAgICAgKiBBIHNpbmdsZSB3cmFwcGVyIGlzIGNyZWF0ZWQgZm9yIGVhY2ggbGlzdGVuZXIgZnVuY3Rpb24sIGFuZCBzdG9yZWQgaW4gYVxuICAgICAgICogbWFwLiBTdWJzZXF1ZW50IGNhbGxzIHRvIGBhZGRMaXN0ZW5lcmAsIGBoYXNMaXN0ZW5lcmAsIG9yIGByZW1vdmVMaXN0ZW5lcmBcbiAgICAgICAqIHJldHJpZXZlIHRoZSBvcmlnaW5hbCB3cmFwcGVyLCBzbyB0aGF0ICBhdHRlbXB0cyB0byByZW1vdmUgYVxuICAgICAgICogcHJldmlvdXNseS1hZGRlZCBsaXN0ZW5lciB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RGVmYXVsdFdlYWtNYXA8ZnVuY3Rpb24sIGZ1bmN0aW9uPn0gd3JhcHBlck1hcFxuICAgICAgICogICAgICAgIEEgRGVmYXVsdFdlYWtNYXAgb2JqZWN0IHdoaWNoIHdpbGwgY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgZm9yIGEgZ2l2ZW4gbGlzdGVuZXIgZnVuY3Rpb24gd2hlbiBvbmUgZG9lcyBub3QgZXhpc3QsIGFuZCByZXRyaWV2ZVxuICAgICAgICogICAgICAgIGFuIGV4aXN0aW5nIG9uZSB3aGVuIGl0IGRvZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBFdmVudCA9IHdyYXBwZXJNYXAgPT4gKHtcbiAgICAgICAgYWRkTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lciwgLi4uYXJncykge1xuICAgICAgICAgIHRhcmdldC5hZGRMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lciksIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0xpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0Lmhhc0xpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lcikpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvblJlcXVlc3RGaW5pc2hlZFdyYXBwZXJzID0gbmV3IERlZmF1bHRXZWFrTWFwKGxpc3RlbmVyID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcyBhbiBvblJlcXVlc3RGaW5pc2hlZCBsaXN0ZW5lciBmdW5jdGlvbiBzbyB0aGF0IGl0IHdpbGwgcmV0dXJuIGFcbiAgICAgICAgICogYGdldENvbnRlbnQoKWAgcHJvcGVydHkgd2hpY2ggcmV0dXJucyBhIGBQcm9taXNlYCByYXRoZXIgdGhhbiB1c2luZyBhXG4gICAgICAgICAqIGNhbGxiYWNrIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHJlcVxuICAgICAgICAgKiAgICAgICAgVGhlIEhBUiBlbnRyeSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuZXR3b3JrIHJlcXVlc3QuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uUmVxdWVzdEZpbmlzaGVkKHJlcSkge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRSZXEgPSB3cmFwT2JqZWN0KHJlcSwge31cbiAgICAgICAgICAvKiB3cmFwcGVycyAqL1xuICAgICAgICAgICwge1xuICAgICAgICAgICAgZ2V0Q29udGVudDoge1xuICAgICAgICAgICAgICBtaW5BcmdzOiAwLFxuICAgICAgICAgICAgICBtYXhBcmdzOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGlzdGVuZXIod3JhcHBlZFJlcSk7XG4gICAgICAgIH07XG4gICAgICB9KTsgLy8gS2VlcCB0cmFjayBpZiB0aGUgZGVwcmVjYXRpb24gd2FybmluZyBoYXMgYmVlbiBsb2dnZWQgYXQgbGVhc3Qgb25jZS5cblxuICAgICAgbGV0IGxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZyA9IGZhbHNlO1xuICAgICAgY29uc3Qgb25NZXNzYWdlV3JhcHBlcnMgPSBuZXcgRGVmYXVsdFdlYWtNYXAobGlzdGVuZXIgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXBzIGEgbWVzc2FnZSBsaXN0ZW5lciBmdW5jdGlvbiBzbyB0aGF0IGl0IG1heSBzZW5kIHJlc3BvbnNlcyBiYXNlZCBvblxuICAgICAgICAgKiBpdHMgcmV0dXJuIHZhbHVlLCByYXRoZXIgdGhhbiBieSByZXR1cm5pbmcgYSBzZW50aW5lbCB2YWx1ZSBhbmQgY2FsbGluZyBhXG4gICAgICAgICAqIGNhbGxiYWNrLiBJZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gcmV0dXJucyBhIFByb21pc2UsIHRoZSByZXNwb25zZSBpc1xuICAgICAgICAgKiBzZW50IHdoZW4gdGhlIHByb21pc2UgZWl0aGVyIHJlc29sdmVzIG9yIHJlamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gbWVzc2FnZVxuICAgICAgICAgKiAgICAgICAgVGhlIG1lc3NhZ2Ugc2VudCBieSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjaGFubmVsLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VuZGVyXG4gICAgICAgICAqICAgICAgICBEZXRhaWxzIGFib3V0IHRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IHNlbmRSZXNwb25zZVxuICAgICAgICAgKiAgICAgICAgQSBjYWxsYmFjayB3aGljaCwgd2hlbiBjYWxsZWQgd2l0aCBhbiBhcmJpdHJhcnkgYXJndW1lbnQsIHNlbmRzXG4gICAgICAgICAqICAgICAgICB0aGF0IHZhbHVlIGFzIGEgcmVzcG9uc2UuXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiAgICAgICAgVHJ1ZSBpZiB0aGUgd3JhcHBlZCBsaXN0ZW5lciByZXR1cm5lZCBhIFByb21pc2UsIHdoaWNoIHdpbGwgbGF0ZXJcbiAgICAgICAgICogICAgICAgIHlpZWxkIGEgcmVzcG9uc2UuIEZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG5cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gb25NZXNzYWdlKG1lc3NhZ2UsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSB7XG4gICAgICAgICAgbGV0IGRpZENhbGxTZW5kUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgd3JhcHBlZFNlbmRSZXNwb25zZTtcbiAgICAgICAgICBsZXQgc2VuZFJlc3BvbnNlUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgd3JhcHBlZFNlbmRSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICBpZiAoIWxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihTRU5EX1JFU1BPTlNFX0RFUFJFQ0FUSU9OX1dBUk5JTkcsIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBsb2dnZWRTZW5kUmVzcG9uc2VEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxpc3RlbmVyKG1lc3NhZ2UsIHNlbmRlciwgd3JhcHBlZFNlbmRSZXNwb25zZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGlzUmVzdWx0VGhlbmFibGUgPSByZXN1bHQgIT09IHRydWUgJiYgaXNUaGVuYWJsZShyZXN1bHQpOyAvLyBJZiB0aGUgbGlzdGVuZXIgZGlkbid0IHJldHVybmVkIHRydWUgb3IgYSBQcm9taXNlLCBvciBjYWxsZWRcbiAgICAgICAgICAvLyB3cmFwcGVkU2VuZFJlc3BvbnNlIHN5bmNocm9ub3VzbHksIHdlIGNhbiBleGl0IGVhcmxpZXJcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIHdpbGwgYmUgbm8gcmVzcG9uc2Ugc2VudCBmcm9tIHRoaXMgbGlzdGVuZXIuXG5cbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlICYmICFpc1Jlc3VsdFRoZW5hYmxlICYmICFkaWRDYWxsU2VuZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBBIHNtYWxsIGhlbHBlciB0byBzZW5kIHRoZSBtZXNzYWdlIGlmIHRoZSBwcm9taXNlIHJlc29sdmVzXG4gICAgICAgICAgLy8gYW5kIGFuIGVycm9yIGlmIHRoZSBwcm9taXNlIHJlamVjdHMgKGEgd3JhcHBlZCBzZW5kTWVzc2FnZSBoYXNcbiAgICAgICAgICAvLyB0byB0cmFuc2xhdGUgdGhlIG1lc3NhZ2UgaW50byBhIHJlc29sdmVkIHByb21pc2Ugb3IgYSByZWplY3RlZFxuICAgICAgICAgIC8vIHByb21pc2UpLlxuXG5cbiAgICAgICAgICBjb25zdCBzZW5kUHJvbWlzZWRSZXN1bHQgPSBwcm9taXNlID0+IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihtc2cgPT4ge1xuICAgICAgICAgICAgICAvLyBzZW5kIHRoZSBtZXNzYWdlIHZhbHVlLlxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UobXNnKTtcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgLy8gU2VuZCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yIGlmIHRoZSByZWplY3RlZCB2YWx1ZVxuICAgICAgICAgICAgICAvLyBpcyBhbiBpbnN0YW5jZSBvZiBlcnJvciwgb3IgdGhlIG9iamVjdCBpdHNlbGYgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICBsZXQgbWVzc2FnZTtcblxuICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZFwiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBfX21veldlYkV4dGVuc2lvblBvbHlmaWxsUmVqZWN0X186IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgIC8vIFByaW50IGFuIGVycm9yIG9uIHRoZSBjb25zb2xlIGlmIHVuYWJsZSB0byBzZW5kIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZW5kIG9uTWVzc2FnZSByZWplY3RlZCByZXBseVwiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8gSWYgdGhlIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgc2VuZCB0aGUgcmVzb2x2ZWQgdmFsdWUgYXMgYVxuICAgICAgICAgIC8vIHJlc3VsdCwgb3RoZXJ3aXNlIHdhaXQgdGhlIHByb21pc2UgcmVsYXRlZCB0byB0aGUgd3JhcHBlZFNlbmRSZXNwb25zZVxuICAgICAgICAgIC8vIGNhbGxiYWNrIHRvIHJlc29sdmUgYW5kIHNlbmQgaXQgYXMgYSByZXNwb25zZS5cblxuXG4gICAgICAgICAgaWYgKGlzUmVzdWx0VGhlbmFibGUpIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kUHJvbWlzZWRSZXN1bHQoc2VuZFJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgfSAvLyBMZXQgQ2hyb21lIGtub3cgdGhhdCB0aGUgbGlzdGVuZXIgaXMgcmVwbHlpbmcuXG5cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRTZW5kTWVzc2FnZUNhbGxiYWNrID0gKHtcbiAgICAgICAgcmVqZWN0LFxuICAgICAgICByZXNvbHZlXG4gICAgICB9LCByZXBseSkgPT4ge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgIC8vIERldGVjdCB3aGVuIG5vbmUgb2YgdGhlIGxpc3RlbmVycyByZXBsaWVkIHRvIHRoZSBzZW5kTWVzc2FnZSBjYWxsIGFuZCByZXNvbHZlXG4gICAgICAgICAgLy8gdGhlIHByb21pc2UgdG8gdW5kZWZpbmVkIGFzIGluIEZpcmVmb3guXG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9pc3N1ZXMvMTMwXG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSA9PT0gQ0hST01FX1NFTkRfTUVTU0FHRV9DQUxMQkFDS19OT19SRVNQT05TRV9NRVNTQUdFKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlcGx5ICYmIHJlcGx5Ll9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXykge1xuICAgICAgICAgIC8vIENvbnZlcnQgYmFjayB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaW50b1xuICAgICAgICAgIC8vIGFuIEVycm9yIGluc3RhbmNlLlxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVwbHkubWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVwbHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB3cmFwcGVkU2VuZE1lc3NhZ2UgPSAobmFtZSwgbWV0YWRhdGEsIGFwaU5hbWVzcGFjZU9iaiwgLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBtZXRhZGF0YS5taW5BcmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1ldGFkYXRhLm1heEFyZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYiA9IHdyYXBwZWRTZW5kTWVzc2FnZUNhbGxiYWNrLmJpbmQobnVsbCwge1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkQ2IpO1xuICAgICAgICAgIGFwaU5hbWVzcGFjZU9iai5zZW5kTWVzc2FnZSguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGF0aWNXcmFwcGVycyA9IHtcbiAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgICBvblJlcXVlc3RGaW5pc2hlZDogd3JhcEV2ZW50KG9uUmVxdWVzdEZpbmlzaGVkV3JhcHBlcnMpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgb25NZXNzYWdlOiB3cmFwRXZlbnQob25NZXNzYWdlV3JhcHBlcnMpLFxuICAgICAgICAgIG9uTWVzc2FnZUV4dGVybmFsOiB3cmFwRXZlbnQob25NZXNzYWdlV3JhcHBlcnMpLFxuICAgICAgICAgIHNlbmRNZXNzYWdlOiB3cmFwcGVkU2VuZE1lc3NhZ2UuYmluZChudWxsLCBcInNlbmRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgICBtYXhBcmdzOiAzXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgdGFiczoge1xuICAgICAgICAgIHNlbmRNZXNzYWdlOiB3cmFwcGVkU2VuZE1lc3NhZ2UuYmluZChudWxsLCBcInNlbmRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIG1pbkFyZ3M6IDIsXG4gICAgICAgICAgICBtYXhBcmdzOiAzXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHRpbmdNZXRhZGF0YSA9IHtcbiAgICAgICAgY2xlYXI6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH0sXG4gICAgICAgIHNldDoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXBpTWV0YWRhdGEucHJpdmFjeSA9IHtcbiAgICAgICAgbmV0d29yazoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgc2VydmljZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH0sXG4gICAgICAgIHdlYnNpdGVzOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdyYXBPYmplY3QoZXh0ZW5zaW9uQVBJcywgc3RhdGljV3JhcHBlcnMsIGFwaU1ldGFkYXRhKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBjaHJvbWUgIT0gXCJvYmplY3RcIiB8fCAhY2hyb21lIHx8ICFjaHJvbWUucnVudGltZSB8fCAhY2hyb21lLnJ1bnRpbWUuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2NyaXB0IHNob3VsZCBvbmx5IGJlIGxvYWRlZCBpbiBhIGJyb3dzZXIgZXh0ZW5zaW9uLlwiKTtcbiAgICB9IC8vIFRoZSBidWlsZCBwcm9jZXNzIGFkZHMgYSBVTUQgd3JhcHBlciBhcm91bmQgdGhpcyBmaWxlLCB3aGljaCBtYWtlcyB0aGVcbiAgICAvLyBgbW9kdWxlYCB2YXJpYWJsZSBhdmFpbGFibGUuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gd3JhcEFQSXMoY2hyb21lKTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJyb3dzZXI7XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci1wb2x5ZmlsbC5qcy5tYXBcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5XSEFUV0dGZXRjaCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBnbG9iYWwgPVxuICAgICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYpIHx8XG4gICAgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCk7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnbG9iYWwsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIGdsb2JhbCAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOlxuICAgICAgJ0ZpbGVSZWFkZXInIGluIGdsb2JhbCAmJlxuICAgICAgJ0Jsb2InIGluIGdsb2JhbCAmJlxuICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGdsb2JhbCxcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBnbG9iYWxcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV07XG4gICAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgLypcbiAgICAgICAgZmV0Y2gtbW9jayB3cmFwcyB0aGUgUmVzcG9uc2Ugb2JqZWN0IGluIGFuIEVTNiBQcm94eSB0b1xuICAgICAgICBwcm92aWRlIHVzZWZ1bCB0ZXN0IGhhcm5lc3MgZmVhdHVyZXMgc3VjaCBhcyBmbHVzaC4gSG93ZXZlciwgb25cbiAgICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgICAgdGhlIHByb3h5LXBvbGx5ZmlsbCBpcyB1bmFibGUgdG8gcHJveHkgYW4gYXR0cmlidXRlIHVubGVzcyBpdCBleGlzdHNcbiAgICAgICAgb24gdGhlIG9iamVjdCBiZWZvcmUgdGhlIFByb3h5IGlzIGNyZWF0ZWQuIFRoaXMgY2hhbmdlIGVuc3VyZXNcbiAgICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICAgIHNlbWFudGljIG9mIHNldHRpbmcgUmVxdWVzdC5ib2R5VXNlZCBpbiB0aGUgY29uc3RydWN0b3IgYmVmb3JlXG4gICAgICAgIF9pbml0Qm9keSBpcyBjYWxsZWQuXG4gICAgICAqL1xuICAgICAgdGhpcy5ib2R5VXNlZCA9IHRoaXMuYm9keVVzZWQ7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgICAgaWYgKGlzQ29uc3VtZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5fYm9keUFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCArIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG5cbiAgICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhICdfJyBwYXJhbWV0ZXIgaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgICB2YXIgcmVQYXJhbVNlYXJjaCA9IC8oWz8mXSlfPVteJl0qLztcbiAgICAgICAgaWYgKHJlUGFyYW1TZWFyY2gudGVzdCh0aGlzLnVybCkpIHtcbiAgICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5yZXBsYWNlKHJlUGFyYW1TZWFyY2gsICckMV89JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGEgbmV3ICdfJyBwYXJhbWV0ZXIgdG8gdGhlIGVuZCB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vO1xuICAgICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG4gIH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGJvZHlcbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdCgnJicpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaC9pc3N1ZXMvNzQ4XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzc1MVxuICAgIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAgIC5zcGxpdCgnXFxyJylcbiAgICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgICB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHQgPT09IHVuZGVmaW5lZCA/ICcnIDogJycgKyBvcHRpb25zLnN0YXR1c1RleHQ7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGdsb2JhbC5ET01FeGNlcHRpb247XG4gIHRyeSB7XG4gICAgbmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKTtcbiAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB9O1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBleHBvcnRzLkRPTUV4Y2VwdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBmaXhVcmwodXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZ2xvYmFsLmxvY2F0aW9uLmhyZWYgPyBnbG9iYWwubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHVybFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCBmaXhVcmwocmVxdWVzdC51cmwpLCB0cnVlKTtcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBzdXBwb3J0LmFycmF5QnVmZmVyICYmXG4gICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgJiZcbiAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKS5pbmRleE9mKCdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSAhPT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbml0LmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG5vcm1hbGl6ZVZhbHVlKGluaXQuaGVhZGVyc1tuYW1lXSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpO1xuICAgIH0pXG4gIH1cblxuICBmZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG5cbiAgaWYgKCFnbG9iYWwuZmV0Y2gpIHtcbiAgICBnbG9iYWwuZmV0Y2ggPSBmZXRjaDtcbiAgICBnbG9iYWwuSGVhZGVycyA9IEhlYWRlcnM7XG4gICAgZ2xvYmFsLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIGdsb2JhbC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICB9XG5cbiAgZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbiAgZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICBleHBvcnRzLmZldGNoID0gZmV0Y2g7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTZWN1cml0eUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWN1cml0eUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlY3VyaXR5RXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlY3VyaXR5RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlNlY3VyaXR5RXJyb3IgPSBTZWN1cml0eUVycm9yO1xudmFyIEludmFsaWRTdGF0ZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZhbGlkU3RhdGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW52YWxpZFN0YXRlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkludmFsaWRTdGF0ZUVycm9yID0gSW52YWxpZFN0YXRlRXJyb3I7XG52YXIgTmV0d29ya0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXR3b3JrRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV0d29ya0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBOZXR3b3JrRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLk5ldHdvcmtFcnJvciA9IE5ldHdvcmtFcnJvcjtcbnZhciBTeW50YXhFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ludGF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ludGF4RXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN5bnRheEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5TeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3htbC1odHRwLXJlcXVlc3RcIikpO1xudmFyIHhtbF9odHRwX3JlcXVlc3RfZXZlbnRfdGFyZ2V0XzEgPSByZXF1aXJlKFwiLi94bWwtaHR0cC1yZXF1ZXN0LWV2ZW50LXRhcmdldFwiKTtcbmV4cG9ydHMuWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCA9IHhtbF9odHRwX3JlcXVlc3RfZXZlbnRfdGFyZ2V0XzEuWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFByb2dyZXNzRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudCh0eXBlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBQcm9ncmVzc0V2ZW50O1xufSgpKTtcbmV4cG9ydHMuUHJvZ3Jlc3NFdmVudCA9IFByb2dyZXNzRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9ncmVzcy1ldmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBldmVudFR5cGUgPSBldmVudFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0gfHwgW107XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0ucHVzaChsaXN0ZW5lci5oYW5kbGVFdmVudCB8fCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0uaW5kZXhPZihsaXN0ZW5lci5oYW5kbGVFdmVudCB8fCBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBldmVudC50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7IC8vIFRPRE86IHNldCBldmVudC5jdXJyZW50VGFyZ2V0P1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyXzEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJfMS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzW1wib25cIiArIGV2ZW50VHlwZV07XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldDtcbn0oKSk7XG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQgPSBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eG1sLWh0dHAtcmVxdWVzdC1ldmVudC10YXJnZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB4bWxfaHR0cF9yZXF1ZXN0X2V2ZW50X3RhcmdldF8xID0gcmVxdWlyZShcIi4veG1sLWh0dHAtcmVxdWVzdC1ldmVudC10YXJnZXRcIik7XG52YXIgWE1MSHR0cFJlcXVlc3RVcGxvYWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhNTEh0dHBSZXF1ZXN0VXBsb2FkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0VXBsb2FkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5fYm9keSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9yZXNldCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYm9keSA9IG51bGw7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3NldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JvZHkgPSBuZXcgQnVmZmVyKGRhdGEsICd1dGYtOCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5fYm9keSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCdWZmZXIoZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYm9keVtpXSA9IHZpZXdbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLmJ1ZmZlciAmJiBkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCdWZmZXIoZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBib2R5W2ldID0gdmlld1tpICsgb2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc2VuZCgpIGRhdGEgXCIgKyBkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbiAoaGVhZGVycywgbG93ZXJlZEhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRUeXBlICYmICFsb3dlcmVkSGVhZGVyc1snY29udGVudC10eXBlJ10pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5fY29udGVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JvZHkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSB0aGlzLl9ib2R5Lmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3N0YXJ0VXBsb2FkID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHkpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qud3JpdGUodGhpcy5fYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9O1xuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdFVwbG9hZDtcbn0oeG1sX2h0dHBfcmVxdWVzdF9ldmVudF90YXJnZXRfMS5YTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KSk7XG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0VXBsb2FkID0gWE1MSHR0cFJlcXVlc3RVcGxvYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14bWwtaHR0cC1yZXF1ZXN0LXVwbG9hZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xudmFyIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xudmFyIG9zID0gcmVxdWlyZShcIm9zXCIpO1xudmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG52YXIgcHJvZ3Jlc3NfZXZlbnRfMSA9IHJlcXVpcmUoXCIuL3Byb2dyZXNzLWV2ZW50XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIHhtbF9odHRwX3JlcXVlc3RfZXZlbnRfdGFyZ2V0XzEgPSByZXF1aXJlKFwiLi94bWwtaHR0cC1yZXF1ZXN0LWV2ZW50LXRhcmdldFwiKTtcbnZhciB4bWxfaHR0cF9yZXF1ZXN0X3VwbG9hZF8xID0gcmVxdWlyZShcIi4veG1sLWh0dHAtcmVxdWVzdC11cGxvYWRcIik7XG52YXIgQ29va2llID0gcmVxdWlyZShcImNvb2tpZWphclwiKTtcbnZhciBYTUxIdHRwUmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWE1MSHR0cFJlcXVlc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5VTlNFTlQgPSBYTUxIdHRwUmVxdWVzdC5VTlNFTlQ7XG4gICAgICAgIF90aGlzLk9QRU5FRCA9IFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRDtcbiAgICAgICAgX3RoaXMuSEVBREVSU19SRUNFSVZFRCA9IFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQ7XG4gICAgICAgIF90aGlzLkxPQURJTkcgPSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HO1xuICAgICAgICBfdGhpcy5ET05FID0gWE1MSHR0cFJlcXVlc3QuRE9ORTtcbiAgICAgICAgX3RoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmVhZHlTdGF0ZSA9IFhNTEh0dHBSZXF1ZXN0LlVOU0VOVDtcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgICBfdGhpcy5yZXNwb25zZVRleHQgPSAnJztcbiAgICAgICAgX3RoaXMucmVzcG9uc2VUeXBlID0gJyc7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9IDA7IC8vIFRPRE86IFVOU0VOVD9cbiAgICAgICAgX3RoaXMuc3RhdHVzVGV4dCA9ICcnO1xuICAgICAgICBfdGhpcy50aW1lb3V0ID0gMDtcbiAgICAgICAgX3RoaXMudXBsb2FkID0gbmV3IHhtbF9odHRwX3JlcXVlc3RfdXBsb2FkXzEuWE1MSHR0cFJlcXVlc3RVcGxvYWQoKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2VVcmwgPSAnJztcbiAgICAgICAgX3RoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9tZXRob2QgPSBudWxsO1xuICAgICAgICBfdGhpcy5fdXJsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3N5bmMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgX3RoaXMuX2xvd2VyZWRIZWFkZXJzID0ge307XG4gICAgICAgIF90aGlzLl9taW1lT3ZlcnJpZGUgPSBudWxsOyAvLyBUT0RPOiBpcyB0eXBlIHJpZ2h0P1xuICAgICAgICBfdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9yZXNwb25zZVBhcnRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IG51bGw7XG4gICAgICAgIF90aGlzLl9hYm9ydGluZyA9IG51bGw7IC8vIFRPRE86IHR5cGU/XG4gICAgICAgIF90aGlzLl9lcnJvciA9IG51bGw7IC8vIFRPRE86IHR5cGU/XG4gICAgICAgIF90aGlzLl9sb2FkZWRCeXRlcyA9IDA7XG4gICAgICAgIF90aGlzLl90b3RhbEJ5dGVzID0gMDtcbiAgICAgICAgX3RoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3Jlc3RyaWN0ZWRNZXRob2RzID0geyBDT05ORUNUOiB0cnVlLCBUUkFDRTogdHJ1ZSwgVFJBQ0s6IHRydWUgfTtcbiAgICAgICAgX3RoaXMuX3Jlc3RyaWN0ZWRIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2FjY2VwdC1jaGFyc2V0JzogdHJ1ZSxcbiAgICAgICAgICAgICdhY2NlcHQtZW5jb2RpbmcnOiB0cnVlLFxuICAgICAgICAgICAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnOiB0cnVlLFxuICAgICAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICdjb250ZW50LWxlbmd0aCc6IHRydWUsXG4gICAgICAgICAgICBjb29raWU6IHRydWUsXG4gICAgICAgICAgICBjb29raWUyOiB0cnVlLFxuICAgICAgICAgICAgZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIGhvc3Q6IHRydWUsXG4gICAgICAgICAgICAna2VlcC1hbGl2ZSc6IHRydWUsXG4gICAgICAgICAgICBvcmlnaW46IHRydWUsXG4gICAgICAgICAgICByZWZlcmVyOiB0cnVlLFxuICAgICAgICAgICAgdGU6IHRydWUsXG4gICAgICAgICAgICB0cmFpbGVyOiB0cnVlLFxuICAgICAgICAgICAgJ3RyYW5zZmVyLWVuY29kaW5nJzogdHJ1ZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRydWUsXG4gICAgICAgICAgICAndXNlci1hZ2VudCc6IHRydWUsXG4gICAgICAgICAgICB2aWE6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX3ByaXZhdGVIZWFkZXJzID0geyAnc2V0LWNvb2tpZSc6IHRydWUsICdzZXQtY29va2llMic6IHRydWUgfTtcbiAgICAgICAgX3RoaXMuX3VzZXJBZ2VudCA9IFwiTW96aWxsYS81LjAgKFwiICsgb3MudHlwZSgpICsgXCIgXCIgKyBvcy5hcmNoKCkgKyBcIikgbm9kZS5qcy9cIiArIHByb2Nlc3MudmVyc2lvbnMubm9kZSArIFwiIHY4L1wiICsgcHJvY2Vzcy52ZXJzaW9ucy52ODtcbiAgICAgICAgX3RoaXMuX2Fub255bW91cyA9IG9wdGlvbnMuYW5vbiB8fCBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XG4gICAgICAgIGlmIChhc3luYyA9PT0gdm9pZCAwKSB7IGFzeW5jID0gdHJ1ZTsgfVxuICAgICAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3RyaWN0ZWRNZXRob2RzW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBYTUxIdHRwUmVxdWVzdC5TZWN1cml0eUVycm9yKFwiSFRUUCBtZXRob2QgXCIgKyBtZXRob2QgKyBcIiBpcyBub3QgYWxsb3dlZCBpbiBYSFJcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB2YXIgeGhyVXJsID0gdGhpcy5fcGFyc2VVcmwodXJsLCB1c2VyLCBwYXNzd29yZCk7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HKSB7XG4gICAgICAgICAgICAvLyBUT0RPKHB3bmFsbCk6IHRlcm1pbmF0ZSBhYm9ydCgpLCB0ZXJtaW5hdGUgc2VuZCgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLl91cmwgPSB4aHJVcmw7XG4gICAgICAgIHRoaXMuX3N5bmMgPSAhYXN5bmM7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fbG93ZXJlZEhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fbWltZU92ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5PUEVORUQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDA7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnO1xuICAgICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gW107XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvYWRlZEJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy5fdG90YWxCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFhNTEh0dHBSZXF1ZXN0LkludmFsaWRTdGF0ZUVycm9yKCdYSFIgcmVhZHlTdGF0ZSBtdXN0IGJlIE9QRU5FRCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb3dlcmVkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3RyaWN0ZWRIZWFkZXJzW2xvd2VyZWROYW1lXSB8fCAvXnNlYy0vLnRlc3QobG93ZXJlZE5hbWUpIHx8IC9ecHJveHktLy50ZXN0KGxvd2VyZWROYW1lKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuX2xvd2VyZWRIZWFkZXJzW2xvd2VyZWROYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5fbG93ZXJlZEhlYWRlcnNbbG93ZXJlZE5hbWVdO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyc1tuYW1lXSA9IHRoaXMuX2hlYWRlcnNbbmFtZV0gKyBcIiwgXCIgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xvd2VyZWRIZWFkZXJzW2xvd2VyZWROYW1lXSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWE1MSHR0cFJlcXVlc3QuSW52YWxpZFN0YXRlRXJyb3IoJ1hIUiByZWFkeVN0YXRlIG11c3QgYmUgT1BFTkVEJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBYTUxIdHRwUmVxdWVzdC5JbnZhbGlkU3RhdGVFcnJvcignc2VuZCgpIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLl91cmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGU6JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEZpbGUoZGF0YSk7XG4gICAgICAgICAgICBjYXNlICdodHRwOic6XG4gICAgICAgICAgICBjYXNlICdodHRwczonOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kSHR0cChkYXRhKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFhNTEh0dHBSZXF1ZXN0Lk5ldHdvcmtFcnJvcihcIlVuc3VwcG9ydGVkIHByb3RvY29sIFwiICsgdGhpcy5fdXJsLnByb3RvY29sKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdhYm9ydCcpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2VIZWFkZXJzID09IG51bGwgfHwgbmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG93ZXJlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZUhlYWRlcnMuaGFzT3duUHJvcGVydHkobG93ZXJlZE5hbWUpXG4gICAgICAgICAgICA/IHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2VIZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcmVzcG9uc2VIZWFkZXJzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ICsgXCI6IFwiICsgX3RoaXMuX3Jlc3BvbnNlSGVhZGVyc1trZXldOyB9KS5qb2luKCdcXHJcXG4nKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vdmVycmlkZU1pbWVUeXBlID0gZnVuY3Rpb24gKG1pbWVUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWE1MSHR0cFJlcXVlc3QuSW52YWxpZFN0YXRlRXJyb3IoJ292ZXJyaWRlTWltZVR5cGUoKSBub3QgYWxsb3dlZCBpbiBMT0FESU5HIG9yIERPTkUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9taW1lT3ZlcnJpZGUgPSBtaW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc1NldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubm9kZWpzSHR0cEFnZW50ID0gb3B0aW9ucy5odHRwQWdlbnQgfHwgdGhpcy5ub2RlanNIdHRwQWdlbnQ7XG4gICAgICAgIHRoaXMubm9kZWpzSHR0cHNBZ2VudCA9IG9wdGlvbnMuaHR0cHNBZ2VudCB8fCB0aGlzLm5vZGVqc0h0dHBzQWdlbnQ7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdiYXNlVXJsJykpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJhc2VVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWRVcmwgPSB1cmwucGFyc2Uob3B0aW9ucy5iYXNlVXJsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFhNTEh0dHBSZXF1ZXN0LlN5bnRheEVycm9yKFwiYmFzZVVybCBtdXN0IGJlIGFuIGFic29sdXRlIFVSTFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vZGVqc0Jhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0Lm5vZGVqc1NldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNTZXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NldFJlYWR5U3RhdGUgPSBmdW5jdGlvbiAocmVhZHlTdGF0ZSkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSByZWFkeVN0YXRlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IHByb2dyZXNzX2V2ZW50XzEuUHJvZ3Jlc3NFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2VuZEZpbGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgZmlsZTogbm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRIdHRwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N5bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3luY2hyb25vdXMgWEhSIHByb2Nlc3Npbmcgbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgJiYgKHRoaXMuX21ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5fbWV0aG9kID09PSAnSEVBRCcpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEaXNjYXJkaW5nIGVudGl0eSBib2R5IGZvciBcIiArIHRoaXMuX21ldGhvZCArIFwiIHJlcXVlc3RzXCIpO1xuICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwbG9hZC5fc2V0RGF0YShkYXRhKTtcbiAgICAgICAgdGhpcy5fZmluYWxpemVIZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuX3NlbmRIeHhwUmVxdWVzdCgpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZW5kSHh4cFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLndpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgICAgdmFyIGNvb2tpZSA9IFhNTEh0dHBSZXF1ZXN0LmNvb2tpZUphclxuICAgICAgICAgICAgICAgIC5nZXRDb29raWVzKENvb2tpZS5Db29raWVBY2Nlc3NJbmZvKHRoaXMuX3VybC5ob3N0bmFtZSwgdGhpcy5fdXJsLnBhdGhuYW1lLCB0aGlzLl91cmwucHJvdG9jb2wgPT09ICdodHRwczonKSkudG9WYWx1ZVN0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5jb29raWUgPSB0aGlzLl9oZWFkZXJzLmNvb2tpZTIgPSBjb29raWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdXJsLnByb3RvY29sID09PSAnaHR0cDonID8gW2h0dHAsIHRoaXMubm9kZWpzSHR0cEFnZW50XSA6IFtodHRwcywgdGhpcy5ub2RlanNIdHRwc0FnZW50XSwgaHh4cCA9IF9hWzBdLCBhZ2VudCA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVxdWVzdE1ldGhvZCA9IGh4eHAucmVxdWVzdC5iaW5kKGh4eHApO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlcXVlc3RNZXRob2Qoe1xuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuX3VybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6ICt0aGlzLl91cmwucG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuX3VybC5wYXRoLFxuICAgICAgICAgICAgYXV0aDogdGhpcy5fdXJsLmF1dGgsXG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMuX21ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMsXG4gICAgICAgICAgICBhZ2VudDogYWdlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQodGhpcy50aW1lb3V0LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25IdHRwVGltZW91dChyZXF1ZXN0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSk7IH0pO1xuICAgICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX3RoaXMuX29uSHR0cFJlcXVlc3RFcnJvcihyZXF1ZXN0LCBlcnJvcik7IH0pO1xuICAgICAgICB0aGlzLnVwbG9hZC5fc3RhcnRVcGxvYWQocmVxdWVzdCk7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ID09PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSBfX2Fzc2lnbih7fSwgdGhpcy5faGVhZGVycywgeyBDb25uZWN0aW9uOiAna2VlcC1hbGl2ZScsIEhvc3Q6IHRoaXMuX3VybC5ob3N0LCAnVXNlci1BZ2VudCc6IHRoaXMuX3VzZXJBZ2VudCB9LCB0aGlzLl9hbm9ueW1vdXMgPyB7IFJlZmVyZXI6ICdhYm91dDpibGFuaycgfSA6IHt9KTtcbiAgICAgICAgdGhpcy51cGxvYWQuX2ZpbmFsaXplSGVhZGVycyh0aGlzLl9oZWFkZXJzLCB0aGlzLl9sb3dlcmVkSGVhZGVycyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2l0aENyZWRlbnRpYWxzICYmIChyZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10gfHwgcmVzcG9uc2UuaGVhZGVyc1snc2V0LWNvb2tpZTInXSkpIHtcbiAgICAgICAgICAgIFhNTEh0dHBSZXF1ZXN0LmNvb2tpZUphclxuICAgICAgICAgICAgICAgIC5zZXRDb29raWVzKHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXSB8fCByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llMiddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XS5pbmRleE9mKHJlc3BvbnNlLnN0YXR1c0NvZGUpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3VybCA9IHRoaXMuX3BhcnNlVXJsKHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbdGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1snQ29udGVudC1MZW5ndGgnXTtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkLl9yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemVIZWFkZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kSHh4cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLl9yZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VEYXRhKHJlc3BvbnNlLCBkYXRhKTsgfSk7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VFbmQocmVzcG9uc2UpOyB9KTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uSHR0cFJlc3BvbnNlQ2xvc2UocmVzcG9uc2UpOyB9KTtcbiAgICAgICAgdGhpcy5yZXNwb25zZVVybCA9IHRoaXMuX3VybC5ocmVmLnNwbGl0KCcjJylbMF07XG4gICAgICAgIHRoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gaHR0cC5TVEFUVVNfQ09ERVNbdGhpcy5zdGF0dXNdO1xuICAgICAgICB0aGlzLl9wYXJzZVJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgICAgIHZhciBsZW5ndGhTdHJpbmcgPSB0aGlzLl9yZXNwb25zZUhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gfHwgJyc7XG4gICAgICAgIHRoaXMuX3RvdGFsQnl0ZXMgPSArbGVuZ3RoU3RyaW5nO1xuICAgICAgICB0aGlzLl9sZW5ndGhDb21wdXRhYmxlID0gISFsZW5ndGhTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlRGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cy5wdXNoKG5ldyBCdWZmZXIoZGF0YSkpO1xuICAgICAgICB0aGlzLl9sb2FkZWRCeXRlcyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuTE9BRElORykge1xuICAgICAgICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5MT0FESU5HKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdwcm9ncmVzcycpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXNwb25zZUVuZCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyc2VSZXNwb25zZSgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkJyk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVzcG9uc2VDbG9zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0O1xuICAgICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2Vycm9yJyk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwVGltZW91dCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCd0aW1lb3V0Jyk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVxdWVzdEVycm9yID0gZnVuY3Rpb24gKHJlcXVlc3QsIGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdlcnJvcicpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX2Rpc3BhdGNoUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBYTUxIdHRwUmVxdWVzdC5Qcm9ncmVzc0V2ZW50KGV2ZW50VHlwZSk7XG4gICAgICAgIGV2ZW50Lmxlbmd0aENvbXB1dGFibGUgPSB0aGlzLl9sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICBldmVudC5sb2FkZWQgPSB0aGlzLl9sb2FkZWRCeXRlcztcbiAgICAgICAgZXZlbnQudG90YWwgPSB0aGlzLl90b3RhbEJ5dGVzO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZXRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cyA9IG51bGw7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlVXJsID0gZnVuY3Rpb24gKHVybFN0cmluZywgdXNlciwgcGFzc3dvcmQpIHtcbiAgICAgICAgdmFyIGFic29sdXRlVXJsID0gdGhpcy5ub2RlanNCYXNlVXJsID09IG51bGwgPyB1cmxTdHJpbmcgOiB1cmwucmVzb2x2ZSh0aGlzLm5vZGVqc0Jhc2VVcmwsIHVybFN0cmluZyk7XG4gICAgICAgIHZhciB4aHJVcmwgPSB1cmwucGFyc2UoYWJzb2x1dGVVcmwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgeGhyVXJsLmhhc2ggPSBudWxsO1xuICAgICAgICB2YXIgX2EgPSAoeGhyVXJsLmF1dGggfHwgJycpLnNwbGl0KCc6JyksIHhoclVzZXIgPSBfYVswXSwgeGhyUGFzc3dvcmQgPSBfYVsxXTtcbiAgICAgICAgaWYgKHhoclVzZXIgfHwgeGhyUGFzc3dvcmQgfHwgdXNlciB8fCBwYXNzd29yZCkge1xuICAgICAgICAgICAgeGhyVXJsLmF1dGggPSAodXNlciB8fCB4aHJVc2VyIHx8ICcnKSArIFwiOlwiICsgKHBhc3N3b3JkIHx8IHhoclBhc3N3b3JkIHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geGhyVXJsO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBsb3dlcmVkTmFtZSA9IG5hbWVfMS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVIZWFkZXJzW2xvd2VyZWROYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzW2xvd2VyZWROYW1lXSA9IHJlc3BvbnNlLmhlYWRlcnNbbmFtZV8xXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWltZU92ZXJyaWRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1snY29udGVudC10eXBlJ10gPSB0aGlzLl9taW1lT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQodGhpcy5fcmVzcG9uc2VQYXJ0cyk7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBhcnJheUJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBidWZmZXIudG9TdHJpbmcodGhpcy5fcGFyc2VSZXNwb25zZUVuY29kaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZUVuY29kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLztcXHMqY2hhcnNldD0oLiopJC8uZXhlYyh0aGlzLl9yZXNwb25zZUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnKVsxXSB8fCAndXRmLTgnO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QuUHJvZ3Jlc3NFdmVudCA9IHByb2dyZXNzX2V2ZW50XzEuUHJvZ3Jlc3NFdmVudDtcbiAgICBYTUxIdHRwUmVxdWVzdC5JbnZhbGlkU3RhdGVFcnJvciA9IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yO1xuICAgIFhNTEh0dHBSZXF1ZXN0Lk5ldHdvcmtFcnJvciA9IGVycm9yc18xLk5ldHdvcmtFcnJvcjtcbiAgICBYTUxIdHRwUmVxdWVzdC5TZWN1cml0eUVycm9yID0gZXJyb3JzXzEuU2VjdXJpdHlFcnJvcjtcbiAgICBYTUxIdHRwUmVxdWVzdC5TeW50YXhFcnJvciA9IGVycm9yc18xLlN5bnRheEVycm9yO1xuICAgIFhNTEh0dHBSZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0VXBsb2FkID0geG1sX2h0dHBfcmVxdWVzdF91cGxvYWRfMS5YTUxIdHRwUmVxdWVzdFVwbG9hZDtcbiAgICBYTUxIdHRwUmVxdWVzdC5VTlNFTlQgPSAwO1xuICAgIFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCA9IDE7XG4gICAgWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCA9IDI7XG4gICAgWE1MSHR0cFJlcXVlc3QuTE9BRElORyA9IDM7XG4gICAgWE1MSHR0cFJlcXVlc3QuRE9ORSA9IDQ7XG4gICAgWE1MSHR0cFJlcXVlc3QuY29va2llSmFyID0gQ29va2llLkNvb2tpZUphcigpO1xuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdDtcbn0oeG1sX2h0dHBfcmVxdWVzdF9ldmVudF90YXJnZXRfMS5YTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KSk7XG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3Q7XG5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzSHR0cEFnZW50ID0gaHR0cC5nbG9iYWxBZ2VudDtcblhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNIdHRwc0FnZW50ID0gaHR0cHMuZ2xvYmFsQWdlbnQ7XG5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzQmFzZVVybCA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14bWwtaHR0cC1yZXF1ZXN0LmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gWE1MSHR0cFJlcXVlc3Q7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiZXhwb3J0IGNvbnN0IEFMRVJUX1RZUEVTID0ge1xyXG4gIHVuY29ubmVjdGVkQWNjb3VudDogJ3VuY29ubmVjdGVkQWNjb3VudCcsXHJcbiAgd2ViM1NoaW1Vc2FnZTogJ3dlYjNTaGltVXNhZ2UnLFxyXG4gIGludmFsaWRDdXN0b21OZXR3b3JrOiAnaW52YWxpZEN1c3RvbU5ldHdvcmsnLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsZXJ0cyB0aGF0IGNhbiBiZSBlbmFibGVkIG9yIGRpc2FibGVkIGJ5IHRoZSB1c2VyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRPR0dMRUFCTEVfQUxFUlRfVFlQRVMgPSBbXHJcbiAgQUxFUlRfVFlQRVMudW5jb25uZWN0ZWRBY2NvdW50LFxyXG4gIEFMRVJUX1RZUEVTLndlYjNTaGltVXNhZ2UsXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgV0VCM19TSElNX1VTQUdFX0FMRVJUX1NUQVRFUyA9IHtcclxuICBSRUNPUkRFRDogMSxcclxuICBESVNNSVNTRUQ6IDIsXHJcbn07XHJcbiIsImltcG9ydCB7IFJlc3RyaWN0ZWRNZXRob2RzIH0gZnJvbSAnLi9wZXJtaXNzaW9ucyc7XHJcblxyXG4vKipcclxuICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGVudmlyb25tZW50IHRoZSBhcHBsaWNhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZyBpblxyXG4gKiBwb3B1cCAtIFdoZW4gdGhlIHVzZXIgY2xpY2sncyB0aGUgaWNvbiBpbiB0aGVpciBicm93c2VyJ3MgZXh0ZW5zaW9uIGJhcjsgdGhlIGRlZmF1bHQgdmlld1xyXG4gKiBub3RpZmljYXRpb24gLSBXaGVuIHRoZSBleHRlbnNpb24gb3BlbnMgZHVlIHRvIGludGVyYWN0aW9uIHdpdGggYSBXZWIzIGVuYWJsZWQgd2Vic2l0ZVxyXG4gKiBmdWxsc2NyZWVuIC0gV2hlbiB0aGUgdXNlciBjbGlja3MgJ2V4cGFuZCB2aWV3JyB0byBvcGVuIHRoZSBleHRlbnNpb24gaW4gYSBuZXcgdGFiXHJcbiAqIGJhY2tncm91bmQgLSBUaGUgYmFja2dyb3VuZCBwcm9jZXNzIHRoYXQgcG93ZXJzIHRoZSBleHRlbnNpb25cclxuICovXHJcbmV4cG9ydCB0eXBlIEVudmlyb25tZW50VHlwZSA9XHJcbiAgfCAncG9wdXAnXHJcbiAgfCAnbm90aWZpY2F0aW9uJ1xyXG4gIHwgJ2Z1bGxzY3JlZW4nXHJcbiAgfCAnYmFja2dyb3VuZCc7XHJcbmV4cG9ydCBjb25zdCBFTlZJUk9OTUVOVF9UWVBFX1BPUFVQID0gJ3BvcHVwJztcclxuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OID0gJ25vdGlmaWNhdGlvbic7XHJcbmV4cG9ydCBjb25zdCBFTlZJUk9OTUVOVF9UWVBFX0ZVTExTQ1JFRU4gPSAnZnVsbHNjcmVlbic7XHJcbmV4cG9ydCBjb25zdCBFTlZJUk9OTUVOVF9UWVBFX0JBQ0tHUk9VTkQgPSAnYmFja2dyb3VuZCc7XHJcblxyXG4vKipcclxuICogVGhlIGRpc3RyaWJ1dGlvbiB0aGlzIGJ1aWxkIGlzIGludGVuZGVkIGZvci5cclxuICpcclxuICogVGhpcyBzaG91bGQgYmUga2VwdCBpbi1zeW5jIHdpdGggdGhlIGBCdWlsZFR5cGVgIG1hcCBpbiBgZGV2ZWxvcG1lbnQvYnVpbGQvdXRpbHMuanNgLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEJ1aWxkVHlwZSA9IHtcclxuICBiZXRhOiAnYmV0YScsXHJcbiAgZmxhc2s6ICdmbGFzaycsXHJcbiAgbWFpbjogJ21haW4nLFxyXG59IGFzIGNvbnN0O1xyXG5cclxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0JSQVZFID0gJ0JyYXZlJztcclxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0NIUk9NRSA9ICdDaHJvbWUnO1xyXG5leHBvcnQgY29uc3QgUExBVEZPUk1fRURHRSA9ICdFZGdlJztcclxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0ZJUkVGT1ggPSAnRmlyZWZveCc7XHJcbmV4cG9ydCBjb25zdCBQTEFURk9STV9PUEVSQSA9ICdPcGVyYSc7XHJcblxyXG5leHBvcnQgY29uc3QgTUVTU0FHRV9UWVBFID0ge1xyXG4gIEFERF9FVEhFUkVVTV9DSEFJTjogJ3dhbGxldF9hZGRFdGhlcmV1bUNoYWluJyxcclxuICBFVEhfQUNDT1VOVFM6IFJlc3RyaWN0ZWRNZXRob2RzLmV0aF9hY2NvdW50cyxcclxuICBFVEhfREVDUllQVDogJ2V0aF9kZWNyeXB0JyxcclxuICBFVEhfR0VUX0VOQ1JZUFRJT05fUFVCTElDX0tFWTogJ2V0aF9nZXRFbmNyeXB0aW9uUHVibGljS2V5JyxcclxuICBFVEhfUkVRVUVTVF9BQ0NPVU5UUzogJ2V0aF9yZXF1ZXN0QWNjb3VudHMnLFxyXG4gIEVUSF9TSUdOOiAnZXRoX3NpZ24nLFxyXG4gIEVUSF9TSUdOX1RZUEVEX0RBVEE6ICdldGhfc2lnblR5cGVkRGF0YScsXHJcbiAgRVRIX1NJR05fVFlQRURfREFUQV9WMzogJ2V0aF9zaWduVHlwZWREYXRhX3YzJyxcclxuICBFVEhfU0lHTl9UWVBFRF9EQVRBX1Y0OiAnZXRoX3NpZ25UeXBlZERhdGFfdjQnLFxyXG4gIEdFVF9QUk9WSURFUl9TVEFURTogJ21ldGFtYXNrX2dldFByb3ZpZGVyU3RhdGUnLFxyXG4gIExPR19XRUIzX1NISU1fVVNBR0U6ICdtZXRhbWFza19sb2dXZWIzU2hpbVVzYWdlJyxcclxuICBQRVJTT05BTF9TSUdOOiAncGVyc29uYWxfc2lnbicsXHJcbiAgU0VORF9NRVRBREFUQTogJ21ldGFtYXNrX3NlbmREb21haW5NZXRhZGF0YScsXHJcbiAgU1dJVENIX0VUSEVSRVVNX0NIQUlOOiAnd2FsbGV0X3N3aXRjaEV0aGVyZXVtQ2hhaW4nLFxyXG4gIFdBTExFVF9SRVFVRVNUX1BFUk1JU1NJT05TOiAnd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9ucycsXHJcbiAgV0FUQ0hfQVNTRVQ6ICd3YWxsZXRfd2F0Y2hBc3NldCcsXHJcbiAgV0FUQ0hfQVNTRVRfTEVHQUNZOiAnbWV0YW1hc2tfd2F0Y2hBc3NldCcsXHJcbiAgLy8vOiBCRUdJTjpPTkxZX0lOQ0xVREVfSU4oZmxhc2spXHJcbiAgU05BUF9DT05GSVJNOiBSZXN0cmljdGVkTWV0aG9kcy5zbmFwX2NvbmZpcm0sXHJcbiAgLy8vOiBFTkQ6T05MWV9JTkNMVURFX0lOXHJcbn0gYXMgY29uc3Q7XHJcblxyXG4vKipcclxuICogVGhlIGRpZmZlcmVudCBraW5kcyBvZiBzdWJqZWN0cyB0aGF0IE1ldGFNYXNrIG1heSBpbnRlcmFjdCB3aXRoLCBpbmNsdWRpbmdcclxuICogdGhpcmQgcGFydGllcyBhbmQgaXRzZWxmIChlLmcuIHdoZW4gdGhlIGJhY2tncm91bmQgY29tbXVuaWNhdGVkIHdpdGggdGhlIFVJKS5cclxuICovXHJcbmV4cG9ydCBjb25zdCBTVUJKRUNUX1RZUEVTID0ge1xyXG4gIEVYVEVOU0lPTjogJ2V4dGVuc2lvbicsXHJcbiAgSU5URVJOQUw6ICdpbnRlcm5hbCcsXHJcbiAgVU5LTk9XTjogJ3Vua25vd24nLFxyXG4gIFdFQlNJVEU6ICd3ZWJzaXRlJyxcclxuICAvLy86IEJFR0lOOk9OTFlfSU5DTFVERV9JTihmbGFzaylcclxuICBTTkFQOiAnc25hcCcsXHJcbiAgLy8vOiBFTkQ6T05MWV9JTkNMVURFX0lOXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5leHBvcnQgY29uc3QgUE9MTElOR19UT0tFTl9FTlZJUk9OTUVOVF9UWVBFUyA9IHtcclxuICBbRU5WSVJPTk1FTlRfVFlQRV9QT1BVUF06ICdwb3B1cEdhc1BvbGxUb2tlbnMnLFxyXG4gIFtFTlZJUk9OTUVOVF9UWVBFX05PVElGSUNBVElPTl06ICdub3RpZmljYXRpb25HYXNQb2xsVG9rZW5zJyxcclxuICBbRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOXTogJ2Z1bGxTY3JlZW5HYXNQb2xsVG9rZW5zJyxcclxufSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBPUklHSU5fTUVUQU1BU0sgPSAnbWV0YW1hc2snO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0JFVEFfQ0hST01FX0lEID0gJ3BiYmthbWZnbWFlZGNjbmZrbWpjb2ZjZWNqaGZnbGRuJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX1BST0RfQ0hST01FX0lEID0gJ25rYmloZmJlb2dhZWFvZWhsZWZua29kYmVmZ3Bna25uJztcclxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0ZMQVNLX0NIUk9NRV9JRCA9ICdsamZvZWluanBhZWRqZmVjYm1nZ2pnb2RiZ2ttamtqayc7XHJcblxyXG5leHBvcnQgY29uc3QgQ0hST01FX0JVSUxEX0lEUyA9IFtcclxuICBNRVRBTUFTS19CRVRBX0NIUk9NRV9JRCxcclxuICBNRVRBTUFTS19QUk9EX0NIUk9NRV9JRCxcclxuICBNRVRBTUFTS19GTEFTS19DSFJPTUVfSUQsXHJcbl0gYXMgY29uc3Q7XHJcblxyXG5jb25zdCBNRVRBTUFTS19CRVRBX0ZJUkVGT1hfSUQgPSAnd2ViZXh0ZW5zaW9uLWJldGFAbWV0YW1hc2suaW8nO1xyXG5jb25zdCBNRVRBTUFTS19QUk9EX0ZJUkVGT1hfSUQgPSAnd2ViZXh0ZW5zaW9uQG1ldGFtYXNrLmlvJztcclxuY29uc3QgTUVUQU1BU0tfRkxBU0tfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb24tZmxhc2tAbWV0YW1hc2suaW8nO1xyXG5cclxuZXhwb3J0IGNvbnN0IEZJUkVGT1hfQlVJTERfSURTID0gW1xyXG4gIE1FVEFNQVNLX0JFVEFfRklSRUZPWF9JRCxcclxuICBNRVRBTUFTS19QUk9EX0ZJUkVGT1hfSUQsXHJcbiAgTUVUQU1BU0tfRkxBU0tfRklSRUZPWF9JRCxcclxuXSBhcyBjb25zdDtcclxuXHJcbmV4cG9ydCBjb25zdCBVTktOT1dOX1RJQ0tFUl9TWU1CT0wgPSAnVU5LTk9XTic7XHJcbiIsImltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XHJcblxyXG5jb25zdCBPTkVfSFVORFJFRF9USE9VU0FORCA9IDEwMDAwMDtcclxuY29uc3QgTUlOX0dBU19MSU1JVF9ERUMgPSAnMjEwMDAnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1JTl9HQVNfTElNSVRfSEVYID0gcGFyc2VJbnQoTUlOX0dBU19MSU1JVF9ERUMsIDEwKS50b1N0cmluZygxNik7XHJcblxyXG5leHBvcnQgY29uc3QgR0FTX0xJTUlUUyA9IHtcclxuICAvLyBtYXhpbXVtIGdhc0xpbWl0IG9mIGEgc2ltcGxlIHNlbmRcclxuICBTSU1QTEU6IGFkZEhleFByZWZpeChNSU5fR0FTX0xJTUlUX0hFWCksXHJcbiAgLy8gYSBiYXNlIGVzdGltYXRlIGZvciB0b2tlbiB0cmFuc2ZlcnMuXHJcbiAgQkFTRV9UT0tFTl9FU1RJTUFURTogYWRkSGV4UHJlZml4KE9ORV9IVU5EUkVEX1RIT1VTQU5ELnRvU3RyaW5nKDE2KSksXHJcbn07XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gR2FzRXN0aW1hdGVUeXBlc1xyXG4gKiBAcHJvcGVydHkgeydmZWUtbWFya2V0J30gRkVFX01BUktFVCAtIEEgZ2FzIGVzdGltYXRlIGZvciBhIGZlZSBtYXJrZXRcclxuICogIHRyYW5zYWN0aW9uIGdlbmVyYXRlZCBieSBvdXIgZ2FzIGVzdGltYXRpb24gQVBJLlxyXG4gKiBAcHJvcGVydHkgeydsZWdhY3knfSBMRUdBQ1kgLSBBIGdhcyBlc3RpbWF0ZSBmb3IgYSBsZWdhY3kgVHJhbnNhY3Rpb25cclxuICogIGdlbmVyYXRlZCBieSBvdXIgZ2FzIGVzdGltYXRpb24gQVBJLlxyXG4gKiBAcHJvcGVydHkgeydldGhfZ2FzUHJpY2UnfSBFVEhfR0FTX1BSSUNFIC0gQSBnYXMgZXN0aW1hdGUgcHJvdmlkZWQgYnkgdGhlXHJcbiAqICBFdGhlcmV1bSBub2RlIHZpYSBldGhfZ2FzUHJpY2UuXHJcbiAqIEBwcm9wZXJ0eSB7J25vbmUnfSBOT05FIC0gTm8gZ2FzIGVzdGltYXRlIGF2YWlsYWJsZS5cclxuICovXHJcblxyXG4vKipcclxuICogVGhlc2UgYXJlIGFscmVhZHkgZGVjbGFyZWQgaW4gQG1ldGFtYXNrL2NvbnRyb2xsZXJzIGJ1dCBpbXBvcnRpbmcgdGhlbSBmcm9tXHJcbiAqIHRoYXQgbW9kdWxlIGFuZCByZS1leHBvcnRpbmcgY2F1c2VzIHRoZSBVSSBidW5kbGUgc2l6ZSB0byBleHBhbmQgYmV5b25kIDRNQlxyXG4gKlxyXG4gKiBAdHlwZSB7R2FzRXN0aW1hdGVUeXBlc31cclxuICovXHJcbmV4cG9ydCBjb25zdCBHQVNfRVNUSU1BVEVfVFlQRVMgPSB7XHJcbiAgRkVFX01BUktFVDogJ2ZlZS1tYXJrZXQnLFxyXG4gIExFR0FDWTogJ2xlZ2FjeScsXHJcbiAgRVRIX0dBU1BSSUNFOiAnZXRoX2dhc1ByaWNlJyxcclxuICBOT05FOiAnbm9uZScsXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlc2UgcmVwcmVzZW50IGdhcyByZWNvbW1lbmRhdGlvbiBsZXZlbHMgcHJlc2VudGVkIGluIHRoZSBVSVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEdBU19SRUNPTU1FTkRBVElPTlMgPSB7XHJcbiAgTE9XOiAnbG93JyxcclxuICBNRURJVU06ICdtZWRpdW0nLFxyXG4gIEhJR0g6ICdoaWdoJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgdHlwZXMgb2YgZ2FzIGVzdGltYXRpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBQUklPUklUWV9MRVZFTFMgPSB7XHJcbiAgVEVOX1BFUkNFTlRfSU5DUkVBU0VEOiAndGVuUGVyY2VudEluY3JlYXNlZCcsXHJcbiAgTE9XOiAnbG93JyxcclxuICBNRURJVU06ICdtZWRpdW0nLFxyXG4gIEhJR0g6ICdoaWdoJyxcclxuICBDVVNUT006ICdjdXN0b20nLFxyXG4gIERBUFBfU1VHR0VTVEVEOiAnZGFwcFN1Z2dlc3RlZCcsXHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgdXNlciBjdXN0b21pemluZyB0aGVpciBnYXMgcHJlZmVyZW5jZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENVU1RPTV9HQVNfRVNUSU1BVEUgPSAnY3VzdG9tJztcclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgdGhlIGRpZmZlcmVudCBlZGl0IG1vZGVzIHByZXNlbnRlZCBpbiB0aGUgVUlcclxuICovXHJcbmV4cG9ydCBjb25zdCBFRElUX0dBU19NT0RFUyA9IHtcclxuICBTUEVFRF9VUDogJ3NwZWVkLXVwJyxcclxuICBDQU5DRUw6ICdjYW5jZWwnLFxyXG4gIE1PRElGWV9JTl9QTEFDRTogJ21vZGlmeS1pbi1wbGFjZScsXHJcbiAgU1dBUFM6ICdzd2FwcycsXHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBsZXZlbHMgZm9yIGBuZXR3b3JrQ29uZ2VzdGlvbmAgKGNhbGN1bGF0ZWQgYWxvbmcgd2l0aCBnYXMgZmVlXHJcbiAqIGVzdGltYXRlczsgcmVwcmVzZW50cyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEpIHRoYXQgd2UgdXNlIHRvIHJlbmRlciB0aGVcclxuICogbmV0d29yayBzdGF0dXMgc2xpZGVyIG9uIHRoZSBzZW5kIHRyYW5zYWN0aW9uIHNjcmVlbiBhbmQgaW5mb3JtIHVzZXJzIHdoZW5cclxuICogZ2FzIGZlZXMgYXJlIGhpZ2hcclxuICovXHJcbmV4cG9ydCBjb25zdCBORVRXT1JLX0NPTkdFU1RJT05fVEhSRVNIT0xEUyA9IHtcclxuICBOT1RfQlVTWTogMCxcclxuICBTVEFCTEU6IDAuMzMsXHJcbiAgQlVTWTogMC42NixcclxufTtcclxuIiwiLyoqXG4gKiBBY2NvdW50cyBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gc2ltcGxlLCBIRCBvciB0aGUgbXVsdGlwbGUgaGFyZHdhcmUgd2FsbGV0XG4gKiBrZXlyaW5nIHR5cGVzLiBCb3RoIHNpbXBsZSBhbmQgSEQgYXJlIHRyZWF0ZWQgYXMgZGVmYXVsdCBidXQgd2UgZG8gc3BlY2lhbFxuICogY2FzZSBhY2NvdW50cyBtYW5hZ2VkIGJ5IGEgaGFyZHdhcmUgd2FsbGV0LlxuICovXG5leHBvcnQgY29uc3QgS0VZUklOR19UWVBFUyA9IHtcbiAgTEVER0VSOiAnTGVkZ2VyIEhhcmR3YXJlJyxcbiAgVFJFWk9SOiAnVHJlem9yIEhhcmR3YXJlJyxcbiAgTEFUVElDRTogJ0xhdHRpY2UgSGFyZHdhcmUnLFxuICBRUjogJ1FSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2UnLFxuICBJTVBPUlRFRDogJ1NpbXBsZSBLZXkgUGFpcicsXG59O1xuXG5leHBvcnQgY29uc3QgREVWSUNFX05BTUVTID0ge1xuICBMRURHRVI6ICdsZWRnZXInLFxuICBUUkVaT1I6ICd0cmV6b3InLFxuICBRUjogJ1FSIEhhcmR3YXJlJyxcbiAgTEFUVElDRTogJ2xhdHRpY2UnLFxufTtcblxuZXhwb3J0IGNvbnN0IEtFWVJJTkdfTkFNRVMgPSB7XG4gIExFREdFUjogJ0xlZGdlcicsXG4gIFRSRVpPUjogJ1RyZXpvcicsXG4gIFFSOiAnUVInLFxuICBMQVRUSUNFOiAnTGF0dGljZTEnLFxufTtcblxuLyoqXG4gKiBVc2VkIGZvciBzZXR0aW5nIHRoZSB1c2VycyBwcmVmZXJlbmNlIGZvciBsZWRnZXIgdHJhbnNwb3J0IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IExFREdFUl9UUkFOU1BPUlRfVFlQRVMgPSB7XG4gIExJVkU6ICdsZWRnZXJMaXZlJyxcbiAgV0VCSElEOiAnd2ViaGlkJyxcbiAgVTJGOiAndTJmJyxcbn07XG5cbmV4cG9ydCBjb25zdCBMRURHRVJfVVNCX1ZFTkRPUl9JRCA9ICcweDJjOTcnO1xuXG5leHBvcnQgY29uc3QgV0VCSElEX0NPTk5FQ1RFRF9TVEFUVVNFUyA9IHtcbiAgQ09OTkVDVEVEOiAnY29ubmVjdGVkJyxcbiAgTk9UX0NPTk5FQ1RFRDogJ25vdENvbm5lY3RlZCcsXG4gIFVOS05PV046ICd1bmtub3duJyxcbn07XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRfU1RBVEVTID0ge1xuICBOT05FOiAnTk9ORScsXG4gIFZFUklGSUVEOiAnVkVSSUZJRUQnLFxuICBERVZJQ0VfT1BFTl9GQUlMVVJFOiAnREVWSUNFX09QRU5fRkFJTFVSRScsXG4gIFVOS05PV05fRkFJTFVSRTogJ1VOS05PV05fRkFJTFVSRScsXG59O1xuXG5leHBvcnQgY29uc3QgQUZGSUxJQVRFX0xJTktTID0ge1xuICBMRURHRVI6ICdodHRwczovL3Nob3AubGVkZ2VyLmNvbS8/cj0xN2M0OTkxYTAzZmEnLFxuICBHUklEUExVUzogJ2h0dHBzOi8vZ3JpZHBsdXMuaW8vP2FmbWM9N3AnLFxuICBUUkVaT1I6XG4gICAgJ2h0dHBzOi8vc2hvcC50cmV6b3IuaW8vcHJvZHVjdC90cmV6b3Itb25lLWJsYWNrP29mZmVyX2lkPTM1JmFmZl9pZD0xMTAwOScsXG4gIEtFWVNUT05FOlxuICAgICdodHRwczovL3Nob3Aua2V5c3Qub25lLz9yZnNuPTYwODgyNTcuNjU2YjNlOSZ1dG1fc291cmNlPXJlZmVyc2lvbiZ1dG1fbWVkaXVtPWFmZmlsaWF0ZSZ1dG1fY2FtcGFpZ249NjA4ODI1Ny42NTZiM2U5JyxcbiAgQUlSR0FQOiAnaHR0cHM6Ly9haXJnYXAuaXQvJyxcbiAgQ09PTFdBTExFVDogJ2h0dHBzOi8vd3d3LmNvb2x3YWxsZXQuaW8vJyxcbiAgRENFTlQ6ICdodHRwczovL2RjZW50d2FsbGV0LmNvbS8nLFxufTtcblxuZXhwb3J0IGNvbnN0IEFGRklMSUFURV9UVVRPUklBTF9MSU5LUyA9IHtcbiAgTEVER0VSOlxuICAgICdodHRwczovL3N1cHBvcnQubGVkZ2VyLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDA0MzY2ODY0NjU3LVNldC11cC1hbmQtdXNlLU1ldGFNYXNrLXRvLWFjY2Vzcy15b3VyLUxlZGdlci1FdGhlcmV1bS1FVEgtYWNjb3VudD9kb2NzPXRydWUnLFxuICBHUklEUExVUzogJ2h0dHBzOi8vZG9jcy5ncmlkcGx1cy5pby9zZXR1cC9tZXRhbWFzaycsXG4gIFRSRVpPUjogJ2h0dHBzOi8vd2lraS50cmV6b3IuaW8vQXBwczpNZXRhTWFzaycsXG4gIEtFWVNUT05FOlxuICAgICdodHRwczovL3N1cHBvcnQua2V5c3Qub25lLzNyZC1wYXJ0eS13YWxsZXRzL2V0aC1hbmQtd2ViMy13YWxsZXRzLWtleXN0b25lL2JpbmQtbWV0YW1hc2std2l0aC1rZXlzdG9uZScsXG4gIEFJUkdBUDogJ2h0dHBzOi8vc3VwcG9ydC5haXJnYXAuaXQvZ3VpZGVzL21ldGFtYXNrLycsXG4gIENPT0xXQUxMRVQ6ICdodHRwczovL3d3dy5jb29sd2FsbGV0LmlvL21ldGFtYXNrLXN0ZXAtYnktc3RlcC1ndWlkZXMvJyxcbiAgRENFTlQ6XG4gICAgJ2h0dHBzOi8vbWVkaXVtLmNvbS9kY2VudHdhbGxldC9kY2VudC13YWxsZXQtbm93LXN1cHBvcnRzLXFyLWJhc2VkLXByb3RvY29sLXRvLWxpbmstd2l0aC1tZXRhbWFzay01NzU1NWYwMjYwM2YnLFxufTtcbiIsIi8vIFRoZSBjaGFyYWN0ZXIgbGltaXQgb24gRU5TIG5hbWVzLCBuaWNrbmFtZXMgYW5kIGFkZHJlc3NlcyBiZWZvcmUgd2UgdHJ1bmNhdGVcclxuZXhwb3J0IGNvbnN0IFRSVU5DQVRFRF9OQU1FX0NIQVJfTElNSVQgPSAxMTtcclxuXHJcbi8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzbGljZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYW4gYWRkcmVzcyBmb3IgdHJ1bmNhdGVkIGZvcm1hdDpcclxuLy8gYCR7VFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlN9Li4uJHtUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlN9YFxyXG5leHBvcnQgY29uc3QgVFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlMgPSA1O1xyXG5cclxuLy8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHNsaWNlIGZyb20gdGhlIGVuZCBvZiBhbiBhZGRyZXNzIGZvciB0cnVuY2F0ZWQgZm9ybWF0OlxyXG4vLyBgJHtUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSU30uLi4ke1RSVU5DQVRFRF9BRERSRVNTX0VORF9DSEFSU31gXHJcbmV4cG9ydCBjb25zdCBUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlMgPSA0O1xyXG4iLCIvLyBUeXBlIEltcG9ydHNcbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnKS5FbnZpcm9ubWVudFR5cGV9IEVudmlyb25tZW50VHlwZVxuICovXG5cbi8vIFR5cGUgRGVjbGFyYXRpb25zXG4vKipcbiAqIFVzZWQgdG8gYXR0YWNoIGNvbnRleHQgb2Ygd2hlcmUgdGhlIHVzZXIgd2FzIGF0IGluIHRoZSBhcHBsaWNhdGlvbiB3aGVuIHRoZVxuICogZXZlbnQgd2FzIHRyaWdnZXJlZC4gQWxzbyBpbmNsdWRlZCBhcyBmdWxsIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZSBpblxuICogcGFnZSBldmVudHMuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NQYWdlT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BhdGhdIC0gdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgcGFnZSAoZS5nIC9ob21lKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV0gLSB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgcGFnZSAoZS5nICdob21lJylcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSAtIHRoZSBmdWxseSBxdWFsaWZpZWQgdXJsIG9mIHRoZSBjdXJyZW50IHBhZ2VcbiAqL1xuXG4vKipcbiAqIEZvciBtZXRhbWFzaywgdGhpcyBpcyB0aGUgZGFwcCB0aGF0IHRyaWdnZXJlZCBhbiBpbnRlcmFjdGlvblxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSAtIHRoZSBvcmlnaW4gb2YgdGhlIGRhcHAgaXNzdWluZyB0aGVcbiAqICBub3RpZmljYXRpb25cbiAqL1xuXG4vKipcbiAqIFdlIGF0dGFjaCBjb250ZXh0IHRvIGV2ZXJ5IG1ldGEgbWV0cmljcyBldmVudCB0aGF0IGhlbHAgdG8gcXVhbGlmeSBvdXJcbiAqIGFuYWx5dGljcy4gVGhpcyB0eXBlIGhhcyBhbGwgb3B0aW9uYWwgdmFsdWVzIGJlY2F1c2UgaXQgcmVwcmVzZW50cyBhXG4gKiByZXR1cm5lZCBvYmplY3QgZnJvbSBhIG1ldGhvZCBjYWxsLiBJZGVhbGx5IGFwcCBhbmQgdXNlckFnZW50IGFyZVxuICogZGVmaW5lZCBvbiBldmVyeSBldmVudC4gVGhpcyBpcyBjb25maXJtZWQgaW4gdGhlIGdldFRyYWNrTWV0YU1ldHJpY3NFdmVudFxuICogZnVuY3Rpb24sIGJ1dCBzdGlsbCBwcm92aWRlcyB0aGUgY29uc3VtZXIgYSB3YXkgdG8gb3ZlcnJpZGUgdGhlc2UgdmFsdWVzIGlmXG4gKiBuZWNlc3NhcnkuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NDb250ZXh0XG4gKiBAcHJvcGVydHkge29iamVjdH0gYXBwIC0gQXBwbGljYXRpb24gbWV0YWRhdGEuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXBwLm5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24gdHJhY2tpbmcgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXBwLnZlcnNpb24gLSB0aGUgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VyQWdlbnQgLSB0aGUgdXNlcmFnZW50IHN0cmluZyBvZiB0aGUgdXNlclxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9IFtwYWdlXSAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgZGV0YWlscyBvZlxuICogIHRoZSBjdXJyZW50IHBhZ2VcbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdH0gW3JlZmVycmVyXSAtIGZvciBtZXRhbWFzaywgdGhpcyBpcyB0aGVcbiAqICBkYXBwIHRoYXQgdHJpZ2dlcmVkIGFuIGludGVyYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWV0cmljc0V2ZW50UGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZSB0byB0cmFja1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdGVnb3J5IC0gY2F0ZWdvcnkgdG8gYXNzb2NpYXRlIGV2ZW50IHRvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Vudmlyb25tZW50VHlwZV0gLSBUaGUgdHlwZSBvZiBlbnZpcm9ubWVudCB0aGlzIGV2ZW50XG4gKiAgb2NjdXJyZWQgaW4uIERlZmF1bHRzIHRvIHRoZSBiYWNrZ3JvdW5kIHByb2Nlc3MgdHlwZVxuICogQHByb3BlcnR5IHtvYmplY3R9IFtwcm9wZXJ0aWVzXSAtIG9iamVjdCBvZiBjdXN0b20gdmFsdWVzIHRvIHRyYWNrLCBrZXlzXG4gKiAgaW4gdGhpcyBvYmplY3QgbXVzdCBiZSBpbiBzbmFrZV9jYXNlXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3NlbnNpdGl2ZVByb3BlcnRpZXNdIC0gT2JqZWN0IG9mIHNlbnNpdGl2ZSB2YWx1ZXMgdG9cbiAqICB0cmFjay4gS2V5cyBpbiB0aGlzIG9iamVjdCBtdXN0IGJlIGluIHNuYWtlX2Nhc2UuIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZVxuICogIHNlbnQgaW4gYW4gYWRkaXRpb25hbCBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgbWV0YU1ldHJpY3NJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXZlbnVlXSAtIGFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IGV2ZW50IGNyZWF0ZXMgaW5cbiAqICByZXZlbnVlIGZvciBNZXRhTWFza1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjdXJyZW5jeV0gLSBJU08gNDEyNyBmb3JtYXQgY3VycmVuY3kgZm9yIGV2ZW50cyB3aXRoXG4gKiAgcmV2ZW51ZSwgZGVmYXVsdHMgdG8gVVMgZG9sbGFyc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV0gLSBBYnN0cmFjdCBidXNpbmVzcyBcInZhbHVlXCIgYXR0cmlidXRhYmxlIHRvXG4gKiAgY3VzdG9tZXJzIHdobyB0cmlnZ2VyIHRoaXMgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NQYWdlT2JqZWN0fSBbcGFnZV0gLSB0aGUgcGFnZS9yb3V0ZSB0aGF0IHRoZSBldmVudFxuICogIG9jY3VycmVkIG9uXG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3R9IFtyZWZlcnJlcl0gLSB0aGUgb3JpZ2luIG9mIHRoZSBkYXBwXG4gKiAgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWV0cmljc0V2ZW50T3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbaXNPcHRJbl0gLSBoYXBwZW5lZCBkdXJpbmcgb3B0IGluL291dCB3b3JrZmxvd1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZmx1c2hJbW1lZGlhdGVseV0gLSBXaGVuIHRydWUgd2lsbCBhdXRvbWF0aWNhbGx5IGZsdXNoXG4gKiAgdGhlIHNlZ21lbnQgcXVldWUgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LiBSZWNvbW1lbmRlZCBpZiB0aGUgcmVzdWx0IG9mXG4gKiAgdHJhY2tpbmcgdGhlIGV2ZW50IG11c3QgYmUga25vd24gYmVmb3JlIFVJIHRyYW5zaXRpb24gb3IgdXBkYXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtleGNsdWRlTWV0YU1ldHJpY3NJZF0gLSB3aGV0aGVyIHRvIGV4Y2x1ZGUgdGhlIHVzZXInc1xuICogIG1ldGFtZXRyaWNzIGlkIGZvciBhbm9ueW1pdHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWV0YU1ldHJpY3NJZF0gLSBhbiBvdmVycmlkZSBmb3IgdGhlIG1ldGFNZXRyaWNzSWQgaW5cbiAqICB0aGUgZXZlbnQgb25lIGlzIGNyZWF0ZWQgYXMgcGFydCBvZiBhbiBhc3luY2hyb25vdXMgd29ya2Zsb3csIHN1Y2ggYXNcbiAqICBhd2FpdGluZyB0aGUgcmVzdWx0IG9mIHRoZSBtZXRhbWV0cmljcyBvcHQtaW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlXG4gKiAgdXNlcidzIG1ldGFtZXRyaWNzIGlkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttYXRvbW9FdmVudF0gLSBpcyB0aGlzIGV2ZW50IGEgaG9sZG92ZXIgZnJvbSBtYXRvbW9cbiAqICB0aGF0IG5lZWRzIGZ1cnRoZXIgbWlncmF0aW9uPyB3aGVuIHRydWUsIHNlbmRzIHRoZSBkYXRhIHRvIGEgc3BlY2lhbFxuICogIHNlZ21lbnQgc291cmNlIHRoYXQgbWFya3MgdGhlIGV2ZW50IGRhdGEgYXMgbm90IGNvbmZvcm1pbmcgdG8gb3VyIHNjaGVtYVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NFdmVudEZyYWdtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3VjY2Vzc0V2ZW50IC0gVGhlIGV2ZW50IG5hbWUgdG8gZmlyZSB3aGVuIHRoZSBmcmFnbWVudFxuICogIGlzIGNsb3NlZCBpbiBhbiBhZmZpcm1hdGl2ZSBhY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZhaWx1cmVFdmVudF0gLSBUaGUgZXZlbnQgbmFtZSB0byBmaXJlIHdoZW4gdGhlIGZyYWdtZW50XG4gKiAgaXMgY2xvc2VkIHdpdGggYSByZWplY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2luaXRpYWxFdmVudF0gLSBBbiBldmVudCBuYW1lIHRvIGZpcmUgaW1tZWRpYXRlbHkgdXBvblxuICogIGZyYWdtZW50IGNyZWF0aW9uLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmcgZnVubmVscyBpbiBtaXhwYW5lbCBhbmQgZm9yXG4gKiAgcmVkdWN0aW9uIG9mIGNvZGUgZHVwbGljYXRpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSB0aGUgZXZlbnQgY2F0ZWdvcnkgdG8gdXNlIGZvciBib3RoIHRoZSBzdWNjZXNzXG4gKiAgYW5kIGZhaWx1cmUgZXZlbnRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwZXJzaXN0XSAtIFNob3VsZCB0aGlzIGZyYWdtZW50IGJlIHBlcnNpc3RlZCBpblxuICogIHN0YXRlIGFuZCBwcm9ncmVzc2VkIGFmdGVyIHRoZSBleHRlbnNpb24gaXMgbG9ja2VkIGFuZCB1bmxvY2tlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZW91dF0gLSBUaW1lIGluIHNlY29uZHMgdGhlIGV2ZW50IHNob3VsZCBiZSBwZXJzaXN0ZWRcbiAqICBmb3IuIEFmdGVyIHRoZSB0aW1lb3V0IHRoZSBmcmFnbWVudCB3aWxsIGJlIGNsb3NlZCBhcyBhYmFuZG9uZWQuIGlmIG5vdFxuICogIHN1cHBsaWVkIHRoZSBmcmFnbWVudCBpcyBzdG9yZWQgaW5kZWZpbml0ZWx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXN0VXBkYXRlZF0gLSBEYXRlLm5vdygpIHdoZW4gdGhlIGZyYWdtZW50IHdhcyBsYXN0XG4gKiAgdXBkYXRlZC4gVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIHRpbWVvdXQgaGFzIGV4cGlyZWQgYW5kIHRoZSBmcmFnbWVudFxuICogIHNob3VsZCBiZSBjbG9zZWQuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3Byb3BlcnRpZXNdIC0gT2JqZWN0IG9mIGN1c3RvbSB2YWx1ZXMgdG8gdHJhY2ssIGtleXMgaW5cbiAqICB0aGlzIG9iamVjdCBtdXN0IGJlIGluIHNuYWtlX2Nhc2UuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3NlbnNpdGl2ZVByb3BlcnRpZXNdIC0gT2JqZWN0IG9mIHNlbnNpdGl2ZSB2YWx1ZXMgdG9cbiAqICB0cmFjay4gS2V5cyBpbiB0aGlzIG9iamVjdCBtdXN0IGJlIGluIHNuYWtlX2Nhc2UuIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZVxuICogIHNlbnQgaW4gYW4gYWRkaXRpb25hbCBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgbWV0YU1ldHJpY3NJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXZlbnVlXSAtIGFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IGV2ZW50IGNyZWF0ZXMgaW5cbiAqICByZXZlbnVlIGZvciBNZXRhTWFzayBpZiBmcmFnbWVudCBpcyBzdWNjZXNzZnVsLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjdXJyZW5jeV0gLSBJU08gNDEyNyBmb3JtYXQgY3VycmVuY3kgZm9yIGV2ZW50cyB3aXRoXG4gKiAgcmV2ZW51ZSwgZGVmYXVsdHMgdG8gVVMgZG9sbGFyc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV0gLSBBYnN0cmFjdCBidXNpbmVzcyBcInZhbHVlXCIgYXR0cmlidXRhYmxlIHRvXG4gKiAgY3VzdG9tZXJzIHdobyBzdWNjZXNzZnVsbHkgY29tcGxldGUgdGhpcyBmcmFnbWVudFxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9IFtwYWdlXSAtIHRoZSBwYWdlL3JvdXRlIHRoYXQgdGhlIGV2ZW50XG4gKiAgb2NjdXJyZWQgb25cbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdH0gW3JlZmVycmVyXSAtIHRoZSBvcmlnaW4gb2YgdGhlIGRhcHBcbiAqICB0aGF0IGluaXRpYXRlZCB0aGUgZXZlbnQgZnJhZ21lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VuaXF1ZUlkZW50aWZpZXJdIC0gb3B0aW9uYWwgYXJndW1lbnQgdG8gb3ZlcnJpZGUgdGhlXG4gKiAgYXV0b21hdGljIGdlbmVyYXRpb24gb2YgVVVJRCBmb3IgdGhlIGV2ZW50IGZyYWdtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuXG4gKiAgdHJhY2tpbmcgZXZlbnRzIGZvciBzdWJzeXN0ZW1zIHRoYXQgYWxyZWFkeSBnZW5lcmF0ZSBVVUlEcyBzbyB0byBhdm9pZFxuICogIHVubmVjZXNzYXJ5IGxvb2t1cHMgYW5kIHJlZHVjZSBhY2NpZGVudGFsIGR1cGxpY2F0aW9uLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgc2hhcGUgb2YgZGF0YSBzZW50IHRvIHRoZSBzZWdtZW50LnRyYWNrIG1ldGhvZC5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZWdtZW50RXZlbnRQYXlsb2FkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VzZXJJZF0gLSBUaGUgbWV0YW1ldHJpY3MgaWQgZm9yIHRoZSB1c2VyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Fub255bW91c0lkXSAtIEFuIGFub255bW91c0lkIHRoYXQgaXMgdXNlZCB0byB0cmFja1xuICogIHNlbnNpdGl2ZSBkYXRhIHdoaWxlIHByZXNlcnZpbmcgYW5vbnltaXR5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50IC0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gcHJvcGVydGllcyB0byBhdHRhY2ggdG8gdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzQ29udGV4dH0gY29udGV4dCAtIHRoZSBjb250ZXh0IHRoZSBldmVudCBvY2N1cnJlZCBpblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NQYWdlUGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFnZSB0aGF0IHdhcyB2aWV3ZWRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSB2YXJpYWRpYyBwYXJ0cyBvZiB0aGUgcGFnZSB1cmxcbiAqICBleGFtcGxlIChyb3V0ZTogYC9hc3NldC86YXNzZXRgLCBwYXRoOiBgL2Fzc2V0L0VUSGApXG4gKiAgcGFyYW1zOiB7IGFzc2V0OiAnRVRIJyB9XG4gKiBAcHJvcGVydHkge0Vudmlyb25tZW50VHlwZX0gZW52aXJvbm1lbnRUeXBlIC0gdGhlIGVudmlyb25tZW50IHR5cGUgdGhhdCB0aGVcbiAqICBwYWdlIHdhcyB2aWV3ZWQgaW5cbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NQYWdlT2JqZWN0fSBbcGFnZV0gLSB0aGUgZGV0YWlscyBvZiB0aGUgcGFnZVxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0fSBbcmVmZXJyZXJdIC0gZGFwcCB0aGF0IHRyaWdnZXJlZCB0aGUgcGFnZVxuICogIHZpZXdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IE1ldGFNZXRyaWNzUGFnZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lzT3B0SW5QYXRoXSAtIGlzIHRoZSBjdXJyZW50IHBhdGggb25lIG9mIHRoZSBwYWdlcyBpblxuICogIHRoZSBvbmJvYXJkaW5nIHdvcmtmbG93PyBJZiB0cnVlIGFuZCBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgaXMgbnVsbCB0cmFja1xuICogIHRoZSBwYWdlIHZpZXdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYWl0c1xuICogQHByb3BlcnR5IHsnYWRkcmVzc19ib29rX2VudHJpZXMnfSBBRERSRVNTX0JPT0tfRU5UUklFUyAtIFdoZW4gdGhlIHVzZXJcbiAqICBhZGRzIG9yIG1vZGlmaWVzIGFkZHJlc3NlcyBpbiBhZGRyZXNzIGJvb2sgdGhlIGFkZHJlc3NfYm9va19lbnRyaWVzIHRyYWl0XG4gKiAgaXMgaWRlbnRpZmllZC5cbiAqIEBwcm9wZXJ0eSB7J2xlZGdlcl9jb25uZWN0aW9uX3R5cGUnfSBMRURHRVJfQ09OTkVDVElPTl9UWVBFIC0gd2hlbiBsZWRnZXJcbiAqICBsaXZlIGNvbm5uZWN0aW9uIHR5cGUgaXMgY2hhbmdlZCB3ZSBpZGVudGlmeSB0aGUgbGVkZ2VyX2Nvbm5lY3Rpb25fdHlwZVxuICogIHRyYWl0XG4gKiBAcHJvcGVydHkgeyduZXR3b3Jrc19hZGRlZCd9IE5FVFdPUktTX0FEREVEIC0gd2hlbiB1c2VyIG1vZGlmaWVzIG5ldHdvcmtzXG4gKiAgd2UgaWRlbnRpZnkgdGhlIG5ldHdvcmtzX2FkZGVkIHRyYWl0XG4gKiBAcHJvcGVydHkgeyduZXR3b3Jrc193aXRob3V0X3RpY2tlcid9IE5FVFdPUktTX1dJVEhPVVRfVElDS0VSIC0gd2hlbiB1c2VyXG4gKiAgbW9kaWZpZXMgbmV0d29ya3Mgd2UgaWRlbnRpZnkgdGhlIG5ldHdvcmtzX3dpdGhvdXRfdGlja2VyIHRyYWl0IGZvclxuICogIG5ldHdvcmtzIHdpdGhvdXQgYSB0aWNrZXIuXG4gKiBAcHJvcGVydHkgeyduZnRfYXV0b2RldGVjdGlvbl9lbmFibGVkJ30gTkZUX0FVVE9ERVRFQ1RJT05fRU5BQkxFRCAtIHdoZW4gQXV0b2RldGVjdCBORlRzXG4gKiBmZWF0dXJlIGlzIHRvZ2dsZWQgd2UgaWRlbnRpZnkgdGhlIG5mdF9hdXRvZGV0ZWN0aW9uX2VuYWJsZWQgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl9hY2NvdW50cyd9IE5VTUJFUl9PRl9BQ0NPVU5UUyAtIHdoZW4gaWRlbnRpdGllc1xuICogIGNoYW5nZSwgd2UgaWRlbnRpZnkgdGhlIG5ldyBudW1iZXJfb2ZfYWNjb3VudHMgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl9uZnRfY29sbGVjdGlvbnMnfSBOVU1CRVJfT0ZfTkZUX0NPTExFQ1RJT05TIC0gdXNlclxuICogIHRyYWl0IGZvciBudW1iZXIgb2YgdW5pcXVlIE5GVCBhZGRyZXNzZXNcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl9uZnRzJ30gTlVNQkVSX09GX05GVFMgLSB1c2VyIHRyYWl0IGZvciBudW1iZXIgb2YgYWxsIE5GVCBhZGRyZXNzZXNcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl90b2tlbnMnfSBOVU1CRVJfT0ZfVE9LRU5TIC0gd2hlbiB0aGUgbnVtYmVyIG9mIHRva2VucyBjaGFuZ2UsIHdlXG4gKiBpZGVudGlmeSB0aGUgbmV3IG51bWJlcl9vZl90b2tlbnMgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J29wZW5zZWFfYXBpX2VuYWJsZWQnfSBPUEVOU0VBX0FQSV9FTkFCTEVEIC0gd2hlbiB0aGUgT3BlblNlYSBBUEkgaXMgZW5hYmxlZFxuICogd2UgaWRlbnRpZnkgdGhlIG9wZW5zZWFfYXBpX2VuYWJsZWQgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J3RocmVlX2JveF9lbmFibGVkJ30gVEhSRUVfQk9YX0VOQUJMRUQgLSBXaGVuIDNCb3ggZmVhdHVyZSBpc1xuICogIHRvZ2dsZWQgd2UgaWRlbnRpZnkgdGhlIDNib3hfZW5hYmxlZCB0cmFpdC4gVGhpcyB0cmFpdCBoYXMgYmVlbiBkZXByZWNhdGVkLlxuICogQHByb3BlcnR5IHsndGhlbWUnfSBUSEVNRSAtIHdoZW4gdGhlIHVzZXIncyB0aGVtZSBjaGFuZ2VzIHdlIGlkZW50aWZ5IHRoZSB0aGVtZSB0cmFpdFxuICogQHByb3BlcnR5IHsndG9rZW5fZGV0ZWN0aW9uX2VuYWJsZWQnfSBUT0tFTl9ERVRFQ1RJT05fRU5BQkxFRCAtIHdoZW4gdG9rZW4gZGV0ZWN0aW9uIGZlYXR1cmUgaXMgdG9nZ2xlZCB3ZVxuICogaWRlbnRpZnkgdGhlIHRva2VuX2RldGVjdGlvbl9lbmFibGVkIHRyYWl0XG4gKiBAcHJvcGVydHkgeydpbnN0YWxsX2RhdGVfZXh0J30gSU5TVEFMTF9EQVRFX0VYVCAtIHdoZW4gdGhlIHVzZXIgaW5zdGFsbGVkIHRoZSBleHRlbnNpb25cbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZSB7VHJhaXRzfVxuICovXG5cbmV4cG9ydCBjb25zdCBUUkFJVFMgPSB7XG4gIEFERFJFU1NfQk9PS19FTlRSSUVTOiAnYWRkcmVzc19ib29rX2VudHJpZXMnLFxuICBJTlNUQUxMX0RBVEVfRVhUOiAnaW5zdGFsbF9kYXRlX2V4dCcsXG4gIExFREdFUl9DT05ORUNUSU9OX1RZUEU6ICdsZWRnZXJfY29ubmVjdGlvbl90eXBlJyxcbiAgTkVUV09SS1NfQURERUQ6ICduZXR3b3Jrc19hZGRlZCcsXG4gIE5FVFdPUktTX1dJVEhPVVRfVElDS0VSOiAnbmV0d29ya3Nfd2l0aG91dF90aWNrZXInLFxuICBORlRfQVVUT0RFVEVDVElPTl9FTkFCTEVEOiAnbmZ0X2F1dG9kZXRlY3Rpb25fZW5hYmxlZCcsXG4gIE5VTUJFUl9PRl9BQ0NPVU5UUzogJ251bWJlcl9vZl9hY2NvdW50cycsXG4gIE5VTUJFUl9PRl9ORlRfQ09MTEVDVElPTlM6ICdudW1iZXJfb2ZfbmZ0X2NvbGxlY3Rpb25zJyxcbiAgTlVNQkVSX09GX05GVFM6ICdudW1iZXJfb2ZfbmZ0cycsXG4gIE5VTUJFUl9PRl9UT0tFTlM6ICdudW1iZXJfb2ZfdG9rZW5zJyxcbiAgT1BFTlNFQV9BUElfRU5BQkxFRDogJ29wZW5zZWFfYXBpX2VuYWJsZWQnLFxuICBUSEVNRTogJ3RoZW1lJyxcbiAgVEhSRUVfQk9YX0VOQUJMRUQ6ICd0aHJlZV9ib3hfZW5hYmxlZCcsXG4gIFRPS0VOX0RFVEVDVElPTl9FTkFCTEVEOiAndG9rZW5fZGV0ZWN0aW9uX2VuYWJsZWQnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWV0cmljc1RyYWl0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZGRyZXNzX2Jvb2tfZW50cmllc10gLSBUaGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlXG4gKiAgdXNlcidzIGFkZHJlc3MgYm9vay5cbiAqIEBwcm9wZXJ0eSB7J2xlZGdlckxpdmUnIHwgJ3dlYmhpZCcgfCAndTJmJ30gW2xlZGdlcl9jb25uZWN0aW9uX3R5cGVdIC0gdGhlXG4gKiAgdHlwZSBvZiBsZWRnZXIgY29ubmVjdGlvbiBzZXQgYnkgdXNlciBwcmVmZXJlbmNlLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbbmV0d29ya3NfYWRkZWRdIC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiBjaGFpbklkc1xuICogIHRoYXQgaW5kaWNhdGUgdGhlIG5ldHdvcmtzIGEgdXNlciBoYXMgYWRkZWQgdG8gdGhlaXIgTWV0YU1hc2suXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFtuZXR3b3Jrc193aXRob3V0X3RpY2tlcl0gLSBBbiBhcnJheSBjb25zaXN0aW5nIG9mXG4gKiAgY2hhaW5JZHMgdGhhdCBpbmRpY2F0ZSB0aGUgbmV0d29ya3MgYWRkZWQgYnkgdGhlIHVzZXIgdGhhdCBkbyBub3QgaGF2ZSBhXG4gKiAgdGlja2VyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtuZnRfYXV0b2RldGVjdGlvbl9lbmFibGVkXSAtIGRvZXMgdGhlIHVzZXIgaGF2ZSB0aGVcbiAqIHVzZSBjb2xsZWN0aW9uL25mdCBkZXRlY3Rpb24gZW5hYmxlZD9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyX29mX2FjY291bnRzXSAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyXG4gKiAgb2YgaWRlbnRpdGllcyhhY2NvdW50cykgYWRkZWQgdG8gdGhlIHVzZXIncyBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyX29mX25mdF9jb2xsZWN0aW9uc10gLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlXG4gKiAgYW1vdW50IG9mIGRpZmZlcmVudCBORlQgY29sbGVjdGlvbnMgdGhlIHVzZXIgcG9zc2Vzc2VzIGFuIE5GVCBmcm9tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1iZXJfb2ZfbmZ0c10gLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlXG4gKiAgYW1vdW50IG9mIGFsbCBORlRzIHRoZSB1c2VyIHBvc3Nlc3NlcyBhY3Jvc3MgYWxsIG5ldHdvcmtzIGFuZCBhY2NvdW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyX29mX3Rva2Vuc10gLSBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VuIGNvbnRyYWN0c1xuICogIHRoZSB1c2VyIGhhcyBhY3Jvc3MgYWxsIG5ldHdvcmtzIGFuZCBhY2NvdW50cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wZW5zZWFfYXBpX2VuYWJsZWRdIC0gZG9lcyB0aGUgdXNlciBoYXZlIHRoZSBPcGVuU2VhXG4gKiAgQVBJIGVuYWJsZWQ/XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0aHJlZV9ib3hfZW5hYmxlZF0gLSBEb2VzIHRoZSB1c2VyIGhhdmUgM2JveCBzeW5jXG4gKiAgZW5hYmxlZD8gKGRlcHJlY2F0ZWQpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RoZW1lXSAtIHdoaWNoIHRoZW1lIHRoZSB1c2VyIGhhcyBzZWxlY3RlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbdG9rZW5fZGV0ZWN0aW9uX2VuYWJsZWRdIC0gZG9lcyB0aGUgdXNlciBoYXZlIHRva2VuIGRldGVjdGlvbiBpcyBlbmFibGVkP1xuICovXG5cbi8vIE1peHBhbmVsIGNvbnZlcnRzIHRoZSB6ZXJvIGFkZHJlc3MgdmFsdWUgdG8gYSB0cnVseSBhbm9ueW1vdXMgZXZlbnQsIHdoaWNoXG4vLyBzcGVlZHMgdXAgcmVwb3J0aW5nXG5leHBvcnQgY29uc3QgTUVUQU1FVFJJQ1NfQU5PTllNT1VTX0lEID0gJzB4MDAwMDAwMDAwMDAwMDAwMCc7XG5cbi8qKlxuICogVGhpcyBvYmplY3QgaXMgdXNlZCB0byBpZGVudGlmeSBldmVudHMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IHRoZSBiYWNrZ3JvdW5kXG4gKiBwcm9jZXNzLlxuICpcbiAqIEB0eXBlIHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRBTUVUUklDU19CQUNLR1JPVU5EX1BBR0VfT0JKRUNUID0ge1xuICBwYXRoOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG4gIHRpdGxlOiAnQmFja2dyb3VuZCBQcm9jZXNzJyxcbiAgdXJsOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlZ21lbnRJbnRlcmZhY2VcbiAqIEBwcm9wZXJ0eSB7U2VnbWVudEV2ZW50UGF5bG9hZFtdfSBxdWV1ZSAtIEEgcXVldWUgb2YgZXZlbnRzIHRvIGJlIHNlbnQgd2hlblxuICogIHRoZSBmbHVzaEF0IGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQsIG9yIGZsdXNoSW50ZXJ2YWwgb2NjdXJzXG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGZsdXNoIC0gSW1tZWRpYXRlbHkgZmx1c2ggdGhlIHF1ZXVlLCByZXNldHRpbmcgaXQgdG9cbiAqICBhbiBlbXB0eSBhcnJheSBhbmQgc2VuZGluZyB0aGUgcGVuZGluZyBldmVudHMgdG8gU2VnbWVudFxuICogQHByb3BlcnR5IHsoXG4gKiAgcGF5bG9hZDogU2VnbWVudEV2ZW50UGF5bG9hZCxcbiAqICBjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkXG4gKiApID0+IHZvaWR9IHRyYWNrIC0gVHJhY2sgYW4gZXZlbnQgd2l0aCBTZWdtZW50LCB1c2luZyB0aGUgaW50ZXJuYWwgYmF0Y2hpbmdcbiAqICBtZWNoYW5pc20gdG8gb3B0aW1pemUgbmV0d29yayByZXF1ZXN0c1xuICogQHByb3BlcnR5IHsocGF5bG9hZDogb2JqZWN0KSA9PiB2b2lkfSBwYWdlIC0gVHJhY2sgYSBwYWdlIHZpZXcgd2l0aCBTZWdtZW50XG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGlkZW50aWZ5IC0gSWRlbnRpZnkgYW4gYW5vbnltb3VzIHVzZXIuIFdlIGRvIG5vdFxuICogIGN1cnJlbnRseSB1c2UgdGhpcyBtZXRob2QuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0UgPSAnQ2FuY2VsIFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0VfU0lHID1cbiAgJ0NhbmNlbCBTaWcgUmVxdWVzdCBWaWEgTm90aWZpY2F0aW9uIENsb3NlJztcblxuLyoqXG4gKiBFVkVOVFNcbiAqL1xuXG5leHBvcnQgY29uc3QgRVZFTlRfTkFNRVMgPSB7XG4gIEFDQ09VTlRfQURERUQ6ICdBY2NvdW50IEFkZGVkJyxcbiAgQUNDT1VOVF9BRERfU0VMRUNURUQ6ICdBY2NvdW50IEFkZCBTZWxlY3RlZCcsXG4gIEFDQ09VTlRfQUREX0ZBSUxFRDogJ0FjY291bnQgQWRkIEZhaWxlZCcsXG4gIEFDQ09VTlRfUEFTU1dPUkRfQ1JFQVRFRDogJ1dhbGxldCBQYXNzd29yZCBDcmVhdGVkJyxcbiAgQUNDT1VOVF9SRVNFVDogJ0FjY291bnQgUmVzZXQnLFxuICBBUFBfSU5TVEFMTEVEOiAnQXBwIEluc3RhbGxlZCcsXG4gIEFQUF9VTkxPQ0tFRDogJ0FwcCBVbmxvY2tlZCcsXG4gIEFQUF9VTkxPQ0tFRF9GQUlMRUQ6ICdBcHAgVW5sb2NrZWQgRmFpbGVkJyxcbiAgQVBQX1dJTkRPV19FWFBBTkRFRDogJ0FwcCBXaW5kb3cgRXhwYW5kZWQnLFxuICBERUNSWVBUSU9OX0FQUFJPVkVEOiAnRGVjcnlwdGlvbiBBcHByb3ZlZCcsXG4gIERFQ1JZUFRJT05fUkVKRUNURUQ6ICdEZWNyeXB0aW9uIFJlamVjdGVkJyxcbiAgREVDUllQVElPTl9SRVFVRVNURUQ6ICdEZWNyeXB0aW9uIFJlcXVlc3RlZCcsXG4gIEVOQ1JZUFRJT05fUFVCTElDX0tFWV9BUFBST1ZFRDogJ0VuY3J5cHRpb24gQXBwcm92ZWQnLFxuICBFTkNSWVBUSU9OX1BVQkxJQ19LRVlfUkVKRUNURUQ6ICdFbmNyeXB0aW9uIFJlamVjdGVkJyxcbiAgRU5DUllQVElPTl9QVUJMSUNfS0VZX1JFUVVFU1RFRDogJ0VuY3J5cHRpb24gUmVxdWVzdGVkJyxcbiAgRVhURVJOQUxfTElOS19DTElDS0VEOiAnRXh0ZXJuYWwgTGluayBDbGlja2VkJyxcbiAgS0VZX0VYUE9SVF9TRUxFQ1RFRDogJ0tleSBFeHBvcnQgU2VsZWN0ZWQnLFxuICBLRVlfRVhQT1JUX1JFUVVFU1RFRDogJ0tleSBFeHBvcnQgUmVxdWVzdGVkJyxcbiAgS0VZX0VYUE9SVF9GQUlMRUQ6ICdLZXkgRXhwb3J0IEZhaWxlZCcsXG4gIEtFWV9FWFBPUlRfQ0FOQ0VMRUQ6ICdLZXkgRXhwb3J0IENhbmNlbGVkJyxcbiAgS0VZX0VYUE9SVF9SRVZFQUxFRDogJ0tleSBNYXRlcmlhbCBSZXZlYWxlZCcsXG4gIEtFWV9FWFBPUlRfQ09QSUVEOiAnS2V5IE1hdGVyaWFsIENvcGllZCcsXG4gIE1FVFJJQ1NfT1BUX0lOOiAnTWV0cmljcyBPcHQgSW4nLFxuICBNRVRSSUNTX09QVF9PVVQ6ICdNZXRyaWNzIE9wdCBPdXQnLFxuICBOQVZfQUNDT1VOVF9NRU5VX09QRU5FRDogJ0FjY291bnQgTWVudSBPcGVuZWQnLFxuICBOQVZfQUNDT1VOVF9ERVRBSUxTX09QRU5FRDogJ0FjY291bnQgRGV0YWlscyBPcGVuZWQnLFxuICBOQVZfQ09OTkVDVEVEX1NJVEVTX09QRU5FRDogJ0Nvbm5lY3RlZCBTaXRlcyBPcGVuZWQnLFxuICBOQVZfTUFJTl9NRU5VX09QRU5FRDogJ01haW4gTWVudSBPcGVuZWQnLFxuICBOQVZfTkVUV09SS19NRU5VX09QRU5FRDogJ05ldHdvcmsgTWVudSBPcGVuZWQnLFxuICBOQVZfU0VUVElOR1NfT1BFTkVEOiAnU2V0dGluZ3MgT3BlbmVkJyxcbiAgTkFWX0FDQ09VTlRfU1dJVENIRUQ6ICdBY2NvdW50IFN3aXRjaGVkJyxcbiAgTkFWX05FVFdPUktfU1dJVENIRUQ6ICdOZXR3b3JrIFN3aXRjaGVkJyxcbiAgTkFWX0JVWV9CVVRUT05fQ0xJQ0tFRDogJ0J1eSBCdXR0b24gQ2xpY2tlZCcsXG4gIE5BVl9TRU5EX0JVVFRPTl9DTElDS0VEOiAnU2VuZCBCdXR0b24gQ2xpY2tlZCcsXG4gIE5BVl9TV0FQX0JVVFRPTl9DTElDS0VEOiAnU3dhcCBCdXR0b24gQ2xpY2tlZCcsXG4gIFNSUF9UT19DT05GSVJNX0JBQ0tVUDogJ1NSUCBCYWNrdXAgQ29uZmlybSBEaXNwbGF5ZWQnLFxuICBXQUxMRVRfU0VUVVBfU1RBUlRFRDogJ1dhbGxldCBTZXR1cCBTZWxlY3RlZCcsXG4gIFdBTExFVF9TRVRVUF9DQU5DRUxFRDogJ1dhbGxldCBTZXR1cCBDYW5jZWxlZCcsXG4gIFdBTExFVF9TRVRVUF9GQUlMRUQ6ICdXYWxsZXQgU2V0dXAgRmFpbGVkJyxcbiAgV0FMTEVUX0NSRUFURUQ6ICdXYWxsZXQgQ3JlYXRlZCcsXG4gIE5GVF9BRERFRDogJ05GVCBBZGRlZCcsXG4gIE9OUkFNUF9QUk9WSURFUl9TRUxFQ1RFRDogJ09uLXJhbXAgUHJvdmlkZXIgU2VsZWN0ZWQnLFxuICBQRVJNSVNTSU9OU19BUFBST1ZFRDogJ1Blcm1pc3Npb25zIEFwcHJvdmVkJyxcbiAgUEVSTUlTU0lPTlNfUkVKRUNURUQ6ICdQZXJtaXNzaW9ucyBSZWplY3RlZCcsXG4gIFBFUk1JU1NJT05TX1JFUVVFU1RFRDogJ1Blcm1pc3Npb25zIFJlcXVlc3RlZCcsXG4gIFBPUlRGT0xJT19MSU5LX0NMSUNLRUQ6ICdQb3J0Zm9saW8gTGluayBDbGlja2VkJyxcbiAgUFVCTElDX0FERFJFU1NfQ09QSUVEOiAnUHVibGljIEFkZHJlc3MgQ29waWVkJyxcbiAgUFJPVklERVJfTUVUSE9EX0NBTExFRDogJ1Byb3ZpZGVyIE1ldGhvZCBDYWxsZWQnLFxuICBTSUdOQVRVUkVfQVBQUk9WRUQ6ICdTaWduYXR1cmUgQXBwcm92ZWQnLFxuICBTSUdOQVRVUkVfUkVKRUNURUQ6ICdTaWduYXR1cmUgUmVqZWN0ZWQnLFxuICBTSUdOQVRVUkVfUkVRVUVTVEVEOiAnU2lnbmF0dXJlIFJlcXVlc3RlZCcsXG4gIFRPS0VOX0lNUE9SVF9CVVRUT05fQ0xJQ0tFRDogJ0ltcG9ydCBUb2tlbiBCdXR0b24gQ2xpY2tlZCcsXG4gIFRPS0VOX1NDUkVFTl9PUEVORUQ6ICdUb2tlbiBTY3JlZW4gT3BlbmVkJyxcbiAgU1VQUE9SVF9MSU5LX0NMSUNLRUQ6ICdTdXBwb3J0IExpbmsgQ2xpY2tlZCcsXG4gIFRPS0VOX0FEREVEOiAnVG9rZW4gQWRkZWQnLFxuICBUT0tFTl9ERVRFQ1RFRDogJ1Rva2VuIERldGVjdGVkJyxcbiAgVE9LRU5fSElEREVOOiAnVG9rZW4gSGlkZGVuJyxcbiAgVE9LRU5fSU1QT1JUX0NBTkNFTEVEOiAnVG9rZW4gSW1wb3J0IENhbmNlbGVkJyxcbiAgVE9LRU5fSU1QT1JUX0NMSUNLRUQ6ICdUb2tlbiBJbXBvcnQgQ2xpY2tlZCcsXG59O1xuXG5leHBvcnQgY29uc3QgRVZFTlQgPSB7XG4gIEFDQ09VTlRfVFlQRVM6IHtcbiAgICBERUZBVUxUOiAnbWV0YW1hc2snLFxuICAgIElNUE9SVEVEOiAnaW1wb3J0ZWQnLFxuICAgIEhBUkRXQVJFOiAnaGFyZHdhcmUnLFxuICB9LFxuICBBQ0NPVU5UX0lNUE9SVF9UWVBFUzoge1xuICAgIEpTT046ICdqc29uJyxcbiAgICBQUklWQVRFX0tFWTogJ3ByaXZhdGVfa2V5JyxcbiAgICBTUlA6ICdzcnAnLFxuICB9LFxuICBDQVRFR09SSUVTOiB7XG4gICAgQUNDT1VOVFM6ICdBY2NvdW50cycsXG4gICAgQVBQOiAnQXBwJyxcbiAgICBBVVRIOiAnQXV0aCcsXG4gICAgQkFDS0dST1VORDogJ0JhY2tncm91bmQnLFxuICAgIEVSUk9SOiAnRXJyb3InLFxuICAgIEZPT1RFUjogJ0Zvb3RlcicsXG4gICAgSE9NRTogJ0hvbWUnLFxuICAgIElOUEFHRV9QUk9WSURFUjogJ2lucGFnZV9wcm92aWRlcicsXG4gICAgS0VZUzogJ0tleXMnLFxuICAgIE1FU1NBR0VTOiAnTWVzc2FnZXMnLFxuICAgIE5BVklHQVRJT046ICdOYXZpZ2F0aW9uJyxcbiAgICBORVRXT1JLOiAnTmV0d29yaycsXG4gICAgT05CT0FSRElORzogJ09uYm9hcmRpbmcnLFxuICAgIFJFVEVOVElPTjogJ1JldGVudGlvbicsXG4gICAgU0VUVElOR1M6ICdTZXR0aW5ncycsXG4gICAgU05BUFM6ICdTbmFwcycsXG4gICAgU1dBUFM6ICdTd2FwcycsXG4gICAgVFJBTlNBQ1RJT05TOiAnVHJhbnNhY3Rpb25zJyxcbiAgICBXQUxMRVQ6ICdXYWxsZXQnLFxuICB9LFxuICBFWFRFUk5BTF9MSU5LX1RZUEVTOiB7XG4gICAgVFJBTlNBQ1RJT05fQkxPQ0tfRVhQTE9SRVI6ICdUcmFuc2FjdGlvbiBCbG9jayBFeHBsb3JlcicsXG4gICAgQkxPQ0tfRVhQTE9SRVI6ICdCbG9jayBFeHBsb3JlcicsXG4gICAgQUNDT1VOVF9UUkFDS0VSOiAnQWNjb3VudCBUcmFja2VyJyxcbiAgICBUT0tFTl9UUkFDS0VSOiAnVG9rZW4gVHJhY2tlcicsXG4gIH0sXG4gIEtFWV9UWVBFUzoge1xuICAgIFBLRVk6ICdwcml2YXRlX2tleScsXG4gICAgU1JQOiAnc3JwJyxcbiAgfSxcbiAgT05SQU1QX1BST1ZJREVSX1RZUEVTOiB7XG4gICAgQ09JTkJBU0U6ICdjb2luYmFzZScsXG4gICAgTU9PTlBBWTogJ21vb25wYXknLFxuICAgIFdZUkU6ICd3eXJlJyxcbiAgICBUUkFOU0FLOiAndHJhbnNhaycsXG4gICAgU0VMRl9ERVBPU0lUOiAnZGlyZWN0X2RlcG9zaXQnLFxuICB9LFxuICBTT1VSQ0U6IHtcbiAgICBORVRXT1JLOiB7XG4gICAgICBDVVNUT01fTkVUV09SS19GT1JNOiAnY3VzdG9tX25ldHdvcmtfZm9ybScsXG4gICAgICBQT1BVTEFSX05FVFdPUktfTElTVDogJ3BvcHVsYXJfbmV0d29ya19saXN0JyxcbiAgICB9LFxuICAgIFNXQVBTOiB7XG4gICAgICBNQUlOX1ZJRVc6ICdNYWluIFZpZXcnLFxuICAgICAgVE9LRU5fVklFVzogJ1Rva2VuIFZpZXcnLFxuICAgIH0sXG4gICAgVE9LRU46IHtcbiAgICAgIENVU1RPTTogJ2N1c3RvbScsXG4gICAgICBEQVBQOiAnZGFwcCcsXG4gICAgICBERVRFQ1RFRDogJ2RldGVjdGVkJyxcbiAgICAgIExJU1Q6ICdsaXN0JyxcbiAgICB9LFxuICAgIFRSQU5TQUNUSU9OOiB7XG4gICAgICBEQVBQOiAnZGFwcCcsXG4gICAgICBVU0VSOiAndXNlcicsXG4gICAgfSxcbiAgfSxcbiAgTE9DQVRJT046IHtcbiAgICBUT0tFTl9ERVRBSUxTOiAndG9rZW5fZGV0YWlscycsXG4gICAgVE9LRU5fREVURUNUSU9OOiAndG9rZW5fZGV0ZWN0aW9uJyxcbiAgICBUT0tFTl9NRU5VOiAndG9rZW5fbWVudScsXG4gIH0sXG59O1xuXG4vLyBWYWx1ZXMgYmVsb3cgKGUuZy4gJ2xvY2F0aW9uJykgY2FuIGJlIHVzZWQgaW4gdGhlIFwicHJvcGVydGllc1wiXG4vLyB0cmFja2luZyBvYmplY3QgYXMga2V5cywgZS5nLiB7IGxvY2F0aW9uOiAnSG9tZScgfVxuZXhwb3J0IGNvbnN0IENPTlRFWFRfUFJPUFMgPSB7XG4gIFBBR0VfVElUTEU6ICdsb2NhdGlvbicsXG59O1xuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJ2xvZGFzaCc7XG4vKipcbiAqIEEgdHlwZSByZXByZXNlbnRpbmcgYW55IHZhbGlkIHZhbHVlIGZvciAndHlwZScgZm9yIHNldFByb3ZpZGVyVHlwZSBhbmQgb3RoZXJcbiAqIG1ldGhvZHMgdGhhdCBhZGQgb3IgbWFuaXB1bGF0ZSBuZXR3b3JrcyBpbiBNZXRhTWFzayBzdGF0ZS5cbiAqL1xuZXhwb3J0IHR5cGUgTmV0d29ya1R5cGUgPSB0eXBlb2YgTkVUV09SS19UWVBFU1trZXlvZiB0eXBlb2YgTkVUV09SS19UWVBFU107XG5cbi8qKlxuICogQSB1bmlvbiB0eXBlIG9mIGFsbCBwb3NzaWJsZSBoYXJkLWNvZGVkIGNoYWluIGlkcy4gVGhpcyB0eXBlIGlzIG5vdFxuICogZXhoYXVzdGl2ZSBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIHR5cGluZyBjaGFpbklkIGluIGFyZWFzIHdoZXJlIHRoZSB1c2VyIG9yXG4gKiBkYXBwIG1heSBzcGVjaWZ5IGFueSBjaGFpbklkLlxuICovXG5leHBvcnQgdHlwZSBDaGFpbklkID0gdHlwZW9mIENIQUlOX0lEU1trZXlvZiB0eXBlb2YgQ0hBSU5fSURTXTtcblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBpcyBhIHVuaW9uIHR5cGUgb2YgYWxsIHBvc3NpYmxlIGhhcmRjb2RlZCBjdXJyZW5jeSBzeW1ib2xzLlxuICogVGhpcyB0eXBlIGlzIG5vbi1leGhhdXN0aXZlLCBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIGFyZWFzIHdoZXJlIHRoZSB1c2VyXG4gKiBvciBkYXBwIG1heSBzdXBwbHkgdGhlaXIgb3duIHN5bWJvbC5cbiAqL1xudHlwZSBDdXJyZW5jeVN5bWJvbCA9IHR5cGVvZiBDVVJSRU5DWV9TWU1CT0xTW2tleW9mIHR5cGVvZiBDVVJSRU5DWV9TWU1CT0xTXTtcbi8qKlxuICogQSB0eXBlIHRoYXQgaXMgYSB1bmlvbiB0eXBlIGZvciB0aGUgc3VwcG9ydGVkIHN5bWJvbHMgb24gZGlmZmVyZW50IG9ucmFtcCBwcm92aWRlcnMuXG4gKi9cbnR5cGUgU3VwcG9ydGVkQ3VycmVuY3lTeW1ib2wgPVxuICB0eXBlb2YgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFNba2V5b2YgdHlwZW9mIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTXTtcbi8qKlxuICogVGVzdCBuZXR3b3JrcyBoYXZlIHNwZWNpYWwgc3ltYm9scyB0aGF0IGNvbWJpbmUgdGhlIG5ldHdvcmsgbmFtZSBhbmQgJ0VUSCdcbiAqIHNvIHRoYXQgdGhleSBhcmUgZGlzdGluY3QgZnJvbSBtYWlubmV0IGFuZCBvdGhlciBuZXR3b3JrcyB0aGF0IHVzZSAnRVRIJy5cbiAqL1xuZXhwb3J0IHR5cGUgVGVzdE5ldHdvcmtDdXJyZW5jeVN5bWJvbCA9XG4gIHR5cGVvZiBURVNUX05FVFdPUktfVElDS0VSX01BUFtrZXlvZiB0eXBlb2YgVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBdO1xuXG4vKipcbiAqIE1vb25QYXkgaXMgYSBmaWF0IG9ucmFtcCBwcm92aWRlciwgYW5kIHRoZXJlIGFyZSBzb21lIHNwZWNpYWwgc3RyaW5ncyB0aGF0XG4gKiBpbmZvcm0gdGhlIE1vb25QYXkgQVBJIHdoaWNoIG5ldHdvcmsgdGhlIHVzZXIgaXMgYXR0ZW1wdGluZyB0byBvbnJhbXAgaW50by5cbiAqIFRoaXMgdHlwZSByZWZsZWN0cyB0aG9zZSBwb3NzaWJsZSB2YWx1ZXMuXG4gKi9cbnR5cGUgTW9vblBheU5ldHdvcmtBYmJyZXZpYXRpb24gPSAnQlNDJyB8ICdDQ0hBSU4nIHwgJ1BPTFlHT04nO1xuXG4vKipcbiAqIE1vb25QYXkgcmVxdWlyZXMgc29tZSBzZXR0aW5ncyB0aGF0IGFyZSBjb25maWd1cmVkIHBlciBuZXR3b3JrIHRoYXQgaXQgaXNcbiAqIGVuYWJsZWQgb24uIFRoaXMgdHlwZSBkZXNjcmliZXMgdGhvc2Ugc2V0dGluZ3MuXG4gKi9cbnR5cGUgTW9vblBheUNoYWluU2V0dGluZ3MgPSB7XG4gIC8qKlxuICAgKiBXaGF0IHNob3VsZCB0aGUgZGVmYXVsdCBvbnJhbXAgY3VycmVuY3kgYmUsIGZvciBleGFtcGxlICdldGgnIG9uICdtYWlubmV0J1xuICAgKiBUaGlzIHR5cGUgbWF0Y2hlcyBhIHNpbmdsZSBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbCBvciBhXG4gICAqIFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sIGFuZCBhIE1vb25QYXlOZXR3b3JrQWJicmV2aWF0aW9uIGpvaW5lZCBieSBhICdfJy5cbiAgICovXG4gIGRlZmF1bHRDdXJyZW5jeUNvZGU6XG4gICAgfCBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbFxuICAgIHwgYCR7U3VwcG9ydGVkQ3VycmVuY3lTeW1ib2x9XyR7TW9vblBheU5ldHdvcmtBYmJyZXZpYXRpb259YDtcbiAgLyoqXG4gICAqIFdlIG11c3QgYWxzbyBjb25maWd1cmUgYWxsIHBvc3NpYmxlIG9ucmFtcCBjdXJyZW5jaWVzIHdlIHdpc2ggdG8gc3VwcG9ydC5cbiAgICogVGhpcyB0eXBlIG1hdGNoZXMgZWl0aGVyIGFuIGFycmF5IG9mIFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sIG9yXG4gICAqIGFuIGFycmF5IG9mIFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sIGFuZCBhIE1vb25QYXlOZXR3b3JrQWJicmV2aWF0aW9uIGpvaW5lZCBieSBhICdfJy5cbiAgICovXG4gIHNob3dPbmx5Q3VycmVuY2llczpcbiAgICB8IFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sW11cbiAgICB8IGAke1N1cHBvcnRlZEN1cnJlbmN5U3ltYm9sfV8ke01vb25QYXlOZXR3b3JrQWJicmV2aWF0aW9ufWBbXTtcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJlZmVyZW5jZXMgZm9yIGFuIFJQQyBkZWZpbml0aW9uXG4gKi9cbnR5cGUgUlBDUHJlZmVyZW5jZXMgPSB7XG4gIC8qKlxuICAgKiBBIFVSTCBmb3IgdGhlIGJsb2NrIGV4cGxvcmVyIGZvciB0aGUgUlBDJ3MgbmV0d29ya1xuICAgKi9cbiAgYmxvY2tFeHBsb3JlclVybDogYGh0dHBzOi8vJHtzdHJpbmd9YDtcbiAgLyoqXG4gICAqIEEgaW1hZ2UgcmVmbGVjdGluZyB0aGUgYXNzZXQgc3ltYm9sIGZvciB0aGUgbmV0d29ya1xuICAgKi9cbiAgaW1hZ2VVcmw6IHN0cmluZztcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbmV0d29yayB0byBiZSB1c2VkIGluc2lkZSBvZiBNZXRhTWFza1xuICovXG50eXBlIFJQQ0RlZmluaXRpb24gPSB7XG4gIC8qKlxuICAgKiBUaGUgaGV4IGVuY29kZWQgQ2hhaW5JZCBmb3IgdGhlIG5ldHdvcmtcbiAgICovXG4gIGNoYWluSWQ6IENoYWluSWQ7XG4gIC8qKlxuICAgKiBUaGUgbmlja25hbWUgZm9yIHRoZSBuZXR3b3JrXG4gICAqL1xuICBuaWNrbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIFVSTCBmb3IgdGhlIGNsaWVudCB0byBzZW5kIG5ldHdvcmsgcmVxdWVzdHMgdG9cbiAgICovXG4gIHJwY1VybDogYGh0dHBzOi8vJHtzdHJpbmd9YDtcbiAgLyoqXG4gICAqIFRoZSBDdXJyZW5jeSBTeW1ib2wgZm9yIHRoZSBuZXR3b3JrXG4gICAqL1xuICB0aWNrZXI6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgcHJlZmVyZW5jZXMgZm9yIHRoZSBuZXR3b3JrLCBzdWNoIGFzIGJsb2NrRXhwbG9yZXJVcmxcbiAgICovXG4gIHJwY1ByZWZzOiBSUENQcmVmZXJlbmNlcztcbn07XG5cbi8qKlxuICogV3lyZSBpcyBhIGZpYXQgb25yYW1wIHByb3ZpZGVyLiBXZSBtdXN0IHByb3ZpZGUgc29tZSBzZXR0aW5ncyBmb3IgbmV0d29ya3NcbiAqIHRoYXQgc3VwcG9ydCBXeXJlLlxuICovXG50eXBlIFd5cmVDaGFpblNldHRpbmdzID0ge1xuICAvKipcbiAgICogVGhlIG5ldHdvcmsgbmFtZVxuICAgKi9cbiAgc3JuOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmF0aXZlIGN1cnJlbmN5IGZvciB0aGUgbmV0d29ya1xuICAgKi9cbiAgY3VycmVuY3lDb2RlOiBDdXJyZW5jeVN5bWJvbDtcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBjdXJyZW5jaWVzIGZvciB0aGUgV3lyZSBvbnJhbXAgcHJvdmlkZXJcbiAgICovXG4gIGN1cnJlbmNpZXM6IFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sW107XG59O1xuXG4vKipcbiAqIEZvciBlYWNoIGNoYWluIHRoYXQgd2Ugc3VwcG9ydCBmaWF0IG9ucmFtcHMgZm9yLCB3ZSBwcm92aWRlIGEgc2V0IG9mXG4gKiBjb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBoZWxwIGZvciBpbml0aWFsaXppbmcgdGhlIGNvbm5lY3Rpb25nIHRvIHRoZVxuICogb25yYW1wIHByb3ZpZGVycy5cbiAqL1xudHlwZSBCdXlhYmxlQ2hhaW5TZXR0aW5ncyA9IHtcbiAgLyoqXG4gICAqIFRoZSBuYXRpdmUgY3VycmVuY3kgZm9yIHRoZSBnaXZlbiBjaGFpblxuICAgKi9cbiAgbmF0aXZlQ3VycmVuY3k6IEN1cnJlbmN5U3ltYm9sIHwgVGVzdE5ldHdvcmtDdXJyZW5jeVN5bWJvbDtcbiAgLyoqXG4gICAqIFRoZSBuZXR3b3JrIG5hbWUgb3IgaWRlbnRpZmllclxuICAgKi9cbiAgbmV0d29yazogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIGN1cnJlbmNpZXMgZm9yIHRoZSBUcmFuc2FrIG9ucmFtcCBwcm92aWRlclxuICAgKi9cbiAgdHJhbnNha0N1cnJlbmNpZXM/OiBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbFtdO1xuICAvKipcbiAgICogQSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIE1vb25QYXkgb25yYW1wIHByb3ZpZGVyXG4gICAqL1xuICBtb29uUGF5PzogTW9vblBheUNoYWluU2V0dGluZ3M7XG4gIC8qKlxuICAgKiBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgV3lyZSBvbnJhbXAgcHJvdmlkZXJcbiAgICovXG4gIHd5cmU/OiBXeXJlQ2hhaW5TZXR0aW5ncztcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBjdXJyZW5jaWVzIGZvciB0aGUgQ29pbmJhc2VQYXkgb25yYW1wIHByb3ZpZGVyXG4gICAqL1xuICBjb2luYmFzZVBheUN1cnJlbmNpZXM/OiBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbFtdO1xufTtcblxuLyoqXG4gKiBUaHJvdWdob3V0IHRoZSBleHRlbnNpb24gd2Ugc2V0IHRoZSBjdXJyZW50IHByb3ZpZGVyIGJ5IHJlZmVyZW5jaW5nIGl0c1xuICogXCJ0eXBlXCIsIHdoaWNoIGNhbiBiZSBhbnkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYmVsb3cgb2JqZWN0LiBUaGVzZSB2YWx1ZXNcbiAqIHJlcHJlc2VudCB0aGUgYnVpbHQtaW4gbmV0d29ya3Mgb2YgTWV0YU1hc2ssIGluY2x1ZGluZyB0ZXN0IG5ldHMsIGFzIHdlbGxcbiAqIGFzIFwicnBjXCIgd2hpY2ggaXMgdGhlIFwidHlwZVwiIG9mIGEgY3VzdG9tIG5ldHdvcmsgYWRkZWQgYnkgdGhlIHVzZXIgb3IgdmlhXG4gKiB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbi5cbiAqL1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfVFlQRVMgPSB7XG4gIEdPRVJMSTogJ2dvZXJsaScsXG4gIExPQ0FMSE9TVDogJ2xvY2FsaG9zdCcsXG4gIE1BSU5ORVQ6ICdtYWlubmV0JyxcbiAgUlBDOiAncnBjJyxcbiAgU0VQT0xJQTogJ3NlcG9saWEnLFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBzaG9ydGN1dCBuYW1lcyBmb3IgYW55IG5vbi1idWlsdGluIG5ldHdvcmsuIFdlIG5lZWRcbiAqIHRoaXMgdG8gYmUgYWJsZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbmV0d29ya3MgdGhhdCByZXF1aXJlIGN1c3RvbVxuICogc2VjdGlvbnMgb2YgY29kZSBmb3Igb3VyIHZhcmlvdXMgZmVhdHVyZXMsIHN1Y2ggYXMgc3dhcHMgb3IgdG9rZW4gbGlzdHMuXG4gKi9cbmV4cG9ydCBjb25zdCBORVRXT1JLX05BTUVTID0ge1xuICBIT01FU1RFQUQ6ICdob21lc3RlYWQnLFxufTtcblxuLyoqXG4gKiBUaGUgTmV0d29yayBJRCBmb3Igb3VyIGJ1aWx0aW4gbmV0d29ya3MuIFRoaXMgaXMgdGhlIGRlY2ltYWwgZXF1aXZhbGVudCBvZlxuICogdGhlIGNoYWluIGlkIGZvciB0aGUgbmV0d29yaywgYnV0IGlzIGV4cHJlc3NzZWQgYXMgYSBzdHJpbmcuIE1hbnkgbW9vbnMgYWdvXG4gKiB0aGUgZGVjaXNpb24gd2FzIG1hZGUgb24gdGhlIGV4dGVuc2lvbiB0ZWFtIHRvIGV4cHJlc3NseSB1c2UgY2hhaW5JZCB3aXRoXG4gKiBoZXggZW5jb2Rpbmcgb3ZlciBuZXR3b3JrIGlkLiBDb25zaWRlciB0aGF0IHdoZW4gYWNjZXNzaW5nIHRoaXMgb2JqZWN0LiBOb3RlXG4gKiBmb3IgY3Jvc3MgcHJvZHVjdCBwdXJwb3NlczogYWxpZ25tZW50IHdpdGggbW9iaWxlIG9uIHRoaXMgbWF0dGVyIGhhcyBub3RcbiAqIGJlZW4gZnVsbHkgYWNoaWV2ZWQsIHRodXMgaXQgaXMgcG9zc2libGUgZm9yIHNvbWUgZGVwZW5kZW5jaWVzIHRvIHN0aWxsXG4gKiBhc2sgZm9yIG9yIHJlcXVpcmUgbmV0d29yayBpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfSURTID0ge1xuICBNQUlOTkVUOiAnMScsXG4gIEdPRVJMSTogJzUnLFxuICBMT0NBTEhPU1Q6ICcxMzM3JyxcbiAgU0VQT0xJQTogJzExMTU1MTExJyxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjaGFpbiBpZHMgZm9yIG5ldHdvcmtzIGJvdGggYnVpbHQgaW4gYW5kXG4gKiB0aG9zZSB0aGF0IHdlIGhhdmUgYWRkZWQgY3VzdG9tIGNvZGUgdG8gc3VwcG9ydCBvdXIgZmVhdHVyZSBzZXQuXG4gKi9cbmV4cG9ydCBjb25zdCBDSEFJTl9JRFMgPSB7XG4gIE1BSU5ORVQ6ICcweDEnLFxuICBHT0VSTEk6ICcweDUnLFxuICBMT0NBTEhPU1Q6ICcweDUzOScsXG4gIEJTQzogJzB4MzgnLFxuICBPUFRJTUlTTTogJzB4YScsXG4gIE9QVElNSVNNX1RFU1RORVQ6ICcweDFhNCcsXG4gIFBPTFlHT046ICcweDg5JyxcbiAgQVZBTEFOQ0hFOiAnMHhhODZhJyxcbiAgRkFOVE9NOiAnMHhmYScsXG4gIENFTE86ICcweGE0ZWMnLFxuICBBUkJJVFJVTTogJzB4YTRiMScsXG4gIEhBUk1PTlk6ICcweDYzNTY0YzQwJyxcbiAgUEFMTTogJzB4MmExNWMzMDhkJyxcbiAgU0VQT0xJQTogJzB4YWEzNmE3JyxcbiAgQVVST1JBOiAnMHg0ZTQ1NDE1MicsXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIFRoZSBsYXJnZXN0IHBvc3NpYmxlIGNoYWluIElEIHdlIGNhbiBoYW5kbGUuXG4gKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmVrbWFya3MvYTQ3YmQ1ZjI1MjU5MzZjNGI4ZWVlMzFhMTYzNDU1NTNcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0NIQUlOX0lEID0gNDUwMzU5OTYyNzM3MDQ3NjtcblxuZXhwb3J0IGNvbnN0IE1BSU5ORVRfRElTUExBWV9OQU1FID0gJ0V0aGVyZXVtIE1haW5uZXQnO1xuZXhwb3J0IGNvbnN0IEdPRVJMSV9ESVNQTEFZX05BTUUgPSAnR29lcmxpJztcbmV4cG9ydCBjb25zdCBTRVBPTElBX0RJU1BMQVlfTkFNRSA9ICdTZXBvbGlhJztcbmV4cG9ydCBjb25zdCBMT0NBTEhPU1RfRElTUExBWV9OQU1FID0gJ0xvY2FsaG9zdCA4NTQ1JztcbmV4cG9ydCBjb25zdCBCU0NfRElTUExBWV9OQU1FID0gJ0JpbmFuY2UgU21hcnQgQ2hhaW4nO1xuZXhwb3J0IGNvbnN0IFBPTFlHT05fRElTUExBWV9OQU1FID0gJ1BvbHlnb24nO1xuZXhwb3J0IGNvbnN0IEFWQUxBTkNIRV9ESVNQTEFZX05BTUUgPSAnQXZhbGFuY2hlIE5ldHdvcmsgQy1DaGFpbic7XG5leHBvcnQgY29uc3QgQVJCSVRSVU1fRElTUExBWV9OQU1FID0gJ0FyYml0cnVtIE9uZSc7XG5leHBvcnQgY29uc3QgQk5CX0RJU1BMQVlfTkFNRSA9XG4gICdCTkIgU21hcnQgQ2hhaW4gKHByZXZpb3VzbHkgQmluYW5jZSBTbWFydCBDaGFpbiBNYWlubmV0KSc7XG5leHBvcnQgY29uc3QgT1BUSU1JU01fRElTUExBWV9OQU1FID0gJ09wdGltaXNtJztcbmV4cG9ydCBjb25zdCBGQU5UT01fRElTUExBWV9OQU1FID0gJ0ZhbnRvbSBPcGVyYSc7XG5leHBvcnQgY29uc3QgSEFSTU9OWV9ESVNQTEFZX05BTUUgPSAnSGFybW9ueSBNYWlubmV0IFNoYXJkIDAnO1xuZXhwb3J0IGNvbnN0IFBBTE1fRElTUExBWV9OQU1FID0gJ1BhbG0nO1xuZXhwb3J0IGNvbnN0IEFVUk9SQV9ESVNQTEFZX05BTUUgPSAnQXVyb3JhIE1haW5uZXQnO1xuXG5leHBvcnQgY29uc3QgaW5mdXJhUHJvamVjdElkID0gcHJvY2Vzcy5lbnYuSU5GVVJBX1BST0pFQ1RfSUQ7XG5leHBvcnQgY29uc3QgZ2V0UnBjVXJsID0gKHtcbiAgbmV0d29yayxcbiAgZXhjbHVkZVByb2plY3RJZCA9IGZhbHNlLFxufToge1xuICBuZXR3b3JrOiBOZXR3b3JrVHlwZTtcbiAgZXhjbHVkZVByb2plY3RJZD86IGJvb2xlYW47XG59KSA9PlxuICBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pby92My8ke2V4Y2x1ZGVQcm9qZWN0SWQgPyAnJyA6IGluZnVyYVByb2plY3RJZH1gO1xuXG5leHBvcnQgY29uc3QgTUFJTk5FVF9SUENfVVJMID0gZ2V0UnBjVXJsKHtcbiAgbmV0d29yazogTkVUV09SS19UWVBFUy5NQUlOTkVULFxufSk7XG5leHBvcnQgY29uc3QgR09FUkxJX1JQQ19VUkwgPSBnZXRScGNVcmwoeyBuZXR3b3JrOiBORVRXT1JLX1RZUEVTLkdPRVJMSSB9KTtcbmV4cG9ydCBjb25zdCBTRVBPTElBX1JQQ19VUkwgPSBnZXRScGNVcmwoeyBuZXR3b3JrOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEgfSk7XG5leHBvcnQgY29uc3QgTE9DQUxIT1NUX1JQQ19VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JztcblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW4gc3ltYm9scyBmb3IgdmFyaW91cyB0b2tlbnMgdGhhdCBhcmUgZWl0aGVyXG4gKiBuYXRpdmUgY3VycmVuY2llcyBvciB0aG9zZSB0aGF0IGhhdmUgYmVlbiBzcGVjaWFsIGNhc2VkIGJ5IHRoZSBleHRlbnNpb25cbiAqIGZvciBzdXBwb3J0aW5nIG91ciBmZWF0dXJlIHNldC5cbiAqL1xuZXhwb3J0IGNvbnN0IENVUlJFTkNZX1NZTUJPTFMgPSB7XG4gIEFSQklUUlVNOiAnRVRIJyxcbiAgQVVST1JBOiAnQXVyb3JhIEVUSCcsXG4gIEFWQUxBTkNIRTogJ0FWQVgnLFxuICBCTkI6ICdCTkInLFxuICBCVVNEOiAnQlVTRCcsXG4gIENFTE86ICdDRUxPJyxcbiAgREFJOiAnREFJJyxcbiAgRVRIOiAnRVRIJyxcbiAgRkFOVE9NOiAnRlRNJyxcbiAgSEFSTU9OWTogJ09ORScsXG4gIFBBTE06ICdQQUxNJyxcbiAgTUFUSUM6ICdNQVRJQycsXG4gIFRFU1RfRVRIOiAnVEVTVEVUSCcsXG4gIFVTREM6ICdVU0RDJyxcbiAgVVNEVDogJ1VTRFQnLFxuICBXRVRIOiAnV0VUSCcsXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB0b2tlbiBzeW1ib2xzIGZvciB2YXJpb3VzIHRva2VucyB0aGF0IGFyZSBzdXBwb3J0ZWRcbiAqIG9uIGRpZmZlcmVudCBvbiByYW1wIHByb3ZpZGVycy4gVGhpcyBvYmplY3QgaXMgbWVhbnQgZm9yIGludGVybmFsIGNvbnN1bXB0aW9uLFxuICogaGVuY2Ugd2h5IGl0IGlzIG5vdCBleHBvcnRlZC5cbiAqL1xuY29uc3QgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMgPSB7XG4gIC4uLkNVUlJFTkNZX1NZTUJPTFMsXG4gICcxSU5DSCc6ICcxSU5DSCcsXG4gIEFBVkU6ICdBQVZFJyxcbiAgQUJUOiAnQUJUJyxcbiAgQUNIOiAnQUNIJyxcbiAgQUdFVVI6ICdBR0VVUicsXG4gIEFHTEQ6ICdBR0xEJyxcbiAgQU1QOiAnQU1QJyxcbiAgQU5LUjogJ0FOS1InLFxuICBBUEU6ICdBUEUnLFxuICBBUlBBOiAnQVJQQScsXG4gIEFTTTogJ0FTTScsXG4gIEFVQ1RJT046ICdBVUNUSU9OJyxcbiAgQVhTOiAnQVhTJyxcbiAgQVZBWDogJ0FWQVgnLFxuICBBVkFYQzogJ0FWQVhDJyxcbiAgQVZBWENVU0RDOiAnQVZBWENVU0RDJyxcbiAgQkFER0VSOiAnQkFER0VSJyxcbiAgQkFMOiAnQkFMJyxcbiAgQkFORDogJ0JBTkQnLFxuICBCQVQ6ICdCQVQnLFxuICBCTlQ6ICdCTlQnLFxuICBCT0JBOiAnQk9CQScsXG4gIEJPTkQ6ICdCT05EJyxcbiAgQlRSU1Q6ICdCVFJTVCcsXG4gIENIQUlOOiAnQ0hBSU4nLFxuICBDSFo6ICdDSFonLFxuICBDTFY6ICdDTFYnLFxuICBDT01QOiAnQ09NUCcsXG4gIENPVEk6ICdDT1RJJyxcbiAgQ1JPOiAnQ1JPJyxcbiAgQ1JWOiAnQ1JWJyxcbiAgQ1RTSTogJ0NUU0knLFxuICBDVkM6ICdDVkMnLFxuICBEQU86ICdEQU8nLFxuICBERFg6ICdERFgnLFxuICBETlQ6ICdETlQnLFxuICBFTko6ICdFTkonLFxuICBFTlM6ICdFTlMnLFxuICBFVVJUOiAnRVVSVCcsXG4gIEZBUk06ICdGQVJNJyxcbiAgRkVUOiAnRkVUJyxcbiAgRk9SVEg6ICdGT1JUSCcsXG4gIEZYOiAnRlgnLFxuICBHTk86ICdHTk8nLFxuICBHUlQ6ICdHUlQnLFxuICBHVEM6ICdHVEMnLFxuICBHVEg6ICdHVEgnLFxuICBHVVNEOiAnR1VTRCcsXG4gIEdZRU46ICdHWUVOJyxcbiAgSEVYOiAnSEVYJyxcbiAgSU9UWDogJ0lPVFgnLFxuICBJTVg6ICdJTVgnLFxuICBKQVNNWTogJ0pBU01ZJyxcbiAgS0VFUDogJ0tFRVAnLFxuICBLTkM6ICdLTkMnLFxuICBLUkw6ICdLUkwnLFxuICBMQ1g6ICdMQ1gnLFxuICBMSU5LOiAnTElOSycsXG4gIExQVDogJ0xQVCcsXG4gIExSQzogJ0xSQycsXG4gIE1BTkE6ICdNQU5BJyxcbiAgTUFTSzogJ01BU0snLFxuICBNSU5EUzogJ01JTkRTJyxcbiAgTUlSOiAnTUlSJyxcbiAgTUtSOiAnTUtSJyxcbiAgTUxOOiAnTUxOJyxcbiAgTVRMOiAnTVRMJyxcbiAgTVVTREM6ICdtVVNEQycsXG4gIE5LTjogJ05LTicsXG4gIE5NUjogJ05NUicsXG4gIE5VOiAnTlUnLFxuICBPR046ICdPR04nLFxuICBPTUc6ICdPTUcnLFxuICBPUk46ICdPUk4nLFxuICBPWFQ6ICdPWFQnLFxuICBQQVg6ICdQQVgnLFxuICBQRVJQOiAnUEVSUCcsXG4gIFBMQTogJ1BMQScsXG4gIFBPTFM6ICdQT0xTJyxcbiAgUE9MWTogJ1BPTFknLFxuICBRTlQ6ICdRTlQnLFxuICBRVUlDSzogJ1FVSUNLJyxcbiAgUkFEOiAnUkFEJyxcbiAgUkFJOiAnUkFJJyxcbiAgUkFSSTogJ1JBUkknLFxuICBSRU46ICdSRU4nLFxuICBSRVA6ICdSRVAnLFxuICBSRVE6ICdSRVEnLFxuICBSTEM6ICdSTEMnLFxuICBSTFk6ICdSTFknLFxuICBTQU5EOiAnU0FORCcsXG4gIFNISUI6ICdTSElCJyxcbiAgU0tMOiAnU0tMJyxcbiAgU05YOiAnU05YJyxcbiAgU1BBOiAnU1BBJyxcbiAgU1RFVEg6ICdTVEVUSCcsXG4gIFNUT1JKOiAnU1RPUkonLFxuICBTVUtVOiAnU1VLVScsXG4gIFNVU0hJOiAnU1VTSEknLFxuICBTV0FQOiAnU1dBUCcsXG4gIFNXRlRDOiAnU1dGVEMnLFxuICBUUkFDOiAnVFJBQycsXG4gIFRSQjogJ1RSQicsXG4gIFRSSUJFOiAnVFJJQkUnLFxuICBUUlU6ICdUUlUnLFxuICBUWEw6ICdUWEwnLFxuICBVTUE6ICdVTUEnLFxuICBVTkk6ICdVTkknLFxuICBVU0RTOiAnVVNEUycsXG4gIFZSQTogJ1ZSQScsXG4gIFdCVEM6ICdXQlRDJyxcbiAgV0NGRzogJ1dDRkcnLFxuICBYWU86ICdYWU8nLFxuICBZRklJOiAnWUZJSScsXG4gIFlGSTogJ1lGSScsXG4gIFlMRDogJ1lMRCcsXG4gIFpSWDogJ1pSWCcsXG4gIFpVU0Q6ICdaVVNEJyxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBFVEhfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2V0aF9sb2dvLnN2Zyc7XG5leHBvcnQgY29uc3QgVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2JsYWNrLWV0aC1sb2dvLnN2Zyc7XG5leHBvcnQgY29uc3QgQk5CX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ibmIucG5nJztcbmV4cG9ydCBjb25zdCBNQVRJQ19UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvbWF0aWMtdG9rZW4ucG5nJztcbmV4cG9ydCBjb25zdCBBVkFYX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9hdmF4LXRva2VuLnBuZyc7XG5leHBvcnQgY29uc3QgQUVUSF9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvYXJiaXRydW0uc3ZnJztcbmV4cG9ydCBjb25zdCBGVE1fVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2ZhbnRvbS1vcGVyYS5zdmcnO1xuZXhwb3J0IGNvbnN0IEhBUk1PTllfT05FX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9oYXJtb255LW9uZS5zdmcnO1xuZXhwb3J0IGNvbnN0IE9QVElNSVNNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9vcHRpbWlzbS5zdmcnO1xuZXhwb3J0IGNvbnN0IFBBTE1fVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL3BhbG0uc3ZnJztcbmV4cG9ydCBjb25zdCBBVVJPUkFfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2F1cm9yYS5wbmcnO1xuXG5leHBvcnQgY29uc3QgSU5GVVJBX1BST1ZJREVSX1RZUEVTID0gW1xuICBORVRXT1JLX1RZUEVTLk1BSU5ORVQsXG4gIE5FVFdPUktfVFlQRVMuR09FUkxJLFxuICBORVRXT1JLX1RZUEVTLlNFUE9MSUEsXG5dO1xuXG5leHBvcnQgY29uc3QgVEVTVF9DSEFJTlMgPSBbXG4gIENIQUlOX0lEUy5HT0VSTEksXG4gIENIQUlOX0lEUy5TRVBPTElBLFxuICBDSEFJTl9JRFMuTE9DQUxIT1NULFxuXTtcblxuY29uc3QgdHlwZWRDYXBpdGFsaXplID0gPEsgZXh0ZW5kcyBzdHJpbmc+KGs6IEspOiBDYXBpdGFsaXplPEs+ID0+XG4gIGNhcGl0YWxpemUoaykgYXMgQ2FwaXRhbGl6ZTx0eXBlb2Ygaz47XG5cbmV4cG9ydCBjb25zdCBURVNUX05FVFdPUktfVElDS0VSX01BUDoge1xuICBbSyBpbiBFeGNsdWRlPFxuICAgIE5ldHdvcmtUeXBlLFxuICAgICdsb2NhbGhvc3QnIHwgJ21haW5uZXQnIHwgJ3JwYydcbiAgPl06IGAke0NhcGl0YWxpemU8Sz59JHt0eXBlb2YgQ1VSUkVOQ1lfU1lNQk9MUy5FVEh9YDtcbn0gPSB7XG4gIFtORVRXT1JLX1RZUEVTLkdPRVJMSV06IGAke3R5cGVkQ2FwaXRhbGl6ZShORVRXT1JLX1RZUEVTLkdPRVJMSSl9JHtcbiAgICBDVVJSRU5DWV9TWU1CT0xTLkVUSFxuICB9YCxcbiAgW05FVFdPUktfVFlQRVMuU0VQT0xJQV06IGAke3R5cGVkQ2FwaXRhbGl6ZShORVRXT1JLX1RZUEVTLlNFUE9MSUEpfSR7XG4gICAgQ1VSUkVOQ1lfU1lNQk9MUy5FVEhcbiAgfWAsXG59O1xuXG4vKipcbiAqIE1hcCBvZiBhbGwgYnVpbGQtaW4gSW5mdXJhIG5ldHdvcmtzIHRvIHRoZWlyIG5ldHdvcmssIHRpY2tlciBhbmQgY2hhaW4gSURzLlxuICovXG5leHBvcnQgY29uc3QgQlVJTFRfSU5fTkVUV09SS1MgPSB7XG4gIFtORVRXT1JLX1RZUEVTLkdPRVJMSV06IHtcbiAgICBuZXR3b3JrSWQ6IE5FVFdPUktfSURTLkdPRVJMSSxcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuR09FUkxJLFxuICAgIHRpY2tlcjogVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBbTkVUV09SS19UWVBFUy5HT0VSTEldLFxuICB9LFxuICBbTkVUV09SS19UWVBFUy5TRVBPTElBXToge1xuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuU0VQT0xJQSxcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuU0VQT0xJQSxcbiAgICB0aWNrZXI6IFRFU1RfTkVUV09SS19USUNLRVJfTUFQW05FVFdPUktfVFlQRVMuU0VQT0xJQV0sXG4gIH0sXG4gIFtORVRXT1JLX1RZUEVTLk1BSU5ORVRdOiB7XG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5NQUlOTkVULFxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5NQUlOTkVULFxuICB9LFxuICBbTkVUV09SS19UWVBFUy5MT0NBTEhPU1RdOiB7XG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5MT0NBTEhPU1QsXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkxPQ0FMSE9TVCxcbiAgfSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBORVRXT1JLX1RPX05BTUVfTUFQID0ge1xuICBbTkVUV09SS19UWVBFUy5NQUlOTkVUXTogTUFJTk5FVF9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX1RZUEVTLkdPRVJMSV06IEdPRVJMSV9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdOiBTRVBPTElBX0RJU1BMQVlfTkFNRSxcbiAgW05FVFdPUktfVFlQRVMuTE9DQUxIT1NUXTogTE9DQUxIT1NUX0RJU1BMQVlfTkFNRSxcblxuICBbTkVUV09SS19JRFMuR09FUkxJXTogR09FUkxJX0RJU1BMQVlfTkFNRSxcbiAgW05FVFdPUktfSURTLlNFUE9MSUFdOiBTRVBPTElBX0RJU1BMQVlfTkFNRSxcbiAgW05FVFdPUktfSURTLk1BSU5ORVRdOiBNQUlOTkVUX0RJU1BMQVlfTkFNRSxcbiAgW05FVFdPUktfSURTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9ESVNQTEFZX05BTUUsXG5cbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBHT0VSTElfRElTUExBWV9OQU1FLFxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBTRVBPTElBX0RJU1BMQVlfTkFNRSxcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTUFJTk5FVF9ESVNQTEFZX05BTUUsXG4gIFtDSEFJTl9JRFMuTE9DQUxIT1NUXTogTE9DQUxIT1NUX0RJU1BMQVlfTkFNRSxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBDSEFJTl9JRF9UT19UWVBFX01BUCA9IHtcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTkVUV09SS19UWVBFUy5NQUlOTkVULFxuICBbQ0hBSU5fSURTLkdPRVJMSV06IE5FVFdPUktfVFlQRVMuR09FUkxJLFxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEsXG4gIFtDSEFJTl9JRFMuTE9DQUxIT1NUXTogTkVUV09SS19UWVBFUy5MT0NBTEhPU1QsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgQ0hBSU5fSURfVE9fUlBDX1VSTF9NQVAgPSB7XG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX1JQQ19VUkwsXG4gIFtDSEFJTl9JRFMuU0VQT0xJQV06IFNFUE9MSUFfUlBDX1VSTCxcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTUFJTk5FVF9SUENfVVJMLFxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9SUENfVVJMLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX05FVFdPUktfSU1BR0VfVVJMX01BUCA9IHtcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFYX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5CU0NdOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBBRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5GQU5UT01dOiBGVE1fVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLkhBUk1PTlldOiBIQVJNT05ZX09ORV9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBPUFRJTUlTTV9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuUEFMTV06IFBBTE1fVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLkFVUk9SQV06IEFVUk9SQV9UT0tFTl9JTUFHRV9VUkwsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgTkVUV09SS19JRF9UT19FVEhFUlNfTkVUV09SS19OQU1FX01BUCA9IHtcbiAgW05FVFdPUktfSURTLkdPRVJMSV06IE5FVFdPUktfVFlQRVMuR09FUkxJLFxuICBbTkVUV09SS19JRFMuU0VQT0xJQV06IE5FVFdPUktfVFlQRVMuU0VQT0xJQSxcbiAgW05FVFdPUktfSURTLk1BSU5ORVRdOiBORVRXT1JLX05BTUVTLkhPTUVTVEVBRCxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBDSEFJTl9JRF9UT19ORVRXT1JLX0lEX01BUCA9IHtcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogTkVUV09SS19JRFMuTUFJTk5FVCxcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBORVRXT1JLX0lEUy5HT0VSTEksXG4gIFtDSEFJTl9JRFMuU0VQT0xJQV06IE5FVFdPUktfSURTLlNFUE9MSUEsXG4gIFtDSEFJTl9JRFMuTE9DQUxIT1NUXTogTkVUV09SS19JRFMuTE9DQUxIT1NULFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE5BVElWRV9DVVJSRU5DWV9UT0tFTl9JTUFHRV9NQVAgPSB7XG4gIFtDVVJSRU5DWV9TWU1CT0xTLkVUSF06IEVUSF9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDVVJSRU5DWV9TWU1CT0xTLlRFU1RfRVRIXTogVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5CTkJdOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQ106IE1BVElDX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFXTogQVZBWF9UT0tFTl9JTUFHRV9VUkwsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgSU5GVVJBX0JMT0NLRURfS0VZID0gJ2NvdW50cnlCbG9ja2VkJztcblxuLyoqXG4gKiBIYXJkZm9ya3MgYXJlIHBvaW50cyBpbiB0aGUgY2hhaW4gd2hlcmUgbG9naWMgaXMgY2hhbmdlZCBzaWduaWZpY2FudGx5XG4gKiBlbm91Z2ggd2hlcmUgdGhlcmUgaXMgYSBmb3JrIGFuZCB0aGUgbmV3IGZvcmsgYmVjb21lcyB0aGUgYWN0aXZlIGNoYWluLlxuICogVGhlc2UgY29uc3RhbnRzIGFyZSBwcmVzZW50ZWQgaW4gY2hyb25vbG9naWNhbCBvcmRlciBzdGFydGluZyB3aXRoIEJFUkxJTlxuICogYmVjYXVzZSB3aGVuIHdlIGZpcnN0IG5lZWRlZCB0byB0cmFjayB0aGUgaGFyZGZvcmsgd2UgaGFkIGxhdW5jaGVkIHN1cHBvcnRcbiAqIGZvciBFSVAtMjcxOCAod2hlcmUgdHJhbnNhY3Rpb25zIGNhbiBoYXZlIHR5cGVzIGFuZCBkaWZmZXJlbnQgc2hhcGVzKSBhbmRcbiAqIEVJUC0yOTMwIChvcHRpb25hbCBhY2Nlc3MgbGlzdHMpLCB3aGljaCB3ZXJlIGluY2x1ZGVkIGluIEJFUkxJTi5cbiAqXG4gKiBCRVJMSU4gLSBmb3JrZWQgYXQgYmxvY2sgbnVtYmVyIDEyLDI0NCwwMDAsIGluY2x1ZGVkIHR5cGVkIHRyYW5zYWN0aW9ucyBhbmRcbiAqIG9wdGlvbmFsIGFjY2VzcyBsaXN0c1xuICogTE9ORE9OIC0gZnV0dXJlLCB1cGNvbWluZyBmb3JrIHRoYXQgaW50cm9kdWNlcyB0aGUgYmFzZUZlZVBlckdhcywgYW4gYW1vdW50XG4gKiBvZiB0aGUgRVRIIHRyYW5zYWN0aW9uIGZlZXMgdGhhdCB3aWxsIGJlIGJ1cm5lZCBpbnN0ZWFkIG9mIGdpdmVuIHRvIHRoZVxuICogbWluZXIuIFRoaXMgY2hhbmdlIG5lY2Vzc2l0YXRlZCB0aGUgdGhpcmQgdHlwZSBvZiB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0b1xuICogc3BlY2lmeSBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIG1vdmluZyB0aGUgZmVlIGJpZGRpbmcgc3lzdGVtXG4gKiB0byBhIHNlY29uZCBwcmljZSBhdWN0aW9uIG1vZGVsLlxuICovXG5leHBvcnQgY29uc3QgSEFSREZPUktTID0ge1xuICBCRVJMSU46ICdiZXJsaW4nLFxuICBMT05ET046ICdsb25kb24nLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX0dBU19MSU1JVF9CVUZGRVJfTUFQID0ge1xuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogMSxcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVUXTogMSxcbn07XG5cbi8qKlxuICogRXRoZXJldW0gSlNPTi1SUEMgbWV0aG9kcyB0aGF0IGFyZSBrbm93biB0byBleGlzdCBidXQgdGhhdCB3ZSBpbnRlbnRpb25hbGx5XG4gKiBkbyBub3Qgc3VwcG9ydC5cbiAqL1xuZXhwb3J0IGNvbnN0IFVOU1VQUE9SVEVEX1JQQ19NRVRIT0RTID0gbmV3IFNldChbXG4gIC8vIFRoaXMgaXMgaW1wbGVtZW50ZWQgbGF0ZXIgaW4gb3VyIG1pZGRsZXdhcmUgc3RhY2sg4oCTIHNwZWNpZmljYWxseSwgaW5cbiAgLy8gZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUg4oCTIGJ1dCBvdXIgVUkgZG9lcyBub3Qgc3VwcG9ydCBpdC5cbiAgJ2V0aF9zaWduVHJhbnNhY3Rpb24nIGFzIGNvbnN0LFxuXSk7XG5cbmV4cG9ydCBjb25zdCBJUEZTX0RFRkFVTFRfR0FURVdBWV9VUkwgPSAnZHdlYi5saW5rJztcblxuLy8gVGhlIGZpcnN0IGl0ZW0gaW4gdHJhbnNha0N1cnJlbmNpZXMgbXVzdCBiZSB0aGVcbi8vIGRlZmF1bHQgY3J5cHRvIGN1cnJlbmN5IGZvciB0aGUgbmV0d29ya1xuY29uc3QgQlVZQUJMRV9DSEFJTl9FVEhFUkVVTV9ORVRXT1JLX05BTUUgPSAnZXRoZXJldW0nO1xuXG5leHBvcnQgY29uc3QgQlVZQUJMRV9DSEFJTlNfTUFQOiB7XG4gIFtLIGluIEV4Y2x1ZGU8XG4gICAgQ2hhaW5JZCxcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuTE9DQUxIT1NUXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLlBBTE1cbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuSEFSTU9OWVxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5PUFRJTUlTTV9URVNUTkVUXG4gID5dOiBCdXlhYmxlQ2hhaW5TZXR0aW5ncztcbn0gPSB7XG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXG4gICAgbmV0d29yazogQlVZQUJMRV9DSEFJTl9FVEhFUkVVTV9ORVRXT1JLX05BTUUsXG4gICAgdHJhbnNha0N1cnJlbmNpZXM6IFtcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTWycxSU5DSCddLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQUFWRSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFHRVVSLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQlVTRCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNIQUlOLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ0xWLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ09NUCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNUU0ksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5EQUksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5EQU8sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5FTkosXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5FVVJULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuR1RILFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuSEVYLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTElOSyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BTkEsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NQVNLLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUlORFMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NS1IsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5QTEEsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5QT0xTLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU0FORCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNURVRILFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU1VTSEksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TV0FQLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVFhMLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVU5JLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTRFQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5WUkEsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5XQlRDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuWUxELFxuICAgIF0sXG4gICAgbW9vblBheToge1xuICAgICAgZGVmYXVsdEN1cnJlbmN5Q29kZTogU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgICAgc2hvd09ubHlDdXJyZW5jaWVzOiBbXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEVCxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEQyxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuREFJLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuT1JOLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5XRVRILFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5JTVgsXG4gICAgICBdLFxuICAgIH0sXG4gICAgd3lyZToge1xuICAgICAgc3JuOiAnZXRoZXJldW0nLFxuICAgICAgY3VycmVuY3lDb2RlOiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICAgIGN1cnJlbmNpZXM6IFtcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BQVZFLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CQVQsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJVU0QsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNPTVAsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNSVixcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuREFJLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5HVVNELFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5HWUVOLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5MSU5LLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NS1IsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlBBWCxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUkFJLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TTlgsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVNQSxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVU5JLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RDLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RTLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RULFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5XQlRDLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5XRVRILFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5ZRkksXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlpVU0QsXG4gICAgICBdLFxuICAgIH0sXG4gICAgY29pbmJhc2VQYXlDdXJyZW5jaWVzOiBbXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MU1snMUlOQ0gnXSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFBVkUsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BQlQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BQ0gsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BR0xELFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQU1QLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQU5LUixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFQRSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFSUEEsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BU00sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BVUNUSU9OLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQVhTLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQkFER0VSLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQkFMLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQkFORCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJBVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJOVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJPQkEsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CT05ELFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQlRSU1QsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DSFosXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DTFYsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DT01QLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ09USSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNSTyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNSVixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNUU0ksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DVkMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5EQUksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5ERFgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5ETlQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5FTkosXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5FTlMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5GQVJNLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRkVULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRk9SVEgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5GWCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkdOTyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkdSVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkdUQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLklPVFgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5KQVNNWSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLktFRVAsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5LTkMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5LUkwsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5MQ1gsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5MSU5LLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTFBULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTFJDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUFOQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BU0ssXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1JUixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1LUixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1MTixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1UTCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk5LTixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk5NUixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk5VLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuT0dOLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuT01HLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuT1hULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUEFYLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUEVSUCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlBMQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlBPTFksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5RTlQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5RVUlDSyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJBRCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJBSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJBUkksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5SRU4sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5SRVAsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5SRVEsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5STEMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5STFksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TQU5ELFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU0hJQixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNLTCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNOWCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNUT1JKLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU1VLVSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNVU0hJLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU1dGVEMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5UUkFDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVFJCLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVFJJQkUsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5UUlUsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VTUEsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VTkksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLldCVEMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5XQ0ZHLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuWFlPLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuWUZJSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlpSWCxcbiAgICBdLFxuICB9LFxuICBbQ0hBSU5fSURTLkdPRVJMSV06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBbTkVUV09SS19UWVBFUy5HT0VSTEldLFxuICAgIG5ldHdvcms6IEJVWUFCTEVfQ0hBSU5fRVRIRVJFVU1fTkVUV09SS19OQU1FLFxuICB9LFxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiB7XG4gICAgbmF0aXZlQ3VycmVuY3k6IFRFU1RfTkVUV09SS19USUNLRVJfTUFQW05FVFdPUktfVFlQRVMuU0VQT0xJQV0sXG4gICAgbmV0d29yazogQlVZQUJMRV9DSEFJTl9FVEhFUkVVTV9ORVRXT1JLX05BTUUsXG4gIH0sXG4gIFtDSEFJTl9JRFMuQlNDXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkJOQixcbiAgICBuZXR3b3JrOiAnYnNjJyxcbiAgICB0cmFuc2FrQ3VycmVuY2llczogW1xuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQk5CLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQlVTRCxcbiAgICBdLFxuICAgIG1vb25QYXk6IHtcbiAgICAgIGRlZmF1bHRDdXJyZW5jeUNvZGU6IGAke1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJOQn1fQlNDYCxcbiAgICAgIHNob3dPbmx5Q3VycmVuY2llczogW1xuICAgICAgICBgJHtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CTkJ9X0JTQ2AsXG4gICAgICAgIGAke1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJVU0R9X0JTQ2AsXG4gICAgICBdLFxuICAgIH0sXG4gIH0sXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcbiAgICBuZXR3b3JrOiAncG9seWdvbicsXG4gICAgdHJhbnNha0N1cnJlbmNpZXM6IFtcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTREMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5EQUksXG4gICAgXSxcbiAgICBtb29uUGF5OiB7XG4gICAgICBkZWZhdWx0Q3VycmVuY3lDb2RlOiBgJHtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CTkJ9X1BPTFlHT05gLFxuICAgICAgc2hvd09ubHlDdXJyZW5jaWVzOiBbXG4gICAgICAgIGAke1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BVElDfV9QT0xZR09OYCxcbiAgICAgICAgYCR7U1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEQ31fUE9MWUdPTmAsXG4gICAgICBdLFxuICAgIH0sXG4gICAgd3lyZToge1xuICAgICAgc3JuOiAnbWF0aWMnLFxuICAgICAgY3VycmVuY3lDb2RlOiBDVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICAgICAgY3VycmVuY2llczogW1xuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTVVTREMsXG4gICAgICBdLFxuICAgIH0sXG4gIH0sXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkFWQUxBTkNIRSxcbiAgICBuZXR3b3JrOiAnYXZheGNjaGFpbicsXG4gICAgdHJhbnNha0N1cnJlbmNpZXM6IFtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEVdLFxuICAgIG1vb25QYXk6IHtcbiAgICAgIGRlZmF1bHRDdXJyZW5jeUNvZGU6IGAke1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFWQVh9X0NDSEFJTmAsXG4gICAgICBzaG93T25seUN1cnJlbmNpZXM6IFtgJHtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BVkFYfV9DQ0hBSU5gXSxcbiAgICB9LFxuICAgIHd5cmU6IHtcbiAgICAgIHNybjogJ2F2YWxhbmNoZScsXG4gICAgICBjdXJyZW5jeUNvZGU6IENVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFLFxuICAgICAgY3VycmVuY2llczogW1xuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFWQVhDLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BVkFYQ1VTREMsXG4gICAgICBdLFxuICAgIH0sXG4gICAgY29pbmJhc2VQYXlDdXJyZW5jaWVzOiBbU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFXSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5GQU5UT01dOiB7XG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuRkFOVE9NLFxuICAgIG5ldHdvcms6ICdmYW50b20nLFxuICAgIHRyYW5zYWtDdXJyZW5jaWVzOiBbU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRkFOVE9NXSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5DRUxPXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkNFTE8sXG4gICAgbmV0d29yazogJ2NlbG8nLFxuICAgIHRyYW5zYWtDdXJyZW5jaWVzOiBbU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ0VMT10sXG4gICAgbW9vblBheToge1xuICAgICAgZGVmYXVsdEN1cnJlbmN5Q29kZTogU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ0VMTyxcbiAgICAgIHNob3dPbmx5Q3VycmVuY2llczogW1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNFTE9dLFxuICAgIH0sXG4gIH0sXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiB7XG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgIG5ldHdvcms6ICdvcHRpbWlzbScsXG4gICAgdHJhbnNha0N1cnJlbmNpZXM6IFtcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTREMsXG4gICAgXSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5BUkJJVFJVTSxcbiAgICBuZXR3b3JrOiAnYXJiaXRydW0nLFxuICAgIHRyYW5zYWtDdXJyZW5jaWVzOiBbXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BUkJJVFJVTSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNQQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTREMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RTLFxuICAgIF0sXG4gIH0sXG4gIFtDSEFJTl9JRFMuQVVST1JBXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkFVUk9SQSxcbiAgICBuZXR3b3JrOiAnYXVyb3JhJyxcbiAgICB0cmFuc2FrQ3VycmVuY2llczogW1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFVUk9SQV0sXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgRkVBVFVSRURfUlBDUzogUlBDRGVmaW5pdGlvbltdID0gW1xuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkFSQklUUlVNLFxuICAgIG5pY2tuYW1lOiBBUkJJVFJVTV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hcmJpdHJ1bS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5BUkJJVFJVTSxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZXhwbG9yZXIuYXJiaXRydW0uaW8nLFxuICAgICAgaW1hZ2VVcmw6IEFFVEhfVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuQVVST1JBLFxuICAgIG5pY2tuYW1lOiBBVVJPUkFfRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogYGh0dHBzOi8vYXVyb3JhLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkFVUk9SQSxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vYXVyb3Jhc2Nhbi5kZXYvJyxcbiAgICAgIGltYWdlVXJsOiBBVVJPUkFfVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuQVZBTEFOQ0hFLFxuICAgIG5pY2tuYW1lOiBBVkFMQU5DSEVfRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogYGh0dHBzOi8vYXZhbGFuY2hlLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkFWQUxBTkNIRSxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vc25vd3RyYWNlLmlvLycsXG4gICAgICBpbWFnZVVybDogQVZBWF9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5CU0MsXG4gICAgbmlja25hbWU6IEJOQl9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiAnaHR0cHM6Ly9ic2MtZGF0YXNlZWQuYmluYW5jZS5vcmcvJyxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuQk5CLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9ic2NzY2FuLmNvbS8nLFxuICAgICAgaW1hZ2VVcmw6IEJOQl9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5GQU5UT00sXG4gICAgbmlja25hbWU6IEZBTlRPTV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiAnaHR0cHM6Ly9ycGMuZnRtLnRvb2xzLycsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkZBTlRPTSxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZnRtc2Nhbi5jb20vJyxcbiAgICAgIGltYWdlVXJsOiBGVE1fVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuSEFSTU9OWSxcbiAgICBuaWNrbmFtZTogSEFSTU9OWV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiAnaHR0cHM6Ly9hcGkuaGFybW9ueS5vbmUvJyxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuSEFSTU9OWSxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vZXhwbG9yZXIuaGFybW9ueS5vbmUvJyxcbiAgICAgIGltYWdlVXJsOiBIQVJNT05ZX09ORV9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5PUFRJTUlTTSxcbiAgICBuaWNrbmFtZTogT1BUSU1JU01fRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogYGh0dHBzOi8vb3B0aW1pc20tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9vcHRpbWlzdGljLmV0aGVyc2Nhbi5pby8nLFxuICAgICAgaW1hZ2VVcmw6IE9QVElNSVNNX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLlBBTE0sXG4gICAgbmlja25hbWU6IFBBTE1fRElTUExBWV9OQU1FLFxuICAgIHJwY1VybDogYGh0dHBzOi8vcGFsbS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5QQUxNLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5wYWxtLmlvLycsXG4gICAgICBpbWFnZVVybDogUEFMTV9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5QT0xZR09OLFxuICAgIG5pY2tuYW1lOiBgJHtQT0xZR09OX0RJU1BMQVlfTkFNRX0gJHtjYXBpdGFsaXplKE5FVFdPUktfVFlQRVMuTUFJTk5FVCl9YCxcbiAgICBycGNVcmw6IGBodHRwczovL3BvbHlnb24tbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuTUFUSUMsXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL3BvbHlnb25zY2FuLmNvbS8nLFxuICAgICAgaW1hZ2VVcmw6IE1BVElDX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuXTtcbiIsImV4cG9ydCBjb25zdCBDYXZlYXRUeXBlcyA9IE9iamVjdC5mcmVlemUoe1xuICByZXN0cmljdFJldHVybmVkQWNjb3VudHM6ICdyZXN0cmljdFJldHVybmVkQWNjb3VudHMnIGFzIGNvbnN0LFxufSk7XG5cbmV4cG9ydCBjb25zdCBSZXN0cmljdGVkTWV0aG9kcyA9IE9iamVjdC5mcmVlemUoe1xuICBldGhfYWNjb3VudHM6ICdldGhfYWNjb3VudHMnLFxuICAvLy86IEJFR0lOOk9OTFlfSU5DTFVERV9JTihmbGFzaylcbiAgc25hcF9jb25maXJtOiAnc25hcF9jb25maXJtJyxcbiAgc25hcF9ub3RpZnk6ICdzbmFwX25vdGlmeScsXG4gIHNuYXBfbWFuYWdlU3RhdGU6ICdzbmFwX21hbmFnZVN0YXRlJyxcbiAgc25hcF9nZXRCaXAzMlB1YmxpY0tleTogJ3NuYXBfZ2V0QmlwMzJQdWJsaWNLZXknLFxuICBzbmFwX2dldEJpcDMyRW50cm9weTogJ3NuYXBfZ2V0QmlwMzJFbnRyb3B5JyxcbiAgc25hcF9nZXRCaXA0NEVudHJvcHk6ICdzbmFwX2dldEJpcDQ0RW50cm9weScsXG4gICd3YWxsZXRfc25hcF8qJzogJ3dhbGxldF9zbmFwXyonLFxuICAvLy86IEVORDpPTkxZX0lOQ0xVREVfSU5cbn0gYXMgY29uc3QpO1xuXG4vLy86IEJFR0lOOk9OTFlfSU5DTFVERV9JTihmbGFzaylcbmV4cG9ydCBjb25zdCBQZXJtaXNzaW9uTmFtZXNwYWNlcyA9IE9iamVjdC5mcmVlemUoe1xuICB3YWxsZXRfc25hcF86ICd3YWxsZXRfc25hcF8qJyxcbn0gYXMgY29uc3QpO1xuXG5leHBvcnQgY29uc3QgRW5kb3dtZW50UGVybWlzc2lvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgJ2VuZG93bWVudDpuZXR3b3JrLWFjY2Vzcyc6ICdlbmRvd21lbnQ6bmV0d29yay1hY2Nlc3MnLFxuICAnZW5kb3dtZW50OmxvbmctcnVubmluZyc6ICdlbmRvd21lbnQ6bG9uZy1ydW5uaW5nJyxcbiAgJ2VuZG93bWVudDp0cmFuc2FjdGlvbi1pbnNpZ2h0JzogJ2VuZG93bWVudDp0cmFuc2FjdGlvbi1pbnNpZ2h0Jyxcbn0gYXMgY29uc3QpO1xuXG4vLyBNZXRob2RzIC8gcGVybWlzc2lvbnMgaW4gZXh0ZXJuYWwgcGFja2FnZXMgdGhhdCB3ZSBhcmUgdGVtcG9yYXJpbHkgZXhjbHVkaW5nLlxuZXhwb3J0IGNvbnN0IEV4Y2x1ZGVkU25hcFBlcm1pc3Npb25zID0gbmV3IFNldChbJ3NuYXBfZGlhbG9nJ10pO1xuZXhwb3J0IGNvbnN0IEV4Y2x1ZGVkU25hcEVuZG93bWVudHMgPSBuZXcgU2V0KFsnZW5kb3dtZW50OmtleXJpbmcnXSk7XG4vLy86IEVORDpPTkxZX0lOQ0xVREVfSU5cbiIsImltcG9ydCB7XHJcbiAgVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIEJOQl9UT0tFTl9JTUFHRV9VUkwsXHJcbiAgTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxyXG4gIENVUlJFTkNZX1NZTUJPTFMsXHJcbiAgQ0hBSU5fSURTLFxyXG59IGZyb20gJy4vbmV0d29yayc7XHJcblxyXG5leHBvcnQgY29uc3QgUVVPVEVTX0VYUElSRURfRVJST1IgPSAncXVvdGVzLWV4cGlyZWQnO1xyXG5leHBvcnQgY29uc3QgU1dBUF9GQUlMRURfRVJST1IgPSAnc3dhcC1mYWlsZWQtZXJyb3InO1xyXG5leHBvcnQgY29uc3QgRVJST1JfRkVUQ0hJTkdfUVVPVEVTID0gJ2Vycm9yLWZldGNoaW5nLXF1b3Rlcyc7XHJcbmV4cG9ydCBjb25zdCBRVU9URVNfTk9UX0FWQUlMQUJMRV9FUlJPUiA9ICdxdW90ZXMtbm90LWF2aWxhYmxlJztcclxuZXhwb3J0IGNvbnN0IENPTlRSQUNUX0RBVEFfRElTQUJMRURfRVJST1IgPSAnY29udHJhY3QtZGF0YS1kaXNhYmxlZCc7XHJcbmV4cG9ydCBjb25zdCBPRkZMSU5FX0ZPUl9NQUlOVEVOQU5DRSA9ICdvZmZsaW5lLWZvci1tYWludGVuYW5jZSc7XHJcbmV4cG9ydCBjb25zdCBTV0FQU19GRVRDSF9PUkRFUl9DT05GTElDVCA9ICdzd2Fwcy1mZXRjaC1vcmRlci1jb25mbGljdCc7XHJcblxyXG4vLyBBbiBhZGRyZXNzIHRoYXQgdGhlIG1ldGFzd2FwLWFwaSByZWNvZ25pemVzIGFzIHRoZSBkZWZhdWx0IHRva2VuIGZvciB0aGUgY3VycmVudCBuZXR3b3JrLCBpbiBwbGFjZSBvZiB0aGUgdG9rZW4gYWRkcmVzcyB0aGF0IEVSQy0yMCB0b2tlbnMgaGF2ZVxyXG5jb25zdCBERUZBVUxUX1RPS0VOX0FERFJFU1MgPSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJztcclxuXHJcbmV4cG9ydCBjb25zdCBFVEhfU1dBUFNfVE9LRU5fT0JKRUNUID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXHJcbiAgbmFtZTogJ0V0aGVyJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6ICcuL2ltYWdlcy9ibGFjay1ldGgtbG9nby5zdmcnLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEJOQl9TV0FQU19UT0tFTl9PQkpFQ1QgPSB7XHJcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLkJOQixcclxuICBuYW1lOiAnQmluYW5jZSBDb2luJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6IEJOQl9UT0tFTl9JTUFHRV9VUkwsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgTUFUSUNfU1dBUFNfVE9LRU5fT0JKRUNUID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcclxuICBuYW1lOiAnTWF0aWMnLFxyXG4gIGFkZHJlc3M6IERFRkFVTFRfVE9LRU5fQUREUkVTUyxcclxuICBkZWNpbWFsczogMTgsXHJcbiAgaWNvblVybDogTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IEFWQVhfU1dBUFNfVE9LRU5fT0JKRUNUID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXHJcbiAgbmFtZTogJ0F2YWxhbmNoZScsXHJcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxyXG4gIGRlY2ltYWxzOiAxOCxcclxuICBpY29uVXJsOiBBVkFYX1RPS0VOX0lNQUdFX1VSTCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBURVNUX0VUSF9TV0FQU19UT0tFTl9PQkpFQ1QgPSB7XHJcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLlRFU1RfRVRILFxyXG4gIG5hbWU6ICdUZXN0IEV0aGVyJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBHT0VSTElfU1dBUFNfVE9LRU5fT0JKRUNUID0ge1xyXG4gIHN5bWJvbDogQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXHJcbiAgbmFtZTogJ0V0aGVyJyxcclxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXHJcbiAgZGVjaW1hbHM6IDE4LFxyXG4gIGljb25Vcmw6IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcclxufTtcclxuXHJcbi8vIEEgZ2FzIHZhbHVlIGZvciBFUkMyMCBhcHByb3ZlIGNhbGxzIHRoYXQgc2hvdWxkIGJlIHN1ZmZpY2llbnQgZm9yIGFsbCBFUkMyMCBhcHByb3ZlIGltcGxlbWVudGF0aW9uc1xyXG5leHBvcnQgY29uc3QgREVGQVVMVF9FUkMyMF9BUFBST1ZFX0dBUyA9ICcweDFkNGMwJztcclxuXHJcbmNvbnN0IE1BSU5ORVRfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDg4MWQ0MDIzNzY1OWMyNTE4MTFjZWM5YzM2NGVmOTFkYzA4ZDMwMGMnO1xyXG5cclxuY29uc3QgVEVTVE5FVF9DT05UUkFDVF9BRERSRVNTID0gJzB4ODgxZDQwMjM3NjU5YzI1MTgxMWNlYzljMzY0ZWY5MWRjMDhkMzAwYyc7XHJcblxyXG5jb25zdCBCU0NfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDFhMWVjMjVkYzA4ZTk4ZTVlOTNmMTEwNGI1ZTVjZGQyOTg3MDdkMzEnO1xyXG5cclxuLy8gSXQncyB0aGUgc2FtZSBhcyB3ZSB1c2UgZm9yIEJTQy5cclxuY29uc3QgUE9MWUdPTl9DT05UUkFDVF9BRERSRVNTID0gJzB4MWExZWMyNWRjMDhlOThlNWU5M2YxMTA0YjVlNWNkZDI5ODcwN2QzMSc7XHJcblxyXG5jb25zdCBBVkFMQU5DSEVfQ09OVFJBQ1RfQUREUkVTUyA9ICcweDFhMWVjMjVkYzA4ZTk4ZTVlOTNmMTEwNGI1ZTVjZGQyOTg3MDdkMzEnO1xyXG5cclxuZXhwb3J0IGNvbnN0IFdFVEhfQ09OVFJBQ1RfQUREUkVTUyA9XHJcbiAgJzB4YzAyYWFhMzliMjIzZmU4ZDBhMGU1YzRmMjdlYWQ5MDgzYzc1NmNjMic7XHJcbmV4cG9ydCBjb25zdCBXRVRIX0dPRVJMSV9DT05UUkFDVF9BRERSRVNTID1cclxuICAnMHhCNEZCRjI3MTE0M0Y0RkJmN0I5MUE1ZGVkMzE4MDVlNDJiMjIwOGQ2JztcclxuZXhwb3J0IGNvbnN0IFdCTkJfQ09OVFJBQ1RfQUREUkVTUyA9XHJcbiAgJzB4YmI0Y2RiOWNiZDM2YjAxYmQxY2JhZWJmMmRlMDhkOTE3M2JjMDk1Yyc7XHJcbmV4cG9ydCBjb25zdCBXTUFUSUNfQ09OVFJBQ1RfQUREUkVTUyA9XHJcbiAgJzB4MGQ1MDBiMWQ4ZThlZjMxZTIxYzk5ZDFkYjlhNjQ0NGQzYWRmMTI3MCc7XHJcbmV4cG9ydCBjb25zdCBXQVZBWF9DT05UUkFDVF9BRERSRVNTID1cclxuICAnMHhiMzFmNjZhYTNjMWU3ODUzNjNmMDg3NWExYjc0ZTI3Yjg1ZmQ2NmM3JztcclxuXHJcbmNvbnN0IFNXQVBTX1RFU1RORVRfQ0hBSU5fSUQgPSAnMHg1MzknO1xyXG5cclxuZXhwb3J0IGNvbnN0IFNXQVBTX0FQSV9WMl9CQVNFX1VSTCA9ICdodHRwczovL3N3YXAubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsnO1xyXG5leHBvcnQgY29uc3QgU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTCA9XHJcbiAgJ2h0dHBzOi8vc3dhcC5tZXRhc3dhcC1kZXYuY29kZWZpLm5ldHdvcmsnO1xyXG5leHBvcnQgY29uc3QgR0FTX0FQSV9CQVNFX1VSTCA9ICdodHRwczovL2dhcy1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsnO1xyXG5leHBvcnQgY29uc3QgR0FTX0RFVl9BUElfQkFTRV9VUkwgPVxyXG4gICdodHRwczovL2dhcy1hcGkubWV0YXN3YXAtZGV2LmNvZGVmaS5uZXR3b3JrJztcclxuXHJcbmNvbnN0IEJTQ19ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2JzY3NjYW4uY29tLyc7XHJcbmNvbnN0IE1BSU5ORVRfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9ldGhlcnNjYW4uaW8vJztcclxuY29uc3QgR09FUkxJX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMID0gJ2h0dHBzOi8vZ29lcmxpLmV0aGVyc2Nhbi5pby8nO1xyXG5jb25zdCBQT0xZR09OX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMID0gJ2h0dHBzOi8vcG9seWdvbnNjYW4uY29tLyc7XHJcbmNvbnN0IEFWQUxBTkNIRV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL3Nub3d0cmFjZS5pby8nO1xyXG5cclxuZXhwb3J0IGNvbnN0IEFMTE9XRURfUFJPRF9TV0FQU19DSEFJTl9JRFMgPSBbXHJcbiAgQ0hBSU5fSURTLk1BSU5ORVQsXHJcbiAgU1dBUFNfVEVTVE5FVF9DSEFJTl9JRCxcclxuICBDSEFJTl9JRFMuQlNDLFxyXG4gIENIQUlOX0lEUy5QT0xZR09OLFxyXG4gIENIQUlOX0lEUy5BVkFMQU5DSEUsXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgQUxMT1dFRF9ERVZfU1dBUFNfQ0hBSU5fSURTID0gW1xyXG4gIC4uLkFMTE9XRURfUFJPRF9TV0FQU19DSEFJTl9JRFMsXHJcbiAgQ0hBSU5fSURTLkdPRVJMSSxcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBBTExPV0VEX1NNQVJUX1RSQU5TQUNUSU9OU19DSEFJTl9JRFMgPSBbXHJcbiAgQ0hBSU5fSURTLk1BSU5ORVQsXHJcbiAgQ0hBSU5fSURTLkdPRVJMSSxcclxuXTtcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQID0ge1xyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE1BSU5ORVRfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF06IFRFU1RORVRfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkJTQ106IEJTQ19DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFBPTFlHT05fQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkdPRVJMSV06IFRFU1RORVRfQ09OVFJBQ1RfQUREUkVTUyxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IEFWQUxBTkNIRV9DT05UUkFDVF9BRERSRVNTLFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFUyA9IHtcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBXRVRIX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBXRVRIX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5CU0NdOiBXQk5CX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5QT0xZR09OXTogV01BVElDX0NPTlRSQUNUX0FERFJFU1MsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBXRVRIX0dPRVJMSV9DT05UUkFDVF9BRERSRVNTLFxyXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogV0FWQVhfQ09OVFJBQ1RfQUREUkVTUyxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBBTExPV0VEX0NPTlRSQUNUX0FERFJFU1NFUyA9IHtcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBbXHJcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5NQUlOTkVUXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuTUFJTk5FVF0sXHJcbiAgXSxcclxuICBbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF06IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF0sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF0sXHJcbiAgXSxcclxuICBbQ0hBSU5fSURTLkdPRVJMSV06IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLkdPRVJMSV0sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkdPRVJMSV0sXHJcbiAgXSxcclxuICBbQ0hBSU5fSURTLkJTQ106IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLkJTQ10sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkJTQ10sXHJcbiAgXSxcclxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBbXHJcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5QT0xZR09OXSxcclxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuUE9MWUdPTl0sXHJcbiAgXSxcclxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IFtcclxuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLkFWQUxBTkNIRV0sXHJcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLkFWQUxBTkNIRV0sXHJcbiAgXSxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQID0ge1xyXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IEVUSF9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBURVNUX0VUSF9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbiAgW0NIQUlOX0lEUy5CU0NdOiBCTkJfU1dBUFNfVE9LRU5fT0JKRUNULFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IE1BVElDX1NXQVBTX1RPS0VOX09CSkVDVCxcclxuICBbQ0hBSU5fSURTLkdPRVJMSV06IEdPRVJMSV9TV0FQU19UT0tFTl9PQkpFQ1QsXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFYX1NXQVBTX1RPS0VOX09CSkVDVCxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMX01BUCA9IHtcclxuICBbQ0hBSU5fSURTLkJTQ106IEJTQ19ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcclxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxyXG4gIFtDSEFJTl9JRFMuUE9MWUdPTl06IFBPTFlHT05fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBHT0VSTElfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFMQU5DSEVfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgRVRIRVJFVU0gPSAnZXRoZXJldW0nO1xyXG5leHBvcnQgY29uc3QgUE9MWUdPTiA9ICdwb2x5Z29uJztcclxuZXhwb3J0IGNvbnN0IEJTQyA9ICdic2MnO1xyXG5leHBvcnQgY29uc3QgR09FUkxJID0gJ2dvZXJsaSc7XHJcbmV4cG9ydCBjb25zdCBBVkFMQU5DSEUgPSAnYXZhbGFuY2hlJztcclxuXHJcbmV4cG9ydCBjb25zdCBTV0FQU19DTElFTlRfSUQgPSAnZXh0ZW5zaW9uJztcclxuXHJcbmV4cG9ydCBjb25zdCBUT0tFTl9CVUNLRVRfUFJJT1JJVFkgPSB7XHJcbiAgT1dORUQ6ICdvd25lZCcsXHJcbiAgVE9QOiAndG9wJyxcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBTTElQUEFHRSA9IHtcclxuICBERUZBVUxUOiAyLFxyXG4gIEhJR0g6IDMsXHJcbn07XHJcbiIsImV4cG9ydCBjb25zdCBNSUxMSVNFQ09ORCA9IDE7XHJcbmV4cG9ydCBjb25zdCBTRUNPTkQgPSBNSUxMSVNFQ09ORCAqIDEwMDA7XHJcbmV4cG9ydCBjb25zdCBNSU5VVEUgPSBTRUNPTkQgKiA2MDtcclxuZXhwb3J0IGNvbnN0IEhPVVIgPSBNSU5VVEUgKiA2MDtcclxuZXhwb3J0IGNvbnN0IERBWSA9IEhPVVIgKiAyNDtcclxuIiwiaW1wb3J0IGNvbnRyYWN0TWFwIGZyb20gJ0BtZXRhbWFzay9jb250cmFjdC1tZXRhZGF0YSc7XHJcblxyXG4vKipcclxuICogQSBub3JtYWxpemVkIGxpc3Qgb2YgYWRkcmVzc2VzIGV4cG9ydGVkIGFzIHBhcnQgb2YgdGhlIGNvbnRyYWN0TWFwIGluXHJcbiAqIGBAbWV0YW1hc2svY29udHJhY3QtbWV0YWRhdGFgLiBVc2VkIHByaW1hcmlseSB0byB2YWxpZGF0ZSBpZiBtYW51YWxseSBlbnRlcmVkXHJcbiAqIGNvbnRyYWN0IGFkZHJlc3NlcyBkbyBub3QgbWF0Y2ggb25lIG9mIG91ciBsaXN0ZWQgdG9rZW5zXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgTElTVEVEX0NPTlRSQUNUX0FERFJFU1NFUyA9IE9iamVjdC5rZXlzKGNvbnRyYWN0TWFwKS5tYXAoXHJcbiAgKGFkZHJlc3MpID0+IGFkZHJlc3MudG9Mb3dlckNhc2UoKSxcclxuKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUb2tlbkRldGFpbHNcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VsZWN0ZWQgJ1RPS0VOJyBvclxyXG4gKiAgJ0NPTExFQ1RJQkxFJyBjb250cmFjdC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtzeW1ib2xdIC0gVGhlIHN5bWJvbCBvZiB0aGUgdG9rZW4uXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVjaW1hbHNdIC0gVGhlIG51bWJlciBvZiBkZWNpbWFscyBvZiB0aGUgc2VsZWN0ZWRcclxuICogICdFUkMyMCcgYXNzZXQuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdG9rZW5JZF0gLSBUaGUgaWQgb2YgdGhlIHNlbGVjdGVkICdDT0xMRUNUSUJMRScgYXNzZXQuXHJcbiAqIEBwcm9wZXJ0eSB7VG9rZW5TdGFuZGFyZFN0cmluZ3N9IFtzdGFuZGFyZF0gLSBUaGUgc3RhbmRhcmQgb2YgdGhlIHNlbGVjdGVkXHJcbiAqICBhc3NldC5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBbaXNFUkM3MjFdIC0gVHJ1ZSB3aGVuIHRoZSBhc3NldCBpcyBhIEVSQzcyMSB0b2tlbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBTVEFUSUNfTUFJTk5FVF9UT0tFTl9MSVNUID0gT2JqZWN0LmtleXMoY29udHJhY3RNYXApLnJlZHVjZShcclxuICAoYWNjLCBiYXNlKSA9PiB7XHJcbiAgICBjb25zdCB7IGxvZ28sIC4uLnRva2VuTWV0YWRhdGEgfSA9IGNvbnRyYWN0TWFwW2Jhc2VdO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgLi4uYWNjLFxyXG4gICAgICBbYmFzZS50b0xvd2VyQ2FzZSgpXToge1xyXG4gICAgICAgIC4uLnRva2VuTWV0YWRhdGEsXHJcbiAgICAgICAgYWRkcmVzczogYmFzZS50b0xvd2VyQ2FzZSgpLFxyXG4gICAgICAgIGljb25Vcmw6IGBpbWFnZXMvY29udHJhY3QvJHtsb2dvfWAsXHJcbiAgICAgICAgYWdncmVnYXRvcnM6IFtdLFxyXG4gICAgICB9LFxyXG4gICAgfTtcclxuICB9LFxyXG4gIHt9LFxyXG4pO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRPS0VOX0FQSV9NRVRBU1dBUF9DT0RFRklfVVJMID1cclxuICAnaHR0cHM6Ly90b2tlbi1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsvdG9rZW5zLyc7XHJcbiIsImltcG9ydCB7IE1FU1NBR0VfVFlQRSB9IGZyb20gJy4vYXBwJztcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2FjdGlvbiBUeXBlIGlzIGEgTWV0YU1hc2sgY29uc3RydWN0IHVzZWQgaW50ZXJuYWxseVxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvblR5cGVzXHJcbiAqIEBwcm9wZXJ0eSB7J3RyYW5zZmVyJ30gVE9LRU5fTUVUSE9EX1RSQU5TRkVSIC0gQSB0b2tlbiB0cmFuc2FjdGlvbiB3aGVyZSB0aGUgdXNlclxyXG4gKiAgaXMgc2VuZGluZyB0b2tlbnMgdGhhdCB0aGV5IG93biB0byBhbm90aGVyIGFkZHJlc3NcclxuICogQHByb3BlcnR5IHsndHJhbnNmZXJmcm9tJ30gVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST00gLSBBIHRva2VuIHRyYW5zYWN0aW9uXHJcbiAqICB0cmFuc2ZlcnJpbmcgdG9rZW5zIGZyb20gYW4gYWNjb3VudCB0aGF0IHRoZSBzZW5kZXIgaGFzIGFuIGFsbG93YW5jZSBvZi5cclxuICogIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGFsbG93YW5jZXMsIHNlZSB0aGUgYXBwcm92ZSB0eXBlLlxyXG4gKiBAcHJvcGVydHkgeydzYWZldHJhbnNmZXJmcm9tJ30gVE9LRU5fTUVUSE9EX1NBRkVfVFJBTlNGRVJfRlJPTSAtIEEgdG9rZW4gdHJhbnNhY3Rpb25cclxuICogIHRyYW5zZmVycmluZyB0b2tlbnMgZnJvbSBhbiBhY2NvdW50IHRoYXQgdGhlIHNlbmRlciBoYXMgYW4gYWxsb3dhbmNlIG9mLlxyXG4gKiAgVGhlIG1ldGhvZCBpcyBwcmVmaXhlZCB3aXRoIHNhZmUgYmVjYXVzZSB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgdGhlIGNvbnRyYWN0IGNoZWNrc1xyXG4gKiAgdG8gZW5zdXJlIHRoYXQgdGhlIHJlY2VpdmVyIGlzIGFuIGFkZHJlc3MgY2FwYWJsZSBvZiBoYW5kbGluZyB3aXRoIHRoZSB0b2tlbiBiZWluZyBzZW50LlxyXG4gKiBAcHJvcGVydHkgeydhcHByb3ZlJ30gVE9LRU5fTUVUSE9EX0FQUFJPVkUgLSBBIHRva2VuIHRyYW5zYWN0aW9uIHJlcXVlc3RpbmcgYW5cclxuICogIGFsbG93YW5jZSBvZiB0aGUgdG9rZW4gdG8gc3BlbmQgb24gYmVoYWxmIG9mIHRoZSB1c2VyXHJcbiAqIEBwcm9wZXJ0eSB7J3NldGFwcHJvdmFsZm9yYWxsJ30gVE9LRU5fTUVUSE9EX1NFVF9BUFBST1ZBTF9GT1JfQUxMIC0gQSB0b2tlbiB0cmFuc2FjdGlvbiByZXF1ZXN0aW5nIGFuXHJcbiAqICBhbGxvd2FuY2Ugb2YgYWxsIG9mIGEgdXNlcidzIHRva2VuIHRvIHNwZW5kIG9uIGJlaGFsZiBvZiB0aGUgdXNlclxyXG4gKiBAcHJvcGVydHkgeydpbmNvbWluZyd9IElOQ09NSU5HIC0gQW4gaW5jb21pbmcgKGRlcG9zaXQpIHRyYW5zYWN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7J3NpbXBsZVNlbmQnfSBTSU1QTEVfU0VORCAtIEEgdHJhbnNhY3Rpb24gc2VuZGluZyBhIG5ldHdvcmsncyBuYXRpdmUgYXNzZXQgdG8gYSByZWNpcGllbnRcclxuICogQHByb3BlcnR5IHsnY29udHJhY3RJbnRlcmFjdGlvbid9IENPTlRSQUNUX0lOVEVSQUNUSU9OIC0gQSB0cmFuc2FjdGlvbiB0aGF0IGlzXHJcbiAqICBpbnRlcmFjdGluZyB3aXRoIGEgc21hcnQgY29udHJhY3QncyBtZXRob2RzIHRoYXQgd2UgaGF2ZSBub3QgdHJlYXRlZCBhcyBhIHNwZWNpYWxcclxuICogIGNhc2UsIHN1Y2ggYXMgYXBwcm92ZSwgdHJhbnNmZXIsIGFuZCB0cmFuc2ZlcmZyb21cclxuICogQHByb3BlcnR5IHsnY29udHJhY3REZXBsb3ltZW50J30gREVQTE9ZX0NPTlRSQUNUIC0gQSB0cmFuc2FjdGlvbiB0aGF0IGRlcGxveWVkXHJcbiAqICBhIHNtYXJ0IGNvbnRyYWN0XHJcbiAqIEBwcm9wZXJ0eSB7J3N3YXAnfSBTV0FQIC0gQSB0cmFuc2FjdGlvbiBzd2FwcGluZyBvbmUgdG9rZW4gZm9yIGFub3RoZXIgdGhyb3VnaFxyXG4gKiAgTWV0YU1hc2sgU3dhcHNcclxuICogQHByb3BlcnR5IHsnc3dhcEFwcHJvdmFsJ30gU1dBUF9BUFBST1ZBTCAtIFNpbWlsYXIgdG8gdGhlIGFwcHJvdmUgdHlwZSwgYSBzd2FwXHJcbiAqICBhcHByb3ZhbCBpcyBhIHNwZWNpYWwgY2FzZSBvZiBFUkMyMCBhcHByb3ZlIG1ldGhvZCB0aGF0IHJlcXVlc3RzIGFuIGFsbG93YW5jZSBvZlxyXG4gKiAgdGhlIHRva2VuIHRvIHNwZW5kIG9uIGJlaGFsZiBvZiB0aGUgdXNlciBmb3IgdGhlIE1ldGFNYXNrIFN3YXBzIGNvbnRyYWN0LiBUaGUgZmlyc3RcclxuICogIHN3YXAgZm9yIGFueSB0b2tlbiB3aWxsIGhhdmUgYW4gYWNjb21wYW55aW5nIHN3YXBBcHByb3ZhbCB0cmFuc2FjdGlvbi5cclxuICogQHByb3BlcnR5IHsnY2FuY2VsJ30gQ0FOQ0VMIC0gQSB0cmFuc2FjdGlvbiBzdWJtaXR0ZWQgd2l0aCB0aGUgc2FtZSBub25jZSBhcyBhXHJcbiAqICBwcmV2aW91cyB0cmFuc2FjdGlvbiwgYSBoaWdoZXIgZ2FzIHByaWNlIGFuZCBhIHplcm9lZCBvdXQgc2VuZCBhbW91bnQuIFVzZWZ1bFxyXG4gKiAgZm9yIHVzZXJzIHdobyBhY2NpZGVudGFsbHkgc2VuZCB0byBlcnJvbmVvdXMgYWRkcmVzc2VzIG9yIGlmIHRoZXkgc2VuZCB0b28gbXVjaC5cclxuICogQHByb3BlcnR5IHsncmV0cnknfSBSRVRSWSAtIFdoZW4gYSB0cmFuc2FjdGlvbiBpcyBmYWlsZWQgaXQgY2FuIGJlIHJldHJpZWQgYnlcclxuICogIHJlc3VibWl0dGluZyB0aGUgc2FtZSB0cmFuc2FjdGlvbiB3aXRoIGEgaGlnaGVyIGdhcyBmZWUuIFRoaXMgdHlwZSBpcyBhbHNvIHVzZWRcclxuICogIHRvIHNwZWVkIHVwIHBlbmRpbmcgdHJhbnNhY3Rpb25zLiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBjcmVhdGluZyBhIG5ldyB0eCB3aXRoXHJcbiAqICB0aGUgc2FtZSBub25jZSBhbmQgaGlnaGVyIGdhcyBmZWVzLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUaGlzIHR5cGUgd2lsbCB3b3JrIGFueXdoZXJlIHlvdSBleHBlY3QgYSBzdHJpbmcgdGhhdCBjYW4gYmUgb25lIG9mIHRoZVxyXG4gKiBhYm92ZSB0cmFuc2FjdGlvbiB0eXBlcy5cclxuICpcclxuICogQHR5cGVkZWYge1RyYW5zYWN0aW9uVHlwZXNba2V5b2YgVHJhbnNhY3Rpb25UeXBlc119IFRyYW5zYWN0aW9uVHlwZVN0cmluZ1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7VHJhbnNhY3Rpb25UeXBlc31cclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9UWVBFUyA9IHtcclxuICBDQU5DRUw6ICdjYW5jZWwnLFxyXG4gIENPTlRSQUNUX0lOVEVSQUNUSU9OOiAnY29udHJhY3RJbnRlcmFjdGlvbicsXHJcbiAgREVQTE9ZX0NPTlRSQUNUOiAnY29udHJhY3REZXBsb3ltZW50JyxcclxuICBFVEhfREVDUllQVDogTUVTU0FHRV9UWVBFLkVUSF9ERUNSWVBULFxyXG4gIEVUSF9HRVRfRU5DUllQVElPTl9QVUJMSUNfS0VZOiBNRVNTQUdFX1RZUEUuRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVksXHJcbiAgSU5DT01JTkc6ICdpbmNvbWluZycsXHJcbiAgUEVSU09OQUxfU0lHTjogTUVTU0FHRV9UWVBFLlBFUlNPTkFMX1NJR04sXHJcbiAgUkVUUlk6ICdyZXRyeScsXHJcbiAgU0lHTjogTUVTU0FHRV9UWVBFLkVUSF9TSUdOLFxyXG4gIFNJR05fVFlQRURfREFUQTogTUVTU0FHRV9UWVBFLkVUSF9TSUdOX1RZUEVEX0RBVEEsXHJcbiAgU0lNUExFX1NFTkQ6ICdzaW1wbGVTZW5kJyxcclxuICBTTUFSVDogJ3NtYXJ0JyxcclxuICBTV0FQOiAnc3dhcCcsXHJcbiAgU1dBUF9BUFBST1ZBTDogJ3N3YXBBcHByb3ZhbCcsXHJcbiAgVE9LRU5fTUVUSE9EX0FQUFJPVkU6ICdhcHByb3ZlJyxcclxuICBUT0tFTl9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NOiAnc2FmZXRyYW5zZmVyZnJvbScsXHJcbiAgVE9LRU5fTUVUSE9EX1RSQU5TRkVSOiAndHJhbnNmZXInLFxyXG4gIFRPS0VOX01FVEhPRF9UUkFOU0ZFUl9GUk9NOiAndHJhbnNmZXJmcm9tJyxcclxuICBUT0tFTl9NRVRIT0RfU0VUX0FQUFJPVkFMX0ZPUl9BTEw6ICdzZXRhcHByb3ZhbGZvcmFsbCcsXHJcbn07XHJcblxyXG4vKipcclxuICogSW4gRUlQLTI3MTggdHlwZWQgdHJhbnNhY3Rpb24gZW52ZWxvcGVzIHdlcmUgc3BlY2lmaWVkLCB3aXRoIHRoZSB2ZXJ5IGZpcnN0XHJcbiAqIHR5cGVkIGVudmVsb3BlIGJlaW5nICdsZWdhY3knIGFuZCBkZXNjcmliaW5nIHRoZSBzaGFwZSBvZiB0aGUgYmFzZVxyXG4gKiB0cmFuc2FjdGlvbiBwYXJhbXMgdGhhdCB3ZXJlIGhpdGhlcnRvIHRoZSBvbmx5IHRyYW5zYWN0aW9uIHR5cGUgc2VudCBvblxyXG4gKiBFdGhlcmV1bS5cclxuICpcclxuICogQHR5cGVkZWYge29iamVjdH0gVHJhbnNhY3Rpb25FbnZlbG9wZVR5cGVzXHJcbiAqIEBwcm9wZXJ0eSB7JzB4MCd9IExFR0FDWSAtIEEgbGVnYWN5IHRyYW5zYWN0aW9uLCB0aGUgdmVyeSBmaXJzdCB0eXBlLlxyXG4gKiBAcHJvcGVydHkgeycweDEnfSBBQ0NFU1NfTElTVCAtIEVJUC0yOTMwIGRlZmluZWQgdGhlIGFjY2VzcyBsaXN0IHRyYW5zYWN0aW9uXHJcbiAqICB0eXBlIHRoYXQgYWxsb3dlZCBmb3Igc3BlY2lmeWluZyB0aGUgc3RhdGUgdGhhdCBhIHRyYW5zYWN0aW9uIHdvdWxkIGFjdFxyXG4gKiAgdXBvbiBpbiBhZHZhbmNlIGFuZCB0aGVvcmV0aWNhbGx5IHNhdmUgb24gZ2FzIGZlZXMuXHJcbiAqIEBwcm9wZXJ0eSB7JzB4Mid9IEZFRV9NQVJLRVQgLSBUaGUgdHlwZSBpbnRyb2R1Y2VkIGNvbWVzIGZyb20gRUlQLTE1NTksXHJcbiAqICBGZWUgTWFya2V0IGRlc2NyaWJlcyB0aGUgYWRkaXRpb24gb2YgYSBiYXNlRmVlIHRvIGJsb2NrcyB0aGF0IHdpbGwgYmVcclxuICogIGJ1cm5lZCBpbnN0ZWFkIG9mIGRpc3RyaWJ1dGVkIHRvIG1pbmVycy4gVHJhbnNhY3Rpb25zIG9mIHRoaXMgdHlwZSBoYXZlXHJcbiAqICBib3RoIGEgbWF4RmVlUGVyR2FzIChtYXhpbXVtIHRvdGFsIGFtb3VudCBpbiBnd2VpIHBlciBnYXMgdG8gc3BlbmQgb24gdGhlXHJcbiAqICB0cmFuc2FjdGlvbikgd2hpY2ggaXMgaW5jbHVzaXZlIG9mIHRoZSBtYXhQcmlvcml0eUZlZVBlckdhcyAobWF4aW11bSBhbW91bnRcclxuICogIG9mIGd3ZWkgcGVyIGdhcyBmcm9tIHRoZSB0cmFuc2FjdGlvbiBmZWUgdG8gZGlzdHJpYnV0ZSB0byBtaW5lcikuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtUcmFuc2FjdGlvbkVudmVsb3BlVHlwZXN9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMgPSB7XHJcbiAgTEVHQUNZOiAnMHgwJyxcclxuICBBQ0NFU1NfTElTVDogJzB4MScsXHJcbiAgRkVFX01BUktFVDogJzB4MicsXHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNhY3Rpb24gU3RhdHVzIGlzIGEgbWl4IG9mIEV0aGVyZXVtIGFuZCBNZXRhTWFzayB0ZXJtaW5vbG9neSwgdXNlZCBpbnRlcm5hbGx5XHJcbiAqIGZvciB0cmFuc2FjdGlvbiBwcm9jZXNzaW5nLlxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvblN0YXR1c2VzXHJcbiAqIEBwcm9wZXJ0eSB7J3VuYXBwcm92ZWQnfSBVTkFQUFJPVkVEIC0gQSBuZXcgdHJhbnNhY3Rpb24gdGhhdCB0aGUgdXNlciBoYXMgbm90XHJcbiAqICBhcHByb3ZlZCBvciByZWplY3RlZFxyXG4gKiBAcHJvcGVydHkgeydhcHByb3ZlZCd9IEFQUFJPVkVEIC0gVGhlIHVzZXIgaGFzIGFwcHJvdmVkIHRoZSB0cmFuc2FjdGlvbiBpbiB0aGVcclxuICogIE1ldGFNYXNrIFVJXHJcbiAqIEBwcm9wZXJ0eSB7J3JlamVjdGVkJ30gUkVKRUNURUQgLSBUaGUgdXNlciBoYXMgcmVqZWN0ZWQgdGhlIHRyYW5zYWN0aW9uIGluIHRoZVxyXG4gKiAgTWV0YU1hc2sgVUlcclxuICogQHByb3BlcnR5IHsnc2lnbmVkJ30gU0lHTkVEIC0gVGhlIHRyYW5zYWN0aW9uIGhhcyBiZWVuIHNpZ25lZFxyXG4gKiBAcHJvcGVydHkgeydzdWJtaXR0ZWQnfSBTVUJNSVRURUQgLSBUaGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc3VibWl0dGVkIHRvIG5ldHdvcmtcclxuICogQHByb3BlcnR5IHsnZmFpbGVkJ30gRkFJTEVEIC0gVGhlIHRyYW5zYWN0aW9uIGhhcyBmYWlsZWQgZm9yIHNvbWUgcmVhc29uXHJcbiAqIEBwcm9wZXJ0eSB7J2Ryb3BwZWQnfSBEUk9QUEVEIC0gVGhlIHRyYW5zYWN0aW9uIHdhcyBkcm9wcGVkIGR1ZSB0byBhIHR4IHdpdGggc2FtZVxyXG4gKiAgbm9uY2UgYmVpbmcgYWNjZXB0ZWRcclxuICogQHByb3BlcnR5IHsnY29uZmlybWVkJ30gQ09ORklSTUVEIC0gVGhlIHRyYW5zYWN0aW9uIHdhcyBjb25maXJtZWQgYnkgdGhlIG5ldHdvcmtcclxuICovXHJcblxyXG4vKipcclxuICogVGhpcyB0eXBlIHdpbGwgd29yayBhbnl3aGVyZSB5b3UgZXhwZWN0IGEgc3RyaW5nIHRoYXQgY2FuIGJlIG9uZSBvZiB0aGVcclxuICogYWJvdmUgdHJhbnNhY3Rpb24gc3RhdHVzZXMuXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtUcmFuc2FjdGlvblN0YXR1c2VzW2tleW9mIFRyYW5zYWN0aW9uU3RhdHVzZXNdfSBUcmFuc2FjdGlvblN0YXR1c1N0cmluZ1xyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7VHJhbnNhY3Rpb25TdGF0dXNlc31cclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9TVEFUVVNFUyA9IHtcclxuICBVTkFQUFJPVkVEOiAndW5hcHByb3ZlZCcsXHJcbiAgQVBQUk9WRUQ6ICdhcHByb3ZlZCcsXHJcbiAgUkVKRUNURUQ6ICdyZWplY3RlZCcsXHJcbiAgU0lHTkVEOiAnc2lnbmVkJyxcclxuICBTVUJNSVRURUQ6ICdzdWJtaXR0ZWQnLFxyXG4gIEZBSUxFRDogJ2ZhaWxlZCcsXHJcbiAgRFJPUFBFRDogJ2Ryb3BwZWQnLFxyXG4gIENPTkZJUk1FRDogJ2NvbmZpcm1lZCcsXHJcbiAgUEVORElORzogJ3BlbmRpbmcnLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFdpdGggdGhpcyBsaXN0IHdlIGNhbiBkZXRlY3QgaWYgYSB0cmFuc2FjdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzcy5cclxuICovXHJcbmV4cG9ydCBjb25zdCBJTl9QUk9HUkVTU19UUkFOU0FDVElPTl9TVEFUVVNFUyA9IFtcclxuICBUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVELFxyXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkFQUFJPVkVELFxyXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlNJR05FRCxcclxuICBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQsXHJcbiAgVFJBTlNBQ1RJT05fU1RBVFVTRVMuUEVORElORyxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBUcmFuc2FjdGlvbiBHcm91cCBTdGF0dXMgaXMgYSBNZXRhTWFzayBjb25zdHJ1Y3QgdG8gdHJhY2sgdGhlIHN0YXR1cyBvZiBncm91cHNcclxuICogb2YgdHJhbnNhY3Rpb25zLlxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvbkdyb3VwU3RhdHVzZXNcclxuICogQHByb3BlcnR5IHsnY2FuY2VsbGVkJ30gQ0FOQ0VMTEVEIC0gQSBjYW5jZWwgdHlwZSB0cmFuc2FjdGlvbiBpbiB0aGUgZ3JvdXAgd2FzXHJcbiAqICBjb25maXJtZWRcclxuICogQHByb3BlcnR5IHsncGVuZGluZyd9IFBFTkRJTkcgLSBUaGUgcHJpbWFyeVRyYW5zYWN0aW9uIG9mIHRoZSBncm91cCBoYXMgYSBzdGF0dXNcclxuICogIHRoYXQgaXMgb25lIG9mIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkFQUFJPVkVELCBUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVEXHJcbiAqICBvciBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURURcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGUge1RyYW5zYWN0aW9uR3JvdXBTdGF0dXNlc31cclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9HUk9VUF9TVEFUVVNFUyA9IHtcclxuICBDQU5DRUxMRUQ6ICdjYW5jZWxsZWQnLFxyXG4gIFBFTkRJTkc6ICdwZW5kaW5nJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTdGF0dXNlcyB0aGF0IGFyZSBzcGVjaWZpYyB0byBTbWFydCBUcmFuc2FjdGlvbnMuXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1xyXG4gKiBAcHJvcGVydHkgeydjYW5jZWxsZWQnfSBDQU5DRUxMRUQgLSBJdCBjYW4gYmUgY2FuY2VsbGVkIGZvciB2YXJpb3VzIHJlYXNvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7J3BlbmRpbmcnfSBQRU5ESU5HIC0gU21hcnQgdHJhbnNhY3Rpb24gaXMgYmVpbmcgcHJvY2Vzc2VkLlxyXG4gKiBAcHJvcGVydHkgeydzdWNjZXNzJ30gU1VDQ0VTUyAtIFNtYXJ0IHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsbHkgbWluZWQuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtTbWFydFRyYW5zYWN0aW9uU3RhdHVzZXN9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgU01BUlRfVFJBTlNBQ1RJT05fU1RBVFVTRVMgPSB7XHJcbiAgQ0FOQ0VMTEVEOiAnY2FuY2VsbGVkJyxcclxuICBQRU5ESU5HOiAncGVuZGluZycsXHJcbiAgU1VDQ0VTUzogJ3N1Y2Nlc3MnLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFR5cGVzIHRoYXQgYXJlIHNwZWNpZmljIHRvIHRoZSB0cmFuc2FjdGlvbiBhcHByb3ZhbCBhbW91bnQuXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYW5zYWN0aW9uQXBwcm92YWxBbW91bnRUeXBlXHJcbiAqIEBwcm9wZXJ0eSB7J2N1c3RvbSd9IENVU1RPTSAtIFRoZSB1c2VyIGhhcyBlZGl0ZWQgdGhlIHRva2VuIGFtb3VudC5cclxuICogQHByb3BlcnR5IHsncmV2b2tlJ30gUkVWT0tFIC0gVGhlIHNlbGVjdGVkIGFtb3VudCAoZWl0aGVyIENVU1RPTSBvciBEQVBQX1BST1BPU0VEKSBpcyAwLlxyXG4gKiBAcHJvcGVydHkgeydkYXBwX3Byb3Bvc2VkJ30gREFQUF9QUk9QT1NFRCAtIFRoZSBkYXBwIHByb3Bvc2VkIHRva2VuIGFtb3VudC5cclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGUge1RyYW5zYWN0aW9uQXBwcm92YWxBbW91bnRUeXBlfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0FQUFJPVkFMX0FNT1VOVF9UWVBFID0ge1xyXG4gIENVU1RPTTogJ2N1c3RvbScsXHJcbiAgUkVWT0tFOiAncmV2b2tlJyxcclxuICBEQVBQX1BST1BPU0VEOiAnZGFwcF9wcm9wb3NlZCcsXHJcbn07XHJcblxyXG4vKipcclxuICogVHJhbnNhY3Rpb24gR3JvdXAgQ2F0ZWdvcnkgaXMgYSBNZXRhTWFzayBjb25zdHJ1Y3QgdG8gY2F0ZWdvcml6ZSB0aGUgaW50ZW50XHJcbiAqIG9mIGEgZ3JvdXAgb2YgdHJhbnNhY3Rpb25zIGZvciBwdXJwb3NlcyBvZiBkaXNwbGF5aW5nIGluIHRoZSBVSVxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvbkdyb3VwQ2F0ZWdvcmllc1xyXG4gKiBAcHJvcGVydHkgeydzZW5kJ30gU0VORCAtIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBldGhlciBiZWluZyBzZW50IGZyb21cclxuICogIHRoZSB1c2VyLlxyXG4gKiBAcHJvcGVydHkgeydyZWNlaXZlJ30gUkVDRUlWRSAtIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBhIGRlcG9zaXQvaW5jb21pbmdcclxuICogIHRyYW5zYWN0aW9uLiBUaGlzIGNhdGVnb3J5IG1hcHMgMToxIHdpdGggVFJBTlNBQ1RJT05fQ0FURUdPUklFUy5JTkNPTUlORy5cclxuICogQHByb3BlcnR5IHsnaW50ZXJhY3Rpb24nfSBJTlRFUkFDVElPTiAtIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZ1xyXG4gKiAgYW4gaW50ZXJhY3Rpb24gd2l0aCBhIHNtYXJ0IGNvbnRyYWN0J3MgbWV0aG9kcy5cclxuICogQHByb3BlcnR5IHsnYXBwcm92YWwnfSBBUFBST1ZBTCAtIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBhIHJlcXVlc3QgZm9yIGFuXHJcbiAqICBhbGxvd2FuY2Ugb2YgYSB0b2tlbiB0byBzcGVuZCBvbiB0aGUgdXNlcidzIGJlaGFsZi5cclxuICogQHByb3BlcnR5IHsnc2lnbmF0dXJlLXJlcXVlc3QnfSBTSUdOQVRVUkVfUkVRVUVTVCAtIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZ1xyXG4gKiAgYSBzaWduYXR1cmUgcmVxdWVzdCBUaGlzIGN1cnJlbnRseSBvbmx5IHNob3dzIHVwIGluIHRoZSBVSSB3aGVuIGl0cyBwZW5kaW5nIHVzZXJcclxuICogIGFwcHJvdmFsIGluIHRoZSBVSS4gT25jZSB0aGUgdXNlciBhcHByb3ZlcyBvciByZWplY3RzIGl0IHdpbGwgbm8gbG9uZ2VyIHNob3cgaW5cclxuICogIGFjdGl2aXR5LlxyXG4gKiBAcHJvcGVydHkgeydzd2FwJ30gU1dBUCAtIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZyBhIHRva2VuIHN3YXAgdGhyb3VnaFxyXG4gKiAgTWV0YU1hc2sgU3dhcHMuIFRoaXMgdHJhbnNhY3Rpb24gZ3JvdXAncyBwcmltYXJ5IGN1cnJlbmN5IGNoYW5nZXMgZGVwZW5kaW5nXHJcbiAqICBvbiBjb250ZXh0LiBJZiB0aGUgdXNlciBpcyB2aWV3aW5nIGFuIGFzc2V0IHBhZ2UgZm9yIGEgdG9rZW4gcmVjZWl2ZWQgZnJvbSBhIHN3YXAsXHJcbiAqICB0aGUgcHJpbWFyeSBjdXJyZW5jeSB3aWxsIGJlIHRoZSByZWNlaXZlZCB0b2tlbi4gT3RoZXJ3aXNlIHRoZSB0b2tlbiBleGNoYW5nZWRcclxuICogIHdpbGwgYmUgc2hvd24uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtUcmFuc2FjdGlvbkdyb3VwQ2F0ZWdvcmllc31cclxuICovXHJcbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9HUk9VUF9DQVRFR09SSUVTID0ge1xyXG4gIEFQUFJPVkFMOiAnYXBwcm92YWwnLFxyXG4gIElOVEVSQUNUSU9OOiAnaW50ZXJhY3Rpb24nLFxyXG4gIFJFQ0VJVkU6ICdyZWNlaXZlJyxcclxuICBTRU5EOiAnc2VuZCcsXHJcbiAgU0lHTkFUVVJFX1JFUVVFU1Q6ICdzaWduYXR1cmUtcmVxdWVzdCcsXHJcbiAgU1dBUDogJ3N3YXAnLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR4UGFyYW1zXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmcm9tIC0gVGhlIGFkZHJlc3MgdGhlIHRyYW5zYWN0aW9uIGlzIHNlbnQgZnJvbVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG8gLSBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gaXMgc2VudCB0b1xyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWUgLSBUaGUgYW1vdW50IG9mIHdlaSwgaW4gaGV4YWRlY2ltYWwsIHRvIHNlbmRcclxuICogQHByb3BlcnR5IHtudW1iZXJ9IG5vbmNlIC0gVGhlIHRyYW5zYWN0aW9uIGNvdW50IGZvciB0aGUgY3VycmVudCBhY2NvdW50L25ldHdvcmtcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdhc1ByaWNlIC0gVGhlIGFtb3VudCBvZiBnd2VpLCBpbiBoZXhhZGVjaW1hbCwgcGVyIHVuaXQgb2YgZ2FzXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnYXMgLSBUaGUgbWF4IGFtb3VudCBvZiBnd2VpLCBpbiBoZXhhZGVjaW1hbCwgdGhlIHVzZXIgaXMgd2lsbGluZyB0byBwYXlcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtkYXRhXSAtIEhleGFkZWNpbWFsIGVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGluZyBjYWxscyB0byB0aGUgRVZNJ3MgQUJJXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR4RXJyb3JcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBmcm9tIHRoZSBlbmNvdW50ZXJlZCBlcnJvci5cclxuICogQHByb3BlcnR5IHthbnl9IHJwYyAtIFRoZSBcInZhbHVlXCIgb2YgdGhlIGVycm9yLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N0YWNrXSAtIHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoZSBlcnJvciwgaWYgYXZhaWxhYmxlLlxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIGEgdHJhbnNhY3Rpb24sIGluIHdoYXRldmVyIHN0YXRlIGl0IGlzIGluLlxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvbk1ldGFcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtibG9ja051bWJlcl0gLSBUaGUgYmxvY2sgbnVtYmVyIHRoaXMgdHJhbnNhY3Rpb24gd2FzXHJcbiAqICBpbmNsdWRlZCBpbi4gQ3VycmVudGx5IG9ubHkgcHJlc2VudCBvbiBpbmNvbWluZyB0cmFuc2FjdGlvbnMhXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCAtIEFuIGludGVybmFsbHkgdW5pcXVlIHR4IGlkZW50aWZpZXIuXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIC0gVGltZSB0aGUgdHJhbnNhY3Rpb24gd2FzIGZpcnN0IHN1Z2dlc3RlZCwgaW4gdW5peFxyXG4gKiAgZXBvY2ggdGltZSAobXMpLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udHJhY3RNZXRob2ROYW1lIC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbmFtZSBvZlxyXG4gKiB0cmFuc2FjdGlvbiBjb250cmFjdCBtZXRob2QuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXN0b21Ub2tlbkFtb3VudCAtIFRoZSBjdXN0b20gdG9rZW4gYW1vdW50IGlzIHRoZSBhbW91bnRcclxuICogc2V0IGJ5IHRoZSB1c2VyXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXBwUHJvcG9zZWRUb2tlbkFtb3VudCAtIFRoZSBkYXBwIHByb3Bvc2VkIHRva2VuIGFtb3VudFxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY3VycmVudFRva2VuQmFsYW5jZSAtIFRoZSBiYWxhbmNlIG9mIHRoZSB0b2tlbiB0aGF0IGlzXHJcbiAqIGJlaW5nIHNlbmRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbmFsQXBwcm92YWxBbW91bnQgLSBUaGUgb3JpZ2luYWwgYXBwcm92YWwgYW1vdW50XHJcbiAqIGlzIHRoZSBvcmlnaW5hbGx5IGRhcHAgcHJvcG9zZWQgdG9rZW4gYW1vdW50XHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaW5hbEFwcHJvdmFsQW1vdW50IC0gVGhlIGNob3NlbiBhbW91bnQgd2hpY2ggd2lsbCBiZSB0aGVcclxuICogc2FtZSBhcyB0aGUgb3JpZ2luYWxseSBwcm9wb3NlZCB0b2tlbiBhbW91bnQgaWYgdGhlIHVzZXIgZG9lcyBub3QgZWRpdCB0aGVcclxuICogYW1vdW50IG9yIHdpbGwgYmUgYSBjdXN0b20gdG9rZW4gYW1vdW50IHNldCBieSB0aGUgdXNlclxyXG4gKiBAcHJvcGVydHkge1RyYW5zYWN0aW9uVHlwZVN0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uIHRoaXMgdHhNZXRhXHJcbiAqICByZXByZXNlbnRzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3JpZ2luYWxUeXBlIC0gV2hlbiB3ZSBzcGVlZCB1cCBhIHRyYW5zYWN0aW9uLFxyXG4gKiAgd2Ugc2V0IHRoZSB0eXBlIGFzIFJldHJ5IGFuZCB3ZSBsb3NlIGluZm9ybWF0aW9uIGFib3V0IHR5cGUgb2YgdHJhbnNhY3Rpb25cclxuICogIHRoYXQgaXMgYmVpbmcgc2V0IHVwLCBzbyB3ZSB1c2Ugb3JpZ2luYWwgdHlwZSB0byB0cmFjayB0aGF0IGluZm9ybWF0aW9uLlxyXG4gKiBAcHJvcGVydHkge1RyYW5zYWN0aW9uU3RhdHVzU3RyaW5nfSBzdGF0dXMgLSBUaGUgY3VycmVudCBzdGF0dXMgb2YgdGhlXHJcbiAqICB0cmFuc2FjdGlvbi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1ldGFtYXNrTmV0d29ya0lkIC0gVGhlIHRyYW5zYWN0aW9uJ3MgbmV0d29yayBJRCwgdXNlZFxyXG4gKiAgZm9yIEVJUC0xNTUgY29tcGxpYW5jZS5cclxuICogQHByb3BlcnR5IHtib29sZWFufSBsb2FkaW5nRGVmYXVsdHMgLSBUT0RPOiBEb2N1bWVudFxyXG4gKiBAcHJvcGVydHkge1R4UGFyYW1zfSB0eFBhcmFtcyAtIFRoZSB0cmFuc2FjdGlvbiBwYXJhbXMgYXMgcGFzc2VkIHRvIHRoZVxyXG4gKiAgbmV0d29yayBwcm92aWRlci5cclxuICogQHByb3BlcnR5IHtvYmplY3RbXX0gaGlzdG9yeSAtIEEgaGlzdG9yeSBvZiBtdXRhdGlvbnMgdG8gdGhpc1xyXG4gKiAgVHJhbnNhY3Rpb25NZXRhIG9iamVjdC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbiAtIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgaW50ZXJmYWNlIHRoYXRcclxuICogIHN1Z2dlc3RlZCB0aGUgdHJhbnNhY3Rpb24uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcmlnaW5hbEdhc0VzdGltYXRlIC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBvcmlnaW5hbFxyXG4gKiBnYXMgZXN0aW1hdGlvbiBvbiB0aGUgdHJhbnNhY3Rpb24gbWV0YWRhdGEuXHJcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlckVkaXRlZEdhc0xpbWl0IC0gQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGVuIHRoZVxyXG4gKiB1c2VyIG1hbnVhbGx5IGVkaXRlZCB0aGUgZ2FzIGxpbWl0LlxyXG4gKiBAcHJvcGVydHkge29iamVjdH0gbm9uY2VEZXRhaWxzIC0gQSBtZXRhZGF0YSBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvblxyXG4gKiAgdXNlZCB0byBkZXJpdmUgdGhlIHN1Z2dlc3RlZCBub25jZSwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgbm9uY2UgaXNzdWVzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmF3VHggLSBBIGhleCBzdHJpbmcgb2YgdGhlIGZpbmFsIHNpZ25lZCB0cmFuc2FjdGlvbixcclxuICogIHJlYWR5IHRvIHN1Ym1pdCB0byB0aGUgbmV0d29yay5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2ggLSBBIGhleCBzdHJpbmcgb2YgdGhlIHRyYW5zYWN0aW9uIGhhc2gsIHVzZWQgdG9cclxuICogIGlkZW50aWZ5IHRoZSB0cmFuc2FjdGlvbiBvbiB0aGUgbmV0d29yay5cclxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtzdWJtaXR0ZWRUaW1lXSAtIFRoZSB0aW1lIHRoZSB0cmFuc2FjdGlvbiB3YXMgc3VibWl0dGVkIHRvXHJcbiAqICB0aGUgbmV0d29yaywgaW4gVW5peCBlcG9jaCB0aW1lIChtcykuXHJcbiAqIEBwcm9wZXJ0eSB7VHhFcnJvcn0gW2Vycl0gLSBUaGUgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHRoZSB0cmFuc2FjdGlvblxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBEZWZpbmVzIHRoZSBwb3NzaWJsZSB0eXBlc1xyXG4gKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvbk1ldGFNZXRyaWNzRXZlbnRzXHJcbiAqIEBwcm9wZXJ0eSB7J1RyYW5zYWN0aW9uIEFkZGVkJ30gQURERUQgLSBBbGwgdHJhbnNhY3Rpb25zLCBleGNlcHQgaW5jb21pbmdcclxuICogIG9uZXMsIGFyZSBhZGRlZCB0byB0aGUgY29udHJvbGxlciBzdGF0ZSBpbiBhbiB1bmFwcHJvdmVkIHN0YXR1cy4gV2hlbiB0aGlzXHJcbiAqICBoYXBwZW5zIHdlIGZpcmUgdGhlIFRyYW5zYWN0aW9uIEFkZGVkIGV2ZW50IHRvIHNob3cgdGhhdCB0aGUgdHJhbnNhY3Rpb25cclxuICogIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSB1c2VyJ3MgTWV0YU1hc2suXHJcbiAqIEBwcm9wZXJ0eSB7J1RyYW5zYWN0aW9uIEFwcHJvdmVkJ30gQVBQUk9WRUQgLSBXaGVuIGFuIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25cclxuICogIGlzIGluIHRoZSBjb250cm9sbGVyIHN0YXRlLCBNZXRhTWFzayB3aWxsIHJlbmRlciBhIGNvbmZpcm1hdGlvbiBzY3JlZW4gZm9yXHJcbiAqICB0aGF0IHRyYW5zYWN0aW9uLiBJZiB0aGUgdXNlciBhcHByb3ZlcyB0aGUgdHJhbnNhY3Rpb24gd2UgZmlyZSB0aGlzIGV2ZW50XHJcbiAqICB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2VyIGhhcyBhcHByb3ZlZCB0aGUgdHJhbnNhY3Rpb24gZm9yIHN1Ym1pc3Npb24gdG9cclxuICogIHRoZSBuZXR3b3JrLlxyXG4gKiBAcHJvcGVydHkgeydUcmFuc2FjdGlvbiBSZWplY3RlZCd9IFJFSkVDVEVEIC0gV2hlbiBhbiB1bmFwcHJvdmVkIHRyYW5zYWN0aW9uXHJcbiAqICBpcyBpbiB0aGUgY29udHJvbGxlciBzdGF0ZSwgTWV0YU1hc2sgd2lsbCByZW5kZXIgYSBjb25maXJtYXRpb24gc2NyZWVuIGZvclxyXG4gKiAgdGhhdCB0cmFuc2FjdGlvbi4gSWYgdGhlIHVzZXIgcmVqZWN0cyB0aGUgdHJhbnNhY3Rpb24gd2UgZmlyZSB0aGlzIGV2ZW50XHJcbiAqICB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2VyIGhhcyByZWplY3RlZCB0aGUgdHJhbnNhY3Rpb24uIEl0IHdpbGwgYmUgcmVtb3ZlZFxyXG4gKiAgZnJvbSBzdGF0ZSBhcyBhIHJlc3VsdC5cclxuICogQHByb3BlcnR5IHsnVHJhbnNhY3Rpb24gU3VibWl0dGVkJ30gU1VCTUlUVEVEIC0gQWZ0ZXIgYSB0cmFuc2FjdGlvbiBpc1xyXG4gKiAgYXBwcm92ZWQgYnkgdGhlIHVzZXIsIGl0IGlzIHRoZW4gc3VibWl0dGVkIHRvIHRoZSBuZXR3b3JrIGZvciBpbmNsdXNpb24gaW5cclxuICogIGEgYmxvY2suIFdoZW4gdGhpcyBoYXBwZW5zIHdlIGZpcmUgdGhlIFRyYW5zYWN0aW9uIFN1Ym1pdHRlZCBldmVudCB0b1xyXG4gKiAgaW5kaWNhdGUgdGhhdCBNZXRhTWFzayBpcyBzdWJtaXR0aW5nIGEgdHJhbnNhY3Rpb24gYXQgdGhlIHVzZXIncyByZXF1ZXN0LlxyXG4gKiBAcHJvcGVydHkgeydUcmFuc2FjdGlvbiBGaW5hbGl6ZWQnfSBGSU5BTElaRUQgLSBBbGwgdHJhbnNhY3Rpb25zIHRoYXQgYXJlXHJcbiAqICBzdWJtaXR0ZWQgd2lsbCBmaW5hbGl6ZWQgKGV2ZW50dWFsbHkpIGJ5IGVpdGhlciBiZWluZyBkcm9wcGVkLCBmYWlsaW5nXHJcbiAqICBvciBiZWluZyBjb25maXJtZWQuIFdoZW4gdGhpcyBoYXBwZW5zIHdlIHRyYWNrIHRoaXMgZXZlbnQsIGFsb25nIHdpdGggdGhlXHJcbiAqICBzdGF0dXMuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgdHlwZSB3aWxsIHdvcmsgYW55d2hlcmUgeW91IGV4cGVjdCBhIHN0cmluZyB0aGF0IGNhbiBiZSBvbmUgb2YgdGhlXHJcbiAqIGFib3ZlIHRyYW5zYWN0aW9uIGV2ZW50IHR5cGVzLlxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7VHJhbnNhY3Rpb25NZXRhTWV0cmljc0V2ZW50c1trZXlvZiBUcmFuc2FjdGlvbk1ldGFNZXRyaWNzRXZlbnRzXX0gVHJhbnNhY3Rpb25NZXRhTWV0cmljc0V2ZW50U3RyaW5nXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlIHtUcmFuc2FjdGlvbk1ldGFNZXRyaWNzRXZlbnRzfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0VWRU5UUyA9IHtcclxuICBBRERFRDogJ1RyYW5zYWN0aW9uIEFkZGVkJyxcclxuICBBUFBST1ZFRDogJ1RyYW5zYWN0aW9uIEFwcHJvdmVkJyxcclxuICBGSU5BTElaRUQ6ICdUcmFuc2FjdGlvbiBGaW5hbGl6ZWQnLFxyXG4gIFJFSkVDVEVEOiAnVHJhbnNhY3Rpb24gUmVqZWN0ZWQnLFxyXG4gIFNVQk1JVFRFRDogJ1RyYW5zYWN0aW9uIFN1Ym1pdHRlZCcsXHJcbn07XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gQXNzZXRUeXBlc1xyXG4gKiBAcHJvcGVydHkgeydOQVRJVkUnfSBOQVRJVkUgLSBUaGUgbmF0aXZlIGFzc2V0IGZvciB0aGUgY3VycmVudCBuZXR3b3JrLCBzdWNoXHJcbiAqICBhcyBFVEhcclxuICogQHByb3BlcnR5IHsnVE9LRU4nfSBUT0tFTiAtIEFuIEVSQzIwIHRva2VuLlxyXG4gKiBAcHJvcGVydHkgeydDT0xMRUNUSUJMRSd9IENPTExFQ1RJQkxFIC0gQW4gRVJDNzIxIG9yIEVSQzExNTUgdG9rZW4uXHJcbiAqIEBwcm9wZXJ0eSB7J1VOS05PV04nfSBVTktOT1dOIC0gQSB0cmFuc2FjdGlvbiBpbnRlcmFjdGluZyB3aXRoIGEgY29udHJhY3RcclxuICogIHRoYXQgaXNuJ3QgYSB0b2tlbiBtZXRob2QgaW50ZXJhY3Rpb24gd2lsbCBiZSBtYXJrZWQgYXMgZGVhbGluZyB3aXRoIGFuXHJcbiAqICB1bmtub3duIGFzc2V0IHR5cGUuXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgdHlwZSB3aWxsIHdvcmsgYW55d2hlcmUgeW91IGV4cGVjdCBhIHN0cmluZyB0aGF0IGNhbiBiZSBvbmUgb2YgdGhlXHJcbiAqIGFib3ZlIGFzc2V0IHR5cGVzXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtBc3NldFR5cGVzW2tleW9mIEFzc2V0VHlwZXNdfSBBc3NldFR5cGVzU3RyaW5nXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoZSB0eXBlcyBvZiBhc3NldHMgdGhhdCBhIHVzZXIgY2FuIHNlbmRcclxuICpcclxuICogQHR5cGUge0Fzc2V0VHlwZXN9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQVNTRVRfVFlQRVMgPSB7XHJcbiAgTkFUSVZFOiAnTkFUSVZFJyxcclxuICBUT0tFTjogJ1RPS0VOJyxcclxuICBDT0xMRUNUSUJMRTogJ0NPTExFQ1RJQkxFJyxcclxuICBVTktOT1dOOiAnVU5LTk9XTicsXHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgRVJDMjAgPSAnRVJDMjAnO1xyXG5leHBvcnQgY29uc3QgRVJDNzIxID0gJ0VSQzcyMSc7XHJcbmV4cG9ydCBjb25zdCBFUkMxMTU1ID0gJ0VSQzExNTUnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRva2VuU3RhbmRhcmRzXHJcbiAqIEBwcm9wZXJ0eSB7J0VSQzIwJ30gRVJDMjAgLSBBIHRva2VuIHRoYXQgY29uZm9ybXMgdG8gdGhlIEVSQzIwIHN0YW5kYXJkLlxyXG4gKiBAcHJvcGVydHkgeydFUkM3MjEnfSBFUkM3MjEgLSBBIHRva2VuIHRoYXQgY29uZm9ybXMgdG8gdGhlIEVSQzcyMSBzdGFuZGFyZC5cclxuICogQHByb3BlcnR5IHsnRVJDMTE1NSd9IEVSQzExNTUgLSBBIHRva2VuIHRoYXQgY29uZm9ybXMgdG8gdGhlIEVSQzExNTVcclxuICogIHN0YW5kYXJkLlxyXG4gKiBAcHJvcGVydHkgeydOT05FJ30gTk9ORSAtIE5vdCBhIHRva2VuLCBidXQgcmF0aGVyIHRoZSBiYXNlIGFzc2V0IG9mIHRoZVxyXG4gKiAgc2VsZWN0ZWQgY2hhaW4uXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgdHlwZSB3aWxsIHdvcmsgYW55d2hlcmUgeW91IGV4cGVjdCBhIHN0cmluZyB0aGF0IGNhbiBiZSBvbmUgb2YgdGhlXHJcbiAqIGFib3ZlIHN0YXR1c2VzXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtUb2tlblN0YW5kYXJkc1trZXlvZiBUb2tlblN0YW5kYXJkc119IFRva2VuU3RhbmRhcmRTdHJpbmdzXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIERlc2NyaWJlcyB0aGUgc3RhbmRhcmQgd2hpY2ggYSB0b2tlbiBjb25mb3JtcyB0by5cclxuICpcclxuICogQHR5cGUge1Rva2VuU3RhbmRhcmRzfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRPS0VOX1NUQU5EQVJEUyA9IHtcclxuICBFUkMyMCxcclxuICBFUkM3MjEsXHJcbiAgRVJDMTE1NSxcclxuICBOT05FOiAnTk9ORScsXHJcbn07XHJcbiIsImltcG9ydCB7IE1JTlVURSwgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IGdldEZldGNoV2l0aFRpbWVvdXQgZnJvbSAnLi4vbW9kdWxlcy9mZXRjaC13aXRoLXRpbWVvdXQnO1xuaW1wb3J0IHsgZ2V0U3RvcmFnZUl0ZW0sIHNldFN0b3JhZ2VJdGVtIH0gZnJvbSAnLi9zdG9yYWdlLWhlbHBlcnMnO1xuXG5jb25zdCBmZXRjaFdpdGhDYWNoZSA9IGFzeW5jIChcbiAgdXJsLFxuICBmZXRjaE9wdGlvbnMgPSB7fSxcbiAgeyBjYWNoZVJlZnJlc2hUaW1lID0gTUlOVVRFICogNiwgdGltZW91dCA9IFNFQ09ORCAqIDMwIH0gPSB7fSxcbikgPT4ge1xuICBpZiAoXG4gICAgZmV0Y2hPcHRpb25zLmJvZHkgfHxcbiAgICAoZmV0Y2hPcHRpb25zLm1ldGhvZCAmJiBmZXRjaE9wdGlvbnMubWV0aG9kICE9PSAnR0VUJylcbiAgKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmZXRjaFdpdGhDYWNoZSBvbmx5IHN1cHBvcnRzIEdFVCByZXF1ZXN0cycpO1xuICB9XG4gIGlmICghKGZldGNoT3B0aW9ucy5oZWFkZXJzIGluc3RhbmNlb2Ygd2luZG93LkhlYWRlcnMpKSB7XG4gICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBuZXcgd2luZG93LkhlYWRlcnMoZmV0Y2hPcHRpb25zLmhlYWRlcnMpO1xuICB9XG4gIGlmIChcbiAgICBmZXRjaE9wdGlvbnMuaGVhZGVycy5oYXMoJ0NvbnRlbnQtVHlwZScpICYmXG4gICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKSAhPT0gJ2FwcGxpY2F0aW9uL2pzb24nXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmV0Y2hXaXRoQ2FjaGUgb25seSBzdXBwb3J0cyBKU09OIHJlc3BvbnNlcycpO1xuICB9XG5cbiAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICBjb25zdCBjYWNoZUtleSA9IGBjYWNoZWRGZXRjaDoke3VybH1gO1xuICBjb25zdCB7IGNhY2hlZFJlc3BvbnNlLCBjYWNoZWRUaW1lIH0gPSAoYXdhaXQgZ2V0U3RvcmFnZUl0ZW0oY2FjaGVLZXkpKSB8fCB7fTtcbiAgaWYgKGNhY2hlZFJlc3BvbnNlICYmIGN1cnJlbnRUaW1lIC0gY2FjaGVkVGltZSA8IGNhY2hlUmVmcmVzaFRpbWUpIHtcbiAgICByZXR1cm4gY2FjaGVkUmVzcG9uc2U7XG4gIH1cbiAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuc2V0KCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICBjb25zdCBmZXRjaFdpdGhUaW1lb3V0ID0gZ2V0RmV0Y2hXaXRoVGltZW91dCh0aW1lb3V0KTtcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaFdpdGhUaW1lb3V0KHVybCwge1xuICAgIHJlZmVycmVyUG9saWN5OiAnbm8tcmVmZXJyZXItd2hlbi1kb3duZ3JhZGUnLFxuICAgIGJvZHk6IG51bGwsXG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICBtb2RlOiAnY29ycycsXG4gICAgLi4uZmV0Y2hPcHRpb25zLFxuICB9KTtcbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBGZXRjaCBmYWlsZWQgd2l0aCBzdGF0dXMgJyR7cmVzcG9uc2Uuc3RhdHVzfSc6ICcke3Jlc3BvbnNlLnN0YXR1c1RleHR9J2AsXG4gICAgKTtcbiAgfVxuICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gIGNvbnN0IGNhY2hlRW50cnkgPSB7XG4gICAgY2FjaGVkUmVzcG9uc2U6IHJlc3BvbnNlSnNvbixcbiAgICBjYWNoZWRUaW1lOiBjdXJyZW50VGltZSxcbiAgfTtcblxuICBhd2FpdCBzZXRTdG9yYWdlSXRlbShjYWNoZUtleSwgY2FjaGVFbnRyeSk7XG4gIHJldHVybiByZXNwb25zZUpzb247XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmZXRjaFdpdGhDYWNoZTtcbiIsImltcG9ydCB7IGNvbnZlcnNpb25VdGlsIH0gZnJvbSAnLi4vbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvRGVjaW1hbChoZXhWYWx1ZSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoaGV4VmFsdWUsIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuVmFsdWVQYXJhbSh0b2tlbkRhdGEgPSB7fSkge1xuICByZXR1cm4gdG9rZW5EYXRhPy5hcmdzPy5fdmFsdWU/LnRvU3RyaW5nKCk7XG59XG4iLCJpbXBvcnQgbG9jYWxmb3JhZ2UgZnJvbSAnbG9jYWxmb3JhZ2UnO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmFnZUl0ZW0oa2V5KSB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2VyaWFsaXplZERhdGEgPSBhd2FpdCBsb2NhbGZvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgaWYgKHNlcmlhbGl6ZWREYXRhID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiBKU09OLnBhcnNlKHNlcmlhbGl6ZWREYXRhKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc2V0U3RvcmFnZUl0ZW0oa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIGF3YWl0IGxvY2FsZm9yYWdlLnNldEl0ZW0oa2V5LCBzZXJpYWxpemVkRGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybihlcnIpO1xuICB9XG59XG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgbG9nIGZyb20gJ2xvZ2xldmVsJztcbmltcG9ydCB7IENIQUlOX0lEUyB9IGZyb20gJy4uL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7XG4gIEdBU19BUElfQkFTRV9VUkwsXG4gIEdBU19ERVZfQVBJX0JBU0VfVVJMLFxuICBTV0FQU19BUElfVjJfQkFTRV9VUkwsXG4gIFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVAsXG4gIFNXQVBTX0NMSUVOVF9JRCxcbiAgU1dBUFNfREVWX0FQSV9WMl9CQVNFX1VSTCxcbiAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTLFxufSBmcm9tICcuLi9jb25zdGFudHMvc3dhcHMnO1xuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xuaW1wb3J0IHsgaXNWYWxpZEhleEFkZHJlc3MgfSBmcm9tICcuLi9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XG5pbXBvcnQgZmV0Y2hXaXRoQ2FjaGUgZnJvbSAnLi9mZXRjaC13aXRoLWNhY2hlJztcbmltcG9ydCB7IGRlY2ltYWxUb0hleCB9IGZyb20gJy4vdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMnO1xuXG5jb25zdCBURVNUX0NIQUlOX0lEUyA9IFtDSEFJTl9JRFMuR09FUkxJLCBDSEFJTl9JRFMuTE9DQUxIT1NUXTtcblxuY29uc3QgY2xpZW50SWRIZWFkZXIgPSB7ICdYLUNsaWVudC1JZCc6IFNXQVBTX0NMSUVOVF9JRCB9O1xuXG5leHBvcnQgY29uc3QgdmFsaWRIZXggPSAoc3RyaW5nKSA9PiBCb29sZWFuKHN0cmluZz8ubWF0Y2goL14weFthLWYwLTldKyQvdSkpO1xuZXhwb3J0IGNvbnN0IHRydXRoeVN0cmluZyA9IChzdHJpbmcpID0+IEJvb2xlYW4oc3RyaW5nPy5sZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHRydXRoeURpZ2l0U3RyaW5nID0gKHN0cmluZykgPT5cbiAgdHJ1dGh5U3RyaW5nKHN0cmluZykgJiYgQm9vbGVhbihzdHJpbmcubWF0Y2goL15cXGQrJC91KSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZURhdGEodmFsaWRhdG9ycywgb2JqZWN0LCB1cmxVc2VkLCBsb2dFcnJvciA9IHRydWUpIHtcbiAgcmV0dXJuIHZhbGlkYXRvcnMuZXZlcnkoKHsgcHJvcGVydHksIHR5cGUsIHZhbGlkYXRvciB9KSA9PiB7XG4gICAgY29uc3QgdHlwZXMgPSB0eXBlLnNwbGl0KCd8Jyk7XG5cbiAgICBjb25zdCB2YWxpZCA9XG4gICAgICB0eXBlcy5zb21lKChfdHlwZSkgPT4gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV0gPT09IF90eXBlKSAmJlxuICAgICAgKCF2YWxpZGF0b3IgfHwgdmFsaWRhdG9yKG9iamVjdFtwcm9wZXJ0eV0pKTtcbiAgICBpZiAoIXZhbGlkICYmIGxvZ0Vycm9yKSB7XG4gICAgICBsb2cuZXJyb3IoXG4gICAgICAgIGByZXNwb25zZSB0byBHRVQgJHt1cmxVc2VkfSBpbnZhbGlkIGZvciBwcm9wZXJ0eSAke3Byb3BlcnR5fTsgdmFsdWUgd2FzOmAsXG4gICAgICAgIG9iamVjdFtwcm9wZXJ0eV0sXG4gICAgICAgICd8IHR5cGUgd2FzOiAnLFxuICAgICAgICB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XSxcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB2YWxpZDtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBRVU9URV9WQUxJREFUT1JTID0gW1xuICB7XG4gICAgcHJvcGVydHk6ICd0cmFkZScsXG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgdmFsaWRhdG9yOiAodHJhZGUpID0+XG4gICAgICB0cmFkZSAmJlxuICAgICAgdmFsaWRIZXgodHJhZGUuZGF0YSkgJiZcbiAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyYWRlLnRvLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pICYmXG4gICAgICBpc1ZhbGlkSGV4QWRkcmVzcyh0cmFkZS5mcm9tLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pICYmXG4gICAgICB0cnV0aHlTdHJpbmcodHJhZGUudmFsdWUpLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhcHByb3ZhbE5lZWRlZCcsXG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgdmFsaWRhdG9yOiAoYXBwcm92YWxUeCkgPT5cbiAgICAgIGFwcHJvdmFsVHggPT09IG51bGwgfHxcbiAgICAgIChhcHByb3ZhbFR4ICYmXG4gICAgICAgIHZhbGlkSGV4KGFwcHJvdmFsVHguZGF0YSkgJiZcbiAgICAgICAgaXNWYWxpZEhleEFkZHJlc3MoYXBwcm92YWxUeC50bywgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSAmJlxuICAgICAgICBpc1ZhbGlkSGV4QWRkcmVzcyhhcHByb3ZhbFR4LmZyb20sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkpLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdzb3VyY2VBbW91bnQnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogdHJ1dGh5RGlnaXRTdHJpbmcsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2Rlc3RpbmF0aW9uQW1vdW50JyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeURpZ2l0U3RyaW5nLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdzb3VyY2VUb2tlbicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvblRva2VuJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IChpbnB1dCkgPT4gaXNWYWxpZEhleEFkZHJlc3MoaW5wdXQsIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSksXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2FnZ3JlZ2F0b3InLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogdHJ1dGh5U3RyaW5nLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhZ2dUeXBlJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeVN0cmluZyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnZXJyb3InLFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHZhbGlkYXRvcjogKGVycm9yKSA9PiBlcnJvciA9PT0gbnVsbCB8fCB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhdmVyYWdlR2FzJyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnbWF4R2FzJyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnZ2FzRXN0aW1hdGUnLFxuICAgIHR5cGU6ICdudW1iZXJ8dW5kZWZpbmVkJyxcbiAgICB2YWxpZGF0b3I6IChnYXNFc3RpbWF0ZSkgPT4gZ2FzRXN0aW1hdGUgPT09IHVuZGVmaW5lZCB8fCBnYXNFc3RpbWF0ZSA+IDAsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2ZlZScsXG4gICAgdHlwZTogJ251bWJlcicsXG4gIH0sXG5dO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVHlwZSBvZiBhbiBBUEkgY2FsbCwgZS5nLiBcInRva2Vuc1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZFxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmNvbnN0IGdldEJhc2VVcmxGb3JOZXdTd2Fwc0FwaSA9ICh0eXBlLCBjaGFpbklkKSA9PiB7XG4gIGNvbnN0IHVzZURldkFwaXMgPSBwcm9jZXNzLmVudi5TV0FQU19VU0VfREVWX0FQSVM7XG4gIGNvbnN0IHYyQXBpQmFzZVVybCA9IHVzZURldkFwaXNcbiAgICA/IFNXQVBTX0RFVl9BUElfVjJfQkFTRV9VUkxcbiAgICA6IFNXQVBTX0FQSV9WMl9CQVNFX1VSTDtcbiAgY29uc3QgZ2FzQXBpQmFzZVVybCA9IHVzZURldkFwaXMgPyBHQVNfREVWX0FQSV9CQVNFX1VSTCA6IEdBU19BUElfQkFTRV9VUkw7XG4gIGNvbnN0IG5vTmV0d29ya1NwZWNpZmljVHlwZXMgPSBbJ3JlZnJlc2hUaW1lJ107IC8vIFRoZXNlIHR5cGVzIGRvbid0IG5lZWQgbmV0d29yayBpbmZvIGluIHRoZSBVUkwuXG4gIGlmIChub05ldHdvcmtTcGVjaWZpY1R5cGVzLmluY2x1ZGVzKHR5cGUpKSB7XG4gICAgcmV0dXJuIHYyQXBpQmFzZVVybDtcbiAgfVxuICBjb25zdCBjaGFpbklkRGVjaW1hbCA9IGNoYWluSWQgJiYgcGFyc2VJbnQoY2hhaW5JZCwgMTYpO1xuICBjb25zdCBnYXNBcGlUeXBlcyA9IFsnZ2FzUHJpY2VzJ107XG4gIGlmIChnYXNBcGlUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHJldHVybiBgJHtnYXNBcGlCYXNlVXJsfS9uZXR3b3Jrcy8ke2NoYWluSWREZWNpbWFsfWA7IC8vIEdhcyBjYWxjdWxhdGlvbnMgYXJlIGluIGl0cyBvd24gcmVwby5cbiAgfVxuICByZXR1cm4gYCR7djJBcGlCYXNlVXJsfS9uZXR3b3Jrcy8ke2NoYWluSWREZWNpbWFsfWA7XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0QmFzZUFwaSA9IGZ1bmN0aW9uICh0eXBlLCBjaGFpbklkID0gQ0hBSU5fSURTLk1BSU5ORVQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNoYWluSWQgPSBURVNUX0NIQUlOX0lEUy5pbmNsdWRlcyhjaGFpbklkKSA/IENIQUlOX0lEUy5NQUlOTkVUIDogY2hhaW5JZDtcbiAgY29uc3QgYmFzZVVybCA9IGdldEJhc2VVcmxGb3JOZXdTd2Fwc0FwaSh0eXBlLCBjaGFpbklkKTtcbiAgY29uc3QgY2hhaW5JZERlY2ltYWwgPSBjaGFpbklkICYmIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgaWYgKCFiYXNlVXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBTd2FwcyBBUEkgY2FsbHMgYXJlIGRpc2FibGVkIGZvciBjaGFpbklkOiAke2NoYWluSWR9YCk7XG4gIH1cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAndHJhZGUnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3RyYWRlcz9gO1xuICAgIGNhc2UgJ3Rva2Vucyc6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9rZW5zYDtcbiAgICBjYXNlICd0b2tlbic6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9rZW5gO1xuICAgIGNhc2UgJ3RvcEFzc2V0cyc6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vdG9wQXNzZXRzYDtcbiAgICBjYXNlICdhZ2dyZWdhdG9yTWV0YWRhdGEnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L2FnZ3JlZ2F0b3JNZXRhZGF0YWA7XG4gICAgY2FzZSAnZ2FzUHJpY2VzJzpcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9nYXNQcmljZXNgO1xuICAgIGNhc2UgJ25ldHdvcmsnOlxuICAgICAgLy8gT25seSB1c2UgdjIgZm9yIHRoaXMgZW5kcG9pbnQuXG4gICAgICByZXR1cm4gYCR7U1dBUFNfQVBJX1YyX0JBU0VfVVJMfS9uZXR3b3Jrcy8ke2NoYWluSWREZWNpbWFsfWA7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2V0QmFzZUFwaSByZXF1aXJlcyBhbiBhcGkgY2FsbCB0eXBlJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjVG9rZW5WYWx1ZSh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgY29uc3QgbXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBOdW1iZXIoZGVjaW1hbHMgfHwgMCkpO1xuICByZXR1cm4gbmV3IEJpZ051bWJlcihTdHJpbmcodmFsdWUpKS50aW1lcyhtdWx0aXBsaWVyKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNob3VsZEVuYWJsZURpcmVjdFdyYXBwaW5nID0gKFxuICBjaGFpbklkLFxuICBzb3VyY2VUb2tlbixcbiAgZGVzdGluYXRpb25Ub2tlbixcbikgPT4ge1xuICBpZiAoIXNvdXJjZVRva2VuIHx8ICFkZXN0aW5hdGlvblRva2VuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHdyYXBwZWRUb2tlbiA9IFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tjaGFpbklkXTtcbiAgY29uc3QgbmF0aXZlVG9rZW4gPSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5hZGRyZXNzO1xuICBjb25zdCBzb3VyY2VUb2tlbkxvd2VyQ2FzZSA9IHNvdXJjZVRva2VuLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IGRlc3RpbmF0aW9uVG9rZW5Mb3dlckNhc2UgPSBkZXN0aW5hdGlvblRva2VuLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiAoXG4gICAgKHNvdXJjZVRva2VuTG93ZXJDYXNlID09PSB3cmFwcGVkVG9rZW4gJiZcbiAgICAgIGRlc3RpbmF0aW9uVG9rZW5Mb3dlckNhc2UgPT09IG5hdGl2ZVRva2VuKSB8fFxuICAgIChzb3VyY2VUb2tlbkxvd2VyQ2FzZSA9PT0gbmF0aXZlVG9rZW4gJiZcbiAgICAgIGRlc3RpbmF0aW9uVG9rZW5Mb3dlckNhc2UgPT09IHdyYXBwZWRUb2tlbilcbiAgKTtcbn07XG5cbi8qKlxuICogR2l2ZW4gYW5kIG9iamVjdCB3aGVyZSBhbGwgdmFsdWVzIGFyZSBzdHJpbmdzLCByZXR1cm5zIHRoZSBzYW1lIG9iamVjdCB3aXRoIGFsbCB2YWx1ZXNcbiAqIG5vdyBwcmVmaXhlZCB3aXRoICcweCdcbiAqXG4gKiBAcGFyYW0gb2JqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRIZXhQcmVmaXhUb09iamVjdFZhbHVlcyhvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikucmVkdWNlKChuZXdPYmosIGtleSkgPT4ge1xuICAgIHJldHVybiB7IC4uLm5ld09iaiwgW2tleV06IGFkZEhleFByZWZpeChvYmpba2V5XSkgfTtcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSBzdGFuZGFyZCBzZXQgb2YgaW5mb3JtYXRpb24gYWJvdXQgYSB0cmFuc2FjdGlvbiwgcmV0dXJucyBhIHRyYW5zYWN0aW9uIHByb3Blcmx5IGZvcm1hdHRlZCBmb3JcbiAqIHB1Ymxpc2hpbmcgdmlhIEpTT04gUlBDIGFuZCB3ZWIzXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2VuZFRva2VuXSAtIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGUgdHJhbnNhY2l0b24gaXMgYSB0b2tlbiB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZGF0YSAtIEEgaGV4IHN0cmluZyBjb250YWluaW5nIHRoZSBkYXRhIHRvIGluY2x1ZGUgaW4gdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy50byAtIEEgaGV4IGFkZHJlc3Mgb2YgdGhlIHR4IHJlY2lwaWVudCBhZGRyZXNzXG4gKiBAcGFyYW0gb3B0aW9ucy5hbW91bnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmZyb20gLSBBIGhleCBhZGRyZXNzIG9mIHRoZSB0eCBzZW5kZXIgYWRkcmVzc1xuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZ2FzIC0gQSBoZXggcmVwcmVzZW50YXRpb24gb2YgdGhlIGdhcyB2YWx1ZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5nYXNQcmljZSAtIEEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnYXMgcHJpY2UgZm9yIHRoZSB0cmFuc2FjdGlvblxuICogQHJldHVybnMge29iamVjdH0gQW4gb2JqZWN0IHJlYWR5IGZvciBzdWJtaXNzaW9uIHRvIHRoZSBibG9ja2NoYWluLCB3aXRoIGFsbCB2YWx1ZXMgYXBwcm9wcmlhdGVseSBoZXggcHJlZml4ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnN0cnVjdFR4UGFyYW1zKHtcbiAgc2VuZFRva2VuLFxuICBkYXRhLFxuICB0byxcbiAgYW1vdW50LFxuICBmcm9tLFxuICBnYXMsXG4gIGdhc1ByaWNlLFxufSkge1xuICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICBkYXRhLFxuICAgIGZyb20sXG4gICAgdmFsdWU6ICcwJyxcbiAgICBnYXMsXG4gICAgZ2FzUHJpY2UsXG4gIH07XG5cbiAgaWYgKCFzZW5kVG9rZW4pIHtcbiAgICB0eFBhcmFtcy52YWx1ZSA9IGFtb3VudDtcbiAgICB0eFBhcmFtcy50byA9IHRvO1xuICB9XG4gIHJldHVybiBhZGRIZXhQcmVmaXhUb09iamVjdFZhbHVlcyh0eFBhcmFtcyk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFRyYWRlc0luZm8oXG4gIHtcbiAgICBzbGlwcGFnZSxcbiAgICBzb3VyY2VUb2tlbixcbiAgICBzb3VyY2VEZWNpbWFscyxcbiAgICBkZXN0aW5hdGlvblRva2VuLFxuICAgIHZhbHVlLFxuICAgIGZyb21BZGRyZXNzLFxuICAgIGV4Y2hhbmdlTGlzdCxcbiAgfSxcbiAgeyBjaGFpbklkIH0sXG4pIHtcbiAgY29uc3QgdXJsUGFyYW1zID0ge1xuICAgIGRlc3RpbmF0aW9uVG9rZW4sXG4gICAgc291cmNlVG9rZW4sXG4gICAgc291cmNlQW1vdW50OiBjYWxjVG9rZW5WYWx1ZSh2YWx1ZSwgc291cmNlRGVjaW1hbHMpLnRvU3RyaW5nKDEwKSxcbiAgICBzbGlwcGFnZSxcbiAgICB0aW1lb3V0OiBTRUNPTkQgKiAxMCxcbiAgICB3YWxsZXRBZGRyZXNzOiBmcm9tQWRkcmVzcyxcbiAgfTtcblxuICBpZiAoZXhjaGFuZ2VMaXN0KSB7XG4gICAgdXJsUGFyYW1zLmV4Y2hhbmdlTGlzdCA9IGV4Y2hhbmdlTGlzdDtcbiAgfVxuICBpZiAoc2hvdWxkRW5hYmxlRGlyZWN0V3JhcHBpbmcoY2hhaW5JZCwgc291cmNlVG9rZW4sIGRlc3RpbmF0aW9uVG9rZW4pKSB7XG4gICAgdXJsUGFyYW1zLmVuYWJsZURpcmVjdFdyYXBwaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IHF1ZXJ5U3RyaW5nID0gbmV3IFVSTFNlYXJjaFBhcmFtcyh1cmxQYXJhbXMpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IHRyYWRlVVJMID0gYCR7Z2V0QmFzZUFwaSgndHJhZGUnLCBjaGFpbklkKX0ke3F1ZXJ5U3RyaW5nfWA7XG4gIGNvbnN0IHRyYWRlc1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgdHJhZGVVUkwsXG4gICAgeyBtZXRob2Q6ICdHRVQnLCBoZWFkZXJzOiBjbGllbnRJZEhlYWRlciB9LFxuICAgIHsgY2FjaGVSZWZyZXNoVGltZTogMCwgdGltZW91dDogU0VDT05EICogMTUgfSxcbiAgKTtcbiAgY29uc3QgbmV3UXVvdGVzID0gdHJhZGVzUmVzcG9uc2UucmVkdWNlKChhZ2dJZFRyYWRlTWFwLCBxdW90ZSkgPT4ge1xuICAgIGlmIChcbiAgICAgIHF1b3RlLnRyYWRlICYmXG4gICAgICAhcXVvdGUuZXJyb3IgJiZcbiAgICAgIHZhbGlkYXRlRGF0YShRVU9URV9WQUxJREFUT1JTLCBxdW90ZSwgdHJhZGVVUkwpXG4gICAgKSB7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RlZFRyYWRlID0gY29uc3RydWN0VHhQYXJhbXMoe1xuICAgICAgICB0bzogcXVvdGUudHJhZGUudG8sXG4gICAgICAgIGZyb206IHF1b3RlLnRyYWRlLmZyb20sXG4gICAgICAgIGRhdGE6IHF1b3RlLnRyYWRlLmRhdGEsXG4gICAgICAgIGFtb3VudDogZGVjaW1hbFRvSGV4KHF1b3RlLnRyYWRlLnZhbHVlKSxcbiAgICAgICAgZ2FzOiBkZWNpbWFsVG9IZXgocXVvdGUubWF4R2FzKSxcbiAgICAgIH0pO1xuXG4gICAgICBsZXQgeyBhcHByb3ZhbE5lZWRlZCB9ID0gcXVvdGU7XG5cbiAgICAgIGlmIChhcHByb3ZhbE5lZWRlZCkge1xuICAgICAgICBhcHByb3ZhbE5lZWRlZCA9IGNvbnN0cnVjdFR4UGFyYW1zKHtcbiAgICAgICAgICAuLi5hcHByb3ZhbE5lZWRlZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFnZ0lkVHJhZGVNYXAsXG4gICAgICAgIFtxdW90ZS5hZ2dyZWdhdG9yXToge1xuICAgICAgICAgIC4uLnF1b3RlLFxuICAgICAgICAgIHNsaXBwYWdlLFxuICAgICAgICAgIHRyYWRlOiBjb25zdHJ1Y3RlZFRyYWRlLFxuICAgICAgICAgIGFwcHJvdmFsTmVlZGVkLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFnZ0lkVHJhZGVNYXA7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gbmV3UXVvdGVzO1xufVxuIiwiLyoqXG4gKiBTd2l0Y2ggdGhlIENTUyBzdHlsZXNoZWV0IHVzZWQgYmV0d2VlbiAncnRsJyBhbmQgJ2x0cidcbiAqXG4gKiBAcGFyYW0geygnbHRyJyB8ICdydGwnIHwgJ2F1dG8nKX0gZGlyZWN0aW9uIC0gVGV4dCBkaXJlY3Rpb24sIGVpdGhlciBsZWZ0LXRvLXJpZ2h0IChsdHIpIG9yIHJpZ2h0LXRvLWxlZnQgKHJ0bClcbiAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxuICovXG5jb25zdCBzd2l0Y2hEaXJlY3Rpb24gPSBhc3luYyAoZGlyZWN0aW9uKSA9PiB7XG4gIGlmIChkaXJlY3Rpb24gPT09ICdhdXRvJykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgIGRpcmVjdGlvbiA9ICdsdHInO1xuICB9XG5cbiAgbGV0IHVwZGF0ZWRMaW5rO1xuICBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGlua1tyZWw9c3R5bGVzaGVldF0nKV0uZm9yRWFjaCgobGluaykgPT4ge1xuICAgIGlmIChsaW5rLnRpdGxlID09PSBkaXJlY3Rpb24gJiYgbGluay5kaXNhYmxlZCkge1xuICAgICAgbGluay5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgdXBkYXRlZExpbmsgPSBsaW5rO1xuICAgIH0gZWxzZSBpZiAobGluay50aXRsZSAhPT0gZGlyZWN0aW9uICYmICFsaW5rLmRpc2FibGVkKSB7XG4gICAgICBsaW5rLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmICh1cGRhdGVkTGluaykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB1cGRhdGVkTGluay5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH07XG4gICAgICB1cGRhdGVkTGluay5vbmVycm9yID0gKCkgPT5cbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgJyR7ZGlyZWN0aW9ufScgc3R5bGVzaGVldGApKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBzd2l0Y2hEaXJlY3Rpb247XG4iLCJpbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUyB9IGZyb20gJy4uL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQge1xuICBjb252ZXJzaW9uVXRpbCxcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxuICBzdWJ0cmFjdEN1cnJlbmNpZXMsXG59IGZyb20gJy4uL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBpc1N3YXBzRGVmYXVsdFRva2VuU3ltYm9sIH0gZnJvbSAnLi4vbW9kdWxlcy9zd2Fwcy51dGlscyc7XG5cbmNvbnN0IFRPS0VOX1RSQU5TRkVSX0xPR19UT1BJQ19IQVNIID1cbiAgJzB4ZGRmMjUyYWQxYmUyYzg5YjY5YzJiMDY4ZmMzNzhkYWE5NTJiYTdmMTYzYzRhMTE2MjhmNTVhNGRmNTIzYjNlZic7XG5cbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9OT19DT05UUkFDVF9FUlJPUl9LRVkgPSAndHJhbnNhY3Rpb25FcnJvck5vQ29udHJhY3QnO1xuXG5leHBvcnQgY29uc3QgVEVOX1NFQ09ORFNfSU5fTUlMTElTRUNPTkRTID0gMTBfMDAwO1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY0dhc1RvdGFsKGdhc0xpbWl0ID0gJzAnLCBnYXNQcmljZSA9ICcwJykge1xuICByZXR1cm4gbXVsdGlwbHlDdXJyZW5jaWVzKGdhc0xpbWl0LCBnYXNQcmljZSwge1xuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxuICAgIG11bHRpcGxpZXJCYXNlOiAxNixcbiAgfSk7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBudW1iZXIgYW5kIHNwZWNpZmllZCBwcmVjaXNpb24sIHJldHVybnMgdGhhdCBudW1iZXIgaW4gYmFzZSAxMCB3aXRoIGEgbWF4aW11bSBvZiBwcmVjaXNpb25cbiAqIHNpZ25pZmljYW50IGRpZ2l0cywgYnV0IHdpdGhvdXQgYW55IHRyYWlsaW5nIHplcm9zIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50IFRvIGJlIHVzZWQgd2hlbiB3aXNoaW5nXG4gKiB0byBkaXNwbGF5IG9ubHkgYXMgbXVjaCBkaWdpdHMgdG8gdGhlIHVzZXIgYXMgbmVjZXNzYXJ5XG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBCaWdOdW1iZXJ9IG4gLSBUaGUgbnVtYmVyIHRvIGZvcm1hdFxuICogQHBhcmFtIHtudW1iZXJ9IHByZWNpc2lvbiAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgaW4gdGhlIHJldHVybiB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIG51bWJlciBpbiBkZWNpbWFsIGZvcm0sIHdpdGggPD0gcHJlY2lzaW9uIHNpZ25pZmljYW50IGRpZ2l0cyBhbmQgbm8gZGVjaW1hbCB0cmFpbGluZyB6ZXJvc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QcmVjaXNpb25XaXRob3V0VHJhaWxpbmdaZXJvcyhuLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobilcbiAgICAudG9QcmVjaXNpb24ocHJlY2lzaW9uKVxuICAgIC5yZXBsYWNlKC8oXFwuWzAtOV0qWzEtOV0pMCp8KFxcLjAqKS91LCAnJDEnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNUb2tlbkFtb3VudCh2YWx1ZSwgZGVjaW1hbHMpIHtcbiAgY29uc3QgbXVsdGlwbGllciA9IE1hdGgucG93KDEwLCBOdW1iZXIoZGVjaW1hbHMgfHwgMCkpO1xuICByZXR1cm4gbmV3IEJpZ051bWJlcihTdHJpbmcodmFsdWUpKS5kaXYobXVsdGlwbGllcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTd2Fwc1Rva2Vuc1JlY2VpdmVkRnJvbVR4TWV0YShcbiAgdG9rZW5TeW1ib2wsXG4gIHR4TWV0YSxcbiAgdG9rZW5BZGRyZXNzLFxuICBhY2NvdW50QWRkcmVzcyxcbiAgdG9rZW5EZWNpbWFscyxcbiAgYXBwcm92YWxUeE1ldGEsXG4gIGNoYWluSWQsXG4pIHtcbiAgY29uc3QgdHhSZWNlaXB0ID0gdHhNZXRhPy50eFJlY2VpcHQ7XG4gIGNvbnN0IG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5ID1cbiAgICB0eE1ldGE/LnR4UmVjZWlwdD8udHlwZSA9PT0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuRkVFX01BUktFVDtcbiAgaWYgKGlzU3dhcHNEZWZhdWx0VG9rZW5TeW1ib2wodG9rZW5TeW1ib2wsIGNoYWluSWQpKSB7XG4gICAgaWYgKFxuICAgICAgIXR4UmVjZWlwdCB8fFxuICAgICAgIXR4TWV0YSB8fFxuICAgICAgIXR4TWV0YS5wb3N0VHhCYWxhbmNlIHx8XG4gICAgICAhdHhNZXRhLnByZVR4QmFsYW5jZVxuICAgICkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHR4TWV0YS5zd2FwTWV0YURhdGEgJiYgdHhNZXRhLnByZVR4QmFsYW5jZSA9PT0gdHhNZXRhLnBvc3RUeEJhbGFuY2UpIHtcbiAgICAgIC8vIElmIHByZVR4QmFsYW5jZSBhbmQgcG9zdFR4QmFsYW5jZSBhcmUgZXF1YWwsIHBvc3RUeEJhbGFuY2UgaGFzbid0IGJlZW4gdXBkYXRlZCBvbiB0aW1lXG4gICAgICAvLyBiZWNhdXNlIG9mIHRoZSBSUEMgcHJvdmlkZXIgZGVsYXksIHNvIHdlIHJldHVybiBhbiBlc3RpbWF0ZWQgcmVjZWl2aW5nIGFtb3VudCBpbnN0ZWFkLlxuICAgICAgcmV0dXJuIHR4TWV0YS5zd2FwTWV0YURhdGEudG9rZW5fdG9fYW1vdW50O1xuICAgIH1cblxuICAgIGxldCBhcHByb3ZhbFR4R2FzQ29zdCA9ICcweDAnO1xuICAgIGlmIChhcHByb3ZhbFR4TWV0YSAmJiBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQpIHtcbiAgICAgIGFwcHJvdmFsVHhHYXNDb3N0ID0gY2FsY0dhc1RvdGFsKFxuICAgICAgICBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQuZ2FzVXNlZCxcbiAgICAgICAgbmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTlcbiAgICAgICAgICA/IGFwcHJvdmFsVHhNZXRhLnR4UmVjZWlwdC5lZmZlY3RpdmVHYXNQcmljZSAvLyBCYXNlIGZlZSArIHByaW9yaXR5IGZlZS5cbiAgICAgICAgICA6IGFwcHJvdmFsVHhNZXRhLnR4UGFyYW1zLmdhc1ByaWNlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBnYXNDb3N0ID0gY2FsY0dhc1RvdGFsKFxuICAgICAgdHhSZWNlaXB0Lmdhc1VzZWQsXG4gICAgICBuZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OVxuICAgICAgICA/IHR4UmVjZWlwdC5lZmZlY3RpdmVHYXNQcmljZVxuICAgICAgICA6IHR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSxcbiAgICApO1xuICAgIGNvbnN0IHRvdGFsR2FzQ29zdCA9IG5ldyBCaWdOdW1iZXIoZ2FzQ29zdCwgMTYpXG4gICAgICAucGx1cyhhcHByb3ZhbFR4R2FzQ29zdCwgMTYpXG4gICAgICAudG9TdHJpbmcoMTYpO1xuXG4gICAgY29uc3QgcHJlVHhCYWxhbmNlTGVzc0dhc0Nvc3QgPSBzdWJ0cmFjdEN1cnJlbmNpZXMoXG4gICAgICB0eE1ldGEucHJlVHhCYWxhbmNlLFxuICAgICAgdG90YWxHYXNDb3N0LFxuICAgICAge1xuICAgICAgICBhQmFzZTogMTYsXG4gICAgICAgIGJCYXNlOiAxNixcbiAgICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICB9LFxuICAgICk7XG5cbiAgICBjb25zdCBldGhSZWNlaXZlZCA9IHN1YnRyYWN0Q3VycmVuY2llcyhcbiAgICAgIHR4TWV0YS5wb3N0VHhCYWxhbmNlLFxuICAgICAgcHJlVHhCYWxhbmNlTGVzc0dhc0Nvc3QsXG4gICAgICB7XG4gICAgICAgIGFCYXNlOiAxNixcbiAgICAgICAgYkJhc2U6IDE2LFxuICAgICAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgICAgICAgdG9EZW5vbWluYXRpb246ICdFVEgnLFxuICAgICAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcbiAgICAgICAgbnVtYmVyT2ZEZWNpbWFsczogNixcbiAgICAgIH0sXG4gICAgKTtcbiAgICByZXR1cm4gZXRoUmVjZWl2ZWQ7XG4gIH1cbiAgY29uc3QgdHhSZWNlaXB0TG9ncyA9IHR4UmVjZWlwdD8ubG9ncztcbiAgaWYgKHR4UmVjZWlwdExvZ3MgJiYgdHhSZWNlaXB0Py5zdGF0dXMgIT09ICcweDAnKSB7XG4gICAgY29uc3QgdG9rZW5UcmFuc2ZlckxvZyA9IHR4UmVjZWlwdExvZ3MuZmluZCgodHhSZWNlaXB0TG9nKSA9PiB7XG4gICAgICBjb25zdCBpc1Rva2VuVHJhbnNmZXIgPVxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzICYmXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3NbMF0gPT09IFRPS0VOX1RSQU5TRkVSX0xPR19UT1BJQ19IQVNIO1xuICAgICAgY29uc3QgaXNUcmFuc2ZlckZyb21HaXZlblRva2VuID0gdHhSZWNlaXB0TG9nLmFkZHJlc3MgPT09IHRva2VuQWRkcmVzcztcbiAgICAgIGNvbnN0IGlzVHJhbnNmZXJGcm9tR2l2ZW5BZGRyZXNzID1cbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljcyAmJlxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzJdICYmXG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3NbMl0ubWF0Y2goYWNjb3VudEFkZHJlc3Muc2xpY2UoMikpO1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgaXNUb2tlblRyYW5zZmVyICYmXG4gICAgICAgIGlzVHJhbnNmZXJGcm9tR2l2ZW5Ub2tlbiAmJlxuICAgICAgICBpc1RyYW5zZmVyRnJvbUdpdmVuQWRkcmVzc1xuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9rZW5UcmFuc2ZlckxvZ1xuICAgICAgPyB0b1ByZWNpc2lvbldpdGhvdXRUcmFpbGluZ1plcm9zKFxuICAgICAgICAgIGNhbGNUb2tlbkFtb3VudCh0b2tlblRyYW5zZmVyTG9nLmRhdGEsIHRva2VuRGVjaW1hbHMpLnRvU3RyaW5nKDEwKSxcbiAgICAgICAgICA2LFxuICAgICAgICApXG4gICAgICA6ICcnO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRV9OQU1FUyA9IHtcbiAgRkVFX01BUktFVDogJ2ZlZS1tYXJrZXQnLFxuICBMRUdBQ1k6ICdsZWdhY3knLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGhleFdFSVRvRGVjR1dFSShkZWNHV0VJKSB7XG4gIHJldHVybiBjb252ZXJzaW9uVXRpbChkZWNHV0VJLCB7XG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcbiAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgICB0b0Rlbm9taW5hdGlvbjogJ0dXRUknLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY2ltYWxUb0hleChkZWNpbWFsKSB7XG4gIHJldHVybiBjb252ZXJzaW9uVXRpbChkZWNpbWFsLCB7XG4gICAgZnJvbU51bWVyaWNCYXNlOiAnZGVjJyxcbiAgICB0b051bWVyaWNCYXNlOiAnaGV4JyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhXRUlUb0RlY0VUSChoZXhXRUkpIHtcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKGhleFdFSSwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ1dFSScsXG4gICAgdG9EZW5vbWluYXRpb246ICdFVEgnLFxuICB9KTtcbn1cbiIsImV4cG9ydCBjb25zdCByZWFkQWRkcmVzc0FzQ29udHJhY3QgPSBhc3luYyAoZXRoUXVlcnksIGFkZHJlc3MpID0+IHtcclxuICBsZXQgY29udHJhY3RDb2RlO1xyXG4gIHRyeSB7XHJcbiAgICBjb250cmFjdENvZGUgPSBhd2FpdCBldGhRdWVyeS5nZXRDb2RlKGFkZHJlc3MpO1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnRyYWN0Q29kZSA9IG51bGw7XHJcbiAgfVxyXG5cclxuICBjb25zdCBpc0NvbnRyYWN0QWRkcmVzcyA9XHJcbiAgICBjb250cmFjdENvZGUgJiYgY29udHJhY3RDb2RlICE9PSAnMHgnICYmIGNvbnRyYWN0Q29kZSAhPT0gJzB4MCc7XHJcbiAgcmV0dXJuIHsgY29udHJhY3RDb2RlLCBpc0NvbnRyYWN0QWRkcmVzcyB9O1xyXG59O1xyXG4iLCIvKipcbiAqIEN1cnJlbmN5IENvbnZlcnNpb24gVXRpbGl0eVxuICogVGhpcyB1dGlsaXR5IGZ1bmN0aW9uIGNhbiBiZSB1c2VkIGZvciBjb252ZXJ0aW5nIGN1cnJlbmN5IHJlbGF0ZWQgdmFsdWVzIHdpdGhpbiBtZXRhbWFzay5cbiAqIFRoZSBjYWxsZXIgc2hvdWxkIGJlIGFibGUgdG8gcGFzcyBpdCBhIHZhbHVlLCBhbG9uZyB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSB2YWx1ZSdzXG4gKiBudW1lcmljIGJhc2UsIGRlbm9taW5hdGlvbiBhbmQgY3VycmVuY3ksIGFuZCB0aGUgZGVzaXJlZCBudW1lcmljIGJhc2UsIGRlbm9taW5hdGlvbiBhbmRcbiAqIGN1cnJlbmN5LiBJdCBzaG91bGQgcmV0dXJuIGEgc2luZ2xlIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7KG51bWJlciB8IHN0cmluZyB8IEJOKX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIHRvIHNwZWNpZnkgZGV0YWlscyBvZiB0aGUgY29udmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZyb21DdXJyZW5jeSA9ICdFVEgnIHwgJ1VTRCddIC0gVGhlIGN1cnJlbmN5IG9mIHRoZSBwYXNzZWQgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b0N1cnJlbmN5ID0gJ0VUSCcgfCAnVVNEJ10gLSBUaGUgZGVzaXJlZCBjdXJyZW5jeSBvZiB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZnJvbU51bWVyaWNCYXNlID0gJ2hleCcgfCAnZGVjJyB8ICdCTiddIC0gVGhlIG51bWVyaWMgYmFzaWMgb2YgdGhlIHBhc3NlZCB2YWx1ZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b051bWVyaWNCYXNlID0gJ2hleCcgfCAnZGVjJyB8ICdCTiddIC0gVGhlIGRlc2lyZWQgbnVtZXJpYyBiYXNpYyBvZiB0aGUgcmVzdWx0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZyb21EZW5vbWluYXRpb24gPSAnV0VJJ10gLSBUaGUgZGVub21pbmF0aW9uIG9mIHRoZSBwYXNzZWQgdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5udW1iZXJPZkRlY2ltYWxzXSAtIFRoZSBkZXNpcmVkIG51bWJlciBvZiBkZWNpbWFscyBpbiB0aGUgcmVzdWx0XG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMucm91bmREb3duXSAtIFRoZSBkZXNpcmVkIG51bWJlciBvZiBkZWNpbWFscyB0byByb3VuZCBkb3duIHRvXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29udmVyc2lvblJhdGVdIC0gVGhlIHJhdGUgdG8gdXNlIHRvIG1ha2UgdGhlIGZyb21DdXJyZW5jeSAtPiB0b0N1cnJlbmN5IGNvbnZlcnNpb25cbiAqIEByZXR1cm5zIHsobnVtYmVyIHwgc3RyaW5nIHwgQk4pfVxuICpcbiAqIFRoZSB1dGlsaXR5IHBhc3NlcyB2YWx1ZSBhbG9uZyB3aXRoIHRoZSBvcHRpb25zIGFzIGEgc2luZ2xlIG9iamVjdCB0byB0aGUgYGNvbnZlcnRlcmAgZnVuY3Rpb24uXG4gKiBgY29udmVydGVyYCBjb25kaXRpb25hbCBtb2RpZmllcyB0aGUgc3VwcGxpZWQgYHZhbHVlYCBwcm9wZXJ0eSwgZGVwZW5kaW5nXG4gKiBvbiB0aGUgYWNjb21wYW55aW5nIG9wdGlvbnMuXG4gKi9cblxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5pbXBvcnQgeyBCTiB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5cbmltcG9ydCB7IHN0cmlwSGV4UHJlZml4IH0gZnJvbSAnLi9oZXhzdHJpbmctdXRpbHMnO1xuXG4vLyBCaWcgTnVtYmVyIENvbnN0YW50c1xuY29uc3QgQklHX05VTUJFUl9XRUlfTVVMVElQTElFUiA9IG5ldyBCaWdOdW1iZXIoJzEwMDAwMDAwMDAwMDAwMDAwMDAnKTtcbmNvbnN0IEJJR19OVU1CRVJfR1dFSV9NVUxUSVBMSUVSID0gbmV3IEJpZ051bWJlcignMTAwMDAwMDAwMCcpO1xuY29uc3QgQklHX05VTUJFUl9FVEhfTVVMVElQTElFUiA9IG5ldyBCaWdOdW1iZXIoJzEnKTtcblxuLy8gU2V0dGVyIE1hcHNcbmNvbnN0IHRvQmlnTnVtYmVyID0ge1xuICBoZXg6IChuKSA9PiBuZXcgQmlnTnVtYmVyKHN0cmlwSGV4UHJlZml4KG4pLCAxNiksXG4gIGRlYzogKG4pID0+IG5ldyBCaWdOdW1iZXIoU3RyaW5nKG4pLCAxMCksXG4gIEJOOiAobikgPT4gbmV3IEJpZ051bWJlcihuLnRvU3RyaW5nKDE2KSwgMTYpLFxufTtcbmNvbnN0IHRvTm9ybWFsaXplZERlbm9taW5hdGlvbiA9IHtcbiAgV0VJOiAoYmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIuZGl2KEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIpLFxuICBHV0VJOiAoYmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIuZGl2KEJJR19OVU1CRVJfR1dFSV9NVUxUSVBMSUVSKSxcbiAgRVRIOiAoYmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIuZGl2KEJJR19OVU1CRVJfRVRIX01VTFRJUExJRVIpLFxufTtcbmNvbnN0IHRvU3BlY2lmaWVkRGVub21pbmF0aW9uID0ge1xuICBXRUk6IChiaWdOdW1iZXIpID0+IGJpZ051bWJlci50aW1lcyhCSUdfTlVNQkVSX1dFSV9NVUxUSVBMSUVSKS5yb3VuZCgpLFxuICBHV0VJOiAoYmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIudGltZXMoQklHX05VTUJFUl9HV0VJX01VTFRJUExJRVIpLnJvdW5kKDkpLFxuICBFVEg6IChiaWdOdW1iZXIpID0+IGJpZ051bWJlci50aW1lcyhCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSKS5yb3VuZCg5KSxcbn07XG5jb25zdCBiYXNlQ2hhbmdlID0ge1xuICBoZXg6IChuKSA9PiBuLnRvU3RyaW5nKDE2KSxcbiAgZGVjOiAobikgPT4gbmV3IEJpZ051bWJlcihuKS50b1N0cmluZygxMCksXG4gIEJOOiAobikgPT4gbmV3IEJOKG4udG9TdHJpbmcoMTYpKSxcbn07XG5cbi8vIFV0aWxpdHkgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGJhc2UgdHlwZXNcbmNvbnN0IGlzVmFsaWRCYXNlID0gKGJhc2UpID0+IHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIoYmFzZSkgJiYgYmFzZSA+IDE7XG59O1xuXG4vKipcbiAqIERlZmluZXMgdGhlIGJhc2UgdHlwZSBvZiBudW1lcmljIHZhbHVlXG4gKlxuICogQHR5cGVkZWYgeygnaGV4JyB8ICdkZWMnIHwgJ0JOJyl9IE51bWVyaWNCYXNlXG4gKi9cblxuLyoqXG4gKiBEZWZpbmVzIHdoaWNoIHR5cGUgb2YgZGVub21pbmF0aW9uIGEgdmFsdWUgaXMgaW5cbiAqXG4gKiBAdHlwZWRlZiB7KCdXRUknIHwgJ0dXRUknIHwgJ0VUSCcpfSBFdGhEZW5vbWluYXRpb25cbiAqL1xuXG4vKipcbiAqIFV0aWxpdHkgbWV0aG9kIHRvIGNvbnZlcnQgYSB2YWx1ZSBiZXR3ZWVuIGRlbm9taW5hdGlvbnMsIGZvcm1hdHMgYW5kIGN1cnJlbmNpZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGlucHV0XG4gKiBAcGFyYW0ge3N0cmluZyB8IEJpZ051bWJlcn0gaW5wdXQudmFsdWVcbiAqIEBwYXJhbSB7TnVtZXJpY0Jhc2V9IGlucHV0LmZyb21OdW1lcmljQmFzZVxuICogQHBhcmFtIHtFdGhEZW5vbWluYXRpb259IFtpbnB1dC5mcm9tRGVub21pbmF0aW9uXVxuICogQHBhcmFtIHtzdHJpbmd9IFtpbnB1dC5mcm9tQ3VycmVuY3ldXG4gKiBAcGFyYW0ge051bWVyaWNCYXNlfSBpbnB1dC50b051bWVyaWNCYXNlXG4gKiBAcGFyYW0ge0V0aERlbm9taW5hdGlvbn0gW2lucHV0LnRvRGVub21pbmF0aW9uXVxuICogQHBhcmFtIHtzdHJpbmd9IFtpbnB1dC50b0N1cnJlbmN5XVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dC5udW1iZXJPZkRlY2ltYWxzXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dC5jb252ZXJzaW9uUmF0ZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lucHV0LmludmVydENvbnZlcnNpb25SYXRlXVxuICogQHBhcmFtIHtzdHJpbmd9IFtpbnB1dC5yb3VuZERvd25dXG4gKi9cbmNvbnN0IGNvbnZlcnRlciA9ICh7XG4gIHZhbHVlLFxuICBmcm9tTnVtZXJpY0Jhc2UsXG4gIGZyb21EZW5vbWluYXRpb24sXG4gIGZyb21DdXJyZW5jeSxcbiAgdG9OdW1lcmljQmFzZSxcbiAgdG9EZW5vbWluYXRpb24sXG4gIHRvQ3VycmVuY3ksXG4gIG51bWJlck9mRGVjaW1hbHMsXG4gIGNvbnZlcnNpb25SYXRlLFxuICBpbnZlcnRDb252ZXJzaW9uUmF0ZSxcbiAgcm91bmREb3duLFxufSkgPT4ge1xuICBsZXQgY29udmVydGVkVmFsdWUgPSBmcm9tTnVtZXJpY0Jhc2VcbiAgICA/IHRvQmlnTnVtYmVyW2Zyb21OdW1lcmljQmFzZV0odmFsdWUpXG4gICAgOiB2YWx1ZTtcblxuICBpZiAoZnJvbURlbm9taW5hdGlvbikge1xuICAgIGNvbnZlcnRlZFZhbHVlID0gdG9Ob3JtYWxpemVkRGVub21pbmF0aW9uW2Zyb21EZW5vbWluYXRpb25dKGNvbnZlcnRlZFZhbHVlKTtcbiAgfVxuXG4gIGlmIChmcm9tQ3VycmVuY3kgIT09IHRvQ3VycmVuY3kpIHtcbiAgICBpZiAoY29udmVyc2lvblJhdGUgPT09IG51bGwgfHwgY29udmVyc2lvblJhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQ29udmVydGluZyBmcm9tICR7ZnJvbUN1cnJlbmN5fSB0byAke3RvQ3VycmVuY3l9IHJlcXVpcmVzIGEgY29udmVyc2lvblJhdGUsIGJ1dCBvbmUgd2FzIG5vdCBwcm92aWRlZGAsXG4gICAgICApO1xuICAgIH1cbiAgICBsZXQgcmF0ZSA9IHRvQmlnTnVtYmVyLmRlYyhjb252ZXJzaW9uUmF0ZSk7XG4gICAgaWYgKGludmVydENvbnZlcnNpb25SYXRlKSB7XG4gICAgICByYXRlID0gbmV3IEJpZ051bWJlcigxLjApLmRpdihjb252ZXJzaW9uUmF0ZSk7XG4gICAgfVxuICAgIGNvbnZlcnRlZFZhbHVlID0gY29udmVydGVkVmFsdWUudGltZXMocmF0ZSk7XG4gIH1cblxuICBpZiAodG9EZW5vbWluYXRpb24pIHtcbiAgICBjb252ZXJ0ZWRWYWx1ZSA9IHRvU3BlY2lmaWVkRGVub21pbmF0aW9uW3RvRGVub21pbmF0aW9uXShjb252ZXJ0ZWRWYWx1ZSk7XG4gIH1cblxuICBpZiAobnVtYmVyT2ZEZWNpbWFscyAhPT0gdW5kZWZpbmVkICYmIG51bWJlck9mRGVjaW1hbHMgIT09IG51bGwpIHtcbiAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlZFZhbHVlLnJvdW5kKFxuICAgICAgbnVtYmVyT2ZEZWNpbWFscyxcbiAgICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0RPV04sXG4gICAgKTtcbiAgfVxuXG4gIGlmIChyb3VuZERvd24pIHtcbiAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlZFZhbHVlLnJvdW5kKHJvdW5kRG93biwgQmlnTnVtYmVyLlJPVU5EX0RPV04pO1xuICB9XG5cbiAgaWYgKHRvTnVtZXJpY0Jhc2UpIHtcbiAgICBjb252ZXJ0ZWRWYWx1ZSA9IGJhc2VDaGFuZ2VbdG9OdW1lcmljQmFzZV0oY29udmVydGVkVmFsdWUpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0ZWRWYWx1ZTtcbn07XG5cbmNvbnN0IGNvbnZlcnNpb25VdGlsID0gKFxuICB2YWx1ZSxcbiAge1xuICAgIGZyb21DdXJyZW5jeSA9IG51bGwsXG4gICAgdG9DdXJyZW5jeSA9IGZyb21DdXJyZW5jeSxcbiAgICBmcm9tTnVtZXJpY0Jhc2UsXG4gICAgdG9OdW1lcmljQmFzZSxcbiAgICBmcm9tRGVub21pbmF0aW9uLFxuICAgIHRvRGVub21pbmF0aW9uLFxuICAgIG51bWJlck9mRGVjaW1hbHMsXG4gICAgY29udmVyc2lvblJhdGUsXG4gICAgaW52ZXJ0Q29udmVyc2lvblJhdGUsXG4gIH0sXG4pID0+IHtcbiAgaWYgKGZyb21DdXJyZW5jeSAhPT0gdG9DdXJyZW5jeSAmJiAhY29udmVyc2lvblJhdGUpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gY29udmVydGVyKHtcbiAgICBmcm9tQ3VycmVuY3ksXG4gICAgdG9DdXJyZW5jeSxcbiAgICBmcm9tTnVtZXJpY0Jhc2UsXG4gICAgdG9OdW1lcmljQmFzZSxcbiAgICBmcm9tRGVub21pbmF0aW9uLFxuICAgIHRvRGVub21pbmF0aW9uLFxuICAgIG51bWJlck9mRGVjaW1hbHMsXG4gICAgY29udmVyc2lvblJhdGUsXG4gICAgaW52ZXJ0Q29udmVyc2lvblJhdGUsXG4gICAgdmFsdWU6IHZhbHVlIHx8ICcwJyxcbiAgfSk7XG59O1xuXG5jb25zdCBnZXRCaWdOdW1iZXIgPSAodmFsdWUsIGJhc2UpID0+IHtcbiAgaWYgKCFpc1ZhbGlkQmFzZShiYXNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHZhbGlkIGJhc2UnKTtcbiAgfVxuXG4gIC8vIFdlIGRvbid0IGluY2x1ZGUgJ251bWJlcicgaGVyZSwgYmVjYXVzZSBCaWdOdW1iZXIgd2lsbCB0aHJvdyBpZiBwYXNzZWRcbiAgLy8gYSBudW1iZXIgcHJpbWl0aXZlIGl0IGNvbnNpZGVycyB1bnNhZmUuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgQmlnTnVtYmVyKSB7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIGJhc2UpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoU3RyaW5nKHZhbHVlKSwgYmFzZSk7XG59O1xuXG5jb25zdCBhZGRDdXJyZW5jaWVzID0gKGEsIGIsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IGFCYXNlLCBiQmFzZSwgLi4uY29udmVyc2lvbk9wdGlvbnMgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFpc1ZhbGlkQmFzZShhQmFzZSkgfHwgIWlzVmFsaWRCYXNlKGJCYXNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHZhbGlkIGFCYXNlIGFuZCBiQmFzZScpO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBnZXRCaWdOdW1iZXIoYSwgYUJhc2UpLmFkZChnZXRCaWdOdW1iZXIoYiwgYkJhc2UpKTtcblxuICByZXR1cm4gY29udmVydGVyKHtcbiAgICB2YWx1ZSxcbiAgICAuLi5jb252ZXJzaW9uT3B0aW9ucyxcbiAgfSk7XG59O1xuXG5jb25zdCBzdWJ0cmFjdEN1cnJlbmNpZXMgPSAoYSwgYiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIGNvbnN0IHsgYUJhc2UsIGJCYXNlLCAuLi5jb252ZXJzaW9uT3B0aW9ucyB9ID0gb3B0aW9ucztcblxuICBpZiAoIWlzVmFsaWRCYXNlKGFCYXNlKSB8fCAhaXNWYWxpZEJhc2UoYkJhc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgdmFsaWQgYUJhc2UgYW5kIGJCYXNlJyk7XG4gIH1cblxuICBjb25zdCB2YWx1ZSA9IGdldEJpZ051bWJlcihhLCBhQmFzZSkubWludXMoZ2V0QmlnTnVtYmVyKGIsIGJCYXNlKSk7XG5cbiAgcmV0dXJuIGNvbnZlcnRlcih7XG4gICAgdmFsdWUsXG4gICAgLi4uY29udmVyc2lvbk9wdGlvbnMsXG4gIH0pO1xufTtcblxuY29uc3QgbXVsdGlwbHlDdXJyZW5jaWVzID0gKGEsIGIsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IG11bHRpcGxpY2FuZEJhc2UsIG11bHRpcGxpZXJCYXNlLCAuLi5jb252ZXJzaW9uT3B0aW9ucyB9ID0gb3B0aW9ucztcblxuICBpZiAoIWlzVmFsaWRCYXNlKG11bHRpcGxpY2FuZEJhc2UpIHx8ICFpc1ZhbGlkQmFzZShtdWx0aXBsaWVyQmFzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSB2YWxpZCBtdWx0aXBsaWNhbmRCYXNlIGFuZCBtdWx0aXBsaWVyQmFzZScpO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBnZXRCaWdOdW1iZXIoYSwgbXVsdGlwbGljYW5kQmFzZSkudGltZXMoXG4gICAgZ2V0QmlnTnVtYmVyKGIsIG11bHRpcGxpZXJCYXNlKSxcbiAgKTtcblxuICByZXR1cm4gY29udmVydGVyKHtcbiAgICB2YWx1ZSxcbiAgICAuLi5jb252ZXJzaW9uT3B0aW9ucyxcbiAgfSk7XG59O1xuXG5jb25zdCBkaXZpZGVDdXJyZW5jaWVzID0gKGEsIGIsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IGRpdmlkZW5kQmFzZSwgZGl2aXNvckJhc2UsIC4uLmNvbnZlcnNpb25PcHRpb25zIH0gPSBvcHRpb25zO1xuXG4gIGlmICghaXNWYWxpZEJhc2UoZGl2aWRlbmRCYXNlKSB8fCAhaXNWYWxpZEJhc2UoZGl2aXNvckJhc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgdmFsaWQgZGl2aWRlbmRCYXNlIGFuZCBkaXZpc29yQmFzZScpO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBnZXRCaWdOdW1iZXIoYSwgZGl2aWRlbmRCYXNlKS5kaXYoZ2V0QmlnTnVtYmVyKGIsIGRpdmlzb3JCYXNlKSk7XG5cbiAgcmV0dXJuIGNvbnZlcnRlcih7XG4gICAgdmFsdWUsXG4gICAgLi4uY29udmVyc2lvbk9wdGlvbnMsXG4gIH0pO1xufTtcblxuY29uc3QgY29udmVyc2lvbkdyZWF0ZXJUaGFuID0gKHsgLi4uZmlyc3RQcm9wcyB9LCB7IC4uLnNlY29uZFByb3BzIH0pID0+IHtcbiAgY29uc3QgZmlyc3RWYWx1ZSA9IGNvbnZlcnRlcih7IC4uLmZpcnN0UHJvcHMgfSk7XG4gIGNvbnN0IHNlY29uZFZhbHVlID0gY29udmVydGVyKHsgLi4uc2Vjb25kUHJvcHMgfSk7XG5cbiAgcmV0dXJuIGZpcnN0VmFsdWUuZ3Qoc2Vjb25kVmFsdWUpO1xufTtcblxuY29uc3QgY29udmVyc2lvbkxlc3NUaGFuID0gKHsgLi4uZmlyc3RQcm9wcyB9LCB7IC4uLnNlY29uZFByb3BzIH0pID0+IHtcbiAgY29uc3QgZmlyc3RWYWx1ZSA9IGNvbnZlcnRlcih7IC4uLmZpcnN0UHJvcHMgfSk7XG4gIGNvbnN0IHNlY29uZFZhbHVlID0gY29udmVydGVyKHsgLi4uc2Vjb25kUHJvcHMgfSk7XG5cbiAgcmV0dXJuIGZpcnN0VmFsdWUubHQoc2Vjb25kVmFsdWUpO1xufTtcblxuY29uc3QgY29udmVyc2lvbk1heCA9ICh7IC4uLmZpcnN0UHJvcHMgfSwgeyAuLi5zZWNvbmRQcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGZpcnN0SXNHcmVhdGVyID0gY29udmVyc2lvbkdyZWF0ZXJUaGFuKFxuICAgIHsgLi4uZmlyc3RQcm9wcyB9LFxuICAgIHsgLi4uc2Vjb25kUHJvcHMgfSxcbiAgKTtcblxuICByZXR1cm4gZmlyc3RJc0dyZWF0ZXIgPyBmaXJzdFByb3BzLnZhbHVlIDogc2Vjb25kUHJvcHMudmFsdWU7XG59O1xuXG5jb25zdCBjb252ZXJzaW9uR1RFID0gKHsgLi4uZmlyc3RQcm9wcyB9LCB7IC4uLnNlY29uZFByb3BzIH0pID0+IHtcbiAgY29uc3QgZmlyc3RWYWx1ZSA9IGNvbnZlcnRlcih7IC4uLmZpcnN0UHJvcHMgfSk7XG4gIGNvbnN0IHNlY29uZFZhbHVlID0gY29udmVydGVyKHsgLi4uc2Vjb25kUHJvcHMgfSk7XG4gIHJldHVybiBmaXJzdFZhbHVlLmdyZWF0ZXJUaGFuT3JFcXVhbFRvKHNlY29uZFZhbHVlKTtcbn07XG5cbmNvbnN0IGNvbnZlcnNpb25MVEUgPSAoeyAuLi5maXJzdFByb3BzIH0sIHsgLi4uc2Vjb25kUHJvcHMgfSkgPT4ge1xuICBjb25zdCBmaXJzdFZhbHVlID0gY29udmVydGVyKHsgLi4uZmlyc3RQcm9wcyB9KTtcbiAgY29uc3Qgc2Vjb25kVmFsdWUgPSBjb252ZXJ0ZXIoeyAuLi5zZWNvbmRQcm9wcyB9KTtcbiAgcmV0dXJuIGZpcnN0VmFsdWUubGVzc1RoYW5PckVxdWFsVG8oc2Vjb25kVmFsdWUpO1xufTtcblxuY29uc3QgdG9OZWdhdGl2ZSA9IChuLCBvcHRpb25zID0ge30pID0+IHtcbiAgcmV0dXJuIG11bHRpcGx5Q3VycmVuY2llcyhuLCAtMSwgb3B0aW9ucyk7XG59O1xuXG5mdW5jdGlvbiBkZWNHV0VJVG9IZXhXRUkoZGVjR1dFSSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoZGVjR1dFSSwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ0dXRUknLFxuICAgIHRvRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgfSk7XG59XG5cbmV4cG9ydCB7XG4gIGNvbnZlcnNpb25VdGlsLFxuICBhZGRDdXJyZW5jaWVzLFxuICBtdWx0aXBseUN1cnJlbmNpZXMsXG4gIGNvbnZlcnNpb25HcmVhdGVyVGhhbixcbiAgY29udmVyc2lvbkxlc3NUaGFuLFxuICBjb252ZXJzaW9uR1RFLFxuICBjb252ZXJzaW9uTFRFLFxuICBjb252ZXJzaW9uTWF4LFxuICB0b05lZ2F0aXZlLFxuICBzdWJ0cmFjdEN1cnJlbmNpZXMsXG4gIGRlY0dXRUlUb0hleFdFSSxcbiAgdG9CaWdOdW1iZXIsXG4gIHRvTm9ybWFsaXplZERlbm9taW5hdGlvbixcbiAgZGl2aWRlQ3VycmVuY2llcyxcbn07XG4iLCJpbXBvcnQgeyBtZW1vaXplIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgU0VDT05EIH0gZnJvbSAnLi4vY29uc3RhbnRzL3RpbWUnO1xyXG5cclxuY29uc3QgZ2V0RmV0Y2hXaXRoVGltZW91dCA9IG1lbW9pemUoKHRpbWVvdXQgPSBTRUNPTkQgKiAzMCkgPT4ge1xyXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcih0aW1lb3V0KSB8fCB0aW1lb3V0IDwgMSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgcG9zaXRpdmUgaW50ZWdlciB0aW1lb3V0LicpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uIF9mZXRjaCh1cmwsIG9wdHMpIHtcclxuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyB3aW5kb3cuQWJvcnRDb250cm9sbGVyKCk7XHJcbiAgICBjb25zdCB7IHNpZ25hbCB9ID0gYWJvcnRDb250cm9sbGVyO1xyXG4gICAgY29uc3QgZiA9IHdpbmRvdy5mZXRjaCh1cmwsIHtcclxuICAgICAgLi4ub3B0cyxcclxuICAgICAgc2lnbmFsLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IGFib3J0Q29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcclxuXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmO1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICByZXR1cm4gcmVzO1xyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xyXG4gICAgICB0aHJvdyBlO1xyXG4gICAgfVxyXG4gIH07XHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZ2V0RmV0Y2hXaXRoVGltZW91dDtcclxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcclxuaW1wb3J0IHtcclxuICBhZGRDdXJyZW5jaWVzLFxyXG4gIGNvbnZlcnNpb25HcmVhdGVyVGhhbixcclxuICBtdWx0aXBseUN1cnJlbmNpZXMsXHJcbn0gZnJvbSAnLi9jb252ZXJzaW9uLnV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBBY2NlcHRzIGFuIG9wdGlvbnMgYmFnIGNvbnRhaW5pbmcgZ2FzIGZlZSBwYXJhbWV0ZXJzIGluIGhleCBmb3JtYXQgYW5kXHJcbiAqIHJldHVybnMgYSBnYXNUb3RhbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHRoZSBtYXhpbXVtIGFtb3VudCBvZiB3ZWkgdGhlXHJcbiAqIHRyYW5zYWN0aW9uIHdpbGwgY29zdC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBnYXMgZmVlIHBhcmFtZXRlcnMgb2JqZWN0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5nYXNMaW1pdF0gLSB0aGUgbWF4aW11bSBhbW91bnQgb2YgZ2FzIHRvIGFsbG93IHRoaXNcclxuICogIHRyYW5zYWN0aW9uIHRvIGNvbnN1bWUuIFZhbHVlIGlzIGEgaGV4IHN0cmluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZ2FzUHJpY2VdIC0gVGhlIGZlZSBpbiB3ZWkgdG8gcGF5IHBlciBnYXMgdXNlZC5cclxuICogIGdhc1ByaWNlIGlzIG9ubHkgc2V0IG9uIExlZ2FjeSB0eXBlIHRyYW5zYWN0aW9ucy4gVmFsdWUgaXMgaGV4IHN0cmluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWF4RmVlUGVyR2FzXSAtIFRoZSBtYXhpbXVtIGZlZSBpbiB3ZWkgdG8gcGF5IHBlclxyXG4gKiAgZ2FzIHVzZWQuIG1heEZlZVBlckdhcyBpcyBpbnRyb2R1Y2VkIGluIEVJUCAxNTU5IGFuZCByZXByZXNlbnRzIHRoZSBtYXhcclxuICogIHRvdGFsIGEgdXNlciB3aWxsIHBheSBwZXIgZ2FzLiBBY3R1YWwgY29zdCBpcyBkZXRlcm1pbmVkIGJ5IGJhc2VGZWVQZXJHYXNcclxuICogIG9uIHRoZSBibG9jayArIG1heFByaW9yaXR5RmVlUGVyR2FzLiBWYWx1ZSBpcyBoZXggc3RyaW5nXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBtYXhpbXVtIHRvdGFsIGNvc3Qgb2YgdHJhbnNhY3Rpb24gaW4gaGV4IHdlaSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNYXhpbXVtR2FzVG90YWxJbkhleFdlaSh7XHJcbiAgZ2FzTGltaXQgPSAnMHgwJyxcclxuICBnYXNQcmljZSxcclxuICBtYXhGZWVQZXJHYXMsXHJcbn0gPSB7fSkge1xyXG4gIGlmIChtYXhGZWVQZXJHYXMpIHtcclxuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoXHJcbiAgICAgIG11bHRpcGx5Q3VycmVuY2llcyhnYXNMaW1pdCwgbWF4RmVlUGVyR2FzLCB7XHJcbiAgICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXHJcbiAgICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTYsXHJcbiAgICAgICAgbXVsdGlwbGllckJhc2U6IDE2LFxyXG4gICAgICB9KSxcclxuICAgICk7XHJcbiAgfVxyXG4gIGlmICghZ2FzUHJpY2UpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgJ2dldE1heGltdW1HYXNUb3RhbEluSGV4V2VpIHJlcXVpcmVzIGdhc1ByaWNlIGJlIHByb3ZpZGVkIHRvIGNhbGN1bGF0ZSBsZWdhY3kgZ2FzIHRvdGFsJyxcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBhZGRIZXhQcmVmaXgoXHJcbiAgICBtdWx0aXBseUN1cnJlbmNpZXMoZ2FzTGltaXQsIGdhc1ByaWNlLCB7XHJcbiAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgICBtdWx0aXBsaWNhbmRCYXNlOiAxNixcclxuICAgICAgbXVsdGlwbGllckJhc2U6IDE2LFxyXG4gICAgfSksXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFjY2VwdHMgYW4gb3B0aW9ucyBiYWcgY29udGFpbmluZyBnYXMgZmVlIHBhcmFtZXRlcnMgaW4gaGV4IGZvcm1hdCBhbmRcclxuICogcmV0dXJucyBhIGdhc1RvdGFsIHBhcmFtZXRlciByZXByZXNlbnRpbmcgdGhlIG1pbmltdW0gYW1vdW50IG9mIHdlaSB0aGVcclxuICogdHJhbnNhY3Rpb24gd2lsbCBjb3N0LiBGb3IgZ2FzUHJpY2UgdHlwZXMgdGhpcyBpcyB0aGUgc2FtZSBhcyBtYXguXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gZ2FzIGZlZSBwYXJhbWV0ZXJzIG9iamVjdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZ2FzTGltaXRdIC0gdGhlIG1heGltdW0gYW1vdW50IG9mIGdhcyB0byBhbGxvdyB0aGlzXHJcbiAqICB0cmFuc2FjdGlvbiB0byBjb25zdW1lLiBWYWx1ZSBpcyBhIGhleCBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmdhc1ByaWNlXSAtIFRoZSBmZWUgaW4gd2VpIHRvIHBheSBwZXIgZ2FzIHVzZWQuXHJcbiAqICBnYXNQcmljZSBpcyBvbmx5IHNldCBvbiBMZWdhY3kgdHlwZSB0cmFuc2FjdGlvbnMuIFZhbHVlIGlzIGhleCBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1heEZlZVBlckdhc10gLSBUaGUgbWF4aW11bSBmZWUgaW4gd2VpIHRvIHBheSBwZXJcclxuICogIGdhcyB1c2VkLiBtYXhGZWVQZXJHYXMgaXMgaW50cm9kdWNlZCBpbiBFSVAgMTU1OSBhbmQgcmVwcmVzZW50cyB0aGUgbWF4XHJcbiAqICB0b3RhbCBhIHVzZXIgd2lsbCBwYXkgcGVyIGdhcy4gQWN0dWFsIGNvc3QgaXMgZGV0ZXJtaW5lZCBieSBiYXNlRmVlUGVyR2FzXHJcbiAqICBvbiB0aGUgYmxvY2sgKyBtYXhQcmlvcml0eUZlZVBlckdhcy4gVmFsdWUgaXMgaGV4IHN0cmluZ1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWF4UHJpb3JpdHlGZWVQZXJHYXNdIC0gVGhlIG1heGltdW0gZmVlIGluIHdlaSB0b1xyXG4gKiAgcGF5IGEgbWluZXIgdG8gaW5jbHVkZSB0aGlzIHRyYW5zYWN0aW9uLlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmFzZUZlZVBlckdhc10gLSBUaGUgZXN0aW1hdGVkIGJsb2NrIGJhc2VGZWVQZXJHYXNcclxuICogIHRoYXQgd2lsbCBiZSBidXJuZWQuIEludHJvZHVjZWQgaW4gRUlQIDE1NTkuIFZhbHVlIGluIGhleCB3ZWkuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBtaW5pbXVtIHRvdGFsIGNvc3Qgb2YgdHJhbnNhY3Rpb24gaW4gaGV4IHdlaSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5pbXVtR2FzVG90YWxJbkhleFdlaSh7XHJcbiAgZ2FzTGltaXQgPSAnMHgwJyxcclxuICBnYXNQcmljZSxcclxuICBtYXhQcmlvcml0eUZlZVBlckdhcyxcclxuICBtYXhGZWVQZXJHYXMsXHJcbiAgYmFzZUZlZVBlckdhcyxcclxufSA9IHt9KSB7XHJcbiAgY29uc3QgaXNFSVAxNTU5RXN0aW1hdGUgPSBCb29sZWFuKFxyXG4gICAgbWF4RmVlUGVyR2FzIHx8IG1heFByaW9yaXR5RmVlUGVyR2FzIHx8IGJhc2VGZWVQZXJHYXMsXHJcbiAgKTtcclxuICBpZiAoaXNFSVAxNTU5RXN0aW1hdGUgJiYgZ2FzUHJpY2UpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYGdldE1pbmltdW1HYXNUb3RhbEluSGV4V2VpIGV4cGVjdHMgZWl0aGVyIGdhc1ByaWNlIE9SIHRoZSBFSVAtMTU1OSBnYXMgZmllbGRzLCBidXQgYm90aCB3ZXJlIHByb3ZpZGVkYCxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNFSVAxNTU5RXN0aW1hdGUgPT09IGZhbHNlICYmICFnYXNQcmljZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgZ2V0TWluaW11bUdhc1RvdGFsSW5IZXhXZWkgZXhwZWN0cyBlaXRoZXIgZ2FzUHJpY2UgT1IgdGhlIEVJUC0xNTU5IGdhcyBmaWVsZHMsIGJ1dCBuZWl0aGVyIHdlcmUgcHJvdmlkZWRgLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0VJUDE1NTlFc3RpbWF0ZSAmJiAhYmFzZUZlZVBlckdhcykge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgZ2V0TWluaW11bUdhc1RvdGFsSW5IZXhXZWkgcmVxdWlyZXMgYmFzZUZlZVBlckdhcyBiZSBwcm92aWRlZCB3aGVuIGNhbGN1bGF0aW5nIEVJUC0xNTU5IHRvdGFsc2AsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzRUlQMTU1OUVzdGltYXRlICYmICghbWF4RmVlUGVyR2FzIHx8ICFtYXhQcmlvcml0eUZlZVBlckdhcykpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYGdldE1pbmltdW1HYXNUb3RhbEluSGV4V2VpIHJlcXVpcmVzIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgYmUgcHJvdmlkZWQgd2hlbiBjYWxjdWxhdGluZyBFSVAtMTU1OSB0b3RhbHNgLFxyXG4gICAgKTtcclxuICB9XHJcbiAgaWYgKGlzRUlQMTU1OUVzdGltYXRlID09PSBmYWxzZSkge1xyXG4gICAgcmV0dXJuIGdldE1heGltdW1HYXNUb3RhbEluSGV4V2VpKHsgZ2FzTGltaXQsIGdhc1ByaWNlIH0pO1xyXG4gIH1cclxuICBjb25zdCBtaW5pbXVtRmVlUGVyR2FzID0gYWRkQ3VycmVuY2llcyhiYXNlRmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywge1xyXG4gICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXHJcbiAgICBhQmFzZTogMTYsXHJcbiAgICBiQmFzZTogMTYsXHJcbiAgfSk7XHJcblxyXG4gIGlmIChcclxuICAgIGNvbnZlcnNpb25HcmVhdGVyVGhhbihcclxuICAgICAgeyB2YWx1ZTogbWluaW11bUZlZVBlckdhcywgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxyXG4gICAgICB7IHZhbHVlOiBtYXhGZWVQZXJHYXMsIGZyb21OdW1lcmljQmFzZTogJ2hleCcgfSxcclxuICAgIClcclxuICApIHtcclxuICAgIHJldHVybiBnZXRNYXhpbXVtR2FzVG90YWxJbkhleFdlaSh7IGdhc0xpbWl0LCBtYXhGZWVQZXJHYXMgfSk7XHJcbiAgfVxyXG4gIHJldHVybiBhZGRIZXhQcmVmaXgoXHJcbiAgICBtdWx0aXBseUN1cnJlbmNpZXMoZ2FzTGltaXQsIG1pbmltdW1GZWVQZXJHYXMsIHtcclxuICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXHJcbiAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxyXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTYsXHJcbiAgICB9KSxcclxuICApO1xyXG59XHJcbiIsImltcG9ydCB7XG4gIGlzSGV4U3RyaW5nLFxuICBpc1ZhbGlkQWRkcmVzcyxcbiAgaXNWYWxpZENoZWNrc3VtQWRkcmVzcyxcbiAgYWRkSGV4UHJlZml4LFxuICB0b0NoZWNrc3VtQWRkcmVzcyxcbiAgemVyb0FkZHJlc3MsXG4gIGlzSGV4UHJlZml4ZWQsXG59IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5cbmV4cG9ydCBjb25zdCBCVVJOX0FERFJFU1MgPSB6ZXJvQWRkcmVzcygpO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNCdXJuQWRkcmVzcyhhZGRyZXNzKSB7XG4gIHJldHVybiBhZGRyZXNzID09PSBCVVJOX0FERFJFU1M7XG59XG5cbi8qKlxuICogVmFsaWRhdGVzIHRoYXQgdGhlIGlucHV0IGlzIGEgaGV4IGFkZHJlc3MuIFRoaXMgdXRpbGl0eSBtZXRob2QgaXMgYSB0aGluXG4gKiB3cmFwcGVyIGFyb3VuZCBldGhlcmV1bWpzLXV0aWwuaXNWYWxpZEFkZHJlc3MsIHdpdGggdGhlIGV4Y2VwdGlvbiB0aGF0IGl0XG4gKiBkb2VzIG5vdCB0aHJvdyBhbiBlcnJvciB3aGVuIHByb3ZpZGVkIHZhbHVlcyB0aGF0IGFyZSBub3QgaGV4IHN0cmluZ3MuIEluXG4gKiBhZGRpdGlvbiwgYW5kIGJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHRydWUgZm9yIGhleCBzdHJpbmdzIHRoYXRcbiAqIG1lZXQgdGhlIGxlbmd0aCByZXF1aXJlbWVudCBvZiBhIGhleCBhZGRyZXNzLCBidXQgYXJlIG5vdCBwcmVmaXhlZCB3aXRoIGAweGBcbiAqIEZpbmFsbHksIGlmIHRoZSBtaXhlZENhc2VVc2VDaGVja3N1bSBmbGFnIGlzIHRydWUgYW5kIGEgbWl4ZWQgY2FzZSBzdHJpbmcgaXNcbiAqIHByb3ZpZGVkIHRoaXMgbWV0aG9kIHdpbGwgdmFsaWRhdGUgaXQgaGFzIHRoZSBwcm9wZXIgY2hlY2tzdW0gZm9ybWF0dGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcG9zc2libGVBZGRyZXNzIC0gSW5wdXQgcGFyYW1ldGVyIHRvIGNoZWNrIGFnYWluc3RcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBvcHRpb25zIGJhZ1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5hbGxvd05vblByZWZpeGVkXSAtIElmIHRydWUgd2lsbCBmaXJzdCBlbnN1cmUgJzB4J1xuICogIGlzIHByZXBlbmRlZCB0byB0aGUgc3RyaW5nXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLm1peGVkQ2FzZVVzZUNoZWNrc3VtXSAtIElmIHRydWUgd2lsbCB0cmVhdCBtaXhlZFxuICogIGNhc2UgYWRkcmVzc2VzIGFzIGNoZWNrc3VtIGFkZHJlc3NlcyBhbmQgdmFsaWRhdGUgdGhhdCBwcm9wZXIgY2hlY2tzdW1cbiAqICBmb3JtYXQgaXMgdXNlZFxuICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSBpbnB1dCBpcyBhIHZhbGlkIGhleCBhZGRyZXNzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkSGV4QWRkcmVzcyhcbiAgcG9zc2libGVBZGRyZXNzLFxuICB7IGFsbG93Tm9uUHJlZml4ZWQgPSB0cnVlLCBtaXhlZENhc2VVc2VDaGVja3N1bSA9IGZhbHNlIH0gPSB7fSxcbikge1xuICBjb25zdCBhZGRyZXNzVG9DaGVjayA9IGFsbG93Tm9uUHJlZml4ZWRcbiAgICA/IGFkZEhleFByZWZpeChwb3NzaWJsZUFkZHJlc3MpXG4gICAgOiBwb3NzaWJsZUFkZHJlc3M7XG4gIGlmICghaXNIZXhTdHJpbmcoYWRkcmVzc1RvQ2hlY2spKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG1peGVkQ2FzZVVzZUNoZWNrc3VtKSB7XG4gICAgY29uc3QgcHJlZml4UmVtb3ZlZCA9IGFkZHJlc3NUb0NoZWNrLnNsaWNlKDIpO1xuICAgIGNvbnN0IGxvd2VyID0gcHJlZml4UmVtb3ZlZC50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHVwcGVyID0gcHJlZml4UmVtb3ZlZC50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IGFsbE9uZUNhc2UgPSBwcmVmaXhSZW1vdmVkID09PSBsb3dlciB8fCBwcmVmaXhSZW1vdmVkID09PSB1cHBlcjtcbiAgICBpZiAoIWFsbE9uZUNhc2UpIHtcbiAgICAgIHJldHVybiBpc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzKGFkZHJlc3NUb0NoZWNrKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaXNWYWxpZEFkZHJlc3MoYWRkcmVzc1RvQ2hlY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9DaGVja3N1bUhleEFkZHJlc3MoYWRkcmVzcykge1xuICBpZiAoIWFkZHJlc3MpIHtcbiAgICAvLyBvdXIgaW50ZXJuYWwgY2hlY2tzdW1BZGRyZXNzIGZ1bmN0aW9uIHRoYXQgdGhpcyBtZXRob2QgcmVwbGFjZXMgd291bGRcbiAgICAvLyByZXR1cm4gYW4gZW1wdHkgc3RyaW5nIGZvciBudWxsaXNoIGlucHV0LiBJZiBhbnkgZGlyZWN0IHVzYWdlcyBvZlxuICAgIC8vIGV0aGVyZXVtanMtdXRpbC50b0NoZWNrc3VtQWRkcmVzcyB3ZXJlIGNhbGxlZCB3aXRoIG51bGxpc2ggaW5wdXQgaXRcbiAgICAvLyB3b3VsZCBoYXZlIHJlc3VsdGVkIGluIGFuIGVycm9yIG9uIHZlcnNpb24gNS4xLlxuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBoZXhQcmVmaXhlZCA9IGFkZEhleFByZWZpeChhZGRyZXNzKTtcbiAgaWYgKCFpc0hleFN0cmluZyhoZXhQcmVmaXhlZCkpIHtcbiAgICAvLyBWZXJzaW9uIDUuMSBvZiBldGhlcmV1bWpzLXV0aWxzIHdvdWxkIGhhdmUgcmV0dXJuZWQgJzB4WScgZm9yIGlucHV0ICd5J1xuICAgIC8vIGJ1dCB3ZSBzaG91bGRuJ3Qgd2FzdGUgZWZmb3J0IHRyeWluZyB0byBjaGFuZ2UgY2FzZSBvbiBhIGNsZWFybHkgaW52YWxpZFxuICAgIC8vIHN0cmluZy4gSW5zdGVhZCBqdXN0IHJldHVybiB0aGUgaGV4IHByZWZpeGVkIG9yaWdpbmFsIHN0cmluZyB3aGljaCBtb3N0XG4gICAgLy8gY2xvc2VseSBtaW1pY3MgdGhlIG9yaWdpbmFsIGJlaGF2aW9yLlxuICAgIHJldHVybiBoZXhQcmVmaXhlZDtcbiAgfVxuICByZXR1cm4gdG9DaGVja3N1bUFkZHJlc3MoaGV4UHJlZml4ZWQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIZXhQcmVmaXgoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIGlzSGV4UHJlZml4ZWQoc3RyKSA/IHN0ci5zbGljZSgyKSA6IHN0cjtcbn1cbiIsImltcG9ydCBicm93c2VyIGZyb20gJ3dlYmV4dGVuc2lvbi1wb2x5ZmlsbCc7XHJcblxyXG5leHBvcnQgY29uc3QgaXNNYW5pZmVzdFYzID1cclxuICBicm93c2VyLnJ1bnRpbWUuZ2V0TWFuaWZlc3QoKS5tYW5pZmVzdF92ZXJzaW9uID09PSAzO1xyXG4iLCJpbXBvcnQgeyBDSEFJTl9JRFMsIE1BWF9TQUZFX0NIQUlOX0lEIH0gZnJvbSAnLi4vY29uc3RhbnRzL25ldHdvcmsnO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBudW1iZXIgcHJpbWl0aXZlIGNoYWluIElEIGlzIHNhZmUuXHJcbiAqIEJlY2F1c2Ugc29tZSBjcnlwdG9ncmFwaGljIGxpYnJhcmllcyB3ZSB1c2UgZXhwZWN0IHRoZSBjaGFpbiBJRCB0byBiZSBhXHJcbiAqIG51bWJlciBwcmltaXRpdmUsIGl0IG11c3Qgbm90IGV4Y2VlZCBhIGNlcnRhaW4gc2l6ZS5cclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGNoYWluSWQgLSBUaGUgY2hhaW4gSUQgdG8gY2hlY2sgZm9yIHNhZmV0eS5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGdpdmVuIGNoYWluIElEIGlzIHNhZmUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZlQ2hhaW5JZChjaGFpbklkKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKGNoYWluSWQpICYmIGNoYWluSWQgPiAwICYmIGNoYWluSWQgPD0gTUFYX1NBRkVfQ0hBSU5fSURcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgMHgtcHJlZml4ZWQsIG5vbi16ZXJvLCBub24temVyby1wYWRkZWQsXHJcbiAqIGhleGFkZWNpbWFsIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNoZWNrLlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgYSBjb3JyZWN0bHkgZm9ybWF0dGVkIGhleCBzdHJpbmcsXHJcbiAqIGZhbHNlIG90aGVyd2lzZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1ByZWZpeGVkRm9ybWF0dGVkSGV4U3RyaW5nKHZhbHVlKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcbiAgcmV0dXJuIC9eMHhbMS05YS1mXStbMC05YS1mXSokL2l1LnRlc3QodmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdG9rZW4gZGV0ZWN0aW9uIGlzIGVuYWJsZWQgZm9yIGNlcnRhaW4gbmV0d29ya3NcclxuICpcclxuICogQHBhcmFtIGNoYWluSWQgLSBDaGFpbklEIG9mIG5ldHdvcmtcclxuICogQHJldHVybnMgV2hldGhlciB0aGUgY3VycmVudCBuZXR3b3JrIHN1cHBvcnRzIHRva2VuIGRldGVjdGlvblxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5EZXRlY3Rpb25FbmFibGVkRm9yTmV0d29yayhjaGFpbklkKSB7XHJcbiAgc3dpdGNoIChjaGFpbklkKSB7XHJcbiAgICBjYXNlIENIQUlOX0lEUy5NQUlOTkVUOlxyXG4gICAgY2FzZSBDSEFJTl9JRFMuQlNDOlxyXG4gICAgY2FzZSBDSEFJTl9JRFMuUE9MWUdPTjpcclxuICAgIGNhc2UgQ0hBSU5fSURTLkFWQUxBTkNIRTpcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcbiIsIi8qKlxyXG4gKiBSZXR1cm4gYSBcIm1hc2tlZFwiIGNvcHkgb2YgdGhlIGdpdmVuIG9iamVjdC5cclxuICpcclxuICogVGhlIHJldHVybmVkIG9iamVjdCBpbmNsdWRlcyBvbmx5IHRoZSBwcm9wZXJ0aWVzIHByZXNlbnQgaW4gdGhlIG1hc2suIFRoZVxyXG4gKiBtYXNrIGlzIGFuIG9iamVjdCB0aGF0IG1pcnJvcnMgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LCBleGNlcHRcclxuICogdGhlIG9ubHkgdmFsdWVzIGFyZSBgdHJ1ZWAgb3IgYSBzdWItbWFzay4gYHRydWVgIGltcGxpZXMgdGhlIHByb3BlcnR5XHJcbiAqIHNob3VsZCBiZSBpbmNsdWRlZCwgYW5kIGEgc3ViLW1hc2sgaW1wbGllcyB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGZ1cnRoZXJcclxuICogbWFza2VkIGFjY29yZGluZyB0byB0aGF0IHN1Yi1tYXNrLlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IC0gVGhlIG9iamVjdCB0byBtYXNrXHJcbiAqIEBwYXJhbSB7T2JqZWN0PG9iamVjdCB8IGJvb2xlYW4+fSBtYXNrIC0gVGhlIG1hc2sgdG8gYXBwbHkgdG8gdGhlIG9iamVjdFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hc2tPYmplY3Qob2JqZWN0LCBtYXNrKSB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkucmVkdWNlKChzdGF0ZSwga2V5KSA9PiB7XHJcbiAgICBpZiAobWFza1trZXldID09PSB0cnVlKSB7XHJcbiAgICAgIHN0YXRlW2tleV0gPSBvYmplY3Rba2V5XTtcclxuICAgIH0gZWxzZSBpZiAobWFza1trZXldKSB7XHJcbiAgICAgIHN0YXRlW2tleV0gPSBtYXNrT2JqZWN0KG9iamVjdFtrZXldLCBtYXNrW2tleV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN0YXRlO1xyXG4gIH0sIHt9KTtcclxufVxyXG4iLCJjb25zdCBNQVggPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcclxuXHJcbmxldCBpZENvdW50ZXIgPSBNYXRoLnJvdW5kKE1hdGgucmFuZG9tKCkgKiBNQVgpO1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVSYW5kb21JZCgpIHtcclxuICBpZENvdW50ZXIgJT0gTUFYO1xyXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wbHVzcGx1c1xyXG4gIHJldHVybiBpZENvdW50ZXIrKztcclxufVxyXG4iLCJpbXBvcnQgZ2V0RmV0Y2hXaXRoVGltZW91dCBmcm9tICcuL2ZldGNoLXdpdGgtdGltZW91dCc7XHJcblxyXG5jb25zdCBmZXRjaFdpdGhUaW1lb3V0ID0gZ2V0RmV0Y2hXaXRoVGltZW91dCgpO1xyXG5cclxuLyoqXHJcbiAqIE1ha2VzIGEgSlNPTiBSUEMgcmVxdWVzdCB0byB0aGUgZ2l2ZW4gVVJMLCB3aXRoIHRoZSBnaXZlbiBSUEMgbWV0aG9kIGFuZCBwYXJhbXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBycGNVcmwgLSBUaGUgUlBDIGVuZHBvaW50IFVSTCB0byB0YXJnZXQuXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBycGNNZXRob2QgLSBUaGUgUlBDIG1ldGhvZCB0byByZXF1ZXN0LlxyXG4gKiBAcGFyYW0ge0FycmF5PHVua25vd24+fSBbcnBjUGFyYW1zXSAtIFRoZSBSUEMgbWV0aG9kIHBhcmFtcy5cclxuICogQHJldHVybnMge1Byb21pc2U8dW5rbm93bnx1bmRlZmluZWQ+fSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIFJQQyBtZXRob2QgY2FsbCxcclxuICogb3IgdGhyb3dzIGFuIGVycm9yIGluIGNhc2Ugb2YgZmFpbHVyZS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBqc29uUnBjUmVxdWVzdChycGNVcmwsIHJwY01ldGhvZCwgcnBjUGFyYW1zID0gW10pIHtcclxuICBsZXQgZmV0Y2hVcmwgPSBycGNVcmw7XHJcbiAgY29uc3QgaGVhZGVycyA9IHtcclxuICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgfTtcclxuICAvLyBDb252ZXJ0IGJhc2ljIGF1dGggVVJMIGNvbXBvbmVudCB0byBBdXRob3JpemF0aW9uIGhlYWRlclxyXG4gIGNvbnN0IHsgb3JpZ2luLCBwYXRobmFtZSwgdXNlcm5hbWUsIHBhc3N3b3JkLCBzZWFyY2ggfSA9IG5ldyBVUkwocnBjVXJsKTtcclxuICAvLyBVUkxzIGNvbnRhaW5pbmcgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIG5lZWRzIHNwZWNpYWwgcHJvY2Vzc2luZ1xyXG4gIGlmICh1c2VybmFtZSAmJiBwYXNzd29yZCkge1xyXG4gICAgY29uc3QgZW5jb2RlZEF1dGggPSBCdWZmZXIuZnJvbShgJHt1c2VybmFtZX06JHtwYXNzd29yZH1gKS50b1N0cmluZyhcclxuICAgICAgJ2Jhc2U2NCcsXHJcbiAgICApO1xyXG4gICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJhc2ljICR7ZW5jb2RlZEF1dGh9YDtcclxuICAgIGZldGNoVXJsID0gYCR7b3JpZ2lufSR7cGF0aG5hbWV9JHtzZWFyY2h9YDtcclxuICB9XHJcbiAgY29uc3QganNvblJwY1Jlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChmZXRjaFVybCwge1xyXG4gICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgIGlkOiBEYXRlLm5vdygpLnRvU3RyaW5nKCksXHJcbiAgICAgIGpzb25ycGM6ICcyLjAnLFxyXG4gICAgICBtZXRob2Q6IHJwY01ldGhvZCxcclxuICAgICAgcGFyYW1zOiBycGNQYXJhbXMsXHJcbiAgICB9KSxcclxuICAgIGhlYWRlcnMsXHJcbiAgICBjYWNoZTogJ2RlZmF1bHQnLFxyXG4gIH0pLnRoZW4oKGh0dHBSZXNwb25zZSkgPT4gaHR0cFJlc3BvbnNlLmpzb24oKSk7XHJcblxyXG4gIGlmIChcclxuICAgICFqc29uUnBjUmVzcG9uc2UgfHxcclxuICAgIEFycmF5LmlzQXJyYXkoanNvblJwY1Jlc3BvbnNlKSB8fFxyXG4gICAgdHlwZW9mIGpzb25ScGNSZXNwb25zZSAhPT0gJ29iamVjdCdcclxuICApIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihgUlBDIGVuZHBvaW50ICR7cnBjVXJsfSByZXR1cm5lZCBub24tb2JqZWN0IHJlc3BvbnNlLmApO1xyXG4gIH1cclxuICBjb25zdCB7IGVycm9yLCByZXN1bHQgfSA9IGpzb25ScGNSZXNwb25zZTtcclxuXHJcbiAgaWYgKGVycm9yKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3I/Lm1lc3NhZ2UgfHwgZXJyb3IpO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbiIsImltcG9ydCB7IFBhcnNlZE1lc3NhZ2UgfSBmcm9tICdAc3BydWNlaWQvc2l3ZS1wYXJzZXInO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBzdHJpcEhleFByZWZpeCB9IGZyb20gJy4vaGV4c3RyaW5nLXV0aWxzJztcblxuY29uc3QgbXNnSGV4VG9UZXh0ID0gKGhleCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHN0cmlwcGVkID0gc3RyaXBIZXhQcmVmaXgoaGV4KTtcbiAgICBjb25zdCBidWZmID0gQnVmZmVyLmZyb20oc3RyaXBwZWQsICdoZXgnKTtcbiAgICByZXR1cm4gYnVmZi5sZW5ndGggPT09IDMyID8gaGV4IDogYnVmZi50b1N0cmluZygndXRmOCcpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9nLmVycm9yKGUpO1xuICAgIHJldHVybiBoZXg7XG4gIH1cbn07XG5cbi8qKlxuICogQSBsb2NhbGx5IGRlZmluZWQgb2JqZWN0IHVzZWQgdG8gcHJvdmlkZSBkYXRhIHRvIGlkZW50aWZ5IGEgU2lnbi1JbiBXaXRoIEV0aGVyZXVtIChTSVdFKShFSVAtNDM2MSkgbWVzc2FnZSBhbmQgcHJvdmlkZSB0aGUgcGFyc2VkIG1lc3NhZ2VcbiAqXG4gKiBAdHlwZWRlZiBsb2NhbFNJV0VPYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTSVdFTWVzc2FnZSAtIERvZXMgdGhlIGludGVyY2VwdGVkIG1lc3NhZ2UgY29uZm9ybSB0byB0aGUgU0lXRSBzcGVjaWZpY2F0aW9uP1xuICogQHBhcmFtIHtQYXJzZWRNZXNzYWdlfSBwYXJzZWRNZXNzYWdlIC0gVGhlIGRhdGEgcGFyc2VkIG91dCBvZiB0aGUgbWVzc2FnZVxuICovXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpbnRlcmNlcHRzIGEgc2lnbiBtZXNzYWdlLCBkZXRlY3RzIGlmIGl0J3MgYVxuICogU2lnbi1JbiBXaXRoIEV0aGVyZXVtIChTSVdFKShFSVAtNDM2MSkgbWVzc2FnZSwgYW5kIHJldHVybnMgYW4gb2JqZWN0IHdpdGhcbiAqIHJlbGV2YW50IFNJV0UgZGF0YS5cbiAqXG4gKiB7QHNlZSB7QGxpbmsgaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC00MzYxfX1cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbXNnUGFyYW1zIC0gVGhlIHBhcmFtcyBvZiB0aGUgbWVzc2FnZSB0byBzaWduXG4gKiBAcmV0dXJucyB7bG9jYWxTSVdFT2JqZWN0fVxuICovXG5leHBvcnQgY29uc3QgZGV0ZWN0U0lXRSA9IChtc2dQYXJhbXMpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGRhdGEgfSA9IG1zZ1BhcmFtcztcbiAgICBjb25zdCBtZXNzYWdlID0gbXNnSGV4VG9UZXh0KGRhdGEpO1xuICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBuZXcgUGFyc2VkTWVzc2FnZShtZXNzYWdlKTtcblxuICAgIHJldHVybiB7XG4gICAgICBpc1NJV0VNZXNzYWdlOiB0cnVlLFxuICAgICAgcGFyc2VkTWVzc2FnZSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIGlnbm9yZSBlcnJvciwgaXQncyBub3QgYSB2YWxpZCBTSVdFIG1lc3NhZ2VcbiAgICByZXR1cm4ge1xuICAgICAgaXNTSVdFTWVzc2FnZTogZmFsc2UsXG4gICAgICBwYXJzZWRNZXNzYWdlOiBudWxsLFxuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICogVGFrZXMgaW4gYSBwYXJzZWQgU2lnbi1JbiB3aXRoIEV0aGVyZXVtIE1lc3NhZ2UgKEVJUC00MzYxKVxuICogYW5kIGdlbmVyYXRlcyBhbiBhcnJheSBvZiBsYWJlbC12YWx1ZSBwYWlyc1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJzZWRNZXNzYWdlIC0gQSBwYXJzZWQgU0lXRSBtZXNzYWdlIHdpdGggbWVzc2FnZSBjb250ZW50c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gdCAtIGkxOG4gZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgbGFiZWwtdmFsdWUgcGFpcnMgd2l0aCB0aGUgdHlwZSBvZiB0aGUgdmFsdWUgYXMgdGhlIGxhYmVsXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JtYXRNZXNzYWdlUGFyYW1zID0gKHBhcnNlZE1lc3NhZ2UsIHQpID0+IHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG5cbiAgY29uc3Qge1xuICAgIHN0YXRlbWVudCxcbiAgICB1cmksXG4gICAgdmVyc2lvbixcbiAgICBjaGFpbklkLFxuICAgIG5vbmNlLFxuICAgIGlzc3VlZEF0LFxuICAgIGV4cGlyYXRpb25UaW1lLFxuICAgIG5vdEJlZm9yZSxcbiAgICByZXF1ZXN0SWQsXG4gICAgcmVzb3VyY2VzLFxuICB9ID0gcGFyc2VkTWVzc2FnZTtcblxuICBpZiAoc3RhdGVtZW50KSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbE1lc3NhZ2UnKSxcbiAgICAgIHZhbHVlOiBzdGF0ZW1lbnQsXG4gICAgfSk7XG4gIH1cblxuICBpZiAodXJpKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbFVSSScpLFxuICAgICAgdmFsdWU6IHVyaSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmICh2ZXJzaW9uKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbFZlcnNpb24nKSxcbiAgICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGNoYWluSWQpIHtcbiAgICBvdXRwdXQucHVzaCh7XG4gICAgICBsYWJlbDogdCgnU0lXRUxhYmVsQ2hhaW5JRCcpLFxuICAgICAgdmFsdWU6IGNoYWluSWQsXG4gICAgfSk7XG4gIH1cblxuICBpZiAobm9uY2UpIHtcbiAgICBvdXRwdXQucHVzaCh7XG4gICAgICBsYWJlbDogdCgnU0lXRUxhYmVsTm9uY2UnKSxcbiAgICAgIHZhbHVlOiBub25jZSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc3N1ZWRBdCkge1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIGxhYmVsOiB0KCdTSVdFTGFiZWxJc3N1ZWRBdCcpLFxuICAgICAgdmFsdWU6IGlzc3VlZEF0LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbEV4cGlyYXRpb25UaW1lJyksXG4gICAgICB2YWx1ZTogZXhwaXJhdGlvblRpbWUsXG4gICAgfSk7XG4gIH1cblxuICBpZiAobm90QmVmb3JlKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbE5vdEJlZm9yZScpLFxuICAgICAgdmFsdWU6IG5vdEJlZm9yZSxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXF1ZXN0SWQpIHtcbiAgICBvdXRwdXQucHVzaCh7XG4gICAgICBsYWJlbDogdCgnU0lXRUxhYmVsUmVxdWVzdElEJyksXG4gICAgICB2YWx1ZTogcmVxdWVzdElkLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc291cmNlcyAmJiByZXNvdXJjZXMubGVuZ3RoID4gMCkge1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIGxhYmVsOiB0KCdTSVdFTGFiZWxSZXNvdXJjZXMnLCBbcmVzb3VyY2VzLmxlbmd0aF0pLFxuICAgICAgdmFsdWU6IHJlc291cmNlc1xuICAgICAgICAucmVkdWNlKChwcmV2aW91cywgcmVzb3VyY2UpID0+IGAke3ByZXZpb3VzfSR7cmVzb3VyY2V9XFxuYCwgJycpXG4gICAgICAgIC50cmltKCksXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufTtcbiIsImV4cG9ydCBmdW5jdGlvbiBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKHZhbHVlMSwgdmFsdWUyKSB7XHJcbiAgaWYgKHR5cGVvZiB2YWx1ZTEgIT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZTIgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiB2YWx1ZTEudG9Mb3dlckNhc2UoKSA9PT0gdmFsdWUyLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBwcmVwZW5kWmVybyhudW0sIG1heExlbmd0aCkge1xyXG4gIHJldHVybiBudW0udG9TdHJpbmcoKS5wYWRTdGFydChtYXhMZW5ndGgsICcwJyk7XHJcbn1cclxuIiwiaW1wb3J0IHsgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUCB9IGZyb20gJy4uL2NvbnN0YW50cy9zd2Fwcyc7XHJcblxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIHByb3ZpZGVkIGFkZHJlc3MgaXMgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIGFkZHJlc3MgZm9yXHJcbiAqIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIG9mIHRoZSBwcm92aWRlZCBjaGFpbi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgc3RyaW5nIHRvIGNvbXBhcmUgdG8gdGhlIGRlZmF1bHQgdG9rZW4gYWRkcmVzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBoZXggZW5jb2RlZCBjaGFpbiBJRCBvZiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgYWRkcmVzcyBpcyB0aGUgcHJvdmlkZWQgY2hhaW4ncyBkZWZhdWx0IHRva2VuIGFkZHJlc3NcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N3YXBzRGVmYXVsdFRva2VuQWRkcmVzcyhhZGRyZXNzLCBjaGFpbklkKSB7XHJcbiAgaWYgKCFhZGRyZXNzIHx8ICFjaGFpbklkKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYWRkcmVzcyA9PT0gU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUFtjaGFpbklkXT8uYWRkcmVzcztcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBzeW1ib2wgaXMgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIHN5bWJvbCBmb3JcclxuICogdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gb2YgdGhlIHByb3ZpZGVkIGNoYWluLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ltYm9sIC0gVGhlIHN0cmluZyB0byBjb21wYXJlIHRvIHRoZSBkZWZhdWx0IHRva2VuIHN5bWJvbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2hhaW5JZCAtIFRoZSBoZXggZW5jb2RlZCBjaGFpbiBJRCBvZiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciB0aGUgc3ltYmwgaXMgdGhlIHByb3ZpZGVkIGNoYWluJ3MgZGVmYXVsdCB0b2tlbiBzeW1ib2xcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N3YXBzRGVmYXVsdFRva2VuU3ltYm9sKHN5bWJvbCwgY2hhaW5JZCkge1xyXG4gIGlmICghc3ltYm9sIHx8ICFjaGFpbklkKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3ltYm9sID09PSBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQW2NoYWluSWRdPy5zeW1ib2w7XHJcbn1cclxuIiwiaW1wb3J0IHsgaXNIZXhTdHJpbmcgfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xyXG5pbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xyXG5pbXBvcnQgeyBhYmlFUkM3MjEsIGFiaUVSQzIwLCBhYmlFUkMxMTU1IH0gZnJvbSAnQG1ldGFtYXNrL21ldGFtYXNrLWV0aC1hYmlzJztcclxuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCB7XHJcbiAgQVNTRVRfVFlQRVMsXHJcbiAgVE9LRU5fU1RBTkRBUkRTLFxyXG4gIFRSQU5TQUNUSU9OX1RZUEVTLFxyXG59IGZyb20gJy4uL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XHJcbmltcG9ydCB7IHJlYWRBZGRyZXNzQXNDb250cmFjdCB9IGZyb20gJy4vY29udHJhY3QtdXRpbHMnO1xyXG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi9zdHJpbmctdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIHsgJ3RyYW5zZmVyJyB8ICdhcHByb3ZlJyB8ICdzZXRhcHByb3ZhbGZvcmFsbCcgfCAndHJhbnNmZXJmcm9tJyB8ICdjb250cmFjdEludGVyYWN0aW9uJ3wgJ3NpbXBsZVNlbmQnIH0gSW5mZXJyYWJsZVRyYW5zYWN0aW9uVHlwZXNcclxuICovXHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gSW5mZXJUcmFuc2FjdGlvblR5cGVSZXN1bHRcclxuICogQHByb3BlcnR5IHtJbmZlcnJhYmxlVHJhbnNhY3Rpb25UeXBlc30gdHlwZSAtIFRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnZXRDb2RlUmVzcG9uc2UgLSBUaGUgY29udHJhY3QgY29kZSwgaW4gaGV4IGZvcm1hdCBpZlxyXG4gKiAgaXQgZXhpc3RzLiAnMHgwJyBvciAnMHgnIGFyZSBhbHNvIGluZGljYXRvcnMgb2Ygbm9uLWV4aXN0ZW50IGNvbnRyYWN0XHJcbiAqICBjb2RlXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEB0eXBlZGVmIEV0aGVyc0NvbnRyYWN0Q2FsbFxyXG4gKiBAdHlwZSBvYmplY3RcclxuICogQHByb3BlcnR5IHthbnlbXX0gYXJncyAtIFRoZSBhcmdzL3BhcmFtcyB0byB0aGUgZnVuY3Rpb24gY2FsbC5cclxuICogQW4gYXJyYXktbGlrZSBvYmplY3Qgd2l0aCBudW1lcmljYWwgYW5kIHN0cmluZyBpbmRpY2VzLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ25hdHVyZSAtIFRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaWdoYXNoIC0gVGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBoYXNoLlxyXG4gKiBAcHJvcGVydHkge0V0aGVyc0JpZ051bWJlcn0gdmFsdWUgLSBUaGUgRVRIIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsbC5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbkZyYWdtZW50fSBmdW5jdGlvbkZyYWdtZW50IC0gVGhlIEV0aGVycyBmdW5jdGlvbiBmcmFnbWVudFxyXG4gKiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuY29uc3QgZXJjMjBJbnRlcmZhY2UgPSBuZXcgZXRoZXJzLnV0aWxzLkludGVyZmFjZShhYmlFUkMyMCk7XHJcbmNvbnN0IGVyYzcyMUludGVyZmFjZSA9IG5ldyBldGhlcnMudXRpbHMuSW50ZXJmYWNlKGFiaUVSQzcyMSk7XHJcbmNvbnN0IGVyYzExNTVJbnRlcmZhY2UgPSBuZXcgZXRoZXJzLnV0aWxzLkludGVyZmFjZShhYmlFUkMxMTU1KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrKHRyYW5zYWN0aW9uLCBjaGFpbklkLCBuZXR3b3JrSWQpIHtcclxuICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uLmNoYWluSWQgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uY2hhaW5JZCA9PT0gY2hhaW5JZDtcclxuICB9XHJcbiAgcmV0dXJuIHRyYW5zYWN0aW9uLm1ldGFtYXNrTmV0d29ya0lkID09PSBuZXR3b3JrSWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIGZpZWxkcyBhcmUgc3VwcGxpZWRcclxuICogYW5kIHZhbGlkIGlucHV0cy4gVGhpcyB3aWxsIHJldHVybiBmYWxzZSBmb3Igbm9uIGhleCBzdHJpbmcgaW5wdXRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbnN0YW50cy90cmFuc2FjdGlvblwiKS5UcmFuc2FjdGlvbk1ldGF9IHRyYW5zYWN0aW9uIC1cclxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0cmFuc2FjdGlvbiB1c2VzIHZhbGlkIEVJUDE1NTkgZmllbGRzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNFSVAxNTU5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcclxuICByZXR1cm4gKFxyXG4gICAgaXNIZXhTdHJpbmcodHJhbnNhY3Rpb24/LnR4UGFyYW1zPy5tYXhGZWVQZXJHYXMpICYmXHJcbiAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbj8udHhQYXJhbXM/Lm1heFByaW9yaXR5RmVlUGVyR2FzKVxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgaWYgdGhlIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgZmllbGRzIGFyZSBub3RcclxuICogc3VwcGxpZWQgYW5kIHRoYXQgdGhlIGdhc1ByaWNlIGZpZWxkIGlzIHZhbGlkIGlmIGl0IGlzIHByb3ZpZGVkLiBUaGlzIHdpbGxcclxuICogcmV0dXJuIGZhbHNlIGlmIGdhc1ByaWNlIGlzIGEgbm9uIGhleCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxyXG4gKiAgdGhlIHRyYW5zYWN0aW9uIHRvIGNoZWNrXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRyYW5zYWN0aW9uIHVzZXMgdmFsaWQgTGVnYWN5IGZpZWxkcyBPUiBsYWNrc1xyXG4gKiAgRUlQMTU1OSBmaWVsZHNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0xlZ2FjeVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XHJcbiAgcmV0dXJuIChcclxuICAgIHR5cGVvZiB0cmFuc2FjdGlvbi50eFBhcmFtcy5tYXhGZWVQZXJHYXMgPT09ICd1bmRlZmluZWQnICYmXHJcbiAgICB0eXBlb2YgdHJhbnNhY3Rpb24udHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAodHlwZW9mIHRyYW5zYWN0aW9uLnR4UGFyYW1zLmdhc1ByaWNlID09PSAndW5kZWZpbmVkJyB8fFxyXG4gICAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbi50eFBhcmFtcy5nYXNQcmljZSkpXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZSBpZiBhIHRyYW5zYWN0aW9ucyBnYXMgZmVlcyBpbiB0eFBhcmFtcyBtYXRjaCB0aG9zZSBpbiBpdHMgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgcHJvcGVydHlcclxuICpcclxuICogQHBhcmFtIHtpbXBvcnQoXCIuLi9jb25zdGFudHMvdHJhbnNhY3Rpb25cIikuVHJhbnNhY3Rpb25NZXRhfSB0cmFuc2FjdGlvbiAtXHJcbiAqICB0aGUgdHJhbnNhY3Rpb24gdG8gY2hlY2tcclxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYm90aCB0aGUgdHhQYXJhbXMgYW5kIGRhcHBTdWdnZXN0ZWRHYXNGZWVzIGFyZSBvYmplY3RzIHdpdGggdHJ1dGh5IGdhcyBmZWUgcHJvcGVydGllcyxcclxuICogICBhbmQgdGhvc2UgcHJvcGVydGllcyBhcmUgc3RyaWN0bHkgZXF1YWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB0eFBhcmFtc0FyZURhcHBTdWdnZXN0ZWQodHJhbnNhY3Rpb24pIHtcclxuICBjb25zdCB7IGdhc1ByaWNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzIH0gPVxyXG4gICAgdHJhbnNhY3Rpb24/LnR4UGFyYW1zIHx8IHt9O1xyXG4gIHJldHVybiAoXHJcbiAgICAoZ2FzUHJpY2UgJiYgZ2FzUHJpY2UgPT09IHRyYW5zYWN0aW9uPy5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8uZ2FzUHJpY2UpIHx8XHJcbiAgICAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcclxuICAgICAgbWF4RmVlUGVyR2FzICYmXHJcbiAgICAgIHRyYW5zYWN0aW9uPy5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8ubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09XHJcbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcclxuICAgICAgdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5tYXhGZWVQZXJHYXMgPT09IG1heEZlZVBlckdhcylcclxuICApO1xyXG59XHJcblxyXG4vKipcclxuICogQXR0ZW1wdHMgdG8gZGVjb2RlIHRyYW5zYWN0aW9uIGRhdGEgdXNpbmcgQUJJcyBmb3IgdGhyZWUgZGlmZmVyZW50IHRva2VuIHN0YW5kYXJkczogRVJDMjAsIEVSQzcyMSwgRVJDMTE1NS5cclxuICogVGhlIGRhdGEgd2lsbCBkZWNvZGUgY29ycmVjdGx5IGlmIHRoZSB0cmFuc2FjdGlvbiBpcyBhbiBpbnRlcmFjdGlvbiB3aXRoIGEgY29udHJhY3QgdGhhdCBtYXRjaGVzIG9uZSBvZiB0aGVzZVxyXG4gKiBjb250cmFjdCBzdGFuZGFyZHNcclxuICpcclxuICogQHBhcmFtIGRhdGEgLSBlbmNvZGVkIHRyYW5zYWN0aW9uIGRhdGFcclxuICogQHJldHVybnMge0V0aGVyc0NvbnRyYWN0Q2FsbCB8IHVuZGVmaW5lZH1cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEoZGF0YSkge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZXJjMjBJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICAvLyBpZ25vcmUgYW5kIG5leHQgdHJ5IHRvIHBhcnNlIHdpdGggZXJjNzIxIEFCSVxyXG4gIH1cclxuXHJcbiAgdHJ5IHtcclxuICAgIHJldHVybiBlcmM3MjFJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICAvLyBpZ25vcmUgYW5kIG5leHQgdHJ5IHRvIHBhcnNlIHdpdGggZXJjMTE1NSBBQklcclxuICB9XHJcblxyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gZXJjMTE1NUludGVyZmFjZS5wYXJzZVRyYW5zYWN0aW9uKHsgZGF0YSB9KTtcclxuICB9IGNhdGNoIHtcclxuICAgIC8vIGlnbm9yZSBhbmQgcmV0dXJuIHVuZGVmaW5lZFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldGVybWluZXMgdGhlIGNvbnRyYWN0Q29kZSBvZiB0aGUgdHJhbnNhY3Rpb24gYnkgYW5hbHl6aW5nIHRoZSB0eFBhcmFtcy5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHR4UGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIHRyYW5zYWN0aW9uXHJcbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcclxuICogQHJldHVybnMge0luZmVyVHJhbnNhY3Rpb25UeXBlUmVzdWx0fVxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uQ29udHJhY3RDb2RlKHR4UGFyYW1zLCBxdWVyeSkge1xyXG4gIGNvbnN0IHsgdG8gfSA9IHR4UGFyYW1zO1xyXG4gIGNvbnN0IHsgY29udHJhY3RDb2RlIH0gPSBhd2FpdCByZWFkQWRkcmVzc0FzQ29udHJhY3QocXVlcnksIHRvKTtcclxuICByZXR1cm4gY29udHJhY3RDb2RlO1xyXG59XHJcblxyXG4vKipcclxuICogRGV0ZXJtaW5lcyB0aGUgdHlwZSBvZiB0aGUgdHJhbnNhY3Rpb24gYnkgYW5hbHl6aW5nIHRoZSB0eFBhcmFtcy5cclxuICogVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gb25lIG9mIHRoZSB0eXBlcyBkZWZpbmVkIGluIHNoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb25zXHJcbiAqIEl0IHdpbGwgbmV2ZXIgcmV0dXJuIFRSQU5TQUNUSU9OX1RZUEVfQ0FOQ0VMIG9yIFRSQU5TQUNUSU9OX1RZUEVfUkVUUlkgYXMgdGhlc2VcclxuICogcmVwcmVzZW50IHNwZWNpZmljIGV2ZW50cyB0aGF0IHdlIGNvbnRyb2wgZnJvbSB0aGUgZXh0ZW5zaW9uIGFuZCBhcmUgYWRkZWQgbWFudWFsbHlcclxuICogYXQgdHJhbnNhY3Rpb24gY3JlYXRpb24uXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eFBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSB0cmFuc2FjdGlvblxyXG4gKiBAcGFyYW0ge0V0aFF1ZXJ5fSBxdWVyeSAtIEV0aFF1ZXJ5IGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHtJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdH1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVUcmFuc2FjdGlvblR5cGUodHhQYXJhbXMsIHF1ZXJ5KSB7XHJcbiAgY29uc3QgeyBkYXRhLCB0byB9ID0gdHhQYXJhbXM7XHJcbiAgbGV0IG5hbWU7XHJcbiAgdHJ5IHtcclxuICAgICh7IG5hbWUgfSA9IGRhdGEgJiYgcGFyc2VTdGFuZGFyZFRva2VuVHJhbnNhY3Rpb25EYXRhKGRhdGEpKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgbG9nLmRlYnVnKCdGYWlsZWQgdG8gcGFyc2UgdHJhbnNhY3Rpb24gZGF0YS4nLCBlcnJvciwgZGF0YSk7XHJcbiAgfVxyXG5cclxuICBsZXQgcmVzdWx0O1xyXG4gIGxldCBjb250cmFjdENvZGU7XHJcblxyXG4gIGlmIChkYXRhICYmICF0bykge1xyXG4gICAgcmVzdWx0ID0gVFJBTlNBQ1RJT05fVFlQRVMuREVQTE9ZX0NPTlRSQUNUO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjb25zdCB7IGNvbnRyYWN0Q29kZTogcmVzdWx0Q29kZSwgaXNDb250cmFjdEFkZHJlc3MgfSA9XHJcbiAgICAgIGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChxdWVyeSwgdG8pO1xyXG5cclxuICAgIGNvbnRyYWN0Q29kZSA9IHJlc3VsdENvZGU7XHJcblxyXG4gICAgaWYgKGlzQ29udHJhY3RBZGRyZXNzKSB7XHJcbiAgICAgIGNvbnN0IHRva2VuTWV0aG9kTmFtZSA9IFtcclxuICAgICAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfQVBQUk9WRSxcclxuICAgICAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfU0VUX0FQUFJPVkFMX0ZPUl9BTEwsXHJcbiAgICAgICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSLFxyXG4gICAgICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUl9GUk9NLFxyXG4gICAgICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TQUZFX1RSQU5TRkVSX0ZST00sXHJcbiAgICAgIF0uZmluZCgobWV0aG9kTmFtZSkgPT4gaXNFcXVhbENhc2VJbnNlbnNpdGl2ZShtZXRob2ROYW1lLCBuYW1lKSk7XHJcblxyXG4gICAgICByZXN1bHQgPVxyXG4gICAgICAgIGRhdGEgJiYgdG9rZW5NZXRob2ROYW1lXHJcbiAgICAgICAgICA/IHRva2VuTWV0aG9kTmFtZVxyXG4gICAgICAgICAgOiBUUkFOU0FDVElPTl9UWVBFUy5DT05UUkFDVF9JTlRFUkFDVElPTjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlc3VsdCA9IFRSQU5TQUNUSU9OX1RZUEVTLlNJTVBMRV9TRU5EO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHsgdHlwZTogcmVzdWx0LCBnZXRDb2RlUmVzcG9uc2U6IGNvbnRyYWN0Q29kZSB9O1xyXG59XHJcblxyXG5jb25zdCBJTkZFUlJBQkxFX1RSQU5TQUNUSU9OX1RZUEVTID0gW1xyXG4gIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFLFxyXG4gIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTCxcclxuICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVIsXHJcbiAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST00sXHJcbiAgVFJBTlNBQ1RJT05fVFlQRVMuQ09OVFJBQ1RfSU5URVJBQ1RJT04sXHJcbiAgVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQsXHJcbl07XHJcblxyXG4vKipcclxuICogR2l2ZW4gYSB0cmFuc2FjdGlvbiBtZXRhIG9iamVjdCwgZGV0ZXJtaW5lIHRoZSBhc3NldCB0eXBlIHRoYXQgdGhlXHJcbiAqIHRyYW5zYWN0aW9uIGlzIGRlYWxpbmcgd2l0aCwgYXMgd2VsbCBhcyB0aGUgc3RhbmRhcmQgZm9yIHRoZSB0b2tlbiBpZiBpdFxyXG4gKiBpcyBhIHRva2VuIHRyYW5zYWN0aW9uLlxyXG4gKlxyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuVHJhbnNhY3Rpb25NZXRhfSB0eE1ldGEgLVxyXG4gKiAgdHJhbnNhY3Rpb24gbWV0YSBvYmplY3RcclxuICogQHBhcmFtIHtFdGhRdWVyeX0gcXVlcnkgLSBFdGhRdWVyeSBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyAtIGZ1bmN0aW9uIHRvIGdldCB0b2tlblxyXG4gKiAgc3RhbmRhcmRzIGFuZCBkZXRhaWxzLlxyXG4gKiBAcmV0dXJucyB7eyBhc3NldFR5cGU6IHN0cmluZywgdG9rZW5TdGFuZGFyZDogc3RyaW5nfX1cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlcm1pbmVUcmFuc2FjdGlvbkFzc2V0VHlwZShcclxuICB0eE1ldGEsXHJcbiAgcXVlcnksXHJcbiAgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMsXHJcbikge1xyXG4gIC8vIElmIHRoZSB0cmFuc2FjdGlvbiB0eXBlIGlzIGFscmVhZHkgb25lIG9mIHRoZSBpbmZlcnJhYmxlIHR5cGVzLCB0aGVuIHdlIGRvXHJcbiAgLy8gbm90IG5lZWQgdG8gcmUtZXN0YWJsaXNoIHRoZSB0eXBlLlxyXG4gIGxldCBpbmZlcnJhYmxlVHlwZSA9IHR4TWV0YS50eXBlO1xyXG4gIGlmIChJTkZFUlJBQkxFX1RSQU5TQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR4TWV0YS50eXBlKSA9PT0gZmFsc2UpIHtcclxuICAgIC8vIEJlY2F1c2Ugd2Ugd2lsbCBkZWFsIHdpdGggYWxsIHR5cGVzIG9mIHRyYW5zYWN0aW9ucyAoaW5jbHVkaW5nIHN3YXBzKVxyXG4gICAgLy8gd2Ugd2FudCB0byBnZXQgYW4gaW5mZXJyYWJsZSB0eXBlIG9mIHRyYW5zYWN0aW9uIHRoYXQgaXNuJ3Qgc3BlY2lhbCBjYXNlZFxyXG4gICAgLy8gdGhhdCB3YXkgd2UgY2FuIG5hcnJvdyB0aGUgbnVtYmVyIG9mIGxvZ2ljIGdhdGVzIHJlcXVpcmVkLlxyXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGV0ZXJtaW5lVHJhbnNhY3Rpb25UeXBlKHR4TWV0YS50eFBhcmFtcywgcXVlcnkpO1xyXG4gICAgaW5mZXJyYWJsZVR5cGUgPSByZXN1bHQudHlwZTtcclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSBpbmZlcnJlZCB0eXBlIG9mIHRoZSB0cmFuc2FjdGlvbiBpcyBvbmUgb2YgdGhvc2UgdGhhdCBhcmUgcGFydCBvZlxyXG4gIC8vIHRoZSB0b2tlbiBjb250cmFjdCBzdGFuZGFyZHMsIHdlIGNhbiB1c2UgdGhlIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzXHJcbiAgLy8gbWV0aG9kIHRvIGdldCB0aGUgYXNzZXQgdHlwZS5cclxuICBjb25zdCBpc1Rva2VuTWV0aG9kID0gW1xyXG4gICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX0FQUFJPVkUsXHJcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfU0VUX0FQUFJPVkFMX0ZPUl9BTEwsXHJcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVIsXHJcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSxcclxuICBdLmZpbmQoKG1ldGhvZE5hbWUpID0+IG1ldGhvZE5hbWUgPT09IGluZmVycmFibGVUeXBlKTtcclxuXHJcbiAgaWYgKFxyXG4gICAgaXNUb2tlbk1ldGhvZCB8fFxyXG4gICAgLy8gV2UgY2FuIGFsc28gY2hlY2sgYW55IGNvbnRyYWN0IGludGVyYWN0aW9uIHR5cGUgdG8gc2VlIGlmIHRoZSB0byBhZGRyZXNzXHJcbiAgICAvLyBpcyBhIHRva2VuIGNvbnRyYWN0LiBJZiBpdCBpc24ndCwgdGhlbiB0aGUgbWV0aG9kIHdpbGwgdGhyb3cgYW5kIHdlIGNhblxyXG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBvdGhlciBjaGVja3MuXHJcbiAgICBpbmZlcnJhYmxlVHlwZSA9PT0gVFJBTlNBQ1RJT05fVFlQRVMuQ09OVFJBQ1RfSU5URVJBQ1RJT05cclxuICApIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFdlIGRvbid0IG5lZWQgYSBiYWxhbmNlIGNoZWNrLCBzbyB0aGUgc2Vjb25kIHBhcmFtZXRlciB0b1xyXG4gICAgICAvLyBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyBpcyBvbWl0dGVkLlxyXG4gICAgICBjb25zdCBkZXRhaWxzID0gYXdhaXQgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHModHhNZXRhLnR4UGFyYW1zLnRvKTtcclxuICAgICAgaWYgKGRldGFpbHMuc3RhbmRhcmQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgYXNzZXRUeXBlOlxyXG4gICAgICAgICAgICBkZXRhaWxzLnN0YW5kYXJkID09PSBUT0tFTl9TVEFOREFSRFMuRVJDMjBcclxuICAgICAgICAgICAgICA/IEFTU0VUX1RZUEVTLlRPS0VOXHJcbiAgICAgICAgICAgICAgOiBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRSxcclxuICAgICAgICAgIHRva2VuU3RhbmRhcmQ6IGRldGFpbHMuc3RhbmRhcmQsXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCB7XHJcbiAgICAgIC8vIG5vb3AsIFdlIGV4cGVjdCBlcnJvcnMgaGVyZSBidXQgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgdGhlbSBvciBkb1xyXG4gICAgICAvLyBhbnl0aGluZyBpbiByZXNwb25zZS5cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIHRoZSB0cmFuc2FjdGlvbiBpcyBpbnRlcmFjdGluZyB3aXRoIGEgY29udHJhY3QgYnV0IGlzbid0IGEgdG9rZW4gbWV0aG9kXHJcbiAgLy8gd2UgdXNlIHRoZSAnVU5LTk9XTicgdmFsdWUgdG8gc2hvdyB0aGF0IGl0IGlzbid0IGEgdHJhbnNhY3Rpb24gc2VuZGluZyBhbnlcclxuICAvLyBwYXJ0aWN1bGFyIGFzc2V0LlxyXG4gIGlmIChpbmZlcnJhYmxlVHlwZSA9PT0gVFJBTlNBQ1RJT05fVFlQRVMuQ09OVFJBQ1RfSU5URVJBQ1RJT04pIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGFzc2V0VHlwZTogQVNTRVRfVFlQRVMuVU5LTk9XTixcclxuICAgICAgdG9rZW5TdGFuZGFyZDogVE9LRU5fU1RBTkRBUkRTLk5PTkUsXHJcbiAgICB9O1xyXG4gIH1cclxuICByZXR1cm4geyBhc3NldFR5cGU6IEFTU0VUX1RZUEVTLk5BVElWRSwgdG9rZW5TdGFuZGFyZDogVE9LRU5fU1RBTkRBUkRTLk5PTkUgfTtcclxufVxyXG4iLCIvLyBNZXNzYWdlcyBhbmQgZGVzY3JpcHRpb25zIGZvciB0aGVzZSBsb2NhbGUga2V5cyBhcmUgaW4gYXBwL19sb2NhbGVzL2VuL21lc3NhZ2VzLmpzb25cclxuZXhwb3J0IGNvbnN0IFVJX05PVElGSUNBVElPTlMgPSB7XHJcbiAgMToge1xyXG4gICAgaWQ6IDEsXHJcbiAgICBkYXRlOiAnMjAyMS0wMy0xNycsXHJcbiAgICBpbWFnZToge1xyXG4gICAgICBzcmM6ICdpbWFnZXMvbW9iaWxlLWxpbmstcXIuc3ZnJyxcclxuICAgICAgaGVpZ2h0OiAnMjMwcHgnLFxyXG4gICAgICB3aWR0aDogJzIzMHB4JyxcclxuICAgICAgcGxhY2VJbWFnZUJlbG93RGVzY3JpcHRpb246IHRydWUsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgMzoge1xyXG4gICAgaWQ6IDMsXHJcbiAgICBkYXRlOiAnMjAyMS0wMy0wOCcsXHJcbiAgfSxcclxuICA0OiB7XHJcbiAgICBpZDogNCxcclxuICAgIGRhdGU6ICcyMDIxLTA1LTExJyxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy9zb3VyY2UtbG9nb3MtYnNjLnN2ZycsXHJcbiAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgNToge1xyXG4gICAgaWQ6IDUsXHJcbiAgICBkYXRlOiAnMjAyMS0wNi0wOScsXHJcbiAgfSxcclxuICA2OiB7XHJcbiAgICBpZDogNixcclxuICAgIGRhdGU6ICcyMDIxLTA1LTI2JyxcclxuICB9LFxyXG4gIDc6IHtcclxuICAgIGlkOiA3LFxyXG4gICAgZGF0ZTogJzIwMjEtMDktMTcnLFxyXG4gIH0sXHJcbiAgODoge1xyXG4gICAgaWQ6IDgsXHJcbiAgICBkYXRlOiAnMjAyMS0xMS0wMScsXHJcbiAgfSxcclxuICA5OiB7XHJcbiAgICBpZDogOSxcclxuICAgIGRhdGU6ICcyMDIxLTEyLTA3JyxcclxuICAgIGltYWdlOiB7XHJcbiAgICAgIHNyYzogJ2ltYWdlcy90eGluc2lnaHRzLnBuZycsXHJcbiAgICAgIHdpZHRoOiAnODAlJyxcclxuICAgIH0sXHJcbiAgfSxcclxuICAxMDoge1xyXG4gICAgaWQ6IDEwLFxyXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxyXG4gICAgaW1hZ2U6IHtcclxuICAgICAgc3JjOiAnaW1hZ2VzL3Rva2VuLWRldGVjdGlvbi5zdmcnLFxyXG4gICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIDExOiB7XHJcbiAgICBpZDogMTEsXHJcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXHJcbiAgfSxcclxuICAxMjoge1xyXG4gICAgaWQ6IDEyLFxyXG4gICAgZGF0ZTogJzIwMjItMDUtMTgnLFxyXG4gICAgaW1hZ2U6IHtcclxuICAgICAgc3JjOiAnaW1hZ2VzL2Rhcmttb2RlLWJhbm5lci5wbmcnLFxyXG4gICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIDEzOiB7XHJcbiAgICBpZDogMTMsXHJcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXHJcbiAgfSxcclxuICAxNDoge1xyXG4gICAgaWQ6IDE0LFxyXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxyXG4gIH0sXHJcbiAgMTU6IHtcclxuICAgIGlkOiAxNSxcclxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcclxuICB9LFxyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldFRyYW5zbGF0ZWRVSU5vdGlmaWNhdGlvbnMgPSAodCwgbG9jYWxlKSA9PiB7XHJcbiAgY29uc3QgZm9ybWF0dGVkTG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoJ18nLCAnLScpO1xyXG4gIHJldHVybiB7XHJcbiAgICAxOiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMV0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMVRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMURlc2NyaXB0aW9uJyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMV0uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgMzoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzNdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczNUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczNEZXNjcmlwdGlvbicpLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zM0FjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1szXS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICA0OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbNF0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zNFRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zNERlc2NyaXB0aW9uJyksXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnM0QWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzRdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDU6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s1XSxcclxuICAgICAgdGl0bGU6IHQoJ3NlY3JldFJlY292ZXJ5UGhyYXNlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zNURlc2NyaXB0aW9uJyksXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMzQWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzVdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDY6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s2XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM2VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zNkRlc2NyaXB0aW9uT25lJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczZEZXNjcmlwdGlvblR3bycpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM2RGVzY3JpcHRpb25UaHJlZScpLFxyXG4gICAgICBdLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzZdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDc6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s3XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM3VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zN0Rlc2NyaXB0aW9uT25lJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczdEZXNjcmlwdGlvblR3bycpLFxyXG4gICAgICBdLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzddLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDg6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s4XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM4VGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zOERlc2NyaXB0aW9uT25lJyksXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczhEZXNjcmlwdGlvblR3bycpLFxyXG4gICAgICBdLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzhdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zOEFjdGlvblRleHQnKSxcclxuICAgIH0sXHJcbiAgICA5OiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbOV0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zOVRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBbXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczlEZXNjcmlwdGlvbk9uZScpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM5RGVzY3JpcHRpb25Ud28nKSxcclxuICAgICAgXSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s5XS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICAxMDoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzEwXSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxMFRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBbXHJcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczEwRGVzY3JpcHRpb25PbmUnKSxcclxuICAgICAgICB0KCdub3RpZmljYXRpb25zMTBEZXNjcmlwdGlvblR3bycpLFxyXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnMxMERlc2NyaXB0aW9uVGhyZWUnKSxcclxuICAgICAgXSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczEwQWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzEwXS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICAxMToge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzExXSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxMVRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTFEZXNjcmlwdGlvbicpLFxyXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzExXS5kYXRlKSxcclxuICAgICAgKSxcclxuICAgIH0sXHJcbiAgICAxMjoge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzEyXSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxMlRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTJEZXNjcmlwdGlvbicpLFxyXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTJBY3Rpb25UZXh0JyksXHJcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxyXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTJdLmRhdGUpLFxyXG4gICAgICApLFxyXG4gICAgfSxcclxuICAgIDEzOiB7XHJcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTNdLFxyXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczEzVGl0bGUnKSxcclxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxM0Rlc2NyaXB0aW9uJyksXHJcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxM0FjdGlvblRleHQnKSxcclxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXHJcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxM10uZGF0ZSksXHJcbiAgICAgICksXHJcbiAgICB9LFxyXG4gICAgMTQ6IHtcclxuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxNF0sXHJcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTRUaXRsZScpLFxyXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczE0RGVzY3JpcHRpb24nKSxcclxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczE0QWN0aW9uVGV4dCcpLFxyXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzE0XS5kYXRlXHJcbiAgICAgICAgPyBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxNF0uZGF0ZSksXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiAnJyxcclxuICAgIH0sXHJcbiAgICAxNToge1xyXG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzE1XSxcclxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxNVRpdGxlJyksXHJcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTVEZXNjcmlwdGlvbicpLFxyXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzE1XS5kYXRlXHJcbiAgICAgICAgPyBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcclxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxNV0uZGF0ZSksXHJcbiAgICAgICAgICApXHJcbiAgICAgICAgOiAnJyxcclxuICAgIH0sXHJcbiAgfTtcclxufTtcclxuIiwiZXhwb3J0IGNvbnN0IEFMRVJUX1NUQVRFID0ge1xyXG4gIENMT1NFRDogJ0NMT1NFRCcsXHJcbiAgRVJST1I6ICdFUlJPUicsXHJcbiAgTE9BRElORzogJ0xPQURJTkcnLFxyXG4gIE9QRU46ICdPUEVOJyxcclxufTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlU2xpY2UgfSBmcm9tICdAcmVkdXhqcy90b29sa2l0JztcclxuaW1wb3J0IHsgY2FwdHVyZUV4Y2VwdGlvbiB9IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XHJcblxyXG5pbXBvcnQgeyBBTEVSVF9UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvYWxlcnRzJztcclxuaW1wb3J0ICogYXMgYWN0aW9uQ29uc3RhbnRzIGZyb20gJy4uLy4uL3N0b3JlL2FjdGlvbkNvbnN0YW50cyc7XHJcbmltcG9ydCB7XHJcbiAgYWRkUGVybWl0dGVkQWNjb3VudCxcclxuICBzZXRBbGVydEVuYWJsZWRuZXNzLFxyXG4gIHNldFNlbGVjdGVkQWRkcmVzcyxcclxufSBmcm9tICcuLi8uLi9zdG9yZS9hY3Rpb25zJztcclxuaW1wb3J0IHsgZ2V0T3JpZ2luT2ZDdXJyZW50VGFiLCBnZXRTZWxlY3RlZEFkZHJlc3MgfSBmcm9tICcuLi8uLi9zZWxlY3RvcnMnO1xyXG5pbXBvcnQgeyBBTEVSVF9TVEFURSB9IGZyb20gJy4vZW51bXMnO1xyXG5cclxuLy8gQ29uc3RhbnRzXHJcblxyXG5jb25zdCBuYW1lID0gQUxFUlRfVFlQRVMudW5jb25uZWN0ZWRBY2NvdW50O1xyXG5cclxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xyXG4gIHN0YXRlOiBBTEVSVF9TVEFURS5DTE9TRUQsXHJcbn07XHJcblxyXG4vLyBTbGljZSAocmVkdWNlciBwbHVzIGF1dG8tZ2VuZXJhdGVkIGFjdGlvbnMgYW5kIGFjdGlvbiBjcmVhdG9ycylcclxuXHJcbmNvbnN0IHNsaWNlID0gY3JlYXRlU2xpY2Uoe1xyXG4gIG5hbWUsXHJcbiAgaW5pdGlhbFN0YXRlLFxyXG4gIHJlZHVjZXJzOiB7XHJcbiAgICBjb25uZWN0QWNjb3VudEZhaWxlZDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuRVJST1I7XHJcbiAgICB9LFxyXG4gICAgY29ubmVjdEFjY291bnRSZXF1ZXN0ZWQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkxPQURJTkc7XHJcbiAgICB9LFxyXG4gICAgY29ubmVjdEFjY291bnRTdWNjZWVkZWQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkNMT1NFRDtcclxuICAgIH0sXHJcbiAgICBkaXNhYmxlQWxlcnRGYWlsZWQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkVSUk9SO1xyXG4gICAgfSxcclxuICAgIGRpc2FibGVBbGVydFJlcXVlc3RlZDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuTE9BRElORztcclxuICAgIH0sXHJcbiAgICBkaXNhYmxlQWxlcnRTdWNjZWVkZWQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkNMT1NFRDtcclxuICAgIH0sXHJcbiAgICBkaXNtaXNzQWxlcnQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkNMT1NFRDtcclxuICAgIH0sXHJcbiAgICBzd2l0Y2hBY2NvdW50RmFpbGVkOiAoc3RhdGUpID0+IHtcclxuICAgICAgc3RhdGUuc3RhdGUgPSBBTEVSVF9TVEFURS5FUlJPUjtcclxuICAgIH0sXHJcbiAgICBzd2l0Y2hBY2NvdW50UmVxdWVzdGVkOiAoc3RhdGUpID0+IHtcclxuICAgICAgc3RhdGUuc3RhdGUgPSBBTEVSVF9TVEFURS5MT0FESU5HO1xyXG4gICAgfSxcclxuICAgIHN3aXRjaEFjY291bnRTdWNjZWVkZWQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkNMT1NFRDtcclxuICAgIH0sXHJcbiAgICBzd2l0Y2hlZFRvVW5jb25uZWN0ZWRBY2NvdW50OiAoc3RhdGUpID0+IHtcclxuICAgICAgc3RhdGUuc3RhdGUgPSBBTEVSVF9TVEFURS5PUEVOO1xyXG4gICAgfSxcclxuICB9LFxyXG4gIGV4dHJhUmVkdWNlcnM6IHtcclxuICAgIFthY3Rpb25Db25zdGFudHMuU0VMRUNURURfQUREUkVTU19DSEFOR0VEXTogKHN0YXRlKSA9PiB7XHJcbiAgICAgIC8vIGNsb3NlIHRoZSBhbGVydCBpZiB0aGUgYWNjb3VudCBpcyBzd2l0Y2hlZCB3aGlsZSBpdCdzIG9wZW5cclxuICAgICAgaWYgKHN0YXRlLnN0YXRlID09PSBBTEVSVF9TVEFURS5PUEVOKSB7XHJcbiAgICAgICAgc3RhdGUuc3RhdGUgPSBBTEVSVF9TVEFURS5DTE9TRUQ7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgfSxcclxufSk7XHJcblxyXG5jb25zdCB7IGFjdGlvbnMsIHJlZHVjZXIgfSA9IHNsaWNlO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcclxuXHJcbi8vIFNlbGVjdG9yc1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEFsZXJ0U3RhdGUgPSAoc3RhdGUpID0+IHN0YXRlW25hbWVdLnN0YXRlO1xyXG5cclxuZXhwb3J0IGNvbnN0IGFsZXJ0SXNPcGVuID0gKHN0YXRlKSA9PiBzdGF0ZVtuYW1lXS5zdGF0ZSAhPT0gQUxFUlRfU1RBVEUuQ0xPU0VEO1xyXG5cclxuLy8gQWN0aW9ucyAvIGFjdGlvbi1jcmVhdG9yc1xyXG5cclxuY29uc3Qge1xyXG4gIGNvbm5lY3RBY2NvdW50RmFpbGVkLFxyXG4gIGNvbm5lY3RBY2NvdW50UmVxdWVzdGVkLFxyXG4gIGNvbm5lY3RBY2NvdW50U3VjY2VlZGVkLFxyXG4gIGRpc2FibGVBbGVydEZhaWxlZCxcclxuICBkaXNhYmxlQWxlcnRSZXF1ZXN0ZWQsXHJcbiAgZGlzYWJsZUFsZXJ0U3VjY2VlZGVkLFxyXG4gIGRpc21pc3NBbGVydCxcclxuICBzd2l0Y2hBY2NvdW50RmFpbGVkLFxyXG4gIHN3aXRjaEFjY291bnRSZXF1ZXN0ZWQsXHJcbiAgc3dpdGNoQWNjb3VudFN1Y2NlZWRlZCxcclxuICBzd2l0Y2hlZFRvVW5jb25uZWN0ZWRBY2NvdW50LFxyXG59ID0gYWN0aW9ucztcclxuXHJcbmV4cG9ydCB7IGRpc21pc3NBbGVydCwgc3dpdGNoZWRUb1VuY29ubmVjdGVkQWNjb3VudCB9O1xyXG5cclxuZXhwb3J0IGNvbnN0IGRpc21pc3NBbmREaXNhYmxlQWxlcnQgPSAoKSA9PiB7XHJcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goZGlzYWJsZUFsZXJ0UmVxdWVzdGVkKCkpO1xyXG4gICAgICBhd2FpdCBzZXRBbGVydEVuYWJsZWRuZXNzKG5hbWUsIGZhbHNlKTtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goZGlzYWJsZUFsZXJ0U3VjY2VlZGVkKCkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgIGNhcHR1cmVFeGNlcHRpb24oZXJyb3IpO1xyXG4gICAgICBhd2FpdCBkaXNwYXRjaChkaXNhYmxlQWxlcnRGYWlsZWQoKSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBzd2l0Y2hUb0FjY291bnQgPSAoYWRkcmVzcykgPT4ge1xyXG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gpID0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGRpc3BhdGNoKHN3aXRjaEFjY291bnRSZXF1ZXN0ZWQoKSk7XHJcbiAgICAgIGF3YWl0IGRpc3BhdGNoKHNldFNlbGVjdGVkQWRkcmVzcyhhZGRyZXNzKSk7XHJcbiAgICAgIGF3YWl0IGRpc3BhdGNoKHN3aXRjaEFjY291bnRTdWNjZWVkZWQoKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgY2FwdHVyZUV4Y2VwdGlvbihlcnJvcik7XHJcbiAgICAgIGF3YWl0IGRpc3BhdGNoKHN3aXRjaEFjY291bnRGYWlsZWQoKSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb25uZWN0QWNjb3VudCA9ICgpID0+IHtcclxuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xyXG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xyXG4gICAgY29uc3Qgc2VsZWN0ZWRBZGRyZXNzID0gZ2V0U2VsZWN0ZWRBZGRyZXNzKHN0YXRlKTtcclxuICAgIGNvbnN0IG9yaWdpbiA9IGdldE9yaWdpbk9mQ3VycmVudFRhYihzdGF0ZSk7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBkaXNwYXRjaChjb25uZWN0QWNjb3VudFJlcXVlc3RlZCgpKTtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goYWRkUGVybWl0dGVkQWNjb3VudChvcmlnaW4sIHNlbGVjdGVkQWRkcmVzcykpO1xyXG4gICAgICBhd2FpdCBkaXNwYXRjaChjb25uZWN0QWNjb3VudFN1Y2NlZWRlZCgpKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICBjYXB0dXJlRXhjZXB0aW9uKGVycm9yKTtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goY29ubmVjdEFjY291bnRGYWlsZWQoKSk7XHJcbiAgICB9XHJcbiAgfTtcclxufTtcclxuIiwiaW1wb3J0IHtcbiAgV0VCSElEX0NPTk5FQ1RFRF9TVEFUVVNFUyxcbiAgVFJBTlNQT1JUX1NUQVRFUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9oYXJkd2FyZS13YWxsZXRzJztcbmltcG9ydCAqIGFzIGFjdGlvbkNvbnN0YW50cyBmcm9tICcuLi8uLi9zdG9yZS9hY3Rpb25Db25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWR1Y2VBcHAoc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIC8vIGRlZmF1bHQgc3RhdGVcbiAgY29uc3QgYXBwU3RhdGUgPSB7XG4gICAgc2hvdWxkQ2xvc2U6IGZhbHNlLFxuICAgIG1lbnVPcGVuOiBmYWxzZSxcbiAgICBtb2RhbDoge1xuICAgICAgb3BlbjogZmFsc2UsXG4gICAgICBtb2RhbFN0YXRlOiB7XG4gICAgICAgIG5hbWU6IG51bGwsXG4gICAgICAgIHByb3BzOiB7fSxcbiAgICAgIH0sXG4gICAgICBwcmV2aW91c01vZGFsU3RhdGU6IHtcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBhbGVydE9wZW46IGZhbHNlLFxuICAgIGFsZXJ0TWVzc2FnZTogbnVsbCxcbiAgICBxckNvZGVEYXRhOiBudWxsLFxuICAgIG5ldHdvcmtEcm9wZG93bk9wZW46IGZhbHNlLFxuICAgIGFjY291bnREZXRhaWw6IHtcbiAgICAgIHN1YnZpZXc6ICd0cmFuc2FjdGlvbnMnLFxuICAgIH0sXG4gICAgLy8gVXNlZCB0byBkaXNwbGF5IGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAvLyBVc2VkIHRvIGRpc3BsYXkgZXJyb3IgdGV4dFxuICAgIHdhcm5pbmc6IG51bGwsXG4gICAgYnV5Vmlldzoge30sXG4gICAgaXNNb3VzZVVzZXI6IGZhbHNlLFxuICAgIGRlZmF1bHRIZFBhdGhzOiB7XG4gICAgICB0cmV6b3I6IGBtLzQ0Jy82MCcvMCcvMGAsXG4gICAgICBsZWRnZXI6IGBtLzQ0Jy82MCcvMCcvMC8wYCxcbiAgICAgIGxhdHRpY2U6IGBtLzQ0Jy82MCcvMCcvMGAsXG4gICAgfSxcbiAgICBuZXR3b3Jrc1RhYlNlbGVjdGVkUnBjVXJsOiAnJyxcbiAgICBsb2FkaW5nTWV0aG9kRGF0YTogZmFsc2UsXG4gICAgcmVxdWVzdEFjY291bnRUYWJzOiB7fSxcbiAgICBvcGVuTWV0YU1hc2tUYWJzOiB7fSxcbiAgICBjdXJyZW50V2luZG93VGFiOiB7fSxcbiAgICBzaG93V2hhdHNOZXdQb3B1cDogdHJ1ZSxcbiAgICBzaW5nbGVFeGNlcHRpb25zOiB7XG4gICAgICB0ZXN0S2V5OiBudWxsLFxuICAgIH0sXG4gICAgZ2FzTG9hZGluZ0FuaW1hdGlvbklzU2hvd2luZzogZmFsc2UsXG4gICAgc21hcnRUcmFuc2FjdGlvbnNFcnJvcjogbnVsbCxcbiAgICBzbWFydFRyYW5zYWN0aW9uc0Vycm9yTWVzc2FnZURpc21pc3NlZDogZmFsc2UsXG4gICAgbGVkZ2VyV2ViSGlkQ29ubmVjdGVkU3RhdHVzOiBXRUJISURfQ09OTkVDVEVEX1NUQVRVU0VTLlVOS05PV04sXG4gICAgbGVkZ2VyVHJhbnNwb3J0U3RhdHVzOiBUUkFOU1BPUlRfU1RBVEVTLk5PTkUsXG4gICAgbmV3TmV0d29ya0FkZGVkOiAnJyxcbiAgICBuZXdDb2xsZWN0aWJsZUFkZGVkTWVzc2FnZTogJycsXG4gICAgcG9ydGZvbGlvVG9vbHRpcFdhc1Nob3duSW5UaGlzU2Vzc2lvbjogZmFsc2UsXG4gICAgc2VuZElucHV0Q3VycmVuY3lTd2l0Y2hlZDogZmFsc2UsXG4gICAgbmV3VG9rZW5zSW1wb3J0ZWQ6ICcnLFxuICAgIG5ld0N1c3RvbU5ldHdvcmtBZGRlZDoge30sXG4gICAgb25ib2FyZGVkSW5UaGlzVUlTZXNzaW9uOiBmYWxzZSxcbiAgICAuLi5zdGF0ZSxcbiAgfTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLy8gZHJvcGRvd24gbWV0aG9kc1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLk5FVFdPUktfRFJPUERPV05fT1BFTjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBuZXR3b3JrRHJvcGRvd25PcGVuOiB0cnVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLk5FVFdPUktfRFJPUERPV05fQ0xPU0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV0d29ya0Ryb3Bkb3duT3BlbjogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgLy8gYWxlcnQgbWV0aG9kc1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkFMRVJUX09QRU46XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWxlcnRPcGVuOiB0cnVlLFxuICAgICAgICBhbGVydE1lc3NhZ2U6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5BTEVSVF9DTE9TRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBhbGVydE9wZW46IGZhbHNlLFxuICAgICAgICBhbGVydE1lc3NhZ2U6IG51bGwsXG4gICAgICB9O1xuXG4gICAgLy8gcXIgc2Nhbm5lciBtZXRob2RzXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuUVJfQ09ERV9ERVRFQ1RFRDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBxckNvZGVEYXRhOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgLy8gU21hcnQgVHJhbnNhY3Rpb25zIGVycm9ycy5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfU01BUlRfVFJBTlNBQ1RJT05TX0VSUk9SOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zRXJyb3I6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkRJU01JU1NfU01BUlRfVFJBTlNBQ1RJT05TX0VSUk9SX01FU1NBR0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNFcnJvck1lc3NhZ2VEaXNtaXNzZWQ6IHRydWUsXG4gICAgICB9O1xuXG4gICAgLy8gbW9kYWwgbWV0aG9kczpcbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5NT0RBTF9PUEVOOiB7XG4gICAgICBjb25zdCB7IG5hbWUsIC4uLm1vZGFsUHJvcHMgfSA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbW9kYWw6IHtcbiAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgIG1vZGFsU3RhdGU6IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBwcm9wczogeyAuLi5tb2RhbFByb3BzIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcmV2aW91c01vZGFsU3RhdGU6IHsgLi4uYXBwU3RhdGUubW9kYWwubW9kYWxTdGF0ZSB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5NT0RBTF9DTE9TRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBtb2RhbDogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBhcHBTdGF0ZS5tb2RhbCxcbiAgICAgICAgICB7IG9wZW46IGZhbHNlIH0sXG4gICAgICAgICAgeyBtb2RhbFN0YXRlOiB7IG5hbWU6IG51bGwsIHByb3BzOiB7fSB9IH0sXG4gICAgICAgICAgeyBwcmV2aW91c01vZGFsU3RhdGU6IGFwcFN0YXRlLm1vZGFsLm1vZGFsU3RhdGUgfSxcbiAgICAgICAgKSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5DTEVBUl9BQ0NPVU5UX0RFVEFJTFM6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWNjb3VudERldGFpbDoge30sXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuRk9SR09UX1BBU1NXT1JEOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0hPV19TRU5EX1RPS0VOX1BBR0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgd2FybmluZzogbnVsbCxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5MT0NLX01FVEFNQVNLOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICB9O1xuXG4gICAgLy8gYWNjb3VudHNcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkdPX0hPTUU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWNjb3VudERldGFpbDoge1xuICAgICAgICAgIHN1YnZpZXc6ICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgIGFjY291bnRFeHBvcnQ6ICdub25lJyxcbiAgICAgICAgICBwcml2YXRlS2V5OiAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgd2FybmluZzogbnVsbCxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TSE9XX0FDQ09VTlRfREVUQUlMOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBhcHBTdGF0ZS5mb3Jnb3R0ZW5QYXNzd29yZFxuICAgICAgICAgID8gIWFwcFN0YXRlLmZvcmdvdHRlblBhc3N3b3JkXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgICBhY2NvdW50RGV0YWlsOiB7XG4gICAgICAgICAgc3VidmlldzogJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgYWNjb3VudEV4cG9ydDogJ25vbmUnLFxuICAgICAgICAgIHByaXZhdGVLZXk6ICcnLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfQUNDT1VOVFNfUEFHRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICBzY3JvbGxUb0JvdHRvbTogZmFsc2UsXG4gICAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TSE9XX0NPTkZfVFhfUEFHRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICB0eElkOiBhY3Rpb24uaWQsXG4gICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuQ09NUExFVEVEX1RYOlxuICAgICAgaWYgKGFjdGlvbi52YWx1ZS51bmNvbmZpcm1lZEFjdGlvbnNDb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgICB0eElkOiBudWxsLFxuICAgICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgLy8gaW5kaWNhdGUgbm90aWZpY2F0aW9uIHNob3VsZCBjbG9zZVxuICAgICAgICBzaG91bGRDbG9zZTogdHJ1ZSxcbiAgICAgICAgd2FybmluZzogbnVsbCxcbiAgICAgICAgdHhJZDogbnVsbCxcbiAgICAgICAgYWNjb3VudERldGFpbDoge1xuICAgICAgICAgIHN1YnZpZXc6ICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRSQU5TQUNUSU9OX0VSUk9SOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuVU5MT0NLX0ZBSUxFRDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICB3YXJuaW5nOiBhY3Rpb24udmFsdWUgfHwgJ0luY29ycmVjdCBwYXNzd29yZC4gVHJ5IGFnYWluLicsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuVU5MT0NLX1NVQ0NFRURFRDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICB3YXJuaW5nOiAnJyxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfSEFSRFdBUkVfV0FMTEVUX0RFRkFVTFRfSERfUEFUSDoge1xuICAgICAgY29uc3QgeyBkZXZpY2UsIHBhdGggfSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIGNvbnN0IG5ld0RlZmF1bHRzID0geyAuLi5hcHBTdGF0ZS5kZWZhdWx0SGRQYXRocyB9O1xuICAgICAgbmV3RGVmYXVsdHNbZGV2aWNlXSA9IHBhdGg7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBkZWZhdWx0SGRQYXRoczogbmV3RGVmYXVsdHMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfTE9BRElORzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgIGxvYWRpbmdNZXNzYWdlOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuSElERV9MT0FESU5HOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuRElTUExBWV9XQVJOSU5HOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHdhcm5pbmc6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5ISURFX1dBUk5JTkc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgd2FybmluZzogdW5kZWZpbmVkLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfUFJJVkFURV9LRVk6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWNjb3VudERldGFpbDoge1xuICAgICAgICAgIHN1YnZpZXc6ICdleHBvcnQnLFxuICAgICAgICAgIGFjY291bnRFeHBvcnQ6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgIHByaXZhdGVLZXk6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTU9VU0VfVVNFUl9TVEFURTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBpc01vdXNlVXNlcjogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9TRUxFQ1RFRF9TRVRUSU5HU19SUENfVVJMOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIG5ldHdvcmtzVGFiU2VsZWN0ZWRScGNVcmw6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTkVXX05FVFdPUktfQURERUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3TmV0d29ya0FkZGVkOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0VUX05FV19UT0tFTlNfSU1QT1JURUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3VG9rZW5zSW1wb3J0ZWQ6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTkVXX0NPTExFQ1RJQkxFX0FEREVEX01FU1NBR0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3Q29sbGVjdGlibGVBZGRlZE1lc3NhZ2U6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5QT1JURk9MSU9fVE9PTFRJUF9XQVNfU0hPV05fSU5fVEhJU19TRVNTSU9OOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHBvcnRmb2xpb1Rvb2x0aXBXYXNTaG93bkluVGhpc1Nlc3Npb246IHRydWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuTE9BRElOR19NRVRIT0RfREFUQV9TVEFSVEVEOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGxvYWRpbmdNZXRob2REYXRhOiB0cnVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkxPQURJTkdfTUVUSE9EX0RBVEFfRklOSVNIRUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbG9hZGluZ01ldGhvZERhdGE6IGZhbHNlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9SRVFVRVNUX0FDQ09VTlRfVEFCUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICByZXF1ZXN0QWNjb3VudFRhYnM6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfT1BFTl9NRVRBTUFTS19UQUJfSURTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIG9wZW5NZXRhTWFza1RhYnM6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfQ1VSUkVOVF9XSU5ET1dfVEFCOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGN1cnJlbnRXaW5kb3dUYWI6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5ISURFX1dIQVRTX05FV19QT1BVUDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBzaG93V2hhdHNOZXdQb3B1cDogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuQ0FQVFVSRV9TSU5HTEVfRVhDRVBUSU9OOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHNpbmdsZUV4Y2VwdGlvbnM6IHtcbiAgICAgICAgICAuLi5hcHBTdGF0ZS5zaW5nbGVFeGNlcHRpb25zLFxuICAgICAgICAgIFthY3Rpb24udmFsdWVdOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9HQVNfTE9BRElOR19BTklNQVRJT046XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgZ2FzTG9hZGluZ0FuaW1hdGlvbklzU2hvd2luZzogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9XRUJISURfQ09OTkVDVEVEX1NUQVRVUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBsZWRnZXJXZWJIaWRDb25uZWN0ZWRTdGF0dXM6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTEVER0VSX1RSQU5TUE9SVF9TVEFUVVM6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbGVkZ2VyVHJhbnNwb3J0U3RhdHVzOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9DVVJSRU5DWV9JTlBVVF9TV0lUQ0g6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgc2VuZElucHV0Q3VycmVuY3lTd2l0Y2hlZDogIWFwcFN0YXRlLnNlbmRJbnB1dEN1cnJlbmN5U3dpdGNoZWQsXG4gICAgICB9O1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9ORVdfQ1VTVE9NX05FVFdPUktfQURERUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3Q3VzdG9tTmV0d29ya0FkZGVkOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLk9OQk9BUkRFRF9JTl9USElTX1VJX1NFU1NJT046XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgb25ib2FyZGVkSW5UaGlzVUlTZXNzaW9uOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXBwU3RhdGU7XG4gIH1cbn1cblxuLy8gQWN0aW9uIENyZWF0b3JzXG5leHBvcnQgZnVuY3Rpb24gaGlkZVdoYXRzTmV3UG9wdXAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYWN0aW9uQ29uc3RhbnRzLkhJREVfV0hBVFNfTkVXX1BPUFVQLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9ydGZvbGlvVG9vbHRpcFdhc1Nob3duSW5UaGlzU2Vzc2lvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBhY3Rpb25Db25zdGFudHMuUE9SVEZPTElPX1RPT0xUSVBfV0FTX1NIT1dOX0lOX1RISVNfU0VTU0lPTixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUdhc0xvYWRpbmdBbmltYXRpb24odmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9HQVNfTE9BRElOR19BTklNQVRJT04sIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMZWRnZXJXZWJIaWRDb25uZWN0ZWRTdGF0dXModmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLlNFVF9XRUJISURfQ09OTkVDVEVEX1NUQVRVUywgdmFsdWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExlZGdlclRyYW5zcG9ydFN0YXR1cyh2YWx1ZSkge1xuICByZXR1cm4geyB0eXBlOiBhY3Rpb25Db25zdGFudHMuU0VUX0xFREdFUl9UUkFOU1BPUlRfU1RBVFVTLCB2YWx1ZSB9O1xufVxuXG4vLyBTZWxlY3RvcnNcbmV4cG9ydCBmdW5jdGlvbiBnZXRRckNvZGVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5hcHBTdGF0ZS5xckNvZGVEYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2FzTG9hZGluZ0FuaW1hdGlvbklzU2hvd2luZyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuYXBwU3RhdGUuZ2FzTG9hZGluZ0FuaW1hdGlvbklzU2hvd2luZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExlZGdlcldlYkhpZENvbm5lY3RlZFN0YXR1cyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuYXBwU3RhdGUubGVkZ2VyV2ViSGlkQ29ubmVjdGVkU3RhdHVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVkZ2VyVHJhbnNwb3J0U3RhdHVzKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5hcHBTdGF0ZS5sZWRnZXJUcmFuc3BvcnRTdGF0dXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3J0Zm9saW9Ub29sdGlwV2FzU2hvd25JblRoaXNTZXNzaW9uKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5hcHBTdGF0ZS5wb3J0Zm9saW9Ub29sdGlwV2FzU2hvd25JblRoaXNTZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ3VycmVuY3lTd2l0Y2goKSB7XG4gIHJldHVybiB7IHR5cGU6IGFjdGlvbkNvbnN0YW50cy5UT0dHTEVfQ1VSUkVOQ1lfSU5QVVRfU1dJVENIIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXROZXdDdXN0b21OZXR3b3JrQWRkZWQodmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLlNFVF9ORVdfQ1VTVE9NX05FVFdPUktfQURERUQsIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRPbkJvYXJkZWRJblRoaXNVSVNlc3Npb24odmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLk9OQk9BUkRFRF9JTl9USElTX1VJX1NFU1NJT04sIHZhbHVlIH07XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgbmV0d29ya01hcCBmcm9tICdldGhlcmV1bS1lbnMtbmV0d29yay1tYXAnO1xuaW1wb3J0IHsgaXNDb25mdXNpbmcgfSBmcm9tICd1bmljb2RlLWNvbmZ1c2FibGVzJztcbmltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5cbmltcG9ydCB7IGdldEN1cnJlbnRDaGFpbklkIH0gZnJvbSAnLi4vc2VsZWN0b3JzJztcbmltcG9ydCB7XG4gIENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQLFxuICBORVRXT1JLX0lEUyxcbiAgTkVUV09SS19JRF9UT19FVEhFUlNfTkVUV09SS19OQU1FX01BUCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7XG4gIENPTkZVU0lOR19FTlNfRVJST1IsXG4gIEVOU19JTExFR0FMX0NIQVJBQ1RFUixcbiAgRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLLFxuICBFTlNfTk9UX1NVUFBPUlRFRF9PTl9ORVRXT1JLLFxuICBFTlNfTk9fQUREUkVTU19GT1JfTkFNRSxcbiAgRU5TX1JFR0lTVFJBVElPTl9FUlJPUixcbiAgRU5TX1VOS05PV05fRVJST1IsXG59IGZyb20gJy4uL3BhZ2VzL3NlbmQvc2VuZC5jb25zdGFudHMnO1xuaW1wb3J0IHsgaXNWYWxpZERvbWFpbk5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgQ0hBSU5fQ0hBTkdFRCB9IGZyb20gJy4uL3N0b3JlL2FjdGlvbkNvbnN0YW50cyc7XG5pbXBvcnQge1xuICBCVVJOX0FERFJFU1MsXG4gIGlzQnVybkFkZHJlc3MsXG4gIGlzVmFsaWRIZXhBZGRyZXNzLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xuXG4vLyBMb2NhbCBDb25zdGFudHNcbmNvbnN0IFpFUk9fWF9FUlJPUl9BRERSRVNTID0gJzB4JztcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBzdGFnZTogJ1VOSU5JVElBTElaRUQnLFxuICByZXNvbHV0aW9uOiBudWxsLFxuICBlcnJvcjogbnVsbCxcbiAgd2FybmluZzogbnVsbCxcbiAgbmV0d29yazogbnVsbCxcbn07XG5cbmV4cG9ydCBjb25zdCBlbnNJbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbmNvbnN0IG5hbWUgPSAnRU5TJztcblxubGV0IHdlYjNQcm92aWRlciA9IG51bGw7XG5cbmNvbnN0IHNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lLFxuICBpbml0aWFsU3RhdGUsXG4gIHJlZHVjZXJzOiB7XG4gICAgZW5zTG9va3VwOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgLy8gZmlyc3QgY2xlYXIgb3V0IHRoZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgc3RhdGUucmVzb2x1dGlvbiA9IG51bGw7XG4gICAgICBzdGF0ZS5lcnJvciA9IG51bGw7XG4gICAgICBzdGF0ZS53YXJuaW5nID0gbnVsbDtcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgZW5zTmFtZSwgZXJyb3IsIG5ldHdvcmsgfSA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzVmFsaWREb21haW5OYW1lKGVuc05hbWUpICYmXG4gICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ0VOUyBuYW1lIG5vdCBkZWZpbmVkLidcbiAgICAgICAgKSB7XG4gICAgICAgICAgc3RhdGUuZXJyb3IgPVxuICAgICAgICAgICAgbmV0d29yayA9PT0gTkVUV09SS19JRFMuTUFJTk5FVFxuICAgICAgICAgICAgICA/IEVOU19OT19BRERSRVNTX0ZPUl9OQU1FXG4gICAgICAgICAgICAgIDogRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdJbGxlZ2FsIGNoYXJhY3RlciBmb3IgRU5TLicpIHtcbiAgICAgICAgICBzdGF0ZS5lcnJvciA9IEVOU19JTExFR0FMX0NIQVJBQ1RFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHN0YXRlLmVycm9yID0gRU5TX1VOS05PV05fRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PT0gQlVSTl9BRERSRVNTKSB7XG4gICAgICAgICAgc3RhdGUuZXJyb3IgPSBFTlNfTk9fQUREUkVTU19GT1JfTkFNRTtcbiAgICAgICAgfSBlbHNlIGlmIChhZGRyZXNzID09PSBaRVJPX1hfRVJST1JfQUREUkVTUykge1xuICAgICAgICAgIHN0YXRlLmVycm9yID0gRU5TX1JFR0lTVFJBVElPTl9FUlJPUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5yZXNvbHV0aW9uID0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZERvbWFpbk5hbWUoYWRkcmVzcykgJiYgaXNDb25mdXNpbmcoYWRkcmVzcykpIHtcbiAgICAgICAgICBzdGF0ZS53YXJuaW5nID0gQ09ORlVTSU5HX0VOU19FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuZXJyb3IgPSBFTlNfTk9fQUREUkVTU19GT1JfTkFNRTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuYWJsZUVuc0xvb2t1cDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLnN0YWdlID0gJ0lOSVRJQUxJWkVEJztcbiAgICAgIHN0YXRlLmVycm9yID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlc29sdXRpb24gPSBudWxsO1xuICAgICAgc3RhdGUud2FybmluZyA9IG51bGw7XG4gICAgICBzdGF0ZS5uZXR3b3JrID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcbiAgICBkaXNhYmxlRW5zTG9va3VwOiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLnN0YWdlID0gJ05PX05FVFdPUktfU1VQUE9SVCc7XG4gICAgICBzdGF0ZS5lcnJvciA9IG51bGw7XG4gICAgICBzdGF0ZS53YXJuaW5nID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlc29sdXRpb24gPSBudWxsO1xuICAgICAgc3RhdGUubmV0d29yayA9IG51bGw7XG4gICAgfSxcbiAgICBlbnNOb3RTdXBwb3J0ZWQ6IChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucmVzb2x1dGlvbiA9IG51bGw7XG4gICAgICBzdGF0ZS53YXJuaW5nID0gbnVsbDtcbiAgICAgIHN0YXRlLmVycm9yID0gRU5TX05PVF9TVVBQT1JURURfT05fTkVUV09SSztcbiAgICB9LFxuICAgIHJlc2V0RW5zUmVzb2x1dGlvbjogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5yZXNvbHV0aW9uID0gbnVsbDtcbiAgICAgIHN0YXRlLndhcm5pbmcgPSBudWxsO1xuICAgICAgc3RhdGUuZXJyb3IgPSBudWxsO1xuICAgIH0sXG4gIH0sXG4gIGV4dHJhUmVkdWNlcnM6IChidWlsZGVyKSA9PiB7XG4gICAgYnVpbGRlci5hZGRDYXNlKENIQUlOX0NIQU5HRUQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoYWN0aW9uLnBheWxvYWQgIT09IHN0YXRlLmN1cnJlbnRDaGFpbklkKSB7XG4gICAgICAgIHN0YXRlLnN0YWdlID0gJ1VOSU5JVElBTElaRUQnO1xuICAgICAgICB3ZWIzUHJvdmlkZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufSk7XG5cbmNvbnN0IHsgcmVkdWNlciwgYWN0aW9ucyB9ID0gc2xpY2U7XG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5jb25zdCB7XG4gIGRpc2FibGVFbnNMb29rdXAsXG4gIGVuc0xvb2t1cCxcbiAgZW5hYmxlRW5zTG9va3VwLFxuICBlbnNOb3RTdXBwb3J0ZWQsXG4gIHJlc2V0RW5zUmVzb2x1dGlvbixcbn0gPSBhY3Rpb25zO1xuZXhwb3J0IHsgcmVzZXRFbnNSZXNvbHV0aW9uIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRW5zU2xpY2UoKSB7XG4gIHJldHVybiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSk7XG4gICAgY29uc3QgbmV0d29yayA9IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW2NoYWluSWRdO1xuICAgIGNvbnN0IG5ldHdvcmtOYW1lID0gTkVUV09SS19JRF9UT19FVEhFUlNfTkVUV09SS19OQU1FX01BUFtuZXR3b3JrXTtcbiAgICBjb25zdCBlbnNBZGRyZXNzID0gbmV0d29ya01hcFtuZXR3b3JrXTtcbiAgICBjb25zdCBuZXR3b3JrSXNTdXBwb3J0ZWQgPSBCb29sZWFuKGVuc0FkZHJlc3MpO1xuICAgIGlmIChuZXR3b3JrSXNTdXBwb3J0ZWQpIHtcbiAgICAgIHdlYjNQcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcihcbiAgICAgICAgZ2xvYmFsLmV0aGVyZXVtUHJvdmlkZXIsXG4gICAgICAgIHtcbiAgICAgICAgICBjaGFpbklkOiBwYXJzZUludChuZXR3b3JrLCAxMCksXG4gICAgICAgICAgbmFtZTogbmV0d29ya05hbWUsXG4gICAgICAgICAgZW5zQWRkcmVzcyxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBkaXNwYXRjaChlbmFibGVFbnNMb29rdXAobmV0d29yaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ZWIzUHJvdmlkZXIgPSBudWxsO1xuICAgICAgZGlzcGF0Y2goZGlzYWJsZUVuc0xvb2t1cCgpKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXBFbnNOYW1lKGVuc05hbWUpIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCB0cmltbWVkRW5zTmFtZSA9IGVuc05hbWUudHJpbSgpO1xuICAgIGxldCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlW25hbWVdLnN0YWdlID09PSAnVU5JTklUSUFMSVpFRCcpIHtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGluaXRpYWxpemVFbnNTbGljZSgpKTtcbiAgICB9XG4gICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGlmIChcbiAgICAgIHN0YXRlW25hbWVdLnN0YWdlID09PSAnTk9fTkVUV09SS19TVVBQT1JUJyAmJlxuICAgICAgIShcbiAgICAgICAgaXNCdXJuQWRkcmVzcyh0cmltbWVkRW5zTmFtZSkgPT09IGZhbHNlICYmXG4gICAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyaW1tZWRFbnNOYW1lLCB7IG1peGVkQ2FzZVVzZUNoZWNrc3VtOiB0cnVlIH0pXG4gICAgICApICYmXG4gICAgICAhaXNIZXhTdHJpbmcodHJpbW1lZEVuc05hbWUpXG4gICAgKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChlbnNOb3RTdXBwb3J0ZWQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5pbmZvKGBFTlMgYXR0ZW1wdGluZyB0byByZXNvbHZlIG5hbWU6ICR7dHJpbW1lZEVuc05hbWV9YCk7XG4gICAgICBsZXQgYWRkcmVzcztcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB3cml0YWJsZSBwcm9wZXJ0eSBvbiB0aGUgJ3Byb3ZpZGVyJyBvYmplY3Qgb24gdGhlICd3ZWIzUHJvdmlkZXInIGZsaXBzIHRvIGZhbHNlIHdoZW4gc3RhbGVcbiAgICAgICAgLy8gVGhpcyBoZWxwcyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHByb3ZpZGVyIGlzIGJlY29tZXMgdW5yZXNwb25zaXZlIGlmL3doZW4sIGluIE1WMywgdGhlIHNlcnZpY2Ugd29ya2VyIGRpZXMgYWZ0ZXIgdGhlIEVOUyBzbGljZSBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgY29uc3QgaXNQcm92aWRlckFjdGl2ZSA9IHdlYjNQcm92aWRlci5wcm92aWRlcj8ud3JpdGFibGU7XG4gICAgICAgIGlmICghaXNQcm92aWRlckFjdGl2ZSkge1xuICAgICAgICAgIGF3YWl0IGRpc3BhdGNoKGluaXRpYWxpemVFbnNTbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYXdhaXQgd2ViM1Byb3ZpZGVyLnJlc29sdmVOYW1lKHRyaW1tZWRFbnNOYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSk7XG4gICAgICBjb25zdCBuZXR3b3JrID0gQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbY2hhaW5JZF07XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgZW5zTG9va3VwKHtcbiAgICAgICAgICBlbnNOYW1lOiB0cmltbWVkRW5zTmFtZSxcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgbmV0d29yayxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVuc1Jlc29sdXRpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLnJlc29sdXRpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnNFcnJvcihzdGF0ZSkge1xuICByZXR1cm4gc3RhdGVbbmFtZV0uZXJyb3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnNXYXJuaW5nKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZVtuYW1lXS53YXJuaW5nO1xufVxuIiwiLy8gVGhpcyBmaWxlIGhhcyBiZWVuIHNlcGFyYXRlZCBiZWNhdXNlIGl0IGlzIHJlcXVpcmVkIGluIGJvdGggdGhlIGdhcyBhbmQgc2VuZFxyXG4vLyBzbGljZXMuIFRoaXMgY3JlYXRlZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbSBhcyBib3RoIHNsaWNlcyBhbHNvXHJcbi8vIGltcG9ydCBmcm9tIHRoZSBhY3Rpb25zIGFuZCBzZWxlY3RvcnMgZmlsZXMuIFRoaXMgZWFzaWVzdCBwYXRoIGZvclxyXG4vLyB1bnRhbmdsaW5nIGlzIGhhdmluZyB0aGUgY29uc3RhbnRzIHNlcGFyYXRlLlxyXG5cclxuLy8gQWN0aW9uc1xyXG5leHBvcnQgY29uc3QgUkVTRVRfQ1VTVE9NX0RBVEEgPSAnbWV0YW1hc2svZ2FzL1JFU0VUX0NVU1RPTV9EQVRBJztcclxuZXhwb3J0IGNvbnN0IFNFVF9DVVNUT01fR0FTX0xJTUlUID0gJ21ldGFtYXNrL2dhcy9TRVRfQ1VTVE9NX0dBU19MSU1JVCc7XHJcbmV4cG9ydCBjb25zdCBTRVRfQ1VTVE9NX0dBU19QUklDRSA9ICdtZXRhbWFzay9nYXMvU0VUX0NVU1RPTV9HQVNfUFJJQ0UnO1xyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgUkVTRVRfQ1VTVE9NX0RBVEEsXG4gIFNFVF9DVVNUT01fR0FTX0xJTUlULFxuICBTRVRfQ1VTVE9NX0dBU19QUklDRSxcbn0gZnJvbSAnLi9nYXMtYWN0aW9uLWNvbnN0YW50cyc7XG5cbmNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgY3VzdG9tRGF0YToge1xuICAgIHByaWNlOiBudWxsLFxuICAgIGxpbWl0OiBudWxsLFxuICB9LFxufTtcblxuLy8gUmVkdWNlclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGluaXRTdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFNFVF9DVVNUT01fR0FTX1BSSUNFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGN1c3RvbURhdGE6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5jdXN0b21EYXRhLFxuICAgICAgICAgIHByaWNlOiBhY3Rpb24udmFsdWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIGNhc2UgU0VUX0NVU1RPTV9HQVNfTElNSVQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgY3VzdG9tRGF0YToge1xuICAgICAgICAgIC4uLnN0YXRlLmN1c3RvbURhdGEsXG4gICAgICAgICAgbGltaXQ6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgY2FzZSBSRVNFVF9DVVNUT01fREFUQTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBjdXN0b21EYXRhOiBjbG9uZURlZXAoaW5pdFN0YXRlLmN1c3RvbURhdGEpLFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXN0b21HYXNQcmljZShuZXdQcmljZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNFVF9DVVNUT01fR0FTX1BSSUNFLFxuICAgIHZhbHVlOiBuZXdQcmljZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEN1c3RvbUdhc0xpbWl0KG5ld0xpbWl0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0VUX0NVU1RPTV9HQVNfTElNSVQsXG4gICAgdmFsdWU6IG5ld0xpbWl0LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4LCBpc0hleFN0cmluZyB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgKiBhcyBhY3Rpb25Db25zdGFudHMgZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9uQ29uc3RhbnRzJztcbmltcG9ydCB7IEFMRVJUX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hbGVydHMnO1xuaW1wb3J0IHtcbiAgR0FTX0VTVElNQVRFX1RZUEVTLFxuICBORVRXT1JLX0NPTkdFU1RJT05fVEhSRVNIT0xEUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xuaW1wb3J0IHsgTkVUV09SS19UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICBhY2NvdW50c1dpdGhTZW5kRXRoZXJJbmZvU2VsZWN0b3IsXG4gIGNoZWNrTmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTksXG4gIGdldEFkZHJlc3NCb29rLFxufSBmcm9tICcuLi8uLi9zZWxlY3RvcnMnO1xuaW1wb3J0IHsgdXBkYXRlVHJhbnNhY3Rpb25HYXNGZWVzIH0gZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgeyBzZXRDdXN0b21HYXNMaW1pdCwgc2V0Q3VzdG9tR2FzUHJpY2UgfSBmcm9tICcuLi9nYXMvZ2FzLmR1Y2snO1xuaW1wb3J0IHsgZGVjR1dFSVRvSGV4V0VJIH0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlscy9jb252ZXJzaW9ucy51dGlsJztcblxuaW1wb3J0IHsgS0VZUklOR19UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvc3RyaW5nLXV0aWxzJztcbmltcG9ydCB7IHN0cmlwSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVkdWNlTWV0YW1hc2soc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIGNvbnN0IG1ldGFtYXNrU3RhdGUgPSB7XG4gICAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gICAgaXNVbmxvY2tlZDogZmFsc2UsXG4gICAgaXNBY2NvdW50TWVudU9wZW46IGZhbHNlLFxuICAgIGlkZW50aXRpZXM6IHt9LFxuICAgIHVuYXBwcm92ZWRUeHM6IHt9LFxuICAgIGZyZXF1ZW50UnBjTGlzdDogW10sXG4gICAgYWRkcmVzc0Jvb2s6IFtdLFxuICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30sXG4gICAgcGVuZGluZ1Rva2Vuczoge30sXG4gICAgY3VzdG9tTm9uY2VWYWx1ZTogJycsXG4gICAgdXNlQmxvY2tpZTogZmFsc2UsXG4gICAgZmVhdHVyZUZsYWdzOiB7fSxcbiAgICB3ZWxjb21lU2NyZWVuU2VlbjogZmFsc2UsXG4gICAgY3VycmVudExvY2FsZTogJycsXG4gICAgY3VycmVudEJsb2NrR2FzTGltaXQ6ICcnLFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICBhdXRvTG9ja1RpbWVMaW1pdDogdW5kZWZpbmVkLFxuICAgICAgc2hvd0ZpYXRJblRlc3RuZXRzOiBmYWxzZSxcbiAgICAgIHNob3dUZXN0TmV0d29ya3M6IGZhbHNlLFxuICAgICAgdXNlTmF0aXZlQ3VycmVuY3lBc1ByaW1hcnlDdXJyZW5jeTogdHJ1ZSxcbiAgICB9LFxuICAgIGZpcnN0VGltZUZsb3dUeXBlOiBudWxsLFxuICAgIGNvbXBsZXRlZE9uYm9hcmRpbmc6IGZhbHNlLFxuICAgIGtub3duTWV0aG9kRGF0YToge30sXG4gICAgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOiBudWxsLFxuICAgIG5leHROb25jZTogbnVsbCxcbiAgICBjb252ZXJzaW9uUmF0ZTogbnVsbCxcbiAgICBuYXRpdmVDdXJyZW5jeTogJ0VUSCcsXG4gICAgLi4uc3RhdGUsXG4gIH07XG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlVQREFURV9NRVRBTUFTS19TVEFURTpcbiAgICAgIHJldHVybiB7IC4uLm1ldGFtYXNrU3RhdGUsIC4uLmFjdGlvbi52YWx1ZSB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuTE9DS19NRVRBTUFTSzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9SUENfVEFSR0VUOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgICB0eXBlOiBORVRXT1JLX1RZUEVTLlJQQyxcbiAgICAgICAgICBycGNVcmw6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfUFJPVklERVJfVFlQRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIHByb3ZpZGVyOiB7XG4gICAgICAgICAgdHlwZTogYWN0aW9uLnZhbHVlLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfQUNDT1VOVF9ERVRBSUw6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBpc1VubG9ja2VkOiB0cnVlLFxuICAgICAgICBpc0luaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICBzZWxlY3RlZEFkZHJlc3M6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfQUNDT1VOVF9MQUJFTDoge1xuICAgICAgY29uc3QgeyBhY2NvdW50IH0gPSBhY3Rpb24udmFsdWU7XG4gICAgICBjb25zdCBuYW1lID0gYWN0aW9uLnZhbHVlLmxhYmVsO1xuICAgICAgY29uc3QgaWQgPSB7fTtcbiAgICAgIGlkW2FjY291bnRdID0geyAuLi5tZXRhbWFza1N0YXRlLmlkZW50aXRpZXNbYWNjb3VudF0sIG5hbWUgfTtcbiAgICAgIGNvbnN0IGlkZW50aXRpZXMgPSB7IC4uLm1ldGFtYXNrU3RhdGUuaWRlbnRpdGllcywgLi4uaWQgfTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG1ldGFtYXNrU3RhdGUsIHsgaWRlbnRpdGllcyB9KTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5VUERBVEVfQ1VTVE9NX05PTkNFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgY3VzdG9tTm9uY2VWYWx1ZTogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9BQ0NPVU5UX01FTlU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBpc0FjY291bnRNZW51T3BlbjogIW1ldGFtYXNrU3RhdGUuaXNBY2NvdW50TWVudU9wZW4sXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuVVBEQVRFX1RSQU5TQUNUSU9OX1BBUkFNUzoge1xuICAgICAgY29uc3QgeyBpZDogdHhJZCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGxldCB7IGN1cnJlbnROZXR3b3JrVHhMaXN0IH0gPSBtZXRhbWFza1N0YXRlO1xuICAgICAgY3VycmVudE5ldHdvcmtUeExpc3QgPSBjdXJyZW50TmV0d29ya1R4TGlzdC5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eC5pZCA9PT0gdHhJZCkge1xuICAgICAgICAgIGNvbnN0IG5ld1R4ID0geyAuLi50eCB9O1xuICAgICAgICAgIG5ld1R4LnR4UGFyYW1zID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG5ld1R4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBjdXJyZW50TmV0d29ya1R4TGlzdCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0VUX1BBUlRJQ0lQQVRFX0lOX01FVEFNRVRSSUNTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0VUX1VTRV9CTE9DS0lFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgdXNlQmxvY2tpZTogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlVQREFURV9GRUFUVVJFX0ZMQUdTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgZmVhdHVyZUZsYWdzOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuQ0xPU0VfV0VMQ09NRV9TQ1JFRU46XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICB3ZWxjb21lU2NyZWVuU2VlbjogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfQ1VSUkVOVF9MT0NBTEU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBjdXJyZW50TG9jYWxlOiBhY3Rpb24udmFsdWUubG9jYWxlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9QRU5ESU5HX1RPS0VOUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIHBlbmRpbmdUb2tlbnM6IHsgLi4uYWN0aW9uLnBheWxvYWQgfSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5DTEVBUl9QRU5ESU5HX1RPS0VOUzoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcGVuZGluZ1Rva2Vuczoge30sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlVQREFURV9QUkVGRVJFTkNFUzoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgICAuLi5tZXRhbWFza1N0YXRlLnByZWZlcmVuY2VzLFxuICAgICAgICAgIC4uLmFjdGlvbi5wYXlsb2FkLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5DT01QTEVURV9PTkJPQVJESU5HOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBjb21wbGV0ZWRPbmJvYXJkaW5nOiB0cnVlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfRklSU1RfVElNRV9GTE9XX1RZUEU6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIGZpcnN0VGltZUZsb3dUeXBlOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9ORVhUX05PTkNFOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBuZXh0Tm9uY2U6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBtZXRhbWFza1N0YXRlO1xuICB9XG59XG5cbmNvbnN0IHRvSGV4V2VpID0gKHZhbHVlLCBleHBlY3RIZXhXZWkpID0+IHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChleHBlY3RIZXhXZWkgPyB2YWx1ZSA6IGRlY0dXRUlUb0hleFdFSSh2YWx1ZSkpO1xufTtcblxuLy8gQWN0aW9uIENyZWF0b3JzXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlR2FzRmVlcyh7XG4gIGdhc1ByaWNlLFxuICBnYXNMaW1pdCxcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gIG1heEZlZVBlckdhcyxcbiAgdHJhbnNhY3Rpb24sXG4gIGV4cGVjdEhleFdlaSA9IGZhbHNlLFxufSkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XG4gICAgY29uc3QgdHhQYXJhbXNDb3B5ID0geyAuLi50cmFuc2FjdGlvbi50eFBhcmFtcywgZ2FzOiBnYXNMaW1pdCB9O1xuICAgIGlmIChnYXNQcmljZSkge1xuICAgICAgZGlzcGF0Y2goXG4gICAgICAgIHNldEN1c3RvbUdhc1ByaWNlKHRvSGV4V2VpKHR4UGFyYW1zQ29weS5nYXNQcmljZSwgZXhwZWN0SGV4V2VpKSksXG4gICAgICApO1xuICAgICAgdHhQYXJhbXNDb3B5Lmdhc1ByaWNlID0gdG9IZXhXZWkoZ2FzUHJpY2UsIGV4cGVjdEhleFdlaSk7XG4gICAgfSBlbHNlIGlmIChtYXhGZWVQZXJHYXMgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgIHR4UGFyYW1zQ29weS5tYXhGZWVQZXJHYXMgPSB0b0hleFdlaShtYXhGZWVQZXJHYXMsIGV4cGVjdEhleFdlaSk7XG4gICAgICB0eFBhcmFtc0NvcHkubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBhZGRIZXhQcmVmaXgoXG4gICAgICAgIGRlY0dXRUlUb0hleFdFSShtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkVHggPSB7XG4gICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgIHR4UGFyYW1zOiB0eFBhcmFtc0NvcHksXG4gICAgfTtcblxuICAgIGNvbnN0IGN1c3RvbUdhc0xpbWl0ID0gaXNIZXhTdHJpbmcoYWRkSGV4UHJlZml4KGdhc0xpbWl0KSlcbiAgICAgID8gYWRkSGV4UHJlZml4KGdhc0xpbWl0KVxuICAgICAgOiBhZGRIZXhQcmVmaXgoZ2FzTGltaXQudG9TdHJpbmcoMTYpKTtcbiAgICBkaXNwYXRjaChzZXRDdXN0b21HYXNMaW1pdChjdXN0b21HYXNMaW1pdCkpO1xuICAgIGF3YWl0IGRpc3BhdGNoKHVwZGF0ZVRyYW5zYWN0aW9uR2FzRmVlcyh1cGRhdGVkVHguaWQsIHVwZGF0ZWRUeCkpO1xuICB9O1xufVxuXG4vLyBTZWxlY3RvcnNcblxuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRMb2NhbGUgPSAoc3RhdGUpID0+IHN0YXRlLm1ldGFtYXNrLmN1cnJlbnRMb2NhbGU7XG5cbmV4cG9ydCBjb25zdCBnZXRBbGVydEVuYWJsZWRuZXNzID0gKHN0YXRlKSA9PiBzdGF0ZS5tZXRhbWFzay5hbGVydEVuYWJsZWRuZXNzO1xuXG5leHBvcnQgY29uc3QgZ2V0VW5jb25uZWN0ZWRBY2NvdW50QWxlcnRFbmFibGVkbmVzcyA9IChzdGF0ZSkgPT5cbiAgZ2V0QWxlcnRFbmFibGVkbmVzcyhzdGF0ZSlbQUxFUlRfVFlQRVMudW5jb25uZWN0ZWRBY2NvdW50XTtcblxuZXhwb3J0IGNvbnN0IGdldFdlYjNTaGltVXNhZ2VBbGVydEVuYWJsZWRuZXNzID0gKHN0YXRlKSA9PlxuICBnZXRBbGVydEVuYWJsZWRuZXNzKHN0YXRlKVtBTEVSVF9UWVBFUy53ZWIzU2hpbVVzYWdlXTtcblxuZXhwb3J0IGNvbnN0IGdldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd24gPSAoc3RhdGUpID0+XG4gIHN0YXRlLm1ldGFtYXNrLnVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd25PcmlnaW5zO1xuXG5leHBvcnQgY29uc3QgZ2V0UGVuZGluZ1Rva2VucyA9IChzdGF0ZSkgPT4gc3RhdGUubWV0YW1hc2sucGVuZGluZ1Rva2VucztcblxuZXhwb3J0IGNvbnN0IGdldFRva2VucyA9IChzdGF0ZSkgPT4gc3RhdGUubWV0YW1hc2sudG9rZW5zO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5jb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5jb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5hYmxlRUlQMTU1OVYyTm90aWNlRGlzbWlzc2VkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5lbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb2xsZWN0aWJsZXMgPSAoc3RhdGUpID0+IHtcbiAgY29uc3Qge1xuICAgIG1ldGFtYXNrOiB7XG4gICAgICBhbGxDb2xsZWN0aWJsZXMsXG4gICAgICBwcm92aWRlcjogeyBjaGFpbklkIH0sXG4gICAgICBzZWxlY3RlZEFkZHJlc3MsXG4gICAgfSxcbiAgfSA9IHN0YXRlO1xuXG4gIHJldHVybiBhbGxDb2xsZWN0aWJsZXM/LltzZWxlY3RlZEFkZHJlc3NdPy5bY2hhaW5JZF0gPz8gW107XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q29sbGVjdGlibGVDb250cmFjdHMgPSAoc3RhdGUpID0+IHtcbiAgY29uc3Qge1xuICAgIG1ldGFtYXNrOiB7XG4gICAgICBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cyxcbiAgICAgIHByb3ZpZGVyOiB7IGNoYWluSWQgfSxcbiAgICAgIHNlbGVjdGVkQWRkcmVzcyxcbiAgICB9LFxuICB9ID0gc3RhdGU7XG5cbiAgcmV0dXJuIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzPy5bc2VsZWN0ZWRBZGRyZXNzXT8uW2NoYWluSWRdID8/IFtdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJsb2NrR2FzTGltaXQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLmN1cnJlbnRCbG9ja0dhc0xpbWl0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udmVyc2lvblJhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLmNvbnZlcnNpb25SYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmF0aXZlQ3VycmVuY3koc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLm5hdGl2ZUN1cnJlbmN5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VuZEhleERhdGFGZWF0dXJlRmxhZ1N0YXRlKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5mZWF0dXJlRmxhZ3Muc2VuZEhleERhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kVG9BY2NvdW50cyhzdGF0ZSkge1xuICBjb25zdCBmcm9tQWNjb3VudHMgPSBhY2NvdW50c1dpdGhTZW5kRXRoZXJJbmZvU2VsZWN0b3Ioc3RhdGUpO1xuICBjb25zdCBhZGRyZXNzQm9va0FjY291bnRzID0gZ2V0QWRkcmVzc0Jvb2soc3RhdGUpO1xuICByZXR1cm4gWy4uLmZyb21BY2NvdW50cywgLi4uYWRkcmVzc0Jvb2tBY2NvdW50c107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmFwcHJvdmVkVHhzKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay51bmFwcHJvdmVkVHhzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiBuZXR3b3JrIGRldGFpbHMgYXJlIGZldGNoZWQgYW5kIGl0IGlzIGZvdW5kIHRvIG5vdCBzdXBwb3J0IEVJUC0xNTU5XG4gKlxuICogQHBhcmFtIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vdEVJUDE1NTlOZXR3b3JrKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5uZXR3b3JrRGV0YWlscz8uRUlQU1sxNTU5XSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIG5ldHdvcmsgZGV0YWlscyBhcmUgZmV0Y2hlZCBhbmQgaXQgaXMgZm91bmQgdG8gc3VwcG9ydCBFSVAtMTU1OVxuICpcbiAqIEBwYXJhbSBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFSVAxNTU5TmV0d29yayhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2submV0d29ya0RldGFpbHM/LkVJUFNbMTU1OV0gPT09IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHYXNFc3RpbWF0ZVR5cGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLmdhc0VzdGltYXRlVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdhc0ZlZUVzdGltYXRlcyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suZ2FzRmVlRXN0aW1hdGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldElzR2FzRXN0aW1hdGVzTG9hZGluZyhzdGF0ZSkge1xuICBjb25zdCBuZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OSA9XG4gICAgY2hlY2tOZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OShzdGF0ZSk7XG4gIGNvbnN0IGdhc0VzdGltYXRlVHlwZSA9IGdldEdhc0VzdGltYXRlVHlwZShzdGF0ZSk7XG5cbiAgLy8gV2UgY29uc2lkZXIgdGhlIGdhcyBlc3RpbWF0ZSB0byBiZSBsb2FkaW5nIGlmIHRoZSBnYXNFc3RpbWF0ZVR5cGUgaXNcbiAgLy8gJ05PTkUnIG9yIGlmIHRoZSBjdXJyZW50IGdhc0VzdGltYXRlVHlwZSBjYW5ub3QgYmUgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50XG4gIC8vIG5ldHdvcmtcbiAgY29uc3QgaXNFSVAxNTU5VG9sZXJhYmxlRXN0aW1hdGVUeXBlID1cbiAgICBnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VUIHx8XG4gICAgZ2FzRXN0aW1hdGVUeXBlID09PSBHQVNfRVNUSU1BVEVfVFlQRVMuRVRIX0dBU1BSSUNFO1xuICBjb25zdCBpc0dhc0VzdGltYXRlc0xvYWRpbmcgPVxuICAgIGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLk5PTkUgfHxcbiAgICAobmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTkgJiYgIWlzRUlQMTU1OVRvbGVyYWJsZUVzdGltYXRlVHlwZSkgfHxcbiAgICAoIW5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5ICYmXG4gICAgICBnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VUKTtcblxuICByZXR1cm4gaXNHYXNFc3RpbWF0ZXNMb2FkaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNOZXR3b3JrQnVzeShzdGF0ZSkge1xuICBjb25zdCBnYXNGZWVFc3RpbWF0ZXMgPSBnZXRHYXNGZWVFc3RpbWF0ZXMoc3RhdGUpO1xuICByZXR1cm4gKFxuICAgIGdhc0ZlZUVzdGltYXRlcz8ubmV0d29ya0Nvbmdlc3Rpb24gPj0gTkVUV09SS19DT05HRVNUSU9OX1RIUkVTSE9MRFMuQlVTWVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcGxldGVkT25ib2FyZGluZyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suY29tcGxldGVkT25ib2FyZGluZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc0luaXRpYWxpemVkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5pc0luaXRpYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNVbmxvY2tlZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suaXNVbmxvY2tlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlZWRQaHJhc2VCYWNrZWRVcChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suc2VlZFBocmFzZUJhY2tlZFVwO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSByZWR1eCBzdGF0ZSBvYmplY3QgYW5kIGFuIGFkZHJlc3MsIGZpbmRzIGEga2V5cmluZyB0aGF0IGNvbnRhaW5zIHRoYXQgYWRkcmVzcywgaWYgb25lIGV4aXN0c1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIHRoZSByZWR1eCBzdGF0ZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gc2VhcmNoIGZvciBhbW9uZyB0aGUga2V5cmluZyBhZGRyZXNzZXNcbiAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9IFRoZSBrZXlyaW5nIHdoaWNoIGNvbnRhaW5zIHRoZSBwYXNzZWQgYWRkcmVzcywgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kS2V5cmluZ0ZvckFkZHJlc3Moc3RhdGUsIGFkZHJlc3MpIHtcbiAgY29uc3Qga2V5cmluZyA9IHN0YXRlLm1ldGFtYXNrLmtleXJpbmdzLmZpbmQoKGtyKSA9PiB7XG4gICAgcmV0dXJuIGtyLmFjY291bnRzLnNvbWUoKGFjY291bnQpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUoYWNjb3VudCwgYWRkSGV4UHJlZml4KGFkZHJlc3MpKSB8fFxuICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGFjY291bnQsIHN0cmlwSGV4UHJlZml4KGFkZHJlc3MpKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGtleXJpbmc7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIHJlZHV4IHN0YXRlIG9iamVjdCwgcmV0dXJucyB0aGUgdXNlcnMgcHJlZmVycmVkIGxlZGdlciB0cmFuc3BvcnQgdHlwZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIHRoZSByZWR1eCBzdGF0ZSBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB1c2VycyBwcmVmZXJyZWQgbGVkZ2VyIHRyYW5zcG9ydCB0eXBlLiBPbmUgb2YnbGVkZ2VyTGl2ZScsICd3ZWJoaWQnIG9yICd1MmYnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWRnZXJUcmFuc3BvcnRUeXBlKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5sZWRnZXJUcmFuc3BvcnRUeXBlO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSByZWR1eCBzdGF0ZSBvYmplY3QgYW5kIGFuIGFkZHJlc3MsIHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFzc2VkIGFkZHJlc3MgaXMgcGFydCBvZiBhIExlZGdlciBrZXlyaW5nXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gdGhlIHJlZHV4IHN0YXRlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSB0aGUgYWRkcmVzcyB0byBzZWFyY2ggZm9yIGFtb25nIGFsbCBrZXlyaW5nIGFkZHJlc3Nlc1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHBhc3NlZCBhZGRyZXNzIGlzIHBhcnQgb2YgYSBsZWRnZXIga2V5cmluZywgYW5kIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzTGVkZ2VyKHN0YXRlLCBhZGRyZXNzKSB7XG4gIGNvbnN0IGtleXJpbmcgPSBmaW5kS2V5cmluZ0ZvckFkZHJlc3Moc3RhdGUsIGFkZHJlc3MpO1xuXG4gIHJldHVybiBrZXlyaW5nPy50eXBlID09PSBLRVlSSU5HX1RZUEVTLkxFREdFUjtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgcmVkdXggc3RhdGUgb2JqZWN0LCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFueSBMZWRnZXIgYWNjb3VudHMgYWRkZWQgdG8gTWV0YU1hc2sgKGkuZS4gTGVkZ2VyIGtleXJpbmdzXG4gKiBpbiBzdGF0ZSlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSB0aGUgcmVkdXggc3RhdGUgb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdXNlciBoYXMgYSBMZWRnZXIgYWNjb3VudCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb2VzVXNlckhhdmVBTGVkZ2VyQWNjb3VudChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2sua2V5cmluZ3Muc29tZSgoa3IpID0+IHtcbiAgICByZXR1cm4ga3IudHlwZSA9PT0gS0VZUklOR19UWVBFUy5MRURHRVI7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCBhYmkgZnJvbSAnaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpJztcbmltcG9ydCB7IEdBU19MSU1JVFMsIE1JTl9HQVNfTElNSVRfSEVYIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xuaW1wb3J0IHsgY2FsY1Rva2VuQW1vdW50IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi90cmFuc2FjdGlvbnMtY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQgeyBDSEFJTl9JRF9UT19HQVNfTElNSVRfQlVGRkVSX01BUCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICBBU1NFVF9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgcmVhZEFkZHJlc3NBc0NvbnRyYWN0IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udHJhY3QtdXRpbHMnO1xuaW1wb3J0IHtcbiAgY29udmVyc2lvblV0aWwsXG4gIG11bHRpcGx5Q3VycmVuY2llcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBFVEgsIEdXRUkgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2NvbnN0YW50cy9jb21tb24nO1xuaW1wb3J0IHtcbiAgYWRkR2FzQnVmZmVyLFxuICBnZW5lcmF0ZUVSQzIwVHJhbnNmZXJEYXRhLFxuICBnZW5lcmF0ZUVSQzcyMVRyYW5zZmVyRGF0YSxcbiAgZ2V0QXNzZXRUcmFuc2ZlckRhdGEsXG59IGZyb20gJy4uLy4uL3BhZ2VzL3NlbmQvc2VuZC51dGlscyc7XG5pbXBvcnQgeyBnZXRHYXNQcmljZUluSGV4V2VpIH0gZnJvbSAnLi4vLi4vc2VsZWN0b3JzJztcbmltcG9ydCB7IGVzdGltYXRlR2FzIH0gZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9ucyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlc3RpbWF0ZUdhc0xpbWl0Rm9yU2VuZCh7XG4gIHNlbGVjdGVkQWRkcmVzcyxcbiAgdmFsdWUsXG4gIGdhc1ByaWNlLFxuICBzZW5kVG9rZW4sXG4gIHRvLFxuICBkYXRhLFxuICBpc05vblN0YW5kYXJkRXRoQ2hhaW4sXG4gIGNoYWluSWQsXG4gIGdhc0xpbWl0LFxuICAuLi5vcHRpb25zXG59KSB7XG4gIGxldCBpc1NpbXBsZVNlbmRPbk5vblN0YW5kYXJkTmV0d29yayA9IGZhbHNlO1xuXG4gIC8vIGJsb2NrR2FzTGltaXQgbWF5IGJlIGEgZmFsc3ksIGJ1dCBkZWZpbmVkLCB2YWx1ZSB3aGVuIHdlIHJlY2VpdmUgaXQgZnJvbVxuICAvLyBzdGF0ZSwgc28gd2UgdXNlIGxvZ2ljYWwgb3IgdG8gZmFsbCBiYWNrIHRvIE1JTl9HQVNfTElNSVRfSEVYLiBTb21lXG4gIC8vIG5ldHdvcmsgaW1wbGVtZW50YXRpb25zIGNoZWNrIHRoZSBnYXMgcGFyYW1ldGVyIHN1cHBsaWVkIHRvXG4gIC8vIGV0aF9lc3RpbWF0ZUdhcyBmb3IgdmFsaWRpdHkuIEZvciB0aGlzIHJlYXNvbiwgd2Ugc2V0IHRva2VuIHNlbmRzXG4gIC8vIGJsb2NrR2FzTGltaXQgZGVmYXVsdCB0byBhIGhpZ2hlciBudW1iZXIuIE5vdGUgdGhhdCB0aGUgY3VycmVudCBnYXNMaW1pdFxuICAvLyBvbiBhIEJMT0NLIGlzIDE1LDAwMCwwMDAgYW5kIHdpbGwgYmUgMzAsMDAwLDAwMCBvbiBtYWlubmV0IGFmdGVyIExvbmRvbi5cbiAgLy8gTWVhbndoaWxlLCBNSU5fR0FTX0xJTUlUX0hFWCBpcyAweDUyMDguXG4gIGxldCBibG9ja0dhc0xpbWl0ID0gTUlOX0dBU19MSU1JVF9IRVg7XG4gIGlmIChvcHRpb25zLmJsb2NrR2FzTGltaXQpIHtcbiAgICBibG9ja0dhc0xpbWl0ID0gb3B0aW9ucy5ibG9ja0dhc0xpbWl0O1xuICB9IGVsc2UgaWYgKHNlbmRUb2tlbikge1xuICAgIGJsb2NrR2FzTGltaXQgPSBHQVNfTElNSVRTLkJBU0VfVE9LRU5fRVNUSU1BVEU7XG4gIH1cblxuICAvLyBUaGUgcGFyYW1ldGVycyBiZWxvdyB3aWxsIGJlIHNlbnQgdG8gb3VyIGJhY2tncm91bmQgcHJvY2VzcyB0byBlc3RpbWF0ZVxuICAvLyBob3cgbXVjaCBnYXMgd2lsbCBiZSB1c2VkIGZvciBhIHRyYW5zYWN0aW9uLiBUaGF0IGJhY2tncm91bmQgcHJvY2VzcyBpc1xuICAvLyBsb2NhdGVkIGluIHR4LWdhcy11dGlscy5qcyBpbiB0aGUgdHJhbnNhY3Rpb24gY29udHJvbGxlciBmb2xkZXIuXG4gIGNvbnN0IHBhcmFtc0Zvckdhc0VzdGltYXRlID0geyBmcm9tOiBzZWxlY3RlZEFkZHJlc3MsIHZhbHVlLCBnYXNQcmljZSB9O1xuXG4gIGlmIChzZW5kVG9rZW4pIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICAvLyBJZiBubyB0byBhZGRyZXNzIGlzIHByb3ZpZGVkLCB3ZSBjYW5ub3QgZ2VuZXJhdGUgdGhlIHRva2VuIHRyYW5zZmVyXG4gICAgICAvLyBoZXhEYXRhLiBoZXhEYXRhIGluIGEgdHJhbnNhY3Rpb24gbGFyZ2VseSBkaWN0YXRlcyBob3cgbXVjaCBnYXMgd2lsbFxuICAgICAgLy8gYmUgY29uc3VtZWQgYnkgYSB0cmFuc2FjdGlvbi4gV2UgbXVzdCB1c2Ugb3VyIGJlc3QgZ3Vlc3MsIHdoaWNoIGlzXG4gICAgICAvLyByZXByZXNlbnRlZCBpbiB0aGUgZ2FzIHNoYXJlZCBjb25zdGFudHMuXG4gICAgICByZXR1cm4gR0FTX0xJTUlUUy5CQVNFX1RPS0VOX0VTVElNQVRFO1xuICAgIH1cbiAgICBwYXJhbXNGb3JHYXNFc3RpbWF0ZS52YWx1ZSA9ICcweDAnO1xuXG4gICAgLy8gV2UgaGF2ZSB0byBnZW5lcmF0ZSB0aGUgZXJjMjAvZXJjNzIxIGNvbnRyYWN0IGNhbGwgdG8gdHJhbnNmZXIgdG9rZW5zIGluXG4gICAgLy8gb3JkZXIgdG8gZ2V0IGEgcHJvcGVyIGVzdGltYXRlIGZvciBnYXNMaW1pdC5cbiAgICBwYXJhbXNGb3JHYXNFc3RpbWF0ZS5kYXRhID0gZ2V0QXNzZXRUcmFuc2ZlckRhdGEoe1xuICAgICAgc2VuZFRva2VuLFxuICAgICAgZnJvbUFkZHJlc3M6IHNlbGVjdGVkQWRkcmVzcyxcbiAgICAgIHRvQWRkcmVzczogdG8sXG4gICAgICBhbW91bnQ6IHZhbHVlLFxuICAgIH0pO1xuXG4gICAgcGFyYW1zRm9yR2FzRXN0aW1hdGUudG8gPSBzZW5kVG9rZW4uYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIC8vIGV0aC5nZXRDb2RlIHdpbGwgcmV0dXJuIHRoZSBjb21waWxlZCBzbWFydCBjb250cmFjdCBjb2RlIGF0IHRoZVxuICAgICAgLy8gYWRkcmVzcy4gSWYgdGhpcyByZXR1cm5zIDB4LCAweDAgb3IgYSBudWxsaXNoIHZhbHVlIHRoZW4gdGhlIGFkZHJlc3NcbiAgICAgIC8vIGlzIGFuIGV4dGVybmFsbHkgb3duZWQgYWNjb3VudCAoTk9UIGEgY29udHJhY3QgYWNjb3VudCkuIEZvciB0aGVzZVxuICAgICAgLy8gdHlwZXMgb2YgdHJhbnNhY3Rpb25zIHRoZSBnYXNMaW1pdCB3aWxsIGFsd2F5cyBiZSAyMSwwMDAgb3IgMHg1MjA4XG4gICAgICBjb25zdCB7IGlzQ29udHJhY3RBZGRyZXNzIH0gPSB0b1xuICAgICAgICA/IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChnbG9iYWwuZXRoLCB0bylcbiAgICAgICAgOiB7fTtcbiAgICAgIGlmICghaXNDb250cmFjdEFkZHJlc3MgJiYgIWlzTm9uU3RhbmRhcmRFdGhDaGFpbikge1xuICAgICAgICByZXR1cm4gR0FTX0xJTUlUUy5TSU1QTEU7XG4gICAgICB9IGVsc2UgaWYgKCFpc0NvbnRyYWN0QWRkcmVzcyAmJiBpc05vblN0YW5kYXJkRXRoQ2hhaW4pIHtcbiAgICAgICAgaXNTaW1wbGVTZW5kT25Ob25TdGFuZGFyZE5ldHdvcmsgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKHRvKSB7XG4gICAgICBwYXJhbXNGb3JHYXNFc3RpbWF0ZS50byA9IHRvO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUgfHwgdmFsdWUgPT09ICcwJykge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0J3MgZ29pbmcgb24gaGVyZS4gQWNjb3JkaW5nIHRvIGV0aF9lc3RpbWF0ZUdhc1xuICAgICAgLy8gZG9jcyB0aGlzIHZhbHVlIGNhbiBiZSB6ZXJvLCBvciB1bmRlZmluZWQsIHlldCB3ZSBhcmUgc2V0dGluZyBpdCB0byBhXG4gICAgICAvLyB2YWx1ZSBoZXJlIHdoZW4gdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCBvciB6ZXJvLiBGb3IgbW9yZSBjb250ZXh0OlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9wdWxsLzYxOTVcbiAgICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlLnZhbHVlID0gJzB4ZmYnO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNTaW1wbGVTZW5kT25Ob25TdGFuZGFyZE5ldHdvcmspIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgeWV0IGhhdmUgYSBnYXNMaW1pdCwgd2UgbXVzdCBjYWxsIGludG8gb3VyIGJhY2tncm91bmRcbiAgICAvLyBwcm9jZXNzIHRvIGdldCBhbiBlc3RpbWF0ZSBmb3IgZ2FzTGltaXQgYmFzZWQgb24ga25vd24gcGFyYW1ldGVycy5cblxuICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlLmdhcyA9IGFkZEhleFByZWZpeChcbiAgICAgIG11bHRpcGx5Q3VycmVuY2llcyhibG9ja0dhc0xpbWl0LCAwLjk1LCB7XG4gICAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxuICAgICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgICAgIHJvdW5kRG93bjogJzAnLFxuICAgICAgICB0b051bWVyaWNCYXNlOiAnaGV4JyxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvLyBUaGUgYnVmZmVyIG11bHRpcGxlciByZWR1Y2VzIHRyYW5zYWN0aW9uIGZhaWx1cmVzIGJ5IGVuc3VyaW5nIHRoYXQgdGhlXG4gIC8vIGVzdGltYXRlZCBnYXMgaXMgYWx3YXlzIHN1ZmZpY2llbnQuIFdpdGhvdXQgdGhlIG11bHRpcGxpZXIsIGVzdGltYXRlc1xuICAvLyBmb3IgY29udHJhY3QgaW50ZXJhY3Rpb25zIGNhbiBiZWNvbWUgaW5hY2N1cmF0ZSBvdmVyIHRpbWUuIFRoaXMgaXMgYmVjYXVzZVxuICAvLyBnYXMgZXN0aW1hdGlvbiBpcyBub24tZGV0ZXJtaW5pc3RpYy4gVGhlIGdhcyByZXF1aXJlZCBmb3IgdGhlIGV4YWN0IHNhbWVcbiAgLy8gdHJhbnNhY3Rpb24gY2FsbCBjYW4gY2hhbmdlIGJhc2VkIG9uIHN0YXRlIG9mIGEgY29udHJhY3Qgb3IgY2hhbmdlcyBpbiB0aGVcbiAgLy8gY29udHJhY3RzIGVudmlyb25tZW50IChibG9ja2NoYWluIGRhdGEgb3IgY29udHJhY3RzIGl0IGludGVyYWN0cyB3aXRoKS5cbiAgLy8gQXBwbHlpbmcgdGhlIDEuNSBidWZmZXIgaGFzIHByb3ZlbiB0byBiZSBhIHVzZWZ1bCBndWFyZCBhZ2FpbnN0IHRoaXMgbm9uLVxuICAvLyBkZXRlcm1pbmlzdGljIGJlaGF2aW91ci5cbiAgLy9cbiAgLy8gR2FzIGVzdGltYXRpb24gb2Ygc2ltcGxlIHNlbmRzIHNob3VsZCwgaG93ZXZlciwgYmUgZGV0ZXJtaW5pc3RpYy4gQXMgc3VjaFxuICAvLyBubyBidWZmZXIgaXMgbmVlZGVkIGluIHRob3NlIGNhc2VzLlxuICBsZXQgYnVmZmVyTXVsdGlwbGllciA9IDEuNTtcbiAgaWYgKGlzU2ltcGxlU2VuZE9uTm9uU3RhbmRhcmROZXR3b3JrKSB7XG4gICAgYnVmZmVyTXVsdGlwbGllciA9IDE7XG4gIH0gZWxzZSBpZiAoQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF0pIHtcbiAgICBidWZmZXJNdWx0aXBsaWVyID0gQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF07XG4gIH1cblxuICB0cnkge1xuICAgIC8vIENhbGwgaW50byB0aGUgYmFja2dyb3VuZCBwcm9jZXNzIHRoYXQgd2lsbCBzaW11bGF0ZSB0cmFuc2FjdGlvblxuICAgIC8vIGV4ZWN1dGlvbiBvbiB0aGUgbm9kZSBhbmQgcmV0dXJuIGFuIGVzdGltYXRlIG9mIGdhc0xpbWl0XG4gICAgY29uc3QgZXN0aW1hdGVkR2FzTGltaXQgPSBhd2FpdCBlc3RpbWF0ZUdhcyhwYXJhbXNGb3JHYXNFc3RpbWF0ZSk7XG4gICAgY29uc3QgZXN0aW1hdGVXaXRoQnVmZmVyID0gYWRkR2FzQnVmZmVyKFxuICAgICAgZXN0aW1hdGVkR2FzTGltaXQsXG4gICAgICBibG9ja0dhc0xpbWl0LFxuICAgICAgYnVmZmVyTXVsdGlwbGllcixcbiAgICApO1xuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoZXN0aW1hdGVXaXRoQnVmZmVyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBzaW11bGF0aW9uRmFpbGVkID1cbiAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1RyYW5zYWN0aW9uIGV4ZWN1dGlvbiBlcnJvci4nKSB8fFxuICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcbiAgICAgICAgJ2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZSBvciBhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbicsXG4gICAgICApIHx8XG4gICAgICAoQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF0gJiZcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlJykpO1xuICAgIGlmIChzaW11bGF0aW9uRmFpbGVkKSB7XG4gICAgICBjb25zdCBlc3RpbWF0ZVdpdGhCdWZmZXIgPSBhZGRHYXNCdWZmZXIoXG4gICAgICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlPy5nYXMgPz8gZ2FzTGltaXQsXG4gICAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICAgIGJ1ZmZlck11bHRpcGxpZXIsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFkZEhleFByZWZpeChlc3RpbWF0ZVdpdGhCdWZmZXIpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHR4UGFyYW1zIGZyb20gdGhlIHNlbmQgc2xpY2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4nKS5TZW5kU3RhdGV9IHNlbmRTdGF0ZSAtIHRoZSBzdGF0ZSBvZiB0aGUgc2VuZCBzbGljZVxuICogQHJldHVybnMge2ltcG9ydChcbiAqICAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbidcbiAqICkuVHhQYXJhbXN9IEEgdHhQYXJhbXMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgdHJhbnNhY3Rpb24gb3JcbiAqICB1cGRhdGUgYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRyYW5zYWN0aW9uUGFyYW1zKHNlbmRTdGF0ZSkge1xuICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICBzZW5kU3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc2VuZFN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAvLyBJZiB0aGUgZnJvbUFjY291bnQgaGFzIGJlZW4gc3BlY2lmaWVkIHdlIHVzZSB0aGF0LCBpZiBub3Qgd2UgdXNlIHRoZVxuICAgIC8vIHNlbGVjdGVkIGFjY291bnQuXG4gICAgZnJvbTpcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZnJvbUFjY291bnQ/LmFkZHJlc3MgfHxcbiAgICAgIHNlbmRTdGF0ZS5zZWxlY3RlZEFjY291bnQuYWRkcmVzcyxcbiAgICAvLyBnYXNMaW1pdCBhbHdheXMgbmVlZHMgdG8gYmUgc2V0IHJlZ2FyZGxlc3Mgb2YgdGhlIGFzc2V0IGJlaW5nIHNlbnRcbiAgICAvLyBvciB0aGUgdHlwZSBvZiB0cmFuc2FjdGlvbi5cbiAgICBnYXM6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0LFxuICB9O1xuICBzd2l0Y2ggKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSkge1xuICAgIGNhc2UgQVNTRVRfVFlQRVMuVE9LRU46XG4gICAgICAvLyBXaGVuIHNlbmRpbmcgYSB0b2tlbiB0aGUgdG8gYWRkcmVzcyBpcyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZlxuICAgICAgLy8gdGhlIHRva2VuIGJlaW5nIHNlbnQuIFRoZSB2YWx1ZSBpcyBzZXQgdG8gJzB4MCcgYW5kIHRoZSBkYXRhXG4gICAgICAvLyBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVjaXBpZW50IGFkZHJlc3MsIHRva2VuIGJlaW5nIHNlbnQgYW5kXG4gICAgICAvLyBhbW91bnQuXG4gICAgICB0eFBhcmFtcy50byA9IGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscy5hZGRyZXNzO1xuICAgICAgdHhQYXJhbXMudmFsdWUgPSAnMHgwJztcbiAgICAgIHR4UGFyYW1zLmRhdGEgPSBnZW5lcmF0ZUVSQzIwVHJhbnNmZXJEYXRhKHtcbiAgICAgICAgdG9BZGRyZXNzOiBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICBzZW5kVG9rZW46IGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscyxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRTpcbiAgICAgIC8vIFdoZW4gc2VuZGluZyBhIHRva2VuIHRoZSB0byBhZGRyZXNzIGlzIHRoZSBjb250cmFjdCBhZGRyZXNzIG9mXG4gICAgICAvLyB0aGUgdG9rZW4gYmVpbmcgc2VudC4gVGhlIHZhbHVlIGlzIHNldCB0byAnMHgwJyBhbmQgdGhlIGRhdGFcbiAgICAgIC8vIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZWNpcGllbnQgYWRkcmVzcywgdG9rZW4gYmVpbmcgc2VudCBhbmRcbiAgICAgIC8vIGFtb3VudC5cbiAgICAgIHR4UGFyYW1zLnRvID0gZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5kZXRhaWxzLmFkZHJlc3M7XG4gICAgICB0eFBhcmFtcy52YWx1ZSA9ICcweDAnO1xuICAgICAgdHhQYXJhbXMuZGF0YSA9IGdlbmVyYXRlRVJDNzIxVHJhbnNmZXJEYXRhKHtcbiAgICAgICAgdG9BZGRyZXNzOiBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzLFxuICAgICAgICBmcm9tQWRkcmVzczpcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50Py5hZGRyZXNzID8/XG4gICAgICAgICAgc2VuZFN0YXRlLnNlbGVjdGVkQWNjb3VudC5hZGRyZXNzLFxuICAgICAgICB0b2tlbklkOiBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHMudG9rZW5JZCxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBU1NFVF9UWVBFUy5OQVRJVkU6XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFdoZW4gc2VuZGluZyBuYXRpdmUgY3VycmVuY3kgdGhlIHRvIGFuZCB2YWx1ZSBmaWVsZHMgdXNlIHRoZVxuICAgICAgLy8gcmVjaXBpZW50IGFuZCBhbW91bnQgdmFsdWVzIGFuZCB0aGUgZGF0YSBrZXkgaXMgZWl0aGVyIG51bGwgb3JcbiAgICAgIC8vIHBvcHVsYXRlZCB3aXRoIHRoZSB1c2VyIGlucHV0IHByb3ZpZGVkIGluIGhleCBmaWVsZC5cbiAgICAgIHR4UGFyYW1zLnRvID0gZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcztcbiAgICAgIHR4UGFyYW1zLnZhbHVlID0gZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQudmFsdWU7XG4gICAgICB0eFBhcmFtcy5kYXRhID0gZHJhZnRUcmFuc2FjdGlvbi51c2VySW5wdXRIZXhEYXRhID8/IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBpbmNsdWRlIHRoZSByaWdodCBnYXMgZmVlIGZpZWxkc1xuICAvLyBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0cmFuc2FjdGlvbiB0aGUgbmV0d29yayBzdXBwb3J0cy4gV2Ugd2lsbCBhbHNvIHNldFxuICAvLyB0aGUgdHlwZSBwYXJhbSBoZXJlLlxuICBpZiAoc2VuZFN0YXRlLmVpcDE1NTlzdXBwb3J0KSB7XG4gICAgdHhQYXJhbXMudHlwZSA9IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkZFRV9NQVJLRVQ7XG5cbiAgICB0eFBhcmFtcy5tYXhGZWVQZXJHYXMgPSBkcmFmdFRyYW5zYWN0aW9uLmdhcy5tYXhGZWVQZXJHYXM7XG4gICAgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBkcmFmdFRyYW5zYWN0aW9uLmdhcy5tYXhQcmlvcml0eUZlZVBlckdhcztcblxuICAgIGlmICghdHhQYXJhbXMubWF4RmVlUGVyR2FzIHx8IHR4UGFyYW1zLm1heEZlZVBlckdhcyA9PT0gJzB4MCcpIHtcbiAgICAgIHR4UGFyYW1zLm1heEZlZVBlckdhcyA9IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICF0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyB8fFxuICAgICAgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICcweDAnXG4gICAgKSB7XG4gICAgICB0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4UGFyYW1zLm1heEZlZVBlckdhcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdHhQYXJhbXMuZ2FzUHJpY2UgPSBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNQcmljZTtcbiAgICB0eFBhcmFtcy50eXBlID0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuTEVHQUNZO1xuICB9XG5cbiAgcmV0dXJuIHR4UGFyYW1zO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgbG9naWMgZnJvbSB0aGUgZ2FzLmR1Y2suanMgZmlsZVxuICogYWZ0ZXIgcmVjZWl2aW5nIGEgZ2FzUHJpY2UgZnJvbSBldGhfZ2FzUHJpY2UuIEZpcnN0LCB0aGUgcmV0dXJuZWQgZ2FzUHJpY2VcbiAqIHdhcyBjb252ZXJ0ZWQgdG8gR1dFSSwgdGhlbiBpdCB3YXMgY29udmVydGVkIHRvIGEgTnVtYmVyLCB0aGVuIGluIHRoZSBzZW5kXG4gKiBkdWNrIChoZXJlKSB3ZSB3b3VsZCB1c2UgZ2V0R2FzUHJpY2VJbkhleFdlaSB0byBnZXQgYmFjayB0byBoZXhXZWkuIE5vdyB0aGF0XG4gKiB3ZSByZWNlaXZlIGEgR1dFSSBlc3RpbWF0ZSBmcm9tIHRoZSBjb250cm9sbGVyLCB3ZSBzdGlsbCBuZWVkIHRvIGRvIHRoaXNcbiAqIHdlaXJkIGNvbnZlcnNpb24gdG8gZ2V0IHRoZSBwcm9wZXIgcm91bmRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGdhc1ByaWNlRXN0aW1hdGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3VuZGVkR2FzUHJpY2UoZ2FzUHJpY2VFc3RpbWF0ZSkge1xuICBjb25zdCBnYXNQcmljZUluRGVjR3dlaSA9IGNvbnZlcnNpb25VdGlsKGdhc1ByaWNlRXN0aW1hdGUsIHtcbiAgICBudW1iZXJPZkRlY2ltYWxzOiA5LFxuICAgIHRvRGVub21pbmF0aW9uOiBHV0VJLFxuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgZnJvbUN1cnJlbmN5OiBFVEgsXG4gICAgZnJvbURlbm9taW5hdGlvbjogR1dFSSxcbiAgfSk7XG4gIGNvbnN0IGdhc1ByaWNlQXNOdW1iZXIgPSBOdW1iZXIoZ2FzUHJpY2VJbkRlY0d3ZWkpO1xuICByZXR1cm4gZ2V0R2FzUHJpY2VJbkhleFdlaShnYXNQcmljZUFzTnVtYmVyKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVSQzIwQmFsYW5jZSh0b2tlbiwgYWNjb3VudEFkZHJlc3MpIHtcbiAgY29uc3QgY29udHJhY3QgPSBnbG9iYWwuZXRoLmNvbnRyYWN0KGFiaSkuYXQodG9rZW4uYWRkcmVzcyk7XG4gIGNvbnN0IHVzZXJzVG9rZW4gPSAoYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKGFjY291bnRBZGRyZXNzKSkgPz8gbnVsbDtcbiAgaWYgKCF1c2Vyc1Rva2VuKSB7XG4gICAgcmV0dXJuICcweDAnO1xuICB9XG4gIGNvbnN0IGFtb3VudCA9IGNhbGNUb2tlbkFtb3VudChcbiAgICB1c2Vyc1Rva2VuLmJhbGFuY2UudG9TdHJpbmcoKSxcbiAgICB0b2tlbi5kZWNpbWFscyxcbiAgKS50b1N0cmluZygxNik7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoYW1vdW50KTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vc2VuZCc7XHJcbiIsImltcG9ydCB7IGNyZWF0ZUFzeW5jVGh1bmssIGNyZWF0ZVNsaWNlIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQge1xuICBjb252ZXJzaW9uR3JlYXRlclRoYW4sXG4gIGNvbnZlcnNpb25VdGlsLFxuICBtdWx0aXBseUN1cnJlbmNpZXMsXG4gIHN1YnRyYWN0Q3VycmVuY2llcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBHQVNfRVNUSU1BVEVfVFlQRVMsIEdBU19MSU1JVFMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2dhcyc7XG5pbXBvcnQge1xuICBDT05UUkFDVF9BRERSRVNTX0VSUk9SLFxuICBJTlNVRkZJQ0lFTlRfRlVORFNfRVJST1IsXG4gIElOU1VGRklDSUVOVF9UT0tFTlNfRVJST1IsXG4gIElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfRVJST1IsXG4gIElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfTk9UX0VUSF9ORVRXT1JLX0VSUk9SLFxuICBLTk9XTl9SRUNJUElFTlRfQUREUkVTU19XQVJOSU5HLFxuICBORUdBVElWRV9FVEhfRVJST1IsXG4gIFJFQ0lQSUVOVF9UWVBFUyxcbn0gZnJvbSAnLi4vLi4vcGFnZXMvc2VuZC9zZW5kLmNvbnN0YW50cyc7XG5cbmltcG9ydCB7XG4gIGlzQmFsYW5jZVN1ZmZpY2llbnQsXG4gIGlzVG9rZW5CYWxhbmNlU3VmZmljaWVudCxcbn0gZnJvbSAnLi4vLi4vcGFnZXMvc2VuZC9zZW5kLnV0aWxzJztcbmltcG9ydCB7XG4gIGdldEFkdmFuY2VkSW5saW5lR2FzU2hvd24sXG4gIGdldEN1cnJlbnRDaGFpbklkLFxuICBnZXRHYXNQcmljZUluSGV4V2VpLFxuICBnZXRJc01haW5uZXQsXG4gIGdldFRhcmdldEFjY291bnQsXG4gIGdldElzTm9uU3RhbmRhcmRFdGhDaGFpbixcbiAgY2hlY2tOZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OSxcbiAgZ2V0VXNlVG9rZW5EZXRlY3Rpb24sXG4gIGdldFRva2VuTGlzdCxcbiAgZ2V0QWRkcmVzc0Jvb2tFbnRyeU9yQWNjb3VudE5hbWUsXG4gIGdldElzTXVsdGlMYXllckZlZU5ldHdvcmssXG4gIGdldEVuc1Jlc29sdXRpb25CeUFkZHJlc3MsXG4gIGdldFNlbGVjdGVkQWNjb3VudCxcbiAgZ2V0U2VsZWN0ZWRBZGRyZXNzLFxufSBmcm9tICcuLi8uLi9zZWxlY3RvcnMnO1xuaW1wb3J0IHtcbiAgZGlzY29ubmVjdEdhc0ZlZUVzdGltYXRlUG9sbGVyLFxuICBkaXNwbGF5V2FybmluZyxcbiAgZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nLFxuICBoaWRlTG9hZGluZ0luZGljYXRpb24sXG4gIHNob3dMb2FkaW5nSW5kaWNhdGlvbixcbiAgdXBkYXRlRWRpdGFibGVQYXJhbXMsXG4gIHVwZGF0ZVRyYW5zYWN0aW9uR2FzRmVlcyxcbiAgYWRkUG9sbGluZ1Rva2VuVG9BcHBTdGF0ZSxcbiAgcmVtb3ZlUG9sbGluZ1Rva2VuRnJvbUFwcFN0YXRlLFxuICBpc0NvbGxlY3RpYmxlT3duZXIsXG4gIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzLFxuICBzaG93TW9kYWwsXG4gIGFkZFVuYXBwcm92ZWRUcmFuc2FjdGlvbkFuZFJvdXRlVG9Db25maXJtYXRpb25QYWdlLFxuICB1cGRhdGVUcmFuc2FjdGlvblNlbmRGbG93SGlzdG9yeSxcbn0gZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgeyBzZXRDdXN0b21HYXNMaW1pdCB9IGZyb20gJy4uL2dhcy9nYXMuZHVjayc7XG5pbXBvcnQge1xuICBRUl9DT0RFX0RFVEVDVEVELFxuICBTRUxFQ1RFRF9BQ0NPVU5UX0NIQU5HRUQsXG4gIEFDQ09VTlRfQ0hBTkdFRCxcbiAgQUREUkVTU19CT09LX1VQREFURUQsXG4gIEdBU19GRUVfRVNUSU1BVEVTX1VQREFURUQsXG59IGZyb20gJy4uLy4uL3N0b3JlL2FjdGlvbkNvbnN0YW50cyc7XG5pbXBvcnQge1xuICBnZXRUb2tlbkFkZHJlc3NQYXJhbSxcbiAgZ2V0VG9rZW5NZXRhZGF0YSxcbiAgZ2V0VG9rZW5JZFBhcmFtLFxufSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzL3Rva2VuLXV0aWwnO1xuaW1wb3J0IHtcbiAgY2hlY2tFeGlzdGluZ0FkZHJlc3NlcyxcbiAgaXNEZWZhdWx0TWV0YU1hc2tDaGFpbixcbiAgaXNPcmlnaW5Db250cmFjdEFkZHJlc3MsXG4gIGlzVmFsaWREb21haW5OYW1lLFxufSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHtcbiAgZ2V0R2FzRXN0aW1hdGVUeXBlLFxuICBnZXRUb2tlbnMsXG4gIGdldFVuYXBwcm92ZWRUeHMsXG59IGZyb20gJy4uL21ldGFtYXNrL21ldGFtYXNrJztcblxuaW1wb3J0IHsgcmVzZXRFbnNSZXNvbHV0aW9uIH0gZnJvbSAnLi4vZW5zJztcbmltcG9ydCB7XG4gIGlzQnVybkFkZHJlc3MsXG4gIGlzVmFsaWRIZXhBZGRyZXNzLFxuICB0b0NoZWNrc3VtSGV4QWRkcmVzcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcbmltcG9ydCB7XG4gIGlzU21hcnRDb250cmFjdEFkZHJlc3MsXG4gIHN1bUhleGVzLFxufSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzL3RyYW5zYWN0aW9ucy51dGlsJztcbmltcG9ydCBmZXRjaEVzdGltYXRlZEwxRmVlIGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMvb3B0aW1pc20vZmV0Y2hFc3RpbWF0ZWRMMUZlZSc7XG5cbmltcG9ydCB7IEVUSCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvY29uc3RhbnRzL2NvbW1vbic7XG5pbXBvcnQge1xuICBBU1NFVF9UWVBFUyxcbiAgVE9LRU5fU1RBTkRBUkRTLFxuICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgSU5WQUxJRF9BU1NFVF9UWVBFIH0gZnJvbSAnLi4vLi4vaGVscGVycy9jb25zdGFudHMvZXJyb3Ita2V5cyc7XG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvc3RyaW5nLXV0aWxzJztcbmltcG9ydCB7IGdldFZhbHVlRnJvbVdlaUhleCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMvY29uZmlybS10eC51dGlsJztcbmltcG9ydCB7IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3RyYW5zYWN0aW9uLnV0aWxzJztcbmltcG9ydCB7IGdldFRva2VuVmFsdWVQYXJhbSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvbWV0YW1hc2stY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQge1xuICBjYWxjR2FzVG90YWwsXG4gIGNhbGNUb2tlbkFtb3VudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi90cmFuc2FjdGlvbnMtY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQge1xuICBlc3RpbWF0ZUdhc0xpbWl0Rm9yU2VuZCxcbiAgZ2VuZXJhdGVUcmFuc2FjdGlvblBhcmFtcyxcbiAgZ2V0Um91bmRlZEdhc1ByaWNlLFxufSBmcm9tICcuL2hlbHBlcnMnO1xuLy8gdHlwZWRlZiBpbXBvcnQgc3RhdGVtZW50c1xuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnaW1tZXIvZGlzdC9pbnRlcm5hbCcpLldyaXRhYmxlRHJhZnQ8U2VuZFN0YXRlPlxuICogKX0gU2VuZFN0YXRlRHJhZnRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuQXNzZXRUeXBlc1N0cmluZ1xuICogKX0gQXNzZXRUeXBlc1N0cmluZ1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoICcuLi8uLi9oZWxwZXJzL2NvbnN0YW50cy9jb21tb24nKS5Ub2tlblN0YW5kYXJkU3RyaW5nc1xuICogKX0gVG9rZW5TdGFuZGFyZFN0cmluZ3NcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90b2tlbnMnKS5Ub2tlbkRldGFpbHNcbiAqICl9IFRva2VuRGV0YWlsc1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nKS5UcmFuc2FjdGlvblR5cGVTdHJpbmdcbiAqICl9IFRyYW5zYWN0aW9uVHlwZVN0cmluZ1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0BtZXRhbWFzay9jb250cm9sbGVycycpLkxlZ2FjeUdhc1ByaWNlRXN0aW1hdGVcbiAqICl9IExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAbWV0YW1hc2svY29udHJvbGxlcnMnKS5HYXNGZWVFc3RpbWF0ZXNcbiAqICl9IEdhc0ZlZUVzdGltYXRlc1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0BtZXRhbWFzay9jb250cm9sbGVycycpLkV0aEdhc1ByaWNlRXN0aW1hdGVcbiAqICl9IEV0aEdhc1ByaWNlRXN0aW1hdGVcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAbWV0YW1hc2svY29udHJvbGxlcnMnKS5HYXNFc3RpbWF0ZVR5cGVcbiAqICl9IEdhc0VzdGltYXRlVHlwZVxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ3JlZHV4JykuQW55QWN0aW9uXG4gKiApfSBBbnlBY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBSIC0gUmV0dXJuIHR5cGUgb2YgdGhlIGFzeW5jIGZ1bmN0aW9uXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgncmVkdXgtdGh1bmsnKS5UaHVua0FjdGlvbjxSLCBNZXRhTWFza1N0YXRlLCB1bmtub3duLCBBbnlBY3Rpb24+XG4gKiApfSBUaHVua0FjdGlvbjxSPlxuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHdpbGwgdGFrZSBhIHR5cGljYWwgY29uc3RhbnQgc3RyaW5nIG1hcHBlZCBvYmplY3QgYW5kIHR1cm4gaXQgaW50b1xuICogYSB1bmlvbiB0eXBlIG9mIHRoZSB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIE8gLSBUaGUgb2JqZWN0IHRvIG1ha2Ugc3RyaW5ncyBvdXQgb2ZcbiAqIEB0eXBlZGVmIHtPW2tleW9mIE9dfSBNYXBWYWx1ZXNUb1VuaW9uPE8+XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZW5kU3RhdGVTdGFnZXNcbiAqIEBwcm9wZXJ0eSB7J0FERF9SRUNJUElFTlQnfSBBRERfUkVDSVBJRU5UIC0gVGhlIHVzZXIgaXMgc2VsZWN0aW5nIHdoaWNoXG4gKiAgYWRkcmVzcyB0byBzZW5kIGFuIGFzc2V0IHRvLlxuICogQHByb3BlcnR5IHsnRFJBRlQnfSBEUkFGVCAtIFRoZSBzZW5kIGZvcm0gaXMgc2hvd24gZm9yIGEgdHJhbnNhY3Rpb24geWV0IHRvXG4gKiAgYmUgc2VudCB0byB0aGUgVHJhbnNhY3Rpb24gQ29udHJvbGxlci5cbiAqIEBwcm9wZXJ0eSB7J0VESVQnfSBFRElUIC0gVGhlIHNlbmQgZm9ybSBpcyBzaG93biBmb3IgYSB0cmFuc2FjdGlvbiBhbHJlYWR5XG4gKiAgc3VibWl0dGVkIHRvIHRoZSBUcmFuc2FjdGlvbiBDb250cm9sbGVyIGJ1dCBub3QgeWV0IGNvbmZpcm1lZC4gVGhpcyBoYXBwZW5zXG4gKiAgd2hlbiBhIGNvbmZpcm1hdGlvbiBpcyBzaG93biBmb3IgYSB0cmFuc2FjdGlvbiBhbmQgdGhlICdlZGl0JyBidXR0b24gaW4gdGhlXG4gKiAgaGVhZGVyIGlzIGNsaWNrZWQuXG4gKiBAcHJvcGVydHkgeydJTkFDVElWRSd9IElOQUNUSVZFIC0gVGhlIHNlbmQgc3RhdGUgaXMgaWRsZSwgYW5kIGhhc24ndCB5ZXRcbiAqICBmZXRjaGVkIHJlcXVpcmVkIGRhdGEgZm9yIGdhc1ByaWNlIGFuZCBnYXNMaW1pdCBlc3RpbWF0aW9ucywgZXRjLlxuICovXG5cbi8qKlxuICogVGhlIFN0YWdlcyB0aGF0IHRoZSBzZW5kIHNsaWNlIGNhbiBiZSBpblxuICpcbiAqIEB0eXBlIHtTZW5kU3RhdGVTdGFnZXN9XG4gKi9cbmV4cG9ydCBjb25zdCBTRU5EX1NUQUdFUyA9IHtcbiAgQUREX1JFQ0lQSUVOVDogJ0FERF9SRUNJUElFTlQnLFxuICBEUkFGVDogJ0RSQUZUJyxcbiAgRURJVDogJ0VESVQnLFxuICBJTkFDVElWRTogJ0lOQUNUSVZFJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRHJhZnRUeFN0YXR1c1xuICogQHByb3BlcnR5IHsnSU5WQUxJRCd9IElOVkFMSUQgLSBUaGUgdHJhbnNhY3Rpb24gaXMgaW52YWxpZCBhbmQgY2Fubm90IGJlXG4gKiAgc3VibWl0dGVkLiBUaGVyZSBhcmUgYSBudW1iZXIgb2YgY2FzZXMgdGhhdCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZFxuICogIHNlbmQgc3RhdGU6XG4gKiAgMS4gVGhlIHJlY2lwaWVudCBpcyBub3QgeWV0IGRlZmluZWRcbiAqICAyLiBUaGUgYW1vdW50ICsgZ2FzVG90YWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB1c2VyJ3MgYmFsYW5jZSB3aGVuIHNlbmRpbmdcbiAqICAgICBuYXRpdmUgY3VycmVuY3lcbiAqICAzLiBUaGUgZ2FzVG90YWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB1c2VyJ3MgKm5hdGl2ZSogYmFsYW5jZVxuICogIDQuIFRoZSBhbW91bnQgb2Ygc2VudCBhc3NldCBpcyBncmVhdGVyIHRoYW4gdGhlIHVzZXIncyAqYXNzZXQqIGJhbGFuY2VcbiAqICA1LiBHYXMgcHJpY2UgZXN0aW1hdGVzIGZhaWxlZCB0byBsb2FkIGVudGlyZWx5XG4gKiAgNi4gVGhlIGdhc0xpbWl0IGlzIGxlc3MgdGhhbiAyMTAwMCAoMHg1MjA4KVxuICogQHByb3BlcnR5IHsnVkFMSUQnfSBWQUxJRCAtIFRoZSB0cmFuc2FjdGlvbiBpcyB2YWxpZCBhbmQgY2FuIGJlIHN1Ym1pdHRlZC5cbiAqL1xuXG4vKipcbiAqIFRoZSBzdGF0dXMgb2YgdGhlIHNlbmQgc2xpY2VcbiAqXG4gKiBAdHlwZSB7RHJhZnRUeFN0YXR1c31cbiAqL1xuZXhwb3J0IGNvbnN0IFNFTkRfU1RBVFVTRVMgPSB7XG4gIElOVkFMSUQ6ICdJTlZBTElEJyxcbiAgVkFMSUQ6ICdWQUxJRCcsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlbmRTdGF0ZUdhc01vZGVzXG4gKiBAcHJvcGVydHkgeydCQVNJQyd9IEJBU0lDIC0gU2hvd3MgdGhlIGJhc2ljIGVzdGltYXRlIHNsb3cvYXZnL2Zhc3QgYnV0dG9uc1xuICogIHdoZW4gb24gbWFpbm5ldCBhbmQgdGhlIG1ldGFzd2FwcyBBUEkgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICogQHByb3BlcnR5IHsnQ1VTVE9NJ30gQ1VTVE9NIC0gU2hvd3MgR2FzRmVlRGlzcGxheSBjb21wb25lbnQgdGhhdCBpcyBhIHJlYWRcbiAqICBvbmx5IGRpc3BsYXkgb2YgdGhlIHZhbHVlcyB0aGUgdXNlciBoYXMgc2V0IGluIHRoZSBhZHZhbmNlZCBnYXMgbW9kYWxcbiAqICAoc3RvcmVkIGluIHRoZSBnYXMgZHVjayB1bmRlciB0aGUgY3VzdG9tRGF0YSBrZXkpLlxuICogQHByb3BlcnR5IHsnSU5MSU5FJ30gSU5MSU5FIC0gU2hvd3MgaW5saW5lIGdhc0xpbWl0L2dhc1ByaWNlIGZpZWxkcyB3aGVuIG9uXG4gKiAgYW55IG90aGVyIG5ldHdvcmsgb3IgbWV0YXN3YXBzIEFQSSBmYWlscyBhbmQgd2UgdXNlIGV0aF9nYXNQcmljZS5cbiAqL1xuXG4vKipcbiAqIENvbnRyb2xzIHdoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBzZW5kLWdhcy1yb3cgY29tcG9uZW50LlxuICpcbiAqIEB0eXBlIHtTZW5kU3RhdGVHYXNNb2Rlc31cbiAqL1xuZXhwb3J0IGNvbnN0IEdBU19JTlBVVF9NT0RFUyA9IHtcbiAgQkFTSUM6ICdCQVNJQycsXG4gIENVU1RPTTogJ0NVU1RPTScsXG4gIElOTElORTogJ0lOTElORScsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlbmRTdGF0ZUFtb3VudE1vZGVzXG4gKiBAcHJvcGVydHkgeydJTlBVVCd9IElOUFVUIC0gdGhlIHVzZXIgcHJvdmlkZXMgdGhlIGFtb3VudCBieSB0eXBpbmcgaW4gdGhlXG4gKiAgZmllbGQuXG4gKiBAcHJvcGVydHkgeydNQVgnfSBNQVggLSBUaGUgdXNlciBzZWxlY3RzIHRoZSBNQVggYnV0dG9uIGFuZCBhbW91bnQgaXNcbiAqICBjYWxjdWxhdGVkIGJhc2VkIG9uIGJhbGFuY2UgLSAoYW1vdW50ICsgZ2FzVG90YWwpLlxuICovXG5cbi8qKlxuICogVGhlIG1vZGVzIHRoYXQgdGhlIGFtb3VudCBmaWVsZCBjYW4gYmUgc2V0IGJ5XG4gKlxuICogQHR5cGUge1NlbmRTdGF0ZUFtb3VudE1vZGVzfVxuICovXG5leHBvcnQgY29uc3QgQU1PVU5UX01PREVTID0ge1xuICBJTlBVVDogJ0lOUFVUJyxcbiAgTUFYOiAnTUFYJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU2VuZFN0YXRlUmVjaXBpZW50TW9kZXNcbiAqIEBwcm9wZXJ0eSB7J0NPTlRBQ1RfTElTVCd9IENPTlRBQ1RfTElTVCAtIFRoZSB1c2VyIGlzIGRpc3BsYXllZCBhIGxpc3Qgb2ZcbiAqICB0aGVpciBjb250YWN0cyBhbmQgYWRkcmVzc2VzIHRoZXkgaGF2ZSByZWNlbnRseSBzZW5kIHRvLlxuICogQHByb3BlcnR5IHsnTVlfQUNDT1VOVFMnfSBNWV9BQ0NPVU5UUyAtIHRoZSB1c2VyIGlzIGRpc3BsYXllZCBhIGxpc3Qgb2ZcbiAqICB0aGVpciBvd24gYWNjb3VudHMgdG8gc2VuZCB0by5cbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHJlY2lwaWVudCBsaXN0IHRoYXQgaXMgZGlzcGxheWVkIHRvIHVzZXJcbiAqXG4gKiBAdHlwZSB7U2VuZFN0YXRlUmVjaXBpZW50TW9kZXN9XG4gKi9cbmV4cG9ydCBjb25zdCBSRUNJUElFTlRfU0VBUkNIX01PREVTID0ge1xuICBDT05UQUNUX0xJU1Q6ICdDT05UQUNUX0xJU1QnLFxuICBNWV9BQ0NPVU5UUzogJ01ZX0FDQ09VTlRTJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQWNjb3VudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgaGV4IGFkZHJlc3Mgb2YgdGhlIGFjY291bnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmFsYW5jZSAtIEhleCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuYXRpdmUgYXNzZXRcbiAqICBiYWxhbmNlIG9mIHRoZSBhY2NvdW50IHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHNlbnQgZnJvbS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEFtb3VudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvcl0gLSBFcnJvciB0byBkaXNwbGF5IGZvciB0aGUgYW1vdW50IGZpZWxkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlIC0gQSBoZXggc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYW1vdW50IG9mIHRoZVxuICogIHNlbGVjdGVkIGN1cnJlbmN5IHRvIHNlbmQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBBc3NldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhbGFuY2UgLSBBIGhleCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBiYWxhbmNlXG4gKiAgdGhhdCB0aGUgdXNlciBob2xkcyBvZiB0aGUgYXNzZXQgdGhhdCB0aGV5IGFyZSBhdHRlbXB0aW5nIHRvIHNlbmQuXG4gKiBAcHJvcGVydHkge1Rva2VuRGV0YWlsc30gW2RldGFpbHNdIC0gQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZVxuICogIHNlbGVjdGVkIGFzc2V0IGluIHRoZSBjYXNlIHRoYXQgdGhlIHVzZXIgaXMgc2VuZGluZyBhIHRva2VuIG9yIGNvbGxlY3RpYmUuXG4gKiAgV2lsbCBiZSBudWxsIHdoZW4gYXNzZXQudHlwZSBpcyAnTkFUSVZFJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JdIC0gRXJyb3IgdG8gZGlzcGxheSB3aGVuIHRoZXJlIGlzIGFuIGlzc3VlXG4gKiAgd2l0aCB0aGUgYXNzZXQuXG4gKiBAcHJvcGVydHkge0Fzc2V0VHlwZXNTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBhc3NldCB0aGF0IHRoZSB1c2VyXG4gKiAgaXMgYXR0ZW1wdGluZyB0byBzZW5kLiBEZWZhdWx0cyB0byAnTkFUSVZFJyB3aGljaCByZXByZXNlbnRzIHRoZSBuYXRpdmVcbiAqICBhc3NldCBvZiB0aGUgY2hhaW4uIENhbiBhbHNvIGJlICdUT0tFTicgb3IgJ0NPTExFQ1RJQkxFJy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEdhc0ZlZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JdIC0gZXJyb3IgdG8gZGlzcGxheSBmb3IgZ2FzIGZpZWxkcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnYXNMaW1pdCAtIG1heGltdW0gZ2FzIG5lZWRlZCBmb3IgdHguXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzUHJpY2UgLSBwcmljZSBpbiB3ZWkgdG8gcGF5IHBlciBnYXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzVG90YWwgLSBtYXhpbXVtIHRvdGFsIHByaWNlIGluIHdlaSB0byBwYXkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWF4RmVlUGVyR2FzIC0gTWF4aW11bSBwcmljZSBpbiB3ZWkgdG8gcGF5IHBlciBnYXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWF4UHJpb3JpdHlGZWVQZXJHYXMgLSBNYXhpbXVtIHByaW9yaXR5IGZlZSBpbiB3ZWkgdG8gcGF5XG4gKiAgcGVyIGdhcy5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgaW50ZW5kZWQgcmVjaXBpZW50IG9mIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gUmVjaXBpZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBmdWxseSBxdWFsaWZpZWQgYWRkcmVzcyBvZiB0aGUgcmVjaXBpZW50LlxuICogIFRoaXMgaXMgc2V0IGFmdGVyIHRoZSByZWNpcGllbnQudXNlcklucHV0IGlzIHZhbGlkYXRlZCwgdGhlIHVzZXJJbnB1dCBmaWVsZFxuICogIGlzIHF1aWNrbHkgdXBkYXRlZCB0byBhdm9pZCBkZWxheSBiZXR3ZWVuIGtleXN0cm9rZXMgYW5kIHNlZWluZyB0aGUgaW5wdXRcbiAqICBmaWVsZCB1cGRhdGVkLiBBZnRlciBhIGRlYm91bmNlIHRoZSBhZGRyZXNzIHR5cGVkIGlzIHZhbGlkYXRlZCBhbmQgdGhlbiB0aGVcbiAqICBhZGRyZXNzIGZpZWxkIGlzIHVwZGF0ZWQuIFRoZSBhZGRyZXNzIGZpZWxkIGlzIGFsc28gc2V0IHdoZW4gdGhlIHVzZXJcbiAqICBzZWxlY3RzIGEgY29udGFjdCBvciBhY2NvdW50IGZyb20gdGhlIGxpc3QsIG9yIGFuIEVOUyByZXNvbHV0aW9uIHdoZW5cbiAqICB0eXBpbmcgRU5TIG5hbWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvcl0gLSBFcnJvciB0byBkaXNwbGF5IG9uIHRoZSBhZGRyZXNzIGZpZWxkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5pY2tuYW1lIC0gVGhlIG5pY2tuYW1lIHRoYXQgdGhlIHVzZXIgaGFzIGFkZGVkIHRvIHRoZWlyXG4gKiAgYWRkcmVzcyBib29rIGZvciB0aGUgcmVjaXBpZW50LmFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3dhcm5pbmddIC0gV2FybmluZyB0byBkaXNwbGF5IG9uIHRoZSBhZGRyZXNzIGZpZWxkLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRHJhZnRUcmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtBbW91bnR9IGFtb3VudCAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogIGFtb3VudCBvZiBjdXJyZW5jeSB0byBzZW5kLlxuICogQHByb3BlcnR5IHtBc3NldH0gYXNzZXQgLSBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGFzc2V0IHRoYXQgdGhlIHVzZXJcbiAqICBoYXMgc2VsZWN0ZWQgdG8gc2VuZC5cbiAqIEBwcm9wZXJ0eSB7QWNjb3VudH0gW2Zyb21BY2NvdW50XSAtIFRoZSBzZW5kIGZsb3cgaXMgdXN1YWxseSBvbmx5IHJlbGF0aXZlIHRvXG4gKiAgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBhY2NvdW50LiBXaGVuIGVkaXRpbmcgYSB0cmFuc2FjdGlvbiwgaG93ZXZlciwgdGhlXG4gKiAgYWNjb3VudCBtYXkgZGlmZmVyLiBJbiB0aGF0IGNhc2UsIHRoZSBkZXRhaWxzIG9mIHRoYXQgYWNjb3VudCB3aWxsIGJlXG4gKiAgc3RvcmVkIGluIHRoaXMgb2JqZWN0IHdpdGhpbiB0aGUgZHJhZnRUcmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7R2FzRmVlc30gZ2FzIC0gRGV0YWlscyBhYm91dCB0aGUgY3VycmVudCBnYXMgc2V0dGluZ3NcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8e2V2ZW50OiBzdHJpbmcsIHRpbWVzdGFtcDogbnVtYmVyfT59IGhpc3RvcnkgLSBBbiBhcnJheSBvZlxuICogIGVudHJpZXMgdGhhdCBkZXNjcmliZSB0aGUgdXNlcidzIGpvdXJuZXkgdGhyb3VnaCB0aGUgc2VuZCBmbG93LiBUaGlzIGlzXG4gKiAgc2VudCB0byB0aGUgY29udHJvbGxlciBmb3IgYXR0YWNoaW5nIHRvIHN0YXRlIGxvZ3MgZm9yIHRyb3VibGVzaG9vdGluZyBhbmRcbiAqICBzdXBwb3J0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF0gLSBJZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGVcbiAqICBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgdGhpcyBmaWVsZCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGl0cyBpZCBmcm9tIHRoZVxuICogIFRyYW5zYWN0aW9uQ29udHJvbGxlciBzdGF0ZS4gVGhpcyBpcyByZXF1aXJlZCB0byBiZSBhYmxlIHRvIHVwZGF0ZSB0aGVcbiAqICB0cmFuc2FjdGlvbiBpbiB0aGUgY29udHJvbGxlci5cbiAqIEBwcm9wZXJ0eSB7UmVjaXBpZW50fSByZWNpcGllbnQgLSBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGludGVuZGVkXG4gKiAgcmVjaXBpZW50IG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7TWFwVmFsdWVzVG9VbmlvbjxEcmFmdFR4U3RhdHVzPn0gc3RhdHVzIC0gRGVzY3JpYmVzIHRoZVxuICogIHZhbGlkaXR5IG9mIHRoZSBkcmFmdCB0cmFuc2FjdGlvbiwgd2hpY2ggd2lsbCBiZSBlaXRoZXIgJ1ZBTElEJyBvclxuICogICdJTlZBTElEJywgZGVwZW5kaW5nIG9uIG91ciBhYmlsaXR5IHRvIGdlbmVyYXRlIGEgdmFsaWQgdHhQYXJhbXMgb2JqZWN0IGZvclxuICogIHN1Ym1pc3Npb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHJhbnNhY3Rpb25UeXBlIC0gRGV0ZXJtaW5lcyB0eXBlIG9mIHRyYW5zYWN0aW9uIGJlaW5nXG4gKiAgc2VudCwgZGVmYXVsdGVkIHRvIDB4MCAobGVnYWN5KS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXNlcklucHV0SGV4RGF0YV0gLSBXaGVuIGEgdXNlciBoYXMgZW5hYmxlZCBjdXN0b20gaGV4XG4gKiAgZGF0YSBmaWVsZCBpbiBhZHZhbmNlZCBvcHRpb25zLCB0aGV5IGNhbiBzdXBwbHkgZGF0YSB0byB0aGUgZmllbGQgd2hpY2ggaXNcbiAqICBzdG9yZWQgdW5kZXIgdGhpcyBrZXkuXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7RHJhZnRUcmFuc2FjdGlvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUgPSB7XG4gIGFtb3VudDoge1xuICAgIGVycm9yOiBudWxsLFxuICAgIHZhbHVlOiAnMHgwJyxcbiAgfSxcbiAgYXNzZXQ6IHtcbiAgICBiYWxhbmNlOiAnMHgwJyxcbiAgICBkZXRhaWxzOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIHR5cGU6IEFTU0VUX1RZUEVTLk5BVElWRSxcbiAgfSxcbiAgZnJvbUFjY291bnQ6IG51bGwsXG4gIGdhczoge1xuICAgIGVycm9yOiBudWxsLFxuICAgIGdhc0xpbWl0OiAnMHgwJyxcbiAgICBnYXNQcmljZTogJzB4MCcsXG4gICAgZ2FzVG90YWw6ICcweDAnLFxuICAgIG1heEZlZVBlckdhczogJzB4MCcsXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6ICcweDAnLFxuICAgIHdhc01hbnVhbGx5RWRpdGVkOiBmYWxzZSxcbiAgfSxcbiAgaGlzdG9yeTogW10sXG4gIGlkOiBudWxsLFxuICByZWNpcGllbnQ6IHtcbiAgICBhZGRyZXNzOiAnJyxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBuaWNrbmFtZTogJycsXG4gICAgd2FybmluZzogbnVsbCxcbiAgICB0eXBlOiAnJyxcbiAgICByZWNpcGllbnRXYXJuaW5nQWNrbm93bGVkZ2VkOiBmYWxzZSxcbiAgfSxcbiAgc3RhdHVzOiBTRU5EX1NUQVRVU0VTLlZBTElELFxuICB0cmFuc2FjdGlvblR5cGU6IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkxFR0FDWSxcbiAgdXNlcklucHV0SGV4RGF0YTogbnVsbCxcbn07XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBzdGF0ZSB0cmVlIG9mIHRoZSBzZW5kIHNsaWNlXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gU2VuZFN0YXRlXG4gKiBAcHJvcGVydHkge01hcFZhbHVlc1RvVW5pb248U2VuZFN0YXRlQW1vdW50TW9kZXM+fSBhbW91bnRNb2RlIC0gRGVzY3JpYmVcbiAqICB3aGV0aGVyIHRoZSB1c2VyIGhhcyBtYW51YWxseSBpbnB1dCBhbiBhbW91bnQgb3IgaWYgdGhleSBoYXZlIHNlbGVjdGVkIG1heFxuICogIHRvIHNlbmQgdGhlIG1heGltdW0gYW1vdW50IG9mIHRoZSBzZWxlY3RlZCBjdXJyZW5jeS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50VHJhbnNhY3Rpb25VVUlEIC0gVGhlIFVVSUQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gKiAgY3VycmVudGx5IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzZW5kIGZsb3cuIFRoaXMgVVVJRCBpcyBnZW5lcmF0ZWQgdXBvblxuICogIGluaXRpYWxpemF0aW9uIG9mIHRoZSBzZW5kIGZsb3csIGFueSBwcmV2aW91cyBVVUlEcyBhcmUgZGlzY2FyZGVkIGF0XG4gKiAgY2xlYW4gdXAgQU5EIGR1cmluZyBpbml0aWFsaXphdGlvbi4gV2hlbiBhIHRyYW5zYWN0aW9uIGlzIGVkaXRlZCBhIG5ldyBVVUlEXG4gKiAgaXMgZ2VuZXJhdGVkIGZvciBpdCBhbmQgdGhlIHN0YXRlIG9mIHRoYXQgdHJhbnNhY3Rpb24gaXMgY29waWVkIGludG8gYSBuZXdcbiAqICBlbnRyeSBpbiB0aGUgZHJhZnRUcmFuc2FjdGlvbnMgb2JqZWN0LlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBEcmFmdFRyYW5zYWN0aW9uPn0gZHJhZnRUcmFuc2FjdGlvbnMgLSBBbiBvYmplY3Qga2V5ZWRcbiAqICBieSBVVUlEIHdpdGggZHJhZnRUcmFuc2FjdGlvbnMgYXMgdGhlIHZhbHVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZWlwMTU1OXN1cHBvcnQgLSB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCBuZXR3b3JrXG4gKiAgc3VwcG9ydHMgRUlQIDE1NTkgdHJhbnNhY3Rpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBnYXNFc3RpbWF0ZUlzTG9hZGluZyAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBnYXNcbiAqICBlc3RpbWF0ZSBpcyBsb2FkaW5nLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtnYXNFc3RpbWF0ZVBvbGxUb2tlbl0gLSBTdHJpbmcgdG9rZW4gaWRlbnRpZnlpbmcgYVxuICogIGxpc3RlbmVyIGZvciBwb2xsaW5nIG9uIHRoZSBnYXNGZWVDb250cm9sbGVyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGdhc0lzU2V0SW5Nb2RhbCAtIHRydWUgaWYgdGhlIHVzZXIgc2V0IGN1c3RvbSBnYXMgaW4gdGhlXG4gKiAgY3VzdG9tIGdhcyBtb2RhbFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdhc0xpbWl0TWluaW11bSAtIG1pbmltdW0gc3VwcG9ydGVkIGdhc0xpbWl0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdhc1ByaWNlRXN0aW1hdGUgLSBFeHBlY3RlZCBwcmljZSBpbiB3ZWkgbmVjZXNzYXJ5IHRvXG4gKiAgcGF5IHBlciBnYXMgdXNlZCBmb3IgYSB0cmFuc2FjdGlvbiB0byBiZSBpbmNsdWRlZCBpbiBhIHJlYXNvbmFibGUgdGltZWZyYW1lLlxuICogIENvbWVzIGZyb20gdGhlIEdhc0ZlZUNvbnRyb2xsZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzVG90YWxGb3JMYXllcjEgLSAgTGF5ZXIgMSBnYXMgZmVlIHRvdGFsIG9uIG11bHRpLWxheWVyXG4gKiAgZmVlIG5ldHdvcmtzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVjaXBpZW50SW5wdXQgLSBUaGUgdXNlciBpbnB1dCBvZiB0aGUgcmVjaXBpZW50XG4gKiAgd2hpY2ggaXMgdXBkYXRlZCBxdWlja2x5IHRvIGF2b2lkIGRlbGF5cyBpbiB0aGUgVUkgcmVmbGVjdGluZyBtYW51YWwgZW50cnlcbiAqICBvZiBhZGRyZXNzZXMuXG4gKiBAcHJvcGVydHkge01hcFZhbHVlc1RvVW5pb248U2VuZFN0YXRlUmVjaXBpZW50TW9kZXM+fSByZWNpcGllbnRNb2RlIC1cbiAqICBEZXNjcmliZXMgd2hpY2ggbGlzdCBvZiByZWNpcGllbnRzIHRoZSB1c2VyIGlzIHNob3duIG9uIHRoZSBhZGQgcmVjaXBpZW50XG4gKiAgc2NyZWVuLiBXaGVuIHRoaXMga2V5IGlzIHNldCB0byAnTVlfQUNDT1VOVFMnIHRoZSB1c2VyIGlzIHNob3duIHRoZSBsaXN0IG9mXG4gKiAgYWNjb3VudHMgdGhleSBvd24uIFdoZW4gaXQgaXMgJ0NPTlRBQ1RfTElTVCcgdGhlIHVzZXIgaXMgc2hvd24gdGhlIGxpc3Qgb2ZcbiAqICBjb250YWN0cyB0aGV5IGhhdmUgc2F2ZWQgaW4gTWV0YU1hc2sgYW5kIGFueSBhZGRyZXNzZXMgdGhleSBoYXZlIHJlY2VudGx5XG4gKiAgc2VudCB0by5cbiAqIEBwcm9wZXJ0eSB7QWNjb3VudH0gc2VsZWN0ZWRBY2NvdW50IC0gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBhY2NvdW50IGluXG4gKiAgTWV0YU1hc2suIE5hdGl2ZSBiYWxhbmNlIGFuZCBhZGRyZXNzIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhpcyBhY2NvdW50IGlmIGFcbiAqICBmcm9tQWNjb3VudCBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBkcmFmdFRyYW5zYWN0aW9uIG9iamVjdC4gRHVyaW5nIGFuIGVkaXRcbiAqICB0aGUgZnJvbUFjY291bnQgaXMgc3BlY2lmaWVkLlxuICogQHByb3BlcnR5IHtNYXBWYWx1ZXNUb1VuaW9uPFNlbmRTdGF0ZVN0YWdlcz59IHN0YWdlIC0gVGhlIHN0YWdlIG9mIHRoZVxuICogIHNlbmQgZmxvdyB0aGF0IHRoZSB1c2VyIGhhcyBwcm9ncmVzc2VkIHRvLiBEZWZhdWx0cyB0byAnSU5BQ1RJVkUnIHdoaWNoXG4gKiAgcmVzdWx0cyBpbiB0aGUgc2VuZCBzY3JlZW4gbm90IGJlaW5nIHNob3duLlxuICovXG5cbi8qKlxuICogQHR5cGUge1NlbmRTdGF0ZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgYW1vdW50TW9kZTogQU1PVU5UX01PREVTLklOUFVULFxuICBjdXJyZW50VHJhbnNhY3Rpb25VVUlEOiBudWxsLFxuICBkcmFmdFRyYW5zYWN0aW9uczoge30sXG4gIGVpcDE1NTlzdXBwb3J0OiBmYWxzZSxcbiAgZ2FzRXN0aW1hdGVJc0xvYWRpbmc6IHRydWUsXG4gIGdhc0VzdGltYXRlUG9sbFRva2VuOiBudWxsLFxuICBnYXNJc1NldEluTW9kYWw6IGZhbHNlLFxuICBnYXNQcmljZUVzdGltYXRlOiAnMHgwJyxcbiAgZ2FzTGltaXRNaW5pbXVtOiBHQVNfTElNSVRTLlNJTVBMRSxcbiAgZ2FzVG90YWxGb3JMYXllcjE6ICcweDAnLFxuICByZWNpcGllbnRNb2RlOiBSRUNJUElFTlRfU0VBUkNIX01PREVTLkNPTlRBQ1RfTElTVCxcbiAgcmVjaXBpZW50SW5wdXQ6ICcnLFxuICBzZWxlY3RlZEFjY291bnQ6IHtcbiAgICBhZGRyZXNzOiBudWxsLFxuICAgIGJhbGFuY2U6ICcweDAnLFxuICB9LFxuICBzdGFnZTogU0VORF9TVEFHRVMuSU5BQ1RJVkUsXG59O1xuXG4vKipcbiAqIFRPRE86IFdlIHJlYWxseSBuZWVkIHRvIHN0YXJ0IGNyZWF0aW5nIHRoZSBtZXRhbWFzayBzdGF0ZSB0eXBlLCBhbmQgdGhlXG4gKiBlbnRpcmUgc3RhdGUgdHJlZSBvZiByZWR1eC4gV291bGQgYmUgKmV4dHJlbWVseSogdmFsdWFibGUgaW4gZnV0dXJlXG4gKiB0eXBlc2NyaXB0IGNvbnZlcnNpb25zLiBUaGUgbWV0YW1hc2sga2V5IGlzIHR5cGVkIGFzIGFuIG9iamVjdCBvbiBwdXJwb3NlXG4gKiBoZXJlIGJlY2F1c2UgSSBjYW5ub3QgZ28gc28gZmFyIGluIHRoaXMgd29yayBhcyB0byB0eXBlIHRoYXQgZW50aXJlIG9iamVjdC5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWFza1N0YXRlXG4gKiBAcHJvcGVydHkge1NlbmRTdGF0ZX0gc2VuZCAtIFRoZSBzdGF0ZSBvZiB0aGUgc2VuZCBmbG93LlxuICogQHByb3BlcnR5IHtvYmplY3R9IG1ldGFtYXNrIC0gVGhlIHN0YXRlIG9mIHRoZSBtZXRhbWFzayBzdG9yZS5cbiAqL1xuXG5jb25zdCBuYW1lID0gJ3NlbmQnO1xuXG4vLyBBZnRlciBtb2RpZmljYXRpb24gb2Ygc3BlY2lmaWMgZmllbGRzIGluIHNwZWNpZmljIGNpcmN1bXN0YW5jZXMgd2UgbXVzdFxuLy8gcmVjb21wdXRlIHRoZSBnYXNMaW1pdCBlc3RpbWF0ZSB0byBiZSBhcyBhY2N1cmF0ZSBhcyBwb3NzaWJsZS4gdGhlIGNhc2VzXG4vLyB0aGF0IG5lY2Vzc2l0YXRlIHRoaXMgbG9naWMgYXJlIGxpc3RlZCBiZWxvdzpcbi8vIDEuIHdoZW4gdGhlIGFtb3VudCBzZW50IGNoYW5nZXMgd2hlbiBzZW5kaW5nIGEgdG9rZW4gZHVlIHRvIHRoZSBhbW91bnQgYmVpbmdcbi8vICAgIHBhcnQgb2YgdGhlIGhleCBlbmNvZGVkIGRhdGEgcHJvcGVydHkgb2YgdGhlIHRyYW5zYWN0aW9uLlxuLy8gMi4gd2hlbiB1cGRhdGluZyB0aGUgZGF0YSBwcm9wZXJ0eSB3aGlsZSBzZW5kaW5nIE5BVElWRSBjdXJyZW5jeSAoZXg6IEVUSClcbi8vICAgIGJlY2F1c2UgdGhlIGRhdGEgcGFyYW1ldGVyIGRlZmluZXMgZnVuY3Rpb24gY2FsbHMgdGhhdCB0aGUgRVZNIHdpbGwgaGF2ZVxuLy8gICAgdG8gZXhlY3V0ZSB3aGljaCBpcyB3aGVyZSBhIGxhcmdlIGNodW5rIG9mIGdhcyBpcyBwb3RlbnRpYWxseSBjb25zdW1lZC5cbi8vIDMuIHdoZW4gdGhlIHJlY2lwaWVudCBjaGFuZ2VzIHdoaWxlIHNlbmRpbmcgYSB0b2tlbiBkdWUgdG8gdGhlIHJlY2lwaWVudCdzXG4vLyAgICBhZGRyZXNzIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBoZXggZW5jb2RlZCBkYXRhIHByb3BlcnR5IG9mIHRoZVxuLy8gICAgdHJhbnNhY3Rpb25cbi8vIDQuIHdoZW4gdGhlIGFzc2V0IGJlaW5nIHNlbnQgY2hhbmdlcyBkdWUgdG8gdGhlIGNvbnRyYWN0IGFkZHJlc3MgYW5kIGRldGFpbHNcbi8vICAgIG9mIHRoZSB0b2tlbiBiZWluZyBpbmNsdWRlZCBpbiB0aGUgaGV4IGVuY29kZWQgZGF0YSBwcm9wZXJ0eSBvZiB0aGVcbi8vICAgIHRyYW5zYWN0aW9uLiBJZiBzd2l0Y2hpbmcgdG8gTkFUSVZFIGN1cnJlbmN5IChleDogRVRIKSwgdGhlIGdhc0xpbWl0IHdpbGxcbi8vICAgIGNoYW5nZSBkdWUgdG8gaGV4IGRhdGEgYmVpbmcgcmVtb3ZlZCAodW5sZXNzIHN1cHBsaWVkIGJ5IHVzZXIpLlxuLy8gVGhpcyBtZXRob2QgY29tcHV0ZXMgdGhlIGdhc0xpbWl0IGVzdGltYXRlIHdoaWNoIGlzIHdyaXR0ZW4gdG8gc3RhdGUgaW4gYW5cbi8vIGFjdGlvbiBoYW5kbGVyIGluIGV4dHJhUmVkdWNlcnMuXG5leHBvcnQgY29uc3QgY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0ID0gY3JlYXRlQXN5bmNUaHVuayhcbiAgJ3NlbmQvY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0JyxcbiAgYXN5bmMgKF8sIHRodW5rQXBpKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aHVua0FwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgc2VuZCwgbWV0YW1hc2sgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc2VuZC5kcmFmdFRyYW5zYWN0aW9uc1tzZW5kLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgIGNvbnN0IHVuYXBwcm92ZWRUeHMgPSBnZXRVbmFwcHJvdmVkVHhzKHN0YXRlKTtcbiAgICBjb25zdCBpc011bHRpTGF5ZXJGZWVOZXR3b3JrID0gZ2V0SXNNdWx0aUxheWVyRmVlTmV0d29yayhzdGF0ZSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB1bmFwcHJvdmVkVHhzW2RyYWZ0VHJhbnNhY3Rpb24uaWRdO1xuICAgIGNvbnN0IGlzTm9uU3RhbmRhcmRFdGhDaGFpbiA9IGdldElzTm9uU3RhbmRhcmRFdGhDaGFpbihzdGF0ZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKHN0YXRlKTtcblxuICAgIGxldCBnYXNUb3RhbEZvckxheWVyMTtcbiAgICBpZiAoaXNNdWx0aUxheWVyRmVlTmV0d29yaykge1xuICAgICAgZ2FzVG90YWxGb3JMYXllcjEgPSBhd2FpdCBmZXRjaEVzdGltYXRlZEwxRmVlKGdsb2JhbC5ldGgsIHtcbiAgICAgICAgdHhQYXJhbXM6IHtcbiAgICAgICAgICBnYXNQcmljZTogZHJhZnRUcmFuc2FjdGlvbi5nYXMuZ2FzUHJpY2UsXG4gICAgICAgICAgZ2FzOiBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCxcbiAgICAgICAgICB0bzogZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcz8udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgIHNlbmQuYW1vdW50TW9kZSA9PT0gQU1PVU5UX01PREVTLk1BWFxuICAgICAgICAgICAgICA/IHNlbmQuc2VsZWN0ZWRBY2NvdW50LmJhbGFuY2VcbiAgICAgICAgICAgICAgOiBkcmFmdFRyYW5zYWN0aW9uLmFtb3VudC52YWx1ZSxcbiAgICAgICAgICBmcm9tOiBzZW5kLnNlbGVjdGVkQWNjb3VudC5hZGRyZXNzLFxuICAgICAgICAgIGRhdGE6IGRyYWZ0VHJhbnNhY3Rpb24udXNlcklucHV0SGV4RGF0YSxcbiAgICAgICAgICB0eXBlOiAnMHgwJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHNlbmQuc3RhZ2UgIT09IFNFTkRfU1RBR0VTLkVESVQgfHxcbiAgICAgICF0cmFuc2FjdGlvbi5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8uZ2FzIHx8XG4gICAgICAhdHJhbnNhY3Rpb24udXNlckVkaXRlZEdhc0xpbWl0XG4gICAgKSB7XG4gICAgICBjb25zdCBnYXNMaW1pdCA9IGF3YWl0IGVzdGltYXRlR2FzTGltaXRGb3JTZW5kKHtcbiAgICAgICAgZ2FzUHJpY2U6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlLFxuICAgICAgICBibG9ja0dhc0xpbWl0OiBtZXRhbWFzay5jdXJyZW50QmxvY2tHYXNMaW1pdCxcbiAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOiBtZXRhbWFzay5zZWxlY3RlZEFkZHJlc3MsXG4gICAgICAgIHNlbmRUb2tlbjogZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5kZXRhaWxzLFxuICAgICAgICB0bzogZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcz8udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgdmFsdWU6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICBkYXRhOiBkcmFmdFRyYW5zYWN0aW9uLnVzZXJJbnB1dEhleERhdGEsXG4gICAgICAgIGlzTm9uU3RhbmRhcmRFdGhDaGFpbixcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgZ2FzTGltaXQ6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0LFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aHVua0FwaS5kaXNwYXRjaChzZXRDdXN0b21HYXNMaW1pdChnYXNMaW1pdCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgIGdhc1RvdGFsRm9yTGF5ZXIxLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEFzc2V0XG4gKiBAcHJvcGVydHkge0Fzc2V0VHlwZXNTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBhc3NldCB0aGF0IHRoZSB1c2VyXG4gKiAgaXMgYXR0ZW1wdGluZyB0byBzZW5kLiBEZWZhdWx0cyB0byAnTkFUSVZFJyB3aGljaCByZXByZXNlbnRzIHRoZSBuYXRpdmVcbiAqICBhc3NldCBvZiB0aGUgY2hhaW4uIENhbiBhbHNvIGJlICdUT0tFTicgb3IgJ0NPTExFQ1RJQkxFJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWxhbmNlIC0gQSBoZXggc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYmFsYW5jZVxuICogIHRoYXQgdGhlIHVzZXIgaG9sZHMgb2YgdGhlIGFzc2V0IHRoYXQgdGhleSBhcmUgYXR0ZW1wdGluZyB0byBzZW5kLlxuICogQHByb3BlcnR5IHtUb2tlbkRldGFpbHN9IFtkZXRhaWxzXSAtIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGVcbiAqICBzZWxlY3RlZCBhc3NldCBpbiB0aGUgY2FzZSB0aGF0IHRoZSB1c2VyIGlzIHNlbmRpbmcgYSB0b2tlbiBvciBjb2xsZWN0aWJlLlxuICogIFdpbGwgYmUgbnVsbCB3aGVuIGFzc2V0LnR5cGUgaXMgJ05BVElWRScuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Vycm9yXSAtIEVycm9yIHRvIGRpc3BsYXkgd2hlbiB0aGVyZSBpcyBhbiBpc3N1ZVxuICogIHdpdGggdGhlIGFzc2V0LlxuICovXG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIGluaXRpYWxpemluZyByZXF1aXJlZCBzdGF0ZSBmb3IgdGhlIHNlbmQgc2xpY2UuXG4gKiBUaGlzIG1ldGhvZCBpcyBkaXNwYXRjaGVkIGZyb20gdGhlIHNlbmQgcGFnZSBpbiB0aGUgY29tcG9uZW50RGlkTW91bnRcbiAqIG1ldGhvZC4gSXQgaXMgYWxzbyBkaXNwYXRjaGVkIGFueXRpbWUgdGhlIG5ldHdvcmsgY2hhbmdlcyB0byBlbnN1cmUgdGhhdFxuICogdGhlIHNsaWNlIHJlbWFpbnMgdmFsaWQgd2l0aCBjaGFuZ2luZyB0b2tlbiBhbmQgYWNjb3VudCBiYWxhbmNlcy4gVG8gZG8gc29cbiAqIGl0IGtleXMgaW50byBzdGF0ZSB0byBnZXQgbmVjZXNzYXJ5IHZhbHVlcyBhbmQgY29tcHV0ZXMgYSBzdGFydGluZyBwb2ludCBmb3JcbiAqIHRoZSBzZW5kIHNsaWNlLiBJdCByZXR1cm5zIHRoZSB2YWx1ZXMgdGhhdCBtaWdodCBjaGFuZ2UgZnJvbSB0aGlzIGFjdGlvbiBhbmRcbiAqIHRob3NlIHZhbHVlcyBhcmUgd3JpdHRlbiB0byB0aGUgc2xpY2UgaW4gdGhlIGBpbml0aWFsaXplU2VuZFN0YXRlLmZ1bGZpbGxlZGBcbiAqIGFjdGlvbiBoYW5kbGVyLlxuICovXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVNlbmRTdGF0ZSA9IGNyZWF0ZUFzeW5jVGh1bmsoXG4gICdzZW5kL2luaXRpYWxpemVTZW5kU3RhdGUnLFxuICBhc3luYyAoeyBjaGFpbkhhc0NoYW5nZWQgPSBmYWxzZSB9ID0ge30sIHRodW5rQXBpKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge29iamVjdH0gUmVkdXhTdGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBtZXRhbWFzayAtIEhhbGYgYmFrZWQgdHlwZSBmb3IgdGhlIE1ldGFNYXNrIG9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7U2VuZFN0YXRlfSBzZW5kIC0gdGhlIHNlbmQgc3RhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZWR1eFN0YXRlfVxuICAgICAqL1xuICAgIGNvbnN0IHN0YXRlID0gdGh1bmtBcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc05vblN0YW5kYXJkRXRoQ2hhaW4gPSBnZXRJc05vblN0YW5kYXJkRXRoQ2hhaW4oc3RhdGUpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSk7XG4gICAgY29uc3QgZWlwMTU1OXN1cHBvcnQgPSBjaGVja05ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5KHN0YXRlKTtcbiAgICBjb25zdCBhY2NvdW50ID0gZ2V0U2VsZWN0ZWRBY2NvdW50KHN0YXRlKTtcbiAgICBjb25zdCB7IHNlbmQ6IHNlbmRTdGF0ZSwgbWV0YW1hc2sgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc2VuZFN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3NlbmRTdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcblxuICAgIC8vIElmIHRoZSBkcmFmdCB0cmFuc2FjdGlvbiBpcyBub3QgcHJlc2VudCwgdGhlbiB0aGlzIGFjdGlvbiBoYXMgYmVlblxuICAgIC8vIGRpc3BhdGNoZWQgb3V0IG9mIHN5bmMgd2l0aCB0aGUgaW50ZW5kZWQgZmxvdy4gVGhpcyBpcyBub3QgYWx3YXlzIGEgYnVnLlxuICAgIC8vIEZvciBpbnN0YW5jZSwgaW4gdGhlIGFjdGlvbnMuanMgZmlsZSB3ZSBkaXNwYXRjaCB0aGlzIGFjdGlvbiBhbnl0aW1lIHRoZVxuICAgIC8vIGNoYWluIGNoYW5nZXMuXG4gICAgaWYgKCFkcmFmdFRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGh1bmtBcGkucmVqZWN0V2l0aFZhbHVlKFxuICAgICAgICAnZHJhZnRUcmFuc2FjdGlvbiBub3QgZm91bmQsIHBvc3NpYmx5IG5vdCBvbiBzZW5kIGZsb3cnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGdhc1ByaWNlIHRvIDEgZ3dlaSBpZiBhbGwgZXN0aW1hdGlvbiBmYWlscywgdGhpcyBpcyBvbmx5IHVzZWRcbiAgICAvLyBmb3IgZ2FzTGltaXQgZXN0aW1hdGlvbiBhbmQgd29uJ3QgYmUgc2V0IGRpcmVjdGx5IGluIHN0YXRlLiBJbnN0ZWFkLCB3ZVxuICAgIC8vIHdpbGwgcmV0dXJuIHRoZSBnYXNGZWVFc3RpbWF0ZXMgYW5kIGdhc0VzdGltYXRlVHlwZSBzbyB0aGF0IHRoZSByZWR1Y2VyXG4gICAgLy8gY2FuIHNldCB0aGUgYXBwcm9wcmlhdGUgZ2FzIGZlZXMgaW4gc3RhdGUuXG4gICAgbGV0IGdhc1ByaWNlID1cbiAgICAgIHNlbmRTdGF0ZS5zdGFnZSA9PT0gU0VORF9TVEFHRVMuRURJVFxuICAgICAgICA/IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlXG4gICAgICAgIDogJzB4MSc7XG4gICAgbGV0IGdhc0VzdGltYXRlUG9sbFRva2VuID0gbnVsbDtcblxuICAgIC8vIEluc3RydWN0IHRoZSBiYWNrZ3JvdW5kIHByb2Nlc3MgdGhhdCBwb2xsaW5nIGZvciBnYXMgcHJpY2VzIHNob3VsZCBiZWdpblxuICAgIGdhc0VzdGltYXRlUG9sbFRva2VuID0gYXdhaXQgZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nKCk7XG5cbiAgICBhZGRQb2xsaW5nVG9rZW5Ub0FwcFN0YXRlKGdhc0VzdGltYXRlUG9sbFRva2VuKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIG1ldGFtYXNrOiB7IGdhc0ZlZUVzdGltYXRlcywgZ2FzRXN0aW1hdGVUeXBlIH0sXG4gICAgfSA9IHRodW5rQXBpLmdldFN0YXRlKCk7XG5cbiAgICBpZiAoc2VuZFN0YXRlLnN0YWdlICE9PSBTRU5EX1NUQUdFUy5FRElUKSB7XG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gZ2V0dGluZyBhIGdhc0xpbWl0IGVzdGltYXRpb24gd2Ugb25seVxuICAgICAgLy8gbmVlZCB0byB3b3JyeSBhYm91dCBnYXNQcmljZS4gU28gd2UgdXNlIG1heEZlZVBlckdhcyBhcyBnYXNQcmljZSBpZiB3ZVxuICAgICAgLy8gaGF2ZSBhIGZlZSBtYXJrZXQgZXN0aW1hdGlvbi5cbiAgICAgIGlmIChnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5MRUdBQ1kpIHtcbiAgICAgICAgZ2FzUHJpY2UgPSBnZXRHYXNQcmljZUluSGV4V2VpKGdhc0ZlZUVzdGltYXRlcy5tZWRpdW0pO1xuICAgICAgfSBlbHNlIGlmIChnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5FVEhfR0FTUFJJQ0UpIHtcbiAgICAgICAgZ2FzUHJpY2UgPSBnZXRSb3VuZGVkR2FzUHJpY2UoZ2FzRmVlRXN0aW1hdGVzLmdhc1ByaWNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2FzRXN0aW1hdGVUeXBlID09PSBHQVNfRVNUSU1BVEVfVFlQRVMuRkVFX01BUktFVCkge1xuICAgICAgICBnYXNQcmljZSA9IGdldEdhc1ByaWNlSW5IZXhXZWkoXG4gICAgICAgICAgZ2FzRmVlRXN0aW1hdGVzLm1lZGl1bS5zdWdnZXN0ZWRNYXhGZWVQZXJHYXMsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYXNQcmljZSA9IGdhc0ZlZUVzdGltYXRlcy5nYXNQcmljZVxuICAgICAgICAgID8gZ2V0Um91bmRlZEdhc1ByaWNlKGdhc0ZlZUVzdGltYXRlcy5nYXNQcmljZSlcbiAgICAgICAgICA6ICcweDAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBhIGJhc2ljIGdhc0xpbWl0IGluIHRoZSBldmVudCB0aGF0IG90aGVyIGVzdGltYXRpb24gZmFpbHNcbiAgICBsZXQgeyBnYXNMaW1pdCB9ID0gZHJhZnRUcmFuc2FjdGlvbi5nYXM7XG4gICAgaWYgKFxuICAgICAgZ2FzRXN0aW1hdGVUeXBlICE9PSBHQVNfRVNUSU1BVEVfVFlQRVMuTk9ORSAmJlxuICAgICAgc2VuZFN0YXRlLnN0YWdlICE9PSBTRU5EX1NUQUdFUy5FRElUICYmXG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzXG4gICAgKSB7XG4gICAgICBnYXNMaW1pdCA9XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4gfHxcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgICAgID8gR0FTX0xJTUlUUy5CQVNFX1RPS0VOX0VTVElNQVRFXG4gICAgICAgICAgOiBHQVNfTElNSVRTLlNJTVBMRTtcbiAgICAgIC8vIFJ1biBvdXIgZXN0aW1hdGVHYXNMaW1pdCBsb2dpYyB0byBnZXQgYSBtb3JlIGFjY3VyYXRlIGVzdGltYXRpb24gb2ZcbiAgICAgIC8vIHJlcXVpcmVkIGdhcy4gSWYgdGhpcyB2YWx1ZSBpc24ndCBudWxsaXNoLCBzZXQgaXQgYXMgdGhlIG5ldyBnYXNMaW1pdFxuICAgICAgY29uc3QgZXN0aW1hdGVkR2FzTGltaXQgPSBhd2FpdCBlc3RpbWF0ZUdhc0xpbWl0Rm9yU2VuZCh7XG4gICAgICAgIGdhc1ByaWNlLFxuICAgICAgICBibG9ja0dhc0xpbWl0OiBtZXRhbWFzay5jdXJyZW50QmxvY2tHYXNMaW1pdCxcbiAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOlxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZnJvbUFjY291bnQ/LmFkZHJlc3MgPz9cbiAgICAgICAgICBzZW5kU3RhdGUuc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MsXG4gICAgICAgIHNlbmRUb2tlbjogZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5kZXRhaWxzLFxuICAgICAgICB0bzogZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICB2YWx1ZTogZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQudmFsdWUsXG4gICAgICAgIGRhdGE6IGRyYWZ0VHJhbnNhY3Rpb24udXNlcklucHV0SGV4RGF0YSxcbiAgICAgICAgaXNOb25TdGFuZGFyZEV0aENoYWluLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgfSk7XG4gICAgICBnYXNMaW1pdCA9IGVzdGltYXRlZEdhc0xpbWl0IHx8IGdhc0xpbWl0O1xuICAgIH1cbiAgICAvLyBXZSBoYXZlIHRvIGtlZXAgdGhlIGdhcyBzbGljZSBpbiBzeW5jIHdpdGggdGhlIHNlbmQgc2xpY2Ugc3RhdGVcbiAgICAvLyBzbyB0aGF0IGl0J2xsIGJlIGluaXRpYWxpemVkIGNvcnJlY3RseSBpZiB0aGUgZ2FzIG1vZGFsIGlzIG9wZW5lZC5cbiAgICBhd2FpdCB0aHVua0FwaS5kaXNwYXRjaChzZXRDdXN0b21HYXNMaW1pdChnYXNMaW1pdCkpO1xuXG4gICAgLy8gVGhlcmUgbWF5IGJlIGEgY2FzZSB3aGVyZSB0aGUgc2VuZCBoYXMgYmVlbiBjYW5jZWxlZCBieSB0aGUgdXNlciB3aGlsZVxuICAgIC8vIHRoZSBnYXMgZXN0aW1hdGUgaXMgYmVpbmcgY29tcHV0ZWQuIFNvIHdlIGNoZWNrIGFnYWluIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgLy8gYSBjdXJyZW50VHJhbnNhY3Rpb25VVUlEIGV4aXN0cyBhbmQgbWF0Y2hlcyB0aGUgcHJldmlvdXMgdHguXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aHVua0FwaS5nZXRTdGF0ZSgpO1xuICAgIGlmIChcbiAgICAgIG5ld1N0YXRlLnNlbmQuY3VycmVudFRyYW5zYWN0aW9uVVVJRCAhPT0gc2VuZFN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURcbiAgICApIHtcbiAgICAgIHJldHVybiB0aHVua0FwaS5yZWplY3RXaXRoVmFsdWUoXG4gICAgICAgIGBkcmFmdFRyYW5zYWN0aW9uIGNoYW5nZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgICAgICBBIG5ldyBpbml0aWFsaXplU2VuZFN0YXRlIGFjdGlvbiBtdXN0IGJlIGRpc3BhdGNoZWQuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnQsXG4gICAgICBjaGFpbklkOiBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSksXG4gICAgICB0b2tlbnM6IGdldFRva2VucyhzdGF0ZSksXG4gICAgICBjaGFpbkhhc0NoYW5nZWQsXG4gICAgICBnYXNGZWVFc3RpbWF0ZXMsXG4gICAgICBnYXNFc3RpbWF0ZVR5cGUsXG4gICAgICBnYXNMaW1pdCxcbiAgICAgIGdhc1RvdGFsOiBhZGRIZXhQcmVmaXgoY2FsY0dhc1RvdGFsKGdhc0xpbWl0LCBnYXNQcmljZSkpLFxuICAgICAgZ2FzRXN0aW1hdGVQb2xsVG9rZW4sXG4gICAgICBlaXAxNTU5c3VwcG9ydCxcbiAgICAgIHVzZVRva2VuRGV0ZWN0aW9uOiBnZXRVc2VUb2tlbkRldGVjdGlvbihzdGF0ZSksXG4gICAgICB0b2tlbkFkZHJlc3NMaXN0OiBPYmplY3Qua2V5cyhnZXRUb2tlbkxpc3Qoc3RhdGUpKSxcbiAgICB9O1xuICB9LFxuKTtcblxuLy8gQWN0aW9uIFBheWxvYWQgVHlwZWRlZnNcbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0ByZWR1eGpzL3Rvb2xraXQnKS5QYXlsb2FkQWN0aW9uPHN0cmluZz5cbiAqICl9IFNpbXBsZVN0cmluZ1BheWxvYWRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAcmVkdXhqcy90b29sa2l0JykuUGF5bG9hZEFjdGlvbjxNYXBWYWx1ZXNUb1VuaW9uPFNlbmRTdGF0ZUFtb3VudE1vZGVzPj5cbiAqICl9IFNlbmRTdGF0ZUFtb3VudE1vZGVQYXlsb2FkXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnQHJlZHV4anMvdG9vbGtpdCcpLlBheWxvYWRBY3Rpb248RHJhZnRUcmFuc2FjdGlvblsnYXNzZXQnXT5cbiAqICl9IFVwZGF0ZUFzc2V0UGF5bG9hZFxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0ByZWR1eGpzL3Rvb2xraXQnKS5QYXlsb2FkQWN0aW9uPFBhcnRpYWw8XG4gKiAgIFBpY2s8RHJhZnRUcmFuc2FjdGlvblsncmVjaXBpZW50J10sICdhZGRyZXNzJyB8ICduaWNrbmFtZSc+PlxuICogID5cbiAqICl9IHVwZGF0ZVJlY2lwaWVudFBheWxvYWRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAcmVkdXhqcy90b29sa2l0JykuUGF5bG9hZEFjdGlvbjxTZW5kU3RhdGVbJ3JlY2lwaWVudE1vZGUnXT5cbiAqICl9IFVwZGF0ZVJlY2lwaWVudE1vZGVQYXlsb2FkXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBHYXNGZWVVcGRhdGVQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7VHJhbnNhY3Rpb25UeXBlU3RyaW5nfSB0cmFuc2FjdGlvblR5cGUgLSBUaGUgdHJhbnNhY3Rpb24gdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFttYXhGZWVQZXJHYXNdIC0gVGhlIG1heGltdW0gYW1vdW50IGluIGhleCB3ZWkgdG8gcGF5XG4gKiAgcGVyIGdhcyBvbiBhIEZFRV9NQVJLRVQgdHJhbnNhY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21heFByaW9yaXR5RmVlUGVyR2FzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBpbiBoZXhcbiAqICB3ZWkgdG8gcGF5IHBlciBnYXMgYXMgYW4gaW5jZW50aXZlIHRvIG1pbmVycyBvbiBhIEZFRV9NQVJLRVRcbiAqICB0cmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2FzUHJpY2VdIC0gVGhlIGFtb3VudCBpbiBoZXggd2VpIHRvIHBheSBwZXIgZ2FzIG9uXG4gKiAgYSBMRUdBQ1kgdHJhbnNhY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpc0F1dG9tYXRpY1VwZGF0ZV0gLSB0cnVlIGlmIHRoZSB1cGRhdGUgaXMgdGhlXG4gKiAgcmVzdWx0IG9mIGEgZ2FzIGVzdGltYXRlIHVwZGF0ZSBmcm9tIHRoZSBjb250cm9sbGVyLlxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0ByZWR1eGpzL3Rvb2xraXQnKS5QYXlsb2FkQWN0aW9uPEdhc0ZlZVVwZGF0ZVBhcmFtcz5cbiAqICl9IEdhc0ZlZVVwZGF0ZVBheWxvYWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEdhc0VzdGltYXRlVXBkYXRlUGFyYW1zXG4gKiBAcHJvcGVydHkge0dhc0VzdGltYXRlVHlwZX0gZ2FzRXN0aW1hdGVUeXBlIC0gVGhlIHR5cGUgb2YgZ2FzIGVzdGltYXRpb25cbiAqICBwcm92aWRlZCBieSB0aGUgY29udHJvbGxlci5cbiAqIEBwcm9wZXJ0eSB7KFxuICogIEV0aEdhc1ByaWNlRXN0aW1hdGUgfCBMZWdhY3lHYXNQcmljZUVzdGltYXRlIHwgR2FzRmVlRXN0aW1hdGVzXG4gKiApfSBnYXNGZWVFc3RpbWF0ZXMgLSBUaGUgZ2FzIGZlZSBlc3RpbWF0ZXMgcHJvdmlkZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnQHJlZHV4anMvdG9vbGtpdCcpLlBheWxvYWRBY3Rpb248R2FzRXN0aW1hdGVVcGRhdGVQYXJhbXM+XG4gKiApfSBHYXNFc3RpbWF0ZVVwZGF0ZVBheWxvYWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAcmVkdXhqcy90b29sa2l0JykuUGF5bG9hZEFjdGlvbjxEcmFmdFRyYW5zYWN0aW9uWydhc3NldCddPlxuICogKX0gVXBkYXRlQXNzZXRQYXlsb2FkXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnQHJlZHV4anMvdG9vbGtpdCcpLlBheWxvYWRBY3Rpb248RHJhZnRUcmFuc2FjdGlvbj5cbiAqICl9IERyYWZ0VHJhbnNhY3Rpb25QYXlsb2FkXG4gKi9cblxuY29uc3Qgc2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gIG5hbWUsXG4gIGluaXRpYWxTdGF0ZSxcbiAgcmVkdWNlcnM6IHtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRyYWZ0IHRyYW5zYWN0aW9uIHRvIHN0YXRlLCBmaXJzdCBnZW5lcmF0aW5nIGEgbmV3IFVVSUQgZm9yXG4gICAgICogdGhlIHRyYW5zYWN0aW9uIGFuZCBzZXR0aW5nIHRoYXQgYXMgdGhlIGN1cnJlbnRUcmFuc2FjdGlvblVVSUQuIElmIHRoZVxuICAgICAqIGRyYWZ0IGhhcyBhbiBpZCBwcm9wZXJ0eSBzZXQsIHRoZSBzdGFnZSBpcyBzZXQgdG8gRURJVC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7RHJhZnRUcmFuc2FjdGlvblBheWxvYWR9IGFjdGlvbiAtIEFuIGFjdGlvbiB3aXRoIHBheWxvYWQgdGhhdCBpc1xuICAgICAqICBhIG5ldyBkcmFmdCB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gc3RhdGUuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgYWRkTmV3RHJhZnQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEID0gdXVpZHY0KCk7XG4gICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkLmlkKSB7XG4gICAgICAgIHN0YXRlLnN0YWdlID0gU0VORF9TVEFHRVMuRURJVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnN0YWdlID0gU0VORF9TVEFHRVMuQUREX1JFQ0lQSUVOVDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50cnksIHdpdGggdGltZXN0YW1wLCB0byB0aGUgZHJhZnRUcmFuc2FjdGlvbiBoaXN0b3J5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtTaW1wbGVTdHJpbmdQYXlsb2FkfSBhY3Rpb24gLSBBbiBhY3Rpb24gd2l0aCBwYXlsb2FkIHRoYXQgaXNcbiAgICAgKiAgYSBzdHJpbmcgdG8gYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgb2YgdGhlIGRyYWZ0VHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBhZGRIaXN0b3J5RW50cnk6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbikge1xuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgZW50cnk6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnYXNUb3RhbCBpcyBjb21wdXRlZCBiYXNlZCBvbiBnYXNQcmljZSBhbmQgZ2FzTGltaXQgYW5kIHNldCBpbiBzdGF0ZVxuICAgICAqIHJlY29tcHV0ZXMgdGhlIG1heGltdW0gYW1vdW50IGlmIHRoZSBjdXJyZW50IGFtb3VudCBtb2RlIGlzICdNQVgnIGFuZFxuICAgICAqIHNlbmRpbmcgdGhlIG5hdGl2ZSB0b2tlbi4gRVJDMjAgYXNzZXRzIG1heCBhbW91bnQgaXMgdW5hZmZlY3RlZCBieVxuICAgICAqIGdhc1RvdGFsIHNvIGRvZXMgbm90IG5lZWQgdG8gYmUgcmVjb21wdXRlZC4gRmluYWxseSwgdmFsaWRhdGVzIHRoZSBnYXNcbiAgICAgKiBmaWVsZCBhbmQgc2VuZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUdhc1RvdGFsOiAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIC8vIHVzZSBtYXhGZWVQZXJHYXMgYXMgdGhlIG11bHRpcGxpZXIgaWYgd29ya2luZyB3aXRoIGEgRkVFX01BUktFVCB0cmFuc2FjdGlvblxuICAgICAgLy8gb3RoZXJ3aXNlIHVzZSBnYXNQcmljZVxuICAgICAgaWYgKFxuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uVHlwZSA9PT1cbiAgICAgICAgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuRkVFX01BUktFVFxuICAgICAgKSB7XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1RvdGFsID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgIGNhbGNHYXNUb3RhbChcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0LFxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMubWF4RmVlUGVyR2FzLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNUb3RhbCA9IGFkZEhleFByZWZpeChcbiAgICAgICAgICBjYWxjR2FzVG90YWwoXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCxcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVggJiZcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICkge1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlQW1vdW50VG9NYXgoc3RhdGUpO1xuICAgICAgfVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlQW1vdW50RmllbGQoc3RhdGUpO1xuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgLy8gdmFsaWRhdGUgc2VuZCBzdGF0ZVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgZHJhZnRzIGZyb20gc2VuZCBzdGF0ZSBhbmQgZHJvcHMgdGhlIGN1cnJlbnRUcmFuc2FjdGlvblVVSUQuXG4gICAgICogVGhpcyBpcyBhbiBpbXBvcnRhbnQgZmlyc3Qgc3RlcCBiZWZvcmUgYWRkaW5nIGEgbmV3IGRyYWZ0IHRyYW5zYWN0aW9uIHRvXG4gICAgICogYXZvaWQgcG9zc2libGUgY29sbGlzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgY2xlYXJQcmV2aW91c0RyYWZ0czogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEID0gbnVsbDtcbiAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zID0ge307XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHNlbmQgc3RhdGUgYnkgc2V0dGluZyBpdCB0byB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1NlbmRTdGF0ZX1cbiAgICAgKi9cbiAgICByZXNldFNlbmRTdGF0ZTogKCkgPT4gaW5pdGlhbFN0YXRlLFxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIGFtb3VudCBtb2RlIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSBhcyBsb25nIGFzIGl0IGlzIG9uZSBvZiB0aGVcbiAgICAgKiBzdXBwb3J0ZWQgbW9kZXMgKE1BWHxJTlBVVClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlQW1vdW50TW9kZVBheWxvYWR9IGFjdGlvbiAtIFRoZSBhbW91bnQgbW9kZVxuICAgICAqICB0byBzZXQgdGhlIHN0YXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHVwZGF0ZUFtb3VudE1vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhBTU9VTlRfTU9ERVMpLmluY2x1ZGVzKGFjdGlvbi5wYXlsb2FkKSkge1xuICAgICAgICBzdGF0ZS5hbW91bnRNb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgYXNzZXQgdGhhdCBjYW4gYmUgc2VudCBhbmQgdGhlbiBjYWxsc1xuICAgICAqIHRoZSB1cGRhdGVTZW5kQW1vdW50IGFjdGlvbiBhYm92ZSB3aXRoIHRoZSBjb21wdXRlZCB2YWx1ZSwgd2hpY2ggd2lsbFxuICAgICAqIHJldmFsaWRhdGUgdGhlIGZpZWxkIGFuZCBmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlQW1vdW50VG9NYXg6IChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgbGV0IGFtb3VudCA9ICcweDAnO1xuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4pIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHM/LmRlY2ltYWxzID8/IDA7XG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTnVtYmVyKGRlY2ltYWxzKSk7XG5cbiAgICAgICAgYW1vdW50ID0gbXVsdGlwbHlDdXJyZW5jaWVzKFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuYmFsYW5jZSxcbiAgICAgICAgICBtdWx0aXBsaWVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgICAgICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTYsXG4gICAgICAgICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IF9nYXNUb3RhbCA9IHN1bUhleGVzKFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1RvdGFsIHx8ICcweDAnLFxuICAgICAgICAgIHN0YXRlLmdhc1RvdGFsRm9yTGF5ZXIxIHx8ICcweDAnLFxuICAgICAgICApO1xuICAgICAgICBhbW91bnQgPSBzdWJ0cmFjdEN1cnJlbmNpZXMoXG4gICAgICAgICAgYWRkSGV4UHJlZml4KGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuYmFsYW5jZSksXG4gICAgICAgICAgYWRkSGV4UHJlZml4KF9nYXNUb3RhbCksXG4gICAgICAgICAge1xuICAgICAgICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICAgICAgICBhQmFzZTogMTYsXG4gICAgICAgICAgICBiQmFzZTogMTYsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVTZW5kQW1vdW50KHN0YXRlLCB7XG4gICAgICAgIHBheWxvYWQ6IGFtb3VudCxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGFzc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge1VwZGF0ZUFzc2V0UGF5bG9hZH0gYWN0aW9uIC0gVGhlIGFzc2V0IHRvIHNldCBpbiB0aGVcbiAgICAgKiAgZHJhZnRUcmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVBc3NldDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IHsgYXNzZXQsIGluaXRpYWxBc3NldFNldCB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG5cbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9IGFzc2V0LnR5cGU7XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmJhbGFuY2UgPSBhc3NldC5iYWxhbmNlO1xuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5lcnJvciA9IGFzc2V0LmVycm9yO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4gfHxcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgKSB7XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscyA9IGFzc2V0LmRldGFpbHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjbGVhciB0aGUgZGV0YWlscyBvYmplY3Qgd2hlbiBzZW5kaW5nIG5hdGl2ZSBjdXJyZW5jeVxuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHMgPSBudWxsO1xuICAgICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuZXJyb3IgPT09IENPTlRSQUNUX0FERFJFU1NfRVJST1IpIHtcbiAgICAgICAgICAvLyBFcnJvcnMgcmVsYXRlZCB0byBzZW5kaW5nIHRva2VucyB0byB0aGVpciBvd24gY29udHJhY3QgYWRkcmVzc1xuICAgICAgICAgIC8vIGFyZSBubyBsb25nZXIgdmFsaWQgd2hlbiBzZW5kaW5nIG5hdGl2ZSBjdXJyZW5jeS5cbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5lcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGFtb3VudCBtb2RlIGlzIE1BWCB1cGRhdGUgYW1vdW50IHRvIG1heCBvZiBuZXcgYXNzZXQsIG90aGVyd2lzZSBzZXRcbiAgICAgIC8vIHRvIHplcm8uIFRoaXMgd2lsbCByZXZhbGlkYXRlIHRoZSBzZW5kIGFtb3VudCBmaWVsZC5cbiAgICAgIGlmIChzdGF0ZS5hbW91bnRNb2RlID09PSBBTU9VTlRfTU9ERVMuTUFYKSB7XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVBbW91bnRUb01heChzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxBc3NldFNldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnVwZGF0ZVNlbmRBbW91bnQoc3RhdGUsIHsgcGF5bG9hZDogJzB4MCcgfSk7XG4gICAgICB9XG4gICAgICAvLyB2YWxpZGF0ZSBzZW5kIHN0YXRlXG4gICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXBwcm9wcmlhdGUgZ2FzIGZlZXMgaW4gc3RhdGUgYWZ0ZXIgcmVjZWl2aW5nIG5ldyBlc3RpbWF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge0dhc0VzdGltYXRlVXBkYXRlUGF5bG9hZCl9IGFjdGlvbiAtIFRoZSBnYXMgZmVlIHVwZGF0ZSBwYXlsb2FkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlR2FzRmVlRXN0aW1hdGVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgeyBnYXNGZWVFc3RpbWF0ZXMsIGdhc0VzdGltYXRlVHlwZSB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBsZXQgZ2FzUHJpY2VFc3RpbWF0ZSA9ICcweDAnO1xuICAgICAgc3dpdGNoIChnYXNFc3RpbWF0ZVR5cGUpIHtcbiAgICAgICAgY2FzZSBHQVNfRVNUSU1BVEVfVFlQRVMuRkVFX01BUktFVDpcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlR2FzRmVlcyhzdGF0ZSwge1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvblR5cGU6IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkZFRV9NQVJLRVQsXG4gICAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0R2FzUHJpY2VJbkhleFdlaShcbiAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXMubWVkaXVtLnN1Z2dlc3RlZE1heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldEdhc1ByaWNlSW5IZXhXZWkoXG4gICAgICAgICAgICAgICAgZ2FzRmVlRXN0aW1hdGVzLm1lZGl1bS5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0FTX0VTVElNQVRFX1RZUEVTLkxFR0FDWTpcbiAgICAgICAgICBnYXNQcmljZUVzdGltYXRlID0gZ2V0Um91bmRlZEdhc1ByaWNlKGdhc0ZlZUVzdGltYXRlcy5tZWRpdW0pO1xuICAgICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVHYXNGZWVzKHN0YXRlLCB7XG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgIGdhc1ByaWNlOiBnYXNQcmljZUVzdGltYXRlLFxuICAgICAgICAgICAgICB0eXBlOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1ksXG4gICAgICAgICAgICAgIGlzQXV0b21hdGljVXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHQVNfRVNUSU1BVEVfVFlQRVMuRVRIX0dBU1BSSUNFOlxuICAgICAgICAgIGdhc1ByaWNlRXN0aW1hdGUgPSBnZXRSb3VuZGVkR2FzUHJpY2UoZ2FzRmVlRXN0aW1hdGVzLmdhc1ByaWNlKTtcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlR2FzRmVlcyhzdGF0ZSwge1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICBnYXNQcmljZTogZ2V0Um91bmRlZEdhc1ByaWNlKGdhc0ZlZUVzdGltYXRlcy5nYXNQcmljZSksXG4gICAgICAgICAgICAgIHR5cGU6IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkxFR0FDWSxcbiAgICAgICAgICAgICAgaXNBdXRvbWF0aWNVcGRhdGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdBU19FU1RJTUFURV9UWVBFUy5OT05FOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gUmVjb3JkIHRoZSBsYXRlc3QgZ2FzUHJpY2VFc3RpbWF0ZSBmb3IgZnV0dXJlIGNvbXBhcmlzb25zXG4gICAgICBzdGF0ZS5nYXNQcmljZUVzdGltYXRlID0gYWRkSGV4UHJlZml4KGdhc1ByaWNlRXN0aW1hdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXBwcm9wcmlhdGUgZ2FzIGZlZXMgaW4gc3RhdGUgYW5kIGRldGVybWluZXMgYW5kIHNldHMgdGhlXG4gICAgICogYXBwcm9wcmlhdGUgdHJhbnNhY3Rpb25UeXBlIGJhc2VkIG9uIGdhcyBmZWUgZmllbGRzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtHYXNGZWVVcGRhdGVQYXlsb2FkfSBhY3Rpb24gLSBUaGUgZ2FzIGZlZXMgdG8gdXBkYXRlIHdpdGhcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVHYXNGZWVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGlvbi5wYXlsb2FkLnRyYW5zYWN0aW9uVHlwZSA9PT1cbiAgICAgICAgICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUXG4gICAgICAgICkge1xuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLm1heEZlZVBlckdhcyA9IGFkZEhleFByZWZpeChcbiAgICAgICAgICAgIGFjdGlvbi5wYXlsb2FkLm1heEZlZVBlckdhcyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgICAgYWN0aW9uLnBheWxvYWQubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uVHlwZSA9XG4gICAgICAgICAgICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZC5tYW51YWxseUVkaXRlZCkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMud2FzTWFudWFsbHlFZGl0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2FzIHByaWNlIGlmIGl0IGhhcyBub3QgYmVlbiBtYW51YWxseSBlZGl0ZWQsXG4gICAgICAgICAgLy8gb3IgaWYgdGhpcyBjdXJyZW50IGFjdGlvbiBpcyBhIG1hbnVhbCBlZGl0LlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFkcmFmdFRyYW5zYWN0aW9uLmdhcy53YXNNYW51YWxseUVkaXRlZCB8fFxuICAgICAgICAgICAgYWN0aW9uLnBheWxvYWQubWFudWFsbHlFZGl0ZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgICAgICBhY3Rpb24ucGF5bG9hZC5nYXNQcmljZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24udHJhbnNhY3Rpb25UeXBlID0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuTEVHQUNZO1xuICAgICAgICB9XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy5jYWxjdWxhdGVHYXNUb3RhbChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBwcm92aWRlZCBnYXNMaW1pdCBpbiBzdGF0ZSBhbmQgdGhlbiByZWNvbXB1dGVzIHRoZSBnYXNUb3RhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7U2ltcGxlU3RyaW5nUGF5bG9hZH0gYWN0aW9uIC0gVGhlXG4gICAgICogIGdhc0xpbWl0IGluIGhleCB0byBzZXQgaW4gc3RhdGUuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlR2FzTGltaXQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbikge1xuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCA9IGFkZEhleFByZWZpeChhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy5jYWxjdWxhdGVHYXNUb3RhbChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBsYXllciAxIGZlZXMgdG90YWwgKGZvciBhIG11bHRpLWxheWVyIGZlZSBuZXR3b3JrKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtTaW1wbGVTdHJpbmdQYXlsb2FkfSBhY3Rpb24gLSB0aGVcbiAgICAgKiAgZ2FzVG90YWxGb3JMYXllcjEgdG8gc2V0IGluIGhleCB3ZWkuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlTGF5ZXIxRmVlczogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIHN0YXRlLmdhc1RvdGFsRm9yTGF5ZXIxID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVggJiZcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICkge1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlQW1vdW50VG9NYXgoc3RhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVjaXBpZW50IG9mIHRoZSBkcmFmdFRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge3VwZGF0ZVJlY2lwaWVudFBheWxvYWR9IGFjdGlvbiAtIFRoZSByZWNpcGllbnQgdG8gc2V0IGluIHRoZVxuICAgICAqICBkcmFmdFRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHVwZGF0ZVJlY2lwaWVudDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LmVycm9yID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlY2lwaWVudElucHV0ID0gJyc7XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzID0gYWN0aW9uLnBheWxvYWQuYWRkcmVzcyA/PyAnJztcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50Lm5pY2tuYW1lID0gYWN0aW9uLnBheWxvYWQubmlja25hbWUgPz8gJyc7XG5cbiAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzID09PSAnJykge1xuICAgICAgICAvLyBJZiBhZGRyZXNzIGlzIG51bGwgd2UgYXJlIGNsZWFyaW5nIHRoZSByZWNpcGllbnQgYW5kIG11c3QgcmV0dXJuXG4gICAgICAgIC8vIHRvIHRoZSBBRERfUkVDSVBJRU5UIHN0YWdlLlxuICAgICAgICBzdGF0ZS5zdGFnZSA9IFNFTkRfU1RBR0VTLkFERF9SRUNJUElFTlQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBhbiBhZGRyZXNzIGlzIHByb3ZpZGVkIGFuZCBhbiBpZCBleGlzdHMsIHdlIHByb2dyZXNzIHRvIHRoZSBFRElUXG4gICAgICAgIC8vIHN0YWdlLCBvdGhlcndpc2Ugd2UgcHJvZ3Jlc3MgdG8gdGhlIERSQUZUIHN0YWdlLiBXZSBhbHNvIHJlc2V0IHRoZVxuICAgICAgICAvLyBzZWFyY2ggbW9kZSBmb3IgcmVjaXBpZW50IHNlYXJjaC5cbiAgICAgICAgc3RhdGUuc3RhZ2UgPVxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uaWQgPT09IG51bGwgPyBTRU5EX1NUQUdFUy5EUkFGVCA6IFNFTkRfU1RBR0VTLkVESVQ7XG4gICAgICAgIHN0YXRlLnJlY2lwaWVudE1vZGUgPSBSRUNJUElFTlRfU0VBUkNIX01PREVTLkNPTlRBQ1RfTElTVDtcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWRhdGUgc2VuZCBzdGF0ZVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgdXNlciBpbnB1dCBhbmQgY2hhbmdlcyB0aGUgcmVjaXBpZW50IHNlYXJjaCBtb2RlIHRvIHRoZVxuICAgICAqIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtVcGRhdGVSZWNpcGllbnRNb2RlUGF5bG9hZH0gYWN0aW9uIC0gVGhlIG1vZGUgdG8gc2V0IHRoZVxuICAgICAqICByZWNpcGllbnQgc2VhcmNoIHRvXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlUmVjaXBpZW50U2VhcmNoTW9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLnJlY2lwaWVudElucHV0ID0gJyc7XG4gICAgICBzdGF0ZS5yZWNpcGllbnRNb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlY2lwaWVudFdhcm5pbmc6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC53YXJuaW5nID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlY2lwaWVudFR5cGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC50eXBlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHVwZGF0ZURyYWZ0VHJhbnNhY3Rpb25TdGF0dXM6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnN0YXR1cyA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH0sXG5cbiAgICBhY2tub3dsZWRnZVJlY2lwaWVudFdhcm5pbmc6IChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQucmVjaXBpZW50V2FybmluZ0Fja25vd2xlZGdlZCA9IHRydWU7XG4gICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcmVjaXBpZW50SW5wdXQga2V5IHdpdGggd2hhdCB0aGUgdXNlciBoYXNcbiAgICAgKiB0eXBlZCBpbnRvIHRoZSByZWNpcGllbnQgaW5wdXQgZmllbGQgaW4gdGhlIFVJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtTaW1wbGVTdHJpbmdQYXlsb2FkfSBhY3Rpb24gLSB0aGUgdmFsdWUgdGhlIHVzZXIgaGFzIHR5cGVkIGludG9cbiAgICAgKiAgdGhlIHJlY2lwaWVudCBmaWVsZC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVSZWNpcGllbnRVc2VySW5wdXQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGluIHN0YXRlIHRvIG1hdGNoIHdoYXQgdGhlIHVzZXIgaXMgdHlwaW5nIGludG8gdGhlXG4gICAgICAvLyBpbnB1dCBmaWVsZFxuICAgICAgc3RhdGUucmVjaXBpZW50SW5wdXQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBjdXJyZW50IGFtb3VudC52YWx1ZSBpbiBzdGF0ZSBhbmQgcnVuIHBvc3QgdXBkYXRlIHZhbGlkYXRpb24gb2ZcbiAgICAgKiB0aGUgYW1vdW50IGZpZWxkIGFuZCB0aGUgc2VuZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7U2ltcGxlU3RyaW5nUGF5bG9hZH0gYWN0aW9uIC0gVGhlIGhleCBzdHJpbmcgdG8gYmUgc2V0IGFzIHRoZVxuICAgICAqICBhbW91bnQgdmFsdWUuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlU2VuZEFtb3VudDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlID0gYWRkSGV4UHJlZml4KGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIC8vIE9uY2UgYW1vdW50IGhhcyBjaGFuZ2VkLCB2YWxpZGF0ZSB0aGUgZmllbGRcbiAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy52YWxpZGF0ZUFtb3VudEZpZWxkKHN0YXRlKTtcbiAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LnR5cGUgPT09IEFTU0VUX1RZUEVTLk5BVElWRSkge1xuICAgICAgICAvLyBpZiBzZW5kaW5nIHRoZSBuYXRpdmUgYXNzZXQgdGhlIGFtb3VudCBiZWluZyBzZW50IHdpbGwgaW1wYWN0IHRoZVxuICAgICAgICAvLyBnYXMgZmllbGQgYXMgd2VsbCBiZWNhdXNlIHRoZSBnYXMgdmFsaWRhdGlvbiB0YWtlcyBpbnRvXG4gICAgICAgIC8vIGNvbnNpZGVyYXRpb24gdGhlIGF2YWlsYWJsZSBiYWxhbmNlIG1pbnVzIGFtb3VudCBzZW50IGJlZm9yZVxuICAgICAgICAvLyBjaGVja2luZyBpZiB0aGVyZSBpcyBlbm91Z2ggbGVmdCB0byBjb3ZlciB0aGUgZ2FzIGZlZS5cbiAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgfVxuICAgICAgLy8gdmFsaWRhdGUgc2VuZCBzdGF0ZVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHVwZGF0ZXMgdGhlIHVzZXJJbnB1dEhleERhdGEgc3RhdGUga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge1NpbXBsZVN0cmluZ1BheWxvYWR9IGFjdGlvbiAtIFRoZSBoZXggc3RyaW5nIHRvIGJlIHNldCBhcyB0aGVcbiAgICAgKiAgdXNlcklucHV0SGV4RGF0YSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVVc2VySW5wdXRIZXhEYXRhOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgZHJhZnRUcmFuc2FjdGlvbi51c2VySW5wdXRIZXhEYXRhID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnYXNJc1NldEluTW9kYWwgcHJvcGVydHkgdG8gdHJ1ZSB3aGljaCByZXN1bHRzIGluIHNob3dpbmdcbiAgICAgKiB0aGUgZ2FzIGZlZXMgZnJvbSB0aGUgY3VzdG9tIGdhcyBtb2RhbCBpbiB0aGUgc2VuZCBwYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXNlQ3VzdG9tR2FzOiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmdhc0lzU2V0SW5Nb2RhbCA9IHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnYXNJc1NldEluTW9kYWwgcHJvcGVydHkgdG8gZmFsc2Ugd2hpY2ggcmVzdWx0cyBpbiBzaG93aW5nXG4gICAgICogdGhlIGRlZmF1bHQgZ2FzIHByaWNlL2xpbWl0IGZpZWxkcyBpbiB0aGUgc2VuZCBwYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXNlRGVmYXVsdEdhczogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5nYXNJc1NldEluTW9kYWwgPSBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgdGhlIHZhbGlkaXR5IG9mIHRoZSBkcmFmdFRyYW5zYWN0aW9ucyBzZWxlY3RlZCBhbW91bnQgdG8gc2VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdmFsaWRhdGVBbW91bnRGaWVsZDogKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgLy8gc2V0IGVycm9yIHRvIElOU1VGRklDSUVOVF9GVU5EU19FUlJPUiBpZiB0aGUgYWNjb3VudCBiYWxhbmNlIGlzIGxvd2VyXG4gICAgICAgIC8vIHRoYW4gdGhlIHRvdGFsIHByaWNlIG9mIHRoZSB0cmFuc2FjdGlvbiBpbmNsdXNpdmUgb2YgZ2FzIGZlZXMuXG4gICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUgJiZcbiAgICAgICAgICAhaXNCYWxhbmNlU3VmZmljaWVudCh7XG4gICAgICAgICAgICBhbW91bnQ6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICAgICAgYmFsYW5jZTogZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5iYWxhbmNlLFxuICAgICAgICAgICAgZ2FzVG90YWw6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1RvdGFsID8/ICcweDAnLFxuICAgICAgICAgIH0pOlxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LmVycm9yID0gSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBzZXQgZXJyb3IgdG8gSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SIGlmIHRoZSB0b2tlbiBiYWxhbmNlIGlzIGxvd2VyXG4gICAgICAgIC8vIHRoYW4gdGhlIGFtb3VudCBvZiB0b2tlbiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIHNlbmQuXG4gICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5UT0tFTiAmJlxuICAgICAgICAgICFpc1Rva2VuQmFsYW5jZVN1ZmZpY2llbnQoe1xuICAgICAgICAgICAgdG9rZW5CYWxhbmNlOiBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmJhbGFuY2UgPz8gJzB4MCcsXG4gICAgICAgICAgICBhbW91bnQ6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICAgICAgZGVjaW1hbHM6IGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscy5kZWNpbWFscyxcbiAgICAgICAgICB9KTpcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFtb3VudC5lcnJvciA9IElOU1VGRklDSUVOVF9UT0tFTlNfRVJST1I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGlmIHRoZSBhbW91bnQgaXMgbmVnYXRpdmUsIHNldCBlcnJvciB0byBORUdBVElWRV9FVEhfRVJST1JcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRoaXMgdG8gTkVHQVRJVkVfRVJST1IgYW5kIHJlbW92ZSB0aGUgY3VycmVuY3kgYmlhcy5cbiAgICAgICAgY2FzZSBjb252ZXJzaW9uR3JlYXRlclRoYW4oXG4gICAgICAgICAgeyB2YWx1ZTogMCwgZnJvbU51bWVyaWNCYXNlOiAnZGVjJyB9LFxuICAgICAgICAgIHsgdmFsdWU6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgICAgICk6XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQuZXJyb3IgPSBORUdBVElWRV9FVEhfRVJST1I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIGFyZSB0cnVlLCBzZXQgZXJyb3IgdG8gbnVsbFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LmVycm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdXNlciBoYXMgZW5vdWdoIGZ1bmRzIHRvIGNvdmVyIHRoZSBjb3N0IG9mIGdhcywgYWx3YXlzXG4gICAgICogdXNlcyB0aGUgbmF0aXZlIGN1cnJlbmN5IGFuZCBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgYW1vdW50XG4gICAgICogYmVpbmcgc2VudC4gSWYgdGhlIHVzZXIgaGFzIGVub3VnaCB0byBjb3ZlciBjb3N0IG9mIGdhcyBidXQgbm90IGdhc1xuICAgICAqICsgYW1vdW50IHRoZW4gdGhlIGVycm9yIHdpbGwgYmUgZGlzcGxheWVkIG9uIHRoZSBhbW91bnQgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUdhc0ZpZWxkOiAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGNvbnN0IGluc3VmZmljaWVudEZ1bmRzID0gIWlzQmFsYW5jZVN1ZmZpY2llbnQoe1xuICAgICAgICBhbW91bnQ6XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICAgICAgID8gZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQudmFsdWVcbiAgICAgICAgICAgIDogJzB4MCcsXG4gICAgICAgIGJhbGFuY2U6XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudD8uYmFsYW5jZSA/P1xuICAgICAgICAgIHN0YXRlLnNlbGVjdGVkQWNjb3VudC5iYWxhbmNlLFxuICAgICAgICBnYXNUb3RhbDogZHJhZnRUcmFuc2FjdGlvbi5nYXMuZ2FzVG90YWwgPz8gJzB4MCcsXG4gICAgICB9KTtcblxuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMuZXJyb3IgPSBpbnN1ZmZpY2llbnRGdW5kc1xuICAgICAgICA/IElOU1VGRklDSUVOVF9GVU5EU19FUlJPUlxuICAgICAgICA6IG51bGw7XG4gICAgfSxcbiAgICB2YWxpZGF0ZVJlY2lwaWVudFVzZXJJbnB1dDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcblxuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0YXRlLnJlY2lwaWVudE1vZGUgPT09IFJFQ0lQSUVOVF9TRUFSQ0hfTU9ERVMuTVlfQUNDT1VOVFMgfHxcbiAgICAgICAgICBzdGF0ZS5yZWNpcGllbnRJbnB1dCA9PT0gJycgfHxcbiAgICAgICAgICBzdGF0ZS5yZWNpcGllbnRJbnB1dCA9PT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5lcnJvciA9IG51bGw7XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuQWRkcmVzc0xpc3QsXG4gICAgICAgICAgICBpc1Byb2JhYmx5QW5Bc3NldENvbnRyYWN0LFxuICAgICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzQnVybkFkZHJlc3Moc3RhdGUucmVjaXBpZW50SW5wdXQpIHx8XG4gICAgICAgICAgICAoIWlzVmFsaWRIZXhBZGRyZXNzKHN0YXRlLnJlY2lwaWVudElucHV0LCB7XG4gICAgICAgICAgICAgIG1peGVkQ2FzZVVzZUNoZWNrc3VtOiB0cnVlLFxuICAgICAgICAgICAgfSkgJiZcbiAgICAgICAgICAgICAgIWlzVmFsaWREb21haW5OYW1lKHN0YXRlLnJlY2lwaWVudElucHV0KSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LmVycm9yID0gaXNEZWZhdWx0TWV0YU1hc2tDaGFpbihjaGFpbklkKVxuICAgICAgICAgICAgICA/IElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfRVJST1JcbiAgICAgICAgICAgICAgOiBJTlZBTElEX1JFQ0lQSUVOVF9BRERSRVNTX05PVF9FVEhfTkVUV09SS19FUlJPUjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgaXNPcmlnaW5Db250cmFjdEFkZHJlc3MoXG4gICAgICAgICAgICAgIHN0YXRlLnJlY2lwaWVudElucHV0LFxuICAgICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0Py5kZXRhaWxzPy5hZGRyZXNzLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuZXJyb3IgPSBDT05UUkFDVF9BRERSRVNTX0VSUk9SO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5lcnJvciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChpc1ZhbGlkSGV4QWRkcmVzcyhzdGF0ZS5yZWNpcGllbnRJbnB1dCkgJiZcbiAgICAgICAgICAgICAgKHRva2VuQWRkcmVzc0xpc3QuZmluZCgoYWRkcmVzcykgPT5cbiAgICAgICAgICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGFkZHJlc3MsIHN0YXRlLnJlY2lwaWVudElucHV0KSxcbiAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIGNoZWNrRXhpc3RpbmdBZGRyZXNzZXMoc3RhdGUucmVjaXBpZW50SW5wdXQsIHRva2VucykpKSB8fFxuICAgICAgICAgICAgaXNQcm9iYWJseUFuQXNzZXRDb250cmFjdFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9XG4gICAgICAgICAgICAgIEtOT1dOX1JFQ0lQSUVOVF9BRERSRVNTX1dBUk5JTkc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50Lndhcm5pbmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZHJhZnRUcmFuc2FjdGlvbiBpcyBjdXJyZW50bHkgdmFsaWQuIFRoZSBmb2xsb3dpbmcgbGlzdCBvZlxuICAgICAqIGNhc2VzIGZyb20gdGhlIHN3aXRjaCBzdGF0ZW1lbnQgaW4gdGhpcyBmdW5jdGlvbiBkZXNjcmliZSB3aGVuIHRoZVxuICAgICAqIHRyYW5zYWN0aW9uIGlzIGludmFsaWQuIFBsZWFzZSBrZWVwIHRoaXMgY29tbWVudCB1cGRhdGVkLlxuICAgICAqXG4gICAgICogY2FzZSAxOiBTdGF0ZSBpcyBpbnZhbGlkIHdoZW4gYW1vdW50IGZpZWxkIGhhcyBhbiBlcnJvci5cbiAgICAgKiBjYXNlIDI6IFN0YXRlIGlzIGludmFsaWQgd2hlbiBnYXMgZmllbGQgaGFzIGFuIGVycm9yLlxuICAgICAqIGNhc2UgMzogU3RhdGUgaXMgaW52YWxpZCB3aGVuIGFzc2V0IGZpZWxkIGhhcyBhbiBlcnJvci5cbiAgICAgKiBjYXNlIDQ6IFN0YXRlIGlzIGludmFsaWQgaWYgYXNzZXQgdHlwZSBpcyBhIHRva2VuIGFuZCB0aGUgdG9rZW4gZGV0YWlsc1xuICAgICAqICBhcmUgdW5rbm93bi5cbiAgICAgKiBjYXNlIDU6IFN0YXRlIGlzIGludmFsaWQgaWYgbm8gcmVjaXBpZW50IGhhcyBiZWVuIGFkZGVkLlxuICAgICAqIGNhc2UgNjogU3RhdGUgaXMgaW52YWxpZCBpZiB0aGUgc2VuZCBzdGF0ZSBpcyB1bmluaXRpYWxpemVkLlxuICAgICAqIGNhc2UgNzogU3RhdGUgaXMgaW52YWxpZCBpZiBnYXMgZXN0aW1hdGVzIGFyZSBsb2FkaW5nLlxuICAgICAqIGNhc2UgODogU3RhdGUgaXMgaW52YWxpZCBpZiBnYXNMaW1pdCBpcyBsZXNzIHRoYW4gdGhlIGdhc0xpbWl0TWluaW11bS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHZhbGlkYXRlU2VuZFN0YXRlOiAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2UgQm9vbGVhbihkcmFmdFRyYW5zYWN0aW9uLmFtb3VudC5lcnJvcik6XG4gICAgICAgICAgY2FzZSBCb29sZWFuKGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmVycm9yKTpcbiAgICAgICAgICBjYXNlIEJvb2xlYW4oZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5lcnJvcik6XG4gICAgICAgICAgY2FzZSBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LnR5cGUgPT09IEFTU0VUX1RZUEVTLlRPS0VOICYmXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHMgPT09IG51bGw6XG4gICAgICAgICAgY2FzZSBzdGF0ZS5zdGFnZSA9PT0gU0VORF9TVEFHRVMuQUREX1JFQ0lQSUVOVDpcbiAgICAgICAgICBjYXNlIHN0YXRlLnN0YWdlID09PSBTRU5EX1NUQUdFUy5JTkFDVElWRTpcbiAgICAgICAgICBjYXNlIHN0YXRlLmdhc0VzdGltYXRlSXNMb2FkaW5nOlxuICAgICAgICAgIGNhc2UgbmV3IEJpZ051bWJlcihkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCwgMTYpLmxlc3NUaGFuKFxuICAgICAgICAgICAgbmV3IEJpZ051bWJlcihzdGF0ZS5nYXNMaW1pdE1pbmltdW0pLFxuICAgICAgICAgICk6XG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnN0YXR1cyA9IFNFTkRfU1RBVFVTRVMuSU5WQUxJRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9PT0gJ2xvYWRpbmcnOlxuICAgICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9PT1cbiAgICAgICAgICAgIEtOT1dOX1JFQ0lQSUVOVF9BRERSRVNTX1dBUk5JTkcgJiZcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LnJlY2lwaWVudFdhcm5pbmdBY2tub3dsZWRnZWQgPT09IGZhbHNlOlxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5zdGF0dXMgPSBTRU5EX1NUQVRVU0VTLklOVkFMSUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5zdGF0dXMgPSBTRU5EX1NUQVRVU0VTLlZBTElEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgZXh0cmFSZWR1Y2VyczogKGJ1aWxkZXIpID0+IHtcbiAgICBidWlsZGVyXG4gICAgICAuYWRkQ2FzZShBQ0NPVU5UX0NIQU5HRUQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgZXZlbnQgb2NjdXJzIHdoZW4gdGhlIHVzZXIncyBhY2NvdW50IGRldGFpbHMgdXBkYXRlIGR1ZSB0b1xuICAgICAgICAvLyBiYWNrZ3JvdW5kIHN0YXRlIGNoYW5nZXMuIElmIHRoZSBhY2NvdW50IHRoYXQgaXMgYmVpbmcgdXBkYXRlZCBpc1xuICAgICAgICAvLyB0aGUgY3VycmVudCBmcm9tIGFjY291bnQgb24gdGhlIGVkaXQgZmxvdyB3ZSBuZWVkIHRvIHVwZGF0ZVxuICAgICAgICAvLyB0aGUgYmFsYW5jZSBmb3IgdGhlIGFjY291bnQgYW5kIHJldmFsaWRhdGUgdGhlIHNlbmQgc3RhdGUuXG4gICAgICAgIGlmIChzdGF0ZS5zdGFnZSA9PT0gU0VORF9TVEFHRVMuRURJVCAmJiBhY3Rpb24ucGF5bG9hZC5hY2NvdW50KSB7XG4gICAgICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50ICYmXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50LmFkZHJlc3MgPT09XG4gICAgICAgICAgICAgIGFjdGlvbi5wYXlsb2FkLmFjY291bnQuYWRkcmVzc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudC5iYWxhbmNlID1cbiAgICAgICAgICAgICAgYWN0aW9uLnBheWxvYWQuYWNjb3VudC5iYWxhbmNlO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIGFzc2V0IGJhbGFuY2UgaWYgdGhlIGFzc2V0IGlzIHRoZSBuYXRpdmVcbiAgICAgICAgICAgIC8vIG5ldHdvcmsgYXNzZXQuIE9uY2Ugd2UgdXBkYXRlIHRoZSBiYWxhbmNlIHdlIHJlY29tcHV0ZSBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LnR5cGUgPT09IEFTU0VUX1RZUEVTLk5BVElWRSkge1xuICAgICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmJhbGFuY2UgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmJhbGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVBbW91bnRGaWVsZChzdGF0ZSk7XG4gICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVHYXNGaWVsZChzdGF0ZSk7XG4gICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKEFERFJFU1NfQk9PS19VUERBVEVELCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAvLyBXaGVuIHRoZSBhZGRyZXNzIGJvb2sgdXBkYXRlcyBmcm9tIGJhY2tncm91bmQgc3RhdGUgY2hhbmdlcyB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRvIHNlZSBpZiBhbiBlbnRyeSBleGlzdHMgZm9yIHRoZSBjdXJyZW50IGFkZHJlc3Mgb3IgaWYgdGhlXG4gICAgICAgIC8vIGVudHJ5IGNoYW5nZWQuXG4gICAgICAgIGNvbnN0IHsgYWRkcmVzc0Jvb2sgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICBhZGRyZXNzQm9va1tkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzXT8ubmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5uaWNrbmFtZSA9XG4gICAgICAgICAgICBhZGRyZXNzQm9va1tkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzXS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UoY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0LnBlbmRpbmcsIChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyBXaGVuIHdlIGJlZ2luIHRvIGZldGNoIGdhc0xpbWl0IHdlIHNob3VsZCBpbmRpY2F0ZSB3ZSBhcmUgbG9hZGluZ1xuICAgICAgICAvLyBhIGdhcyBlc3RpbWF0ZS5cbiAgICAgICAgc3RhdGUuZ2FzRXN0aW1hdGVJc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGNvbXB1dGVFc3RpbWF0ZWRHYXNMaW1pdC5mdWxmaWxsZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIC8vIFdoZW4gd2UgcmVjZWl2ZSBhIG5ldyBnYXNMaW1pdCBmcm9tIHRoZSBjb21wdXRlRXN0aW1hdGVkR2FzTGltaXRcbiAgICAgICAgLy8gdGh1bmsgd2UgbmVlZCB0byB1cGRhdGUgb3VyIGdhc0xpbWl0IGluIHRoZSBzbGljZS4gV2UgY2FsbCBpbnRvIHRoZVxuICAgICAgICAvLyBjYXNlUmVkdWNlciB1cGRhdGVHYXNMaW1pdCB0byB0YXAgaW50byB0aGUgYXBwcm9wcmlhdGUgZm9sbG93IHVwXG4gICAgICAgIC8vIGNoZWNrcyBhbmQgZ2FzVG90YWwgY2FsY3VsYXRpb24uIEZpcnN0IHNldCBnYXNFc3RpbWF0ZUlzTG9hZGluZyB0b1xuICAgICAgICAvLyBmYWxzZS5cbiAgICAgICAgc3RhdGUuZ2FzRXN0aW1hdGVJc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkPy5nYXNMaW1pdCkge1xuICAgICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVHYXNMaW1pdChzdGF0ZSwge1xuICAgICAgICAgICAgcGF5bG9hZDogYWN0aW9uLnBheWxvYWQuZ2FzTGltaXQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkPy5nYXNUb3RhbEZvckxheWVyMSkge1xuICAgICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVMYXllcjFGZWVzKHN0YXRlLCB7XG4gICAgICAgICAgICBwYXlsb2FkOiBhY3Rpb24ucGF5bG9hZC5nYXNUb3RhbEZvckxheWVyMSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGNvbXB1dGVFc3RpbWF0ZWRHYXNMaW1pdC5yZWplY3RlZCwgKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIElmIGdhcyBlc3RpbWF0aW9uIGZhaWxzLCB3ZSBzaG91bGQgc2V0IHRoZSBsb2FkaW5nIHN0YXRlIHRvIGZhbHNlLFxuICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIG5vIGxvbmdlciBsb2FkaW5nXG4gICAgICAgIHN0YXRlLmdhc0VzdGltYXRlSXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UoR0FTX0ZFRV9FU1RJTUFURVNfVVBEQVRFRCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgZ2FzRmVlQ29udHJvbGxlciB1cGRhdGVzIGl0cyBnYXMgZmVlIGVzdGltYXRlcyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHVwZGF0ZSBhbmQgdmFsaWRhdGUgc3RhdGUgYmFzZWQgb24gdGhvc2UgbmV3IHZhbHVlc1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlR2FzRmVlRXN0aW1hdGVzKHN0YXRlLCB7XG4gICAgICAgICAgcGF5bG9hZDogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGluaXRpYWxpemVTZW5kU3RhdGUucGVuZGluZywgKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIHdoZW4gd2UgYmVnaW4gaW5pdGlhbGl6aW5nIHN0YXRlLCB3aGljaCBjYW4gaGFwcGVuIHdoZW4gc3dpdGNoaW5nXG4gICAgICAgIC8vIGNoYWlucyBldmVuIGFmdGVyIGxvYWRpbmcgdGhlIHNlbmQgZmxvdywgd2Ugc2V0IGdhc0VzdGltYXRlSXNMb2FkaW5nXG4gICAgICAgIC8vIGFzIGluaXRpYWxpemF0aW9uIHdpbGwgdHJpZ2dlciBhIGZldGNoIGZvciBnYXNQcmljZSBlc3RpbWF0ZXMuXG4gICAgICAgIHN0YXRlLmdhc0VzdGltYXRlSXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAuYWRkQ2FzZShpbml0aWFsaXplU2VuZFN0YXRlLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gd3JpdGVzIHRoZSBjb21wdXRlZCBpbml0aWFsaXplZCBzdGF0ZSB2YWx1ZXMgaW50byB0aGUgc2xpY2UgYW5kIHRoZW5cbiAgICAgICAgLy8gY2FsY3VsYXRlcyBzbGljZSB2YWxpZGl0eSB1c2luZyB0aGUgY2FzZVJlZHVjZXJzLlxuICAgICAgICBzdGF0ZS5laXAxNTU5c3VwcG9ydCA9IGFjdGlvbi5wYXlsb2FkLmVpcDE1NTlzdXBwb3J0O1xuICAgICAgICBzdGF0ZS5zZWxlY3RlZEFjY291bnQuYWRkcmVzcyA9IGFjdGlvbi5wYXlsb2FkLmFjY291bnQuYWRkcmVzcztcbiAgICAgICAgc3RhdGUuc2VsZWN0ZWRBY2NvdW50LmJhbGFuY2UgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmJhbGFuY2U7XG4gICAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0ID0gYWN0aW9uLnBheWxvYWQuZ2FzTGltaXQ7XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMuZ2FzVG90YWwgPSBhY3Rpb24ucGF5bG9hZC5nYXNUb3RhbDtcbiAgICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQuY2hhaW5IYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3RhdGUgd2FzIHJlaW5pdGlhbGl6ZWQgYXMgYSByZXN1bHQgb2YgdGhlIHVzZXIgY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBuZXR3b3JrIGZyb20gdGhlIG5ldHdvcmsgZHJvcGRvd24sIHRoZW4gdGhlIHNlbGVjdGVkIGFzc2V0IGlzXG4gICAgICAgICAgICAvLyBubyBsb25nZXIgdmFsaWQgYW5kIHNob3VsZCBiZSBzZXQgdG8gdGhlIG5hdGl2ZSBhc3NldCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBuZXR3b3JrLlxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID0gQVNTRVRfVFlQRVMuTkFUSVZFO1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5iYWxhbmNlID1cbiAgICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudD8uYmFsYW5jZSA/P1xuICAgICAgICAgICAgICBzdGF0ZS5zZWxlY3RlZEFjY291bnQuYmFsYW5jZTtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVHYXNGZWVFc3RpbWF0ZXMoc3RhdGUsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IGFjdGlvbi5wYXlsb2FkLmdhc0ZlZUVzdGltYXRlcyxcbiAgICAgICAgICAgIGdhc0VzdGltYXRlVHlwZTogYWN0aW9uLnBheWxvYWQuZ2FzRXN0aW1hdGVUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5nYXNFc3RpbWF0ZVBvbGxUb2tlbiA9IGFjdGlvbi5wYXlsb2FkLmdhc0VzdGltYXRlUG9sbFRva2VuO1xuICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQuZ2FzRXN0aW1hdGVQb2xsVG9rZW4pIHtcbiAgICAgICAgICBzdGF0ZS5nYXNFc3RpbWF0ZUlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zdGFnZSAhPT0gU0VORF9TVEFHRVMuSU5BQ1RJVkUpIHtcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVSZWNpcGllbnRVc2VySW5wdXQoc3RhdGUsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgY2hhaW5JZDogYWN0aW9uLnBheWxvYWQuY2hhaW5JZCxcbiAgICAgICAgICAgICAgdG9rZW5zOiBhY3Rpb24ucGF5bG9hZC50b2tlbnMsXG4gICAgICAgICAgICAgIHVzZVRva2VuRGV0ZWN0aW9uOiBhY3Rpb24ucGF5bG9hZC51c2VUb2tlbkRldGVjdGlvbixcbiAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzTGlzdDogYWN0aW9uLnBheWxvYWQudG9rZW5BZGRyZXNzTGlzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVgpIHtcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlQW1vdW50VG9NYXgoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy52YWxpZGF0ZUFtb3VudEZpZWxkKHN0YXRlKTtcbiAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKFNFTEVDVEVEX0FDQ09VTlRfQ0hBTkdFRCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gVGhpcyBldmVudCBvY2N1cnMgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgbmV3IGFjY291bnQgZnJvbSB0aGVcbiAgICAgICAgLy8gYWNjb3VudCBtZW51LCBvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBhY2NvdW50J3MgYmFsYW5jZSB1cGRhdGVzLlxuICAgICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgbmV3IHRyYW5zYWN0aW9ucywgbm90IGVkaXRzLCBoZXJlLCBiZWNhdXNlIHdlIHVzZVxuICAgICAgICAvLyB0aGUgZnJvbUFjY291bnQgYW5kIEFDQ09VTlRfQ0hBTkdFRCBhY3Rpb24gZm9yIHRoYXQuXG4gICAgICAgIGlmIChzdGF0ZS5zdGFnZSAhPT0gU0VORF9TVEFHRVMuRURJVCAmJiBhY3Rpb24ucGF5bG9hZC5hY2NvdW50KSB7XG4gICAgICAgICAgc3RhdGUuc2VsZWN0ZWRBY2NvdW50LmJhbGFuY2UgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmJhbGFuY2U7XG4gICAgICAgICAgc3RhdGUuc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgICAgICAvLyBUaGlzIGFjdGlvbiB3aWxsIG9jY3VyIGV2ZW4gd2hlbiB3ZSBhcmVuJ3Qgb24gdGhlIHNlbmQgZmxvdywgd2hpY2hcbiAgICAgICAgICAvLyBpcyBva2F5IGFzIGl0IGtlZXBzIHRoZSBzZWxlY3RlZEFjY291bnQgZGV0YWlscyB1cCB0byBkYXRlLiBXZSBkb1xuICAgICAgICAgIC8vIG5vdCBuZWVkIHRvIHZhbGlkYXRlIGFueXRoaW5nIGlmIHRoZXJlIGlzbid0IGEgY3VycmVudCBkcmFmdFxuICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLiBJZiB0aGVyZSBpcywgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGFzc2V0IGJhbGFuY2UgaWZcbiAgICAgICAgICAvLyB0aGUgYXNzZXQgaXMgc2V0IHRvIHRoZSBuYXRpdmUgbmV0d29yayBhc3NldCwgYW5kIHRoZW4gdmFsaWRhdGVcbiAgICAgICAgICAvLyB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uPy5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUpIHtcbiAgICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5iYWxhbmNlID0gYWN0aW9uLnBheWxvYWQuYWNjb3VudC5iYWxhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlQW1vdW50RmllbGQoc3RhdGUpO1xuICAgICAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYWRkQ2FzZShRUl9DT0RFX0RFVEVDVEVELCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAvLyBXaGVuIGRhdGEgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgUVIgQ29kZSBTY2FubmVyIHdlIHNldCB0aGUgcmVjaXBpZW50XG4gICAgICAgIC8vIGFzIGxvbmcgYXMgYSB2YWxpZCBhZGRyZXNzIGNhbiBiZSBwdWxsZWQgZnJvbSB0aGUgZGF0YS4gSWYgYW5cbiAgICAgICAgLy8gYWRkcmVzcyBpcyBwdWxsZWQgYnV0IGl0IGlzIGludmFsaWQsIHdlIGRpc3BsYXkgYW4gZXJyb3IuXG4gICAgICAgIGNvbnN0IHFyQ29kZURhdGEgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgICBpZiAocXJDb2RlRGF0YSAmJiBkcmFmdFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgaWYgKHFyQ29kZURhdGEudHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FubmVkQWRkcmVzcyA9IHFyQ29kZURhdGEudmFsdWVzLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaXNWYWxpZEhleEFkZHJlc3Moc2Nhbm5lZEFkZHJlc3MsIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcyAhPT0gc2Nhbm5lZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlUmVjaXBpZW50KHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IGFkZHJlc3M6IHNjYW5uZWRBZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LmVycm9yID1cbiAgICAgICAgICAgICAgICBJTlZBTElEX1JFQ0lQSUVOVF9BRERSRVNTX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0sXG59KTtcblxuY29uc3QgeyBhY3Rpb25zLCByZWR1Y2VyIH0gPSBzbGljZTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuY29uc3Qge1xuICB1c2VEZWZhdWx0R2FzLFxuICB1c2VDdXN0b21HYXMsXG4gIHVwZGF0ZUdhc0xpbWl0LFxuICB2YWxpZGF0ZVJlY2lwaWVudFVzZXJJbnB1dCxcbiAgdXBkYXRlUmVjaXBpZW50U2VhcmNoTW9kZSxcbiAgYWRkSGlzdG9yeUVudHJ5LFxuICBhY2tub3dsZWRnZVJlY2lwaWVudFdhcm5pbmcsXG59ID0gYWN0aW9ucztcblxuZXhwb3J0IHtcbiAgdXNlRGVmYXVsdEdhcyxcbiAgdXNlQ3VzdG9tR2FzLFxuICB1cGRhdGVHYXNMaW1pdCxcbiAgYWRkSGlzdG9yeUVudHJ5LFxuICBhY2tub3dsZWRnZVJlY2lwaWVudFdhcm5pbmcsXG59O1xuXG4vLyBBY3Rpb24gQ3JlYXRvcnNcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBmb3IgdXNhZ2Ugd2hlbiB2YWxpZGF0aW5nIHVzZXIgaW5wdXQgc28gdGhhdCB2YWxpZGF0aW9uXG4gKiBpcyBvbmx5IHJ1biBhZnRlciBhIGRlbGF5IGluIHR5cGluZyBvZiAzMDBtcy4gVXNhZ2UgYXQgY2FsbHNpdGVzIHJlcXVpcmVzXG4gKiBwYXNzaW5nIGluIGJvdGggdGhlIGRpc3BhdGNoIG1ldGhvZCBhbmQgdGhlIHBheWxvYWQgdG8gZGlzcGF0Y2gsIHdoaWNoIG1ha2VzXG4gKiBpdCBvbmx5IGFwcGxpY2FibGUgZm9yIHVzZSB3aXRoaW4gYWN0aW9uIGNyZWF0b3JzLlxuICovXG5jb25zdCBkZWJvdW5jZWRWYWxpZGF0ZVJlY2lwaWVudFVzZXJJbnB1dCA9IGRlYm91bmNlKFxuICAoZGlzcGF0Y2gsIHBheWxvYWQsIHJlc29sdmUpID0+IHtcbiAgICBkaXNwYXRjaChcbiAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgYHNlbmRGbG93IC0gdXNlciB0eXBlZCAke3BheWxvYWQudXNlcklucHV0fSBpbnRvIHJlY2lwaWVudCBpbnB1dCBmaWVsZGAsXG4gICAgICApLFxuICAgICk7XG4gICAgZGlzcGF0Y2godmFsaWRhdGVSZWNpcGllbnRVc2VySW5wdXQocGF5bG9hZCkpO1xuICAgIHJlc29sdmUoKTtcbiAgfSxcbiAgMzAwLFxuKTtcblxuLyoqXG4gKiBCZWdpbnMgYSBuZXcgZHJhZnQgdHJhbnNhY3Rpb24sIGRlcml2ZWQgZnJvbSB0aGUgdHhQYXJhbXMgb2YgYW4gZXhpc3RpbmdcbiAqIHRyYW5zYWN0aW9uIGluIHRoZSBUcmFuc2FjdGlvbkNvbnRyb2xsZXIuIFRoaXMgYWN0aW9uIHdpbGwgZmlyc3QgY2xlYXIgb3V0XG4gKiB0aGUgcHJldmlvdXMgZHJhZnQgdHJhbnNhY3Rpb25zIGFuZCBjdXJyZW50VHJhbnNhY3Rpb25VVUlEIGZyb20gc3RhdGUuIFRoaXNcbiAqIGFjdGlvbiBpcyBvbmUgb2YgdGhlIHR3byBlbnRyeSBwb2ludHMgaW50byB0aGUgc2VuZCBmbG93LiBOT1RFOiBZb3UgbXVzdFxuICogcm91dGUgdG8gdGhlIHNlbmQgcGFnZSAqYWZ0ZXIqIGRpc3BhdGNoaW5nIHRoaXMgYWN0aW9uIHJlc29sdmVzIHRvIGVuc3VyZVxuICogdGhhdCB0aGUgZHJhZnRUcmFuc2FjdGlvbiBpcyBwcm9wZXJseSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7QXNzZXRUeXBlc1N0cmluZ30gYXNzZXRUeXBlIC0gVGhlIHR5cGUgb2YgYXNzZXQgdGhlIHRyYW5zYWN0aW9uXG4gKiAgYmVpbmcgZWRpdGVkIHdhcyBzZW5kaW5nLiBUaGUgZGV0YWlscyBvZiB0aGUgYXNzZXQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbVxuICogIHRoZSB0cmFuc2FjdGlvbiBkYXRhIGluIHN0YXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgLSBUaGUgaWQgb2YgdGhlIHRyYW5zYWN0aW9uIGJlaW5nIGVkaXRlZC5cbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkaXRFeGlzdGluZ1RyYW5zYWN0aW9uKGFzc2V0VHlwZSwgdHJhbnNhY3Rpb25JZCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGF3YWl0IGRpc3BhdGNoKGFjdGlvbnMuY2xlYXJQcmV2aW91c0RyYWZ0cygpKTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgdW5hcHByb3ZlZFRyYW5zYWN0aW9ucyA9IGdldFVuYXBwcm92ZWRUeHMoc3RhdGUpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdW5hcHByb3ZlZFRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkXTtcbiAgICBjb25zdCBhY2NvdW50ID0gZ2V0VGFyZ2V0QWNjb3VudChzdGF0ZSwgdHJhbnNhY3Rpb24udHhQYXJhbXMuZnJvbSk7XG5cbiAgICBpZiAoYXNzZXRUeXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUpIHtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKFxuICAgICAgICBhY3Rpb25zLmFkZE5ld0RyYWZ0KHtcbiAgICAgICAgICAuLi5kcmFmdFRyYW5zYWN0aW9uSW5pdGlhbFN0YXRlLFxuICAgICAgICAgIGlkOiB0cmFuc2FjdGlvbklkLFxuICAgICAgICAgIGZyb21BY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgIGdhczoge1xuICAgICAgICAgICAgLi4uZHJhZnRUcmFuc2FjdGlvbkluaXRpYWxTdGF0ZS5nYXMsXG4gICAgICAgICAgICBnYXNMaW1pdDogdHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRyYW5zYWN0aW9uLnR4UGFyYW1zLmdhc1ByaWNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXNlcklucHV0SGV4RGF0YTogdHJhbnNhY3Rpb24udHhQYXJhbXMuZGF0YSxcbiAgICAgICAgICByZWNpcGllbnQ6IHtcbiAgICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUucmVjaXBpZW50LFxuICAgICAgICAgICAgYWRkcmVzczogdHJhbnNhY3Rpb24udHhQYXJhbXMudG8sXG4gICAgICAgICAgICBuaWNrbmFtZTpcbiAgICAgICAgICAgICAgZ2V0QWRkcmVzc0Jvb2tFbnRyeU9yQWNjb3VudE5hbWUoXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24udHhQYXJhbXMudG8sXG4gICAgICAgICAgICAgICkgPz8gJycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUuYW1vdW50LFxuICAgICAgICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uLnR4UGFyYW1zLnZhbHVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGlzdG9yeTogW1xuICAgICAgICAgICAgYHNlbmRGbG93IC0gdXNlciBjbGlja2VkIGVkaXQgb24gdHJhbnNhY3Rpb24gd2l0aCBpZCAke3RyYW5zYWN0aW9uSWR9YCxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgdXBkYXRlU2VuZEFzc2V0KFxuICAgICAgICAgIHsgdHlwZTogQVNTRVRfVFlQRVMuTkFUSVZFIH0sXG4gICAgICAgICAgeyBpbml0aWFsQXNzZXRTZXQ6IHRydWUgfSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VuRGF0YSA9IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YShcbiAgICAgICAgdHJhbnNhY3Rpb24udHhQYXJhbXMuZGF0YSxcbiAgICAgICk7XG4gICAgICBjb25zdCB0b2tlbkFtb3VudEluRGVjID1cbiAgICAgICAgYXNzZXRUeXBlID09PSBBU1NFVF9UWVBFUy5UT0tFTiA/IGdldFRva2VuVmFsdWVQYXJhbSh0b2tlbkRhdGEpIDogJzEnO1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGdldFRva2VuQWRkcmVzc1BhcmFtKHRva2VuRGF0YSk7XG4gICAgICBjb25zdCBuaWNrbmFtZSA9IGdldEFkZHJlc3NCb29rRW50cnlPckFjY291bnROYW1lKHN0YXRlLCBhZGRyZXNzKSA/PyAnJztcblxuICAgICAgY29uc3QgdG9rZW5BbW91bnRJbkhleCA9IGFkZEhleFByZWZpeChcbiAgICAgICAgY29udmVyc2lvblV0aWwodG9rZW5BbW91bnRJbkRlYywge1xuICAgICAgICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIGFjdGlvbnMuYWRkTmV3RHJhZnQoe1xuICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUsXG4gICAgICAgICAgaWQ6IHRyYW5zYWN0aW9uSWQsXG4gICAgICAgICAgZnJvbUFjY291bnQ6IGFjY291bnQsXG4gICAgICAgICAgZ2FzOiB7XG4gICAgICAgICAgICAuLi5kcmFmdFRyYW5zYWN0aW9uSW5pdGlhbFN0YXRlLmdhcyxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0cmFuc2FjdGlvbi50eFBhcmFtcy5nYXMsXG4gICAgICAgICAgICBnYXNQcmljZTogdHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzUHJpY2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VySW5wdXRIZXhEYXRhOiB0cmFuc2FjdGlvbi50eFBhcmFtcy5kYXRhLFxuICAgICAgICAgIHJlY2lwaWVudDoge1xuICAgICAgICAgICAgLi4uZHJhZnRUcmFuc2FjdGlvbkluaXRpYWxTdGF0ZS5yZWNpcGllbnQsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgbmlja25hbWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUuYW1vdW50LFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuQW1vdW50SW5IZXgsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoaXN0b3J5OiBbXG4gICAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIGNsaWNrZWQgZWRpdCBvbiB0cmFuc2FjdGlvbiB3aXRoIGlkICR7dHJhbnNhY3Rpb25JZH1gLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIHVwZGF0ZVNlbmRBc3NldChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBhc3NldFR5cGUsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIGFkZHJlc3M6IHRyYW5zYWN0aW9uLnR4UGFyYW1zLnRvLFxuICAgICAgICAgICAgICAuLi4oYXNzZXRUeXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbklkOlxuICAgICAgICAgICAgICAgICAgICAgIGdldFRva2VuSWRQYXJhbSh0b2tlbkRhdGEpID8/XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VG9rZW5WYWx1ZVBhcmFtKHRva2VuRGF0YSksXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBpbml0aWFsQXNzZXRTZXQ6IHRydWUgfSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYXdhaXQgZGlzcGF0Y2goaW5pdGlhbGl6ZVNlbmRTdGF0ZSgpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlciB0byBzdXBwb3J0IHRoZSBvbGQgVUkgaW4gYm90aCB0aGVcbiAqIGdhcyBtb2RhbCBhbmQgdGhlIHNlbmQgZmxvdy4gU29vbiB3ZSB3b24ndCBuZWVkIHRvIG1vZGlmeSBnYXNQcmljZSBmcm9tIHRoZVxuICogc2VuZCBmbG93IGJhc2VkIG9uIHVzZXIgaW5wdXQsIGl0J2xsIGp1c3QgYmUgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGN1cnJlbnRcbiAqIGVzdGltYXRlLiBUaGlzIG1ldGhvZCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIHRoaXNcbiAqIHNsaWNlIGhhcyBiZWVuIGNoYW5nZWQgc3VjaCB0aGF0IGl0IGlzIGFnbm9zdGljIHRvIHRyYW5zYWN0aW9uIGVudmVsb3BlXG4gKiB0eXBlLCBhbmQgdGhpcyBtZXRob2QgY2FsbHMgaW50byB0aGUgbmV3IHN0cnVjdHVyZSBpbiB0aGUgYXBwcm9wcmlhdGUgd2F5LlxuICpcbiAqIEBkZXByZWNhdGVkIC0gZG9uJ3QgZXh0ZW5kIHRoZSB1c2FnZSBvZiB0aGlzIHRlbXBvcmFyeSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBnYXNQcmljZSAtIG5ldyBnYXMgcHJpY2UgaW4gaGV4IHdlaVxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlR2FzUHJpY2UoZ2FzUHJpY2UpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIGRpc3BhdGNoKFxuICAgICAgYWRkSGlzdG9yeUVudHJ5KGBzZW5kRmxvdyAtIHVzZXIgc2V0IGxlZ2FjeSBnYXNQcmljZSB0byAke2dhc1ByaWNlfWApLFxuICAgICk7XG4gICAgZGlzcGF0Y2goXG4gICAgICBhY3Rpb25zLnVwZGF0ZUdhc0ZlZXMoe1xuICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgdHJhbnNhY3Rpb25UeXBlOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1ksXG4gICAgICAgIG1hbnVhbGx5RWRpdGVkOiB0cnVlLFxuICAgICAgfSksXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByZWNpcGllbnQgaW4gc3RhdGUgYmFzZWQgb24gdGhlIGlucHV0IHByb3ZpZGVkLCBhbmQgdGhlbiB3aWxsXG4gKiByZWNvbXB1dGUgZ2FzIGxpbWl0IHdoZW4gc2VuZGluZyBhIFRPS0VOIGFzc2V0IHR5cGUuIENoYW5naW5nIHRoZSByZWNpcGllbnRcbiAqIGFkZHJlc3MgcmVzdWx0cyBpbiBoZXggZGF0YSBjaGFuZ2luZyBiZWNhdXNlIHRoZSByZWNpcGllbnQgYWRkcmVzcyBpc1xuICogZW5jb2RlZCBpbiB0aGUgZGF0YSBpbnN0ZWFkIG9mIGJlaW5nIGluIHRoZSAndG8nIGZpZWxkLiBUaGUgdG8gZmllbGQgaW4gYVxuICogdG9rZW4gc2VuZCB3aWxsIGFsd2F5cyBiZSB0aGUgdG9rZW4gY29udHJhY3QgYWRkcmVzcy5cbiAqIElmIG5vIG5pY2tuYW1lIGlzIHByb3ZpZGVkLCB0aGUgYWRkcmVzcyBib29rIHN0YXRlIHdpbGwgYmUgY2hlY2tlZCB0byBzZWUgaWZcbiAqIGEgbmlja25hbWUgZm9yIHRoZSBwYXNzZWQgYWRkcmVzcyBoYXMgYWxyZWFkeSBiZWVuIHNhdmVkLiBUaGlzIGVuc3VyZXMgdGhlXG4gKiAodGVtcG9yYXJ5KSBzZW5kIHN0YXRlIHJlY2lwaWVudCBuaWNrbmFtZSBpcyBjb25zaXN0ZW50IHdpdGggdGhlIGFkZHJlc3MgYm9va1xuICogbmlja25hbWUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBwZXJzaXN0ZWQgdG8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHJlY2lwaWVudCAtIFJlY2lwaWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJlY2lwaWVudC5hZGRyZXNzIC0gaGV4IGFkZHJlc3MgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVjaXBpZW50Lm5pY2tuYW1lXSAtIEFsaWFzIGZvciB0aGUgYWRkcmVzcyB0byBkaXNwbGF5XG4gKiAgdG8gdGhlIHVzZXJcbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVJlY2lwaWVudCh7IGFkZHJlc3MsIG5pY2tuYW1lIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICAvLyBEbyBub3QgYWRkSGlzdG9yeUVudHJ5IGhlcmUgYXMgdGhpcyBpcyBjYWxsZWQgZnJvbSBhIG51bWJlciBvZiBwbGFjZXNcbiAgICAvLyBlYWNoIHdpdGggc2lnbmlmaWNhbmNlIHRvIHRoZSB1c2VyIGFuZCB0cmFuc2FjdGlvbiBoaXN0b3J5LlxuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBuaWNrbmFtZUZyb21BZGRyZXNzQm9va0VudHJ5T3JBY2NvdW50TmFtZSA9XG4gICAgICBnZXRBZGRyZXNzQm9va0VudHJ5T3JBY2NvdW50TmFtZShzdGF0ZSwgYWRkcmVzcykgPz8gJyc7XG4gICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICBhY3Rpb25zLnVwZGF0ZVJlY2lwaWVudCh7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIG5pY2tuYW1lOiBuaWNrbmFtZSB8fCBuaWNrbmFtZUZyb21BZGRyZXNzQm9va0VudHJ5T3JBY2NvdW50TmFtZSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgYXdhaXQgZGlzcGF0Y2goY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0KCkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byB1cGRhdGUgdGhlIHVzZXIncyBpbnB1dCBpbnRvIHRoZSBFTlMgaW5wdXQgZmllbGQuXG4gKiBPbmNlIHRoZSBmaWVsZCBpcyB1cGRhdGVkLCB0aGUgZmllbGQgd2lsbCBiZSB2YWxpZGF0ZWQgdXNpbmcgYSBkZWJvdW5jZWRcbiAqIHZlcnNpb24gb2YgdGhlIHZhbGlkYXRlUmVjaXBpZW50VXNlcklucHV0IGFjdGlvbi4gVGhpcyB3YXkgdmFsaWRhdGlvbiBvbmx5XG4gKiBvY2N1cnMgb25jZSB0aGUgdXNlciBoYXMgc3RvcHBlZCB0eXBpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJbnB1dCAtIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIGlzIHR5cGluZyBpbnRvIHRoZSBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUmVjaXBpZW50VXNlcklucHV0KHVzZXJJbnB1dCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGRpc3BhdGNoKGFjdGlvbnMudXBkYXRlUmVjaXBpZW50V2FybmluZygnbG9hZGluZycpKTtcbiAgICBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZURyYWZ0VHJhbnNhY3Rpb25TdGF0dXMoU0VORF9TVEFUVVNFUy5JTlZBTElEKSk7XG4gICAgYXdhaXQgZGlzcGF0Y2goYWN0aW9ucy51cGRhdGVSZWNpcGllbnRVc2VySW5wdXQodXNlcklucHV0KSk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc3RhdGVbbmFtZV0uZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGVbbmFtZV0uY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgY29uc3Qgc2VuZGluZ0FkZHJlc3MgPVxuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudD8uYWRkcmVzcyA/P1xuICAgICAgc3RhdGVbbmFtZV0uc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MgPz9cbiAgICAgIGdldFNlbGVjdGVkQWRkcmVzcyhzdGF0ZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKHN0YXRlKTtcbiAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlbnMoc3RhdGUpO1xuICAgIGNvbnN0IHVzZVRva2VuRGV0ZWN0aW9uID0gZ2V0VXNlVG9rZW5EZXRlY3Rpb24oc3RhdGUpO1xuICAgIGNvbnN0IHRva2VuTWFwID0gZ2V0VG9rZW5MaXN0KHN0YXRlKTtcbiAgICBjb25zdCB0b2tlbkFkZHJlc3NMaXN0ID0gT2JqZWN0LmtleXModG9rZW5NYXApO1xuXG4gICAgY29uc3QgaW5wdXRJc1ZhbGlkSGV4QWRkcmVzcyA9IGlzVmFsaWRIZXhBZGRyZXNzKHVzZXJJbnB1dCk7XG4gICAgbGV0IGlzUHJvYmFibHlBbkFzc2V0Q29udHJhY3QgPSBmYWxzZTtcbiAgICBpZiAoaW5wdXRJc1ZhbGlkSGV4QWRkcmVzcykge1xuICAgICAgY29uc3Qgc21hcnRDb250cmFjdEFkZHJlc3MgPSBhd2FpdCBpc1NtYXJ0Q29udHJhY3RBZGRyZXNzKHVzZXJJbnB1dCk7XG4gICAgICBpZiAoc21hcnRDb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgZGlzcGF0Y2goYWN0aW9ucy51cGRhdGVSZWNpcGllbnRUeXBlKFJFQ0lQSUVOVF9UWVBFUy5TTUFSVF9DT05UUkFDVCkpO1xuICAgICAgICBjb25zdCB7IHN5bWJvbCwgZGVjaW1hbHMgfSA9XG4gICAgICAgICAgZ2V0VG9rZW5NZXRhZGF0YSh1c2VySW5wdXQsIHRva2VuTWFwKSB8fCB7fTtcblxuICAgICAgICBpc1Byb2JhYmx5QW5Bc3NldENvbnRyYWN0ID0gc3ltYm9sICYmIGRlY2ltYWxzICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCFpc1Byb2JhYmx5QW5Bc3NldENvbnRyYWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhbmRhcmQgfSA9IGF3YWl0IGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKFxuICAgICAgICAgICAgICB1c2VySW5wdXQsXG4gICAgICAgICAgICAgIHNlbmRpbmdBZGRyZXNzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzUHJvYmFibHlBbkFzc2V0Q29udHJhY3QgPSBCb29sZWFuKHN0YW5kYXJkKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGRlYm91bmNlZFZhbGlkYXRlUmVjaXBpZW50VXNlcklucHV0KFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAge1xuICAgICAgICAgIHVzZXJJbnB1dCxcbiAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICB1c2VUb2tlbkRldGVjdGlvbixcbiAgICAgICAgICB0b2tlbkFkZHJlc3NMaXN0LFxuICAgICAgICAgIGlzUHJvYmFibHlBbkFzc2V0Q29udHJhY3QsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmUsXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGFtb3VudCB0aGUgdXNlciBpbnRlbmRzIHRvIHNlbmQgYW5kIHBlcmZvcm1zIHNpZGUgZWZmZWN0cy5cbiAqIDEuIElmIHRoZSBjdXJyZW50IG1vZGUgaXMgTUFYIGNoYW5nZSB0byBJTlBVVFxuICogMi4gSWYgc2VuZGluZyBhIHRva2VuLCByZWNvbXB1dGUgdGhlIGdhc0xpbWl0IGVzdGltYXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIGhleCBzdHJpbmcgcmVwcmVzZW50aW5nIHZhbHVlXG4gKiBAcmV0dXJucyB7VGh1bmtBY3Rpb248dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTZW5kQW1vdW50KGFtb3VudCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IG1ldGFtYXNrIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgIHN0YXRlW25hbWVdLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlW25hbWVdLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgIGxldCBsb2dBbW91bnQgPSBhbW91bnQ7XG4gICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4pIHtcbiAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdyhcbiAgICAgICAgMTAsXG4gICAgICAgIE51bWJlcihkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHM/LmRlY2ltYWxzIHx8IDApLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlY2ltYWxWYWx1ZVN0cmluZyA9IGNvbnZlcnNpb25VdGlsKGFkZEhleFByZWZpeChhbW91bnQpLCB7XG4gICAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgICAgICB0b0N1cnJlbmN5OiBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHM/LnN5bWJvbCxcbiAgICAgICAgY29udmVyc2lvblJhdGU6IG11bHRpcGxpZXIsXG4gICAgICAgIGludmVydENvbnZlcnNpb25SYXRlOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ0Ftb3VudCA9IGAke051bWJlcihkZWNpbWFsVmFsdWVTdHJpbmcpID8gZGVjaW1hbFZhbHVlU3RyaW5nIDogJyd9ICR7XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscz8uc3ltYm9sXG4gICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXRoVmFsdWUgPSBnZXRWYWx1ZUZyb21XZWlIZXgoe1xuICAgICAgICB2YWx1ZTogYW1vdW50LFxuICAgICAgICB0b0N1cnJlbmN5OiBFVEgsXG4gICAgICAgIG51bWJlck9mRGVjaW1hbHM6IDgsXG4gICAgICB9KTtcbiAgICAgIGxvZ0Ftb3VudCA9IGAke2V0aFZhbHVlfSAke21ldGFtYXNrPy5wcm92aWRlcj8udGlja2VyIHx8IEVUSH1gO1xuICAgIH1cbiAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgIGFkZEhpc3RvcnlFbnRyeShgc2VuZEZsb3cgLSB1c2VyIHNldCBhbW91bnQgdG8gJHtsb2dBbW91bnR9YCksXG4gICAgKTtcbiAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZVNlbmRBbW91bnQoYW1vdW50KSk7XG4gICAgaWYgKHN0YXRlW25hbWVdLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVgpIHtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGFjdGlvbnMudXBkYXRlQW1vdW50TW9kZShBTU9VTlRfTU9ERVMuSU5QVVQpKTtcbiAgICB9XG4gICAgYXdhaXQgZGlzcGF0Y2goY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0KCkpO1xuICB9O1xufVxuXG4vKipcbiAqIHVwZGF0ZXMgdGhlIGFzc2V0IHRvIHNlbmQgdG8gb25lIG9mIE5BVElWRSBvciBUT0tFTiBhbmQgZW5zdXJlcyB0aGF0IHRoZVxuICogYXNzZXQgYmFsYW5jZSBpcyBzZXQuIElmIHNlbmRpbmcgYSBUT0tFTiBhbHNvIHVwZGF0ZXMgdGhlIGFzc2V0IGRldGFpbHNcbiAqIG9iamVjdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBFUkMyMCBkZXRhaWxzIGluY2x1ZGluZyBhZGRyZXNzLCBzeW1ib2wgYW5kXG4gKiBkZWNpbWFscy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZCAtIGFjdGlvbiBwYXlsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZC50eXBlIC0gdHlwZSBvZiBhc3NldCB0byBzZW5kXG4gKiBAcGFyYW0ge1Rva2VuRGV0YWlsc30gW3BheWxvYWQuZGV0YWlsc10gLSBFUkMyMCBkZXRhaWxzIGlmIHNlbmRpbmcgVE9LRU4gYXNzZXRcbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVNlbmRBc3NldChcbiAgeyB0eXBlLCBkZXRhaWxzOiBwcm92aWRlZERldGFpbHMgfSxcbiAgeyBpbml0aWFsQXNzZXRTZXQgPSBmYWxzZSB9ID0ge30sXG4pIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICBzdGF0ZVtuYW1lXS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZVtuYW1lXS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICBjb25zdCBzZW5kaW5nQWRkcmVzcyA9XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50Py5hZGRyZXNzID8/XG4gICAgICBzdGF0ZVtuYW1lXS5zZWxlY3RlZEFjY291bnQuYWRkcmVzcyA/P1xuICAgICAgZ2V0U2VsZWN0ZWRBZGRyZXNzKHN0YXRlKTtcbiAgICBjb25zdCBhY2NvdW50ID0gZ2V0VGFyZ2V0QWNjb3VudChzdGF0ZSwgc2VuZGluZ0FkZHJlc3MpO1xuICAgIGlmICh0eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUpIHtcbiAgICAgIGNvbnN0IHVuYXBwcm92ZWRUeHMgPSBnZXRVbmFwcHJvdmVkVHhzKHN0YXRlKTtcbiAgICAgIGNvbnN0IHVuYXBwcm92ZWRUeCA9IHVuYXBwcm92ZWRUeHM/LltkcmFmdFRyYW5zYWN0aW9uLmlkXTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNldCBhc3NldCBvZiB0eXBlICR7XG4gICAgICAgICAgICBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICAgICB9IHdpdGggc3ltYm9sICR7c3RhdGUubWV0YW1hc2sucHJvdmlkZXI/LnRpY2tlciA/PyBFVEh9YCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgYWN0aW9ucy51cGRhdGVBc3NldCh7XG4gICAgICAgICAgYXNzZXQ6IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBudWxsLFxuICAgICAgICAgICAgYmFsYW5jZTogYWNjb3VudC5iYWxhbmNlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0aWFsQXNzZXRTZXQsXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgLy8gVGhpcyBpcyBtZWFudCB0byBoYW5kbGUgY2FzZXMgd2hlcmUgd2UgYXJlIGVkaXRpbmcgYW4gdW5hcHByb3ZlZFR4IGZyb20gdGhlIGJhY2tncm91bmQgc3RhdGVcbiAgICAgIC8vIGFuZCBpdHMgdHlwZSBpcyBhIHRva2VuIG1ldGhvZC4gSW4gc3VjaCBhIGNhc2UsIHRoZSBoZXggZGF0YSB3aWxsIGJlIHRoZSBuZWNlc3NhcnkgaGV4IGRhdGFcbiAgICAgIC8vIGZvciBjYWxsaW5nIHRoZSBjb250cmFjdCB0cmFuc2ZlciBtZXRob2QuXG4gICAgICAvLyBOb3cgdGhhdCB3ZSBhcmUgdXBkYXRpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIGEgc2VuZCBvZiBhIG5hdGl2ZSBhc3NldCB0eXBlLCB3ZSBzaG91bGRcbiAgICAgIC8vIHNldCB0aGUgaGV4IGRhdGEgb2YgdGhlIHRyYW5zYWN0aW9uIGJlaW5nIGVkaXRpbmcgdG8gYmUgZW1wdHkuXG4gICAgICAvLyB0aGVuIHRoZSB1c2VyIHdpbGwgbm90IHdhbnQgdG8gc2VuZCBhbnkgaGV4IGRhdGEgbm93IHRoYXQgdGhleSBoYXZlIGNoYW5nZSB0aGVcbiAgICAgIGlmIChcbiAgICAgICAgdW5hcHByb3ZlZFR4Py50eXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSB8fFxuICAgICAgICB1bmFwcHJvdmVkVHg/LnR5cGUgPT09IFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUiB8fFxuICAgICAgICB1bmFwcHJvdmVkVHg/LnR5cGUgPT09IFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TQUZFX1RSQU5TRkVSX0ZST01cbiAgICAgICkge1xuICAgICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZVVzZXJJbnB1dEhleERhdGEoJycpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgZGlzcGF0Y2goc2hvd0xvYWRpbmdJbmRpY2F0aW9uKCkpO1xuICAgICAgY29uc3QgZGV0YWlscyA9IHtcbiAgICAgICAgLi4ucHJvdmlkZWREZXRhaWxzLFxuICAgICAgICAuLi4oYXdhaXQgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMoXG4gICAgICAgICAgcHJvdmlkZWREZXRhaWxzLmFkZHJlc3MsXG4gICAgICAgICAgc2VuZGluZ0FkZHJlc3MsXG4gICAgICAgICAgcHJvdmlkZWREZXRhaWxzLnRva2VuSWQsXG4gICAgICAgICkpLFxuICAgICAgfTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGhpZGVMb2FkaW5nSW5kaWNhdGlvbigpKTtcblxuICAgICAgY29uc3QgYXNzZXQgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgaWYgKGRldGFpbHMuc3RhbmRhcmQgPT09IFRPS0VOX1NUQU5EQVJEUy5FUkMyMCkge1xuICAgICAgICBhc3NldC5iYWxhbmNlID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgIGNhbGNUb2tlbkFtb3VudChkZXRhaWxzLmJhbGFuY2UsIGRldGFpbHMuZGVjaW1hbHMpLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgICBhZGRIaXN0b3J5RW50cnkoXG4gICAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNldCBhc3NldCB0byBFUkMyMCB0b2tlbiB3aXRoIHN5bWJvbCAke2RldGFpbHMuc3ltYm9sfSBhbmQgYWRkcmVzcyAke2RldGFpbHMuYWRkcmVzc31gLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBkZXRhaWxzLnN0YW5kYXJkID09PSBUT0tFTl9TVEFOREFSRFMuRVJDMTE1NSAmJlxuICAgICAgICB0eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VuZHMgb2YgRVJDMTE1NSB0b2tlbnMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBkZXRhaWxzLnN0YW5kYXJkID09PSBUT0tFTl9TVEFOREFSRFMuRVJDMTE1NSB8fFxuICAgICAgICBkZXRhaWxzLnN0YW5kYXJkID09PSBUT0tFTl9TVEFOREFSRFMuRVJDNzIxXG4gICAgICApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IEFTU0VUX1RZUEVTLlRPS0VOICYmIHByb2Nlc3MuZW52LkNPTExFQ1RJQkxFU19WMSkge1xuICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgc2hvd01vZGFsKHtcbiAgICAgICAgICAgICAgbmFtZTogJ0NPTlZFUlRfVE9LRU5fVE9fTkZUJyxcbiAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBkZXRhaWxzLmFkZHJlc3MsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGFzc2V0LmVycm9yID0gSU5WQUxJRF9BU1NFVF9UWVBFO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0FTU0VUX1RZUEUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpc0N1cnJlbnRPd25lciA9IHRydWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzQ3VycmVudE93bmVyID0gYXdhaXQgaXNDb2xsZWN0aWJsZU93bmVyKFxuICAgICAgICAgICAgICBzZW5kaW5nQWRkcmVzcyxcbiAgICAgICAgICAgICAgZGV0YWlscy5hZGRyZXNzLFxuICAgICAgICAgICAgICBkZXRhaWxzLnRva2VuSWQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdVbmFibGUgdG8gdmVyaWZ5IG93bmVyc2hpcC4nKSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIHdvdWxkIGluZGljYXRlIHRoYXQgZWl0aGVyIG91ciBhdHRlbXB0cyB0byB2ZXJpZnkgb3duZXJzaGlwIGZhaWxlZCBiZWNhdXNlIG9mIG5ldHdvcmsgaXNzdWVzLFxuICAgICAgICAgICAgICAvLyBvciwgc29tZWhvdyBhIHRva2VuIGhhcyBiZWVuIGFkZGVkIHRvIGNvbGxlY3RpYmxlcyBzdGF0ZSB3aXRoIGFuIGluY29ycmVjdCBjaGFpbklkLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQW55IG90aGVyIGVycm9yIGlzIHVuZXhwZWN0ZWQgYW5kIHNob3VsZCBiZSBzdXJmYWNlZC5cbiAgICAgICAgICAgICAgZGlzcGF0Y2goZGlzcGxheVdhcm5pbmcoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDdXJyZW50T3duZXIpIHtcbiAgICAgICAgICAgIGFzc2V0LmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGFzc2V0LmJhbGFuY2UgPSAnMHgxJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnU2VuZCBzbGljZSBpbml0aWFsaXplZCBhcyBjb2xsZWN0aWJsZSBzZW5kIHdpdGggYSBjb2xsZWN0aWJsZSBub3QgY3VycmVudGx5IG93bmVkIGJ5IHRoZSBzZWxlY3QgYWNjb3VudCcsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgICAgICAgYHNlbmRGbG93IC0gdXNlciBzZXQgYXNzZXQgdG8gTkZUIHdpdGggdG9rZW5JZCAke2RldGFpbHMudG9rZW5JZH0gYW5kIGFkZHJlc3MgJHtkZXRhaWxzLmFkZHJlc3N9YCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZUFzc2V0KHsgYXNzZXQsIGluaXRpYWxBc3NldFNldCB9KSk7XG4gICAgfVxuICAgIGlmIChpbml0aWFsQXNzZXRTZXQgPT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChjb21wdXRlRXN0aW1hdGVkR2FzTGltaXQoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFdoZW4gYSB1c2VyIGhhcyBlbmFibGVkIGhleCBkYXRhIGZpZWxkIGluIGFkdmFuY2VkIHNldHRpbmdzIHRoZXkgd2lsbCBiZVxuICogYWJsZSB0byBzdXBwbHkgaGV4IGRhdGEgb24gYSB0cmFuc2FjdGlvbi4gVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgdXNlclxuICogc3VwcGxpZWQgZGF0YS4gTm90ZSwgd2hlbiBzZW5kaW5nIG5hdGl2ZSBhc3NldHMgdGhpcyB3aWxsIHJlc3VsdCBpblxuICogcmVjb21wdXRpbmcgZXN0aW1hdGVkIGdhc0xpbWl0LiBXaGVuIHNlbmRpbmcgYSBFUkMyMCBhc3NldCB0aGlzIGlzIG5vdCBkb25lXG4gKiBiZWNhdXNlIHRoZSBkYXRhIHNlbnQgaW4gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgYXNzZXQsXG4gKiByZWNpcGllbnQgYW5kIHZhbHVlLCBOT1Qgd2hhdCB0aGUgdXNlciBoYXMgc3VwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhleERhdGEgLSBoZXggZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRyYW5zYWN0aW9uIGRhdGEuXG4gKiBAcmV0dXJucyB7VGh1bmtBY3Rpb248dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTZW5kSGV4RGF0YShoZXhEYXRhKSB7XG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICBhZGRIaXN0b3J5RW50cnkoYHNlbmRGbG93IC0gdXNlciBhZGRlZCBjdXN0b20gaGV4RGF0YSAke2hleERhdGF9YCksXG4gICAgKTtcblxuICAgIGF3YWl0IGRpc3BhdGNoKGFjdGlvbnMudXBkYXRlVXNlcklucHV0SGV4RGF0YShoZXhEYXRhKSk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc3RhdGVbbmFtZV0uZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGVbbmFtZV0uY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuTkFUSVZFKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChjb21wdXRlRXN0aW1hdGVkR2FzTGltaXQoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHJlY2lwaWVudCBzZWFyY2ggbW9kZSB0byBzaG93IGEgbGlzdCBvZiB0aGUgdXNlcidzIGNvbnRhY3RzIGFuZFxuICogcmVjZW50bHkgaW50ZXJhY3RlZCB3aXRoIGFkZHJlc3Nlcy5cbiAqXG4gKiBAcmV0dXJucyB7VGh1bmtBY3Rpb248dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb250YWN0TGlzdEZvclJlY2lwaWVudFNlYXJjaCgpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIGRpc3BhdGNoKFxuICAgICAgYWRkSGlzdG9yeUVudHJ5KFxuICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNlbGVjdGVkIGJhY2sgdG8gYWxsIG9uIHJlY2lwaWVudCBzY3JlZW5gLFxuICAgICAgKSxcbiAgICApO1xuICAgIGRpc3BhdGNoKHVwZGF0ZVJlY2lwaWVudFNlYXJjaE1vZGUoUkVDSVBJRU5UX1NFQVJDSF9NT0RFUy5DT05UQUNUX0xJU1QpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSByZWNpcGllbnQgc2VhcmNoIG1vZGUgdG8gc2hvdyBhIGxpc3Qgb2YgdGhlIHVzZXIncyBvd24gYWNjb3VudHMuXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTXlBY2NvdW50c0ZvclJlY2lwaWVudFNlYXJjaCgpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIGRpc3BhdGNoKFxuICAgICAgYWRkSGlzdG9yeUVudHJ5KFxuICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNlbGVjdGVkIHRyYW5zZmVyIHRvIG15IGFjY291bnRzIG9uIHJlY2lwaWVudCBzY3JlZW5gLFxuICAgICAgKSxcbiAgICApO1xuICAgIGRpc3BhdGNoKHVwZGF0ZVJlY2lwaWVudFNlYXJjaE1vZGUoUkVDSVBJRU5UX1NFQVJDSF9NT0RFUy5NWV9BQ0NPVU5UUykpO1xuICB9O1xufVxuXG4vKipcbiAqIENsZWFycyBvdXQgdGhlIHJlY2lwaWVudCB1c2VyIGlucHV0LCBFTlMgcmVzb2x1dGlvbiBhbmQgcmVjaXBpZW50IHZhbGlkYXRpb24uXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRSZWNpcGllbnRJbnB1dCgpIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKHN0YXRlKTtcbiAgICBhd2FpdCBkaXNwYXRjaChhZGRIaXN0b3J5RW50cnkoYHNlbmRGbG93IC0gdXNlciBjbGVhcmVkIHJlY2lwaWVudCBpbnB1dGApKTtcbiAgICBhd2FpdCBkaXNwYXRjaCh1cGRhdGVSZWNpcGllbnRVc2VySW5wdXQoJycpKTtcbiAgICBhd2FpdCBkaXNwYXRjaCh1cGRhdGVSZWNpcGllbnQoeyBhZGRyZXNzOiAnJywgbmlja25hbWU6ICcnIH0pKTtcbiAgICBhd2FpdCBkaXNwYXRjaChyZXNldEVuc1Jlc29sdXRpb24oKSk7XG4gICAgYXdhaXQgZGlzcGF0Y2godmFsaWRhdGVSZWNpcGllbnRVc2VySW5wdXQoeyBjaGFpbklkIH0pKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIGVudGlyZSBzZW5kIHN0YXRlIHRyZWUgdG8gdGhlIGluaXRpYWwgc3RhdGUuIEl0IGFsc28gZGlzY29ubmVjdHNcbiAqIHBvbGxpbmcgZnJvbSB0aGUgZ2FzIGNvbnRyb2xsZXIgaWYgdGhlIHRva2VuIGlzIHByZXNlbnQgaW4gc3RhdGUuXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRTZW5kU3RhdGUoKSB7XG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGRpc3BhdGNoKGFjdGlvbnMucmVzZXRTZW5kU3RhdGUoKSk7XG5cbiAgICBpZiAoc3RhdGVbbmFtZV0uZ2FzRXN0aW1hdGVQb2xsVG9rZW4pIHtcbiAgICAgIGF3YWl0IGRpc2Nvbm5lY3RHYXNGZWVFc3RpbWF0ZVBvbGxlcihzdGF0ZVtuYW1lXS5nYXNFc3RpbWF0ZVBvbGxUb2tlbik7XG4gICAgICByZW1vdmVQb2xsaW5nVG9rZW5Gcm9tQXBwU3RhdGUoc3RhdGVbbmFtZV0uZ2FzRXN0aW1hdGVQb2xsVG9rZW4pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBTaWducyBhIHRyYW5zYWN0aW9uIG9yIHVwZGF0ZXMgYSB0cmFuc2FjdGlvbiBpbiBzdGF0ZSBpZiBlZGl0aW5nLlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIGNsaWNrcyB0aGUgbmV4dCBidXR0b24gaW4gdGhlIGZvb3RlciBvZlxuICogdGhlIHNlbmQgcGFnZSwgc2lnbmFsaW5nIHRoYXQgYSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuIFRoaXMgbWV0aG9kXG4gKiB3aWxsIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb24gaW4gc3RhdGUgKGJ5IHdheSBvZiB0aGUgdmFyaW91cyBnbG9iYWwgcHJvdmlkZXJcbiAqIGNvbnN0cnVjdHMpIHdoaWNoIHdpbGwgZXZlbnR1YWxseSAoYW5kIGZhaXJseSBxdWlja2x5IGZyb20gdXNlciBwZXJzcGVjdGl2ZSlcbiAqIHJlc3VsdCBpbiBhIGNvbmZpcm1hdGlvbiB3aW5kb3cgYmVpbmcgZGlzcGxheWVkIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IHN0YWdlLCBlaXAxNTU5c3VwcG9ydCB9ID0gc3RhdGVbbmFtZV07XG4gICAgY29uc3QgdHhQYXJhbXMgPSBnZW5lcmF0ZVRyYW5zYWN0aW9uUGFyYW1zKHN0YXRlW25hbWVdKTtcbiAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgIHN0YXRlW25hbWVdLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlW25hbWVdLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgIGlmIChzdGFnZSA9PT0gU0VORF9TVEFHRVMuRURJVCkge1xuICAgICAgLy8gV2hlbiBkZWFsaW5nIHdpdGggdGhlIGVkaXQgZmxvdyB0aGVyZSBpcyBhbHJlYWR5IGEgdHJhbnNhY3Rpb24gaW5cbiAgICAgIC8vIHN0YXRlIHRoYXQgd2UgbXVzdCB1cGRhdGUsIHRoaXMgYnJhbmNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0IGxvZ2ljLlxuICAgICAgLy8gV2UgZmlyc3QgbXVzdCBncmFiIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbiBvYmplY3QgZnJvbSBzdGF0ZSBhbmQgdGhlblxuICAgICAgLy8gbWVyZ2UgaW4gdGhlIG1vZGlmaWVkIHR4UGFyYW1zLiBPbmNlIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgLy8gd2UgY2FuIHNlbmQgdGhhdCB0byB0aGUgYmFja2dyb3VuZCB0byB1cGRhdGUgdGhlIHRyYW5zYWN0aW9uIGluIHN0YXRlLlxuICAgICAgY29uc3QgdW5hcHByb3ZlZFR4cyA9IGdldFVuYXBwcm92ZWRUeHMoc3RhdGUpO1xuICAgICAgY29uc3QgdW5hcHByb3ZlZFR4ID0gdW5hcHByb3ZlZFR4c1tkcmFmdFRyYW5zYWN0aW9uLmlkXTtcbiAgICAgIC8vIFdlIG9ubHkgdXBkYXRlIHRoZSB0eCBwYXJhbXMgdGhhdCBjYW4gYmUgY2hhbmdlZCB2aWEgdGhlIGVkaXQgZmxvdyBVWFxuICAgICAgY29uc3QgZWlwMTU1OU9ubHlUeFBhcmFtc1RvVXBkYXRlID0ge1xuICAgICAgICBkYXRhOiB0eFBhcmFtcy5kYXRhLFxuICAgICAgICBmcm9tOiB0eFBhcmFtcy5mcm9tLFxuICAgICAgICB0bzogdHhQYXJhbXMudG8sXG4gICAgICAgIHZhbHVlOiB0eFBhcmFtcy52YWx1ZSxcbiAgICAgICAgZ2FzOiB1bmFwcHJvdmVkVHgudXNlckVkaXRlZEdhc0xpbWl0XG4gICAgICAgICAgPyB1bmFwcHJvdmVkVHgudHhQYXJhbXMuZ2FzXG4gICAgICAgICAgOiB0eFBhcmFtcy5nYXMsXG4gICAgICB9O1xuICAgICAgdW5hcHByb3ZlZFR4Lm9yaWdpbmFsR2FzRXN0aW1hdGUgPSBlaXAxNTU5T25seVR4UGFyYW1zVG9VcGRhdGUuZ2FzO1xuICAgICAgY29uc3QgZWRpdGluZ1R4ID0ge1xuICAgICAgICAuLi51bmFwcHJvdmVkVHgsXG4gICAgICAgIHR4UGFyYW1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHVuYXBwcm92ZWRUeC50eFBhcmFtcyxcbiAgICAgICAgICBlaXAxNTU5c3VwcG9ydCA/IGVpcDE1NTlPbmx5VHhQYXJhbXNUb1VwZGF0ZSA6IHR4UGFyYW1zLFxuICAgICAgICApLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIGNsaWNrZWQgbmV4dCBhbmQgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIHVwZGF0ZWQgaW4gY29udHJvbGxlcmAsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uU2VuZEZsb3dIaXN0b3J5KFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uaWQsXG4gICAgICAgICAgdW5hcHByb3ZlZFR4LnNlbmRGbG93SGlzdG9yeT8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5oaXN0b3J5LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKFxuICAgICAgICB1cGRhdGVFZGl0YWJsZVBhcmFtcyhkcmFmdFRyYW5zYWN0aW9uLmlkLCBlZGl0aW5nVHgudHhQYXJhbXMpLFxuICAgICAgKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKFxuICAgICAgICB1cGRhdGVUcmFuc2FjdGlvbkdhc0ZlZXMoZHJhZnRUcmFuc2FjdGlvbi5pZCwgZWRpdGluZ1R4LnR4UGFyYW1zKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0cmFuc2FjdGlvblR5cGUgPVxuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC50eXBlID09PSBSRUNJUElFTlRfVFlQRVMuU01BUlRfQ09OVFJBQ1RcbiAgICAgICAgICA/IFRSQU5TQUNUSU9OX1RZUEVTLkNPTlRSQUNUX0lOVEVSQUNUSU9OXG4gICAgICAgICAgOiBUUkFOU0FDVElPTl9UWVBFUy5TSU1QTEVfU0VORDtcblxuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSAhPT0gQVNTRVRfVFlQRVMuTkFUSVZFKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZSA9XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgICAgICAgPyBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTVxuICAgICAgICAgICAgOiBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVI7XG4gICAgICB9XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgYWRkSGlzdG9yeUVudHJ5KFxuICAgICAgICAgIGBzZW5kRmxvdyAtIHVzZXIgY2xpY2tlZCBuZXh0IGFuZCB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWRkZWQgdG8gY29udHJvbGxlcmAsXG4gICAgICAgICksXG4gICAgICApO1xuXG4gICAgICBkaXNwYXRjaChcbiAgICAgICAgYWRkVW5hcHByb3ZlZFRyYW5zYWN0aW9uQW5kUm91dGVUb0NvbmZpcm1hdGlvblBhZ2UoXG4gICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgdHJhbnNhY3Rpb25UeXBlLFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uaGlzdG9yeSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFRvZ2dsZXMgdGhlIGFtb3VudC5tb2RlIGJldHdlZW4gSU5QVVQgYW5kIE1BWCBtb2Rlcy5cbiAqIEFzIGEgcmVzdWx0LCB0aGUgYW1vdW50LnZhbHVlIHdpbGwgY2hhbmdlIHRvIGVpdGhlciAnMHgwJyB3aGVuIG1vdmluZyBmcm9tXG4gKiBNQVggdG8gSU5QVVQsIG9yIHRvIHRoZSBtYXhpbXVtIGFsbG93YWJsZSBhbW91bnQgYmFzZWQgb24gY3VycmVudCBhc3NldCB3aGVuXG4gKiBtb3ZpbmcgZnJvbSBJTlBVVCB0byBNQVguXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlU2VuZE1heE1vZGUoKSB7XG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZVtuYW1lXS5hbW91bnRNb2RlID09PSBBTU9VTlRfTU9ERVMuTUFYKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZUFtb3VudE1vZGUoQU1PVU5UX01PREVTLklOUFVUKSk7XG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZVNlbmRBbW91bnQoJzB4MCcpKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGFkZEhpc3RvcnlFbnRyeShgc2VuZEZsb3cgLSB1c2VyIHRvZ2dsZWQgbWF4IG1vZGUgb2ZmYCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZUFtb3VudE1vZGUoQU1PVU5UX01PREVTLk1BWCkpO1xuICAgICAgYXdhaXQgZGlzcGF0Y2goYWN0aW9ucy51cGRhdGVBbW91bnRUb01heCgpKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGFkZEhpc3RvcnlFbnRyeShgc2VuZEZsb3cgLSB1c2VyIHRvZ2dsZWQgbWF4IG1vZGUgb25gKSk7XG4gICAgfVxuICAgIGF3YWl0IGRpc3BhdGNoKGNvbXB1dGVFc3RpbWF0ZWRHYXNMaW1pdCgpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCZWdpbnMgYSBuZXcgZHJhZnQgdHJhbnNhY3Rpb24sIGNsZWFyaW5nIG91dCB0aGUgcHJldmlvdXMgZHJhZnQgdHJhbnNhY3Rpb25zXG4gKiBmcm9tIHN0YXRlLCBhbmQgY2xlYXJpbmcgdGhlIGN1cnJlbnRUcmFuc2FjdGlvblVVSUQuIFRoaXMgYWN0aW9uIGlzIG9uZSBvZlxuICogdGhlIHR3byBlbnRyeSBwb2ludHMgaW50byB0aGUgc2VuZCBmbG93LiBOT1RFOiBZb3UgbXVzdCByb3V0ZSB0byB0aGUgc2VuZFxuICogcGFnZSAqYWZ0ZXIqIGRpc3BhdGNoaW5nIHRoaXMgYWN0aW9uIHJlc29sdmVzIHRvIGVuc3VyZSB0aGF0IHRoZVxuICogZHJhZnRUcmFuc2FjdGlvbiBpcyBwcm9wZXJseSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7UGljazxBc3NldCwgJ3R5cGUnIHwgJ2RldGFpbHMnPn0gYXNzZXQgLSBBIHBhcnRpYWwgYXNzZXRcbiAqICBvYmplY3QgY29udGFpbmluZyBhdCBsZWFzdCB0aGUgYXNzZXQgdHlwZS4gSWYgc3BlY2lmeWluZyBhIG5vbi1uYXRpdmUgYXNzZXRcbiAqICB0aGVuIHRoZSBhc3NldCBkZXRhaWxzIG11c3QgYmUgaW5jbHVkZWQgd2l0aCBhdCBsZWFzdCB0aGUgYWRkcmVzcy5cbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0TmV3RHJhZnRUcmFuc2FjdGlvbihhc3NldCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XG4gICAgYXdhaXQgZGlzcGF0Y2goYWN0aW9ucy5jbGVhclByZXZpb3VzRHJhZnRzKCkpO1xuXG4gICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICBhY3Rpb25zLmFkZE5ld0RyYWZ0KHtcbiAgICAgICAgLi4uZHJhZnRUcmFuc2FjdGlvbkluaXRpYWxTdGF0ZSxcbiAgICAgICAgaGlzdG9yeTogW2BzZW5kRmxvdyAtIFVzZXIgc3RhcnRlZCBuZXcgZHJhZnQgdHJhbnNhY3Rpb25gXSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgIHVwZGF0ZVNlbmRBc3NldCh7XG4gICAgICAgIHR5cGU6IGFzc2V0LnR5cGUgPz8gQVNTRVRfVFlQRVMuTkFUSVZFLFxuICAgICAgICBkZXRhaWxzOiBhc3NldC5kZXRhaWxzLFxuICAgICAgfSksXG4gICAgKTtcblxuICAgIGF3YWl0IGRpc3BhdGNoKGluaXRpYWxpemVTZW5kU3RhdGUoKSk7XG4gIH07XG59XG5cbi8vIFNlbGVjdG9yc1xuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHR5cGVkZWYgaXMgYSBzaG9ydGN1dCBmb3IgdHlwaW5nIHNlbGVjdG9ycyBiZWxvdy4gSXQgdXNlcyBhXG4gKiBnZW5lcmljIHR5cGUsIFQsIHNvIHRoYXQgZWFjaCBzZWxlY3RvciBjYW4gc3BlY2lmeSBpdCdzIHJldHVybiB0eXBlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7KHN0YXRlOiBNZXRhTWFza1N0YXRlKSA9PiBUfSBTZWxlY3RvclxuICovXG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgVVVJRC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2FjdGlvblVVSUQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLmN1cnJlbnRUcmFuc2FjdGlvblVVSUQ7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uLlxuICpcbiAqIEB0eXBlIHtTZWxlY3RvcjxEcmFmdFRyYW5zYWN0aW9uPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZVtuYW1lXS5kcmFmdFRyYW5zYWN0aW9uc1tnZXRDdXJyZW50VHJhbnNhY3Rpb25VVUlEKHN0YXRlKV0gPz8ge307XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgYSBkcmFmdCB0cmFuc2FjdGlvbiBleGlzdHMuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPGJvb2xlYW4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHJhZnRUcmFuc2FjdGlvbkV4aXN0cyhzdGF0ZSkge1xuICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID0gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpO1xuICBpZiAoT2JqZWN0LmtleXMoZHJhZnRUcmFuc2FjdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBHYXMgc2VsZWN0b3JzXG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgZ2FzTGltaXQuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPD9zdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2FzTGltaXQoc3RhdGUpIHtcbiAgcmV0dXJuIGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5nYXM/Lmdhc0xpbWl0O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBkcmFmdCB0cmFuc2FjdGlvbidzIGdhc1ByaWNlLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdhc1ByaWNlKHN0YXRlKSB7XG4gIHJldHVybiBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5nYXNQcmljZTtcbn1cblxuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24ncyBnYXNUb3RhbC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHYXNUb3RhbChzdGF0ZSkge1xuICByZXR1cm4gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLmdhcz8uZ2FzVG90YWw7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBlcnJvciwgaWYgcHJlc2VudCwgZm9yIHRoZSBnYXMgZmllbGRzLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdhc0ZlZUlzSW5FcnJvcihzdGF0ZSkge1xuICByZXR1cm4gQm9vbGVhbihnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5lcnJvcik7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBtaW5pbXVtIGdhc0xpbWl0IGZvciB0aGUgY3VycmVudCBuZXR3b3JrLlxuICpcbiAqIEB0eXBlIHtTZWxlY3RvcjxzdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluaW11bUdhc0xpbWl0Rm9yU2VuZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGVbbmFtZV0uZ2FzTGltaXRNaW5pbXVtO1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBkcmFmdCB0cmFuc2FjdGlvbidzIGdhc0xpbWl0LlxuICpcbiAqIEB0eXBlIHtTZWxlY3RvcjxNYXBWYWx1ZXNUb1VuaW9uPFNlbmRTdGF0ZUdhc01vZGVzPj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHYXNJbnB1dE1vZGUoc3RhdGUpIHtcbiAgY29uc3QgaXNNYWlubmV0ID0gZ2V0SXNNYWlubmV0KHN0YXRlKTtcbiAgY29uc3QgZ2FzRXN0aW1hdGVUeXBlID0gZ2V0R2FzRXN0aW1hdGVUeXBlKHN0YXRlKTtcbiAgY29uc3Qgc2hvd0FkdmFuY2VkR2FzRmllbGRzID0gZ2V0QWR2YW5jZWRJbmxpbmVHYXNTaG93bihzdGF0ZSk7XG4gIGlmIChzdGF0ZVtuYW1lXS5nYXNJc1NldEluTW9kYWwpIHtcbiAgICByZXR1cm4gR0FTX0lOUFVUX01PREVTLkNVU1RPTTtcbiAgfVxuICBpZiAoKCFpc01haW5uZXQgJiYgIXByb2Nlc3MuZW52LklOX1RFU1QpIHx8IHNob3dBZHZhbmNlZEdhc0ZpZWxkcykge1xuICAgIHJldHVybiBHQVNfSU5QVVRfTU9ERVMuSU5MSU5FO1xuICB9XG5cbiAgLy8gV2UgZ2V0IGV0aF9nYXNQcmljZSBlc3RpbWF0aW9uIGlmIHRoZSBsZWdhY3kgQVBJIGZhaWxzIGJ1dCB3ZSBuZWVkIHRvXG4gIC8vIGluc3RydWN0IHRoZSBVSSB0byByZW5kZXIgdGhlIElOTElORSBpbnB1dHMgaW4gdGhpcyBjYXNlLCBvbmx5IG9uXG4gIC8vIG1haW5uZXQgb3IgSU5fVEVTVC5cbiAgaWYgKFxuICAgIChpc01haW5uZXQgfHwgcHJvY2Vzcy5lbnYuSU5fVEVTVCkgJiZcbiAgICBnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5FVEhfR0FTUFJJQ0VcbiAgKSB7XG4gICAgcmV0dXJuIEdBU19JTlBVVF9NT0RFUy5JTkxJTkU7XG4gIH1cbiAgcmV0dXJuIEdBU19JTlBVVF9NT0RFUy5CQVNJQztcbn1cblxuLy8gQXNzZXQgU2VsZWN0b3JzXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgYXNzZXQgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24gaXMgc2VuZGluZy5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P0Fzc2V0Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbmRBc3NldChzdGF0ZSkge1xuICByZXR1cm4gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLmFzc2V0O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgbm9uLW5hdGl2ZSBhc3NldCB0aGF0XG4gKiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBpcyBzZW5kaW5nLCBpZiBpdCBleGlzdHMuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPD9zdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VuZEFzc2V0QWRkcmVzcyhzdGF0ZSkge1xuICByZXR1cm4gZ2V0U2VuZEFzc2V0KHN0YXRlKT8uZGV0YWlscz8uYWRkcmVzcztcbn1cblxuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgYSBib29sZWFuIHZhbHVlIGRlc2NyaWJpbmcgd2hldGhlciB0aGUgY3VycmVudGx5XG4gKiBzZWxlY3RlZCBhc3NldCBpcyBzZW5kYWJsZSwgYmFzZWQgdXBvbiB0aGUgc3RhbmRhcmQgb2YgdGhlIHRva2VuLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElzQXNzZXRTZW5kYWJsZShzdGF0ZSkge1xuICBpZiAoZ2V0U2VuZEFzc2V0KHN0YXRlKT8udHlwZSA9PT0gQVNTRVRfVFlQRVMuTkFUSVZFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGdldFNlbmRBc3NldChzdGF0ZSk/LmRldGFpbHM/LmlzRVJDNzIxID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgdGhlIGFzc2V0IGVycm9yIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NldEVycm9yKHN0YXRlKSB7XG4gIHJldHVybiBnZXRTZW5kQXNzZXQoc3RhdGUpLmVycm9yO1xufVxuXG4vLyBBbW91bnQgU2VsZWN0b3JzXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgYW1vdW50IHRoYXQgY3VycmVudCBkcmFmdCB0cmFuc2FjdGlvbiBpcyBzZW5kaW5nLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbmRBbW91bnQoc3RhdGUpIHtcbiAgcmV0dXJuIGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5hbW91bnQ/LnZhbHVlO1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGhhcyBlbm91Z2ggbmF0aXZlIGFzc2V0IGJhbGFuY2UgdG9cbiAqIGNvdmVyIHRoZSBjb3N0IG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc0JhbGFuY2VJbnN1ZmZpY2llbnQoc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5lcnJvciA9PT0gSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SXG4gICk7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBhbW91bmcgc2VuZCBtb2RlLCBlaXRoZXIgTUFYIG9yIElOUFVULlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbmRNYXhNb2RlU3RhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVg7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgZGF0YSBmaWVsZC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kSGV4RGF0YShzdGF0ZSkge1xuICByZXR1cm4gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLnVzZXJJbnB1dEhleERhdGE7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgaWQsIGlmIHByZXNlbnQuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPD9zdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHJhZnRUcmFuc2FjdGlvbklEKHN0YXRlKSB7XG4gIHJldHVybiBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuaWQ7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW4gZXJyb3Igb24gdGhlIGFtb3VudCBmaWVsZC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kQW1vdW50SXNJbkVycm9yKHN0YXRlKSB7XG4gIHJldHVybiBCb29sZWFuKGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5hbW91bnQ/LmVycm9yKTtcbn1cblxuLy8gUmVjaXBpZW50IFNlbGVjdG9yc1xuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24ncyByZWNpcGllbnQuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPERyYWZ0VHJhbnNhY3Rpb25bJ3JlY2lwaWVudCddPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY2lwaWVudChzdGF0ZSkge1xuICBjb25zdCBkcmFmdCA9IGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKTtcbiAgaWYgKCFkcmFmdC5yZWNpcGllbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogJycsXG4gICAgICBuaWNrbmFtZTogJycsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgfTtcbiAgfVxuICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSB0b0NoZWNrc3VtSGV4QWRkcmVzcyhkcmFmdC5yZWNpcGllbnQuYWRkcmVzcyk7XG4gIGlmIChzdGF0ZS5tZXRhbWFzay5lbnNSZXNvbHV0aW9uc0J5QWRkcmVzcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kcmFmdC5yZWNpcGllbnQsXG4gICAgICBuaWNrbmFtZTpcbiAgICAgICAgZHJhZnQucmVjaXBpZW50Lm5pY2tuYW1lIHx8XG4gICAgICAgIGdldEVuc1Jlc29sdXRpb25CeUFkZHJlc3Moc3RhdGUsIGNoZWNrc3VtbWVkQWRkcmVzcyksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZHJhZnQucmVjaXBpZW50O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgYWRkcmVzIG9mIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3NcbiAqIHJlY2lwaWVudC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kVG8oc3RhdGUpIHtcbiAgcmV0dXJuIGdldFJlY2lwaWVudChzdGF0ZSk/LmFkZHJlc3M7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcmVjaXBpZW50TW9kZSBpcyBNWV9BQ0NPVU5UU1xuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElzVXNpbmdNeUFjY291bnRGb3JSZWNpcGllbnRTZWFyY2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLnJlY2lwaWVudE1vZGUgPT09IFJFQ0lQSUVOVF9TRUFSQ0hfTU9ERVMuTVlfQUNDT1VOVFM7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIGhhcyB0eXBlZCBpbnRvIHRoZSByZWNpcGllbnRcbiAqIGlucHV0IGZpZWxkLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY2lwaWVudFVzZXJJbnB1dChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGVbbmFtZV0ucmVjaXBpZW50SW5wdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWNpcGllbnRXYXJuaW5nQWNrbm93bGVkZ2VtZW50KHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLnJlY2lwaWVudD8ucmVjaXBpZW50V2FybmluZ0Fja25vd2xlZGdlZCA/P1xuICAgIGZhbHNlXG4gICk7XG59XG5cbi8vIE92ZXJhbGwgdmFsaWRpdHkgYW5kIHN0YWdlIHNlbGVjdG9yc1xuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgZ2FzRmVlIGFuZCBhbW91bnQgZXJyb3JzLCBpZiB0aGV5IGV4aXN0LlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjx7IGdhc0ZlZT86IHN0cmluZywgYW1vdW50Pzogc3RyaW5nfT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kRXJyb3JzKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgZ2FzRmVlOiBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5lcnJvcixcbiAgICBhbW91bnQ6IGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5hbW91bnQ/LmVycm9yLFxuICB9O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBzdGFnZSBpcyBhbnl0aGluZyBleGNlcHQgSU5BQ1RJVkVcbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NlbmRTdGF0ZUluaXRpYWxpemVkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZVtuYW1lXS5zdGFnZSAhPT0gU0VORF9TVEFHRVMuSU5BQ1RJVkU7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24gaXMgdmFsaWQgYW5kIGluXG4gKiBhIHNlbmRhYmxlIHN0YXRlLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2VuZEZvcm1JbnZhbGlkKHN0YXRlKSB7XG4gIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPSBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSk7XG4gIGlmICghZHJhZnRUcmFuc2FjdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBkcmFmdFRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gU0VORF9TVEFUVVNFUy5JTlZBTElEO1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBzdGFnZSBvZiB0aGUgc2VuZCBmbG93XG4gKlxuICogQHR5cGUge1NlbGVjdG9yPE1hcFZhbHVlc1RvVW5pb248U2VuZFN0YXRlU3RhZ2VzPj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kU3RhZ2Uoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLnN0YWdlO1xufVxuIiwiZXhwb3J0IGNvbnN0IEVUSCA9ICdFVEgnO1xuZXhwb3J0IGNvbnN0IEdXRUkgPSAnR1dFSSc7XG5leHBvcnQgY29uc3QgV0VJID0gJ1dFSSc7XG5cbmV4cG9ydCBjb25zdCBQUklNQVJZID0gJ1BSSU1BUlknO1xuZXhwb3J0IGNvbnN0IFNFQ09OREFSWSA9ICdTRUNPTkRBUlknO1xuXG5leHBvcnQgY29uc3QgR0FTX0VTVElNQVRFX1RZUEVTID0ge1xuICBTTE9XOiAnU0xPVycsXG4gIEFWRVJBR0U6ICdBVkVSQUdFJyxcbiAgRkFTVDogJ0ZBU1QnLFxuICBGQVNURVNUOiAnRkFTVEVTVCcsXG59O1xuXG5sZXQgX3N1cHBvcnRSZXF1ZXN0TGluayA9ICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzJztcbmNvbnN0IF9jb250cmFjdEFkZHJlc3NMaW5rID1cbiAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDIwMDI4MDkyLVdoYXQtaXMtdGhlLWtub3duLWNvbnRyYWN0LWFkZHJlc3Mtd2FybmluZy0nO1xuXG5cbmV4cG9ydCBjb25zdCBTVVBQT1JUX1JFUVVFU1RfTElOSyA9IF9zdXBwb3J0UmVxdWVzdExpbms7XG5leHBvcnQgY29uc3QgQ09OVFJBQ1RfQUREUkVTU19MSU5LID0gX2NvbnRyYWN0QWRkcmVzc0xpbms7XG4iLCIvKipcbiAqIEEgbm90ZSBhYm91dCB0aGUgZXhpc3RlbmNlIG9mIGJvdGggc2luZ3VsYXIgYW5kIHBsdXJhbCB2YXJpYWJsZSBuYW1lcyBoZXJlOlxuICogV2hlbiBkZWFsaW5nIHdpdGggYSBsaXRlcmFsIHByb3BlcnR5IG5hbWUsIGUuZy4gQUxJR05fSVRFTVMsIHRoZSBjb25zdGFudFxuICogc2hvdWxkIG1hdGNoIHRoZSBwcm9wZXJ0eS4gV2hlbiBkZXRhaWxpbmcgYSBjb2xsZWN0aW9uIG9mIHRoaW5ncywgaXQgc2hvdWxkXG4gKiBtYXRjaCB0aGUgcGx1cmFsIGZvcm0gb2YgdGhlIHRoaW5nLiBlLmcuIENPTE9SUywgVFlQT0dSQVBIWVxuICovXG5cbmltcG9ydCB7IHBpY2sgfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgY29uc3QgQ09MT1JTID0ge1xuICBCQUNLR1JPVU5EX0RFRkFVTFQ6ICdiYWNrZ3JvdW5kLWRlZmF1bHQnLFxuICBCQUNLR1JPVU5EX0FMVEVSTkFUSVZFOiAnYmFja2dyb3VuZC1hbHRlcm5hdGl2ZScsXG4gIFRFWFRfREVGQVVMVDogJ3RleHQtZGVmYXVsdCcsXG4gIFRFWFRfQUxURVJOQVRJVkU6ICd0ZXh0LWFsdGVybmF0aXZlJyxcbiAgVEVYVF9NVVRFRDogJ3RleHQtbXV0ZWQnLFxuICBJQ09OX0RFRkFVTFQ6ICdpY29uLWRlZmF1bHQnLFxuICBJQ09OX0FMVEVSTkFUSVZFOiAnaWNvbi1hbHRlcm5hdGl2ZScsXG4gIElDT05fTVVURUQ6ICdpY29uLW11dGVkJyxcbiAgQk9SREVSX0RFRkFVTFQ6ICdib3JkZXItZGVmYXVsdCcsXG4gIEJPUkRFUl9NVVRFRDogJ2JvcmRlci1tdXRlZCcsXG4gIE9WRVJMQVlfREVGQVVMVDogJ292ZXJsYXktZGVmYXVsdCcsXG4gIE9WRVJMQVlfSU5WRVJTRTogJ292ZXJsYXktaW52ZXJzZScsXG4gIFBSSU1BUllfREVGQVVMVDogJ3ByaW1hcnktZGVmYXVsdCcsXG4gIFBSSU1BUllfQUxURVJOQVRJVkU6ICdwcmltYXJ5LWFsdGVybmF0aXZlJyxcbiAgUFJJTUFSWV9NVVRFRDogJ3ByaW1hcnktbXV0ZWQnLFxuICBQUklNQVJZX0lOVkVSU0U6ICdwcmltYXJ5LWludmVyc2UnLFxuICBQUklNQVJZX0RJU0FCTEVEOiAncHJpbWFyeS1kaXNhYmxlZCcsXG4gIEVSUk9SX0RFRkFVTFQ6ICdlcnJvci1kZWZhdWx0JyxcbiAgRVJST1JfQUxURVJOQVRJVkU6ICdlcnJvci1hbHRlcm5hdGl2ZScsXG4gIEVSUk9SX01VVEVEOiAnZXJyb3ItbXV0ZWQnLFxuICBFUlJPUl9JTlZFUlNFOiAnZXJyb3ItaW52ZXJzZScsXG4gIEVSUk9SX0RJU0FCTEVEOiAnZXJyb3ItZGlzYWJsZWQnLFxuICBXQVJOSU5HX0RFRkFVTFQ6ICd3YXJuaW5nLWRlZmF1bHQnLFxuICBXQVJOSU5HX0FMVEVSTkFUSVZFOiAnd2FybmluZy1hbHRlcm5hdGl2ZScsXG4gIFdBUk5JTkdfTVVURUQ6ICd3YXJuaW5nLW11dGVkJyxcbiAgV0FSTklOR19JTlZFUlNFOiAnd2FybmluZy1pbnZlcnNlJyxcbiAgV0FSTklOR19ESVNBQkxFRDogJ3dhcm5pbmctZGlzYWJsZWQnLFxuICBTVUNDRVNTX0RFRkFVTFQ6ICdzdWNjZXNzLWRlZmF1bHQnLFxuICBTVUNDRVNTX0FMVEVSTkFUSVZFOiAnc3VjY2Vzcy1hbHRlcm5hdGl2ZScsXG4gIFNVQ0NFU1NfTVVURUQ6ICdzdWNjZXNzLW11dGVkJyxcbiAgU1VDQ0VTU19JTlZFUlNFOiAnc3VjY2Vzcy1pbnZlcnNlJyxcbiAgU1VDQ0VTU19ESVNBQkxFRDogJ3N1Y2Nlc3MtZGlzYWJsZWQnLFxuICBJTkZPX0RFRkFVTFQ6ICdpbmZvLWRlZmF1bHQnLFxuICBJTkZPX0FMVEVSTkFUSVZFOiAnaW5mby1hbHRlcm5hdGl2ZScsXG4gIElORk9fTVVURUQ6ICdpbmZvLW11dGVkJyxcbiAgSU5GT19JTlZFUlNFOiAnaW5mby1pbnZlcnNlJyxcbiAgSU5GT19ESVNBQkxFRDogJ2luZm8tZGlzYWJsZWQnLFxuICBNQUlOTkVUOiAnbWFpbm5ldCcsXG4gIEdPRVJMSTogJ2dvZXJsaScsXG4gIFNFUE9MSUE6ICdzZXBvbGlhJyxcbiAgTE9DQUxIT1NUOiAnbG9jYWxob3N0JyxcbiAgVFJBTlNQQVJFTlQ6ICd0cmFuc3BhcmVudCcsXG4gIElOSEVSSVQ6ICdpbmhlcml0Jyxcbn07XG5leHBvcnQgY29uc3QgQkFDS0dST1VORF9DT0xPUlMgPSBwaWNrKENPTE9SUywgW1xuICAnQkFDS0dST1VORF9ERUZBVUxUJyxcbiAgJ0JBQ0tHUk9VTkRfQUxURVJOQVRJVkUnLFxuICAnT1ZFUkxBWV9ERUZBVUxUJyxcbiAgJ1BSSU1BUllfREVGQVVMVCcsXG4gICdQUklNQVJZX0FMVEVSTkFUSVZFJyxcbiAgJ1BSSU1BUllfTVVURUQnLFxuICAnRVJST1JfREVGQVVMVCcsXG4gICdFUlJPUl9BTFRFUk5BVElWRScsXG4gICdFUlJPUl9NVVRFRCcsXG4gICdXQVJOSU5HX0RFRkFVTFQnLFxuICAnV0FSTklOR19BTFRFUk5BVElWRScsXG4gICdXQVJOSU5HX01VVEVEJyxcbiAgJ1NVQ0NFU1NfREVGQVVMVCcsXG4gICdTVUNDRVNTX0FMVEVSTkFUSVZFJyxcbiAgJ1NVQ0NFU1NfTVVURUQnLFxuICAnSU5GT19ERUZBVUxUJyxcbiAgJ0lORk9fQUxURVJOQVRJVkUnLFxuICAnSU5GT19NVVRFRCcsXG4gICdNQUlOTkVUJyxcbiAgJ0dPRVJMSScsXG4gICdTRVBPTElBJyxcbiAgJ1RSQU5TUEFSRU5UJyxcbiAgJ0xPQ0FMSE9TVCcsXG5dKTtcblxuZXhwb3J0IGNvbnN0IEJPUkRFUl9DT0xPUlMgPSBwaWNrKENPTE9SUywgW1xuICAnQk9SREVSX0RFRkFVTFQnLFxuICAnQk9SREVSX01VVEVEJyxcbiAgJ1BSSU1BUllfREVGQVVMVCcsXG4gICdQUklNQVJZX0FMVEVSTkFUSVZFJyxcbiAgJ1BSSU1BUllfTVVURUQnLFxuICAnRVJST1JfREVGQVVMVCcsXG4gICdFUlJPUl9BTFRFUk5BVElWRScsXG4gICdFUlJPUl9NVVRFRCcsXG4gICdXQVJOSU5HX0RFRkFVTFQnLFxuICAnV0FSTklOR19BTFRFUk5BVElWRScsXG4gICdXQVJOSU5HX01VVEVEJyxcbiAgJ1NVQ0NFU1NfREVGQVVMVCcsXG4gICdTVUNDRVNTX0FMVEVSTkFUSVZFJyxcbiAgJ1NVQ0NFU1NfTVVURUQnLFxuICAnSU5GT19ERUZBVUxUJyxcbiAgJ0lORk9fQUxURVJOQVRJVkUnLFxuICAnSU5GT19NVVRFRCcsXG4gICdNQUlOTkVUJyxcbiAgJ0dPRVJMSScsXG4gICdTRVBPTElBJyxcbiAgJ1RSQU5TUEFSRU5UJyxcbiAgJ0xPQ0FMSE9TVCcsXG5dKTtcblxuZXhwb3J0IGNvbnN0IFRFWFRfQ09MT1JTID0gcGljayhDT0xPUlMsIFtcbiAgJ1RFWFRfREVGQVVMVCcsXG4gICdURVhUX0FMVEVSTkFUSVZFJyxcbiAgJ1RFWFRfTVVURUQnLFxuICAnT1ZFUkxBWV9JTlZFUlNFJyxcbiAgJ1BSSU1BUllfREVGQVVMVCcsXG4gICdQUklNQVJZX0lOVkVSU0UnLFxuICAnRVJST1JfREVGQVVMVCcsXG4gICdFUlJPUl9JTlZFUlNFJyxcbiAgJ1NVQ0NFU1NfREVGQVVMVCcsXG4gICdTVUNDRVNTX0lOVkVSU0UnLFxuICAnV0FSTklOR19ERUZBVUxUJyxcbiAgJ1dBUk5JTkdfSU5WRVJTRScsXG4gICdJTkZPX0RFRkFVTFQnLFxuICAnSU5GT19JTlZFUlNFJyxcbiAgJ0lOSEVSSVQnLFxuXSk7XG5cbmV4cG9ydCBjb25zdCBJQ09OX0NPTE9SUyA9IHBpY2soQ09MT1JTLCBbXG4gICdJQ09OX0RFRkFVTFQnLFxuICAnSUNPTl9BTFRFUk5BVElWRScsXG4gICdJQ09OX01VVEVEJyxcbiAgJ09WRVJMQVlfSU5WRVJTRScsXG4gICdQUklNQVJZX0RFRkFVTFQnLFxuICAnUFJJTUFSWV9JTlZFUlNFJyxcbiAgJ0VSUk9SX0RFRkFVTFQnLFxuICAnRVJST1JfSU5WRVJTRScsXG4gICdTVUNDRVNTX0RFRkFVTFQnLFxuICAnU1VDQ0VTU19JTlZFUlNFJyxcbiAgJ1dBUk5JTkdfREVGQVVMVCcsXG4gICdXQVJOSU5HX0lOVkVSU0UnLFxuICAnSU5GT19ERUZBVUxUJyxcbiAgJ0lORk9fSU5WRVJTRScsXG4gICdJTkhFUklUJyxcbl0pO1xuXG5leHBvcnQgY29uc3QgVFlQT0dSQVBIWSA9IHtcbiAgSDE6ICdoMScsXG4gIEgyOiAnaDInLFxuICBIMzogJ2gzJyxcbiAgSDQ6ICdoNCcsXG4gIEg1OiAnaDUnLFxuICBINjogJ2g2JyxcbiAgSDc6ICdoNycsXG4gIEg4OiAnaDgnLFxuICBIOTogJ2g5JyxcbiAgUGFyYWdyYXBoOiAncCcsXG59O1xuXG5leHBvcnQgY29uc3QgVEVYVCA9IHtcbiAgRElTUExBWV9NRDogJ2Rpc3BsYXktbWQnLFxuICBIRUFESU5HX0xHOiAnaGVhZGluZy1sZycsXG4gIEhFQURJTkdfTUQ6ICdoZWFkaW5nLW1kJyxcbiAgSEVBRElOR19TTTogJ2hlYWRpbmctc20nLFxuICBCT0RZX0xHOiAnYm9keS1sZy1tZWRpdW0nLFxuICBCT0RZX01EOiAnYm9keS1tZCcsXG4gIEJPRFlfU006ICdib2R5LXNtJyxcbiAgQk9EWV9YUzogJ2JvZHkteHMnLFxuICBJTkhFUklUOiAnaW5oZXJpdCcsXG59O1xuXG5jb25zdCBOT05FID0gJ25vbmUnO1xuXG5leHBvcnQgY29uc3QgU0laRVMgPSB7XG4gIFhYUzogJ3h4cycsXG4gIFhTOiAneHMnLFxuICBTTTogJ3NtJyxcbiAgTUQ6ICdtZCcsXG4gIExHOiAnbGcnLFxuICBYTDogJ3hsJyxcbiAgQVVUTzogJ2F1dG8nLCAvLyBVc2VkIGZvciBUZXh0LCBJY29uLCBhbmQgQnV0dG9uIGNvbXBvbmVudHMgdG8gaW5oZXJpdCB0aGUgcGFyZW50IGVsZW1lbnRzIGZvbnQtc2l6ZVxuICBOT05FLFxufTtcblxuZXhwb3J0IGNvbnN0IEJPUkRFUl9TVFlMRSA9IHtcbiAgREFTSEVEOiAnZGFzaGVkJyxcbiAgU09MSUQ6ICdzb2xpZCcsXG4gIERPVFRFRDogJ2RvdHRlZCcsXG4gIERPVUJMRTogJ2RvdWJsZScsXG4gIE5PTkUsXG59O1xuXG5leHBvcnQgY29uc3QgQk9SREVSX1JBRElVUyA9IHtcbiAgWFM6IFNJWkVTLlhTLFxuICBTTTogU0laRVMuU00sXG4gIE1EOiBTSVpFUy5NRCxcbiAgTEc6IFNJWkVTLkxHLFxuICBYTDogU0laRVMuWEwsXG4gIE5PTkUsXG4gIFBJTEw6ICdwaWxsJyxcbn07XG5cbmNvbnN0IEZMRVhfRU5EID0gJ2ZsZXgtZW5kJztcbmNvbnN0IEZMRVhfU1RBUlQgPSAnZmxleC1zdGFydCc7XG5jb25zdCBDRU5URVIgPSAnY2VudGVyJztcblxuZXhwb3J0IGNvbnN0IEFMSUdOX0lURU1TID0ge1xuICBGTEVYX1NUQVJULFxuICBGTEVYX0VORCxcbiAgQ0VOVEVSLFxuICBCQVNFTElORTogJ2Jhc2VsaW5lJyxcbiAgU1RSRVRDSDogJ3N0cmV0Y2gnLFxufTtcblxuZXhwb3J0IGNvbnN0IEpVU1RJRllfQ09OVEVOVCA9IHtcbiAgRkxFWF9TVEFSVCxcbiAgRkxFWF9FTkQsXG4gIENFTlRFUixcbiAgU1BBQ0VfQVJPVU5EOiAnc3BhY2UtYXJvdW5kJyxcbiAgU1BBQ0VfQkVUV0VFTjogJ3NwYWNlLWJldHdlZW4nLFxuICBTUEFDRV9FVkVOTFk6ICdzcGFjZS1ldmVubHknLFxufTtcblxuZXhwb3J0IGNvbnN0IEZMRVhfRElSRUNUSU9OID0ge1xuICBST1c6ICdyb3cnLFxuICBST1dfUkVWRVJTRTogJ3Jvdy1yZXZlcnNlJyxcbiAgQ09MVU1OOiAnY29sdW1uJyxcbiAgQ09MVU1OX1JFVkVSU0U6ICdjb2x1bW4tcmV2ZXJzZScsXG59O1xuXG5leHBvcnQgY29uc3QgRkxFWF9XUkFQID0ge1xuICBXUkFQOiAnd3JhcCcsXG4gIFdSQVBfUkVWRVJTRTogJ3dyYXAtcmV2ZXJzZScsXG4gIE5PX1dSQVA6ICdub3dyYXAnLFxufTtcblxuZXhwb3J0IGNvbnN0IERJU1BMQVkgPSB7XG4gIEJMT0NLOiAnYmxvY2snLFxuICBGTEVYOiAnZmxleCcsXG4gIEdSSUQ6ICdncmlkJyxcbiAgSU5MSU5FX0JMT0NLOiAnaW5saW5lLWJsb2NrJyxcbiAgSU5MSU5FOiAnaW5saW5lJyxcbiAgSU5MSU5FX0ZMRVg6ICdpbmxpbmUtZmxleCcsXG4gIElOTElORV9HUklEOiAnaW5saW5lLWdyaWQnLFxuICBMSVNUX0lURU06ICdsaXN0LWl0ZW0nLFxuICBOT05FOiAnbm9uZScsXG59O1xuXG5leHBvcnQgY29uc3QgRlJBQ1RJT05TID0ge1xuICBIQUxGOiAnMS8yJyxcbiAgT05FX1RISVJEOiAnMS8zJyxcbiAgVFdPX1RISVJEUzogJzIvMycsXG4gIE9ORV9GT1VSVEg6ICcxLzQnLFxuICBUV09fRk9VUlRIUzogJzIvNCcsXG4gIFRIUkVFX0ZPVVJUSFM6ICczLzQnLFxuICBPTkVfRklGVEg6ICcxLzUnLFxuICBUV09fRklGVEhTOiAnMi81JyxcbiAgVEhSRUVfRklGVEhTOiAnMy81JyxcbiAgRk9VUl9GSUZUSFM6ICc0LzUnLFxuICBPTkVfU0lYVEg6ICcxLzYnLFxuICBUV09fU0lYVEhTOiAnMi82JyxcbiAgVEhSRUVfU0lYVEhTOiAnMy82JyxcbiAgRk9VUl9TSVhUSFM6ICc0LzYnLFxuICBGSVZFX1NJWFRIUzogJzUvNicsXG4gIE9ORV9UV0VMRlRIOiAnMS8xMicsXG4gIFRXT19UV0VMRlRIUzogJzIvMTInLFxuICBUSFJFRV9UV0VMRlRIUzogJzMvMTInLFxuICBGT1VSX1RXRUxGVEhTOiAnNC8xMicsXG4gIEZJVkVfVFdFTEZUSFM6ICc1LzEyJyxcbiAgU0lYX1RXRUxGVEhTOiAnNi8xMicsXG4gIFNFVkVOX1RXRUxGVEhTOiAnNy8xMicsXG4gIEVJR0hUX1RXRUxGVEhTOiAnOC8xMicsXG4gIE5JTkVfVFdFTEZUSFM6ICc5LzEyJyxcbiAgVEVOX1RXRUxGVEhTOiAnMTAvMTInLFxuICBFTEVWRU5fVFdFTEZUSFM6ICcxMS8xMicsXG59O1xuXG5leHBvcnQgY29uc3QgQkxPQ0tfU0laRVMgPSB7XG4gIC4uLkZSQUNUSU9OUyxcbiAgU0NSRUVOOiAnc2NyZWVuJyxcbiAgTUFYOiAnbWF4JyxcbiAgTUlOOiAnbWluJyxcbiAgRlVMTDogJ2Z1bGwnLFxufTtcblxuZXhwb3J0IGNvbnN0IFRFWFRfQUxJR04gPSB7XG4gIExFRlQ6ICdsZWZ0JyxcbiAgQ0VOVEVSOiAnY2VudGVyJyxcbiAgUklHSFQ6ICdyaWdodCcsXG4gIEpVU1RJRlk6ICdqdXN0aWZ5JyxcbiAgRU5EOiAnZW5kJyxcbn07XG5cbmV4cG9ydCBjb25zdCBURVhUX1RSQU5TRk9STSA9IHtcbiAgVVBQRVJDQVNFOiAndXBwZXJjYXNlJyxcbiAgTE9XRVJDQVNFOiAnbG93ZXJjYXNlJyxcbiAgQ0FQSVRBTElaRTogJ2NhcGl0YWxpemUnLFxufTtcblxuZXhwb3J0IGNvbnN0IEZPTlRfV0VJR0hUID0ge1xuICBCT0xEOiAnYm9sZCcsXG4gIE1FRElVTTogJ21lZGl1bScsXG4gIE5PUk1BTDogJ25vcm1hbCcsXG59O1xuXG5leHBvcnQgY29uc3QgT1ZFUkZMT1dfV1JBUCA9IHtcbiAgQlJFQUtfV09SRDogJ2JyZWFrLXdvcmQnLFxuICBOT1JNQUw6ICdub3JtYWwnLFxufTtcblxuZXhwb3J0IGNvbnN0IEZPTlRfU1RZTEUgPSB7XG4gIElUQUxJQzogJ2l0YWxpYycsXG4gIE5PUk1BTDogJ25vcm1hbCcsXG59O1xuXG5leHBvcnQgY29uc3QgU0VWRVJJVElFUyA9IHtcbiAgREFOR0VSOiAnZGFuZ2VyJyxcbiAgV0FSTklORzogJ3dhcm5pbmcnLFxuICBJTkZPOiAnaW5mbycsXG4gIFNVQ0NFU1M6ICdzdWNjZXNzJyxcbn07XG5cbmV4cG9ydCBjb25zdCBSRVNJWkUgPSB7XG4gIE5PTkU6ICdub25lJyxcbiAgQk9USDogJ2JvdGgnLFxuICBIT1JJWk9OVEFMOiAnaG9yaXpvbnRhbCcsXG4gIFZFUlRJQ0FMOiAndmVydGljYWwnLFxuICBJTklUSUFMOiAnaW5pdGlhbCcsXG4gIElOSEVSSVQ6ICdpbmhlcml0Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBCUkVBS1BPSU5UUyA9IFsnYmFzZScsICdzbScsICdtZCcsICdsZyddO1xuIiwiZXhwb3J0IGNvbnN0IElOU1VGRklDSUVOVF9GVU5EU19FUlJPUl9LRVkgPSAnaW5zdWZmaWNpZW50RnVuZHMnO1xuZXhwb3J0IGNvbnN0IEdBU19MSU1JVF9UT09fTE9XX0VSUk9SX0tFWSA9ICdnYXNMaW1pdFRvb0xvdyc7XG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRVJST1JfS0VZID0gJ3RyYW5zYWN0aW9uRXJyb3InO1xuZXhwb3J0IGNvbnN0IEVUSF9HQVNfUFJJQ0VfRkVUQ0hfV0FSTklOR19LRVkgPSAnZXRoR2FzUHJpY2VGZXRjaFdhcm5pbmcnO1xuZXhwb3J0IGNvbnN0IEdBU19QUklDRV9GRVRDSF9GQUlMVVJFX0VSUk9SX0tFWSA9ICdnYXNQcmljZUZldGNoRmFpbGVkJztcbmV4cG9ydCBjb25zdCBHQVNfUFJJQ0VfRVhDRVNTSVZFX0VSUk9SX0tFWSA9ICdnYXNQcmljZUV4Y2Vzc2l2ZSc7XG5leHBvcnQgY29uc3QgVU5TRU5EQUJMRV9BU1NFVF9FUlJPUl9LRVkgPSAndW5zZW5kYWJsZUFzc2V0JztcbmV4cG9ydCBjb25zdCBJTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0dBU19FUlJPUl9LRVkgPSAnaW5zdWZmaWNpZW50RnVuZHNGb3JHYXMnO1xuZXhwb3J0IGNvbnN0IElOVkFMSURfQVNTRVRfVFlQRSA9ICdpbnZhbGlkQXNzZXRUeXBlJztcbiIsImNvbnN0IERFRkFVTFRfUk9VVEUgPSAnLyc7XHJcbmNvbnN0IFVOTE9DS19ST1VURSA9ICcvdW5sb2NrJztcclxuY29uc3QgTE9DS19ST1VURSA9ICcvbG9jayc7XHJcbmNvbnN0IEFTU0VUX1JPVVRFID0gJy9hc3NldCc7XHJcbmNvbnN0IFNFVFRJTkdTX1JPVVRFID0gJy9zZXR0aW5ncyc7XHJcbmNvbnN0IEdFTkVSQUxfUk9VVEUgPSAnL3NldHRpbmdzL2dlbmVyYWwnO1xyXG5jb25zdCBBRFZBTkNFRF9ST1VURSA9ICcvc2V0dGluZ3MvYWR2YW5jZWQnO1xyXG5jb25zdCBFWFBFUklNRU5UQUxfUk9VVEUgPSAnL3NldHRpbmdzL2V4cGVyaW1lbnRhbCc7XHJcbmNvbnN0IFNFQ1VSSVRZX1JPVVRFID0gJy9zZXR0aW5ncy9zZWN1cml0eSc7XHJcbmNvbnN0IEFCT1VUX1VTX1JPVVRFID0gJy9zZXR0aW5ncy9hYm91dC11cyc7XHJcbmNvbnN0IEFMRVJUU19ST1VURSA9ICcvc2V0dGluZ3MvYWxlcnRzJztcclxuY29uc3QgTkVUV09SS1NfUk9VVEUgPSAnL3NldHRpbmdzL25ldHdvcmtzJztcclxuY29uc3QgTkVUV09SS1NfRk9STV9ST1VURSA9ICcvc2V0dGluZ3MvbmV0d29ya3MvZm9ybSc7XHJcbmNvbnN0IEFERF9ORVRXT1JLX1JPVVRFID0gJy9zZXR0aW5ncy9uZXR3b3Jrcy9hZGQtbmV0d29yayc7XHJcbmNvbnN0IEFERF9QT1BVTEFSX0NVU1RPTV9ORVRXT1JLID1cclxuICAnL3NldHRpbmdzL25ldHdvcmtzL2FkZC1wb3B1bGFyLWN1c3RvbS1uZXR3b3JrJztcclxuY29uc3QgU05BUFNfTElTVF9ST1VURSA9ICcvc2V0dGluZ3Mvc25hcHMtbGlzdCc7XHJcbmNvbnN0IFNOQVBTX1ZJRVdfUk9VVEUgPSAnL3NldHRpbmdzL3NuYXBzLXZpZXcnO1xyXG5jb25zdCBDT05UQUNUX0xJU1RfUk9VVEUgPSAnL3NldHRpbmdzL2NvbnRhY3QtbGlzdCc7XHJcbmNvbnN0IENPTlRBQ1RfRURJVF9ST1VURSA9ICcvc2V0dGluZ3MvY29udGFjdC1saXN0L2VkaXQtY29udGFjdCc7XHJcbmNvbnN0IENPTlRBQ1RfQUREX1JPVVRFID0gJy9zZXR0aW5ncy9jb250YWN0LWxpc3QvYWRkLWNvbnRhY3QnO1xyXG5jb25zdCBDT05UQUNUX1ZJRVdfUk9VVEUgPSAnL3NldHRpbmdzL2NvbnRhY3QtbGlzdC92aWV3LWNvbnRhY3QnO1xyXG5jb25zdCBSRVZFQUxfU0VFRF9ST1VURSA9ICcvc2VlZCc7XHJcbmNvbnN0IE1PQklMRV9TWU5DX1JPVVRFID0gJy9tb2JpbGUtc3luYyc7XHJcbmNvbnN0IFJFU1RPUkVfVkFVTFRfUk9VVEUgPSAnL3Jlc3RvcmUtdmF1bHQnO1xyXG5jb25zdCBJTVBPUlRfVE9LRU5fUk9VVEUgPSAnL2ltcG9ydC10b2tlbic7XHJcbmNvbnN0IENPTkZJUk1fSU1QT1JUX1RPS0VOX1JPVVRFID0gJy9jb25maXJtLWltcG9ydC10b2tlbic7XHJcbmNvbnN0IENPTkZJUk1fQUREX1NVR0dFU1RFRF9UT0tFTl9ST1VURSA9ICcvY29uZmlybS1hZGQtc3VnZ2VzdGVkLXRva2VuJztcclxuY29uc3QgTkVXX0FDQ09VTlRfUk9VVEUgPSAnL25ldy1hY2NvdW50JztcclxuY29uc3QgSU1QT1JUX0FDQ09VTlRfUk9VVEUgPSAnL25ldy1hY2NvdW50L2ltcG9ydCc7XHJcbmNvbnN0IENPTk5FQ1RfSEFSRFdBUkVfUk9VVEUgPSAnL25ldy1hY2NvdW50L2Nvbm5lY3QnO1xyXG5jb25zdCBTRU5EX1JPVVRFID0gJy9zZW5kJztcclxuY29uc3QgVE9LRU5fREVUQUlMUyA9ICcvdG9rZW4tZGV0YWlscyc7XHJcbmNvbnN0IENPTk5FQ1RfUk9VVEUgPSAnL2Nvbm5lY3QnO1xyXG5jb25zdCBDT05ORUNUX0NPTkZJUk1fUEVSTUlTU0lPTlNfUk9VVEUgPSAnL2NvbmZpcm0tcGVybWlzc2lvbnMnO1xyXG5cbmNvbnN0IENPTk5FQ1RFRF9ST1VURSA9ICcvY29ubmVjdGVkJztcclxuY29uc3QgQ09OTkVDVEVEX0FDQ09VTlRTX1JPVVRFID0gJy9jb25uZWN0ZWQvYWNjb3VudHMnO1xyXG5jb25zdCBTV0FQU19ST1VURSA9ICcvc3dhcHMnO1xyXG5jb25zdCBCVUlMRF9RVU9URV9ST1VURSA9ICcvc3dhcHMvYnVpbGQtcXVvdGUnO1xyXG5jb25zdCBWSUVXX1FVT1RFX1JPVVRFID0gJy9zd2Fwcy92aWV3LXF1b3RlJztcclxuY29uc3QgTE9BRElOR19RVU9URVNfUk9VVEUgPSAnL3N3YXBzL2xvYWRpbmctcXVvdGVzJztcclxuY29uc3QgQVdBSVRJTkdfU0lHTkFUVVJFU19ST1VURSA9ICcvc3dhcHMvYXdhaXRpbmctc2lnbmF0dXJlcyc7XHJcbmNvbnN0IFNNQVJUX1RSQU5TQUNUSU9OX1NUQVRVU19ST1VURSA9ICcvc3dhcHMvc21hcnQtdHJhbnNhY3Rpb24tc3RhdHVzJztcclxuY29uc3QgQVdBSVRJTkdfU1dBUF9ST1VURSA9ICcvc3dhcHMvYXdhaXRpbmctc3dhcCc7XHJcbmNvbnN0IFNXQVBTX0VSUk9SX1JPVVRFID0gJy9zd2Fwcy9zd2Fwcy1lcnJvcic7XHJcbmNvbnN0IFNXQVBTX01BSU5URU5BTkNFX1JPVVRFID0gJy9zd2Fwcy9tYWludGVuYW5jZSc7XHJcbmNvbnN0IEFERF9DT0xMRUNUSUJMRV9ST1VURSA9ICcvYWRkLWNvbGxlY3RpYmxlJztcclxuXHJcbmNvbnN0IElOSVRJQUxJWkVfUk9VVEUgPSAnL2luaXRpYWxpemUnO1xyXG5jb25zdCBJTklUSUFMSVpFX1dFTENPTUVfUk9VVEUgPSAnL2luaXRpYWxpemUvd2VsY29tZSc7XHJcbmNvbnN0IElOSVRJQUxJWkVfVU5MT0NLX1JPVVRFID0gJy9pbml0aWFsaXplL3VubG9jayc7XHJcbmNvbnN0IElOSVRJQUxJWkVfQ1JFQVRFX1BBU1NXT1JEX1JPVVRFID0gJy9pbml0aWFsaXplL2NyZWF0ZS1wYXNzd29yZCc7XHJcbmNvbnN0IElOSVRJQUxJWkVfSU1QT1JUX1dJVEhfU0VFRF9QSFJBU0VfUk9VVEUgPVxyXG4gICcvaW5pdGlhbGl6ZS9jcmVhdGUtcGFzc3dvcmQvaW1wb3J0LXdpdGgtc2VlZC1waHJhc2UnO1xyXG5jb25zdCBJTklUSUFMSVpFX1NFTEVDVF9BQ1RJT05fUk9VVEUgPSAnL2luaXRpYWxpemUvc2VsZWN0LWFjdGlvbic7XHJcbmNvbnN0IElOSVRJQUxJWkVfU0VFRF9QSFJBU0VfUk9VVEUgPSAnL2luaXRpYWxpemUvc2VlZC1waHJhc2UnO1xyXG5jb25zdCBJTklUSUFMSVpFX0JBQ0tVUF9TRUVEX1BIUkFTRV9ST1VURSA9ICcvaW5pdGlhbGl6ZS9iYWNrdXAtc2VlZC1waHJhc2UnO1xyXG5jb25zdCBJTklUSUFMSVpFX1NFRURfUEhSQVNFX0lOVFJPX1JPVVRFID0gJy9pbml0aWFsaXplL3NlZWQtcGhyYXNlLWludHJvJztcclxuY29uc3QgSU5JVElBTElaRV9FTkRfT0ZfRkxPV19ST1VURSA9ICcvaW5pdGlhbGl6ZS9lbmQtb2YtZmxvdyc7XHJcbmNvbnN0IElOSVRJQUxJWkVfQ09ORklSTV9TRUVEX1BIUkFTRV9ST1VURSA9ICcvaW5pdGlhbGl6ZS9zZWVkLXBocmFzZS9jb25maXJtJztcclxuY29uc3QgSU5JVElBTElaRV9NRVRBTUVUUklDU19PUFRfSU5fUk9VVEUgPSAnL2luaXRpYWxpemUvbWV0YW1ldHJpY3Mtb3B0LWluJztcclxuXHJcbmNvbnN0IE9OQk9BUkRJTkdfUk9VVEUgPSAnL29uYm9hcmRpbmcnO1xyXG5jb25zdCBPTkJPQVJESU5HX1JFVklFV19TUlBfUk9VVEUgPSAnL29uYm9hcmRpbmcvcmV2aWV3LXJlY292ZXJ5LXBocmFzZSc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfQ09ORklSTV9TUlBfUk9VVEUgPSAnL29uYm9hcmRpbmcvY29uZmlybS1yZWNvdmVyeS1waHJhc2UnO1xyXG5jb25zdCBPTkJPQVJESU5HX0NSRUFURV9QQVNTV09SRF9ST1VURSA9ICcvb25ib2FyZGluZy9jcmVhdGUtcGFzc3dvcmQnO1xyXG5jb25zdCBPTkJPQVJESU5HX0NPTVBMRVRJT05fUk9VVEUgPSAnL29uYm9hcmRpbmcvY29tcGxldGlvbic7XHJcbmNvbnN0IE9OQk9BUkRJTkdfVU5MT0NLX1JPVVRFID0gJy9vbmJvYXJkaW5nL3VubG9jayc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfSEVMUF9VU19JTVBST1ZFX1JPVVRFID0gJy9vbmJvYXJkaW5nL2hlbHAtdXMtaW1wcm92ZSc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfSU1QT1JUX1dJVEhfU1JQX1JPVVRFID1cclxuICAnL29uYm9hcmRpbmcvaW1wb3J0LXdpdGgtcmVjb3ZlcnktcGhyYXNlJztcclxuY29uc3QgT05CT0FSRElOR19JTVBPUlRfTU9CSUxFX1JPVVRFID0gJy9vbmJvYXJkaW5nL2ltcG9ydC1tb2JpbGUnO1xyXG5jb25zdCBPTkJPQVJESU5HX1NFQ1VSRV9ZT1VSX1dBTExFVF9ST1VURSA9ICcvb25ib2FyZGluZy9zZWN1cmUteW91ci13YWxsZXQnO1xyXG5jb25zdCBPTkJPQVJESU5HX1BSSVZBQ1lfU0VUVElOR1NfUk9VVEUgPSAnL29uYm9hcmRpbmcvcHJpdmFjeS1zZXR0aW5ncyc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfUElOX0VYVEVOU0lPTl9ST1VURSA9ICcvb25ib2FyZGluZy9waW4tZXh0ZW5zaW9uJztcclxuY29uc3QgT05CT0FSRElOR19XRUxDT01FX1JPVVRFID0gJy9vbmJvYXJkaW5nL3dlbGNvbWUnO1xyXG5jb25zdCBPTkJPQVJESU5HX01FVEFNRVRSSUNTID0gJy9vbmJvYXJkaW5nL21ldGFtZXRyaWNzJztcclxuXHJcblxuXHJcbmNvbnN0IENPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEUgPSAnL2NvbmZpcm0tdHJhbnNhY3Rpb24nO1xyXG5jb25zdCBDT05GSVJNX1NFTkRfRVRIRVJfUEFUSCA9ICcvc2VuZC1ldGhlcic7XHJcbmNvbnN0IENPTkZJUk1fU0VORF9UT0tFTl9QQVRIID0gJy9zZW5kLXRva2VuJztcclxuY29uc3QgQ09ORklSTV9ERVBMT1lfQ09OVFJBQ1RfUEFUSCA9ICcvZGVwbG95LWNvbnRyYWN0JztcclxuY29uc3QgQ09ORklSTV9BUFBST1ZFX1BBVEggPSAnL2FwcHJvdmUnO1xyXG5jb25zdCBDT05GSVJNX1NFVF9BUFBST1ZBTF9GT1JfQUxMX1BBVEggPSAnL3NldC1hcHByb3ZhbC1mb3ItYWxsJztcclxuY29uc3QgQ09ORklSTV9UUkFOU0ZFUl9GUk9NX1BBVEggPSAnL3RyYW5zZmVyLWZyb20nO1xyXG5jb25zdCBDT05GSVJNX1NBRkVfVFJBTlNGRVJfRlJPTV9QQVRIID0gJy9zYWZlLXRyYW5zZmVyLWZyb20nO1xyXG5jb25zdCBDT05GSVJNX1RPS0VOX01FVEhPRF9QQVRIID0gJy90b2tlbi1tZXRob2QnO1xyXG5jb25zdCBTSUdOQVRVUkVfUkVRVUVTVF9QQVRIID0gJy9zaWduYXR1cmUtcmVxdWVzdCc7XHJcbmNvbnN0IERFQ1JZUFRfTUVTU0FHRV9SRVFVRVNUX1BBVEggPSAnL2RlY3J5cHQtbWVzc2FnZS1yZXF1ZXN0JztcclxuY29uc3QgRU5DUllQVElPTl9QVUJMSUNfS0VZX1JFUVVFU1RfUEFUSCA9ICcvZW5jcnlwdGlvbi1wdWJsaWMta2V5LXJlcXVlc3QnO1xyXG5jb25zdCBDT05GSVJNQVRJT05fVl9ORVhUX1JPVVRFID0gJy9jb25maXJtYXRpb24nO1xyXG5cclxuLy8gVXNlZCB0byBwdWxsIGEgY29udmVuaWVudCBuYW1lIGZvciBhbmFseXRpY3MgdHJhY2tpbmcgZXZlbnRzLiBUaGUga2V5IG11c3RcclxuLy8gYmUgcmVhY3Qtcm91dGVyIHJlYWR5IHBhdGgsIGFuZCBjYW4gaW5jbHVkZSBwYXJhbXMgc3VjaCBhcyA6aWQgZm9yIHBvcHVwIHdpbmRvd3NcclxuY29uc3QgUEFUSF9OQU1FX01BUCA9IHtcclxuICBbREVGQVVMVF9ST1VURV06ICdIb21lJyxcclxuICBbVU5MT0NLX1JPVVRFXTogJ1VubG9jayBQYWdlJyxcclxuICBbTE9DS19ST1VURV06ICdMb2NrIFBhZ2UnLFxyXG4gIFtgJHtBU1NFVF9ST1VURX0vOmFzc2V0LzppZGBdOiBgQXNzZXQgUGFnZWAsXHJcbiAgW1NFVFRJTkdTX1JPVVRFXTogJ1NldHRpbmdzIFBhZ2UnLFxyXG4gIFtHRU5FUkFMX1JPVVRFXTogJ0dlbmVyYWwgU2V0dGluZ3MgUGFnZScsXHJcbiAgW0FEVkFOQ0VEX1JPVVRFXTogJ0FkdmFuY2VkIFNldHRpbmdzIFBhZ2UnLFxyXG4gIFtFWFBFUklNRU5UQUxfUk9VVEVdOiAnRXhwZXJpbWVudGFsIFNldHRpbmdzIFBhZ2UnLFxyXG4gIFtTRUNVUklUWV9ST1VURV06ICdTZWN1cml0eSBTZXR0aW5ncyBQYWdlJyxcclxuICBbQUJPVVRfVVNfUk9VVEVdOiAnQWJvdXQgVXMgUGFnZScsXHJcbiAgW0FMRVJUU19ST1VURV06ICdBbGVydHMgU2V0dGluZ3MgUGFnZScsXHJcbiAgW05FVFdPUktTX1JPVVRFXTogJ05ldHdvcmsgU2V0dGluZ3MgUGFnZScsXHJcbiAgW05FVFdPUktTX0ZPUk1fUk9VVEVdOiAnTmV0d29yayBTZXR0aW5ncyBQYWdlIEZvcm0nLFxyXG4gIFtBRERfTkVUV09SS19ST1VURV06ICdBZGQgTmV0d29yayBGcm9tIFNldHRpbmdzIFBhZ2UgRm9ybScsXHJcbiAgW0FERF9QT1BVTEFSX0NVU1RPTV9ORVRXT1JLXTpcclxuICAgICdBZGQgTmV0d29yayBGcm9tIEEgTGlzdCBPZiBQb3B1bGFyIEN1c3RvbSBOZXR3b3JrcycsXHJcbiAgW0NPTlRBQ1RfTElTVF9ST1VURV06ICdDb250YWN0IExpc3QgU2V0dGluZ3MgUGFnZScsXHJcbiAgW2Ake0NPTlRBQ1RfRURJVF9ST1VURX0vOmFkZHJlc3NgXTogJ0VkaXQgQ29udGFjdCBTZXR0aW5ncyBQYWdlJyxcclxuICBbQ09OVEFDVF9BRERfUk9VVEVdOiAnQWRkIENvbnRhY3QgU2V0dGluZ3MgUGFnZScsXHJcbiAgW2Ake0NPTlRBQ1RfVklFV19ST1VURX0vOmFkZHJlc3NgXTogJ1ZpZXcgQ29udGFjdCBTZXR0aW5ncyBQYWdlJyxcclxuICBbUkVWRUFMX1NFRURfUk9VVEVdOiAnUmV2ZWFsIFNlY3JldCBSZWNvdmVyeSBQaHJhc2UgUGFnZScsXHJcbiAgW01PQklMRV9TWU5DX1JPVVRFXTogJ1N5bmMgV2l0aCBNb2JpbGUgUGFnZScsXHJcbiAgW1JFU1RPUkVfVkFVTFRfUk9VVEVdOiAnUmVzdG9yZSBWYXVsdCBQYWdlJyxcclxuICBbSU1QT1JUX1RPS0VOX1JPVVRFXTogJ0ltcG9ydCBUb2tlbiBQYWdlJyxcclxuICBbQ09ORklSTV9JTVBPUlRfVE9LRU5fUk9VVEVdOiAnQ29uZmlybSBJbXBvcnQgVG9rZW4gUGFnZScsXHJcbiAgW0NPTkZJUk1fQUREX1NVR0dFU1RFRF9UT0tFTl9ST1VURV06ICdDb25maXJtIEFkZCBTdWdnZXN0ZWQgVG9rZW4gUGFnZScsXHJcbiAgW05FV19BQ0NPVU5UX1JPVVRFXTogJ05ldyBBY2NvdW50IFBhZ2UnLFxyXG4gIFtJTVBPUlRfQUNDT1VOVF9ST1VURV06ICdJbXBvcnQgQWNjb3VudCBQYWdlJyxcclxuICBbQ09OTkVDVF9IQVJEV0FSRV9ST1VURV06ICdDb25uZWN0IEhhcmR3YXJlIFdhbGxldCBQYWdlJyxcclxuICBbU0VORF9ST1VURV06ICdTZW5kIFBhZ2UnLFxyXG4gIFtgJHtUT0tFTl9ERVRBSUxTfS86YWRkcmVzc2BdOiAnVG9rZW4gRGV0YWlscyBQYWdlJyxcclxuICBbYCR7Q09OTkVDVF9ST1VURX0vOmlkYF06ICdDb25uZWN0IFRvIFNpdGUgQ29uZmlybWF0aW9uIFBhZ2UnLFxyXG4gIFtgJHtDT05ORUNUX1JPVVRFfS86aWQke0NPTk5FQ1RfQ09ORklSTV9QRVJNSVNTSU9OU19ST1VURX1gXTpcclxuICAgICdHcmFudCBDb25uZWN0ZWQgU2l0ZSBQZXJtaXNzaW9ucyBDb25maXJtYXRpb24gUGFnZScsXHJcbiAgW0NPTk5FQ1RFRF9ST1VURV06ICdTaXRlcyBDb25uZWN0ZWQgVG8gVGhpcyBBY2NvdW50IFBhZ2UnLFxyXG4gIFtDT05ORUNURURfQUNDT1VOVFNfUk9VVEVdOiAnQWNjb3VudHMgQ29ubmVjdGVkIFRvIFRoaXMgU2l0ZSBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkYF06ICdDb25maXJtYXRpb24gUm9vdCBQYWdlJyxcclxuICBbQ09ORklSTV9UUkFOU0FDVElPTl9ST1VURV06ICdDb25maXJtYXRpb24gUm9vdCBQYWdlJyxcclxuICAvLyBUT0RPOiByZW5hbWUgd2hlbiB0aGlzIGlzIHRoZSBvbmx5IGNvbmZpcm1hdGlvbiBwYWdlXHJcbiAgW0NPTkZJUk1BVElPTl9WX05FWFRfUk9VVEVdOiAnTmV3IENvbmZpcm1hdGlvbiBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtDT05GSVJNX1RPS0VOX01FVEhPRF9QQVRIfWBdOlxyXG4gICAgJ0NvbmZpcm0gVG9rZW4gTWV0aG9kIFRyYW5zYWN0aW9uIFBhZ2UnLFxyXG4gIFtgJHtDT05GSVJNX1RSQU5TQUNUSU9OX1JPVVRFfS86aWQke0NPTkZJUk1fU0VORF9FVEhFUl9QQVRIfWBdOlxyXG4gICAgJ0NvbmZpcm0gU2VuZCBFdGhlciBUcmFuc2FjdGlvbiBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtDT05GSVJNX1NFTkRfVE9LRU5fUEFUSH1gXTpcclxuICAgICdDb25maXJtIFNlbmQgVG9rZW4gVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7Q09ORklSTV9ERVBMT1lfQ09OVFJBQ1RfUEFUSH1gXTpcclxuICAgICdDb25maXJtIERlcGxveSBDb250cmFjdCBUcmFuc2FjdGlvbiBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtDT05GSVJNX0FQUFJPVkVfUEFUSH1gXTpcclxuICAgICdDb25maXJtIEFwcHJvdmUgVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7Q09ORklSTV9TRVRfQVBQUk9WQUxfRk9SX0FMTF9QQVRIfWBdOlxyXG4gICAgJ0NvbmZpcm0gU2V0IEFwcHJvdmFsIEZvciBBbGwgVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7Q09ORklSTV9UUkFOU0ZFUl9GUk9NX1BBVEh9YF06XHJcbiAgICAnQ29uZmlybSBUcmFuc2ZlciBGcm9tIFRyYW5zYWN0aW9uIFBhZ2UnLFxyXG4gIFtgJHtDT05GSVJNX1RSQU5TQUNUSU9OX1JPVVRFfS86aWQke0NPTkZJUk1fU0FGRV9UUkFOU0ZFUl9GUk9NX1BBVEh9YF06XHJcbiAgICAnQ29uZmlybSBTYWZlIFRyYW5zZmVyIEZyb20gVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7U0lHTkFUVVJFX1JFUVVFU1RfUEFUSH1gXTpcclxuICAgICdTaWduYXR1cmUgUmVxdWVzdCBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtERUNSWVBUX01FU1NBR0VfUkVRVUVTVF9QQVRIfWBdOlxyXG4gICAgJ0RlY3J5cHQgTWVzc2FnZSBSZXF1ZXN0IFBhZ2UnLFxyXG4gIFtgJHtDT05GSVJNX1RSQU5TQUNUSU9OX1JPVVRFfS86aWQke0VOQ1JZUFRJT05fUFVCTElDX0tFWV9SRVFVRVNUX1BBVEh9YF06XHJcbiAgICAnRW5jcnlwdGlvbiBQdWJsaWMgS2V5IFJlcXVlc3QgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfUk9VVEVdOiAnSW5pdGlhbGl6YXRpb24gUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfV0VMQ09NRV9ST1VURV06ICdJbnN0YWxsIFdlbGNvbWUgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfVU5MT0NLX1JPVVRFXTogJ0luaXRpYWxpemF0aW9uIFVubG9jayBwYWdlJyxcclxuICBbSU5JVElBTElaRV9DUkVBVEVfUEFTU1dPUkRfUk9VVEVdOiAnSW5pdGlhbGl6YXRpb24gQ3JlYXRlIFBhc3N3b3JkIFBhZ2UnLFxyXG4gIFtJTklUSUFMSVpFX0lNUE9SVF9XSVRIX1NFRURfUEhSQVNFX1JPVVRFXTpcclxuICAgICdJbml0aWFsaXphdGlvbiBJbXBvcnQgQWNjb3VudCBXaXRoIFNlY3JldCBSZWNvdmVyeSBQaHJhc2UgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfU0VMRUNUX0FDVElPTl9ST1VURV06XHJcbiAgICAnSW5pdGlhbGl6YXRpb24gQ2hvb3NlIFJlc3RvcmUgb3IgTmV3IEFjY291bnQgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfU0VFRF9QSFJBU0VfUk9VVEVdOiAnSW5pdGlhbGl6YXRpb24gU2VjcmV0IFJlY292ZXJ5IFBocmFzZSBQYWdlJyxcclxuICBbSU5JVElBTElaRV9CQUNLVVBfU0VFRF9QSFJBU0VfUk9VVEVdOlxyXG4gICAgJ0luaXRpYWxpemF0aW9uIEJhY2t1cCBTZWNyZXQgUmVjb3ZlcnkgUGhyYXNlIFBhZ2UnLFxyXG4gIFtJTklUSUFMSVpFX1NFRURfUEhSQVNFX0lOVFJPX1JPVVRFXTpcclxuICAgICdJbml0aWFsaXphdGlvbiBTZWNyZXQgUmVjb3ZlcnkgUGhyYXNlIEludHJvIFBhZ2UnLFxyXG4gIFtJTklUSUFMSVpFX0VORF9PRl9GTE9XX1JPVVRFXTogJ0VuZCBvZiBJbml0aWFsaXphdGlvbiBQYWdlJyxcclxuICBbSU5JVElBTElaRV9DT05GSVJNX1NFRURfUEhSQVNFX1JPVVRFXTpcclxuICAgICdJbml0aWFsaXphdGlvbiBDb25maXJtIFNlY3JldCBSZWNvdmVyeSBQaHJhc2UgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfTUVUQU1FVFJJQ1NfT1BUX0lOX1JPVVRFXTogJ01ldGFNZXRyaWNzIE9wdCBJbiBQYWdlJyxcclxuICBbQlVJTERfUVVPVEVfUk9VVEVdOiAnU3dhcHMgQnVpbGQgUXVvdGUgUGFnZScsXHJcbiAgW1ZJRVdfUVVPVEVfUk9VVEVdOiAnU3dhcHMgVmlldyBRdW90ZXMgUGFnZScsXHJcbiAgW0xPQURJTkdfUVVPVEVTX1JPVVRFXTogJ1N3YXBzIExvYWRpbmcgUXVvdGVzIFBhZ2UnLFxyXG4gIFtBV0FJVElOR19TV0FQX1JPVVRFXTogJ1N3YXBzIEF3YWl0aW5nIFN3YXBzIFBhZ2UnLFxyXG4gIFtTV0FQU19FUlJPUl9ST1VURV06ICdTd2FwcyBFcnJvciBQYWdlJyxcclxufTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgREVGQVVMVF9ST1VURSxcclxuICBBTEVSVFNfUk9VVEUsXHJcbiAgQVNTRVRfUk9VVEUsXHJcbiAgVU5MT0NLX1JPVVRFLFxyXG4gIExPQ0tfUk9VVEUsXHJcbiAgU0VUVElOR1NfUk9VVEUsXHJcbiAgUkVWRUFMX1NFRURfUk9VVEUsXHJcbiAgTU9CSUxFX1NZTkNfUk9VVEUsXHJcbiAgUkVTVE9SRV9WQVVMVF9ST1VURSxcclxuICBJTVBPUlRfVE9LRU5fUk9VVEUsXHJcbiAgQ09ORklSTV9JTVBPUlRfVE9LRU5fUk9VVEUsXHJcbiAgQ09ORklSTV9BRERfU1VHR0VTVEVEX1RPS0VOX1JPVVRFLFxyXG4gIE5FV19BQ0NPVU5UX1JPVVRFLFxyXG4gIElNUE9SVF9BQ0NPVU5UX1JPVVRFLFxyXG4gIENPTk5FQ1RfSEFSRFdBUkVfUk9VVEUsXHJcbiAgU0VORF9ST1VURSxcclxuICBUT0tFTl9ERVRBSUxTLFxyXG4gIElOSVRJQUxJWkVfUk9VVEUsXHJcbiAgSU5JVElBTElaRV9XRUxDT01FX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfVU5MT0NLX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfQ1JFQVRFX1BBU1NXT1JEX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfSU1QT1JUX1dJVEhfU0VFRF9QSFJBU0VfUk9VVEUsXHJcbiAgSU5JVElBTElaRV9TRUxFQ1RfQUNUSU9OX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfU0VFRF9QSFJBU0VfUk9VVEUsXHJcbiAgSU5JVElBTElaRV9DT05GSVJNX1NFRURfUEhSQVNFX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfRU5EX09GX0ZMT1dfUk9VVEUsXHJcbiAgQ09ORklSTV9UUkFOU0FDVElPTl9ST1VURSxcclxuICBDT05GSVJNX1NFTkRfRVRIRVJfUEFUSCxcclxuICBDT05GSVJNX1NFTkRfVE9LRU5fUEFUSCxcclxuICBDT05GSVJNX0RFUExPWV9DT05UUkFDVF9QQVRILFxyXG4gIENPTkZJUk1fQVBQUk9WRV9QQVRILFxyXG4gIENPTkZJUk1fU0VUX0FQUFJPVkFMX0ZPUl9BTExfUEFUSCxcclxuICBDT05GSVJNX1RSQU5TRkVSX0ZST01fUEFUSCxcclxuICBDT05GSVJNX1NBRkVfVFJBTlNGRVJfRlJPTV9QQVRILFxyXG4gIENPTkZJUk1fVE9LRU5fTUVUSE9EX1BBVEgsXHJcbiAgU0lHTkFUVVJFX1JFUVVFU1RfUEFUSCxcclxuICBERUNSWVBUX01FU1NBR0VfUkVRVUVTVF9QQVRILFxyXG4gIEVOQ1JZUFRJT05fUFVCTElDX0tFWV9SRVFVRVNUX1BBVEgsXHJcbiAgQ09ORklSTUFUSU9OX1ZfTkVYVF9ST1VURSxcclxuICBJTklUSUFMSVpFX01FVEFNRVRSSUNTX09QVF9JTl9ST1VURSxcclxuICBBRFZBTkNFRF9ST1VURSxcclxuICBFWFBFUklNRU5UQUxfUk9VVEUsXHJcbiAgU0VDVVJJVFlfUk9VVEUsXHJcbiAgR0VORVJBTF9ST1VURSxcclxuICBBQk9VVF9VU19ST1VURSxcclxuICBTTkFQU19MSVNUX1JPVVRFLFxyXG4gIFNOQVBTX1ZJRVdfUk9VVEUsXHJcbiAgQ09OVEFDVF9MSVNUX1JPVVRFLFxyXG4gIENPTlRBQ1RfRURJVF9ST1VURSxcclxuICBDT05UQUNUX0FERF9ST1VURSxcclxuICBDT05UQUNUX1ZJRVdfUk9VVEUsXHJcbiAgTkVUV09SS1NfUk9VVEUsXHJcbiAgTkVUV09SS1NfRk9STV9ST1VURSxcclxuICBBRERfTkVUV09SS19ST1VURSxcclxuICBBRERfUE9QVUxBUl9DVVNUT01fTkVUV09SSyxcclxuICBJTklUSUFMSVpFX0JBQ0tVUF9TRUVEX1BIUkFTRV9ST1VURSxcclxuICBJTklUSUFMSVpFX1NFRURfUEhSQVNFX0lOVFJPX1JPVVRFLFxyXG4gIENPTk5FQ1RfUk9VVEUsXHJcbiAgQ09OTkVDVF9DT05GSVJNX1BFUk1JU1NJT05TX1JPVVRFLFxyXG5cbiAgQ09OTkVDVEVEX1JPVVRFLFxyXG4gIENPTk5FQ1RFRF9BQ0NPVU5UU19ST1VURSxcclxuICBQQVRIX05BTUVfTUFQLFxyXG4gIFNXQVBTX1JPVVRFLFxyXG4gIEJVSUxEX1FVT1RFX1JPVVRFLFxyXG4gIFZJRVdfUVVPVEVfUk9VVEUsXHJcbiAgTE9BRElOR19RVU9URVNfUk9VVEUsXHJcbiAgQVdBSVRJTkdfU1dBUF9ST1VURSxcclxuICBBV0FJVElOR19TSUdOQVRVUkVTX1JPVVRFLFxyXG4gIFNXQVBTX0VSUk9SX1JPVVRFLFxyXG4gIFNXQVBTX01BSU5URU5BTkNFX1JPVVRFLFxyXG4gIFNNQVJUX1RSQU5TQUNUSU9OX1NUQVRVU19ST1VURSxcclxuICBBRERfQ09MTEVDVElCTEVfUk9VVEUsXHJcbiAgT05CT0FSRElOR19ST1VURSxcclxuICBPTkJPQVJESU5HX0hFTFBfVVNfSU1QUk9WRV9ST1VURSxcclxuICBPTkJPQVJESU5HX0NSRUFURV9QQVNTV09SRF9ST1VURSxcclxuICBPTkJPQVJESU5HX0lNUE9SVF9XSVRIX1NSUF9ST1VURSxcclxuICBPTkJPQVJESU5HX0lNUE9SVF9NT0JJTEVfUk9VVEUsXHJcbiAgT05CT0FSRElOR19TRUNVUkVfWU9VUl9XQUxMRVRfUk9VVEUsXHJcbiAgT05CT0FSRElOR19SRVZJRVdfU1JQX1JPVVRFLFxyXG4gIE9OQk9BUkRJTkdfQ09ORklSTV9TUlBfUk9VVEUsXHJcbiAgT05CT0FSRElOR19QUklWQUNZX1NFVFRJTkdTX1JPVVRFLFxyXG4gIE9OQk9BUkRJTkdfQ09NUExFVElPTl9ST1VURSxcclxuICBPTkJPQVJESU5HX1VOTE9DS19ST1VURSxcclxuICBPTkJPQVJESU5HX1BJTl9FWFRFTlNJT05fUk9VVEUsXHJcbiAgT05CT0FSRElOR19XRUxDT01FX1JPVVRFLFxyXG4gIE9OQk9BUkRJTkdfTUVUQU1FVFJJQ1MsXHJcblxufTtcclxuIiwiaW1wb3J0IHtcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuZXhwb3J0IGNvbnN0IFBFTkRJTkdfU1RBVFVTX0hBU0ggPSB7XG4gIFtUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVEXTogdHJ1ZSxcbiAgW1RSQU5TQUNUSU9OX1NUQVRVU0VTLkFQUFJPVkVEXTogdHJ1ZSxcbiAgW1RSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRF06IHRydWUsXG4gIFtUUkFOU0FDVElPTl9TVEFUVVNFUy5QRU5ESU5HXTogdHJ1ZSxcbn07XG5cbmV4cG9ydCBjb25zdCBQUklPUklUWV9TVEFUVVNfSEFTSCA9IHtcbiAgLi4uUEVORElOR19TVEFUVVNfSEFTSCxcbiAgW1RSQU5TQUNUSU9OX1NUQVRVU0VTLkNPTkZJUk1FRF06IHRydWUsXG59O1xuXG5leHBvcnQgY29uc3QgVE9LRU5fQ0FURUdPUllfSEFTSCA9IHtcbiAgW1RSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFXTogdHJ1ZSxcbiAgW1RSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTF06IHRydWUsXG4gIFtUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJdOiB0cnVlLFxuICBbVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST01dOiB0cnVlLFxufTtcbiIsImNvbnN0IFpFTkRFU0tfVVJMUyA9IHtcclxuICBBRERfQ1VTVE9NX1RPS0VOUzpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAxNTQ4OTAzMScsXHJcbiAgQUREX01JU1NJTkdfQUNDT1VOVFM6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMTU0ODkyNzEnLFxyXG4gIEJBU0lDX1NBRkVUWTpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAxNTQ4OTU5MS1CYXNpYy1TYWZldHktVGlwcycsXHJcbiAgQ1VTVE9NSVpFX05PTkNFOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvNzQxNzQ5OTMzMzUzMS1Ib3ctdG8tY3VzdG9taXplLWEtdHJhbnNhY3Rpb24tbm9uY2UnLFxyXG4gIEhBUkRXQVJFX0NPTk5FQ1RJT046XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMjAzOTQ2MTItSG93LXRvLWNvbm5lY3QtYS1UcmV6b3Itb3ItTGVkZ2VyLUhhcmR3YXJlLVdhbGxldCcsXHJcbiAgSU1QT1JUX0FDQ09VTlRTOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDE1NDg5MzMxJyxcclxuICBJTVBPUlRFRF9BQ0NPVU5UUzpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAxNTI4OTkzMicsXHJcbiAgSU5GVVJBX0JMT0NLQUdFOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDU5Mzg2NzEyJyxcclxuICBMRUdBQ1lfV0VCMzogJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDUzMTQ3MDEyJyxcclxuICBORlRfVE9LRU5TOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDU4MjM4NTkxLU5GVC10b2tlbnMtaW4tTWV0YU1hc2std2FsbGV0JyxcclxuICBQQVNTV09SRF9BUlRJQ0xFOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvNDQwNDcyMjc4MjEwNycsXHJcbiAgU0VDUkVUX1JFQ09WRVJZX1BIUkFTRTpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDA2MDgyNjQzMi1XaGF0LWlzLWEtU2VjcmV0LVJlY292ZXJ5LVBocmFzZS1hbmQtaG93LXRvLWtlZXAteW91ci1jcnlwdG8td2FsbGV0LXNlY3VyZScsXHJcbiAgU1BFRURVUF9DQU5DRUw6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMTU0ODkyNTEtSG93LXRvLXNwZWVkLXVwLW9yLWNhbmNlbC1hLXBlbmRpbmctdHJhbnNhY3Rpb24nLFxyXG4gIFRPS0VOX1NBRkVUWV9QUkFDVElDRVM6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDAzOTg4ODM5NDUxJyxcclxuICBVTktOT1dOX05FVFdPUks6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDE3NTAwNDY2OTcxJyxcclxuICBVU0VSX0dVSURFX0NVU1RPTV9ORVRXT1JLUzpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzQ0MDQ0MjQ2NTk5OTUnLFxyXG4gIFVTRVJfR1VJREVfREFQUFM6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDA1NTA2MDY2MzMxLVVzZXItZ3VpZGUtRGFwcHMnLFxyXG4gIFVTRVJfR1VJREVfR0FTOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvNDQwNDYwMDE3OTIyNy1Vc2VyLUd1aWRlLUdhcycsXHJcbiAgVkVSSUZZX0NVU1RPTV9ORVRXT1JLOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDU3MTQyMzkyJyxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFpFTkRFU0tfVVJMUztcclxuIiwiaW1wb3J0IGN1cnJlbmN5Rm9ybWF0dGVyIGZyb20gJ2N1cnJlbmN5LWZvcm1hdHRlcic7XHJcbmltcG9ydCBjdXJyZW5jaWVzIGZyb20gJ2N1cnJlbmN5LWZvcm1hdHRlci9jdXJyZW5jaWVzJztcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xyXG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XHJcblxyXG5pbXBvcnQgeyB1bmNvbmZpcm1lZFRyYW5zYWN0aW9uc0NvdW50U2VsZWN0b3IgfSBmcm9tICcuLi8uLi9zZWxlY3RvcnMnO1xyXG5pbXBvcnQge1xyXG4gIGNvbnZlcnNpb25VdGlsLFxyXG4gIGFkZEN1cnJlbmNpZXMsXHJcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxyXG4gIGNvbnZlcnNpb25HcmVhdGVyVGhhbixcclxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmNyZWFzZUxhc3RHYXNQcmljZShsYXN0R2FzUHJpY2UpIHtcclxuICByZXR1cm4gYWRkSGV4UHJlZml4KFxyXG4gICAgbXVsdGlwbHlDdXJyZW5jaWVzKGxhc3RHYXNQcmljZSB8fCAnMHgwJywgMS4xLCB7XHJcbiAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxyXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXHJcbiAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgfSksXHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhleEdyZWF0ZXJUaGFuKGEsIGIpIHtcclxuICByZXR1cm4gY29udmVyc2lvbkdyZWF0ZXJUaGFuKFxyXG4gICAgeyB2YWx1ZTogYSwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxyXG4gICAgeyB2YWx1ZTogYiwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRIZXhHYXNUb3RhbCh7IGdhc0xpbWl0LCBnYXNQcmljZSB9KSB7XHJcbiAgcmV0dXJuIGFkZEhleFByZWZpeChcclxuICAgIG11bHRpcGx5Q3VycmVuY2llcyhnYXNMaW1pdCB8fCAnMHgwJywgZ2FzUHJpY2UgfHwgJzB4MCcsIHtcclxuICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXHJcbiAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxyXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTYsXHJcbiAgICB9KSxcclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkRXRoKC4uLmFyZ3MpIHtcclxuICByZXR1cm4gYXJncy5yZWR1Y2UoKGFjYywgZXRoQW1vdW50KSA9PiB7XHJcbiAgICByZXR1cm4gYWRkQ3VycmVuY2llcyhhY2MsIGV0aEFtb3VudCwge1xyXG4gICAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcclxuICAgICAgbnVtYmVyT2ZEZWNpbWFsczogNixcclxuICAgICAgYUJhc2U6IDEwLFxyXG4gICAgICBiQmFzZTogMTAsXHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZEZpYXQoLi4uYXJncykge1xyXG4gIHJldHVybiBhcmdzLnJlZHVjZSgoYWNjLCBmaWF0QW1vdW50KSA9PiB7XHJcbiAgICByZXR1cm4gYWRkQ3VycmVuY2llcyhhY2MsIGZpYXRBbW91bnQsIHtcclxuICAgICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXHJcbiAgICAgIG51bWJlck9mRGVjaW1hbHM6IDIsXHJcbiAgICAgIGFCYXNlOiAxMCxcclxuICAgICAgYkJhc2U6IDEwLFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21XZWlIZXgoe1xyXG4gIHZhbHVlLFxyXG4gIGZyb21DdXJyZW5jeSA9ICdFVEgnLFxyXG4gIHRvQ3VycmVuY3ksXHJcbiAgY29udmVyc2lvblJhdGUsXHJcbiAgbnVtYmVyT2ZEZWNpbWFscyxcclxuICB0b0Rlbm9taW5hdGlvbixcclxufSkge1xyXG4gIHJldHVybiBjb252ZXJzaW9uVXRpbCh2YWx1ZSwge1xyXG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcclxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxyXG4gICAgZnJvbUN1cnJlbmN5LFxyXG4gICAgdG9DdXJyZW5jeSxcclxuICAgIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcclxuICAgIHRvRGVub21pbmF0aW9uLFxyXG4gICAgY29udmVyc2lvblJhdGUsXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkZlZSh7XHJcbiAgdmFsdWUsXHJcbiAgZnJvbUN1cnJlbmN5ID0gJ0VUSCcsXHJcbiAgdG9DdXJyZW5jeSxcclxuICBjb252ZXJzaW9uUmF0ZSxcclxuICBudW1iZXJPZkRlY2ltYWxzLFxyXG59KSB7XHJcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKHZhbHVlLCB7XHJcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdCTicsXHJcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcclxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxyXG4gICAgZnJvbUN1cnJlbmN5LFxyXG4gICAgdG9DdXJyZW5jeSxcclxuICAgIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgICBjb252ZXJzaW9uUmF0ZSxcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5KHZhbHVlLCBjdXJyZW5jeUNvZGUpIHtcclxuICBjb25zdCB1cHBlckNhc2VDdXJyZW5jeUNvZGUgPSBjdXJyZW5jeUNvZGUudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgcmV0dXJuIGN1cnJlbmNpZXMuZmluZCgoY3VycmVuY3kpID0+IGN1cnJlbmN5LmNvZGUgPT09IHVwcGVyQ2FzZUN1cnJlbmN5Q29kZSlcclxuICAgID8gY3VycmVuY3lGb3JtYXR0ZXIuZm9ybWF0KE51bWJlcih2YWx1ZSksIHtcclxuICAgICAgICBjb2RlOiB1cHBlckNhc2VDdXJyZW5jeUNvZGUsXHJcbiAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXHJcbiAgICAgIH0pXHJcbiAgICA6IHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRva2VuVG9GaWF0KHtcclxuICB2YWx1ZSxcclxuICBmcm9tQ3VycmVuY3kgPSAnRVRIJyxcclxuICB0b0N1cnJlbmN5LFxyXG4gIGNvbnZlcnNpb25SYXRlLFxyXG4gIGNvbnRyYWN0RXhjaGFuZ2VSYXRlLFxyXG59KSB7XHJcbiAgY29uc3QgdG90YWxFeGNoYW5nZVJhdGUgPSBjb252ZXJzaW9uUmF0ZSAqIGNvbnRyYWN0RXhjaGFuZ2VSYXRlO1xyXG5cclxuICByZXR1cm4gY29udmVyc2lvblV0aWwodmFsdWUsIHtcclxuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXHJcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcclxuICAgIGZyb21DdXJyZW5jeSxcclxuICAgIHRvQ3VycmVuY3ksXHJcbiAgICBudW1iZXJPZkRlY2ltYWxzOiAyLFxyXG4gICAgY29udmVyc2lvblJhdGU6IHRvdGFsRXhjaGFuZ2VSYXRlLFxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGFzVW5jb25maXJtZWRUcmFuc2FjdGlvbnMoc3RhdGUpIHtcclxuICByZXR1cm4gdW5jb25maXJtZWRUcmFuc2FjdGlvbnNDb3VudFNlbGVjdG9yKHN0YXRlKSA+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSb3VuZHMgdGhlIGdpdmVuIGRlY2ltYWwgc3RyaW5nIHRvIDQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVjaW1hbFN0cmluZyAtIFRoZSBiYXNlLXRlbiBudW1iZXIgdG8gcm91bmQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByb3VuZGVkIG51bWJlciwgb3IgdGhlIG9yaWdpbmFsIG51bWJlciBpZiBub1xyXG4gKiByb3VuZGluZyB3YXMgbmVjZXNzYXJ5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kRXhwb25lbnRpYWwoZGVjaW1hbFN0cmluZykge1xyXG4gIGNvbnN0IFBSRUNJU0lPTiA9IDQ7XHJcbiAgY29uc3QgYmlnTnVtYmVyVmFsdWUgPSBuZXcgQmlnTnVtYmVyKGRlY2ltYWxTdHJpbmcpO1xyXG5cclxuICAvLyBJbiBKUywgbnVtYmVycyB3aXRoIGV4cG9uZW50aWFscyBncmVhdGVyIHRoYW4gMjAgZ2V0IGRpc3BsYXllZCBhcyBhbiBleHBvbmVudGlhbC5cclxuICByZXR1cm4gYmlnTnVtYmVyVmFsdWUuZSA+IDIwXHJcbiAgICA/IGJpZ051bWJlclZhbHVlLnRvUHJlY2lzaW9uKFBSRUNJU0lPTilcclxuICAgIDogZGVjaW1hbFN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZURhcHBTdWdnZXN0ZWRBbmRUeFBhcmFtR2FzRmVlc1RoZVNhbWUodHhEYXRhID0ge30pIHtcclxuICBjb25zdCB7IHR4UGFyYW1zLCBkYXBwU3VnZ2VzdGVkR2FzRmVlcyB9ID0gdHhEYXRhO1xyXG4gIGNvbnN0IHtcclxuICAgIGdhc1ByaWNlOiB0eFBhcmFtc0dhc1ByaWNlLFxyXG4gICAgbWF4RmVlUGVyR2FzOiB0eFBhcmFtc01heEZlZVBlckdhcyxcclxuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0eFBhcmFtc01heFByaW9yaXR5RmVlUGVyR2FzLFxyXG4gIH0gPSB0eFBhcmFtcyB8fCB7fTtcclxuICBjb25zdCB7XHJcbiAgICBnYXNQcmljZTogZGFwcEdhc1ByaWNlLFxyXG4gICAgbWF4RmVlUGVyR2FzOiBkYXBwTWF4RmVlUGVyR2FzLFxyXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGRhcHBNYXhQcmlvcml0eUZlZVBlckdhcyxcclxuICB9ID0gZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgfHwge307XHJcblxyXG4gIGNvbnN0IHR4UGFyYW1zRG9lc05vdEhhdmVGZWVQcm9wZXJ0aWVzID1cclxuICAgICF0eFBhcmFtc0dhc1ByaWNlICYmICF0eFBhcmFtc01heEZlZVBlckdhcyAmJiAhdHhQYXJhbXNNYXhQcmlvcml0eUZlZVBlckdhcztcclxuICBjb25zdCBkYXBwRGlkTm90U3VnZ2VzdEZlZVByb3BlcnRpZXMgPVxyXG4gICAgIWRhcHBHYXNQcmljZSAmJiAhZGFwcE1heEZlZVBlckdhcyAmJiAhZGFwcE1heFByaW9yaXR5RmVlUGVyR2FzO1xyXG4gIGlmICh0eFBhcmFtc0RvZXNOb3RIYXZlRmVlUHJvcGVydGllcyB8fCBkYXBwRGlkTm90U3VnZ2VzdEZlZVByb3BlcnRpZXMpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHR4UGFyYW1zR2FzUHJpY2VNYXRjaGVzRGFwcFN1Z2dlc3RlZEdhc1ByaWNlID1cclxuICAgIHR4UGFyYW1zR2FzUHJpY2UgJiYgdHhQYXJhbXNHYXNQcmljZSA9PT0gZGFwcEdhc1ByaWNlO1xyXG4gIGNvbnN0IHR4UGFyYW1zRUlQMTU1OUZlZXNNYXRjaERhcHBTdWdnZXN0ZWRHYXNQcmljZSA9IFtcclxuICAgIHR4UGFyYW1zTWF4RmVlUGVyR2FzLFxyXG4gICAgdHhQYXJhbXNNYXhQcmlvcml0eUZlZVBlckdhcyxcclxuICBdLmV2ZXJ5KChmZWUpID0+IGZlZSA9PT0gZGFwcEdhc1ByaWNlKTtcclxuICBjb25zdCB0eFBhcmFtc0VJUDE1NTlGZWVzTWF0Y2hEYXBwU3VnZ2VzdGVkRUlQMTU1OUZlZXMgPVxyXG4gICAgdHhQYXJhbXNNYXhGZWVQZXJHYXMgJiZcclxuICAgIHR4UGFyYW1zTWF4RmVlUGVyR2FzID09PSBkYXBwTWF4RmVlUGVyR2FzICYmXHJcbiAgICB0eFBhcmFtc01heFByaW9yaXR5RmVlUGVyR2FzID09PSBkYXBwTWF4UHJpb3JpdHlGZWVQZXJHYXM7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICB0eFBhcmFtc0dhc1ByaWNlTWF0Y2hlc0RhcHBTdWdnZXN0ZWRHYXNQcmljZSB8fFxyXG4gICAgdHhQYXJhbXNFSVAxNTU5RmVlc01hdGNoRGFwcFN1Z2dlc3RlZEdhc1ByaWNlIHx8XHJcbiAgICB0eFBhcmFtc0VJUDE1NTlGZWVzTWF0Y2hEYXBwU3VnZ2VzdGVkRUlQMTU1OUZlZXNcclxuICApO1xyXG59XHJcbiIsImltcG9ydCB7IEVUSCwgR1dFSSwgV0VJIH0gZnJvbSAnLi4vY29uc3RhbnRzL2NvbW1vbic7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XG5pbXBvcnQge1xuICBjb252ZXJzaW9uVXRpbCxcbiAgYWRkQ3VycmVuY2llcyxcbiAgc3VidHJhY3RDdXJyZW5jaWVzLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcbmltcG9ydCB7IGZvcm1hdEN1cnJlbmN5IH0gZnJvbSAnLi9jb25maXJtLXR4LnV0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gYm5Ub0hleChpbnB1dEJuKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoaW5wdXRCbi50b1N0cmluZygxNikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXRoQ29udmVyc2lvbkZyb21XZWlIZXgoe1xuICB2YWx1ZSxcbiAgZnJvbUN1cnJlbmN5ID0gRVRILFxuICBjb252ZXJzaW9uUmF0ZSxcbiAgbnVtYmVyT2ZEZWNpbWFscyA9IDYsXG59KSB7XG4gIGNvbnN0IGRlbm9taW5hdGlvbnMgPSBbZnJvbUN1cnJlbmN5LCBHV0VJLCBXRUldO1xuXG4gIGxldCBub25aZXJvRGVub21pbmF0aW9uO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVub21pbmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gZ2V0VmFsdWVGcm9tV2VpSGV4KHtcbiAgICAgIHZhbHVlLFxuICAgICAgY29udmVyc2lvblJhdGUsXG4gICAgICBmcm9tQ3VycmVuY3ksXG4gICAgICB0b0N1cnJlbmN5OiBmcm9tQ3VycmVuY3ksXG4gICAgICBudW1iZXJPZkRlY2ltYWxzLFxuICAgICAgdG9EZW5vbWluYXRpb246IGRlbm9taW5hdGlvbnNbaV0sXG4gICAgfSk7XG5cbiAgICBpZiAoY29udmVydGVkVmFsdWUgIT09ICcwJyB8fCBpID09PSBkZW5vbWluYXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgIG5vblplcm9EZW5vbWluYXRpb24gPSBgJHtjb252ZXJ0ZWRWYWx1ZX0gJHtkZW5vbWluYXRpb25zW2ldfWA7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9uWmVyb0Rlbm9taW5hdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlRnJvbVdlaUhleCh7XG4gIHZhbHVlLFxuICBmcm9tQ3VycmVuY3kgPSBFVEgsXG4gIHRvQ3VycmVuY3ksXG4gIGNvbnZlcnNpb25SYXRlLFxuICBudW1iZXJPZkRlY2ltYWxzLFxuICB0b0Rlbm9taW5hdGlvbixcbn0pIHtcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKHZhbHVlLCB7XG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcbiAgICBmcm9tQ3VycmVuY3ksXG4gICAgdG9DdXJyZW5jeSxcbiAgICBudW1iZXJPZkRlY2ltYWxzLFxuICAgIGZyb21EZW5vbWluYXRpb246IFdFSSxcbiAgICB0b0Rlbm9taW5hdGlvbixcbiAgICBjb252ZXJzaW9uUmF0ZSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWlIZXhGcm9tRGVjaW1hbFZhbHVlKHtcbiAgdmFsdWUsXG4gIGZyb21DdXJyZW5jeSxcbiAgY29udmVyc2lvblJhdGUsXG4gIGZyb21EZW5vbWluYXRpb24sXG4gIGludmVydENvbnZlcnNpb25SYXRlLFxufSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwodmFsdWUsIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIHRvQ3VycmVuY3k6IEVUSCxcbiAgICBmcm9tQ3VycmVuY3ksXG4gICAgY29udmVyc2lvblJhdGUsXG4gICAgaW52ZXJ0Q29udmVyc2lvblJhdGUsXG4gICAgZnJvbURlbm9taW5hdGlvbixcbiAgICB0b0Rlbm9taW5hdGlvbjogV0VJLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhleFdFSXNUb0RlYyhhSGV4V0VJLCBiSGV4V0VJKSB7XG4gIHJldHVybiBhZGRDdXJyZW5jaWVzKGFIZXhXRUksIGJIZXhXRUksIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3RIZXhXRUlzVG9EZWMoYUhleFdFSSwgYkhleFdFSSkge1xuICByZXR1cm4gc3VidHJhY3RDdXJyZW5jaWVzKGFIZXhXRUksIGJIZXhXRUksIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjRXRoVG9Db252ZXJ0ZWRDdXJyZW5jeShcbiAgZXRoVG90YWwsXG4gIGNvbnZlcnRlZEN1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbikge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoZXRoVG90YWwsIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIGZyb21DdXJyZW5jeTogJ0VUSCcsXG4gICAgdG9DdXJyZW5jeTogY29udmVydGVkQ3VycmVuY3ksXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogMixcbiAgICBjb252ZXJzaW9uUmF0ZSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNHV0VJVG9IZXhXRUkoZGVjR1dFSSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoZGVjR1dFSSwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ0dXRUknLFxuICAgIHRvRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNFVEhUb0RlY1dFSShkZWNFdGgpIHtcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKGRlY0V0aCwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ0VUSCcsXG4gICAgdG9EZW5vbWluYXRpb246ICdXRUknLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleFdFSVRvRGVjRVRIKGhleFdFSSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoaGV4V0VJLCB7XG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcbiAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgICB0b0Rlbm9taW5hdGlvbjogJ0VUSCcsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjV0VJVG9EZWNFVEgoaGV4V0VJKSB7XG4gIHJldHVybiBjb252ZXJzaW9uVXRpbChoZXhXRUksIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgIHRvRGVub21pbmF0aW9uOiAnRVRIJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRIZXhlcyhhSGV4V0VJLCBiSGV4V0VJKSB7XG4gIHJldHVybiBhZGRDdXJyZW5jaWVzKGFIZXhXRUksIGJIZXhXRUksIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3RIZXhlcyhhSGV4V0VJLCBiSGV4V0VJKSB7XG4gIHJldHVybiBzdWJ0cmFjdEN1cnJlbmNpZXMoYUhleFdFSSwgYkhleFdFSSwge1xuICAgIGFCYXNlOiAxNixcbiAgICBiQmFzZTogMTYsXG4gICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogNixcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1IZXhXRUlzKGhleFdFSXMpIHtcbiAgcmV0dXJuIGhleFdFSXMuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShhZGRIZXhlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1IZXhXRUlzVG9VbmZvcm1hdHRlZEZpYXQoXG4gIGhleFdFSXMsXG4gIGNvbnZlcnRlZEN1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbikge1xuICBjb25zdCBoZXhXRUlzU3VtID0gc3VtSGV4V0VJcyhoZXhXRUlzKTtcbiAgY29uc3QgY29udmVydGVkVG90YWwgPSBkZWNFdGhUb0NvbnZlcnRlZEN1cnJlbmN5KFxuICAgIGdldFZhbHVlRnJvbVdlaUhleCh7XG4gICAgICB2YWx1ZTogaGV4V0VJc1N1bSxcbiAgICAgIHRvQ3VycmVuY3k6ICdFVEgnLFxuICAgICAgbnVtYmVyT2ZEZWNpbWFsczogNCxcbiAgICB9KSxcbiAgICBjb252ZXJ0ZWRDdXJyZW5jeSxcbiAgICBjb252ZXJzaW9uUmF0ZSxcbiAgKTtcbiAgcmV0dXJuIGNvbnZlcnRlZFRvdGFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VtSGV4V0VJc1RvUmVuZGVyYWJsZUZpYXQoXG4gIGhleFdFSXMsXG4gIGNvbnZlcnRlZEN1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbikge1xuICBjb25zdCBjb252ZXJ0ZWRUb3RhbCA9IHN1bUhleFdFSXNUb1VuZm9ybWF0dGVkRmlhdChcbiAgICBoZXhXRUlzLFxuICAgIGNvbnZlcnRlZEN1cnJlbmN5LFxuICAgIGNvbnZlcnNpb25SYXRlLFxuICApO1xuICByZXR1cm4gZm9ybWF0Q3VycmVuY3koY29udmVydGVkVG90YWwsIGNvbnZlcnRlZEN1cnJlbmN5KTtcbn1cbiIsIi8vIFRPRE86IFJlbmFtZSB0byByZWZsZWN0IHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciBtb3JlIGNhc2VzIHRoYW4gRVRILCBhbmQgdXBkYXRlIGFsbCB1c2VzLlxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RVRIRmVlKGV0aEZlZSwgY3VycmVuY3lTeW1ib2wgPSAnRVRIJykge1xyXG4gIHJldHVybiBgJHtldGhGZWV9ICR7Y3VycmVuY3lTeW1ib2x9YDtcclxufVxyXG4iLCIvLyBjcm9zcy1icm93c2VyIGNvbm5lY3Rpb24gdG8gZXh0ZW5zaW9uIGkxOG4gQVBJXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBTZW50cnkgZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCBnZXRGZXRjaFdpdGhUaW1lb3V0IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XG5cbmNvbnN0IGZldGNoV2l0aFRpbWVvdXQgPSBnZXRGZXRjaFdpdGhUaW1lb3V0KCk7XG5cbmNvbnN0IHdhcm5lZCA9IHt9O1xuY29uc3QgbWlzc2luZ01lc3NhZ2VFcnJvcnMgPSB7fTtcbmNvbnN0IG1pc3NpbmdTdWJzdGl0dXRpb25FcnJvcnMgPSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxpemVkIG1lc3NhZ2UgZm9yIHRoZSBnaXZlbiBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlQ29kZSAtIFRoZSBjb2RlIGZvciB0aGUgY3VycmVudCBsb2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBsb2NhbGVNZXNzYWdlcyAtIFRoZSBtYXAgb2YgbWVzc2FnZXMgZm9yIHRoZSBjdXJyZW50IGxvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBtZXNzYWdlIGtleVxuICogQHBhcmFtIHtzdHJpbmdbXX0gc3Vic3RpdHV0aW9ucyAtIEEgbGlzdCBvZiBtZXNzYWdlIHN1YnN0aXR1dGlvbiByZXBsYWNlbWVudHNcbiAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGxvY2FsaXplZCBtZXNzYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRNZXNzYWdlID0gKGxvY2FsZUNvZGUsIGxvY2FsZU1lc3NhZ2VzLCBrZXksIHN1YnN0aXR1dGlvbnMpID0+IHtcbiAgaWYgKCFsb2NhbGVNZXNzYWdlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghbG9jYWxlTWVzc2FnZXNba2V5XSkge1xuICAgIGlmIChsb2NhbGVDb2RlID09PSAnZW4nKSB7XG4gICAgICBpZiAoIW1pc3NpbmdNZXNzYWdlRXJyb3JzW2tleV0pIHtcbiAgICAgICAgbWlzc2luZ01lc3NhZ2VFcnJvcnNba2V5XSA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5hYmxlIHRvIGZpbmQgdmFsdWUgb2Yga2V5IFwiJHtrZXl9XCIgZm9yIGxvY2FsZSBcIiR7bG9jYWxlQ29kZX1cImAsXG4gICAgICAgICk7XG4gICAgICAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKG1pc3NpbmdNZXNzYWdlRXJyb3JzW2tleV0pO1xuICAgICAgICBsb2cuZXJyb3IobWlzc2luZ01lc3NhZ2VFcnJvcnNba2V5XSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5JTl9URVNUKSB7XG4gICAgICAgICAgdGhyb3cgbWlzc2luZ01lc3NhZ2VFcnJvcnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXdhcm5lZFtsb2NhbGVDb2RlXSB8fCAhd2FybmVkW2xvY2FsZUNvZGVdW2tleV0pIHtcbiAgICAgIGlmICghd2FybmVkW2xvY2FsZUNvZGVdKSB7XG4gICAgICAgIHdhcm5lZFtsb2NhbGVDb2RlXSA9IHt9O1xuICAgICAgfVxuICAgICAgd2FybmVkW2xvY2FsZUNvZGVdW2tleV0gPSB0cnVlO1xuICAgICAgbG9nLndhcm4oXG4gICAgICAgIGBUcmFuc2xhdG9yIC0gVW5hYmxlIHRvIGZpbmQgdmFsdWUgb2Yga2V5IFwiJHtrZXl9XCIgZm9yIGxvY2FsZSBcIiR7bG9jYWxlQ29kZX1cImAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbnRyeSA9IGxvY2FsZU1lc3NhZ2VzW2tleV07XG4gIGxldCBwaHJhc2UgPSBlbnRyeS5tZXNzYWdlO1xuXG4gIGNvbnN0IGhhc1N1YnN0aXR1dGlvbnMgPSBCb29sZWFuKHN1YnN0aXR1dGlvbnMgJiYgc3Vic3RpdHV0aW9ucy5sZW5ndGgpO1xuICBjb25zdCBoYXNSZWFjdFN1YnN0aXR1dGlvbnMgPVxuICAgIGhhc1N1YnN0aXR1dGlvbnMgJiZcbiAgICBzdWJzdGl0dXRpb25zLnNvbWUoXG4gICAgICAoZWxlbWVudCkgPT5cbiAgICAgICAgZWxlbWVudCAhPT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIGVsZW1lbnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnKSxcbiAgICApO1xuXG4gIC8vIHBlcmZvcm0gc3Vic3RpdHV0aW9uc1xuICBpZiAoaGFzU3Vic3RpdHV0aW9ucykge1xuICAgIGNvbnN0IHBhcnRzID0gcGhyYXNlLnNwbGl0KC8oXFwkXFxkKS9ndSk7XG5cbiAgICBjb25zdCBzdWJzdGl0dXRlZFBhcnRzID0gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgICBjb25zdCBzdWJNYXRjaCA9IHBhcnQubWF0Y2goL1xcJChcXGQpL3UpO1xuICAgICAgaWYgKCFzdWJNYXRjaCkge1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnN0aXR1dGVJbmRleCA9IE51bWJlcihzdWJNYXRjaFsxXSkgLSAxO1xuICAgICAgaWYgKFxuICAgICAgICAoc3Vic3RpdHV0aW9uc1tzdWJzdGl0dXRlSW5kZXhdID09PSBudWxsIHx8XG4gICAgICAgICAgc3Vic3RpdHV0aW9uc1tzdWJzdGl0dXRlSW5kZXhdID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICFtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3JzW2xvY2FsZUNvZGVdPy5ba2V5XVxuICAgICAgKSB7XG4gICAgICAgIGlmICghbWlzc2luZ1N1YnN0aXR1dGlvbkVycm9yc1tsb2NhbGVDb2RlXSkge1xuICAgICAgICAgIG1pc3NpbmdTdWJzdGl0dXRpb25FcnJvcnNbbG9jYWxlQ29kZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3JzW2xvY2FsZUNvZGVdW2tleV0gPSB0cnVlO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW5zdWZmaWNpZW50IG51bWJlciBvZiBzdWJzdGl0dXRpb25zIGZvciBrZXkgXCIke2tleX1cIiB3aXRoIGxvY2FsZSBcIiR7bG9jYWxlQ29kZX1cImAsXG4gICAgICAgICk7XG4gICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJzdGl0dXRpb25zW3N1YnN0aXR1dGVJbmRleF07XG4gICAgfSk7XG5cbiAgICBwaHJhc2UgPSBoYXNSZWFjdFN1YnN0aXR1dGlvbnMgPyAoXG4gICAgICA8c3Bhbj4ge3N1YnN0aXR1dGVkUGFydHN9IDwvc3Bhbj5cbiAgICApIDogKFxuICAgICAgc3Vic3RpdHV0ZWRQYXJ0cy5qb2luKCcnKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGhyYXNlO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTG9jYWxlKGxvY2FsZUNvZGUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoXG4gICAgICBgLi9fbG9jYWxlcy8ke2xvY2FsZUNvZGV9L21lc3NhZ2VzLmpzb25gLFxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoYGZhaWxlZCB0byBmZXRjaCAke2xvY2FsZUNvZGV9IGxvY2FsZSBiZWNhdXNlIG9mICR7ZXJyb3J9YCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmNvbnN0IHJlbGF0aXZlVGltZUZvcm1hdExvY2FsZURhdGEgPSBuZXcgU2V0KCk7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUmVsYXRpdmVUaW1lRm9ybWF0TG9jYWxlRGF0YShsb2NhbGVDb2RlKSB7XG4gIGNvbnN0IGxhbmd1YWdlVGFnID0gbG9jYWxlQ29kZS5zcGxpdCgnXycpWzBdO1xuICBpZiAoXG4gICAgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQgJiZcbiAgICB0eXBlb2YgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuX19hZGRMb2NhbGVEYXRhID09PSAnZnVuY3Rpb24nICYmXG4gICAgIXJlbGF0aXZlVGltZUZvcm1hdExvY2FsZURhdGEuaGFzKGxhbmd1YWdlVGFnKVxuICApIHtcbiAgICBjb25zdCBsb2NhbGVEYXRhID0gYXdhaXQgZmV0Y2hSZWxhdGl2ZVRpbWVGb3JtYXREYXRhKGxhbmd1YWdlVGFnKTtcbiAgICBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5fX2FkZExvY2FsZURhdGEobG9jYWxlRGF0YSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWxhdGl2ZVRpbWVGb3JtYXREYXRhKGxhbmd1YWdlVGFnKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChcbiAgICBgLi9pbnRsLyR7bGFuZ3VhZ2VUYWd9L3JlbGF0aXZlLXRpbWUtZm9ybWF0LWRhdGEuanNvbmAsXG4gICk7XG4gIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG59XG4iLCJpbXBvcnQge1xuICBCVVlBQkxFX0NIQUlOU19NQVAsXG4gIENIQUlOX0lEUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuZXhwb3J0IGNvbnN0IGZvcm1hdE1vb25wYXlTeW1ib2wgPSAoc3ltYm9sLCBjaGFpbklkID0gQ0hBSU5fSURTLk1BSU5ORVQpID0+IHtcbiAgaWYgKCFzeW1ib2wpIHtcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9XG4gIGxldCBfc3ltYm9sID0gc3ltYm9sO1xuICBpZiAoY2hhaW5JZCA9PT0gQ0hBSU5fSURTLlBPTFlHT04gfHwgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLkJTQykge1xuICAgIF9zeW1ib2wgPSBgJHtfc3ltYm9sfV8ke0JVWUFCTEVfQ0hBSU5TX01BUD8uW1xuICAgICAgY2hhaW5JZFxuICAgIF0/Lm5ldHdvcmsudG9VcHBlckNhc2UoKX1gO1xuICB9IGVsc2UgaWYgKGNoYWluSWQgPT09IENIQUlOX0lEUy5BVkFMQU5DSEUpIHtcbiAgICBfc3ltYm9sID0gYCR7X3N5bWJvbH1fQ0NIQUlOYDtcbiAgfVxuICByZXR1cm4gX3N5bWJvbDtcbn07XG4iLCJpbXBvcnQgeyBvbWl0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEJOIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCBDb21tb24sIHsgQ2hhaW4sIEhhcmRmb3JrIH0gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9IGZyb20gJ0BldGhlcmV1bWpzL3R4JztcbmltcG9ydCB7IHN0cmlwSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcblxuZnVuY3Rpb24gYnVpbGRUeFBhcmFtcyh0eE1ldGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vbWl0KHR4TWV0YS50eFBhcmFtcywgJ2dhcycpLFxuICAgIGdhc0xpbWl0OiB0eE1ldGEudHhQYXJhbXMuZ2FzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFRyYW5zYWN0aW9uQ29tbW9uKHR4TWV0YSkge1xuICAvLyBUaGlzIHByb2R1Y2VzIGEgdHJhbnNhY3Rpb24gd2hvc2UgaW5mb3JtYXRpb24gZG9lcyBub3QgY29tcGxldGVseSBtYXRjaCBhblxuICAvLyBPcHRpbWlzbSB0cmFuc2FjdGlvbiDigJQgZm9yIGluc3RhbmNlLCBERUZBVUxUX0NIQUlOIGlzIHN0aWxsICdtYWlubmV0JyBhbmRcbiAgLy8gZ2VuZXNpcyBwb2ludHMgdG8gdGhlIG1haW5uZXQgZ2VuZXNpcywgbm90IHRoZSBPcHRpbWlzbSBnZW5lc2lzIOKAlCBidXRcbiAgLy8gY29uc2lkZXJpbmcgdGhhdCBhbGwgd2Ugd2FudCB0byBkbyBpcyBzZXJpYWxpemUgYSB0cmFuc2FjdGlvbiwgdGhpcyB3b3Jrc1xuICAvLyBmaW5lIGZvciBvdXIgdXNlIGNhc2UuXG4gIHJldHVybiBDb21tb24uZm9yQ3VzdG9tQ2hhaW4oQ2hhaW4uTWFpbm5ldCwge1xuICAgIGNoYWluSWQ6IG5ldyBCTihzdHJpcEhleFByZWZpeCh0eE1ldGEuY2hhaW5JZCksIDE2KSxcbiAgICBuZXR3b3JrSWQ6IG5ldyBCTih0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQsIDEwKSxcbiAgICAvLyBPcHRpbWlzbSBvbmx5IHN1cHBvcnRzIHR5cGUtMCB0cmFuc2FjdGlvbnM7IGl0IGRvZXMgbm90IHN1cHBvcnQgYW55IG9mXG4gICAgLy8gdGhlIG5ld2VyIEVJUHMgc2luY2UgRUlQLTE1NS4gU291cmNlOlxuICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0tb3B0aW1pc20vb3B0aW1pc20vYmxvYi9kZXZlbG9wL3NwZWNzL2wyZ2V0aC90cmFuc2FjdGlvbi10eXBlcy5tZD5cbiAgICBkZWZhdWx0SGFyZGZvcms6IEhhcmRmb3JrLlNwdXJpb3VzRHJhZ29uLFxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVbnNlcmlhbGl6ZWRUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgY29uc3QgdHhQYXJhbXMgPSBidWlsZFR4UGFyYW1zKHR4TWV0YSk7XG4gIGNvbnN0IGNvbW1vbiA9IGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKTtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4UGFyYW1zLCB7IGNvbW1vbiB9KTtcbn1cbiIsImltcG9ydCAqIGFzIGV0aGVycyBmcm9tICdldGhlcnMnO1xyXG5pbXBvcnQgeyBnZXRDb250cmFjdEZhY3RvcnkgfSBmcm9tICdAZXRoLW9wdGltaXNtL2NvbnRyYWN0cy9kaXN0L2NvbnRyYWN0LWRlZnMnO1xyXG5pbXBvcnQgeyBwcmVkZXBsb3lzIH0gZnJvbSAnQGV0aC1vcHRpbWlzbS9jb250cmFjdHMvZGlzdC9wcmVkZXBsb3lzJztcclxuaW1wb3J0IGJ1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24gZnJvbSAnLi9idWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uJztcclxuXHJcbi8vIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBsYXJnZWx5IGRyYXduIGZyb20gaHR0cHM6Ly9jb21tdW5pdHkub3B0aW1pc20uaW8vZG9jcy9kZXZlbG9wZXJzL2wyL25ldy1mZWVzLmh0bWwjZm9yLWZyb250ZW5kLWFuZC13YWxsZXQtZGV2ZWxvcGVyc1xyXG5cclxuZnVuY3Rpb24gYnVpbGRPVk1HYXNQcmljZU9yYWNsZUNvbnRyYWN0KGV0aCkge1xyXG4gIGNvbnN0IE9WTUdhc1ByaWNlT3JhY2xlID0gZ2V0Q29udHJhY3RGYWN0b3J5KCdPVk1fR2FzUHJpY2VPcmFjbGUnKS5hdHRhY2goXHJcbiAgICBwcmVkZXBsb3lzLk9WTV9HYXNQcmljZU9yYWNsZSxcclxuICApO1xyXG4gIGNvbnN0IGFiaSA9IEpTT04ucGFyc2UoXHJcbiAgICBPVk1HYXNQcmljZU9yYWNsZS5pbnRlcmZhY2UuZm9ybWF0KGV0aGVycy51dGlscy5Gb3JtYXRUeXBlcy5qc29uKSxcclxuICApO1xyXG4gIHJldHVybiBldGguY29udHJhY3QoYWJpKS5hdChPVk1HYXNQcmljZU9yYWNsZS5hZGRyZXNzKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hFc3RpbWF0ZWRMMUZlZShldGgsIHR4TWV0YSkge1xyXG4gIGNvbnN0IGNvbnRyYWN0ID0gYnVpbGRPVk1HYXNQcmljZU9yYWNsZUNvbnRyYWN0KGV0aCk7XHJcbiAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID1cclxuICAgIGJ1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24odHhNZXRhKS5zZXJpYWxpemUoKTtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5nZXRMMUZlZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xyXG4gIHJldHVybiByZXN1bHQ/LlswXT8udG9TdHJpbmcoMTYpO1xyXG59XHJcbiIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHtcbiAgY29udmVyc2lvblV0aWwsXG4gIG11bHRpcGx5Q3VycmVuY2llcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyB9IGZyb20gJy4uLy4uL3N0b3JlL2FjdGlvbnMnO1xuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3N0cmluZy11dGlscyc7XG5pbXBvcnQgeyBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XG5pbXBvcnQgeyBFUkMyMCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgZ2V0VG9rZW5WYWx1ZVBhcmFtIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9tZXRhbWFzay1jb250cm9sbGVyLXV0aWxzJztcbmltcG9ydCB7IGNhbGNUb2tlbkFtb3VudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZm9ybWF0Q3VycmVuY3kgfSBmcm9tICcuL2NvbmZpcm0tdHgudXRpbCc7XG5cbmNvbnN0IERFRkFVTFRfU1lNQk9MID0gJyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN5bWJvbEZyb21Db250cmFjdCh0b2tlbkFkZHJlc3MpIHtcbiAgY29uc3QgdG9rZW4gPSB1dGlsLmdldENvbnRyYWN0QXRBZGRyZXNzKHRva2VuQWRkcmVzcyk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9rZW4uc3ltYm9sKCk7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cud2FybihcbiAgICAgIGBzeW1ib2woKSBjYWxsIGZvciB0b2tlbiBhdCBhZGRyZXNzICR7dG9rZW5BZGRyZXNzfSByZXN1bHRlZCBpbiBlcnJvcjpgLFxuICAgICAgZXJyb3IsXG4gICAgKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldERlY2ltYWxzRnJvbUNvbnRyYWN0KHRva2VuQWRkcmVzcykge1xuICBjb25zdCB0b2tlbiA9IHV0aWwuZ2V0Q29udHJhY3RBdEFkZHJlc3ModG9rZW5BZGRyZXNzKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRva2VuLmRlY2ltYWxzKCk7XG4gICAgY29uc3QgZGVjaW1hbHNCTiA9IHJlc3VsdFswXTtcbiAgICByZXR1cm4gZGVjaW1hbHNCTj8udG9TdHJpbmcoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cud2FybihcbiAgICAgIGBkZWNpbWFscygpIGNhbGwgZm9yIHRva2VuIGF0IGFkZHJlc3MgJHt0b2tlbkFkZHJlc3N9IHJlc3VsdGVkIGluIGVycm9yOmAsXG4gICAgICBlcnJvcixcbiAgICApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuTWV0YWRhdGEodG9rZW5BZGRyZXNzLCB0b2tlbkxpc3QpIHtcbiAgcmV0dXJuIHRva2VuQWRkcmVzcyAmJiB0b2tlbkxpc3RbdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCldO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTeW1ib2wodG9rZW5BZGRyZXNzLCB0b2tlbkxpc3QpIHtcbiAgbGV0IHN5bWJvbCA9IGF3YWl0IGdldFN5bWJvbEZyb21Db250cmFjdCh0b2tlbkFkZHJlc3MpO1xuXG4gIGlmICghc3ltYm9sKSB7XG4gICAgY29uc3QgY29udHJhY3RNZXRhZGF0YUluZm8gPSBnZXRUb2tlbk1ldGFkYXRhKHRva2VuQWRkcmVzcywgdG9rZW5MaXN0KTtcblxuICAgIGlmIChjb250cmFjdE1ldGFkYXRhSW5mbykge1xuICAgICAgc3ltYm9sID0gY29udHJhY3RNZXRhZGF0YUluZm8uc3ltYm9sO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW1ib2w7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldERlY2ltYWxzKHRva2VuQWRkcmVzcywgdG9rZW5MaXN0KSB7XG4gIGxldCBkZWNpbWFscyA9IGF3YWl0IGdldERlY2ltYWxzRnJvbUNvbnRyYWN0KHRva2VuQWRkcmVzcyk7XG5cbiAgaWYgKCFkZWNpbWFscyB8fCBkZWNpbWFscyA9PT0gJzAnKSB7XG4gICAgY29uc3QgY29udHJhY3RNZXRhZGF0YUluZm8gPSBnZXRUb2tlbk1ldGFkYXRhKHRva2VuQWRkcmVzcywgdG9rZW5MaXN0KTtcblxuICAgIGlmIChjb250cmFjdE1ldGFkYXRhSW5mbykge1xuICAgICAgZGVjaW1hbHMgPSBjb250cmFjdE1ldGFkYXRhSW5mby5kZWNpbWFscz8udG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hbHM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTeW1ib2xBbmREZWNpbWFscyh0b2tlbkFkZHJlc3MsIHRva2VuTGlzdCkge1xuICBsZXQgc3ltYm9sLCBkZWNpbWFscztcblxuICB0cnkge1xuICAgIHN5bWJvbCA9IGF3YWl0IGdldFN5bWJvbCh0b2tlbkFkZHJlc3MsIHRva2VuTGlzdCk7XG4gICAgZGVjaW1hbHMgPSBhd2FpdCBnZXREZWNpbWFscyh0b2tlbkFkZHJlc3MsIHRva2VuTGlzdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nLndhcm4oXG4gICAgICBgc3ltYm9sKCkgYW5kIGRlY2ltYWwoKSBjYWxscyBmb3IgdG9rZW4gYXQgYWRkcmVzcyAke3Rva2VuQWRkcmVzc30gcmVzdWx0ZWQgaW4gZXJyb3I6YCxcbiAgICAgIGVycm9yLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN5bWJvbDogc3ltYm9sIHx8IERFRkFVTFRfU1lNQk9MLFxuICAgIGRlY2ltYWxzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5JbmZvR2V0dGVyKCkge1xuICBjb25zdCB0b2tlbnMgPSB7fTtcblxuICByZXR1cm4gYXN5bmMgKGFkZHJlc3MsIHRva2VuTGlzdCkgPT4ge1xuICAgIGlmICh0b2tlbnNbYWRkcmVzc10pIHtcbiAgICAgIHJldHVybiB0b2tlbnNbYWRkcmVzc107XG4gICAgfVxuXG4gICAgdG9rZW5zW2FkZHJlc3NdID0gYXdhaXQgZ2V0U3ltYm9sQW5kRGVjaW1hbHMoYWRkcmVzcywgdG9rZW5MaXN0KTtcblxuICAgIHJldHVybiB0b2tlbnNbYWRkcmVzc107XG4gIH07XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IHRoZSBhZGRyZXNzIHBhcmFtZXRlciBvZiB0aGUgZ2l2ZW4gdG9rZW4gdHJhbnNhY3Rpb24gZGF0YVxuICogKGkuZS4gZnVuY3Rpb24gY2FsbCkgcGVyIHRoZSBIdW1hbiBTdGFuZGFyZCBUb2tlbiBBQkksIGluIHRoZSBmb2xsb3dpbmdcbiAqIG9yZGVyOlxuICogICAtIFRoZSAnX3RvJyBwYXJhbWV0ZXIsIGlmIHByZXNlbnRcbiAqICAgLSBUaGUgZmlyc3QgcGFyYW1ldGVyLCBpZiBwcmVzZW50XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRva2VuRGF0YSAtIGV0aGVycyBJbnRlcmZhY2UgdG9rZW4gZGF0YS5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IEEgbG93ZXJjYXNlIGFkZHJlc3Mgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5BZGRyZXNzUGFyYW0odG9rZW5EYXRhID0ge30pIHtcbiAgY29uc3QgdmFsdWUgPVxuICAgIHRva2VuRGF0YT8uYXJncz8uX3RvIHx8IHRva2VuRGF0YT8uYXJncz8udG8gfHwgdG9rZW5EYXRhPy5hcmdzPy5bMF07XG4gIHJldHVybiB2YWx1ZT8udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlICdfdmFsdWUnIHBhcmFtZXRlciBvZiB0aGUgZ2l2ZW4gdG9rZW4gdHJhbnNhY3Rpb24gZGF0YVxuICogKGkuZSBmdW5jdGlvbiBjYWxsKSBwZXIgdGhlIEh1bWFuIFN0YW5kYXJkIFRva2VuIEFCSSwgaWYgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdG9rZW5EYXRhIC0gZXRoZXJzIEludGVyZmFjZSB0b2tlbiBkYXRhLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gQSBkZWNpbWFsIHN0cmluZyB2YWx1ZS5cbiAqL1xuLyoqXG4gKiBHZXRzIGVpdGhlciB0aGUgJ190b2tlbklkJyBwYXJhbWV0ZXIgb3IgdGhlICdpZCcgcGFyYW0gb2YgdGhlIHBhc3NlZCB0b2tlbiB0cmFuc2FjdGlvbiBkYXRhLixcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2VkIHRva2VuSWQgdmFsdWVzIHJldHVybmVkIGJ5IGBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGFgIGFzIGRlZmluZWRcbiAqIGluIHRoZSBFUkM3MjEgYW5kIEVSQzExNTUgQUJJcyBmcm9tIG1ldGFtYXNrLWV0aC1hYmlzIChodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2stZXRoLWFiaXMvdHJlZS9tYWluL3NyYy9hYmlzKVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbkRhdGEgLSBldGhlcnMgSW50ZXJmYWNlIHRva2VuIGRhdGEuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBBIGRlY2ltYWwgc3RyaW5nIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5JZFBhcmFtKHRva2VuRGF0YSA9IHt9KSB7XG4gIHJldHVybiAoXG4gICAgdG9rZW5EYXRhPy5hcmdzPy5fdG9rZW5JZD8udG9TdHJpbmcoKSA/PyB0b2tlbkRhdGE/LmFyZ3M/LmlkPy50b1N0cmluZygpXG4gICk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgJ19hcHByb3ZlZCcgcGFyYW1ldGVyIG9mIHRoZSBnaXZlbiB0b2tlbiB0cmFuc2FjdGlvbiBkYXRhXG4gKiAoaS5lIGZ1bmN0aW9uIGNhbGwpIHBlciB0aGUgSHVtYW4gU3RhbmRhcmQgVG9rZW4gQUJJLCBpZiBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbkRhdGEgLSBldGhlcnMgSW50ZXJmYWNlIHRva2VuIGRhdGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkIHRvIGFwcHJvdmUgb3IgcmV2b2tlIGFjY2Vzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuQXBwcm92ZWRQYXJhbSh0b2tlbkRhdGEgPSB7fSkge1xuICByZXR1cm4gdG9rZW5EYXRhPy5hcmdzPy5fYXBwcm92ZWQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0b2tlbiBiYWxhbmNlIGNvbnZlcnRlZCB0byBmaWF0IGFuZCBvcHRpb25hbGx5IGZvcm1hdHRlZCBmb3IgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29udHJhY3RFeGNoYW5nZVJhdGVdIC0gVGhlIGV4Y2hhbmdlIHJhdGUgYmV0d2VlbiB0aGUgY3VycmVudCB0b2tlbiBhbmQgdGhlIG5hdGl2ZSBjdXJyZW5jeVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnZlcnNpb25SYXRlIC0gVGhlIGV4Y2hhbmdlIHJhdGUgYmV0d2VlbiB0aGUgY3VycmVudCBmaWF0IGN1cnJlbmN5IGFuZCB0aGUgbmF0aXZlIGN1cnJlbmN5XG4gKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudEN1cnJlbmN5IC0gVGhlIGN1cnJlbmN5IGNvZGUgZm9yIHRoZSB1c2VyJ3MgY2hvc2VuIGZpYXQgY3VycmVuY3lcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdG9rZW5BbW91bnRdIC0gVGhlIGN1cnJlbnQgdG9rZW4gYmFsYW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFt0b2tlblN5bWJvbF0gLSBUaGUgdG9rZW4gc3ltYm9sXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JtYXR0ZWRdIC0gV2hldGhlciB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBiZSBmb3JtYXR0ZWQgb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWRlQ3VycmVuY3lTeW1ib2xdIC0gZXhjbHVkZXMgdGhlIGN1cnJlbmN5IHN5bWJvbCBpbiB0aGUgcmVzdWx0IGlmIHRydWVcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgdG9rZW4gYW1vdW50IGluIHRoZSB1c2VyJ3MgY2hvc2VuIGZpYXQgY3VycmVuY3ksIG9wdGlvbmFsbHkgZm9ybWF0dGVkIGFuZCBsb2NhbGl6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5GaWF0QW1vdW50KFxuICBjb250cmFjdEV4Y2hhbmdlUmF0ZSxcbiAgY29udmVyc2lvblJhdGUsXG4gIGN1cnJlbnRDdXJyZW5jeSxcbiAgdG9rZW5BbW91bnQsXG4gIHRva2VuU3ltYm9sLFxuICBmb3JtYXR0ZWQgPSB0cnVlLFxuICBoaWRlQ3VycmVuY3lTeW1ib2wgPSBmYWxzZSxcbikge1xuICAvLyBJZiB0aGUgY29udmVyc2lvblJhdGUgaXMgMCAoaS5lLiB1bmtub3duKSBvciB0aGUgY29udHJhY3QgZXhjaGFuZ2UgcmF0ZVxuICAvLyBpcyBjdXJyZW50bHkgdW5rbm93biwgdGhlIGZpYXQgYW1vdW50IGNhbm5vdCBiZSBjYWxjdWxhdGVkIHNvIGl0IGlzIG5vdFxuICAvLyBzaG93biB0byB0aGUgdXNlclxuICBpZiAoXG4gICAgY29udmVyc2lvblJhdGUgPD0gMCB8fFxuICAgICFjb250cmFjdEV4Y2hhbmdlUmF0ZSB8fFxuICAgIHRva2VuQW1vdW50ID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRUb2tlblRvRmlhdFJhdGUgPSBtdWx0aXBseUN1cnJlbmNpZXMoXG4gICAgY29udHJhY3RFeGNoYW5nZVJhdGUsXG4gICAgY29udmVyc2lvblJhdGUsXG4gICAge1xuICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTAsXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgfSxcbiAgKTtcbiAgY29uc3QgY3VycmVudFRva2VuSW5GaWF0ID0gY29udmVyc2lvblV0aWwodG9rZW5BbW91bnQsIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIGZyb21DdXJyZW5jeTogdG9rZW5TeW1ib2wsXG4gICAgdG9DdXJyZW5jeTogY3VycmVudEN1cnJlbmN5LnRvVXBwZXJDYXNlKCksXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogMixcbiAgICBjb252ZXJzaW9uUmF0ZTogY3VycmVudFRva2VuVG9GaWF0UmF0ZSxcbiAgfSk7XG4gIGxldCByZXN1bHQ7XG4gIGlmIChoaWRlQ3VycmVuY3lTeW1ib2wpIHtcbiAgICByZXN1bHQgPSBmb3JtYXRDdXJyZW5jeShjdXJyZW50VG9rZW5JbkZpYXQsIGN1cnJlbnRDdXJyZW5jeSk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkKSB7XG4gICAgcmVzdWx0ID0gYCR7Zm9ybWF0Q3VycmVuY3koXG4gICAgICBjdXJyZW50VG9rZW5JbkZpYXQsXG4gICAgICBjdXJyZW50Q3VycmVuY3ksXG4gICAgKX0gJHtjdXJyZW50Q3VycmVuY3kudG9VcHBlckNhc2UoKX1gO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGN1cnJlbnRUb2tlbkluRmlhdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXNzZXREZXRhaWxzKFxuICB0b2tlbkFkZHJlc3MsXG4gIGN1cnJlbnRVc2VyQWRkcmVzcyxcbiAgdHJhbnNhY3Rpb25EYXRhLFxuICBleGlzdGluZ0NvbGxlY3RpYmxlcyxcbikge1xuICBjb25zdCB0b2tlbkRhdGEgPSBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEodHJhbnNhY3Rpb25EYXRhKTtcbiAgaWYgKCF0b2tlbkRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlY3QgdmFsaWQgdG9rZW4gZGF0YScpO1xuICB9XG5cbiAgLy8gU29tZXRpbWVzIHRoZSB0b2tlbklkIHZhbHVlIGlzIHBhcnNlZCBhcyBcIl92YWx1ZVwiIHBhcmFtLiBOb3Qgc2VlaW5nIHRoaXMgb2Z0ZW4gYW55IG1vcmUsIGJ1dCBzdGlsbCBvY2Nhc2lvbmFsbHk6XG4gIC8vIGkuZS4gY2FsbCBhcHByb3ZlKCkgb24gQkFZQyBjb250cmFjdCAtIGh0dHBzOi8vZXRoZXJzY2FuLmlvL3Rva2VuLzB4YmM0Y2EwZWRhNzY0N2E4YWI3YzIwNjFjMmUxMThhMThhOTM2ZjEzZCN3cml0ZUNvbnRyYWN0LCBhbmQgdG9rZW5JZCBzaG93cyB1cCBhcyBfdmFsdWUsXG4gIC8vIG5vdCBzdXJlIHdoeSBzaW5jZSBpdCBkb2Vzbid0IG1hdGNoIHRoZSBFUkM3MjEgQUJJIHNwZWMgd2UgdXNlIHRvIHBhcnNlIHRoZXNlIHRyYW5zYWN0aW9ucyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1ldGgtYWJpcy9ibG9iL2QwNDc0MzA4YTI4OGY5MjUyNTk3YjdjOTNhM2E4ZGVhYWQxOWUxYjIvc3JjL2FiaXMvYWJpRVJDNzIxLnRzI0w2Mi5cbiAgbGV0IHRva2VuSWQgPVxuICAgIGdldFRva2VuSWRQYXJhbSh0b2tlbkRhdGEpPy50b1N0cmluZygpID8/IGdldFRva2VuVmFsdWVQYXJhbSh0b2tlbkRhdGEpO1xuXG4gIGNvbnN0IHRvQWRkcmVzcyA9IGdldFRva2VuQWRkcmVzc1BhcmFtKHRva2VuRGF0YSk7XG5cbiAgbGV0IHRva2VuRGV0YWlscztcblxuICAvLyBpZiBhIHRva2VuSWQgaXMgcHJlc2VudCBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbGxlY3RpYmxlIGluIHN0YXRlIG1hdGNoaW5nIHRoZSBhZGRyZXNzL3Rva2VuSWRcbiAgLy8gYW5kIGF2b2lkIHVubmVjZXNzYXJ5IG5ldHdvcmsgcmVxdWVzdHMgdG8gcXVlcnkgdG9rZW4gZGV0YWlscyB3ZSBhbHJlYWR5IGhhdmVcbiAgaWYgKGV4aXN0aW5nQ29sbGVjdGlibGVzPy5sZW5ndGggJiYgdG9rZW5JZCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ29sbGVjdGlibGUgPSBleGlzdGluZ0NvbGxlY3RpYmxlcy5maW5kKFxuICAgICAgKHsgYWRkcmVzcywgdG9rZW5JZDogX3Rva2VuSWQgfSkgPT5cbiAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSh0b2tlbkFkZHJlc3MsIGFkZHJlc3MpICYmIF90b2tlbklkID09PSB0b2tlbklkLFxuICAgICk7XG5cbiAgICBpZiAoZXhpc3RpbmdDb2xsZWN0aWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9BZGRyZXNzLFxuICAgICAgICAuLi5leGlzdGluZ0NvbGxlY3RpYmxlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHRva2VuRGV0YWlscyA9IGF3YWl0IGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKFxuICAgICAgdG9rZW5BZGRyZXNzLFxuICAgICAgY3VycmVudFVzZXJBZGRyZXNzLFxuICAgICAgdG9rZW5JZCxcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy53YXJuKGVycm9yKTtcbiAgICAvLyBpZiB3ZSBjYW4ndCBkZXRlcm1pbmUgYW55IHRva2VuIHN0YW5kYXJkIG9yIGRldGFpbHMgcmV0dXJuIHRoZSBkYXRhIHdlIGNhbiBleHRyYWN0IHB1cmVseSBmcm9tIHRoZSBwYXJzZWQgdHJhbnNhY3Rpb24gZGF0YVxuICAgIHJldHVybiB7IHRvQWRkcmVzcywgdG9rZW5JZCB9O1xuICB9XG5cbiAgY29uc3QgdG9rZW5BbW91bnQgPVxuICAgIHRva2VuRGF0YSAmJlxuICAgIHRva2VuRGV0YWlscz8uZGVjaW1hbHMgJiZcbiAgICBjYWxjVG9rZW5BbW91bnQoXG4gICAgICBnZXRUb2tlblZhbHVlUGFyYW0odG9rZW5EYXRhKSxcbiAgICAgIHRva2VuRGV0YWlscz8uZGVjaW1hbHMsXG4gICAgKS50b1N0cmluZygxMCk7XG5cbiAgY29uc3QgZGVjaW1hbHMgPVxuICAgIHRva2VuRGV0YWlscz8uZGVjaW1hbHMgJiYgTnVtYmVyKHRva2VuRGV0YWlscy5kZWNpbWFscz8udG9TdHJpbmcoMTApKTtcblxuICBpZiAodG9rZW5EZXRhaWxzPy5zdGFuZGFyZCA9PT0gRVJDMjApIHtcbiAgICB0b2tlbklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gZWxzZSBpZiBub3QgYSBjb2xsZWN0aWJsZSBhbHJlYWR5IGluIHN0YXRlIG9yIHN0YW5kYXJkID09PSBFUkMyMCByZXR1cm4gdG9rZW5EZXRhaWxzIGFuZCB0b2tlbklkXG4gIHJldHVybiB7XG4gICAgdG9rZW5BbW91bnQsXG4gICAgdG9BZGRyZXNzLFxuICAgIGRlY2ltYWxzLFxuICAgIHRva2VuSWQsXG4gICAgLi4udG9rZW5EZXRhaWxzLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgTWV0aG9kUmVnaXN0cnkgfSBmcm9tICdldGgtbWV0aG9kLXJlZ2lzdHJ5JztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XG5pbXBvcnQge1xuICBUUkFOU0FDVElPTl9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fR1JPVVBfU1RBVFVTRVMsXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLFxuICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBhZGRDdXJyZW5jaWVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyByZWFkQWRkcmVzc0FzQ29udHJhY3QgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscyc7XG5pbXBvcnQgZmV0Y2hXaXRoQ2FjaGUgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9mZXRjaC13aXRoLWNhY2hlJztcblxuLyoqXG4gKiBAdHlwZWRlZiBFdGhlcnNDb250cmFjdENhbGxcbiAqIEB0eXBlIG9iamVjdFxuICogQHByb3BlcnR5IHthbnlbXX0gYXJncyAtIFRoZSBhcmdzL3BhcmFtcyB0byB0aGUgZnVuY3Rpb24gY2FsbC5cbiAqIEFuIGFycmF5LWxpa2Ugb2JqZWN0IHdpdGggbnVtZXJpY2FsIGFuZCBzdHJpbmcgaW5kaWNlcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ25hdHVyZSAtIFRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2lnaGFzaCAtIFRoZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzaC5cbiAqIEBwcm9wZXJ0eSB7RXRoZXJzQmlnTnVtYmVyfSB2YWx1ZSAtIFRoZSBFVEggdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxsLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbkZyYWdtZW50fSBmdW5jdGlvbkZyYWdtZW50IC0gVGhlIEV0aGVycyBmdW5jdGlvbiBmcmFnbWVudFxuICogcmVwcmVzZW50YXRpb24gb2YgdGhlIGZ1bmN0aW9uLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1ldGhvZEZyb200Qnl0ZShmb3VyQnl0ZVByZWZpeCkge1xuICBjb25zdCBmb3VyQnl0ZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgYGh0dHBzOi8vd3d3LjRieXRlLmRpcmVjdG9yeS9hcGkvdjEvc2lnbmF0dXJlcy8/aGV4X3NpZ25hdHVyZT0ke2ZvdXJCeXRlUHJlZml4fWAsXG4gICAge1xuICAgICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgICBib2R5OiBudWxsLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICB9LFxuICApO1xuICBmb3VyQnl0ZVJlc3BvbnNlLnJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgIHJldHVybiBuZXcgRGF0ZShhLmNyZWF0ZWRfYXQpLmdldFRpbWUoKSA8IG5ldyBEYXRlKGIuY3JlYXRlZF9hdCkuZ2V0VGltZSgpXG4gICAgICA/IC0xXG4gICAgICA6IDE7XG4gIH0pO1xuICByZXR1cm4gZm91ckJ5dGVSZXNwb25zZS5yZXN1bHRzWzBdLnRleHRfc2lnbmF0dXJlO1xufVxuXG5sZXQgcmVnaXN0cnk7XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBtZXRob2QgZGF0YSBmcm9tIHRoZSBNZXRob2RSZWdpc3RyeSBsaWJyYXJ5LCB0aGUgbWVzc2FnZSByZWdpc3RyeSBsaWJyYXJ5IGFuZCB0aGUgdG9rZW4gYWJpLCBpbiB0aGF0IG9yZGVyIG9mIHByZWZlcmVuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm91ckJ5dGVQcmVmaXggLSBUaGUgcHJlZml4IGZyb20gdGhlIG1ldGhvZCBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1ldGhvZERhdGFBc3luYyhmb3VyQnl0ZVByZWZpeCkge1xuICB0cnkge1xuICAgIGNvbnN0IGZvdXJCeXRlU2lnID0gYXdhaXQgZ2V0TWV0aG9kRnJvbTRCeXRlKGZvdXJCeXRlUHJlZml4KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgbG9nLmVycm9yKGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoIXJlZ2lzdHJ5KSB7XG4gICAgICByZWdpc3RyeSA9IG5ldyBNZXRob2RSZWdpc3RyeSh7IHByb3ZpZGVyOiBnbG9iYWwuZXRoZXJldW1Qcm92aWRlciB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWZvdXJCeXRlU2lnKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkUmVzdWx0ID0gcmVnaXN0cnkucGFyc2UoZm91ckJ5dGVTaWcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHBhcnNlZFJlc3VsdC5uYW1lLFxuICAgICAgcGFyYW1zOiBwYXJzZWRSZXN1bHQuYXJncyxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBmb3VyLWJ5dGUgbWV0aG9kIHNpZ25hdHVyZSBmcm9tIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBoZXggZGF0YSAoQGNvZGUgdHhQYXJhbXMuZGF0YSkgb2YgYSB0cmFuc2FjdGlvblxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvdXItYnl0ZSBtZXRob2Qgc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3VyQnl0ZVByZWZpeChkYXRhID0gJycpIHtcbiAgY29uc3QgcHJlZml4ZWREYXRhID0gYWRkSGV4UHJlZml4KGRhdGEpO1xuICBjb25zdCBmb3VyQnl0ZVByZWZpeCA9IHByZWZpeGVkRGF0YS5zbGljZSgwLCAxMCk7XG4gIHJldHVybiBmb3VyQnl0ZVByZWZpeDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiB0cmFuc2FjdGlvbiBjYXRlZ29yeSwgcmV0dXJucyBhIGJvb2xlYW4gd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGlzIGNhbGxpbmcgYW4gZXJjMjAgdG9rZW4gbWV0aG9kXG4gKlxuICogQHBhcmFtIHtUUkFOU0FDVElPTl9UWVBFU1trZXlvZiBUUkFOU0FDVElPTl9UWVBFU119IHR5cGUgLSBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvbiBiZWluZyBldmFsdWF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBpcyBjYWxsaW5nIGFuIGVyYzIwIHRva2VuIG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbk1ldGhvZEFjdGlvbih0eXBlKSB7XG4gIHJldHVybiBbXG4gICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSLFxuICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFLFxuICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTCxcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSxcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NLFxuICBdLmluY2x1ZGVzKHR5cGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF0ZXN0U3VibWl0dGVkVHhXaXRoTm9uY2UoXG4gIHRyYW5zYWN0aW9ucyA9IFtdLFxuICBub25jZSA9ICcweDAnLFxuKSB7XG4gIGlmICghdHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdGlvbnMucmVkdWNlKChhY2MsIGN1cnJlbnQpID0+IHtcbiAgICBjb25zdCB7IHN1Ym1pdHRlZFRpbWUsIHR4UGFyYW1zOiB7IG5vbmNlOiBjdXJyZW50Tm9uY2UgfSA9IHt9IH0gPSBjdXJyZW50O1xuXG4gICAgaWYgKGN1cnJlbnROb25jZSA9PT0gbm9uY2UpIHtcbiAgICAgIGlmICghYWNjLnN1Ym1pdHRlZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VibWl0dGVkVGltZSA+IGFjYy5zdWJtaXR0ZWRUaW1lID8gY3VycmVudCA6IGFjYztcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNTbWFydENvbnRyYWN0QWRkcmVzcyhhZGRyZXNzKSB7XG4gIGNvbnN0IHsgaXNDb250cmFjdEFkZHJlc3MgfSA9IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChcbiAgICBnbG9iYWwuZXRoLFxuICAgIGFkZHJlc3MsXG4gICk7XG4gIHJldHVybiBpc0NvbnRyYWN0QWRkcmVzcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1bUhleGVzKC4uLmFyZ3MpIHtcbiAgY29uc3QgdG90YWwgPSBhcmdzLnJlZHVjZSgoYWNjLCBoZXhBbW91bnQpID0+IHtcbiAgICByZXR1cm4gYWRkQ3VycmVuY2llcyhhY2MsIGhleEFtb3VudCwge1xuICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICBhQmFzZTogMTYsXG4gICAgICBiQmFzZTogMTYsXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBhZGRIZXhQcmVmaXgodG90YWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWdhY3lUcmFuc2FjdGlvbih0eFBhcmFtcykge1xuICByZXR1cm4gdHhQYXJhbXM/LnR5cGUgPT09IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkxFR0FDWTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RhdHVzIGtleSBmb3IgYSB0cmFuc2FjdGlvbi4gUmVxdWlyZXMgcGFyc2luZyB0aGUgdHhNZXRhLnR4UmVjZWlwdCBvbiB0b3Agb2ZcbiAqIHR4TWV0YS5zdGF0dXMgYmVjYXVzZSB0eE1ldGEuc3RhdHVzIGRvZXMgbm90IHJlZmxlY3Qgb24tY2hhaW4gZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2FjdGlvbiAtIFRoZSB0eE1ldGEgb2JqZWN0IG9mIGEgdHJhbnNhY3Rpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdHJhbnNhY3Rpb24udHhSZWNlaXB0IC0gVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzS2V5KHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHtcbiAgICB0eFJlY2VpcHQ6IHsgc3RhdHVzOiByZWNlaXB0U3RhdHVzIH0gPSB7fSxcbiAgICB0eXBlLFxuICAgIHN0YXR1cyxcbiAgfSA9IHRyYW5zYWN0aW9uO1xuXG4gIC8vIFRoZXJlIHdhcyBhbiBvbi1jaGFpbiBmYWlsdXJlXG4gIGlmIChyZWNlaXB0U3RhdHVzID09PSAnMHgwJykge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQ7XG4gIH1cblxuICBpZiAoXG4gICAgc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQgJiZcbiAgICB0eXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5DQU5DRUxcbiAgKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX0dST1VQX1NUQVRVU0VTLkNBTkNFTExFRDtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdGlvbi5zdGF0dXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHRpdGxlIGZvciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gY2F0ZWdvcnkuXG4gKlxuICogVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSB0cmFuc2FjdGlvbiBjYXRlZ29yeSBpcyB1bnJlY29nbml6ZWQgYW5kIG5vIGRlZmF1bHQgaXMgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdCAtIFRoZSB0cmFuc2xhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHtUUkFOU0FDVElPTl9UWVBFU1trZXlvZiBUUkFOU0FDVElPTl9UWVBFU119IHR5cGUgLSBUaGUgdHJhbnNhY3Rpb24gdHlwZSBjb25zdGFudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hdGl2ZUN1cnJlbmN5IC0gVGhlIG5hdGl2ZSBjdXJyZW5jeSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5ldHdvcmtcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmFuc2FjdGlvbiBjYXRlZ29yeSB0aXRsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25UeXBlVGl0bGUodCwgdHlwZSwgbmF0aXZlQ3VycmVuY3kgPSAnRVRIJykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUjoge1xuICAgICAgcmV0dXJuIHQoJ3RyYW5zZmVyJyk7XG4gICAgfVxuICAgIGNhc2UgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST006IHtcbiAgICAgIHJldHVybiB0KCd0cmFuc2ZlckZyb20nKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NOiB7XG4gICAgICByZXR1cm4gdCgnc2FmZVRyYW5zZmVyRnJvbScpO1xuICAgIH1cbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFOiB7XG4gICAgICByZXR1cm4gdCgnYXBwcm92ZScpO1xuICAgIH1cbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTDoge1xuICAgICAgcmV0dXJuIHQoJ3NldEFwcHJvdmFsRm9yQWxsJyk7XG4gICAgfVxuICAgIGNhc2UgVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQ6IHtcbiAgICAgIHJldHVybiB0KCdzZW5kaW5nTmF0aXZlQXNzZXQnLCBbbmF0aXZlQ3VycmVuY3ldKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5DT05UUkFDVF9JTlRFUkFDVElPTjoge1xuICAgICAgcmV0dXJuIHQoJ2NvbnRyYWN0SW50ZXJhY3Rpb24nKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5ERVBMT1lfQ09OVFJBQ1Q6IHtcbiAgICAgIHJldHVybiB0KCdjb250cmFjdERlcGxveW1lbnQnKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5TV0FQOiB7XG4gICAgICByZXR1cm4gdCgnc3dhcCcpO1xuICAgIH1cbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlNXQVBfQVBQUk9WQUw6IHtcbiAgICAgIHJldHVybiB0KCdzd2FwQXBwcm92YWwnKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCB7IHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XHJcbmltcG9ydCB7IHZhbHVlc0ZvciB9IGZyb20gJy4vdXRpbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0eEhlbHBlcihcclxuICB1bmFwcHJvdmVkVHhzLFxyXG4gIHVuYXBwcm92ZWRNc2dzLFxyXG4gIHBlcnNvbmFsTXNncyxcclxuICBkZWNyeXB0TXNncyxcclxuICBlbmNyeXB0aW9uUHVibGljS2V5TXNncyxcclxuICB0eXBlZE1lc3NhZ2VzLFxyXG4gIG5ldHdvcmssXHJcbiAgY2hhaW5JZCxcclxuKSB7XHJcbiAgbG9nLmRlYnVnKCd0eC1oZWxwZXIgY2FsbGVkIHdpdGggcGFyYW1zOicpO1xyXG4gIGxvZy5kZWJ1Zyh7XHJcbiAgICB1bmFwcHJvdmVkVHhzLFxyXG4gICAgdW5hcHByb3ZlZE1zZ3MsXHJcbiAgICBwZXJzb25hbE1zZ3MsXHJcbiAgICBkZWNyeXB0TXNncyxcclxuICAgIGVuY3J5cHRpb25QdWJsaWNLZXlNc2dzLFxyXG4gICAgdHlwZWRNZXNzYWdlcyxcclxuICAgIG5ldHdvcmssXHJcbiAgICBjaGFpbklkLFxyXG4gIH0pO1xyXG5cclxuICBjb25zdCB0eFZhbHVlcyA9IG5ldHdvcmtcclxuICAgID8gdmFsdWVzRm9yKHVuYXBwcm92ZWRUeHMpLmZpbHRlcigodHhNZXRhKSA9PlxyXG4gICAgICAgIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsodHhNZXRhLCBjaGFpbklkLCBuZXR3b3JrKSxcclxuICAgICAgKVxyXG4gICAgOiB2YWx1ZXNGb3IodW5hcHByb3ZlZFR4cyk7XHJcbiAgbG9nLmRlYnVnKGB0eCBoZWxwZXIgZm91bmQgJHt0eFZhbHVlcy5sZW5ndGh9IHVuYXBwcm92ZWQgdHhzYCk7XHJcblxyXG4gIGNvbnN0IG1zZ1ZhbHVlcyA9IHZhbHVlc0Zvcih1bmFwcHJvdmVkTXNncyk7XHJcbiAgbG9nLmRlYnVnKGB0eCBoZWxwZXIgZm91bmQgJHttc2dWYWx1ZXMubGVuZ3RofSB1bnNpZ25lZCBtZXNzYWdlc2ApO1xyXG4gIGxldCBhbGxWYWx1ZXMgPSB0eFZhbHVlcy5jb25jYXQobXNnVmFsdWVzKTtcclxuXHJcbiAgY29uc3QgcGVyc29uYWxWYWx1ZXMgPSB2YWx1ZXNGb3IocGVyc29uYWxNc2dzKTtcclxuICBsb2cuZGVidWcoXHJcbiAgICBgdHggaGVscGVyIGZvdW5kICR7cGVyc29uYWxWYWx1ZXMubGVuZ3RofSB1bnNpZ25lZCBwZXJzb25hbCBtZXNzYWdlc2AsXHJcbiAgKTtcclxuICBhbGxWYWx1ZXMgPSBhbGxWYWx1ZXMuY29uY2F0KHBlcnNvbmFsVmFsdWVzKTtcclxuXHJcbiAgY29uc3QgZGVjcnlwdFZhbHVlcyA9IHZhbHVlc0ZvcihkZWNyeXB0TXNncyk7XHJcbiAgbG9nLmRlYnVnKGB0eCBoZWxwZXIgZm91bmQgJHtkZWNyeXB0VmFsdWVzLmxlbmd0aH0gZGVjcnlwdCByZXF1ZXN0c2ApO1xyXG4gIGFsbFZhbHVlcyA9IGFsbFZhbHVlcy5jb25jYXQoZGVjcnlwdFZhbHVlcyk7XHJcblxyXG4gIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXlWYWx1ZXMgPSB2YWx1ZXNGb3IoZW5jcnlwdGlvblB1YmxpY0tleU1zZ3MpO1xyXG4gIGxvZy5kZWJ1ZyhcclxuICAgIGB0eCBoZWxwZXIgZm91bmQgJHtlbmNyeXB0aW9uUHVibGljS2V5VmFsdWVzLmxlbmd0aH0gZW5jcnlwdGlvblB1YmxpY0tleSByZXF1ZXN0c2AsXHJcbiAgKTtcclxuICBhbGxWYWx1ZXMgPSBhbGxWYWx1ZXMuY29uY2F0KGVuY3J5cHRpb25QdWJsaWNLZXlWYWx1ZXMpO1xyXG5cclxuICBjb25zdCB0eXBlZFZhbHVlcyA9IHZhbHVlc0Zvcih0eXBlZE1lc3NhZ2VzKTtcclxuICBsb2cuZGVidWcoYHR4IGhlbHBlciBmb3VuZCAke3R5cGVkVmFsdWVzLmxlbmd0aH0gdW5zaWduZWQgdHlwZWQgbWVzc2FnZXNgKTtcclxuICBhbGxWYWx1ZXMgPSBhbGxWYWx1ZXMuY29uY2F0KHR5cGVkVmFsdWVzKTtcclxuXHJcbiAgYWxsVmFsdWVzID0gYWxsVmFsdWVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBhbGxWYWx1ZXM7XHJcbn1cclxuIiwiaW1wb3J0IHB1bnljb2RlIGZyb20gJ3B1bnljb2RlL3B1bnljb2RlJztcbmltcG9ydCBhYmkgZnJvbSAnaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIGV0aFV0aWwgZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSAnbHV4b24nO1xuaW1wb3J0IHsgZ2V0Rm9ybWF0dGVkSXBmc1VybCB9IGZyb20gJ0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3V0aWwnO1xuaW1wb3J0IHNsaXA0NCBmcm9tICdAbWV0YW1hc2svc2xpcDQ0JztcbmltcG9ydCB7IENIQUlOX0lEUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICB0b0NoZWNrc3VtSGV4QWRkcmVzcyxcbiAgc3RyaXBIZXhQcmVmaXgsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5pbXBvcnQge1xuICBUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSUyxcbiAgVFJVTkNBVEVEX05BTUVfQ0hBUl9MSU1JVCxcbiAgVFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2xhYmVscyc7XG5pbXBvcnQgeyB0b0JpZ051bWJlciB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMnO1xuXG4vLyBmb3JtYXREYXRhIDo6ICggZGF0ZTogPFVuaXggVGltZXN0YW1wPiApIC0+IFN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0ID0gXCJNL2QveSAnYXQnIFRcIikge1xuICBpZiAoIWRhdGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSkudG9Gb3JtYXQoZm9ybWF0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGVXaXRoWWVhckNvbnRleHQoXG4gIGRhdGUsXG4gIGZvcm1hdFRoaXNZZWFyID0gJ01NTSBkJyxcbiAgZmFsbGJhY2sgPSAnTU1NIGQsIHknLFxuKSB7XG4gIGlmICghZGF0ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBkYXRlVGltZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSk7XG4gIGNvbnN0IG5vdyA9IERhdGVUaW1lLmxvY2FsKCk7XG4gIHJldHVybiBkYXRlVGltZS50b0Zvcm1hdChcbiAgICBub3cueWVhciA9PT0gZGF0ZVRpbWUueWVhciA/IGZvcm1hdFRoaXNZZWFyIDogZmFsbGJhY2ssXG4gICk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb3ZpZGVkIGNoYWluSWQgaXMgYSBkZWZhdWx0IE1ldGFNYXNrIGNoYWluXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBjaGFpbklkIHRvIGNoZWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmF1bHRNZXRhTWFza0NoYWluKGNoYWluSWQpIHtcbiAgaWYgKFxuICAgICFjaGFpbklkIHx8XG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLk1BSU5ORVQgfHxcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuR09FUkxJIHx8XG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLlNFUE9MSUEgfHxcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuTE9DQUxIT1NUXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzRm9yKG9iaikge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRyZXNzU3VtbWFyeShcbiAgYWRkcmVzcyxcbiAgZmlyc3RTZWdMZW5ndGggPSAxMCxcbiAgbGFzdFNlZ0xlbmd0aCA9IDQsXG4gIGluY2x1ZGVIZXggPSB0cnVlLFxuKSB7XG4gIGlmICghYWRkcmVzcykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBsZXQgY2hlY2tlZCA9IHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICBpZiAoIWluY2x1ZGVIZXgpIHtcbiAgICBjaGVja2VkID0gc3RyaXBIZXhQcmVmaXgoY2hlY2tlZCk7XG4gIH1cbiAgcmV0dXJuIGNoZWNrZWRcbiAgICA/IGAke2NoZWNrZWQuc2xpY2UoMCwgZmlyc3RTZWdMZW5ndGgpfS4uLiR7Y2hlY2tlZC5zbGljZShcbiAgICAgICAgY2hlY2tlZC5sZW5ndGggLSBsYXN0U2VnTGVuZ3RoLFxuICAgICAgKX1gXG4gICAgOiAnLi4uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREb21haW5OYW1lKGFkZHJlc3MpIHtcbiAgY29uc3QgbWF0Y2ggPSBwdW55Y29kZVxuICAgIC50b0FTQ0lJKGFkZHJlc3MpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAvLyBDaGVja3MgdGhhdCB0aGUgZG9tYWluIGNvbnNpc3RzIG9mIGF0IGxlYXN0IG9uZSB2YWxpZCBkb21haW4gcGllY2VzIHNlcGFyYXRlZCBieSBwZXJpb2RzLCBmb2xsb3dlZCBieSBhIHRsZFxuICAgIC8vIEVhY2ggcGllY2Ugb2YgZG9tYWluIG5hbWUgaGFzIG9ubHkgdGhlIGNoYXJhY3RlcnMgYS16LCAwLTksIGFuZCBhIGh5cGhlbiAoYnV0IG5vdCBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGNodW5rKVxuICAgIC8vIEEgY2h1bmsgaGFzIG1pbmltdW0gbGVuZ3RoIG9mIDEsIGJ1dCBtaW5pbXVtIHRsZCBpcyBzZXQgdG8gMiBmb3Igbm93IChubyAxLWNoYXJhY3RlciB0bGRzIGV4aXN0IHlldClcbiAgICAubWF0Y2goXG4gICAgICAvXig/OlthLXowLTldKD86Wy1hLXowLTldKlthLXowLTldKT9cXC4pK1thLXowLTldWy1hLXowLTldKlthLXowLTldJC91LFxuICAgICk7XG4gIHJldHVybiBtYXRjaCAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3JpZ2luQ29udHJhY3RBZGRyZXNzKHRvLCBzZW5kVG9rZW5BZGRyZXNzKSB7XG4gIGlmICghdG8gfHwgIXNlbmRUb2tlbkFkZHJlc3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRvLnRvTG93ZXJDYXNlKCkgPT09IHNlbmRUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gVGFrZXMgd2VpIEhleCwgcmV0dXJucyB3ZWkgQk4sIGV2ZW4gaWYgaW5wdXQgaXMgbnVsbFxuZXhwb3J0IGZ1bmN0aW9uIG51bWVyaWNCYWxhbmNlKGJhbGFuY2UpIHtcbiAgaWYgKCFiYWxhbmNlKSB7XG4gICAgcmV0dXJuIG5ldyBldGhVdGlsLkJOKDAsIDE2KTtcbiAgfVxuICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGJhbGFuY2UpO1xuICByZXR1cm4gbmV3IGV0aFV0aWwuQk4oc3RyaXBwZWQsIDE2KTtcbn1cblxuLy8gVGFrZXMgIGhleCwgcmV0dXJucyBbYmVmb3JlRGVjaW1hbCwgYWZ0ZXJEZWNpbWFsXVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQmFsYW5jZShiYWxhbmNlKSB7XG4gIGxldCBhZnRlckRlY2ltYWw7XG4gIGNvbnN0IHdlaSA9IG51bWVyaWNCYWxhbmNlKGJhbGFuY2UpO1xuICBjb25zdCB3ZWlTdHJpbmcgPSB3ZWkudG9TdHJpbmcoKTtcbiAgY29uc3QgdHJhaWxpbmdaZXJvcyA9IC8wKyQvdTtcblxuICBjb25zdCBiZWZvcmVEZWNpbWFsID1cbiAgICB3ZWlTdHJpbmcubGVuZ3RoID4gMTggPyB3ZWlTdHJpbmcuc2xpY2UoMCwgd2VpU3RyaW5nLmxlbmd0aCAtIDE4KSA6ICcwJztcbiAgYWZ0ZXJEZWNpbWFsID0gYDAwMDAwMDAwMDAwMDAwMDAwMCR7d2VpfWBcbiAgICAuc2xpY2UoLTE4KVxuICAgIC5yZXBsYWNlKHRyYWlsaW5nWmVyb3MsICcnKTtcbiAgaWYgKGFmdGVyRGVjaW1hbCA9PT0gJycpIHtcbiAgICBhZnRlckRlY2ltYWwgPSAnMCc7XG4gIH1cbiAgcmV0dXJuIFtiZWZvcmVEZWNpbWFsLCBhZnRlckRlY2ltYWxdO1xufVxuXG4vLyBUYWtlcyB3ZWkgaGV4LCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRocmVlIHByb3BlcnRpZXMuXG4vLyBJdHMgXCJmb3JtYXR0ZWRcIiBwcm9wZXJ0eSBpcyB3aGF0IHdlIGdlbmVyYWxseSB1c2UgdG8gcmVuZGVyIHZhbHVlcy5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCYWxhbmNlKFxuICBiYWxhbmNlLFxuICBkZWNpbWFsc1RvS2VlcCxcbiAgbmVlZHNQYXJzZSA9IHRydWUsXG4gIHRpY2tlciA9ICdFVEgnLFxuKSB7XG4gIGNvbnN0IHBhcnNlZCA9IG5lZWRzUGFyc2UgPyBwYXJzZUJhbGFuY2UoYmFsYW5jZSkgOiBiYWxhbmNlLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGJlZm9yZURlY2ltYWwgPSBwYXJzZWRbMF07XG4gIGxldCBhZnRlckRlY2ltYWwgPSBwYXJzZWRbMV07XG4gIGxldCBmb3JtYXR0ZWQgPSAnTm9uZSc7XG4gIGlmIChkZWNpbWFsc1RvS2VlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGJlZm9yZURlY2ltYWwgPT09ICcwJykge1xuICAgICAgaWYgKGFmdGVyRGVjaW1hbCAhPT0gJzAnKSB7XG4gICAgICAgIGNvbnN0IHNpZ0ZpZ3MgPSBhZnRlckRlY2ltYWwubWF0Y2goL14wKiguezJ9KS91KTsgLy8gZGVmYXVsdDogZ3JhYnMgMiBtb3N0IHNpZ25pZmljYW50IGRpZ2l0c1xuICAgICAgICBpZiAoc2lnRmlncykge1xuICAgICAgICAgIGFmdGVyRGVjaW1hbCA9IHNpZ0ZpZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0dGVkID0gYDAuJHthZnRlckRlY2ltYWx9ICR7dGlja2VyfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdHRlZCA9IGAke2JlZm9yZURlY2ltYWx9LiR7YWZ0ZXJEZWNpbWFsLnNsaWNlKDAsIDMpfSAke3RpY2tlcn1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhZnRlckRlY2ltYWwgKz0gQXJyYXkoZGVjaW1hbHNUb0tlZXApLmpvaW4oJzAnKTtcbiAgICBmb3JtYXR0ZWQgPSBgJHtiZWZvcmVEZWNpbWFsfS4ke2FmdGVyRGVjaW1hbC5zbGljZShcbiAgICAgIDAsXG4gICAgICBkZWNpbWFsc1RvS2VlcCxcbiAgICApfSAke3RpY2tlcn1gO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFjdEF0QWRkcmVzcyh0b2tlbkFkZHJlc3MpIHtcbiAgcmV0dXJuIGdsb2JhbC5ldGguY29udHJhY3QoYWJpKS5hdCh0b2tlbkFkZHJlc3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tRmlsZU5hbWUoKSB7XG4gIGxldCBmaWxlTmFtZSA9ICcnO1xuICBjb25zdCBjaGFyQmFuayA9IFtcbiAgICAuLi4nYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknLFxuICBdO1xuICBjb25zdCBmaWxlTmFtZUxlbmd0aCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDcgKyA2KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVOYW1lTGVuZ3RoOyBpKyspIHtcbiAgICBmaWxlTmFtZSArPSBjaGFyQmFua1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyQmFuay5sZW5ndGgpXTtcbiAgfVxuXG4gIHJldHVybiBmaWxlTmFtZTtcbn1cblxuLyoqXG4gKiBTaG9ydGVucyBhbiBFdGhlcmV1bSBhZGRyZXNzIGZvciBkaXNwbGF5LCBwcmVzZXJ2aW5nIHRoZSBiZWdpbm5pbmcgYW5kIGVuZC5cbiAqIFJldHVybnMgdGhlIGdpdmVuIGFkZHJlc3MgaWYgaXQgaXMgbm8gbG9uZ2VyIHRoYW4gMTAgY2hhcmFjdGVycy5cbiAqIFNob3J0ZW5lZCBhZGRyZXNzZXMgYXJlIDEzIGNoYXJhY3RlcnMgbG9uZy5cbiAqXG4gKiBFeGFtcGxlIG91dHB1dDogMHhhYmNkLi4uMTIzNFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gc2hvcnRlbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzaG9ydGVuZWQgYWRkcmVzcywgb3IgdGhlIG9yaWdpbmFsIGlmIGl0IHdhcyBubyBsb25nZXJcbiAqIHRoYW4gMTAgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3J0ZW5BZGRyZXNzKGFkZHJlc3MgPSAnJykge1xuICBpZiAoYWRkcmVzcy5sZW5ndGggPCBUUlVOQ0FURURfTkFNRV9DSEFSX0xJTUlUKSB7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICByZXR1cm4gYCR7YWRkcmVzcy5zbGljZSgwLCBUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSUyl9Li4uJHthZGRyZXNzLnNsaWNlKFxuICAgIC1UUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlMsXG4gICl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY291bnRCeUFkZHJlc3MoYWNjb3VudHMgPSBbXSwgdGFyZ2V0QWRkcmVzcykge1xuICByZXR1cm4gYWNjb3VudHMuZmluZCgoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MgPT09IHRhcmdldEFkZHJlc3MpO1xufVxuXG4vKipcbiAqIFN0cmlwcyB0aGUgZm9sbG93aW5nIHNjaGVtZXMgZnJvbSBVUkwgc3RyaW5nczpcbiAqIC0gaHR0cFxuICogLSBodHRwc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxTdHJpbmcgLSBUaGUgVVJMIHN0cmluZyB0byBzdHJpcCB0aGUgc2NoZW1lIGZyb20uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEh0dHBTY2hlbWVzKHVybFN0cmluZykge1xuICByZXR1cm4gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwcz86XFwvXFwvL3UsICcnKTtcbn1cblxuLyoqXG4gKiBTdHJpcHMgdGhlIGZvbGxvd2luZyBzY2hlbWVzIGZyb20gVVJMIHN0cmluZ3M6XG4gKiAtIGh0dHBzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFN0cmluZyAtIFRoZSBVUkwgc3RyaW5nIHRvIHN0cmlwIHRoZSBzY2hlbWUgZnJvbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBVUkwgc3RyaW5nLCB3aXRob3V0IHRoZSBzY2hlbWUsIGlmIGl0IHdhcyBzdHJpcHBlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSHR0cHNTY2hlbWUodXJsU3RyaW5nKSB7XG4gIHJldHVybiB1cmxTdHJpbmcucmVwbGFjZSgvXmh0dHBzOlxcL1xcLy91LCAnJyk7XG59XG5cbi8qKlxuICogU3RyaXBzIGBodHRwc2Agc2NoZW1lcyBmcm9tIFVSTCBzdHJpbmdzLCBpZiB0aGUgVVJMIGRvZXMgbm90IGhhdmUgYSBwb3J0LlxuICogVGhpcyBpcyB1c2VmdWxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIFVSTCBzdHJpbmcsIHdpdGhvdXQgdGhlIHNjaGVtZSwgaWYgaXQgd2FzIHN0cmlwcGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwc1NjaGVtZVdpdGhvdXRQb3J0KHVybFN0cmluZykge1xuICBpZiAoZ2V0VVJMKHVybFN0cmluZykucG9ydCkge1xuICAgIHJldHVybiB1cmxTdHJpbmc7XG4gIH1cblxuICByZXR1cm4gc3RyaXBIdHRwc1NjaGVtZSh1cmxTdHJpbmcpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgVVJMLWxpa2UgdmFsdWUgKG9iamVjdCBvciBzdHJpbmcpIGlzIGFuIGV4dGVuc2lvbiBVUkwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBVUkwgfCBvYmplY3R9IHVybExpa2UgLSBUaGUgVVJMLWxpa2UgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBVUkwtbGlrZSB2YWx1ZSBpcyBhbiBleHRlbnNpb24gVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbnNpb25VcmwodXJsTGlrZSkge1xuICBjb25zdCBFWFRfUFJPVE9DT0xTID0gWydjaHJvbWUtZXh0ZW5zaW9uOicsICdtb3otZXh0ZW5zaW9uOiddO1xuXG4gIGlmICh0eXBlb2YgdXJsTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIEVYVF9QUk9UT0NPTFMpIHtcbiAgICAgIGlmICh1cmxMaWtlLnN0YXJ0c1dpdGgocHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh1cmxMaWtlPy5wcm90b2NvbCkge1xuICAgIHJldHVybiBFWFRfUFJPVE9DT0xTLmluY2x1ZGVzKHVybExpa2UucHJvdG9jb2wpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBhZGRyZXNzIGlzIGluIGEgcGFzc2VkIGxpc3Qgb2Ygb2JqZWN0cyB3aXRoIGFkZHJlc3MgcHJvcGVydGllcy4gVGhlIGNoZWNrIGlzIHBlcmZvcm1lZCBvbiB0aGVcbiAqIGxvd2VyY2FzZWQgdmVyc2lvbiBvZiB0aGUgYWRkcmVzc2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGhleCBhZGRyZXNzIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gVGhlIGFycmF5IG9mIG9iamVjdHMgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkcmVzcyBpcyBpbiB0aGUgbGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFeGlzdGluZ0FkZHJlc3NlcyhhZGRyZXNzLCBsaXN0ID0gW10pIHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbWF0Y2hlc0FkZHJlc3MgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIG9iai5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICByZXR1cm4gbGlzdC5zb21lKG1hdGNoZXNBZGRyZXNzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJuR3JlYXRlclRoYW4oYSwgYikge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV3IEJpZ051bWJlcihhLCAxMCkuZ3QoYiwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm5MZXNzVGhhbihhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5sdChiLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibkdyZWF0ZXJUaGFuRXF1YWxUbyhhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5ndGUoYiwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm5MZXNzVGhhbkVxdWFsVG8oYSwgYikge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV3IEJpZ051bWJlcihhLCAxMCkubHRlKGIsIDEwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3QodXJsKSB7XG4gIHJldHVybiBnZXRVUkwodXJsKT8uaG9zdCB8fCAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3ROYW1lKHVybCkge1xuICByZXR1cm4gZ2V0VVJMKHVybCk/Lmhvc3RuYW1lIHx8ICcnO1xufVxuXG4vLyBPbmNlIHdlIHJlYWNoIHRoaXMgdGhyZXNob2xkLCB3ZSBzd2l0Y2ggdG8gaGlnaGVyIHVuaXRcbmNvbnN0IE1JTlVURV9DVVRPRkYgPSA5MCAqIDYwO1xuY29uc3QgU0VDT05EX0NVVE9GRiA9IDkwO1xuXG5leHBvcnQgY29uc3QgdG9IdW1hblJlYWRhYmxlVGltZSA9ICh0LCBtaWxsaXNlY29uZHMpID0+IHtcbiAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkIHx8IG1pbGxpc2Vjb25kcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5jZWlsKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICBpZiAoc2Vjb25kcyA8PSBTRUNPTkRfQ1VUT0ZGKSB7XG4gICAgcmV0dXJuIHQoJ2dhc1RpbWluZ1NlY29uZHNTaG9ydCcsIFtzZWNvbmRzXSk7XG4gIH1cbiAgaWYgKHNlY29uZHMgPD0gTUlOVVRFX0NVVE9GRikge1xuICAgIHJldHVybiB0KCdnYXNUaW1pbmdNaW51dGVzU2hvcnQnLCBbTWF0aC5jZWlsKHNlY29uZHMgLyA2MCldKTtcbiAgfVxuICByZXR1cm4gdCgnZ2FzVGltaW5nSG91cnNTaG9ydCcsIFtNYXRoLmNlaWwoc2Vjb25kcyAvIDM2MDApXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDbGlwYm9hcmQoKSB7XG4gIHdpbmRvdy5uYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCgnJyk7XG59XG5cbmNvbnN0IHNvbGlkaXR5VHlwZXMgPSAoKSA9PiB7XG4gIGNvbnN0IHR5cGVzID0gW1xuICAgICdib29sJyxcbiAgICAnYWRkcmVzcycsXG4gICAgJ3N0cmluZycsXG4gICAgJ2J5dGVzJyxcbiAgICAnaW50JyxcbiAgICAndWludCcsXG4gICAgJ2ZpeGVkJyxcbiAgICAndWZpeGVkJyxcbiAgXTtcblxuICBjb25zdCBpbnRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoMzIpKS5tYXAoXG4gICAgKF8sIGluZGV4KSA9PiBgaW50JHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgdWludHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcbiAgICAoXywgaW5kZXgpID0+IGB1aW50JHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgYnl0ZXMgPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcbiAgICAoXywgaW5kZXgpID0+IGBieXRlcyR7aW5kZXggKyAxfWAsXG4gICk7XG5cbiAgLyoqXG4gICAqIGZpeGVkIGFuZCB1Zml4ZWRcbiAgICogVGhpcyB2YWx1ZSB0eXBlIGFsc28gY2FuIGJlIGRlY2xhcmVkIGtleXdvcmRzIHN1Y2ggYXMgdWZpeGVkTXhOIGFuZCBmaXhlZE14Ti5cbiAgICogVGhlIE0gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGJpdHMgdGhhdCB0aGUgdHlwZSB0YWtlcyxcbiAgICogd2l0aCBOIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRoYXQgYXJlIGF2YWlsYWJsZS5cbiAgICogIE0gaGFzIHRvIGJlIGRpdmlzaWJsZSBieSA4LCBhbmQgYSBudW1iZXIgZnJvbSA4IHRvIDI1Ni5cbiAgICogTiBoYXMgdG8gYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDgwLCBhbHNvIGJlaW5nIGluY2x1c2l2ZS5cbiAgICovXG4gIGNvbnN0IGZpeGVkTSA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxuICAgIChfLCBpbmRleCkgPT4gYGZpeGVkJHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgdWZpeGVkTSA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxuICAgIChfLCBpbmRleCkgPT4gYHVmaXhlZCR7KGluZGV4ICsgMSkgKiA4fWAsXG4gICk7XG4gIGNvbnN0IGZpeGVkID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoODApKS5tYXAoKF8sIGluZGV4KSA9PlxuICAgIGZpeGVkTS5tYXAoKGFGaXhlZE0pID0+IGAke2FGaXhlZE19eCR7aW5kZXggKyAxfWApLFxuICApO1xuICBjb25zdCB1Zml4ZWQgPSBBcnJheS5mcm9tKG5ldyBBcnJheSg4MCkpLm1hcCgoXywgaW5kZXgpID0+XG4gICAgdWZpeGVkTS5tYXAoKGF1Rml4ZWRNKSA9PiBgJHthdUZpeGVkTX14JHtpbmRleCArIDF9YCksXG4gICk7XG5cbiAgcmV0dXJuIFtcbiAgICAuLi50eXBlcyxcbiAgICAuLi5pbnRzLFxuICAgIC4uLnVpbnRzLFxuICAgIC4uLmJ5dGVzLFxuICAgIC4uLmZpeGVkLmZsYXQoKSxcbiAgICAuLi51Zml4ZWQuZmxhdCgpLFxuICBdO1xufTtcblxuZXhwb3J0IGNvbnN0IHNhbml0aXplTWVzc2FnZSA9IChtc2csIGJhc2VUeXBlLCB0eXBlcykgPT4ge1xuICBpZiAoIXR5cGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR5cGVzIGRlZmluaXRpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGJhc2VUeXBlRGVmaW5pdGlvbnMgPSB0eXBlc1tiYXNlVHlwZV07XG4gIGlmICghYmFzZVR5cGVEZWZpbml0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmltYXJ5IHR5cGUgZGVmaW5pdGlvbmApO1xuICB9XG5cbiAgY29uc3Qgc2FuaXRpemVkTWVzc2FnZSA9IHt9O1xuICBjb25zdCBtc2dLZXlzID0gT2JqZWN0LmtleXMobXNnKTtcbiAgbXNnS2V5cy5mb3JFYWNoKChtc2dLZXkpID0+IHtcbiAgICBjb25zdCBkZWZpbmVkVHlwZSA9IE9iamVjdC52YWx1ZXMoYmFzZVR5cGVEZWZpbml0aW9ucykuZmluZChcbiAgICAgIChiYXNlVHlwZURlZmluaXRpb24pID0+IGJhc2VUeXBlRGVmaW5pdGlvbi5uYW1lID09PSBtc2dLZXksXG4gICAgKTtcblxuICAgIGlmICghZGVmaW5lZFR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBrZXkgaGFzIGEgdHlwZS4gY2hlY2sgaWYgdGhlIGRlZmluZWRUeXBlIGlzIGFsc28gYSB0eXBlXG4gICAgY29uc3QgbmVzdGVkVHlwZSA9IGRlZmluZWRUeXBlLnR5cGUucmVwbGFjZSgvXFxbXFxdJC91LCAnJyk7XG4gICAgY29uc3QgbmVzdGVkVHlwZURlZmluaXRpb24gPSB0eXBlc1tuZXN0ZWRUeXBlXTtcblxuICAgIGlmIChuZXN0ZWRUeXBlRGVmaW5pdGlvbikge1xuICAgICAgaWYgKGRlZmluZWRUeXBlLnR5cGUuZW5kc1dpdGgoJ1tdJykgPiAwKSB7XG4gICAgICAgIC8vIG5lc3RlZCBhcnJheVxuICAgICAgICBzYW5pdGl6ZWRNZXNzYWdlW21zZ0tleV0gPSBtc2dbbXNnS2V5XS5tYXAoKHZhbHVlKSA9PlxuICAgICAgICAgIHNhbml0aXplTWVzc2FnZSh2YWx1ZSwgbmVzdGVkVHlwZSwgdHlwZXMpLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmVzdGVkIG9iamVjdFxuICAgICAgICBzYW5pdGl6ZWRNZXNzYWdlW21zZ0tleV0gPSBzYW5pdGl6ZU1lc3NhZ2UoXG4gICAgICAgICAgbXNnW21zZ0tleV0sXG4gICAgICAgICAgZGVmaW5lZFR5cGUudHlwZSxcbiAgICAgICAgICB0eXBlcyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgaWYgaXQncyBhIHZhbGlkIHNvbGlkaXR5IHR5cGVcbiAgICAgIGNvbnN0IGlzU29saWRpdHlUeXBlID0gc29saWRpdHlUeXBlcygpLmluY2x1ZGVzKG5lc3RlZFR5cGUpO1xuICAgICAgaWYgKGlzU29saWRpdHlUeXBlKSB7XG4gICAgICAgIHNhbml0aXplZE1lc3NhZ2VbbXNnS2V5XSA9IG1zZ1ttc2dLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzYW5pdGl6ZWRNZXNzYWdlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFzc2V0SW1hZ2VVUkwoaW1hZ2UsIGlwZnNHYXRld2F5KSB7XG4gIGlmICghaW1hZ2UgfHwgIWlwZnNHYXRld2F5IHx8IHR5cGVvZiBpbWFnZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoaW1hZ2Uuc3RhcnRzV2l0aCgnaXBmczovLycpKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZElwZnNVcmwoaXBmc0dhdGV3YXksIGltYWdlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvRGVjaW1hbFBsYWNlc1JlbW92aW5nRXh0cmFaZXJvZXMoXG4gIG51bWJlcmlzaCxcbiAgbnVtYmVyT2ZEZWNpbWFsUGxhY2VzLFxuKSB7XG4gIGlmIChudW1iZXJpc2ggPT09IHVuZGVmaW5lZCB8fCBudW1iZXJpc2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHRvQmlnTnVtYmVyXG4gICAgLmRlYyh0b0JpZ051bWJlci5kZWMobnVtYmVyaXNoKS50b0ZpeGVkKG51bWJlck9mRGVjaW1hbFBsYWNlcykpXG4gICAgLnRvTnVtYmVyKCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgU0xJUC00NCBwcm90b2NvbCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWRcbiAqIGBjb2luX3R5cGVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBjb2luVHlwZSAtIFRoZSBTTElQLTQ0IGBjb2luX3R5cGVgIHZhbHVlIHdob3NlIG5hbWVcbiAqIHRvIHJldHJpZXZlLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIG5hbWUgb2YgdGhlIHByb3RvY29sIGlmIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29pblR5cGVUb1Byb3RvY29sTmFtZShjb2luVHlwZSkge1xuICBpZiAoU3RyaW5nKGNvaW5UeXBlKSA9PT0gJzEnKSB7XG4gICAgcmV0dXJuICdUZXN0IE5ldHdvcmtzJztcbiAgfVxuICByZXR1cm4gc2xpcDQ0W2NvaW5UeXBlXT8ubmFtZSB8fCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGVzdHMgXCJudWxsaXNobmVzc1wiLiBVc2VkIHRvIGd1YXJkIGEgc2VjdGlvbiBvZiBhIGNvbXBvbmVudCBmcm9tIGJlaW5nXG4gKiByZW5kZXJlZCBiYXNlZCBvbiBhIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIEEgdmFsdWUgKGxpdGVyYWxseSBhbnl0aGluZykuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbGlzaCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbmZ1cmFQcm9qZWN0SWQgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHtcbiAgU0VWRVJJVElFUyxcbiAgVFlQT0dSQVBIWSxcbiAgVEVYVF9BTElHTixcbiAgSlVTVElGWV9DT05URU5ULFxuICBESVNQTEFZLFxuICBDT0xPUlMsXG4gIEZMRVhfRElSRUNUSU9OLFxuICBBTElHTl9JVEVNUyxcbn0gZnJvbSAnLi4vLi4vLi4vaGVscGVycy9jb25zdGFudHMvZGVzaWduLXN5c3RlbSc7XG5pbXBvcnQgeyBERUZBVUxUX1JPVVRFIH0gZnJvbSAnLi4vLi4vLi4vaGVscGVycy9jb25zdGFudHMvcm91dGVzJztcbmltcG9ydCBaRU5ERVNLX1VSTFMgZnJvbSAnLi4vLi4vLi4vaGVscGVycy9jb25zdGFudHMvemVuZGVzay11cmwnO1xuaW1wb3J0IGZldGNoV2l0aENhY2hlIGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvZmV0Y2gtd2l0aC1jYWNoZSc7XG5cbmNvbnN0IFVOUkVDT0dOSVpFRF9DSEFJTiA9IHtcbiAgaWQ6ICdVTlJFQ09HTklaRURfQ0hBSU4nLFxuICBzZXZlcml0eTogU0VWRVJJVElFUy5XQVJOSU5HLFxuICBjb250ZW50OiB7XG4gICAgZWxlbWVudDogJ3NwYW4nLFxuICAgIGNoaWxkcmVuOiB7XG4gICAgICBlbGVtZW50OiAnTWV0YU1hc2tUcmFuc2xhdGlvbicsXG4gICAgICBwcm9wczoge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogJ3VucmVjb2duaXplZENoYWluJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IE1JU01BVENIRURfQ0hBSU5fUkVDT01NRU5EQVRJT04gPSB7XG4gIGlkOiAnTUlTTUFUQ0hFRF9DSEFJTl9SRUNPTU1FTkRBVElPTicsXG4gIGNvbnRlbnQ6IHtcbiAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiAnbWlzbWF0Y2hlZENoYWluUmVjb21tZW5kYXRpb24nLFxuICAgICAgICB2YXJpYWJsZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbGVtZW50OiAnYScsXG4gICAgICAgICAgICBrZXk6ICdtaXNtYXRjaGVkQ2hhaW5MaW5rJyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIGhyZWY6IFpFTkRFU0tfVVJMUy5WRVJJRllfQ1VTVE9NX05FVFdPUkssXG4gICAgICAgICAgICAgIHRhcmdldDogJ19fYmxhbmsnLFxuICAgICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgICAgICBlbGVtZW50OiAnTWV0YU1hc2tUcmFuc2xhdGlvbicsXG4gICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6ICdtaXNtYXRjaGVkQ2hhaW5MaW5rVGV4dCcsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBNSVNNQVRDSEVEX05FVFdPUktfTkFNRSA9IHtcbiAgaWQ6ICdNSVNNQVRDSEVEX05FVFdPUktfTkFNRScsXG4gIHNldmVyaXR5OiBTRVZFUklUSUVTLldBUk5JTkcsXG4gIGNvbnRlbnQ6IHtcbiAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiAnbWlzbWF0Y2hlZE5ldHdvcmtOYW1lJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IE1JU01BVENIRURfTkVUV09SS19TWU1CT0wgPSB7XG4gIGlkOiAnTUlTTUFUQ0hFRF9ORVRXT1JLX1NZTUJPTCcsXG4gIHNldmVyaXR5OiBTRVZFUklUSUVTLkRBTkdFUixcbiAgY29udGVudDoge1xuICAgIGVsZW1lbnQ6ICdzcGFuJyxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgZWxlbWVudDogJ01ldGFNYXNrVHJhbnNsYXRpb24nLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdHJhbnNsYXRpb25LZXk6ICdtaXNtYXRjaGVkTmV0d29ya1N5bWJvbCcsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBNSVNNQVRDSEVEX05FVFdPUktfUlBDID0ge1xuICBpZDogJ01JU01BVENIRURfTkVUV09SS19SUEMnLFxuICBzZXZlcml0eTogU0VWRVJJVElFUy5EQU5HRVIsXG4gIGNvbnRlbnQ6IHtcbiAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiAnbWlzbWF0Y2hlZFJwY1VybCcsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59O1xuXG5hc3luYyBmdW5jdGlvbiBnZXRBbGVydHMocGVuZGluZ0FwcHJvdmFsKSB7XG4gIGNvbnN0IGFsZXJ0cyA9IFtdO1xuICBjb25zdCBzYWZlQ2hhaW5zTGlzdCA9XG4gICAgKGF3YWl0IGZldGNoV2l0aENhY2hlKCdodHRwczovL2NoYWluaWQubmV0d29yay9jaGFpbnMuanNvbicpKSB8fCBbXTtcbiAgY29uc3QgbWF0Y2hlZENoYWluID0gc2FmZUNoYWluc0xpc3QuZmluZChcbiAgICAoY2hhaW4pID0+XG4gICAgICBjaGFpbi5jaGFpbklkID09PSBwYXJzZUludChwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuY2hhaW5JZCwgMTYpLFxuICApO1xuXG4gIGNvbnN0IG9yaWdpbklzTWV0YU1hc2sgPSBwZW5kaW5nQXBwcm92YWwub3JpZ2luID09PSAnbWV0YW1hc2snO1xuICBpZiAob3JpZ2luSXNNZXRhTWFzayAmJiBCb29sZWFuKG1hdGNoZWRDaGFpbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAobWF0Y2hlZENoYWluKSB7XG4gICAgaWYgKFxuICAgICAgbWF0Y2hlZENoYWluLm5hbWUudG9Mb3dlckNhc2UoKSAhPT1cbiAgICAgIHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5jaGFpbk5hbWUudG9Mb3dlckNhc2UoKVxuICAgICkge1xuICAgICAgYWxlcnRzLnB1c2goTUlTTUFUQ0hFRF9ORVRXT1JLX05BTUUpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBtYXRjaGVkQ2hhaW4ubmF0aXZlQ3VycmVuY3k/LnN5bWJvbCAhPT0gcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnRpY2tlclxuICAgICkge1xuICAgICAgYWxlcnRzLnB1c2goTUlTTUFUQ0hFRF9ORVRXT1JLX1NZTUJPTCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvcmlnaW4gfSA9IG5ldyBVUkwocGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnJwY1VybCk7XG4gICAgaWYgKCFtYXRjaGVkQ2hhaW4ucnBjLm1hcCgocnBjKSA9PiBuZXcgVVJMKHJwYykub3JpZ2luKS5pbmNsdWRlcyhvcmlnaW4pKSB7XG4gICAgICBhbGVydHMucHVzaChNSVNNQVRDSEVEX05FVFdPUktfUlBDKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW1hdGNoZWRDaGFpbikge1xuICAgIGFsZXJ0cy5wdXNoKFVOUkVDT0dOSVpFRF9DSEFJTik7XG4gIH1cblxuICBpZiAoYWxlcnRzLmxlbmd0aCkge1xuICAgIGFsZXJ0cy5wdXNoKE1JU01BVENIRURfQ0hBSU5fUkVDT01NRU5EQVRJT04pO1xuICB9XG5cbiAgcmV0dXJuIGFsZXJ0cztcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKHBlbmRpbmdBcHByb3ZhbCwgdCwgYWN0aW9ucywgaGlzdG9yeSkge1xuICBjb25zdCBvcmlnaW5Jc01ldGFNYXNrID0gcGVuZGluZ0FwcHJvdmFsLm9yaWdpbiA9PT0gJ21ldGFtYXNrJztcblxuICByZXR1cm4ge1xuICAgIGNvbnRlbnQ6IFtcbiAgICAgIHtcbiAgICAgICAgaGlkZTogIW9yaWdpbklzTWV0YU1hc2ssXG4gICAgICAgIGVsZW1lbnQ6ICdCb3gnLFxuICAgICAgICBrZXk6ICduZXR3b3JrLWJveCcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdGV4dEFsaWduOiBURVhUX0FMSUdOLkNFTlRFUixcbiAgICAgICAgICBkaXNwbGF5OiBESVNQTEFZLkZMRVgsXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6IEpVU1RJRllfQ09OVEVOVC5DRU5URVIsXG4gICAgICAgICAgbWFyZ2luVG9wOiA0LFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogMixcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbGVtZW50OiAnQ2hpcCcsXG4gICAgICAgICAgICBrZXk6ICduZXR3b3JrLWNoaXAnLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgbGFiZWw6IHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5jaGFpbk5hbWUsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ09MT1JTLkJBQ0tHUk9VTkRfQUxURVJOQVRJVkUsXG4gICAgICAgICAgICAgIGxlZnRJY29uVXJsOiBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuaW1hZ2VVcmwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBlbGVtZW50OiAnVHlwb2dyYXBoeScsXG4gICAgICAgIGtleTogJ3RpdGxlJyxcbiAgICAgICAgY2hpbGRyZW46IG9yaWdpbklzTWV0YU1hc2tcbiAgICAgICAgICA/IHQoJ3dhbnRUb0FkZFRoaXNOZXR3b3JrJylcbiAgICAgICAgICA6IHQoJ2FkZEV0aGVyZXVtQ2hhaW5Db25maXJtYXRpb25UaXRsZScpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHZhcmlhbnQ6IFRZUE9HUkFQSFkuSDMsXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICBib3hQcm9wczoge1xuICAgICAgICAgICAgbWFyZ2luOiBbMCwgMCwgNF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGVsZW1lbnQ6ICdUeXBvZ3JhcGh5JyxcbiAgICAgICAga2V5OiAnZGVzY3JpcHRpb24nLFxuICAgICAgICBjaGlsZHJlbjogdCgnYWRkRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvbkRlc2NyaXB0aW9uJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdmFyaWFudDogVFlQT0dSQVBIWS5INyxcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgYm94UHJvcHM6IHtcbiAgICAgICAgICAgIG1hcmdpbjogb3JpZ2luSXNNZXRhTWFzayA/IFswLCA4LCA0XSA6IFswLCAwLCA0XSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZWxlbWVudDogJ1R5cG9ncmFwaHknLFxuICAgICAgICBrZXk6ICdvbmx5LWFkZC1uZXR3b3Jrcy15b3UtdHJ1c3QnLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6ICdiJyxcbiAgICAgICAgICAgIGtleTogJ2JvbGRlZC10ZXh0JyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IG9yaWdpbklzTWV0YU1hc2sgJiYgJy13ZWJraXQtYm94JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIGAke3QoJ2FkZEV0aGVyZXVtQ2hhaW5Db25maXJtYXRpb25SaXNrcycpfSBgLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaGlkZTogIW9yaWdpbklzTWV0YU1hc2ssXG4gICAgICAgICAgICAgICAgZWxlbWVudDogJ1Rvb2x0aXAnLFxuICAgICAgICAgICAgICAgIGtleTogJ3Rvb2x0aXAtaW5mbycsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogJ21vdXNlZW50ZXInLFxuICAgICAgICAgICAgICAgICAgaHRtbDogKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTgwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAge3QoJ3NvbWVOZXR3b3Jrc01heVBvc2VTZWN1cml0eScpfXsnICd9XG4gICAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cInplbmRlc2tfcGFnZV9saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9e1pFTkRFU0tfVVJMUy5VTktOT1dOX05FVFdPUkt9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWw9XCJub3JlZmVycmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBjb2xvcjogJ3ZhcigtLWNvbG9yLXByaW1hcnktZGVmYXVsdCknIH19XG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAge3QoJ2xlYXJuTW9yZVVwcGVyQ2FzZScpfVxuICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ2knLFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdpbmZvLWNpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmFzIGZhLWluZm8tY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJzRweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yLWljb24tZGVmYXVsdCknLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWxlbWVudDogJ01ldGFNYXNrVHJhbnNsYXRpb24nLFxuICAgICAgICAgICAga2V5OiAnbGVhcm4tYWJvdXQtcmlza3MnLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6ICdhZGRFdGhlcmV1bUNoYWluQ29uZmlybWF0aW9uUmlza3NMZWFybk1vcmUnLFxuICAgICAgICAgICAgICB2YXJpYWJsZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiAnYScsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogdCgnYWRkRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvblJpc2tzTGVhcm5Nb3JlTGluaycpLFxuICAgICAgICAgICAgICAgICAga2V5OiAnYWRkRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvblJpc2tzTGVhcm5Nb3JlTGluaycsXG4gICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBaRU5ERVNLX1VSTFMuVVNFUl9HVUlERV9DVVNUT01fTkVUV09SS1MsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ19fYmxhbmsnLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHZhcmlhbnQ6IFRZUE9HUkFQSFkuSDcsXG4gICAgICAgICAgYm94UHJvcHM6IHtcbiAgICAgICAgICAgIG1hcmdpbjogb3JpZ2luSXNNZXRhTWFzayA/IFswLCA4XSA6IDAsXG4gICAgICAgICAgICBkaXNwbGF5OiBESVNQTEFZLkZMRVgsXG4gICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBGTEVYX0RJUkVDVElPTi5DT0xVTU4sXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBBTElHTl9JVEVNUy5DRU5URVIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGVsZW1lbnQ6ICdUcnVuY2F0ZWREZWZpbml0aW9uTGlzdCcsXG4gICAgICAgIGtleTogJ25ldHdvcmstZGV0YWlscycsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdGl0bGU6IHQoJ25ldHdvcmtEZXRhaWxzJyksXG4gICAgICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgICAgIFt0KCduZXR3b3JrTmFtZScpXTogdCgnbmV0d29ya05hbWVEZWZpbml0aW9uJyksXG4gICAgICAgICAgICBbdCgnbmV0d29ya1VSTCcpXTogdCgnbmV0d29ya1VSTERlZmluaXRpb24nKSxcbiAgICAgICAgICAgIFt0KCdjaGFpbklkJyldOiB0KCdjaGFpbklkRGVmaW5pdGlvbicpLFxuICAgICAgICAgICAgW3QoJ2N1cnJlbmN5U3ltYm9sJyldOiB0KCdjdXJyZW5jeVN5bWJvbERlZmluaXRpb24nKSxcbiAgICAgICAgICAgIFt0KCdibG9ja0V4cGxvcmVyVXJsJyldOiB0KCdibG9ja0V4cGxvcmVyVXJsRGVmaW5pdGlvbicpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGljdGlvbmFyeToge1xuICAgICAgICAgICAgW3QoJ25ldHdvcmtOYW1lJyldOiBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuY2hhaW5OYW1lLFxuICAgICAgICAgICAgW3QoJ25ldHdvcmtVUkwnKV06IHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5ycGNVcmw/LmluY2x1ZGVzKFxuICAgICAgICAgICAgICBgL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgID8gcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnJwY1VybC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgYC92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5ycGNVcmwsXG4gICAgICAgICAgICBbdCgnY2hhaW5JZCcpXTogcGFyc2VJbnQocGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLmNoYWluSWQsIDE2KSxcbiAgICAgICAgICAgIFt0KCdjdXJyZW5jeVN5bWJvbCcpXTogcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnRpY2tlcixcbiAgICAgICAgICAgIFt0KCdibG9ja0V4cGxvcmVyVXJsJyldOlxuICAgICAgICAgICAgICBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuYmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZWZhY2VLZXlzOiBbXG4gICAgICAgICAgICB0KCduZXR3b3JrTmFtZScpLFxuICAgICAgICAgICAgdCgnbmV0d29ya1VSTCcpLFxuICAgICAgICAgICAgdCgnY2hhaW5JZCcpLFxuICAgICAgICAgICAgdCgnY3VycmVuY3lTeW1ib2wnKSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdLFxuICAgIGFwcHJvdmFsVGV4dDogdCgnYXBwcm92ZUJ1dHRvblRleHQnKSxcbiAgICBjYW5jZWxUZXh0OiB0KCdjYW5jZWwnKSxcbiAgICBvbkFwcHJvdmU6IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGFjdGlvbnMucmVzb2x2ZVBlbmRpbmdBcHByb3ZhbChcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsLmlkLFxuICAgICAgICBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEsXG4gICAgICApO1xuICAgICAgaWYgKG9yaWdpbklzTWV0YU1hc2spIHtcbiAgICAgICAgYWN0aW9ucy5hZGRDdXN0b21OZXR3b3JrKHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YSk7XG4gICAgICAgIGhpc3RvcnkucHVzaChERUZBVUxUX1JPVVRFKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2FuY2VsOiAoKSA9PlxuICAgICAgYWN0aW9ucy5yZWplY3RQZW5kaW5nQXBwcm92YWwoXG4gICAgICAgIHBlbmRpbmdBcHByb3ZhbC5pZCxcbiAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoKS5zZXJpYWxpemUoKSxcbiAgICAgICksXG4gICAgbmV0d29ya0Rpc3BsYXk6ICFvcmlnaW5Jc01ldGFNYXNrLFxuICB9O1xufVxuXG5jb25zdCBhZGRFdGhlcmV1bUNoYWluID0ge1xuICBnZXRBbGVydHMsXG4gIGdldFZhbHVlcyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFkZEV0aGVyZXVtQ2hhaW47XG4iLCJpbXBvcnQgeyBvbWl0LCBwaWNrIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xyXG5pbXBvcnQge1xyXG4gIHJlamVjdFBlbmRpbmdBcHByb3ZhbCxcclxuICByZXNvbHZlUGVuZGluZ0FwcHJvdmFsLFxyXG4gIGFkZEN1c3RvbU5ldHdvcmssXHJcbn0gZnJvbSAnLi4vLi4vLi4vc3RvcmUvYWN0aW9ucyc7XHJcbmltcG9ydCBhZGRFdGhlcmV1bUNoYWluIGZyb20gJy4vYWRkLWV0aGVyZXVtLWNoYWluJztcclxuaW1wb3J0IHN3aXRjaEV0aGVyZXVtQ2hhaW4gZnJvbSAnLi9zd2l0Y2gtZXRoZXJldW0tY2hhaW4nO1xyXG5cblxyXG5jb25zdCBBUFBST1ZBTF9URU1QTEFURVMgPSB7XHJcbiAgW01FU1NBR0VfVFlQRS5BRERfRVRIRVJFVU1fQ0hBSU5dOiBhZGRFdGhlcmV1bUNoYWluLFxyXG4gIFtNRVNTQUdFX1RZUEUuU1dJVENIX0VUSEVSRVVNX0NIQUlOXTogc3dpdGNoRXRoZXJldW1DaGFpbixcclxuXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFRF9DT05GSVJNQVRJT05fTUVTU0FHRV9UWVBFUyA9XHJcbiAgT2JqZWN0LmtleXMoQVBQUk9WQUxfVEVNUExBVEVTKTtcclxuXHJcbmNvbnN0IEFMTE9XRURfVEVNUExBVEVfS0VZUyA9IFtcclxuICAnY29udGVudCcsXHJcbiAgJ2FwcHJvdmFsVGV4dCcsXHJcbiAgJ2NhbmNlbFRleHQnLFxyXG4gICdvbkFwcHJvdmUnLFxyXG4gICdvbkNhbmNlbCcsXHJcbiAgJ25ldHdvcmtEaXNwbGF5JyxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQZW5kaW5nQXBwcm92YWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHJhbmRvbWx5IGdlbmVyYXRlZCBpZCBvZiB0aGUgYXBwcm92YWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHNpdGUgcmVxdWVzdGluZyB0aGlzIGFwcHJvdmFsXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIC0gVGhlIHRpbWUgdGhlIGFwcHJvdmFsIHdhcyByZXF1ZXN0ZWRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBhcHByb3ZhbCBiZWluZyByZXF1ZXN0ZWRcclxuICogQHByb3BlcnR5IHtvYmplY3R9IHJlcXVlc3REYXRhIC0gVGhlIGRhdGEgc3VibWl0dGVkIHdpdGggdGhlIHJlcXVlc3RcclxuICovXHJcblxyXG4vKipcclxuICogZ2V0VGVtcGxhdGVBbGVydHMgY2FsbHMgdGhlIGdldEFsZXJ0cyBmdW5jdGlvbiBleHBvcnRlZCBieSB0aGUgdGVtcGxhdGUgaWZcclxuICogaXQgZXhpc3RzLCBhbmQgdGhlbiByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhhdCBmdW5jdGlvbi4gSW4gdGhlIGNvbmZpcm1hdGlvblxyXG4gKiBwYWdlIHRoZSBhbGVydHMgcmV0dXJuZWQgZnJvbSB0aGUgZ2V0QWxlcnRzIG1ldGhvZCB3aWxsIGJlIHNldCBpbnRvIHRoZVxyXG4gKiBhbGVydFN0YXRlIHN0YXRlIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHBlbmRpbmdBcHByb3ZhbCAtIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb25maXJtYXRpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUZW1wbGF0ZUFsZXJ0cyhwZW5kaW5nQXBwcm92YWwpIHtcclxuICBjb25zdCBmbiA9IEFQUFJPVkFMX1RFTVBMQVRFU1twZW5kaW5nQXBwcm92YWwudHlwZV0/LmdldEFsZXJ0cztcclxuICBjb25zdCByZXN1bHRzID0gZm4gPyBhd2FpdCBmbihwZW5kaW5nQXBwcm92YWwpIDogW107XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGFsZXJ0cyBtdXN0IGJlIGFuIGFycmF5LCByZWNlaXZlZDogJHtyZXN1bHRzfWApO1xyXG4gIH1cclxuICBpZiAocmVzdWx0cy5zb21lKChyZXN1bHQpID0+IHJlc3VsdD8uaWQgPT09IHVuZGVmaW5lZCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYFRlbXBsYXRlIGFsZXJ0IGVudHJpZXMgbXVzdCBiZSBvYmplY3RzIHdpdGggYW4gaWQga2V5LiBSZWNlaXZlZDogJHtyZXN1bHRzfWAsXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0cztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiBjYWxsIHRvIHJldHVybiBzdGF0ZSBtdXN0IGJlIGEgcHJvbWlzZSByZXR1cm5pbmcgZnVuY3Rpb25cclxuICogdGhpcyBcIk5PT1BcIiBpcyBoZXJlIHRvIGNvbmZvcm0gdG8gdGhlIHJlcXVpcmVtZW50cyBmb3IgdGVtcGxhdGVzIHdpdGhvdXRcclxuICogc3RhdGUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbXB0eVN0YXRlKCkge1xyXG4gIHJldHVybiB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldFRlbXBsYXRlU3RhdGUgY2FsbHMgdGhlIGdldFN0YXRlIGZ1bmN0aW9uIGV4cG9ydGVkIGJ5IHRoZSB0ZW1wbGF0ZSBpZlxyXG4gKiBpdCBleGlzdHMsIGFuZCB0aGVuIHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGF0IGZ1bmN0aW9uLiBJbiB0aGUgY29uZmlybWF0aW9uXHJcbiAqIHBhZ2UgdGhlIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBnZXRTdGF0ZSBtZXRob2Qgd2lsbCBiZSBzZXQgaW50byB0aGVcclxuICogY29uZmlybWF0aW9uU3RhdGUgc3RhdGUgb2JqZWN0LiBOb3RlLCB0aGlzIHN0YXRlIGlzIG5vdCBjb25zdW1lZCBieSB0aGUgcGFnZVxyXG4gKiBpdHNlbGYuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwZW5kaW5nQXBwcm92YWwgLSB0aGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY29uZmlybWF0aW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGVtcGxhdGVTdGF0ZShwZW5kaW5nQXBwcm92YWwpIHtcclxuICBjb25zdCBmbiA9IEFQUFJPVkFMX1RFTVBMQVRFU1twZW5kaW5nQXBwcm92YWwudHlwZV0/LmdldFN0YXRlID8/IGVtcHR5U3RhdGU7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4ocGVuZGluZ0FwcHJvdmFsKTtcclxuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIHN0YXRlIG11c3QgYmUgYW4gb2JqZWN0LCByZWNlaXZlZDogJHtyZXN1bHR9YCk7XHJcbiAgfSBlbHNlIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdlIGRvIG5vdCB3YW50IHRvIHBhc3MgdGhlIGVudGlyZSBkaXNwYXRjaCBmdW5jdGlvbiB0byB0aGUgdGVtcGxhdGUuXHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgYWN0aW9ucyB0aGF0IHdlIGdlbmVyYWxseSBjb25zaWRlclxyXG4gKiB0byBiZSBzYWZlIGZvciB0ZW1wbGF0ZXMgdG8gaW52b2tlLiBJbiB0aGUgZnV0dXJlIHdlIGNvdWxkIHB1dCB0aGVzZSBiZWhpbmRcclxuICogcGVybWlzc2lvbiBzZXRzIHNvIHRoYXQgc25hcHMgdGhhdCB3aXNoIHRvIG1hbmlwdWxhdGUgc3RhdGUgbXVzdCBhc2sgZm9yXHJcbiAqIGV4cGxpY2l0IHBlcm1pc3Npb24gdG8gZG8gc28uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIC0gUmVkdXggZGlzcGF0Y2ggZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldEF0dGVudWF0ZWREaXNwYXRjaChkaXNwYXRjaCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZWplY3RQZW5kaW5nQXBwcm92YWw6ICguLi5hcmdzKSA9PlxyXG4gICAgICBkaXNwYXRjaChyZWplY3RQZW5kaW5nQXBwcm92YWwoLi4uYXJncykpLFxyXG4gICAgcmVzb2x2ZVBlbmRpbmdBcHByb3ZhbDogKC4uLmFyZ3MpID0+XHJcbiAgICAgIGRpc3BhdGNoKHJlc29sdmVQZW5kaW5nQXBwcm92YWwoLi4uYXJncykpLFxyXG4gICAgYWRkQ3VzdG9tTmV0d29yazogKC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFkZEN1c3RvbU5ldHdvcmsoLi4uYXJncykpLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZWQgdmFsdWVzIHRvIGJlIGNvbnN1bWVkIGluIHRoZSBjb25maXJtYXRpb24gcGFnZVxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gcGVuZGluZ0FwcHJvdmFsIC0gVGhlIHBlbmRpbmcgY29uZmlybWF0aW9uIG9iamVjdFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0IC0gVHJhbnNsYXRpb24gZnVuY3Rpb25cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggLSBSZWR1eCBkaXNwYXRjaCBmdW5jdGlvblxyXG4gKiBAcGFyYW0gaGlzdG9yeVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRlbXBsYXRlVmFsdWVzKHBlbmRpbmdBcHByb3ZhbCwgdCwgZGlzcGF0Y2gsIGhpc3RvcnkpIHtcclxuICBjb25zdCBmbiA9IEFQUFJPVkFMX1RFTVBMQVRFU1twZW5kaW5nQXBwcm92YWwudHlwZV0/LmdldFZhbHVlcztcclxuICBpZiAoIWZuKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBNRVNTQUdFX1RZUEU6ICcke3BlbmRpbmdBcHByb3ZhbC50eXBlfScgaXMgbm90IHNwZWNpZmllZCBpbiBhcHByb3ZhbCB0ZW1wbGF0ZXNgLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhZmVBY3Rpb25zID0gZ2V0QXR0ZW51YXRlZERpc3BhdGNoKGRpc3BhdGNoKTtcclxuICBjb25zdCB2YWx1ZXMgPSBmbihwZW5kaW5nQXBwcm92YWwsIHQsIHNhZmVBY3Rpb25zLCBoaXN0b3J5KTtcclxuICBjb25zdCBleHRyYW5lb3VzS2V5cyA9IG9taXQodmFsdWVzLCBBTExPV0VEX1RFTVBMQVRFX0tFWVMpO1xyXG4gIGNvbnN0IHNhZmVWYWx1ZXMgPSBwaWNrKHZhbHVlcywgQUxMT1dFRF9URU1QTEFURV9LRVlTKTtcclxuICBpZiAoZXh0cmFuZW91c0tleXMubGVuZ3RoID4gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgUmVjZWl2ZWQgZXh0cmFuZW91cyBrZXlzIGZyb20gJHtcclxuICAgICAgICBwZW5kaW5nQXBwcm92YWwudHlwZVxyXG4gICAgICB9LmdldFZhbHVlcy4gVGhlc2Uga2V5cyBhcmUgbm90IHBhc3NlZCB0byB0aGUgY29uZmlybWF0aW9uIHBhZ2U6ICR7T2JqZWN0LmtleXMoXHJcbiAgICAgICAgZXh0cmFuZW91c0tleXMsXHJcbiAgICAgICl9YCxcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBzYWZlVmFsdWVzO1xyXG59XHJcbiIsImltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcclxuaW1wb3J0IHtcclxuICBDT0xPUlMsXHJcbiAgSlVTVElGWV9DT05URU5ULFxyXG4gIFNFVkVSSVRJRVMsXHJcbiAgVFlQT0dSQVBIWSxcclxufSBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL2NvbnN0YW50cy9kZXNpZ24tc3lzdGVtJztcclxuXHJcbmNvbnN0IFBFTkRJTkdfVFhfRFJPUF9OT1RJQ0UgPSB7XHJcbiAgaWQ6ICdQRU5ESU5HX1RYX0RST1BfTk9USUNFJyxcclxuICBzZXZlcml0eTogU0VWRVJJVElFUy5XQVJOSU5HLFxyXG4gIGNvbnRlbnQ6IHtcclxuICAgIGVsZW1lbnQ6ICdzcGFuJyxcclxuICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcclxuICAgICAgcHJvcHM6IHtcclxuICAgICAgICB0cmFuc2xhdGlvbktleTogJ3N3aXRjaGluZ05ldHdvcmtzQ2FuY2Vsc1BlbmRpbmdDb25maXJtYXRpb25zJyxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfSxcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEFsZXJ0cygpIHtcclxuICByZXR1cm4gW1BFTkRJTkdfVFhfRFJPUF9OT1RJQ0VdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRWYWx1ZXMocGVuZGluZ0FwcHJvdmFsLCB0LCBhY3Rpb25zKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNvbnRlbnQ6IFtcclxuICAgICAge1xyXG4gICAgICAgIGVsZW1lbnQ6ICdUeXBvZ3JhcGh5JyxcclxuICAgICAgICBrZXk6ICd0aXRsZScsXHJcbiAgICAgICAgY2hpbGRyZW46IHQoJ3N3aXRjaEV0aGVyZXVtQ2hhaW5Db25maXJtYXRpb25UaXRsZScpLFxyXG4gICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICB2YXJpYW50OiBUWVBPR1JBUEhZLkgzLFxyXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXHJcbiAgICAgICAgICBib3hQcm9wczoge1xyXG4gICAgICAgICAgICBtYXJnaW46IFswLCAwLCAyXSxcclxuICAgICAgICAgICAgcGFkZGluZzogWzAsIDQsIDAsIDRdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgZWxlbWVudDogJ1R5cG9ncmFwaHknLFxyXG4gICAgICAgIGtleTogJ2Rlc2NyaXB0aW9uJyxcclxuICAgICAgICBjaGlsZHJlbjogdCgnc3dpdGNoRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvbkRlc2NyaXB0aW9uJyksXHJcbiAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgIHZhcmlhbnQ6IFRZUE9HUkFQSFkuSDcsXHJcbiAgICAgICAgICBjb2xvcjogQ09MT1JTLlRFWFRfQUxURVJOQVRJVkUsXHJcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICBib3hQcm9wczoge1xyXG4gICAgICAgICAgICBwYWRkaW5nOiBbMCwgNCwgMCwgNF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBlbGVtZW50OiAnQm94JyxcclxuICAgICAgICBrZXk6ICdzdGF0dXMtYm94JyxcclxuICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6IEpVU1RJRllfQ09OVEVOVC5DRU5URVIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGlsZHJlbjoge1xyXG4gICAgICAgICAgZWxlbWVudDogJ0NvbmZpcm1hdGlvbk5ldHdvcmtTd2l0Y2gnLFxyXG4gICAgICAgICAga2V5OiAnbmV0d29yay1iZWluZy1zd2l0Y2hlZCcsXHJcbiAgICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICBuZXdOZXR3b3JrOiB7XHJcbiAgICAgICAgICAgICAgY2hhaW5JZDogcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLmNoYWluSWQsXHJcbiAgICAgICAgICAgICAgbmFtZTogcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLm5pY2tuYW1lLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICAgIGFwcHJvdmFsVGV4dDogdCgnc3dpdGNoTmV0d29yaycpLFxyXG4gICAgY2FuY2VsVGV4dDogdCgnY2FuY2VsJyksXHJcbiAgICBvbkFwcHJvdmU6ICgpID0+XHJcbiAgICAgIGFjdGlvbnMucmVzb2x2ZVBlbmRpbmdBcHByb3ZhbChcclxuICAgICAgICBwZW5kaW5nQXBwcm92YWwuaWQsXHJcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLFxyXG4gICAgICApLFxyXG5cclxuICAgIG9uQ2FuY2VsOiAoKSA9PlxyXG4gICAgICBhY3Rpb25zLnJlamVjdFBlbmRpbmdBcHByb3ZhbChcclxuICAgICAgICBwZW5kaW5nQXBwcm92YWwuaWQsXHJcbiAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoKS5zZXJpYWxpemUoKSxcclxuICAgICAgKSxcclxuICAgIG5ldHdvcmtEaXNwbGF5OiB0cnVlLFxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IHN3aXRjaEV0aGVyZXVtQ2hhaW4gPSB7XHJcbiAgZ2V0QWxlcnRzLFxyXG4gIGdldFZhbHVlcyxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHN3aXRjaEV0aGVyZXVtQ2hhaW47XHJcbiIsImltcG9ydCB7XHJcbiAgY29udmVyc2lvblV0aWwsXHJcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxyXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMnO1xyXG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XHJcbmltcG9ydCB7IE1JTl9HQVNfTElNSVRfSEVYIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xyXG5cclxuY29uc3QgTUlOX0dBU19QUklDRV9ERUMgPSAnMCc7XHJcbmNvbnN0IE1JTl9HQVNfUFJJQ0VfSEVYID0gcGFyc2VJbnQoTUlOX0dBU19QUklDRV9ERUMsIDEwKS50b1N0cmluZygxNik7XHJcbmNvbnN0IE1JTl9HQVNfTElNSVRfREVDID0gJzIxMDAwJztcclxuY29uc3QgTUFYX0dBU19MSU1JVF9ERUMgPSAnNzkyMDAyNyc7XHJcblxyXG5jb25zdCBISUdIX0ZFRV9XQVJOSU5HX01VTFRJUExJRVIgPSAxLjU7XHJcbmNvbnN0IE1JTl9HQVNfUFJJQ0VfR1dFSSA9IGFkZEhleFByZWZpeChcclxuICBjb252ZXJzaW9uVXRpbChNSU5fR0FTX1BSSUNFX0hFWCwge1xyXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ1dFSScsXHJcbiAgICB0b0Rlbm9taW5hdGlvbjogJ0dXRUknLFxyXG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcclxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogMSxcclxuICB9KSxcclxuKTtcclxuXHJcbmNvbnN0IE1JTl9HQVNfVE9UQUwgPSBtdWx0aXBseUN1cnJlbmNpZXMoTUlOX0dBU19MSU1JVF9IRVgsIE1JTl9HQVNfUFJJQ0VfSEVYLCB7XHJcbiAgdG9OdW1lcmljQmFzZTogJ2hleCcsXHJcbiAgbXVsdGlwbGljYW5kQmFzZTogMTYsXHJcbiAgbXVsdGlwbGllckJhc2U6IDE2LFxyXG59KTtcclxuXHJcbmNvbnN0IFRPS0VOX1RSQU5TRkVSX0ZVTkNUSU9OX1NJR05BVFVSRSA9ICcweGE5MDU5Y2JiJztcclxuY29uc3QgQ09MTEVDVElCTEVfVFJBTlNGRVJfRlJPTV9GVU5DVElPTl9TSUdOQVRVUkUgPSAnMHgyM2I4NzJkZCc7XHJcblxyXG5jb25zdCBJTlNVRkZJQ0lFTlRfRlVORFNfRVJST1IgPSAnaW5zdWZmaWNpZW50RnVuZHMnO1xyXG5jb25zdCBJTlNVRkZJQ0lFTlRfVE9LRU5TX0VSUk9SID0gJ2luc3VmZmljaWVudFRva2Vucyc7XHJcbmNvbnN0IE5FR0FUSVZFX0VUSF9FUlJPUiA9ICduZWdhdGl2ZUVUSCc7XHJcbmNvbnN0IElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfRVJST1IgPSAnaW52YWxpZEFkZHJlc3NSZWNpcGllbnQnO1xyXG5jb25zdCBJTlZBTElEX1JFQ0lQSUVOVF9BRERSRVNTX05PVF9FVEhfTkVUV09SS19FUlJPUiA9XHJcbiAgJ2ludmFsaWRBZGRyZXNzUmVjaXBpZW50Tm90RXRoTmV0d29yayc7XHJcbmNvbnN0IFJFUVVJUkVEX0VSUk9SID0gJ3JlcXVpcmVkJztcclxuY29uc3QgS05PV05fUkVDSVBJRU5UX0FERFJFU1NfV0FSTklORyA9ICdrbm93bkFkZHJlc3NSZWNpcGllbnQnO1xyXG5jb25zdCBDT05UUkFDVF9BRERSRVNTX0VSUk9SID0gJ2NvbnRyYWN0QWRkcmVzc0Vycm9yJztcclxuY29uc3QgQ09ORlVTSU5HX0VOU19FUlJPUiA9ICdjb25mdXNpbmdFbnNEb21haW4nO1xyXG5jb25zdCBFTlNfTk9fQUREUkVTU19GT1JfTkFNRSA9ICdub0FkZHJlc3NGb3JOYW1lJztcclxuY29uc3QgRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLID0gJ2Vuc05vdEZvdW5kT25DdXJyZW50TmV0d29yayc7XHJcbmNvbnN0IEVOU19OT1RfU1VQUE9SVEVEX09OX05FVFdPUksgPSAnZW5zTm90U3VwcG9ydGVkT25OZXR3b3JrJztcclxuY29uc3QgRU5TX0lMTEVHQUxfQ0hBUkFDVEVSID0gJ2Vuc0lsbGVnYWxDaGFyYWN0ZXInO1xyXG5jb25zdCBFTlNfVU5LTk9XTl9FUlJPUiA9ICdlbnNVbmtub3duRXJyb3InO1xyXG5jb25zdCBFTlNfUkVHSVNUUkFUSU9OX0VSUk9SID0gJ2Vuc1JlZ2lzdHJhdGlvbkVycm9yJztcclxuXHJcbmNvbnN0IFJFQ0lQSUVOVF9UWVBFUyA9IHtcclxuICBTTUFSVF9DT05UUkFDVDogJ1NNQVJUX0NPTlRSQUNUJyxcclxuICBOT05fQ09OVFJBQ1Q6ICdOT05fQ09OVFJBQ1QnLFxyXG59O1xyXG5cclxuZXhwb3J0IHtcclxuICBNQVhfR0FTX0xJTUlUX0RFQyxcclxuICBISUdIX0ZFRV9XQVJOSU5HX01VTFRJUExJRVIsXHJcbiAgSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SLFxyXG4gIElOU1VGRklDSUVOVF9UT0tFTlNfRVJST1IsXHJcbiAgSU5WQUxJRF9SRUNJUElFTlRfQUREUkVTU19FUlJPUixcclxuICBLTk9XTl9SRUNJUElFTlRfQUREUkVTU19XQVJOSU5HLFxyXG4gIENPTlRSQUNUX0FERFJFU1NfRVJST1IsXHJcbiAgSU5WQUxJRF9SRUNJUElFTlRfQUREUkVTU19OT1RfRVRIX05FVFdPUktfRVJST1IsXHJcbiAgRU5TX05PX0FERFJFU1NfRk9SX05BTUUsXHJcbiAgRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLLFxyXG4gIEVOU19OT1RfU1VQUE9SVEVEX09OX05FVFdPUkssXHJcbiAgRU5TX0lMTEVHQUxfQ0hBUkFDVEVSLFxyXG4gIEVOU19VTktOT1dOX0VSUk9SLFxyXG4gIEVOU19SRUdJU1RSQVRJT05fRVJST1IsXHJcbiAgTUlOX0dBU19MSU1JVF9ERUMsXHJcbiAgTUlOX0dBU19QUklDRV9ERUMsXHJcbiAgTUlOX0dBU19QUklDRV9HV0VJLFxyXG4gIE1JTl9HQVNfUFJJQ0VfSEVYLFxyXG4gIE1JTl9HQVNfVE9UQUwsXHJcbiAgTkVHQVRJVkVfRVRIX0VSUk9SLFxyXG4gIFJFUVVJUkVEX0VSUk9SLFxyXG4gIENPTkZVU0lOR19FTlNfRVJST1IsXHJcbiAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFLFxyXG4gIENPTExFQ1RJQkxFX1RSQU5TRkVSX0ZST01fRlVOQ1RJT05fU0lHTkFUVVJFLFxyXG4gIFJFQ0lQSUVOVF9UWVBFUyxcclxufTtcclxuIiwiaW1wb3J0IGFiaSBmcm9tICdldGhlcmV1bWpzLWFiaSc7XG5pbXBvcnQge1xuICBhZGRDdXJyZW5jaWVzLFxuICBjb252ZXJzaW9uVXRpbCxcbiAgY29udmVyc2lvbkdURSxcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxuICBjb252ZXJzaW9uR3JlYXRlclRoYW4sXG4gIGNvbnZlcnNpb25MZXNzVGhhbixcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5cbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uLy4uLy4uL2FwcC9zY3JpcHRzL2xpYi91dGlsJztcbmltcG9ydCB7IEVSQzIwLCBFUkM3MjEgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGNhbGNUb2tlbkFtb3VudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMnO1xuaW1wb3J0IHtcbiAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFLFxuICBDT0xMRUNUSUJMRV9UUkFOU0ZFUl9GUk9NX0ZVTkNUSU9OX1NJR05BVFVSRSxcbn0gZnJvbSAnLi9zZW5kLmNvbnN0YW50cyc7XG5cbmV4cG9ydCB7XG4gIGFkZEdhc0J1ZmZlcixcbiAgZ2V0QXNzZXRUcmFuc2ZlckRhdGEsXG4gIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEsXG4gIGdlbmVyYXRlRVJDNzIxVHJhbnNmZXJEYXRhLFxuICBpc0JhbGFuY2VTdWZmaWNpZW50LFxuICBpc1Rva2VuQmFsYW5jZVN1ZmZpY2llbnQsXG4gIGVsbGlwc2lmeSxcbn07XG5cbmZ1bmN0aW9uIGlzQmFsYW5jZVN1ZmZpY2llbnQoe1xuICBhbW91bnQgPSAnMHgwJyxcbiAgYmFsYW5jZSA9ICcweDAnLFxuICBjb252ZXJzaW9uUmF0ZSA9IDEsXG4gIGdhc1RvdGFsID0gJzB4MCcsXG4gIHByaW1hcnlDdXJyZW5jeSxcbn0pIHtcbiAgY29uc3QgdG90YWxBbW91bnQgPSBhZGRDdXJyZW5jaWVzKGFtb3VudCwgZ2FzVG90YWwsIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICB9KTtcblxuICBjb25zdCBiYWxhbmNlSXNTdWZmaWNpZW50ID0gY29udmVyc2lvbkdURShcbiAgICB7XG4gICAgICB2YWx1ZTogYmFsYW5jZSxcbiAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICBmcm9tQ3VycmVuY3k6IHByaW1hcnlDdXJyZW5jeSxcbiAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgIH0sXG4gICAge1xuICAgICAgdmFsdWU6IHRvdGFsQW1vdW50LFxuICAgICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgICAgZnJvbUN1cnJlbmN5OiBwcmltYXJ5Q3VycmVuY3ksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4gYmFsYW5jZUlzU3VmZmljaWVudDtcbn1cblxuZnVuY3Rpb24gaXNUb2tlbkJhbGFuY2VTdWZmaWNpZW50KHsgYW1vdW50ID0gJzB4MCcsIHRva2VuQmFsYW5jZSwgZGVjaW1hbHMgfSkge1xuICBjb25zdCBhbW91bnRJbkRlYyA9IGNvbnZlcnNpb25VdGlsKGFtb3VudCwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gIH0pO1xuXG4gIGNvbnN0IHRva2VuQmFsYW5jZUlzU3VmZmljaWVudCA9IGNvbnZlcnNpb25HVEUoXG4gICAge1xuICAgICAgdmFsdWU6IHRva2VuQmFsYW5jZSxcbiAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgfSxcbiAgICB7XG4gICAgICB2YWx1ZTogY2FsY1Rva2VuQW1vdW50KGFtb3VudEluRGVjLCBkZWNpbWFscyksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4gdG9rZW5CYWxhbmNlSXNTdWZmaWNpZW50O1xufVxuXG5mdW5jdGlvbiBhZGRHYXNCdWZmZXIoXG4gIGluaXRpYWxHYXNMaW1pdEhleCxcbiAgYmxvY2tHYXNMaW1pdEhleCxcbiAgYnVmZmVyTXVsdGlwbGllciA9IDEuNSxcbikge1xuICBjb25zdCB1cHBlckdhc0xpbWl0ID0gbXVsdGlwbHlDdXJyZW5jaWVzKGJsb2NrR2FzTGltaXRIZXgsIDAuOSwge1xuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxuICAgIG11bHRpcGxpZXJCYXNlOiAxMCxcbiAgICBudW1iZXJPZkRlY2ltYWxzOiAnMCcsXG4gIH0pO1xuICBjb25zdCBidWZmZXJlZEdhc0xpbWl0ID0gbXVsdGlwbHlDdXJyZW5jaWVzKFxuICAgIGluaXRpYWxHYXNMaW1pdEhleCxcbiAgICBidWZmZXJNdWx0aXBsaWVyLFxuICAgIHtcbiAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTYsXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgICBudW1iZXJPZkRlY2ltYWxzOiAnMCcsXG4gICAgfSxcbiAgKTtcblxuICAvLyBpZiBpbml0aWFsR2FzTGltaXQgaXMgYWJvdmUgYmxvY2tHYXNMaW1pdCwgZG9udCBtb2RpZnkgaXRcbiAgaWYgKFxuICAgIGNvbnZlcnNpb25HcmVhdGVyVGhhbihcbiAgICAgIHsgdmFsdWU6IGluaXRpYWxHYXNMaW1pdEhleCwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxuICAgICAgeyB2YWx1ZTogdXBwZXJHYXNMaW1pdCwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIGluaXRpYWxHYXNMaW1pdEhleDtcbiAgfVxuICAvLyBpZiBidWZmZXJlZEdhc0xpbWl0IGlzIGJlbG93IGJsb2NrR2FzTGltaXQsIHVzZSBidWZmZXJlZEdhc0xpbWl0XG4gIGlmIChcbiAgICBjb252ZXJzaW9uTGVzc1RoYW4oXG4gICAgICB7IHZhbHVlOiBidWZmZXJlZEdhc0xpbWl0LCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgICB7IHZhbHVlOiB1cHBlckdhc0xpbWl0LCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gYnVmZmVyZWRHYXNMaW1pdDtcbiAgfVxuICAvLyBvdGhlcndpc2UgdXNlIGJsb2NrR2FzTGltaXRcbiAgcmV0dXJuIHVwcGVyR2FzTGltaXQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEoe1xuICB0b0FkZHJlc3MgPSAnMHgwJyxcbiAgYW1vdW50ID0gJzB4MCcsXG4gIHNlbmRUb2tlbixcbn0pIHtcbiAgaWYgKCFzZW5kVG9rZW4pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAoXG4gICAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFICtcbiAgICBBcnJheS5wcm90b3R5cGUubWFwXG4gICAgICAuY2FsbChcbiAgICAgICAgYWJpLnJhd0VuY29kZShcbiAgICAgICAgICBbJ2FkZHJlc3MnLCAndWludDI1NiddLFxuICAgICAgICAgIFthZGRIZXhQcmVmaXgodG9BZGRyZXNzKSwgYWRkSGV4UHJlZml4KGFtb3VudCldLFxuICAgICAgICApLFxuICAgICAgICAoeCkgPT4gYDAwJHt4LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxcbiAgICAgIClcbiAgICAgIC5qb2luKCcnKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVSQzcyMVRyYW5zZmVyRGF0YSh7XG4gIHRvQWRkcmVzcyA9ICcweDAnLFxuICBmcm9tQWRkcmVzcyA9ICcweDAnLFxuICB0b2tlbklkLFxufSkge1xuICBpZiAoIXRva2VuSWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAoXG4gICAgQ09MTEVDVElCTEVfVFJBTlNGRVJfRlJPTV9GVU5DVElPTl9TSUdOQVRVUkUgK1xuICAgIEFycmF5LnByb3RvdHlwZS5tYXBcbiAgICAgIC5jYWxsKFxuICAgICAgICBhYmkucmF3RW5jb2RlKFxuICAgICAgICAgIFsnYWRkcmVzcycsICdhZGRyZXNzJywgJ3VpbnQyNTYnXSxcbiAgICAgICAgICBbYWRkSGV4UHJlZml4KGZyb21BZGRyZXNzKSwgYWRkSGV4UHJlZml4KHRvQWRkcmVzcyksIHRva2VuSWRdLFxuICAgICAgICApLFxuICAgICAgICAoeCkgPT4gYDAwJHt4LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxcbiAgICAgIClcbiAgICAgIC5qb2luKCcnKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRBc3NldFRyYW5zZmVyRGF0YSh7IHNlbmRUb2tlbiwgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgYW1vdW50IH0pIHtcbiAgc3dpdGNoIChzZW5kVG9rZW4uc3RhbmRhcmQpIHtcbiAgICBjYXNlIEVSQzcyMTpcbiAgICAgIHJldHVybiBnZW5lcmF0ZUVSQzcyMVRyYW5zZmVyRGF0YSh7XG4gICAgICAgIHRvQWRkcmVzcyxcbiAgICAgICAgZnJvbUFkZHJlc3MsXG4gICAgICAgIHRva2VuSWQ6IHNlbmRUb2tlbi50b2tlbklkLFxuICAgICAgfSk7XG4gICAgY2FzZSBFUkMyMDpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEoe1xuICAgICAgICB0b0FkZHJlc3MsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgc2VuZFRva2VuLFxuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZWxsaXBzaWZ5KHRleHQsIGZpcnN0ID0gNiwgbGFzdCA9IDQpIHtcbiAgcmV0dXJuIGAke3RleHQuc2xpY2UoMCwgZmlyc3QpfS4uLiR7dGV4dC5zbGljZSgtbGFzdCl9YDtcbn1cbiJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXBvbHlmaWxsLmpzLm1hcCJ9
