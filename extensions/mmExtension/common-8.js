LavaPack.loadBundle([
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\validate.js", { "./regex.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\regex.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uuid\dist\validate.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _regex = _interopRequireDefault(require("./regex.js"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          function validate(uuid) {
            return typeof uuid === 'string' && _regex.default.test(uuid);
          }

          var _default = validate;
          exports.default = _default;
        };
      };
    }
  }, { package: "uuid", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\version.js", { "./validate.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\validate.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\uuid\dist\version.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _validate = _interopRequireDefault(require("./validate.js"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          function version(uuid) {
            if (!(0, _validate.default)(uuid)) {
              throw TypeError('Invalid UUID');
            }

            return parseInt(uuid.substr(14, 1), 16);
          }

          var _default = version;
          exports.default = _default;
        };
      };
    }
  }, { package: "uuid", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\valid-url\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\valid-url\index.js
        return function (require, module, exports) {
          (function (module) {
            'use strict';

            module.exports.is_uri = is_iri;
            module.exports.is_http_uri = is_http_iri;
            module.exports.is_https_uri = is_https_iri;
            module.exports.is_web_uri = is_web_iri;
            // Create aliases
            module.exports.isUri = is_iri;
            module.exports.isHttpUri = is_http_iri;
            module.exports.isHttpsUri = is_https_iri;
            module.exports.isWebUri = is_web_iri;


            // private function
            // internal URI spitter method - direct from RFC 3986
            var splitUri = function (uri) {
              var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
              return splitted;
            };

            function is_iri(value) {
              if (!value) {
                return;
              }

              // check for illegal characters
              if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;

              // check for hex escapes that aren't complete
              if (/%[^0-9a-f]/i.test(value)) return;
              if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;

              var splitted = [];
              var scheme = '';
              var authority = '';
              var path = '';
              var query = '';
              var fragment = '';
              var out = '';

              // from RFC 3986
              splitted = splitUri(value);
              scheme = splitted[1];
              authority = splitted[2];
              path = splitted[3];
              query = splitted[4];
              fragment = splitted[5];

              // scheme and path are required, though the path can be empty
              if (!(scheme && scheme.length && path.length >= 0)) return;

              // if authority is present, the path must be empty or begin with a /
              if (authority && authority.length) {
                if (!(path.length === 0 || /^\//.test(path))) return;
              } else {
                // if authority is not present, the path must not start with //
                if (/^\/\//.test(path)) return;
              }

              // scheme must begin with a letter, then consist of letters, digits, +, ., or -
              if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase())) return;

              // re-assemble the URL per section 5.3 in RFC 3986
              out += scheme + ':';
              if (authority && authority.length) {
                out += '//' + authority;
              }

              out += path;

              if (query && query.length) {
                out += '?' + query;
              }

              if (fragment && fragment.length) {
                out += '#' + fragment;
              }

              return out;
            }

            function is_http_iri(value, allowHttps) {
              if (!is_iri(value)) {
                return;
              }

              var splitted = [];
              var scheme = '';
              var authority = '';
              var path = '';
              var port = '';
              var query = '';
              var fragment = '';
              var out = '';

              // from RFC 3986
              splitted = splitUri(value);
              scheme = splitted[1];
              authority = splitted[2];
              path = splitted[3];
              query = splitted[4];
              fragment = splitted[5];

              if (!scheme) return;

              if (allowHttps) {
                if (scheme.toLowerCase() != 'https') return;
              } else {
                if (scheme.toLowerCase() != 'http') return;
              }

              // fully-qualified URIs must have an authority section that is
              // a valid host
              if (!authority) {
                return;
              }

              // enable port component
              if (/:(\d+)$/.test(authority)) {
                port = authority.match(/:(\d+)$/)[0];
                authority = authority.replace(/:\d+$/, '');
              }

              out += scheme + ':';
              out += '//' + authority;

              if (port) {
                out += port;
              }

              out += path;

              if (query && query.length) {
                out += '?' + query;
              }

              if (fragment && fragment.length) {
                out += '#' + fragment;
              }

              return out;
            }

            function is_https_iri(value) {
              return is_http_iri(value, true);
            }

            function is_web_iri(value) {
              return (is_http_iri(value) || is_https_iri(value));
            }

          })(module);

        };
      };
    }
  }, { package: "valid-url", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\vm-browserify\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\vm-browserify\index.js
        return function (require, module, exports) {
          var indexOf = function (xs, item) {
            if (xs.indexOf) return xs.indexOf(item);
            else for (var i = 0; i < xs.length; i++) {
              if (xs[i] === item) return i;
            }
            return -1;
          };
          var Object_keys = function (obj) {
            if (Object.keys) return Object.keys(obj)
            else {
              var res = [];
              for (var key in obj) res.push(key)
              return res;
            }
          };

          var forEach = function (xs, fn) {
            if (xs.forEach) return xs.forEach(fn)
            else for (var i = 0; i < xs.length; i++) {
              fn(xs[i], i, xs);
            }
          };

          var defineProp = (function () {
            try {
              Object.defineProperty({}, '_', {});
              return function (obj, name, value) {
                Object.defineProperty(obj, name, {
                  writable: true,
                  enumerable: false,
                  configurable: true,
                  value: value
                })
              };
            } catch (e) {
              return function (obj, name, value) {
                obj[name] = value;
              };
            }
          }());

          var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
            'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
            'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
            'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
            'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

          function Context() { }
          Context.prototype = {};

          var Script = exports.Script = function NodeScript(code) {
            if (!(this instanceof Script)) return new Script(code);
            this.code = code;
          };

          Script.prototype.runInContext = function (context) {
            if (!(context instanceof Context)) {
              throw new TypeError("needs a 'context' argument.");
            }

            var iframe = document.createElement('iframe');
            if (!iframe.style) iframe.style = {};
            iframe.style.display = 'none';

            document.body.appendChild(iframe);

            var win = iframe.contentWindow;
            var wEval = win.eval, wExecScript = win.execScript;

            if (!wEval && wExecScript) {
              // win.(0,eval)() magically appears when this is called in IE:
              wExecScript.call(win, 'null');
              wEval = win.eval;
            }

            forEach(Object_keys(context), function (key) {
              win[key] = context[key];
            });
            forEach(globals, function (key) {
              if (context[key]) {
                win[key] = context[key];
              }
            });

            var winKeys = Object_keys(win);

            var res = wEval.call(win, this.code);

            forEach(Object_keys(win), function (key) {
              // Avoid copying circular objects like `top` and `window` by only
              // updating existing context properties or new properties in the `win`
              // that was only introduced after the eval.
              if (key in context || indexOf(winKeys, key) === -1) {
                context[key] = win[key];
              }
            });

            forEach(globals, function (key) {
              if (!(key in context)) {
                defineProp(context, key, win[key]);
              }
            });

            document.body.removeChild(iframe);

            return res;
          };

          Script.prototype.runInThisContext = function () {
            return (0, eval)(this.code); // maybe...
          };

          Script.prototype.runInNewContext = function (context) {
            var ctx = Script.createContext(context);
            var res = this.runInContext(ctx);

            if (context) {
              forEach(Object_keys(ctx), function (key) {
                context[key] = ctx[key];
              });
            }

            return res;
          };

          forEach(Object_keys(Script.prototype), function (name) {
            exports[name] = Script[name] = function (code) {
              var s = Script(code);
              return s[name].apply(s, [].slice.call(arguments, 1));
            };
          });

          exports.isContext = function (context) {
            return context instanceof Context;
          };

          exports.createScript = function (code) {
            return exports.Script(code);
          };

          exports.createContext = Script.createContext = function (context) {
            var copy = new Context();
            if (typeof context === 'object') {
              forEach(Object_keys(context), function (key) {
                copy[key] = context[key];
              });
            }
            return copy;
          };

        };
      };
    }
  }, { package: "browserify>vm-browserify", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\index.js", { "./util/create-payload.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js", "./util/rpc-cache-utils.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\rpc-cache-utils.js", "./util/stoplight.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\stoplight.js", "async/eachSeries": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\eachSeries.js", "async/map": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\map.js", "eth-block-tracker": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\polling.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js", "events": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\index.js
        return function (require, module, exports) {
          const EventEmitter = require('events').EventEmitter
          const inherits = require('util').inherits
          const ethUtil = require('ethereumjs-util')
          const EthBlockTracker = require('eth-block-tracker')
          const map = require('async/map')
          const eachSeries = require('async/eachSeries')
          const Stoplight = require('./util/stoplight.js')
          const cacheUtils = require('./util/rpc-cache-utils.js')
          const createPayload = require('./util/create-payload.js')
          const noop = function () { }

          module.exports = Web3ProviderEngine


          inherits(Web3ProviderEngine, EventEmitter)

          function Web3ProviderEngine(opts) {
            const self = this
            EventEmitter.call(self)
            self.setMaxListeners(30)
            // parse options
            opts = opts || {}

            // block polling
            const directProvider = { sendAsync: self._handleAsync.bind(self) }
            const blockTrackerProvider = opts.blockTrackerProvider || directProvider
            self._blockTracker = opts.blockTracker || new EthBlockTracker({
              provider: blockTrackerProvider,
              pollingInterval: opts.pollingInterval || 4000,
              setSkipCacheFlag: true,
            })

            // set initialization blocker
            self._ready = new Stoplight()

            // local state
            self.currentBlock = null
            self._providers = []
          }

          // public

          Web3ProviderEngine.prototype.start = function (cb = noop) {
            const self = this

            // trigger start
            self._ready.go()

            // on new block, request block body and emit as events
            self._blockTracker.on('latest', (blockNumber) => {
              // get block body
              self._getBlockByNumberWithRetry(blockNumber, (err, block) => {
                if (err) {
                  this.emit('error', err)
                  return
                }
                if (!block) {
                  console.log(block)
                  this.emit('error', new Error("Could not find block"))
                  return
                }
                const bufferBlock = toBufferBlock(block)
                // set current + emit "block" event
                self._setCurrentBlock(bufferBlock)
                // emit other events
                self.emit('rawBlock', block)
                self.emit('latest', block)
              })
            })

            // forward other events
            self._blockTracker.on('sync', self.emit.bind(self, 'sync'))
            self._blockTracker.on('error', self.emit.bind(self, 'error'))

            // update state
            self._running = true
            // signal that we started
            self.emit('start')
          }

          Web3ProviderEngine.prototype.stop = function () {
            const self = this
            // stop block polling by removing event listeners
            self._blockTracker.removeAllListeners()
            // update state
            self._running = false
            // signal that we stopped
            self.emit('stop')
          }

          Web3ProviderEngine.prototype.isRunning = function () {
            const self = this
            return self._running
          }

          Web3ProviderEngine.prototype.addProvider = function (source, index) {
            const self = this
            if (typeof index === 'number') {
              self._providers.splice(index, 0, source)
            } else {
              self._providers.push(source)
            }
            source.setEngine(this)
          }

          Web3ProviderEngine.prototype.removeProvider = function (source) {
            const self = this
            const index = self._providers.indexOf(source)
            if (index < 0) throw new Error('Provider not found.')
            self._providers.splice(index, 1)
          }

          Web3ProviderEngine.prototype.send = function (payload) {
            throw new Error('Web3ProviderEngine does not support synchronous requests.')
          }

          Web3ProviderEngine.prototype.sendAsync = function (payload, cb) {
            const self = this
            self._ready.await(function () {

              if (Array.isArray(payload)) {
                // handle batch
                map(payload, self._handleAsync.bind(self), cb)
              } else {
                // handle single
                self._handleAsync(payload, cb)
              }

            })
          }

          // private

          Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function (blockNumber, cb) {
            const self = this

            let retriesRemaining = 5

            attemptRequest()
            return

            function attemptRequest() {
              self._getBlockByNumber(blockNumber, afterRequest)
            }

            function afterRequest(err, block) {
              // anomalous error occurred
              if (err) return cb(err)
              // block not ready yet
              if (!block) {
                if (retriesRemaining > 0) {
                  // wait 1s then try again
                  retriesRemaining--
                  setTimeout(function () {
                    attemptRequest()
                  }, 1000)
                  return
                } else {
                  // give up, return a null block
                  cb(null, null)
                  return
                }
              }
              // otherwise return result
              cb(null, block)
              return
            }
          }


          Web3ProviderEngine.prototype._getBlockByNumber = function (blockNumber, cb) {
            const req = createPayload({ method: 'eth_getBlockByNumber', params: [blockNumber, false], skipCache: true })
            this._handleAsync(req, (err, res) => {
              if (err) return cb(err)
              return cb(null, res.result)
            })
          }

          Web3ProviderEngine.prototype._handleAsync = function (payload, finished) {
            var self = this
            var currentProvider = -1
            var result = null
            var error = null

            var stack = []

            next()

            function next(after) {
              currentProvider += 1
              stack.unshift(after)

              // Bubbled down as far as we could go, and the request wasn't
              // handled. Return an error.
              if (currentProvider >= self._providers.length) {
                end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'))
              } else {
                try {
                  var provider = self._providers[currentProvider]
                  provider.handleRequest(payload, next, end)
                } catch (e) {
                  end(e)
                }
              }
            }

            function end(_error, _result) {
              error = _error
              result = _result

              eachSeries(stack, function (fn, callback) {

                if (fn) {
                  fn(error, result, callback)
                } else {
                  callback()
                }
              }, function () {

                var resultObj = {
                  id: payload.id,
                  jsonrpc: payload.jsonrpc,
                  result: result
                }

                if (error != null) {
                  resultObj.error = {
                    message: error.stack || error.message || error,
                    code: -32000
                  }
                  // respond with both error formats
                  finished(error, resultObj)
                } else {
                  finished(null, resultObj)
                }
              })
            }
          }

          //
          // from remote-data
          //

          Web3ProviderEngine.prototype._setCurrentBlock = function (block) {
            const self = this
            self.currentBlock = block
            self.emit('block', block)
          }

          // util

          function toBufferBlock(jsonBlock) {
            return {
              number: ethUtil.toBuffer(jsonBlock.number),
              hash: ethUtil.toBuffer(jsonBlock.hash),
              parentHash: ethUtil.toBuffer(jsonBlock.parentHash),
              nonce: ethUtil.toBuffer(jsonBlock.nonce),
              mixHash: ethUtil.toBuffer(jsonBlock.mixHash),
              sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),
              logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),
              transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),
              stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),
              receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
              miner: ethUtil.toBuffer(jsonBlock.miner),
              difficulty: ethUtil.toBuffer(jsonBlock.difficulty),
              totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),
              size: ethUtil.toBuffer(jsonBlock.size),
              extraData: ethUtil.toBuffer(jsonBlock.extraData),
              gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),
              gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),
              timestamp: ethUtil.toBuffer(jsonBlock.timestamp),
              transactions: jsonBlock.transactions,
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\base.js", { "eth-query": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-query\\index.js", "pify": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\pify\\index.js", "safe-event-emitter": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-event-emitter\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-block-tracker\src\base.js
        return function (require, module, exports) {
          const EthQuery = require('eth-query')
          const pify = require('pify')
          const SafeEventEmitter = require('safe-event-emitter')

          const sec = 1000

          const calculateSum = (accumulator, currentValue) => accumulator + currentValue
          const blockTrackerEvents = ['sync', 'latest']

          class BaseBlockTracker extends SafeEventEmitter {

            //
            // public
            //

            constructor(opts = {}) {
              super()
              // config
              this._blockResetDuration = opts.blockResetDuration || 20 * sec
              // state
              this._blockResetTimeout
              this._currentBlock = null
              this._isRunning = false
              // bind functions for internal use
              this._onNewListener = this._onNewListener.bind(this)
              this._onRemoveListener = this._onRemoveListener.bind(this)
              this._resetCurrentBlock = this._resetCurrentBlock.bind(this)
              // listen for handler changes
              this._setupInternalEvents()
            }

            isRunning() {
              return this._isRunning
            }

            getCurrentBlock() {
              return this._currentBlock
            }

            async getLatestBlock() {
              // return if available
              if (this._currentBlock) return this._currentBlock
              // wait for a new latest block
              const latestBlock = await new Promise(resolve => this.once('latest', resolve))
              // return newly set current block
              return latestBlock
            }

            // dont allow module consumer to remove our internal event listeners
            removeAllListeners(eventName) {
              // perform default behavior, preserve fn arity
              if (eventName) {
                super.removeAllListeners(eventName)
              } else {
                super.removeAllListeners()
              }
              // re-add internal events
              this._setupInternalEvents()
              // trigger stop check just in case
              this._onRemoveListener()
            }

            //
            // to be implemented in subclass
            //

            _start() {
              // default behavior is noop
            }

            _end() {
              // default behavior is noop
            }

            //
            // private
            //

            _setupInternalEvents() {
              // first remove listeners for idempotence
              this.removeListener('newListener', this._onNewListener)
              this.removeListener('removeListener', this._onRemoveListener)
              // then add them
              this.on('newListener', this._onNewListener)
              this.on('removeListener', this._onRemoveListener)
            }

            _onNewListener(eventName, handler) {
              // `newListener` is called *before* the listener is added
              if (!blockTrackerEvents.includes(eventName)) return
              this._maybeStart()
            }

            _onRemoveListener(eventName, handler) {
              // `removeListener` is called *after* the listener is removed
              if (this._getBlockTrackerEventCount() > 0) return
              this._maybeEnd()
            }

            _maybeStart() {
              if (this._isRunning) return
              this._isRunning = true
              // cancel setting latest block to stale
              this._cancelBlockResetTimeout()
              this._start()
            }

            _maybeEnd() {
              if (!this._isRunning) return
              this._isRunning = false
              this._setupBlockResetTimeout()
              this._end()
            }

            _getBlockTrackerEventCount() {
              return blockTrackerEvents
                .map(eventName => this.listenerCount(eventName))
                .reduce(calculateSum)
            }

            _newPotentialLatest(newBlock) {
              const currentBlock = this._currentBlock
              // only update if blok number is higher
              if (currentBlock && (hexToInt(newBlock) <= hexToInt(currentBlock))) return
              this._setCurrentBlock(newBlock)
            }

            _setCurrentBlock(newBlock) {
              const oldBlock = this._currentBlock
              this._currentBlock = newBlock
              this.emit('latest', newBlock)
              this.emit('sync', { oldBlock, newBlock })
            }

            _setupBlockResetTimeout() {
              // clear any existing timeout
              this._cancelBlockResetTimeout()
              // clear latest block when stale
              this._blockResetTimeout = setTimeout(this._resetCurrentBlock, this._blockResetDuration)
              // nodejs - dont hold process open
              if (this._blockResetTimeout.unref) {
                this._blockResetTimeout.unref()
              }
            }

            _cancelBlockResetTimeout() {
              clearTimeout(this._blockResetTimeout)
            }

            _resetCurrentBlock() {
              this._currentBlock = null
            }

          }

          module.exports = BaseBlockTracker

          function hexToInt(hexInt) {
            return Number.parseInt(hexInt, 16)
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-block-tracker", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\polling.js", { "./base": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-block-tracker\\src\\base.js", "pify": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\pify\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-block-tracker\src\polling.js
        return function (require, module, exports) {
          const pify = require('pify')
          const BaseBlockTracker = require('./base')

          const sec = 1000

          class PollingBlockTracker extends BaseBlockTracker {

            constructor(opts = {}) {
              // parse + validate args
              if (!opts.provider) throw new Error('PollingBlockTracker - no provider specified.')
              const pollingInterval = opts.pollingInterval || 20 * sec
              const retryTimeout = opts.retryTimeout || pollingInterval / 10
              const keepEventLoopActive = opts.keepEventLoopActive !== undefined ? opts.keepEventLoopActive : true
              const setSkipCacheFlag = opts.setSkipCacheFlag || false
              // BaseBlockTracker constructor
              super(Object.assign({
                blockResetDuration: pollingInterval,
              }, opts))
              // config
              this._provider = opts.provider
              this._pollingInterval = pollingInterval
              this._retryTimeout = retryTimeout
              this._keepEventLoopActive = keepEventLoopActive
              this._setSkipCacheFlag = setSkipCacheFlag
            }

            //
            // public
            //

            // trigger block polling
            async checkForLatestBlock() {
              await this._updateLatestBlock()
              return await this.getLatestBlock()
            }

            //
            // private
            //

            _start() {
              this._performSync().catch(err => this.emit('error', err))
            }

            async _performSync() {
              while (this._isRunning) {
                try {
                  await this._updateLatestBlock()
                  await timeout(this._pollingInterval, !this._keepEventLoopActive)
                } catch (err) {
                  const newErr = new Error(`PollingBlockTracker - encountered an error while attempting to update latest block:\n${err.stack}`)
                  try {
                    this.emit('error', newErr)
                  } catch (emitErr) {
                    console.error(newErr)
                  }
                  await timeout(this._retryTimeout, !this._keepEventLoopActive)
                }
              }
            }

            async _updateLatestBlock() {
              // fetch + set latest block
              const latestBlock = await this._fetchLatestBlock()
              this._newPotentialLatest(latestBlock)
            }

            async _fetchLatestBlock() {
              const req = { jsonrpc: "2.0", id: 1, method: 'eth_blockNumber', params: [] }
              if (this._setSkipCacheFlag) req.skipCache = true
              const res = await pify((cb) => this._provider.sendAsync(req, cb))()
              if (res.error) throw new Error(`PollingBlockTracker - encountered error fetching block:\n${res.error}`)
              return res.result
            }

          }

          module.exports = PollingBlockTracker

          function timeout(duration, unref) {
            return new Promise(resolve => {
              const timoutRef = setTimeout(resolve, duration)
              // don't keep process open
              if (timoutRef.unref && unref) {
                timoutRef.unref()
              }
            })
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-block-tracker", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\block-cache.js", { "./cache-utils.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\cache-utils.js", "json-rpc-engine/src/createAsyncMiddleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\block-cache.js
        return function (require, module, exports) {
          const cacheUtils = require('./cache-utils.js')
          const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
          // `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925
          const emptyValues = [undefined, null, '\u003cnil\u003e']

          module.exports = createBlockCacheMiddleware


          function createBlockCacheMiddleware(opts = {}) {
            // validate options
            const { blockTracker } = opts
            if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')

            // create caching strategies
            const blockCache = new BlockCacheStrategy()
            const strategies = {
              perma: blockCache,
              block: blockCache,
              fork: blockCache,
            }

            return createAsyncMiddleware(async (req, res, next) => {
              // allow cach to be skipped if so specified
              if (req.skipCache) {
                return next()
              }
              // check type and matching strategy
              const type = cacheUtils.cacheTypeForPayload(req)
              const strategy = strategies[type]
              // If there's no strategy in place, pass it down the chain.
              if (!strategy) {
                return next()
              }
              // If the strategy can't cache this request, ignore it.
              if (!strategy.canCacheRequest(req)) {
                return next()
              }

              // get block reference (number or keyword)
              let blockTag = cacheUtils.blockTagForPayload(req)
              if (!blockTag) blockTag = 'latest'

              // get exact block number
              let requestedBlockNumber
              if (blockTag === 'earliest') {
                // this just exists for symmetry with "latest"
                requestedBlockNumber = '0x00'
              } else if (blockTag === 'latest') {
                // fetch latest block number
                const latestBlockNumber = await blockTracker.getLatestBlock()
                // clear all cache before latest block
                blockCache.clearBefore(latestBlockNumber)
                requestedBlockNumber = latestBlockNumber
              } else {
                // We have a hex number
                requestedBlockNumber = blockTag
              }

              // end on a hit, continue on a miss
              const cacheResult = await strategy.get(req, requestedBlockNumber)
              if (cacheResult === undefined) {
                // cache miss
                // wait for other middleware to handle request
                await next()
                // add result to cache
                await strategy.set(req, requestedBlockNumber, res.result)
              } else {
                // fill in result from cache
                res.result = cacheResult
              }
            })
          }


          //
          // Cache Strategies
          //

          class BlockCacheStrategy {

            constructor() {
              this.cache = {}
            }

            getBlockCacheForPayload(payload, blockNumberHex) {
              const blockNumber = Number.parseInt(blockNumberHex, 16)
              let blockCache = this.cache[blockNumber]
              // create new cache if necesary
              if (!blockCache) {
                const newCache = {}
                this.cache[blockNumber] = newCache
                blockCache = newCache
              }
              return blockCache
            }

            async get(payload, requestedBlockNumber) {
              // lookup block cache
              const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)
              if (!blockCache) return
              // lookup payload in block cache
              const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)
              const cached = blockCache[identifier]
              // may be undefined
              return cached
            }

            async set(payload, requestedBlockNumber, result) {
              // check if we can cached this result
              const canCache = this.canCacheResult(payload, result)
              if (!canCache) return
              // set the value in the cache
              const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)
              const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)
              blockCache[identifier] = result
            }

            canCacheRequest(payload) {
              // check request method
              if (!cacheUtils.canCache(payload)) {
                return false
              }
              // check blockTag
              const blockTag = cacheUtils.blockTagForPayload(payload)
              if (blockTag === 'pending') {
                return false
              }
              // can be cached
              return true
            }

            canCacheResult(payload, result) {
              // never cache empty values (e.g. undefined)
              if (emptyValues.includes(result)) return
              // check if transactions have block reference before caching
              if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {
                if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {
                  return false
                }
              }
              // otherwise true
              return true
            }

            // removes all block caches with block number lower than `oldBlockHex`
            clearBefore(oldBlockHex) {
              const self = this
              const oldBlockNumber = Number.parseInt(oldBlockHex, 16)
              // clear old caches
              Object.keys(self.cache)
                .map(Number)
                .filter(num => num < oldBlockNumber)
                .forEach(num => delete self.cache[num])
            }

          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\cache-utils.js", { "json-stable-stringify": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-stable-stringify\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\cache-utils.js
        return function (require, module, exports) {
          const stringify = require('json-stable-stringify')

          module.exports = {
            cacheIdentifierForPayload: cacheIdentifierForPayload,
            canCache: canCache,
            blockTagForPayload: blockTagForPayload,
            paramsWithoutBlockTag: paramsWithoutBlockTag,
            blockTagParamIndex: blockTagParamIndex,
            cacheTypeForPayload: cacheTypeForPayload
          }

          function cacheIdentifierForPayload(payload, skipBlockRef) {
            const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params
            if (canCache(payload)) {
              return payload.method + ':' + stringify(simpleParams)
            } else {
              return null
            }
          }

          function canCache(payload) {
            return cacheTypeForPayload(payload) !== 'never'
          }

          function blockTagForPayload(payload) {
            let index = blockTagParamIndex(payload)

            // Block tag param not passed.
            if (index >= payload.params.length) {
              return null
            }

            return payload.params[index]
          }

          function paramsWithoutBlockTag(payload) {
            const index = blockTagParamIndex(payload)

            // Block tag param not passed.
            if (index >= payload.params.length) {
              return payload.params
            }

            // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
            if (payload.method === 'eth_getBlockByNumber') {
              return payload.params.slice(1)
            }

            return payload.params.slice(0, index)
          }

          function blockTagParamIndex(payload) {
            switch (payload.method) {
              // blockTag is at index 2
              case 'eth_getStorageAt':
                return 2
              // blockTag is at index 1
              case 'eth_getBalance':
              case 'eth_getCode':
              case 'eth_getTransactionCount':
              case 'eth_call':
                return 1
              // blockTag is at index 0
              case 'eth_getBlockByNumber':
                return 0
              // there is no blockTag
              default:
                return undefined
            }
          }

          function cacheTypeForPayload(payload) {
            switch (payload.method) {
              // cache permanently
              case 'web3_clientVersion':
              case 'web3_sha3':
              case 'eth_protocolVersion':
              case 'eth_getBlockTransactionCountByHash':
              case 'eth_getUncleCountByBlockHash':
              case 'eth_getCode':
              case 'eth_getBlockByHash':
              case 'eth_getTransactionByHash':
              case 'eth_getTransactionByBlockHashAndIndex':
              case 'eth_getTransactionReceipt':
              case 'eth_getUncleByBlockHashAndIndex':
              case 'eth_getCompilers':
              case 'eth_compileLLL':
              case 'eth_compileSolidity':
              case 'eth_compileSerpent':
              case 'shh_version':
              case 'test_permaCache':
                return 'perma'

              // cache until fork
              case 'eth_getBlockByNumber':
              case 'eth_getBlockTransactionCountByNumber':
              case 'eth_getUncleCountByBlockNumber':
              case 'eth_getTransactionByBlockNumberAndIndex':
              case 'eth_getUncleByBlockNumberAndIndex':
              case 'test_forkCache':
                return 'fork'

              // cache for block
              case 'eth_gasPrice':
              case 'eth_blockNumber':
              case 'eth_getBalance':
              case 'eth_getStorageAt':
              case 'eth_getTransactionCount':
              case 'eth_call':
              case 'eth_estimateGas':
              case 'eth_getFilterLogs':
              case 'eth_getLogs':
              case 'test_blockCache':
                return 'block'

              // never cache
              case 'net_version':
              case 'net_peerCount':
              case 'net_listening':
              case 'eth_syncing':
              case 'eth_sign':
              case 'eth_coinbase':
              case 'eth_mining':
              case 'eth_hashrate':
              case 'eth_accounts':
              case 'eth_sendTransaction':
              case 'eth_sendRawTransaction':
              case 'eth_newFilter':
              case 'eth_newBlockFilter':
              case 'eth_newPendingTransactionFilter':
              case 'eth_uninstallFilter':
              case 'eth_getFilterChanges':
              case 'eth_getWork':
              case 'eth_submitWork':
              case 'eth_submitHashrate':
              case 'db_putString':
              case 'db_getString':
              case 'db_putHex':
              case 'db_getHex':
              case 'shh_post':
              case 'shh_newIdentity':
              case 'shh_hasIdentity':
              case 'shh_newGroup':
              case 'shh_addToGroup':
              case 'shh_newFilter':
              case 'shh_uninstallFilter':
              case 'shh_getFilterChanges':
              case 'shh_getMessages':
              case 'test_neverCache':
                return 'never'
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\fetch.js", { "btoa": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\btoa\\index.js", "eth-rpc-errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\index.js", "json-rpc-engine/src/createAsyncMiddleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js", "node-fetch": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\node-fetch\\browser.js", "url": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\url\\url.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\fetch.js
        return function (require, module, exports) {
          const fetch = global.fetch || require('node-fetch')
          const url = require('url')
          const { ethErrors } = require('eth-rpc-errors')
          const btoa = require('btoa')
          const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')


          module.exports = createFetchMiddleware
          module.exports.createFetchConfigFromReq = createFetchConfigFromReq

          const RETRIABLE_ERRORS = [
            // ignore server overload errors
            'Gateway timeout',
            'ETIMEDOUT',
            // ignore server sent html error pages
            // or truncated json responses
            'failed to parse response body',
            // ignore errors where http req failed to establish
            'Failed to fetch',
          ]

          function createFetchMiddleware({ rpcUrl, originHttpHeaderKey }) {
            return createAsyncMiddleware(async (req, res, next) => {
              const { fetchUrl, fetchParams } = createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey })

              // attempt request multiple times
              const maxAttempts = 5
              const retryInterval = 1000
              for (let attempt = 0; attempt < maxAttempts; attempt++) {
                try {
                  const fetchRes = await fetch(fetchUrl, fetchParams)
                  // check for http errrors
                  checkForHttpErrors(fetchRes)
                  // parse response body
                  const rawBody = await fetchRes.text()
                  let fetchBody
                  try {
                    fetchBody = JSON.parse(rawBody)
                  } catch (_) {
                    throw new Error(`FetchMiddleware - failed to parse response body: "${rawBody}"`)
                  }
                  const result = parseResponse(fetchRes, fetchBody)
                  // set result and exit retry loop
                  res.result = result
                  return
                } catch (err) {
                  const errMsg = err.toString()
                  const isRetriable = RETRIABLE_ERRORS.some(phrase => errMsg.includes(phrase))
                  // re-throw error if not retriable
                  if (!isRetriable) throw err
                }
                // delay before retrying
                await timeout(retryInterval)
              }
            })
          }

          function checkForHttpErrors(fetchRes) {
            // check for errors
            switch (fetchRes.status) {
              case 405:
                throw ethErrors.rpc.methodNotFound()

              case 418:
                throw createRatelimitError()

              case 503:
              case 504:
                throw createTimeoutError()
            }
          }

          function parseResponse(fetchRes, body) {
            // check for error code
            if (fetchRes.status !== 200) {
              throw ethErrors.rpc.internal({
                message: `Non-200 status code: '${fetchRes.status}'`,
                data: body,
              })
            }
            // check for rpc error
            if (body.error) throw ethErrors.rpc.internal({
              data: body.error,
            })
            // return successful result
            return body.result
          }

          function createFetchConfigFromReq({ req, rpcUrl, originHttpHeaderKey }) {
            const parsedUrl = url.parse(rpcUrl)
            const fetchUrl = normalizeUrlFromParsed(parsedUrl)

            // prepare payload
            // copy only canonical json rpc properties
            const payload = {
              id: req.id,
              jsonrpc: req.jsonrpc,
              method: req.method,
              params: req.params,
            }

            // extract 'origin' parameter from request
            const originDomain = req.origin

            // serialize request body
            const serializedPayload = JSON.stringify(payload)

            // configure fetch params
            const fetchParams = {
              method: 'POST',
              headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
              },
              body: serializedPayload,
            }

            // encoded auth details as header (not allowed in fetch url)
            if (parsedUrl.auth) {
              const encodedAuth = btoa(parsedUrl.auth)
              fetchParams.headers['Authorization'] = `Basic ${encodedAuth}`
            }

            // optional: add request origin as header
            if (originHttpHeaderKey && originDomain) {
              fetchParams.headers[originHttpHeaderKey] = originDomain
            }

            return { fetchUrl, fetchParams }
          }

          function normalizeUrlFromParsed(parsedUrl) {
            let result = ''
            result += parsedUrl.protocol
            if (parsedUrl.slashes) result += '//'
            result += parsedUrl.hostname
            if (parsedUrl.port) {
              result += `:${parsedUrl.port}`
            }
            result += `${parsedUrl.path}`
            return result
          }

          function createRatelimitError() {
            return ethErrors.rpc.internal({ message: `Request is being rate limited.` })
          }

          function createTimeoutError() {
            let msg = `Gateway timeout. The request took too long to process. `
            msg += `This can happen when querying logs over too wide a block range.`
            return ethErrors.rpc.internal({ message: msg })
          }

          function timeout(duration) {
            return new Promise(resolve => setTimeout(resolve, duration))
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\inflight-cache.js", { "./cache-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\cache-utils.js", "clone": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\clone\\clone.js", "json-rpc-engine/src/createAsyncMiddleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-json-rpc-middleware\inflight-cache.js
        return function (require, module, exports) {
          const clone = require('clone')
          const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
          const cacheIdentifierForPayload = require('./cache-utils').cacheIdentifierForPayload

          module.exports = createInflightCache


          function createInflightCache() {
            const inflightRequests = {}

            return createAsyncMiddleware(async (req, res, next) => {
              // allow cach to be skipped if so specified
              if (req.skipCache) return next()
              // get cacheId, if cacheable
              const cacheId = cacheIdentifierForPayload(req)
              // if not cacheable, skip
              if (!cacheId) return next()
              // check for matching requests
              let activeRequestHandlers = inflightRequests[cacheId]
              // if found, wait for the active request to be handled
              if (activeRequestHandlers) {
                // setup the response listener and wait for it to be called
                // it will handle copying the result and request fields
                await createActiveRequestHandler(res, activeRequestHandlers)
                return
              }
              // setup response handler array for subsequent requests
              activeRequestHandlers = []
              inflightRequests[cacheId] = activeRequestHandlers
              // allow request to be handled normally
              await next()
              // clear inflight requests
              delete inflightRequests[cacheId]
              // schedule activeRequestHandlers to be handled
              handleActiveRequest(res, activeRequestHandlers)
              // complete
              return
            })

            function createActiveRequestHandler(res, activeRequestHandlers) {
              const { resolve, promise } = deferredPromise()
              activeRequestHandlers.push((handledRes) => {
                // append a copy of the result and error to the response
                res.result = clone(handledRes.result)
                res.error = clone(handledRes.error)
                resolve()
              })
              return promise
            }

            function handleActiveRequest(res, activeRequestHandlers) {
              // use setTimeout so we can resolve our original request first
              setTimeout(() => {
                activeRequestHandlers.forEach((handler) => {
                  try {
                    handler(res)
                  } catch (err) {
                    // catch error so all requests are handled correctly
                    console.error(err)
                  }
                })
              })
            }
          }

          function deferredPromise() {
            let resolve
            const promise = new Promise(_resolve => { resolve = _resolve })
            return { resolve, promise }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\index.js", { "./src/classes": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js", "./src/errorCodes.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json", "./src/errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errors.js", "./src/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\utils.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\index.js
        return function (require, module, exports) {

          const { EthereumRpcError, EthereumProviderError } = require('./src/classes')
          const {
            serializeError, getMessageFromCode,
          } = require('./src/utils')
          const ethErrors = require('./src/errors')
          const ERROR_CODES = require('./src/errorCodes.json')

          module.exports = {
            ethErrors,
            EthereumRpcError,
            EthereumProviderError,
            serializeError,
            getMessageFromCode,

            /** @type ErrorCodes */
            ERROR_CODES,
          }

          // Types

          /**
           * @typedef {Object} EthereumProviderErrorCodes
           * @property {number} userRejectedRequest
           * @property {number} unauthorized
           * @property {number} unsupportedMethod
           * @property {number} disconnected
           * @property {number} chainDisconnected
           */

          /**
           * @typedef {Object} EthereumRpcErrorCodes
           * @property {number} parse
           * @property {number} invalidRequest
           * @property {number} invalidParams
           * @property {number} methodNotFound
           * @property {number} limitExceeded
           * @property {number} internal
           * @property {number} invalidInput
           * @property {number} resourceNotFound
           * @property {number} resourceUnavailable
           * @property {number} transactionRejected
           * @property {number} methodNotSupported
           */

          /**
           * @typedef ErrorCodes
           * @property {EthereumRpcErrorCodes} rpc
           * @property {EthereumProviderErrorCodes} provider
           */

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-rpc-errors", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js", { "fast-safe-stringify": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\fast-safe-stringify\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\classes.js
        return function (require, module, exports) {

          const safeStringify = require('fast-safe-stringify')

          /**
           * @class JsonRpcError
           * Error subclass implementing JSON RPC 2.0 errors and Ethereum RPC errors
           * per EIP 1474.
           * Permits any integer error code.
           */
          class EthereumRpcError extends Error {

            /**
             * Create an Ethereum JSON RPC error.
             *
             * @param {number} code - The integer error code.
             * @param {string} message - The string message.
             * @param {any} [data] - The error data.
             */
            constructor(code, message, data) {

              if (!Number.isInteger(code)) {
                throw new Error(
                  '"code" must be an integer.',
                )
              }
              if (!message || typeof message !== 'string') {
                throw new Error(
                  '"message" must be a nonempty string.',
                )
              }

              super(message)
              this.code = code
              if (data !== undefined) {
                this.data = data
              }
            }

            /**
             * Returns a plain object with all public class properties.
             *
             * @returns {object} The serialized error.
             */
            serialize() {
              const serialized = {
                code: this.code,
                message: this.message,
              }
              if (this.data !== undefined) {
                serialized.data = this.data
              }
              if (this.stack) {
                serialized.stack = this.stack
              }
              return serialized
            }

            /**
             * Return a string representation of the serialized error, omitting
             * any circular references.
             *
             * @returns {string} The serialized error as a string.
             */
            toString() {
              return safeStringify(
                this.serialize(),
                stringifyReplacer,
                2,
              )
            }
          }

          /**
           * @class EthereumRpcError
           * Error subclass implementing Ethereum Provider errors per EIP 1193.
           * Permits integer error codes in the [ 1000 <= 4999 ] range.
           */
          class EthereumProviderError extends EthereumRpcError {

            /**
             * Create an Ethereum JSON RPC error.
             *
             * @param {number} code - The integer error code, in the [ 1000 <= 4999 ] range.
             * @param {string} message - The string message.
             * @param {any} [data] - The error data.
             */
            constructor(code, message, data) {

              if (!isValidEthProviderCode(code)) {
                throw new Error(
                  '"code" must be an integer such that: 1000 <= code <= 4999',
                )
              }

              super(code, message, data)
            }
          }

          // Internal

          function isValidEthProviderCode(code) {
            return Number.isInteger(code) && code >= 1000 && code <= 4999
          }

          function stringifyReplacer(_, value) {
            if (value === '[Circular]') {
              return undefined
            }
            return value
          }

          // Exports

          module.exports = {
            EthereumRpcError,
            EthereumProviderError,
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-rpc-errors", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\errorCodes.json
        return function (require, module, exports) {
          module.exports = {
            "rpc": {
              "invalidInput": -32000,
              "resourceNotFound": -32001,
              "resourceUnavailable": -32002,
              "transactionRejected": -32003,
              "methodNotSupported": -32004,
              "limitExceeded": -32005,
              "parse": -32700,
              "invalidRequest": -32600,
              "methodNotFound": -32601,
              "invalidParams": -32602,
              "internal": -32603
            },
            "provider": {
              "userRejectedRequest": 4001,
              "unauthorized": 4100,
              "unsupportedMethod": 4200,
              "disconnected": 4900,
              "chainDisconnected": 4901
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-rpc-errors", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorValues.json", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\errorValues.json
        return function (require, module, exports) {
          module.exports = {
            "-32700": {
              "standard": "JSON RPC 2.0",
              "message": "Invalid JSON was received by the server. An error occurred on the server while parsing the JSON text."
            },
            "-32600": {
              "standard": "JSON RPC 2.0",
              "message": "The JSON sent is not a valid Request object."
            },
            "-32601": {
              "standard": "JSON RPC 2.0",
              "message": "The method does not exist / is not available."
            },
            "-32602": {
              "standard": "JSON RPC 2.0",
              "message": "Invalid method parameter(s)."
            },
            "-32603": {
              "standard": "JSON RPC 2.0",
              "message": "Internal JSON-RPC error."
            },
            "-32000": {
              "standard": "EIP 1474",
              "message": "Invalid input."
            },
            "-32001": {
              "standard": "EIP 1474",
              "message": "Resource not found."
            },
            "-32002": {
              "standard": "EIP 1474",
              "message": "Resource unavailable."
            },
            "-32003": {
              "standard": "EIP 1474",
              "message": "Transaction rejected."
            },
            "-32004": {
              "standard": "EIP 1474",
              "message": "Method not supported."
            },
            "-32005": {
              "standard": "EIP 1474",
              "message": "Request limit exceeded."
            },
            "4001": {
              "standard": "EIP 1193",
              "message": "User rejected the request."
            },
            "4100": {
              "standard": "EIP 1193",
              "message": "The requested account and/or method has not been authorized by the user."
            },
            "4200": {
              "standard": "EIP 1193",
              "message": "The requested method is not supported by this Ethereum provider."
            },
            "4900": {
              "standard": "EIP 1193",
              "message": "The provider is disconnected from all chains."
            },
            "4901": {
              "standard": "EIP 1193",
              "message": "The provider is disconnected from the specified chain."
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-rpc-errors", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errors.js", { "./classes": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js", "./errorCodes.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json", "./utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\utils.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\errors.js
        return function (require, module, exports) {

          const { EthereumRpcError, EthereumProviderError } = require('./classes')
          const { getMessageFromCode } = require('./utils')
          const ERROR_CODES = require('./errorCodes.json')

          module.exports = {
            rpc: {

              /**
               * Get a JSON RPC 2.0 Parse (-32700) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              parse: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.parse, opts,
              ),

              /**
               * Get a JSON RPC 2.0 Invalid Request (-32600) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              invalidRequest: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.invalidRequest, opts,
              ),

              /**
               * Get a JSON RPC 2.0 Invalid Params (-32602) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              invalidParams: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.invalidParams, opts,
              ),

              /**
               * Get a JSON RPC 2.0 Method Not Found (-32601) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              methodNotFound: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.methodNotFound, opts,
              ),

              /**
               * Get a JSON RPC 2.0 Internal (-32603) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              internal: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.internal, opts,
              ),

              /**
               * Get a JSON RPC 2.0 Server error.
               * Permits integer error codes in the [ -32099 <= -32005 ] range.
               * Codes -32000 through -32004 are reserved by EIP 1474.
               *
               * @param {Object|string} opts - Options object
               * @param {number} opts.code - The error code
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              server: (opts) => {
                if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                  throw new Error('Ethereum RPC Server errors must provide single object argument.')
                }
                const { code } = opts
                if (!Number.isInteger(code) || code > -32005 || code < -32099) {
                  throw new Error(
                    '"code" must be an integer such that: -32099 <= code <= -32005',
                  )
                }
                return getEthJsonRpcError(code, opts)
              },

              /**
               * Get an Ethereum JSON RPC Invalid Input (-32000) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              invalidInput: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.invalidInput, opts,
              ),

              /**
               * Get an Ethereum JSON RPC Resource Not Found (-32001) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              resourceNotFound: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.resourceNotFound, opts,
              ),

              /**
               * Get an Ethereum JSON RPC Resource Unavailable (-32002) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              resourceUnavailable: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.resourceUnavailable, opts,
              ),

              /**
               * Get an Ethereum JSON RPC Transaction Rejected (-32003) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              transactionRejected: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.transactionRejected, opts,
              ),

              /**
               * Get an Ethereum JSON RPC Method Not Supported (-32004) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              methodNotSupported: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.methodNotSupported, opts,
              ),

              /**
               * Get an Ethereum JSON RPC Limit Exceeded (-32005) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumRpcError} The error
               */
              limitExceeded: (opts) => getEthJsonRpcError(
                ERROR_CODES.rpc.limitExceeded, opts,
              ),
            },

            provider: {

              /**
               * Get an Ethereum Provider User Rejected Request (4001) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumProviderError} The error
               */
              userRejectedRequest: (opts) => {
                return getEthProviderError(
                  ERROR_CODES.provider.userRejectedRequest, opts,
                )
              },

              /**
               * Get an Ethereum Provider Unauthorized (4100) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumProviderError} The error
               */
              unauthorized: (opts) => {
                return getEthProviderError(
                  ERROR_CODES.provider.unauthorized, opts,
                )
              },

              /**
               * Get an Ethereum Provider Unsupported Method (4200) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumProviderError} The error
               */
              unsupportedMethod: (opts) => {
                return getEthProviderError(
                  ERROR_CODES.provider.unsupportedMethod, opts,
                )
              },

              /**
               * Get an Ethereum Provider Not Connected (4900) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumProviderError} The error
               */
              disconnected: (opts) => {
                return getEthProviderError(
                  ERROR_CODES.provider.disconnected, opts,
                )
              },

              /**
               * Get an Ethereum Provider Chain Not Connected (4901) error.
               *
               * @param {Object|string} [opts] - Options object or error message string
               * @param {string} [opts.message] - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumProviderError} The error
               */
              chainDisconnected: (opts) => {
                return getEthProviderError(
                  ERROR_CODES.provider.chainDisconnected, opts,
                )
              },

              /**
               * Get a custom Ethereum Provider error.
               *
               * @param {Object|string} opts - Options object
               * @param {number} opts.code - The error code
               * @param {string} opts.message - The error message
               * @param {any} [opts.data] - Error data
               * @returns {EthereumProviderError} The error
               */
              custom: (opts) => {
                if (!opts || typeof opts !== 'object' || Array.isArray(opts)) {
                  throw new Error('Ethereum Provider custom errors must provide single object argument.')
                }
                const { code, message, data } = opts
                if (!message || typeof message !== 'string') {
                  throw new Error(
                    '"message" must be a nonempty string',
                  )
                }
                return new EthereumProviderError(code, message, data)
              },
            },
          }

          // Internal

          function getEthJsonRpcError(code, opts) {
            const [message, data] = validateOpts(opts)
            return new EthereumRpcError(
              code,
              message || getMessageFromCode(code),
              data,
            )
          }

          function getEthProviderError(code, opts) {
            const [message, data] = validateOpts(opts)
            return new EthereumProviderError(
              code,
              message || getMessageFromCode(code),
              data,
            )
          }

          function validateOpts(opts) {
            if (opts) {
              if (typeof opts === 'string') {
                return [opts]
              } else if (typeof opts === 'object' && !Array.isArray(opts)) {
                const { message, data } = opts
                return [message, data]
              }
            }
            return []
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-rpc-errors", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\utils.js", { "./classes": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\classes.js", "./errorCodes.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorCodes.json", "./errorValues.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-rpc-errors\\src\\errorValues.json" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-rpc-errors\src\utils.js
        return function (require, module, exports) {

          const errorValues = require('./errorValues.json')
          const FALLBACK_ERROR_CODE = require('./errorCodes.json').rpc.internal
          const { EthereumRpcError } = require('./classes')

          const JSON_RPC_SERVER_ERROR_MESSAGE = 'Unspecified server error.'

          const FALLBACK_MESSAGE = 'Unspecified error message. This is a bug, please report it.'

          const FALLBACK_ERROR = {
            code: FALLBACK_ERROR_CODE,
            message: getMessageFromCode(FALLBACK_ERROR_CODE),
          }

          /**
           * Gets the message for a given code, or a fallback message if the code has
           * no corresponding message.
           *
           * @param {number} code - The integer error code
           * @param {string} fallbackMessage - The fallback message
           * @return {string} The corresponding message or the fallback message
           */
          function getMessageFromCode(code, fallbackMessage = FALLBACK_MESSAGE) {

            if (Number.isInteger(code)) {

              const codeString = code.toString()

              if (errorValues[codeString]) {
                return errorValues[codeString].message
              }
              if (isJsonRpcServerError(code)) {
                return JSON_RPC_SERVER_ERROR_MESSAGE
              }
            }
            return fallbackMessage
          }

          /**
           * Returns whether the given code is valid.
           * A code is only valid if it has a message.
           *
           * @param {number} code - The code to check
           * @return {boolean} true if the code is valid, false otherwise.
           */
          function isValidCode(code) {

            if (!Number.isInteger(code)) {
              return false
            }

            const codeString = code.toString()
            if (errorValues[codeString]) {
              return true
            }

            if (isJsonRpcServerError(code)) {
              return true
            }

            // TODO: allow valid codes and messages to be extended
            // // EIP 1193 Status Codes
            // if (code >= 4000 && code <= 4999) return true

            return false
          }

          /**
           * Serializes the given error to an Ethereum JSON RPC-compatible error object.
           * Merely copies the given error's values if it is already compatible.
           * If the given error is not fully compatible, it will be preserved on the
           * returned object's data.originalError property.
           *
           * @param {any} error - The error to serialize.
           * @param {Object} [options] - An options object.
           * @param {Object} [options.fallbackError] - The custom fallback error values if
           * the given error is invalid.
           * @param {boolean} [options.shouldIncludeStack] - Whether the 'stack' property
           * of the given error should be included on the serialized error, if present.
           * @return {Object} A standardized, plain error object.
           */
          function serializeError(
            error,
            { fallbackError = FALLBACK_ERROR, shouldIncludeStack = false } = {},
          ) {

            if (
              !fallbackError ||
              !Number.isInteger(fallbackError.code) ||
              typeof fallbackError.message !== 'string'
            ) {
              throw new Error(
                'Must provide fallback error with integer number code and string message.',
              )
            }

            if (error instanceof EthereumRpcError) {
              return error.serialize()
            }

            const serialized = {}

            if (error && isValidCode(error.code)) {

              serialized.code = error.code

              if (error.message && typeof error.message === 'string') {
                serialized.message = error.message
                if ('data' in error) {
                  serialized.data = error.data
                }
              } else {
                serialized.message = getMessageFromCode(serialized.code)
                serialized.data = { originalError: assignOriginalError(error) }
              }

            } else {
              serialized.code = fallbackError.code
              serialized.message = (
                error && error.message
                  ? error.message
                  : fallbackError.message
              )
              serialized.data = { originalError: assignOriginalError(error) }
            }

            if (shouldIncludeStack && error && typeof error.stack === 'string') {
              serialized.stack = error.stack
            }
            return serialized
          }

          // Internal

          function isJsonRpcServerError(code) {
            return code >= -32099 && code <= -32000
          }

          function assignOriginalError(error) {
            if (error && typeof error === 'object' && !Array.isArray(error)) {
              return { ...error }
            }
            return error
          }

          // Exports

          module.exports = {
            getMessageFromCode,
            isValidCode,
            serializeError,
            JSON_RPC_SERVER_ERROR_MESSAGE,
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-rpc-errors", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-sig-util\\index.js", { "ethereumjs-abi": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\eth-sig-util\index.js
        return function (require, module, exports) {
          const ethUtil = require('ethereumjs-util')
          const ethAbi = require('ethereumjs-abi')

          module.exports = {

            concatSig: function (v, r, s) {
              const rSig = ethUtil.fromSigned(r)
              const sSig = ethUtil.fromSigned(s)
              const vSig = ethUtil.bufferToInt(v)
              const rStr = padWithZeroes(ethUtil.toUnsigned(rSig).toString('hex'), 64)
              const sStr = padWithZeroes(ethUtil.toUnsigned(sSig).toString('hex'), 64)
              const vStr = ethUtil.stripHexPrefix(ethUtil.intToHex(vSig))
              return ethUtil.addHexPrefix(rStr.concat(sStr, vStr)).toString('hex')
            },

            normalize: function (input) {
              if (!input) return

              if (typeof input === 'number') {
                const buffer = ethUtil.toBuffer(input)
                input = ethUtil.bufferToHex(buffer)
              }

              if (typeof input !== 'string') {
                var msg = 'eth-sig-util.normalize() requires hex string or integer input.'
                msg += ' received ' + (typeof input) + ': ' + input
                throw new Error(msg)
              }

              return ethUtil.addHexPrefix(input.toLowerCase())
            },

            personalSign: function (privateKey, msgParams) {
              var message = ethUtil.toBuffer(msgParams.data)
              var msgHash = ethUtil.hashPersonalMessage(message)
              var sig = ethUtil.ecsign(msgHash, privateKey)
              var serialized = ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
              return serialized
            },

            recoverPersonalSignature: function (msgParams) {
              const publicKey = getPublicKeyFor(msgParams)
              const sender = ethUtil.publicToAddress(publicKey)
              const senderHex = ethUtil.bufferToHex(sender)
              return senderHex
            },

            extractPublicKey: function (msgParams) {
              const publicKey = getPublicKeyFor(msgParams)
              return '0x' + publicKey.toString('hex')
            },

            typedSignatureHash: function (typedData) {
              const hashBuffer = typedSignatureHash(typedData)
              return ethUtil.bufferToHex(hashBuffer)
            },

            signTypedData: function (privateKey, msgParams) {
              const msgHash = typedSignatureHash(msgParams.data)
              const sig = ethUtil.ecsign(msgHash, privateKey)
              return ethUtil.bufferToHex(this.concatSig(sig.v, sig.r, sig.s))
            },

            recoverTypedSignature: function (msgParams) {
              const msgHash = typedSignatureHash(msgParams.data)
              const publicKey = recoverPublicKey(msgHash, msgParams.sig)
              const sender = ethUtil.publicToAddress(publicKey)
              return ethUtil.bufferToHex(sender)
            }

          }

          /**
           * @param typedData - Array of data along with types, as per EIP712.
           * @returns Buffer
           */
          function typedSignatureHash(typedData) {
            const error = new Error('Expect argument to be non-empty array')
            if (typeof typedData !== 'object' || !typedData.length) throw error

            const data = typedData.map(function (e) {
              return e.type === 'bytes' ? ethUtil.toBuffer(e.value) : e.value
            })
            const types = typedData.map(function (e) { return e.type })
            const schema = typedData.map(function (e) {
              if (!e.name) throw error
              return e.type + ' ' + e.name
            })

            return ethAbi.soliditySHA3(
              ['bytes32', 'bytes32'],
              [
                ethAbi.soliditySHA3(new Array(typedData.length).fill('string'), schema),
                ethAbi.soliditySHA3(types, data)
              ]
            )
          }

          function recoverPublicKey(hash, sig) {
            const signature = ethUtil.toBuffer(sig)
            const sigParams = ethUtil.fromRpcSig(signature)
            return ethUtil.ecrecover(hash, sigParams.v, sigParams.r, sigParams.s)
          }

          function getPublicKeyFor(msgParams) {
            const message = ethUtil.toBuffer(msgParams.data)
            const msgHash = ethUtil.hashPersonalMessage(message)
            return recoverPublicKey(msgHash, msgParams.sig)
          }


          function padWithZeroes(number, length) {
            var myString = '' + number
            while (myString.length < length) {
              myString = '0' + myString
            }
            return myString
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-sig-util", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js", { "./secp256k1-adapter": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", "assert": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\assert\\assert.js", "bn.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js", "create-hash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\create-hash\\browser.js", "ethereum-cryptography/keccak": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\keccak.js", "ethjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethjs-util\\lib\\index.js", "rlp": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\rlp\\dist.browser\\index.js", "safe-buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\safe-buffer\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\index.js
        return function (require, module, exports) {
          'use strict';

          var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

          var _require = require('ethereum-cryptography/keccak'),
            keccak224 = _require.keccak224,
            keccak384 = _require.keccak384,
            k256 = _require.keccak256,
            keccak512 = _require.keccak512;

          var secp256k1 = require('./secp256k1-adapter');
          var assert = require('assert');
          var rlp = require('rlp');
          var BN = require('bn.js');
          var createHash = require('create-hash');
          var Buffer = require('safe-buffer').Buffer;
          Object.assign(exports, require('ethjs-util'));

          /**
           * the max integer that this VM can handle (a ```BN```)
           * @var {BN} MAX_INTEGER
           */
          exports.MAX_INTEGER = new BN('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);

          /**
           * 2^256 (a ```BN```)
           * @var {BN} TWO_POW256
           */
          exports.TWO_POW256 = new BN('10000000000000000000000000000000000000000000000000000000000000000', 16);

          /**
           * Keccak-256 hash of null (a ```String```)
           * @var {String} KECCAK256_NULL_S
           */
          exports.KECCAK256_NULL_S = 'c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';
          exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;

          /**
           * Keccak-256 hash of null (a ```Buffer```)
           * @var {Buffer} KECCAK256_NULL
           */
          exports.KECCAK256_NULL = Buffer.from(exports.KECCAK256_NULL_S, 'hex');
          exports.SHA3_NULL = exports.KECCAK256_NULL;

          /**
           * Keccak-256 of an RLP of an empty array (a ```String```)
           * @var {String} KECCAK256_RLP_ARRAY_S
           */
          exports.KECCAK256_RLP_ARRAY_S = '1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347';
          exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;

          /**
           * Keccak-256 of an RLP of an empty array (a ```Buffer```)
           * @var {Buffer} KECCAK256_RLP_ARRAY
           */
          exports.KECCAK256_RLP_ARRAY = Buffer.from(exports.KECCAK256_RLP_ARRAY_S, 'hex');
          exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;

          /**
           * Keccak-256 hash of the RLP of null  (a ```String```)
           * @var {String} KECCAK256_RLP_S
           */
          exports.KECCAK256_RLP_S = '56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421';
          exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;

          /**
           * Keccak-256 hash of the RLP of null (a ```Buffer```)
           * @var {Buffer} KECCAK256_RLP
           */
          exports.KECCAK256_RLP = Buffer.from(exports.KECCAK256_RLP_S, 'hex');
          exports.SHA3_RLP = exports.KECCAK256_RLP;

          /**
           * [`BN`](https://github.com/indutny/bn.js)
           * @var {Function}
           */
          exports.BN = BN;

          /**
           * [`rlp`](https://github.com/ethereumjs/rlp)
           * @var {Function}
           */
          exports.rlp = rlp;

          /**
           * [`secp256k1`](https://github.com/cryptocoinjs/secp256k1-node/)
           * @var {Object}
           */
          exports.secp256k1 = secp256k1;

          /**
           * Returns a buffer filled with 0s
           * @method zeros
           * @param {Number} bytes  the number of bytes the buffer should be
           * @return {Buffer}
           */
          exports.zeros = function (bytes) {
            return Buffer.allocUnsafe(bytes).fill(0);
          };

          /**
            * Returns a zero address
            * @method zeroAddress
            * @return {String}
            */
          exports.zeroAddress = function () {
            var addressLength = 20;
            var zeroAddress = exports.zeros(addressLength);
            return exports.bufferToHex(zeroAddress);
          };

          /**
           * Left Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
           * Or it truncates the beginning if it exceeds.
           * @method lsetLength
           * @param {Buffer|Array} msg the value to pad
           * @param {Number} length the number of bytes the output should be
           * @param {Boolean} [right=false] whether to start padding form the left or right
           * @return {Buffer|Array}
           */
          exports.setLengthLeft = exports.setLength = function (msg, length, right) {
            var buf = exports.zeros(length);
            msg = exports.toBuffer(msg);
            if (right) {
              if (msg.length < length) {
                msg.copy(buf);
                return buf;
              }
              return msg.slice(0, length);
            } else {
              if (msg.length < length) {
                msg.copy(buf, length - msg.length);
                return buf;
              }
              return msg.slice(-length);
            }
          };

          /**
           * Right Pads an `Array` or `Buffer` with leading zeros till it has `length` bytes.
           * Or it truncates the beginning if it exceeds.
           * @param {Buffer|Array} msg the value to pad
           * @param {Number} length the number of bytes the output should be
           * @return {Buffer|Array}
           */
          exports.setLengthRight = function (msg, length) {
            return exports.setLength(msg, length, true);
          };

          /**
           * Trims leading zeros from a `Buffer` or an `Array`
           * @param {Buffer|Array|String} a
           * @return {Buffer|Array|String}
           */
          exports.unpad = exports.stripZeros = function (a) {
            a = exports.stripHexPrefix(a);
            var first = a[0];
            while (a.length > 0 && first.toString() === '0') {
              a = a.slice(1);
              first = a[0];
            }
            return a;
          };
          /**
           * Attempts to turn a value into a `Buffer`. As input it supports `Buffer`, `String`, `Number`, null/undefined, `BN` and other objects with a `toArray()` method.
           * @param {*} v the value
           */
          exports.toBuffer = function (v) {
            if (!Buffer.isBuffer(v)) {
              if (Array.isArray(v)) {
                v = Buffer.from(v);
              } else if (typeof v === 'string') {
                if (exports.isHexString(v)) {
                  v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), 'hex');
                } else {
                  v = Buffer.from(v);
                }
              } else if (typeof v === 'number') {
                v = exports.intToBuffer(v);
              } else if (v === null || v === undefined) {
                v = Buffer.allocUnsafe(0);
              } else if (BN.isBN(v)) {
                v = v.toArrayLike(Buffer);
              } else if (v.toArray) {
                // converts a BN to a Buffer
                v = Buffer.from(v.toArray());
              } else {
                throw new Error('invalid type');
              }
            }
            return v;
          };

          /**
           * Converts a `Buffer` to a `Number`
           * @param {Buffer} buf
           * @return {Number}
           * @throws If the input number exceeds 53 bits.
           */
          exports.bufferToInt = function (buf) {
            return new BN(exports.toBuffer(buf)).toNumber();
          };

          /**
           * Converts a `Buffer` into a hex `String`
           * @param {Buffer} buf
           * @return {String}
           */
          exports.bufferToHex = function (buf) {
            buf = exports.toBuffer(buf);
            return '0x' + buf.toString('hex');
          };

          /**
           * Interprets a `Buffer` as a signed integer and returns a `BN`. Assumes 256-bit numbers.
           * @param {Buffer} num
           * @return {BN}
           */
          exports.fromSigned = function (num) {
            return new BN(num).fromTwos(256);
          };

          /**
           * Converts a `BN` to an unsigned integer and returns it as a `Buffer`. Assumes 256-bit numbers.
           * @param {BN} num
           * @return {Buffer}
           */
          exports.toUnsigned = function (num) {
            return Buffer.from(num.toTwos(256).toArray());
          };

          /**
           * Creates Keccak hash of the input
           * @param {Buffer|Array|String|Number} a the input data
           * @param {Number} [bits=256] the Keccak width
           * @return {Buffer}
           */
          exports.keccak = function (a, bits) {
            a = exports.toBuffer(a);
            if (!bits) bits = 256;

            switch (bits) {
              case 224:
                {
                  return keccak224(a);
                }
              case 256:
                {
                  return k256(a);
                }
              case 384:
                {
                  return keccak384(a);
                }
              case 512:
                {
                  return keccak512(a);
                }
              default:
                {
                  throw new Error('Invald algorithm: keccak' + bits);
                }
            }
          };

          /**
           * Creates Keccak-256 hash of the input, alias for keccak(a, 256)
           * @param {Buffer|Array|String|Number} a the input data
           * @return {Buffer}
           */
          exports.keccak256 = function (a) {
            return exports.keccak(a);
          };

          /**
           * Creates SHA-3 (Keccak) hash of the input [OBSOLETE]
           * @param {Buffer|Array|String|Number} a the input data
           * @param {Number} [bits=256] the SHA-3 width
           * @return {Buffer}
           */
          exports.sha3 = exports.keccak;

          /**
           * Creates SHA256 hash of the input
           * @param {Buffer|Array|String|Number} a the input data
           * @return {Buffer}
           */
          exports.sha256 = function (a) {
            a = exports.toBuffer(a);
            return createHash('sha256').update(a).digest();
          };

          /**
           * Creates RIPEMD160 hash of the input
           * @param {Buffer|Array|String|Number} a the input data
           * @param {Boolean} padded whether it should be padded to 256 bits or not
           * @return {Buffer}
           */
          exports.ripemd160 = function (a, padded) {
            a = exports.toBuffer(a);
            var hash = createHash('rmd160').update(a).digest();
            if (padded === true) {
              return exports.setLength(hash, 32);
            } else {
              return hash;
            }
          };

          /**
           * Creates SHA-3 hash of the RLP encoded version of the input
           * @param {Buffer|Array|String|Number} a the input data
           * @return {Buffer}
           */
          exports.rlphash = function (a) {
            return exports.keccak(rlp.encode(a));
          };

          /**
           * Checks if the private key satisfies the rules of the curve secp256k1.
           * @param {Buffer} privateKey
           * @return {Boolean}
           */
          exports.isValidPrivate = function (privateKey) {
            return secp256k1.privateKeyVerify(privateKey);
          };

          /**
           * Checks if the public key satisfies the rules of the curve secp256k1
           * and the requirements of Ethereum.
           * @param {Buffer} publicKey The two points of an uncompressed key, unless sanitize is enabled
           * @param {Boolean} [sanitize=false] Accept public keys in other formats
           * @return {Boolean}
           */
          exports.isValidPublic = function (publicKey, sanitize) {
            if (publicKey.length === 64) {
              // Convert to SEC1 for secp256k1
              return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));
            }

            if (!sanitize) {
              return false;
            }

            return secp256k1.publicKeyVerify(publicKey);
          };

          /**
           * Returns the ethereum address of a given public key.
           * Accepts "Ethereum public keys" and SEC1 encoded keys.
           * @param {Buffer} pubKey The two points of an uncompressed key, unless sanitize is enabled
           * @param {Boolean} [sanitize=false] Accept public keys in other formats
           * @return {Buffer}
           */
          exports.pubToAddress = exports.publicToAddress = function (pubKey, sanitize) {
            pubKey = exports.toBuffer(pubKey);
            if (sanitize && pubKey.length !== 64) {
              pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
            }
            assert(pubKey.length === 64);
            // Only take the lower 160bits of the hash
            return exports.keccak(pubKey).slice(-20);
          };

          /**
           * Returns the ethereum public key of a given private key
           * @param {Buffer} privateKey A private key must be 256 bits wide
           * @return {Buffer}
           */
          var privateToPublic = exports.privateToPublic = function (privateKey) {
            privateKey = exports.toBuffer(privateKey);
            // skip the type flag and use the X, Y points
            return secp256k1.publicKeyCreate(privateKey, false).slice(1);
          };

          /**
           * Converts a public key to the Ethereum format.
           * @param {Buffer} publicKey
           * @return {Buffer}
           */
          exports.importPublic = function (publicKey) {
            publicKey = exports.toBuffer(publicKey);
            if (publicKey.length !== 64) {
              publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
            }
            return publicKey;
          };

          /**
           * ECDSA sign
           * @param {Buffer} msgHash
           * @param {Buffer} privateKey
           * @return {Object}
           */
          exports.ecsign = function (msgHash, privateKey) {
            var sig = secp256k1.sign(msgHash, privateKey);

            var ret = {};
            ret.r = sig.signature.slice(0, 32);
            ret.s = sig.signature.slice(32, 64);
            ret.v = sig.recovery + 27;
            return ret;
          };

          /**
           * Returns the keccak-256 hash of `message`, prefixed with the header used by the `eth_sign` RPC call.
           * The output of this function can be fed into `ecsign` to produce the same signature as the `eth_sign`
           * call for a given `message`, or fed to `ecrecover` along with a signature to recover the public key
           * used to produce the signature.
           * @param message
           * @returns {Buffer} hash
           */
          exports.hashPersonalMessage = function (message) {
            var prefix = exports.toBuffer('\x19Ethereum Signed Message:\n' + message.length.toString());
            return exports.keccak(Buffer.concat([prefix, message]));
          };

          /**
           * ECDSA public key recovery from signature
           * @param {Buffer} msgHash
           * @param {Number} v
           * @param {Buffer} r
           * @param {Buffer} s
           * @return {Buffer} publicKey
           */
          exports.ecrecover = function (msgHash, v, r, s) {
            var signature = Buffer.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
            var recovery = v - 27;
            if (recovery !== 0 && recovery !== 1) {
              throw new Error('Invalid signature v value');
            }
            var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
            return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
          };

          /**
           * Convert signature parameters into the format of `eth_sign` RPC method
           * @param {Number} v
           * @param {Buffer} r
           * @param {Buffer} s
           * @return {String} sig
           */
          exports.toRpcSig = function (v, r, s) {
            // NOTE: with potential introduction of chainId this might need to be updated
            if (v !== 27 && v !== 28) {
              throw new Error('Invalid recovery id');
            }

            // geth (and the RPC eth_sign method) uses the 65 byte format used by Bitcoin
            // FIXME: this might change in the future - https://github.com/ethereum/go-ethereum/issues/2053
            return exports.bufferToHex(Buffer.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
          };

          /**
           * Convert signature format of the `eth_sign` RPC method to signature parameters
           * NOTE: all because of a bug in geth: https://github.com/ethereum/go-ethereum/issues/2053
           * @param {String} sig
           * @return {Object}
           */
          exports.fromRpcSig = function (sig) {
            sig = exports.toBuffer(sig);

            // NOTE: with potential introduction of chainId this might need to be updated
            if (sig.length !== 65) {
              throw new Error('Invalid signature length');
            }

            var v = sig[64];
            // support both versions of `eth_sign` responses
            if (v < 27) {
              v += 27;
            }

            return {
              v: v,
              r: sig.slice(0, 32),
              s: sig.slice(32, 64)
            };
          };

          /**
           * Returns the ethereum address of a given private key
           * @param {Buffer} privateKey A private key must be 256 bits wide
           * @return {Buffer}
           */
          exports.privateToAddress = function (privateKey) {
            return exports.publicToAddress(privateToPublic(privateKey));
          };

          /**
           * Checks if the address is a valid. Accepts checksummed addresses too
           * @param {String} address
           * @return {Boolean}
           */
          exports.isValidAddress = function (address) {
            return (/^0x[0-9a-fA-F]{40}$/.test(address)
            );
          };

          /**
            * Checks if a given address is a zero address
            * @method isZeroAddress
            * @param {String} address
            * @return {Boolean}
            */
          exports.isZeroAddress = function (address) {
            var zeroAddress = exports.zeroAddress();
            return zeroAddress === exports.addHexPrefix(address);
          };

          /**
           * Returns a checksummed address
           * @param {String} address
           * @return {String}
           */
          exports.toChecksumAddress = function (address) {
            address = exports.stripHexPrefix(address).toLowerCase();
            var hash = exports.keccak(address).toString('hex');
            var ret = '0x';

            for (var i = 0; i < address.length; i++) {
              if (parseInt(hash[i], 16) >= 8) {
                ret += address[i].toUpperCase();
              } else {
                ret += address[i];
              }
            }

            return ret;
          };

          /**
           * Checks if the address is a valid checksummed address
           * @param {Buffer} address
           * @return {Boolean}
           */
          exports.isValidChecksumAddress = function (address) {
            return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
          };

          /**
           * Generates an address of a newly created contract
           * @param {Buffer} from the address which is creating this new address
           * @param {Buffer} nonce the nonce of the from account
           * @return {Buffer}
           */
          exports.generateAddress = function (from, nonce) {
            from = exports.toBuffer(from);
            nonce = new BN(nonce);

            if (nonce.isZero()) {
              // in RLP we want to encode null in the case of zero nonce
              // read the RLP documentation for an answer if you dare
              nonce = null;
            } else {
              nonce = Buffer.from(nonce.toArray());
            }

            // Only take the lower 160bits of the hash
            return exports.rlphash([from, nonce]).slice(-20);
          };

          /**
           * Returns true if the supplied address belongs to a precompiled account (Byzantium)
           * @param {Buffer|String} address
           * @return {Boolean}
           */
          exports.isPrecompiled = function (address) {
            var a = exports.unpad(address);
            return a.length === 1 && a[0] >= 1 && a[0] <= 8;
          };

          /**
           * Adds "0x" to a given `String` if it does not already start with "0x"
           * @param {String} str
           * @return {String}
           */
          exports.addHexPrefix = function (str) {
            if (typeof str !== 'string') {
              return str;
            }

            return exports.isHexPrefixed(str) ? str : '0x' + str;
          };

          /**
           * Validate ECDSA signature
           * @method isValidSignature
           * @param {Buffer} v
           * @param {Buffer} r
           * @param {Buffer} s
           * @param {Boolean} [homestead=true]
           * @return {Boolean}
           */

          exports.isValidSignature = function (v, r, s, homestead) {
            var SECP256K1_N_DIV_2 = new BN('7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0', 16);
            var SECP256K1_N = new BN('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 16);

            if (r.length !== 32 || s.length !== 32) {
              return false;
            }

            if (v !== 27 && v !== 28) {
              return false;
            }

            r = new BN(r);
            s = new BN(s);

            if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
              return false;
            }

            if (homestead === false && new BN(s).cmp(SECP256K1_N_DIV_2) === 1) {
              return false;
            }

            return true;
          };

          /**
           * Converts a `Buffer` or `Array` to JSON
           * @param {Buffer|Array} ba
           * @return {Array|String|null}
           */
          exports.baToJSON = function (ba) {
            if (Buffer.isBuffer(ba)) {
              return '0x' + ba.toString('hex');
            } else if (ba instanceof Array) {
              var array = [];
              for (var i = 0; i < ba.length; i++) {
                array.push(exports.baToJSON(ba[i]));
              }
              return array;
            }
          };

          /**
           * Defines properties on a `Object`. It make the assumption that underlying data is binary.
           * @param {Object} self the `Object` to define properties on
           * @param {Array} fields an array fields to define. Fields can contain:
           * * `name` - the name of the properties
           * * `length` - the number of bytes the field can have
           * * `allowLess` - if the field can be less than the length
           * * `allowEmpty`
           * @param {*} data data to be validated against the definitions
           */
          exports.defineProperties = function (self, fields, data) {
            self.raw = [];
            self._fields = [];

            // attach the `toJSON`
            self.toJSON = function (label) {
              if (label) {
                var obj = {};
                self._fields.forEach(function (field) {
                  obj[field] = '0x' + self[field].toString('hex');
                });
                return obj;
              }
              return exports.baToJSON(this.raw);
            };

            self.serialize = function serialize() {
              return rlp.encode(self.raw);
            };

            fields.forEach(function (field, i) {
              self._fields.push(field.name);
              function getter() {
                return self.raw[i];
              }
              function setter(v) {
                v = exports.toBuffer(v);

                if (v.toString('hex') === '00' && !field.allowZero) {
                  v = Buffer.allocUnsafe(0);
                }

                if (field.allowLess && field.length) {
                  v = exports.stripZeros(v);
                  assert(field.length >= v.length, 'The field ' + field.name + ' must not have more ' + field.length + ' bytes');
                } else if (!(field.allowZero && v.length === 0) && field.length) {
                  assert(field.length === v.length, 'The field ' + field.name + ' must have byte length of ' + field.length);
                }

                self.raw[i] = v;
              }

              Object.defineProperty(self, field.name, {
                enumerable: true,
                configurable: true,
                get: getter,
                set: setter
              });

              if (field.default) {
                self[field.name] = field.default;
              }

              // attach alias
              if (field.alias) {
                Object.defineProperty(self, field.alias, {
                  enumerable: false,
                  configurable: true,
                  set: setter,
                  get: getter
                });
              }
            });

            // if the constuctor is passed data
            if (data) {
              if (typeof data === 'string') {
                data = Buffer.from(exports.stripHexPrefix(data), 'hex');
              }

              if (Buffer.isBuffer(data)) {
                data = rlp.decode(data);
              }

              if (Array.isArray(data)) {
                if (data.length > self._fields.length) {
                  throw new Error('wrong number of fields in data');
                }

                // make sure all the items are buffers
                data.forEach(function (d, i) {
                  self[self._fields[i]] = exports.toBuffer(d);
                });
              } else if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object') {
                var keys = Object.keys(data);
                fields.forEach(function (field) {
                  if (keys.indexOf(field.name) !== -1) self[field.name] = data[field.name];
                  if (keys.indexOf(field.alias) !== -1) self[field.alias] = data[field.alias];
                });
              } else {
                throw new Error('invalid data');
              }
            }
          };
        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>ethereumjs-util", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-adapter.js", { "./secp256k1-lib/der": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", "./secp256k1-lib/index": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "ethereum-cryptography/secp256k1": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-cryptography\\secp256k1.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\secp256k1-adapter.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              'use strict';

              var secp256k1 = require('ethereum-cryptography/secp256k1');

              var secp256k1v3 = require('./secp256k1-lib/index');
              var der = require('./secp256k1-lib/der');

              /**
               * Verify an ECDSA privateKey
               * @method privateKeyVerify
               * @param {Buffer} privateKey
               * @return {boolean}
               */
              var privateKeyVerify = function privateKeyVerify(privateKey) {
                // secp256k1 v4 version throws when privateKey length is not 32
                if (privateKey.length !== 32) {
                  return false;
                }

                return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));
              };

              /**
               * Export a privateKey in DER format
               * @method privateKeyExport
               * @param {Buffer} privateKey
               * @param {boolean} compressed
               * @return {boolean}
               */
              var privateKeyExport = function privateKeyExport(privateKey, compressed) {
                // privateKeyExport method is not part of secp256k1 v4 package
                // this implementation is based on v3
                if (privateKey.length !== 32) {
                  throw new RangeError('private key length is invalid');
                }

                var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);

                return der.privateKeyExport(privateKey, publicKey, compressed);
              };

              /**
               * Import a privateKey in DER format
               * @method privateKeyImport
               * @param {Buffer} privateKey
               * @return {Buffer}
               */

              var privateKeyImport = function privateKeyImport(privateKey) {
                // privateKeyImport method is not part of secp256k1 v4 package
                // this implementation is based on v3
                privateKey = der.privateKeyImport(privateKey);
                if (privateKey !== null && privateKey.length === 32 && privateKeyVerify(privateKey)) {
                  return privateKey;
                }

                throw new Error("couldn't import from DER format");
              };

              /**
               * Negate a privateKey by subtracting it from the order of the curve's base point
               * @method privateKeyNegate
               * @param {Buffer} privateKey
               * @return {Buffer}
               */
              var privateKeyNegate = function privateKeyNegate(privateKey) {
                return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));
              };

              /**
               * Compute the inverse of a privateKey (modulo the order of the curve's base point).
               * @method privateKeyModInverse
               * @param {Buffer} privateKey
               * @return {Buffer}
               */
              var privateKeyModInverse = function privateKeyModInverse(privateKey) {
                if (privateKey.length !== 32) {
                  throw new Error('private key length is invalid');
                }

                return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));
              };

              /**
               * Tweak a privateKey by adding tweak to it.
               * @method privateKeyTweakAdd
               * @param {Buffer} privateKey
               * @param {Buffer} tweak
               * @return {Buffer}
               */
              var privateKeyTweakAdd = function privateKeyTweakAdd(privateKey, tweak) {
                return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));
              };

              /**
               * Tweak a privateKey by multiplying it by a tweak.
               * @method privateKeyTweakMul
               * @param {Buffer} privateKey
               * @param {Buffer} tweak
               * @return {Buffer}
               */
              var privateKeyTweakMul = function privateKeyTweakMul(privateKey, tweak) {
                return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));
              };

              /**
               * Compute the public key for a privateKey.
               * @method publicKeyCreate
               * @param {Buffer} privateKey
               * @param {boolean} compressed
               * @return {Buffer}
               */
              var publicKeyCreate = function publicKeyCreate(privateKey, compressed) {
                return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));
              };

              /**
               * Convert a publicKey to compressed or uncompressed form.
               * @method publicKeyConvert
               * @param {Buffer} publicKey
               * @param {boolean} compressed
               * @return {Buffer}
               */
              var publicKeyConvert = function publicKeyConvert(publicKey, compressed) {
                return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));
              };

              /**
               * Verify an ECDSA publicKey.
               * @method publicKeyVerify
               * @param {Buffer} publicKey
               * @return {boolean}
               */
              var publicKeyVerify = function publicKeyVerify(publicKey) {
                // secp256k1 v4 version throws when publicKey length is not 33 or 65
                if (publicKey.length !== 33 && publicKey.length !== 65) {
                  return false;
                }

                return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));
              };

              /**
               * Tweak a publicKey by adding tweak times the generator to it.
               * @method publicKeyTweakAdd
               * @param {Buffer} publicKey
               * @param {Buffer} tweak
               * @param {boolean} compressed
               * @return {Buffer}
               */
              var publicKeyTweakAdd = function publicKeyTweakAdd(publicKey, tweak, compressed) {
                return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
              };

              /**
               * Tweak a publicKey by multiplying it by a tweak value
               * @method publicKeyTweakMul
               * @param {Buffer} publicKey
               * @param {Buffer} tweak
               * @param {boolean} compressed
               * @return {Buffer}
               */
              var publicKeyTweakMul = function publicKeyTweakMul(publicKey, tweak, compressed) {
                return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));
              };

              /**
               * Add a given publicKeys together.
               * @method publicKeyCombine
               * @param {Array<Buffer>} publicKeys
               * @param {boolean} compressed
               * @return {Buffer}
               */
              var publicKeyCombine = function publicKeyCombine(publicKeys, compressed) {
                var keys = [];
                publicKeys.forEach(function (publicKey) {
                  keys.push(Uint8Array.from(publicKey));
                });

                return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));
              };

              /**
               * Convert a signature to a normalized lower-S form.
               * @method signatureNormalize
               * @param {Buffer} signature
               * @return {Buffer}
               */
              var signatureNormalize = function signatureNormalize(signature) {
                return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));
              };

              /**
               * Serialize an ECDSA signature in DER format.
               * @method signatureExport
               * @param {Buffer} signature
               * @return {Buffer}
               */
              var signatureExport = function signatureExport(signature) {
                return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));
              };

              /**
               * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
               * @method signatureImport
               * @param {Buffer} signature
               * @return {Buffer}
               */
              var signatureImport = function signatureImport(signature) {
                return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));
              };

              /**
               * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).
               * @method signatureImportLax
               * @param {Buffer} signature
               * @return {Buffer}
               */
              var signatureImportLax = function signatureImportLax(signature) {
                // signatureImportLax method is not part of secp256k1 v4 package
                // this implementation is based on v3
                // ensure that signature is greater than 0
                if (signature.length === 0) {
                  throw new RangeError('signature length is invalid');
                }

                var sigObj = der.signatureImportLax(signature);
                if (sigObj === null) {
                  throw new Error("couldn't parse DER signature");
                }

                return secp256k1v3.signatureImport(sigObj);
              };

              /**
               * Create an ECDSA signature. Always return low-S signature.
               * @method sign
               * @param {Buffer} message
               * @param {Buffer} privateKey
               * @param {Object} options
               * @return {Buffer}
               */
              var sign = function sign(message, privateKey, options) {
                if (options === null) {
                  throw new TypeError('options should be an Object');
                }

                var signOptions = void 0;

                if (options) {
                  signOptions = {};

                  if (options.data === null) {
                    throw new TypeError('options.data should be a Buffer');
                  }

                  if (options.data) {
                    // validate option.data length
                    if (options.data.length !== 32) {
                      throw new RangeError('options.data length is invalid');
                    }

                    signOptions.data = new Uint8Array(options.data);
                  }

                  if (options.noncefn === null) {
                    throw new TypeError('options.noncefn should be a Function');
                  }

                  if (options.noncefn) {
                    //  convert option.noncefn function signature
                    signOptions.noncefn = function (message, privateKey, algo, data, attempt) {
                      var bufferAlgo = algo != null ? Buffer.from(algo) : null;
                      var bufferData = data != null ? Buffer.from(data) : null;

                      var buffer = Buffer.from('');

                      if (options.noncefn) {
                        buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);
                      }

                      return Uint8Array.from(buffer);
                    };
                  }
                }

                var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);

                return {
                  signature: Buffer.from(sig.signature),
                  recovery: sig.recid
                };
              };

              /**
               * Verify an ECDSA signature.
               * @method verify
               * @param {Buffer} message
               * @param {Buffer} signature
               * @param {Buffer} publicKey
               * @return {boolean}
               */
              var verify = function verify(message, signature, publicKey) {
                // note: secp256k1 v4 verify method has a different argument order
                return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);
              };

              /**
               * Recover an ECDSA public key from a signature.
               * @method recover
               * @param {Buffer} message
               * @param {Buffer} signature
               * @param {Number} recid
               * @param {boolean} compressed
               * @return {Buffer}
               */
              var recover = function recover(message, signature, recid, compressed) {
                // note: secp256k1 v4 recover method has a different argument order
                return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));
              };

              /**
               * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.
               * @method ecdh
               * @param {Buffer} publicKey
               * @param {Buffer} privateKey
               * @return {Buffer}
               */
              var ecdh = function ecdh(publicKey, privateKey) {
                // note: secp256k1 v3 doesn't allow optional parameter
                return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));
              };

              /**
               * Compute an EC Diffie-Hellman secret and return public key as result
               * @method ecdhUnsafe
               * @param {Buffer} publicKey
               * @param {Buffer} privateKey
               * @param {boolean} compressed
               * @return {Buffer}
               */
              var ecdhUnsafe = function ecdhUnsafe(publicKey, privateKey, compressed) {
                // ecdhUnsafe method is not part of secp256k1 v4 package
                // this implementation is based on v3
                // ensure valid publicKey length
                if (publicKey.length !== 33 && publicKey.length !== 65) {
                  throw new RangeError('public key length is invalid');
                }

                // ensure valid privateKey length
                if (privateKey.length !== 32) {
                  throw new RangeError('private key length is invalid');
                }

                return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));
              };

              module.exports = {
                privateKeyVerify: privateKeyVerify,
                privateKeyExport: privateKeyExport,
                privateKeyImport: privateKeyImport,
                privateKeyNegate: privateKeyNegate,
                privateKeyModInverse: privateKeyModInverse,
                privateKeyTweakAdd: privateKeyTweakAdd,
                privateKeyTweakMul: privateKeyTweakMul,

                publicKeyCreate: publicKeyCreate,
                publicKeyConvert: publicKeyConvert,
                publicKeyVerify: publicKeyVerify,
                publicKeyTweakAdd: publicKeyTweakAdd,
                publicKeyTweakMul: publicKeyTweakMul,
                publicKeyCombine: publicKeyCombine,

                signatureNormalize: signatureNormalize,
                signatureExport: signatureExport,
                signatureImport: signatureImport,
                signatureImportLax: signatureImportLax,

                sign: sign,
                verify: verify,
                recover: recover,

                ecdh: ecdh,
                ecdhUnsafe: ecdhUnsafe
              };
            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>ethereumjs-util", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\der.js", { "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\secp256k1-lib\der.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";

              // This file is imported from secp256k1 v3
              // https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

              var EC_PRIVKEY_EXPORT_DER_COMPRESSED = Buffer.from([
                // begin
                0x30, 0x81, 0xd3, 0x02, 0x01, 0x01, 0x04, 0x20,
                // private key
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                // middle
                0xa0, 0x81, 0x85, 0x30, 0x81, 0x82, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x21, 0x02, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x24, 0x03, 0x22, 0x00,
                // public key
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

              var EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED = Buffer.from([
                // begin
                0x30, 0x82, 0x01, 0x13, 0x02, 0x01, 0x01, 0x04, 0x20,
                // private key
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                // middle
                0xa0, 0x81, 0xa5, 0x30, 0x81, 0xa2, 0x02, 0x01, 0x01, 0x30, 0x2c, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x01, 0x01, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xff, 0xff, 0xfc, 0x2f, 0x30, 0x06, 0x04, 0x01, 0x00, 0x04, 0x01, 0x07, 0x04, 0x41, 0x04, 0x79, 0xbe, 0x66, 0x7e, 0xf9, 0xdc, 0xbb, 0xac, 0x55, 0xa0, 0x62, 0x95, 0xce, 0x87, 0x0b, 0x07, 0x02, 0x9b, 0xfc, 0xdb, 0x2d, 0xce, 0x28, 0xd9, 0x59, 0xf2, 0x81, 0x5b, 0x16, 0xf8, 0x17, 0x98, 0x48, 0x3a, 0xda, 0x77, 0x26, 0xa3, 0xc4, 0x65, 0x5d, 0xa4, 0xfb, 0xfc, 0x0e, 0x11, 0x08, 0xa8, 0xfd, 0x17, 0xb4, 0x48, 0xa6, 0x85, 0x54, 0x19, 0x9c, 0x47, 0xd0, 0x8f, 0xfb, 0x10, 0xd4, 0xb8, 0x02, 0x21, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0xba, 0xae, 0xdc, 0xe6, 0xaf, 0x48, 0xa0, 0x3b, 0xbf, 0xd2, 0x5e, 0x8c, 0xd0, 0x36, 0x41, 0x41, 0x02, 0x01, 0x01, 0xa1, 0x44, 0x03, 0x42, 0x00,
                // public key
                0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);

              exports.privateKeyExport = function (privateKey, publicKey, compressed) {
                var result = Buffer.from(compressed ? EC_PRIVKEY_EXPORT_DER_COMPRESSED : EC_PRIVKEY_EXPORT_DER_UNCOMPRESSED);
                privateKey.copy(result, compressed ? 8 : 9);
                publicKey.copy(result, compressed ? 181 : 214);
                return result;
              };

              exports.privateKeyImport = function (privateKey) {
                var length = privateKey.length;

                // sequence header
                var index = 0;
                if (length < index + 1 || privateKey[index] !== 0x30) return null;
                index += 1;

                // sequence length constructor
                if (length < index + 1 || !(privateKey[index] & 0x80)) return null;

                var lenb = privateKey[index] & 0x7f;
                index += 1;
                if (lenb < 1 || lenb > 2) return null;
                if (length < index + lenb) return null;

                // sequence length
                var len = privateKey[index + lenb - 1] | (lenb > 1 ? privateKey[index + lenb - 2] << 8 : 0);
                index += lenb;
                if (length < index + len) return null;

                // sequence element 0: version number (=1)
                if (length < index + 3 || privateKey[index] !== 0x02 || privateKey[index + 1] !== 0x01 || privateKey[index + 2] !== 0x01) {
                  return null;
                }
                index += 3;

                // sequence element 1: octet string, up to 32 bytes
                if (length < index + 2 || privateKey[index] !== 0x04 || privateKey[index + 1] > 0x20 || length < index + 2 + privateKey[index + 1]) {
                  return null;
                }

                return privateKey.slice(index + 2, index + 2 + privateKey[index + 1]);
              };

              exports.signatureImportLax = function (signature) {
                var r = Buffer.alloc(32, 0);
                var s = Buffer.alloc(32, 0);

                var length = signature.length;
                var index = 0;

                // sequence tag byte
                if (signature[index++] !== 0x30) {
                  return null;
                }

                // sequence length byte
                var lenbyte = signature[index++];
                if (lenbyte & 0x80) {
                  index += lenbyte - 0x80;
                  if (index > length) {
                    return null;
                  }
                }

                // sequence tag byte for r
                if (signature[index++] !== 0x02) {
                  return null;
                }

                // length for r
                var rlen = signature[index++];
                if (rlen & 0x80) {
                  lenbyte = rlen - 0x80;
                  if (index + lenbyte > length) {
                    return null;
                  }
                  for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) { }
                  for (rlen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
                    rlen = (rlen << 8) + signature[index];
                  }
                }
                if (rlen > length - index) {
                  return null;
                }
                var rindex = index;
                index += rlen;

                // sequence tag byte for s
                if (signature[index++] !== 0x02) {
                  return null;
                }

                // length for s
                var slen = signature[index++];
                if (slen & 0x80) {
                  lenbyte = slen - 0x80;
                  if (index + lenbyte > length) {
                    return null;
                  }
                  for (; lenbyte > 0 && signature[index] === 0x00; index += 1, lenbyte -= 1) { }
                  for (slen = 0; lenbyte > 0; index += 1, lenbyte -= 1) {
                    slen = (slen << 8) + signature[index];
                  }
                }
                if (slen > length - index) {
                  return null;
                }
                var sindex = index;
                index += slen;

                // ignore leading zeros in r
                for (; rlen > 0 && signature[rindex] === 0x00; rlen -= 1, rindex += 1) { }
                // copy r value
                if (rlen > 32) {
                  return null;
                }
                var rvalue = signature.slice(rindex, rindex + rlen);
                rvalue.copy(r, 32 - rvalue.length);

                // ignore leading zeros in s
                for (; slen > 0 && signature[sindex] === 0x00; slen -= 1, sindex += 1) { }
                // copy s value
                if (slen > 32) {
                  return null;
                }
                var svalue = signature.slice(sindex, sindex + slen);
                svalue.copy(s, 32 - svalue.length);

                return { r: r, s: s };
              };
            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>ethereumjs-util", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\secp256k1-lib\\index.js", { "bn.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bn.js\\lib\\bn.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "elliptic": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\elliptic\\lib\\elliptic.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethereumjs-util\dist\secp256k1-lib\index.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              'use strict';

              // This file is imported from secp256k1 v3
              // https://github.com/cryptocoinjs/secp256k1-node/blob/master/LICENSE

              var BN = require('bn.js');
              var EC = require('elliptic').ec;

              var ec = new EC('secp256k1');
              var ecparams = ec.curve;

              exports.privateKeyExport = function (privateKey, compressed) {
                var d = new BN(privateKey);
                if (d.ucmp(ecparams.n) >= 0) {
                  throw new Error('couldn\'t export to DER format');
                }

                var point = ec.g.mul(d);
                return toPublicKey(point.getX(), point.getY(), compressed);
              };

              exports.privateKeyModInverse = function (privateKey) {
                var bn = new BN(privateKey);
                if (bn.ucmp(ecparams.n) >= 0 || bn.isZero()) {
                  throw new Error('private key range is invalid');
                }

                return bn.invm(ecparams.n).toArrayLike(Buffer, 'be', 32);
              };

              exports.signatureImport = function (sigObj) {
                var r = new BN(sigObj.r);
                if (r.ucmp(ecparams.n) >= 0) {
                  r = new BN(0);
                }

                var s = new BN(sigObj.s);
                if (s.ucmp(ecparams.n) >= 0) {
                  s = new BN(0);
                }

                return Buffer.concat([r.toArrayLike(Buffer, 'be', 32), s.toArrayLike(Buffer, 'be', 32)]);
              };

              exports.ecdhUnsafe = function (publicKey, privateKey, compressed) {
                var point = ec.keyFromPublic(publicKey);

                var scalar = new BN(privateKey);
                if (scalar.ucmp(ecparams.n) >= 0 || scalar.isZero()) {
                  throw new Error('scalar was invalid (zero or overflow)');
                }

                var shared = point.pub.mul(scalar);
                return toPublicKey(shared.getX(), shared.getY(), compressed);
              };

              var toPublicKey = function toPublicKey(x, y, compressed) {
                var publicKey = void 0;

                if (compressed) {
                  publicKey = Buffer.alloc(33);
                  publicKey[0] = y.isOdd() ? 0x03 : 0x02;
                  x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
                } else {
                  publicKey = Buffer.alloc(65);
                  publicKey[0] = 0x04;
                  x.toArrayLike(Buffer, 'be', 32).copy(publicKey, 1);
                  y.toArrayLike(Buffer, 'be', 32).copy(publicKey, 33);
                }

                return publicKey;
              };
            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>ethereumjs-util", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethjs-util\\lib\\index.js", { "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "is-hex-prefixed": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\is-hex-prefixed\\src\\index.js", "strip-hex-prefix": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\strip-hex-prefix\\src\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\ethjs-util\lib\index.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              'use strict';

              var isHexPrefixed = require('is-hex-prefixed');
              var stripHexPrefix = require('strip-hex-prefix');

              /**
               * Pads a `String` to have an even length
               * @param {String} value
               * @return {String} output
               */
              function padToEven(value) {
                var a = value; // eslint-disable-line

                if (typeof a !== 'string') {
                  throw new Error('[ethjs-util] while padding to even, value must be string, is currently ' + typeof a + ', while padToEven.');
                }

                if (a.length % 2) {
                  a = '0' + a;
                }

                return a;
              }

              /**
               * Converts a `Number` into a hex `String`
               * @param {Number} i
               * @return {String}
               */
              function intToHex(i) {
                var hex = i.toString(16); // eslint-disable-line

                return '0x' + hex;
              }

              /**
               * Converts an `Number` to a `Buffer`
               * @param {Number} i
               * @return {Buffer}
               */
              function intToBuffer(i) {
                var hex = intToHex(i);

                return new Buffer(padToEven(hex.slice(2)), 'hex');
              }

              /**
               * Get the binary size of a string
               * @param {String} str
               * @return {Number}
               */
              function getBinarySize(str) {
                if (typeof str !== 'string') {
                  throw new Error('[ethjs-util] while getting binary size, method getBinarySize requires input \'str\' to be type String, got \'' + typeof str + '\'.');
                }

                return Buffer.byteLength(str, 'utf8');
              }

              /**
               * Returns TRUE if the first specified array contains all elements
               * from the second one. FALSE otherwise.
               *
               * @param {array} superset
               * @param {array} subset
               *
               * @returns {boolean}
               */
              function arrayContainsArray(superset, subset, some) {
                if (Array.isArray(superset) !== true) {
                  throw new Error('[ethjs-util] method arrayContainsArray requires input \'superset\' to be an array got type \'' + typeof superset + '\'');
                }
                if (Array.isArray(subset) !== true) {
                  throw new Error('[ethjs-util] method arrayContainsArray requires input \'subset\' to be an array got type \'' + typeof subset + '\'');
                }

                return subset[Boolean(some) && 'some' || 'every'](function (value) {
                  return superset.indexOf(value) >= 0;
                });
              }

              /**
               * Should be called to get utf8 from it's hex representation
               *
               * @method toUtf8
               * @param {String} string in hex
               * @returns {String} ascii string representation of hex value
               */
              function toUtf8(hex) {
                var bufferValue = new Buffer(padToEven(stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');

                return bufferValue.toString('utf8');
              }

              /**
               * Should be called to get ascii from it's hex representation
               *
               * @method toAscii
               * @param {String} string in hex
               * @returns {String} ascii string representation of hex value
               */
              function toAscii(hex) {
                var str = ''; // eslint-disable-line
                var i = 0,
                  l = hex.length; // eslint-disable-line

                if (hex.substring(0, 2) === '0x') {
                  i = 2;
                }

                for (; i < l; i += 2) {
                  var code = parseInt(hex.substr(i, 2), 16);
                  str += String.fromCharCode(code);
                }

                return str;
              }

              /**
               * Should be called to get hex representation (prefixed by 0x) of utf8 string
               *
               * @method fromUtf8
               * @param {String} string
               * @param {Number} optional padding
               * @returns {String} hex representation of input string
               */
              function fromUtf8(stringValue) {
                var str = new Buffer(stringValue, 'utf8');

                return '0x' + padToEven(str.toString('hex')).replace(/^0+|0+$/g, '');
              }

              /**
               * Should be called to get hex representation (prefixed by 0x) of ascii string
               *
               * @method fromAscii
               * @param {String} string
               * @param {Number} optional padding
               * @returns {String} hex representation of input string
               */
              function fromAscii(stringValue) {
                var hex = ''; // eslint-disable-line
                for (var i = 0; i < stringValue.length; i++) {
                  // eslint-disable-line
                  var code = stringValue.charCodeAt(i);
                  var n = code.toString(16);
                  hex += n.length < 2 ? '0' + n : n;
                }

                return '0x' + hex;
              }

              /**
               * getKeys([{a: 1, b: 2}, {a: 3, b: 4}], 'a') => [1, 3]
               *
               * @method getKeys get specific key from inner object array of objects
               * @param {String} params
               * @param {String} key
               * @param {Boolean} allowEmpty
               * @returns {Array} output just a simple array of output keys
               */
              function getKeys(params, key, allowEmpty) {
                if (!Array.isArray(params)) {
                  throw new Error('[ethjs-util] method getKeys expecting type Array as \'params\' input, got \'' + typeof params + '\'');
                }
                if (typeof key !== 'string') {
                  throw new Error('[ethjs-util] method getKeys expecting type String for input \'key\' got \'' + typeof key + '\'.');
                }

                var result = []; // eslint-disable-line

                for (var i = 0; i < params.length; i++) {
                  // eslint-disable-line
                  var value = params[i][key]; // eslint-disable-line
                  if (allowEmpty && !value) {
                    value = '';
                  } else if (typeof value !== 'string') {
                    throw new Error('invalid abi');
                  }
                  result.push(value);
                }

                return result;
              }

              /**
               * Is the string a hex string.
               *
               * @method check if string is hex string of specific length
               * @param {String} value
               * @param {Number} length
               * @returns {Boolean} output the string is a hex string
               */
              function isHexString(value, length) {
                if (typeof value !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
                  return false;
                }

                if (length && value.length !== 2 + 2 * length) {
                  return false;
                }

                return true;
              }

              module.exports = {
                arrayContainsArray: arrayContainsArray,
                intToBuffer: intToBuffer,
                getBinarySize: getBinarySize,
                isHexPrefixed: isHexPrefixed,
                stripHexPrefix: stripHexPrefix,
                padToEven: padToEven,
                intToHex: intToHex,
                fromAscii: fromAscii,
                fromUtf8: fromUtf8,
                toAscii: toAscii,
                toUtf8: toUtf8,
                getKeys: getKeys,
                isHexString: isHexString
              };
            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>ethereumjs-util>ethjs-util", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\json-rpc-engine\\src\\createAsyncMiddleware.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\json-rpc-engine\src\createAsyncMiddleware.js
        return function (require, module, exports) {
          /**
           * JsonRpcEngine only accepts callback-based middleware directly.
           * createAsyncMiddleware exists to enable consumers to pass in async middleware
           * functions.
           *
           * Async middleware have no "end" function. Instead, they "end" if they return
           * without calling "next". Rather than passing in explicit return handlers,
           * async middleware can simply await "next", and perform operations on the
           * response object when execution resumes.
           *
           * To accomplish this, createAsyncMiddleware passes the async middleware a
           * wrapped "next" function. That function calls the internal JsonRpcEngine
           * "next" function with a return handler that resolves a promise when called.
           *
           * The return handler will always be called. Its resolution of the promise
           * enables the control flow described above.
           */

          module.exports = function createAsyncMiddleware(asyncMiddleware) {
            return (req, res, next, end) => {

              // nextPromise is the key to the implementation
              // it is resolved by the return handler passed to the
              // "next" function
              let resolveNextPromise
              const nextPromise = new Promise((resolve) => {
                resolveNextPromise = resolve
              })

              let returnHandlerCallback, nextWasCalled

              const asyncNext = async () => {

                nextWasCalled = true

                next((callback) => { // eslint-disable-line callback-return
                  returnHandlerCallback = callback
                  resolveNextPromise()
                })
                await nextPromise
              }

              asyncMiddleware(req, res, asyncNext)
                .then(async () => {
                  if (nextWasCalled) {
                    await nextPromise // we must wait until the return handler is called
                    returnHandlerCallback(null)
                  } else {
                    end(null)
                  }
                })
                .catch((error) => {
                  if (returnHandlerCallback) {
                    returnHandlerCallback(error)
                  } else {
                    end(error)
                  }
                })
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-json-rpc-middleware>json-rpc-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\pify\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\node_modules\pify\index.js
        return function (require, module, exports) {
          'use strict';

          const processFn = (fn, opts) => function () {
            const P = opts.promiseModule;
            const args = new Array(arguments.length);

            for (let i = 0; i < arguments.length; i++) {
              args[i] = arguments[i];
            }

            return new P((resolve, reject) => {
              if (opts.errorFirst) {
                args.push(function (err, result) {
                  if (opts.multiArgs) {
                    const results = new Array(arguments.length - 1);

                    for (let i = 1; i < arguments.length; i++) {
                      results[i - 1] = arguments[i];
                    }

                    if (err) {
                      results.unshift(err);
                      reject(results);
                    } else {
                      resolve(results);
                    }
                  } else if (err) {
                    reject(err);
                  } else {
                    resolve(result);
                  }
                });
              } else {
                args.push(function (result) {
                  if (opts.multiArgs) {
                    const results = new Array(arguments.length - 1);

                    for (let i = 0; i < arguments.length; i++) {
                      results[i] = arguments[i];
                    }

                    resolve(results);
                  } else {
                    resolve(result);
                  }
                });
              }

              fn.apply(this, args);
            });
          };

          module.exports = (obj, opts) => {
            opts = Object.assign({
              exclude: [/.+(Sync|Stream)$/],
              errorFirst: true,
              promiseModule: Promise
            }, opts);

            const filter = key => {
              const match = pattern => typeof pattern === 'string' ? key === pattern : pattern.test(key);
              return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
            };

            let ret;
            if (typeof obj === 'function') {
              ret = function () {
                if (opts.excludeMain) {
                  return obj.apply(this, arguments);
                }

                return processFn(obj, opts).apply(this, arguments);
              };
            } else {
              ret = Object.create(Object.getPrototypeOf(obj));
            }

            for (const key in obj) { // eslint-disable-line guard-for-in
              const x = obj[key];
              ret[key] = typeof x === 'function' && filter(key) ? processFn(x, opts) : x;
            }

            return ret;
          };

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine>eth-block-tracker>pify", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\package.json", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\package.json
        return function (require, module, exports) {
          module.exports = {
            "name": "web3-provider-engine",
            "version": "16.0.3",
            "description": "A JavaScript library for composing Ethereum provider objects using middleware modules",
            "repository": "https://github.com/MetaMask/web3-provider-engine",
            "main": "index.js",
            "engines": {
              "node": ">=12.0.0"
            },
            "scripts": {
              "test": "node test/index.js && yarn lint",
              "prepublishOnly": "yarn build && yarn bundle",
              "build": "babel zero.js index.js -d dist/es5 && babel subproviders -d dist/es5/subproviders && babel util -d dist/es5/util",
              "bundle": "mkdir -p ./dist && yarn bundle-engine && yarn bundle-zero",
              "bundle-zero": "browserify -s ZeroClientProvider -e zero.js -t [ babelify --presets [ @babel/preset-env ] ] > dist/ZeroClientProvider.js",
              "bundle-engine": "browserify -s ProviderEngine -e index.js -t [ babelify --presets [ @babel/preset-env ] ] > dist/ProviderEngine.js",
              "lint": "eslint --quiet --ignore-path .gitignore ."
            },
            "files": [
              "*.js",
              "dist",
              "subproviders",
              "util"
            ],
            "license": "MIT",
            "resolutions": {
              "ganache-core/**/elliptic": "^6.5.2"
            },
            "dependencies": {
              "@ethereumjs/tx": "^3.3.0",
              "async": "^2.5.0",
              "backoff": "^2.5.0",
              "clone": "^2.0.0",
              "cross-fetch": "^2.1.0",
              "eth-block-tracker": "^4.4.2",
              "eth-json-rpc-filters": "^4.2.1",
              "eth-json-rpc-infura": "^5.1.0",
              "eth-json-rpc-middleware": "^6.0.0",
              "eth-rpc-errors": "^3.0.0",
              "eth-sig-util": "^1.4.2",
              "ethereumjs-block": "^1.2.2",
              "ethereumjs-util": "^5.1.5",
              "ethereumjs-vm": "^2.3.4",
              "json-stable-stringify": "^1.0.1",
              "promise-to-callback": "^1.0.0",
              "readable-stream": "^2.2.9",
              "request": "^2.85.0",
              "semaphore": "^1.0.3",
              "ws": "^5.1.1",
              "xhr": "^2.2.0",
              "xtend": "^4.0.1"
            },
            "devDependencies": {
              "@babel/cli": "^7.5.5",
              "@babel/core": "^7.5.5",
              "@babel/preset-env": "^7.5.5",
              "babelify": "^10.0.0",
              "browserify": "^16.5.0",
              "eslint": "^6.2.0",
              "ethjs": "^0.3.6",
              "ganache-core": "^2.7.0",
              "tape": "^4.4.0"
            },
            "browser": {
              "request": false,
              "ws": false
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\cache.js", { "./json-rpc-engine-middleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js", "eth-json-rpc-middleware/block-cache": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\block-cache.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\cache.js
        return function (require, module, exports) {
          const ProviderSubprovider = require('./json-rpc-engine-middleware')
          const createBlockCacheMiddleware = require('eth-json-rpc-middleware/block-cache')

          class BlockCacheSubprovider extends ProviderSubprovider {
            constructor(opts) {
              super(({ blockTracker }) => createBlockCacheMiddleware(Object.assign({ blockTracker }, opts)))
            }
          }

          module.exports = BlockCacheSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\default-fixture.js", { "../package.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\package.json", "./fixture.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fixture.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js", "xtend": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\default-fixture.js
        return function (require, module, exports) {
          const inherits = require('util').inherits
          const extend = require('xtend')
          const FixtureProvider = require('./fixture.js')
          const version = require('../package.json').version

          module.exports = DefaultFixtures

          inherits(DefaultFixtures, FixtureProvider)

          function DefaultFixtures(opts) {
            const self = this
            opts = opts || {}
            var responses = extend({
              web3_clientVersion: 'ProviderEngine/v' + version + '/javascript',
              net_listening: true,
              eth_hashrate: '0x00',
              eth_mining: false,
            }, opts)
            FixtureProvider.call(self, responses)
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fetch.js", { "./json-rpc-engine-middleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js", "eth-json-rpc-middleware/fetch": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\fetch.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\fetch.js
        return function (require, module, exports) {
          const ProviderSubprovider = require('./json-rpc-engine-middleware')
          const createFetchMiddleware = require('eth-json-rpc-middleware/fetch')

          class FetchSubprovider extends ProviderSubprovider {
            constructor(opts) {
              super(({ blockTracker, provider, engine }) => {
                return createFetchMiddleware(opts)
              })
            }
          }

          module.exports = FetchSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\filters.js", { "./json-rpc-engine-middleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js", "eth-json-rpc-filters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-filters\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\filters.js
        return function (require, module, exports) {
          const ProviderSubprovider = require('./json-rpc-engine-middleware')
          const createFilterMiddleware = require('eth-json-rpc-filters')

          class SubscriptionsSubprovider extends ProviderSubprovider {
            constructor() {
              super(({ blockTracker, provider, engine }) => {
                return createFilterMiddleware({ blockTracker, provider })
              })
            }
          }

          module.exports = SubscriptionsSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fixture.js", { "./subprovider.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\fixture.js
        return function (require, module, exports) {
          const inherits = require('util').inherits
          const Subprovider = require('./subprovider.js')

          module.exports = FixtureProvider

          inherits(FixtureProvider, Subprovider)

          function FixtureProvider(staticResponses) {
            const self = this
            staticResponses = staticResponses || {}
            self.staticResponses = staticResponses
          }

          FixtureProvider.prototype.handleRequest = function (payload, next, end) {
            const self = this
            var staticResponse = self.staticResponses[payload.method]
            // async function
            if ('function' === typeof staticResponse) {
              staticResponse(payload, next, end)
              // static response - null is valid response
            } else if (staticResponse !== undefined) {
              // return result asynchronously
              setTimeout(() => end(null, staticResponse))
              // no prepared response - skip
            } else {
              next()
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\hooked-wallet.js", { "../util/estimate-gas.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\estimate-gas.js", "./subprovider.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", "async/parallel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\parallel.js", "async/waterfall": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\async\\waterfall.js", "eth-sig-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-sig-util\\index.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js", "semaphore": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\semaphore\\lib\\semaphore.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js", "xtend": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\hooked-wallet.js
        return function (require, module, exports) {
          /*
           * Emulate 'eth_accounts' / 'eth_sendTransaction' using 'eth_sendRawTransaction'
           *
           * The two callbacks a user needs to implement are:
           * - getAccounts() -- array of addresses supported
           * - signTransaction(tx) -- sign a raw transaction object
           */

          const waterfall = require('async/waterfall')
          const parallel = require('async/parallel')
          const inherits = require('util').inherits
          const ethUtil = require('ethereumjs-util')
          const sigUtil = require('eth-sig-util')
          const extend = require('xtend')
          const Semaphore = require('semaphore')
          const Subprovider = require('./subprovider.js')
          const estimateGas = require('../util/estimate-gas.js')
          const hexRegex = /^[0-9A-Fa-f]+$/g

          module.exports = HookedWalletSubprovider

          // handles the following RPC methods:
          //   eth_coinbase
          //   eth_accounts
          //   eth_sendTransaction
          //   eth_sign
          //   eth_signTypedData
          //   eth_signTypedData_v3
          //   eth_signTypedData_v4
          //   personal_sign
          //   eth_decryptMessage
          //   encryption_public_key
          //   personal_ecRecover
          //   parity_postTransaction
          //   parity_checkRequest
          //   parity_defaultAccount

          //
          // Tx Signature Flow
          //
          // handleRequest: eth_sendTransaction
          //   validateTransaction (basic validity check)
          //     validateSender (checks that sender is in accounts)
          //   processTransaction (sign tx and submit to network)
          //     approveTransaction (UI approval hook)
          //     checkApproval
          //     finalizeAndSubmitTx (tx signing)
          //       nonceLock.take (bottle neck to ensure atomic nonce)
          //         fillInTxExtras (set fallback gasPrice, nonce, etc)
          //         signTransaction (perform the signature)
          //         publishTransaction (publish signed tx to network)
          //


          inherits(HookedWalletSubprovider, Subprovider)

          function HookedWalletSubprovider(opts) {
            const self = this
            // control flow
            self.nonceLock = Semaphore(1)

            // data lookup
            if (opts.getAccounts) self.getAccounts = opts.getAccounts
            // high level override
            if (opts.processTransaction) self.processTransaction = opts.processTransaction
            if (opts.processMessage) self.processMessage = opts.processMessage
            if (opts.processPersonalMessage) self.processPersonalMessage = opts.processPersonalMessage
            if (opts.processTypedMessage) self.processTypedMessage = opts.processTypedMessage
            // approval hooks
            self.approveTransaction = opts.approveTransaction || self.autoApprove
            self.approveMessage = opts.approveMessage || self.autoApprove
            self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove
            self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove
            self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove
            self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove
            // actually perform the signature
            if (opts.signTransaction) self.signTransaction = opts.signTransaction || mustProvideInConstructor('signTransaction')
            if (opts.signMessage) self.signMessage = opts.signMessage || mustProvideInConstructor('signMessage')
            if (opts.signPersonalMessage) self.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor('signPersonalMessage')
            if (opts.decryptMessage) self.decryptMessage = opts.decryptMessage || mustProvideInConstructor('decryptMessage')
            if (opts.encryptionPublicKey) self.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor('encryptionPublicKey')
            if (opts.signTypedMessage) self.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor('signTypedMessage')
            if (opts.recoverPersonalSignature) self.recoverPersonalSignature = opts.recoverPersonalSignature
            // publish to network
            if (opts.publishTransaction) self.publishTransaction = opts.publishTransaction
            // gas options
            self.estimateGas = opts.estimateGas || self.estimateGas
            self.getGasPrice = opts.getGasPrice || self.getGasPrice
          }

          HookedWalletSubprovider.prototype.handleRequest = function (payload, next, end) {
            const self = this
            self._parityRequests = {}
            self._parityRequestCount = 0

            // switch statement is not block scoped
            // sp we cant repeat var declarations
            let txParams, msgParams, extraParams
            let message, address

            switch (payload.method) {

              case 'eth_coinbase':
                // process normally
                self.getAccounts(function (err, accounts) {
                  if (err) return end(err)
                  let result = accounts[0] || null
                  end(null, result)
                })
                return

              case 'eth_accounts':
                // process normally
                self.getAccounts(function (err, accounts) {
                  if (err) return end(err)
                  end(null, accounts)
                })
                return

              case 'eth_sendTransaction':
                txParams = payload.params[0]
                waterfall([
                  (cb) => self.validateTransaction(txParams, cb),
                  (cb) => self.processTransaction(txParams, cb),
                ], end)
                return

              case 'eth_signTransaction':
                txParams = payload.params[0]
                waterfall([
                  (cb) => self.validateTransaction(txParams, cb),
                  (cb) => self.processSignTransaction(txParams, cb),
                ], end)
                return

              case 'eth_sign':
                // process normally
                address = payload.params[0]
                message = payload.params[1]
                // non-standard "extraParams" to be appended to our "msgParams" obj
                // good place for metadata
                extraParams = payload.params[2] || {}
                msgParams = extend(extraParams, {
                  from: address,
                  data: message,
                })
                waterfall([
                  (cb) => self.validateMessage(msgParams, cb),
                  (cb) => self.processMessage(msgParams, cb),
                ], end)
                return

              case 'personal_sign':
                return (function () {
                  // process normally
                  const first = payload.params[0]
                  const second = payload.params[1]

                  // We initially incorrectly ordered these parameters.
                  // To gracefully respect users who adopted this API early,
                  // we are currently gracefully recovering from the wrong param order
                  // when it is clearly identifiable.
                  //
                  // That means when the first param is definitely an address,
                  // and the second param is definitely not, but is hex.
                  if (resemblesData(second) && resemblesAddress(first)) {
                    let warning = `The eth_personalSign method requires params ordered `
                    warning += `[message, address]. This was previously handled incorrectly, `
                    warning += `and has been corrected automatically. `
                    warning += `Please switch this param order for smooth behavior in the future.`
                    console.warn(warning)

                    address = payload.params[0]
                    message = payload.params[1]
                  } else {
                    message = payload.params[0]
                    address = payload.params[1]
                  }

                  // non-standard "extraParams" to be appended to our "msgParams" obj
                  // good place for metadata
                  extraParams = payload.params[2] || {}
                  msgParams = extend(extraParams, {
                    from: address,
                    data: message,
                  })
                  waterfall([
                    (cb) => self.validatePersonalMessage(msgParams, cb),
                    (cb) => self.processPersonalMessage(msgParams, cb),
                  ], end)
                })()

              case 'eth_decryptMessage':
                return (function () {
                  // process normally
                  const first = payload.params[0]
                  const second = payload.params[1]

                  // We initially incorrectly ordered these parameters.
                  // To gracefully respect users who adopted this API early,
                  // we are currently gracefully recovering from the wrong param order
                  // when it is clearly identifiable.
                  //
                  // That means when the first param is definitely an address,
                  // and the second param is definitely not, but is hex.
                  if (resemblesData(second) && resemblesAddress(first)) {
                    let warning = `The eth_decryptMessage method requires params ordered `
                    warning += `[message, address]. This was previously handled incorrectly, `
                    warning += `and has been corrected automatically. `
                    warning += `Please switch this param order for smooth behavior in the future.`
                    console.warn(warning)

                    address = payload.params[0]
                    message = payload.params[1]
                  } else {
                    message = payload.params[0]
                    address = payload.params[1]
                  }

                  // non-standard "extraParams" to be appended to our "msgParams" obj
                  // good place for metadata
                  extraParams = payload.params[2] || {}
                  msgParams = extend(extraParams, {
                    from: address,
                    data: message,
                  })
                  waterfall([
                    (cb) => self.validateDecryptMessage(msgParams, cb),
                    (cb) => self.processDecryptMessage(msgParams, cb),
                  ], end)
                })()

              case 'encryption_public_key':
                return (function () {
                  const address = payload.params[0]

                  waterfall([
                    (cb) => self.validateEncryptionPublicKey(address, cb),
                    (cb) => self.processEncryptionPublicKey(address, cb),
                  ], end)
                })()

              case 'personal_ecRecover':
                return (function () {
                  message = payload.params[0]
                  let signature = payload.params[1]
                  // non-standard "extraParams" to be appended to our "msgParams" obj
                  // good place for metadata
                  extraParams = payload.params[2] || {}
                  msgParams = extend(extraParams, {
                    sig: signature,
                    data: message,
                  })
                  self.recoverPersonalSignature(msgParams, end)
                })()

              case 'eth_signTypedData':
              case 'eth_signTypedData_v3':
              case 'eth_signTypedData_v4':
                return (function () {
                  // process normally

                  const first = payload.params[0]
                  const second = payload.params[1]

                  if (resemblesAddress(first)) {
                    address = first
                    message = second
                  } else {
                    message = first
                    address = second
                  }

                  extraParams = payload.params[2] || {}
                  msgParams = extend(extraParams, {
                    from: address,
                    data: message,
                  })
                  waterfall([
                    (cb) => self.validateTypedMessage(msgParams, cb),
                    (cb) => self.processTypedMessage(msgParams, cb),
                  ], end)
                })()

              case 'parity_postTransaction':
                txParams = payload.params[0]
                self.parityPostTransaction(txParams, end)
                return

              case 'parity_postSign':
                address = payload.params[0]
                message = payload.params[1]
                self.parityPostSign(address, message, end)
                return

              case 'parity_checkRequest':
                return (function () {
                  const requestId = payload.params[0]
                  self.parityCheckRequest(requestId, end)
                })()

              case 'parity_defaultAccount':
                self.getAccounts(function (err, accounts) {
                  if (err) return end(err)
                  const account = accounts[0] || null
                  end(null, account)
                })
                return

              default:
                next()
                return

            }
          }

          //
          // data lookup
          //

          HookedWalletSubprovider.prototype.getAccounts = function (cb) {
            cb(null, [])
          }


          //
          // "process" high level flow
          //

          HookedWalletSubprovider.prototype.processTransaction = function (txParams, cb) {
            const self = this
            waterfall([
              (cb) => self.approveTransaction(txParams, cb),
              (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),
              (cb) => self.finalizeAndSubmitTx(txParams, cb),
            ], cb)
          }


          HookedWalletSubprovider.prototype.processSignTransaction = function (txParams, cb) {
            const self = this
            waterfall([
              (cb) => self.approveTransaction(txParams, cb),
              (didApprove, cb) => self.checkApproval('transaction', didApprove, cb),
              (cb) => self.finalizeTx(txParams, cb),
            ], cb)
          }

          HookedWalletSubprovider.prototype.processMessage = function (msgParams, cb) {
            const self = this
            waterfall([
              (cb) => self.approveMessage(msgParams, cb),
              (didApprove, cb) => self.checkApproval('message', didApprove, cb),
              (cb) => self.signMessage(msgParams, cb),
            ], cb)
          }

          HookedWalletSubprovider.prototype.processPersonalMessage = function (msgParams, cb) {
            const self = this
            waterfall([
              (cb) => self.approvePersonalMessage(msgParams, cb),
              (didApprove, cb) => self.checkApproval('message', didApprove, cb),
              (cb) => self.signPersonalMessage(msgParams, cb),
            ], cb)
          }

          HookedWalletSubprovider.prototype.processDecryptMessage = function (msgParams, cb) {
            const self = this
            waterfall([
              (cb) => self.approveDecryptMessage(msgParams, cb),
              (didApprove, cb) => self.checkApproval('decryptMessage', didApprove, cb),
              (cb) => self.decryptMessage(msgParams, cb),
            ], cb)
          }

          HookedWalletSubprovider.prototype.processEncryptionPublicKey = function (msgParams, cb) {
            const self = this
            waterfall([
              (cb) => self.approveEncryptionPublicKey(msgParams, cb),
              (didApprove, cb) => self.checkApproval('encryptionPublicKey', didApprove, cb),
              (cb) => self.encryptionPublicKey(msgParams, cb),
            ], cb)
          }

          HookedWalletSubprovider.prototype.processTypedMessage = function (msgParams, cb) {
            const self = this
            waterfall([
              (cb) => self.approveTypedMessage(msgParams, cb),
              (didApprove, cb) => self.checkApproval('message', didApprove, cb),
              (cb) => self.signTypedMessage(msgParams, cb),
            ], cb)
          }

          //
          // approval
          //

          HookedWalletSubprovider.prototype.autoApprove = function (txParams, cb) {
            cb(null, true)
          }

          HookedWalletSubprovider.prototype.checkApproval = function (type, didApprove, cb) {
            cb(didApprove ? null : new Error('User denied ' + type + ' signature.'))
          }

          //
          // parity
          //

          HookedWalletSubprovider.prototype.parityPostTransaction = function (txParams, cb) {
            const self = this

            // get next id
            const count = self._parityRequestCount
            const reqId = `0x${count.toString(16)}`
            self._parityRequestCount++

            self.emitPayload({
              method: 'eth_sendTransaction',
              params: [txParams],
            }, function (error, res) {
              if (error) {
                self._parityRequests[reqId] = { error }
                return
              }
              const txHash = res.result
              self._parityRequests[reqId] = txHash
            })

            cb(null, reqId)
          }


          HookedWalletSubprovider.prototype.parityPostSign = function (address, message, cb) {
            const self = this

            // get next id
            const count = self._parityRequestCount
            const reqId = `0x${count.toString(16)}`
            self._parityRequestCount++

            self.emitPayload({
              method: 'eth_sign',
              params: [address, message],
            }, function (error, res) {
              if (error) {
                self._parityRequests[reqId] = { error }
                return
              }
              const result = res.result
              self._parityRequests[reqId] = result
            })

            cb(null, reqId)
          }

          HookedWalletSubprovider.prototype.parityCheckRequest = function (reqId, cb) {
            const self = this
            const result = self._parityRequests[reqId] || null
            // tx not handled yet
            if (!result) return cb(null, null)
            // tx was rejected (or other error)
            if (result.error) return cb(result.error)
            // tx sent
            cb(null, result)
          }

          //
          // signature and recovery
          //

          HookedWalletSubprovider.prototype.recoverPersonalSignature = function (msgParams, cb) {
            let senderHex
            try {
              senderHex = sigUtil.recoverPersonalSignature(msgParams)
            } catch (err) {
              return cb(err)
            }
            cb(null, senderHex)
          }

          //
          // validation
          //

          HookedWalletSubprovider.prototype.validateTransaction = function (txParams, cb) {
            const self = this
            // shortcut: undefined sender is invalid
            if (txParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign transaction.`))
            self.validateSender(txParams.from, function (err, senderIsValid) {
              if (err) return cb(err)
              if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign transaction for this address: "${txParams.from}"`))
              cb()
            })
          }

          HookedWalletSubprovider.prototype.validateMessage = function (msgParams, cb) {
            const self = this
            if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign message.`))
            self.validateSender(msgParams.from, function (err, senderIsValid) {
              if (err) return cb(err)
              if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`))
              cb()
            })
          }

          HookedWalletSubprovider.prototype.validatePersonalMessage = function (msgParams, cb) {
            const self = this
            if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign personal message.`))
            if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to sign personal message.`))
            if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateMessage - message was not encoded as hex.`))
            self.validateSender(msgParams.from, function (err, senderIsValid) {
              if (err) return cb(err)
              if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`))
              cb()
            })
          }

          HookedWalletSubprovider.prototype.validateDecryptMessage = function (msgParams, cb) {
            const self = this
            if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to decrypt message.`))
            if (msgParams.data === undefined) return cb(new Error(`Undefined message - message required to decrypt message.`))
            if (!isValidHex(msgParams.data)) return cb(new Error(`HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex.`))
            self.validateSender(msgParams.from, function (err, senderIsValid) {
              if (err) return cb(err)
              if (!senderIsValid) return cb(new Error(`Unknown address - unable to decrypt message for this address: "${msgParams.from}"`))
              cb()
            })
          }

          HookedWalletSubprovider.prototype.validateEncryptionPublicKey = function (address, cb) {
            const self = this

            self.validateSender(address, function (err, senderIsValid) {
              if (err) return cb(err)
              if (!senderIsValid) return cb(new Error(`Unknown address - unable to obtain encryption public key for this address: "${address}"`))
              cb()
            })
          }

          HookedWalletSubprovider.prototype.validateTypedMessage = function (msgParams, cb) {
            if (msgParams.from === undefined) return cb(new Error(`Undefined address - from address required to sign typed data.`))
            if (msgParams.data === undefined) return cb(new Error(`Undefined data - message required to sign typed data.`))
            this.validateSender(msgParams.from, function (err, senderIsValid) {
              if (err) return cb(err)
              if (!senderIsValid) return cb(new Error(`Unknown address - unable to sign message for this address: "${msgParams.from}"`))
              cb()
            })
          }

          HookedWalletSubprovider.prototype.validateSender = function (senderAddress, cb) {
            const self = this
            // shortcut: undefined sender is invalid
            if (!senderAddress) return cb(null, false)
            self.getAccounts(function (err, accounts) {
              if (err) return cb(err)
              const senderIsValid = (accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1)
              cb(null, senderIsValid)
            })
          }

          //
          // tx helpers
          //

          HookedWalletSubprovider.prototype.finalizeAndSubmitTx = function (txParams, cb) {
            const self = this
            // can only allow one tx to pass through this flow at a time
            // so we can atomically consume a nonce
            self.nonceLock.take(function () {
              waterfall([
                self.fillInTxExtras.bind(self, txParams),
                self.signTransaction.bind(self),
                self.publishTransaction.bind(self),
              ], function (err, txHash) {
                self.nonceLock.leave()
                if (err) return cb(err)
                cb(null, txHash)
              })
            })
          }

          HookedWalletSubprovider.prototype.finalizeTx = function (txParams, cb) {
            const self = this
            // can only allow one tx to pass through this flow at a time
            // so we can atomically consume a nonce
            self.nonceLock.take(function () {
              waterfall([
                self.fillInTxExtras.bind(self, txParams),
                self.signTransaction.bind(self),
              ], function (err, signedTx) {
                self.nonceLock.leave()
                if (err) return cb(err)
                cb(null, { raw: signedTx, tx: txParams })
              })
            })
          }

          HookedWalletSubprovider.prototype.publishTransaction = function (rawTx, cb) {
            const self = this
            self.emitPayload({
              method: 'eth_sendRawTransaction',
              params: [rawTx],
            }, function (err, res) {
              if (err) return cb(err)
              cb(null, res.result)
            })
          }

          HookedWalletSubprovider.prototype.estimateGas = function (txParams, cb) {
            const self = this
            estimateGas(self.engine, txParams, cb)
          }

          HookedWalletSubprovider.prototype.getGasPrice = function (cb) {
            const self = this
            self.emitPayload({ method: 'eth_gasPrice', params: [] }, function (err, res) {
              if (err) return cb(err)
              cb(null, res.result)
            })
          }

          HookedWalletSubprovider.prototype.fillInTxExtras = function (txParams, cb) {
            const self = this
            const address = txParams.from
            // console.log('fillInTxExtras - address:', address)

            const tasks = {}

            if (txParams.gasPrice === undefined) {
              // console.log("need to get gasprice")
              tasks.gasPrice = self.getGasPrice.bind(self)
            }

            if (txParams.nonce === undefined) {
              // console.log("need to get nonce")
              tasks.nonce = self.emitPayload.bind(self, { method: 'eth_getTransactionCount', params: [address, 'pending'] })
            }

            if (txParams.gas === undefined) {
              // console.log("need to get gas")
              tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams))
            }

            parallel(tasks, function (err, taskResults) {
              if (err) return cb(err)

              const result = {}
              if (taskResults.gasPrice) result.gasPrice = taskResults.gasPrice
              if (taskResults.nonce) result.nonce = taskResults.nonce.result
              if (taskResults.gas) result.gas = taskResults.gas

              cb(null, extend(txParams, result))
            })
          }

          // util

          // we use this to clean any custom params from the txParams
          function cloneTxParams(txParams) {
            return {
              from: txParams.from,
              to: txParams.to,
              value: txParams.value,
              data: txParams.data,
              gas: txParams.gas,
              gasPrice: txParams.gasPrice,
              nonce: txParams.nonce,
            }
          }

          function toLowerCase(string) {
            return string.toLowerCase()
          }

          function resemblesAddress(string) {
            const fixed = ethUtil.addHexPrefix(string)
            const isValid = ethUtil.isValidAddress(fixed)
            return isValid
          }

          // Returns true if resembles hex data
          // but definitely not a valid address.
          function resemblesData(string) {
            const fixed = ethUtil.addHexPrefix(string)
            const isValidAddress = ethUtil.isValidAddress(fixed)
            return !isValidAddress && isValidHex(string)
          }

          function isValidHex(data) {
            const isString = typeof data === 'string'
            if (!isString) return false
            const isHexPrefixed = data.slice(0, 2) === '0x'
            if (!isHexPrefixed) return false
            const nonPrefixed = data.slice(2)
            const isValid = nonPrefixed.match(hexRegex)
            return isValid
          }

          function mustProvideInConstructor(methodName) {
            return function (params, cb) {
              cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'))
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\inflight-cache.js", { "./json-rpc-engine-middleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js", "eth-json-rpc-middleware/inflight-cache": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\eth-json-rpc-middleware\\inflight-cache.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\inflight-cache.js
        return function (require, module, exports) {
          const ProviderSubprovider = require('./json-rpc-engine-middleware')
          const createInflightCacheMiddleware = require('eth-json-rpc-middleware/inflight-cache')

          class InflightCacheSubprovider extends ProviderSubprovider {
            constructor(opts) {
              super(() => createInflightCacheMiddleware(opts))
            }
          }

          module.exports = InflightCacheSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\infura.js", { "./provider.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\provider.js", "eth-json-rpc-infura/src/createProvider": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-infura\\src\\createProvider.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\infura.js
        return function (require, module, exports) {
          const createInfuraProvider = require('eth-json-rpc-infura/src/createProvider')
          const ProviderSubprovider = require('./provider.js')

          class InfuraSubprovider extends ProviderSubprovider {
            constructor(opts = {}) {
              const provider = createInfuraProvider(opts)
              super(provider)
            }
          }

          module.exports = InfuraSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js", { "./subprovider.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\json-rpc-engine-middleware.js
        return function (require, module, exports) {
          const Subprovider = require('./subprovider.js')

          // wraps a json-rpc-engine middleware in a subprovider interface

          class JsonRpcEngineMiddlewareSubprovider extends Subprovider {

            // take a constructorFn to call once we have a reference to the engine
            constructor(constructorFn) {
              super()
              if (!constructorFn) throw new Error('JsonRpcEngineMiddlewareSubprovider - no constructorFn specified')
              this._constructorFn = constructorFn
            }

            // this is called once the subprovider has been added to the provider engine
            setEngine(engine) {
              if (this.middleware) throw new Error('JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice')
              const blockTracker = engine._blockTracker
              const middleware = this._constructorFn({ engine, provider: engine, blockTracker })
              if (!middleware) throw new Error('JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware')
              if (typeof middleware !== 'function') throw new Error('JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function')
              this.middleware = middleware
            }

            handleRequest(req, provEngNext, provEngEnd) {
              const res = { id: req.id }
              this.middleware(req, res, middlewareNext, middlewareEnd)

              function middlewareNext(handler) {
                provEngNext((err, result, cb) => {
                  // update response object with result or error
                  if (err) {
                    delete res.result
                    res.error = { message: err.message || err }
                  } else {
                    res.result = result
                  }
                  // call middleware's next handler (even if error)
                  if (handler) {
                    handler(cb)
                  } else {
                    cb()
                  }
                })
              }

              function middlewareEnd(err) {
                if (err) return provEngEnd(err)
                provEngEnd(null, res.result)
              }
            }

          }

          module.exports = JsonRpcEngineMiddlewareSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\nonce-tracker.js", { "../util/rpc-cache-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\rpc-cache-utils.js", "./subprovider.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", "@ethereumjs/tx": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\nonce-tracker.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              const inherits = require('util').inherits
              const { TransactionFactory } = require('@ethereumjs/tx')
              const ethUtil = require('ethereumjs-util')
              const Subprovider = require('./subprovider.js')
              const blockTagForPayload = require('../util/rpc-cache-utils').blockTagForPayload

              module.exports = NonceTrackerSubprovider

              // handles the following RPC methods:
              //   eth_getTransactionCount (pending only)
              //
              // observes the following RPC methods:
              //   eth_sendRawTransaction
              //   evm_revert (to clear the nonce cache)

              inherits(NonceTrackerSubprovider, Subprovider)

              function NonceTrackerSubprovider() {
                const self = this

                self.nonceCache = {}
              }

              NonceTrackerSubprovider.prototype.handleRequest = function (payload, next, end) {
                const self = this

                switch (payload.method) {

                  case 'eth_getTransactionCount':
                    var blockTag = blockTagForPayload(payload)
                    var address = payload.params[0].toLowerCase()
                    var cachedResult = self.nonceCache[address]
                    // only handle requests against the 'pending' blockTag
                    if (blockTag === 'pending') {
                      // has a result
                      if (cachedResult) {
                        end(null, cachedResult)
                        // fallthrough then populate cache
                      } else {
                        next(function (err, result, cb) {
                          if (err) return cb()
                          if (self.nonceCache[address] === undefined) {
                            self.nonceCache[address] = result
                          }
                          cb()
                        })
                      }
                    } else {
                      next()
                    }
                    return

                  case 'eth_sendRawTransaction':
                    // allow the request to continue normally
                    next(function (err, result, cb) {
                      // only update local nonce if tx was submitted correctly
                      if (err) return cb()
                      // parse raw tx
                      var rawTx = payload.params[0]
                      var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), 'hex')
                      const tx = TransactionFactory.fromSerializedData(rawData)
                      // extract address
                      var address = tx.getSenderAddress().toString('hex').toLowerCase()
                      // extract nonce and increment
                      var nonce = ethUtil.bufferToInt(tx.nonce)
                      nonce++
                      // hexify and normalize
                      var hexNonce = nonce.toString(16)
                      if (hexNonce.length % 2) hexNonce = '0' + hexNonce
                      hexNonce = '0x' + hexNonce
                      // dont update our record on the nonce until the submit was successful
                      // update cache
                      self.nonceCache[address] = hexNonce
                      cb()
                    })
                    return

                  // Clear cache on a testrpc revert
                  case 'evm_revert':
                    self.nonceCache = {}
                    next()
                    return

                  default:
                    next()
                    return

                }
              }

            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\provider.js", { "./subprovider.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\provider.js
        return function (require, module, exports) {
          const inherits = require('util').inherits
          const Subprovider = require('./subprovider.js')

          // wraps a provider in a subprovider interface

          module.exports = ProviderSubprovider

          inherits(ProviderSubprovider, Subprovider)

          function ProviderSubprovider(provider) {
            if (!provider) throw new Error('ProviderSubprovider - no provider specified')
            if (!provider.sendAsync) throw new Error('ProviderSubprovider - specified provider does not have a sendAsync method')
            this.provider = provider
          }

          ProviderSubprovider.prototype.handleRequest = function (payload, next, end) {
            this.provider.sendAsync(payload, function (err, response) {
              if (err) return end(err)
              if (response.error) return end(new Error(response.error.message))
              end(null, response.result)
            })
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\sanitizer.js", { "./subprovider.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\node_modules\\ethereumjs-util\\dist\\index.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js", "xtend": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\sanitizer.js
        return function (require, module, exports) {
          /* Sanitization Subprovider
           * For Parity compatibility
           * removes irregular keys
           */

          const inherits = require('util').inherits
          const Subprovider = require('./subprovider.js')
          const extend = require('xtend')
          const ethUtil = require('ethereumjs-util')

          module.exports = SanitizerSubprovider

          inherits(SanitizerSubprovider, Subprovider)

          function SanitizerSubprovider(opts) {
            const self = this
          }

          SanitizerSubprovider.prototype.handleRequest = function (payload, next, end) {
            var txParams = payload.params[0]

            if (typeof txParams === 'object' && !Array.isArray(txParams)) {
              var sanitized = cloneTxParams(txParams)
              payload.params[0] = sanitized
            }

            next()
          }

          // we use this to clean any custom params from the txParams
          var permitted = [
            'from',
            'to',
            'value',
            'data',
            'gas',
            'gasPrice',
            'nonce',
            'fromBlock',
            'toBlock',
            'address',
            'topics',
          ]

          function cloneTxParams(txParams) {
            var sanitized = permitted.reduce(function (copy, permitted) {
              if (permitted in txParams) {
                if (Array.isArray(txParams[permitted])) {
                  copy[permitted] = txParams[permitted]
                    .map(function (item) {
                      return sanitize(item)
                    })
                } else {
                  copy[permitted] = sanitize(txParams[permitted])
                }
              }
              return copy
            }, {})

            return sanitized
          }

          function sanitize(value) {
            switch (value) {
              case 'latest':
                return value
              case 'pending':
                return value
              case 'earliest':
                return value
              default:
                if (typeof value === 'string') {
                  return ethUtil.addHexPrefix(value.toLowerCase())
                } else {
                  return value
                }
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", { "../util/create-payload.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\subprovider.js
        return function (require, module, exports) {
          const createPayload = require('../util/create-payload.js')

          module.exports = SubProvider

          // this is the base class for a subprovider -- mostly helpers


          function SubProvider() {

          }

          SubProvider.prototype.setEngine = function (engine) {
            const self = this
            if (self.engine) return
            self.engine = engine
            engine.on('block', function (block) {
              self.currentBlock = block
            })

            engine.on('start', function () {
              self.start()
            })

            engine.on('stop', function () {
              self.stop()
            })
          }

          SubProvider.prototype.handleRequest = function (payload, next, end) {
            throw new Error('Subproviders should override `handleRequest`.')
          }

          SubProvider.prototype.emitPayload = function (payload, cb) {
            const self = this
            self.engine.sendAsync(createPayload(payload), cb)
          }

          // dummies for overriding

          SubProvider.prototype.stop = function () { }

          SubProvider.prototype.start = function () { }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subscriptions.js", { "./json-rpc-engine-middleware": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\json-rpc-engine-middleware.js", "eth-json-rpc-filters/subscriptionManager": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-json-rpc-filters\\subscriptionManager.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\subscriptions.js
        return function (require, module, exports) {
          const ProviderSubprovider = require('./json-rpc-engine-middleware')
          const createSubscriptionManager = require('eth-json-rpc-filters/subscriptionManager')

          class SubscriptionsSubprovider extends ProviderSubprovider {
            constructor() {
              super(({ blockTracker, provider, engine }) => {
                const { events, middleware } = createSubscriptionManager({ blockTracker, provider })
                // forward subscription events on the engine
                events.on('notification', (data) => engine.emit('data', null, data))
                // return the subscription install/remove middleware
                return middleware
              })
            }
          }

          module.exports = SubscriptionsSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\websocket.js", { "../util/create-payload": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js", "./subprovider": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subprovider.js", "backoff": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\backoff\\index.js", "events": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js", "ws": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\browser-resolve\\empty.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\subproviders\websocket.js
        return function (require, module, exports) {
          const Backoff = require('backoff')
          const EventEmitter = require('events')
          const inherits = require('util').inherits
          const WebSocket = global.WebSocket || require('ws')
          const Subprovider = require('./subprovider')
          const createPayload = require('../util/create-payload')

          class WebsocketSubprovider
            extends Subprovider {
            constructor({ rpcUrl, debug, origin }) {
              super()

              // inherit from EventEmitter
              EventEmitter.call(this)

              Object.defineProperties(this, {
                _backoff: {
                  value: Backoff.exponential({
                    randomisationFactor: 0.2,
                    maxDelay: 5000
                  })
                },
                _connectTime: {
                  value: null,
                  writable: true
                },
                _log: {
                  value: debug
                    ? (...args) => console.info.apply(console, ['[WSProvider]', ...args])
                    : () => { }
                },
                _origin: {
                  value: origin
                },
                _pendingRequests: {
                  value: new Map()
                },
                _socket: {
                  value: null,
                  writable: true
                },
                _unhandledRequests: {
                  value: []
                },
                _url: {
                  value: rpcUrl
                }
              })

              this._handleSocketClose = this._handleSocketClose.bind(this)
              this._handleSocketMessage = this._handleSocketMessage.bind(this)
              this._handleSocketOpen = this._handleSocketOpen.bind(this)

              // Called when a backoff timeout has finished. Time to try reconnecting.
              this._backoff.on('ready', () => {
                this._openSocket()
              })

              this._openSocket()
            }

            handleRequest(payload, next, end) {
              if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {
                this._unhandledRequests.push(Array.from(arguments))
                this._log('Socket not open. Request queued.')
                return
              }

              this._pendingRequests.set(payload.id, [payload, end])

              const newPayload = createPayload(payload)
              delete newPayload.origin

              this._socket.send(JSON.stringify(newPayload))
              this._log(`Sent: ${newPayload.method} #${newPayload.id}`)
            }

            _handleSocketClose({ reason, code }) {
              this._log(`Socket closed, code ${code} (${reason || 'no reason'})`)
              // If the socket has been open for longer than 5 seconds, reset the backoff
              if (this._connectTime && Date.now() - this._connectTime > 5000) {
                this._backoff.reset()
              }

              this._socket.removeEventListener('close', this._handleSocketClose)
              this._socket.removeEventListener('message', this._handleSocketMessage)
              this._socket.removeEventListener('open', this._handleSocketOpen)

              this._socket = null
              this._backoff.backoff()
            }

            _handleSocketMessage(message) {
              let payload

              try {
                payload = JSON.parse(message.data)
              } catch (e) {
                this._log('Received a message that is not valid JSON:', payload)
                return
              }

              // check if server-sent notification
              if (payload.id === undefined) {
                return this.engine.emit('data', null, payload)
              }

              // ignore if missing
              if (!this._pendingRequests.has(payload.id)) {
                return
              }

              // retrieve payload + arguments
              const [originalReq, end] = this._pendingRequests.get(payload.id)
              this._pendingRequests.delete(payload.id)

              this._log(`Received: ${originalReq.method} #${payload.id}`)

              // forward response
              if (payload.error) {
                return end(new Error(payload.error.message))
              }
              end(null, payload.result)
            }

            _handleSocketOpen() {
              this._log('Socket open.')
              this._connectTime = Date.now()

              // Any pending requests need to be resent because our session was lost
              // and will not get responses for them in our new session.
              this._pendingRequests.forEach(([payload, end]) => {
                this._unhandledRequests.push([payload, null, end])
              })
              this._pendingRequests.clear()

              const unhandledRequests = this._unhandledRequests.splice(0, this._unhandledRequests.length)
              unhandledRequests.forEach(request => {
                this.handleRequest.apply(this, request)
              })
            }

            _openSocket() {
              this._log('Opening socket...')
              this._socket = new WebSocket(this._url, [], this._origin ? { headers: { origin: this._origin } } : {})
              this._socket.addEventListener('close', this._handleSocketClose)
              this._socket.addEventListener('message', this._handleSocketMessage)
              this._socket.addEventListener('open', this._handleSocketOpen)
            }
          }

          // multiple inheritance
          Object.assign(WebsocketSubprovider.prototype, EventEmitter.prototype)

          module.exports = WebsocketSubprovider

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js", { "./random-id.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\random-id.js", "xtend": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\create-payload.js
        return function (require, module, exports) {
          const getRandomId = require('./random-id.js')
          const extend = require('xtend')

          module.exports = createPayload


          function createPayload(data) {
            return extend({
              // defaults
              id: getRandomId(),
              jsonrpc: '2.0',
              params: [],
              // user-specified
            }, data)
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\estimate-gas.js", { "./create-payload.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\create-payload.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\estimate-gas.js
        return function (require, module, exports) {
          const createPayload = require('./create-payload.js')

          module.exports = estimateGas

          /*
          
          This is a work around for https://github.com/ethereum/go-ethereum/issues/2577
          
          */


          function estimateGas(provider, txParams, cb) {
            provider.sendAsync(createPayload({
              method: 'eth_estimateGas',
              params: [txParams]
            }), function (err, res) {
              if (err) {
                // handle simple value transfer case
                if (err.message === 'no contract code at given address') {
                  return cb(null, '0xcf08')
                } else {
                  return cb(err)
                }
              }
              cb(null, res.result)
            })
          }
        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\random-id.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\random-id.js
        return function (require, module, exports) {
          module.exports = createRandomId


          function createRandomId() {
            // random id
            return Math.floor(Number.MAX_SAFE_INTEGER * Math.random())
          }
        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\rpc-cache-utils.js", { "json-stable-stringify": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\json-stable-stringify\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\rpc-cache-utils.js
        return function (require, module, exports) {
          const stringify = require('json-stable-stringify')

          module.exports = {
            cacheIdentifierForPayload: cacheIdentifierForPayload,
            canCache: canCache,
            blockTagForPayload: blockTagForPayload,
            paramsWithoutBlockTag: paramsWithoutBlockTag,
            blockTagParamIndex: blockTagParamIndex,
            cacheTypeForPayload: cacheTypeForPayload,
          }

          function cacheIdentifierForPayload(payload, opts = {}) {
            if (!canCache(payload)) return null
            const { includeBlockRef } = opts
            const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload)
            return payload.method + ':' + stringify(params)
          }

          function canCache(payload) {
            return cacheTypeForPayload(payload) !== 'never'
          }

          function blockTagForPayload(payload) {
            var index = blockTagParamIndex(payload);

            // Block tag param not passed.
            if (index >= payload.params.length) {
              return null;
            }

            return payload.params[index];
          }

          function paramsWithoutBlockTag(payload) {
            var index = blockTagParamIndex(payload);

            // Block tag param not passed.
            if (index >= payload.params.length) {
              return payload.params;
            }

            // eth_getBlockByNumber has the block tag first, then the optional includeTx? param
            if (payload.method === 'eth_getBlockByNumber') {
              return payload.params.slice(1);
            }

            return payload.params.slice(0, index);
          }

          function blockTagParamIndex(payload) {
            switch (payload.method) {
              // blockTag is third param
              case 'eth_getStorageAt':
                return 2
              // blockTag is second param
              case 'eth_getBalance':
              case 'eth_getCode':
              case 'eth_getTransactionCount':
              case 'eth_call':
              case 'eth_estimateGas':
                return 1
              // blockTag is first param
              case 'eth_getBlockByNumber':
                return 0
              // there is no blockTag
              default:
                return undefined
            }
          }

          function cacheTypeForPayload(payload) {
            switch (payload.method) {
              // cache permanently
              case 'web3_clientVersion':
              case 'web3_sha3':
              case 'eth_protocolVersion':
              case 'eth_getBlockTransactionCountByHash':
              case 'eth_getUncleCountByBlockHash':
              case 'eth_getCode':
              case 'eth_getBlockByHash':
              case 'eth_getTransactionByHash':
              case 'eth_getTransactionByBlockHashAndIndex':
              case 'eth_getTransactionReceipt':
              case 'eth_getUncleByBlockHashAndIndex':
              case 'eth_getCompilers':
              case 'eth_compileLLL':
              case 'eth_compileSolidity':
              case 'eth_compileSerpent':
              case 'shh_version':
                return 'perma'

              // cache until fork
              case 'eth_getBlockByNumber':
              case 'eth_getBlockTransactionCountByNumber':
              case 'eth_getUncleCountByBlockNumber':
              case 'eth_getTransactionByBlockNumberAndIndex':
              case 'eth_getUncleByBlockNumberAndIndex':
                return 'fork'

              // cache for block
              case 'eth_gasPrice':
              case 'eth_getBalance':
              case 'eth_getStorageAt':
              case 'eth_getTransactionCount':
              case 'eth_call':
              case 'eth_estimateGas':
              case 'eth_getFilterLogs':
              case 'eth_getLogs':
              case 'eth_blockNumber':
                return 'block'

              // never cache
              case 'net_version':
              case 'net_peerCount':
              case 'net_listening':
              case 'eth_syncing':
              case 'eth_sign':
              case 'eth_coinbase':
              case 'eth_mining':
              case 'eth_hashrate':
              case 'eth_accounts':
              case 'eth_sendTransaction':
              case 'eth_sendRawTransaction':
              case 'eth_newFilter':
              case 'eth_newBlockFilter':
              case 'eth_newPendingTransactionFilter':
              case 'eth_uninstallFilter':
              case 'eth_getFilterChanges':
              case 'eth_getWork':
              case 'eth_submitWork':
              case 'eth_submitHashrate':
              case 'db_putString':
              case 'db_getString':
              case 'db_putHex':
              case 'db_getHex':
              case 'shh_post':
              case 'shh_newIdentity':
              case 'shh_hasIdentity':
              case 'shh_newGroup':
              case 'shh_addToGroup':
              case 'shh_newFilter':
              case 'shh_uninstallFilter':
              case 'shh_getFilterChanges':
              case 'shh_getMessages':
                return 'never'
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\util\\stoplight.js", { "events": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\events\\events.js", "util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\util\\util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\util\stoplight.js
        return function (require, module, exports) {
          const EventEmitter = require('events').EventEmitter
          const inherits = require('util').inherits

          module.exports = Stoplight


          inherits(Stoplight, EventEmitter)

          function Stoplight() {
            const self = this
            EventEmitter.call(self)
            self.isLocked = true
          }

          Stoplight.prototype.go = function () {
            const self = this
            self.isLocked = false
            self.emit('unlock')
          }

          Stoplight.prototype.stop = function () {
            const self = this
            self.isLocked = true
            self.emit('lock')
          }

          Stoplight.prototype.await = function (fn) {
            const self = this
            if (self.isLocked) {
              self.once('unlock', fn)
            } else {
              setTimeout(fn)
            }
          }
        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\zero.js", { "./index.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\index.js", "./subproviders/cache.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\cache.js", "./subproviders/default-fixture.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\default-fixture.js", "./subproviders/fetch.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\fetch.js", "./subproviders/filters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\filters.js", "./subproviders/hooked-wallet.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\hooked-wallet.js", "./subproviders/inflight-cache": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\inflight-cache.js", "./subproviders/infura.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\infura.js", "./subproviders/nonce-tracker.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\nonce-tracker.js", "./subproviders/sanitizer.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\sanitizer.js", "./subproviders/subscriptions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\subscriptions.js", "./subproviders/websocket.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3-provider-engine\\subproviders\\websocket.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3-provider-engine\zero.js
        return function (require, module, exports) {
          const ProviderEngine = require('./index.js')
          const DefaultFixture = require('./subproviders/default-fixture.js')
          const NonceTrackerSubprovider = require('./subproviders/nonce-tracker.js')
          const CacheSubprovider = require('./subproviders/cache.js')
          const FilterSubprovider = require('./subproviders/filters')
          const SubscriptionSubprovider = require('./subproviders/subscriptions')
          const InflightCacheSubprovider = require('./subproviders/inflight-cache')
          const HookedWalletSubprovider = require('./subproviders/hooked-wallet.js')
          const SanitizingSubprovider = require('./subproviders/sanitizer.js')
          const InfuraSubprovider = require('./subproviders/infura.js')
          const FetchSubprovider = require('./subproviders/fetch.js')
          const WebSocketSubprovider = require('./subproviders/websocket.js')


          module.exports = ZeroClientProvider


          function ZeroClientProvider(opts = {}) {
            const connectionType = getConnectionType(opts)

            const engine = new ProviderEngine(opts.engineParams)

            // static
            const staticSubprovider = new DefaultFixture(opts.static)
            engine.addProvider(staticSubprovider)

            // nonce tracker
            engine.addProvider(new NonceTrackerSubprovider())

            // sanitization
            const sanitizer = new SanitizingSubprovider()
            engine.addProvider(sanitizer)

            // cache layer
            const cacheSubprovider = new CacheSubprovider()
            engine.addProvider(cacheSubprovider)

            // filters + subscriptions
            // only polyfill if not websockets
            if (connectionType !== 'ws') {
              engine.addProvider(new SubscriptionSubprovider())
              engine.addProvider(new FilterSubprovider())
            }

            // inflight cache
            const inflightCache = new InflightCacheSubprovider()
            engine.addProvider(inflightCache)

            // id mgmt
            const idmgmtSubprovider = new HookedWalletSubprovider({
              // accounts
              getAccounts: opts.getAccounts,
              // transactions
              processTransaction: opts.processTransaction,
              approveTransaction: opts.approveTransaction,
              signTransaction: opts.signTransaction,
              publishTransaction: opts.publishTransaction,
              // messages
              // old eth_sign
              processMessage: opts.processMessage,
              approveMessage: opts.approveMessage,
              signMessage: opts.signMessage,
              // new personal_sign
              processPersonalMessage: opts.processPersonalMessage,
              processTypedMessage: opts.processTypedMessage,
              approvePersonalMessage: opts.approvePersonalMessage,
              approveTypedMessage: opts.approveTypedMessage,
              signPersonalMessage: opts.signPersonalMessage,
              signTypedMessage: opts.signTypedMessage,
              personalRecoverSigner: opts.personalRecoverSigner,
            })
            engine.addProvider(idmgmtSubprovider)

            // data source
            const dataSubprovider = opts.dataSubprovider || createDataSubprovider(connectionType, opts)
            engine.addProvider(dataSubprovider)

            // start polling
            if (!opts.stopped) {
              engine.start()
            }

            return engine

          }

          function createDataSubprovider(connectionType, opts) {
            const { rpcUrl, debug } = opts

            // default to infura
            if (!connectionType) {
              return new InfuraSubprovider()
            }
            if (connectionType === 'http') {
              return new FetchSubprovider({ rpcUrl, debug })
            }
            if (connectionType === 'ws') {
              return new WebSocketSubprovider({ rpcUrl, debug })
            }

            throw new Error(`ProviderEngine - unrecognized connectionType "${connectionType}"`)
          }

          function getConnectionType({ rpcUrl }) {
            if (!rpcUrl) return undefined

            const protocol = rpcUrl.split(':')[0].toLowerCase()
            switch (protocol) {
              case 'http':
              case 'https':
                return 'http'
              case 'ws':
              case 'wss':
                return 'ws'
              default:
                throw new Error(`ProviderEngine - unrecognized protocol in "${rpcUrl}"`)
            }
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3-provider-engine", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\index.js", { "./lib/web3": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\index.js
        return function (require, module, exports) {
          var Web3 = require('./lib/web3');

          // dont override global variable
          if (typeof window !== 'undefined' && typeof window.Web3 === 'undefined') {
            window.Web3 = Web3;
          }

          module.exports = Web3;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\GlobalRegistrar.json", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\contracts\GlobalRegistrar.json
        return function (require, module, exports) {
          module.exports = [
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_owner",
                  "type": "address"
                }
              ],
              "name": "name",
              "outputs": [
                {
                  "name": "o_name",
                  "type": "bytes32"
                }
              ],
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "owner",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "content",
              "outputs": [
                {
                  "name": "",
                  "type": "bytes32"
                }
              ],
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "addr",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "reserve",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "subRegistrar",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "name": "_newOwner",
                  "type": "address"
                }
              ],
              "name": "transfer",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "name": "_registrar",
                  "type": "address"
                }
              ],
              "name": "setSubRegistrar",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [],
              "name": "Registrar",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "name": "_a",
                  "type": "address"
                },
                {
                  "name": "_primary",
                  "type": "bool"
                }
              ],
              "name": "setAddress",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "name": "_content",
                  "type": "bytes32"
                }
              ],
              "name": "setContent",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "disown",
              "outputs": [],
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "indexed": false,
                  "name": "_winner",
                  "type": "address"
                }
              ],
              "name": "AuctionEnded",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "indexed": false,
                  "name": "_bidder",
                  "type": "address"
                },
                {
                  "indexed": false,
                  "name": "_value",
                  "type": "uint256"
                }
              ],
              "name": "NewBid",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "name",
                  "type": "bytes32"
                }
              ],
              "name": "Changed",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "name",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "addr",
                  "type": "address"
                }
              ],
              "name": "PrimaryChanged",
              "type": "event"
            }
          ]

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\ICAPRegistrar.json", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\contracts\ICAPRegistrar.json
        return function (require, module, exports) {
          module.exports = [
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "owner",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "name": "_refund",
                  "type": "address"
                }
              ],
              "name": "disown",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": true,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "addr",
              "outputs": [
                {
                  "name": "",
                  "type": "address"
                }
              ],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                }
              ],
              "name": "reserve",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "name": "_newOwner",
                  "type": "address"
                }
              ],
              "name": "transfer",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "_name",
                  "type": "bytes32"
                },
                {
                  "name": "_a",
                  "type": "address"
                }
              ],
              "name": "setAddr",
              "outputs": [],
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "name",
                  "type": "bytes32"
                }
              ],
              "name": "Changed",
              "type": "event"
            }
          ]

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\SmartExchange.json", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\contracts\SmartExchange.json
        return function (require, module, exports) {
          module.exports = [
            {
              "constant": false,
              "inputs": [
                {
                  "name": "from",
                  "type": "bytes32"
                },
                {
                  "name": "to",
                  "type": "address"
                },
                {
                  "name": "value",
                  "type": "uint256"
                }
              ],
              "name": "transfer",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "from",
                  "type": "bytes32"
                },
                {
                  "name": "to",
                  "type": "address"
                },
                {
                  "name": "indirectId",
                  "type": "bytes32"
                },
                {
                  "name": "value",
                  "type": "uint256"
                }
              ],
              "name": "icapTransfer",
              "outputs": [],
              "type": "function"
            },
            {
              "constant": false,
              "inputs": [
                {
                  "name": "to",
                  "type": "bytes32"
                }
              ],
              "name": "deposit",
              "outputs": [],
              "payable": true,
              "type": "function"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "from",
                  "type": "address"
                },
                {
                  "indexed": false,
                  "name": "value",
                  "type": "uint256"
                }
              ],
              "name": "AnonymousDeposit",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "from",
                  "type": "address"
                },
                {
                  "indexed": true,
                  "name": "to",
                  "type": "bytes32"
                },
                {
                  "indexed": false,
                  "name": "value",
                  "type": "uint256"
                }
              ],
              "name": "Deposit",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "from",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "to",
                  "type": "address"
                },
                {
                  "indexed": false,
                  "name": "value",
                  "type": "uint256"
                }
              ],
              "name": "Transfer",
              "type": "event"
            },
            {
              "anonymous": false,
              "inputs": [
                {
                  "indexed": true,
                  "name": "from",
                  "type": "bytes32"
                },
                {
                  "indexed": true,
                  "name": "to",
                  "type": "address"
                },
                {
                  "indexed": false,
                  "name": "indirectId",
                  "type": "bytes32"
                },
                {
                  "indexed": false,
                  "name": "value",
                  "type": "uint256"
                }
              ],
              "name": "IcapTransfer",
              "type": "event"
            }
          ]

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\address.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\address.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          /**
           * SolidityTypeAddress is a prootype that represents address type
           * It matches:
           * address
           * address[]
           * address[4]
           * address[][]
           * address[3][]
           * address[][6][], ...
           */
          var SolidityTypeAddress = function () {
            this._inputFormatter = f.formatInputInt;
            this._outputFormatter = f.formatOutputAddress;
          };

          SolidityTypeAddress.prototype = new SolidityType({});
          SolidityTypeAddress.prototype.constructor = SolidityTypeAddress;

          SolidityTypeAddress.prototype.isType = function (name) {
            return !!name.match(/address(\[([0-9]*)\])?/);
          };

          module.exports = SolidityTypeAddress;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bool.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\bool.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          /**
           * SolidityTypeBool is a prootype that represents bool type
           * It matches:
           * bool
           * bool[]
           * bool[4]
           * bool[][]
           * bool[3][]
           * bool[][6][], ...
           */
          var SolidityTypeBool = function () {
            this._inputFormatter = f.formatInputBool;
            this._outputFormatter = f.formatOutputBool;
          };

          SolidityTypeBool.prototype = new SolidityType({});
          SolidityTypeBool.prototype.constructor = SolidityTypeBool;

          SolidityTypeBool.prototype.isType = function (name) {
            return !!name.match(/^bool(\[([0-9]*)\])*$/);
          };

          module.exports = SolidityTypeBool;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bytes.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\bytes.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          /**
           * SolidityTypeBytes is a prototype that represents the bytes type.
           * It matches:
           * bytes
           * bytes[]
           * bytes[4]
           * bytes[][]
           * bytes[3][]
           * bytes[][6][], ...
           * bytes32
           * bytes8[4]
           * bytes[3][]
           */
          var SolidityTypeBytes = function () {
            this._inputFormatter = f.formatInputBytes;
            this._outputFormatter = f.formatOutputBytes;
          };

          SolidityTypeBytes.prototype = new SolidityType({});
          SolidityTypeBytes.prototype.constructor = SolidityTypeBytes;

          SolidityTypeBytes.prototype.isType = function (name) {
            return !!name.match(/^bytes([0-9]{1,})(\[([0-9]*)\])*$/);
          };

          module.exports = SolidityTypeBytes;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js", { "./address": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\address.js", "./bool": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bool.js", "./bytes": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\bytes.js", "./dynamicbytes": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\dynamicbytes.js", "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./int": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\int.js", "./real": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\real.js", "./string": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\string.js", "./uint": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\uint.js", "./ureal": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\ureal.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\coder.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file coder.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var f = require('./formatters');

          var SolidityTypeAddress = require('./address');
          var SolidityTypeBool = require('./bool');
          var SolidityTypeInt = require('./int');
          var SolidityTypeUInt = require('./uint');
          var SolidityTypeDynamicBytes = require('./dynamicbytes');
          var SolidityTypeString = require('./string');
          var SolidityTypeReal = require('./real');
          var SolidityTypeUReal = require('./ureal');
          var SolidityTypeBytes = require('./bytes');

          var isDynamic = function (solidityType, type) {
            return solidityType.isDynamicType(type) ||
              solidityType.isDynamicArray(type);
          };

          /**
           * SolidityCoder prototype should be used to encode/decode solidity params of any type
           */
          var SolidityCoder = function (types) {
            this._types = types;
          };

          /**
           * This method should be used to transform type to SolidityType
           *
           * @method _requireType
           * @param {String} type
           * @returns {SolidityType}
           * @throws {Error} throws if no matching type is found
           */
          SolidityCoder.prototype._requireType = function (type) {
            var solidityType = this._types.filter(function (t) {
              return t.isType(type);
            })[0];

            if (!solidityType) {
              throw Error('invalid solidity type!: ' + type);
            }

            return solidityType;
          };

          /**
           * Should be used to encode plain param
           *
           * @method encodeParam
           * @param {String} type
           * @param {Object} plain param
           * @return {String} encoded plain param
           */
          SolidityCoder.prototype.encodeParam = function (type, param) {
            return this.encodeParams([type], [param]);
          };

          /**
           * Should be used to encode list of params
           *
           * @method encodeParams
           * @param {Array} types
           * @param {Array} params
           * @return {String} encoded list of params
           */
          SolidityCoder.prototype.encodeParams = function (types, params) {
            var solidityTypes = this.getSolidityTypes(types);

            var encodeds = solidityTypes.map(function (solidityType, index) {
              return solidityType.encode(params[index], types[index]);
            });

            var dynamicOffset = solidityTypes.reduce(function (acc, solidityType, index) {
              var staticPartLength = solidityType.staticPartLength(types[index]);
              var roundedStaticPartLength = Math.floor((staticPartLength + 31) / 32) * 32;

              return acc + (isDynamic(solidityTypes[index], types[index]) ?
                32 :
                roundedStaticPartLength);
            }, 0);

            var result = this.encodeMultiWithOffset(types, solidityTypes, encodeds, dynamicOffset);

            return result;
          };

          SolidityCoder.prototype.encodeMultiWithOffset = function (types, solidityTypes, encodeds, dynamicOffset) {
            var result = "";
            var self = this;

            types.forEach(function (type, i) {
              if (isDynamic(solidityTypes[i], types[i])) {
                result += f.formatInputInt(dynamicOffset).encode();
                var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
                dynamicOffset += e.length / 2;
              } else {
                // don't add length to dynamicOffset. it's already counted
                result += self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
              }

              // TODO: figure out nested arrays
            });

            types.forEach(function (type, i) {
              if (isDynamic(solidityTypes[i], types[i])) {
                var e = self.encodeWithOffset(types[i], solidityTypes[i], encodeds[i], dynamicOffset);
                dynamicOffset += e.length / 2;
                result += e;
              }
            });
            return result;
          };

          SolidityCoder.prototype.encodeWithOffset = function (type, solidityType, encoded, offset) {
            /* jshint maxcomplexity: 17 */
            /* jshint maxdepth: 5 */

            var self = this;
            var encodingMode = { dynamic: 1, static: 2, other: 3 };

            var mode = (solidityType.isDynamicArray(type) ? encodingMode.dynamic : (solidityType.isStaticArray(type) ? encodingMode.static : encodingMode.other));

            if (mode !== encodingMode.other) {
              var nestedName = solidityType.nestedName(type);
              var nestedStaticPartLength = solidityType.staticPartLength(nestedName);
              var result = (mode === encodingMode.dynamic ? encoded[0] : '');

              if (solidityType.isDynamicArray(nestedName)) {
                var previousLength = (mode === encodingMode.dynamic ? 2 : 0);

                for (var i = 0; i < encoded.length; i++) {
                  // calculate length of previous item
                  if (mode === encodingMode.dynamic) {
                    previousLength += +(encoded[i - 1])[0] || 0;
                  }
                  else if (mode === encodingMode.static) {
                    previousLength += +(encoded[i - 1] || [])[0] || 0;
                  }
                  result += f.formatInputInt(offset + i * nestedStaticPartLength + previousLength * 32).encode();
                }
              }

              var len = (mode === encodingMode.dynamic ? encoded.length - 1 : encoded.length);
              for (var c = 0; c < len; c++) {
                var additionalOffset = result / 2;
                if (mode === encodingMode.dynamic) {
                  result += self.encodeWithOffset(nestedName, solidityType, encoded[c + 1], offset + additionalOffset);
                }
                else if (mode === encodingMode.static) {
                  result += self.encodeWithOffset(nestedName, solidityType, encoded[c], offset + additionalOffset);
                }
              }

              return result;
            }

            return encoded;
          };


          /**
           * Should be used to decode bytes to plain param
           *
           * @method decodeParam
           * @param {String} type
           * @param {String} bytes
           * @return {Object} plain param
           */
          SolidityCoder.prototype.decodeParam = function (type, bytes) {
            return this.decodeParams([type], bytes)[0];
          };

          /**
           * Should be used to decode list of params
           *
           * @method decodeParam
           * @param {Array} types
           * @param {String} bytes
           * @return {Array} array of plain params
           */
          SolidityCoder.prototype.decodeParams = function (types, bytes) {
            var solidityTypes = this.getSolidityTypes(types);
            var offsets = this.getOffsets(types, solidityTypes);

            return solidityTypes.map(function (solidityType, index) {
              return solidityType.decode(bytes, offsets[index], types[index], index);
            });
          };

          SolidityCoder.prototype.getOffsets = function (types, solidityTypes) {
            var lengths = solidityTypes.map(function (solidityType, index) {
              return solidityType.staticPartLength(types[index]);
            });

            for (var i = 1; i < lengths.length; i++) {
              // sum with length of previous element
              lengths[i] += lengths[i - 1];
            }

            return lengths.map(function (length, index) {
              // remove the current length, so the length is sum of previous elements
              var staticPartLength = solidityTypes[index].staticPartLength(types[index]);
              return length - staticPartLength;
            });
          };

          SolidityCoder.prototype.getSolidityTypes = function (types) {
            var self = this;
            return types.map(function (type) {
              return self._requireType(type);
            });
          };

          var coder = new SolidityCoder([
            new SolidityTypeAddress(),
            new SolidityTypeBool(),
            new SolidityTypeInt(),
            new SolidityTypeUInt(),
            new SolidityTypeDynamicBytes(),
            new SolidityTypeBytes(),
            new SolidityTypeString(),
            new SolidityTypeReal(),
            new SolidityTypeUReal()
          ]);

          module.exports = coder;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\dynamicbytes.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\dynamicbytes.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          var SolidityTypeDynamicBytes = function () {
            this._inputFormatter = f.formatInputDynamicBytes;
            this._outputFormatter = f.formatOutputDynamicBytes;
          };

          SolidityTypeDynamicBytes.prototype = new SolidityType({});
          SolidityTypeDynamicBytes.prototype.constructor = SolidityTypeDynamicBytes;

          SolidityTypeDynamicBytes.prototype.isType = function (name) {
            return !!name.match(/^bytes(\[([0-9]*)\])*$/);
          };

          SolidityTypeDynamicBytes.prototype.isDynamicType = function () {
            return true;
          };

          module.exports = SolidityTypeDynamicBytes;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", { "../utils/config": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js", "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./param": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\param.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\formatters.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file formatters.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var BigNumber = require('bignumber.js');
          var utils = require('../utils/utils');
          var c = require('../utils/config');
          var SolidityParam = require('./param');


          /**
           * Formats input value to byte representation of int
           * If value is negative, return it's two's complement
           * If the value is floating point, round it down
           *
           * @method formatInputInt
           * @param {String|Number|BigNumber} value that needs to be formatted
           * @returns {SolidityParam}
           */
          var formatInputInt = function (value) {
            BigNumber.config(c.ETH_BIGNUMBER_ROUNDING_MODE);
            var result = utils.padLeft(utils.toTwosComplement(value).toString(16), 64);
            return new SolidityParam(result);
          };

          /**
           * Formats input bytes
           *
           * @method formatInputBytes
           * @param {String}
           * @returns {SolidityParam}
           */
          var formatInputBytes = function (value) {
            var result = utils.toHex(value).substr(2);
            var l = Math.floor((result.length + 63) / 64);
            result = utils.padRight(result, l * 64);
            return new SolidityParam(result);
          };

          /**
           * Formats input bytes
           *
           * @method formatDynamicInputBytes
           * @param {String}
           * @returns {SolidityParam}
           */
          var formatInputDynamicBytes = function (value) {
            var result = utils.toHex(value).substr(2);
            var length = result.length / 2;
            var l = Math.floor((result.length + 63) / 64);
            result = utils.padRight(result, l * 64);
            return new SolidityParam(formatInputInt(length).value + result);
          };

          /**
           * Formats input value to byte representation of string
           *
           * @method formatInputString
           * @param {String}
           * @returns {SolidityParam}
           */
          var formatInputString = function (value) {
            var result = utils.fromUtf8(value).substr(2);
            var length = result.length / 2;
            var l = Math.floor((result.length + 63) / 64);
            result = utils.padRight(result, l * 64);
            return new SolidityParam(formatInputInt(length).value + result);
          };

          /**
           * Formats input value to byte representation of bool
           *
           * @method formatInputBool
           * @param {Boolean}
           * @returns {SolidityParam}
           */
          var formatInputBool = function (value) {
            var result = '000000000000000000000000000000000000000000000000000000000000000' + (value ? '1' : '0');
            return new SolidityParam(result);
          };

          /**
           * Formats input value to byte representation of real
           * Values are multiplied by 2^m and encoded as integers
           *
           * @method formatInputReal
           * @param {String|Number|BigNumber}
           * @returns {SolidityParam}
           */
          var formatInputReal = function (value) {
            return formatInputInt(new BigNumber(value).times(new BigNumber(2).pow(128)));
          };

          /**
           * Check if input value is negative
           *
           * @method signedIsNegative
           * @param {String} value is hex format
           * @returns {Boolean} true if it is negative, otherwise false
           */
          var signedIsNegative = function (value) {
            return (new BigNumber(value.substr(0, 1), 16).toString(2).substr(0, 1)) === '1';
          };

          /**
           * Formats right-aligned output bytes to int
           *
           * @method formatOutputInt
           * @param {SolidityParam} param
           * @returns {BigNumber} right-aligned output bytes formatted to big number
           */
          var formatOutputInt = function (param) {
            var value = param.staticPart() || "0";

            // check if it's negative number
            // it it is, return two's complement
            if (signedIsNegative(value)) {
              return new BigNumber(value, 16).minus(new BigNumber('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16)).minus(1);
            }
            return new BigNumber(value, 16);
          };

          /**
           * Formats right-aligned output bytes to uint
           *
           * @method formatOutputUInt
           * @param {SolidityParam}
           * @returns {BigNumeber} right-aligned output bytes formatted to uint
           */
          var formatOutputUInt = function (param) {
            var value = param.staticPart() || "0";
            return new BigNumber(value, 16);
          };

          /**
           * Formats right-aligned output bytes to real
           *
           * @method formatOutputReal
           * @param {SolidityParam}
           * @returns {BigNumber} input bytes formatted to real
           */
          var formatOutputReal = function (param) {
            return formatOutputInt(param).dividedBy(new BigNumber(2).pow(128));
          };

          /**
           * Formats right-aligned output bytes to ureal
           *
           * @method formatOutputUReal
           * @param {SolidityParam}
           * @returns {BigNumber} input bytes formatted to ureal
           */
          var formatOutputUReal = function (param) {
            return formatOutputUInt(param).dividedBy(new BigNumber(2).pow(128));
          };

          /**
           * Should be used to format output bool
           *
           * @method formatOutputBool
           * @param {SolidityParam}
           * @returns {Boolean} right-aligned input bytes formatted to bool
           */
          var formatOutputBool = function (param) {
            return param.staticPart() === '0000000000000000000000000000000000000000000000000000000000000001' ? true : false;
          };

          /**
           * Should be used to format output bytes
           *
           * @method formatOutputBytes
           * @param {SolidityParam} left-aligned hex representation of string
           * @param {String} name type name
           * @returns {String} hex string
           */
          var formatOutputBytes = function (param, name) {
            var matches = name.match(/^bytes([0-9]*)/);
            var size = parseInt(matches[1]);
            return '0x' + param.staticPart().slice(0, 2 * size);
          };

          /**
           * Should be used to format output bytes
           *
           * @method formatOutputDynamicBytes
           * @param {SolidityParam} left-aligned hex representation of string
           * @returns {String} hex string
           */
          var formatOutputDynamicBytes = function (param) {
            var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
            return '0x' + param.dynamicPart().substr(64, length);
          };

          /**
           * Should be used to format output string
           *
           * @method formatOutputString
           * @param {SolidityParam} left-aligned hex representation of string
           * @returns {String} ascii string
           */
          var formatOutputString = function (param) {
            var length = (new BigNumber(param.dynamicPart().slice(0, 64), 16)).toNumber() * 2;
            return utils.toUtf8(param.dynamicPart().substr(64, length));
          };

          /**
           * Should be used to format output address
           *
           * @method formatOutputAddress
           * @param {SolidityParam} right-aligned input bytes
           * @returns {String} address
           */
          var formatOutputAddress = function (param) {
            var value = param.staticPart();
            return "0x" + value.slice(value.length - 40, value.length);
          };

          module.exports = {
            formatInputInt: formatInputInt,
            formatInputBytes: formatInputBytes,
            formatInputDynamicBytes: formatInputDynamicBytes,
            formatInputString: formatInputString,
            formatInputBool: formatInputBool,
            formatInputReal: formatInputReal,
            formatOutputInt: formatOutputInt,
            formatOutputUInt: formatOutputUInt,
            formatOutputReal: formatOutputReal,
            formatOutputUReal: formatOutputUReal,
            formatOutputBool: formatOutputBool,
            formatOutputBytes: formatOutputBytes,
            formatOutputDynamicBytes: formatOutputDynamicBytes,
            formatOutputString: formatOutputString,
            formatOutputAddress: formatOutputAddress
          };

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\int.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\int.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          /**
           * SolidityTypeInt is a prootype that represents int type
           * It matches:
           * int
           * int[]
           * int[4]
           * int[][]
           * int[3][]
           * int[][6][], ...
           * int32
           * int64[]
           * int8[4]
           * int256[][]
           * int[3][]
           * int64[][6][], ...
           */
          var SolidityTypeInt = function () {
            this._inputFormatter = f.formatInputInt;
            this._outputFormatter = f.formatOutputInt;
          };

          SolidityTypeInt.prototype = new SolidityType({});
          SolidityTypeInt.prototype.constructor = SolidityTypeInt;

          SolidityTypeInt.prototype.isType = function (name) {
            return !!name.match(/^int([0-9]*)?(\[([0-9]*)\])*$/);
          };

          module.exports = SolidityTypeInt;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\param.js", { "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\param.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file param.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var utils = require('../utils/utils');

          /**
           * SolidityParam object prototype.
           * Should be used when encoding, decoding solidity bytes
           */
          var SolidityParam = function (value, offset) {
            this.value = value || '';
            this.offset = offset; // offset in bytes
          };

          /**
           * This method should be used to get length of params's dynamic part
           * 
           * @method dynamicPartLength
           * @returns {Number} length of dynamic part (in bytes)
           */
          SolidityParam.prototype.dynamicPartLength = function () {
            return this.dynamicPart().length / 2;
          };

          /**
           * This method should be used to create copy of solidity param with different offset
           *
           * @method withOffset
           * @param {Number} offset length in bytes
           * @returns {SolidityParam} new solidity param with applied offset
           */
          SolidityParam.prototype.withOffset = function (offset) {
            return new SolidityParam(this.value, offset);
          };

          /**
           * This method should be used to combine solidity params together
           * eg. when appending an array
           *
           * @method combine
           * @param {SolidityParam} param with which we should combine
           * @param {SolidityParam} result of combination
           */
          SolidityParam.prototype.combine = function (param) {
            return new SolidityParam(this.value + param.value);
          };

          /**
           * This method should be called to check if param has dynamic size.
           * If it has, it returns true, otherwise false
           *
           * @method isDynamic
           * @returns {Boolean}
           */
          SolidityParam.prototype.isDynamic = function () {
            return this.offset !== undefined;
          };

          /**
           * This method should be called to transform offset to bytes
           *
           * @method offsetAsBytes
           * @returns {String} bytes representation of offset
           */
          SolidityParam.prototype.offsetAsBytes = function () {
            return !this.isDynamic() ? '' : utils.padLeft(utils.toTwosComplement(this.offset).toString(16), 64);
          };

          /**
           * This method should be called to get static part of param
           *
           * @method staticPart
           * @returns {String} offset if it is a dynamic param, otherwise value
           */
          SolidityParam.prototype.staticPart = function () {
            if (!this.isDynamic()) {
              return this.value;
            }
            return this.offsetAsBytes();
          };

          /**
           * This method should be called to get dynamic part of param
           *
           * @method dynamicPart
           * @returns {String} returns a value if it is a dynamic param, otherwise empty string
           */
          SolidityParam.prototype.dynamicPart = function () {
            return this.isDynamic() ? this.value : '';
          };

          /**
           * This method should be called to encode param
           *
           * @method encode
           * @returns {String}
           */
          SolidityParam.prototype.encode = function () {
            return this.staticPart() + this.dynamicPart();
          };

          /**
           * This method should be called to encode array of params
           *
           * @method encodeList
           * @param {Array[SolidityParam]} params
           * @returns {String}
           */
          SolidityParam.encodeList = function (params) {

            // updating offsets
            var totalOffset = params.length * 32;
            var offsetParams = params.map(function (param) {
              if (!param.isDynamic()) {
                return param;
              }
              var offset = totalOffset;
              totalOffset += param.dynamicPartLength();
              return param.withOffset(offset);
            });

            // encode everything!
            return offsetParams.reduce(function (result, param) {
              return result + param.dynamicPart();
            }, offsetParams.reduce(function (result, param) {
              return result + param.staticPart();
            }, ''));
          };



          module.exports = SolidityParam;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\real.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\real.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          /**
           * SolidityTypeReal is a prootype that represents real type
           * It matches:
           * real
           * real[]
           * real[4]
           * real[][]
           * real[3][]
           * real[][6][], ...
           * real32
           * real64[]
           * real8[4]
           * real256[][]
           * real[3][]
           * real64[][6][], ...
           */
          var SolidityTypeReal = function () {
            this._inputFormatter = f.formatInputReal;
            this._outputFormatter = f.formatOutputReal;
          };

          SolidityTypeReal.prototype = new SolidityType({});
          SolidityTypeReal.prototype.constructor = SolidityTypeReal;

          SolidityTypeReal.prototype.isType = function (name) {
            return !!name.match(/real([0-9]*)?(\[([0-9]*)\])?/);
          };

          module.exports = SolidityTypeReal;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\string.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\string.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          var SolidityTypeString = function () {
            this._inputFormatter = f.formatInputString;
            this._outputFormatter = f.formatOutputString;
          };

          SolidityTypeString.prototype = new SolidityType({});
          SolidityTypeString.prototype.constructor = SolidityTypeString;

          SolidityTypeString.prototype.isType = function (name) {
            return !!name.match(/^string(\[([0-9]*)\])*$/);
          };

          SolidityTypeString.prototype.isDynamicType = function () {
            return true;
          };

          module.exports = SolidityTypeString;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./param": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\param.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\type.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityParam = require('./param');

          /**
           * SolidityType prototype is used to encode/decode solidity params of certain type
           */
          var SolidityType = function (config) {
            this._inputFormatter = config.inputFormatter;
            this._outputFormatter = config.outputFormatter;
          };

          /**
           * Should be used to determine if this SolidityType do match given name
           *
           * @method isType
           * @param {String} name
           * @return {Bool} true if type match this SolidityType, otherwise false
           */
          SolidityType.prototype.isType = function (name) {
            throw "this method should be overrwritten for type " + name;
          };

          /**
           * Should be used to determine what is the length of static part in given type
           *
           * @method staticPartLength
           * @param {String} name
           * @return {Number} length of static part in bytes
           */
          SolidityType.prototype.staticPartLength = function (name) {
            // If name isn't an array then treat it like a single element array.
            return (this.nestedTypes(name) || ['[1]'])
              .map(function (type) {
                // the length of the nested array
                return parseInt(type.slice(1, -1), 10) || 1;
              })
              .reduce(function (previous, current) {
                return previous * current;
                // all basic types are 32 bytes long
              }, 32);
          };

          /**
           * Should be used to determine if type is dynamic array
           * eg:
           * "type[]" => true
           * "type[4]" => false
           *
           * @method isDynamicArray
           * @param {String} name
           * @return {Bool} true if the type is dynamic array
           */
          SolidityType.prototype.isDynamicArray = function (name) {
            var nestedTypes = this.nestedTypes(name);
            return !!nestedTypes && !nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
          };

          /**
           * Should be used to determine if type is static array
           * eg:
           * "type[]" => false
           * "type[4]" => true
           *
           * @method isStaticArray
           * @param {String} name
           * @return {Bool} true if the type is static array
           */
          SolidityType.prototype.isStaticArray = function (name) {
            var nestedTypes = this.nestedTypes(name);
            return !!nestedTypes && !!nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g);
          };

          /**
           * Should return length of static array
           * eg.
           * "int[32]" => 32
           * "int256[14]" => 14
           * "int[2][3]" => 3
           * "int" => 1
           * "int[1]" => 1
           * "int[]" => 1
           *
           * @method staticArrayLength
           * @param {String} name
           * @return {Number} static array length
           */
          SolidityType.prototype.staticArrayLength = function (name) {
            var nestedTypes = this.nestedTypes(name);
            if (nestedTypes) {
              return parseInt(nestedTypes[nestedTypes.length - 1].match(/[0-9]{1,}/g) || 1);
            }
            return 1;
          };

          /**
           * Should return nested type
           * eg.
           * "int[32]" => "int"
           * "int256[14]" => "int256"
           * "int[2][3]" => "int[2]"
           * "int" => "int"
           * "int[]" => "int"
           *
           * @method nestedName
           * @param {String} name
           * @return {String} nested name
           */
          SolidityType.prototype.nestedName = function (name) {
            // remove last [] in name
            var nestedTypes = this.nestedTypes(name);
            if (!nestedTypes) {
              return name;
            }

            return name.substr(0, name.length - nestedTypes[nestedTypes.length - 1].length);
          };

          /**
           * Should return true if type has dynamic size by default
           * such types are "string", "bytes"
           *
           * @method isDynamicType
           * @param {String} name
           * @return {Bool} true if is dynamic, otherwise false
           */
          SolidityType.prototype.isDynamicType = function () {
            return false;
          };

          /**
           * Should return array of nested types
           * eg.
           * "int[2][3][]" => ["[2]", "[3]", "[]"]
           * "int[] => ["[]"]
           * "int" => null
           *
           * @method nestedTypes
           * @param {String} name
           * @return {Array} array of nested types
           */
          SolidityType.prototype.nestedTypes = function (name) {
            // return list of strings eg. "[]", "[3]", "[]", "[2]"
            return name.match(/(\[[0-9]*\])/g);
          };

          /**
           * Should be used to encode the value
           *
           * @method encode
           * @param {Object} value
           * @param {String} name
           * @return {String} encoded value
           */
          SolidityType.prototype.encode = function (value, name) {
            var self = this;
            if (this.isDynamicArray(name)) {

              return (function () {
                var length = value.length;                          // in int
                var nestedName = self.nestedName(name);

                var result = [];
                result.push(f.formatInputInt(length).encode());

                value.forEach(function (v) {
                  result.push(self.encode(v, nestedName));
                });

                return result;
              })();

            } else if (this.isStaticArray(name)) {

              return (function () {
                var length = self.staticArrayLength(name);          // in int
                var nestedName = self.nestedName(name);

                var result = [];
                for (var i = 0; i < length; i++) {
                  result.push(self.encode(value[i], nestedName));
                }

                return result;
              })();

            }

            return this._inputFormatter(value, name).encode();
          };

          /**
           * Should be used to decode value from bytes
           *
           * @method decode
           * @param {String} bytes
           * @param {Number} offset in bytes
           * @param {String} name type name
           * @returns {Object} decoded value
           */
          SolidityType.prototype.decode = function (bytes, offset, name) {
            var self = this;

            if (this.isDynamicArray(name)) {

              return (function () {
                var arrayOffset = parseInt('0x' + bytes.substr(offset * 2, 64)); // in bytes
                var length = parseInt('0x' + bytes.substr(arrayOffset * 2, 64)); // in int
                var arrayStart = arrayOffset + 32; // array starts after length; // in bytes

                var nestedName = self.nestedName(name);
                var nestedStaticPartLength = self.staticPartLength(nestedName);  // in bytes
                var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
                var result = [];

                for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                  result.push(self.decode(bytes, arrayStart + i, nestedName));
                }

                return result;
              })();

            } else if (this.isStaticArray(name)) {

              return (function () {
                var length = self.staticArrayLength(name);                      // in int
                var arrayStart = offset;                                        // in bytes

                var nestedName = self.nestedName(name);
                var nestedStaticPartLength = self.staticPartLength(nestedName); // in bytes
                var roundedNestedStaticPartLength = Math.floor((nestedStaticPartLength + 31) / 32) * 32;
                var result = [];

                for (var i = 0; i < length * roundedNestedStaticPartLength; i += roundedNestedStaticPartLength) {
                  result.push(self.decode(bytes, arrayStart + i, nestedName));
                }

                return result;
              })();
            } else if (this.isDynamicType(name)) {

              return (function () {
                var dynamicOffset = parseInt('0x' + bytes.substr(offset * 2, 64));      // in bytes
                var length = parseInt('0x' + bytes.substr(dynamicOffset * 2, 64));      // in bytes
                var roundedLength = Math.floor((length + 31) / 32);                     // in int
                var param = new SolidityParam(bytes.substr(dynamicOffset * 2, (1 + roundedLength) * 64), 0);
                return self._outputFormatter(param, name);
              })();
            }

            var length = this.staticPartLength(name);
            var param = new SolidityParam(bytes.substr(offset * 2, length * 2));
            return this._outputFormatter(param, name);
          };

          module.exports = SolidityType;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\uint.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\uint.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          /**
           * SolidityTypeUInt is a prootype that represents uint type
           * It matches:
           * uint
           * uint[]
           * uint[4]
           * uint[][]
           * uint[3][]
           * uint[][6][], ...
           * uint32
           * uint64[]
           * uint8[4]
           * uint256[][]
           * uint[3][]
           * uint64[][6][], ...
           */
          var SolidityTypeUInt = function () {
            this._inputFormatter = f.formatInputInt;
            this._outputFormatter = f.formatOutputUInt;
          };

          SolidityTypeUInt.prototype = new SolidityType({});
          SolidityTypeUInt.prototype.constructor = SolidityTypeUInt;

          SolidityTypeUInt.prototype.isType = function (name) {
            return !!name.match(/^uint([0-9]*)?(\[([0-9]*)\])*$/);
          };

          module.exports = SolidityTypeUInt;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\ureal.js", { "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\formatters.js", "./type": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\type.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\solidity\ureal.js
        return function (require, module, exports) {
          var f = require('./formatters');
          var SolidityType = require('./type');

          /**
           * SolidityTypeUReal is a prootype that represents ureal type
           * It matches:
           * ureal
           * ureal[]
           * ureal[4]
           * ureal[][]
           * ureal[3][]
           * ureal[][6][], ...
           * ureal32
           * ureal64[]
           * ureal8[4]
           * ureal256[][]
           * ureal[3][]
           * ureal64[][6][], ...
           */
          var SolidityTypeUReal = function () {
            this._inputFormatter = f.formatInputReal;
            this._outputFormatter = f.formatOutputUReal;
          };

          SolidityTypeUReal.prototype = new SolidityType({});
          SolidityTypeUReal.prototype.constructor = SolidityTypeUReal;

          SolidityTypeUReal.prototype.isType = function (name) {
            return !!name.match(/^ureal([0-9]*)?(\[([0-9]*)\])*$/);
          };

          module.exports = SolidityTypeUReal;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\browser-xhr.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\browser-xhr.js
        return function (require, module, exports) {
          'use strict';

          // go env doesn't have and need XMLHttpRequest
          if (typeof XMLHttpRequest === 'undefined') {
            exports.XMLHttpRequest = {};
          } else {
            exports.XMLHttpRequest = XMLHttpRequest; // jshint ignore:line
          }


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js", { "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\config.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file config.js
           * @authors:
           *   Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          /**
           * Utils
           * 
           * @module utils
           */

          /**
           * Utility functions
           * 
           * @class [utils] config
           * @constructor
           */


          /// required to define ETH_BIGNUMBER_ROUNDING_MODE
          var BigNumber = require('bignumber.js');

          var ETH_UNITS = [
            'wei',
            'kwei',
            'Mwei',
            'Gwei',
            'szabo',
            'finney',
            'femtoether',
            'picoether',
            'nanoether',
            'microether',
            'milliether',
            'nano',
            'micro',
            'milli',
            'ether',
            'grand',
            'Mether',
            'Gether',
            'Tether',
            'Pether',
            'Eether',
            'Zether',
            'Yether',
            'Nether',
            'Dether',
            'Vether',
            'Uether'
          ];

          module.exports = {
            ETH_PADDING: 32,
            ETH_SIGNATURE_LENGTH: 4,
            ETH_UNITS: ETH_UNITS,
            ETH_BIGNUMBER_ROUNDING_MODE: { ROUNDING_MODE: BigNumber.ROUND_DOWN },
            ETH_POLLING_TIMEOUT: 1000 / 2,
            defaultBlock: 'latest',
            defaultAccount: undefined
          };


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js", { "crypto-js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\crypto-js\\index.js", "crypto-js/sha3": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\crypto-js\\sha3.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\sha3.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file sha3.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var CryptoJS = require('crypto-js');
          var sha3 = require('crypto-js/sha3');

          module.exports = function (value, options) {
            if (options && options.encoding === 'hex') {
              if (value.length > 2 && value.substr(0, 2) === '0x') {
                value = value.substr(2);
              }
              value = CryptoJS.enc.Hex.parse(value);
            }

            return sha3(value, {
              outputLength: 256
            }).toString();
          };


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", { "./sha3.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js", "utf8": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\utf8\\utf8.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\utils\utils.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file utils.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          /**
           * Utils
           *
           * @module utils
           */

          /**
           * Utility functions
           *
           * @class [utils] utils
           * @constructor
           */


          var BigNumber = require('bignumber.js');
          var sha3 = require('./sha3.js');
          var utf8 = require('utf8');

          var unitMap = {
            'noether': '0',
            'wei': '1',
            'kwei': '1000',
            'Kwei': '1000',
            'babbage': '1000',
            'femtoether': '1000',
            'mwei': '1000000',
            'Mwei': '1000000',
            'lovelace': '1000000',
            'picoether': '1000000',
            'gwei': '1000000000',
            'Gwei': '1000000000',
            'shannon': '1000000000',
            'nanoether': '1000000000',
            'nano': '1000000000',
            'szabo': '1000000000000',
            'microether': '1000000000000',
            'micro': '1000000000000',
            'finney': '1000000000000000',
            'milliether': '1000000000000000',
            'milli': '1000000000000000',
            'ether': '1000000000000000000',
            'kether': '1000000000000000000000',
            'grand': '1000000000000000000000',
            'mether': '1000000000000000000000000',
            'gether': '1000000000000000000000000000',
            'tether': '1000000000000000000000000000000'
          };

          /**
           * Should be called to pad string to expected length
           *
           * @method padLeft
           * @param {String} string to be padded
           * @param {Number} characters that result string should have
           * @param {String} sign, by default 0
           * @returns {String} right aligned string
           */
          var padLeft = function (string, chars, sign) {
            return new Array(chars - string.length + 1).join(sign ? sign : "0") + string;
          };

          /**
           * Should be called to pad string to expected length
           *
           * @method padRight
           * @param {String} string to be padded
           * @param {Number} characters that result string should have
           * @param {String} sign, by default 0
           * @returns {String} right aligned string
           */
          var padRight = function (string, chars, sign) {
            return string + (new Array(chars - string.length + 1).join(sign ? sign : "0"));
          };

          /**
           * Should be called to get utf8 from it's hex representation
           *
           * @method toUtf8
           * @param {String} string in hex
           * @returns {String} ascii string representation of hex value
           */
          var toUtf8 = function (hex) {
            // Find termination
            var str = "";
            var i = 0, l = hex.length;
            if (hex.substring(0, 2) === '0x') {
              i = 2;
            }
            for (; i < l; i += 2) {
              var code = parseInt(hex.substr(i, 2), 16);
              if (code === 0)
                break;
              str += String.fromCharCode(code);
            }

            return utf8.decode(str);
          };

          /**
           * Should be called to get ascii from it's hex representation
           *
           * @method toAscii
           * @param {String} string in hex
           * @returns {String} ascii string representation of hex value
           */
          var toAscii = function (hex) {
            // Find termination
            var str = "";
            var i = 0, l = hex.length;
            if (hex.substring(0, 2) === '0x') {
              i = 2;
            }
            for (; i < l; i += 2) {
              var code = parseInt(hex.substr(i, 2), 16);
              str += String.fromCharCode(code);
            }

            return str;
          };

          /**
           * Should be called to get hex representation (prefixed by 0x) of utf8 string
           *
           * @method fromUtf8
           * @param {String} string
           * @param {Boolean} allowZero to convert code point zero to 00 instead of end of string
           * @returns {String} hex representation of input string
           */
          var fromUtf8 = function (str, allowZero) {
            str = utf8.encode(str);
            var hex = "";
            for (var i = 0; i < str.length; i++) {
              var code = str.charCodeAt(i);
              if (code === 0) {
                if (allowZero) {
                  hex += '00';
                } else {
                  break;
                }
              } else {
                var n = code.toString(16);
                hex += n.length < 2 ? '0' + n : n;
              }
            }

            return "0x" + hex;
          };

          /**
           * Should be called to get hex representation (prefixed by 0x) of ascii string
           *
           * @method fromAscii
           * @param {String} string
           * @param {Number} optional padding
           * @returns {String} hex representation of input string
           */
          var fromAscii = function (str, num) {
            var hex = "";
            for (var i = 0; i < str.length; i++) {
              var code = str.charCodeAt(i);
              var n = code.toString(16);
              hex += n.length < 2 ? '0' + n : n;
            }

            return "0x" + hex.padEnd(num, '0');
          };

          /**
           * Should be used to create full function/event name from json abi
           *
           * @method transformToFullName
           * @param {Object} json-abi
           * @return {String} full fnction/event name
           */
          var transformToFullName = function (json) {
            if (json.name.indexOf('(') !== -1) {
              return json.name;
            }

            var typeName = json.inputs.map(function (i) { return i.type; }).join();
            return json.name + '(' + typeName + ')';
          };

          /**
           * Should be called to get display name of contract function
           *
           * @method extractDisplayName
           * @param {String} name of function/event
           * @returns {String} display name for function/event eg. multiply(uint256) -> multiply
           */
          var extractDisplayName = function (name) {
            var stBracket = name.indexOf('(');
            var endBracket = name.indexOf(')');
            return (stBracket !== -1 && endBracket !== -1) ? name.substr(0, stBracket) : name;
          };

          /**
           * Should be called to get type name of contract function
           *
           * @method extractTypeName
           * @param {String} name of function/event
           * @returns {String} type name for function/event eg. multiply(uint256) -> uint256
           */
          var extractTypeName = function (name) {
            var stBracket = name.indexOf('(');
            var endBracket = name.indexOf(')');
            return (stBracket !== -1 && endBracket !== -1) ? name.substr(stBracket + 1, endBracket - stBracket - 1).replace(' ', '') : "";
          };

          /**
           * Converts value to it's decimal representation in string
           *
           * @method toDecimal
           * @param {String|Number|BigNumber}
           * @return {String}
           */
          var toDecimal = function (value) {
            return toBigNumber(value).toNumber();
          };

          /**
           * Converts value to it's hex representation
           *
           * @method fromDecimal
           * @param {String|Number|BigNumber}
           * @return {String}
           */
          var fromDecimal = function (value) {
            var number = toBigNumber(value);
            var result = number.toString(16);

            return number.lessThan(0) ? '-0x' + result.substr(1) : '0x' + result;
          };

          /**
           * Auto converts any given value into it's hex representation.
           *
           * And even stringifys objects before.
           *
           * @method toHex
           * @param {String|Number|BigNumber|Object}
           * @return {String}
           */
          var toHex = function (val) {
            /*jshint maxcomplexity: 8 */

            if (isBoolean(val))
              return fromDecimal(+val);

            if (isBigNumber(val))
              return fromDecimal(val);

            if (typeof val === 'object')
              return fromUtf8(JSON.stringify(val));

            // if its a negative number, pass it through fromDecimal
            if (isString(val)) {
              if (val.indexOf('-0x') === 0)
                return fromDecimal(val);
              else if (val.indexOf('0x') === 0)
                return val;
              else if (!isFinite(val))
                return fromUtf8(val, 1);
            }

            return fromDecimal(val);
          };

          /**
           * Returns value of unit in Wei
           *
           * @method getValueOfUnit
           * @param {String} unit the unit to convert to, default ether
           * @returns {BigNumber} value of the unit (in Wei)
           * @throws error if the unit is not correct:w
           */
          var getValueOfUnit = function (unit) {
            unit = unit ? unit.toLowerCase() : 'ether';
            var unitValue = unitMap[unit];
            if (unitValue === undefined) {
              throw new Error('This unit doesn\'t exists, please use the one of the following units' + JSON.stringify(unitMap, null, 2));
            }
            return new BigNumber(unitValue, 10);
          };

          /**
           * Takes a number of wei and converts it to any other ether unit.
           *
           * Possible units are:
           *   SI Short   SI Full        Effigy       Other
           * - kwei       femtoether     babbage
           * - mwei       picoether      lovelace
           * - gwei       nanoether      shannon      nano
           * - --         microether     szabo        micro
           * - --         milliether     finney       milli
           * - ether      --             --
           * - kether                    --           grand
           * - mether
           * - gether
           * - tether
           *
           * @method fromWei
           * @param {Number|String} number can be a number, number string or a HEX of a decimal
           * @param {String} unit the unit to convert to, default ether
           * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
          */
          var fromWei = function (number, unit) {
            var returnValue = toBigNumber(number).dividedBy(getValueOfUnit(unit));

            return isBigNumber(number) ? returnValue : returnValue.toString(10);
          };

          /**
           * Takes a number of a unit and converts it to wei.
           *
           * Possible units are:
           *   SI Short   SI Full        Effigy       Other
           * - kwei       femtoether     babbage
           * - mwei       picoether      lovelace
           * - gwei       nanoether      shannon      nano
           * - --         microether     szabo        micro
           * - --         milliether     finney       milli
           * - ether      --             --
           * - kether                    --           grand
           * - mether
           * - gether
           * - tether
           *
           * @method toWei
           * @param {Number|String|BigNumber} number can be a number, number string or a HEX of a decimal
           * @param {String} unit the unit to convert from, default ether
           * @return {String|Object} When given a BigNumber object it returns one as well, otherwise a number
          */
          var toWei = function (number, unit) {
            var returnValue = toBigNumber(number).times(getValueOfUnit(unit));

            return isBigNumber(number) ? returnValue : returnValue.toString(10);
          };

          /**
           * Takes an input and transforms it into an bignumber
           *
           * @method toBigNumber
           * @param {Number|String|BigNumber} a number, string, HEX string or BigNumber
           * @return {BigNumber} BigNumber
          */
          var toBigNumber = function (number) {
            /*jshint maxcomplexity:5 */
            number = number || 0;
            if (isBigNumber(number))
              return number;

            if (isString(number) && (number.indexOf('0x') === 0 || number.indexOf('-0x') === 0)) {
              return new BigNumber(number.replace('0x', ''), 16);
            }

            return new BigNumber(number.toString(10), 10);
          };

          /**
           * Takes and input transforms it into bignumber and if it is negative value, into two's complement
           *
           * @method toTwosComplement
           * @param {Number|String|BigNumber}
           * @return {BigNumber}
           */
          var toTwosComplement = function (number) {
            var bigNumber = toBigNumber(number).round();
            if (bigNumber.lessThan(0)) {
              return new BigNumber("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16).plus(bigNumber).plus(1);
            }
            return bigNumber;
          };

          /**
           * Checks if the given string is strictly an address
           *
           * @method isStrictAddress
           * @param {String} address the given HEX adress
           * @return {Boolean}
          */
          var isStrictAddress = function (address) {
            return /^0x[0-9a-f]{40}$/i.test(address);
          };

          /**
           * Checks if the given string is an address
           *
           * @method isAddress
           * @param {String} address the given HEX adress
           * @return {Boolean}
          */
          var isAddress = function (address) {
            if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
              // check if it has the basic requirements of an address
              return false;
            } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
              // If it's all small caps or all all caps, return true
              return true;
            } else {
              // Otherwise check each case
              return isChecksumAddress(address);
            }
          };

          /**
           * Checks if the given string is a checksummed address
           *
           * @method isChecksumAddress
           * @param {String} address the given HEX adress
           * @return {Boolean}
          */
          var isChecksumAddress = function (address) {
            // Check each case
            address = address.replace('0x', '');
            var addressHash = sha3(address.toLowerCase());

            for (var i = 0; i < 40; i++) {
              // the nth letter should be uppercase if the nth digit of casemap is 1
              if ((parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i]) || (parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i])) {
                return false;
              }
            }
            return true;
          };



          /**
           * Makes a checksum address
           *
           * @method toChecksumAddress
           * @param {String} address the given HEX adress
           * @return {String}
          */
          var toChecksumAddress = function (address) {
            if (typeof address === 'undefined') return '';

            address = address.toLowerCase().replace('0x', '');
            var addressHash = sha3(address);
            var checksumAddress = '0x';

            for (var i = 0; i < address.length; i++) {
              // If ith character is 9 to f then make it uppercase
              if (parseInt(addressHash[i], 16) > 7) {
                checksumAddress += address[i].toUpperCase();
              } else {
                checksumAddress += address[i];
              }
            }
            return checksumAddress;
          };

          /**
           * Transforms given string to valid 20 bytes-length addres with 0x prefix
           *
           * @method toAddress
           * @param {String} address
           * @return {String} formatted address
           */
          var toAddress = function (address) {
            if (isStrictAddress(address)) {
              return address;
            }

            if (/^[0-9a-f]{40}$/.test(address)) {
              return '0x' + address;
            }

            return '0x' + padLeft(toHex(address).substr(2), 40);
          };

          /**
           * Returns true if object is BigNumber, otherwise false
           *
           * @method isBigNumber
           * @param {Object}
           * @return {Boolean}
           */
          var isBigNumber = function (object) {
            return object instanceof BigNumber ||
              (object && object.constructor && object.constructor.name === 'BigNumber');
          };

          /**
           * Returns true if object is string, otherwise false
           *
           * @method isString
           * @param {Object}
           * @return {Boolean}
           */
          var isString = function (object) {
            return typeof object === 'string' ||
              (object && object.constructor && object.constructor.name === 'String');
          };

          /**
           * Returns true if object is function, otherwise false
           *
           * @method isFunction
           * @param {Object}
           * @return {Boolean}
           */
          var isFunction = function (object) {
            return typeof object === 'function';
          };

          /**
           * Returns true if object is Objet, otherwise false
           *
           * @method isObject
           * @param {Object}
           * @return {Boolean}
           */
          var isObject = function (object) {
            return object !== null && !(Array.isArray(object)) && typeof object === 'object';
          };

          /**
           * Returns true if object is boolean, otherwise false
           *
           * @method isBoolean
           * @param {Object}
           * @return {Boolean}
           */
          var isBoolean = function (object) {
            return typeof object === 'boolean';
          };

          /**
           * Returns true if object is array, otherwise false
           *
           * @method isArray
           * @param {Object}
           * @return {Boolean}
           */
          var isArray = function (object) {
            return Array.isArray(object);
          };

          /**
           * Returns true if given string is valid json object
           *
           * @method isJson
           * @param {String}
           * @return {Boolean}
           */
          var isJson = function (str) {
            try {
              return !!JSON.parse(str);
            } catch (e) {
              return false;
            }
          };

          /**
           * Returns true if given string is a valid Ethereum block header bloom.
           *
           * @method isBloom
           * @param {String} hex encoded bloom filter
           * @return {Boolean}
           */
          var isBloom = function (bloom) {
            if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
              return false;
            } else if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
              return true;
            }
            return false;
          };

          /**
           * Returns true if given string is a valid log topic.
           *
           * @method isTopic
           * @param {String} hex encoded topic
           * @return {Boolean}
           */
          var isTopic = function (topic) {
            if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
              return false;
            } else if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
              return true;
            }
            return false;
          };

          module.exports = {
            padLeft: padLeft,
            padRight: padRight,
            toHex: toHex,
            toDecimal: toDecimal,
            fromDecimal: fromDecimal,
            toUtf8: toUtf8,
            toAscii: toAscii,
            fromUtf8: fromUtf8,
            fromAscii: fromAscii,
            transformToFullName: transformToFullName,
            extractDisplayName: extractDisplayName,
            extractTypeName: extractTypeName,
            toWei: toWei,
            fromWei: fromWei,
            toBigNumber: toBigNumber,
            toTwosComplement: toTwosComplement,
            toAddress: toAddress,
            isBigNumber: isBigNumber,
            isStrictAddress: isStrictAddress,
            isAddress: isAddress,
            isChecksumAddress: isChecksumAddress,
            toChecksumAddress: toChecksumAddress,
            isFunction: isFunction,
            isString: isString,
            isObject: isObject,
            isBoolean: isBoolean,
            isArray: isArray,
            isJson: isJson,
            isBloom: isBloom,
            isTopic: isTopic,
          };

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\version.json", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\version.json
        return function (require, module, exports) {
          module.exports = {
            "version": "0.20.7"
          }

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3.js", { "./utils/sha3": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js", "./utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./version.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\version.json", "./web3/batch": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\batch.js", "./web3/extend": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\extend.js", "./web3/httpprovider": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\httpprovider.js", "./web3/iban": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js", "./web3/ipcprovider": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\ipcprovider.js", "./web3/methods/db": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\db.js", "./web3/methods/eth": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\eth.js", "./web3/methods/net": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\net.js", "./web3/methods/personal": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\personal.js", "./web3/methods/shh": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\shh.js", "./web3/methods/swarm": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\swarm.js", "./web3/property": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js", "./web3/requestmanager": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\requestmanager.js", "./web3/settings": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\settings.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3.js
        return function (require, module, exports) {
          /*!
           * web3.js - Ethereum JavaScript API
           *
           * @license lgpl-3.0
           * @see https://github.com/ethereum/web3.js
          */

          /*
           * This file is part of web3.js.
           * 
           * web3.js is free software: you can redistribute it and/or modify
           * it under the terms of the GNU Lesser General Public License as published by
           * the Free Software Foundation, either version 3 of the License, or
           * (at your option) any later version.
           * 
           * web3.js is distributed in the hope that it will be useful,
           * but WITHOUT ANY WARRANTY; without even the implied warranty of
           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
           * GNU Lesser General Public License for more details.
           * 
           * You should have received a copy of the GNU Lesser General Public License
           * along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
           *
           * @file web3.js
           * @authors:
           *   Jeffrey Wilcke <jeff@ethdev.com>
           *   Marek Kotewicz <marek@ethdev.com>
           *   Marian Oancea <marian@ethdev.com>
           *   Fabian Vogelsteller <fabian@ethdev.com>
           *   Gav Wood <g@ethdev.com>
           * @date 2014
           */

          var RequestManager = require('./web3/requestmanager');
          var Iban = require('./web3/iban');
          var Eth = require('./web3/methods/eth');
          var DB = require('./web3/methods/db');
          var Shh = require('./web3/methods/shh');
          var Net = require('./web3/methods/net');
          var Personal = require('./web3/methods/personal');
          var Swarm = require('./web3/methods/swarm');
          var Settings = require('./web3/settings');
          var version = require('./version.json');
          var utils = require('./utils/utils');
          var sha3 = require('./utils/sha3');
          var extend = require('./web3/extend');
          var Batch = require('./web3/batch');
          var Property = require('./web3/property');
          var HttpProvider = require('./web3/httpprovider');
          var IpcProvider = require('./web3/ipcprovider');
          var BigNumber = require('bignumber.js');



          function Web3(provider) {
            this._requestManager = new RequestManager(provider);
            this.currentProvider = provider;
            this.eth = new Eth(this);
            this.db = new DB(this);
            this.shh = new Shh(this);
            this.net = new Net(this);
            this.personal = new Personal(this);
            this.bzz = new Swarm(this);
            this.settings = new Settings();
            this.version = {
              api: version.version
            };
            this.providers = {
              HttpProvider: HttpProvider,
              IpcProvider: IpcProvider
            };
            this._extend = extend(this);
            this._extend({
              properties: properties()
            });
          }

          // expose providers on the class
          Web3.providers = {
            HttpProvider: HttpProvider,
            IpcProvider: IpcProvider
          };

          Web3.prototype.setProvider = function (provider) {
            this._requestManager.setProvider(provider);
            this.currentProvider = provider;
          };

          Web3.prototype.reset = function (keepIsSyncing) {
            this._requestManager.reset(keepIsSyncing);
            this.settings = new Settings();
          };

          Web3.prototype.BigNumber = BigNumber;
          Web3.prototype.toHex = utils.toHex;
          Web3.prototype.toAscii = utils.toAscii;
          Web3.prototype.toUtf8 = utils.toUtf8;
          Web3.prototype.fromAscii = utils.fromAscii;
          Web3.prototype.fromUtf8 = utils.fromUtf8;
          Web3.prototype.toDecimal = utils.toDecimal;
          Web3.prototype.fromDecimal = utils.fromDecimal;
          Web3.prototype.toBigNumber = utils.toBigNumber;
          Web3.prototype.toWei = utils.toWei;
          Web3.prototype.fromWei = utils.fromWei;
          Web3.prototype.isAddress = utils.isAddress;
          Web3.prototype.isChecksumAddress = utils.isChecksumAddress;
          Web3.prototype.toChecksumAddress = utils.toChecksumAddress;
          Web3.prototype.isIBAN = utils.isIBAN;
          Web3.prototype.padLeft = utils.padLeft;
          Web3.prototype.padRight = utils.padRight;


          Web3.prototype.sha3 = function (string, options) {
            return '0x' + sha3(string, options);
          };

          /**
           * Transforms direct icap to address
           */
          Web3.prototype.fromICAP = function (icap) {
            var iban = new Iban(icap);
            return iban.address();
          };

          var properties = function () {
            return [
              new Property({
                name: 'version.node',
                getter: 'web3_clientVersion'
              }),
              new Property({
                name: 'version.network',
                getter: 'net_version',
                inputFormatter: utils.toDecimal
              }),
              new Property({
                name: 'version.ethereum',
                getter: 'eth_protocolVersion',
                inputFormatter: utils.toDecimal
              }),
              new Property({
                name: 'version.whisper',
                getter: 'shh_version',
                inputFormatter: utils.toDecimal
              })
            ];
          };

          Web3.prototype.isConnected = function () {
            return (this.currentProvider && this.currentProvider.isConnected());
          };

          Web3.prototype.createBatch = function () {
            return new Batch(this);
          };

          module.exports = Web3;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\allevents.js", { "../utils/sha3": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js", "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./event": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\event.js", "./filter": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js", "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js", "./methods/watches": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\allevents.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file allevents.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2014
           */

          var sha3 = require('../utils/sha3');
          var SolidityEvent = require('./event');
          var formatters = require('./formatters');
          var utils = require('../utils/utils');
          var Filter = require('./filter');
          var watches = require('./methods/watches');

          var AllSolidityEvents = function (requestManager, json, address) {
            this._requestManager = requestManager;
            this._json = json;
            this._address = address;
          };

          AllSolidityEvents.prototype.encode = function (options) {
            options = options || {};
            var result = {};

            ['fromBlock', 'toBlock'].filter(function (f) {
              return options[f] !== undefined;
            }).forEach(function (f) {
              result[f] = formatters.inputBlockNumberFormatter(options[f]);
            });

            result.address = this._address;

            return result;
          };

          AllSolidityEvents.prototype.decode = function (data) {
            data.data = data.data || '';


            var eventTopic = (utils.isArray(data.topics) && utils.isString(data.topics[0])) ? data.topics[0].slice(2) : '';
            var match = this._json.filter(function (j) {
              return eventTopic === sha3(utils.transformToFullName(j));
            })[0];

            if (!match) { // cannot find matching event?
              return formatters.outputLogFormatter(data);
            }

            var event = new SolidityEvent(this._requestManager, match, this._address);
            return event.decode(data);
          };

          AllSolidityEvents.prototype.execute = function (options, callback) {

            if (utils.isFunction(arguments[arguments.length - 1])) {
              callback = arguments[arguments.length - 1];
              if (arguments.length === 1)
                options = null;
            }

            var o = this.encode(options);
            var formatter = this.decode.bind(this);
            return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
          };

          AllSolidityEvents.prototype.attachToContract = function (contract) {
            var execute = this.execute.bind(this);
            contract.allEvents = execute;
          };

          module.exports = AllSolidityEvents;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\batch.js", { "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js", "./jsonrpc": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\jsonrpc.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\batch.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file batch.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var Jsonrpc = require('./jsonrpc');
          var errors = require('./errors');

          var Batch = function (web3) {
            this.requestManager = web3._requestManager;
            this.requests = [];
          };

          /**
           * Should be called to add create new request to batch request
           *
           * @method add
           * @param {Object} jsonrpc requet object
           */
          Batch.prototype.add = function (request) {
            this.requests.push(request);
          };

          /**
           * Should be called to execute batch request
           *
           * @method execute
           */
          Batch.prototype.execute = function () {
            var requests = this.requests;
            this.requestManager.sendBatch(requests, function (err, results) {
              results = results || [];
              requests.map(function (request, index) {
                return results[index] || {};
              }).forEach(function (result, index) {
                if (requests[index].callback) {

                  if (!Jsonrpc.isValidResponse(result)) {
                    return requests[index].callback(errors.InvalidResponse(result));
                  }

                  requests[index].callback(null, (requests[index].format ? requests[index].format(result.result) : result.result));
                }
              });
            });
          };

          module.exports = Batch;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\contract.js", { "../solidity/coder": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js", "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./allevents": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\allevents.js", "./event": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\event.js", "./function": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\function.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\contract.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file contract.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2014
           */

          var utils = require('../utils/utils');
          var coder = require('../solidity/coder');
          var SolidityEvent = require('./event');
          var SolidityFunction = require('./function');
          var AllEvents = require('./allevents');

          /**
           * Should be called to encode constructor params
           *
           * @method encodeConstructorParams
           * @param {Array} abi
           * @param {Array} constructor params
           */
          var encodeConstructorParams = function (abi, params) {
            return abi.filter(function (json) {
              return json.type === 'constructor' && json.inputs.length === params.length;
            }).map(function (json) {
              return json.inputs.map(function (input) {
                return input.type;
              });
            }).map(function (types) {
              return coder.encodeParams(types, params);
            })[0] || '';
          };

          /**
           * Should be called to add functions to contract object
           *
           * @method addFunctionsToContract
           * @param {Contract} contract
           * @param {Array} abi
           */
          var addFunctionsToContract = function (contract) {
            contract.abi.filter(function (json) {
              return json.type === 'function';
            }).map(function (json) {
              return new SolidityFunction(contract._eth, json, contract.address);
            }).forEach(function (f) {
              f.attachToContract(contract);
            });
          };

          /**
           * Should be called to add events to contract object
           *
           * @method addEventsToContract
           * @param {Contract} contract
           * @param {Array} abi
           */
          var addEventsToContract = function (contract) {
            var events = contract.abi.filter(function (json) {
              return json.type === 'event';
            });

            var All = new AllEvents(contract._eth._requestManager, events, contract.address);
            All.attachToContract(contract);

            events.map(function (json) {
              return new SolidityEvent(contract._eth._requestManager, json, contract.address);
            }).forEach(function (e) {
              e.attachToContract(contract);
            });
          };


          /**
           * Should be called to check if the contract gets properly deployed on the blockchain.
           *
           * @method checkForContractAddress
           * @param {Object} contract
           * @param {Function} callback
           * @returns {Undefined}
           */
          var checkForContractAddress = function (contract, callback) {
            var count = 0,
              callbackFired = false;

            // wait for receipt
            var filter = contract._eth.filter('latest', function (e) {
              if (!e && !callbackFired) {
                count++;

                // stop watching after 50 blocks (timeout)
                if (count > 50) {

                  filter.stopWatching(function () { });
                  callbackFired = true;

                  if (callback)
                    callback(new Error('Contract transaction couldn\'t be found after 50 blocks'));
                  else
                    throw new Error('Contract transaction couldn\'t be found after 50 blocks');


                } else {

                  contract._eth.getTransactionReceipt(contract.transactionHash, function (e, receipt) {
                    if (receipt && receipt.blockHash && !callbackFired) {

                      contract._eth.getCode(receipt.contractAddress, function (e, code) {
                        /*jshint maxcomplexity: 6 */

                        if (callbackFired || !code)
                          return;

                        filter.stopWatching(function () { });
                        callbackFired = true;

                        if (code.length > 3) {

                          // console.log('Contract code deployed!');

                          contract.address = receipt.contractAddress;

                          // attach events and methods again after we have
                          addFunctionsToContract(contract);
                          addEventsToContract(contract);

                          // call callback for the second time
                          if (callback)
                            callback(null, contract);

                        } else {
                          if (callback)
                            callback(new Error('The contract code couldn\'t be stored, please check your gas amount.'));
                          else
                            throw new Error('The contract code couldn\'t be stored, please check your gas amount.');
                        }
                      });
                    }
                  });
                }
              }
            });
          };

          /**
           * Should be called to create new ContractFactory instance
           *
           * @method ContractFactory
           * @param {Array} abi
           */
          var ContractFactory = function (eth, abi) {
            this.eth = eth;
            this.abi = abi;

            /**
             * Should be called to create new contract on a blockchain
             *
             * @method new
             * @param {Any} contract constructor param1 (optional)
             * @param {Any} contract constructor param2 (optional)
             * @param {Object} contract transaction object (required)
             * @param {Function} callback
             * @returns {Contract} returns contract instance
             */
            this.new = function () {
              /*jshint maxcomplexity: 7 */

              var contract = new Contract(this.eth, this.abi);

              // parse arguments
              var options = {}; // required!
              var callback;

              var args = Array.prototype.slice.call(arguments);
              if (utils.isFunction(args[args.length - 1])) {
                callback = args.pop();
              }

              var last = args[args.length - 1];
              if (utils.isObject(last) && !utils.isArray(last)) {
                options = args.pop();
              }

              if (options.value > 0) {
                var constructorAbi = abi.filter(function (json) {
                  return json.type === 'constructor' && json.inputs.length === args.length;
                })[0] || {};

                if (!constructorAbi.payable) {
                  throw new Error('Cannot send value to non-payable constructor');
                }
              }

              var bytes = encodeConstructorParams(this.abi, args);
              options.data += bytes;

              if (callback) {

                // wait for the contract address and check if the code was deployed
                this.eth.sendTransaction(options, function (err, hash) {
                  if (err) {
                    callback(err);
                  } else {
                    // add the transaction hash
                    contract.transactionHash = hash;

                    // call callback for the first time
                    callback(null, contract);

                    checkForContractAddress(contract, callback);
                  }
                });
              } else {
                var hash = this.eth.sendTransaction(options);
                // add the transaction hash
                contract.transactionHash = hash;
                checkForContractAddress(contract);
              }

              return contract;
            };

            this.new.getData = this.getData.bind(this);
          };

          /**
           * Should be called to create new ContractFactory
           *
           * @method contract
           * @param {Array} abi
           * @returns {ContractFactory} new contract factory
           */
          //var contract = function (abi) {
          //return new ContractFactory(abi);
          //};



          /**
           * Should be called to get access to existing contract on a blockchain
           *
           * @method at
           * @param {Address} contract address (required)
           * @param {Function} callback {optional)
           * @returns {Contract} returns contract if no callback was passed,
           * otherwise calls callback function (err, contract)
           */
          ContractFactory.prototype.at = function (address, callback) {
            var contract = new Contract(this.eth, this.abi, address);

            // this functions are not part of prototype,
            // because we dont want to spoil the interface
            addFunctionsToContract(contract);
            addEventsToContract(contract);

            if (callback) {
              callback(null, contract);
            }
            return contract;
          };

          /**
           * Gets the data, which is data to deploy plus constructor params
           *
           * @method getData
           */
          ContractFactory.prototype.getData = function () {
            var options = {}; // required!
            var args = Array.prototype.slice.call(arguments);

            var last = args[args.length - 1];
            if (utils.isObject(last) && !utils.isArray(last)) {
              options = args.pop();
            }

            var bytes = encodeConstructorParams(this.abi, args);
            options.data += bytes;

            return options.data;
          };

          /**
           * Should be called to create new contract instance
           *
           * @method Contract
           * @param {Array} abi
           * @param {Address} contract address
           */
          var Contract = function (eth, abi, address) {
            this._eth = eth;
            this.transactionHash = null;
            this.address = address;
            this.abi = abi;
          };

          module.exports = ContractFactory;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\errors.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file errors.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          module.exports = {
            InvalidNumberOfSolidityArgs: function () {
              return new Error('Invalid number of arguments to Solidity function');
            },
            InvalidNumberOfRPCParams: function () {
              return new Error('Invalid number of input parameters to RPC method');
            },
            InvalidConnection: function (host) {
              return new Error('CONNECTION ERROR: Couldn\'t connect to node ' + host + '.');
            },
            InvalidProvider: function () {
              return new Error('Provider not set or invalid');
            },
            InvalidResponse: function (result) {
              var message = !!result && !!result.error && !!result.error.message ? result.error.message : 'Invalid JSON RPC response: ' + JSON.stringify(result);
              return new Error(message);
            },
            ConnectionTimeout: function (ms) {
              return new Error('CONNECTION TIMEOUT: timeout of ' + ms + ' ms achived');
            }
          };

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\event.js", { "../solidity/coder": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js", "../utils/sha3": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js", "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./filter": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js", "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js", "./methods/watches": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\event.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file event.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2014
           */

          var utils = require('../utils/utils');
          var coder = require('../solidity/coder');
          var formatters = require('./formatters');
          var sha3 = require('../utils/sha3');
          var Filter = require('./filter');
          var watches = require('./methods/watches');

          /**
           * This prototype should be used to create event filters
           */
          var SolidityEvent = function (requestManager, json, address) {
            this._requestManager = requestManager;
            this._params = json.inputs;
            this._name = utils.transformToFullName(json);
            this._address = address;
            this._anonymous = json.anonymous;
          };

          /**
           * Should be used to get filtered param types
           *
           * @method types
           * @param {Bool} decide if returned typed should be indexed
           * @return {Array} array of types
           */
          SolidityEvent.prototype.types = function (indexed) {
            return this._params.filter(function (i) {
              return i.indexed === indexed;
            }).map(function (i) {
              return i.type;
            });
          };

          /**
           * Should be used to get event display name
           *
           * @method displayName
           * @return {String} event display name
           */
          SolidityEvent.prototype.displayName = function () {
            return utils.extractDisplayName(this._name);
          };

          /**
           * Should be used to get event type name
           *
           * @method typeName
           * @return {String} event type name
           */
          SolidityEvent.prototype.typeName = function () {
            return utils.extractTypeName(this._name);
          };

          /**
           * Should be used to get event signature
           *
           * @method signature
           * @return {String} event signature
           */
          SolidityEvent.prototype.signature = function () {
            return sha3(this._name);
          };

          /**
           * Should be used to encode indexed params and options to one final object
           *
           * @method encode
           * @param {Object} indexed
           * @param {Object} options
           * @return {Object} everything combined together and encoded
           */
          SolidityEvent.prototype.encode = function (indexed, options) {
            indexed = indexed || {};
            options = options || {};
            var result = {};

            ['fromBlock', 'toBlock'].filter(function (f) {
              return options[f] !== undefined;
            }).forEach(function (f) {
              result[f] = formatters.inputBlockNumberFormatter(options[f]);
            });

            result.topics = [];

            result.address = this._address;
            if (!this._anonymous) {
              result.topics.push('0x' + this.signature());
            }

            var indexedTopics = this._params.filter(function (i) {
              return i.indexed === true;
            }).map(function (i) {
              var value = indexed[i.name];
              if (value === undefined || value === null) {
                return null;
              }

              if (utils.isArray(value)) {
                return value.map(function (v) {
                  return '0x' + coder.encodeParam(i.type, v);
                });
              }
              return '0x' + coder.encodeParam(i.type, value);
            });

            result.topics = result.topics.concat(indexedTopics);

            return result;
          };

          /**
           * Should be used to decode indexed params and options
           *
           * @method decode
           * @param {Object} data
           * @return {Object} result object with decoded indexed && not indexed params
           */
          SolidityEvent.prototype.decode = function (data) {

            data.data = data.data || '';
            data.topics = data.topics || [];


            var argTopics = this._anonymous ? data.topics : data.topics.slice(1);
            var indexedData = argTopics.map(function (topics) { return topics.slice(2); }).join("");
            var indexedParams = coder.decodeParams(this.types(true), indexedData);

            var notIndexedData = data.data.slice(2);
            var notIndexedParams = coder.decodeParams(this.types(false), notIndexedData);

            var result = formatters.outputLogFormatter(data);
            result.event = this.displayName();
            result.address = data.address;

            result.args = this._params.reduce(function (acc, current) {
              acc[current.name] = current.indexed ? indexedParams.shift() : notIndexedParams.shift();
              return acc;
            }, {});

            delete result.data;
            delete result.topics;

            return result;
          };

          /**
           * Should be used to create new filter object from event
           *
           * @method execute
           * @param {Object} indexed
           * @param {Object} options
           * @return {Object} filter object
           */
          SolidityEvent.prototype.execute = function (indexed, options, callback) {

            if (utils.isFunction(arguments[arguments.length - 1])) {
              callback = arguments[arguments.length - 1];
              if (arguments.length === 2)
                options = null;
              if (arguments.length === 1) {
                options = null;
                indexed = {};
              }
            }

            var o = this.encode(indexed, options);
            var formatter = this.decode.bind(this);
            return new Filter(o, 'eth', this._requestManager, watches.eth(), formatter, callback);
          };

          /**
           * Should be used to attach event to contract object
           *
           * @method attachToContract
           * @param {Contract}
           */
          SolidityEvent.prototype.attachToContract = function (contract) {
            var execute = this.execute.bind(this);
            var displayName = this.displayName();
            if (!contract[displayName]) {
              contract[displayName] = execute;
            }
            contract[displayName][this.typeName()] = this.execute.bind(this, contract);
          };

          module.exports = SolidityEvent;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\extend.js", { "./../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js", "./method": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js", "./property": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\extend.js
        return function (require, module, exports) {
          var formatters = require('./formatters');
          var utils = require('./../utils/utils');
          var Method = require('./method');
          var Property = require('./property');

          // TODO: refactor, so the input params are not altered.
          // it's necessary to make same 'extension' work with multiple providers
          var extend = function (web3) {
            /* jshint maxcomplexity:5 */
            var ex = function (extension) {

              var extendedObject;
              if (extension.property) {
                if (!web3[extension.property]) {
                  web3[extension.property] = {};
                }
                extendedObject = web3[extension.property];
              } else {
                extendedObject = web3;
              }

              if (extension.methods) {
                extension.methods.forEach(function (method) {
                  method.attachToObject(extendedObject);
                  method.setRequestManager(web3._requestManager);
                });
              }

              if (extension.properties) {
                extension.properties.forEach(function (property) {
                  property.attachToObject(extendedObject);
                  property.setRequestManager(web3._requestManager);
                });
              }
            };

            ex.formatters = formatters;
            ex.utils = utils;
            ex.Method = Method;
            ex.Property = Property;

            return ex;
          };



          module.exports = extend;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js", { "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\filter.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file filter.js
           * @authors:
           *   Jeffrey Wilcke <jeff@ethdev.com>
           *   Marek Kotewicz <marek@ethdev.com>
           *   Marian Oancea <marian@ethdev.com>
           *   Fabian Vogelsteller <fabian@ethdev.com>
           *   Gav Wood <g@ethdev.com>
           * @date 2014
           */

          var formatters = require('./formatters');
          var utils = require('../utils/utils');

          /**
          * Converts a given topic to a hex string, but also allows null values.
          *
          * @param {Mixed} value
          * @return {String}
          */
          var toTopic = function (value) {

            if (value === null || typeof value === 'undefined')
              return null;

            value = String(value);

            if (value.indexOf('0x') === 0)
              return value;
            else
              return utils.fromUtf8(value);
          };

          /// This method should be called on options object, to verify deprecated properties && lazy load dynamic ones
          /// @param should be string or object
          /// @returns options string or object
          var getOptions = function (options, type) {
            /*jshint maxcomplexity: 6 */

            if (utils.isString(options)) {
              return options;
            }

            options = options || {};


            switch (type) {
              case 'eth':

                // make sure topics, get converted to hex
                options.topics = options.topics || [];
                options.topics = options.topics.map(function (topic) {
                  return (utils.isArray(topic)) ? topic.map(toTopic) : toTopic(topic);
                });

                return {
                  topics: options.topics,
                  from: options.from,
                  to: options.to,
                  address: options.address,
                  fromBlock: formatters.inputBlockNumberFormatter(options.fromBlock),
                  toBlock: formatters.inputBlockNumberFormatter(options.toBlock)
                };
              case 'shh':
                return options;
            }
          };

          /**
          Adds the callback and sets up the methods, to iterate over the results.
          
          @method getLogsAtStart
          @param {Object} self
          @param {function} callback
          */
          var getLogsAtStart = function (self, callback) {
            // call getFilterLogs for the first watch callback start
            if (!utils.isString(self.options)) {
              self.get(function (err, messages) {
                // don't send all the responses to all the watches again... just to self one
                if (err) {
                  callback(err);
                }

                if (utils.isArray(messages)) {
                  messages.forEach(function (message) {
                    callback(null, message);
                  });
                }
              });
            }
          };

          /**
          Adds the callback and sets up the methods, to iterate over the results.
          
          @method pollFilter
          @param {Object} self
          */
          var pollFilter = function (self) {

            var onMessage = function (error, messages) {
              if (error) {
                return self.callbacks.forEach(function (callback) {
                  callback(error);
                });
              }

              if (utils.isArray(messages)) {
                messages.forEach(function (message) {
                  message = self.formatter ? self.formatter(message) : message;
                  self.callbacks.forEach(function (callback) {
                    callback(null, message);
                  });
                });
              }
            };

            self.requestManager.startPolling({
              method: self.implementation.poll.call,
              params: [self.filterId],
            }, self.filterId, onMessage, self.stopWatching.bind(self));

          };

          var Filter = function (options, type, requestManager, methods, formatter, callback, filterCreationErrorCallback) {
            var self = this;
            var implementation = {};
            methods.forEach(function (method) {
              method.setRequestManager(requestManager);
              method.attachToObject(implementation);
            });
            this.requestManager = requestManager;
            this.options = getOptions(options, type);
            this.implementation = implementation;
            this.filterId = null;
            this.callbacks = [];
            this.getLogsCallbacks = [];
            this.pollFilters = [];
            this.formatter = formatter;
            this.implementation.newFilter(this.options, function (error, id) {
              if (error) {
                self.callbacks.forEach(function (cb) {
                  cb(error);
                });
                if (typeof filterCreationErrorCallback === 'function') {
                  filterCreationErrorCallback(error);
                }
              } else {
                self.filterId = id;

                // check if there are get pending callbacks as a consequence
                // of calling get() with filterId unassigned.
                self.getLogsCallbacks.forEach(function (cb) {
                  self.get(cb);
                });
                self.getLogsCallbacks = [];

                // get filter logs for the already existing watch calls
                self.callbacks.forEach(function (cb) {
                  getLogsAtStart(self, cb);
                });
                if (self.callbacks.length > 0)
                  pollFilter(self);

                // start to watch immediately
                if (typeof callback === 'function') {
                  return self.watch(callback);
                }
              }
            });

            return this;
          };

          Filter.prototype.watch = function (callback) {
            this.callbacks.push(callback);

            if (this.filterId) {
              getLogsAtStart(this, callback);
              pollFilter(this);
            }

            return this;
          };

          Filter.prototype.stopWatching = function (callback) {
            this.requestManager.stopPolling(this.filterId);
            this.callbacks = [];
            // remove filter async
            if (callback) {
              this.implementation.uninstallFilter(this.filterId, callback);
            } else {
              return this.implementation.uninstallFilter(this.filterId);
            }
          };

          Filter.prototype.get = function (callback) {
            var self = this;
            if (utils.isFunction(callback)) {
              if (this.filterId === null) {
                // If filterId is not set yet, call it back
                // when newFilter() assigns it.
                this.getLogsCallbacks.push(callback);
              } else {
                this.implementation.getLogs(this.filterId, function (err, res) {
                  if (err) {
                    callback(err);
                  } else {
                    callback(null, res.map(function (log) {
                      return self.formatter ? self.formatter(log) : log;
                    }));
                  }
                });
              }
            } else {
              if (this.filterId === null) {
                throw new Error('Filter ID Error: filter().get() can\'t be chained synchronous, please provide a callback for the get() method.');
              }
              var logs = this.implementation.getLogs(this.filterId);
              return logs.map(function (log) {
                return self.formatter ? self.formatter(log) : log;
              });
            }

            return this;
          };

          module.exports = Filter;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js", { "../utils/config": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js", "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./iban": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\formatters.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file formatters.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @author Fabian Vogelsteller <fabian@ethdev.com>
           * @date 2015
           */

          'use strict';


          var utils = require('../utils/utils');
          var config = require('../utils/config');
          var Iban = require('./iban');

          /**
           * Should the format output to a big number
           *
           * @method outputBigNumberFormatter
           * @param {String|Number|BigNumber}
           * @returns {BigNumber} object
           */
          var outputBigNumberFormatter = function (number) {
            return utils.toBigNumber(number);
          };

          var isPredefinedBlockNumber = function (blockNumber) {
            return blockNumber === 'latest' || blockNumber === 'pending' || blockNumber === 'earliest';
          };

          var inputDefaultBlockNumberFormatter = function (blockNumber) {
            if (blockNumber === undefined) {
              return config.defaultBlock;
            }
            return inputBlockNumberFormatter(blockNumber);
          };

          var inputBlockNumberFormatter = function (blockNumber) {
            if (blockNumber === undefined) {
              return undefined;
            } else if (isPredefinedBlockNumber(blockNumber)) {
              return blockNumber;
            }
            return utils.toHex(blockNumber);
          };

          /**
           * Formats the input of a transaction and converts all values to HEX
           *
           * @method inputCallFormatter
           * @param {Object} transaction options
           * @returns object
          */
          var inputCallFormatter = function (options) {

            options.from = options.from || config.defaultAccount;

            if (options.from) {
              options.from = inputAddressFormatter(options.from);
            }

            if (options.to) { // it might be contract creation
              options.to = inputAddressFormatter(options.to);
            }

            ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
              return options[key] !== undefined;
            }).forEach(function (key) {
              options[key] = utils.fromDecimal(options[key]);
            });

            return options;
          };

          /**
           * Formats the input of a transaction and converts all values to HEX
           *
           * @method inputTransactionFormatter
           * @param {Object} transaction options
           * @returns object
          */
          var inputTransactionFormatter = function (options) {

            options.from = options.from || config.defaultAccount;
            options.from = inputAddressFormatter(options.from);

            if (options.to) { // it might be contract creation
              options.to = inputAddressFormatter(options.to);
            }

            ['gasPrice', 'gas', 'value', 'nonce'].filter(function (key) {
              return options[key] !== undefined;
            }).forEach(function (key) {
              options[key] = utils.fromDecimal(options[key]);
            });

            return options;
          };

          /**
           * Formats the output of a transaction to its proper values
           *
           * @method outputTransactionFormatter
           * @param {Object} tx
           * @returns {Object}
          */
          var outputTransactionFormatter = function (tx) {
            if (tx.blockNumber !== null)
              tx.blockNumber = utils.toDecimal(tx.blockNumber);
            if (tx.transactionIndex !== null)
              tx.transactionIndex = utils.toDecimal(tx.transactionIndex);
            tx.nonce = utils.toDecimal(tx.nonce);
            tx.gas = utils.toDecimal(tx.gas);
            tx.gasPrice = utils.toBigNumber(tx.gasPrice);
            tx.value = utils.toBigNumber(tx.value);
            return tx;
          };

          /**
           * Formats the output of a transaction receipt to its proper values
           *
           * @method outputTransactionReceiptFormatter
           * @param {Object} receipt
           * @returns {Object}
          */
          var outputTransactionReceiptFormatter = function (receipt) {
            if (receipt.blockNumber !== null)
              receipt.blockNumber = utils.toDecimal(receipt.blockNumber);
            if (receipt.transactionIndex !== null)
              receipt.transactionIndex = utils.toDecimal(receipt.transactionIndex);
            receipt.cumulativeGasUsed = utils.toDecimal(receipt.cumulativeGasUsed);
            receipt.gasUsed = utils.toDecimal(receipt.gasUsed);

            if (utils.isArray(receipt.logs)) {
              receipt.logs = receipt.logs.map(function (log) {
                return outputLogFormatter(log);
              });
            }

            return receipt;
          };

          /**
           * Formats the output of a block to its proper values
           *
           * @method outputBlockFormatter
           * @param {Object} block
           * @returns {Object}
          */
          var outputBlockFormatter = function (block) {

            // transform to number
            block.gasLimit = utils.toDecimal(block.gasLimit);
            block.gasUsed = utils.toDecimal(block.gasUsed);
            block.size = utils.toDecimal(block.size);
            block.timestamp = utils.toDecimal(block.timestamp);
            if (block.number !== null)
              block.number = utils.toDecimal(block.number);

            block.difficulty = utils.toBigNumber(block.difficulty);
            block.totalDifficulty = utils.toBigNumber(block.totalDifficulty);

            if (utils.isArray(block.transactions)) {
              block.transactions.forEach(function (item) {
                if (!utils.isString(item))
                  return outputTransactionFormatter(item);
              });
            }

            return block;
          };

          /**
           * Formats the output of a log
           *
           * @method outputLogFormatter
           * @param {Object} log object
           * @returns {Object} log
          */
          var outputLogFormatter = function (log) {
            if (log.blockNumber)
              log.blockNumber = utils.toDecimal(log.blockNumber);
            if (log.transactionIndex)
              log.transactionIndex = utils.toDecimal(log.transactionIndex);
            if (log.logIndex)
              log.logIndex = utils.toDecimal(log.logIndex);

            return log;
          };

          /**
           * Formats the input of a whisper post and converts all values to HEX
           *
           * @method inputPostFormatter
           * @param {Object} transaction object
           * @returns {Object}
          */
          var inputPostFormatter = function (post) {

            // post.payload = utils.toHex(post.payload);
            post.ttl = utils.fromDecimal(post.ttl);
            post.workToProve = utils.fromDecimal(post.workToProve);
            post.priority = utils.fromDecimal(post.priority);

            // fallback
            if (!utils.isArray(post.topics)) {
              post.topics = post.topics ? [post.topics] : [];
            }

            // format the following options
            post.topics = post.topics.map(function (topic) {
              // convert only if not hex
              return (topic.indexOf('0x') === 0) ? topic : utils.fromUtf8(topic);
            });

            return post;
          };

          /**
           * Formats the output of a received post message
           *
           * @method outputPostFormatter
           * @param {Object}
           * @returns {Object}
           */
          var outputPostFormatter = function (post) {

            post.expiry = utils.toDecimal(post.expiry);
            post.sent = utils.toDecimal(post.sent);
            post.ttl = utils.toDecimal(post.ttl);
            post.workProved = utils.toDecimal(post.workProved);
            // post.payloadRaw = post.payload;
            // post.payload = utils.toAscii(post.payload);

            // if (utils.isJson(post.payload)) {
            //     post.payload = JSON.parse(post.payload);
            // }

            // format the following options
            if (!post.topics) {
              post.topics = [];
            }
            post.topics = post.topics.map(function (topic) {
              return utils.toAscii(topic);
            });

            return post;
          };

          var inputAddressFormatter = function (address) {
            var iban = new Iban(address);
            if (iban.isValid() && iban.isDirect()) {
              return '0x' + iban.address();
            } else if (utils.isStrictAddress(address)) {
              return address;
            } else if (utils.isAddress(address)) {
              return '0x' + address;
            }
            throw new Error('invalid address');
          };


          var outputSyncingFormatter = function (result) {
            if (!result) {
              return result;
            }

            result.startingBlock = utils.toDecimal(result.startingBlock);
            result.currentBlock = utils.toDecimal(result.currentBlock);
            result.highestBlock = utils.toDecimal(result.highestBlock);
            if (result.knownStates) {
              result.knownStates = utils.toDecimal(result.knownStates);
              result.pulledStates = utils.toDecimal(result.pulledStates);
            }

            return result;
          };

          module.exports = {
            inputDefaultBlockNumberFormatter: inputDefaultBlockNumberFormatter,
            inputBlockNumberFormatter: inputBlockNumberFormatter,
            inputCallFormatter: inputCallFormatter,
            inputTransactionFormatter: inputTransactionFormatter,
            inputAddressFormatter: inputAddressFormatter,
            inputPostFormatter: inputPostFormatter,
            outputBigNumberFormatter: outputBigNumberFormatter,
            outputTransactionFormatter: outputTransactionFormatter,
            outputTransactionReceiptFormatter: outputTransactionReceiptFormatter,
            outputBlockFormatter: outputBlockFormatter,
            outputLogFormatter: outputLogFormatter,
            outputPostFormatter: outputPostFormatter,
            outputSyncingFormatter: outputSyncingFormatter
          };


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\function.js", { "../solidity/coder": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\solidity\\coder.js", "../utils/sha3": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\sha3.js", "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js", "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\function.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file function.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var coder = require('../solidity/coder');
          var utils = require('../utils/utils');
          var errors = require('./errors');
          var formatters = require('./formatters');
          var sha3 = require('../utils/sha3');

          /**
           * This prototype should be used to call/sendTransaction to solidity functions
           */
          var SolidityFunction = function (eth, json, address) {
            this._eth = eth;
            this._inputTypes = json.inputs.map(function (i) {
              return i.type;
            });
            this._outputTypes = json.outputs.map(function (i) {
              return i.type;
            });
            this._constant = (json.stateMutability === "view" || json.stateMutability === "pure" || json.constant);
            this._payable = (json.stateMutability === "payable" || json.payable);
            this._name = utils.transformToFullName(json);
            this._address = address;
          };

          SolidityFunction.prototype.extractCallback = function (args) {
            if (utils.isFunction(args[args.length - 1])) {
              return args.pop(); // modify the args array!
            }
          };

          SolidityFunction.prototype.extractDefaultBlock = function (args) {
            if (args.length > this._inputTypes.length && !utils.isObject(args[args.length - 1])) {
              return formatters.inputDefaultBlockNumberFormatter(args.pop()); // modify the args array!
            }
          };

          /**
           * Should be called to check if the number of arguments is correct
           *
           * @method validateArgs
           * @param {Array} arguments
           * @throws {Error} if it is not
           */
          SolidityFunction.prototype.validateArgs = function (args) {
            var inputArgs = args.filter(function (a) {
              // filter the options object but not arguments that are arrays
              return !((utils.isObject(a) === true) &&
                (utils.isArray(a) === false) &&
                (utils.isBigNumber(a) === false)
              );
            });
            if (inputArgs.length !== this._inputTypes.length) {
              throw errors.InvalidNumberOfSolidityArgs();
            }
          };

          /**
           * Should be used to create payload from arguments
           *
           * @method toPayload
           * @param {Array} solidity function params
           * @param {Object} optional payload options
           */
          SolidityFunction.prototype.toPayload = function (args) {
            var options = {};
            if (args.length > this._inputTypes.length && utils.isObject(args[args.length - 1])) {
              options = args[args.length - 1];
            }
            this.validateArgs(args);
            options.to = this._address;
            options.data = '0x' + this.signature() + coder.encodeParams(this._inputTypes, args);
            return options;
          };

          /**
           * Should be used to get function signature
           *
           * @method signature
           * @return {String} function signature
           */
          SolidityFunction.prototype.signature = function () {
            return sha3(this._name).slice(0, 8);
          };


          SolidityFunction.prototype.unpackOutput = function (output) {
            if (!output) {
              return;
            }

            output = output.length >= 2 ? output.slice(2) : output;
            var result = coder.decodeParams(this._outputTypes, output);
            return result.length === 1 ? result[0] : result;
          };

          /**
           * Calls a contract function.
           *
           * @method call
           * @param {...Object} Contract function arguments
           * @param {function} If the last argument is a function, the contract function
           *   call will be asynchronous, and the callback will be passed the
           *   error and result.
           * @return {String} output bytes
           */
          SolidityFunction.prototype.call = function () {
            var args = Array.prototype.slice.call(arguments).filter(function (a) { return a !== undefined; });
            var callback = this.extractCallback(args);
            var defaultBlock = this.extractDefaultBlock(args);
            var payload = this.toPayload(args);


            if (!callback) {
              var output = this._eth.call(payload, defaultBlock);
              return this.unpackOutput(output);
            }

            var self = this;
            this._eth.call(payload, defaultBlock, function (error, output) {
              if (error) return callback(error, null);

              var unpacked = null;
              try {
                unpacked = self.unpackOutput(output);
              }
              catch (e) {
                error = e;
              }

              callback(error, unpacked);
            });
          };

          /**
           * Should be used to sendTransaction to solidity function
           *
           * @method sendTransaction
           */
          SolidityFunction.prototype.sendTransaction = function () {
            var args = Array.prototype.slice.call(arguments).filter(function (a) { return a !== undefined; });
            var callback = this.extractCallback(args);
            var payload = this.toPayload(args);

            if (payload.value > 0 && !this._payable) {
              throw new Error('Cannot send value to non-payable function');
            }

            if (!callback) {
              return this._eth.sendTransaction(payload);
            }

            this._eth.sendTransaction(payload, callback);
          };

          /**
           * Should be used to estimateGas of solidity function
           *
           * @method estimateGas
           */
          SolidityFunction.prototype.estimateGas = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = this.extractCallback(args);
            var payload = this.toPayload(args);

            if (!callback) {
              return this._eth.estimateGas(payload);
            }

            this._eth.estimateGas(payload, callback);
          };

          /**
           * Return the encoded data of the call
           *
           * @method getData
           * @return {String} the encoded data
           */
          SolidityFunction.prototype.getData = function () {
            var args = Array.prototype.slice.call(arguments);
            var payload = this.toPayload(args);

            return payload.data;
          };

          /**
           * Should be used to get function display name
           *
           * @method displayName
           * @return {String} display name of the function
           */
          SolidityFunction.prototype.displayName = function () {
            return utils.extractDisplayName(this._name);
          };

          /**
           * Should be used to get function type name
           *
           * @method typeName
           * @return {String} type name of the function
           */
          SolidityFunction.prototype.typeName = function () {
            return utils.extractTypeName(this._name);
          };

          /**
           * Should be called to get rpc requests from solidity function
           *
           * @method request
           * @returns {Object}
           */
          SolidityFunction.prototype.request = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = this.extractCallback(args);
            var payload = this.toPayload(args);
            var format = this.unpackOutput.bind(this);

            return {
              method: this._constant ? 'eth_call' : 'eth_sendTransaction',
              callback: callback,
              params: [payload],
              format: format
            };
          };

          /**
           * Should be called to execute function
           *
           * @method execute
           */
          SolidityFunction.prototype.execute = function () {
            var transaction = !this._constant;

            // send transaction
            if (transaction) {
              return this.sendTransaction.apply(this, Array.prototype.slice.call(arguments));
            }

            // call
            return this.call.apply(this, Array.prototype.slice.call(arguments));
          };

          /**
           * Should be called to attach function to contract
           *
           * @method attachToContract
           * @param {Contract}
           */
          SolidityFunction.prototype.attachToContract = function (contract) {
            var execute = this.execute.bind(this);
            execute.request = this.request.bind(this);
            Reflect.defineProperty(execute, 'call', this.call.bind(this));
            execute.sendTransaction = this.sendTransaction.bind(this);
            execute.estimateGas = this.estimateGas.bind(this);
            execute.getData = this.getData.bind(this);
            var displayName = this.displayName();
            if (!contract[displayName]) {
              contract[displayName] = execute;
            }
            contract[displayName][this.typeName()] = execute; // circular!!!!
          };

          module.exports = SolidityFunction;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\httpprovider.js", { "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "xhr2-cookies": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\index.js", "xmlhttprequest": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\browser-xhr.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\httpprovider.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              /*
                  This file is part of web3.js.
              
                  web3.js is free software: you can redistribute it and/or modify
                  it under the terms of the GNU Lesser General Public License as published by
                  the Free Software Foundation, either version 3 of the License, or
                  (at your option) any later version.
              
                  web3.js is distributed in the hope that it will be useful,
                  but WITHOUT ANY WARRANTY; without even the implied warranty of
                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                  GNU Lesser General Public License for more details.
              
                  You should have received a copy of the GNU Lesser General Public License
                  along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
              */
              /** @file httpprovider.js
               * @authors:
               *   Marek Kotewicz <marek@ethdev.com>
               *   Marian Oancea <marian@ethdev.com>
               *   Fabian Vogelsteller <fabian@ethdev.com>
               * @date 2015
               */

              var errors = require('./errors');

              // workaround to use httpprovider in different envs

              // browser
              if (typeof window !== 'undefined' && window.XMLHttpRequest) {
                XMLHttpRequest = window.XMLHttpRequest; // jshint ignore: line
                // node
              } else {
                XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest; // jshint ignore: line
              }

              var XHR2 = require('xhr2-cookies').XMLHttpRequest; // jshint ignore: line

              /**
               * HttpProvider should be used to send rpc calls over http
               */
              var HttpProvider = function (host, timeout, user, password, headers) {
                this.host = host || 'http://localhost:8545';
                this.timeout = timeout || 0;
                this.user = user;
                this.password = password;
                this.headers = headers;
              };

              /**
               * Should be called to prepare new XMLHttpRequest
               *
               * @method prepareRequest
               * @param {Boolean} true if request should be async
               * @return {XMLHttpRequest} object
               */
              HttpProvider.prototype.prepareRequest = function (async) {
                var request;

                if (async) {
                  request = new XHR2();
                  request.timeout = this.timeout;
                } else {
                  request = new XMLHttpRequest();
                }
                request.withCredentials = true;

                request.open('POST', this.host, async);
                if (this.user && this.password) {
                  var auth = 'Basic ' + new Buffer(this.user + ':' + this.password).toString('base64');
                  request.setRequestHeader('Authorization', auth);
                } request.setRequestHeader('Content-Type', 'application/json');
                if (this.headers) {
                  this.headers.forEach(function (header) {
                    request.setRequestHeader(header.name, header.value);
                  });
                }
                return request;
              };

              /**
               * Should be called to make sync request
               *
               * @method send
               * @param {Object} payload
               * @return {Object} result
               */
              HttpProvider.prototype.send = function (payload) {
                var request = this.prepareRequest(false);

                try {
                  request.send(JSON.stringify(payload));
                } catch (error) {
                  throw errors.InvalidConnection(this.host);
                }

                var result = request.responseText;

                try {
                  result = JSON.parse(result);
                } catch (e) {
                  throw errors.InvalidResponse(request.responseText);
                }

                return result;
              };

              /**
               * Should be used to make async request
               *
               * @method sendAsync
               * @param {Object} payload
               * @param {Function} callback triggered on end with (err, result)
               */
              HttpProvider.prototype.sendAsync = function (payload, callback) {
                var request = this.prepareRequest(true);

                request.onreadystatechange = function () {
                  if (request.readyState === 4 && request.timeout !== 1) {
                    var result = request.responseText;
                    var error = null;

                    try {
                      result = JSON.parse(result);
                    } catch (e) {
                      error = errors.InvalidResponse(request.responseText);
                    }

                    callback(error, result);
                  }
                };

                request.ontimeout = function () {
                  callback(errors.ConnectionTimeout(this.timeout));
                };

                try {
                  request.send(JSON.stringify(payload));
                } catch (error) {
                  callback(errors.InvalidConnection(this.host));
                }
              };

              /**
               * Synchronously tries to make Http request
               *
               * @method isConnected
               * @return {Boolean} returns true if request haven't failed. Otherwise false
               */
              HttpProvider.prototype.isConnected = function () {
                try {
                  this.send({
                    id: 9999999999,
                    jsonrpc: '2.0',
                    method: 'net_listening',
                    params: []
                  });
                  return true;
                } catch (e) {
                  return false;
                }
              };

              module.exports = HttpProvider;

            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js", { "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\iban.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file iban.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var BigNumber = require('bignumber.js');

          var padLeft = function (string, bytes) {
            var result = string;
            while (result.length < bytes * 2) {
              result = '0' + result;
            }
            return result;
          };

          /**
           * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
           * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
           *
           * @method iso13616Prepare
           * @param {String} iban the IBAN
           * @returns {String} the prepared IBAN
           */
          var iso13616Prepare = function (iban) {
            var A = 'A'.charCodeAt(0);
            var Z = 'Z'.charCodeAt(0);

            iban = iban.toUpperCase();
            iban = iban.substr(4) + iban.substr(0, 4);

            return iban.split('').map(function (n) {
              var code = n.charCodeAt(0);
              if (code >= A && code <= Z) {
                // A = 10, B = 11, ... Z = 35
                return code - A + 10;
              } else {
                return n;
              }
            }).join('');
          };

          /**
           * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
           *
           * @method mod9710
           * @param {String} iban
           * @returns {Number}
           */
          var mod9710 = function (iban) {
            var remainder = iban,
              block;

            while (remainder.length > 2) {
              block = remainder.slice(0, 9);
              remainder = parseInt(block, 10) % 97 + remainder.slice(block.length);
            }

            return parseInt(remainder, 10) % 97;
          };

          /**
           * This prototype should be used to create iban object from iban correct string
           *
           * @param {String} iban
           */
          var Iban = function (iban) {
            this._iban = iban;
          };

          /**
           * This method should be used to create iban object from ethereum address
           *
           * @method fromAddress
           * @param {String} address
           * @return {Iban} the IBAN object
           */
          Iban.fromAddress = function (address) {
            var asBn = new BigNumber(address, 16);
            var base36 = asBn.toString(36);
            var padded = padLeft(base36, 15);
            return Iban.fromBban(padded.toUpperCase());
          };

          /**
           * Convert the passed BBAN to an IBAN for this country specification.
           * Please note that <i>"generation of the IBAN shall be the exclusive responsibility of the bank/branch servicing the account"</i>.
           * This method implements the preferred algorithm described in http://en.wikipedia.org/wiki/International_Bank_Account_Number#Generating_IBAN_check_digits
           *
           * @method fromBban
           * @param {String} bban the BBAN to convert to IBAN
           * @returns {Iban} the IBAN object
           */
          Iban.fromBban = function (bban) {
            var countryCode = 'XE';

            var remainder = mod9710(iso13616Prepare(countryCode + '00' + bban));
            var checkDigit = ('0' + (98 - remainder)).slice(-2);

            return new Iban(countryCode + checkDigit + bban);
          };

          /**
           * Should be used to create IBAN object for given institution and identifier
           *
           * @method createIndirect
           * @param {Object} options, required options are "institution" and "identifier"
           * @return {Iban} the IBAN object
           */
          Iban.createIndirect = function (options) {
            return Iban.fromBban('ETH' + options.institution + options.identifier);
          };

          /**
           * Thos method should be used to check if given string is valid iban object
           *
           * @method isValid
           * @param {String} iban string
           * @return {Boolean} true if it is valid IBAN
           */
          Iban.isValid = function (iban) {
            var i = new Iban(iban);
            return i.isValid();
          };

          /**
           * Should be called to check if iban is correct
           *
           * @method isValid
           * @returns {Boolean} true if it is, otherwise false
           */
          Iban.prototype.isValid = function () {
            return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(this._iban) &&
              mod9710(iso13616Prepare(this._iban)) === 1;
          };

          /**
           * Should be called to check if iban number is direct
           *
           * @method isDirect
           * @returns {Boolean} true if it is, otherwise false
           */
          Iban.prototype.isDirect = function () {
            return this._iban.length === 34 || this._iban.length === 35;
          };

          /**
           * Should be called to check if iban number if indirect
           *
           * @method isIndirect
           * @returns {Boolean} true if it is, otherwise false
           */
          Iban.prototype.isIndirect = function () {
            return this._iban.length === 20;
          };

          /**
           * Should be called to get iban checksum
           * Uses the mod-97-10 checksumming protocol (ISO/IEC 7064:2003)
           *
           * @method checksum
           * @returns {String} checksum
           */
          Iban.prototype.checksum = function () {
            return this._iban.substr(2, 2);
          };

          /**
           * Should be called to get institution identifier
           * eg. XREG
           *
           * @method institution
           * @returns {String} institution identifier
           */
          Iban.prototype.institution = function () {
            return this.isIndirect() ? this._iban.substr(7, 4) : '';
          };

          /**
           * Should be called to get client identifier within institution
           * eg. GAVOFYORK
           *
           * @method client
           * @returns {String} client identifier
           */
          Iban.prototype.client = function () {
            return this.isIndirect() ? this._iban.substr(11) : '';
          };

          /**
           * Should be called to get client direct address
           *
           * @method address
           * @returns {String} client direct address
           */
          Iban.prototype.address = function () {
            if (this.isDirect()) {
              var base36 = this._iban.substr(4);
              var asBn = new BigNumber(base36, 36);
              return padLeft(asBn.toString(16), 20);
            }

            return '';
          };

          Iban.prototype.toString = function () {
            return this._iban;
          };

          module.exports = Iban;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\ipcprovider.js", { "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\ipcprovider.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file ipcprovider.js
           * @authors:
           *   Fabian Vogelsteller <fabian@ethdev.com>
           * @date 2015
           */

          "use strict";

          var utils = require('../utils/utils');
          var errors = require('./errors');


          var IpcProvider = function (path, net) {
            var _this = this;
            this.responseCallbacks = {};
            this.path = path;

            this.connection = net.connect({ path: this.path });

            this.connection.on('error', function (e) {
              console.error('IPC Connection Error', e);
              _this._timeout();
            });

            this.connection.on('end', function () {
              _this._timeout();
            });


            // LISTEN FOR CONNECTION RESPONSES
            this.connection.on('data', function (data) {
              /*jshint maxcomplexity: 6 */

              _this._parseResponse(data.toString()).forEach(function (result) {

                var id = null;

                // get the id which matches the returned id
                if (utils.isArray(result)) {
                  result.forEach(function (load) {
                    if (_this.responseCallbacks[load.id])
                      id = load.id;
                  });
                } else {
                  id = result.id;
                }

                // fire the callback
                if (_this.responseCallbacks[id]) {
                  _this.responseCallbacks[id](null, result);
                  delete _this.responseCallbacks[id];
                }
              });
            });
          };

          /**
          Will parse the response and make an array out of it.
          
          @method _parseResponse
          @param {String} data
          */
          IpcProvider.prototype._parseResponse = function (data) {
            var _this = this,
              returnValues = [];

            // DE-CHUNKER
            var dechunkedData = data
              .replace(/\}[\n\r]?\{/g, '}|--|{') // }{
              .replace(/\}\][\n\r]?\[\{/g, '}]|--|[{') // }][{
              .replace(/\}[\n\r]?\[\{/g, '}|--|[{') // }[{
              .replace(/\}\][\n\r]?\{/g, '}]|--|{') // }]{
              .split('|--|');

            dechunkedData.forEach(function (data) {

              // prepend the last chunk
              if (_this.lastChunk)
                data = _this.lastChunk + data;

              var result = null;

              try {
                result = JSON.parse(data);

              } catch (e) {

                _this.lastChunk = data;

                // start timeout to cancel all requests
                clearTimeout(_this.lastChunkTimeout);
                _this.lastChunkTimeout = setTimeout(function () {
                  _this._timeout();
                  throw errors.InvalidResponse(data);
                }, 1000 * 15);

                return;
              }

              // cancel timeout and set chunk to null
              clearTimeout(_this.lastChunkTimeout);
              _this.lastChunk = null;

              if (result)
                returnValues.push(result);
            });

            return returnValues;
          };


          /**
          Get the adds a callback to the responseCallbacks object,
          which will be called if a response matching the response Id will arrive.
          
          @method _addResponseCallback
          */
          IpcProvider.prototype._addResponseCallback = function (payload, callback) {
            var id = payload.id || payload[0].id;
            var method = payload.method || payload[0].method;

            this.responseCallbacks[id] = callback;
            this.responseCallbacks[id].method = method;
          };

          /**
          Timeout all requests when the end/error event is fired
          
          @method _timeout
          */
          IpcProvider.prototype._timeout = function () {
            for (var key in this.responseCallbacks) {
              if (this.responseCallbacks.hasOwnProperty(key)) {
                this.responseCallbacks[key](errors.InvalidConnection('on IPC'));
                delete this.responseCallbacks[key];
              }
            }
          };


          /**
          Check if the current connection is still valid.
          
          @method isConnected
          */
          IpcProvider.prototype.isConnected = function () {
            var _this = this;

            // try reconnect, when connection is gone
            if (!_this.connection.writable)
              _this.connection.connect({ path: _this.path });

            return !!this.connection.writable;
          };

          IpcProvider.prototype.send = function (payload) {

            if (this.connection.writeSync) {
              var result;

              // try reconnect, when connection is gone
              if (!this.connection.writable)
                this.connection.connect({ path: this.path });

              var data = this.connection.writeSync(JSON.stringify(payload));

              try {
                result = JSON.parse(data);
              } catch (e) {
                throw errors.InvalidResponse(data);
              }

              return result;

            } else {
              throw new Error('You tried to send "' + payload.method + '" synchronously. Synchronous requests are not supported by the IPC provider.');
            }
          };

          IpcProvider.prototype.sendAsync = function (payload, callback) {
            // try reconnect, when connection is gone
            if (!this.connection.writable)
              this.connection.connect({ path: this.path });


            this.connection.write(JSON.stringify(payload));
            this._addResponseCallback(payload, callback);
          };

          module.exports = IpcProvider;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\jsonrpc.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\jsonrpc.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file jsonrpc.js
           * @authors:
           *   Marek Kotewicz <marek@ethdev.com>
           *   Aaron Kumavis <aaron@kumavis.me>
           * @date 2015
           */

          // Initialize Jsonrpc as a simple object with utility functions.
          var Jsonrpc = {
            messageId: 0
          };

          /**
           * Should be called to valid json create payload object
           *
           * @method toPayload
           * @param {Function} method of jsonrpc call, required
           * @param {Array} params, an array of method params, optional
           * @returns {Object} valid jsonrpc payload object
           */
          Jsonrpc.toPayload = function (method, params) {
            if (!method)
              console.error('jsonrpc method should be specified!');

            // advance message ID
            Jsonrpc.messageId++;

            return {
              jsonrpc: '2.0',
              id: Jsonrpc.messageId,
              method: method,
              params: params || []
            };
          };

          /**
           * Should be called to check if jsonrpc response is valid
           *
           * @method isValidResponse
           * @param {Object}
           * @returns {Boolean} true if response is valid, otherwise false
           */
          Jsonrpc.isValidResponse = function (response) {
            return Array.isArray(response) ? response.every(validateSingleMessage) : validateSingleMessage(response);

            function validateSingleMessage(message) {
              return !!message &&
                !message.error &&
                message.jsonrpc === '2.0' &&
                typeof message.id === 'number' &&
                message.result !== undefined; // only undefined is not valid json object
            }
          };

          /**
           * Should be called to create batch payload object
           *
           * @method toBatchPayload
           * @param {Array} messages, an array of objects with method (required) and params (optional) fields
           * @returns {Array} batch payload
           */
          Jsonrpc.toBatchPayload = function (messages) {
            return messages.map(function (message) {
              return Jsonrpc.toPayload(message.method, message.params);
            });
          };

          module.exports = Jsonrpc;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js", { "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\method.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file method.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var utils = require('../utils/utils');
          var errors = require('./errors');

          var Method = function (options) {
            this.name = options.name;
            this.call = options.call;
            this.params = options.params || 0;
            this.inputFormatter = options.inputFormatter;
            this.outputFormatter = options.outputFormatter;
            this.requestManager = null;
          };

          Method.prototype.setRequestManager = function (rm) {
            this.requestManager = rm;
          };

          /**
           * Should be used to determine name of the jsonrpc method based on arguments
           *
           * @method getCall
           * @param {Array} arguments
           * @return {String} name of jsonrpc method
           */
          Method.prototype.getCall = function (args) {
            return utils.isFunction(this.call) ? this.call(args) : this.call;
          };

          /**
           * Should be used to extract callback from array of arguments. Modifies input param
           *
           * @method extractCallback
           * @param {Array} arguments
           * @return {Function|Null} callback, if exists
           */
          Method.prototype.extractCallback = function (args) {
            if (utils.isFunction(args[args.length - 1])) {
              return args.pop(); // modify the args array!
            }
          };

          /**
           * Should be called to check if the number of arguments is correct
           * 
           * @method validateArgs
           * @param {Array} arguments
           * @throws {Error} if it is not
           */
          Method.prototype.validateArgs = function (args) {
            if (args.length !== this.params) {
              throw errors.InvalidNumberOfRPCParams();
            }
          };

          /**
           * Should be called to format input args of method
           * 
           * @method formatInput
           * @param {Array}
           * @return {Array}
           */
          Method.prototype.formatInput = function (args) {
            if (!this.inputFormatter) {
              return args;
            }

            return this.inputFormatter.map(function (formatter, index) {
              return formatter ? formatter(args[index]) : args[index];
            });
          };

          /**
           * Should be called to format output(result) of method
           *
           * @method formatOutput
           * @param {Object}
           * @return {Object}
           */
          Method.prototype.formatOutput = function (result) {
            return this.outputFormatter && result ? this.outputFormatter(result) : result;
          };

          /**
           * Should create payload from given input args
           *
           * @method toPayload
           * @param {Array} args
           * @return {Object}
           */
          Method.prototype.toPayload = function (args) {
            var call = this.getCall(args);
            var callback = this.extractCallback(args);
            var params = this.formatInput(args);
            this.validateArgs(params);

            return {
              method: call,
              params: params,
              callback: callback
            };
          };

          Method.prototype.attachToObject = function (obj) {
            var func = this.buildCall();
            Reflect.defineProperty(func, 'call', { value: this.call })
            var name = this.name.split('.');
            if (name.length > 1) {
              obj[name[0]] = obj[name[0]] || {};
              obj[name[0]][name[1]] = func;
            } else {
              obj[name[0]] = func;
            }
          };

          Method.prototype.buildCall = function () {
            var method = this;
            var send = function () {
              var payload = method.toPayload(Array.prototype.slice.call(arguments));
              if (payload.callback) {
                return method.requestManager.sendAsync(payload, function (err, result) {
                  payload.callback(err, method.formatOutput(result));
                });
              }
              return method.formatOutput(method.requestManager.send(payload));
            };
            send.request = this.request.bind(this);
            return send;
          };

          /**
           * Should be called to create pure JSONRPC request which can be used in batch request
           *
           * @method request
           * @param {...} params
           * @return {Object} jsonrpc request
           */
          Method.prototype.request = function () {
            var payload = this.toPayload(Array.prototype.slice.call(arguments));
            payload.format = this.formatOutput.bind(this);
            return payload;
          };

          module.exports = Method;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\db.js", { "../method": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\db.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file db.js
           * @authors:
           *   Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var Method = require('../method');

          var DB = function (web3) {
            this._requestManager = web3._requestManager;

            var self = this;

            methods().forEach(function (method) {
              method.attachToObject(self);
              method.setRequestManager(web3._requestManager);
            });
          };

          var methods = function () {
            var putString = new Method({
              name: 'putString',
              call: 'db_putString',
              params: 3
            });

            var getString = new Method({
              name: 'getString',
              call: 'db_getString',
              params: 2
            });

            var putHex = new Method({
              name: 'putHex',
              call: 'db_putHex',
              params: 3
            });

            var getHex = new Method({
              name: 'getHex',
              call: 'db_getHex',
              params: 2
            });

            return [
              putString, getString, putHex, getHex
            ];
          };

          module.exports = DB;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\eth.js", { "../../utils/config": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js", "../../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "../contract": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\contract.js", "../filter": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js", "../formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js", "../iban": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js", "../method": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js", "../namereg": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\namereg.js", "../property": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js", "../syncing": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\syncing.js", "../transfer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\transfer.js", "./watches": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\eth.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file eth.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @author Fabian Vogelsteller <fabian@ethdev.com>
           * @date 2015
           */

          "use strict";

          var formatters = require('../formatters');
          var utils = require('../../utils/utils');
          var Method = require('../method');
          var Property = require('../property');
          var c = require('../../utils/config');
          var Contract = require('../contract');
          var watches = require('./watches');
          var Filter = require('../filter');
          var IsSyncing = require('../syncing');
          var namereg = require('../namereg');
          var Iban = require('../iban');
          var transfer = require('../transfer');

          var blockCall = function (args) {
            return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? "eth_getBlockByHash" : "eth_getBlockByNumber";
          };

          var transactionFromBlockCall = function (args) {
            return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getTransactionByBlockHashAndIndex' : 'eth_getTransactionByBlockNumberAndIndex';
          };

          var uncleCall = function (args) {
            return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleByBlockHashAndIndex' : 'eth_getUncleByBlockNumberAndIndex';
          };

          var getBlockTransactionCountCall = function (args) {
            return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getBlockTransactionCountByHash' : 'eth_getBlockTransactionCountByNumber';
          };

          var uncleCountCall = function (args) {
            return (utils.isString(args[0]) && args[0].indexOf('0x') === 0) ? 'eth_getUncleCountByBlockHash' : 'eth_getUncleCountByBlockNumber';
          };

          function Eth(web3) {
            this._requestManager = web3._requestManager;

            var self = this;

            methods().forEach(function (method) {
              method.attachToObject(self);
              method.setRequestManager(self._requestManager);
            });

            properties().forEach(function (p) {
              p.attachToObject(self);
              p.setRequestManager(self._requestManager);
            });


            this.iban = Iban;
            this.sendIBANTransaction = transfer.bind(null, this);
          }

          Object.defineProperty(Eth.prototype, 'defaultBlock', {
            get: function () {
              return c.defaultBlock;
            },
            set: function (val) {
              c.defaultBlock = val;
              return val;
            }
          });

          Object.defineProperty(Eth.prototype, 'defaultAccount', {
            get: function () {
              return c.defaultAccount;
            },
            set: function (val) {
              c.defaultAccount = val;
              return val;
            }
          });

          var methods = function () {
            var getBalance = new Method({
              name: 'getBalance',
              call: 'eth_getBalance',
              params: 2,
              inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter],
              outputFormatter: formatters.outputBigNumberFormatter
            });

            var getStorageAt = new Method({
              name: 'getStorageAt',
              call: 'eth_getStorageAt',
              params: 3,
              inputFormatter: [null, utils.toHex, formatters.inputDefaultBlockNumberFormatter]
            });

            var getCode = new Method({
              name: 'getCode',
              call: 'eth_getCode',
              params: 2,
              inputFormatter: [formatters.inputAddressFormatter, formatters.inputDefaultBlockNumberFormatter]
            });

            var getBlock = new Method({
              name: 'getBlock',
              call: blockCall,
              params: 2,
              inputFormatter: [formatters.inputBlockNumberFormatter, function (val) { return !!val; }],
              outputFormatter: formatters.outputBlockFormatter
            });

            var getUncle = new Method({
              name: 'getUncle',
              call: uncleCall,
              params: 2,
              inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
              outputFormatter: formatters.outputBlockFormatter,

            });

            var getCompilers = new Method({
              name: 'getCompilers',
              call: 'eth_getCompilers',
              params: 0
            });

            var getBlockTransactionCount = new Method({
              name: 'getBlockTransactionCount',
              call: getBlockTransactionCountCall,
              params: 1,
              inputFormatter: [formatters.inputBlockNumberFormatter],
              outputFormatter: utils.toDecimal
            });

            var getBlockUncleCount = new Method({
              name: 'getBlockUncleCount',
              call: uncleCountCall,
              params: 1,
              inputFormatter: [formatters.inputBlockNumberFormatter],
              outputFormatter: utils.toDecimal
            });

            var getTransaction = new Method({
              name: 'getTransaction',
              call: 'eth_getTransactionByHash',
              params: 1,
              outputFormatter: formatters.outputTransactionFormatter
            });

            var getTransactionFromBlock = new Method({
              name: 'getTransactionFromBlock',
              call: transactionFromBlockCall,
              params: 2,
              inputFormatter: [formatters.inputBlockNumberFormatter, utils.toHex],
              outputFormatter: formatters.outputTransactionFormatter
            });

            var getTransactionReceipt = new Method({
              name: 'getTransactionReceipt',
              call: 'eth_getTransactionReceipt',
              params: 1,
              outputFormatter: formatters.outputTransactionReceiptFormatter
            });

            var getTransactionCount = new Method({
              name: 'getTransactionCount',
              call: 'eth_getTransactionCount',
              params: 2,
              inputFormatter: [null, formatters.inputDefaultBlockNumberFormatter],
              outputFormatter: utils.toDecimal
            });

            var sendRawTransaction = new Method({
              name: 'sendRawTransaction',
              call: 'eth_sendRawTransaction',
              params: 1,
              inputFormatter: [null]
            });

            var sendTransaction = new Method({
              name: 'sendTransaction',
              call: 'eth_sendTransaction',
              params: 1,
              inputFormatter: [formatters.inputTransactionFormatter]
            });

            var signTransaction = new Method({
              name: 'signTransaction',
              call: 'eth_signTransaction',
              params: 1,
              inputFormatter: [formatters.inputTransactionFormatter]
            });

            var sign = new Method({
              name: 'sign',
              call: 'eth_sign',
              params: 2,
              inputFormatter: [formatters.inputAddressFormatter, null]
            });

            var call = new Method({
              name: 'call',
              call: 'eth_call',
              params: 2,
              inputFormatter: [formatters.inputCallFormatter, formatters.inputDefaultBlockNumberFormatter]
            });

            var estimateGas = new Method({
              name: 'estimateGas',
              call: 'eth_estimateGas',
              params: 1,
              inputFormatter: [formatters.inputCallFormatter],
              outputFormatter: utils.toDecimal
            });

            var compileSolidity = new Method({
              name: 'compile.solidity',
              call: 'eth_compileSolidity',
              params: 1
            });

            var compileLLL = new Method({
              name: 'compile.lll',
              call: 'eth_compileLLL',
              params: 1
            });

            var compileSerpent = new Method({
              name: 'compile.serpent',
              call: 'eth_compileSerpent',
              params: 1
            });

            var submitWork = new Method({
              name: 'submitWork',
              call: 'eth_submitWork',
              params: 3
            });

            var getWork = new Method({
              name: 'getWork',
              call: 'eth_getWork',
              params: 0
            });

            return [
              getBalance,
              getStorageAt,
              getCode,
              getBlock,
              getUncle,
              getCompilers,
              getBlockTransactionCount,
              getBlockUncleCount,
              getTransaction,
              getTransactionFromBlock,
              getTransactionReceipt,
              getTransactionCount,
              call,
              estimateGas,
              sendRawTransaction,
              signTransaction,
              sendTransaction,
              sign,
              compileSolidity,
              compileLLL,
              compileSerpent,
              submitWork,
              getWork
            ];
          };


          var properties = function () {
            return [
              new Property({
                name: 'coinbase',
                getter: 'eth_coinbase'
              }),
              new Property({
                name: 'mining',
                getter: 'eth_mining'
              }),
              new Property({
                name: 'hashrate',
                getter: 'eth_hashrate',
                outputFormatter: utils.toDecimal
              }),
              new Property({
                name: 'syncing',
                getter: 'eth_syncing',
                outputFormatter: formatters.outputSyncingFormatter
              }),
              new Property({
                name: 'gasPrice',
                getter: 'eth_gasPrice',
                outputFormatter: formatters.outputBigNumberFormatter
              }),
              new Property({
                name: 'accounts',
                getter: 'eth_accounts'
              }),
              new Property({
                name: 'blockNumber',
                getter: 'eth_blockNumber',
                outputFormatter: utils.toDecimal
              }),
              new Property({
                name: 'protocolVersion',
                getter: 'eth_protocolVersion'
              })
            ];
          };

          Eth.prototype.contract = function (abi) {
            var factory = new Contract(this, abi);
            return factory;
          };

          Eth.prototype.filter = function (options, callback, filterCreationErrorCallback) {
            return new Filter(options, 'eth', this._requestManager, watches.eth(), formatters.outputLogFormatter, callback, filterCreationErrorCallback);
          };

          Eth.prototype.namereg = function () {
            return this.contract(namereg.global.abi).at(namereg.global.address);
          };

          Eth.prototype.icapNamereg = function () {
            return this.contract(namereg.icap.abi).at(namereg.icap.address);
          };

          Eth.prototype.isSyncing = function (callback) {
            return new IsSyncing(this._requestManager, callback);
          };

          module.exports = Eth;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\net.js", { "../../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "../property": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\net.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file eth.js
           * @authors:
           *   Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var utils = require('../../utils/utils');
          var Property = require('../property');

          var Net = function (web3) {
            this._requestManager = web3._requestManager;

            var self = this;

            properties().forEach(function (p) {
              p.attachToObject(self);
              p.setRequestManager(web3._requestManager);
            });
          };

          /// @returns an array of objects describing web3.eth api properties
          var properties = function () {
            return [
              new Property({
                name: 'listening',
                getter: 'net_listening'
              }),
              new Property({
                name: 'peerCount',
                getter: 'net_peerCount',
                outputFormatter: utils.toDecimal
              })
            ];
          };

          module.exports = Net;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\personal.js", { "../formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js", "../method": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js", "../property": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\personal.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file eth.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @author Fabian Vogelsteller <fabian@ethdev.com>
           * @date 2015
           */

          "use strict";

          var Method = require('../method');
          var Property = require('../property');
          var formatters = require('../formatters');

          function Personal(web3) {
            this._requestManager = web3._requestManager;

            var self = this;

            methods().forEach(function (method) {
              method.attachToObject(self);
              method.setRequestManager(self._requestManager);
            });

            properties().forEach(function (p) {
              p.attachToObject(self);
              p.setRequestManager(self._requestManager);
            });
          }

          var methods = function () {
            var newAccount = new Method({
              name: 'newAccount',
              call: 'personal_newAccount',
              params: 1,
              inputFormatter: [null]
            });

            var importRawKey = new Method({
              name: 'importRawKey',
              call: 'personal_importRawKey',
              params: 2
            });

            var sign = new Method({
              name: 'sign',
              call: 'personal_sign',
              params: 3,
              inputFormatter: [null, formatters.inputAddressFormatter, null]
            });

            var ecRecover = new Method({
              name: 'ecRecover',
              call: 'personal_ecRecover',
              params: 2
            });

            var unlockAccount = new Method({
              name: 'unlockAccount',
              call: 'personal_unlockAccount',
              params: 3,
              inputFormatter: [formatters.inputAddressFormatter, null, null]
            });

            var sendTransaction = new Method({
              name: 'sendTransaction',
              call: 'personal_sendTransaction',
              params: 2,
              inputFormatter: [formatters.inputTransactionFormatter, null]
            });

            var lockAccount = new Method({
              name: 'lockAccount',
              call: 'personal_lockAccount',
              params: 1,
              inputFormatter: [formatters.inputAddressFormatter]
            });

            return [
              newAccount,
              importRawKey,
              unlockAccount,
              ecRecover,
              sign,
              sendTransaction,
              lockAccount
            ];
          };

          var properties = function () {
            return [
              new Property({
                name: 'listAccounts',
                getter: 'personal_listAccounts'
              })
            ];
          };


          module.exports = Personal;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\shh.js", { "../filter": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\filter.js", "../method": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js", "./watches": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\shh.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file shh.js
           * @authors:
           *   Fabian Vogelsteller <fabian@ethereum.org>
           *   Marek Kotewicz <marek@ethcore.io>
           * @date 2017
           */

          var Method = require('../method');
          var Filter = require('../filter');
          var watches = require('./watches');

          var Shh = function (web3) {
            this._requestManager = web3._requestManager;

            var self = this;

            methods().forEach(function (method) {
              method.attachToObject(self);
              method.setRequestManager(self._requestManager);
            });
          };

          Shh.prototype.newMessageFilter = function (options, callback, filterCreationErrorCallback) {
            return new Filter(options, 'shh', this._requestManager, watches.shh(), null, callback, filterCreationErrorCallback);
          };

          var methods = function () {

            return [
              new Method({
                name: 'version',
                call: 'shh_version',
                params: 0
              }),
              new Method({
                name: 'info',
                call: 'shh_info',
                params: 0
              }),
              new Method({
                name: 'setMaxMessageSize',
                call: 'shh_setMaxMessageSize',
                params: 1
              }),
              new Method({
                name: 'setMinPoW',
                call: 'shh_setMinPoW',
                params: 1
              }),
              new Method({
                name: 'markTrustedPeer',
                call: 'shh_markTrustedPeer',
                params: 1
              }),
              new Method({
                name: 'newKeyPair',
                call: 'shh_newKeyPair',
                params: 0
              }),
              new Method({
                name: 'addPrivateKey',
                call: 'shh_addPrivateKey',
                params: 1
              }),
              new Method({
                name: 'deleteKeyPair',
                call: 'shh_deleteKeyPair',
                params: 1
              }),
              new Method({
                name: 'hasKeyPair',
                call: 'shh_hasKeyPair',
                params: 1
              }),
              new Method({
                name: 'getPublicKey',
                call: 'shh_getPublicKey',
                params: 1
              }),
              new Method({
                name: 'getPrivateKey',
                call: 'shh_getPrivateKey',
                params: 1
              }),
              new Method({
                name: 'newSymKey',
                call: 'shh_newSymKey',
                params: 0
              }),
              new Method({
                name: 'addSymKey',
                call: 'shh_addSymKey',
                params: 1
              }),
              new Method({
                name: 'generateSymKeyFromPassword',
                call: 'shh_generateSymKeyFromPassword',
                params: 1
              }),
              new Method({
                name: 'hasSymKey',
                call: 'shh_hasSymKey',
                params: 1
              }),
              new Method({
                name: 'getSymKey',
                call: 'shh_getSymKey',
                params: 1
              }),
              new Method({
                name: 'deleteSymKey',
                call: 'shh_deleteSymKey',
                params: 1
              }),

              // subscribe and unsubscribe missing

              new Method({
                name: 'post',
                call: 'shh_post',
                params: 1,
                inputFormatter: [null]
              })
            ];
          };

          module.exports = Shh;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\swarm.js", { "../method": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js", "../property": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\swarm.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file bzz.js
           * @author Alex Beregszaszi <alex@rtfs.hu>
           * @date 2016
           *
           * Reference: https://github.com/ethereum/go-ethereum/blob/swarm/internal/web3ext/web3ext.go#L33
           */

          "use strict";

          var Method = require('../method');
          var Property = require('../property');

          function Swarm(web3) {
            this._requestManager = web3._requestManager;

            var self = this;

            methods().forEach(function (method) {
              method.attachToObject(self);
              method.setRequestManager(self._requestManager);
            });

            properties().forEach(function (p) {
              p.attachToObject(self);
              p.setRequestManager(self._requestManager);
            });
          }

          var methods = function () {
            var blockNetworkRead = new Method({
              name: 'blockNetworkRead',
              call: 'bzz_blockNetworkRead',
              params: 1,
              inputFormatter: [null]
            });

            var syncEnabled = new Method({
              name: 'syncEnabled',
              call: 'bzz_syncEnabled',
              params: 1,
              inputFormatter: [null]
            });

            var swapEnabled = new Method({
              name: 'swapEnabled',
              call: 'bzz_swapEnabled',
              params: 1,
              inputFormatter: [null]
            });

            var download = new Method({
              name: 'download',
              call: 'bzz_download',
              params: 2,
              inputFormatter: [null, null]
            });

            var upload = new Method({
              name: 'upload',
              call: 'bzz_upload',
              params: 2,
              inputFormatter: [null, null]
            });

            var retrieve = new Method({
              name: 'retrieve',
              call: 'bzz_retrieve',
              params: 1,
              inputFormatter: [null]
            });

            var store = new Method({
              name: 'store',
              call: 'bzz_store',
              params: 2,
              inputFormatter: [null, null]
            });

            var get = new Method({
              name: 'get',
              call: 'bzz_get',
              params: 1,
              inputFormatter: [null]
            });

            var put = new Method({
              name: 'put',
              call: 'bzz_put',
              params: 2,
              inputFormatter: [null, null]
            });

            var modify = new Method({
              name: 'modify',
              call: 'bzz_modify',
              params: 4,
              inputFormatter: [null, null, null, null]
            });

            return [
              blockNetworkRead,
              syncEnabled,
              swapEnabled,
              download,
              upload,
              retrieve,
              store,
              get,
              put,
              modify
            ];
          };

          var properties = function () {
            return [
              new Property({
                name: 'hive',
                getter: 'bzz_hive'
              }),
              new Property({
                name: 'info',
                getter: 'bzz_info'
              })
            ];
          };


          module.exports = Swarm;

        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\methods\\watches.js", { "../method": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\method.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\methods\watches.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file watches.js
           * @authors:
           *   Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var Method = require('../method');

          /// @returns an array of objects describing web3.eth.filter api methods
          var eth = function () {
            var newFilterCall = function (args) {
              var type = args[0];

              switch (type) {
                case 'latest':
                  args.shift();
                  this.params = 0;
                  return 'eth_newBlockFilter';
                case 'pending':
                  args.shift();
                  this.params = 0;
                  return 'eth_newPendingTransactionFilter';
                default:
                  return 'eth_newFilter';
              }
            };

            var newFilter = new Method({
              name: 'newFilter',
              call: newFilterCall,
              params: 1
            });

            var uninstallFilter = new Method({
              name: 'uninstallFilter',
              call: 'eth_uninstallFilter',
              params: 1
            });

            var getLogs = new Method({
              name: 'getLogs',
              call: 'eth_getFilterLogs',
              params: 1
            });

            var poll = new Method({
              name: 'poll',
              call: 'eth_getFilterChanges',
              params: 1
            });

            return [
              newFilter,
              uninstallFilter,
              getLogs,
              poll
            ];
          };

          /// @returns an array of objects describing web3.shh.watch api methods
          var shh = function () {

            return [
              new Method({
                name: 'newFilter',
                call: 'shh_newMessageFilter',
                params: 1
              }),
              new Method({
                name: 'uninstallFilter',
                call: 'shh_deleteMessageFilter',
                params: 1
              }),
              new Method({
                name: 'getLogs',
                call: 'shh_getFilterMessages',
                params: 1
              }),
              new Method({
                name: 'poll',
                call: 'shh_getFilterMessages',
                params: 1
              })
            ];
          };

          module.exports = {
            eth: eth,
            shh: shh
          };


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\namereg.js", { "../contracts/GlobalRegistrar.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\GlobalRegistrar.json", "../contracts/ICAPRegistrar.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\ICAPRegistrar.json" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\namereg.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file namereg.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var globalRegistrarAbi = require('../contracts/GlobalRegistrar.json');
          var icapRegistrarAbi = require('../contracts/ICAPRegistrar.json');

          var globalNameregAddress = '0xc6d9d2cd449a754c494264e1809c50e34d64562b';
          var icapNameregAddress = '0xa1a111bc074c9cfa781f0c38e63bd51c91b8af00';

          module.exports = {
            global: {
              abi: globalRegistrarAbi,
              address: globalNameregAddress
            },
            icap: {
              abi: icapRegistrarAbi,
              address: icapNameregAddress
            }
          };


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\property.js", { "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\property.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /**
           * @file property.js
           * @author Fabian Vogelsteller <fabian@frozeman.de>
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var utils = require('../utils/utils');

          var Property = function (options) {
            this.name = options.name;
            this.getter = options.getter;
            this.setter = options.setter;
            this.outputFormatter = options.outputFormatter;
            this.inputFormatter = options.inputFormatter;
            this.requestManager = null;
          };

          Property.prototype.setRequestManager = function (rm) {
            this.requestManager = rm;
          };

          /**
           * Should be called to format input args of method
           *
           * @method formatInput
           * @param {Array}
           * @return {Array}
           */
          Property.prototype.formatInput = function (arg) {
            return this.inputFormatter ? this.inputFormatter(arg) : arg;
          };

          /**
           * Should be called to format output(result) of method
           *
           * @method formatOutput
           * @param {Object}
           * @return {Object}
           */
          Property.prototype.formatOutput = function (result) {
            return this.outputFormatter && result !== null && result !== undefined ? this.outputFormatter(result) : result;
          };

          /**
           * Should be used to extract callback from array of arguments. Modifies input param
           *
           * @method extractCallback
           * @param {Array} arguments
           * @return {Function|Null} callback, if exists
           */
          Property.prototype.extractCallback = function (args) {
            if (utils.isFunction(args[args.length - 1])) {
              return args.pop(); // modify the args array!
            }
          };


          /**
           * Should attach function to method
           *
           * @method attachToObject
           * @param {Object}
           * @param {Function}
           */
          Property.prototype.attachToObject = function (obj) {
            var proto = {
              get: this.buildGet(),
              enumerable: true
            };

            var names = this.name.split('.');
            var name = names[0];
            if (names.length > 1) {
              obj[names[0]] = obj[names[0]] || {};
              obj = obj[names[0]];
              name = names[1];
            }

            Object.defineProperty(obj, name, proto);
            obj[asyncGetterName(name)] = this.buildAsyncGet();
          };

          var asyncGetterName = function (name) {
            return 'get' + name.charAt(0).toUpperCase() + name.slice(1);
          };

          Property.prototype.buildGet = function () {
            var property = this;
            return function get() {
              return property.formatOutput(property.requestManager.send({
                method: property.getter
              }));
            };
          };

          Property.prototype.buildAsyncGet = function () {
            var property = this;
            var get = function (callback) {
              property.requestManager.sendAsync({
                method: property.getter
              }, function (err, result) {
                callback(err, property.formatOutput(result));
              });
            };
            get.request = this.request.bind(this);
            return get;
          };

          /**
           * Should be called to create pure JSONRPC request which can be used in batch request
           *
           * @method request
           * @param {...} params
           * @return {Object} jsonrpc request
           */
          Property.prototype.request = function () {
            var payload = {
              method: this.getter,
              params: [],
              callback: this.extractCallback(Array.prototype.slice.call(arguments))
            };
            payload.format = this.formatOutput.bind(this);
            return payload;
          };

          module.exports = Property;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\requestmanager.js", { "../utils/config": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\config.js", "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\errors.js", "./jsonrpc": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\jsonrpc.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\requestmanager.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file requestmanager.js
           * @author Jeffrey Wilcke <jeff@ethdev.com>
           * @author Marek Kotewicz <marek@ethdev.com>
           * @author Marian Oancea <marian@ethdev.com>
           * @author Fabian Vogelsteller <fabian@ethdev.com>
           * @author Gav Wood <g@ethdev.com>
           * @date 2014
           */

          var Jsonrpc = require('./jsonrpc');
          var utils = require('../utils/utils');
          var c = require('../utils/config');
          var errors = require('./errors');

          /**
           * It's responsible for passing messages to providers
           * It's also responsible for polling the ethereum node for incoming messages
           * Default poll timeout is 1 second
           * Singleton
           */
          var RequestManager = function (provider) {
            this.provider = provider;
            this.polls = {};
            this.timeout = null;
          };

          /**
           * Should be used to synchronously send request
           *
           * @method send
           * @param {Object} data
           * @return {Object}
           */
          RequestManager.prototype.send = function (data) {
            if (!this.provider) {
              console.error(errors.InvalidProvider());
              return null;
            }

            var payload = Jsonrpc.toPayload(data.method, data.params);
            var result = this.provider.send(payload);

            if (!Jsonrpc.isValidResponse(result)) {
              throw errors.InvalidResponse(result);
            }

            return result.result;
          };

          /**
           * Should be used to asynchronously send request
           *
           * @method sendAsync
           * @param {Object} data
           * @param {Function} callback
           */
          RequestManager.prototype.sendAsync = function (data, callback) {
            if (!this.provider) {
              return callback(errors.InvalidProvider());
            }

            var payload = Jsonrpc.toPayload(data.method, data.params);
            this.provider.sendAsync(payload, function (err, result) {
              if (err) {
                return callback(err);
              }

              if (!Jsonrpc.isValidResponse(result)) {
                return callback(errors.InvalidResponse(result));
              }

              callback(null, result.result);
            });
          };

          /**
           * Should be called to asynchronously send batch request
           *
           * @method sendBatch
           * @param {Array} batch data
           * @param {Function} callback
           */
          RequestManager.prototype.sendBatch = function (data, callback) {
            if (!this.provider) {
              return callback(errors.InvalidProvider());
            }

            var payload = Jsonrpc.toBatchPayload(data);

            this.provider.sendAsync(payload, function (err, results) {
              if (err) {
                return callback(err);
              }

              if (!utils.isArray(results)) {
                return callback(errors.InvalidResponse(results));
              }

              callback(err, results);
            });
          };

          /**
           * Should be used to set provider of request manager
           *
           * @method setProvider
           * @param {Object}
           */
          RequestManager.prototype.setProvider = function (p) {
            this.provider = p;
          };

          /**
           * Should be used to start polling
           *
           * @method startPolling
           * @param {Object} data
           * @param {Number} pollId
           * @param {Function} callback
           * @param {Function} uninstall
           *
           * @todo cleanup number of params
           */
          RequestManager.prototype.startPolling = function (data, pollId, callback, uninstall) {
            this.polls[pollId] = { data: data, id: pollId, callback: callback, uninstall: uninstall };


            // start polling
            if (!this.timeout) {
              this.poll();
            }
          };

          /**
           * Should be used to stop polling for filter with given id
           *
           * @method stopPolling
           * @param {Number} pollId
           */
          RequestManager.prototype.stopPolling = function (pollId) {
            delete this.polls[pollId];

            // stop polling
            if (Object.keys(this.polls).length === 0 && this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
          };

          /**
           * Should be called to reset the polling mechanism of the request manager
           *
           * @method reset
           */
          RequestManager.prototype.reset = function (keepIsSyncing) {
            /*jshint maxcomplexity:5 */

            for (var key in this.polls) {
              // remove all polls, except sync polls,
              // they need to be removed manually by calling syncing.stopWatching()
              if (!keepIsSyncing || key.indexOf('syncPoll_') === -1) {
                this.polls[key].uninstall();
                delete this.polls[key];
              }
            }

            // stop polling
            if (Object.keys(this.polls).length === 0 && this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
          };

          /**
           * Should be called to poll for changes on filter with given id
           *
           * @method poll
           */
          RequestManager.prototype.poll = function () {
            /*jshint maxcomplexity: 6 */
            this.timeout = setTimeout(this.poll.bind(this), c.ETH_POLLING_TIMEOUT);

            if (Object.keys(this.polls).length === 0) {
              return;
            }

            if (!this.provider) {
              console.error(errors.InvalidProvider());
              return;
            }

            var pollsData = [];
            var pollsIds = [];
            for (var key in this.polls) {
              pollsData.push(this.polls[key].data);
              pollsIds.push(key);
            }

            if (pollsData.length === 0) {
              return;
            }

            var payload = Jsonrpc.toBatchPayload(pollsData);

            // map the request id to they poll id
            var pollsIdMap = {};
            payload.forEach(function (load, index) {
              pollsIdMap[load.id] = pollsIds[index];
            });


            var self = this;
            this.provider.sendAsync(payload, function (error, results) {


              // TODO: console log?
              if (error) {
                return;
              }

              if (!utils.isArray(results)) {
                throw errors.InvalidResponse(results);
              }
              results.map(function (result) {
                var id = pollsIdMap[result.id];

                // make sure the filter is still installed after arrival of the request
                if (self.polls[id]) {
                  result.callback = self.polls[id].callback;
                  return result;
                } else
                  return false;
              }).filter(function (result) {
                return !!result;
              }).filter(function (result) {
                var valid = Jsonrpc.isValidResponse(result);
                if (!valid) {
                  result.callback(errors.InvalidResponse(result));
                }
                return valid;
              }).forEach(function (result) {
                result.callback(null, result.result);
              });
            });
          };

          module.exports = RequestManager;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\settings.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\settings.js
        return function (require, module, exports) {


          var Settings = function () {
            this.defaultBlock = 'latest';
            this.defaultAccount = undefined;
          };

          module.exports = Settings;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\syncing.js", { "../utils/utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\utils\\utils.js", "./formatters": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\formatters.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\syncing.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** @file syncing.js
           * @authors:
           *   Fabian Vogelsteller <fabian@ethdev.com>
           * @date 2015
           */

          var formatters = require('./formatters');
          var utils = require('../utils/utils');

          var count = 1;

          /**
          Adds the callback and sets up the methods, to iterate over the results.
          
          @method pollSyncing
          @param {Object} self
          */
          var pollSyncing = function (self) {

            var onMessage = function (error, sync) {
              if (error) {
                return self.callbacks.forEach(function (callback) {
                  callback(error);
                });
              }

              if (utils.isObject(sync) && sync.startingBlock)
                sync = formatters.outputSyncingFormatter(sync);

              self.callbacks.forEach(function (callback) {
                if (self.lastSyncState !== sync) {

                  // call the callback with true first so the app can stop anything, before receiving the sync data
                  if (!self.lastSyncState && utils.isObject(sync))
                    callback(null, true);

                  // call on the next CPU cycle, so the actions of the sync stop can be processes first
                  setTimeout(function () {
                    callback(null, sync);
                  }, 0);

                  self.lastSyncState = sync;
                }
              });
            };

            self.requestManager.startPolling({
              method: 'eth_syncing',
              params: [],
            }, self.pollId, onMessage, self.stopWatching.bind(self));

          };

          var IsSyncing = function (requestManager, callback) {
            this.requestManager = requestManager;
            this.pollId = 'syncPoll_' + count++;
            this.callbacks = [];
            this.addCallback(callback);
            this.lastSyncState = false;
            pollSyncing(this);

            return this;
          };

          IsSyncing.prototype.addCallback = function (callback) {
            if (callback)
              this.callbacks.push(callback);
            return this;
          };

          IsSyncing.prototype.stopWatching = function () {
            this.requestManager.stopPolling(this.pollId);
            this.callbacks = [];
          };

          module.exports = IsSyncing;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\transfer.js", { "../contracts/SmartExchange.json": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\contracts\\SmartExchange.json", "./iban": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\lib\\web3\\iban.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\lib\web3\transfer.js
        return function (require, module, exports) {
          /*
              This file is part of web3.js.
          
              web3.js is free software: you can redistribute it and/or modify
              it under the terms of the GNU Lesser General Public License as published by
              the Free Software Foundation, either version 3 of the License, or
              (at your option) any later version.
          
              web3.js is distributed in the hope that it will be useful,
              but WITHOUT ANY WARRANTY; without even the implied warranty of
              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
              GNU Lesser General Public License for more details.
          
              You should have received a copy of the GNU Lesser General Public License
              along with web3.js.  If not, see <http://www.gnu.org/licenses/>.
          */
          /** 
           * @file transfer.js
           * @author Marek Kotewicz <marek@ethdev.com>
           * @date 2015
           */

          var Iban = require('./iban');
          var exchangeAbi = require('../contracts/SmartExchange.json');

          /**
           * Should be used to make Iban transfer
           *
           * @method transfer
           * @param {String} from
           * @param {String} to iban
           * @param {Value} value to be tranfered
           * @param {Function} callback, callback
           */
          var transfer = function (eth, from, to, value, callback) {
            var iban = new Iban(to);
            if (!iban.isValid()) {
              throw new Error('invalid iban address');
            }

            if (iban.isDirect()) {
              return transferToAddress(eth, from, iban.address(), value, callback);
            }

            if (!callback) {
              var address = eth.icapNamereg().addr(iban.institution());
              return deposit(eth, from, address, value, iban.client());
            }

            eth.icapNamereg().addr(iban.institution(), function (err, address) {
              return deposit(eth, from, address, value, iban.client(), callback);
            });

          };

          /**
           * Should be used to transfer funds to certain address
           *
           * @method transferToAddress
           * @param {String} from
           * @param {String} to
           * @param {Value} value to be tranfered
           * @param {Function} callback, callback
           */
          var transferToAddress = function (eth, from, to, value, callback) {
            return eth.sendTransaction({
              address: to,
              from: from,
              value: value
            }, callback);
          };

          /**
           * Should be used to deposit funds to generic Exchange contract (must implement deposit(bytes32) method!)
           *
           * @method deposit
           * @param {String} from
           * @param {String} to
           * @param {Value} value to be transfered
           * @param {String} client unique identifier
           * @param {Function} callback, callback
           */
          var deposit = function (eth, from, to, value, client, callback) {
            var abi = exchangeAbi;
            return eth.contract(abi).at(to).deposit(client, {
              from: from,
              value: value
            }, callback);
          };

          module.exports = transfer;


        };
      };
    }
  }, { package: "@metamask/controllers>web3", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\bignumber.js\\bignumber.js", { "crypto": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\crypto-browserify\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\node_modules\bignumber.js\bignumber.js
        return function (require, module, exports) {
          /*! bignumber.js v2.0.7 https://github.com/MikeMcl/bignumber.js/LICENCE */

          ; (function (global) {
            'use strict';

            /*
              bignumber.js v2.0.7
              A JavaScript library for arbitrary-precision arithmetic.
              https://github.com/MikeMcl/bignumber.js
              Copyright (c) 2015 Michael Mclaughlin <M8ch88l@gmail.com>
              MIT Expat Licence
            */


            var BigNumber, crypto, parseNumeric,
              isNumeric = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
              mathceil = Math.ceil,
              mathfloor = Math.floor,
              notBool = ' not a boolean or binary digit',
              roundingMode = 'rounding mode',
              tooManyDigits = 'number type has more than 15 significant digits',
              ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_',
              BASE = 1e14,
              LOG_BASE = 14,
              MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1
              // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1
              POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],
              SQRT_BASE = 1e7,

              /*
               * The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and
               * the arguments to toExponential, toFixed, toFormat, and toPrecision, beyond which an
               * exception is thrown (if ERRORS is true).
               */
              MAX = 1E9;                                   // 0 to MAX_INT32


            /*
             * Create and return a BigNumber constructor.
             */
            function another(configObj) {
              var div,

                // id tracks the caller function, so its name can be included in error messages.
                id = 0,
                P = BigNumber.prototype,
                ONE = new BigNumber(1),


                /********************************* EDITABLE DEFAULTS **********************************/


                /*
                 * The default values below must be integers within the inclusive ranges stated.
                 * The values can also be changed at run-time using BigNumber.config.
                 */

                // The maximum number of decimal places for operations involving division.
                DECIMAL_PLACES = 20,                     // 0 to MAX

                /*
                 * The rounding mode used when rounding to the above decimal places, and when using
                 * toExponential, toFixed, toFormat and toPrecision, and round (default value).
                 * UP         0 Away from zero.
                 * DOWN       1 Towards zero.
                 * CEIL       2 Towards +Infinity.
                 * FLOOR      3 Towards -Infinity.
                 * HALF_UP    4 Towards nearest neighbour. If equidistant, up.
                 * HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
                 * HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
                 * HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
                 * HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
                 */
                ROUNDING_MODE = 4,                       // 0 to 8

                // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]

                // The exponent value at and beneath which toString returns exponential notation.
                // Number type: -7
                TO_EXP_NEG = -7,                         // 0 to -MAX

                // The exponent value at and above which toString returns exponential notation.
                // Number type: 21
                TO_EXP_POS = 21,                         // 0 to MAX

                // RANGE : [MIN_EXP, MAX_EXP]

                // The minimum exponent value, beneath which underflow to zero occurs.
                // Number type: -324  (5e-324)
                MIN_EXP = -1e7,                          // -1 to -MAX

                // The maximum exponent value, above which overflow to Infinity occurs.
                // Number type:  308  (1.7976931348623157e+308)
                // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.
                MAX_EXP = 1e7,                           // 1 to MAX

                // Whether BigNumber Errors are ever thrown.
                ERRORS = true,                           // true or false

                // Change to intValidatorNoErrors if ERRORS is false.
                isValidInt = intValidatorWithErrors,     // intValidatorWithErrors/intValidatorNoErrors

                // Whether to use cryptographically-secure random number generation, if available.
                CRYPTO = false,                          // true or false

                /*
                 * The modulo mode used when calculating the modulus: a mod n.
                 * The quotient (q = a / n) is calculated according to the corresponding rounding mode.
                 * The remainder (r) is calculated as: r = a - n * q.
                 *
                 * UP        0 The remainder is positive if the dividend is negative, else is negative.
                 * DOWN      1 The remainder has the same sign as the dividend.
                 *             This modulo mode is commonly known as 'truncated division' and is
                 *             equivalent to (a % n) in JavaScript.
                 * FLOOR     3 The remainder has the same sign as the divisor (Python %).
                 * HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.
                 * EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).
                 *             The remainder is always positive.
                 *
                 * The truncated division, floored division, Euclidian division and IEEE 754 remainder
                 * modes are commonly used for the modulus operation.
                 * Although the other rounding modes can also be used, they may not give useful results.
                 */
                MODULO_MODE = 1,                         // 0 to 9

                // The maximum number of significant digits of the result of the toPower operation.
                // If POW_PRECISION is 0, there will be unlimited significant digits.
                POW_PRECISION = 100,                     // 0 to MAX

                // The format specification used by the BigNumber.prototype.toFormat method.
                FORMAT = {
                  decimalSeparator: '.',
                  groupSeparator: ',',
                  groupSize: 3,
                  secondaryGroupSize: 0,
                  fractionGroupSeparator: '\xA0',      // non-breaking space
                  fractionGroupSize: 0
                };


              /******************************************************************************************/


              // CONSTRUCTOR


              /*
               * The BigNumber constructor and exported function.
               * Create and return a new instance of a BigNumber object.
               *
               * n {number|string|BigNumber} A numeric value.
               * [b] {number} The base of n. Integer, 2 to 64 inclusive.
               */
              function BigNumber(n, b) {
                var c, e, i, num, len, str,
                  x = this;

                // Enable constructor usage without new.
                if (!(x instanceof BigNumber)) {

                  // 'BigNumber() constructor call without new: {n}'
                  if (ERRORS) raise(26, 'constructor call without new', n);
                  return new BigNumber(n, b);
                }

                // 'new BigNumber() base not an integer: {b}'
                // 'new BigNumber() base out of range: {b}'
                if (b == null || !isValidInt(b, 2, 64, id, 'base')) {

                  // Duplicate.
                  if (n instanceof BigNumber) {
                    x.s = n.s;
                    x.e = n.e;
                    x.c = (n = n.c) ? n.slice() : n;
                    id = 0;
                    return;
                  }

                  if ((num = typeof n == 'number') && n * 0 == 0) {
                    x.s = 1 / n < 0 ? (n = -n, -1) : 1;

                    // Fast path for integers.
                    if (n === ~~n) {
                      for (e = 0, i = n; i >= 10; i /= 10, e++);
                      x.e = e;
                      x.c = [n];
                      id = 0;
                      return;
                    }

                    str = n + '';
                  } else {
                    if (!isNumeric.test(str = n + '')) return parseNumeric(x, str, num);
                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                  }
                } else {
                  b = b | 0;
                  str = n + '';

                  // Ensure return value is rounded to DECIMAL_PLACES as with other bases.
                  // Allow exponential notation to be used with base 10 argument.
                  if (b == 10) {
                    x = new BigNumber(n instanceof BigNumber ? n : str);
                    return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
                  }

                  // Avoid potential interpretation of Infinity and NaN as base 44+ values.
                  // Any number in exponential form will fail due to the [Ee][+-].
                  if ((num = typeof n == 'number') && n * 0 != 0 ||
                    !(new RegExp('^-?' + (c = '[' + ALPHABET.slice(0, b) + ']+') +
                      '(?:\\.' + c + ')?$', b < 37 ? 'i' : '')).test(str)) {
                    return parseNumeric(x, str, num, b);
                  }

                  if (num) {
                    x.s = 1 / n < 0 ? (str = str.slice(1), -1) : 1;

                    if (ERRORS && str.replace(/^0\.0*|\./, '').length > 15) {

                      // 'new BigNumber() number type has more than 15 significant digits: {n}'
                      raise(id, tooManyDigits, n);
                    }

                    // Prevent later check for length on converted number.
                    num = false;
                  } else {
                    x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
                  }

                  str = convertBase(str, 10, b, x.s);
                }

                // Decimal point?
                if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

                // Exponential form?
                if ((i = str.search(/e/i)) > 0) {

                  // Determine exponent.
                  if (e < 0) e = i;
                  e += +str.slice(i + 1);
                  str = str.substring(0, i);
                } else if (e < 0) {

                  // Integer.
                  e = str.length;
                }

                // Determine leading zeros.
                for (i = 0; str.charCodeAt(i) === 48; i++);

                // Determine trailing zeros.
                for (len = str.length; str.charCodeAt(--len) === 48;);
                str = str.slice(i, len + 1);

                if (str) {
                  len = str.length;

                  // Disallow numbers with over 15 significant digits if number type.
                  // 'new BigNumber() number type has more than 15 significant digits: {n}'
                  if (num && ERRORS && len > 15) raise(id, tooManyDigits, x.s * n);

                  e = e - i - 1;

                  // Overflow?
                  if (e > MAX_EXP) {

                    // Infinity.
                    x.c = x.e = null;

                    // Underflow?
                  } else if (e < MIN_EXP) {

                    // Zero.
                    x.c = [x.e = 0];
                  } else {
                    x.e = e;
                    x.c = [];

                    // Transform base

                    // e is the base 10 exponent.
                    // i is where to slice str to get the first element of the coefficient array.
                    i = (e + 1) % LOG_BASE;
                    if (e < 0) i += LOG_BASE;

                    if (i < len) {
                      if (i) x.c.push(+str.slice(0, i));

                      for (len -= LOG_BASE; i < len;) {
                        x.c.push(+str.slice(i, i += LOG_BASE));
                      }

                      str = str.slice(i);
                      i = LOG_BASE - str.length;
                    } else {
                      i -= len;
                    }

                    for (; i--; str += '0');
                    x.c.push(+str);
                  }
                } else {

                  // Zero.
                  x.c = [x.e = 0];
                }

                id = 0;
              }


              // CONSTRUCTOR PROPERTIES


              BigNumber.another = another;

              BigNumber.ROUND_UP = 0;
              BigNumber.ROUND_DOWN = 1;
              BigNumber.ROUND_CEIL = 2;
              BigNumber.ROUND_FLOOR = 3;
              BigNumber.ROUND_HALF_UP = 4;
              BigNumber.ROUND_HALF_DOWN = 5;
              BigNumber.ROUND_HALF_EVEN = 6;
              BigNumber.ROUND_HALF_CEIL = 7;
              BigNumber.ROUND_HALF_FLOOR = 8;
              BigNumber.EUCLID = 9;


              /*
               * Configure infrequently-changing library-wide settings.
               *
               * Accept an object or an argument list, with one or many of the following properties or
               * parameters respectively:
               *
               *   DECIMAL_PLACES  {number}  Integer, 0 to MAX inclusive
               *   ROUNDING_MODE   {number}  Integer, 0 to 8 inclusive
               *   EXPONENTIAL_AT  {number|number[]}  Integer, -MAX to MAX inclusive or
               *                                      [integer -MAX to 0 incl., 0 to MAX incl.]
               *   RANGE           {number|number[]}  Non-zero integer, -MAX to MAX inclusive or
               *                                      [integer -MAX to -1 incl., integer 1 to MAX incl.]
               *   ERRORS          {boolean|number}   true, false, 1 or 0
               *   CRYPTO          {boolean|number}   true, false, 1 or 0
               *   MODULO_MODE     {number}           0 to 9 inclusive
               *   POW_PRECISION   {number}           0 to MAX inclusive
               *   FORMAT          {object}           See BigNumber.prototype.toFormat
               *      decimalSeparator       {string}
               *      groupSeparator         {string}
               *      groupSize              {number}
               *      secondaryGroupSize     {number}
               *      fractionGroupSeparator {string}
               *      fractionGroupSize      {number}
               *
               * (The values assigned to the above FORMAT object properties are not checked for validity.)
               *
               * E.g.
               * BigNumber.config(20, 4) is equivalent to
               * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })
               *
               * Ignore properties/parameters set to null or undefined.
               * Return an object with the properties current values.
               */
              BigNumber.config = function () {
                var v, p,
                  i = 0,
                  r = {},
                  a = arguments,
                  o = a[0],
                  has = o && typeof o == 'object'
                    ? function () { if (o.hasOwnProperty(p)) return (v = o[p]) != null; }
                    : function () { if (a.length > i) return (v = a[i++]) != null; };

                // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.
                // 'config() DECIMAL_PLACES not an integer: {v}'
                // 'config() DECIMAL_PLACES out of range: {v}'
                if (has(p = 'DECIMAL_PLACES') && isValidInt(v, 0, MAX, 2, p)) {
                  DECIMAL_PLACES = v | 0;
                }
                r[p] = DECIMAL_PLACES;

                // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.
                // 'config() ROUNDING_MODE not an integer: {v}'
                // 'config() ROUNDING_MODE out of range: {v}'
                if (has(p = 'ROUNDING_MODE') && isValidInt(v, 0, 8, 2, p)) {
                  ROUNDING_MODE = v | 0;
                }
                r[p] = ROUNDING_MODE;

                // EXPONENTIAL_AT {number|number[]}
                // Integer, -MAX to MAX inclusive or [integer -MAX to 0 inclusive, 0 to MAX inclusive].
                // 'config() EXPONENTIAL_AT not an integer: {v}'
                // 'config() EXPONENTIAL_AT out of range: {v}'
                if (has(p = 'EXPONENTIAL_AT')) {

                  if (isArray(v)) {
                    if (isValidInt(v[0], -MAX, 0, 2, p) && isValidInt(v[1], 0, MAX, 2, p)) {
                      TO_EXP_NEG = v[0] | 0;
                      TO_EXP_POS = v[1] | 0;
                    }
                  } else if (isValidInt(v, -MAX, MAX, 2, p)) {
                    TO_EXP_NEG = -(TO_EXP_POS = (v < 0 ? -v : v) | 0);
                  }
                }
                r[p] = [TO_EXP_NEG, TO_EXP_POS];

                // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or
                // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].
                // 'config() RANGE not an integer: {v}'
                // 'config() RANGE cannot be zero: {v}'
                // 'config() RANGE out of range: {v}'
                if (has(p = 'RANGE')) {

                  if (isArray(v)) {
                    if (isValidInt(v[0], -MAX, -1, 2, p) && isValidInt(v[1], 1, MAX, 2, p)) {
                      MIN_EXP = v[0] | 0;
                      MAX_EXP = v[1] | 0;
                    }
                  } else if (isValidInt(v, -MAX, MAX, 2, p)) {
                    if (v | 0) MIN_EXP = -(MAX_EXP = (v < 0 ? -v : v) | 0);
                    else if (ERRORS) raise(2, p + ' cannot be zero', v);
                  }
                }
                r[p] = [MIN_EXP, MAX_EXP];

                // ERRORS {boolean|number} true, false, 1 or 0.
                // 'config() ERRORS not a boolean or binary digit: {v}'
                if (has(p = 'ERRORS')) {

                  if (v === !!v || v === 1 || v === 0) {
                    id = 0;
                    isValidInt = (ERRORS = !!v) ? intValidatorWithErrors : intValidatorNoErrors;
                  } else if (ERRORS) {
                    raise(2, p + notBool, v);
                  }
                }
                r[p] = ERRORS;

                // CRYPTO {boolean|number} true, false, 1 or 0.
                // 'config() CRYPTO not a boolean or binary digit: {v}'
                // 'config() crypto unavailable: {crypto}'
                if (has(p = 'CRYPTO')) {

                  if (v === !!v || v === 1 || v === 0) {
                    CRYPTO = !!(v && crypto && typeof crypto == 'object');
                    if (v && !CRYPTO && ERRORS) raise(2, 'crypto unavailable', crypto);
                  } else if (ERRORS) {
                    raise(2, p + notBool, v);
                  }
                }
                r[p] = CRYPTO;

                // MODULO_MODE {number} Integer, 0 to 9 inclusive.
                // 'config() MODULO_MODE not an integer: {v}'
                // 'config() MODULO_MODE out of range: {v}'
                if (has(p = 'MODULO_MODE') && isValidInt(v, 0, 9, 2, p)) {
                  MODULO_MODE = v | 0;
                }
                r[p] = MODULO_MODE;

                // POW_PRECISION {number} Integer, 0 to MAX inclusive.
                // 'config() POW_PRECISION not an integer: {v}'
                // 'config() POW_PRECISION out of range: {v}'
                if (has(p = 'POW_PRECISION') && isValidInt(v, 0, MAX, 2, p)) {
                  POW_PRECISION = v | 0;
                }
                r[p] = POW_PRECISION;

                // FORMAT {object}
                // 'config() FORMAT not an object: {v}'
                if (has(p = 'FORMAT')) {

                  if (typeof v == 'object') {
                    FORMAT = v;
                  } else if (ERRORS) {
                    raise(2, p + ' not an object', v);
                  }
                }
                r[p] = FORMAT;

                return r;
              };


              /*
               * Return a new BigNumber whose value is the maximum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.max = function () { return maxOrMin(arguments, P.lt); };


              /*
               * Return a new BigNumber whose value is the minimum of the arguments.
               *
               * arguments {number|string|BigNumber}
               */
              BigNumber.min = function () { return maxOrMin(arguments, P.gt); };


              /*
               * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,
               * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing
               * zeros are produced).
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               *
               * 'random() decimal places not an integer: {dp}'
               * 'random() decimal places out of range: {dp}'
               * 'random() crypto unavailable: {crypto}'
               */
              BigNumber.random = (function () {
                var pow2_53 = 0x20000000000000;

                // Return a 53 bit integer n, where 0 <= n < 9007199254740992.
                // Check if Math.random() produces more than 32 bits of randomness.
                // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.
                // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.
                var random53bitInt = (Math.random() * pow2_53) & 0x1fffff
                  ? function () { return mathfloor(Math.random() * pow2_53); }
                  : function () {
                    return ((Math.random() * 0x40000000 | 0) * 0x800000) +
                      (Math.random() * 0x800000 | 0);
                  };

                return function (dp) {
                  var a, b, e, k, v,
                    i = 0,
                    c = [],
                    rand = new BigNumber(ONE);

                  dp = dp == null || !isValidInt(dp, 0, MAX, 14) ? DECIMAL_PLACES : dp | 0;
                  k = mathceil(dp / LOG_BASE);

                  if (CRYPTO) {

                    // Browsers supporting crypto.getRandomValues.
                    if (crypto && crypto.getRandomValues) {

                      a = crypto.getRandomValues(new Uint32Array(k *= 2));

                      for (; i < k;) {

                        // 53 bits:
                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)
                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000
                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)
                        //                                     11111 11111111 11111111
                        // 0x20000 is 2^21.
                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);

                        // Rejection sampling:
                        // 0 <= v < 9007199254740992
                        // Probability that v >= 9e15, is
                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251
                        if (v >= 9e15) {
                          b = crypto.getRandomValues(new Uint32Array(2));
                          a[i] = b[0];
                          a[i + 1] = b[1];
                        } else {

                          // 0 <= v <= 8999999999999999
                          // 0 <= (v % 1e14) <= 99999999999999
                          c.push(v % 1e14);
                          i += 2;
                        }
                      }
                      i = k / 2;

                      // Node.js supporting crypto.randomBytes.
                    } else if (crypto && crypto.randomBytes) {

                      // buffer
                      a = crypto.randomBytes(k *= 7);

                      for (; i < k;) {

                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40
                        // 0x100000000 is 2^32, 0x1000000 is 2^24
                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111
                        // 0 <= v < 9007199254740992
                        v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +
                          (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +
                          (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];

                        if (v >= 9e15) {
                          crypto.randomBytes(7).copy(a, i);
                        } else {

                          // 0 <= (v % 1e14) <= 99999999999999
                          c.push(v % 1e14);
                          i += 7;
                        }
                      }
                      i = k / 7;
                    } else if (ERRORS) {
                      raise(14, 'crypto unavailable', crypto);
                    }
                  }

                  // Use Math.random: CRYPTO is false or crypto is unavailable and ERRORS is false.
                  if (!i) {

                    for (; i < k;) {
                      v = random53bitInt();
                      if (v < 9e15) c[i++] = v % 1e14;
                    }
                  }

                  k = c[--i];
                  dp %= LOG_BASE;

                  // Convert trailing digits to zeros according to dp.
                  if (k && dp) {
                    v = POWS_TEN[LOG_BASE - dp];
                    c[i] = mathfloor(k / v) * v;
                  }

                  // Remove trailing elements which are zero.
                  for (; c[i] === 0; c.pop(), i--);

                  // Zero?
                  if (i < 0) {
                    c = [e = 0];
                  } else {

                    // Remove leading elements which are zero and adjust exponent accordingly.
                    for (e = -1; c[0] === 0; c.shift(), e -= LOG_BASE);

                    // Count the digits of the first element of c to determine leading zeros, and...
                    for (i = 1, v = c[0]; v >= 10; v /= 10, i++);

                    // adjust the exponent accordingly.
                    if (i < LOG_BASE) e -= LOG_BASE - i;
                  }

                  rand.e = e;
                  rand.c = c;
                  return rand;
                };
              })();


              // PRIVATE FUNCTIONS


              // Convert a numeric string of baseIn to a numeric string of baseOut.
              function convertBase(str, baseOut, baseIn, sign) {
                var d, e, k, r, x, xc, y,
                  i = str.indexOf('.'),
                  dp = DECIMAL_PLACES,
                  rm = ROUNDING_MODE;

                if (baseIn < 37) str = str.toLowerCase();

                // Non-integer.
                if (i >= 0) {
                  k = POW_PRECISION;

                  // Unlimited precision.
                  POW_PRECISION = 0;
                  str = str.replace('.', '');
                  y = new BigNumber(baseIn);
                  x = y.pow(str.length - i);
                  POW_PRECISION = k;

                  // Convert str as if an integer, then restore the fraction part by dividing the
                  // result by its base raised to a power.
                  y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e), 10, baseOut);
                  y.e = y.c.length;
                }

                // Convert the number as integer.
                xc = toBaseOut(str, baseIn, baseOut);
                e = k = xc.length;

                // Remove trailing zeros.
                for (; xc[--k] == 0; xc.pop());
                if (!xc[0]) return '0';

                if (i < 0) {
                  --e;
                } else {
                  x.c = xc;
                  x.e = e;

                  // sign is needed for correct rounding.
                  x.s = sign;
                  x = div(x, y, dp, rm, baseOut);
                  xc = x.c;
                  r = x.r;
                  e = x.e;
                }

                d = e + dp + 1;

                // The rounding digit, i.e. the digit to the right of the digit that may be rounded up.
                i = xc[d];
                k = baseOut / 2;
                r = r || d < 0 || xc[d + 1] != null;

                r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                  : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||
                    rm == (x.s < 0 ? 8 : 7));

                if (d < 1 || !xc[0]) {

                  // 1^-dp or 0.
                  str = r ? toFixedPoint('1', -dp) : '0';
                } else {
                  xc.length = d;

                  if (r) {

                    // Rounding up may mean the previous digit has to be rounded up and so on.
                    for (--baseOut; ++xc[--d] > baseOut;) {
                      xc[d] = 0;

                      if (!d) {
                        ++e;
                        xc.unshift(1);
                      }
                    }
                  }

                  // Determine trailing zeros.
                  for (k = xc.length; !xc[--k];);

                  // E.g. [4, 11, 15] becomes 4bf.
                  for (i = 0, str = ''; i <= k; str += ALPHABET.charAt(xc[i++]));
                  str = toFixedPoint(str, e);
                }

                // The caller will add the sign.
                return str;
              }


              // Perform division in the specified base. Called by div and convertBase.
              div = (function () {

                // Assume non-zero x and k.
                function multiply(x, k, base) {
                  var m, temp, xlo, xhi,
                    carry = 0,
                    i = x.length,
                    klo = k % SQRT_BASE,
                    khi = k / SQRT_BASE | 0;

                  for (x = x.slice(); i--;) {
                    xlo = x[i] % SQRT_BASE;
                    xhi = x[i] / SQRT_BASE | 0;
                    m = khi * xlo + xhi * klo;
                    temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;
                    carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                    x[i] = temp % base;
                  }

                  if (carry) x.unshift(carry);

                  return x;
                }

                function compare(a, b, aL, bL) {
                  var i, cmp;

                  if (aL != bL) {
                    cmp = aL > bL ? 1 : -1;
                  } else {

                    for (i = cmp = 0; i < aL; i++) {

                      if (a[i] != b[i]) {
                        cmp = a[i] > b[i] ? 1 : -1;
                        break;
                      }
                    }
                  }
                  return cmp;
                }

                function subtract(a, b, aL, base) {
                  var i = 0;

                  // Subtract b from a.
                  for (; aL--;) {
                    a[aL] -= i;
                    i = a[aL] < b[aL] ? 1 : 0;
                    a[aL] = i * base + a[aL] - b[aL];
                  }

                  // Remove leading zeros.
                  for (; !a[0] && a.length > 1; a.shift());
                }

                // x: dividend, y: divisor.
                return function (x, y, dp, rm, base) {
                  var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,
                    yL, yz,
                    s = x.s == y.s ? 1 : -1,
                    xc = x.c,
                    yc = y.c;

                  // Either NaN, Infinity or 0?
                  if (!xc || !xc[0] || !yc || !yc[0]) {

                    return new BigNumber(

                      // Return NaN if either NaN, or both Infinity or 0.
                      !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :

                        // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                        xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                    );
                  }

                  q = new BigNumber(s);
                  qc = q.c = [];
                  e = x.e - y.e;
                  s = dp + e + 1;

                  if (!base) {
                    base = BASE;
                    e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                    s = s / LOG_BASE | 0;
                  }

                  // Result exponent may be one less then the current value of e.
                  // The coefficients of the BigNumbers from convertBase may have trailing zeros.
                  for (i = 0; yc[i] == (xc[i] || 0); i++);
                  if (yc[i] > (xc[i] || 0)) e--;

                  if (s < 0) {
                    qc.push(1);
                    more = true;
                  } else {
                    xL = xc.length;
                    yL = yc.length;
                    i = 0;
                    s += 2;

                    // Normalise xc and yc so highest order digit of yc is >= base / 2.

                    n = mathfloor(base / (yc[0] + 1));

                    // Not necessary, but to handle odd bases where yc[0] == ( base / 2 ) - 1.
                    // if ( n > 1 || n++ == 1 && yc[0] < base / 2 ) {
                    if (n > 1) {
                      yc = multiply(yc, n, base);
                      xc = multiply(xc, n, base);
                      yL = yc.length;
                      xL = xc.length;
                    }

                    xi = yL;
                    rem = xc.slice(0, yL);
                    remL = rem.length;

                    // Add zeros to make remainder as long as divisor.
                    for (; remL < yL; rem[remL++] = 0);
                    yz = yc.slice();
                    yz.unshift(0);
                    yc0 = yc[0];
                    if (yc[1] >= base / 2) yc0++;
                    // Not necessary, but to prevent trial digit n > base, when using base 3.
                    // else if ( base == 3 && yc0 == 1 ) yc0 = 1 + 1e-15;

                    do {
                      n = 0;

                      // Compare divisor and remainder.
                      cmp = compare(yc, rem, yL, remL);

                      // If divisor < remainder.
                      if (cmp < 0) {

                        // Calculate trial digit, n.

                        rem0 = rem[0];
                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                        // n is how many times the divisor goes into the current remainder.
                        n = mathfloor(rem0 / yc0);

                        //  Algorithm:
                        //  1. product = divisor * trial digit (n)
                        //  2. if product > remainder: product -= divisor, n--
                        //  3. remainder -= product
                        //  4. if product was < remainder at 2:
                        //    5. compare new remainder and divisor
                        //    6. If remainder > divisor: remainder -= divisor, n++

                        if (n > 1) {

                          // n may be > base only when base is 3.
                          if (n >= base) n = base - 1;

                          // product = divisor * trial digit.
                          prod = multiply(yc, n, base);
                          prodL = prod.length;
                          remL = rem.length;

                          // Compare product and remainder.
                          // If product > remainder.
                          // Trial digit n too high.
                          // n is 1 too high about 5% of the time, and is not known to have
                          // ever been more than 1 too high.
                          while (compare(prod, rem, prodL, remL) == 1) {
                            n--;

                            // Subtract divisor from product.
                            subtract(prod, yL < prodL ? yz : yc, prodL, base);
                            prodL = prod.length;
                            cmp = 1;
                          }
                        } else {

                          // n is 0 or 1, cmp is -1.
                          // If n is 0, there is no need to compare yc and rem again below,
                          // so change cmp to 1 to avoid it.
                          // If n is 1, leave cmp as -1, so yc and rem are compared again.
                          if (n == 0) {

                            // divisor < remainder, so n must be at least 1.
                            cmp = n = 1;
                          }

                          // product = divisor
                          prod = yc.slice();
                          prodL = prod.length;
                        }

                        if (prodL < remL) prod.unshift(0);

                        // Subtract product from remainder.
                        subtract(rem, prod, remL, base);
                        remL = rem.length;

                        // If product was < remainder.
                        if (cmp == -1) {

                          // Compare divisor and new remainder.
                          // If divisor < new remainder, subtract divisor from remainder.
                          // Trial digit n too low.
                          // n is 1 too low about 5% of the time, and very rarely 2 too low.
                          while (compare(yc, rem, yL, remL) < 1) {
                            n++;

                            // Subtract divisor from remainder.
                            subtract(rem, yL < remL ? yz : yc, remL, base);
                            remL = rem.length;
                          }
                        }
                      } else if (cmp === 0) {
                        n++;
                        rem = [0];
                      } // else cmp === 1 and n will be 0

                      // Add the next digit, n, to the result array.
                      qc[i++] = n;

                      // Update the remainder.
                      if (rem[0]) {
                        rem[remL++] = xc[xi] || 0;
                      } else {
                        rem = [xc[xi]];
                        remL = 1;
                      }
                    } while ((xi++ < xL || rem[0] != null) && s--);

                    more = rem[0] != null;

                    // Leading zero?
                    if (!qc[0]) qc.shift();
                  }

                  if (base == BASE) {

                    // To calculate q.e, first get the number of digits of qc[0].
                    for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);
                    round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);

                    // Caller is convertBase.
                  } else {
                    q.e = e;
                    q.r = +more;
                  }

                  return q;
                };
              })();


              /*
               * Return a string representing the value of BigNumber n in fixed-point or exponential
               * notation rounded to the specified decimal places or significant digits.
               *
               * n is a BigNumber.
               * i is the index of the last digit required (i.e. the digit that may be rounded up).
               * rm is the rounding mode.
               * caller is caller id: toExponential 19, toFixed 20, toFormat 21, toPrecision 24.
               */
              function format(n, i, rm, caller) {
                var c0, e, ne, len, str;

                rm = rm != null && isValidInt(rm, 0, 8, caller, roundingMode)
                  ? rm | 0 : ROUNDING_MODE;

                if (!n.c) return n.toString();
                c0 = n.c[0];
                ne = n.e;

                if (i == null) {
                  str = coeffToString(n.c);
                  str = caller == 19 || caller == 24 && ne <= TO_EXP_NEG
                    ? toExponential(str, ne)
                    : toFixedPoint(str, ne);
                } else {
                  n = round(new BigNumber(n), i, rm);

                  // n.e may have changed if the value was rounded up.
                  e = n.e;

                  str = coeffToString(n.c);
                  len = str.length;

                  // toPrecision returns exponential notation if the number of significant digits
                  // specified is less than the number of digits necessary to represent the integer
                  // part of the value in fixed-point notation.

                  // Exponential notation.
                  if (caller == 19 || caller == 24 && (i <= e || e <= TO_EXP_NEG)) {

                    // Append zeros?
                    for (; len < i; str += '0', len++);
                    str = toExponential(str, e);

                    // Fixed-point notation.
                  } else {
                    i -= ne;
                    str = toFixedPoint(str, e);

                    // Append zeros?
                    if (e + 1 > len) {
                      if (--i > 0) for (str += '.'; i--; str += '0');
                    } else {
                      i += e - len;
                      if (i > 0) {
                        if (e + 1 == len) str += '.';
                        for (; i--; str += '0');
                      }
                    }
                  }
                }

                return n.s < 0 && c0 ? '-' + str : str;
              }


              // Handle BigNumber.max and BigNumber.min.
              function maxOrMin(args, method) {
                var m, n,
                  i = 0;

                if (isArray(args[0])) args = args[0];
                m = new BigNumber(args[0]);

                for (; ++i < args.length;) {
                  n = new BigNumber(args[i]);

                  // If any number is NaN, return NaN.
                  if (!n.s) {
                    m = n;
                    break;
                  } else if (method.call(m, n)) {
                    m = n;
                  }
                }

                return m;
              }


              /*
               * Return true if n is an integer in range, otherwise throw.
               * Use for argument validation when ERRORS is true.
               */
              function intValidatorWithErrors(n, min, max, caller, name) {
                if (n < min || n > max || n != truncate(n)) {
                  raise(caller, (name || 'decimal places') +
                    (n < min || n > max ? ' out of range' : ' not an integer'), n);
                }

                return true;
              }


              /*
               * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.
               * Called by minus, plus and times.
               */
              function normalise(n, c, e) {
                var i = 1,
                  j = c.length;

                // Remove trailing zeros.
                for (; !c[--j]; c.pop());

                // Calculate the base 10 exponent. First get the number of digits of c[0].
                for (j = c[0]; j >= 10; j /= 10, i++);

                // Overflow?
                if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {

                  // Infinity.
                  n.c = n.e = null;

                  // Underflow?
                } else if (e < MIN_EXP) {

                  // Zero.
                  n.c = [n.e = 0];
                } else {
                  n.e = e;
                  n.c = c;
                }

                return n;
              }


              // Handle values that fail the validity test in BigNumber.
              parseNumeric = (function () {
                var basePrefix = /^(-?)0([xbo])/i,
                  dotAfter = /^([^.]+)\.$/,
                  dotBefore = /^\.([^.]+)$/,
                  isInfinityOrNaN = /^-?(Infinity|NaN)$/,
                  whitespaceOrPlus = /^\s*\+|^\s+|\s+$/g;

                return function (x, str, num, b) {
                  var base,
                    s = num ? str : str.replace(whitespaceOrPlus, '');

                  // No exception on ±Infinity or NaN.
                  if (isInfinityOrNaN.test(s)) {
                    x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
                  } else {
                    if (!num) {

                      // basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i
                      s = s.replace(basePrefix, function (m, p1, p2) {
                        base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;
                        return !b || b == base ? p1 : m;
                      });

                      if (b) {
                        base = b;

                        // E.g. '1.' to '1', '.1' to '0.1'
                        s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');
                      }

                      if (str != s) return new BigNumber(s, base);
                    }

                    // 'new BigNumber() not a number: {n}'
                    // 'new BigNumber() not a base {b} number: {n}'
                    if (ERRORS) raise(id, 'not a' + (b ? ' base ' + b : '') + ' number', str);
                    x.s = null;
                  }

                  x.c = x.e = null;
                  id = 0;
                }
              })();


              // Throw a BigNumber Error.
              function raise(caller, msg, val) {
                var error = new Error([
                  'new BigNumber',     // 0
                  'cmp',               // 1
                  'config',            // 2
                  'div',               // 3
                  'divToInt',          // 4
                  'eq',                // 5
                  'gt',                // 6
                  'gte',               // 7
                  'lt',                // 8
                  'lte',               // 9
                  'minus',             // 10
                  'mod',               // 11
                  'plus',              // 12
                  'precision',         // 13
                  'random',            // 14
                  'round',             // 15
                  'shift',             // 16
                  'times',             // 17
                  'toDigits',          // 18
                  'toExponential',     // 19
                  'toFixed',           // 20
                  'toFormat',          // 21
                  'toFraction',        // 22
                  'pow',               // 23
                  'toPrecision',       // 24
                  'toString',          // 25
                  'BigNumber'          // 26
                ][caller] + '() ' + msg + ': ' + val);

                error.name = 'BigNumber Error';
                id = 0;
                throw error;
              }


              /*
               * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.
               * If r is truthy, it is known that there are more digits after the rounding digit.
               */
              function round(x, sd, rm, r) {
                var d, i, j, k, n, ni, rd,
                  xc = x.c,
                  pows10 = POWS_TEN;

                // if x is not Infinity or NaN...
                if (xc) {

                  // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.
                  // n is a base 1e14 number, the value of the element of array x.c containing rd.
                  // ni is the index of n within x.c.
                  // d is the number of digits of n.
                  // i is the index of rd within n including leading zeros.
                  // j is the actual index of rd within n (if < 0, rd is a leading zero).
                  out: {

                    // Get the number of digits of the first element of xc.
                    for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);
                    i = sd - d;

                    // If the rounding digit is in the first element of xc...
                    if (i < 0) {
                      i += LOG_BASE;
                      j = sd;
                      n = xc[ni = 0];

                      // Get the rounding digit at index j of n.
                      rd = n / pows10[d - j - 1] % 10 | 0;
                    } else {
                      ni = mathceil((i + 1) / LOG_BASE);

                      if (ni >= xc.length) {

                        if (r) {

                          // Needed by sqrt.
                          for (; xc.length <= ni; xc.push(0));
                          n = rd = 0;
                          d = 1;
                          i %= LOG_BASE;
                          j = i - LOG_BASE + 1;
                        } else {
                          break out;
                        }
                      } else {
                        n = k = xc[ni];

                        // Get the number of digits of n.
                        for (d = 1; k >= 10; k /= 10, d++);

                        // Get the index of rd within n.
                        i %= LOG_BASE;

                        // Get the index of rd within n, adjusted for leading zeros.
                        // The number of leading zeros of n is given by LOG_BASE - d.
                        j = i - LOG_BASE + d;

                        // Get the rounding digit at index j of n.
                        rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                      }
                    }

                    r = r || sd < 0 ||

                      // Are there any non-zero digits after the rounding digit?
                      // The expression  n % pows10[ d - j - 1 ]  returns all digits of n to the right
                      // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
                      xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);

                    r = rm < 4
                      ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
                      : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&

                        // Check whether the digit to the left of the rounding digit is odd.
                        ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||
                        rm == (x.s < 0 ? 8 : 7));

                    if (sd < 1 || !xc[0]) {
                      xc.length = 0;

                      if (r) {

                        // Convert sd to decimal places.
                        sd -= x.e + 1;

                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.
                        xc[0] = pows10[sd % LOG_BASE];
                        x.e = -sd || 0;
                      } else {

                        // Zero.
                        xc[0] = x.e = 0;
                      }

                      return x;
                    }

                    // Remove excess digits.
                    if (i == 0) {
                      xc.length = ni;
                      k = 1;
                      ni--;
                    } else {
                      xc.length = ni + 1;
                      k = pows10[LOG_BASE - i];

                      // E.g. 56700 becomes 56000 if 7 is the rounding digit.
                      // j > 0 means i > number of leading zeros of n.
                      xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                    }

                    // Round up?
                    if (r) {

                      for (; ;) {

                        // If the digit to be rounded up is in the first element of xc...
                        if (ni == 0) {

                          // i will be the length of xc[0] before k is added.
                          for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);
                          j = xc[0] += k;
                          for (k = 1; j >= 10; j /= 10, k++);

                          // if i != k the length has increased.
                          if (i != k) {
                            x.e++;
                            if (xc[0] == BASE) xc[0] = 1;
                          }

                          break;
                        } else {
                          xc[ni] += k;
                          if (xc[ni] != BASE) break;
                          xc[ni--] = 0;
                          k = 1;
                        }
                      }
                    }

                    // Remove trailing zeros.
                    for (i = xc.length; xc[--i] === 0; xc.pop());
                  }

                  // Overflow? Infinity.
                  if (x.e > MAX_EXP) {
                    x.c = x.e = null;

                    // Underflow? Zero.
                  } else if (x.e < MIN_EXP) {
                    x.c = [x.e = 0];
                  }
                }

                return x;
              }


              // PROTOTYPE/INSTANCE METHODS


              /*
               * Return a new BigNumber whose value is the absolute value of this BigNumber.
               */
              P.absoluteValue = P.abs = function () {
                var x = new BigNumber(this);
                if (x.s < 0) x.s = 1;
                return x;
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
               * number in the direction of Infinity.
               */
              P.ceil = function () {
                return round(new BigNumber(this), this.e + 1, 2);
              };


              /*
               * Return
               * 1 if the value of this BigNumber is greater than the value of BigNumber(y, b),
               * -1 if the value of this BigNumber is less than the value of BigNumber(y, b),
               * 0 if they have the same value,
               * or null if the value of either is NaN.
               */
              P.comparedTo = P.cmp = function (y, b) {
                id = 1;
                return compare(this, new BigNumber(y, b));
              };


              /*
               * Return the number of decimal places of the value of this BigNumber, or null if the value
               * of this BigNumber is ±Infinity or NaN.
               */
              P.decimalPlaces = P.dp = function () {
                var n, v,
                  c = this.c;

                if (!c) return null;
                n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;

                // Subtract the number of trailing zeros of the last number.
                if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);
                if (n < 0) n = 0;

                return n;
              };


              /*
               *  n / 0 = I
               *  n / N = N
               *  n / I = 0
               *  0 / n = 0
               *  0 / 0 = N
               *  0 / N = N
               *  0 / I = 0
               *  N / n = N
               *  N / 0 = N
               *  N / N = N
               *  N / I = N
               *  I / n = I
               *  I / 0 = I
               *  I / N = N
               *  I / I = N
               *
               * Return a new BigNumber whose value is the value of this BigNumber divided by the value of
               * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.
               */
              P.dividedBy = P.div = function (y, b) {
                id = 3;
                return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);
              };


              /*
               * Return a new BigNumber whose value is the integer part of dividing the value of this
               * BigNumber by the value of BigNumber(y, b).
               */
              P.dividedToIntegerBy = P.divToInt = function (y, b) {
                id = 4;
                return div(this, new BigNumber(y, b), 0, 1);
              };


              /*
               * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),
               * otherwise returns false.
               */
              P.equals = P.eq = function (y, b) {
                id = 5;
                return compare(this, new BigNumber(y, b)) === 0;
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber rounded to a whole
               * number in the direction of -Infinity.
               */
              P.floor = function () {
                return round(new BigNumber(this), this.e + 1, 3);
              };


              /*
               * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),
               * otherwise returns false.
               */
              P.greaterThan = P.gt = function (y, b) {
                id = 6;
                return compare(this, new BigNumber(y, b)) > 0;
              };


              /*
               * Return true if the value of this BigNumber is greater than or equal to the value of
               * BigNumber(y, b), otherwise returns false.
               */
              P.greaterThanOrEqualTo = P.gte = function (y, b) {
                id = 7;
                return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;

              };


              /*
               * Return true if the value of this BigNumber is a finite number, otherwise returns false.
               */
              P.isFinite = function () {
                return !!this.c;
              };


              /*
               * Return true if the value of this BigNumber is an integer, otherwise return false.
               */
              P.isInteger = P.isInt = function () {
                return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
              };


              /*
               * Return true if the value of this BigNumber is NaN, otherwise returns false.
               */
              P.isNaN = function () {
                return !this.s;
              };


              /*
               * Return true if the value of this BigNumber is negative, otherwise returns false.
               */
              P.isNegative = P.isNeg = function () {
                return this.s < 0;
              };


              /*
               * Return true if the value of this BigNumber is 0 or -0, otherwise returns false.
               */
              P.isZero = function () {
                return !!this.c && this.c[0] == 0;
              };


              /*
               * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),
               * otherwise returns false.
               */
              P.lessThan = P.lt = function (y, b) {
                id = 8;
                return compare(this, new BigNumber(y, b)) < 0;
              };


              /*
               * Return true if the value of this BigNumber is less than or equal to the value of
               * BigNumber(y, b), otherwise returns false.
               */
              P.lessThanOrEqualTo = P.lte = function (y, b) {
                id = 9;
                return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;
              };


              /*
               *  n - 0 = n
               *  n - N = N
               *  n - I = -I
               *  0 - n = -n
               *  0 - 0 = 0
               *  0 - N = N
               *  0 - I = -I
               *  N - n = N
               *  N - 0 = N
               *  N - N = N
               *  N - I = N
               *  I - n = I
               *  I - 0 = I
               *  I - N = N
               *  I - I = N
               *
               * Return a new BigNumber whose value is the value of this BigNumber minus the value of
               * BigNumber(y, b).
               */
              P.minus = P.sub = function (y, b) {
                var i, j, t, xLTy,
                  x = this,
                  a = x.s;

                id = 10;
                y = new BigNumber(y, b);
                b = y.s;

                // Either NaN?
                if (!a || !b) return new BigNumber(NaN);

                // Signs differ?
                if (a != b) {
                  y.s = -b;
                  return x.plus(y);
                }

                var xe = x.e / LOG_BASE,
                  ye = y.e / LOG_BASE,
                  xc = x.c,
                  yc = y.c;

                if (!xe || !ye) {

                  // Either Infinity?
                  if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);

                  // Either zero?
                  if (!xc[0] || !yc[0]) {

                    // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                    return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :

                      // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                      ROUNDING_MODE == 3 ? -0 : 0);
                  }
                }

                xe = bitFloor(xe);
                ye = bitFloor(ye);
                xc = xc.slice();

                // Determine which is the bigger number.
                if (a = xe - ye) {

                  if (xLTy = a < 0) {
                    a = -a;
                    t = xc;
                  } else {
                    ye = xe;
                    t = yc;
                  }

                  t.reverse();

                  // Prepend zeros to equalise exponents.
                  for (b = a; b--; t.push(0));
                  t.reverse();
                } else {

                  // Exponents equal. Check digit by digit.
                  j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;

                  for (a = b = 0; b < j; b++) {

                    if (xc[b] != yc[b]) {
                      xLTy = xc[b] < yc[b];
                      break;
                    }
                  }
                }

                // x < y? Point xc to the array of the bigger number.
                if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;

                b = (j = yc.length) - (i = xc.length);

                // Append zeros to xc if shorter.
                // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.
                if (b > 0) for (; b--; xc[i++] = 0);
                b = BASE - 1;

                // Subtract yc from xc.
                for (; j > a;) {

                  if (xc[--j] < yc[j]) {
                    for (i = j; i && !xc[--i]; xc[i] = b);
                    --xc[i];
                    xc[j] += BASE;
                  }

                  xc[j] -= yc[j];
                }

                // Remove leading zeros and adjust exponent accordingly.
                for (; xc[0] == 0; xc.shift(), --ye);

                // Zero?
                if (!xc[0]) {

                  // Following IEEE 754 (2008) 6.3,
                  // n - n = +0  but  n - n = -0  when rounding towards -Infinity.
                  y.s = ROUNDING_MODE == 3 ? -1 : 1;
                  y.c = [y.e = 0];
                  return y;
                }

                // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity
                // for finite x and y.
                return normalise(y, xc, ye);
              };


              /*
               *   n % 0 =  N
               *   n % N =  N
               *   n % I =  n
               *   0 % n =  0
               *  -0 % n = -0
               *   0 % 0 =  N
               *   0 % N =  N
               *   0 % I =  0
               *   N % n =  N
               *   N % 0 =  N
               *   N % N =  N
               *   N % I =  N
               *   I % n =  N
               *   I % 0 =  N
               *   I % N =  N
               *   I % I =  N
               *
               * Return a new BigNumber whose value is the value of this BigNumber modulo the value of
               * BigNumber(y, b). The result depends on the value of MODULO_MODE.
               */
              P.modulo = P.mod = function (y, b) {
                var q, s,
                  x = this;

                id = 11;
                y = new BigNumber(y, b);

                // Return NaN if x is Infinity or NaN, or y is NaN or zero.
                if (!x.c || !y.s || y.c && !y.c[0]) {
                  return new BigNumber(NaN);

                  // Return x if y is Infinity or x is zero.
                } else if (!y.c || x.c && !x.c[0]) {
                  return new BigNumber(x);
                }

                if (MODULO_MODE == 9) {

                  // Euclidian division: q = sign(y) * floor(x / abs(y))
                  // r = x - qy    where  0 <= r < abs(y)
                  s = y.s;
                  y.s = 1;
                  q = div(x, y, 0, 3);
                  y.s = s;
                  q.s *= s;
                } else {
                  q = div(x, y, 0, MODULO_MODE);
                }

                return x.minus(q.times(y));
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber negated,
               * i.e. multiplied by -1.
               */
              P.negated = P.neg = function () {
                var x = new BigNumber(this);
                x.s = -x.s || null;
                return x;
              };


              /*
               *  n + 0 = n
               *  n + N = N
               *  n + I = I
               *  0 + n = n
               *  0 + 0 = 0
               *  0 + N = N
               *  0 + I = I
               *  N + n = N
               *  N + 0 = N
               *  N + N = N
               *  N + I = N
               *  I + n = I
               *  I + 0 = I
               *  I + N = N
               *  I + I = I
               *
               * Return a new BigNumber whose value is the value of this BigNumber plus the value of
               * BigNumber(y, b).
               */
              P.plus = P.add = function (y, b) {
                var t,
                  x = this,
                  a = x.s;

                id = 12;
                y = new BigNumber(y, b);
                b = y.s;

                // Either NaN?
                if (!a || !b) return new BigNumber(NaN);

                // Signs differ?
                if (a != b) {
                  y.s = -b;
                  return x.minus(y);
                }

                var xe = x.e / LOG_BASE,
                  ye = y.e / LOG_BASE,
                  xc = x.c,
                  yc = y.c;

                if (!xe || !ye) {

                  // Return ±Infinity if either ±Infinity.
                  if (!xc || !yc) return new BigNumber(a / 0);

                  // Either zero?
                  // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.
                  if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);
                }

                xe = bitFloor(xe);
                ye = bitFloor(ye);
                xc = xc.slice();

                // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.
                if (a = xe - ye) {
                  if (a > 0) {
                    ye = xe;
                    t = yc;
                  } else {
                    a = -a;
                    t = xc;
                  }

                  t.reverse();
                  for (; a--; t.push(0));
                  t.reverse();
                }

                a = xc.length;
                b = yc.length;

                // Point xc to the longer array, and b to the shorter length.
                if (a - b < 0) t = yc, yc = xc, xc = t, b = a;

                // Only start adding at yc.length - 1 as the further digits of xc can be ignored.
                for (a = 0; b;) {
                  a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
                  xc[b] %= BASE;
                }

                if (a) {
                  xc.unshift(a);
                  ++ye;
                }

                // No need to check for zero, as +x + +y != 0 && -x + -y != 0
                // ye = MAX_EXP + 1 possible
                return normalise(y, xc, ye);
              };


              /*
               * Return the number of significant digits of the value of this BigNumber.
               *
               * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
               */
              P.precision = P.sd = function (z) {
                var n, v,
                  x = this,
                  c = x.c;

                // 'precision() argument not a boolean or binary digit: {z}'
                if (z != null && z !== !!z && z !== 1 && z !== 0) {
                  if (ERRORS) raise(13, 'argument' + notBool, z);
                  if (z != !!z) z = null;
                }

                if (!c) return null;
                v = c.length - 1;
                n = v * LOG_BASE + 1;

                if (v = c[v]) {

                  // Subtract the number of trailing zeros of the last element.
                  for (; v % 10 == 0; v /= 10, n--);

                  // Add the number of digits of the first element.
                  for (v = c[0]; v >= 10; v /= 10, n++);
                }

                if (z && x.e + 1 > n) n = x.e + 1;

                return n;
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
               * dp decimal places using rounding mode rm, or to 0 and ROUNDING_MODE respectively if
               * omitted.
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * 'round() decimal places out of range: {dp}'
               * 'round() decimal places not an integer: {dp}'
               * 'round() rounding mode not an integer: {rm}'
               * 'round() rounding mode out of range: {rm}'
               */
              P.round = function (dp, rm) {
                var n = new BigNumber(this);

                if (dp == null || isValidInt(dp, 0, MAX, 15)) {
                  round(n, ~~dp + this.e + 1, rm == null ||
                    !isValidInt(rm, 0, 8, 15, roundingMode) ? ROUNDING_MODE : rm | 0);
                }

                return n;
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber shifted by k places
               * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.
               *
               * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.
               *
               * If k is out of range and ERRORS is false, the result will be ±0 if k < 0, or ±Infinity
               * otherwise.
               *
               * 'shift() argument not an integer: {k}'
               * 'shift() argument out of range: {k}'
               */
              P.shift = function (k) {
                var n = this;
                return isValidInt(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 16, 'argument')

                  // k < 1e+21, or truncate(k) will produce exponential notation.
                  ? n.times('1e' + truncate(k))
                  : new BigNumber(n.c && n.c[0] && (k < -MAX_SAFE_INTEGER || k > MAX_SAFE_INTEGER)
                    ? n.s * (k < 0 ? 0 : 1 / 0)
                    : n);
              };


              /*
               *  sqrt(-n) =  N
               *  sqrt( N) =  N
               *  sqrt(-I) =  N
               *  sqrt( I) =  I
               *  sqrt( 0) =  0
               *  sqrt(-0) = -0
               *
               * Return a new BigNumber whose value is the square root of the value of this BigNumber,
               * rounded according to DECIMAL_PLACES and ROUNDING_MODE.
               */
              P.squareRoot = P.sqrt = function () {
                var m, n, r, rep, t,
                  x = this,
                  c = x.c,
                  s = x.s,
                  e = x.e,
                  dp = DECIMAL_PLACES + 4,
                  half = new BigNumber('0.5');

                // Negative/NaN/Infinity/zero?
                if (s !== 1 || !c || !c[0]) {
                  return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
                }

                // Initial estimate.
                s = Math.sqrt(+x);

                // Math.sqrt underflow/overflow?
                // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
                if (s == 0 || s == 1 / 0) {
                  n = coeffToString(c);
                  if ((n.length + e) % 2 == 0) n += '0';
                  s = Math.sqrt(n);
                  e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);

                  if (s == 1 / 0) {
                    n = '1e' + e;
                  } else {
                    n = s.toExponential();
                    n = n.slice(0, n.indexOf('e') + 1) + e;
                  }

                  r = new BigNumber(n);
                } else {
                  r = new BigNumber(s + '');
                }

                // Check for zero.
                // r could be zero if MIN_EXP is changed after the this value was created.
                // This would cause a division by zero (x/t) and hence Infinity below, which would cause
                // coeffToString to throw.
                if (r.c[0]) {
                  e = r.e;
                  s = e + dp;
                  if (s < 3) s = 0;

                  // Newton-Raphson iteration.
                  for (; ;) {
                    t = r;
                    r = half.times(t.plus(div(x, t, dp, 1)));

                    if (coeffToString(t.c).slice(0, s) === (n =
                      coeffToString(r.c)).slice(0, s)) {

                      // The exponent of r may here be one less than the final result exponent,
                      // e.g 0.0009999 (e-4) -- > 0.001 (e-3), so adjust s so the rounding digits
                      // are indexed correctly.
                      if (r.e < e) --s;
                      n = n.slice(s - 3, s + 1);

                      // The 4th rounding digit may be in error by -1 so if the 4 rounding digits
                      // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the
                      // iteration.
                      if (n == '9999' || !rep && n == '4999') {

                        // On the first iteration only, check to see if rounding up gives the
                        // exact result as the nines may infinitely repeat.
                        if (!rep) {
                          round(t, t.e + DECIMAL_PLACES + 2, 0);

                          if (t.times(t).eq(x)) {
                            r = t;
                            break;
                          }
                        }

                        dp += 4;
                        s += 4;
                        rep = 1;
                      } else {

                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact
                        // result. If not, then there are further digits and m will be truthy.
                        if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

                          // Truncate to the first rounding digit.
                          round(r, r.e + DECIMAL_PLACES + 2, 1);
                          m = !r.times(r).eq(x);
                        }

                        break;
                      }
                    }
                  }
                }

                return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
              };


              /*
               *  n * 0 = 0
               *  n * N = N
               *  n * I = I
               *  0 * n = 0
               *  0 * 0 = 0
               *  0 * N = N
               *  0 * I = N
               *  N * n = N
               *  N * 0 = N
               *  N * N = N
               *  N * I = N
               *  I * n = I
               *  I * 0 = N
               *  I * N = N
               *  I * I = I
               *
               * Return a new BigNumber whose value is the value of this BigNumber times the value of
               * BigNumber(y, b).
               */
              P.times = P.mul = function (y, b) {
                var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,
                  base, sqrtBase,
                  x = this,
                  xc = x.c,
                  yc = (id = 17, y = new BigNumber(y, b)).c;

                // Either NaN, ±Infinity or ±0?
                if (!xc || !yc || !xc[0] || !yc[0]) {

                  // Return NaN if either is NaN, or one is 0 and the other is Infinity.
                  if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                    y.c = y.e = y.s = null;
                  } else {
                    y.s *= x.s;

                    // Return ±Infinity if either is ±Infinity.
                    if (!xc || !yc) {
                      y.c = y.e = null;

                      // Return ±0 if either is ±0.
                    } else {
                      y.c = [0];
                      y.e = 0;
                    }
                  }

                  return y;
                }

                e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
                y.s *= x.s;
                xcL = xc.length;
                ycL = yc.length;

                // Ensure xc points to longer array and xcL to its length.
                if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;

                // Initialise the result array with zeros.
                for (i = xcL + ycL, zc = []; i--; zc.push(0));

                base = BASE;
                sqrtBase = SQRT_BASE;

                for (i = ycL; --i >= 0;) {
                  c = 0;
                  ylo = yc[i] % sqrtBase;
                  yhi = yc[i] / sqrtBase | 0;

                  for (k = xcL, j = i + k; j > i;) {
                    xlo = xc[--k] % sqrtBase;
                    xhi = xc[k] / sqrtBase | 0;
                    m = yhi * xlo + xhi * ylo;
                    xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;
                    c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
                    zc[j--] = xlo % base;
                  }

                  zc[j] = c;
                }

                if (c) {
                  ++e;
                } else {
                  zc.shift();
                }

                return normalise(y, zc, e);
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber rounded to a maximum of
               * sd significant digits using rounding mode rm, or ROUNDING_MODE if rm is omitted.
               *
               * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * 'toDigits() precision out of range: {sd}'
               * 'toDigits() precision not an integer: {sd}'
               * 'toDigits() rounding mode not an integer: {rm}'
               * 'toDigits() rounding mode out of range: {rm}'
               */
              P.toDigits = function (sd, rm) {
                var n = new BigNumber(this);
                sd = sd == null || !isValidInt(sd, 1, MAX, 18, 'precision') ? null : sd | 0;
                rm = rm == null || !isValidInt(rm, 0, 8, 18, roundingMode) ? ROUNDING_MODE : rm | 0;
                return sd ? round(n, sd, rm) : n;
              };


              /*
               * Return a string representing the value of this BigNumber in exponential notation and
               * rounded using ROUNDING_MODE to dp fixed decimal places.
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * 'toExponential() decimal places not an integer: {dp}'
               * 'toExponential() decimal places out of range: {dp}'
               * 'toExponential() rounding mode not an integer: {rm}'
               * 'toExponential() rounding mode out of range: {rm}'
               */
              P.toExponential = function (dp, rm) {
                return format(this,
                  dp != null && isValidInt(dp, 0, MAX, 19) ? ~~dp + 1 : null, rm, 19);
              };


              /*
               * Return a string representing the value of this BigNumber in fixed-point notation rounding
               * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.
               *
               * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',
               * but e.g. (-0.00001).toFixed(0) is '-0'.
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * 'toFixed() decimal places not an integer: {dp}'
               * 'toFixed() decimal places out of range: {dp}'
               * 'toFixed() rounding mode not an integer: {rm}'
               * 'toFixed() rounding mode out of range: {rm}'
               */
              P.toFixed = function (dp, rm) {
                return format(this, dp != null && isValidInt(dp, 0, MAX, 20)
                  ? ~~dp + this.e + 1 : null, rm, 20);
              };


              /*
               * Return a string representing the value of this BigNumber in fixed-point notation rounded
               * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties
               * of the FORMAT object (see BigNumber.config).
               *
               * FORMAT = {
               *      decimalSeparator : '.',
               *      groupSeparator : ',',
               *      groupSize : 3,
               *      secondaryGroupSize : 0,
               *      fractionGroupSeparator : '\xA0',    // non-breaking space
               *      fractionGroupSize : 0
               * };
               *
               * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * 'toFormat() decimal places not an integer: {dp}'
               * 'toFormat() decimal places out of range: {dp}'
               * 'toFormat() rounding mode not an integer: {rm}'
               * 'toFormat() rounding mode out of range: {rm}'
               */
              P.toFormat = function (dp, rm) {
                var str = format(this, dp != null && isValidInt(dp, 0, MAX, 21)
                  ? ~~dp + this.e + 1 : null, rm, 21);

                if (this.c) {
                  var i,
                    arr = str.split('.'),
                    g1 = +FORMAT.groupSize,
                    g2 = +FORMAT.secondaryGroupSize,
                    groupSeparator = FORMAT.groupSeparator,
                    intPart = arr[0],
                    fractionPart = arr[1],
                    isNeg = this.s < 0,
                    intDigits = isNeg ? intPart.slice(1) : intPart,
                    len = intDigits.length;

                  if (g2) i = g1, g1 = g2, g2 = i, len -= i;

                  if (g1 > 0 && len > 0) {
                    i = len % g1 || g1;
                    intPart = intDigits.substr(0, i);

                    for (; i < len; i += g1) {
                      intPart += groupSeparator + intDigits.substr(i, g1);
                    }

                    if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
                    if (isNeg) intPart = '-' + intPart;
                  }

                  str = fractionPart
                    ? intPart + FORMAT.decimalSeparator + ((g2 = +FORMAT.fractionGroupSize)
                      ? fractionPart.replace(new RegExp('\\d{' + g2 + '}\\B', 'g'),
                        '$&' + FORMAT.fractionGroupSeparator)
                      : fractionPart)
                    : intPart;
                }

                return str;
              };


              /*
               * Return a string array representing the value of this BigNumber as a simple fraction with
               * an integer numerator and an integer denominator. The denominator will be a positive
               * non-zero value less than or equal to the specified maximum denominator. If a maximum
               * denominator is not specified, the denominator will be the lowest value necessary to
               * represent the number exactly.
               *
               * [md] {number|string|BigNumber} Integer >= 1 and < Infinity. The maximum denominator.
               *
               * 'toFraction() max denominator not an integer: {md}'
               * 'toFraction() max denominator out of range: {md}'
               */
              P.toFraction = function (md) {
                var arr, d0, d2, e, exp, n, n0, q, s,
                  k = ERRORS,
                  x = this,
                  xc = x.c,
                  d = new BigNumber(ONE),
                  n1 = d0 = new BigNumber(ONE),
                  d1 = n0 = new BigNumber(ONE);

                if (md != null) {
                  ERRORS = false;
                  n = new BigNumber(md);
                  ERRORS = k;

                  if (!(k = n.isInt()) || n.lt(ONE)) {

                    if (ERRORS) {
                      raise(22,
                        'max denominator ' + (k ? 'out of range' : 'not an integer'), md);
                    }

                    // ERRORS is false:
                    // If md is a finite non-integer >= 1, round it to an integer and use it.
                    md = !k && n.c && round(n, n.e + 1, 1).gte(ONE) ? n : null;
                  }
                }

                if (!xc) return x.toString();
                s = coeffToString(xc);

                // Determine initial denominator.
                // d is a power of 10 and the minimum max denominator that specifies the value exactly.
                e = d.e = s.length - x.e - 1;
                d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
                md = !md || n.cmp(d) > 0 ? (e > 0 ? d : n1) : n;

                exp = MAX_EXP;
                MAX_EXP = 1 / 0;
                n = new BigNumber(s);

                // n0 = d1 = 0
                n0.c[0] = 0;

                for (; ;) {
                  q = div(n, d, 0, 1);
                  d2 = d0.plus(q.times(d1));
                  if (d2.cmp(md) == 1) break;
                  d0 = d1;
                  d1 = d2;
                  n1 = n0.plus(q.times(d2 = n1));
                  n0 = d2;
                  d = n.minus(q.times(d2 = d));
                  n = d2;
                }

                d2 = div(md.minus(d0), d1, 0, 1);
                n0 = n0.plus(d2.times(n1));
                d0 = d0.plus(d2.times(d1));
                n0.s = n1.s = x.s;
                e *= 2;

                // Determine which fraction is closer to x, n0/d0 or n1/d1
                arr = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().cmp(
                  div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1
                  ? [n1.toString(), d1.toString()]
                  : [n0.toString(), d0.toString()];

                MAX_EXP = exp;
                return arr;
              };


              /*
               * Return the value of this BigNumber converted to a number primitive.
               */
              P.toNumber = function () {
                var x = this;

                // Ensure zero has correct sign.
                return +x || (x.s ? x.s * 0 : NaN);
              };


              /*
               * Return a BigNumber whose value is the value of this BigNumber raised to the power n.
               * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.
               * If POW_PRECISION is not 0, round to POW_PRECISION using ROUNDING_MODE.
               *
               * n {number} Integer, -9007199254740992 to 9007199254740992 inclusive.
               * (Performs 54 loop iterations for n of 9007199254740992.)
               *
               * 'pow() exponent not an integer: {n}'
               * 'pow() exponent out of range: {n}'
               */
              P.toPower = P.pow = function (n) {
                var k, y,
                  i = mathfloor(n < 0 ? -n : +n),
                  x = this;

                // Pass ±Infinity to Math.pow if exponent is out of range.
                if (!isValidInt(n, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER, 23, 'exponent') &&
                  (!isFinite(n) || i > MAX_SAFE_INTEGER && (n /= 0) ||
                    parseFloat(n) != n && !(n = NaN))) {
                  return new BigNumber(Math.pow(+x, n));
                }

                // Truncating each coefficient array to a length of k after each multiplication equates
                // to truncating significant digits to POW_PRECISION + [28, 41], i.e. there will be a
                // minimum of 28 guard digits retained. (Using + 1.5 would give [9, 21] guard digits.)
                k = POW_PRECISION ? mathceil(POW_PRECISION / LOG_BASE + 2) : 0;
                y = new BigNumber(ONE);

                for (; ;) {

                  if (i % 2) {
                    y = y.times(x);
                    if (!y.c) break;
                    if (k && y.c.length > k) y.c.length = k;
                  }

                  i = mathfloor(i / 2);
                  if (!i) break;

                  x = x.times(x);
                  if (k && x.c && x.c.length > k) x.c.length = k;
                }

                if (n < 0) y = ONE.div(y);
                return k ? round(y, POW_PRECISION, ROUNDING_MODE) : y;
              };


              /*
               * Return a string representing the value of this BigNumber rounded to sd significant digits
               * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits
               * necessary to represent the integer part of the value in fixed-point notation, then use
               * exponential notation.
               *
               * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.
               * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
               *
               * 'toPrecision() precision not an integer: {sd}'
               * 'toPrecision() precision out of range: {sd}'
               * 'toPrecision() rounding mode not an integer: {rm}'
               * 'toPrecision() rounding mode out of range: {rm}'
               */
              P.toPrecision = function (sd, rm) {
                return format(this, sd != null && isValidInt(sd, 1, MAX, 24, 'precision')
                  ? sd | 0 : null, rm, 24);
              };


              /*
               * Return a string representing the value of this BigNumber in base b, or base 10 if b is
               * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and
               * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent
               * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than
               * TO_EXP_NEG, return exponential notation.
               *
               * [b] {number} Integer, 2 to 64 inclusive.
               *
               * 'toString() base not an integer: {b}'
               * 'toString() base out of range: {b}'
               */
              P.toString = function (b) {
                var str,
                  n = this,
                  s = n.s,
                  e = n.e;

                // Infinity or NaN?
                if (e === null) {

                  if (s) {
                    str = 'Infinity';
                    if (s < 0) str = '-' + str;
                  } else {
                    str = 'NaN';
                  }
                } else {
                  str = coeffToString(n.c);

                  if (b == null || !isValidInt(b, 2, 64, 25, 'base')) {
                    str = e <= TO_EXP_NEG || e >= TO_EXP_POS
                      ? toExponential(str, e)
                      : toFixedPoint(str, e);
                  } else {
                    str = convertBase(toFixedPoint(str, e), b | 0, 10, s);
                  }

                  if (s < 0 && n.c[0]) str = '-' + str;
                }

                return str;
              };


              /*
               * Return a new BigNumber whose value is the value of this BigNumber truncated to a whole
               * number.
               */
              P.truncated = P.trunc = function () {
                return round(new BigNumber(this), this.e + 1, 1);
              };



              /*
               * Return as toString, but do not accept a base argument.
               */
              P.valueOf = P.toJSON = function () {
                return this.toString();
              };


              // Aliases for BigDecimal methods.
              //P.add = P.plus;         // P.add included above
              //P.subtract = P.minus;   // P.sub included above
              //P.multiply = P.times;   // P.mul included above
              //P.divide = P.div;
              //P.remainder = P.mod;
              //P.compareTo = P.cmp;
              //P.negate = P.neg;


              if (configObj != null) BigNumber.config(configObj);

              return BigNumber;
            }


            // PRIVATE HELPER FUNCTIONS


            function bitFloor(n) {
              var i = n | 0;
              return n > 0 || n === i ? i : i - 1;
            }


            // Return a coefficient array as a string of base 10 digits.
            function coeffToString(a) {
              var s, z,
                i = 1,
                j = a.length,
                r = a[0] + '';

              for (; i < j;) {
                s = a[i++] + '';
                z = LOG_BASE - s.length;
                for (; z--; s = '0' + s);
                r += s;
              }

              // Determine trailing zeros.
              for (j = r.length; r.charCodeAt(--j) === 48;);
              return r.slice(0, j + 1 || 1);
            }


            // Compare the value of BigNumbers x and y.
            function compare(x, y) {
              var a, b,
                xc = x.c,
                yc = y.c,
                i = x.s,
                j = y.s,
                k = x.e,
                l = y.e;

              // Either NaN?
              if (!i || !j) return null;

              a = xc && !xc[0];
              b = yc && !yc[0];

              // Either zero?
              if (a || b) return a ? b ? 0 : -j : i;

              // Signs differ?
              if (i != j) return i;

              a = i < 0;
              b = k == l;

              // Either Infinity?
              if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;

              // Compare exponents.
              if (!b) return k > l ^ a ? 1 : -1;

              j = (k = xc.length) < (l = yc.length) ? k : l;

              // Compare digit by digit.
              for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;

              // Compare lengths.
              return k == l ? 0 : k > l ^ a ? 1 : -1;
            }


            /*
             * Return true if n is a valid number in range, otherwise false.
             * Use for argument validation when ERRORS is false.
             * Note: parseInt('1e+1') == 1 but parseFloat('1e+1') == 10.
             */
            function intValidatorNoErrors(n, min, max) {
              return (n = truncate(n)) >= min && n <= max;
            }


            function isArray(obj) {
              return Object.prototype.toString.call(obj) == '[object Array]';
            }


            /*
             * Convert string of baseIn to an array of numbers of baseOut.
             * Eg. convertBase('255', 10, 16) returns [15, 15].
             * Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
             */
            function toBaseOut(str, baseIn, baseOut) {
              var j,
                arr = [0],
                arrL,
                i = 0,
                len = str.length;

              for (; i < len;) {
                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);
                arr[j = 0] += ALPHABET.indexOf(str.charAt(i++));

                for (; j < arr.length; j++) {

                  if (arr[j] > baseOut - 1) {
                    if (arr[j + 1] == null) arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                  }
                }
              }

              return arr.reverse();
            }


            function toExponential(str, e) {
              return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +
                (e < 0 ? 'e' : 'e+') + e;
            }


            function toFixedPoint(str, e) {
              var len, z;

              // Negative exponent?
              if (e < 0) {

                // Prepend zeros.
                for (z = '0.'; ++e; z += '0');
                str = z + str;

                // Positive exponent
              } else {
                len = str.length;

                // Append zeros.
                if (++e > len) {
                  for (z = '0', e -= len; --e; z += '0');
                  str += z;
                } else if (e < len) {
                  str = str.slice(0, e) + '.' + str.slice(e);
                }
              }

              return str;
            }


            function truncate(n) {
              n = parseFloat(n);
              return n < 0 ? mathceil(n) : mathfloor(n);
            }


            // EXPORT


            BigNumber = another();

            // AMD.
            if (typeof define == 'function' && define.amd) {
              define(function () { return BigNumber; });

              // Node and other environments that support module.exports.
            } else if (typeof module != 'undefined' && module.exports) {
              module.exports = BigNumber;
              if (!crypto) try { crypto = require('crypto'); } catch (e) { }

              // Browser.
            } else {
              global.BigNumber = BigNumber;
            }
          })(this);

        };
      };
    }
  }, { package: "@metamask/controllers>web3>bignumber.js", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\web3\\node_modules\\utf8\\utf8.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\web3\node_modules\utf8\utf8.js
        return function (require, module, exports) {
          /*! https://mths.be/utf8js v2.1.2 by @mathias */
          ; (function (root) {

            // Detect free variables `exports`
            var freeExports = typeof exports == 'object' && exports;

            // Detect free variable `module`
            var freeModule = typeof module == 'object' && module &&
              module.exports == freeExports && module;

            // Detect free variable `global`, from Node.js or Browserified code,
            // and use it as `root`
            var freeGlobal = typeof global == 'object' && global;
            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
              root = freeGlobal;
            }

            /*--------------------------------------------------------------------------*/

            var stringFromCharCode = String.fromCharCode;

            // Taken from https://mths.be/punycode
            function ucs2decode(string) {
              var output = [];
              var counter = 0;
              var length = string.length;
              var value;
              var extra;
              while (counter < length) {
                value = string.charCodeAt(counter++);
                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                  // high surrogate, and there is a next character
                  extra = string.charCodeAt(counter++);
                  if ((extra & 0xFC00) == 0xDC00) { // low surrogate
                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                  } else {
                    // unmatched surrogate; only append this code unit, in case the next
                    // code unit is the high surrogate of a surrogate pair
                    output.push(value);
                    counter--;
                  }
                } else {
                  output.push(value);
                }
              }
              return output;
            }

            // Taken from https://mths.be/punycode
            function ucs2encode(array) {
              var length = array.length;
              var index = -1;
              var value;
              var output = '';
              while (++index < length) {
                value = array[index];
                if (value > 0xFFFF) {
                  value -= 0x10000;
                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                  value = 0xDC00 | value & 0x3FF;
                }
                output += stringFromCharCode(value);
              }
              return output;
            }

            function checkScalarValue(codePoint) {
              if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
                throw Error(
                  'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
                  ' is not a scalar value'
                );
              }
            }
            /*--------------------------------------------------------------------------*/

            function createByte(codePoint, shift) {
              return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
            }

            function encodeCodePoint(codePoint) {
              if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
                return stringFromCharCode(codePoint);
              }
              var symbol = '';
              if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
                symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
              }
              else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
                checkScalarValue(codePoint);
                symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
                symbol += createByte(codePoint, 6);
              }
              else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
                symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
                symbol += createByte(codePoint, 12);
                symbol += createByte(codePoint, 6);
              }
              symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
              return symbol;
            }

            function utf8encode(string) {
              var codePoints = ucs2decode(string);
              var length = codePoints.length;
              var index = -1;
              var codePoint;
              var byteString = '';
              while (++index < length) {
                codePoint = codePoints[index];
                byteString += encodeCodePoint(codePoint);
              }
              return byteString;
            }

            /*--------------------------------------------------------------------------*/

            function readContinuationByte() {
              if (byteIndex >= byteCount) {
                throw Error('Invalid byte index');
              }

              var continuationByte = byteArray[byteIndex] & 0xFF;
              byteIndex++;

              if ((continuationByte & 0xC0) == 0x80) {
                return continuationByte & 0x3F;
              }

              // If we end up here, it’s not a continuation byte
              throw Error('Invalid continuation byte');
            }

            function decodeSymbol() {
              var byte1;
              var byte2;
              var byte3;
              var byte4;
              var codePoint;

              if (byteIndex > byteCount) {
                throw Error('Invalid byte index');
              }

              if (byteIndex == byteCount) {
                return false;
              }

              // Read first byte
              byte1 = byteArray[byteIndex] & 0xFF;
              byteIndex++;

              // 1-byte sequence (no continuation bytes)
              if ((byte1 & 0x80) == 0) {
                return byte1;
              }

              // 2-byte sequence
              if ((byte1 & 0xE0) == 0xC0) {
                byte2 = readContinuationByte();
                codePoint = ((byte1 & 0x1F) << 6) | byte2;
                if (codePoint >= 0x80) {
                  return codePoint;
                } else {
                  throw Error('Invalid continuation byte');
                }
              }

              // 3-byte sequence (may include unpaired surrogates)
              if ((byte1 & 0xF0) == 0xE0) {
                byte2 = readContinuationByte();
                byte3 = readContinuationByte();
                codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
                if (codePoint >= 0x0800) {
                  checkScalarValue(codePoint);
                  return codePoint;
                } else {
                  throw Error('Invalid continuation byte');
                }
              }

              // 4-byte sequence
              if ((byte1 & 0xF8) == 0xF0) {
                byte2 = readContinuationByte();
                byte3 = readContinuationByte();
                byte4 = readContinuationByte();
                codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
                  (byte3 << 0x06) | byte4;
                if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
                  return codePoint;
                }
              }

              throw Error('Invalid UTF-8 detected');
            }

            var byteArray;
            var byteCount;
            var byteIndex;
            function utf8decode(byteString) {
              byteArray = ucs2decode(byteString);
              byteCount = byteArray.length;
              byteIndex = 0;
              var codePoints = [];
              var tmp;
              while ((tmp = decodeSymbol()) !== false) {
                codePoints.push(tmp);
              }
              return ucs2encode(codePoints);
            }

            /*--------------------------------------------------------------------------*/

            var utf8 = {
              'version': '2.1.2',
              'encode': utf8encode,
              'decode': utf8decode
            };

            // Some AMD build optimizers, like r.js, check for specific condition patterns
            // like the following:
            if (
              typeof define == 'function' &&
              typeof define.amd == 'object' &&
              define.amd
            ) {
              define(function () {
                return utf8;
              });
            } else if (freeExports && !freeExports.nodeType) {
              if (freeModule) { // in Node.js or RingoJS v0.8.0+
                freeModule.exports = utf8;
              } else { // in Narwhal or RingoJS v0.7.0-
                var object = {};
                var hasOwnProperty = object.hasOwnProperty;
                for (var key in utf8) {
                  hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
                }
              }
            } else { // in Rhino or a web browser
              root.utf8 = utf8;
            }

          }(this));

        };
      };
    }
  }, { package: "@metamask/controllers>web3>utf8", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\webextension-polyfill\dist\browser-polyfill.js
        return function (require, module, exports) {
          (function (global, factory) {
            if (typeof define === "function" && define.amd) {
              define("webextension-polyfill", ["module"], factory);
            } else if (typeof exports !== "undefined") {
              factory(module);
            } else {
              var mod = {
                exports: {}
              };
              factory(mod);
              global.browser = mod.exports;
            }
          })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : this, function (module) {
            /* webextension-polyfill - v0.8.0 - Tue Apr 20 2021 11:27:38 */

            /* -*- Mode: indent-tabs-mode: nil; js-indent-level: 2 -*- */

            /* vim: set sts=2 sw=2 et tw=80: */

            /* This Source Code Form is subject to the terms of the Mozilla Public
             * License, v. 2.0. If a copy of the MPL was not distributed with this
             * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
            "use strict";

            if (typeof browser === "undefined" || Object.getPrototypeOf(browser) !== Object.prototype) {
              const CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE = "The message port closed before a response was received.";
              const SEND_RESPONSE_DEPRECATION_WARNING = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"; // Wrapping the bulk of this polyfill in a one-time-use function is a minor
              // optimization for Firefox. Since Spidermonkey does not fully parse the
              // contents of a function until the first time it's called, and since it will
              // never actually need to be called, this allows the polyfill to be included
              // in Firefox nearly for free.

              const wrapAPIs = extensionAPIs => {
                // NOTE: apiMetadata is associated to the content of the api-metadata.json file
                // at build time by replacing the following "include" with the content of the
                // JSON file.
                const apiMetadata = {
                  "alarms": {
                    "clear": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "clearAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "get": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "getAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    }
                  },
                  "bookmarks": {
                    "create": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "get": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getChildren": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getRecent": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getSubTree": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getTree": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "move": {
                      "minArgs": 2,
                      "maxArgs": 2
                    },
                    "remove": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeTree": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "search": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "update": {
                      "minArgs": 2,
                      "maxArgs": 2
                    }
                  },
                  "browserAction": {
                    "disable": {
                      "minArgs": 0,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "enable": {
                      "minArgs": 0,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "getBadgeBackgroundColor": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getBadgeText": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getPopup": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getTitle": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "openPopup": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "setBadgeBackgroundColor": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "setBadgeText": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "setIcon": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "setPopup": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "setTitle": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    }
                  },
                  "browsingData": {
                    "remove": {
                      "minArgs": 2,
                      "maxArgs": 2
                    },
                    "removeCache": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeCookies": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeDownloads": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeFormData": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeHistory": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeLocalStorage": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removePasswords": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removePluginData": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "settings": {
                      "minArgs": 0,
                      "maxArgs": 0
                    }
                  },
                  "commands": {
                    "getAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    }
                  },
                  "contextMenus": {
                    "remove": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "update": {
                      "minArgs": 2,
                      "maxArgs": 2
                    }
                  },
                  "cookies": {
                    "get": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getAll": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getAllCookieStores": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "remove": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "set": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  },
                  "devtools": {
                    "inspectedWindow": {
                      "eval": {
                        "minArgs": 1,
                        "maxArgs": 2,
                        "singleCallbackArg": false
                      }
                    },
                    "panels": {
                      "create": {
                        "minArgs": 3,
                        "maxArgs": 3,
                        "singleCallbackArg": true
                      },
                      "elements": {
                        "createSidebarPane": {
                          "minArgs": 1,
                          "maxArgs": 1
                        }
                      }
                    }
                  },
                  "downloads": {
                    "cancel": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "download": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "erase": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getFileIcon": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "open": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "pause": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeFile": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "resume": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "search": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "show": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    }
                  },
                  "extension": {
                    "isAllowedFileSchemeAccess": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "isAllowedIncognitoAccess": {
                      "minArgs": 0,
                      "maxArgs": 0
                    }
                  },
                  "history": {
                    "addUrl": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "deleteAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "deleteRange": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "deleteUrl": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getVisits": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "search": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  },
                  "i18n": {
                    "detectLanguage": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getAcceptLanguages": {
                      "minArgs": 0,
                      "maxArgs": 0
                    }
                  },
                  "identity": {
                    "launchWebAuthFlow": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  },
                  "idle": {
                    "queryState": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  },
                  "management": {
                    "get": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "getSelf": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "setEnabled": {
                      "minArgs": 2,
                      "maxArgs": 2
                    },
                    "uninstallSelf": {
                      "minArgs": 0,
                      "maxArgs": 1
                    }
                  },
                  "notifications": {
                    "clear": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "create": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "getAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "getPermissionLevel": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "update": {
                      "minArgs": 2,
                      "maxArgs": 2
                    }
                  },
                  "pageAction": {
                    "getPopup": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getTitle": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "hide": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "setIcon": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "setPopup": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "setTitle": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    },
                    "show": {
                      "minArgs": 1,
                      "maxArgs": 1,
                      "fallbackToNoCallback": true
                    }
                  },
                  "permissions": {
                    "contains": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getAll": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "remove": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "request": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  },
                  "runtime": {
                    "getBackgroundPage": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "getPlatformInfo": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "openOptionsPage": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "requestUpdateCheck": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "sendMessage": {
                      "minArgs": 1,
                      "maxArgs": 3
                    },
                    "sendNativeMessage": {
                      "minArgs": 2,
                      "maxArgs": 2
                    },
                    "setUninstallURL": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  },
                  "sessions": {
                    "getDevices": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "getRecentlyClosed": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "restore": {
                      "minArgs": 0,
                      "maxArgs": 1
                    }
                  },
                  "storage": {
                    "local": {
                      "clear": {
                        "minArgs": 0,
                        "maxArgs": 0
                      },
                      "get": {
                        "minArgs": 0,
                        "maxArgs": 1
                      },
                      "getBytesInUse": {
                        "minArgs": 0,
                        "maxArgs": 1
                      },
                      "remove": {
                        "minArgs": 1,
                        "maxArgs": 1
                      },
                      "set": {
                        "minArgs": 1,
                        "maxArgs": 1
                      }
                    },
                    "managed": {
                      "get": {
                        "minArgs": 0,
                        "maxArgs": 1
                      },
                      "getBytesInUse": {
                        "minArgs": 0,
                        "maxArgs": 1
                      }
                    },
                    "sync": {
                      "clear": {
                        "minArgs": 0,
                        "maxArgs": 0
                      },
                      "get": {
                        "minArgs": 0,
                        "maxArgs": 1
                      },
                      "getBytesInUse": {
                        "minArgs": 0,
                        "maxArgs": 1
                      },
                      "remove": {
                        "minArgs": 1,
                        "maxArgs": 1
                      },
                      "set": {
                        "minArgs": 1,
                        "maxArgs": 1
                      }
                    }
                  },
                  "tabs": {
                    "captureVisibleTab": {
                      "minArgs": 0,
                      "maxArgs": 2
                    },
                    "create": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "detectLanguage": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "discard": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "duplicate": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "executeScript": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "get": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getCurrent": {
                      "minArgs": 0,
                      "maxArgs": 0
                    },
                    "getZoom": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "getZoomSettings": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "goBack": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "goForward": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "highlight": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "insertCSS": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "move": {
                      "minArgs": 2,
                      "maxArgs": 2
                    },
                    "query": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "reload": {
                      "minArgs": 0,
                      "maxArgs": 2
                    },
                    "remove": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "removeCSS": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "sendMessage": {
                      "minArgs": 2,
                      "maxArgs": 3
                    },
                    "setZoom": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "setZoomSettings": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "update": {
                      "minArgs": 1,
                      "maxArgs": 2
                    }
                  },
                  "topSites": {
                    "get": {
                      "minArgs": 0,
                      "maxArgs": 0
                    }
                  },
                  "webNavigation": {
                    "getAllFrames": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "getFrame": {
                      "minArgs": 1,
                      "maxArgs": 1
                    }
                  },
                  "webRequest": {
                    "handlerBehaviorChanged": {
                      "minArgs": 0,
                      "maxArgs": 0
                    }
                  },
                  "windows": {
                    "create": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "get": {
                      "minArgs": 1,
                      "maxArgs": 2
                    },
                    "getAll": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "getCurrent": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "getLastFocused": {
                      "minArgs": 0,
                      "maxArgs": 1
                    },
                    "remove": {
                      "minArgs": 1,
                      "maxArgs": 1
                    },
                    "update": {
                      "minArgs": 2,
                      "maxArgs": 2
                    }
                  }
                };

                if (Object.keys(apiMetadata).length === 0) {
                  throw new Error("api-metadata.json has not been included in browser-polyfill");
                }
                /**
                 * A WeakMap subclass which creates and stores a value for any key which does
                 * not exist when accessed, but behaves exactly as an ordinary WeakMap
                 * otherwise.
                 *
                 * @param {function} createItem
                 *        A function which will be called in order to create the value for any
                 *        key which does not exist, the first time it is accessed. The
                 *        function receives, as its only argument, the key being created.
                 */


                class DefaultWeakMap extends WeakMap {
                  constructor(createItem, items = undefined) {
                    super(items);
                    this.createItem = createItem;
                  }

                  get(key) {
                    if (!this.has(key)) {
                      this.set(key, this.createItem(key));
                    }

                    return super.get(key);
                  }

                }
                /**
                 * Returns true if the given object is an object with a `then` method, and can
                 * therefore be assumed to behave as a Promise.
                 *
                 * @param {*} value The value to test.
                 * @returns {boolean} True if the value is thenable.
                 */


                const isThenable = value => {
                  return value && typeof value === "object" && typeof value.then === "function";
                };
                /**
                 * Creates and returns a function which, when called, will resolve or reject
                 * the given promise based on how it is called:
                 *
                 * - If, when called, `chrome.runtime.lastError` contains a non-null object,
                 *   the promise is rejected with that value.
                 * - If the function is called with exactly one argument, the promise is
                 *   resolved to that value.
                 * - Otherwise, the promise is resolved to an array containing all of the
                 *   function's arguments.
                 *
                 * @param {object} promise
                 *        An object containing the resolution and rejection functions of a
                 *        promise.
                 * @param {function} promise.resolve
                 *        The promise's resolution function.
                 * @param {function} promise.reject
                 *        The promise's rejection function.
                 * @param {object} metadata
                 *        Metadata about the wrapped method which has created the callback.
                 * @param {boolean} metadata.singleCallbackArg
                 *        Whether or not the promise is resolved with only the first
                 *        argument of the callback, alternatively an array of all the
                 *        callback arguments is resolved. By default, if the callback
                 *        function is invoked with only a single argument, that will be
                 *        resolved to the promise, while all arguments will be resolved as
                 *        an array if multiple are given.
                 *
                 * @returns {function}
                 *        The generated callback function.
                 */


                const makeCallback = (promise, metadata) => {
                  return (...callbackArgs) => {
                    if (extensionAPIs.runtime.lastError) {
                      promise.reject(new Error(extensionAPIs.runtime.lastError.message));
                    } else if (metadata.singleCallbackArg || callbackArgs.length <= 1 && metadata.singleCallbackArg !== false) {
                      promise.resolve(callbackArgs[0]);
                    } else {
                      promise.resolve(callbackArgs);
                    }
                  };
                };

                const pluralizeArguments = numArgs => numArgs == 1 ? "argument" : "arguments";
                /**
                 * Creates a wrapper function for a method with the given name and metadata.
                 *
                 * @param {string} name
                 *        The name of the method which is being wrapped.
                 * @param {object} metadata
                 *        Metadata about the method being wrapped.
                 * @param {integer} metadata.minArgs
                 *        The minimum number of arguments which must be passed to the
                 *        function. If called with fewer than this number of arguments, the
                 *        wrapper will raise an exception.
                 * @param {integer} metadata.maxArgs
                 *        The maximum number of arguments which may be passed to the
                 *        function. If called with more than this number of arguments, the
                 *        wrapper will raise an exception.
                 * @param {boolean} metadata.singleCallbackArg
                 *        Whether or not the promise is resolved with only the first
                 *        argument of the callback, alternatively an array of all the
                 *        callback arguments is resolved. By default, if the callback
                 *        function is invoked with only a single argument, that will be
                 *        resolved to the promise, while all arguments will be resolved as
                 *        an array if multiple are given.
                 *
                 * @returns {function(object, ...*)}
                 *       The generated wrapper function.
                 */


                const wrapAsyncFunction = (name, metadata) => {
                  return function asyncFunctionWrapper(target, ...args) {
                    if (args.length < metadata.minArgs) {
                      throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
                    }

                    if (args.length > metadata.maxArgs) {
                      throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
                    }

                    return new Promise((resolve, reject) => {
                      if (metadata.fallbackToNoCallback) {
                        // This API method has currently no callback on Chrome, but it return a promise on Firefox,
                        // and so the polyfill will try to call it with a callback first, and it will fallback
                        // to not passing the callback if the first call fails.
                        try {
                          target[name](...args, makeCallback({
                            resolve,
                            reject
                          }, metadata));
                        } catch (cbError) {
                          console.warn(`${name} API method doesn't seem to support the callback parameter, ` + "falling back to call it without a callback: ", cbError);
                          target[name](...args); // Update the API method metadata, so that the next API calls will not try to
                          // use the unsupported callback anymore.

                          metadata.fallbackToNoCallback = false;
                          metadata.noCallback = true;
                          resolve();
                        }
                      } else if (metadata.noCallback) {
                        target[name](...args);
                        resolve();
                      } else {
                        target[name](...args, makeCallback({
                          resolve,
                          reject
                        }, metadata));
                      }
                    });
                  };
                };
                /**
                 * Wraps an existing method of the target object, so that calls to it are
                 * intercepted by the given wrapper function. The wrapper function receives,
                 * as its first argument, the original `target` object, followed by each of
                 * the arguments passed to the original method.
                 *
                 * @param {object} target
                 *        The original target object that the wrapped method belongs to.
                 * @param {function} method
                 *        The method being wrapped. This is used as the target of the Proxy
                 *        object which is created to wrap the method.
                 * @param {function} wrapper
                 *        The wrapper function which is called in place of a direct invocation
                 *        of the wrapped method.
                 *
                 * @returns {Proxy<function>}
                 *        A Proxy object for the given method, which invokes the given wrapper
                 *        method in its place.
                 */


                const wrapMethod = (target, method, wrapper) => {
                  return new Proxy(method, {
                    apply(targetMethod, thisObj, args) {
                      return wrapper.call(thisObj, target, ...args);
                    }

                  });
                };

                let hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
                /**
                 * Wraps an object in a Proxy which intercepts and wraps certain methods
                 * based on the given `wrappers` and `metadata` objects.
                 *
                 * @param {object} target
                 *        The target object to wrap.
                 *
                 * @param {object} [wrappers = {}]
                 *        An object tree containing wrapper functions for special cases. Any
                 *        function present in this object tree is called in place of the
                 *        method in the same location in the `target` object tree. These
                 *        wrapper methods are invoked as described in {@see wrapMethod}.
                 *
                 * @param {object} [metadata = {}]
                 *        An object tree containing metadata used to automatically generate
                 *        Promise-based wrapper functions for asynchronous. Any function in
                 *        the `target` object tree which has a corresponding metadata object
                 *        in the same location in the `metadata` tree is replaced with an
                 *        automatically-generated wrapper function, as described in
                 *        {@see wrapAsyncFunction}
                 *
                 * @returns {Proxy<object>}
                 */

                const wrapObject = (target, wrappers = {}, metadata = {}) => {
                  console.log('wrapping object ', target)
                  let cache = Object.create(null);
                  let handlers = {
                    has(proxyTarget, prop) {
                      return prop in target || prop in cache;
                    },

                    get(proxyTarget, prop, receiver) {
                      if (prop in cache) {
                        return cache[prop];
                      }

                      if (!(prop in target)) {
                        return undefined;
                      }

                      let value = target[prop];

                      if (typeof value === "function") {
                        // This is a method on the underlying object. Check if we need to do
                        // any wrapping.
                        if (typeof wrappers[prop] === "function") {
                          // We have a special-case wrapper for this method.
                          value = wrapMethod(target, target[prop], wrappers[prop]);
                        } else if (hasOwnProperty(metadata, prop)) {
                          // This is an async method that we have metadata for. Create a
                          // Promise wrapper for it.
                          let wrapper = wrapAsyncFunction(prop, metadata[prop]);
                          value = wrapMethod(target, target[prop], wrapper);
                        } else {
                          // This is a method that we don't know or care about. Return the
                          // original method, bound to the underlying object.
                          value = value.bind(target);
                        }
                      } else if (typeof value === "object" && value !== null && (hasOwnProperty(wrappers, prop) || hasOwnProperty(metadata, prop))) {
                        // This is an object that we need to do some wrapping for the children
                        // of. Create a sub-object wrapper for it with the appropriate child
                        // metadata.
                        value = wrapObject(value, wrappers[prop], metadata[prop]);
                      } else if (hasOwnProperty(metadata, "*")) {
                        // Wrap all properties in * namespace.
                        value = wrapObject(value, wrappers[prop], metadata["*"]);
                      } else {
                        // We don't need to do any wrapping for this property,
                        // so just forward all access to the underlying object.
                        Object.defineProperty(cache, prop, {
                          configurable: true,
                          enumerable: true,

                          get() {
                            return target[prop];
                          },

                          set(value) {
                            target[prop] = value;
                          }

                        });
                        return value;
                      }

                      cache[prop] = value;
                      return value;
                    },

                    set(proxyTarget, prop, value, receiver) {
                      if (prop in cache) {
                        cache[prop] = value;
                      } else {
                        target[prop] = value;
                      }

                      return true;
                    },

                    defineProperty(proxyTarget, prop, desc) {
                      return Reflect.defineProperty(cache, prop, desc);
                    },

                    deleteProperty(proxyTarget, prop) {
                      return Reflect.deleteProperty(cache, prop);
                    }

                  }; // Per contract of the Proxy API, the "get" proxy handler must return the
                  // original value of the target if that value is declared read-only and
                  // non-configurable. For this reason, we create an object with the
                  // prototype set to `target` instead of using `target` directly.
                  // Otherwise we cannot return a custom object for APIs that
                  // are declared read-only and non-configurable, such as `chrome.devtools`.
                  //
                  // The proxy handlers themselves will still use the original `target`
                  // instead of the `proxyTarget`, so that the methods and properties are
                  // dereferenced via the original targets.

                  let proxyTarget = Object.create(target);
                  return new Proxy(proxyTarget, handlers);
                };
                /**
                 * Creates a set of wrapper functions for an event object, which handles
                 * wrapping of listener functions that those messages are passed.
                 *
                 * A single wrapper is created for each listener function, and stored in a
                 * map. Subsequent calls to `addListener`, `hasListener`, or `removeListener`
                 * retrieve the original wrapper, so that  attempts to remove a
                 * previously-added listener work as expected.
                 *
                 * @param {DefaultWeakMap<function, function>} wrapperMap
                 *        A DefaultWeakMap object which will create the appropriate wrapper
                 *        for a given listener function when one does not exist, and retrieve
                 *        an existing one when it does.
                 *
                 * @returns {object}
                 */


                const wrapEvent = wrapperMap => ({
                  addListener(target, listener, ...args) {
                    target.addListener(wrapperMap.get(listener), ...args);
                  },

                  hasListener(target, listener) {
                    return target.hasListener(wrapperMap.get(listener));
                  },

                  removeListener(target, listener) {
                    target.removeListener(wrapperMap.get(listener));
                  }

                });

                const onRequestFinishedWrappers = new DefaultWeakMap(listener => {
                  if (typeof listener !== "function") {
                    return listener;
                  }
                  /**
                   * Wraps an onRequestFinished listener function so that it will return a
                   * `getContent()` property which returns a `Promise` rather than using a
                   * callback API.
                   *
                   * @param {object} req
                   *        The HAR entry object representing the network request.
                   */


                  return function onRequestFinished(req) {
                    const wrappedReq = wrapObject(req, {}
                      /* wrappers */
                      , {
                        getContent: {
                          minArgs: 0,
                          maxArgs: 0
                        }
                      });
                    listener(wrappedReq);
                  };
                }); // Keep track if the deprecation warning has been logged at least once.

                let loggedSendResponseDeprecationWarning = false;
                const onMessageWrappers = new DefaultWeakMap(listener => {
                  if (typeof listener !== "function") {
                    return listener;
                  }
                  /**
                   * Wraps a message listener function so that it may send responses based on
                   * its return value, rather than by returning a sentinel value and calling a
                   * callback. If the listener function returns a Promise, the response is
                   * sent when the promise either resolves or rejects.
                   *
                   * @param {*} message
                   *        The message sent by the other end of the channel.
                   * @param {object} sender
                   *        Details about the sender of the message.
                   * @param {function(*)} sendResponse
                   *        A callback which, when called with an arbitrary argument, sends
                   *        that value as a response.
                   * @returns {boolean}
                   *        True if the wrapped listener returned a Promise, which will later
                   *        yield a response. False otherwise.
                   */


                  return function onMessage(message, sender, sendResponse) {
                    let didCallSendResponse = false;
                    let wrappedSendResponse;
                    let sendResponsePromise = new Promise(resolve => {
                      wrappedSendResponse = function (response) {
                        if (!loggedSendResponseDeprecationWarning) {
                          console.warn(SEND_RESPONSE_DEPRECATION_WARNING, new Error().stack);
                          loggedSendResponseDeprecationWarning = true;
                        }

                        didCallSendResponse = true;
                        resolve(response);
                      };
                    });
                    let result;

                    try {
                      result = listener(message, sender, wrappedSendResponse);
                    } catch (err) {
                      result = Promise.reject(err);
                    }

                    const isResultThenable = result !== true && isThenable(result); // If the listener didn't returned true or a Promise, or called
                    // wrappedSendResponse synchronously, we can exit earlier
                    // because there will be no response sent from this listener.

                    if (result !== true && !isResultThenable && !didCallSendResponse) {
                      return false;
                    } // A small helper to send the message if the promise resolves
                    // and an error if the promise rejects (a wrapped sendMessage has
                    // to translate the message into a resolved promise or a rejected
                    // promise).


                    const sendPromisedResult = promise => {
                      promise.then(msg => {
                        // send the message value.
                        sendResponse(msg);
                      }, error => {
                        // Send a JSON representation of the error if the rejected value
                        // is an instance of error, or the object itself otherwise.
                        let message;

                        if (error && (error instanceof Error || typeof error.message === "string")) {
                          message = error.message;
                        } else {
                          message = "An unexpected error occurred";
                        }

                        sendResponse({
                          __mozWebExtensionPolyfillReject__: true,
                          message
                        });
                      }).catch(err => {
                        // Print an error on the console if unable to send the response.
                        console.error("Failed to send onMessage rejected reply", err);
                      });
                    }; // If the listener returned a Promise, send the resolved value as a
                    // result, otherwise wait the promise related to the wrappedSendResponse
                    // callback to resolve and send it as a response.


                    if (isResultThenable) {
                      sendPromisedResult(result);
                    } else {
                      sendPromisedResult(sendResponsePromise);
                    } // Let Chrome know that the listener is replying.


                    return true;
                  };
                });

                const wrappedSendMessageCallback = ({
                  reject,
                  resolve
                }, reply) => {
                  if (extensionAPIs.runtime.lastError) {
                    // Detect when none of the listeners replied to the sendMessage call and resolve
                    // the promise to undefined as in Firefox.
                    // See https://github.com/mozilla/webextension-polyfill/issues/130
                    if (extensionAPIs.runtime.lastError.message === CHROME_SEND_MESSAGE_CALLBACK_NO_RESPONSE_MESSAGE) {
                      resolve();
                    } else {
                      reject(new Error(extensionAPIs.runtime.lastError.message));
                    }
                  } else if (reply && reply.__mozWebExtensionPolyfillReject__) {
                    // Convert back the JSON representation of the error into
                    // an Error instance.
                    reject(new Error(reply.message));
                  } else {
                    resolve(reply);
                  }
                };

                const wrappedSendMessage = (name, metadata, apiNamespaceObj, ...args) => {
                  if (args.length < metadata.minArgs) {
                    throw new Error(`Expected at least ${metadata.minArgs} ${pluralizeArguments(metadata.minArgs)} for ${name}(), got ${args.length}`);
                  }

                  if (args.length > metadata.maxArgs) {
                    throw new Error(`Expected at most ${metadata.maxArgs} ${pluralizeArguments(metadata.maxArgs)} for ${name}(), got ${args.length}`);
                  }

                  return new Promise((resolve, reject) => {
                    const wrappedCb = wrappedSendMessageCallback.bind(null, {
                      resolve,
                      reject
                    });
                    args.push(wrappedCb);
                    apiNamespaceObj.sendMessage(...args);
                  });
                };

                const staticWrappers = {
                  devtools: {
                    network: {
                      onRequestFinished: wrapEvent(onRequestFinishedWrappers)
                    }
                  },
                  runtime: {
                    onMessage: wrapEvent(onMessageWrappers),
                    onMessageExternal: wrapEvent(onMessageWrappers),
                    sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                      minArgs: 1,
                      maxArgs: 3
                    })
                  },
                  tabs: {
                    sendMessage: wrappedSendMessage.bind(null, "sendMessage", {
                      minArgs: 2,
                      maxArgs: 3
                    })
                  }
                };
                const settingMetadata = {
                  clear: {
                    minArgs: 1,
                    maxArgs: 1
                  },
                  get: {
                    minArgs: 1,
                    maxArgs: 1
                  },
                  set: {
                    minArgs: 1,
                    maxArgs: 1
                  }
                };
                apiMetadata.privacy = {
                  network: {
                    "*": settingMetadata
                  },
                  services: {
                    "*": settingMetadata
                  },
                  websites: {
                    "*": settingMetadata
                  }
                };
                return wrapObject(extensionAPIs, staticWrappers, apiMetadata);
              };

              if (typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id) {
                throw new Error("This script should only be loaded in a browser extension.");
              } // The build process adds a UMD wrapper around this file, which makes the
              // `module` variable available.


              console.log('wrapping chrome = ', chrome)
              module.exports = wrapAPIs(chrome);
            } else {
              module.exports = browser;
            }
          });
          //# sourceMappingURL=browser-polyfill.js.map

        };
      };
    }
  }, { package: "webextension-polyfill", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\whatwg-fetch\\dist\\fetch.umd.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\whatwg-fetch\dist\fetch.umd.js
        return function (require, module, exports) {
          (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
              typeof define === 'function' && define.amd ? define(['exports'], factory) :
                (factory((global.WHATWGFetch = {})));
          }(this, (function (exports) {
            'use strict';

            var global =
              (typeof globalThis !== 'undefined' && globalThis) ||
              (typeof self !== 'undefined' && self) ||
              (typeof global !== 'undefined' && global);

            var support = {
              searchParams: 'URLSearchParams' in global,
              iterable: 'Symbol' in global && 'iterator' in Symbol,
              blob:
                'FileReader' in global &&
                'Blob' in global &&
                (function () {
                  try {
                    new Blob();
                    return true
                  } catch (e) {
                    return false
                  }
                })(),
              formData: 'FormData' in global,
              arrayBuffer: 'ArrayBuffer' in global
            };

            function isDataView(obj) {
              return obj && DataView.prototype.isPrototypeOf(obj)
            }

            if (support.arrayBuffer) {
              var viewClasses = [
                '[object Int8Array]',
                '[object Uint8Array]',
                '[object Uint8ClampedArray]',
                '[object Int16Array]',
                '[object Uint16Array]',
                '[object Int32Array]',
                '[object Uint32Array]',
                '[object Float32Array]',
                '[object Float64Array]'
              ];

              var isArrayBufferView =
                ArrayBuffer.isView ||
                function (obj) {
                  return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
                };
            }

            function normalizeName(name) {
              if (typeof name !== 'string') {
                name = String(name);
              }
              if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === '') {
                throw new TypeError('Invalid character in header field name: "' + name + '"')
              }
              return name.toLowerCase()
            }

            function normalizeValue(value) {
              if (typeof value !== 'string') {
                value = String(value);
              }
              return value
            }

            // Build a destructive iterator for the value list
            function iteratorFor(items) {
              var iterator = {
                next: function () {
                  var value = items.shift();
                  return { done: value === undefined, value: value }
                }
              };

              if (support.iterable) {
                iterator[Symbol.iterator] = function () {
                  return iterator
                };
              }

              return iterator
            }

            function Headers(headers) {
              this.map = {};

              if (headers instanceof Headers) {
                headers.forEach(function (value, name) {
                  this.append(name, value);
                }, this);
              } else if (Array.isArray(headers)) {
                headers.forEach(function (header) {
                  this.append(header[0], header[1]);
                }, this);
              } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function (name) {
                  this.append(name, headers[name]);
                }, this);
              }
            }

            Headers.prototype.append = function (name, value) {
              name = normalizeName(name);
              value = normalizeValue(value);
              var oldValue = this.map[name];
              this.map[name] = oldValue ? oldValue + ', ' + value : value;
            };

            Headers.prototype['delete'] = function (name) {
              delete this.map[normalizeName(name)];
            };

            Headers.prototype.get = function (name) {
              name = normalizeName(name);
              return this.has(name) ? this.map[name] : null
            };

            Headers.prototype.has = function (name) {
              return this.map.hasOwnProperty(normalizeName(name))
            };

            Headers.prototype.set = function (name, value) {
              this.map[normalizeName(name)] = normalizeValue(value);
            };

            Headers.prototype.forEach = function (callback, thisArg) {
              for (var name in this.map) {
                if (this.map.hasOwnProperty(name)) {
                  callback.call(thisArg, this.map[name], name, this);
                }
              }
            };

            Headers.prototype.keys = function () {
              var items = [];
              this.forEach(function (value, name) {
                items.push(name);
              });
              return iteratorFor(items)
            };

            Headers.prototype.values = function () {
              var items = [];
              this.forEach(function (value) {
                items.push(value);
              });
              return iteratorFor(items)
            };

            Headers.prototype.entries = function () {
              var items = [];
              this.forEach(function (value, name) {
                items.push([name, value]);
              });
              return iteratorFor(items)
            };

            if (support.iterable) {
              Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
            }

            function consumed(body) {
              if (body.bodyUsed) {
                return Promise.reject(new TypeError('Already read'))
              }
              body.bodyUsed = true;
            }

            function fileReaderReady(reader) {
              return new Promise(function (resolve, reject) {
                reader.onload = function () {
                  resolve(reader.result);
                };
                reader.onerror = function () {
                  reject(reader.error);
                };
              })
            }

            function readBlobAsArrayBuffer(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsArrayBuffer(blob);
              return promise
            }

            function readBlobAsText(blob) {
              var reader = new FileReader();
              var promise = fileReaderReady(reader);
              reader.readAsText(blob);
              return promise
            }

            function readArrayBufferAsText(buf) {
              var view = new Uint8Array(buf);
              var chars = new Array(view.length);

              for (var i = 0; i < view.length; i++) {
                chars[i] = String.fromCharCode(view[i]);
              }
              return chars.join('')
            }

            function bufferClone(buf) {
              if (buf.slice) {
                return buf.slice(0)
              } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer
              }
            }

            function Body() {
              this.bodyUsed = false;

              this._initBody = function (body) {
                /*
                  fetch-mock wraps the Response object in an ES6 Proxy to
                  provide useful test harness features such as flush. However, on
                  ES5 browsers without fetch or Proxy support pollyfills must be used;
                  the proxy-pollyfill is unable to proxy an attribute unless it exists
                  on the object before the Proxy is created. This change ensures
                  Response.bodyUsed exists on the instance, while maintaining the
                  semantic of setting Request.bodyUsed in the constructor before
                  _initBody is called.
                */
                this.bodyUsed = this.bodyUsed;
                this._bodyInit = body;
                if (!body) {
                  this._bodyText = '';
                } else if (typeof body === 'string') {
                  this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                  this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                  this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                  this._bodyArrayBuffer = bufferClone(body.buffer);
                  // IE 10-11 can't handle a DataView body.
                  this._bodyInit = new Blob([this._bodyArrayBuffer]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                  this._bodyArrayBuffer = bufferClone(body);
                } else {
                  this._bodyText = body = Object.prototype.toString.call(body);
                }

                if (!this.headers.get('content-type')) {
                  if (typeof body === 'string') {
                    this.headers.set('content-type', 'text/plain;charset=UTF-8');
                  } else if (this._bodyBlob && this._bodyBlob.type) {
                    this.headers.set('content-type', this._bodyBlob.type);
                  } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                  }
                }
              };

              if (support.blob) {
                this.blob = function () {
                  var rejected = consumed(this);
                  if (rejected) {
                    return rejected
                  }

                  if (this._bodyBlob) {
                    return Promise.resolve(this._bodyBlob)
                  } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(new Blob([this._bodyArrayBuffer]))
                  } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as blob')
                  } else {
                    return Promise.resolve(new Blob([this._bodyText]))
                  }
                };

                this.arrayBuffer = function () {
                  if (this._bodyArrayBuffer) {
                    var isConsumed = consumed(this);
                    if (isConsumed) {
                      return isConsumed
                    }
                    if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                      return Promise.resolve(
                        this._bodyArrayBuffer.buffer.slice(
                          this._bodyArrayBuffer.byteOffset,
                          this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
                        )
                      )
                    } else {
                      return Promise.resolve(this._bodyArrayBuffer)
                    }
                  } else {
                    return this.blob().then(readBlobAsArrayBuffer)
                  }
                };
              }

              this.text = function () {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected
                }

                if (this._bodyBlob) {
                  return readBlobAsText(this._bodyBlob)
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as text')
                } else {
                  return Promise.resolve(this._bodyText)
                }
              };

              if (support.formData) {
                this.formData = function () {
                  return this.text().then(decode)
                };
              }

              this.json = function () {
                return this.text().then(JSON.parse)
              };

              return this
            }

            // HTTP methods whose capitalization should be normalized
            var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

            function normalizeMethod(method) {
              var upcased = method.toUpperCase();
              return methods.indexOf(upcased) > -1 ? upcased : method
            }

            function Request(input, options) {
              if (!(this instanceof Request)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
              }

              options = options || {};
              var body = options.body;

              if (input instanceof Request) {
                if (input.bodyUsed) {
                  throw new TypeError('Already read')
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options.headers) {
                  this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                  body = input._bodyInit;
                  input.bodyUsed = true;
                }
              } else {
                this.url = String(input);
              }

              this.credentials = options.credentials || this.credentials || 'same-origin';
              if (options.headers || !this.headers) {
                this.headers = new Headers(options.headers);
              }
              this.method = normalizeMethod(options.method || this.method || 'GET');
              this.mode = options.mode || this.mode || null;
              this.signal = options.signal || this.signal;
              this.referrer = null;

              if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                throw new TypeError('Body not allowed for GET or HEAD requests')
              }
              this._initBody(body);

              if (this.method === 'GET' || this.method === 'HEAD') {
                if (options.cache === 'no-store' || options.cache === 'no-cache') {
                  // Search for a '_' parameter in the query string
                  var reParamSearch = /([?&])_=[^&]*/;
                  if (reParamSearch.test(this.url)) {
                    // If it already exists then set the value with the current time
                    this.url = this.url.replace(reParamSearch, '$1_=' + new Date().getTime());
                  } else {
                    // Otherwise add a new '_' parameter to the end with the current time
                    var reQueryString = /\?/;
                    this.url += (reQueryString.test(this.url) ? '&' : '?') + '_=' + new Date().getTime();
                  }
                }
              }
            }

            Request.prototype.clone = function () {
              return new Request(this, { body: this._bodyInit })
            };

            function decode(body) {
              var form = new FormData();
              body
                .trim()
                .split('&')
                .forEach(function (bytes) {
                  if (bytes) {
                    var split = bytes.split('=');
                    var name = split.shift().replace(/\+/g, ' ');
                    var value = split.join('=').replace(/\+/g, ' ');
                    form.append(decodeURIComponent(name), decodeURIComponent(value));
                  }
                });
              return form
            }

            function parseHeaders(rawHeaders) {
              var headers = new Headers();
              // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
              // https://tools.ietf.org/html/rfc7230#section-3.2
              var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
              // Avoiding split via regex to work around a common IE11 bug with the core-js 3.6.0 regex polyfill
              // https://github.com/github/fetch/issues/748
              // https://github.com/zloirock/core-js/issues/751
              preProcessedHeaders
                .split('\r')
                .map(function (header) {
                  return header.indexOf('\n') === 0 ? header.substr(1, header.length) : header
                })
                .forEach(function (line) {
                  var parts = line.split(':');
                  var key = parts.shift().trim();
                  if (key) {
                    var value = parts.join(':').trim();
                    headers.append(key, value);
                  }
                });
              return headers
            }

            Body.call(Request.prototype);

            function Response(bodyInit, options) {
              if (!(this instanceof Response)) {
                throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.')
              }
              if (!options) {
                options = {};
              }

              this.type = 'default';
              this.status = options.status === undefined ? 200 : options.status;
              this.ok = this.status >= 200 && this.status < 300;
              this.statusText = options.statusText === undefined ? '' : '' + options.statusText;
              this.headers = new Headers(options.headers);
              this.url = options.url || '';
              this._initBody(bodyInit);
            }

            Body.call(Response.prototype);

            Response.prototype.clone = function () {
              return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
              })
            };

            Response.error = function () {
              var response = new Response(null, { status: 0, statusText: '' });
              response.type = 'error';
              return response
            };

            var redirectStatuses = [301, 302, 303, 307, 308];

            Response.redirect = function (url, status) {
              if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError('Invalid status code')
              }

              return new Response(null, { status: status, headers: { location: url } })
            };

            exports.DOMException = global.DOMException;
            try {
              new exports.DOMException();
            } catch (err) {
              exports.DOMException = function (message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
              };
              exports.DOMException.prototype = Object.create(Error.prototype);
              exports.DOMException.prototype.constructor = exports.DOMException;
            }

            function fetch(input, init) {
              return new Promise(function (resolve, reject) {
                var request = new Request(input, init);

                if (request.signal && request.signal.aborted) {
                  return reject(new exports.DOMException('Aborted', 'AbortError'))
                }

                var xhr = new XMLHttpRequest();

                function abortXhr() {
                  xhr.abort();
                }

                xhr.onload = function () {
                  var options = {
                    status: xhr.status,
                    statusText: xhr.statusText,
                    headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                  };
                  options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                  var body = 'response' in xhr ? xhr.response : xhr.responseText;
                  setTimeout(function () {
                    resolve(new Response(body, options));
                  }, 0);
                };

                xhr.onerror = function () {
                  setTimeout(function () {
                    reject(new TypeError('Network request failed'));
                  }, 0);
                };

                xhr.ontimeout = function () {
                  setTimeout(function () {
                    reject(new TypeError('Network request failed'));
                  }, 0);
                };

                xhr.onabort = function () {
                  setTimeout(function () {
                    reject(new exports.DOMException('Aborted', 'AbortError'));
                  }, 0);
                };

                function fixUrl(url) {
                  try {
                    return url === '' && global.location.href ? global.location.href : url
                  } catch (e) {
                    return url
                  }
                }

                xhr.open(request.method, fixUrl(request.url), true);

                if (request.credentials === 'include') {
                  xhr.withCredentials = true;
                } else if (request.credentials === 'omit') {
                  xhr.withCredentials = false;
                }

                if ('responseType' in xhr) {
                  if (support.blob) {
                    xhr.responseType = 'blob';
                  } else if (
                    support.arrayBuffer &&
                    request.headers.get('Content-Type') &&
                    request.headers.get('Content-Type').indexOf('application/octet-stream') !== -1
                  ) {
                    xhr.responseType = 'arraybuffer';
                  }
                }

                if (init && typeof init.headers === 'object' && !(init.headers instanceof Headers)) {
                  Object.getOwnPropertyNames(init.headers).forEach(function (name) {
                    xhr.setRequestHeader(name, normalizeValue(init.headers[name]));
                  });
                } else {
                  request.headers.forEach(function (value, name) {
                    xhr.setRequestHeader(name, value);
                  });
                }

                if (request.signal) {
                  request.signal.addEventListener('abort', abortXhr);

                  xhr.onreadystatechange = function () {
                    // DONE (success or failure)
                    if (xhr.readyState === 4) {
                      request.signal.removeEventListener('abort', abortXhr);
                    }
                  };
                }

                xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
              })
            }

            fetch.polyfill = true;

            if (!global.fetch) {
              global.fetch = fetch;
              global.Headers = Headers;
              global.Request = Request;
              global.Response = Response;
            }

            exports.Headers = Headers;
            exports.Request = Request;
            exports.Response = Response;
            exports.fetch = fetch;

            Object.defineProperty(exports, '__esModule', { value: true });

          })));

        };
      };
    }
  }, { package: "@metamask/controllers>isomorphic-fetch>whatwg-fetch", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\wrappy\\wrappy.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\wrappy\wrappy.js
        return function (require, module, exports) {
          // Returns a wrapper function that returns a wrapped callback
          // The wrapper function should do some stuff, and return a
          // presumably different callback function.
          // This makes sure that own properties are retained, so that
          // decorations and such are not lost along the way.
          module.exports = wrappy
          function wrappy(fn, cb) {
            if (fn && cb) return wrappy(fn)(cb)

            if (typeof fn !== 'function')
              throw new TypeError('need wrapper function')

            Object.keys(fn).forEach(function (k) {
              wrapper[k] = fn[k]
            })

            return wrapper

            function wrapper() {
              var args = new Array(arguments.length)
              for (var i = 0; i < args.length; i++) {
                args[i] = arguments[i]
              }
              var ret = fn.apply(this, args)
              var cb = args[args.length - 1]
              if (typeof ret === 'function' && ret !== cb) {
                Object.keys(cb).forEach(function (k) {
                  ret[k] = cb[k]
                })
              }
              return ret
            }
          }

        };
      };
    }
  }, { package: "pump>once>wrappy", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\errors.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\errors.js
        return function (require, module, exports) {
          "use strict";
          var __extends = (this && this.__extends) || (function () {
            var extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return function (d, b) {
              extendStatics(d, b);
              function __() { this.constructor = d; }
              d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
            };
          })();
          Object.defineProperty(exports, "__esModule", { value: true });
          var SecurityError = /** @class */ (function (_super) {
            __extends(SecurityError, _super);
            function SecurityError() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            return SecurityError;
          }(Error));
          exports.SecurityError = SecurityError;
          var InvalidStateError = /** @class */ (function (_super) {
            __extends(InvalidStateError, _super);
            function InvalidStateError() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            return InvalidStateError;
          }(Error));
          exports.InvalidStateError = InvalidStateError;
          var NetworkError = /** @class */ (function (_super) {
            __extends(NetworkError, _super);
            function NetworkError() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            return NetworkError;
          }(Error));
          exports.NetworkError = NetworkError;
          var SyntaxError = /** @class */ (function (_super) {
            __extends(SyntaxError, _super);
            function SyntaxError() {
              return _super !== null && _super.apply(this, arguments) || this;
            }
            return SyntaxError;
          }(Error));
          exports.SyntaxError = SyntaxError;
          //# sourceMappingURL=errors.js.map
        };
      };
    }
  }, { package: "@metamask/controllers>web3>xhr2-cookies", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\index.js", { "./xml-http-request": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request.js", "./xml-http-request-event-target": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\index.js
        return function (require, module, exports) {
          "use strict";
          function __export(m) {
            for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
          }
          Object.defineProperty(exports, "__esModule", { value: true });
          __export(require("./xml-http-request"));
          var xml_http_request_event_target_1 = require("./xml-http-request-event-target");
          exports.XMLHttpRequestEventTarget = xml_http_request_event_target_1.XMLHttpRequestEventTarget;
          //# sourceMappingURL=index.js.map
        };
      };
    }
  }, { package: "@metamask/controllers>web3>xhr2-cookies", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\progress-event.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\progress-event.js
        return function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var ProgressEvent = /** @class */ (function () {
            function ProgressEvent(type) {
              this.type = type;
              this.bubbles = false;
              this.cancelable = false;
              this.loaded = 0;
              this.lengthComputable = false;
              this.total = 0;
            }
            return ProgressEvent;
          }());
          exports.ProgressEvent = ProgressEvent;
          //# sourceMappingURL=progress-event.js.map
        };
      };
    }
  }, { package: "@metamask/controllers>web3>xhr2-cookies", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\xml-http-request-event-target.js
        return function (require, module, exports) {
          "use strict";
          Object.defineProperty(exports, "__esModule", { value: true });
          var XMLHttpRequestEventTarget = /** @class */ (function () {
            function XMLHttpRequestEventTarget() {
              this.listeners = {};
            }
            XMLHttpRequestEventTarget.prototype.addEventListener = function (eventType, listener) {
              eventType = eventType.toLowerCase();
              this.listeners[eventType] = this.listeners[eventType] || [];
              this.listeners[eventType].push(listener.handleEvent || listener);
            };
            XMLHttpRequestEventTarget.prototype.removeEventListener = function (eventType, listener) {
              eventType = eventType.toLowerCase();
              if (!this.listeners[eventType]) {
                return;
              }
              var index = this.listeners[eventType].indexOf(listener.handleEvent || listener);
              if (index < 0) {
                return;
              }
              this.listeners[eventType].splice(index, 1);
            };
            XMLHttpRequestEventTarget.prototype.dispatchEvent = function (event) {
              var eventType = event.type.toLowerCase();
              event.target = this; // TODO: set event.currentTarget?
              if (this.listeners[eventType]) {
                for (var _i = 0, _a = this.listeners[eventType]; _i < _a.length; _i++) {
                  var listener_1 = _a[_i];
                  listener_1.call(this, event);
                }
              }
              var listener = this["on" + eventType];
              if (listener) {
                listener.call(this, event);
              }
              return true;
            };
            return XMLHttpRequestEventTarget;
          }());
          exports.XMLHttpRequestEventTarget = XMLHttpRequestEventTarget;
          //# sourceMappingURL=xml-http-request-event-target.js.map
        };
      };
    }
  }, { package: "@metamask/controllers>web3>xhr2-cookies", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-upload.js", { "./xml-http-request-event-target": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\xml-http-request-upload.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";
              var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                  function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() { this.constructor = d; }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              })();
              Object.defineProperty(exports, "__esModule", { value: true });
              var xml_http_request_event_target_1 = require("./xml-http-request-event-target");
              var XMLHttpRequestUpload = /** @class */ (function (_super) {
                __extends(XMLHttpRequestUpload, _super);
                function XMLHttpRequestUpload() {
                  var _this = _super.call(this) || this;
                  _this._contentType = null;
                  _this._body = null;
                  _this._reset();
                  return _this;
                }
                XMLHttpRequestUpload.prototype._reset = function () {
                  this._contentType = null;
                  this._body = null;
                };
                XMLHttpRequestUpload.prototype._setData = function (data) {
                  if (data == null) {
                    return;
                  }
                  if (typeof data === 'string') {
                    if (data.length !== 0) {
                      this._contentType = 'text/plain;charset=UTF-8';
                    }
                    this._body = new Buffer(data, 'utf-8');
                  }
                  else if (Buffer.isBuffer(data)) {
                    this._body = data;
                  }
                  else if (data instanceof ArrayBuffer) {
                    var body = new Buffer(data.byteLength);
                    var view = new Uint8Array(data);
                    for (var i = 0; i < data.byteLength; i++) {
                      body[i] = view[i];
                    }
                    this._body = body;
                  }
                  else if (data.buffer && data.buffer instanceof ArrayBuffer) {
                    var body = new Buffer(data.byteLength);
                    var offset = data.byteOffset;
                    var view = new Uint8Array(data.buffer);
                    for (var i = 0; i < data.byteLength; i++) {
                      body[i] = view[i + offset];
                    }
                    this._body = body;
                  }
                  else {
                    throw new Error("Unsupported send() data " + data);
                  }
                };
                XMLHttpRequestUpload.prototype._finalizeHeaders = function (headers, loweredHeaders) {
                  if (this._contentType && !loweredHeaders['content-type']) {
                    headers['Content-Type'] = this._contentType;
                  }
                  if (this._body) {
                    headers['Content-Length'] = this._body.length.toString();
                  }
                };
                XMLHttpRequestUpload.prototype._startUpload = function (request) {
                  if (this._body) {
                    request.write(this._body);
                  }
                  request.end();
                };
                return XMLHttpRequestUpload;
              }(xml_http_request_event_target_1.XMLHttpRequestEventTarget));
              exports.XMLHttpRequestUpload = XMLHttpRequestUpload;

            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3>xhr2-cookies", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request.js", { "./errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\errors.js", "./progress-event": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\progress-event.js", "./xml-http-request-event-target": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-event-target.js", "./xml-http-request-upload": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2-cookies\\dist\\xml-http-request-upload.js", "_process": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\process\\browser.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "cookiejar": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\cookiejar\\cookiejar.js", "http": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\stream-http\\index.js", "https": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\https-browserify\\index.js", "os": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\os-browserify\\browser.js", "url": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\url\\url.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2-cookies\dist\xml-http-request.js
        return function (require, module, exports) {
          (function (process, Buffer) {
            (function () {
              "use strict";
              var __extends = (this && this.__extends) || (function () {
                var extendStatics = Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                  function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
                return function (d, b) {
                  extendStatics(d, b);
                  function __() { this.constructor = d; }
                  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                };
              })();
              var __assign = (this && this.__assign) || Object.assign || function (t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
                }
                return t;
              };
              Object.defineProperty(exports, "__esModule", { value: true });
              var http = require("http");
              var https = require("https");
              var os = require("os");
              var url = require("url");
              var progress_event_1 = require("./progress-event");
              var errors_1 = require("./errors");
              var xml_http_request_event_target_1 = require("./xml-http-request-event-target");
              var xml_http_request_upload_1 = require("./xml-http-request-upload");
              var Cookie = require("cookiejar");
              var XMLHttpRequest = /** @class */ (function (_super) {
                __extends(XMLHttpRequest, _super);
                function XMLHttpRequest(options) {
                  if (options === void 0) { options = {}; }
                  var _this = _super.call(this) || this;
                  _this.UNSENT = XMLHttpRequest.UNSENT;
                  _this.OPENED = XMLHttpRequest.OPENED;
                  _this.HEADERS_RECEIVED = XMLHttpRequest.HEADERS_RECEIVED;
                  _this.LOADING = XMLHttpRequest.LOADING;
                  _this.DONE = XMLHttpRequest.DONE;
                  _this.onreadystatechange = null;
                  _this.readyState = XMLHttpRequest.UNSENT;
                  _this.response = null;
                  _this.responseText = '';
                  _this.responseType = '';
                  _this.status = 0; // TODO: UNSENT?
                  _this.statusText = '';
                  _this.timeout = 0;
                  _this.upload = new xml_http_request_upload_1.XMLHttpRequestUpload();
                  _this.responseUrl = '';
                  _this.withCredentials = false;
                  _this._method = null;
                  _this._url = null;
                  _this._sync = false;
                  _this._headers = {};
                  _this._loweredHeaders = {};
                  _this._mimeOverride = null; // TODO: is type right?
                  _this._request = null;
                  _this._response = null;
                  _this._responseParts = null;
                  _this._responseHeaders = null;
                  _this._aborting = null; // TODO: type?
                  _this._error = null; // TODO: type?
                  _this._loadedBytes = 0;
                  _this._totalBytes = 0;
                  _this._lengthComputable = false;
                  _this._restrictedMethods = { CONNECT: true, TRACE: true, TRACK: true };
                  _this._restrictedHeaders = {
                    'accept-charset': true,
                    'accept-encoding': true,
                    'access-control-request-headers': true,
                    'access-control-request-method': true,
                    connection: true,
                    'content-length': true,
                    cookie: true,
                    cookie2: true,
                    date: true,
                    dnt: true,
                    expect: true,
                    host: true,
                    'keep-alive': true,
                    origin: true,
                    referer: true,
                    te: true,
                    trailer: true,
                    'transfer-encoding': true,
                    upgrade: true,
                    'user-agent': true,
                    via: true
                  };
                  _this._privateHeaders = { 'set-cookie': true, 'set-cookie2': true };
                  _this._userAgent = "Mozilla/5.0 (" + os.type() + " " + os.arch() + ") node.js/" + process.versions.node + " v8/" + process.versions.v8;
                  _this._anonymous = options.anon || false;
                  return _this;
                }
                XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
                  if (async === void 0) { async = true; }
                  method = method.toUpperCase();
                  if (this._restrictedMethods[method]) {
                    throw new XMLHttpRequest.SecurityError("HTTP method " + method + " is not allowed in XHR");
                  }
                  ;
                  var xhrUrl = this._parseUrl(url, user, password);
                  if (this.readyState === XMLHttpRequest.HEADERS_RECEIVED || this.readyState === XMLHttpRequest.LOADING) {
                    // TODO(pwnall): terminate abort(), terminate send()
                  }
                  this._method = method;
                  this._url = xhrUrl;
                  this._sync = !async;
                  this._headers = {};
                  this._loweredHeaders = {};
                  this._mimeOverride = null;
                  this._setReadyState(XMLHttpRequest.OPENED);
                  this._request = null;
                  this._response = null;
                  this.status = 0;
                  this.statusText = '';
                  this._responseParts = [];
                  this._responseHeaders = null;
                  this._loadedBytes = 0;
                  this._totalBytes = 0;
                  this._lengthComputable = false;
                };
                XMLHttpRequest.prototype.setRequestHeader = function (name, value) {
                  if (this.readyState !== XMLHttpRequest.OPENED) {
                    throw new XMLHttpRequest.InvalidStateError('XHR readyState must be OPENED');
                  }
                  var loweredName = name.toLowerCase();
                  if (this._restrictedHeaders[loweredName] || /^sec-/.test(loweredName) || /^proxy-/.test(loweredName)) {
                    console.warn("Refused to set unsafe header \"" + name + "\"");
                    return;
                  }
                  value = value.toString();
                  if (this._loweredHeaders[loweredName] != null) {
                    name = this._loweredHeaders[loweredName];
                    this._headers[name] = this._headers[name] + ", " + value;
                  }
                  else {
                    this._loweredHeaders[loweredName] = name;
                    this._headers[name] = value;
                  }
                };
                XMLHttpRequest.prototype.send = function (data) {
                  if (this.readyState !== XMLHttpRequest.OPENED) {
                    throw new XMLHttpRequest.InvalidStateError('XHR readyState must be OPENED');
                  }
                  if (this._request) {
                    throw new XMLHttpRequest.InvalidStateError('send() already called');
                  }
                  switch (this._url.protocol) {
                    case 'file:':
                      return this._sendFile(data);
                    case 'http:':
                    case 'https:':
                      return this._sendHttp(data);
                    default:
                      throw new XMLHttpRequest.NetworkError("Unsupported protocol " + this._url.protocol);
                  }
                };
                XMLHttpRequest.prototype.abort = function () {
                  if (this._request == null) {
                    return;
                  }
                  this._request.abort();
                  this._setError();
                  this._dispatchProgress('abort');
                  this._dispatchProgress('loadend');
                };
                XMLHttpRequest.prototype.getResponseHeader = function (name) {
                  if (this._responseHeaders == null || name == null) {
                    return null;
                  }
                  var loweredName = name.toLowerCase();
                  return this._responseHeaders.hasOwnProperty(loweredName)
                    ? this._responseHeaders[name.toLowerCase()]
                    : null;
                };
                XMLHttpRequest.prototype.getAllResponseHeaders = function () {
                  var _this = this;
                  if (this._responseHeaders == null) {
                    return '';
                  }
                  return Object.keys(this._responseHeaders).map(function (key) { return key + ": " + _this._responseHeaders[key]; }).join('\r\n');
                };
                XMLHttpRequest.prototype.overrideMimeType = function (mimeType) {
                  if (this.readyState === XMLHttpRequest.LOADING || this.readyState === XMLHttpRequest.DONE) {
                    throw new XMLHttpRequest.InvalidStateError('overrideMimeType() not allowed in LOADING or DONE');
                  }
                  this._mimeOverride = mimeType.toLowerCase();
                };
                XMLHttpRequest.prototype.nodejsSet = function (options) {
                  this.nodejsHttpAgent = options.httpAgent || this.nodejsHttpAgent;
                  this.nodejsHttpsAgent = options.httpsAgent || this.nodejsHttpsAgent;
                  if (options.hasOwnProperty('baseUrl')) {
                    if (options.baseUrl != null) {
                      var parsedUrl = url.parse(options.baseUrl, false, true);
                      if (!parsedUrl.protocol) {
                        throw new XMLHttpRequest.SyntaxError("baseUrl must be an absolute URL");
                      }
                    }
                    this.nodejsBaseUrl = options.baseUrl;
                  }
                };
                XMLHttpRequest.nodejsSet = function (options) {
                  XMLHttpRequest.prototype.nodejsSet(options);
                };
                XMLHttpRequest.prototype._setReadyState = function (readyState) {
                  this.readyState = readyState;
                  this.dispatchEvent(new progress_event_1.ProgressEvent('readystatechange'));
                };
                XMLHttpRequest.prototype._sendFile = function (data) {
                  // TODO
                  throw new Error('Protocol file: not implemented');
                };
                XMLHttpRequest.prototype._sendHttp = function (data) {
                  if (this._sync) {
                    throw new Error('Synchronous XHR processing not implemented');
                  }
                  if (data && (this._method === 'GET' || this._method === 'HEAD')) {
                    console.warn("Discarding entity body for " + this._method + " requests");
                    data = null;
                  }
                  else {
                    data = data || '';
                  }
                  this.upload._setData(data);
                  this._finalizeHeaders();
                  this._sendHxxpRequest();
                };
                XMLHttpRequest.prototype._sendHxxpRequest = function () {
                  var _this = this;
                  if (this.withCredentials) {
                    var cookie = XMLHttpRequest.cookieJar
                      .getCookies(Cookie.CookieAccessInfo(this._url.hostname, this._url.pathname, this._url.protocol === 'https:')).toValueString();
                    this._headers.cookie = this._headers.cookie2 = cookie;
                  }
                  var _a = this._url.protocol === 'http:' ? [http, this.nodejsHttpAgent] : [https, this.nodejsHttpsAgent], hxxp = _a[0], agent = _a[1];
                  var requestMethod = hxxp.request.bind(hxxp);
                  var request = requestMethod({
                    hostname: this._url.hostname,
                    port: +this._url.port,
                    path: this._url.path,
                    auth: this._url.auth,
                    method: this._method,
                    headers: this._headers,
                    agent: agent
                  });
                  this._request = request;
                  if (this.timeout) {
                    request.setTimeout(this.timeout, function () { return _this._onHttpTimeout(request); });
                  }
                  request.on('response', function (response) { return _this._onHttpResponse(request, response); });
                  request.on('error', function (error) { return _this._onHttpRequestError(request, error); });
                  this.upload._startUpload(request);
                  if (this._request === request) {
                    this._dispatchProgress('loadstart');
                  }
                };
                XMLHttpRequest.prototype._finalizeHeaders = function () {
                  this._headers = __assign({}, this._headers, { Connection: 'keep-alive', Host: this._url.host, 'User-Agent': this._userAgent }, this._anonymous ? { Referer: 'about:blank' } : {});
                  this.upload._finalizeHeaders(this._headers, this._loweredHeaders);
                };
                XMLHttpRequest.prototype._onHttpResponse = function (request, response) {
                  var _this = this;
                  if (this._request !== request) {
                    return;
                  }
                  if (this.withCredentials && (response.headers['set-cookie'] || response.headers['set-cookie2'])) {
                    XMLHttpRequest.cookieJar
                      .setCookies(response.headers['set-cookie'] || response.headers['set-cookie2']);
                  }
                  if ([301, 302, 303, 307, 308].indexOf(response.statusCode) >= 0) {
                    this._url = this._parseUrl(response.headers.location);
                    this._method = 'GET';
                    if (this._loweredHeaders['content-type']) {
                      delete this._headers[this._loweredHeaders['content-type']];
                      delete this._loweredHeaders['content-type'];
                    }
                    if (this._headers['Content-Type'] != null) {
                      delete this._headers['Content-Type'];
                    }
                    delete this._headers['Content-Length'];
                    this.upload._reset();
                    this._finalizeHeaders();
                    this._sendHxxpRequest();
                    return;
                  }
                  this._response = response;
                  this._response.on('data', function (data) { return _this._onHttpResponseData(response, data); });
                  this._response.on('end', function () { return _this._onHttpResponseEnd(response); });
                  this._response.on('close', function () { return _this._onHttpResponseClose(response); });
                  this.responseUrl = this._url.href.split('#')[0];
                  this.status = response.statusCode;
                  this.statusText = http.STATUS_CODES[this.status];
                  this._parseResponseHeaders(response);
                  var lengthString = this._responseHeaders['content-length'] || '';
                  this._totalBytes = +lengthString;
                  this._lengthComputable = !!lengthString;
                  this._setReadyState(XMLHttpRequest.HEADERS_RECEIVED);
                };
                XMLHttpRequest.prototype._onHttpResponseData = function (response, data) {
                  if (this._response !== response) {
                    return;
                  }
                  this._responseParts.push(new Buffer(data));
                  this._loadedBytes += data.length;
                  if (this.readyState !== XMLHttpRequest.LOADING) {
                    this._setReadyState(XMLHttpRequest.LOADING);
                  }
                  this._dispatchProgress('progress');
                };
                XMLHttpRequest.prototype._onHttpResponseEnd = function (response) {
                  if (this._response !== response) {
                    return;
                  }
                  this._parseResponse();
                  this._request = null;
                  this._response = null;
                  this._setReadyState(XMLHttpRequest.DONE);
                  this._dispatchProgress('load');
                  this._dispatchProgress('loadend');
                };
                XMLHttpRequest.prototype._onHttpResponseClose = function (response) {
                  if (this._response !== response) {
                    return;
                  }
                  var request = this._request;
                  this._setError();
                  request.abort();
                  this._setReadyState(XMLHttpRequest.DONE);
                  this._dispatchProgress('error');
                  this._dispatchProgress('loadend');
                };
                XMLHttpRequest.prototype._onHttpTimeout = function (request) {
                  if (this._request !== request) {
                    return;
                  }
                  this._setError();
                  request.abort();
                  this._setReadyState(XMLHttpRequest.DONE);
                  this._dispatchProgress('timeout');
                  this._dispatchProgress('loadend');
                };
                XMLHttpRequest.prototype._onHttpRequestError = function (request, error) {
                  if (this._request !== request) {
                    return;
                  }
                  this._setError();
                  request.abort();
                  this._setReadyState(XMLHttpRequest.DONE);
                  this._dispatchProgress('error');
                  this._dispatchProgress('loadend');
                };
                XMLHttpRequest.prototype._dispatchProgress = function (eventType) {
                  var event = new XMLHttpRequest.ProgressEvent(eventType);
                  event.lengthComputable = this._lengthComputable;
                  event.loaded = this._loadedBytes;
                  event.total = this._totalBytes;
                  this.dispatchEvent(event);
                };
                XMLHttpRequest.prototype._setError = function () {
                  this._request = null;
                  this._response = null;
                  this._responseHeaders = null;
                  this._responseParts = null;
                };
                XMLHttpRequest.prototype._parseUrl = function (urlString, user, password) {
                  var absoluteUrl = this.nodejsBaseUrl == null ? urlString : url.resolve(this.nodejsBaseUrl, urlString);
                  var xhrUrl = url.parse(absoluteUrl, false, true);
                  xhrUrl.hash = null;
                  var _a = (xhrUrl.auth || '').split(':'), xhrUser = _a[0], xhrPassword = _a[1];
                  if (xhrUser || xhrPassword || user || password) {
                    xhrUrl.auth = (user || xhrUser || '') + ":" + (password || xhrPassword || '');
                  }
                  return xhrUrl;
                };
                XMLHttpRequest.prototype._parseResponseHeaders = function (response) {
                  this._responseHeaders = {};
                  for (var name_1 in response.headers) {
                    var loweredName = name_1.toLowerCase();
                    if (this._privateHeaders[loweredName]) {
                      continue;
                    }
                    this._responseHeaders[loweredName] = response.headers[name_1];
                  }
                  if (this._mimeOverride != null) {
                    this._responseHeaders['content-type'] = this._mimeOverride;
                  }
                };
                XMLHttpRequest.prototype._parseResponse = function () {
                  var buffer = Buffer.concat(this._responseParts);
                  this._responseParts = null;
                  switch (this.responseType) {
                    case 'json':
                      this.responseText = null;
                      try {
                        this.response = JSON.parse(buffer.toString('utf-8'));
                      }
                      catch (_a) {
                        this.response = null;
                      }
                      return;
                    case 'buffer':
                      this.responseText = null;
                      this.response = buffer;
                      return;
                    case 'arraybuffer':
                      this.responseText = null;
                      var arrayBuffer = new ArrayBuffer(buffer.length);
                      var view = new Uint8Array(arrayBuffer);
                      for (var i = 0; i < buffer.length; i++) {
                        view[i] = buffer[i];
                      }
                      this.response = arrayBuffer;
                      return;
                    case 'text':
                    default:
                      try {
                        this.responseText = buffer.toString(this._parseResponseEncoding());
                      }
                      catch (_b) {
                        this.responseText = buffer.toString('binary');
                      }
                      this.response = this.responseText;
                  }
                };
                XMLHttpRequest.prototype._parseResponseEncoding = function () {
                  return /;\s*charset=(.*)$/.exec(this._responseHeaders['content-type'] || '')[1] || 'utf-8';
                };
                XMLHttpRequest.ProgressEvent = progress_event_1.ProgressEvent;
                XMLHttpRequest.InvalidStateError = errors_1.InvalidStateError;
                XMLHttpRequest.NetworkError = errors_1.NetworkError;
                XMLHttpRequest.SecurityError = errors_1.SecurityError;
                XMLHttpRequest.SyntaxError = errors_1.SyntaxError;
                XMLHttpRequest.XMLHttpRequestUpload = xml_http_request_upload_1.XMLHttpRequestUpload;
                XMLHttpRequest.UNSENT = 0;
                XMLHttpRequest.OPENED = 1;
                XMLHttpRequest.HEADERS_RECEIVED = 2;
                XMLHttpRequest.LOADING = 3;
                XMLHttpRequest.DONE = 4;
                XMLHttpRequest.cookieJar = Cookie.CookieJar();
                return XMLHttpRequest;
              }(xml_http_request_event_target_1.XMLHttpRequestEventTarget));
              exports.XMLHttpRequest = XMLHttpRequest;
              XMLHttpRequest.prototype.nodejsHttpAgent = http.globalAgent;
              XMLHttpRequest.prototype.nodejsHttpsAgent = https.globalAgent;
              XMLHttpRequest.prototype.nodejsBaseUrl = null;

            }).call(this)
          }).call(this, require('_process'), require("buffer").Buffer)

        };
      };
    }
  }, { package: "@metamask/controllers>web3>xhr2-cookies", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xhr2\\lib\\browser.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xhr2\lib\browser.js
        return function (require, module, exports) {
          module.exports = XMLHttpRequest;

        };
      };
    }
  }, { package: "ethjs>ethjs-provider-http>xhr2", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\xtend\\immutable.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\node_modules\xtend\immutable.js
        return function (require, module, exports) {
          module.exports = extend

          var hasOwnProperty = Object.prototype.hasOwnProperty;

          function extend() {
            var target = {}

            for (var i = 0; i < arguments.length; i++) {
              var source = arguments[i]

              for (var key in source) {
                if (hasOwnProperty.call(source, key)) {
                  target[key] = source[key]
                }
              }
            }

            return target
          }

        };
      };
    }
  }, { package: "watchify>xtend", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\alerts.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\alerts.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WEB3_SHIM_USAGE_ALERT_STATES = exports.TOGGLEABLE_ALERT_TYPES = exports.ALERT_TYPES = void 0;
          const ALERT_TYPES = {
            unconnectedAccount: 'unconnectedAccount',
            web3ShimUsage: 'web3ShimUsage',
            invalidCustomNetwork: 'invalidCustomNetwork'
          };
          /**
           * Alerts that can be enabled or disabled by the user.
           */

          exports.ALERT_TYPES = ALERT_TYPES;
          const TOGGLEABLE_ALERT_TYPES = [ALERT_TYPES.unconnectedAccount, ALERT_TYPES.web3ShimUsage];
          exports.TOGGLEABLE_ALERT_TYPES = TOGGLEABLE_ALERT_TYPES;
          const WEB3_SHIM_USAGE_ALERT_STATES = {
            RECORDED: 1,
            DISMISSED: 2
          };
          exports.WEB3_SHIM_USAGE_ALERT_STATES = WEB3_SHIM_USAGE_ALERT_STATES;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts", { "./permissions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\permissions.ts" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\app.ts
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.UNKNOWN_TICKER_SYMBOL = exports.SUBJECT_TYPES = exports.POLLING_TOKEN_ENVIRONMENT_TYPES = exports.PLATFORM_OPERA = exports.PLATFORM_FIREFOX = exports.PLATFORM_EDGE = exports.PLATFORM_CHROME = exports.PLATFORM_BRAVE = exports.ORIGIN_METAMASK = exports.METAMASK_PROD_CHROME_ID = exports.METAMASK_FLASK_CHROME_ID = exports.METAMASK_BETA_CHROME_ID = exports.MESSAGE_TYPE = exports.FIREFOX_BUILD_IDS = exports.ENVIRONMENT_TYPE_POPUP = exports.ENVIRONMENT_TYPE_NOTIFICATION = exports.ENVIRONMENT_TYPE_FULLSCREEN = exports.ENVIRONMENT_TYPE_BACKGROUND = exports.CHROME_BUILD_IDS = exports.BuildType = void 0;

          var _permissions = require("./permissions");

          const ENVIRONMENT_TYPE_POPUP = 'popup';
          exports.ENVIRONMENT_TYPE_POPUP = ENVIRONMENT_TYPE_POPUP;
          const ENVIRONMENT_TYPE_NOTIFICATION = 'notification';
          exports.ENVIRONMENT_TYPE_NOTIFICATION = ENVIRONMENT_TYPE_NOTIFICATION;
          const ENVIRONMENT_TYPE_FULLSCREEN = 'fullscreen';
          exports.ENVIRONMENT_TYPE_FULLSCREEN = ENVIRONMENT_TYPE_FULLSCREEN;
          const ENVIRONMENT_TYPE_BACKGROUND = 'background';
          /**
           * The distribution this build is intended for.
           *
           * This should be kept in-sync with the `BuildType` map in `development/build/utils.js`.
           */

          exports.ENVIRONMENT_TYPE_BACKGROUND = ENVIRONMENT_TYPE_BACKGROUND;
          const BuildType = {
            beta: 'beta',
            flask: 'flask',
            main: 'main'
          };
          exports.BuildType = BuildType;
          const PLATFORM_BRAVE = 'Brave';
          exports.PLATFORM_BRAVE = PLATFORM_BRAVE;
          const PLATFORM_CHROME = 'Chrome';
          exports.PLATFORM_CHROME = PLATFORM_CHROME;
          const PLATFORM_EDGE = 'Edge';
          exports.PLATFORM_EDGE = PLATFORM_EDGE;
          const PLATFORM_FIREFOX = 'Firefox';
          exports.PLATFORM_FIREFOX = PLATFORM_FIREFOX;
          const PLATFORM_OPERA = 'Opera';
          exports.PLATFORM_OPERA = PLATFORM_OPERA;
          const MESSAGE_TYPE = {
            ADD_ETHEREUM_CHAIN: 'wallet_addEthereumChain',
            ETH_ACCOUNTS: _permissions.RestrictedMethods.eth_accounts,
            ETH_DECRYPT: 'eth_decrypt',
            ETH_GET_ENCRYPTION_PUBLIC_KEY: 'eth_getEncryptionPublicKey',
            ETH_REQUEST_ACCOUNTS: 'eth_requestAccounts',
            ETH_SIGN: 'eth_sign',
            ETH_SIGN_TYPED_DATA: 'eth_signTypedData',
            ETH_SIGN_TYPED_DATA_V3: 'eth_signTypedData_v3',
            ETH_SIGN_TYPED_DATA_V4: 'eth_signTypedData_v4',
            GET_PROVIDER_STATE: 'metamask_getProviderState',
            LOG_WEB3_SHIM_USAGE: 'metamask_logWeb3ShimUsage',
            PERSONAL_SIGN: 'personal_sign',
            SEND_METADATA: 'metamask_sendDomainMetadata',
            SWITCH_ETHEREUM_CHAIN: 'wallet_switchEthereumChain',
            WALLET_REQUEST_PERMISSIONS: 'wallet_requestPermissions',
            WATCH_ASSET: 'wallet_watchAsset',
            WATCH_ASSET_LEGACY: 'metamask_watchAsset',
            ///: BEGIN:ONLY_INCLUDE_IN(flask)
            SNAP_CONFIRM: _permissions.RestrictedMethods.snap_confirm ///: END:ONLY_INCLUDE_IN

          };
          /**
           * The different kinds of subjects that MetaMask may interact with, including
           * third parties and itself (e.g. when the background communicated with the UI).
           */

          exports.MESSAGE_TYPE = MESSAGE_TYPE;
          const SUBJECT_TYPES = {
            EXTENSION: 'extension',
            INTERNAL: 'internal',
            UNKNOWN: 'unknown',
            WEBSITE: 'website',
            ///: BEGIN:ONLY_INCLUDE_IN(flask)
            SNAP: 'snap' ///: END:ONLY_INCLUDE_IN

          };
          exports.SUBJECT_TYPES = SUBJECT_TYPES;
          const POLLING_TOKEN_ENVIRONMENT_TYPES = {
            [ENVIRONMENT_TYPE_POPUP]: 'popupGasPollTokens',
            [ENVIRONMENT_TYPE_NOTIFICATION]: 'notificationGasPollTokens',
            [ENVIRONMENT_TYPE_FULLSCREEN]: 'fullScreenGasPollTokens'
          };
          exports.POLLING_TOKEN_ENVIRONMENT_TYPES = POLLING_TOKEN_ENVIRONMENT_TYPES;
          const ORIGIN_METAMASK = 'metamask';
          exports.ORIGIN_METAMASK = ORIGIN_METAMASK;
          const METAMASK_BETA_CHROME_ID = 'pbbkamfgmaedccnfkmjcofcecjhfgldn';
          exports.METAMASK_BETA_CHROME_ID = METAMASK_BETA_CHROME_ID;
          const METAMASK_PROD_CHROME_ID = 'nkbihfbeogaeaoehlefnkodbefgpgknn';
          exports.METAMASK_PROD_CHROME_ID = METAMASK_PROD_CHROME_ID;
          const METAMASK_FLASK_CHROME_ID = 'ljfoeinjpaedjfecbmggjgodbgkmjkjk';
          exports.METAMASK_FLASK_CHROME_ID = METAMASK_FLASK_CHROME_ID;
          const CHROME_BUILD_IDS = [METAMASK_BETA_CHROME_ID, METAMASK_PROD_CHROME_ID, METAMASK_FLASK_CHROME_ID];
          exports.CHROME_BUILD_IDS = CHROME_BUILD_IDS;
          const METAMASK_BETA_FIREFOX_ID = 'webextension-beta@metamask.io';
          const METAMASK_PROD_FIREFOX_ID = 'webextension@metamask.io';
          const METAMASK_FLASK_FIREFOX_ID = 'webextension-flask@metamask.io';
          const FIREFOX_BUILD_IDS = [METAMASK_BETA_FIREFOX_ID, METAMASK_PROD_FIREFOX_ID, METAMASK_FLASK_FIREFOX_ID];
          exports.FIREFOX_BUILD_IDS = FIREFOX_BUILD_IDS;
          const UNKNOWN_TICKER_SYMBOL = 'UNKNOWN';
          exports.UNKNOWN_TICKER_SYMBOL = UNKNOWN_TICKER_SYMBOL;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js", { "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\gas.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.PRIORITY_LEVELS = exports.NETWORK_CONGESTION_THRESHOLDS = exports.MIN_GAS_LIMIT_HEX = exports.GAS_RECOMMENDATIONS = exports.GAS_LIMITS = exports.GAS_ESTIMATE_TYPES = exports.EDIT_GAS_MODES = exports.CUSTOM_GAS_ESTIMATE = void 0;

          var _ethereumjsUtil = require("ethereumjs-util");

          const ONE_HUNDRED_THOUSAND = 100000;
          const MIN_GAS_LIMIT_DEC = '21000';
          const MIN_GAS_LIMIT_HEX = parseInt(MIN_GAS_LIMIT_DEC, 10).toString(16);
          exports.MIN_GAS_LIMIT_HEX = MIN_GAS_LIMIT_HEX;
          const GAS_LIMITS = {
            // maximum gasLimit of a simple send
            SIMPLE: (0, _ethereumjsUtil.addHexPrefix)(MIN_GAS_LIMIT_HEX),
            // a base estimate for token transfers.
            BASE_TOKEN_ESTIMATE: (0, _ethereumjsUtil.addHexPrefix)(ONE_HUNDRED_THOUSAND.toString(16))
          };
          /**
           * @typedef {object} GasEstimateTypes
           * @property {'fee-market'} FEE_MARKET - A gas estimate for a fee market
           *  transaction generated by our gas estimation API.
           * @property {'legacy'} LEGACY - A gas estimate for a legacy Transaction
           *  generated by our gas estimation API.
           * @property {'eth_gasPrice'} ETH_GAS_PRICE - A gas estimate provided by the
           *  Ethereum node via eth_gasPrice.
           * @property {'none'} NONE - No gas estimate available.
           */

          /**
           * These are already declared in @metamask/controllers but importing them from
           * that module and re-exporting causes the UI bundle size to expand beyond 4MB
           *
           * @type {GasEstimateTypes}
           */

          exports.GAS_LIMITS = GAS_LIMITS;
          const GAS_ESTIMATE_TYPES = {
            FEE_MARKET: 'fee-market',
            LEGACY: 'legacy',
            ETH_GASPRICE: 'eth_gasPrice',
            NONE: 'none'
          };
          /**
           * These represent gas recommendation levels presented in the UI
           */

          exports.GAS_ESTIMATE_TYPES = GAS_ESTIMATE_TYPES;
          const GAS_RECOMMENDATIONS = {
            LOW: 'low',
            MEDIUM: 'medium',
            HIGH: 'high'
          };
          /**
           * These represent types of gas estimation
           */

          exports.GAS_RECOMMENDATIONS = GAS_RECOMMENDATIONS;
          const PRIORITY_LEVELS = {
            TEN_PERCENT_INCREASED: 'tenPercentIncreased',
            LOW: 'low',
            MEDIUM: 'medium',
            HIGH: 'high',
            CUSTOM: 'custom',
            DAPP_SUGGESTED: 'dappSuggested'
          };
          /**
           * Represents the user customizing their gas preference
           */

          exports.PRIORITY_LEVELS = PRIORITY_LEVELS;
          const CUSTOM_GAS_ESTIMATE = 'custom';
          /**
           * These represent the different edit modes presented in the UI
           */

          exports.CUSTOM_GAS_ESTIMATE = CUSTOM_GAS_ESTIMATE;
          const EDIT_GAS_MODES = {
            SPEED_UP: 'speed-up',
            CANCEL: 'cancel',
            MODIFY_IN_PLACE: 'modify-in-place',
            SWAPS: 'swaps'
          };
          /**
           * Represents levels for `networkCongestion` (calculated along with gas fee
           * estimates; represents a number between 0 and 1) that we use to render the
           * network status slider on the send transaction screen and inform users when
           * gas fees are high
           */

          exports.EDIT_GAS_MODES = EDIT_GAS_MODES;
          const NETWORK_CONGESTION_THRESHOLDS = {
            NOT_BUSY: 0,
            STABLE: 0.33,
            BUSY: 0.66
          };
          exports.NETWORK_CONGESTION_THRESHOLDS = NETWORK_CONGESTION_THRESHOLDS;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\hardware-wallets.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WEBHID_CONNECTED_STATUSES = exports.TRANSPORT_STATES = exports.LEDGER_USB_VENDOR_ID = exports.LEDGER_TRANSPORT_TYPES = exports.KEYRING_TYPES = exports.KEYRING_NAMES = exports.DEVICE_NAMES = exports.AFFILIATE_TUTORIAL_LINKS = exports.AFFILIATE_LINKS = void 0;

          /**
           * Accounts can be instantiated from simple, HD or the multiple hardware wallet
           * keyring types. Both simple and HD are treated as default but we do special
           * case accounts managed by a hardware wallet.
           */
          const KEYRING_TYPES = {
            LEDGER: 'Ledger Hardware',
            TREZOR: 'Trezor Hardware',
            LATTICE: 'Lattice Hardware',
            QR: 'QR Hardware Wallet Device',
            IMPORTED: 'Simple Key Pair'
          };
          exports.KEYRING_TYPES = KEYRING_TYPES;
          const DEVICE_NAMES = {
            LEDGER: 'ledger',
            TREZOR: 'trezor',
            QR: 'QR Hardware',
            LATTICE: 'lattice'
          };
          exports.DEVICE_NAMES = DEVICE_NAMES;
          const KEYRING_NAMES = {
            LEDGER: 'Ledger',
            TREZOR: 'Trezor',
            QR: 'QR',
            LATTICE: 'Lattice1'
          };
          /**
           * Used for setting the users preference for ledger transport type
           */

          exports.KEYRING_NAMES = KEYRING_NAMES;
          const LEDGER_TRANSPORT_TYPES = {
            LIVE: 'ledgerLive',
            WEBHID: 'webhid',
            U2F: 'u2f'
          };
          exports.LEDGER_TRANSPORT_TYPES = LEDGER_TRANSPORT_TYPES;
          const LEDGER_USB_VENDOR_ID = '0x2c97';
          exports.LEDGER_USB_VENDOR_ID = LEDGER_USB_VENDOR_ID;
          const WEBHID_CONNECTED_STATUSES = {
            CONNECTED: 'connected',
            NOT_CONNECTED: 'notConnected',
            UNKNOWN: 'unknown'
          };
          exports.WEBHID_CONNECTED_STATUSES = WEBHID_CONNECTED_STATUSES;
          const TRANSPORT_STATES = {
            NONE: 'NONE',
            VERIFIED: 'VERIFIED',
            DEVICE_OPEN_FAILURE: 'DEVICE_OPEN_FAILURE',
            UNKNOWN_FAILURE: 'UNKNOWN_FAILURE'
          };
          exports.TRANSPORT_STATES = TRANSPORT_STATES;
          const AFFILIATE_LINKS = {
            LEDGER: 'https://shop.ledger.com/?r=17c4991a03fa',
            GRIDPLUS: 'https://gridplus.io/?afmc=7p',
            TREZOR: 'https://shop.trezor.io/product/trezor-one-black?offer_id=35&aff_id=11009',
            KEYSTONE: 'https://shop.keyst.one/?rfsn=6088257.656b3e9&utm_source=refersion&utm_medium=affiliate&utm_campaign=6088257.656b3e9',
            AIRGAP: 'https://airgap.it/',
            COOLWALLET: 'https://www.coolwallet.io/',
            DCENT: 'https://dcentwallet.com/'
          };
          exports.AFFILIATE_LINKS = AFFILIATE_LINKS;
          const AFFILIATE_TUTORIAL_LINKS = {
            LEDGER: 'https://support.ledger.com/hc/en-us/articles/4404366864657-Set-up-and-use-MetaMask-to-access-your-Ledger-Ethereum-ETH-account?docs=true',
            GRIDPLUS: 'https://docs.gridplus.io/setup/metamask',
            TREZOR: 'https://wiki.trezor.io/Apps:MetaMask',
            KEYSTONE: 'https://support.keyst.one/3rd-party-wallets/eth-and-web3-wallets-keystone/bind-metamask-with-keystone',
            AIRGAP: 'https://support.airgap.it/guides/metamask/',
            COOLWALLET: 'https://www.coolwallet.io/metamask-step-by-step-guides/',
            DCENT: 'https://medium.com/dcentwallet/dcent-wallet-now-supports-qr-based-protocol-to-link-with-metamask-57555f02603f'
          };
          exports.AFFILIATE_TUTORIAL_LINKS = AFFILIATE_TUTORIAL_LINKS;


        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\labels.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\labels.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TRUNCATED_NAME_CHAR_LIMIT = exports.TRUNCATED_ADDRESS_START_CHARS = exports.TRUNCATED_ADDRESS_END_CHARS = void 0;
          // The character limit on ENS names, nicknames and addresses before we truncate
          const TRUNCATED_NAME_CHAR_LIMIT = 11; // The number of characters to slice from the beginning of an address for truncated format:
          // `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`

          exports.TRUNCATED_NAME_CHAR_LIMIT = TRUNCATED_NAME_CHAR_LIMIT;
          const TRUNCATED_ADDRESS_START_CHARS = 5; // The number of characters to slice from the end of an address for truncated format:
          // `${TRUNCATED_ADDRESS_START_CHARS}...${TRUNCATED_ADDRESS_END_CHARS}`

          exports.TRUNCATED_ADDRESS_START_CHARS = TRUNCATED_ADDRESS_START_CHARS;
          const TRUNCATED_ADDRESS_END_CHARS = 4;
          exports.TRUNCATED_ADDRESS_END_CHARS = TRUNCATED_ADDRESS_END_CHARS;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\metametrics.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\metametrics.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TRAITS = exports.REJECT_NOTFICIATION_CLOSE_SIG = exports.REJECT_NOTFICIATION_CLOSE = exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = exports.METAMETRICS_ANONYMOUS_ID = exports.EVENT_NAMES = exports.EVENT = exports.CONTEXT_PROPS = void 0;
          // Type Imports

          /**
           * @typedef {__import__('../../shared/constants/app').EnvironmentType} EnvironmentType
           */
          // Type Declarations

          /**
           * Used to attach context of where the user was at in the application when the
           * event was triggered. Also included as full details of the current page in
           * page events.
           *
           * @typedef {object} MetaMetricsPageObject
           * @property {string} [path] - the path of the current page (e.g /home)
           * @property {string} [title] - the title of the current page (e.g 'home')
           * @property {string} [url] - the fully qualified url of the current page
           */

          /**
           * For metamask, this is the dapp that triggered an interaction
           *
           * @typedef {object} MetaMetricsReferrerObject
           * @property {string} [url] - the origin of the dapp issuing the
           *  notification
           */

          /**
           * We attach context to every meta metrics event that help to qualify our
           * analytics. This type has all optional values because it represents a
           * returned object from a method call. Ideally app and userAgent are
           * defined on every event. This is confirmed in the getTrackMetaMetricsEvent
           * function, but still provides the consumer a way to override these values if
           * necessary.
           *
           * @typedef {object} MetaMetricsContext
           * @property {object} app - Application metadata.
           * @property {string} app.name - the name of the application tracking the event
           * @property {string} app.version - the version of the application
           * @property {string} userAgent - the useragent string of the user
           * @property {MetaMetricsPageObject} [page] - an object representing details of
           *  the current page
           * @property {MetaMetricsReferrerObject} [referrer] - for metamask, this is the
           *  dapp that triggered an interaction
           */

          /**
           * @typedef {object} MetaMetricsEventPayload
           * @property {string} event - event name to track
           * @property {string} category - category to associate event to
           * @property {string} [environmentType] - The type of environment this event
           *  occurred in. Defaults to the background process type
           * @property {object} [properties] - object of custom values to track, keys
           *  in this object must be in snake_case
           * @property {object} [sensitiveProperties] - Object of sensitive values to
           *  track. Keys in this object must be in snake_case. These properties will be
           *  sent in an additional event that excludes the user's metaMetricsId
           * @property {number} [revenue] - amount of currency that event creates in
           *  revenue for MetaMask
           * @property {string} [currency] - ISO 4127 format currency for events with
           *  revenue, defaults to US dollars
           * @property {number} [value] - Abstract business "value" attributable to
           *  customers who trigger this event
           * @property {MetaMetricsPageObject} [page] - the page/route that the event
           *  occurred on
           * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp
           *  that triggered the event
           */

          /**
           * @typedef {object} MetaMetricsEventOptions
           * @property {boolean} [isOptIn] - happened during opt in/out workflow
           * @property {boolean} [flushImmediately] - When true will automatically flush
           *  the segment queue after tracking the event. Recommended if the result of
           *  tracking the event must be known before UI transition or update
           * @property {boolean} [excludeMetaMetricsId] - whether to exclude the user's
           *  metametrics id for anonymity
           * @property {string} [metaMetricsId] - an override for the metaMetricsId in
           *  the event one is created as part of an asynchronous workflow, such as
           *  awaiting the result of the metametrics opt-in function that generates the
           *  user's metametrics id
           * @property {boolean} [matomoEvent] - is this event a holdover from matomo
           *  that needs further migration? when true, sends the data to a special
           *  segment source that marks the event data as not conforming to our schema
           */

          /**
           * @typedef {object} MetaMetricsEventFragment
           * @property {string} successEvent - The event name to fire when the fragment
           *  is closed in an affirmative action.
           * @property {string} [failureEvent] - The event name to fire when the fragment
           *  is closed with a rejection.
           * @property {string} [initialEvent] - An event name to fire immediately upon
           *  fragment creation. This is useful for building funnels in mixpanel and for
           *  reduction of code duplication.
           * @property {string} category - the event category to use for both the success
           *  and failure events
           * @property {boolean} [persist] - Should this fragment be persisted in
           *  state and progressed after the extension is locked and unlocked.
           * @property {number} [timeout] - Time in seconds the event should be persisted
           *  for. After the timeout the fragment will be closed as abandoned. if not
           *  supplied the fragment is stored indefinitely.
           * @property {number} [lastUpdated] - Date.now() when the fragment was last
           *  updated. Used to determine if the timeout has expired and the fragment
           *  should be closed.
           * @property {object} [properties] - Object of custom values to track, keys in
           *  this object must be in snake_case.
           * @property {object} [sensitiveProperties] - Object of sensitive values to
           *  track. Keys in this object must be in snake_case. These properties will be
           *  sent in an additional event that excludes the user's metaMetricsId
           * @property {number} [revenue] - amount of currency that event creates in
           *  revenue for MetaMask if fragment is successful.
           * @property {string} [currency] - ISO 4127 format currency for events with
           *  revenue, defaults to US dollars
           * @property {number} [value] - Abstract business "value" attributable to
           *  customers who successfully complete this fragment
           * @property {MetaMetricsPageObject} [page] - the page/route that the event
           *  occurred on
           * @property {MetaMetricsReferrerObject} [referrer] - the origin of the dapp
           *  that initiated the event fragment.
           * @property {string} [uniqueIdentifier] - optional argument to override the
           *  automatic generation of UUID for the event fragment. This is useful when
           *  tracking events for subsystems that already generate UUIDs so to avoid
           *  unnecessary lookups and reduce accidental duplication.
           */

          /**
           * Represents the shape of data sent to the segment.track method.
           *
           * @typedef {object} SegmentEventPayload
           * @property {string} [userId] - The metametrics id for the user
           * @property {string} [anonymousId] - An anonymousId that is used to track
           *  sensitive data while preserving anonymity.
           * @property {string} event - name of the event to track
           * @property {object} properties - properties to attach to the event
           * @property {MetaMetricsContext} context - the context the event occurred in
           */

          /**
           * @typedef {object} MetaMetricsPagePayload
           * @property {string} name - The name of the page that was viewed
           * @property {object} [params] - The variadic parts of the page url
           *  example (route: `/asset/:asset`, path: `/asset/ETH`)
           *  params: { asset: 'ETH' }
           * @property {EnvironmentType} environmentType - the environment type that the
           *  page was viewed in
           * @property {MetaMetricsPageObject} [page] - the details of the page
           * @property {MetaMetricsReferrerObject} [referrer] - dapp that triggered the page
           *  view
           */

          /**
           * @typedef {object} MetaMetricsPageOptions
           * @property {boolean} [isOptInPath] - is the current path one of the pages in
           *  the onboarding workflow? If true and participateInMetaMetrics is null track
           *  the page view
           */

          /**
           * @typedef {object} Traits
           * @property {'address_book_entries'} ADDRESS_BOOK_ENTRIES - When the user
           *  adds or modifies addresses in address book the address_book_entries trait
           *  is identified.
           * @property {'ledger_connection_type'} LEDGER_CONNECTION_TYPE - when ledger
           *  live connnection type is changed we identify the ledger_connection_type
           *  trait
           * @property {'networks_added'} NETWORKS_ADDED - when user modifies networks
           *  we identify the networks_added trait
           * @property {'networks_without_ticker'} NETWORKS_WITHOUT_TICKER - when user
           *  modifies networks we identify the networks_without_ticker trait for
           *  networks without a ticker.
           * @property {'nft_autodetection_enabled'} NFT_AUTODETECTION_ENABLED - when Autodetect NFTs
           * feature is toggled we identify the nft_autodetection_enabled trait
           * @property {'number_of_accounts'} NUMBER_OF_ACCOUNTS - when identities
           *  change, we identify the new number_of_accounts trait
           * @property {'number_of_nft_collections'} NUMBER_OF_NFT_COLLECTIONS - user
           *  trait for number of unique NFT addresses
           * @property {'number_of_nfts'} NUMBER_OF_NFTS - user trait for number of all NFT addresses
           * @property {'number_of_tokens'} NUMBER_OF_TOKENS - when the number of tokens change, we
           * identify the new number_of_tokens trait
           * @property {'opensea_api_enabled'} OPENSEA_API_ENABLED - when the OpenSea API is enabled
           * we identify the opensea_api_enabled trait
           * @property {'three_box_enabled'} THREE_BOX_ENABLED - When 3Box feature is
           *  toggled we identify the 3box_enabled trait. This trait has been deprecated.
           * @property {'theme'} THEME - when the user's theme changes we identify the theme trait
           * @property {'token_detection_enabled'} TOKEN_DETECTION_ENABLED - when token detection feature is toggled we
           * identify the token_detection_enabled trait
           * @property {'install_date_ext'} INSTALL_DATE_EXT - when the user installed the extension
           */

          /**
           *
           * @type {Traits}
           */
          const TRAITS = {
            ADDRESS_BOOK_ENTRIES: 'address_book_entries',
            INSTALL_DATE_EXT: 'install_date_ext',
            LEDGER_CONNECTION_TYPE: 'ledger_connection_type',
            NETWORKS_ADDED: 'networks_added',
            NETWORKS_WITHOUT_TICKER: 'networks_without_ticker',
            NFT_AUTODETECTION_ENABLED: 'nft_autodetection_enabled',
            NUMBER_OF_ACCOUNTS: 'number_of_accounts',
            NUMBER_OF_NFT_COLLECTIONS: 'number_of_nft_collections',
            NUMBER_OF_NFTS: 'number_of_nfts',
            NUMBER_OF_TOKENS: 'number_of_tokens',
            OPENSEA_API_ENABLED: 'opensea_api_enabled',
            THEME: 'theme',
            THREE_BOX_ENABLED: 'three_box_enabled',
            TOKEN_DETECTION_ENABLED: 'token_detection_enabled'
          };
          /**
           * @typedef {object} MetaMetricsTraits
           * @property {number} [address_book_entries] - The number of entries in the
           *  user's address book.
           * @property {'ledgerLive' | 'webhid' | 'u2f'} [ledger_connection_type] - the
           *  type of ledger connection set by user preference.
           * @property {Array<string>} [networks_added] - An array consisting of chainIds
           *  that indicate the networks a user has added to their MetaMask.
           * @property {Array<string>} [networks_without_ticker] - An array consisting of
           *  chainIds that indicate the networks added by the user that do not have a
           *  ticker.
           * @property {number} [nft_autodetection_enabled] - does the user have the
           * use collection/nft detection enabled?
           * @property {number} [number_of_accounts] - A number representing the number
           *  of identities(accounts) added to the user's MetaMask.
           * @property {number} [number_of_nft_collections] - A number representing the
           *  amount of different NFT collections the user possesses an NFT from.
           * @property {number} [number_of_nfts] - A number representing the
           *  amount of all NFTs the user possesses across all networks and accounts.
           * @property {number} [number_of_tokens] - The total number of token contracts
           *  the user has across all networks and accounts.
           * @property {boolean} [opensea_api_enabled] - does the user have the OpenSea
           *  API enabled?
           * @property {boolean} [three_box_enabled] - Does the user have 3box sync
           *  enabled? (deprecated)
           * @property {string} [theme] - which theme the user has selected
           * @property {boolean} [token_detection_enabled] - does the user have token detection is enabled?
           */
          // Mixpanel converts the zero address value to a truly anonymous event, which
          // speeds up reporting

          exports.TRAITS = TRAITS;
          const METAMETRICS_ANONYMOUS_ID = '0x0000000000000000';
          /**
           * This object is used to identify events that are triggered by the background
           * process.
           *
           * @type {MetaMetricsPageObject}
           */

          exports.METAMETRICS_ANONYMOUS_ID = METAMETRICS_ANONYMOUS_ID;
          const METAMETRICS_BACKGROUND_PAGE_OBJECT = {
            path: '/background-process',
            title: 'Background Process',
            url: '/background-process'
          };
          /**
           * @typedef {object} SegmentInterface
           * @property {SegmentEventPayload[]} queue - A queue of events to be sent when
           *  the flushAt limit has been reached, or flushInterval occurs
           * @property {() => void} flush - Immediately flush the queue, resetting it to
           *  an empty array and sending the pending events to Segment
           * @property {(
           *  payload: SegmentEventPayload,
           *  callback: (err?: Error) => void
           * ) => void} track - Track an event with Segment, using the internal batching
           *  mechanism to optimize network requests
           * @property {(payload: object) => void} page - Track a page view with Segment
           * @property {() => void} identify - Identify an anonymous user. We do not
           *  currently use this method.
           */

          exports.METAMETRICS_BACKGROUND_PAGE_OBJECT = METAMETRICS_BACKGROUND_PAGE_OBJECT;
          const REJECT_NOTFICIATION_CLOSE = 'Cancel Via Notification Close';
          exports.REJECT_NOTFICIATION_CLOSE = REJECT_NOTFICIATION_CLOSE;
          const REJECT_NOTFICIATION_CLOSE_SIG = 'Cancel Sig Request Via Notification Close';
          /**
           * EVENTS
           */

          exports.REJECT_NOTFICIATION_CLOSE_SIG = REJECT_NOTFICIATION_CLOSE_SIG;
          const EVENT_NAMES = {
            ACCOUNT_ADDED: 'Account Added',
            ACCOUNT_ADD_SELECTED: 'Account Add Selected',
            ACCOUNT_ADD_FAILED: 'Account Add Failed',
            ACCOUNT_PASSWORD_CREATED: 'Wallet Password Created',
            ACCOUNT_RESET: 'Account Reset',
            APP_INSTALLED: 'App Installed',
            APP_UNLOCKED: 'App Unlocked',
            APP_UNLOCKED_FAILED: 'App Unlocked Failed',
            APP_WINDOW_EXPANDED: 'App Window Expanded',
            DECRYPTION_APPROVED: 'Decryption Approved',
            DECRYPTION_REJECTED: 'Decryption Rejected',
            DECRYPTION_REQUESTED: 'Decryption Requested',
            ENCRYPTION_PUBLIC_KEY_APPROVED: 'Encryption Approved',
            ENCRYPTION_PUBLIC_KEY_REJECTED: 'Encryption Rejected',
            ENCRYPTION_PUBLIC_KEY_REQUESTED: 'Encryption Requested',
            EXTERNAL_LINK_CLICKED: 'External Link Clicked',
            KEY_EXPORT_SELECTED: 'Key Export Selected',
            KEY_EXPORT_REQUESTED: 'Key Export Requested',
            KEY_EXPORT_FAILED: 'Key Export Failed',
            KEY_EXPORT_CANCELED: 'Key Export Canceled',
            KEY_EXPORT_REVEALED: 'Key Material Revealed',
            KEY_EXPORT_COPIED: 'Key Material Copied',
            METRICS_OPT_IN: 'Metrics Opt In',
            METRICS_OPT_OUT: 'Metrics Opt Out',
            NAV_ACCOUNT_MENU_OPENED: 'Account Menu Opened',
            NAV_ACCOUNT_DETAILS_OPENED: 'Account Details Opened',
            NAV_CONNECTED_SITES_OPENED: 'Connected Sites Opened',
            NAV_MAIN_MENU_OPENED: 'Main Menu Opened',
            NAV_NETWORK_MENU_OPENED: 'Network Menu Opened',
            NAV_SETTINGS_OPENED: 'Settings Opened',
            NAV_ACCOUNT_SWITCHED: 'Account Switched',
            NAV_NETWORK_SWITCHED: 'Network Switched',
            NAV_BUY_BUTTON_CLICKED: 'Buy Button Clicked',
            NAV_SEND_BUTTON_CLICKED: 'Send Button Clicked',
            NAV_SWAP_BUTTON_CLICKED: 'Swap Button Clicked',
            SRP_TO_CONFIRM_BACKUP: 'SRP Backup Confirm Displayed',
            WALLET_SETUP_STARTED: 'Wallet Setup Selected',
            WALLET_SETUP_CANCELED: 'Wallet Setup Canceled',
            WALLET_SETUP_FAILED: 'Wallet Setup Failed',
            WALLET_CREATED: 'Wallet Created',
            NFT_ADDED: 'NFT Added',
            ONRAMP_PROVIDER_SELECTED: 'On-ramp Provider Selected',
            PERMISSIONS_APPROVED: 'Permissions Approved',
            PERMISSIONS_REJECTED: 'Permissions Rejected',
            PERMISSIONS_REQUESTED: 'Permissions Requested',
            PORTFOLIO_LINK_CLICKED: 'Portfolio Link Clicked',
            PUBLIC_ADDRESS_COPIED: 'Public Address Copied',
            PROVIDER_METHOD_CALLED: 'Provider Method Called',
            SIGNATURE_APPROVED: 'Signature Approved',
            SIGNATURE_REJECTED: 'Signature Rejected',
            SIGNATURE_REQUESTED: 'Signature Requested',
            TOKEN_IMPORT_BUTTON_CLICKED: 'Import Token Button Clicked',
            TOKEN_SCREEN_OPENED: 'Token Screen Opened',
            SUPPORT_LINK_CLICKED: 'Support Link Clicked',
            TOKEN_ADDED: 'Token Added',
            TOKEN_DETECTED: 'Token Detected',
            TOKEN_HIDDEN: 'Token Hidden',
            TOKEN_IMPORT_CANCELED: 'Token Import Canceled',
            TOKEN_IMPORT_CLICKED: 'Token Import Clicked'
          };
          exports.EVENT_NAMES = EVENT_NAMES;
          const EVENT = {
            ACCOUNT_TYPES: {
              DEFAULT: 'metamask',
              IMPORTED: 'imported',
              HARDWARE: 'hardware'
            },
            ACCOUNT_IMPORT_TYPES: {
              JSON: 'json',
              PRIVATE_KEY: 'private_key',
              SRP: 'srp'
            },
            CATEGORIES: {
              ACCOUNTS: 'Accounts',
              APP: 'App',
              AUTH: 'Auth',
              BACKGROUND: 'Background',
              ERROR: 'Error',
              FOOTER: 'Footer',
              HOME: 'Home',
              INPAGE_PROVIDER: 'inpage_provider',
              KEYS: 'Keys',
              MESSAGES: 'Messages',
              NAVIGATION: 'Navigation',
              NETWORK: 'Network',
              ONBOARDING: 'Onboarding',
              RETENTION: 'Retention',
              SETTINGS: 'Settings',
              SNAPS: 'Snaps',
              SWAPS: 'Swaps',
              TRANSACTIONS: 'Transactions',
              WALLET: 'Wallet'
            },
            EXTERNAL_LINK_TYPES: {
              TRANSACTION_BLOCK_EXPLORER: 'Transaction Block Explorer',
              BLOCK_EXPLORER: 'Block Explorer',
              ACCOUNT_TRACKER: 'Account Tracker',
              TOKEN_TRACKER: 'Token Tracker'
            },
            KEY_TYPES: {
              PKEY: 'private_key',
              SRP: 'srp'
            },
            ONRAMP_PROVIDER_TYPES: {
              COINBASE: 'coinbase',
              MOONPAY: 'moonpay',
              WYRE: 'wyre',
              TRANSAK: 'transak',
              SELF_DEPOSIT: 'direct_deposit'
            },
            SOURCE: {
              NETWORK: {
                CUSTOM_NETWORK_FORM: 'custom_network_form',
                POPULAR_NETWORK_LIST: 'popular_network_list'
              },
              SWAPS: {
                MAIN_VIEW: 'Main View',
                TOKEN_VIEW: 'Token View'
              },
              TOKEN: {
                CUSTOM: 'custom',
                DAPP: 'dapp',
                DETECTED: 'detected',
                LIST: 'list'
              },
              TRANSACTION: {
                DAPP: 'dapp',
                USER: 'user'
              }
            },
            LOCATION: {
              TOKEN_DETAILS: 'token_details',
              TOKEN_DETECTION: 'token_detection',
              TOKEN_MENU: 'token_menu'
            }
          }; // Values below (e.g. 'location') can be used in the "properties"
          // tracking object as keys, e.g. { location: 'Home' }

          exports.EVENT = EVENT;
          const CONTEXT_PROPS = {
            PAGE_TITLE: 'location'
          };
          exports.CONTEXT_PROPS = CONTEXT_PROPS;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", { "lodash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\network.ts
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.infuraProjectId = exports.getRpcUrl = exports.UNSUPPORTED_RPC_METHODS = exports.TEST_NETWORK_TICKER_MAP = exports.TEST_ETH_TOKEN_IMAGE_URL = exports.TEST_CHAINS = exports.SEPOLIA_RPC_URL = exports.SEPOLIA_DISPLAY_NAME = exports.POLYGON_DISPLAY_NAME = exports.PALM_TOKEN_IMAGE_URL = exports.PALM_DISPLAY_NAME = exports.OPTIMISM_TOKEN_IMAGE_URL = exports.OPTIMISM_DISPLAY_NAME = exports.NETWORK_TYPES = exports.NETWORK_TO_NAME_MAP = exports.NETWORK_NAMES = exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = exports.NETWORK_IDS = exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = exports.MAX_SAFE_CHAIN_ID = exports.MATIC_TOKEN_IMAGE_URL = exports.MAINNET_RPC_URL = exports.MAINNET_DISPLAY_NAME = exports.LOCALHOST_RPC_URL = exports.LOCALHOST_DISPLAY_NAME = exports.IPFS_DEFAULT_GATEWAY_URL = exports.INFURA_PROVIDER_TYPES = exports.INFURA_BLOCKED_KEY = exports.HARMONY_ONE_TOKEN_IMAGE_URL = exports.HARMONY_DISPLAY_NAME = exports.HARDFORKS = exports.GOERLI_RPC_URL = exports.GOERLI_DISPLAY_NAME = exports.FTM_TOKEN_IMAGE_URL = exports.FEATURED_RPCS = exports.FANTOM_DISPLAY_NAME = exports.ETH_TOKEN_IMAGE_URL = exports.CURRENCY_SYMBOLS = exports.CHAIN_ID_TO_TYPE_MAP = exports.CHAIN_ID_TO_RPC_URL_MAP = exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = exports.CHAIN_ID_TO_NETWORK_ID_MAP = exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = exports.CHAIN_IDS = exports.BUYABLE_CHAINS_MAP = exports.BUILT_IN_NETWORKS = exports.BSC_DISPLAY_NAME = exports.BNB_TOKEN_IMAGE_URL = exports.BNB_DISPLAY_NAME = exports.AVAX_TOKEN_IMAGE_URL = exports.AVALANCHE_DISPLAY_NAME = exports.AURORA_TOKEN_IMAGE_URL = exports.AURORA_DISPLAY_NAME = exports.ARBITRUM_DISPLAY_NAME = exports.AETH_TOKEN_IMAGE_URL = void 0;

          var _lodash = require("lodash");

          /**
           * Throughout the extension we set the current provider by referencing its
           * "type", which can be any of the values in the below object. These values
           * represent the built-in networks of MetaMask, including test nets, as well
           * as "rpc" which is the "type" of a custom network added by the user or via
           * wallet_addEthereumChain.
           */
          const NETWORK_TYPES = {
            GOERLI: 'goerli',
            LOCALHOST: 'localhost',
            MAINNET: 'mainnet',
            RPC: 'rpc',
            SEPOLIA: 'sepolia'
          };
          /**
           * An object containing shortcut names for any non-builtin network. We need
           * this to be able to differentiate between networks that require custom
           * sections of code for our various features, such as swaps or token lists.
           */

          exports.NETWORK_TYPES = NETWORK_TYPES;
          const NETWORK_NAMES = {
            HOMESTEAD: 'homestead'
          };
          /**
           * The Network ID for our builtin networks. This is the decimal equivalent of
           * the chain id for the network, but is expresssed as a string. Many moons ago
           * the decision was made on the extension team to expressly use chainId with
           * hex encoding over network id. Consider that when accessing this object. Note
           * for cross product purposes: alignment with mobile on this matter has not
           * been fully achieved, thus it is possible for some dependencies to still
           * ask for or require network id.
           */

          exports.NETWORK_NAMES = NETWORK_NAMES;
          const NETWORK_IDS = {
            MAINNET: '1',
            GOERLI: '5',
            LOCALHOST: '1337',
            SEPOLIA: '11155111'
          };
          /**
           * An object containing all of the chain ids for networks both built in and
           * those that we have added custom code to support our feature set.
           */

          exports.NETWORK_IDS = NETWORK_IDS;
          const CHAIN_IDS = {
            MAINNET: '0x1',
            GOERLI: '0x5',
            LOCALHOST: '0x539',
            BSC: '0x38',
            OPTIMISM: '0xa',
            OPTIMISM_TESTNET: '0x1a4',
            POLYGON: '0x89',
            AVALANCHE: '0xa86a',
            FANTOM: '0xfa',
            CELO: '0xa4ec',
            ARBITRUM: '0xa4b1',
            HARMONY: '0x63564c40',
            PALM: '0x2a15c308d',
            SEPOLIA: '0xaa36a7',
            AURORA: '0x4e454152'
          };
          /**
           * The largest possible chain ID we can handle.
           * Explanation: https://gist.github.com/rekmarks/a47bd5f2525936c4b8eee31a16345553
           */

          exports.CHAIN_IDS = CHAIN_IDS;
          const MAX_SAFE_CHAIN_ID = 4503599627370476;
          exports.MAX_SAFE_CHAIN_ID = MAX_SAFE_CHAIN_ID;
          const MAINNET_DISPLAY_NAME = 'Ethereum Mainnet';
          exports.MAINNET_DISPLAY_NAME = MAINNET_DISPLAY_NAME;
          const GOERLI_DISPLAY_NAME = 'Goerli';
          exports.GOERLI_DISPLAY_NAME = GOERLI_DISPLAY_NAME;
          const SEPOLIA_DISPLAY_NAME = 'Sepolia';
          exports.SEPOLIA_DISPLAY_NAME = SEPOLIA_DISPLAY_NAME;
          const LOCALHOST_DISPLAY_NAME = 'Localhost 8545';
          exports.LOCALHOST_DISPLAY_NAME = LOCALHOST_DISPLAY_NAME;
          const BSC_DISPLAY_NAME = 'Binance Smart Chain';
          exports.BSC_DISPLAY_NAME = BSC_DISPLAY_NAME;
          const POLYGON_DISPLAY_NAME = 'Polygon';
          exports.POLYGON_DISPLAY_NAME = POLYGON_DISPLAY_NAME;
          const AVALANCHE_DISPLAY_NAME = 'Avalanche Network C-Chain';
          exports.AVALANCHE_DISPLAY_NAME = AVALANCHE_DISPLAY_NAME;
          const ARBITRUM_DISPLAY_NAME = 'Arbitrum One';
          exports.ARBITRUM_DISPLAY_NAME = ARBITRUM_DISPLAY_NAME;
          const BNB_DISPLAY_NAME = 'BNB Smart Chain (previously Binance Smart Chain Mainnet)';
          exports.BNB_DISPLAY_NAME = BNB_DISPLAY_NAME;
          const OPTIMISM_DISPLAY_NAME = 'Optimism';
          exports.OPTIMISM_DISPLAY_NAME = OPTIMISM_DISPLAY_NAME;
          const FANTOM_DISPLAY_NAME = 'Fantom Opera';
          exports.FANTOM_DISPLAY_NAME = FANTOM_DISPLAY_NAME;
          const HARMONY_DISPLAY_NAME = 'Harmony Mainnet Shard 0';
          exports.HARMONY_DISPLAY_NAME = HARMONY_DISPLAY_NAME;
          const PALM_DISPLAY_NAME = 'Palm';
          exports.PALM_DISPLAY_NAME = PALM_DISPLAY_NAME;
          const AURORA_DISPLAY_NAME = 'Aurora Mainnet';
          exports.AURORA_DISPLAY_NAME = AURORA_DISPLAY_NAME;
          const infuraProjectId = "bde1e349aa3c4803a5c3a71f5623ecce";
          exports.infuraProjectId = infuraProjectId;

          const getRpcUrl = ({
            network,
            excludeProjectId = false
          }) => `https://${network}.infura.io/v3/${excludeProjectId ? '' : infuraProjectId}`;

          exports.getRpcUrl = getRpcUrl;
          const MAINNET_RPC_URL = getRpcUrl({
            network: NETWORK_TYPES.MAINNET
          });
          exports.MAINNET_RPC_URL = MAINNET_RPC_URL;
          const GOERLI_RPC_URL = getRpcUrl({
            network: NETWORK_TYPES.GOERLI
          });
          exports.GOERLI_RPC_URL = GOERLI_RPC_URL;
          const SEPOLIA_RPC_URL = getRpcUrl({
            network: NETWORK_TYPES.SEPOLIA
          });
          exports.SEPOLIA_RPC_URL = SEPOLIA_RPC_URL;
          const LOCALHOST_RPC_URL = 'http://localhost:8545';
          /**
           * An object containing the token symbols for various tokens that are either
           * native currencies or those that have been special cased by the extension
           * for supporting our feature set.
           */

          exports.LOCALHOST_RPC_URL = LOCALHOST_RPC_URL;
          const CURRENCY_SYMBOLS = {
            ARBITRUM: 'ETH',
            AURORA: 'Aurora ETH',
            AVALANCHE: 'AVAX',
            BNB: 'BNB',
            BUSD: 'BUSD',
            CELO: 'CELO',
            DAI: 'DAI',
            ETH: 'ETH',
            FANTOM: 'FTM',
            HARMONY: 'ONE',
            PALM: 'PALM',
            MATIC: 'MATIC',
            TEST_ETH: 'TESTETH',
            USDC: 'USDC',
            USDT: 'USDT',
            WETH: 'WETH',
            OPTIMISM: 'OP'
          };
          /**
           * An object containing the token symbols for various tokens that are supported
           * on different on ramp providers. This object is meant for internal consumption,
           * hence why it is not exported.
           */

          exports.CURRENCY_SYMBOLS = CURRENCY_SYMBOLS;
          const SUPPORTED_CURRENCY_SYMBOLS = {
            ...CURRENCY_SYMBOLS,
            '1INCH': '1INCH',
            AAVE: 'AAVE',
            ABT: 'ABT',
            ACH: 'ACH',
            AGEUR: 'AGEUR',
            AGLD: 'AGLD',
            AMP: 'AMP',
            ANKR: 'ANKR',
            APE: 'APE',
            ARPA: 'ARPA',
            ASM: 'ASM',
            AUCTION: 'AUCTION',
            AXS: 'AXS',
            AVAX: 'AVAX',
            AVAXC: 'AVAXC',
            AVAXCUSDC: 'AVAXCUSDC',
            BADGER: 'BADGER',
            BAL: 'BAL',
            BAND: 'BAND',
            BAT: 'BAT',
            BNT: 'BNT',
            BOBA: 'BOBA',
            BOND: 'BOND',
            BTRST: 'BTRST',
            CHAIN: 'CHAIN',
            CHZ: 'CHZ',
            CLV: 'CLV',
            COMP: 'COMP',
            COTI: 'COTI',
            CRO: 'CRO',
            CRV: 'CRV',
            CTSI: 'CTSI',
            CVC: 'CVC',
            DAO: 'DAO',
            DDX: 'DDX',
            DNT: 'DNT',
            ENJ: 'ENJ',
            ENS: 'ENS',
            EURT: 'EURT',
            FARM: 'FARM',
            FET: 'FET',
            FORTH: 'FORTH',
            FX: 'FX',
            GNO: 'GNO',
            GRT: 'GRT',
            GTC: 'GTC',
            GTH: 'GTH',
            GUSD: 'GUSD',
            GYEN: 'GYEN',
            HEX: 'HEX',
            IOTX: 'IOTX',
            IMX: 'IMX',
            JASMY: 'JASMY',
            KEEP: 'KEEP',
            KNC: 'KNC',
            KRL: 'KRL',
            LCX: 'LCX',
            LINK: 'LINK',
            LPT: 'LPT',
            LRC: 'LRC',
            MANA: 'MANA',
            MASK: 'MASK',
            MINDS: 'MINDS',
            MIR: 'MIR',
            MKR: 'MKR',
            MLN: 'MLN',
            MTL: 'MTL',
            MUSDC: 'mUSDC',
            NKN: 'NKN',
            NMR: 'NMR',
            NU: 'NU',
            OGN: 'OGN',
            OMG: 'OMG',
            ORN: 'ORN',
            OXT: 'OXT',
            PAX: 'PAX',
            PERP: 'PERP',
            PLA: 'PLA',
            POLS: 'POLS',
            POLY: 'POLY',
            QNT: 'QNT',
            QUICK: 'QUICK',
            RAD: 'RAD',
            RAI: 'RAI',
            RARI: 'RARI',
            REN: 'REN',
            REP: 'REP',
            REQ: 'REQ',
            RLC: 'RLC',
            RLY: 'RLY',
            SAND: 'SAND',
            SHIB: 'SHIB',
            SKL: 'SKL',
            SNX: 'SNX',
            SPA: 'SPA',
            STETH: 'STETH',
            STORJ: 'STORJ',
            SUKU: 'SUKU',
            SUSHI: 'SUSHI',
            SWAP: 'SWAP',
            SWFTC: 'SWFTC',
            TRAC: 'TRAC',
            TRB: 'TRB',
            TRIBE: 'TRIBE',
            TRU: 'TRU',
            TXL: 'TXL',
            UMA: 'UMA',
            UNI: 'UNI',
            USDS: 'USDS',
            VRA: 'VRA',
            WBTC: 'WBTC',
            WCFG: 'WCFG',
            XYO: 'XYO',
            YFII: 'YFII',
            YFI: 'YFI',
            YLD: 'YLD',
            ZRX: 'ZRX',
            ZUSD: 'ZUSD'
          };
          const ETH_TOKEN_IMAGE_URL = './images/eth_logo.svg';
          exports.ETH_TOKEN_IMAGE_URL = ETH_TOKEN_IMAGE_URL;
          const TEST_ETH_TOKEN_IMAGE_URL = './images/black-eth-logo.svg';
          exports.TEST_ETH_TOKEN_IMAGE_URL = TEST_ETH_TOKEN_IMAGE_URL;
          const BNB_TOKEN_IMAGE_URL = './images/bnb.png';
          exports.BNB_TOKEN_IMAGE_URL = BNB_TOKEN_IMAGE_URL;
          const MATIC_TOKEN_IMAGE_URL = './images/matic-token.png';
          exports.MATIC_TOKEN_IMAGE_URL = MATIC_TOKEN_IMAGE_URL;
          const AVAX_TOKEN_IMAGE_URL = './images/avax-token.png';
          exports.AVAX_TOKEN_IMAGE_URL = AVAX_TOKEN_IMAGE_URL;
          const AETH_TOKEN_IMAGE_URL = './images/arbitrum.svg';
          exports.AETH_TOKEN_IMAGE_URL = AETH_TOKEN_IMAGE_URL;
          const FTM_TOKEN_IMAGE_URL = './images/fantom-opera.svg';
          exports.FTM_TOKEN_IMAGE_URL = FTM_TOKEN_IMAGE_URL;
          const HARMONY_ONE_TOKEN_IMAGE_URL = './images/harmony-one.svg';
          exports.HARMONY_ONE_TOKEN_IMAGE_URL = HARMONY_ONE_TOKEN_IMAGE_URL;
          const OPTIMISM_TOKEN_IMAGE_URL = './images/optimism.svg';
          exports.OPTIMISM_TOKEN_IMAGE_URL = OPTIMISM_TOKEN_IMAGE_URL;
          const PALM_TOKEN_IMAGE_URL = './images/palm.svg';
          exports.PALM_TOKEN_IMAGE_URL = PALM_TOKEN_IMAGE_URL;
          const AURORA_TOKEN_IMAGE_URL = './images/aurora.png';
          exports.AURORA_TOKEN_IMAGE_URL = AURORA_TOKEN_IMAGE_URL;
          const INFURA_PROVIDER_TYPES = [NETWORK_TYPES.MAINNET, NETWORK_TYPES.GOERLI, NETWORK_TYPES.SEPOLIA];
          exports.INFURA_PROVIDER_TYPES = INFURA_PROVIDER_TYPES;
          const TEST_CHAINS = [CHAIN_IDS.GOERLI, CHAIN_IDS.SEPOLIA, CHAIN_IDS.LOCALHOST];
          exports.TEST_CHAINS = TEST_CHAINS;

          const typedCapitalize = k => (0, _lodash.capitalize)(k);

          const TEST_NETWORK_TICKER_MAP = {
            [NETWORK_TYPES.GOERLI]: `${typedCapitalize(NETWORK_TYPES.GOERLI)}${CURRENCY_SYMBOLS.ETH}`,
            [NETWORK_TYPES.SEPOLIA]: `${typedCapitalize(NETWORK_TYPES.SEPOLIA)}${CURRENCY_SYMBOLS.ETH}`
          };
          /**
           * Map of all build-in Infura networks to their network, ticker and chain IDs.
           */

          exports.TEST_NETWORK_TICKER_MAP = TEST_NETWORK_TICKER_MAP;
          const BUILT_IN_NETWORKS = {
            [NETWORK_TYPES.GOERLI]: {
              networkId: NETWORK_IDS.GOERLI,
              chainId: CHAIN_IDS.GOERLI,
              ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.GOERLI]
            },
            [NETWORK_TYPES.SEPOLIA]: {
              networkId: NETWORK_IDS.SEPOLIA,
              chainId: CHAIN_IDS.SEPOLIA,
              ticker: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA]
            },
            [NETWORK_TYPES.MAINNET]: {
              networkId: NETWORK_IDS.MAINNET,
              chainId: CHAIN_IDS.MAINNET
            },
            [NETWORK_TYPES.LOCALHOST]: {
              networkId: NETWORK_IDS.LOCALHOST,
              chainId: CHAIN_IDS.LOCALHOST
            }
          };
          exports.BUILT_IN_NETWORKS = BUILT_IN_NETWORKS;
          const NETWORK_TO_NAME_MAP = {
            [NETWORK_TYPES.MAINNET]: MAINNET_DISPLAY_NAME,
            [NETWORK_TYPES.GOERLI]: GOERLI_DISPLAY_NAME,
            [NETWORK_TYPES.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
            [NETWORK_TYPES.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
            [NETWORK_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
            [NETWORK_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
            [NETWORK_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
            [NETWORK_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME,
            [CHAIN_IDS.GOERLI]: GOERLI_DISPLAY_NAME,
            [CHAIN_IDS.SEPOLIA]: SEPOLIA_DISPLAY_NAME,
            [CHAIN_IDS.MAINNET]: MAINNET_DISPLAY_NAME,
            [CHAIN_IDS.LOCALHOST]: LOCALHOST_DISPLAY_NAME
          };
          exports.NETWORK_TO_NAME_MAP = NETWORK_TO_NAME_MAP;
          const CHAIN_ID_TO_TYPE_MAP = {
            [CHAIN_IDS.MAINNET]: NETWORK_TYPES.MAINNET,
            [CHAIN_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
            [CHAIN_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
            [CHAIN_IDS.LOCALHOST]: NETWORK_TYPES.LOCALHOST
          };
          exports.CHAIN_ID_TO_TYPE_MAP = CHAIN_ID_TO_TYPE_MAP;
          const CHAIN_ID_TO_RPC_URL_MAP = {
            [CHAIN_IDS.GOERLI]: GOERLI_RPC_URL,
            [CHAIN_IDS.SEPOLIA]: SEPOLIA_RPC_URL,
            [CHAIN_IDS.MAINNET]: MAINNET_RPC_URL,
            [CHAIN_IDS.LOCALHOST]: LOCALHOST_RPC_URL
          };
          exports.CHAIN_ID_TO_RPC_URL_MAP = CHAIN_ID_TO_RPC_URL_MAP;
          const CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = {
            [CHAIN_IDS.MAINNET]: ETH_TOKEN_IMAGE_URL,
            [CHAIN_IDS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
            [CHAIN_IDS.BSC]: BNB_TOKEN_IMAGE_URL,
            [CHAIN_IDS.POLYGON]: MATIC_TOKEN_IMAGE_URL,
            [CHAIN_IDS.ARBITRUM]: AETH_TOKEN_IMAGE_URL,
            [CHAIN_IDS.FANTOM]: FTM_TOKEN_IMAGE_URL,
            [CHAIN_IDS.HARMONY]: HARMONY_ONE_TOKEN_IMAGE_URL,
            [CHAIN_IDS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL,
            [CHAIN_IDS.PALM]: PALM_TOKEN_IMAGE_URL,
            [CHAIN_IDS.AURORA]: AURORA_TOKEN_IMAGE_URL
          };
          exports.CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP = CHAIN_ID_TO_NETWORK_IMAGE_URL_MAP;
          const NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = {
            [NETWORK_IDS.GOERLI]: NETWORK_TYPES.GOERLI,
            [NETWORK_IDS.SEPOLIA]: NETWORK_TYPES.SEPOLIA,
            [NETWORK_IDS.MAINNET]: NETWORK_NAMES.HOMESTEAD
          };
          exports.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP = NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP;
          const CHAIN_ID_TO_NETWORK_ID_MAP = {
            [CHAIN_IDS.MAINNET]: NETWORK_IDS.MAINNET,
            [CHAIN_IDS.GOERLI]: NETWORK_IDS.GOERLI,
            [CHAIN_IDS.SEPOLIA]: NETWORK_IDS.SEPOLIA,
            [CHAIN_IDS.LOCALHOST]: NETWORK_IDS.LOCALHOST
          };
          exports.CHAIN_ID_TO_NETWORK_ID_MAP = CHAIN_ID_TO_NETWORK_ID_MAP;
          const NATIVE_CURRENCY_TOKEN_IMAGE_MAP = {
            [CURRENCY_SYMBOLS.ETH]: ETH_TOKEN_IMAGE_URL,
            [CURRENCY_SYMBOLS.TEST_ETH]: TEST_ETH_TOKEN_IMAGE_URL,
            [CURRENCY_SYMBOLS.BNB]: BNB_TOKEN_IMAGE_URL,
            [CURRENCY_SYMBOLS.MATIC]: MATIC_TOKEN_IMAGE_URL,
            [CURRENCY_SYMBOLS.AVALANCHE]: AVAX_TOKEN_IMAGE_URL,
            [CURRENCY_SYMBOLS.OPTIMISM]: OPTIMISM_TOKEN_IMAGE_URL
          };
          exports.NATIVE_CURRENCY_TOKEN_IMAGE_MAP = NATIVE_CURRENCY_TOKEN_IMAGE_MAP;
          const INFURA_BLOCKED_KEY = 'countryBlocked';
          /**
           * Hardforks are points in the chain where logic is changed significantly
           * enough where there is a fork and the new fork becomes the active chain.
           * These constants are presented in chronological order starting with BERLIN
           * because when we first needed to track the hardfork we had launched support
           * for EIP-2718 (where transactions can have types and different shapes) and
           * EIP-2930 (optional access lists), which were included in BERLIN.
           *
           * BERLIN - forked at block number 12,244,000, included typed transactions and
           * optional access lists
           * LONDON - future, upcoming fork that introduces the baseFeePerGas, an amount
           * of the ETH transaction fees that will be burned instead of given to the
           * miner. This change necessitated the third type of transaction envelope to
           * specify maxFeePerGas and maxPriorityFeePerGas moving the fee bidding system
           * to a second price auction model.
           */

          exports.INFURA_BLOCKED_KEY = INFURA_BLOCKED_KEY;
          const HARDFORKS = {
            BERLIN: 'berlin',
            LONDON: 'london'
          };
          exports.HARDFORKS = HARDFORKS;
          const CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = {
            [CHAIN_IDS.OPTIMISM]: 1,
            [CHAIN_IDS.OPTIMISM_TESTNET]: 1
          };
          /**
           * Ethereum JSON-RPC methods that are known to exist but that we intentionally
           * do not support.
           */

          exports.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP = CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP;
          const UNSUPPORTED_RPC_METHODS = new Set([// This is implemented later in our middleware stack – specifically, in
            // eth-json-rpc-middleware – but our UI does not support it.
            'eth_signTransaction']);
          exports.UNSUPPORTED_RPC_METHODS = UNSUPPORTED_RPC_METHODS;
          const IPFS_DEFAULT_GATEWAY_URL = 'dweb.link'; // The first item in transakCurrencies must be the
          // default crypto currency for the network

          exports.IPFS_DEFAULT_GATEWAY_URL = IPFS_DEFAULT_GATEWAY_URL;
          const BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME = 'ethereum';
          const BUYABLE_CHAINS_MAP = {
            [CHAIN_IDS.MAINNET]: {
              nativeCurrency: CURRENCY_SYMBOLS.ETH,
              network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME,
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS['1INCH'], SUPPORTED_CURRENCY_SYMBOLS.AAVE, SUPPORTED_CURRENCY_SYMBOLS.AGEUR, SUPPORTED_CURRENCY_SYMBOLS.BUSD, SUPPORTED_CURRENCY_SYMBOLS.CHAIN, SUPPORTED_CURRENCY_SYMBOLS.CLV, SUPPORTED_CURRENCY_SYMBOLS.COMP, SUPPORTED_CURRENCY_SYMBOLS.CTSI, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.DAO, SUPPORTED_CURRENCY_SYMBOLS.ENJ, SUPPORTED_CURRENCY_SYMBOLS.EURT, SUPPORTED_CURRENCY_SYMBOLS.GTH, SUPPORTED_CURRENCY_SYMBOLS.HEX, SUPPORTED_CURRENCY_SYMBOLS.LINK, SUPPORTED_CURRENCY_SYMBOLS.MANA, SUPPORTED_CURRENCY_SYMBOLS.MASK, SUPPORTED_CURRENCY_SYMBOLS.MINDS, SUPPORTED_CURRENCY_SYMBOLS.MKR, SUPPORTED_CURRENCY_SYMBOLS.PLA, SUPPORTED_CURRENCY_SYMBOLS.POLS, SUPPORTED_CURRENCY_SYMBOLS.SAND, SUPPORTED_CURRENCY_SYMBOLS.STETH, SUPPORTED_CURRENCY_SYMBOLS.SUSHI, SUPPORTED_CURRENCY_SYMBOLS.SWAP, SUPPORTED_CURRENCY_SYMBOLS.TXL, SUPPORTED_CURRENCY_SYMBOLS.UNI, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.VRA, SUPPORTED_CURRENCY_SYMBOLS.WBTC, SUPPORTED_CURRENCY_SYMBOLS.YLD],
              moonPay: {
                defaultCurrencyCode: SUPPORTED_CURRENCY_SYMBOLS.ETH,
                showOnlyCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.ORN, SUPPORTED_CURRENCY_SYMBOLS.WETH, SUPPORTED_CURRENCY_SYMBOLS.IMX]
              },
              wyre: {
                srn: 'ethereum',
                currencyCode: CURRENCY_SYMBOLS.ETH,
                currencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS.AAVE, SUPPORTED_CURRENCY_SYMBOLS.BAT, SUPPORTED_CURRENCY_SYMBOLS.BUSD, SUPPORTED_CURRENCY_SYMBOLS.COMP, SUPPORTED_CURRENCY_SYMBOLS.CRV, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.GUSD, SUPPORTED_CURRENCY_SYMBOLS.GYEN, SUPPORTED_CURRENCY_SYMBOLS.LINK, SUPPORTED_CURRENCY_SYMBOLS.MKR, SUPPORTED_CURRENCY_SYMBOLS.PAX, SUPPORTED_CURRENCY_SYMBOLS.RAI, SUPPORTED_CURRENCY_SYMBOLS.SNX, SUPPORTED_CURRENCY_SYMBOLS.UMA, SUPPORTED_CURRENCY_SYMBOLS.UNI, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDS, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.WBTC, SUPPORTED_CURRENCY_SYMBOLS.WETH, SUPPORTED_CURRENCY_SYMBOLS.YFI, SUPPORTED_CURRENCY_SYMBOLS.ZUSD]
              },
              coinbasePayCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS['1INCH'], SUPPORTED_CURRENCY_SYMBOLS.AAVE, SUPPORTED_CURRENCY_SYMBOLS.ABT, SUPPORTED_CURRENCY_SYMBOLS.ACH, SUPPORTED_CURRENCY_SYMBOLS.AGLD, SUPPORTED_CURRENCY_SYMBOLS.AMP, SUPPORTED_CURRENCY_SYMBOLS.ANKR, SUPPORTED_CURRENCY_SYMBOLS.APE, SUPPORTED_CURRENCY_SYMBOLS.ARPA, SUPPORTED_CURRENCY_SYMBOLS.ASM, SUPPORTED_CURRENCY_SYMBOLS.AUCTION, SUPPORTED_CURRENCY_SYMBOLS.AXS, SUPPORTED_CURRENCY_SYMBOLS.BADGER, SUPPORTED_CURRENCY_SYMBOLS.BAL, SUPPORTED_CURRENCY_SYMBOLS.BAND, SUPPORTED_CURRENCY_SYMBOLS.BAT, SUPPORTED_CURRENCY_SYMBOLS.BNT, SUPPORTED_CURRENCY_SYMBOLS.BOBA, SUPPORTED_CURRENCY_SYMBOLS.BOND, SUPPORTED_CURRENCY_SYMBOLS.BTRST, SUPPORTED_CURRENCY_SYMBOLS.CHZ, SUPPORTED_CURRENCY_SYMBOLS.CLV, SUPPORTED_CURRENCY_SYMBOLS.COMP, SUPPORTED_CURRENCY_SYMBOLS.COTI, SUPPORTED_CURRENCY_SYMBOLS.CRO, SUPPORTED_CURRENCY_SYMBOLS.CRV, SUPPORTED_CURRENCY_SYMBOLS.CTSI, SUPPORTED_CURRENCY_SYMBOLS.CVC, SUPPORTED_CURRENCY_SYMBOLS.DAI, SUPPORTED_CURRENCY_SYMBOLS.DDX, SUPPORTED_CURRENCY_SYMBOLS.DNT, SUPPORTED_CURRENCY_SYMBOLS.ENJ, SUPPORTED_CURRENCY_SYMBOLS.ENS, SUPPORTED_CURRENCY_SYMBOLS.FARM, SUPPORTED_CURRENCY_SYMBOLS.FET, SUPPORTED_CURRENCY_SYMBOLS.FORTH, SUPPORTED_CURRENCY_SYMBOLS.FX, SUPPORTED_CURRENCY_SYMBOLS.GNO, SUPPORTED_CURRENCY_SYMBOLS.GRT, SUPPORTED_CURRENCY_SYMBOLS.GTC, SUPPORTED_CURRENCY_SYMBOLS.IOTX, SUPPORTED_CURRENCY_SYMBOLS.JASMY, SUPPORTED_CURRENCY_SYMBOLS.KEEP, SUPPORTED_CURRENCY_SYMBOLS.KNC, SUPPORTED_CURRENCY_SYMBOLS.KRL, SUPPORTED_CURRENCY_SYMBOLS.LCX, SUPPORTED_CURRENCY_SYMBOLS.LINK, SUPPORTED_CURRENCY_SYMBOLS.LPT, SUPPORTED_CURRENCY_SYMBOLS.LRC, SUPPORTED_CURRENCY_SYMBOLS.MANA, SUPPORTED_CURRENCY_SYMBOLS.MASK, SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.MIR, SUPPORTED_CURRENCY_SYMBOLS.MKR, SUPPORTED_CURRENCY_SYMBOLS.MLN, SUPPORTED_CURRENCY_SYMBOLS.MTL, SUPPORTED_CURRENCY_SYMBOLS.NKN, SUPPORTED_CURRENCY_SYMBOLS.NMR, SUPPORTED_CURRENCY_SYMBOLS.NU, SUPPORTED_CURRENCY_SYMBOLS.OGN, SUPPORTED_CURRENCY_SYMBOLS.OMG, SUPPORTED_CURRENCY_SYMBOLS.OXT, SUPPORTED_CURRENCY_SYMBOLS.PAX, SUPPORTED_CURRENCY_SYMBOLS.PERP, SUPPORTED_CURRENCY_SYMBOLS.PLA, SUPPORTED_CURRENCY_SYMBOLS.POLY, SUPPORTED_CURRENCY_SYMBOLS.QNT, SUPPORTED_CURRENCY_SYMBOLS.QUICK, SUPPORTED_CURRENCY_SYMBOLS.RAD, SUPPORTED_CURRENCY_SYMBOLS.RAI, SUPPORTED_CURRENCY_SYMBOLS.RARI, SUPPORTED_CURRENCY_SYMBOLS.REN, SUPPORTED_CURRENCY_SYMBOLS.REP, SUPPORTED_CURRENCY_SYMBOLS.REQ, SUPPORTED_CURRENCY_SYMBOLS.RLC, SUPPORTED_CURRENCY_SYMBOLS.RLY, SUPPORTED_CURRENCY_SYMBOLS.SAND, SUPPORTED_CURRENCY_SYMBOLS.SHIB, SUPPORTED_CURRENCY_SYMBOLS.SKL, SUPPORTED_CURRENCY_SYMBOLS.SNX, SUPPORTED_CURRENCY_SYMBOLS.STORJ, SUPPORTED_CURRENCY_SYMBOLS.SUKU, SUPPORTED_CURRENCY_SYMBOLS.SUSHI, SUPPORTED_CURRENCY_SYMBOLS.SWFTC, SUPPORTED_CURRENCY_SYMBOLS.TRAC, SUPPORTED_CURRENCY_SYMBOLS.TRB, SUPPORTED_CURRENCY_SYMBOLS.TRIBE, SUPPORTED_CURRENCY_SYMBOLS.TRU, SUPPORTED_CURRENCY_SYMBOLS.UMA, SUPPORTED_CURRENCY_SYMBOLS.UNI, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.WBTC, SUPPORTED_CURRENCY_SYMBOLS.WCFG, SUPPORTED_CURRENCY_SYMBOLS.XYO, SUPPORTED_CURRENCY_SYMBOLS.YFII, SUPPORTED_CURRENCY_SYMBOLS.ZRX]
            },
            [CHAIN_IDS.GOERLI]: {
              nativeCurrency: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.GOERLI],
              network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
            },
            [CHAIN_IDS.SEPOLIA]: {
              nativeCurrency: TEST_NETWORK_TICKER_MAP[NETWORK_TYPES.SEPOLIA],
              network: BUYABLE_CHAIN_ETHEREUM_NETWORK_NAME
            },
            [CHAIN_IDS.BSC]: {
              nativeCurrency: CURRENCY_SYMBOLS.BNB,
              network: 'bsc',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.BNB, SUPPORTED_CURRENCY_SYMBOLS.BUSD],
              moonPay: {
                defaultCurrencyCode: `${SUPPORTED_CURRENCY_SYMBOLS.BNB}_BSC`,
                showOnlyCurrencies: [`${SUPPORTED_CURRENCY_SYMBOLS.BNB}_BSC`, `${SUPPORTED_CURRENCY_SYMBOLS.BUSD}_BSC`]
              }
            },
            [CHAIN_IDS.POLYGON]: {
              nativeCurrency: CURRENCY_SYMBOLS.MATIC,
              network: 'polygon',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.USDT, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.DAI],
              moonPay: {
                defaultCurrencyCode: `${SUPPORTED_CURRENCY_SYMBOLS.BNB}_POLYGON`,
                showOnlyCurrencies: [`${SUPPORTED_CURRENCY_SYMBOLS.MATIC}_POLYGON`, `${SUPPORTED_CURRENCY_SYMBOLS.USDC}_POLYGON`]
              },
              wyre: {
                srn: 'matic',
                currencyCode: CURRENCY_SYMBOLS.MATIC,
                currencies: [SUPPORTED_CURRENCY_SYMBOLS.MATIC, SUPPORTED_CURRENCY_SYMBOLS.MUSDC]
              }
            },
            [CHAIN_IDS.AVALANCHE]: {
              nativeCurrency: CURRENCY_SYMBOLS.AVALANCHE,
              network: 'avaxcchain',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.AVALANCHE],
              moonPay: {
                defaultCurrencyCode: `${SUPPORTED_CURRENCY_SYMBOLS.AVAX}_CCHAIN`,
                showOnlyCurrencies: [`${SUPPORTED_CURRENCY_SYMBOLS.AVAX}_CCHAIN`]
              },
              wyre: {
                srn: 'avalanche',
                currencyCode: CURRENCY_SYMBOLS.AVALANCHE,
                currencies: [SUPPORTED_CURRENCY_SYMBOLS.AVALANCHE, SUPPORTED_CURRENCY_SYMBOLS.AVAXC, SUPPORTED_CURRENCY_SYMBOLS.AVAXCUSDC]
              },
              coinbasePayCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.AVALANCHE]
            },
            [CHAIN_IDS.FANTOM]: {
              nativeCurrency: CURRENCY_SYMBOLS.FANTOM,
              network: 'fantom',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.FANTOM]
            },
            [CHAIN_IDS.CELO]: {
              nativeCurrency: CURRENCY_SYMBOLS.CELO,
              network: 'celo',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.CELO],
              moonPay: {
                defaultCurrencyCode: SUPPORTED_CURRENCY_SYMBOLS.CELO,
                showOnlyCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.CELO]
              }
            },
            [CHAIN_IDS.OPTIMISM]: {
              nativeCurrency: CURRENCY_SYMBOLS.ETH,
              network: 'optimism',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ETH, SUPPORTED_CURRENCY_SYMBOLS.USDC]
            },
            [CHAIN_IDS.ARBITRUM]: {
              nativeCurrency: CURRENCY_SYMBOLS.ARBITRUM,
              network: 'arbitrum',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.ARBITRUM, SUPPORTED_CURRENCY_SYMBOLS.SPA, SUPPORTED_CURRENCY_SYMBOLS.USDC, SUPPORTED_CURRENCY_SYMBOLS.USDS]
            },
            [CHAIN_IDS.AURORA]: {
              nativeCurrency: CURRENCY_SYMBOLS.AURORA,
              network: 'aurora',
              transakCurrencies: [SUPPORTED_CURRENCY_SYMBOLS.AURORA]
            }
          };
          exports.BUYABLE_CHAINS_MAP = BUYABLE_CHAINS_MAP;
          const FEATURED_RPCS = [{
            chainId: CHAIN_IDS.ARBITRUM,
            nickname: ARBITRUM_DISPLAY_NAME,
            rpcUrl: `https://arbitrum-mainnet.infura.io/v3/${infuraProjectId}`,
            ticker: CURRENCY_SYMBOLS.ARBITRUM,
            rpcPrefs: {
              blockExplorerUrl: 'https://explorer.arbitrum.io',
              imageUrl: AETH_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.AURORA,
            nickname: AURORA_DISPLAY_NAME,
            rpcUrl: `https://aurora-mainnet.infura.io/v3/${infuraProjectId}`,
            ticker: CURRENCY_SYMBOLS.AURORA,
            rpcPrefs: {
              blockExplorerUrl: 'https://aurorascan.dev/',
              imageUrl: AURORA_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.AVALANCHE,
            nickname: AVALANCHE_DISPLAY_NAME,
            rpcUrl: `https://avalanche-mainnet.infura.io/v3/${infuraProjectId}`,
            ticker: CURRENCY_SYMBOLS.AVALANCHE,
            rpcPrefs: {
              blockExplorerUrl: 'https://snowtrace.io/',
              imageUrl: AVAX_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.BSC,
            nickname: BNB_DISPLAY_NAME,
            rpcUrl: 'https://bsc-dataseed.binance.org/',
            ticker: CURRENCY_SYMBOLS.BNB,
            rpcPrefs: {
              blockExplorerUrl: 'https://bscscan.com/',
              imageUrl: BNB_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.FANTOM,
            nickname: FANTOM_DISPLAY_NAME,
            rpcUrl: 'https://rpc.ftm.tools/',
            ticker: CURRENCY_SYMBOLS.FANTOM,
            rpcPrefs: {
              blockExplorerUrl: 'https://ftmscan.com/',
              imageUrl: FTM_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.HARMONY,
            nickname: HARMONY_DISPLAY_NAME,
            rpcUrl: 'https://api.harmony.one/',
            ticker: CURRENCY_SYMBOLS.HARMONY,
            rpcPrefs: {
              blockExplorerUrl: 'https://explorer.harmony.one/',
              imageUrl: HARMONY_ONE_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.OPTIMISM,
            nickname: OPTIMISM_DISPLAY_NAME,
            rpcUrl: `https://optimism-mainnet.infura.io/v3/${infuraProjectId}`,
            ticker: CURRENCY_SYMBOLS.ETH,
            rpcPrefs: {
              blockExplorerUrl: 'https://optimistic.etherscan.io/',
              imageUrl: OPTIMISM_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.PALM,
            nickname: PALM_DISPLAY_NAME,
            rpcUrl: `https://palm-mainnet.infura.io/v3/${infuraProjectId}`,
            ticker: CURRENCY_SYMBOLS.PALM,
            rpcPrefs: {
              blockExplorerUrl: 'https://explorer.palm.io/',
              imageUrl: PALM_TOKEN_IMAGE_URL
            }
          }, {
            chainId: CHAIN_IDS.POLYGON,
            nickname: `${POLYGON_DISPLAY_NAME} ${(0, _lodash.capitalize)(NETWORK_TYPES.MAINNET)}`,
            rpcUrl: `https://polygon-mainnet.infura.io/v3/${infuraProjectId}`,
            ticker: CURRENCY_SYMBOLS.MATIC,
            rpcPrefs: {
              blockExplorerUrl: 'https://polygonscan.com/',
              imageUrl: MATIC_TOKEN_IMAGE_URL
            }
          }];
          exports.FEATURED_RPCS = FEATURED_RPCS;


        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\permissions.ts", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\permissions.ts
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.RestrictedMethods = exports.PermissionNamespaces = exports.ExcludedSnapPermissions = exports.ExcludedSnapEndowments = exports.EndowmentPermissions = exports.CaveatTypes = void 0;
          const CaveatTypes = Object.freeze({
            restrictReturnedAccounts: 'restrictReturnedAccounts'
          });
          exports.CaveatTypes = CaveatTypes;
          const RestrictedMethods = Object.freeze({
            eth_accounts: 'eth_accounts',
            ///: BEGIN:ONLY_INCLUDE_IN(flask)
            snap_confirm: 'snap_confirm',
            snap_notify: 'snap_notify',
            snap_manageState: 'snap_manageState',
            snap_getBip32PublicKey: 'snap_getBip32PublicKey',
            snap_getBip32Entropy: 'snap_getBip32Entropy',
            snap_getBip44Entropy: 'snap_getBip44Entropy',
            'wallet_snap_*': 'wallet_snap_*' ///: END:ONLY_INCLUDE_IN

          }); ///: BEGIN:ONLY_INCLUDE_IN(flask)

          exports.RestrictedMethods = RestrictedMethods;
          const PermissionNamespaces = Object.freeze({
            wallet_snap_: 'wallet_snap_*'
          });
          exports.PermissionNamespaces = PermissionNamespaces;
          const EndowmentPermissions = Object.freeze({
            'endowment:network-access': 'endowment:network-access',
            'endowment:long-running': 'endowment:long-running',
            'endowment:transaction-insight': 'endowment:transaction-insight',
            'endowment:cronjob': 'endowment:cronjob'
          }); // Methods / permissions in external packages that we are temporarily excluding.

          exports.EndowmentPermissions = EndowmentPermissions;
          const ExcludedSnapPermissions = new Set(['snap_dialog']);
          exports.ExcludedSnapPermissions = ExcludedSnapPermissions;
          const ExcludedSnapEndowments = new Set(['endowment:keyring']); ///: END:ONLY_INCLUDE_IN

          exports.ExcludedSnapEndowments = ExcludedSnapEndowments;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\swaps.js", { "./network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\swaps.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WMATIC_CONTRACT_ADDRESS = exports.WETH_OPTIMISM_CONTRACT_ADDRESS = exports.WETH_GOERLI_CONTRACT_ADDRESS = exports.WETH_CONTRACT_ADDRESS = exports.WETH_ARBITRUM_CONTRACT_ADDRESS = exports.WBNB_CONTRACT_ADDRESS = exports.WAVAX_CONTRACT_ADDRESS = exports.TOKEN_BUCKET_PRIORITY = exports.TEST_ETH_SWAPS_TOKEN_OBJECT = exports.SWAP_FAILED_ERROR = exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = exports.SWAPS_FETCH_ORDER_CONFLICT = exports.SWAPS_DEV_API_V2_BASE_URL = exports.SWAPS_CLIENT_ID = exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = exports.SWAPS_API_V2_BASE_URL = exports.SLIPPAGE = exports.QUOTES_NOT_AVAILABLE_ERROR = exports.QUOTES_EXPIRED_ERROR = exports.POLYGON = exports.OPTIMISM_SWAPS_TOKEN_OBJECT = exports.OPTIMISM = exports.OFFLINE_FOR_MAINTENANCE = exports.MATIC_SWAPS_TOKEN_OBJECT = exports.GOERLI_SWAPS_TOKEN_OBJECT = exports.GOERLI = exports.GAS_DEV_API_BASE_URL = exports.GAS_API_BASE_URL = exports.ETH_SWAPS_TOKEN_OBJECT = exports.ETHEREUM = exports.ERROR_FETCHING_QUOTES = exports.DEFAULT_ERC20_APPROVE_GAS = exports.CONTRACT_DATA_DISABLED_ERROR = exports.BSC = exports.BNB_SWAPS_TOKEN_OBJECT = exports.AVAX_SWAPS_TOKEN_OBJECT = exports.AVALANCHE = exports.ARBITRUM_SWAPS_TOKEN_OBJECT = exports.ARBITRUM = exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = exports.ALLOWED_CONTRACT_ADDRESSES = void 0;

          var _network = require("./network");

          const QUOTES_EXPIRED_ERROR = 'quotes-expired';
          exports.QUOTES_EXPIRED_ERROR = QUOTES_EXPIRED_ERROR;
          const SWAP_FAILED_ERROR = 'swap-failed-error';
          exports.SWAP_FAILED_ERROR = SWAP_FAILED_ERROR;
          const ERROR_FETCHING_QUOTES = 'error-fetching-quotes';
          exports.ERROR_FETCHING_QUOTES = ERROR_FETCHING_QUOTES;
          const QUOTES_NOT_AVAILABLE_ERROR = 'quotes-not-avilable';
          exports.QUOTES_NOT_AVAILABLE_ERROR = QUOTES_NOT_AVAILABLE_ERROR;
          const CONTRACT_DATA_DISABLED_ERROR = 'contract-data-disabled';
          exports.CONTRACT_DATA_DISABLED_ERROR = CONTRACT_DATA_DISABLED_ERROR;
          const OFFLINE_FOR_MAINTENANCE = 'offline-for-maintenance';
          exports.OFFLINE_FOR_MAINTENANCE = OFFLINE_FOR_MAINTENANCE;
          const SWAPS_FETCH_ORDER_CONFLICT = 'swaps-fetch-order-conflict'; // An address that the metaswap-api recognizes as the default token for the current network, in place of the token address that ERC-20 tokens have

          exports.SWAPS_FETCH_ORDER_CONFLICT = SWAPS_FETCH_ORDER_CONFLICT;
          const DEFAULT_TOKEN_ADDRESS = '0x0000000000000000000000000000000000000000';
          const ETH_SWAPS_TOKEN_OBJECT = {
            symbol: _network.CURRENCY_SYMBOLS.ETH,
            name: 'Ether',
            address: DEFAULT_TOKEN_ADDRESS,
            decimals: 18,
            iconUrl: _network.ETH_TOKEN_IMAGE_URL
          };
          exports.ETH_SWAPS_TOKEN_OBJECT = ETH_SWAPS_TOKEN_OBJECT;
          const BNB_SWAPS_TOKEN_OBJECT = {
            symbol: _network.CURRENCY_SYMBOLS.BNB,
            name: 'Binance Coin',
            address: DEFAULT_TOKEN_ADDRESS,
            decimals: 18,
            iconUrl: _network.BNB_TOKEN_IMAGE_URL
          };
          exports.BNB_SWAPS_TOKEN_OBJECT = BNB_SWAPS_TOKEN_OBJECT;
          const MATIC_SWAPS_TOKEN_OBJECT = {
            symbol: _network.CURRENCY_SYMBOLS.MATIC,
            name: 'Matic',
            address: DEFAULT_TOKEN_ADDRESS,
            decimals: 18,
            iconUrl: _network.MATIC_TOKEN_IMAGE_URL
          };
          exports.MATIC_SWAPS_TOKEN_OBJECT = MATIC_SWAPS_TOKEN_OBJECT;
          const AVAX_SWAPS_TOKEN_OBJECT = {
            symbol: _network.CURRENCY_SYMBOLS.AVALANCHE,
            name: 'Avalanche',
            address: DEFAULT_TOKEN_ADDRESS,
            decimals: 18,
            iconUrl: _network.AVAX_TOKEN_IMAGE_URL
          };
          exports.AVAX_SWAPS_TOKEN_OBJECT = AVAX_SWAPS_TOKEN_OBJECT;
          const TEST_ETH_SWAPS_TOKEN_OBJECT = {
            symbol: _network.CURRENCY_SYMBOLS.TEST_ETH,
            name: 'Test Ether',
            address: DEFAULT_TOKEN_ADDRESS,
            decimals: 18,
            iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
          };
          exports.TEST_ETH_SWAPS_TOKEN_OBJECT = TEST_ETH_SWAPS_TOKEN_OBJECT;
          const GOERLI_SWAPS_TOKEN_OBJECT = {
            symbol: _network.CURRENCY_SYMBOLS.ETH,
            name: 'Ether',
            address: DEFAULT_TOKEN_ADDRESS,
            decimals: 18,
            iconUrl: _network.TEST_ETH_TOKEN_IMAGE_URL
          };
          exports.GOERLI_SWAPS_TOKEN_OBJECT = GOERLI_SWAPS_TOKEN_OBJECT;
          const ARBITRUM_SWAPS_TOKEN_OBJECT = {
            ...ETH_SWAPS_TOKEN_OBJECT
          };
          exports.ARBITRUM_SWAPS_TOKEN_OBJECT = ARBITRUM_SWAPS_TOKEN_OBJECT;
          const OPTIMISM_SWAPS_TOKEN_OBJECT = {
            ...ETH_SWAPS_TOKEN_OBJECT
          }; // A gas value for ERC20 approve calls that should be sufficient for all ERC20 approve implementations

          exports.OPTIMISM_SWAPS_TOKEN_OBJECT = OPTIMISM_SWAPS_TOKEN_OBJECT;
          const DEFAULT_ERC20_APPROVE_GAS = '0x1d4c0';
          exports.DEFAULT_ERC20_APPROVE_GAS = DEFAULT_ERC20_APPROVE_GAS;
          const MAINNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
          const TESTNET_CONTRACT_ADDRESS = '0x881d40237659c251811cec9c364ef91dc08d300c';
          const BSC_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31'; // It's the same as we use for BSC.

          const POLYGON_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
          const AVALANCHE_CONTRACT_ADDRESS = '0x1a1ec25dc08e98e5e93f1104b5e5cdd298707d31';
          const OPTIMISM_CONTRACT_ADDRESS = '0x9dDA6Ef3D919c9bC8885D5560999A3640431e8e6';
          const ARBITRUM_CONTRACT_ADDRESS = '0x9dDA6Ef3D919c9bC8885D5560999A3640431e8e6';
          const WETH_CONTRACT_ADDRESS = '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2';
          exports.WETH_CONTRACT_ADDRESS = WETH_CONTRACT_ADDRESS;
          const WETH_GOERLI_CONTRACT_ADDRESS = '0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6';
          exports.WETH_GOERLI_CONTRACT_ADDRESS = WETH_GOERLI_CONTRACT_ADDRESS;
          const WBNB_CONTRACT_ADDRESS = '0xbb4cdb9cbd36b01bd1cbaebf2de08d9173bc095c';
          exports.WBNB_CONTRACT_ADDRESS = WBNB_CONTRACT_ADDRESS;
          const WMATIC_CONTRACT_ADDRESS = '0x0d500b1d8e8ef31e21c99d1db9a6444d3adf1270';
          exports.WMATIC_CONTRACT_ADDRESS = WMATIC_CONTRACT_ADDRESS;
          const WAVAX_CONTRACT_ADDRESS = '0xb31f66aa3c1e785363f0875a1b74e27b85fd66c7';
          exports.WAVAX_CONTRACT_ADDRESS = WAVAX_CONTRACT_ADDRESS;
          const WETH_OPTIMISM_CONTRACT_ADDRESS = '0x4200000000000000000000000000000000000006';
          exports.WETH_OPTIMISM_CONTRACT_ADDRESS = WETH_OPTIMISM_CONTRACT_ADDRESS;
          const WETH_ARBITRUM_CONTRACT_ADDRESS = '0x82aF49447D8a07e3bd95BD0d56f35241523fBab1';
          exports.WETH_ARBITRUM_CONTRACT_ADDRESS = WETH_ARBITRUM_CONTRACT_ADDRESS;
          const SWAPS_TESTNET_CHAIN_ID = '0x539';
          const SWAPS_API_V2_BASE_URL = 'https://swap.metaswap.codefi.network';
          exports.SWAPS_API_V2_BASE_URL = SWAPS_API_V2_BASE_URL;
          const SWAPS_DEV_API_V2_BASE_URL = 'https://swap.metaswap-dev.codefi.network';
          exports.SWAPS_DEV_API_V2_BASE_URL = SWAPS_DEV_API_V2_BASE_URL;
          const GAS_API_BASE_URL = 'https://gas-api.metaswap.codefi.network';
          exports.GAS_API_BASE_URL = GAS_API_BASE_URL;
          const GAS_DEV_API_BASE_URL = 'https://gas-api.metaswap-dev.codefi.network';
          exports.GAS_DEV_API_BASE_URL = GAS_DEV_API_BASE_URL;
          const BSC_DEFAULT_BLOCK_EXPLORER_URL = 'https://bscscan.com/';
          const MAINNET_DEFAULT_BLOCK_EXPLORER_URL = 'https://etherscan.io/';
          const GOERLI_DEFAULT_BLOCK_EXPLORER_URL = 'https://goerli.etherscan.io/';
          const POLYGON_DEFAULT_BLOCK_EXPLORER_URL = 'https://polygonscan.com/';
          const AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL = 'https://snowtrace.io/';
          const OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL = 'https://optimistic.etherscan.io/';
          const ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL = 'https://arbiscan.io/';
          const ALLOWED_PROD_SWAPS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, SWAPS_TESTNET_CHAIN_ID, _network.CHAIN_IDS.BSC, _network.CHAIN_IDS.POLYGON, _network.CHAIN_IDS.AVALANCHE, _network.CHAIN_IDS.OPTIMISM, _network.CHAIN_IDS.ARBITRUM];
          exports.ALLOWED_PROD_SWAPS_CHAIN_IDS = ALLOWED_PROD_SWAPS_CHAIN_IDS;
          const ALLOWED_DEV_SWAPS_CHAIN_IDS = [...ALLOWED_PROD_SWAPS_CHAIN_IDS, _network.CHAIN_IDS.GOERLI];
          exports.ALLOWED_DEV_SWAPS_CHAIN_IDS = ALLOWED_DEV_SWAPS_CHAIN_IDS;
          const ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = [_network.CHAIN_IDS.MAINNET, _network.CHAIN_IDS.GOERLI];
          exports.ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS = ALLOWED_SMART_TRANSACTIONS_CHAIN_IDS;
          const SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = {
            [_network.CHAIN_IDS.MAINNET]: MAINNET_CONTRACT_ADDRESS,
            [SWAPS_TESTNET_CHAIN_ID]: TESTNET_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.BSC]: BSC_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.POLYGON]: POLYGON_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.GOERLI]: TESTNET_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_CONTRACT_ADDRESS
          };
          exports.SWAPS_CHAINID_CONTRACT_ADDRESS_MAP = SWAPS_CHAINID_CONTRACT_ADDRESS_MAP;
          const SWAPS_WRAPPED_TOKENS_ADDRESSES = {
            [_network.CHAIN_IDS.MAINNET]: WETH_CONTRACT_ADDRESS,
            [SWAPS_TESTNET_CHAIN_ID]: WETH_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.BSC]: WBNB_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.POLYGON]: WMATIC_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.GOERLI]: WETH_GOERLI_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.AVALANCHE]: WAVAX_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.OPTIMISM]: WETH_OPTIMISM_CONTRACT_ADDRESS,
            [_network.CHAIN_IDS.ARBITRUM]: WETH_ARBITRUM_CONTRACT_ADDRESS
          };
          exports.SWAPS_WRAPPED_TOKENS_ADDRESSES = SWAPS_WRAPPED_TOKENS_ADDRESSES;
          const ALLOWED_CONTRACT_ADDRESSES = {
            [_network.CHAIN_IDS.MAINNET]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.MAINNET], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.MAINNET]],
            [SWAPS_TESTNET_CHAIN_ID]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[SWAPS_TESTNET_CHAIN_ID], SWAPS_WRAPPED_TOKENS_ADDRESSES[SWAPS_TESTNET_CHAIN_ID]],
            [_network.CHAIN_IDS.GOERLI]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.GOERLI], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.GOERLI]],
            [_network.CHAIN_IDS.BSC]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.BSC], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.BSC]],
            [_network.CHAIN_IDS.POLYGON]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.POLYGON], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.POLYGON]],
            [_network.CHAIN_IDS.AVALANCHE]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.AVALANCHE], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.AVALANCHE]],
            [_network.CHAIN_IDS.OPTIMISM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.OPTIMISM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.OPTIMISM]],
            [_network.CHAIN_IDS.ARBITRUM]: [SWAPS_CHAINID_CONTRACT_ADDRESS_MAP[_network.CHAIN_IDS.ARBITRUM], SWAPS_WRAPPED_TOKENS_ADDRESSES[_network.CHAIN_IDS.ARBITRUM]]
          };
          exports.ALLOWED_CONTRACT_ADDRESSES = ALLOWED_CONTRACT_ADDRESSES;
          const SWAPS_CHAINID_DEFAULT_TOKEN_MAP = {
            [_network.CHAIN_IDS.MAINNET]: ETH_SWAPS_TOKEN_OBJECT,
            [SWAPS_TESTNET_CHAIN_ID]: TEST_ETH_SWAPS_TOKEN_OBJECT,
            [_network.CHAIN_IDS.BSC]: BNB_SWAPS_TOKEN_OBJECT,
            [_network.CHAIN_IDS.POLYGON]: MATIC_SWAPS_TOKEN_OBJECT,
            [_network.CHAIN_IDS.GOERLI]: GOERLI_SWAPS_TOKEN_OBJECT,
            [_network.CHAIN_IDS.AVALANCHE]: AVAX_SWAPS_TOKEN_OBJECT,
            [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_SWAPS_TOKEN_OBJECT,
            [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_SWAPS_TOKEN_OBJECT
          };
          exports.SWAPS_CHAINID_DEFAULT_TOKEN_MAP = SWAPS_CHAINID_DEFAULT_TOKEN_MAP;
          const SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = {
            [_network.CHAIN_IDS.BSC]: BSC_DEFAULT_BLOCK_EXPLORER_URL,
            [_network.CHAIN_IDS.MAINNET]: MAINNET_DEFAULT_BLOCK_EXPLORER_URL,
            [_network.CHAIN_IDS.POLYGON]: POLYGON_DEFAULT_BLOCK_EXPLORER_URL,
            [_network.CHAIN_IDS.GOERLI]: GOERLI_DEFAULT_BLOCK_EXPLORER_URL,
            [_network.CHAIN_IDS.AVALANCHE]: AVALANCHE_DEFAULT_BLOCK_EXPLORER_URL,
            [_network.CHAIN_IDS.OPTIMISM]: OPTIMISM_DEFAULT_BLOCK_EXPLORER_URL,
            [_network.CHAIN_IDS.ARBITRUM]: ARBITRUM_DEFAULT_BLOCK_EXPLORER_URL
          };
          exports.SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP = SWAPS_CHAINID_DEFAULT_BLOCK_EXPLORER_URL_MAP;
          const ETHEREUM = 'ethereum';
          exports.ETHEREUM = ETHEREUM;
          const POLYGON = 'polygon';
          exports.POLYGON = POLYGON;
          const BSC = 'bsc';
          exports.BSC = BSC;
          const GOERLI = 'goerli';
          exports.GOERLI = GOERLI;
          const AVALANCHE = 'avalanche';
          exports.AVALANCHE = AVALANCHE;
          const OPTIMISM = 'optimism';
          exports.OPTIMISM = OPTIMISM;
          const ARBITRUM = 'arbitrum';
          exports.ARBITRUM = ARBITRUM;
          const SWAPS_CLIENT_ID = 'extension';
          exports.SWAPS_CLIENT_ID = SWAPS_CLIENT_ID;
          const TOKEN_BUCKET_PRIORITY = {
            OWNED: 'owned',
            TOP: 'top'
          };
          exports.TOKEN_BUCKET_PRIORITY = TOKEN_BUCKET_PRIORITY;
          const SLIPPAGE = {
            DEFAULT: 2,
            HIGH: 3
          };
          exports.SLIPPAGE = SLIPPAGE;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\time.ts
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SECOND = exports.MINUTE = exports.MILLISECOND = exports.HOUR = exports.DAY = void 0;
          const MILLISECOND = 1;
          exports.MILLISECOND = MILLISECOND;
          const SECOND = MILLISECOND * 1000;
          exports.SECOND = SECOND;
          const MINUTE = SECOND * 60;
          exports.MINUTE = MINUTE;
          const HOUR = MINUTE * 60;
          exports.HOUR = HOUR;
          const DAY = HOUR * 24;
          exports.DAY = DAY;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\tokens.js", { "@metamask/contract-metadata": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\contract-metadata\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\tokens.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TOKEN_API_METASWAP_CODEFI_URL = exports.STATIC_MAINNET_TOKEN_LIST = exports.LISTED_CONTRACT_ADDRESSES = void 0;

          var _contractMetadata = _interopRequireDefault(require("@metamask/contract-metadata"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          /**
           * A normalized list of addresses exported as part of the contractMap in
           * `@metamask/contract-metadata`. Used primarily to validate if manually entered
           * contract addresses do not match one of our listed tokens
           */
          const LISTED_CONTRACT_ADDRESSES = Object.keys(_contractMetadata.default).map(address => address.toLowerCase());
          /**
           * @typedef {object} TokenDetails
           * @property {string} address - The address of the selected 'TOKEN' or
           *  'COLLECTIBLE' contract.
           * @property {string} [symbol] - The symbol of the token.
           * @property {number} [decimals] - The number of decimals of the selected
           *  'ERC20' asset.
           * @property {number} [tokenId] - The id of the selected 'COLLECTIBLE' asset.
           * @property {TokenStandardStrings} [standard] - The standard of the selected
           *  asset.
           * @property {boolean} [isERC721] - True when the asset is a ERC721 token.
           */

          exports.LISTED_CONTRACT_ADDRESSES = LISTED_CONTRACT_ADDRESSES;
          const STATIC_MAINNET_TOKEN_LIST = Object.keys(_contractMetadata.default).reduce((acc, base) => {
            const {
              logo,
              ...tokenMetadata
            } = _contractMetadata.default[base];
            return {
              ...acc,
              [base.toLowerCase()]: {
                ...tokenMetadata,
                address: base.toLowerCase(),
                iconUrl: `images/contract/${logo}`,
                aggregators: []
              }
            };
          }, {});
          exports.STATIC_MAINNET_TOKEN_LIST = STATIC_MAINNET_TOKEN_LIST;
          const TOKEN_API_METASWAP_CODEFI_URL = 'https://token-api.metaswap.codefi.network/tokens/';
          exports.TOKEN_API_METASWAP_CODEFI_URL = TOKEN_API_METASWAP_CODEFI_URL;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", { "./app": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\constants\transaction.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TRANSACTION_TYPES = exports.TRANSACTION_STATUSES = exports.TRANSACTION_GROUP_STATUSES = exports.TRANSACTION_GROUP_CATEGORIES = exports.TRANSACTION_EVENTS = exports.TRANSACTION_ENVELOPE_TYPES = exports.TRANSACTION_APPROVAL_AMOUNT_TYPE = exports.TOKEN_STANDARDS = exports.SMART_TRANSACTION_STATUSES = exports.IN_PROGRESS_TRANSACTION_STATUSES = exports.ERC721 = exports.ERC20 = exports.ERC1155 = exports.ASSET_TYPES = void 0;

          var _app = require("./app");

          /**
           * Transaction Type is a MetaMask construct used internally
           *
           * @typedef {object} TransactionTypes
           * @property {'transfer'} TOKEN_METHOD_TRANSFER - A token transaction where the user
           *  is sending tokens that they own to another address
           * @property {'transferfrom'} TOKEN_METHOD_TRANSFER_FROM - A token transaction
           *  transferring tokens from an account that the sender has an allowance of.
           *  For more information on allowances, see the approve type.
           * @property {'safetransferfrom'} TOKEN_METHOD_SAFE_TRANSFER_FROM - A token transaction
           *  transferring tokens from an account that the sender has an allowance of.
           *  The method is prefixed with safe because when calling this method the contract checks
           *  to ensure that the receiver is an address capable of handling with the token being sent.
           * @property {'approve'} TOKEN_METHOD_APPROVE - A token transaction requesting an
           *  allowance of the token to spend on behalf of the user
           * @property {'setapprovalforall'} TOKEN_METHOD_SET_APPROVAL_FOR_ALL - A token transaction requesting an
           *  allowance of all of a user's token to spend on behalf of the user
           * @property {'incoming'} INCOMING - An incoming (deposit) transaction
           * @property {'simpleSend'} SIMPLE_SEND - A transaction sending a network's native asset to a recipient
           * @property {'contractInteraction'} CONTRACT_INTERACTION - A transaction that is
           *  interacting with a smart contract's methods that we have not treated as a special
           *  case, such as approve, transfer, and transferfrom
           * @property {'contractDeployment'} DEPLOY_CONTRACT - A transaction that deployed
           *  a smart contract
           * @property {'swap'} SWAP - A transaction swapping one token for another through
           *  MetaMask Swaps
           * @property {'swapApproval'} SWAP_APPROVAL - Similar to the approve type, a swap
           *  approval is a special case of ERC20 approve method that requests an allowance of
           *  the token to spend on behalf of the user for the MetaMask Swaps contract. The first
           *  swap for any token will have an accompanying swapApproval transaction.
           * @property {'cancel'} CANCEL - A transaction submitted with the same nonce as a
           *  previous transaction, a higher gas price and a zeroed out send amount. Useful
           *  for users who accidentally send to erroneous addresses or if they send too much.
           * @property {'retry'} RETRY - When a transaction is failed it can be retried by
           *  resubmitting the same transaction with a higher gas fee. This type is also used
           *  to speed up pending transactions. This is accomplished by creating a new tx with
           *  the same nonce and higher gas fees.
           */

          /**
           * This type will work anywhere you expect a string that can be one of the
           * above transaction types.
           *
           * @typedef {TransactionTypes[keyof TransactionTypes]} TransactionTypeString
           */

          /**
           * @type {TransactionTypes}
           */
          const TRANSACTION_TYPES = {
            CANCEL: 'cancel',
            CONTRACT_INTERACTION: 'contractInteraction',
            DEPLOY_CONTRACT: 'contractDeployment',
            ETH_DECRYPT: _app.MESSAGE_TYPE.ETH_DECRYPT,
            ETH_GET_ENCRYPTION_PUBLIC_KEY: _app.MESSAGE_TYPE.ETH_GET_ENCRYPTION_PUBLIC_KEY,
            INCOMING: 'incoming',
            PERSONAL_SIGN: _app.MESSAGE_TYPE.PERSONAL_SIGN,
            RETRY: 'retry',
            SIGN: _app.MESSAGE_TYPE.ETH_SIGN,
            SIGN_TYPED_DATA: _app.MESSAGE_TYPE.ETH_SIGN_TYPED_DATA,
            SIMPLE_SEND: 'simpleSend',
            SMART: 'smart',
            SWAP: 'swap',
            SWAP_APPROVAL: 'swapApproval',
            TOKEN_METHOD_APPROVE: 'approve',
            TOKEN_METHOD_SAFE_TRANSFER_FROM: 'safetransferfrom',
            TOKEN_METHOD_TRANSFER: 'transfer',
            TOKEN_METHOD_TRANSFER_FROM: 'transferfrom',
            TOKEN_METHOD_SET_APPROVAL_FOR_ALL: 'setapprovalforall'
          };
          /**
           * In EIP-2718 typed transaction envelopes were specified, with the very first
           * typed envelope being 'legacy' and describing the shape of the base
           * transaction params that were hitherto the only transaction type sent on
           * Ethereum.
           *
           * @typedef {object} TransactionEnvelopeTypes
           * @property {'0x0'} LEGACY - A legacy transaction, the very first type.
           * @property {'0x1'} ACCESS_LIST - EIP-2930 defined the access list transaction
           *  type that allowed for specifying the state that a transaction would act
           *  upon in advance and theoretically save on gas fees.
           * @property {'0x2'} FEE_MARKET - The type introduced comes from EIP-1559,
           *  Fee Market describes the addition of a baseFee to blocks that will be
           *  burned instead of distributed to miners. Transactions of this type have
           *  both a maxFeePerGas (maximum total amount in gwei per gas to spend on the
           *  transaction) which is inclusive of the maxPriorityFeePerGas (maximum amount
           *  of gwei per gas from the transaction fee to distribute to miner).
           */

          /**
           * @type {TransactionEnvelopeTypes}
           */

          exports.TRANSACTION_TYPES = TRANSACTION_TYPES;
          const TRANSACTION_ENVELOPE_TYPES = {
            LEGACY: '0x0',
            ACCESS_LIST: '0x1',
            FEE_MARKET: '0x2'
          };
          /**
           * Transaction Status is a mix of Ethereum and MetaMask terminology, used internally
           * for transaction processing.
           *
           * @typedef {object} TransactionStatuses
           * @property {'unapproved'} UNAPPROVED - A new transaction that the user has not
           *  approved or rejected
           * @property {'approved'} APPROVED - The user has approved the transaction in the
           *  MetaMask UI
           * @property {'rejected'} REJECTED - The user has rejected the transaction in the
           *  MetaMask UI
           * @property {'signed'} SIGNED - The transaction has been signed
           * @property {'submitted'} SUBMITTED - The transaction has been submitted to network
           * @property {'failed'} FAILED - The transaction has failed for some reason
           * @property {'dropped'} DROPPED - The transaction was dropped due to a tx with same
           *  nonce being accepted
           * @property {'confirmed'} CONFIRMED - The transaction was confirmed by the network
           */

          /**
           * This type will work anywhere you expect a string that can be one of the
           * above transaction statuses.
           *
           * @typedef {TransactionStatuses[keyof TransactionStatuses]} TransactionStatusString
           */

          /**
           * @type {TransactionStatuses}
           */

          exports.TRANSACTION_ENVELOPE_TYPES = TRANSACTION_ENVELOPE_TYPES;
          const TRANSACTION_STATUSES = {
            UNAPPROVED: 'unapproved',
            APPROVED: 'approved',
            REJECTED: 'rejected',
            SIGNED: 'signed',
            SUBMITTED: 'submitted',
            FAILED: 'failed',
            DROPPED: 'dropped',
            CONFIRMED: 'confirmed',
            PENDING: 'pending'
          };
          /**
           * With this list we can detect if a transaction is still in progress.
           */

          exports.TRANSACTION_STATUSES = TRANSACTION_STATUSES;
          const IN_PROGRESS_TRANSACTION_STATUSES = [TRANSACTION_STATUSES.UNAPPROVED, TRANSACTION_STATUSES.APPROVED, TRANSACTION_STATUSES.SIGNED, TRANSACTION_STATUSES.SUBMITTED, TRANSACTION_STATUSES.PENDING];
          /**
           * Transaction Group Status is a MetaMask construct to track the status of groups
           * of transactions.
           *
           * @typedef {object} TransactionGroupStatuses
           * @property {'cancelled'} CANCELLED - A cancel type transaction in the group was
           *  confirmed
           * @property {'pending'} PENDING - The primaryTransaction of the group has a status
           *  that is one of TRANSACTION_STATUSES.APPROVED, TRANSACTION_STATUSES.UNAPPROVED
           *  or TRANSACTION_STATUSES.SUBMITTED
           */

          /**
           * @type {TransactionGroupStatuses}
           */

          exports.IN_PROGRESS_TRANSACTION_STATUSES = IN_PROGRESS_TRANSACTION_STATUSES;
          const TRANSACTION_GROUP_STATUSES = {
            CANCELLED: 'cancelled',
            PENDING: 'pending'
          };
          /**
           * Statuses that are specific to Smart Transactions.
           *
           * @typedef {object} SmartTransactionStatuses
           * @property {'cancelled'} CANCELLED - It can be cancelled for various reasons.
           * @property {'pending'} PENDING - Smart transaction is being processed.
           * @property {'success'} SUCCESS - Smart transaction was successfully mined.
           */

          /**
           * @type {SmartTransactionStatuses}
           */

          exports.TRANSACTION_GROUP_STATUSES = TRANSACTION_GROUP_STATUSES;
          const SMART_TRANSACTION_STATUSES = {
            CANCELLED: 'cancelled',
            PENDING: 'pending',
            SUCCESS: 'success'
          };
          /**
           * Types that are specific to the transaction approval amount.
           *
           * @typedef {object} TransactionApprovalAmountType
           * @property {'custom'} CUSTOM - The user has edited the token amount.
           * @property {'revoke'} REVOKE - The selected amount (either CUSTOM or DAPP_PROPOSED) is 0.
           * @property {'dapp_proposed'} DAPP_PROPOSED - The dapp proposed token amount.
           */

          /**
           * @type {TransactionApprovalAmountType}
           */

          exports.SMART_TRANSACTION_STATUSES = SMART_TRANSACTION_STATUSES;
          const TRANSACTION_APPROVAL_AMOUNT_TYPE = {
            CUSTOM: 'custom',
            REVOKE: 'revoke',
            DAPP_PROPOSED: 'dapp_proposed'
          };
          /**
           * Transaction Group Category is a MetaMask construct to categorize the intent
           * of a group of transactions for purposes of displaying in the UI
           *
           * @typedef {object} TransactionGroupCategories
           * @property {'send'} SEND - Transaction group representing ether being sent from
           *  the user.
           * @property {'receive'} RECEIVE - Transaction group representing a deposit/incoming
           *  transaction. This category maps 1:1 with TRANSACTION_CATEGORIES.INCOMING.
           * @property {'interaction'} INTERACTION - Transaction group representing
           *  an interaction with a smart contract's methods.
           * @property {'approval'} APPROVAL - Transaction group representing a request for an
           *  allowance of a token to spend on the user's behalf.
           * @property {'signature-request'} SIGNATURE_REQUEST - Transaction group representing
           *  a signature request This currently only shows up in the UI when its pending user
           *  approval in the UI. Once the user approves or rejects it will no longer show in
           *  activity.
           * @property {'swap'} SWAP - Transaction group representing a token swap through
           *  MetaMask Swaps. This transaction group's primary currency changes depending
           *  on context. If the user is viewing an asset page for a token received from a swap,
           *  the primary currency will be the received token. Otherwise the token exchanged
           *  will be shown.
           */

          /**
           * @type {TransactionGroupCategories}
           */

          exports.TRANSACTION_APPROVAL_AMOUNT_TYPE = TRANSACTION_APPROVAL_AMOUNT_TYPE;
          const TRANSACTION_GROUP_CATEGORIES = {
            APPROVAL: 'approval',
            INTERACTION: 'interaction',
            RECEIVE: 'receive',
            SEND: 'send',
            SIGNATURE_REQUEST: 'signature-request',
            SWAP: 'swap'
          };
          /**
           * @typedef {object} TxParams
           * @property {string} from - The address the transaction is sent from
           * @property {string} to - The address the transaction is sent to
           * @property {string} value - The amount of wei, in hexadecimal, to send
           * @property {number} nonce - The transaction count for the current account/network
           * @property {string} gasPrice - The amount of gwei, in hexadecimal, per unit of gas
           * @property {string} gas - The max amount of gwei, in hexadecimal, the user is willing to pay
           * @property {string} [data] - Hexadecimal encoded string representing calls to the EVM's ABI
           */

          /**
           * @typedef {object} TxError
           * @property {string} message - The message from the encountered error.
           * @property {any} rpc - The "value" of the error.
           * @property {string} [stack] - the stack trace from the error, if available.
           */

          /**
           * An object representing a transaction, in whatever state it is in.
           *
           * @typedef {object} TransactionMeta
           * @property {string} [blockNumber] - The block number this transaction was
           *  included in. Currently only present on incoming transactions!
           * @property {number} id - An internally unique tx identifier.
           * @property {number} time - Time the transaction was first suggested, in unix
           *  epoch time (ms).
           * @property {string} contractMethodName - A string representing a name of
           * transaction contract method.
           * @property {string} customTokenAmount - The custom token amount is the amount
           * set by the user
           * @property {string} dappProposedTokenAmount - The dapp proposed token amount
           * @property {string} currentTokenBalance - The balance of the token that is
           * being send
           * @property {string} originalApprovalAmount - The original approval amount
           * is the originally dapp proposed token amount
           * @property {string} finalApprovalAmount - The chosen amount which will be the
           * same as the originally proposed token amount if the user does not edit the
           * amount or will be a custom token amount set by the user
           * @property {TransactionTypeString} type - The type of transaction this txMeta
           *  represents.
           * @property {string} originalType - When we speed up a transaction,
           *  we set the type as Retry and we lose information about type of transaction
           *  that is being set up, so we use original type to track that information.
           * @property {TransactionStatusString} status - The current status of the
           *  transaction.
           * @property {string} metamaskNetworkId - The transaction's network ID, used
           *  for EIP-155 compliance.
           * @property {boolean} loadingDefaults - TODO: Document
           * @property {TxParams} txParams - The transaction params as passed to the
           *  network provider.
           * @property {object[]} history - A history of mutations to this
           *  TransactionMeta object.
           * @property {string} origin - A string representing the interface that
           *  suggested the transaction.
           * @property {string} originalGasEstimate - A string representing the original
           * gas estimation on the transaction metadata.
           * @property {boolean} userEditedGasLimit - A boolean representing when the
           * user manually edited the gas limit.
           * @property {object} nonceDetails - A metadata object containing information
           *  used to derive the suggested nonce, useful for debugging nonce issues.
           * @property {string} rawTx - A hex string of the final signed transaction,
           *  ready to submit to the network.
           * @property {string} hash - A hex string of the transaction hash, used to
           *  identify the transaction on the network.
           * @property {number} [submittedTime] - The time the transaction was submitted to
           *  the network, in Unix epoch time (ms).
           * @property {TxError} [err] - The error encountered during the transaction
           */

          /**
           * Defines the possible types
           *
           * @typedef {object} TransactionMetaMetricsEvents
           * @property {'Transaction Added'} ADDED - All transactions, except incoming
           *  ones, are added to the controller state in an unapproved status. When this
           *  happens we fire the Transaction Added event to show that the transaction
           *  has been added to the user's MetaMask.
           * @property {'Transaction Approved'} APPROVED - When an unapproved transaction
           *  is in the controller state, MetaMask will render a confirmation screen for
           *  that transaction. If the user approves the transaction we fire this event
           *  to indicate that the user has approved the transaction for submission to
           *  the network.
           * @property {'Transaction Rejected'} REJECTED - When an unapproved transaction
           *  is in the controller state, MetaMask will render a confirmation screen for
           *  that transaction. If the user rejects the transaction we fire this event
           *  to indicate that the user has rejected the transaction. It will be removed
           *  from state as a result.
           * @property {'Transaction Submitted'} SUBMITTED - After a transaction is
           *  approved by the user, it is then submitted to the network for inclusion in
           *  a block. When this happens we fire the Transaction Submitted event to
           *  indicate that MetaMask is submitting a transaction at the user's request.
           * @property {'Transaction Finalized'} FINALIZED - All transactions that are
           *  submitted will finalized (eventually) by either being dropped, failing
           *  or being confirmed. When this happens we track this event, along with the
           *  status.
           */

          /**
           * This type will work anywhere you expect a string that can be one of the
           * above transaction event types.
           *
           * @typedef {TransactionMetaMetricsEvents[keyof TransactionMetaMetricsEvents]} TransactionMetaMetricsEventString
           */

          /**
           * @type {TransactionMetaMetricsEvents}
           */

          exports.TRANSACTION_GROUP_CATEGORIES = TRANSACTION_GROUP_CATEGORIES;
          const TRANSACTION_EVENTS = {
            ADDED: 'Transaction Added',
            APPROVED: 'Transaction Approved',
            FINALIZED: 'Transaction Finalized',
            REJECTED: 'Transaction Rejected',
            SUBMITTED: 'Transaction Submitted'
          };
          /**
           * @typedef {object} AssetTypes
           * @property {'NATIVE'} NATIVE - The native asset for the current network, such
           *  as ETH
           * @property {'TOKEN'} TOKEN - An ERC20 token.
           * @property {'COLLECTIBLE'} COLLECTIBLE - An ERC721 or ERC1155 token.
           * @property {'UNKNOWN'} UNKNOWN - A transaction interacting with a contract
           *  that isn't a token method interaction will be marked as dealing with an
           *  unknown asset type.
           */

          /**
           * This type will work anywhere you expect a string that can be one of the
           * above asset types
           *
           * @typedef {AssetTypes[keyof AssetTypes]} AssetTypesString
           */

          /**
           * The types of assets that a user can send
           *
           * @type {AssetTypes}
           */

          exports.TRANSACTION_EVENTS = TRANSACTION_EVENTS;
          const ASSET_TYPES = {
            NATIVE: 'NATIVE',
            TOKEN: 'TOKEN',
            COLLECTIBLE: 'COLLECTIBLE',
            UNKNOWN: 'UNKNOWN'
          };
          exports.ASSET_TYPES = ASSET_TYPES;
          const ERC20 = 'ERC20';
          exports.ERC20 = ERC20;
          const ERC721 = 'ERC721';
          exports.ERC721 = ERC721;
          const ERC1155 = 'ERC1155';
          /**
           * @typedef {object} TokenStandards
           * @property {'ERC20'} ERC20 - A token that conforms to the ERC20 standard.
           * @property {'ERC721'} ERC721 - A token that conforms to the ERC721 standard.
           * @property {'ERC1155'} ERC1155 - A token that conforms to the ERC1155
           *  standard.
           * @property {'NONE'} NONE - Not a token, but rather the base asset of the
           *  selected chain.
           */

          /**
           * This type will work anywhere you expect a string that can be one of the
           * above statuses
           *
           * @typedef {TokenStandards[keyof TokenStandards]} TokenStandardStrings
           */

          /**
           * Describes the standard which a token conforms to.
           *
           * @type {TokenStandards}
           */

          exports.ERC1155 = ERC1155;
          const TOKEN_STANDARDS = {
            ERC20,
            ERC721,
            ERC1155,
            NONE: 'NONE'
          };
          exports.TOKEN_STANDARDS = TOKEN_STANDARDS;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js", { "../constants/time": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts", "../modules/fetch-with-timeout": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js", "./storage-helpers": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\storage-helpers.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\fetch-with-cache.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _time = require("../constants/time");

          var _fetchWithTimeout = _interopRequireDefault(require("../modules/fetch-with-timeout"));

          var _storageHelpers = require("./storage-helpers");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          const fetchWithCache = async (url, fetchOptions = {}, {
            cacheRefreshTime = _time.MINUTE * 6,
            timeout = _time.SECOND * 30
          } = {}) => {
            if (fetchOptions.body || fetchOptions.method && fetchOptions.method !== 'GET') {
              throw new Error('fetchWithCache only supports GET requests');
            }

            if (!(fetchOptions.headers instanceof window.Headers)) {
              fetchOptions.headers = new window.Headers(fetchOptions.headers);
            }

            if (fetchOptions.headers.has('Content-Type') && fetchOptions.headers.get('Content-Type') !== 'application/json') {
              throw new Error('fetchWithCache only supports JSON responses');
            }

            const currentTime = Date.now();
            const cacheKey = `cachedFetch:${url}`;
            const {
              cachedResponse,
              cachedTime
            } = (await (0, _storageHelpers.getStorageItem)(cacheKey)) || {};

            if (cachedResponse && currentTime - cachedTime < cacheRefreshTime) {
              return cachedResponse;
            }

            fetchOptions.headers.set('Content-Type', 'application/json');
            const fetchWithTimeout = (0, _fetchWithTimeout.default)(timeout);
            const response = await fetchWithTimeout(url, {
              referrerPolicy: 'no-referrer-when-downgrade',
              body: null,
              method: 'GET',
              mode: 'cors',
              ...fetchOptions
            });

            if (!response.ok) {
              throw new Error(`Fetch failed with status '${response.status}': '${response.statusText}'`);
            }

            const responseJson = await response.json();
            const cacheEntry = {
              cachedResponse: responseJson,
              cachedTime: currentTime
            };
            await (0, _storageHelpers.setStorageItem)(cacheKey, cacheEntry);
            return responseJson;
          };

          var _default = fetchWithCache;
          exports.default = _default;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\metamask-controller-utils.js", { "../modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\metamask-controller-utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getTokenValueParam = getTokenValueParam;
          exports.hexToDecimal = hexToDecimal;

          var _conversion = require("../modules/conversion.utils");

          function hexToDecimal(hexValue) {
            return (0, _conversion.conversionUtil)(hexValue, {
              fromNumericBase: 'hex',
              toNumericBase: 'dec'
            });
          }

          function getTokenValueParam(tokenData = {}) {
            var _tokenData$args, _tokenData$args$_valu;

            return tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : (_tokenData$args$_valu = _tokenData$args._value) === null || _tokenData$args$_valu === void 0 ? void 0 : _tokenData$args$_valu.toString();
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\storage-helpers.js", { "localforage": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\localforage\\dist\\localforage.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\storage-helpers.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getStorageItem = getStorageItem;
          exports.setStorageItem = setStorageItem;

          var _localforage = _interopRequireDefault(require("localforage"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          async function getStorageItem(key) {
            try {
              const serializedData = await _localforage.default.getItem(key);

              if (serializedData === null) {
                return undefined;
              }

              return JSON.parse(serializedData);
            } catch (err) {
              return undefined;
            }
          }

          async function setStorageItem(key, value) {
            try {
              const serializedData = JSON.stringify(value);
              await _localforage.default.setItem(key, serializedData);
            } catch (err) {
              console.warn(err);
            }
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\swaps-utils.js", { "../../app/scripts/lib/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js", "../constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", "../constants/swaps": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\swaps.js", "../constants/time": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts", "../modules/hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "./fetch-with-cache": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js", "./transactions-controller-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\swaps-utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.QUOTE_VALIDATORS = void 0;
          exports.addHexPrefixToObjectValues = addHexPrefixToObjectValues;
          exports.calcTokenValue = calcTokenValue;
          exports.constructTxParams = constructTxParams;
          exports.fetchTradesInfo = fetchTradesInfo;
          exports.validHex = exports.truthyString = exports.truthyDigitString = exports.shouldEnableDirectWrapping = exports.getBaseApi = void 0;
          exports.validateData = validateData;

          var _bignumber = _interopRequireDefault(require("bignumber.js"));

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var _network = require("../constants/network");

          var _swaps = require("../constants/swaps");

          var _time = require("../constants/time");

          var _hexstringUtils = require("../modules/hexstring-utils");

          var _util = require("../../app/scripts/lib/util");

          var _fetchWithCache = _interopRequireDefault(require("./fetch-with-cache"));

          var _transactionsControllerUtils = require("./transactions-controller-utils");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          const TEST_CHAIN_IDS = [_network.CHAIN_IDS.GOERLI, _network.CHAIN_IDS.LOCALHOST];
          const clientIdHeader = {
            'X-Client-Id': _swaps.SWAPS_CLIENT_ID
          };

          const validHex = string => Boolean(string === null || string === void 0 ? void 0 : string.match(/^0x[a-f0-9]+$/u));

          exports.validHex = validHex;

          const truthyString = string => Boolean(string === null || string === void 0 ? void 0 : string.length);

          exports.truthyString = truthyString;

          const truthyDigitString = string => truthyString(string) && Boolean(string.match(/^\d+$/u));

          exports.truthyDigitString = truthyDigitString;

          function validateData(validators, object, urlUsed, logError = true) {
            return validators.every(({
              property,
              type,
              validator
            }) => {
              const types = type.split('|');
              const valid = types.some(_type => typeof object[property] === _type) && (!validator || validator(object[property]));

              if (!valid && logError) {
                _loglevel.default.error(`response to GET ${urlUsed} invalid for property ${property}; value was:`, object[property], '| type was: ', typeof object[property]);
              }

              return valid;
            });
          }

          const QUOTE_VALIDATORS = [{
            property: 'trade',
            type: 'object',
            validator: trade => trade && validHex(trade.data) && (0, _hexstringUtils.isValidHexAddress)(trade.to, {
              allowNonPrefixed: false
            }) && (0, _hexstringUtils.isValidHexAddress)(trade.from, {
              allowNonPrefixed: false
            }) && truthyString(trade.value)
          }, {
            property: 'approvalNeeded',
            type: 'object',
            validator: approvalTx => approvalTx === null || approvalTx && validHex(approvalTx.data) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.to, {
              allowNonPrefixed: false
            }) && (0, _hexstringUtils.isValidHexAddress)(approvalTx.from, {
              allowNonPrefixed: false
            })
          }, {
            property: 'sourceAmount',
            type: 'string',
            validator: truthyDigitString
          }, {
            property: 'destinationAmount',
            type: 'string',
            validator: truthyDigitString
          }, {
            property: 'sourceToken',
            type: 'string',
            validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
              allowNonPrefixed: false
            })
          }, {
            property: 'destinationToken',
            type: 'string',
            validator: input => (0, _hexstringUtils.isValidHexAddress)(input, {
              allowNonPrefixed: false
            })
          }, {
            property: 'aggregator',
            type: 'string',
            validator: truthyString
          }, {
            property: 'aggType',
            type: 'string',
            validator: truthyString
          }, {
            property: 'error',
            type: 'object',
            validator: error => error === null || typeof error === 'object'
          }, {
            property: 'averageGas',
            type: 'number'
          }, {
            property: 'maxGas',
            type: 'number'
          }, {
            property: 'gasEstimate',
            type: 'number|undefined',
            validator: gasEstimate => gasEstimate === undefined || gasEstimate > 0
          }, {
            property: 'fee',
            type: 'number'
          }];
          /**
           * @param {string} type - Type of an API call, e.g. "tokens"
           * @param {string} chainId
           * @returns string
           */

          exports.QUOTE_VALIDATORS = QUOTE_VALIDATORS;

          const getBaseUrlForNewSwapsApi = (type, chainId) => {
            const useDevApis = false;
            const v2ApiBaseUrl = useDevApis ? _swaps.SWAPS_DEV_API_V2_BASE_URL : _swaps.SWAPS_API_V2_BASE_URL;
            const gasApiBaseUrl = useDevApis ? _swaps.GAS_DEV_API_BASE_URL : _swaps.GAS_API_BASE_URL;
            const noNetworkSpecificTypes = ['refreshTime']; // These types don't need network info in the URL.

            if (noNetworkSpecificTypes.includes(type)) {
              return v2ApiBaseUrl;
            }

            const chainIdDecimal = chainId && parseInt(chainId, 16);
            const gasApiTypes = ['gasPrices'];

            if (gasApiTypes.includes(type)) {
              return `${gasApiBaseUrl}/networks/${chainIdDecimal}`; // Gas calculations are in its own repo.
            }

            return `${v2ApiBaseUrl}/networks/${chainIdDecimal}`;
          };

          const getBaseApi = function (type, chainId = _network.CHAIN_IDS.MAINNET) {
            // eslint-disable-next-line no-param-reassign
            chainId = TEST_CHAIN_IDS.includes(chainId) ? _network.CHAIN_IDS.MAINNET : chainId;
            const baseUrl = getBaseUrlForNewSwapsApi(type, chainId);

            if (!baseUrl) {
              throw new Error(`Swaps API calls are disabled for chainId: ${chainId}`);
            }

            switch (type) {
              case 'trade':
                return `${baseUrl}/trades?`;

              case 'tokens':
                return `${baseUrl}/tokens`;

              case 'token':
                return `${baseUrl}/token`;

              case 'topAssets':
                return `${baseUrl}/topAssets`;

              case 'aggregatorMetadata':
                return `${baseUrl}/aggregatorMetadata`;

              case 'gasPrices':
                return `${baseUrl}/gasPrices`;

              case 'network':
                return baseUrl;

              default:
                throw new Error('getBaseApi requires an api call type');
            }
          };

          exports.getBaseApi = getBaseApi;

          function calcTokenValue(value, decimals) {
            const multiplier = Math.pow(10, Number(decimals || 0));
            return new _bignumber.default(String(value)).times(multiplier);
          }

          const shouldEnableDirectWrapping = (chainId, sourceToken, destinationToken) => {
            var _SWAPS_CHAINID_DEFAUL;

            if (!sourceToken || !destinationToken) {
              return false;
            }

            const wrappedToken = _swaps.SWAPS_WRAPPED_TOKENS_ADDRESSES[chainId];
            const nativeToken = (_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address;
            const sourceTokenLowerCase = sourceToken.toLowerCase();
            const destinationTokenLowerCase = destinationToken.toLowerCase();
            return sourceTokenLowerCase === wrappedToken && destinationTokenLowerCase === nativeToken || sourceTokenLowerCase === nativeToken && destinationTokenLowerCase === wrappedToken;
          };
          /**
           * Given and object where all values are strings, returns the same object with all values
           * now prefixed with '0x'
           *
           * @param obj
           */


          exports.shouldEnableDirectWrapping = shouldEnableDirectWrapping;

          function addHexPrefixToObjectValues(obj) {
            return Object.keys(obj).reduce((newObj, key) => {
              return {
                ...newObj,
                [key]: (0, _util.addHexPrefix)(obj[key])
              };
            }, {});
          }
          /**
           * Given the standard set of information about a transaction, returns a transaction properly formatted for
           * publishing via JSON RPC and web3
           *
           * @param {object} options
           * @param {boolean} [options.sendToken] - Indicates whether or not the transaciton is a token transaction
           * @param {string} options.data - A hex string containing the data to include in the transaction
           * @param {string} options.to - A hex address of the tx recipient address
           * @param options.amount
           * @param {string} options.from - A hex address of the tx sender address
           * @param {string} options.gas - A hex representation of the gas value for the transaction
           * @param {string} options.gasPrice - A hex representation of the gas price for the transaction
           * @returns {object} An object ready for submission to the blockchain, with all values appropriately hex prefixed
           */


          function constructTxParams({
            sendToken,
            data,
            to,
            amount,
            from,
            gas,
            gasPrice
          }) {
            const txParams = {
              data,
              from,
              value: '0',
              gas,
              gasPrice
            };

            if (!sendToken) {
              txParams.value = amount;
              txParams.to = to;
            }

            return addHexPrefixToObjectValues(txParams);
          }

          async function fetchTradesInfo({
            slippage,
            sourceToken,
            sourceDecimals,
            destinationToken,
            value,
            fromAddress,
            exchangeList
          }, {
            chainId
          }) {
            const urlParams = {
              destinationToken,
              sourceToken,
              sourceAmount: calcTokenValue(value, sourceDecimals).toString(10),
              slippage,
              timeout: _time.SECOND * 10,
              walletAddress: fromAddress
            };

            if (exchangeList) {
              urlParams.exchangeList = exchangeList;
            }

            if (shouldEnableDirectWrapping(chainId, sourceToken, destinationToken)) {
              urlParams.enableDirectWrapping = true;
            }

            const queryString = new URLSearchParams(urlParams).toString();
            const tradeURL = `${getBaseApi('trade', chainId)}${queryString}`;
            const tradesResponse = await (0, _fetchWithCache.default)(tradeURL, {
              method: 'GET',
              headers: clientIdHeader
            }, {
              cacheRefreshTime: 0,
              timeout: _time.SECOND * 15
            });
            const newQuotes = tradesResponse.reduce((aggIdTradeMap, quote) => {
              if (quote.trade && !quote.error && validateData(QUOTE_VALIDATORS, quote, tradeURL)) {
                const constructedTrade = constructTxParams({
                  to: quote.trade.to,
                  from: quote.trade.from,
                  data: quote.trade.data,
                  amount: (0, _transactionsControllerUtils.decimalToHex)(quote.trade.value),
                  gas: (0, _transactionsControllerUtils.decimalToHex)(quote.maxGas)
                });
                let {
                  approvalNeeded
                } = quote;

                if (approvalNeeded) {
                  approvalNeeded = constructTxParams({
                    ...approvalNeeded
                  });
                }

                return {
                  ...aggIdTradeMap,
                  [quote.aggregator]: {
                    ...quote,
                    slippage,
                    trade: constructedTrade,
                    approvalNeeded
                  }
                };
              }

              return aggIdTradeMap;
            }, {});
            return newQuotes;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\switch-direction.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\switch-direction.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          /**
           * Switch the CSS stylesheet used between 'rtl' and 'ltr'
           *
           * @param {('ltr' | 'rtl' | 'auto')} direction - Text direction, either left-to-right (ltr) or right-to-left (rtl)
           * @returns {Promise<void>}
           */
          const switchDirection = async direction => {
            if (direction === 'auto') {
              // eslint-disable-next-line no-param-reassign
              direction = 'ltr';
            }

            let updatedLink;
            [...document.querySelectorAll('link[rel=stylesheet]')].forEach(link => {
              if (link.title === direction && link.disabled) {
                link.disabled = false;
                updatedLink = link;
              } else if (link.title !== direction && !link.disabled) {
                link.disabled = true;
              }
            });

            if (updatedLink) {
              return new Promise((resolve, reject) => {
                updatedLink.onload = () => {
                  resolve();
                };

                updatedLink.onerror = () => reject(new Error(`Failed to load '${direction}' stylesheet`));
              });
            }

            return undefined;
          };

          var _default = switchDirection;
          exports.default = _default;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", { "../constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", "../modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "../modules/swaps.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\swaps.utils.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\lib\transactions-controller-utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = exports.TRANSACTION_ENVELOPE_TYPE_NAMES = exports.TEN_SECONDS_IN_MILLISECONDS = void 0;
          exports.calcGasTotal = calcGasTotal;
          exports.calcTokenAmount = calcTokenAmount;
          exports.decimalToHex = decimalToHex;
          exports.getSwapsTokensReceivedFromTxMeta = getSwapsTokensReceivedFromTxMeta;
          exports.hexWEIToDecETH = hexWEIToDecETH;
          exports.hexWEIToDecGWEI = hexWEIToDecGWEI;
          exports.toPrecisionWithoutTrailingZeros = toPrecisionWithoutTrailingZeros;

          var _bignumber = _interopRequireDefault(require("bignumber.js"));

          var _transaction = require("../constants/transaction");

          var _conversion = require("../modules/conversion.utils");

          var _swaps = require("../modules/swaps.utils");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          const TOKEN_TRANSFER_LOG_TOPIC_HASH = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
          const TRANSACTION_NO_CONTRACT_ERROR_KEY = 'transactionErrorNoContract';
          exports.TRANSACTION_NO_CONTRACT_ERROR_KEY = TRANSACTION_NO_CONTRACT_ERROR_KEY;
          const TEN_SECONDS_IN_MILLISECONDS = 10000;
          exports.TEN_SECONDS_IN_MILLISECONDS = TEN_SECONDS_IN_MILLISECONDS;

          function calcGasTotal(gasLimit = '0', gasPrice = '0') {
            return (0, _conversion.multiplyCurrencies)(gasLimit, gasPrice, {
              toNumericBase: 'hex',
              multiplicandBase: 16,
              multiplierBase: 16
            });
          }
          /**
           * Given a number and specified precision, returns that number in base 10 with a maximum of precision
           * significant digits, but without any trailing zeros after the decimal point To be used when wishing
           * to display only as much digits to the user as necessary
           *
           * @param {string | number | BigNumber} n - The number to format
           * @param {number} precision - The maximum number of significant digits in the return value
           * @returns {string} The number in decimal form, with <= precision significant digits and no decimal trailing zeros
           */


          function toPrecisionWithoutTrailingZeros(n, precision) {
            return new _bignumber.default(n).toPrecision(precision).replace(/(\.[0-9]*[1-9])0*|(\.0*)/u, '$1');
          }

          function calcTokenAmount(value, decimals) {
            const multiplier = Math.pow(10, Number(decimals || 0));
            return new _bignumber.default(String(value)).div(multiplier);
          }

          function getSwapsTokensReceivedFromTxMeta(tokenSymbol, txMeta, tokenAddress, accountAddress, tokenDecimals, approvalTxMeta, chainId) {
            var _txMeta$txReceipt;

            const txReceipt = txMeta === null || txMeta === void 0 ? void 0 : txMeta.txReceipt;
            const networkAndAccountSupports1559 = (txMeta === null || txMeta === void 0 ? void 0 : (_txMeta$txReceipt = txMeta.txReceipt) === null || _txMeta$txReceipt === void 0 ? void 0 : _txMeta$txReceipt.type) === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;

            if ((0, _swaps.isSwapsDefaultTokenSymbol)(tokenSymbol, chainId)) {
              if (!txReceipt || !txMeta || !txMeta.postTxBalance || !txMeta.preTxBalance) {
                return null;
              }

              if (txMeta.swapMetaData && txMeta.preTxBalance === txMeta.postTxBalance) {
                // If preTxBalance and postTxBalance are equal, postTxBalance hasn't been updated on time
                // because of the RPC provider delay, so we return an estimated receiving amount instead.
                return txMeta.swapMetaData.token_to_amount;
              }

              let approvalTxGasCost = '0x0';

              if (approvalTxMeta && approvalTxMeta.txReceipt) {
                approvalTxGasCost = calcGasTotal(approvalTxMeta.txReceipt.gasUsed, networkAndAccountSupports1559 ? approvalTxMeta.txReceipt.effectiveGasPrice // Base fee + priority fee.
                  : approvalTxMeta.txParams.gasPrice);
              }

              const gasCost = calcGasTotal(txReceipt.gasUsed, networkAndAccountSupports1559 ? txReceipt.effectiveGasPrice : txMeta.txParams.gasPrice);
              const totalGasCost = new _bignumber.default(gasCost, 16).plus(approvalTxGasCost, 16).toString(16);
              const preTxBalanceLessGasCost = (0, _conversion.subtractCurrencies)(txMeta.preTxBalance, totalGasCost, {
                aBase: 16,
                bBase: 16,
                toNumericBase: 'hex'
              });
              const ethReceived = (0, _conversion.subtractCurrencies)(txMeta.postTxBalance, preTxBalanceLessGasCost, {
                aBase: 16,
                bBase: 16,
                fromDenomination: 'WEI',
                toDenomination: 'ETH',
                toNumericBase: 'dec',
                numberOfDecimals: 6
              });
              return ethReceived;
            }

            const txReceiptLogs = txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.logs;

            if (txReceiptLogs && (txReceipt === null || txReceipt === void 0 ? void 0 : txReceipt.status) !== '0x0') {
              const tokenTransferLog = txReceiptLogs.find(txReceiptLog => {
                const isTokenTransfer = txReceiptLog.topics && txReceiptLog.topics[0] === TOKEN_TRANSFER_LOG_TOPIC_HASH;
                const isTransferFromGivenToken = txReceiptLog.address === tokenAddress;
                const isTransferFromGivenAddress = txReceiptLog.topics && txReceiptLog.topics[2] && txReceiptLog.topics[2].match(accountAddress.slice(2));
                return isTokenTransfer && isTransferFromGivenToken && isTransferFromGivenAddress;
              });
              return tokenTransferLog ? toPrecisionWithoutTrailingZeros(calcTokenAmount(tokenTransferLog.data, tokenDecimals).toString(10), 6) : '';
            }

            return null;
          }

          const TRANSACTION_ENVELOPE_TYPE_NAMES = {
            FEE_MARKET: 'fee-market',
            LEGACY: 'legacy'
          };
          exports.TRANSACTION_ENVELOPE_TYPE_NAMES = TRANSACTION_ENVELOPE_TYPE_NAMES;

          function hexWEIToDecGWEI(decGWEI) {
            return (0, _conversion.conversionUtil)(decGWEI, {
              fromNumericBase: 'hex',
              toNumericBase: 'dec',
              fromDenomination: 'WEI',
              toDenomination: 'GWEI'
            });
          }

          function decimalToHex(decimal) {
            return (0, _conversion.conversionUtil)(decimal, {
              fromNumericBase: 'dec',
              toNumericBase: 'hex'
            });
          }

          function hexWEIToDecETH(hexWEI) {
            return (0, _conversion.conversionUtil)(hexWEI, {
              fromNumericBase: 'hex',
              toNumericBase: 'dec',
              fromDenomination: 'WEI',
              toDenomination: 'ETH'
            });
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\contract-utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.readAddressAsContract = void 0;

          const readAddressAsContract = async (ethQuery, address) => {
            let contractCode;

            try {
              contractCode = await ethQuery.getCode(address);
            } catch (e) {
              contractCode = null;
            }

            const isContractAddress = contractCode && contractCode !== '0x' && contractCode !== '0x0';
            return {
              contractCode,
              isContractAddress
            };
          };

          exports.readAddressAsContract = readAddressAsContract;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", { "./hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\conversion.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.conversionUtil = exports.conversionMax = exports.conversionLessThan = exports.conversionLTE = exports.conversionGreaterThan = exports.conversionGTE = exports.addCurrencies = void 0;
          exports.decGWEIToHexWEI = decGWEIToHexWEI;
          exports.toNormalizedDenomination = exports.toNegative = exports.toBigNumber = exports.subtractCurrencies = exports.multiplyCurrencies = exports.divideCurrencies = void 0;

          var _bignumber = _interopRequireDefault(require("bignumber.js"));

          var _ethereumjsUtil = require("ethereumjs-util");

          var _hexstringUtils = require("./hexstring-utils");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          /**
           * Currency Conversion Utility
           * This utility function can be used for converting currency related values within metamask.
           * The caller should be able to pass it a value, along with information about the value's
           * numeric base, denomination and currency, and the desired numeric base, denomination and
           * currency. It should return a single value.
           *
           * @param {(number | string | BN)} value - The value to convert.
           * @param {object} [options] - Options to specify details of the conversion
           * @param {string} [options.fromCurrency = 'ETH' | 'USD'] - The currency of the passed value
           * @param {string} [options.toCurrency = 'ETH' | 'USD'] - The desired currency of the result
           * @param {string} [options.fromNumericBase = 'hex' | 'dec' | 'BN'] - The numeric basic of the passed value.
           * @param {string} [options.toNumericBase = 'hex' | 'dec' | 'BN'] - The desired numeric basic of the result.
           * @param {string} [options.fromDenomination = 'WEI'] - The denomination of the passed value
           * @param {string} [options.numberOfDecimals] - The desired number of decimals in the result
           * @param {string} [options.roundDown] - The desired number of decimals to round down to
           * @param {number} [options.conversionRate] - The rate to use to make the fromCurrency -> toCurrency conversion
           * @returns {(number | string | BN)}
           *
           * The utility passes value along with the options as a single object to the `converter` function.
           * `converter` conditional modifies the supplied `value` property, depending
           * on the accompanying options.
           */
          // Big Number Constants
          const BIG_NUMBER_WEI_MULTIPLIER = new _bignumber.default('1000000000000000000');
          const BIG_NUMBER_GWEI_MULTIPLIER = new _bignumber.default('1000000000');
          const BIG_NUMBER_ETH_MULTIPLIER = new _bignumber.default('1'); // Setter Maps

          const toBigNumber = {
            hex: n => new _bignumber.default((0, _hexstringUtils.stripHexPrefix)(n), 16),
            dec: n => new _bignumber.default(String(n), 10),
            BN: n => new _bignumber.default(n.toString(16), 16)
          };
          exports.toBigNumber = toBigNumber;
          const toNormalizedDenomination = {
            WEI: bigNumber => bigNumber.div(BIG_NUMBER_WEI_MULTIPLIER),
            GWEI: bigNumber => bigNumber.div(BIG_NUMBER_GWEI_MULTIPLIER),
            ETH: bigNumber => bigNumber.div(BIG_NUMBER_ETH_MULTIPLIER)
          };
          exports.toNormalizedDenomination = toNormalizedDenomination;
          const toSpecifiedDenomination = {
            WEI: bigNumber => bigNumber.times(BIG_NUMBER_WEI_MULTIPLIER).round(),
            GWEI: bigNumber => bigNumber.times(BIG_NUMBER_GWEI_MULTIPLIER).round(9),
            ETH: bigNumber => bigNumber.times(BIG_NUMBER_ETH_MULTIPLIER).round(9)
          };
          const baseChange = {
            hex: n => n.toString(16),
            dec: n => new _bignumber.default(n).toString(10),
            BN: n => new _ethereumjsUtil.BN(n.toString(16))
          }; // Utility function for checking base types

          const isValidBase = base => {
            return Number.isInteger(base) && base > 1;
          };
          /**
           * Defines the base type of numeric value
           *
           * @typedef {('hex' | 'dec' | 'BN')} NumericBase
           */

          /**
           * Defines which type of denomination a value is in
           *
           * @typedef {('WEI' | 'GWEI' | 'ETH')} EthDenomination
           */

          /**
           * Utility method to convert a value between denominations, formats and currencies.
           *
           * @param {object} input
           * @param {string | BigNumber} input.value
           * @param {NumericBase} input.fromNumericBase
           * @param {EthDenomination} [input.fromDenomination]
           * @param {string} [input.fromCurrency]
           * @param {NumericBase} input.toNumericBase
           * @param {EthDenomination} [input.toDenomination]
           * @param {string} [input.toCurrency]
           * @param {number} [input.numberOfDecimals]
           * @param {number} [input.conversionRate]
           * @param {boolean} [input.invertConversionRate]
           * @param {string} [input.roundDown]
           */


          const converter = ({
            value,
            fromNumericBase,
            fromDenomination,
            fromCurrency,
            toNumericBase,
            toDenomination,
            toCurrency,
            numberOfDecimals,
            conversionRate,
            invertConversionRate,
            roundDown
          }) => {
            let convertedValue = fromNumericBase ? toBigNumber[fromNumericBase](value) : value;

            if (fromDenomination) {
              convertedValue = toNormalizedDenomination[fromDenomination](convertedValue);
            }

            if (fromCurrency !== toCurrency) {
              if (conversionRate === null || conversionRate === undefined) {
                throw new Error(`Converting from ${fromCurrency} to ${toCurrency} requires a conversionRate, but one was not provided`);
              }

              let rate = toBigNumber.dec(conversionRate);

              if (invertConversionRate) {
                rate = new _bignumber.default(1.0).div(conversionRate);
              }

              convertedValue = convertedValue.times(rate);
            }

            if (toDenomination) {
              convertedValue = toSpecifiedDenomination[toDenomination](convertedValue);
            }

            if (numberOfDecimals !== undefined && numberOfDecimals !== null) {
              convertedValue = convertedValue.round(numberOfDecimals, _bignumber.default.ROUND_HALF_DOWN);
            }

            if (roundDown) {
              convertedValue = convertedValue.round(roundDown, _bignumber.default.ROUND_DOWN);
            }

            if (toNumericBase) {
              convertedValue = baseChange[toNumericBase](convertedValue);
            }

            return convertedValue;
          };

          const conversionUtil = (value, {
            fromCurrency = null,
            toCurrency = fromCurrency,
            fromNumericBase,
            toNumericBase,
            fromDenomination,
            toDenomination,
            numberOfDecimals,
            conversionRate,
            invertConversionRate
          }) => {
            if (fromCurrency !== toCurrency && !conversionRate) {
              return 0;
            }

            return converter({
              fromCurrency,
              toCurrency,
              fromNumericBase,
              toNumericBase,
              fromDenomination,
              toDenomination,
              numberOfDecimals,
              conversionRate,
              invertConversionRate,
              value: value || '0'
            });
          };

          exports.conversionUtil = conversionUtil;

          const getBigNumber = (value, base) => {
            if (!isValidBase(base)) {
              throw new Error('Must specify valid base');
            } // We don't include 'number' here, because BigNumber will throw if passed
            // a number primitive it considers unsafe.


            if (typeof value === 'string' || value instanceof _bignumber.default) {
              return new _bignumber.default(value, base);
            }

            return new _bignumber.default(String(value), base);
          };

          const addCurrencies = (a, b, options = {}) => {
            const {
              aBase,
              bBase,
              ...conversionOptions
            } = options;

            if (!isValidBase(aBase) || !isValidBase(bBase)) {
              throw new Error('Must specify valid aBase and bBase');
            }

            const value = getBigNumber(a, aBase).add(getBigNumber(b, bBase));
            return converter({
              value,
              ...conversionOptions
            });
          };

          exports.addCurrencies = addCurrencies;

          const subtractCurrencies = (a, b, options = {}) => {
            const {
              aBase,
              bBase,
              ...conversionOptions
            } = options;

            if (!isValidBase(aBase) || !isValidBase(bBase)) {
              throw new Error('Must specify valid aBase and bBase');
            }

            const value = getBigNumber(a, aBase).minus(getBigNumber(b, bBase));
            return converter({
              value,
              ...conversionOptions
            });
          };

          exports.subtractCurrencies = subtractCurrencies;

          const multiplyCurrencies = (a, b, options = {}) => {
            const {
              multiplicandBase,
              multiplierBase,
              ...conversionOptions
            } = options;

            if (!isValidBase(multiplicandBase) || !isValidBase(multiplierBase)) {
              throw new Error('Must specify valid multiplicandBase and multiplierBase');
            }

            const value = getBigNumber(a, multiplicandBase).times(getBigNumber(b, multiplierBase));
            return converter({
              value,
              ...conversionOptions
            });
          };

          exports.multiplyCurrencies = multiplyCurrencies;

          const divideCurrencies = (a, b, options = {}) => {
            const {
              dividendBase,
              divisorBase,
              ...conversionOptions
            } = options;

            if (!isValidBase(dividendBase) || !isValidBase(divisorBase)) {
              throw new Error('Must specify valid dividendBase and divisorBase');
            }

            const value = getBigNumber(a, dividendBase).div(getBigNumber(b, divisorBase));
            return converter({
              value,
              ...conversionOptions
            });
          };

          exports.divideCurrencies = divideCurrencies;

          const conversionGreaterThan = ({ ...firstProps
          }, { ...secondProps
          }) => {
            const firstValue = converter({
              ...firstProps
            });
            const secondValue = converter({
              ...secondProps
            });
            return firstValue.gt(secondValue);
          };

          exports.conversionGreaterThan = conversionGreaterThan;

          const conversionLessThan = ({ ...firstProps
          }, { ...secondProps
          }) => {
            const firstValue = converter({
              ...firstProps
            });
            const secondValue = converter({
              ...secondProps
            });
            return firstValue.lt(secondValue);
          };

          exports.conversionLessThan = conversionLessThan;

          const conversionMax = ({ ...firstProps
          }, { ...secondProps
          }) => {
            const firstIsGreater = conversionGreaterThan({
              ...firstProps
            }, {
              ...secondProps
            });
            return firstIsGreater ? firstProps.value : secondProps.value;
          };

          exports.conversionMax = conversionMax;

          const conversionGTE = ({ ...firstProps
          }, { ...secondProps
          }) => {
            const firstValue = converter({
              ...firstProps
            });
            const secondValue = converter({
              ...secondProps
            });
            return firstValue.greaterThanOrEqualTo(secondValue);
          };

          exports.conversionGTE = conversionGTE;

          const conversionLTE = ({ ...firstProps
          }, { ...secondProps
          }) => {
            const firstValue = converter({
              ...firstProps
            });
            const secondValue = converter({
              ...secondProps
            });
            return firstValue.lessThanOrEqualTo(secondValue);
          };

          exports.conversionLTE = conversionLTE;

          const toNegative = (n, options = {}) => {
            return multiplyCurrencies(n, -1, options);
          };

          exports.toNegative = toNegative;

          function decGWEIToHexWEI(decGWEI) {
            return conversionUtil(decGWEI, {
              fromNumericBase: 'dec',
              toNumericBase: 'hex',
              fromDenomination: 'GWEI',
              toDenomination: 'WEI'
            });
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js", { "../constants/time": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\time.ts", "lodash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\fetch-with-timeout.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _lodash = require("lodash");

          var _time = require("../constants/time");

          const getFetchWithTimeout = (0, _lodash.memoize)((timeout = _time.SECOND * 30) => {
            if (!Number.isInteger(timeout) || timeout < 1) {
              throw new Error('Must specify positive integer timeout.');
            }

            return async function _fetch(url, opts) {
              const abortController = new window.AbortController();
              const {
                signal
              } = abortController;
              const f = window.fetch(url, {
                ...opts,
                signal
              });
              const timer = setTimeout(() => abortController.abort(), timeout);

              try {
                const res = await f;
                clearTimeout(timer);
                return res;
              } catch (e) {
                clearTimeout(timer);
                throw e;
              }
            };
          });
          var _default = getFetchWithTimeout;
          exports.default = _default;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\gas.utils.js", { "./conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\gas.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getMaximumGasTotalInHexWei = getMaximumGasTotalInHexWei;
          exports.getMinimumGasTotalInHexWei = getMinimumGasTotalInHexWei;

          var _ethereumjsUtil = require("ethereumjs-util");

          var _conversion = require("./conversion.utils");

          /**
           * Accepts an options bag containing gas fee parameters in hex format and
           * returns a gasTotal parameter representing the maximum amount of wei the
           * transaction will cost.
           *
           * @param {object} options - gas fee parameters object
           * @param {string} [options.gasLimit] - the maximum amount of gas to allow this
           *  transaction to consume. Value is a hex string
           * @param {string} [options.gasPrice] - The fee in wei to pay per gas used.
           *  gasPrice is only set on Legacy type transactions. Value is hex string
           * @param {string} [options.maxFeePerGas] - The maximum fee in wei to pay per
           *  gas used. maxFeePerGas is introduced in EIP 1559 and represents the max
           *  total a user will pay per gas. Actual cost is determined by baseFeePerGas
           *  on the block + maxPriorityFeePerGas. Value is hex string
           * @returns {string} The maximum total cost of transaction in hex wei string
           */
          function getMaximumGasTotalInHexWei({
            gasLimit = '0x0',
            gasPrice,
            maxFeePerGas
          } = {}) {
            if (maxFeePerGas) {
              return (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit, maxFeePerGas, {
                toNumericBase: 'hex',
                multiplicandBase: 16,
                multiplierBase: 16
              }));
            }

            if (!gasPrice) {
              throw new Error('getMaximumGasTotalInHexWei requires gasPrice be provided to calculate legacy gas total');
            }

            return (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit, gasPrice, {
              toNumericBase: 'hex',
              multiplicandBase: 16,
              multiplierBase: 16
            }));
          }
          /**
           * Accepts an options bag containing gas fee parameters in hex format and
           * returns a gasTotal parameter representing the minimum amount of wei the
           * transaction will cost. For gasPrice types this is the same as max.
           *
           * @param {object} options - gas fee parameters object
           * @param {string} [options.gasLimit] - the maximum amount of gas to allow this
           *  transaction to consume. Value is a hex string
           * @param {string} [options.gasPrice] - The fee in wei to pay per gas used.
           *  gasPrice is only set on Legacy type transactions. Value is hex string
           * @param {string} [options.maxFeePerGas] - The maximum fee in wei to pay per
           *  gas used. maxFeePerGas is introduced in EIP 1559 and represents the max
           *  total a user will pay per gas. Actual cost is determined by baseFeePerGas
           *  on the block + maxPriorityFeePerGas. Value is hex string
           * @param {string} [options.maxPriorityFeePerGas] - The maximum fee in wei to
           *  pay a miner to include this transaction.
           * @param {string} [options.baseFeePerGas] - The estimated block baseFeePerGas
           *  that will be burned. Introduced in EIP 1559. Value in hex wei.
           * @returns {string} The minimum total cost of transaction in hex wei string
           */


          function getMinimumGasTotalInHexWei({
            gasLimit = '0x0',
            gasPrice,
            maxPriorityFeePerGas,
            maxFeePerGas,
            baseFeePerGas
          } = {}) {
            const isEIP1559Estimate = Boolean(maxFeePerGas || maxPriorityFeePerGas || baseFeePerGas);

            if (isEIP1559Estimate && gasPrice) {
              throw new Error(`getMinimumGasTotalInHexWei expects either gasPrice OR the EIP-1559 gas fields, but both were provided`);
            }

            if (isEIP1559Estimate === false && !gasPrice) {
              throw new Error(`getMinimumGasTotalInHexWei expects either gasPrice OR the EIP-1559 gas fields, but neither were provided`);
            }

            if (isEIP1559Estimate && !baseFeePerGas) {
              throw new Error(`getMinimumGasTotalInHexWei requires baseFeePerGas be provided when calculating EIP-1559 totals`);
            }

            if (isEIP1559Estimate && (!maxFeePerGas || !maxPriorityFeePerGas)) {
              throw new Error(`getMinimumGasTotalInHexWei requires maxFeePerGas and maxPriorityFeePerGas be provided when calculating EIP-1559 totals`);
            }

            if (isEIP1559Estimate === false) {
              return getMaximumGasTotalInHexWei({
                gasLimit,
                gasPrice
              });
            }

            const minimumFeePerGas = (0, _conversion.addCurrencies)(baseFeePerGas, maxPriorityFeePerGas, {
              toNumericBase: 'hex',
              aBase: 16,
              bBase: 16
            });

            if ((0, _conversion.conversionGreaterThan)({
              value: minimumFeePerGas,
              fromNumericBase: 'hex'
            }, {
              value: maxFeePerGas,
              fromNumericBase: 'hex'
            })) {
              return getMaximumGasTotalInHexWei({
                gasLimit,
                maxFeePerGas
              });
            }

            return (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit, minimumFeePerGas, {
              toNumericBase: 'hex',
              multiplicandBase: 16,
              multiplierBase: 16
            }));
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", { "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\hexstring-utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.BURN_ADDRESS = void 0;
          exports.isBurnAddress = isBurnAddress;
          exports.isValidHexAddress = isValidHexAddress;
          exports.stripHexPrefix = stripHexPrefix;
          exports.toChecksumHexAddress = toChecksumHexAddress;

          var _ethereumjsUtil = require("ethereumjs-util");

          const BURN_ADDRESS = (0, _ethereumjsUtil.zeroAddress)();
          exports.BURN_ADDRESS = BURN_ADDRESS;

          function isBurnAddress(address) {
            return address === BURN_ADDRESS;
          }
          /**
           * Validates that the input is a hex address. This utility method is a thin
           * wrapper around ethereumjs-util.isValidAddress, with the exception that it
           * does not throw an error when provided values that are not hex strings. In
           * addition, and by default, this method will return true for hex strings that
           * meet the length requirement of a hex address, but are not prefixed with `0x`
           * Finally, if the mixedCaseUseChecksum flag is true and a mixed case string is
           * provided this method will validate it has the proper checksum formatting.
           *
           * @param {string} possibleAddress - Input parameter to check against
           * @param {object} [options] - options bag
           * @param {boolean} [options.allowNonPrefixed] - If true will first ensure '0x'
           *  is prepended to the string
           * @param {boolean} [options.mixedCaseUseChecksum] - If true will treat mixed
           *  case addresses as checksum addresses and validate that proper checksum
           *  format is used
           * @returns {boolean} whether or not the input is a valid hex address
           */


          function isValidHexAddress(possibleAddress, {
            allowNonPrefixed = true,
            mixedCaseUseChecksum = false
          } = {}) {
            const addressToCheck = allowNonPrefixed ? (0, _ethereumjsUtil.addHexPrefix)(possibleAddress) : possibleAddress;

            if (!(0, _ethereumjsUtil.isHexString)(addressToCheck)) {
              return false;
            }

            if (mixedCaseUseChecksum) {
              const prefixRemoved = addressToCheck.slice(2);
              const lower = prefixRemoved.toLowerCase();
              const upper = prefixRemoved.toUpperCase();
              const allOneCase = prefixRemoved === lower || prefixRemoved === upper;

              if (!allOneCase) {
                return (0, _ethereumjsUtil.isValidChecksumAddress)(addressToCheck);
              }
            }

            return (0, _ethereumjsUtil.isValidAddress)(addressToCheck);
          }

          function toChecksumHexAddress(address) {
            if (!address) {
              // our internal checksumAddress function that this method replaces would
              // return an empty string for nullish input. If any direct usages of
              // ethereumjs-util.toChecksumAddress were called with nullish input it
              // would have resulted in an error on version 5.1.
              return '';
            }

            const hexPrefixed = (0, _ethereumjsUtil.addHexPrefix)(address);

            if (!(0, _ethereumjsUtil.isHexString)(hexPrefixed)) {
              // Version 5.1 of ethereumjs-utils would have returned '0xY' for input 'y'
              // but we shouldn't waste effort trying to change case on a clearly invalid
              // string. Instead just return the hex prefixed original string which most
              // closely mimics the original behavior.
              return hexPrefixed;
            }

            return (0, _ethereumjsUtil.toChecksumAddress)(hexPrefixed);
          }

          function stripHexPrefix(str) {
            if (typeof str !== 'string') {
              return str;
            }

            return (0, _ethereumjsUtil.isHexPrefixed)(str) ? str.slice(2) : str;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\mv3.utils.js", { "webextension-polyfill": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\webextension-polyfill\\dist\\browser-polyfill.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\mv3.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.isManifestV3 = void 0;

          var _webextensionPolyfill = _interopRequireDefault(require("webextension-polyfill"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          const isManifestV3 = _webextensionPolyfill.default.runtime.getManifest().manifest_version === 3;
          exports.isManifestV3 = isManifestV3;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\network.utils.js", { "../constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\network.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.isPrefixedFormattedHexString = isPrefixedFormattedHexString;
          exports.isSafeChainId = isSafeChainId;
          exports.isTokenDetectionEnabledForNetwork = isTokenDetectionEnabledForNetwork;

          var _network = require("../constants/network");

          /**
           * Checks whether the given number primitive chain ID is safe.
           * Because some cryptographic libraries we use expect the chain ID to be a
           * number primitive, it must not exceed a certain size.
           *
           * @param {number} chainId - The chain ID to check for safety.
           * @returns {boolean} Whether the given chain ID is safe.
           */
          function isSafeChainId(chainId) {
            return Number.isSafeInteger(chainId) && chainId > 0 && chainId <= _network.MAX_SAFE_CHAIN_ID;
          }
          /**
           * Checks whether the given value is a 0x-prefixed, non-zero, non-zero-padded,
           * hexadecimal string.
           *
           * @param {any} value - The value to check.
           * @returns {boolean} True if the value is a correctly formatted hex string,
           * false otherwise.
           */


          function isPrefixedFormattedHexString(value) {
            if (typeof value !== 'string') {
              return false;
            }

            return /^0x[1-9a-f]+[0-9a-f]*$/iu.test(value);
          }
          /**
           * Check if token detection is enabled for certain networks
           *
           * @param chainId - ChainID of network
           * @returns Whether the current network supports token detection
           */


          function isTokenDetectionEnabledForNetwork(chainId) {
            switch (chainId) {
              case _network.CHAIN_IDS.MAINNET:
              case _network.CHAIN_IDS.BSC:
              case _network.CHAIN_IDS.POLYGON:
              case _network.CHAIN_IDS.AVALANCHE:
                return true;

              default:
                return false;
            }
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\object.utils.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\object.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.maskObject = maskObject;

          /**
           * Return a "masked" copy of the given object.
           *
           * The returned object includes only the properties present in the mask. The
           * mask is an object that mirrors the structure of the given object, except
           * the only values are `true` or a sub-mask. `true` implies the property
           * should be included, and a sub-mask implies the property should be further
           * masked according to that sub-mask.
           *
           * @param {object} object - The object to mask
           * @param {Object<object | boolean>} mask - The mask to apply to the object
           */
          function maskObject(object, mask) {
            return Object.keys(object).reduce((state, key) => {
              if (mask[key] === true) {
                state[key] = object[key];
              } else if (mask[key]) {
                state[key] = maskObject(object[key], mask[key]);
              }

              return state;
            }, {});
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\random-id.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\random-id.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = createRandomId;
          const MAX = Number.MAX_SAFE_INTEGER;
          let idCounter = Math.round(Math.random() * MAX);

          function createRandomId() {
            idCounter %= MAX; // eslint-disable-next-line no-plusplus

            return idCounter++;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\rpc.utils.js", { "./fetch-with-timeout": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\rpc.utils.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";

              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.jsonRpcRequest = jsonRpcRequest;

              var _fetchWithTimeout = _interopRequireDefault(require("./fetch-with-timeout"));

              function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

              const fetchWithTimeout = (0, _fetchWithTimeout.default)();
              /**
               * Makes a JSON RPC request to the given URL, with the given RPC method and params.
               *
               * @param {string} rpcUrl - The RPC endpoint URL to target.
               * @param {string} rpcMethod - The RPC method to request.
               * @param {Array<unknown>} [rpcParams] - The RPC method params.
               * @returns {Promise<unknown|undefined>} Returns the result of the RPC method call,
               * or throws an error in case of failure.
               */

              async function jsonRpcRequest(rpcUrl, rpcMethod, rpcParams = []) {
                let fetchUrl = rpcUrl;
                const headers = {
                  'Content-Type': 'application/json'
                }; // Convert basic auth URL component to Authorization header

                const {
                  origin,
                  pathname,
                  username,
                  password,
                  search
                } = new URL(rpcUrl); // URLs containing username and password needs special processing

                if (username && password) {
                  const encodedAuth = Buffer.from(`${username}:${password}`).toString('base64');
                  headers.Authorization = `Basic ${encodedAuth}`;
                  fetchUrl = `${origin}${pathname}${search}`;
                }

                const jsonRpcResponse = await fetchWithTimeout(fetchUrl, {
                  method: 'POST',
                  body: JSON.stringify({
                    id: Date.now().toString(),
                    jsonrpc: '2.0',
                    method: rpcMethod,
                    params: rpcParams
                  }),
                  headers,
                  cache: 'default'
                }).then(httpResponse => httpResponse.json());

                if (!jsonRpcResponse || Array.isArray(jsonRpcResponse) || typeof jsonRpcResponse !== 'object') {
                  throw new Error(`RPC endpoint ${rpcUrl} returned non-object response.`);
                }

                const {
                  error,
                  result
                } = jsonRpcResponse;

                if (error) {
                  throw new Error((error === null || error === void 0 ? void 0 : error.message) || error);
                }

                return result;
              }

            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\siwe.js", { "./hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "@spruceid/siwe-parser": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@spruceid\\siwe-parser\\dist\\parsers.js", "buffer": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\browserify\\node_modules\\buffer\\index.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\siwe.js
        return function (require, module, exports) {
          (function (Buffer) {
            (function () {
              "use strict";

              Object.defineProperty(exports, "__esModule", {
                value: true
              });
              exports.formatMessageParams = exports.detectSIWE = void 0;

              var _siweParser = require("@spruceid/siwe-parser");

              var _loglevel = _interopRequireDefault(require("loglevel"));

              var _hexstringUtils = require("./hexstring-utils");

              function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

              const msgHexToText = hex => {
                try {
                  const stripped = (0, _hexstringUtils.stripHexPrefix)(hex);
                  const buff = Buffer.from(stripped, 'hex');
                  return buff.length === 32 ? hex : buff.toString('utf8');
                } catch (e) {
                  _loglevel.default.error(e);

                  return hex;
                }
              };
              /**
               * A locally defined object used to provide data to identify a Sign-In With Ethereum (SIWE)(EIP-4361) message and provide the parsed message
               *
               * @typedef localSIWEObject
               * @param {boolean} isSIWEMessage - Does the intercepted message conform to the SIWE specification?
               * @param {ParsedMessage} parsedMessage - The data parsed out of the message
               */

              /**
               * This function intercepts a sign message, detects if it's a
               * Sign-In With Ethereum (SIWE)(EIP-4361) message, and returns an object with
               * relevant SIWE data.
               *
               * {@see {@link https://eips.ethereum.org/EIPS/eip-4361}}
               *
               * @param {object} msgParams - The params of the message to sign
               * @returns {localSIWEObject}
               */


              const detectSIWE = msgParams => {
                try {
                  const {
                    data
                  } = msgParams;
                  const message = msgHexToText(data);
                  const parsedMessage = new _siweParser.ParsedMessage(message);
                  return {
                    isSIWEMessage: true,
                    parsedMessage
                  };
                } catch (error) {
                  // ignore error, it's not a valid SIWE message
                  return {
                    isSIWEMessage: false,
                    parsedMessage: null
                  };
                }
              };
              /**
               * Takes in a parsed Sign-In with Ethereum Message (EIP-4361)
               * and generates an array of label-value pairs
               *
               * @param {object} parsedMessage - A parsed SIWE message with message contents
               * @param {Function} t - i18n function
               * @returns {Array} An array of label-value pairs with the type of the value as the label
               */


              exports.detectSIWE = detectSIWE;

              const formatMessageParams = (parsedMessage, t) => {
                const output = [];
                const {
                  statement,
                  uri,
                  version,
                  chainId,
                  nonce,
                  issuedAt,
                  expirationTime,
                  notBefore,
                  requestId,
                  resources
                } = parsedMessage;

                if (statement) {
                  output.push({
                    label: t('SIWELabelMessage'),
                    value: statement
                  });
                }

                if (uri) {
                  output.push({
                    label: t('SIWELabelURI'),
                    value: uri
                  });
                }

                if (version) {
                  output.push({
                    label: t('SIWELabelVersion'),
                    value: version
                  });
                }

                if (chainId) {
                  output.push({
                    label: t('SIWELabelChainID'),
                    value: chainId
                  });
                }

                if (nonce) {
                  output.push({
                    label: t('SIWELabelNonce'),
                    value: nonce
                  });
                }

                if (issuedAt) {
                  output.push({
                    label: t('SIWELabelIssuedAt'),
                    value: issuedAt
                  });
                }

                if (expirationTime) {
                  output.push({
                    label: t('SIWELabelExpirationTime'),
                    value: expirationTime
                  });
                }

                if (notBefore) {
                  output.push({
                    label: t('SIWELabelNotBefore'),
                    value: notBefore
                  });
                }

                if (requestId) {
                  output.push({
                    label: t('SIWELabelRequestID'),
                    value: requestId
                  });
                }

                if (resources && resources.length > 0) {
                  output.push({
                    label: t('SIWELabelResources', [resources.length]),
                    value: resources.reduce((previous, resource) => `${previous}${resource}\n`, '').trim()
                  });
                }

                return output;
              };

              exports.formatMessageParams = formatMessageParams;

            }).call(this)
          }).call(this, require("buffer").Buffer)

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\string-utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.isEqualCaseInsensitive = isEqualCaseInsensitive;
          exports.prependZero = prependZero;

          function isEqualCaseInsensitive(value1, value2) {
            if (typeof value1 !== 'string' || typeof value2 !== 'string') {
              return false;
            }

            return value1.toLowerCase() === value2.toLowerCase();
          }

          function prependZero(num, maxLength) {
            return num.toString().padStart(maxLength, '0');
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\swaps.utils.js", { "../constants/swaps": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\swaps.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\swaps.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.isSwapsDefaultTokenAddress = isSwapsDefaultTokenAddress;
          exports.isSwapsDefaultTokenSymbol = isSwapsDefaultTokenSymbol;

          var _swaps = require("../constants/swaps");

          /**
           * Checks whether the provided address is strictly equal to the address for
           * the default swaps token of the provided chain.
           *
           * @param {string} address - The string to compare to the default token address
           * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
           * @returns {boolean} Whether the address is the provided chain's default token address
           */
          function isSwapsDefaultTokenAddress(address, chainId) {
            var _SWAPS_CHAINID_DEFAUL;

            if (!address || !chainId) {
              return false;
            }

            return address === ((_SWAPS_CHAINID_DEFAUL = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL.address);
          }
          /**
           * Checks whether the provided symbol is strictly equal to the symbol for
           * the default swaps token of the provided chain.
           *
           * @param {string} symbol - The string to compare to the default token symbol
           * @param {string} chainId - The hex encoded chain ID of the default swaps token to check
           * @returns {boolean} Whether the symbl is the provided chain's default token symbol
           */


          function isSwapsDefaultTokenSymbol(symbol, chainId) {
            var _SWAPS_CHAINID_DEFAUL2;

            if (!symbol || !chainId) {
              return false;
            }

            return symbol === ((_SWAPS_CHAINID_DEFAUL2 = _swaps.SWAPS_CHAINID_DEFAULT_TOKEN_MAP[chainId]) === null || _SWAPS_CHAINID_DEFAUL2 === void 0 ? void 0 : _SWAPS_CHAINID_DEFAUL2.symbol);
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js", { "../constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", "./contract-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js", "./string-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js", "@metamask/metamask-eth-abis": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\metamask-eth-abis\\dist\\index.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js", "ethers": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\index.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\modules\transaction.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.determineTransactionAssetType = determineTransactionAssetType;
          exports.determineTransactionContractCode = determineTransactionContractCode;
          exports.determineTransactionType = determineTransactionType;
          exports.isEIP1559Transaction = isEIP1559Transaction;
          exports.isLegacyTransaction = isLegacyTransaction;
          exports.parseStandardTokenTransactionData = parseStandardTokenTransactionData;
          exports.transactionMatchesNetwork = transactionMatchesNetwork;
          exports.txParamsAreDappSuggested = txParamsAreDappSuggested;

          var _ethereumjsUtil = require("ethereumjs-util");

          var _ethers = require("ethers");

          var _metamaskEthAbis = require("@metamask/metamask-eth-abis");

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var _transaction = require("../constants/transaction");

          var _contractUtils = require("./contract-utils");

          var _stringUtils = require("./string-utils");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          /**
           * @typedef { 'transfer' | 'approve' | 'setapprovalforall' | 'transferfrom' | 'contractInteraction'| 'simpleSend' } InferrableTransactionTypes
           */

          /**
           * @typedef {object} InferTransactionTypeResult
           * @property {InferrableTransactionTypes} type - The type of transaction
           * @property {string} getCodeResponse - The contract code, in hex format if
           *  it exists. '0x0' or '0x' are also indicators of non-existent contract
           *  code
           */

          /**
           * @typedef EthersContractCall
           * @type object
           * @property {any[]} args - The args/params to the function call.
           * An array-like object with numerical and string indices.
           * @property {string} name - The name of the function.
           * @property {string} signature - The function signature.
           * @property {string} sighash - The function signature hash.
           * @property {EthersBigNumber} value - The ETH value associated with the call.
           * @property {FunctionFragment} functionFragment - The Ethers function fragment
           * representation of the function.
           */
          const erc20Interface = new _ethers.ethers.utils.Interface(_metamaskEthAbis.abiERC20);
          const erc721Interface = new _ethers.ethers.utils.Interface(_metamaskEthAbis.abiERC721);
          const erc1155Interface = new _ethers.ethers.utils.Interface(_metamaskEthAbis.abiERC1155);

          function transactionMatchesNetwork(transaction, chainId, networkId) {
            if (typeof transaction.chainId !== 'undefined') {
              return transaction.chainId === chainId;
            }

            return transaction.metamaskNetworkId === networkId;
          }
          /**
           * Determines if the maxFeePerGas and maxPriorityFeePerGas fields are supplied
           * and valid inputs. This will return false for non hex string inputs.
           *
           * @param {__import__("../constants/transaction").TransactionMeta} transaction -
           *  the transaction to check
           * @returns {boolean} true if transaction uses valid EIP1559 fields
           */


          function isEIP1559Transaction(transaction) {
            var _transaction$txParams, _transaction$txParams2;

            return (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams = transaction.txParams) === null || _transaction$txParams === void 0 ? void 0 : _transaction$txParams.maxFeePerGas) && (0, _ethereumjsUtil.isHexString)(transaction === null || transaction === void 0 ? void 0 : (_transaction$txParams2 = transaction.txParams) === null || _transaction$txParams2 === void 0 ? void 0 : _transaction$txParams2.maxPriorityFeePerGas);
          }
          /**
           * Determine if the maxFeePerGas and maxPriorityFeePerGas fields are not
           * supplied and that the gasPrice field is valid if it is provided. This will
           * return false if gasPrice is a non hex string.
           *
           * @param {__import__("../constants/transaction").TransactionMeta} transaction -
           *  the transaction to check
           * @returns {boolean} true if transaction uses valid Legacy fields OR lacks
           *  EIP1559 fields
           */


          function isLegacyTransaction(transaction) {
            return typeof transaction.txParams.maxFeePerGas === 'undefined' && typeof transaction.txParams.maxPriorityFeePerGas === 'undefined' && (typeof transaction.txParams.gasPrice === 'undefined' || (0, _ethereumjsUtil.isHexString)(transaction.txParams.gasPrice));
          }
          /**
           * Determine if a transactions gas fees in txParams match those in its dappSuggestedGasFees property
           *
           * @param {__import__("../constants/transaction").TransactionMeta} transaction -
           *  the transaction to check
           * @returns {boolean} true if both the txParams and dappSuggestedGasFees are objects with truthy gas fee properties,
           *   and those properties are strictly equal
           */


          function txParamsAreDappSuggested(transaction) {
            var _transaction$dappSugg, _transaction$dappSugg2, _transaction$dappSugg3;

            const {
              gasPrice,
              maxPriorityFeePerGas,
              maxFeePerGas
            } = (transaction === null || transaction === void 0 ? void 0 : transaction.txParams) || {};
            return gasPrice && gasPrice === (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg === void 0 ? void 0 : _transaction$dappSugg.gasPrice) || maxPriorityFeePerGas && maxFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg2 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg2 === void 0 ? void 0 : _transaction$dappSugg2.maxPriorityFeePerGas) === maxPriorityFeePerGas && (transaction === null || transaction === void 0 ? void 0 : (_transaction$dappSugg3 = transaction.dappSuggestedGasFees) === null || _transaction$dappSugg3 === void 0 ? void 0 : _transaction$dappSugg3.maxFeePerGas) === maxFeePerGas;
          }
          /**
           * Attempts to decode transaction data using ABIs for three different token standards: ERC20, ERC721, ERC1155.
           * The data will decode correctly if the transaction is an interaction with a contract that matches one of these
           * contract standards
           *
           * @param data - encoded transaction data
           * @returns {EthersContractCall | undefined}
           */


          function parseStandardTokenTransactionData(data) {
            try {
              return erc20Interface.parseTransaction({
                data
              });
            } catch {// ignore and next try to parse with erc721 ABI
            }

            try {
              return erc721Interface.parseTransaction({
                data
              });
            } catch {// ignore and next try to parse with erc1155 ABI
            }

            try {
              return erc1155Interface.parseTransaction({
                data
              });
            } catch {// ignore and return undefined
            }

            return undefined;
          }
          /**
           * Determines the contractCode of the transaction by analyzing the txParams.
           *
           * @param {object} txParams - Parameters for the transaction
           * @param {EthQuery} query - EthQuery instance
           * @returns {InferTransactionTypeResult}
           */


          async function determineTransactionContractCode(txParams, query) {
            const {
              to
            } = txParams;
            const {
              contractCode
            } = await (0, _contractUtils.readAddressAsContract)(query, to);
            return contractCode;
          }
          /**
           * Determines the type of the transaction by analyzing the txParams.
           * This method will return one of the types defined in shared/constants/transactions
           * It will never return TRANSACTION_TYPE_CANCEL or TRANSACTION_TYPE_RETRY as these
           * represent specific events that we control from the extension and are added manually
           * at transaction creation.
           *
           * @param {object} txParams - Parameters for the transaction
           * @param {EthQuery} query - EthQuery instance
           * @returns {InferTransactionTypeResult}
           */


          async function determineTransactionType(txParams, query) {
            const {
              data,
              to
            } = txParams;
            let name;

            try {
              ({
                name
              } = data && parseStandardTokenTransactionData(data));
            } catch (error) {
              _loglevel.default.debug('Failed to parse transaction data.', error, data);
            }

            let result;
            let contractCode;

            if (data && !to) {
              result = _transaction.TRANSACTION_TYPES.DEPLOY_CONTRACT;
            } else {
              const {
                contractCode: resultCode,
                isContractAddress
              } = await (0, _contractUtils.readAddressAsContract)(query, to);
              contractCode = resultCode;

              if (isContractAddress) {
                const tokenMethodName = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM].find(methodName => (0, _stringUtils.isEqualCaseInsensitive)(methodName, name));
                result = data && tokenMethodName ? tokenMethodName : _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION;
              } else {
                result = _transaction.TRANSACTION_TYPES.SIMPLE_SEND;
              }
            }

            return {
              type: result,
              getCodeResponse: contractCode
            };
          }

          const INFERRABLE_TRANSACTION_TYPES = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION, _transaction.TRANSACTION_TYPES.SIMPLE_SEND];
          /**
           * Given a transaction meta object, determine the asset type that the
           * transaction is dealing with, as well as the standard for the token if it
           * is a token transaction.
           *
           * @param {__import__('../constants/transaction').TransactionMeta} txMeta -
           *  transaction meta object
           * @param {EthQuery} query - EthQuery instance
           * @param {Function} getTokenStandardAndDetails - function to get token
           *  standards and details.
           * @returns {{ assetType: string, tokenStandard: string}}
           */

          async function determineTransactionAssetType(txMeta, query, getTokenStandardAndDetails) {
            // If the transaction type is already one of the inferrable types, then we do
            // not need to re-establish the type.
            let inferrableType = txMeta.type;

            if (INFERRABLE_TRANSACTION_TYPES.includes(txMeta.type) === false) {
              // Because we will deal with all types of transactions (including swaps)
              // we want to get an inferrable type of transaction that isn't special cased
              // that way we can narrow the number of logic gates required.
              const result = await determineTransactionType(txMeta.txParams, query);
              inferrableType = result.type;
            } // If the inferred type of the transaction is one of those that are part of
            // the token contract standards, we can use the getTokenStandardAndDetails
            // method to get the asset type.


            const isTokenMethod = [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM].find(methodName => methodName === inferrableType);

            if (isTokenMethod || // We can also check any contract interaction type to see if the to address
              // is a token contract. If it isn't, then the method will throw and we can
              // fall through to the other checks.
              inferrableType === _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION) {
              try {
                // We don't need a balance check, so the second parameter to
                // getTokenStandardAndDetails is omitted.
                const details = await getTokenStandardAndDetails(txMeta.txParams.to);

                if (details.standard) {
                  return {
                    assetType: details.standard === _transaction.TOKEN_STANDARDS.ERC20 ? _transaction.ASSET_TYPES.TOKEN : _transaction.ASSET_TYPES.COLLECTIBLE,
                    tokenStandard: details.standard
                  };
                }
              } catch {// noop, We expect errors here but we don't need to report them or do
                // anything in response.
              }
            } // If the transaction is interacting with a contract but isn't a token method
            // we use the 'UNKNOWN' value to show that it isn't a transaction sending any
            // particular asset.


            if (inferrableType === _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION) {
              return {
                assetType: _transaction.ASSET_TYPES.UNKNOWN,
                tokenStandard: _transaction.TOKEN_STANDARDS.NONE
              };
            }

            return {
              assetType: _transaction.ASSET_TYPES.NATIVE,
              tokenStandard: _transaction.TOKEN_STANDARDS.NONE
            };
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\notifications\\index.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\shared\notifications\index.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getTranslatedUINotifications = exports.UI_NOTIFICATIONS = void 0;
          // Messages and descriptions for these locale keys are in app/_locales/en/messages.json
          const UI_NOTIFICATIONS = {
            1: {
              id: 1,
              date: '2021-03-17',
              image: {
                src: 'images/mobile-link-qr.svg',
                height: '230px',
                width: '230px',
                placeImageBelowDescription: true
              }
            },
            3: {
              id: 3,
              date: '2021-03-08'
            },
            4: {
              id: 4,
              date: '2021-05-11',
              image: {
                src: 'images/source-logos-bsc.svg',
                width: '100%'
              }
            },
            5: {
              id: 5,
              date: '2021-06-09'
            },
            6: {
              id: 6,
              date: '2021-05-26'
            },
            7: {
              id: 7,
              date: '2021-09-17'
            },
            8: {
              id: 8,
              date: '2021-11-01'
            },
            9: {
              id: 9,
              date: '2021-12-07',
              image: {
                src: 'images/txinsights.png',
                width: '80%'
              }
            },
            10: {
              id: 10,
              date: '2022-09-15',
              image: {
                src: 'images/token-detection.svg',
                width: '100%'
              }
            },
            11: {
              id: 11,
              date: '2022-09-15'
            },
            12: {
              id: 12,
              date: '2022-05-18',
              image: {
                src: 'images/darkmode-banner.png',
                width: '100%'
              }
            },
            13: {
              id: 13,
              date: '2022-09-15'
            },
            14: {
              id: 14,
              date: '2022-09-15'
            },
            15: {
              id: 15,
              date: '2022-09-15'
            },
            16: {
              id: 16,
              date: null
            }
          };
          exports.UI_NOTIFICATIONS = UI_NOTIFICATIONS;

          const getTranslatedUINotifications = (t, locale) => {
            const formattedLocale = locale.replace('_', '-');
            return {
              1: {
                ...UI_NOTIFICATIONS[1],
                title: t('notifications1Title'),
                description: t('notifications1Description'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[1].date))
              },
              3: {
                ...UI_NOTIFICATIONS[3],
                title: t('notifications3Title'),
                description: t('notifications3Description'),
                actionText: t('notifications3ActionText'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[3].date))
              },
              4: {
                ...UI_NOTIFICATIONS[4],
                title: t('notifications4Title'),
                description: t('notifications4Description'),
                actionText: t('notifications4ActionText'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[4].date))
              },
              5: {
                ...UI_NOTIFICATIONS[5],
                title: t('secretRecoveryPhrase'),
                description: t('notifications5Description'),
                actionText: t('notifications3ActionText'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[5].date))
              },
              6: {
                ...UI_NOTIFICATIONS[6],
                title: t('notifications6Title'),
                description: [t('notifications6DescriptionOne'), t('notifications6DescriptionTwo'), t('notifications6DescriptionThree')],
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[6].date))
              },
              7: {
                ...UI_NOTIFICATIONS[7],
                title: t('notifications7Title'),
                description: [t('notifications7DescriptionOne'), t('notifications7DescriptionTwo')],
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[7].date))
              },
              8: {
                ...UI_NOTIFICATIONS[8],
                title: t('notifications8Title'),
                description: [t('notifications8DescriptionOne'), t('notifications8DescriptionTwo')],
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[8].date)),
                actionText: t('notifications8ActionText')
              },
              9: {
                ...UI_NOTIFICATIONS[9],
                title: t('notifications9Title'),
                description: [t('notifications9DescriptionOne'), t('notifications9DescriptionTwo')],
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[9].date))
              },
              10: {
                ...UI_NOTIFICATIONS[10],
                title: t('notifications10Title'),
                description: [t('notifications10DescriptionOne'), t('notifications10DescriptionTwo'), t('notifications10DescriptionThree')],
                actionText: t('notifications10ActionText'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[10].date))
              },
              11: {
                ...UI_NOTIFICATIONS[11],
                title: t('notifications11Title'),
                description: t('notifications11Description'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[11].date))
              },
              12: {
                ...UI_NOTIFICATIONS[12],
                title: t('notifications12Title'),
                description: t('notifications12Description'),
                actionText: t('notifications12ActionText'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[12].date))
              },
              13: {
                ...UI_NOTIFICATIONS[13],
                title: t('notifications13Title'),
                description: t('notifications13Description'),
                actionText: t('notifications13ActionText'),
                date: new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[13].date))
              },
              14: {
                ...UI_NOTIFICATIONS[14],
                title: t('notifications14Title'),
                description: t('notifications14Description'),
                actionText: t('notifications14ActionText'),
                date: UI_NOTIFICATIONS[14].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[14].date)) : ''
              },
              15: {
                ...UI_NOTIFICATIONS[15],
                title: t('notifications15Title'),
                description: t('notifications15Description'),
                date: UI_NOTIFICATIONS[15].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[15].date)) : ''
              },
              16: {
                ...UI_NOTIFICATIONS[16],
                title: t('notifications16Title'),
                description: t('notifications16Description'),
                actionText: t('notifications16ActionText'),
                date: UI_NOTIFICATIONS[16].date ? new Intl.DateTimeFormat(formattedLocale).format(new Date(UI_NOTIFICATIONS[16].date)) : ''
              }
            };
          };

          exports.getTranslatedUINotifications = getTranslatedUINotifications;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\alerts\\enums.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\alerts\enums.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ALERT_STATE = void 0;
          const ALERT_STATE = {
            CLOSED: 'CLOSED',
            ERROR: 'ERROR',
            LOADING: 'LOADING',
            OPEN: 'OPEN'
          };
          exports.ALERT_STATE = ALERT_STATE;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\alerts\\unconnected-account.js", { "../../../shared/constants/alerts": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\alerts.js", "../../selectors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js", "../../store/actionConstants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js", "../../store/actions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js", "./enums": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\alerts\\enums.js", "@reduxjs/toolkit": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@reduxjs\\toolkit\\dist\\index.js", "@sentry/browser": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@sentry\\browser\\dist\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\alerts\unconnected-account.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.switchedToUnconnectedAccount = exports.switchToAccount = exports.getAlertState = exports.dismissAndDisableAlert = exports.dismissAlert = exports.default = exports.connectAccount = exports.alertIsOpen = void 0;

          var _toolkit = require("@reduxjs/toolkit");

          var _browser = require("@sentry/browser");

          var _alerts = require("../../../shared/constants/alerts");

          var actionConstants = _interopRequireWildcard(require("../../store/actionConstants"));

          var _actions = require("../../store/actions");

          var _selectors = require("../../selectors");

          var _enums = require("./enums");

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          // Constants
          const name = _alerts.ALERT_TYPES.unconnectedAccount;
          const initialState = {
            state: _enums.ALERT_STATE.CLOSED
          }; // Slice (reducer plus auto-generated actions and action creators)

          const slice = (0, _toolkit.createSlice)({
            name,
            initialState,
            reducers: {
              connectAccountFailed: state => {
                state.state = _enums.ALERT_STATE.ERROR;
              },
              connectAccountRequested: state => {
                state.state = _enums.ALERT_STATE.LOADING;
              },
              connectAccountSucceeded: state => {
                state.state = _enums.ALERT_STATE.CLOSED;
              },
              disableAlertFailed: state => {
                state.state = _enums.ALERT_STATE.ERROR;
              },
              disableAlertRequested: state => {
                state.state = _enums.ALERT_STATE.LOADING;
              },
              disableAlertSucceeded: state => {
                state.state = _enums.ALERT_STATE.CLOSED;
              },
              dismissAlert: state => {
                state.state = _enums.ALERT_STATE.CLOSED;
              },
              switchAccountFailed: state => {
                state.state = _enums.ALERT_STATE.ERROR;
              },
              switchAccountRequested: state => {
                state.state = _enums.ALERT_STATE.LOADING;
              },
              switchAccountSucceeded: state => {
                state.state = _enums.ALERT_STATE.CLOSED;
              },
              switchedToUnconnectedAccount: state => {
                state.state = _enums.ALERT_STATE.OPEN;
              }
            },
            extraReducers: {
              [actionConstants.SELECTED_ADDRESS_CHANGED]: state => {
                // close the alert if the account is switched while it's open
                if (state.state === _enums.ALERT_STATE.OPEN) {
                  state.state = _enums.ALERT_STATE.CLOSED;
                }
              }
            }
          });
          const {
            actions,
            reducer
          } = slice;
          var _default = reducer; // Selectors

          exports.default = _default;

          const getAlertState = state => state[name].state;

          exports.getAlertState = getAlertState;

          const alertIsOpen = state => state[name].state !== _enums.ALERT_STATE.CLOSED; // Actions / action-creators


          exports.alertIsOpen = alertIsOpen;
          const {
            connectAccountFailed,
            connectAccountRequested,
            connectAccountSucceeded,
            disableAlertFailed,
            disableAlertRequested,
            disableAlertSucceeded,
            dismissAlert,
            switchAccountFailed,
            switchAccountRequested,
            switchAccountSucceeded,
            switchedToUnconnectedAccount
          } = actions;
          exports.switchedToUnconnectedAccount = switchedToUnconnectedAccount;
          exports.dismissAlert = dismissAlert;

          const dismissAndDisableAlert = () => {
            return async dispatch => {
              try {
                await dispatch(disableAlertRequested());
                await (0, _actions.setAlertEnabledness)(name, false);
                await dispatch(disableAlertSucceeded());
              } catch (error) {
                console.error(error);
                (0, _browser.captureException)(error);
                await dispatch(disableAlertFailed());
              }
            };
          };

          exports.dismissAndDisableAlert = dismissAndDisableAlert;

          const switchToAccount = address => {
            return async dispatch => {
              try {
                await dispatch(switchAccountRequested());
                await dispatch((0, _actions.setSelectedAddress)(address));
                await dispatch(switchAccountSucceeded());
              } catch (error) {
                console.error(error);
                (0, _browser.captureException)(error);
                await dispatch(switchAccountFailed());
              }
            };
          };

          exports.switchToAccount = switchToAccount;

          const connectAccount = () => {
            return async (dispatch, getState) => {
              const state = getState();
              const selectedAddress = (0, _selectors.getSelectedAddress)(state);
              const origin = (0, _selectors.getOriginOfCurrentTab)(state);

              try {
                await dispatch(connectAccountRequested());
                await dispatch((0, _actions.addPermittedAccount)(origin, selectedAddress));
                await dispatch(connectAccountSucceeded());
              } catch (error) {
                console.error(error);
                (0, _browser.captureException)(error);
                await dispatch(connectAccountFailed());
              }
            };
          };

          exports.connectAccount = connectAccount;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\app\\app.js", { "../../../shared/constants/hardware-wallets": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js", "../../store/actionConstants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\app\app.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = reduceApp;
          exports.getGasLoadingAnimationIsShowing = getGasLoadingAnimationIsShowing;
          exports.getLedgerTransportStatus = getLedgerTransportStatus;
          exports.getLedgerWebHidConnectedStatus = getLedgerWebHidConnectedStatus;
          exports.getPortfolioTooltipWasShownInThisSession = getPortfolioTooltipWasShownInThisSession;
          exports.getQrCodeData = getQrCodeData;
          exports.hideWhatsNewPopup = hideWhatsNewPopup;
          exports.setCustomTokenAmount = setCustomTokenAmount;
          exports.setLedgerTransportStatus = setLedgerTransportStatus;
          exports.setLedgerWebHidConnectedStatus = setLedgerWebHidConnectedStatus;
          exports.setNewCustomNetworkAdded = setNewCustomNetworkAdded;
          exports.setOnBoardedInThisUISession = setOnBoardedInThisUISession;
          exports.setPortfolioTooltipWasShownInThisSession = setPortfolioTooltipWasShownInThisSession;
          exports.toggleCurrencySwitch = toggleCurrencySwitch;
          exports.toggleGasLoadingAnimation = toggleGasLoadingAnimation;

          var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

          var actionConstants = _interopRequireWildcard(require("../../store/actionConstants"));

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function reduceApp(state = {}, action) {
            // default state
            const appState = {
              shouldClose: false,
              menuOpen: false,
              modal: {
                open: false,
                modalState: {
                  name: null,
                  props: {}
                },
                previousModalState: {
                  name: null
                }
              },
              alertOpen: false,
              alertMessage: null,
              qrCodeData: null,
              networkDropdownOpen: false,
              accountDetail: {
                subview: 'transactions'
              },
              // Used to display loading indicator
              isLoading: false,
              // Used to display error text
              warning: null,
              buyView: {},
              isMouseUser: false,
              defaultHdPaths: {
                trezor: `m/44'/60'/0'/0`,
                ledger: `m/44'/60'/0'/0/0`,
                lattice: `m/44'/60'/0'/0`
              },
              networksTabSelectedRpcUrl: '',
              loadingMethodData: false,
              requestAccountTabs: {},
              openMetaMaskTabs: {},
              currentWindowTab: {},
              showWhatsNewPopup: true,
              singleExceptions: {
                testKey: null
              },
              gasLoadingAnimationIsShowing: false,
              smartTransactionsError: null,
              smartTransactionsErrorMessageDismissed: false,
              ledgerWebHidConnectedStatus: _hardwareWallets.WEBHID_CONNECTED_STATUSES.UNKNOWN,
              ledgerTransportStatus: _hardwareWallets.TRANSPORT_STATES.NONE,
              newNetworkAdded: '',
              newCollectibleAddedMessage: '',
              portfolioTooltipWasShownInThisSession: false,
              sendInputCurrencySwitched: false,
              newTokensImported: '',
              newCustomNetworkAdded: {},
              onboardedInThisUISession: false,
              customTokenAmount: '',
              ...state
            };

            switch (action.type) {
              // dropdown methods
              case actionConstants.NETWORK_DROPDOWN_OPEN:
                return {
                  ...appState,
                  networkDropdownOpen: true
                };

              case actionConstants.NETWORK_DROPDOWN_CLOSE:
                return {
                  ...appState,
                  networkDropdownOpen: false
                };
              // alert methods

              case actionConstants.ALERT_OPEN:
                return {
                  ...appState,
                  alertOpen: true,
                  alertMessage: action.value
                };

              case actionConstants.ALERT_CLOSE:
                return {
                  ...appState,
                  alertOpen: false,
                  alertMessage: null
                };
              // qr scanner methods

              case actionConstants.QR_CODE_DETECTED:
                return {
                  ...appState,
                  qrCodeData: action.value
                };
              // Smart Transactions errors.

              case actionConstants.SET_SMART_TRANSACTIONS_ERROR:
                return {
                  ...appState,
                  smartTransactionsError: action.payload
                };

              case actionConstants.DISMISS_SMART_TRANSACTIONS_ERROR_MESSAGE:
                return {
                  ...appState,
                  smartTransactionsErrorMessageDismissed: true
                };
              // modal methods:

              case actionConstants.MODAL_OPEN:
                {
                  const {
                    name,
                    ...modalProps
                  } = action.payload;
                  return {
                    ...appState,
                    modal: {
                      open: true,
                      modalState: {
                        name,
                        props: {
                          ...modalProps
                        }
                      },
                      previousModalState: {
                        ...appState.modal.modalState
                      }
                    }
                  };
                }

              case actionConstants.MODAL_CLOSE:
                return {
                  ...appState,
                  modal: Object.assign(appState.modal, {
                    open: false
                  }, {
                    modalState: {
                      name: null,
                      props: {}
                    }
                  }, {
                    previousModalState: appState.modal.modalState
                  })
                };

              case actionConstants.CLEAR_ACCOUNT_DETAILS:
                return {
                  ...appState,
                  accountDetail: {}
                };

              case actionConstants.FORGOT_PASSWORD:
                return {
                  ...appState,
                  forgottenPassword: action.value
                };

              case actionConstants.SHOW_SEND_TOKEN_PAGE:
                return {
                  ...appState,
                  warning: null
                };

              case actionConstants.LOCK_METAMASK:
                return {
                  ...appState,
                  warning: null
                };
              // accounts

              case actionConstants.GO_HOME:
                return {
                  ...appState,
                  accountDetail: {
                    subview: 'transactions',
                    accountExport: 'none',
                    privateKey: ''
                  },
                  warning: null
                };

              case actionConstants.SHOW_ACCOUNT_DETAIL:
                return {
                  ...appState,
                  forgottenPassword: appState.forgottenPassword ? !appState.forgottenPassword : null,
                  accountDetail: {
                    subview: 'transactions',
                    accountExport: 'none',
                    privateKey: ''
                  }
                };

              case actionConstants.SHOW_ACCOUNTS_PAGE:
                return {
                  ...appState,
                  isLoading: false,
                  warning: null,
                  scrollToBottom: false,
                  forgottenPassword: false
                };

              case actionConstants.SHOW_CONF_TX_PAGE:
                return {
                  ...appState,
                  txId: action.id,
                  warning: null,
                  isLoading: false
                };

              case actionConstants.COMPLETED_TX:
                if (action.value.unconfirmedActionsCount > 0) {
                  return {
                    ...appState,
                    txId: null,
                    warning: null
                  };
                }

                return {
                  ...appState,
                  // indicate notification should close
                  shouldClose: true,
                  warning: null,
                  txId: null,
                  accountDetail: {
                    subview: 'transactions'
                  }
                };

              case actionConstants.TRANSACTION_ERROR:
                return {
                  ...appState
                };

              case actionConstants.UNLOCK_FAILED:
                return {
                  ...appState,
                  warning: action.value || 'Incorrect password. Try again.'
                };

              case actionConstants.UNLOCK_SUCCEEDED:
                return {
                  ...appState,
                  warning: ''
                };

              case actionConstants.SET_HARDWARE_WALLET_DEFAULT_HD_PATH:
                {
                  const {
                    device,
                    path
                  } = action.value;
                  const newDefaults = {
                    ...appState.defaultHdPaths
                  };
                  newDefaults[device] = path;
                  return {
                    ...appState,
                    defaultHdPaths: newDefaults
                  };
                }

              case actionConstants.SHOW_LOADING:
                return {
                  ...appState,
                  isLoading: true,
                  loadingMessage: action.value
                };

              case actionConstants.HIDE_LOADING:
                return {
                  ...appState,
                  isLoading: false
                };

              case actionConstants.DISPLAY_WARNING:
                return {
                  ...appState,
                  warning: action.value,
                  isLoading: false
                };

              case actionConstants.HIDE_WARNING:
                return {
                  ...appState,
                  warning: undefined
                };

              case actionConstants.SHOW_PRIVATE_KEY:
                return {
                  ...appState,
                  accountDetail: {
                    subview: 'export',
                    accountExport: 'completed',
                    privateKey: action.value
                  }
                };

              case actionConstants.SET_MOUSE_USER_STATE:
                return {
                  ...appState,
                  isMouseUser: action.value
                };

              case actionConstants.SET_SELECTED_SETTINGS_RPC_URL:
                return {
                  ...appState,
                  networksTabSelectedRpcUrl: action.value
                };

              case actionConstants.SET_NEW_NETWORK_ADDED:
                return {
                  ...appState,
                  newNetworkAdded: action.value
                };

              case actionConstants.SET_NEW_TOKENS_IMPORTED:
                return {
                  ...appState,
                  newTokensImported: action.value
                };

              case actionConstants.SET_NEW_COLLECTIBLE_ADDED_MESSAGE:
                return {
                  ...appState,
                  newCollectibleAddedMessage: action.value
                };

              case actionConstants.PORTFOLIO_TOOLTIP_WAS_SHOWN_IN_THIS_SESSION:
                return {
                  ...appState,
                  portfolioTooltipWasShownInThisSession: true
                };

              case actionConstants.LOADING_METHOD_DATA_STARTED:
                return {
                  ...appState,
                  loadingMethodData: true
                };

              case actionConstants.LOADING_METHOD_DATA_FINISHED:
                return {
                  ...appState,
                  loadingMethodData: false
                };

              case actionConstants.SET_REQUEST_ACCOUNT_TABS:
                return {
                  ...appState,
                  requestAccountTabs: action.value
                };

              case actionConstants.SET_OPEN_METAMASK_TAB_IDS:
                return {
                  ...appState,
                  openMetaMaskTabs: action.value
                };

              case actionConstants.SET_CURRENT_WINDOW_TAB:
                return {
                  ...appState,
                  currentWindowTab: action.value
                };

              case actionConstants.HIDE_WHATS_NEW_POPUP:
                return {
                  ...appState,
                  showWhatsNewPopup: false
                };

              case actionConstants.CAPTURE_SINGLE_EXCEPTION:
                return {
                  ...appState,
                  singleExceptions: {
                    ...appState.singleExceptions,
                    [action.value]: null
                  }
                };

              case actionConstants.TOGGLE_GAS_LOADING_ANIMATION:
                return {
                  ...appState,
                  gasLoadingAnimationIsShowing: action.value
                };

              case actionConstants.SET_WEBHID_CONNECTED_STATUS:
                return {
                  ...appState,
                  ledgerWebHidConnectedStatus: action.value
                };

              case actionConstants.SET_LEDGER_TRANSPORT_STATUS:
                return {
                  ...appState,
                  ledgerTransportStatus: action.value
                };

              case actionConstants.TOGGLE_CURRENCY_INPUT_SWITCH:
                return {
                  ...appState,
                  sendInputCurrencySwitched: !appState.sendInputCurrencySwitched
                };

              case actionConstants.SET_NEW_CUSTOM_NETWORK_ADDED:
                return {
                  ...appState,
                  newCustomNetworkAdded: action.value
                };

              case actionConstants.ONBOARDED_IN_THIS_UI_SESSION:
                return {
                  ...appState,
                  onboardedInThisUISession: action.value
                };

              case actionConstants.SET_CUSTOM_TOKEN_AMOUNT:
                return {
                  ...appState,
                  customTokenAmount: action.value
                };

              default:
                return appState;
            }
          } // Action Creators


          function hideWhatsNewPopup() {
            return {
              type: actionConstants.HIDE_WHATS_NEW_POPUP
            };
          }

          function setPortfolioTooltipWasShownInThisSession() {
            return {
              type: actionConstants.PORTFOLIO_TOOLTIP_WAS_SHOWN_IN_THIS_SESSION
            };
          }

          function toggleGasLoadingAnimation(value) {
            return {
              type: actionConstants.TOGGLE_GAS_LOADING_ANIMATION,
              value
            };
          }

          function setLedgerWebHidConnectedStatus(value) {
            return {
              type: actionConstants.SET_WEBHID_CONNECTED_STATUS,
              value
            };
          }

          function setLedgerTransportStatus(value) {
            return {
              type: actionConstants.SET_LEDGER_TRANSPORT_STATUS,
              value
            };
          } // Selectors


          function getQrCodeData(state) {
            return state.appState.qrCodeData;
          }

          function getGasLoadingAnimationIsShowing(state) {
            return state.appState.gasLoadingAnimationIsShowing;
          }

          function getLedgerWebHidConnectedStatus(state) {
            return state.appState.ledgerWebHidConnectedStatus;
          }

          function getLedgerTransportStatus(state) {
            return state.appState.ledgerTransportStatus;
          }

          function getPortfolioTooltipWasShownInThisSession(state) {
            return state.appState.portfolioTooltipWasShownInThisSession;
          }

          function toggleCurrencySwitch() {
            return {
              type: actionConstants.TOGGLE_CURRENCY_INPUT_SWITCH
            };
          }

          function setNewCustomNetworkAdded(value) {
            return {
              type: actionConstants.SET_NEW_CUSTOM_NETWORK_ADDED,
              value
            };
          }

          function setOnBoardedInThisUISession(value) {
            return {
              type: actionConstants.ONBOARDED_IN_THIS_UI_SESSION,
              value
            };
          }

          function setCustomTokenAmount(value) {
            return {
              type: actionConstants.SET_CUSTOM_TOKEN_AMOUNT,
              value
            };
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\ens.js", { "../../shared/constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", "../../shared/modules/hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "../helpers/utils/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js", "../pages/send/send.constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js", "../selectors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js", "../store/actionConstants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js", "@reduxjs/toolkit": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@reduxjs\\toolkit\\dist\\index.js", "ethereum-ens-network-map": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereum-ens-network-map\\index.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js", "ethers": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\index.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js", "unicode-confusables": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\unicode-confusables\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\ens.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.ensInitialState = exports.default = void 0;
          exports.getEnsError = getEnsError;
          exports.getEnsResolution = getEnsResolution;
          exports.getEnsWarning = getEnsWarning;
          exports.initializeEnsSlice = initializeEnsSlice;
          exports.lookupEnsName = lookupEnsName;
          exports.resetEnsResolution = void 0;

          var _toolkit = require("@reduxjs/toolkit");

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var _ethereumEnsNetworkMap = _interopRequireDefault(require("ethereum-ens-network-map"));

          var _unicodeConfusables = require("unicode-confusables");

          var _ethereumjsUtil = require("ethereumjs-util");

          var _ethers = require("ethers");

          var _selectors = require("../selectors");

          var _network = require("../../shared/constants/network");

          var _send = require("../pages/send/send.constants");

          var _util = require("../helpers/utils/util");

          var _actionConstants = require("../store/actionConstants");

          var _hexstringUtils = require("../../shared/modules/hexstring-utils");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          // Local Constants
          const ZERO_X_ERROR_ADDRESS = '0x';
          const initialState = {
            stage: 'UNINITIALIZED',
            resolution: null,
            error: null,
            warning: null,
            network: null
          };
          const ensInitialState = initialState;
          exports.ensInitialState = ensInitialState;
          const name = 'ENS';
          let web3Provider = null;
          const slice = (0, _toolkit.createSlice)({
            name,
            initialState,
            reducers: {
              ensLookup: (state, action) => {
                // first clear out the previous state
                state.resolution = null;
                state.error = null;
                state.warning = null;
                const {
                  address,
                  ensName,
                  error,
                  network
                } = action.payload;

                if (error) {
                  if ((0, _util.isValidDomainName)(ensName) && error.message === 'ENS name not defined.') {
                    state.error = network === _network.NETWORK_IDS.MAINNET ? _send.ENS_NO_ADDRESS_FOR_NAME : _send.ENS_NOT_FOUND_ON_NETWORK;
                  } else if (error.message === 'Illegal character for ENS.') {
                    state.error = _send.ENS_ILLEGAL_CHARACTER;
                  } else {
                    _loglevel.default.error(error);

                    state.error = _send.ENS_UNKNOWN_ERROR;
                  }
                } else if (address) {
                  if (address === _hexstringUtils.BURN_ADDRESS) {
                    state.error = _send.ENS_NO_ADDRESS_FOR_NAME;
                  } else if (address === ZERO_X_ERROR_ADDRESS) {
                    state.error = _send.ENS_REGISTRATION_ERROR;
                  } else {
                    state.resolution = address;
                  }

                  if ((0, _util.isValidDomainName)(address) && (0, _unicodeConfusables.isConfusing)(address)) {
                    state.warning = _send.CONFUSING_ENS_ERROR;
                  }
                } else {
                  state.error = _send.ENS_NO_ADDRESS_FOR_NAME;
                }
              },
              enableEnsLookup: (state, action) => {
                state.stage = 'INITIALIZED';
                state.error = null;
                state.resolution = null;
                state.warning = null;
                state.network = action.payload;
              },
              disableEnsLookup: state => {
                state.stage = 'NO_NETWORK_SUPPORT';
                state.error = null;
                state.warning = null;
                state.resolution = null;
                state.network = null;
              },
              ensNotSupported: state => {
                state.resolution = null;
                state.warning = null;
                state.error = _send.ENS_NOT_SUPPORTED_ON_NETWORK;
              },
              resetEnsResolution: state => {
                state.resolution = null;
                state.warning = null;
                state.error = null;
              }
            },
            extraReducers: builder => {
              builder.addCase(_actionConstants.CHAIN_CHANGED, (state, action) => {
                if (action.payload !== state.currentChainId) {
                  state.stage = 'UNINITIALIZED';
                  web3Provider = null;
                }
              });
            }
          });
          const {
            reducer,
            actions
          } = slice;
          var _default = reducer;
          exports.default = _default;
          const {
            disableEnsLookup,
            ensLookup,
            enableEnsLookup,
            ensNotSupported,
            resetEnsResolution
          } = actions;
          exports.resetEnsResolution = resetEnsResolution;

          function initializeEnsSlice() {
            return (dispatch, getState) => {
              const state = getState();
              const chainId = (0, _selectors.getCurrentChainId)(state);
              const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];
              const networkName = _network.NETWORK_ID_TO_ETHERS_NETWORK_NAME_MAP[network];
              const ensAddress = _ethereumEnsNetworkMap.default[network];
              const networkIsSupported = Boolean(ensAddress);

              if (networkIsSupported) {
                web3Provider = new _ethers.ethers.providers.Web3Provider(global.ethereumProvider, {
                  chainId: parseInt(network, 10),
                  name: networkName,
                  ensAddress
                });
                dispatch(enableEnsLookup(network));
              } else {
                web3Provider = null;
                dispatch(disableEnsLookup());
              }
            };
          }

          function lookupEnsName(ensName) {
            return async (dispatch, getState) => {
              const trimmedEnsName = ensName.trim();
              let state = getState();

              if (state[name].stage === 'UNINITIALIZED') {
                await dispatch(initializeEnsSlice());
              }

              state = getState();

              if (state[name].stage === 'NO_NETWORK_SUPPORT' && !((0, _hexstringUtils.isBurnAddress)(trimmedEnsName) === false && (0, _hexstringUtils.isValidHexAddress)(trimmedEnsName, {
                mixedCaseUseChecksum: true
              })) && !(0, _ethereumjsUtil.isHexString)(trimmedEnsName)) {
                await dispatch(ensNotSupported());
              } else {
                _loglevel.default.info(`ENS attempting to resolve name: ${trimmedEnsName}`);

                let address;
                let error;

                try {
                  var _web3Provider$provide;

                  // the writable property on the 'provider' object on the 'web3Provider' flips to false when stale
                  // This helps handle the case where the provider is becomes unresponsive if/when, in MV3, the service worker dies after the ENS slice is instantiated
                  const isProviderActive = (_web3Provider$provide = web3Provider.provider) === null || _web3Provider$provide === void 0 ? void 0 : _web3Provider$provide.writable;

                  if (!isProviderActive) {
                    await dispatch(initializeEnsSlice());
                  }

                  address = await web3Provider.resolveName(trimmedEnsName);
                } catch (err) {
                  error = err;
                }

                const chainId = (0, _selectors.getCurrentChainId)(state);
                const network = _network.CHAIN_ID_TO_NETWORK_ID_MAP[chainId];
                await dispatch(ensLookup({
                  ensName: trimmedEnsName,
                  address,
                  error,
                  chainId,
                  network
                }));
              }
            };
          }

          function getEnsResolution(state) {
            return state[name].resolution;
          }

          function getEnsError(state) {
            return state[name].error;
          }

          function getEnsWarning(state) {
            return state[name].warning;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas-action-constants.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\gas\gas-action-constants.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.SET_CUSTOM_GAS_PRICE = exports.SET_CUSTOM_GAS_LIMIT = exports.RESET_CUSTOM_DATA = void 0;
          // This file has been separated because it is required in both the gas and send
          // slices. This created a circular dependency problem as both slices also
          // import from the actions and selectors files. This easiest path for
          // untangling is having the constants separate.
          // Actions
          const RESET_CUSTOM_DATA = 'metamask/gas/RESET_CUSTOM_DATA';
          exports.RESET_CUSTOM_DATA = RESET_CUSTOM_DATA;
          const SET_CUSTOM_GAS_LIMIT = 'metamask/gas/SET_CUSTOM_GAS_LIMIT';
          exports.SET_CUSTOM_GAS_LIMIT = SET_CUSTOM_GAS_LIMIT;
          const SET_CUSTOM_GAS_PRICE = 'metamask/gas/SET_CUSTOM_GAS_PRICE';
          exports.SET_CUSTOM_GAS_PRICE = SET_CUSTOM_GAS_PRICE;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas.duck.js", { "./gas-action-constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas-action-constants.js", "lodash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\gas\gas.duck.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = reducer;
          exports.setCustomGasLimit = setCustomGasLimit;
          exports.setCustomGasPrice = setCustomGasPrice;

          var _lodash = require("lodash");

          var _gasActionConstants = require("./gas-action-constants");

          const initState = {
            customData: {
              price: null,
              limit: null
            }
          }; // Reducer

          function reducer(state = initState, action) {
            switch (action.type) {
              case _gasActionConstants.SET_CUSTOM_GAS_PRICE:
                return {
                  ...state,
                  customData: {
                    ...state.customData,
                    price: action.value
                  }
                };

              case _gasActionConstants.SET_CUSTOM_GAS_LIMIT:
                return {
                  ...state,
                  customData: {
                    ...state.customData,
                    limit: action.value
                  }
                };

              case _gasActionConstants.RESET_CUSTOM_DATA:
                return {
                  ...state,
                  customData: (0, _lodash.cloneDeep)(initState.customData)
                };

              default:
                return state;
            }
          }

          function setCustomGasPrice(newPrice) {
            return {
              type: _gasActionConstants.SET_CUSTOM_GAS_PRICE,
              value: newPrice
            };
          }

          function setCustomGasLimit(newLimit) {
            return {
              type: _gasActionConstants.SET_CUSTOM_GAS_LIMIT,
              value: newLimit
            };
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\metamask\\metamask.js", { "../../../shared/constants/alerts": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\alerts.js", "../../../shared/constants/gas": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js", "../../../shared/constants/hardware-wallets": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\hardware-wallets.js", "../../../shared/constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", "../../../shared/modules/hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "../../../shared/modules/string-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js", "../../helpers/utils/conversions.util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\conversions.util.js", "../../selectors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js", "../../store/actionConstants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js", "../../store/actions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js", "../gas/gas.duck": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas.duck.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\metamask\metamask.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = reduceMetamask;
          exports.doesUserHaveALedgerAccount = doesUserHaveALedgerAccount;
          exports.findKeyringForAddress = findKeyringForAddress;
          exports.getAlertEnabledness = void 0;
          exports.getBlockGasLimit = getBlockGasLimit;
          exports.getCollectibles = exports.getCollectibleContracts = void 0;
          exports.getCollectiblesDetectionNoticeDismissed = getCollectiblesDetectionNoticeDismissed;
          exports.getCollectiblesDropdownState = getCollectiblesDropdownState;
          exports.getCompletedOnboarding = getCompletedOnboarding;
          exports.getConversionRate = getConversionRate;
          exports.getCurrentLocale = void 0;
          exports.getEnableEIP1559V2NoticeDismissed = getEnableEIP1559V2NoticeDismissed;
          exports.getEstimatedGasFeeTimeBounds = getEstimatedGasFeeTimeBounds;
          exports.getGasEstimateType = getGasEstimateType;
          exports.getGasFeeEstimates = getGasFeeEstimates;
          exports.getIsGasEstimatesLoading = getIsGasEstimatesLoading;
          exports.getIsInitialized = getIsInitialized;
          exports.getIsNetworkBusy = getIsNetworkBusy;
          exports.getIsUnlocked = getIsUnlocked;
          exports.getLedgerTransportType = getLedgerTransportType;
          exports.getNativeCurrency = getNativeCurrency;
          exports.getPendingTokens = void 0;
          exports.getSeedPhraseBackedUp = getSeedPhraseBackedUp;
          exports.getSendHexDataFeatureFlagState = getSendHexDataFeatureFlagState;
          exports.getSendToAccounts = getSendToAccounts;
          exports.getTokens = void 0;
          exports.getUnapprovedTxs = getUnapprovedTxs;
          exports.getWeb3ShimUsageAlertEnabledness = exports.getUnconnectedAccountAlertShown = exports.getUnconnectedAccountAlertEnabledness = void 0;
          exports.isAddressLedger = isAddressLedger;
          exports.isEIP1559Network = isEIP1559Network;
          exports.isNotEIP1559Network = isNotEIP1559Network;
          exports.updateGasFees = updateGasFees;

          var _ethereumjsUtil = require("ethereumjs-util");

          var actionConstants = _interopRequireWildcard(require("../../store/actionConstants"));

          var _alerts = require("../../../shared/constants/alerts");

          var _gas = require("../../../shared/constants/gas");

          var _network = require("../../../shared/constants/network");

          var _selectors = require("../../selectors");

          var _actions = require("../../store/actions");

          var _gas2 = require("../gas/gas.duck");

          var _conversions = require("../../helpers/utils/conversions.util");

          var _hardwareWallets = require("../../../shared/constants/hardware-wallets");

          var _stringUtils = require("../../../shared/modules/string-utils");

          var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function reduceMetamask(state = {}, action) {
            const metamaskState = {
              isInitialized: false,
              isUnlocked: false,
              isAccountMenuOpen: false,
              identities: {},
              unapprovedTxs: {},
              frequentRpcList: [],
              addressBook: [],
              contractExchangeRates: {},
              pendingTokens: {},
              customNonceValue: '',
              useBlockie: false,
              featureFlags: {},
              welcomeScreenSeen: false,
              currentLocale: '',
              currentBlockGasLimit: '',
              preferences: {
                autoLockTimeLimit: undefined,
                showFiatInTestnets: false,
                showTestNetworks: false,
                useNativeCurrencyAsPrimaryCurrency: true
              },
              firstTimeFlowType: null,
              completedOnboarding: false,
              knownMethodData: {},
              participateInMetaMetrics: null,
              nextNonce: null,
              conversionRate: null,
              nativeCurrency: 'ETH',
              ...state
            };

            switch (action.type) {
              case actionConstants.UPDATE_METAMASK_STATE:
                return {
                  ...metamaskState,
                  ...action.value
                };

              case actionConstants.LOCK_METAMASK:
                return {
                  ...metamaskState,
                  isUnlocked: false
                };

              case actionConstants.SET_RPC_TARGET:
                return {
                  ...metamaskState,
                  provider: {
                    type: _network.NETWORK_TYPES.RPC,
                    rpcUrl: action.value
                  }
                };

              case actionConstants.SET_PROVIDER_TYPE:
                return {
                  ...metamaskState,
                  provider: {
                    type: action.value
                  }
                };

              case actionConstants.SHOW_ACCOUNT_DETAIL:
                return {
                  ...metamaskState,
                  isUnlocked: true,
                  isInitialized: true,
                  selectedAddress: action.value
                };

              case actionConstants.SET_ACCOUNT_LABEL:
                {
                  const {
                    account
                  } = action.value;
                  const name = action.value.label;
                  const id = {};
                  id[account] = {
                    ...metamaskState.identities[account],
                    name
                  };
                  const identities = {
                    ...metamaskState.identities,
                    ...id
                  };
                  return Object.assign(metamaskState, {
                    identities
                  });
                }

              case actionConstants.UPDATE_CUSTOM_NONCE:
                return {
                  ...metamaskState,
                  customNonceValue: action.value
                };

              case actionConstants.TOGGLE_ACCOUNT_MENU:
                return {
                  ...metamaskState,
                  isAccountMenuOpen: !metamaskState.isAccountMenuOpen
                };

              case actionConstants.UPDATE_TRANSACTION_PARAMS:
                {
                  const {
                    id: txId,
                    value
                  } = action;
                  let {
                    currentNetworkTxList
                  } = metamaskState;
                  currentNetworkTxList = currentNetworkTxList.map(tx => {
                    if (tx.id === txId) {
                      const newTx = {
                        ...tx
                      };
                      newTx.txParams = value;
                      return newTx;
                    }

                    return tx;
                  });
                  return {
                    ...metamaskState,
                    currentNetworkTxList
                  };
                }

              case actionConstants.SET_PARTICIPATE_IN_METAMETRICS:
                return {
                  ...metamaskState,
                  participateInMetaMetrics: action.value
                };

              case actionConstants.SET_USE_BLOCKIE:
                return {
                  ...metamaskState,
                  useBlockie: action.value
                };

              case actionConstants.UPDATE_FEATURE_FLAGS:
                return {
                  ...metamaskState,
                  featureFlags: action.value
                };

              case actionConstants.CLOSE_WELCOME_SCREEN:
                return {
                  ...metamaskState,
                  welcomeScreenSeen: true
                };

              case actionConstants.SET_CURRENT_LOCALE:
                return {
                  ...metamaskState,
                  currentLocale: action.value.locale
                };

              case actionConstants.SET_PENDING_TOKENS:
                return {
                  ...metamaskState,
                  pendingTokens: {
                    ...action.payload
                  }
                };

              case actionConstants.CLEAR_PENDING_TOKENS:
                {
                  return {
                    ...metamaskState,
                    pendingTokens: {}
                  };
                }

              case actionConstants.UPDATE_PREFERENCES:
                {
                  return {
                    ...metamaskState,
                    preferences: {
                      ...metamaskState.preferences,
                      ...action.payload
                    }
                  };
                }

              case actionConstants.COMPLETE_ONBOARDING:
                {
                  return {
                    ...metamaskState,
                    completedOnboarding: true
                  };
                }

              case actionConstants.SET_FIRST_TIME_FLOW_TYPE:
                {
                  return {
                    ...metamaskState,
                    firstTimeFlowType: action.value
                  };
                }

              case actionConstants.SET_NEXT_NONCE:
                {
                  return {
                    ...metamaskState,
                    nextNonce: action.value
                  };
                }

              default:
                return metamaskState;
            }
          }

          const toHexWei = (value, expectHexWei) => {
            return (0, _ethereumjsUtil.addHexPrefix)(expectHexWei ? value : (0, _conversions.decGWEIToHexWEI)(value));
          }; // Action Creators


          function updateGasFees({
            gasPrice,
            gasLimit,
            maxPriorityFeePerGas,
            maxFeePerGas,
            transaction,
            expectHexWei = false
          }) {
            return async dispatch => {
              const txParamsCopy = {
                ...transaction.txParams,
                gas: gasLimit
              };

              if (gasPrice) {
                dispatch((0, _gas2.setCustomGasPrice)(toHexWei(txParamsCopy.gasPrice, expectHexWei)));
                txParamsCopy.gasPrice = toHexWei(gasPrice, expectHexWei);
              } else if (maxFeePerGas && maxPriorityFeePerGas) {
                txParamsCopy.maxFeePerGas = toHexWei(maxFeePerGas, expectHexWei);
                txParamsCopy.maxPriorityFeePerGas = (0, _ethereumjsUtil.addHexPrefix)((0, _conversions.decGWEIToHexWEI)(maxPriorityFeePerGas));
              }

              const updatedTx = {
                ...transaction,
                txParams: txParamsCopy
              };
              const customGasLimit = (0, _ethereumjsUtil.isHexString)((0, _ethereumjsUtil.addHexPrefix)(gasLimit)) ? (0, _ethereumjsUtil.addHexPrefix)(gasLimit) : (0, _ethereumjsUtil.addHexPrefix)(gasLimit.toString(16));
              dispatch((0, _gas2.setCustomGasLimit)(customGasLimit));
              await dispatch((0, _actions.updateTransactionGasFees)(updatedTx.id, updatedTx));
            };
          } // Selectors


          const getCurrentLocale = state => state.metamask.currentLocale;

          exports.getCurrentLocale = getCurrentLocale;

          const getAlertEnabledness = state => state.metamask.alertEnabledness;

          exports.getAlertEnabledness = getAlertEnabledness;

          const getUnconnectedAccountAlertEnabledness = state => getAlertEnabledness(state)[_alerts.ALERT_TYPES.unconnectedAccount];

          exports.getUnconnectedAccountAlertEnabledness = getUnconnectedAccountAlertEnabledness;

          const getWeb3ShimUsageAlertEnabledness = state => getAlertEnabledness(state)[_alerts.ALERT_TYPES.web3ShimUsage];

          exports.getWeb3ShimUsageAlertEnabledness = getWeb3ShimUsageAlertEnabledness;

          const getUnconnectedAccountAlertShown = state => state.metamask.unconnectedAccountAlertShownOrigins;

          exports.getUnconnectedAccountAlertShown = getUnconnectedAccountAlertShown;

          const getPendingTokens = state => state.metamask.pendingTokens;

          exports.getPendingTokens = getPendingTokens;

          const getTokens = state => state.metamask.tokens;

          exports.getTokens = getTokens;

          function getCollectiblesDetectionNoticeDismissed(state) {
            return state.metamask.collectiblesDetectionNoticeDismissed;
          }

          function getCollectiblesDropdownState(state) {
            return state.metamask.collectiblesDropdownState;
          }

          function getEnableEIP1559V2NoticeDismissed(state) {
            return state.metamask.enableEIP1559V2NoticeDismissed;
          }

          const getCollectibles = state => {
            var _allCollectibles$sele, _allCollectibles$sele2;

            const {
              metamask: {
                allCollectibles,
                provider: {
                  chainId
                },
                selectedAddress
              }
            } = state;
            return (_allCollectibles$sele = allCollectibles === null || allCollectibles === void 0 ? void 0 : (_allCollectibles$sele2 = allCollectibles[selectedAddress]) === null || _allCollectibles$sele2 === void 0 ? void 0 : _allCollectibles$sele2[chainId]) !== null && _allCollectibles$sele !== void 0 ? _allCollectibles$sele : [];
          };

          exports.getCollectibles = getCollectibles;

          const getCollectibleContracts = state => {
            var _allCollectibleContra, _allCollectibleContra2;

            const {
              metamask: {
                allCollectibleContracts,
                provider: {
                  chainId
                },
                selectedAddress
              }
            } = state;
            return (_allCollectibleContra = allCollectibleContracts === null || allCollectibleContracts === void 0 ? void 0 : (_allCollectibleContra2 = allCollectibleContracts[selectedAddress]) === null || _allCollectibleContra2 === void 0 ? void 0 : _allCollectibleContra2[chainId]) !== null && _allCollectibleContra !== void 0 ? _allCollectibleContra : [];
          };

          exports.getCollectibleContracts = getCollectibleContracts;

          function getBlockGasLimit(state) {
            return state.metamask.currentBlockGasLimit;
          }

          function getConversionRate(state) {
            return state.metamask.conversionRate;
          }

          function getNativeCurrency(state) {
            return state.metamask.nativeCurrency;
          }

          function getSendHexDataFeatureFlagState(state) {
            return state.metamask.featureFlags.sendHexData;
          }

          function getSendToAccounts(state) {
            const fromAccounts = (0, _selectors.accountsWithSendEtherInfoSelector)(state);
            const addressBookAccounts = (0, _selectors.getAddressBook)(state);
            return [...fromAccounts, ...addressBookAccounts];
          }

          function getUnapprovedTxs(state) {
            return state.metamask.unapprovedTxs;
          }
          /**
           * Function returns true if network details are fetched and it is found to not support EIP-1559
           *
           * @param state
           */


          function isNotEIP1559Network(state) {
            var _state$metamask$netwo;

            return ((_state$metamask$netwo = state.metamask.networkDetails) === null || _state$metamask$netwo === void 0 ? void 0 : _state$metamask$netwo.EIPS[1559]) === false;
          }
          /**
           * Function returns true if network details are fetched and it is found to support EIP-1559
           *
           * @param state
           */


          function isEIP1559Network(state) {
            var _state$metamask$netwo2;

            return ((_state$metamask$netwo2 = state.metamask.networkDetails) === null || _state$metamask$netwo2 === void 0 ? void 0 : _state$metamask$netwo2.EIPS[1559]) === true;
          }

          function getGasEstimateType(state) {
            return state.metamask.gasEstimateType;
          }

          function getGasFeeEstimates(state) {
            return state.metamask.gasFeeEstimates;
          }

          function getEstimatedGasFeeTimeBounds(state) {
            return state.metamask.estimatedGasFeeTimeBounds;
          }

          function getIsGasEstimatesLoading(state) {
            const networkAndAccountSupports1559 = (0, _selectors.checkNetworkAndAccountSupports1559)(state);
            const gasEstimateType = getGasEstimateType(state); // We consider the gas estimate to be loading if the gasEstimateType is
            // 'NONE' or if the current gasEstimateType cannot be supported by the current
            // network

            const isEIP1559TolerableEstimateType = gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET || gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE;
            const isGasEstimatesLoading = gasEstimateType === _gas.GAS_ESTIMATE_TYPES.NONE || networkAndAccountSupports1559 && !isEIP1559TolerableEstimateType || !networkAndAccountSupports1559 && gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET;
            return isGasEstimatesLoading;
          }

          function getIsNetworkBusy(state) {
            const gasFeeEstimates = getGasFeeEstimates(state);
            return (gasFeeEstimates === null || gasFeeEstimates === void 0 ? void 0 : gasFeeEstimates.networkCongestion) >= _gas.NETWORK_CONGESTION_THRESHOLDS.BUSY;
          }

          function getCompletedOnboarding(state) {
            return state.metamask.completedOnboarding;
          }

          function getIsInitialized(state) {
            return state.metamask.isInitialized;
          }

          function getIsUnlocked(state) {
            return state.metamask.isUnlocked;
          }

          function getSeedPhraseBackedUp(state) {
            return state.metamask.seedPhraseBackedUp;
          }
          /**
           * Given the redux state object and an address, finds a keyring that contains that address, if one exists
           *
           * @param {object} state - the redux state object
           * @param {string} address - the address to search for among the keyring addresses
           * @returns {object | undefined} The keyring which contains the passed address, or undefined
           */


          function findKeyringForAddress(state, address) {
            const keyring = state.metamask.keyrings.find(kr => {
              return kr.accounts.some(account => {
                return (0, _stringUtils.isEqualCaseInsensitive)(account, (0, _ethereumjsUtil.addHexPrefix)(address)) || (0, _stringUtils.isEqualCaseInsensitive)(account, (0, _hexstringUtils.stripHexPrefix)(address));
              });
            });
            return keyring;
          }
          /**
           * Given the redux state object, returns the users preferred ledger transport type
           *
           * @param {object} state - the redux state object
           * @returns {string} The users preferred ledger transport type. One of'ledgerLive', 'webhid' or 'u2f'
           */


          function getLedgerTransportType(state) {
            return state.metamask.ledgerTransportType;
          }
          /**
           * Given the redux state object and an address, returns a boolean indicating whether the passed address is part of a Ledger keyring
           *
           * @param {object} state - the redux state object
           * @param {string} address - the address to search for among all keyring addresses
           * @returns {boolean} true if the passed address is part of a ledger keyring, and false otherwise
           */


          function isAddressLedger(state, address) {
            const keyring = findKeyringForAddress(state, address);
            return (keyring === null || keyring === void 0 ? void 0 : keyring.type) === _hardwareWallets.KEYRING_TYPES.LEDGER;
          }
          /**
           * Given the redux state object, returns a boolean indicating whether the user has any Ledger accounts added to MetaMask (i.e. Ledger keyrings
           * in state)
           *
           * @param {object} state - the redux state object
           * @returns {boolean} true if the user has a Ledger account and false otherwise
           */


          function doesUserHaveALedgerAccount(state) {
            return state.metamask.keyrings.some(kr => {
              return kr.type === _hardwareWallets.KEYRING_TYPES.LEDGER;
            });
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\helpers.js", { "../../../shared/constants/gas": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js", "../../../shared/constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", "../../../shared/constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", "../../../shared/lib/transactions-controller-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", "../../../shared/modules/contract-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "../../helpers/constants/common": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js", "../../pages/send/send.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.utils.js", "../../selectors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js", "../../store/actions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js", "human-standard-token-abi": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\human-standard-token-abi\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\send\helpers.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.estimateGasLimitForSend = estimateGasLimitForSend;
          exports.generateTransactionParams = generateTransactionParams;
          exports.getERC20Balance = getERC20Balance;
          exports.getRoundedGasPrice = getRoundedGasPrice;

          var _ethereumjsUtil = require("ethereumjs-util");

          var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

          var _gas = require("../../../shared/constants/gas");

          var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

          var _network = require("../../../shared/constants/network");

          var _transaction = require("../../../shared/constants/transaction");

          var _contractUtils = require("../../../shared/modules/contract-utils");

          var _conversion = require("../../../shared/modules/conversion.utils");

          var _common = require("../../helpers/constants/common");

          var _send = require("../../pages/send/send.utils");

          var _selectors = require("../../selectors");

          var _actions = require("../../store/actions");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          async function estimateGasLimitForSend({
            selectedAddress,
            value,
            gasPrice,
            sendToken,
            to,
            data,
            isNonStandardEthChain,
            chainId,
            gasLimit,
            ...options
          }) {
            let isSimpleSendOnNonStandardNetwork = false; // blockGasLimit may be a falsy, but defined, value when we receive it from
            // state, so we use logical or to fall back to MIN_GAS_LIMIT_HEX. Some
            // network implementations check the gas parameter supplied to
            // eth_estimateGas for validity. For this reason, we set token sends
            // blockGasLimit default to a higher number. Note that the current gasLimit
            // on a BLOCK is 15,000,000 and will be 30,000,000 on mainnet after London.
            // Meanwhile, MIN_GAS_LIMIT_HEX is 0x5208.

            let blockGasLimit = _gas.MIN_GAS_LIMIT_HEX;

            if (options.blockGasLimit) {
              blockGasLimit = options.blockGasLimit;
            } else if (sendToken) {
              blockGasLimit = _gas.GAS_LIMITS.BASE_TOKEN_ESTIMATE;
            } // The parameters below will be sent to our background process to estimate
            // how much gas will be used for a transaction. That background process is
            // located in tx-gas-utils.js in the transaction controller folder.


            const paramsForGasEstimate = {
              from: selectedAddress,
              value,
              gasPrice
            };

            if (sendToken) {
              if (!to) {
                // If no to address is provided, we cannot generate the token transfer
                // hexData. hexData in a transaction largely dictates how much gas will
                // be consumed by a transaction. We must use our best guess, which is
                // represented in the gas shared constants.
                return _gas.GAS_LIMITS.BASE_TOKEN_ESTIMATE;
              }

              paramsForGasEstimate.value = '0x0'; // We have to generate the erc20/erc721 contract call to transfer tokens in
              // order to get a proper estimate for gasLimit.

              paramsForGasEstimate.data = (0, _send.getAssetTransferData)({
                sendToken,
                fromAddress: selectedAddress,
                toAddress: to,
                amount: value
              });
              paramsForGasEstimate.to = sendToken.address;
            } else {
              if (!data) {
                // eth.getCode will return the compiled smart contract code at the
                // address. If this returns 0x, 0x0 or a nullish value then the address
                // is an externally owned account (NOT a contract account). For these
                // types of transactions the gasLimit will always be 21,000 or 0x5208
                const {
                  isContractAddress
                } = to ? await (0, _contractUtils.readAddressAsContract)(global.eth, to) : {};

                if (!isContractAddress && !isNonStandardEthChain) {
                  return _gas.GAS_LIMITS.SIMPLE;
                } else if (!isContractAddress && isNonStandardEthChain) {
                  isSimpleSendOnNonStandardNetwork = true;
                }
              }

              paramsForGasEstimate.data = data;

              if (to) {
                paramsForGasEstimate.to = to;
              }

              if (!value || value === '0') {
                // TODO: Figure out what's going on here. According to eth_estimateGas
                // docs this value can be zero, or undefined, yet we are setting it to a
                // value here when the value is undefined or zero. For more context:
                // https://github.com/MetaMask/metamask-extension/pull/6195
                paramsForGasEstimate.value = '0xff';
              }
            }

            if (!isSimpleSendOnNonStandardNetwork) {
              // If we do not yet have a gasLimit, we must call into our background
              // process to get an estimate for gasLimit based on known parameters.
              paramsForGasEstimate.gas = (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.multiplyCurrencies)(blockGasLimit, 0.95, {
                multiplicandBase: 16,
                multiplierBase: 10,
                roundDown: '0',
                toNumericBase: 'hex'
              }));
            } // The buffer multipler reduces transaction failures by ensuring that the
            // estimated gas is always sufficient. Without the multiplier, estimates
            // for contract interactions can become inaccurate over time. This is because
            // gas estimation is non-deterministic. The gas required for the exact same
            // transaction call can change based on state of a contract or changes in the
            // contracts environment (blockchain data or contracts it interacts with).
            // Applying the 1.5 buffer has proven to be a useful guard against this non-
            // deterministic behaviour.
            //
            // Gas estimation of simple sends should, however, be deterministic. As such
            // no buffer is needed in those cases.


            let bufferMultiplier = 1.5;

            if (isSimpleSendOnNonStandardNetwork) {
              bufferMultiplier = 1;
            } else if (_network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId]) {
              bufferMultiplier = _network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId];
            }

            try {
              // Call into the background process that will simulate transaction
              // execution on the node and return an estimate of gasLimit
              const estimatedGasLimit = await (0, _actions.estimateGas)(paramsForGasEstimate);
              const estimateWithBuffer = (0, _send.addGasBuffer)(estimatedGasLimit, blockGasLimit, bufferMultiplier);
              return (0, _ethereumjsUtil.addHexPrefix)(estimateWithBuffer);
            } catch (error) {
              const simulationFailed = error.message.includes('Transaction execution error.') || error.message.includes('gas required exceeds allowance or always failing transaction') || _network.CHAIN_ID_TO_GAS_LIMIT_BUFFER_MAP[chainId] && error.message.includes('gas required exceeds allowance');

              if (simulationFailed) {
                var _paramsForGasEstimate;

                const estimateWithBuffer = (0, _send.addGasBuffer)((_paramsForGasEstimate = paramsForGasEstimate === null || paramsForGasEstimate === void 0 ? void 0 : paramsForGasEstimate.gas) !== null && _paramsForGasEstimate !== void 0 ? _paramsForGasEstimate : gasLimit, blockGasLimit, bufferMultiplier);
                return (0, _ethereumjsUtil.addHexPrefix)(estimateWithBuffer);
              }

              throw error;
            }
          }
          /**
           * Generates a txParams from the send slice.
           *
           * @param {__import__('.').SendState} sendState - the state of the send slice
           * @returns {__import__(
           *  '../../../shared/constants/transaction'
           * ).TxParams} A txParams object that can be used to create a transaction or
           *  update an existing transaction.
           */


          function generateTransactionParams(sendState) {
            var _draftTransaction$fro, _draftTransaction$fro2, _draftTransaction$fro3, _draftTransaction$use;

            const draftTransaction = sendState.draftTransactions[sendState.currentTransactionUUID];
            const txParams = {
              // If the fromAccount has been specified we use that, if not we use the
              // selected account.
              from: ((_draftTransaction$fro = draftTransaction.fromAccount) === null || _draftTransaction$fro === void 0 ? void 0 : _draftTransaction$fro.address) || sendState.selectedAccount.address,
              // gasLimit always needs to be set regardless of the asset being sent
              // or the type of transaction.
              gas: draftTransaction.gas.gasLimit
            };

            switch (draftTransaction.asset.type) {
              case _transaction.ASSET_TYPES.TOKEN:
                // When sending a token the to address is the contract address of
                // the token being sent. The value is set to '0x0' and the data
                // is generated from the recipient address, token being sent and
                // amount.
                txParams.to = draftTransaction.asset.details.address;
                txParams.value = '0x0';
                txParams.data = (0, _send.generateERC20TransferData)({
                  toAddress: draftTransaction.recipient.address,
                  amount: draftTransaction.amount.value,
                  sendToken: draftTransaction.asset.details
                });
                break;

              case _transaction.ASSET_TYPES.COLLECTIBLE:
                // When sending a token the to address is the contract address of
                // the token being sent. The value is set to '0x0' and the data
                // is generated from the recipient address, token being sent and
                // amount.
                txParams.to = draftTransaction.asset.details.address;
                txParams.value = '0x0';
                txParams.data = (0, _send.generateERC721TransferData)({
                  toAddress: draftTransaction.recipient.address,
                  fromAddress: (_draftTransaction$fro2 = (_draftTransaction$fro3 = draftTransaction.fromAccount) === null || _draftTransaction$fro3 === void 0 ? void 0 : _draftTransaction$fro3.address) !== null && _draftTransaction$fro2 !== void 0 ? _draftTransaction$fro2 : sendState.selectedAccount.address,
                  tokenId: draftTransaction.asset.details.tokenId
                });
                break;

              case _transaction.ASSET_TYPES.NATIVE:
              default:
                // When sending native currency the to and value fields use the
                // recipient and amount values and the data key is either null or
                // populated with the user input provided in hex field.
                txParams.to = draftTransaction.recipient.address;
                txParams.value = draftTransaction.amount.value;
                txParams.data = (_draftTransaction$use = draftTransaction.userInputHexData) !== null && _draftTransaction$use !== void 0 ? _draftTransaction$use : undefined;
            } // We need to make sure that we only include the right gas fee fields
            // based on the type of transaction the network supports. We will also set
            // the type param here.


            if (sendState.eip1559support) {
              txParams.type = _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
              txParams.maxFeePerGas = draftTransaction.gas.maxFeePerGas;
              txParams.maxPriorityFeePerGas = draftTransaction.gas.maxPriorityFeePerGas;

              if (!txParams.maxFeePerGas || txParams.maxFeePerGas === '0x0') {
                txParams.maxFeePerGas = draftTransaction.gas.gasPrice;
              }

              if (!txParams.maxPriorityFeePerGas || txParams.maxPriorityFeePerGas === '0x0') {
                txParams.maxPriorityFeePerGas = txParams.maxFeePerGas;
              }
            } else {
              txParams.gasPrice = draftTransaction.gas.gasPrice;
              txParams.type = _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
            }

            return txParams;
          }
          /**
           * This method is used to keep the original logic from the gas.duck.js file
           * after receiving a gasPrice from eth_gasPrice. First, the returned gasPrice
           * was converted to GWEI, then it was converted to a Number, then in the send
           * duck (here) we would use getGasPriceInHexWei to get back to hexWei. Now that
           * we receive a GWEI estimate from the controller, we still need to do this
           * weird conversion to get the proper rounding.
           *
           * @param {string} gasPriceEstimate
           * @returns {string}
           */


          function getRoundedGasPrice(gasPriceEstimate) {
            const gasPriceInDecGwei = (0, _conversion.conversionUtil)(gasPriceEstimate, {
              numberOfDecimals: 9,
              toDenomination: _common.GWEI,
              fromNumericBase: 'dec',
              toNumericBase: 'dec',
              fromCurrency: _common.ETH,
              fromDenomination: _common.GWEI
            });
            const gasPriceAsNumber = Number(gasPriceInDecGwei);
            return (0, _selectors.getGasPriceInHexWei)(gasPriceAsNumber);
          }

          async function getERC20Balance(token, accountAddress) {
            var _await$contract$balan;

            const contract = global.eth.contract(_humanStandardTokenAbi.default).at(token.address);
            const usersToken = (_await$contract$balan = await contract.balanceOf(accountAddress)) !== null && _await$contract$balan !== void 0 ? _await$contract$balan : null;

            if (!usersToken) {
              return '0x0';
            }

            const amount = (0, _transactionsControllerUtils.calcTokenAmount)(usersToken.balance.toString(), token.decimals).toString(16);
            return (0, _ethereumjsUtil.addHexPrefix)(amount);
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\index.js", { "./send": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\send.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\send\index.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _send = require("./send");

          Object.keys(_send).forEach(function (key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports && exports[key] === _send[key]) return;
            Object.defineProperty(exports, key, {
              enumerable: true,
              get: function () {
                return _send[key];
              }
            });
          });

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\send.js", { "../../../shared/constants/gas": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js", "../../../shared/constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", "../../../shared/lib/metamask-controller-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\metamask-controller-utils.js", "../../../shared/lib/transactions-controller-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "../../../shared/modules/hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "../../../shared/modules/string-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js", "../../../shared/modules/transaction.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js", "../../helpers/constants/common": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js", "../../helpers/constants/error-keys": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\error-keys.js", "../../helpers/utils/confirm-tx.util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js", "../../helpers/utils/optimism/fetchEstimatedL1Fee": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js", "../../helpers/utils/token-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\token-util.js", "../../helpers/utils/transactions.util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\transactions.util.js", "../../helpers/utils/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js", "../../pages/send/send.constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js", "../../pages/send/send.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.utils.js", "../../selectors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js", "../../store/actionConstants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actionConstants.js", "../../store/actions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js", "../ens": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\ens.js", "../gas/gas.duck": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\gas\\gas.duck.js", "../metamask/metamask": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\metamask\\metamask.js", "./helpers": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\ducks\\send\\helpers.js", "@reduxjs/toolkit": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@reduxjs\\toolkit\\dist\\index.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js", "lodash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js", "uuid": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\uuid\\dist\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\ducks\send\send.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.draftTransactionInitialState = exports.default = exports.computeEstimatedGasLimit = exports.addHistoryEntry = exports.acknowledgeRecipientWarning = exports.SEND_STATUSES = exports.SEND_STAGES = exports.RECIPIENT_SEARCH_MODES = exports.GAS_INPUT_MODES = exports.AMOUNT_MODES = void 0;
          exports.editExistingTransaction = editExistingTransaction;
          exports.gasFeeIsInError = gasFeeIsInError;
          exports.getAssetError = getAssetError;
          exports.getCurrentDraftTransaction = getCurrentDraftTransaction;
          exports.getCurrentTransactionUUID = getCurrentTransactionUUID;
          exports.getDraftTransactionExists = getDraftTransactionExists;
          exports.getDraftTransactionID = getDraftTransactionID;
          exports.getGasInputMode = getGasInputMode;
          exports.getGasLimit = getGasLimit;
          exports.getGasPrice = getGasPrice;
          exports.getGasTotal = getGasTotal;
          exports.getIsAssetSendable = getIsAssetSendable;
          exports.getIsBalanceInsufficient = getIsBalanceInsufficient;
          exports.getIsUsingMyAccountForRecipientSearch = getIsUsingMyAccountForRecipientSearch;
          exports.getMinimumGasLimitForSend = getMinimumGasLimitForSend;
          exports.getRecipient = getRecipient;
          exports.getRecipientUserInput = getRecipientUserInput;
          exports.getRecipientWarningAcknowledgement = getRecipientWarningAcknowledgement;
          exports.getSendAmount = getSendAmount;
          exports.getSendAsset = getSendAsset;
          exports.getSendAssetAddress = getSendAssetAddress;
          exports.getSendErrors = getSendErrors;
          exports.getSendHexData = getSendHexData;
          exports.getSendMaxModeState = getSendMaxModeState;
          exports.getSendStage = getSendStage;
          exports.getSendTo = getSendTo;
          exports.initializeSendState = exports.initialState = void 0;
          exports.isSendFormInvalid = isSendFormInvalid;
          exports.isSendStateInitialized = isSendStateInitialized;
          exports.resetRecipientInput = resetRecipientInput;
          exports.resetSendState = resetSendState;
          exports.sendAmountIsInError = sendAmountIsInError;
          exports.signTransaction = signTransaction;
          exports.startNewDraftTransaction = startNewDraftTransaction;
          exports.toggleSendMaxMode = toggleSendMaxMode;
          exports.updateGasLimit = void 0;
          exports.updateGasPrice = updateGasPrice;
          exports.updateRecipient = updateRecipient;
          exports.updateRecipientUserInput = updateRecipientUserInput;
          exports.updateSendAmount = updateSendAmount;
          exports.updateSendAsset = updateSendAsset;
          exports.updateSendHexData = updateSendHexData;
          exports.useContactListForRecipientSearch = useContactListForRecipientSearch;
          exports.useDefaultGas = exports.useCustomGas = void 0;
          exports.useMyAccountsForRecipientSearch = useMyAccountsForRecipientSearch;

          var _toolkit = require("@reduxjs/toolkit");

          var _bignumber = _interopRequireDefault(require("bignumber.js"));

          var _ethereumjsUtil = require("ethereumjs-util");

          var _lodash = require("lodash");

          var _uuid = require("uuid");

          var _conversion = require("../../../shared/modules/conversion.utils");

          var _gas = require("../../../shared/constants/gas");

          var _send = require("../../pages/send/send.constants");

          var _send2 = require("../../pages/send/send.utils");

          var _selectors = require("../../selectors");

          var _actions = require("../../store/actions");

          var _gas2 = require("../gas/gas.duck");

          var _actionConstants = require("../../store/actionConstants");

          var _tokenUtil = require("../../helpers/utils/token-util");

          var _util = require("../../helpers/utils/util");

          var _metamask = require("../metamask/metamask");

          var _ens = require("../ens");

          var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

          var _transactions = require("../../helpers/utils/transactions.util");

          var _fetchEstimatedL1Fee = _interopRequireDefault(require("../../helpers/utils/optimism/fetchEstimatedL1Fee"));

          var _common = require("../../helpers/constants/common");

          var _transaction = require("../../../shared/constants/transaction");

          var _errorKeys = require("../../helpers/constants/error-keys");

          var _stringUtils = require("../../../shared/modules/string-utils");

          var _confirmTx = require("../../helpers/utils/confirm-tx.util");

          var _transaction2 = require("../../../shared/modules/transaction.utils");

          var _metamaskControllerUtils = require("../../../shared/lib/metamask-controller-utils");

          var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

          var _helpers = require("./helpers");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          // typedef import statements

          /**
           * @typedef {(
           *  __import__('immer/dist/internal').WritableDraft<SendState>
           * )} SendStateDraft
           * @typedef {(
           *  __import__('../../../shared/constants/transaction').AssetTypesString
           * )} AssetTypesString
           * @typedef {(
           *  __import__( '../../helpers/constants/common').TokenStandardStrings
           * )} TokenStandardStrings
           * @typedef {(
           *  __import__( '../../../shared/constants/tokens').TokenDetails
           * )} TokenDetails
           * @typedef {(
           *  __import__('../../../shared/constants/transaction').TransactionTypeString
           * )} TransactionTypeString
           * @typedef {(
           *  __import__('@metamask/controllers').LegacyGasPriceEstimate
           * )} LegacyGasPriceEstimate
           * @typedef {(
           *  __import__('@metamask/controllers').GasFeeEstimates
           * )} GasFeeEstimates
           * @typedef {(
           *  __import__('@metamask/controllers').EthGasPriceEstimate
           * )} EthGasPriceEstimate
           * @typedef {(
           *  __import__('@metamask/controllers').GasEstimateType
           * )} GasEstimateType
           * @typedef {(
           *  __import__('redux').AnyAction
           * )} AnyAction
           */

          /**
           * @template R - Return type of the async function
           * @typedef {(
           *  __import__('redux-thunk').ThunkAction<R, MetaMaskState, unknown, AnyAction>
           * )} ThunkAction<R>
           */

          /**
           * This type will take a typical constant string mapped object and turn it into
           * a union type of the values.
           *
           * @template O - The object to make strings out of
           * @typedef {O[keyof O]} MapValuesToUnion<O>
           */

          /**
           * @typedef {object} SendStateStages
           * @property {'ADD_RECIPIENT'} ADD_RECIPIENT - The user is selecting which
           *  address to send an asset to.
           * @property {'DRAFT'} DRAFT - The send form is shown for a transaction yet to
           *  be sent to the Transaction Controller.
           * @property {'EDIT'} EDIT - The send form is shown for a transaction already
           *  submitted to the Transaction Controller but not yet confirmed. This happens
           *  when a confirmation is shown for a transaction and the 'edit' button in the
           *  header is clicked.
           * @property {'INACTIVE'} INACTIVE - The send state is idle, and hasn't yet
           *  fetched required data for gasPrice and gasLimit estimations, etc.
           */

          /**
           * The Stages that the send slice can be in
           *
           * @type {SendStateStages}
           */
          const SEND_STAGES = {
            ADD_RECIPIENT: 'ADD_RECIPIENT',
            DRAFT: 'DRAFT',
            EDIT: 'EDIT',
            INACTIVE: 'INACTIVE'
          };
          /**
           * @typedef {object} DraftTxStatus
           * @property {'INVALID'} INVALID - The transaction is invalid and cannot be
           *  submitted. There are a number of cases that would result in an invalid
           *  send state:
           *  1. The recipient is not yet defined
           *  2. The amount + gasTotal is greater than the user's balance when sending
           *     native currency
           *  3. The gasTotal is greater than the user's *native* balance
           *  4. The amount of sent asset is greater than the user's *asset* balance
           *  5. Gas price estimates failed to load entirely
           *  6. The gasLimit is less than 21000 (0x5208)
           * @property {'VALID'} VALID - The transaction is valid and can be submitted.
           */

          /**
           * The status of the send slice
           *
           * @type {DraftTxStatus}
           */

          exports.SEND_STAGES = SEND_STAGES;
          const SEND_STATUSES = {
            INVALID: 'INVALID',
            VALID: 'VALID'
          };
          /**
           * @typedef {object} SendStateGasModes
           * @property {'BASIC'} BASIC - Shows the basic estimate slow/avg/fast buttons
           *  when on mainnet and the metaswaps API request is successful.
           * @property {'CUSTOM'} CUSTOM - Shows GasFeeDisplay component that is a read
           *  only display of the values the user has set in the advanced gas modal
           *  (stored in the gas duck under the customData key).
           * @property {'INLINE'} INLINE - Shows inline gasLimit/gasPrice fields when on
           *  any other network or metaswaps API fails and we use eth_gasPrice.
           */

          /**
           * Controls what is displayed in the send-gas-row component.
           *
           * @type {SendStateGasModes}
           */

          exports.SEND_STATUSES = SEND_STATUSES;
          const GAS_INPUT_MODES = {
            BASIC: 'BASIC',
            CUSTOM: 'CUSTOM',
            INLINE: 'INLINE'
          };
          /**
           * @typedef {object} SendStateAmountModes
           * @property {'INPUT'} INPUT - the user provides the amount by typing in the
           *  field.
           * @property {'MAX'} MAX - The user selects the MAX button and amount is
           *  calculated based on balance - (amount + gasTotal).
           */

          /**
           * The modes that the amount field can be set by
           *
           * @type {SendStateAmountModes}
           */

          exports.GAS_INPUT_MODES = GAS_INPUT_MODES;
          const AMOUNT_MODES = {
            INPUT: 'INPUT',
            MAX: 'MAX'
          };
          /**
           * @typedef {object} SendStateRecipientModes
           * @property {'CONTACT_LIST'} CONTACT_LIST - The user is displayed a list of
           *  their contacts and addresses they have recently send to.
           * @property {'MY_ACCOUNTS'} MY_ACCOUNTS - the user is displayed a list of
           *  their own accounts to send to.
           */

          /**
           * The type of recipient list that is displayed to user
           *
           * @type {SendStateRecipientModes}
           */

          exports.AMOUNT_MODES = AMOUNT_MODES;
          const RECIPIENT_SEARCH_MODES = {
            CONTACT_LIST: 'CONTACT_LIST',
            MY_ACCOUNTS: 'MY_ACCOUNTS'
          };
          /**
           * @typedef {object} Account
           * @property {string} address - The hex address of the account.
           * @property {string} balance - Hex string representing the native asset
           *  balance of the account the transaction will be sent from.
           */

          /**
           * @typedef {object} Amount
           * @property {string} [error] - Error to display for the amount field.
           * @property {string} value - A hex string representing the amount of the
           *  selected currency to send.
           */

          /**
           * @typedef {object} Asset
           * @property {string} balance - A hex string representing the balance
           *  that the user holds of the asset that they are attempting to send.
           * @property {TokenDetails} [details] - An object that describes the
           *  selected asset in the case that the user is sending a token or collectibe.
           *  Will be null when asset.type is 'NATIVE'.
           * @property {string} [error] - Error to display when there is an issue
           *  with the asset.
           * @property {AssetTypesString} type - The type of asset that the user
           *  is attempting to send. Defaults to 'NATIVE' which represents the native
           *  asset of the chain. Can also be 'TOKEN' or 'COLLECTIBLE'.
           */

          /**
           * @typedef {object} GasFees
           * @property {string} [error] - error to display for gas fields.
           * @property {string} gasLimit - maximum gas needed for tx.
           * @property {string} gasPrice - price in wei to pay per gas.
           * @property {string} gasTotal - maximum total price in wei to pay.
           * @property {string} maxFeePerGas - Maximum price in wei to pay per gas.
           * @property {string} maxPriorityFeePerGas - Maximum priority fee in wei to pay
           *  per gas.
           */

          /**
           * An object that describes the intended recipient of a transaction.
           *
           * @typedef {object} Recipient
           * @property {string} address - The fully qualified address of the recipient.
           *  This is set after the recipient.userInput is validated, the userInput field
           *  is quickly updated to avoid delay between keystrokes and seeing the input
           *  field updated. After a debounce the address typed is validated and then the
           *  address field is updated. The address field is also set when the user
           *  selects a contact or account from the list, or an ENS resolution when
           *  typing ENS names.
           * @property {string} [error] - Error to display on the address field.
           * @property {string} nickname - The nickname that the user has added to their
           *  address book for the recipient.address.
           * @property {string} [warning] - Warning to display on the address field.
           */

          /**
           * @typedef {object} DraftTransaction
           * @property {Amount} amount - An object containing information about the
           *  amount of currency to send.
           * @property {Asset} asset - An object that describes the asset that the user
           *  has selected to send.
           * @property {Account} [fromAccount] - The send flow is usually only relative to
           *  the currently selected account. When editing a transaction, however, the
           *  account may differ. In that case, the details of that account will be
           *  stored in this object within the draftTransaction.
           * @property {GasFees} gas - Details about the current gas settings
           * @property {Array<{event: string, timestamp: number}>} history - An array of
           *  entries that describe the user's journey through the send flow. This is
           *  sent to the controller for attaching to state logs for troubleshooting and
           *  support.
           * @property {string} [id] - If the transaction has already been added to the
           *  TransactionController this field will be populated with its id from the
           *  TransactionController state. This is required to be able to update the
           *  transaction in the controller.
           * @property {Recipient} recipient - An object that describes the intended
           *  recipient of the transaction.
           * @property {MapValuesToUnion<DraftTxStatus>} status - Describes the
           *  validity of the draft transaction, which will be either 'VALID' or
           *  'INVALID', depending on our ability to generate a valid txParams object for
           *  submission.
           * @property {string} transactionType - Determines type of transaction being
           *  sent, defaulted to 0x0 (legacy).
           * @property {string} [userInputHexData] - When a user has enabled custom hex
           *  data field in advanced options, they can supply data to the field which is
           *  stored under this key.
           */

          /**
           * @type {DraftTransaction}
           */

          exports.RECIPIENT_SEARCH_MODES = RECIPIENT_SEARCH_MODES;
          const draftTransactionInitialState = {
            amount: {
              error: null,
              value: '0x0'
            },
            asset: {
              balance: '0x0',
              details: null,
              error: null,
              type: _transaction.ASSET_TYPES.NATIVE
            },
            fromAccount: null,
            gas: {
              error: null,
              gasLimit: '0x0',
              gasPrice: '0x0',
              gasTotal: '0x0',
              maxFeePerGas: '0x0',
              maxPriorityFeePerGas: '0x0',
              wasManuallyEdited: false
            },
            history: [],
            id: null,
            recipient: {
              address: '',
              error: null,
              nickname: '',
              warning: null,
              type: '',
              recipientWarningAcknowledged: false
            },
            status: SEND_STATUSES.VALID,
            transactionType: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
            userInputHexData: null
          };
          /**
           * Describes the state tree of the send slice
           *
           * @typedef {object} SendState
           * @property {MapValuesToUnion<SendStateAmountModes>} amountMode - Describe
           *  whether the user has manually input an amount or if they have selected max
           *  to send the maximum amount of the selected currency.
           * @property {string} currentTransactionUUID - The UUID of the transaction
           *  currently being modified by the send flow. This UUID is generated upon
           *  initialization of the send flow, any previous UUIDs are discarded at
           *  clean up AND during initialization. When a transaction is edited a new UUID
           *  is generated for it and the state of that transaction is copied into a new
           *  entry in the draftTransactions object.
           * @property {Object<string, DraftTransaction>} draftTransactions - An object keyed
           *  by UUID with draftTransactions as the values.
           * @property {boolean} eip1559support - tracks whether the current network
           *  supports EIP 1559 transactions.
           * @property {boolean} gasEstimateIsLoading - Indicates whether the gas
           *  estimate is loading.
           * @property {string} [gasEstimatePollToken] - String token identifying a
           *  listener for polling on the gasFeeController
           * @property {boolean} gasIsSetInModal - true if the user set custom gas in the
           *  custom gas modal
           * @property {string} gasLimitMinimum - minimum supported gasLimit.
           * @property {string} gasPriceEstimate - Expected price in wei necessary to
           *  pay per gas used for a transaction to be included in a reasonable timeframe.
           *  Comes from the GasFeeController.
           * @property {string} gasTotalForLayer1 -  Layer 1 gas fee total on multi-layer
           *  fee networks
           * @property {string} recipientInput - The user input of the recipient
           *  which is updated quickly to avoid delays in the UI reflecting manual entry
           *  of addresses.
           * @property {MapValuesToUnion<SendStateRecipientModes>} recipientMode -
           *  Describes which list of recipients the user is shown on the add recipient
           *  screen. When this key is set to 'MY_ACCOUNTS' the user is shown the list of
           *  accounts they own. When it is 'CONTACT_LIST' the user is shown the list of
           *  contacts they have saved in MetaMask and any addresses they have recently
           *  sent to.
           * @property {Account} selectedAccount - The currently selected account in
           *  MetaMask. Native balance and address will be pulled from this account if a
           *  fromAccount is not specified in the draftTransaction object. During an edit
           *  the fromAccount is specified.
           * @property {MapValuesToUnion<SendStateStages>} stage - The stage of the
           *  send flow that the user has progressed to. Defaults to 'INACTIVE' which
           *  results in the send screen not being shown.
           */

          /**
           * @type {SendState}
           */

          exports.draftTransactionInitialState = draftTransactionInitialState;
          const initialState = {
            amountMode: AMOUNT_MODES.INPUT,
            currentTransactionUUID: null,
            draftTransactions: {},
            eip1559support: false,
            gasEstimateIsLoading: true,
            gasEstimatePollToken: null,
            gasIsSetInModal: false,
            gasPriceEstimate: '0x0',
            gasLimitMinimum: _gas.GAS_LIMITS.SIMPLE,
            gasTotalForLayer1: '0x0',
            recipientMode: RECIPIENT_SEARCH_MODES.CONTACT_LIST,
            recipientInput: '',
            selectedAccount: {
              address: null,
              balance: '0x0'
            },
            stage: SEND_STAGES.INACTIVE
          };
          /**
           * TODO: We really need to start creating the metamask state type, and the
           * entire state tree of redux. Would be *extremely* valuable in future
           * typescript conversions. The metamask key is typed as an object on purpose
           * here because I cannot go so far in this work as to type that entire object.
           *
           * @typedef {object} MetaMaskState
           * @property {SendState} send - The state of the send flow.
           * @property {object} metamask - The state of the metamask store.
           */

          exports.initialState = initialState;
          const name = 'send'; // After modification of specific fields in specific circumstances we must
          // recompute the gasLimit estimate to be as accurate as possible. the cases
          // that necessitate this logic are listed below:
          // 1. when the amount sent changes when sending a token due to the amount being
          //    part of the hex encoded data property of the transaction.
          // 2. when updating the data property while sending NATIVE currency (ex: ETH)
          //    because the data parameter defines function calls that the EVM will have
          //    to execute which is where a large chunk of gas is potentially consumed.
          // 3. when the recipient changes while sending a token due to the recipient's
          //    address being included in the hex encoded data property of the
          //    transaction
          // 4. when the asset being sent changes due to the contract address and details
          //    of the token being included in the hex encoded data property of the
          //    transaction. If switching to NATIVE currency (ex: ETH), the gasLimit will
          //    change due to hex data being removed (unless supplied by user).
          // This method computes the gasLimit estimate which is written to state in an
          // action handler in extraReducers.

          const computeEstimatedGasLimit = (0, _toolkit.createAsyncThunk)('send/computeEstimatedGasLimit', async (_, thunkApi) => {
            var _transaction$dappSugg;

            const state = thunkApi.getState();
            const {
              send,
              metamask
            } = state;
            const draftTransaction = send.draftTransactions[send.currentTransactionUUID];
            const unapprovedTxs = (0, _metamask.getUnapprovedTxs)(state);
            const isMultiLayerFeeNetwork = (0, _selectors.getIsMultiLayerFeeNetwork)(state);
            const transaction = unapprovedTxs[draftTransaction.id];
            const isNonStandardEthChain = (0, _selectors.getIsNonStandardEthChain)(state);
            const chainId = (0, _selectors.getCurrentChainId)(state);
            let gasTotalForLayer1;

            if (isMultiLayerFeeNetwork) {
              var _draftTransaction$rec;

              gasTotalForLayer1 = await (0, _fetchEstimatedL1Fee.default)(global.eth, {
                txParams: {
                  gasPrice: draftTransaction.gas.gasPrice,
                  gas: draftTransaction.gas.gasLimit,
                  to: (_draftTransaction$rec = draftTransaction.recipient.address) === null || _draftTransaction$rec === void 0 ? void 0 : _draftTransaction$rec.toLowerCase(),
                  value: send.amountMode === AMOUNT_MODES.MAX ? send.selectedAccount.balance : draftTransaction.amount.value,
                  from: send.selectedAccount.address,
                  data: draftTransaction.userInputHexData,
                  type: '0x0'
                }
              });
            }

            if (send.stage !== SEND_STAGES.EDIT || !((_transaction$dappSugg = transaction.dappSuggestedGasFees) !== null && _transaction$dappSugg !== void 0 && _transaction$dappSugg.gas) || !transaction.userEditedGasLimit) {
              var _draftTransaction$rec2;

              const gasLimit = await (0, _helpers.estimateGasLimitForSend)({
                gasPrice: draftTransaction.gas.gasPrice,
                blockGasLimit: metamask.currentBlockGasLimit,
                selectedAddress: metamask.selectedAddress,
                sendToken: draftTransaction.asset.details,
                to: (_draftTransaction$rec2 = draftTransaction.recipient.address) === null || _draftTransaction$rec2 === void 0 ? void 0 : _draftTransaction$rec2.toLowerCase(),
                value: draftTransaction.amount.value,
                data: draftTransaction.userInputHexData,
                isNonStandardEthChain,
                chainId,
                gasLimit: draftTransaction.gas.gasLimit
              });
              await thunkApi.dispatch((0, _gas2.setCustomGasLimit)(gasLimit));
              return {
                gasLimit,
                gasTotalForLayer1
              };
            }

            return null;
          });
          /**
           * @typedef {object} Asset
           * @property {AssetTypesString} type - The type of asset that the user
           *  is attempting to send. Defaults to 'NATIVE' which represents the native
           *  asset of the chain. Can also be 'TOKEN' or 'COLLECTIBLE'.
           * @property {string} balance - A hex string representing the balance
           *  that the user holds of the asset that they are attempting to send.
           * @property {TokenDetails} [details] - An object that describes the
           *  selected asset in the case that the user is sending a token or collectibe.
           *  Will be null when asset.type is 'NATIVE'.
           * @property {string} [error] - Error to display when there is an issue
           *  with the asset.
           */

          /**
           * Responsible for initializing required state for the send slice.
           * This method is dispatched from the send page in the componentDidMount
           * method. It is also dispatched anytime the network changes to ensure that
           * the slice remains valid with changing token and account balances. To do so
           * it keys into state to get necessary values and computes a starting point for
           * the send slice. It returns the values that might change from this action and
           * those values are written to the slice in the `initializeSendState.fulfilled`
           * action handler.
           */

          exports.computeEstimatedGasLimit = computeEstimatedGasLimit;
          const initializeSendState = (0, _toolkit.createAsyncThunk)('send/initializeSendState', async ({
            chainHasChanged = false
          } = {}, thunkApi) => {
            /**
             * @typedef {object} ReduxState
             * @property {object} metamask - Half baked type for the MetaMask object
             * @property {SendState} send - the send state
             */

            /**
             * @type {ReduxState}
             */
            const state = thunkApi.getState();
            const isNonStandardEthChain = (0, _selectors.getIsNonStandardEthChain)(state);
            const chainId = (0, _selectors.getCurrentChainId)(state);
            const eip1559support = (0, _selectors.checkNetworkAndAccountSupports1559)(state);
            const account = (0, _selectors.getSelectedAccount)(state);
            const {
              send: sendState,
              metamask
            } = state;
            const draftTransaction = sendState.draftTransactions[sendState.currentTransactionUUID]; // If the draft transaction is not present, then this action has been
            // dispatched out of sync with the intended flow. This is not always a bug.
            // For instance, in the actions.js file we dispatch this action anytime the
            // chain changes.

            if (!draftTransaction) {
              return thunkApi.rejectWithValue('draftTransaction not found, possibly not on send flow');
            } // Default gasPrice to 1 gwei if all estimation fails, this is only used
            // for gasLimit estimation and won't be set directly in state. Instead, we
            // will return the gasFeeEstimates and gasEstimateType so that the reducer
            // can set the appropriate gas fees in state.


            let gasPrice = sendState.stage === SEND_STAGES.EDIT ? draftTransaction.gas.gasPrice : '0x1';
            let gasEstimatePollToken = null; // Instruct the background process that polling for gas prices should begin

            gasEstimatePollToken = await (0, _actions.getGasFeeEstimatesAndStartPolling)();
            (0, _actions.addPollingTokenToAppState)(gasEstimatePollToken);
            const {
              metamask: {
                gasFeeEstimates,
                gasEstimateType
              }
            } = thunkApi.getState();

            if (sendState.stage !== SEND_STAGES.EDIT) {
              // Because we are only interested in getting a gasLimit estimation we only
              // need to worry about gasPrice. So we use maxFeePerGas as gasPrice if we
              // have a fee market estimation.
              if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.LEGACY) {
                gasPrice = (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium);
              } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
                gasPrice = (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice);
              } else if (gasEstimateType === _gas.GAS_ESTIMATE_TYPES.FEE_MARKET) {
                gasPrice = (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium.suggestedMaxFeePerGas);
              } else {
                gasPrice = gasFeeEstimates.gasPrice ? (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice) : '0x0';
              }
            } // Set a basic gasLimit in the event that other estimation fails


            let {
              gasLimit
            } = draftTransaction.gas;

            if (gasEstimateType !== _gas.GAS_ESTIMATE_TYPES.NONE && sendState.stage !== SEND_STAGES.EDIT && draftTransaction.recipient.address) {
              var _draftTransaction$fro, _draftTransaction$fro2;

              gasLimit = draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN || draftTransaction.asset.type === _transaction.ASSET_TYPES.COLLECTIBLE ? _gas.GAS_LIMITS.BASE_TOKEN_ESTIMATE : _gas.GAS_LIMITS.SIMPLE; // Run our estimateGasLimit logic to get a more accurate estimation of
              // required gas. If this value isn't nullish, set it as the new gasLimit

              const estimatedGasLimit = await (0, _helpers.estimateGasLimitForSend)({
                gasPrice,
                blockGasLimit: metamask.currentBlockGasLimit,
                selectedAddress: (_draftTransaction$fro = (_draftTransaction$fro2 = draftTransaction.fromAccount) === null || _draftTransaction$fro2 === void 0 ? void 0 : _draftTransaction$fro2.address) !== null && _draftTransaction$fro !== void 0 ? _draftTransaction$fro : sendState.selectedAccount.address,
                sendToken: draftTransaction.asset.details,
                to: draftTransaction.recipient.address.toLowerCase(),
                value: draftTransaction.amount.value,
                data: draftTransaction.userInputHexData,
                isNonStandardEthChain,
                chainId
              });
              gasLimit = estimatedGasLimit || gasLimit;
            } // We have to keep the gas slice in sync with the send slice state
            // so that it'll be initialized correctly if the gas modal is opened.


            await thunkApi.dispatch((0, _gas2.setCustomGasLimit)(gasLimit)); // There may be a case where the send has been canceled by the user while
            // the gas estimate is being computed. So we check again to make sure that
            // a currentTransactionUUID exists and matches the previous tx.

            const newState = thunkApi.getState();

            if (newState.send.currentTransactionUUID !== sendState.currentTransactionUUID) {
              return thunkApi.rejectWithValue(`draftTransaction changed during initialization.
        A new initializeSendState action must be dispatched.`);
            }

            return {
              account,
              chainId: (0, _selectors.getCurrentChainId)(state),
              tokens: (0, _metamask.getTokens)(state),
              chainHasChanged,
              gasFeeEstimates,
              gasEstimateType,
              gasLimit,
              gasTotal: (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcGasTotal)(gasLimit, gasPrice)),
              gasEstimatePollToken,
              eip1559support,
              useTokenDetection: (0, _selectors.getUseTokenDetection)(state),
              tokenAddressList: Object.keys((0, _selectors.getTokenList)(state))
            };
          }); // Action Payload Typedefs

          /**
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<string>
           * )} SimpleStringPayload
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<MapValuesToUnion<SendStateAmountModes>>
           * )} SendStateAmountModePayload
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<DraftTransaction['asset']>
           * )} UpdateAssetPayload
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<Partial<
           *   Pick<DraftTransaction['recipient'], 'address' | 'nickname'>>
           *  >
           * )} updateRecipientPayload
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<SendState['recipientMode']>
           * )} UpdateRecipientModePayload
           */

          /**
           * @typedef {object} GasFeeUpdateParams
           * @property {TransactionTypeString} transactionType - The transaction type
           * @property {string} [maxFeePerGas] - The maximum amount in hex wei to pay
           *  per gas on a FEE_MARKET transaction.
           * @property {string} [maxPriorityFeePerGas] - The maximum amount in hex
           *  wei to pay per gas as an incentive to miners on a FEE_MARKET
           *  transaction.
           * @property {string} [gasPrice] - The amount in hex wei to pay per gas on
           *  a LEGACY transaction.
           * @property {boolean} [isAutomaticUpdate] - true if the update is the
           *  result of a gas estimate update from the controller.
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<GasFeeUpdateParams>
           * )} GasFeeUpdatePayload
           */

          /**
           * @typedef {object} GasEstimateUpdateParams
           * @property {GasEstimateType} gasEstimateType - The type of gas estimation
           *  provided by the controller.
           * @property {(
           *  EthGasPriceEstimate | LegacyGasPriceEstimate | GasFeeEstimates
           * )} gasFeeEstimates - The gas fee estimates provided by the controller.
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<GasEstimateUpdateParams>
           * )} GasEstimateUpdatePayload
           */

          /**
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<DraftTransaction['asset']>
           * )} UpdateAssetPayload
           * @typedef {(
           *  __import__('@reduxjs/toolkit').PayloadAction<DraftTransaction>
           * )} DraftTransactionPayload
           */

          exports.initializeSendState = initializeSendState;
          const slice = (0, _toolkit.createSlice)({
            name,
            initialState,
            reducers: {
              /**
               * Adds a new draft transaction to state, first generating a new UUID for
               * the transaction and setting that as the currentTransactionUUID. If the
               * draft has an id property set, the stage is set to EDIT.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {DraftTransactionPayload} action - An action with payload that is
               *  a new draft transaction that will be added to state.
               * @returns {void}
               */
              addNewDraft: (state, action) => {
                state.currentTransactionUUID = (0, _uuid.v4)();
                state.draftTransactions[state.currentTransactionUUID] = action.payload;

                if (action.payload.id) {
                  state.stage = SEND_STAGES.EDIT;
                } else {
                  state.stage = SEND_STAGES.ADD_RECIPIENT;
                }
              },

              /**
               * Adds an entry, with timestamp, to the draftTransaction history.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {SimpleStringPayload} action - An action with payload that is
               *  a string to be added to the history of the draftTransaction
               * @returns {void}
               */
              addHistoryEntry: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (draftTransaction) {
                  draftTransaction.history.push({
                    entry: action.payload,
                    timestamp: Date.now()
                  });
                }
              },

              /**
               * gasTotal is computed based on gasPrice and gasLimit and set in state
               * recomputes the maximum amount if the current amount mode is 'MAX' and
               * sending the native token. ERC20 assets max amount is unaffected by
               * gasTotal so does not need to be recomputed. Finally, validates the gas
               * field and send state.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              calculateGasTotal: state => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID]; // use maxFeePerGas as the multiplier if working with a FEE_MARKET transaction
                // otherwise use gasPrice

                if (draftTransaction.transactionType === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
                  draftTransaction.gas.gasTotal = (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcGasTotal)(draftTransaction.gas.gasLimit, draftTransaction.gas.maxFeePerGas));
                } else {
                  draftTransaction.gas.gasTotal = (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcGasTotal)(draftTransaction.gas.gasLimit, draftTransaction.gas.gasPrice));
                }

                if (state.amountMode === AMOUNT_MODES.MAX && draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
                  slice.caseReducers.updateAmountToMax(state);
                }

                slice.caseReducers.validateAmountField(state);
                slice.caseReducers.validateGasField(state); // validate send state

                slice.caseReducers.validateSendState(state);
              },

              /**
               * Clears all drafts from send state and drops the currentTransactionUUID.
               * This is an important first step before adding a new draft transaction to
               * avoid possible collision.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              clearPreviousDrafts: state => {
                state.currentTransactionUUID = null;
                state.draftTransactions = {};
              },

              /**
               * Clears the send state by setting it to the initial value
               *
               * @returns {SendState}
               */
              resetSendState: () => initialState,

              /**
               * sets the amount mode to the provided value as long as it is one of the
               * supported modes (MAX|INPUT)
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {SendStateAmountModePayload} action - The amount mode
               *  to set the state to.
               * @returns {void}
               */
              updateAmountMode: (state, action) => {
                if (Object.values(AMOUNT_MODES).includes(action.payload)) {
                  state.amountMode = action.payload;
                }
              },

              /**
               * computes the maximum amount of asset that can be sent and then calls
               * the updateSendAmount action above with the computed value, which will
               * revalidate the field and form.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              updateAmountToMax: state => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                let amount = '0x0';

                if (draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN) {
                  var _draftTransaction$ass, _draftTransaction$ass2;

                  const decimals = (_draftTransaction$ass = (_draftTransaction$ass2 = draftTransaction.asset.details) === null || _draftTransaction$ass2 === void 0 ? void 0 : _draftTransaction$ass2.decimals) !== null && _draftTransaction$ass !== void 0 ? _draftTransaction$ass : 0;
                  const multiplier = Math.pow(10, Number(decimals));
                  amount = (0, _conversion.multiplyCurrencies)(draftTransaction.asset.balance, multiplier, {
                    toNumericBase: 'hex',
                    multiplicandBase: 16,
                    multiplierBase: 10
                  });
                } else {
                  const _gasTotal = (0, _transactions.sumHexes)(draftTransaction.gas.gasTotal || '0x0', state.gasTotalForLayer1 || '0x0');

                  amount = (0, _conversion.subtractCurrencies)((0, _ethereumjsUtil.addHexPrefix)(draftTransaction.asset.balance), (0, _ethereumjsUtil.addHexPrefix)(_gasTotal), {
                    toNumericBase: 'hex',
                    aBase: 16,
                    bBase: 16
                  });
                }

                slice.caseReducers.updateSendAmount(state, {
                  payload: amount
                });
              },

              /**
               * Updates the currently selected asset
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {UpdateAssetPayload} action - The asset to set in the
               *  draftTransaction.
               * @returns {void}
               */
              updateAsset: (state, action) => {
                const {
                  asset,
                  initialAssetSet
                } = action.payload;
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.asset.type = asset.type;
                draftTransaction.asset.balance = asset.balance;
                draftTransaction.asset.error = asset.error;

                if (draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN || draftTransaction.asset.type === _transaction.ASSET_TYPES.COLLECTIBLE) {
                  draftTransaction.asset.details = asset.details;
                } else {
                  // clear the details object when sending native currency
                  draftTransaction.asset.details = null;

                  if (draftTransaction.recipient.error === _send.CONTRACT_ADDRESS_ERROR) {
                    // Errors related to sending tokens to their own contract address
                    // are no longer valid when sending native currency.
                    draftTransaction.recipient.error = null;
                  }
                } // if amount mode is MAX update amount to max of new asset, otherwise set
                // to zero. This will revalidate the send amount field.


                if (state.amountMode === AMOUNT_MODES.MAX) {
                  slice.caseReducers.updateAmountToMax(state);
                } else if (initialAssetSet === false) {
                  slice.caseReducers.updateSendAmount(state, {
                    payload: '0x0'
                  });
                } // validate send state


                slice.caseReducers.validateSendState(state);
              },

              /**
               * Sets the appropriate gas fees in state after receiving new estimates.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {GasEstimateUpdatePayload)} action - The gas fee update payload
               * @returns {void}
               */
              updateGasFeeEstimates: (state, action) => {
                const {
                  gasFeeEstimates,
                  gasEstimateType
                } = action.payload;
                let gasPriceEstimate = '0x0';

                switch (gasEstimateType) {
                  case _gas.GAS_ESTIMATE_TYPES.FEE_MARKET:
                    slice.caseReducers.updateGasFees(state, {
                      payload: {
                        transactionType: _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET,
                        maxFeePerGas: (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium.suggestedMaxFeePerGas),
                        maxPriorityFeePerGas: (0, _selectors.getGasPriceInHexWei)(gasFeeEstimates.medium.suggestedMaxPriorityFeePerGas)
                      }
                    });
                    break;

                  case _gas.GAS_ESTIMATE_TYPES.LEGACY:
                    gasPriceEstimate = (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.medium);
                    slice.caseReducers.updateGasFees(state, {
                      payload: {
                        gasPrice: gasPriceEstimate,
                        type: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
                        isAutomaticUpdate: true
                      }
                    });
                    break;

                  case _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE:
                    gasPriceEstimate = (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice);
                    slice.caseReducers.updateGasFees(state, {
                      payload: {
                        gasPrice: (0, _helpers.getRoundedGasPrice)(gasFeeEstimates.gasPrice),
                        type: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
                        isAutomaticUpdate: true
                      }
                    });
                    break;

                  case _gas.GAS_ESTIMATE_TYPES.NONE:
                  default:
                    break;
                } // Record the latest gasPriceEstimate for future comparisons


                state.gasPriceEstimate = (0, _ethereumjsUtil.addHexPrefix)(gasPriceEstimate);
              },

              /**
               * Sets the appropriate gas fees in state and determines and sets the
               * appropriate transactionType based on gas fee fields received.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {GasFeeUpdatePayload} action - The gas fees to update with
               * @returns {void}
               */
              updateGasFees: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (draftTransaction) {
                  if (action.payload.transactionType === _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET) {
                    draftTransaction.gas.maxFeePerGas = (0, _ethereumjsUtil.addHexPrefix)(action.payload.maxFeePerGas);
                    draftTransaction.gas.maxPriorityFeePerGas = (0, _ethereumjsUtil.addHexPrefix)(action.payload.maxPriorityFeePerGas);
                    draftTransaction.transactionType = _transaction.TRANSACTION_ENVELOPE_TYPES.FEE_MARKET;
                  } else {
                    if (action.payload.manuallyEdited) {
                      draftTransaction.gas.wasManuallyEdited = true;
                    } // Update the gas price if it has not been manually edited,
                    // or if this current action is a manual edit.


                    if (!draftTransaction.gas.wasManuallyEdited || action.payload.manuallyEdited) {
                      draftTransaction.gas.gasPrice = (0, _ethereumjsUtil.addHexPrefix)(action.payload.gasPrice);
                    }

                    draftTransaction.transactionType = _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
                  }

                  slice.caseReducers.calculateGasTotal(state);
                }
              },

              /**
               * sets the provided gasLimit in state and then recomputes the gasTotal.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {SimpleStringPayload} action - The
               *  gasLimit in hex to set in state.
               * @returns {void}
               */
              updateGasLimit: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (draftTransaction) {
                  draftTransaction.gas.gasLimit = (0, _ethereumjsUtil.addHexPrefix)(action.payload);
                  slice.caseReducers.calculateGasTotal(state);
                }
              },

              /**
               * sets the layer 1 fees total (for a multi-layer fee network)
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {SimpleStringPayload} action - the
               *  gasTotalForLayer1 to set in hex wei.
               * @returns {void}
               */
              updateLayer1Fees: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                state.gasTotalForLayer1 = action.payload;

                if (state.amountMode === AMOUNT_MODES.MAX && draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
                  slice.caseReducers.updateAmountToMax(state);
                }
              },

              /**
               * Updates the recipient of the draftTransaction
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {updateRecipientPayload} action - The recipient to set in the
               *  draftTransaction.
               * @returns {void}
               */
              updateRecipient: (state, action) => {
                var _action$payload$addre, _action$payload$nickn;

                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.recipient.error = null;
                state.recipientInput = '';
                draftTransaction.recipient.address = (_action$payload$addre = action.payload.address) !== null && _action$payload$addre !== void 0 ? _action$payload$addre : '';
                draftTransaction.recipient.nickname = (_action$payload$nickn = action.payload.nickname) !== null && _action$payload$nickn !== void 0 ? _action$payload$nickn : '';

                if (draftTransaction.recipient.address === '') {
                  // If address is null we are clearing the recipient and must return
                  // to the ADD_RECIPIENT stage.
                  state.stage = SEND_STAGES.ADD_RECIPIENT;
                } else {
                  // if an address is provided and an id exists, we progress to the EDIT
                  // stage, otherwise we progress to the DRAFT stage. We also reset the
                  // search mode for recipient search.
                  state.stage = draftTransaction.id === null ? SEND_STAGES.DRAFT : SEND_STAGES.EDIT;
                  state.recipientMode = RECIPIENT_SEARCH_MODES.CONTACT_LIST;
                } // validate send state


                slice.caseReducers.validateSendState(state);
              },

              /**
               * Clears the user input and changes the recipient search mode to the
               * specified value
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {UpdateRecipientModePayload} action - The mode to set the
               *  recipient search to
               * @returns {void}
               */
              updateRecipientSearchMode: (state, action) => {
                state.recipientInput = '';
                state.recipientMode = action.payload;
              },
              updateRecipientWarning: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.recipient.warning = action.payload;
              },
              updateRecipientType: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.recipient.type = action.payload;
              },
              updateDraftTransactionStatus: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.status = action.payload;
              },
              acknowledgeRecipientWarning: state => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.recipient.recipientWarningAcknowledged = true;
                slice.caseReducers.validateSendState(state);
              },

              /**
               * Updates the value of the recipientInput key with what the user has
               * typed into the recipient input field in the UI.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {SimpleStringPayload} action - the value the user has typed into
               *  the recipient field.
               * @returns {void}
               */
              updateRecipientUserInput: (state, action) => {
                // Update the value in state to match what the user is typing into the
                // input field
                state.recipientInput = action.payload;
              },

              /**
               * update current amount.value in state and run post update validation of
               * the amount field and the send state.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {SimpleStringPayload} action - The hex string to be set as the
               *  amount value.
               * @returns {void}
               */
              updateSendAmount: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.amount.value = (0, _ethereumjsUtil.addHexPrefix)(action.payload); // Once amount has changed, validate the field

                slice.caseReducers.validateAmountField(state);

                if (draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
                  // if sending the native asset the amount being sent will impact the
                  // gas field as well because the gas validation takes into
                  // consideration the available balance minus amount sent before
                  // checking if there is enough left to cover the gas fee.
                  slice.caseReducers.validateGasField(state);
                } // validate send state


                slice.caseReducers.validateSendState(state);
              },

              /**
               * updates the userInputHexData state key
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @param {SimpleStringPayload} action - The hex string to be set as the
               *  userInputHexData value.
               * @returns {void}
               */
              updateUserInputHexData: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                draftTransaction.userInputHexData = action.payload;
              },

              /**
               * Updates the gasIsSetInModal property to true which results in showing
               * the gas fees from the custom gas modal in the send page.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              useCustomGas: state => {
                state.gasIsSetInModal = true;
              },

              /**
               * Updates the gasIsSetInModal property to false which results in showing
               * the default gas price/limit fields in the send page.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              useDefaultGas: state => {
                state.gasIsSetInModal = false;
              },

              /**
               * Checks for the validity of the draftTransactions selected amount to send
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              validateAmountField: state => {
                var _draftTransaction$gas, _draftTransaction$ass3;

                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                switch (true) {
                  // set error to INSUFFICIENT_FUNDS_ERROR if the account balance is lower
                  // than the total price of the transaction inclusive of gas fees.
                  case draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE && !(0, _send2.isBalanceSufficient)({
                    amount: draftTransaction.amount.value,
                    balance: draftTransaction.asset.balance,
                    gasTotal: (_draftTransaction$gas = draftTransaction.gas.gasTotal) !== null && _draftTransaction$gas !== void 0 ? _draftTransaction$gas : '0x0'
                  }):
                    draftTransaction.amount.error = _send.INSUFFICIENT_FUNDS_ERROR;
                    break;
                  // set error to INSUFFICIENT_FUNDS_ERROR if the token balance is lower
                  // than the amount of token the user is attempting to send.

                  case draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN && !(0, _send2.isTokenBalanceSufficient)({
                    tokenBalance: (_draftTransaction$ass3 = draftTransaction.asset.balance) !== null && _draftTransaction$ass3 !== void 0 ? _draftTransaction$ass3 : '0x0',
                    amount: draftTransaction.amount.value,
                    decimals: draftTransaction.asset.details.decimals
                  }):
                    draftTransaction.amount.error = _send.INSUFFICIENT_TOKENS_ERROR;
                    break;
                  // if the amount is negative, set error to NEGATIVE_ETH_ERROR
                  // TODO: change this to NEGATIVE_ERROR and remove the currency bias.

                  case (0, _conversion.conversionGreaterThan)({
                    value: 0,
                    fromNumericBase: 'dec'
                  }, {
                    value: draftTransaction.amount.value,
                    fromNumericBase: 'hex'
                  }):
                    draftTransaction.amount.error = _send.NEGATIVE_ETH_ERROR;
                    break;
                  // If none of the above are true, set error to null

                  default:
                    draftTransaction.amount.error = null;
                }
              },

              /**
               * Checks if the user has enough funds to cover the cost of gas, always
               * uses the native currency and does not take into account the amount
               * being sent. If the user has enough to cover cost of gas but not gas
               * + amount then the error will be displayed on the amount field.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              validateGasField: state => {
                var _draftTransaction$fro3, _draftTransaction$fro4, _draftTransaction$gas2;

                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];
                const insufficientFunds = !(0, _send2.isBalanceSufficient)({
                  amount: draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE ? draftTransaction.amount.value : '0x0',
                  balance: (_draftTransaction$fro3 = (_draftTransaction$fro4 = draftTransaction.fromAccount) === null || _draftTransaction$fro4 === void 0 ? void 0 : _draftTransaction$fro4.balance) !== null && _draftTransaction$fro3 !== void 0 ? _draftTransaction$fro3 : state.selectedAccount.balance,
                  gasTotal: (_draftTransaction$gas2 = draftTransaction.gas.gasTotal) !== null && _draftTransaction$gas2 !== void 0 ? _draftTransaction$gas2 : '0x0'
                });
                draftTransaction.gas.error = insufficientFunds ? _send.INSUFFICIENT_FUNDS_ERROR : null;
              },
              validateRecipientUserInput: (state, action) => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (draftTransaction) {
                  if (state.recipientMode === RECIPIENT_SEARCH_MODES.MY_ACCOUNTS || state.recipientInput === '' || state.recipientInput === null) {
                    draftTransaction.recipient.error = null;
                    draftTransaction.recipient.warning = null;
                  } else {
                    var _draftTransaction$ass4, _draftTransaction$ass5;

                    const {
                      chainId,
                      tokens,
                      tokenAddressList,
                      isProbablyAnAssetContract
                    } = action.payload;

                    if ((0, _hexstringUtils.isBurnAddress)(state.recipientInput) || !(0, _hexstringUtils.isValidHexAddress)(state.recipientInput, {
                      mixedCaseUseChecksum: true
                    }) && !(0, _util.isValidDomainName)(state.recipientInput)) {
                      draftTransaction.recipient.error = (0, _util.isDefaultMetaMaskChain)(chainId) ? _send.INVALID_RECIPIENT_ADDRESS_ERROR : _send.INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR;
                    } else if ((0, _util.isOriginContractAddress)(state.recipientInput, (_draftTransaction$ass4 = draftTransaction.asset) === null || _draftTransaction$ass4 === void 0 ? void 0 : (_draftTransaction$ass5 = _draftTransaction$ass4.details) === null || _draftTransaction$ass5 === void 0 ? void 0 : _draftTransaction$ass5.address)) {
                      draftTransaction.recipient.error = _send.CONTRACT_ADDRESS_ERROR;
                    } else {
                      draftTransaction.recipient.error = null;
                    }

                    if ((0, _hexstringUtils.isValidHexAddress)(state.recipientInput) && (tokenAddressList.find(address => (0, _stringUtils.isEqualCaseInsensitive)(address, state.recipientInput)) || (0, _util.checkExistingAddresses)(state.recipientInput, tokens)) || isProbablyAnAssetContract) {
                      draftTransaction.recipient.warning = _send.KNOWN_RECIPIENT_ADDRESS_WARNING;
                    } else {
                      draftTransaction.recipient.warning = null;
                    }
                  }
                }

                slice.caseReducers.validateSendState(state);
              },

              /**
               * Checks if the draftTransaction is currently valid. The following list of
               * cases from the switch statement in this function describe when the
               * transaction is invalid. Please keep this comment updated.
               *
               * case 1: State is invalid when amount field has an error.
               * case 2: State is invalid when gas field has an error.
               * case 3: State is invalid when asset field has an error.
               * case 4: State is invalid if asset type is a token and the token details
               *  are unknown.
               * case 5: State is invalid if no recipient has been added.
               * case 6: State is invalid if the send state is uninitialized.
               * case 7: State is invalid if gas estimates are loading.
               * case 8: State is invalid if gasLimit is less than the gasLimitMinimum.
               *
               * @param {SendStateDraft} state - A writable draft of the send state to be
               *  updated.
               * @returns {void}
               */
              validateSendState: state => {
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (draftTransaction) {
                  switch (true) {
                    case Boolean(draftTransaction.amount.error):
                    case Boolean(draftTransaction.gas.error):
                    case Boolean(draftTransaction.asset.error):
                    case draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN && draftTransaction.asset.details === null:
                    case state.stage === SEND_STAGES.ADD_RECIPIENT:
                    case state.stage === SEND_STAGES.INACTIVE:
                    case state.gasEstimateIsLoading:
                    case new _bignumber.default(draftTransaction.gas.gasLimit, 16).lessThan(new _bignumber.default(state.gasLimitMinimum)):
                      draftTransaction.status = SEND_STATUSES.INVALID;
                      break;

                    case draftTransaction.recipient.warning === 'loading':
                    case draftTransaction.recipient.warning === _send.KNOWN_RECIPIENT_ADDRESS_WARNING && draftTransaction.recipient.recipientWarningAcknowledged === false:
                      draftTransaction.status = SEND_STATUSES.INVALID;
                      break;

                    default:
                      draftTransaction.status = SEND_STATUSES.VALID;
                  }
                }
              }
            },
            extraReducers: builder => {
              builder.addCase(_actionConstants.ACCOUNT_CHANGED, (state, action) => {
                // This event occurs when the user's account details update due to
                // background state changes. If the account that is being updated is
                // the current from account on the edit flow we need to update
                // the balance for the account and revalidate the send state.
                if (state.stage === SEND_STAGES.EDIT && action.payload.account) {
                  const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                  if (draftTransaction && draftTransaction.fromAccount && draftTransaction.fromAccount.address === action.payload.account.address) {
                    draftTransaction.fromAccount.balance = action.payload.account.balance; // We need to update the asset balance if the asset is the native
                    // network asset. Once we update the balance we recompute error state.

                    if (draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
                      draftTransaction.asset.balance = action.payload.account.balance;
                    }

                    slice.caseReducers.validateAmountField(state);
                    slice.caseReducers.validateGasField(state);
                    slice.caseReducers.validateSendState(state);
                  }
                }
              }).addCase(_actionConstants.ADDRESS_BOOK_UPDATED, (state, action) => {
                var _addressBook$draftTra;

                // When the address book updates from background state changes we need
                // to check to see if an entry exists for the current address or if the
                // entry changed.
                const {
                  addressBook
                } = action.payload;
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (draftTransaction && (_addressBook$draftTra = addressBook[draftTransaction.recipient.address]) !== null && _addressBook$draftTra !== void 0 && _addressBook$draftTra.name) {
                  draftTransaction.recipient.nickname = addressBook[draftTransaction.recipient.address].name;
                }
              }).addCase(computeEstimatedGasLimit.pending, state => {
                // When we begin to fetch gasLimit we should indicate we are loading
                // a gas estimate.
                state.gasEstimateIsLoading = true;
              }).addCase(computeEstimatedGasLimit.fulfilled, (state, action) => {
                var _action$payload, _action$payload2;

                // When we receive a new gasLimit from the computeEstimatedGasLimit
                // thunk we need to update our gasLimit in the slice. We call into the
                // caseReducer updateGasLimit to tap into the appropriate follow up
                // checks and gasTotal calculation. First set gasEstimateIsLoading to
                // false.
                state.gasEstimateIsLoading = false;

                if ((_action$payload = action.payload) !== null && _action$payload !== void 0 && _action$payload.gasLimit) {
                  slice.caseReducers.updateGasLimit(state, {
                    payload: action.payload.gasLimit
                  });
                }

                if ((_action$payload2 = action.payload) !== null && _action$payload2 !== void 0 && _action$payload2.gasTotalForLayer1) {
                  slice.caseReducers.updateLayer1Fees(state, {
                    payload: action.payload.gasTotalForLayer1
                  });
                }
              }).addCase(computeEstimatedGasLimit.rejected, state => {
                // If gas estimation fails, we should set the loading state to false,
                // because it is no longer loading
                state.gasEstimateIsLoading = false;
              }).addCase(_actionConstants.GAS_FEE_ESTIMATES_UPDATED, (state, action) => {
                // When the gasFeeController updates its gas fee estimates we need to
                // update and validate state based on those new values
                slice.caseReducers.updateGasFeeEstimates(state, {
                  payload: action.payload
                });
              }).addCase(initializeSendState.pending, state => {
                // when we begin initializing state, which can happen when switching
                // chains even after loading the send flow, we set gasEstimateIsLoading
                // as initialization will trigger a fetch for gasPrice estimates.
                state.gasEstimateIsLoading = true;
              }).addCase(initializeSendState.fulfilled, (state, action) => {
                // writes the computed initialized state values into the slice and then
                // calculates slice validity using the caseReducers.
                state.eip1559support = action.payload.eip1559support;
                state.selectedAccount.address = action.payload.account.address;
                state.selectedAccount.balance = action.payload.account.balance;
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (draftTransaction) {
                  draftTransaction.gas.gasLimit = action.payload.gasLimit;
                  draftTransaction.gas.gasTotal = action.payload.gasTotal;

                  if (action.payload.chainHasChanged) {
                    var _draftTransaction$fro5, _draftTransaction$fro6;

                    // If the state was reinitialized as a result of the user changing
                    // the network from the network dropdown, then the selected asset is
                    // no longer valid and should be set to the native asset for the
                    // network.
                    draftTransaction.asset.type = _transaction.ASSET_TYPES.NATIVE;
                    draftTransaction.asset.balance = (_draftTransaction$fro5 = (_draftTransaction$fro6 = draftTransaction.fromAccount) === null || _draftTransaction$fro6 === void 0 ? void 0 : _draftTransaction$fro6.balance) !== null && _draftTransaction$fro5 !== void 0 ? _draftTransaction$fro5 : state.selectedAccount.balance;
                    draftTransaction.asset.details = null;
                  }
                }

                slice.caseReducers.updateGasFeeEstimates(state, {
                  payload: {
                    gasFeeEstimates: action.payload.gasFeeEstimates,
                    gasEstimateType: action.payload.gasEstimateType
                  }
                });
                state.gasEstimatePollToken = action.payload.gasEstimatePollToken;

                if (action.payload.gasEstimatePollToken) {
                  state.gasEstimateIsLoading = false;
                }

                if (state.stage !== SEND_STAGES.INACTIVE) {
                  slice.caseReducers.validateRecipientUserInput(state, {
                    payload: {
                      chainId: action.payload.chainId,
                      tokens: action.payload.tokens,
                      useTokenDetection: action.payload.useTokenDetection,
                      tokenAddressList: action.payload.tokenAddressList
                    }
                  });
                }

                if (state.amountMode === AMOUNT_MODES.MAX) {
                  slice.caseReducers.updateAmountToMax(state);
                }

                slice.caseReducers.validateAmountField(state);
                slice.caseReducers.validateGasField(state);
                slice.caseReducers.validateSendState(state);
              }).addCase(_actionConstants.SELECTED_ACCOUNT_CHANGED, (state, action) => {
                // This event occurs when the user selects a new account from the
                // account menu, or the currently active account's balance updates.
                // We only care about new transactions, not edits, here, because we use
                // the fromAccount and ACCOUNT_CHANGED action for that.
                if (state.stage !== SEND_STAGES.EDIT && action.payload.account) {
                  state.selectedAccount.balance = action.payload.account.balance;
                  state.selectedAccount.address = action.payload.account.address;
                  const draftTransaction = state.draftTransactions[state.currentTransactionUUID]; // This action will occur even when we aren't on the send flow, which
                  // is okay as it keeps the selectedAccount details up to date. We do
                  // not need to validate anything if there isn't a current draft
                  // transaction. If there is, we need to update the asset balance if
                  // the asset is set to the native network asset, and then validate
                  // the transaction.

                  if (draftTransaction) {
                    if ((draftTransaction === null || draftTransaction === void 0 ? void 0 : draftTransaction.asset.type) === _transaction.ASSET_TYPES.NATIVE) {
                      draftTransaction.asset.balance = action.payload.account.balance;
                    }

                    slice.caseReducers.validateAmountField(state);
                    slice.caseReducers.validateGasField(state);
                    slice.caseReducers.validateSendState(state);
                  }
                }
              }).addCase(_actionConstants.QR_CODE_DETECTED, (state, action) => {
                // When data is received from the QR Code Scanner we set the recipient
                // as long as a valid address can be pulled from the data. If an
                // address is pulled but it is invalid, we display an error.
                const qrCodeData = action.value;
                const draftTransaction = state.draftTransactions[state.currentTransactionUUID];

                if (qrCodeData && draftTransaction) {
                  if (qrCodeData.type === 'address') {
                    const scannedAddress = qrCodeData.values.address.toLowerCase();

                    if ((0, _hexstringUtils.isValidHexAddress)(scannedAddress, {
                      allowNonPrefixed: false
                    })) {
                      if (draftTransaction.recipient.address !== scannedAddress) {
                        slice.caseReducers.updateRecipient(state, {
                          payload: {
                            address: scannedAddress
                          }
                        });
                      }
                    } else {
                      draftTransaction.recipient.error = _send.INVALID_RECIPIENT_ADDRESS_ERROR;
                    }
                  }
                }
              });
            }
          });
          const {
            actions,
            reducer
          } = slice;
          var _default = reducer;
          exports.default = _default;
          const {
            useDefaultGas,
            useCustomGas,
            updateGasLimit,
            validateRecipientUserInput,
            updateRecipientSearchMode,
            addHistoryEntry,
            acknowledgeRecipientWarning
          } = actions;
          exports.acknowledgeRecipientWarning = acknowledgeRecipientWarning;
          exports.addHistoryEntry = addHistoryEntry;
          exports.updateGasLimit = updateGasLimit;
          exports.useCustomGas = useCustomGas;
          exports.useDefaultGas = useDefaultGas;
          // Action Creators

          /**
           * This method is for usage when validating user input so that validation
           * is only run after a delay in typing of 300ms. Usage at callsites requires
           * passing in both the dispatch method and the payload to dispatch, which makes
           * it only applicable for use within action creators.
           */
          const debouncedValidateRecipientUserInput = (0, _lodash.debounce)((dispatch, payload, resolve) => {
            dispatch(addHistoryEntry(`sendFlow - user typed ${payload.userInput} into recipient input field`));
            dispatch(validateRecipientUserInput(payload));
            resolve();
          }, 300);
          /**
           * Begins a new draft transaction, derived from the txParams of an existing
           * transaction in the TransactionController. This action will first clear out
           * the previous draft transactions and currentTransactionUUID from state. This
           * action is one of the two entry points into the send flow. NOTE: You must
           * route to the send page *after* dispatching this action resolves to ensure
           * that the draftTransaction is properly created.
           *
           * @param {AssetTypesString} assetType - The type of asset the transaction
           *  being edited was sending. The details of the asset will be retrieved from
           *  the transaction data in state.
           * @param {string} transactionId - The id of the transaction being edited.
           * @returns {ThunkAction<void>}
           */

          function editExistingTransaction(assetType, transactionId) {
            return async (dispatch, getState) => {
              await dispatch(actions.clearPreviousDrafts());
              const state = getState();
              const unapprovedTransactions = (0, _metamask.getUnapprovedTxs)(state);
              const transaction = unapprovedTransactions[transactionId];
              const account = (0, _selectors.getTargetAccount)(state, transaction.txParams.from);

              if (assetType === _transaction.ASSET_TYPES.NATIVE) {
                var _getAddressBookEntryO;

                await dispatch(actions.addNewDraft({
                  ...draftTransactionInitialState,
                  id: transactionId,
                  fromAccount: account,
                  gas: {
                    ...draftTransactionInitialState.gas,
                    gasLimit: transaction.txParams.gas,
                    gasPrice: transaction.txParams.gasPrice
                  },
                  userInputHexData: transaction.txParams.data,
                  recipient: {
                    ...draftTransactionInitialState.recipient,
                    address: transaction.txParams.to,
                    nickname: (_getAddressBookEntryO = (0, _selectors.getAddressBookEntryOrAccountName)(state, transaction.txParams.to)) !== null && _getAddressBookEntryO !== void 0 ? _getAddressBookEntryO : ''
                  },
                  amount: {
                    ...draftTransactionInitialState.amount,
                    value: transaction.txParams.value
                  },
                  history: [`sendFlow - user clicked edit on transaction with id ${transactionId}`]
                }));
                await dispatch(updateSendAsset({
                  type: _transaction.ASSET_TYPES.NATIVE
                }, {
                  initialAssetSet: true
                }));
              } else {
                var _getAddressBookEntryO2, _getTokenIdParam;

                const tokenData = (0, _transaction2.parseStandardTokenTransactionData)(transaction.txParams.data);
                const tokenAmountInDec = assetType === _transaction.ASSET_TYPES.TOKEN ? (0, _metamaskControllerUtils.getTokenValueParam)(tokenData) : '1';
                const address = (0, _tokenUtil.getTokenAddressParam)(tokenData);
                const nickname = (_getAddressBookEntryO2 = (0, _selectors.getAddressBookEntryOrAccountName)(state, address)) !== null && _getAddressBookEntryO2 !== void 0 ? _getAddressBookEntryO2 : '';
                const tokenAmountInHex = (0, _ethereumjsUtil.addHexPrefix)((0, _conversion.conversionUtil)(tokenAmountInDec, {
                  fromNumericBase: 'dec',
                  toNumericBase: 'hex'
                }));
                await dispatch(actions.addNewDraft({
                  ...draftTransactionInitialState,
                  id: transactionId,
                  fromAccount: account,
                  gas: {
                    ...draftTransactionInitialState.gas,
                    gasLimit: transaction.txParams.gas,
                    gasPrice: transaction.txParams.gasPrice
                  },
                  userInputHexData: transaction.txParams.data,
                  recipient: {
                    ...draftTransactionInitialState.recipient,
                    address,
                    nickname
                  },
                  amount: {
                    ...draftTransactionInitialState.amount,
                    value: tokenAmountInHex
                  },
                  history: [`sendFlow - user clicked edit on transaction with id ${transactionId}`]
                }));
                await dispatch(updateSendAsset({
                  type: assetType,
                  details: {
                    address: transaction.txParams.to,
                    ...(assetType === _transaction.ASSET_TYPES.COLLECTIBLE ? {
                      tokenId: (_getTokenIdParam = (0, _tokenUtil.getTokenIdParam)(tokenData)) !== null && _getTokenIdParam !== void 0 ? _getTokenIdParam : (0, _metamaskControllerUtils.getTokenValueParam)(tokenData)
                    } : {})
                  }
                }, {
                  initialAssetSet: true
                }));
              }

              await dispatch(initializeSendState());
            };
          }
          /**
           * This method is a temporary placeholder to support the old UI in both the
           * gas modal and the send flow. Soon we won't need to modify gasPrice from the
           * send flow based on user input, it'll just be a shallow copy of the current
           * estimate. This method is necessary because the internal structure of this
           * slice has been changed such that it is agnostic to transaction envelope
           * type, and this method calls into the new structure in the appropriate way.
           *
           * @deprecated - don't extend the usage of this temporary method
           * @param {string} gasPrice - new gas price in hex wei
           * @returns {ThunkAction<void>}
           */


          function updateGasPrice(gasPrice) {
            return dispatch => {
              dispatch(addHistoryEntry(`sendFlow - user set legacy gasPrice to ${gasPrice}`));
              dispatch(actions.updateGasFees({
                gasPrice,
                transactionType: _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY,
                manuallyEdited: true
              }));
            };
          }
          /**
           * Updates the recipient in state based on the input provided, and then will
           * recompute gas limit when sending a TOKEN asset type. Changing the recipient
           * address results in hex data changing because the recipient address is
           * encoded in the data instead of being in the 'to' field. The to field in a
           * token send will always be the token contract address.
           * If no nickname is provided, the address book state will be checked to see if
           * a nickname for the passed address has already been saved. This ensures the
           * (temporary) send state recipient nickname is consistent with the address book
           * nickname which has already been persisted to state.
           *
           * @param {object} recipient - Recipient information
           * @param {string} recipient.address - hex address to send the transaction to
           * @param {string} [recipient.nickname] - Alias for the address to display
           *  to the user
           * @returns {ThunkAction<void>}
           */


          function updateRecipient({
            address,
            nickname
          }) {
            return async (dispatch, getState) => {
              var _getAddressBookEntryO3;

              // Do not addHistoryEntry here as this is called from a number of places
              // each with significance to the user and transaction history.
              const state = getState();
              const nicknameFromAddressBookEntryOrAccountName = (_getAddressBookEntryO3 = (0, _selectors.getAddressBookEntryOrAccountName)(state, address)) !== null && _getAddressBookEntryO3 !== void 0 ? _getAddressBookEntryO3 : '';
              await dispatch(actions.updateRecipient({
                address,
                nickname: nickname || nicknameFromAddressBookEntryOrAccountName
              }));
              await dispatch(computeEstimatedGasLimit());
            };
          }
          /**
           * This method is called to update the user's input into the ENS input field.
           * Once the field is updated, the field will be validated using a debounced
           * version of the validateRecipientUserInput action. This way validation only
           * occurs once the user has stopped typing.
           *
           * @param {string} userInput - the value that the user is typing into the field
           */


          function updateRecipientUserInput(userInput) {
            return async (dispatch, getState) => {
              var _ref, _draftTransaction$fro7, _draftTransaction$fro8;

              dispatch(actions.updateRecipientWarning('loading'));
              dispatch(actions.updateDraftTransactionStatus(SEND_STATUSES.INVALID));
              await dispatch(actions.updateRecipientUserInput(userInput));
              const state = getState();
              const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];
              const sendingAddress = (_ref = (_draftTransaction$fro7 = (_draftTransaction$fro8 = draftTransaction.fromAccount) === null || _draftTransaction$fro8 === void 0 ? void 0 : _draftTransaction$fro8.address) !== null && _draftTransaction$fro7 !== void 0 ? _draftTransaction$fro7 : state[name].selectedAccount.address) !== null && _ref !== void 0 ? _ref : (0, _selectors.getSelectedAddress)(state);
              const chainId = (0, _selectors.getCurrentChainId)(state);
              const tokens = (0, _metamask.getTokens)(state);
              const useTokenDetection = (0, _selectors.getUseTokenDetection)(state);
              const tokenMap = (0, _selectors.getTokenList)(state);
              const tokenAddressList = Object.keys(tokenMap);
              const inputIsValidHexAddress = (0, _hexstringUtils.isValidHexAddress)(userInput);
              let isProbablyAnAssetContract = false;

              if (inputIsValidHexAddress) {
                const smartContractAddress = await (0, _transactions.isSmartContractAddress)(userInput);

                if (smartContractAddress) {
                  dispatch(actions.updateRecipientType(_send.RECIPIENT_TYPES.SMART_CONTRACT));
                  const {
                    symbol,
                    decimals
                  } = (0, _tokenUtil.getTokenMetadata)(userInput, tokenMap) || {};
                  isProbablyAnAssetContract = symbol && decimals !== undefined;

                  if (!isProbablyAnAssetContract) {
                    try {
                      const {
                        standard
                      } = await (0, _actions.getTokenStandardAndDetails)(userInput, sendingAddress);
                      isProbablyAnAssetContract = Boolean(standard);
                    } catch (e) {
                      console.log(e);
                    }
                  }
                }
              }

              return new Promise(resolve => {
                debouncedValidateRecipientUserInput(dispatch, {
                  userInput,
                  chainId,
                  tokens,
                  useTokenDetection,
                  tokenAddressList,
                  isProbablyAnAssetContract
                }, resolve);
              });
            };
          }
          /**
           * Updates the amount the user intends to send and performs side effects.
           * 1. If the current mode is MAX change to INPUT
           * 2. If sending a token, recompute the gasLimit estimate
           *
           * @param {string} amount - hex string representing value
           * @returns {ThunkAction<void>}
           */


          function updateSendAmount(amount) {
            return async (dispatch, getState) => {
              const state = getState();
              const {
                metamask
              } = state;
              const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];
              let logAmount = amount;

              if (draftTransaction.asset.type === _transaction.ASSET_TYPES.TOKEN) {
                var _draftTransaction$ass6, _draftTransaction$ass7, _draftTransaction$ass8;

                const multiplier = Math.pow(10, Number(((_draftTransaction$ass6 = draftTransaction.asset.details) === null || _draftTransaction$ass6 === void 0 ? void 0 : _draftTransaction$ass6.decimals) || 0));
                const decimalValueString = (0, _conversion.conversionUtil)((0, _ethereumjsUtil.addHexPrefix)(amount), {
                  fromNumericBase: 'hex',
                  toNumericBase: 'dec',
                  toCurrency: (_draftTransaction$ass7 = draftTransaction.asset.details) === null || _draftTransaction$ass7 === void 0 ? void 0 : _draftTransaction$ass7.symbol,
                  conversionRate: multiplier,
                  invertConversionRate: true
                });
                logAmount = `${Number(decimalValueString) ? decimalValueString : ''} ${(_draftTransaction$ass8 = draftTransaction.asset.details) === null || _draftTransaction$ass8 === void 0 ? void 0 : _draftTransaction$ass8.symbol}`;
              } else {
                var _metamask$provider;

                const ethValue = (0, _confirmTx.getValueFromWeiHex)({
                  value: amount,
                  toCurrency: _common.ETH,
                  numberOfDecimals: 8
                });
                logAmount = `${ethValue} ${(metamask === null || metamask === void 0 ? void 0 : (_metamask$provider = metamask.provider) === null || _metamask$provider === void 0 ? void 0 : _metamask$provider.ticker) || _common.ETH}`;
              }

              await dispatch(addHistoryEntry(`sendFlow - user set amount to ${logAmount}`));
              await dispatch(actions.updateSendAmount(amount));

              if (state[name].amountMode === AMOUNT_MODES.MAX) {
                await dispatch(actions.updateAmountMode(AMOUNT_MODES.INPUT));
              }

              await dispatch(computeEstimatedGasLimit());
            };
          }
          /**
           * updates the asset to send to one of NATIVE or TOKEN and ensures that the
           * asset balance is set. If sending a TOKEN also updates the asset details
           * object with the appropriate ERC20 details including address, symbol and
           * decimals.
           *
           * @param {object} payload - action payload
           * @param {string} payload.type - type of asset to send
           * @param {TokenDetails} [payload.details] - ERC20 details if sending TOKEN asset
           * @returns {ThunkAction<void>}
           */


          function updateSendAsset({
            type,
            details: providedDetails
          }, {
            initialAssetSet = false
          } = {}) {
            return async (dispatch, getState) => {
              var _ref2, _draftTransaction$fro9, _draftTransaction$fro10;

              const state = getState();
              const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];
              const sendingAddress = (_ref2 = (_draftTransaction$fro9 = (_draftTransaction$fro10 = draftTransaction.fromAccount) === null || _draftTransaction$fro10 === void 0 ? void 0 : _draftTransaction$fro10.address) !== null && _draftTransaction$fro9 !== void 0 ? _draftTransaction$fro9 : state[name].selectedAccount.address) !== null && _ref2 !== void 0 ? _ref2 : (0, _selectors.getSelectedAddress)(state);
              const account = (0, _selectors.getTargetAccount)(state, sendingAddress);

              if (type === _transaction.ASSET_TYPES.NATIVE) {
                var _state$metamask$provi, _state$metamask$provi2;

                const unapprovedTxs = (0, _metamask.getUnapprovedTxs)(state);
                const unapprovedTx = unapprovedTxs === null || unapprovedTxs === void 0 ? void 0 : unapprovedTxs[draftTransaction.id];
                await dispatch(addHistoryEntry(`sendFlow - user set asset of type ${_transaction.ASSET_TYPES.NATIVE} with symbol ${(_state$metamask$provi = (_state$metamask$provi2 = state.metamask.provider) === null || _state$metamask$provi2 === void 0 ? void 0 : _state$metamask$provi2.ticker) !== null && _state$metamask$provi !== void 0 ? _state$metamask$provi : _common.ETH}`));
                await dispatch(actions.updateAsset({
                  asset: {
                    type,
                    details: null,
                    balance: account.balance,
                    error: null
                  },
                  initialAssetSet
                })); // This is meant to handle cases where we are editing an unapprovedTx from the background state
                // and its type is a token method. In such a case, the hex data will be the necessary hex data
                // for calling the contract transfer method.
                // Now that we are updating the transaction to be a send of a native asset type, we should
                // set the hex data of the transaction being editing to be empty.
                // then the user will not want to send any hex data now that they have change the

                if ((unapprovedTx === null || unapprovedTx === void 0 ? void 0 : unapprovedTx.type) === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM || (unapprovedTx === null || unapprovedTx === void 0 ? void 0 : unapprovedTx.type) === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER || (unapprovedTx === null || unapprovedTx === void 0 ? void 0 : unapprovedTx.type) === _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM) {
                  await dispatch(actions.updateUserInputHexData(''));
                }
              } else {
                await dispatch((0, _actions.showLoadingIndication)());
                const details = {
                  ...providedDetails,
                  ...(await (0, _actions.getTokenStandardAndDetails)(providedDetails.address, sendingAddress, providedDetails.tokenId))
                };
                await dispatch((0, _actions.hideLoadingIndication)());
                const asset = {
                  type,
                  details,
                  error: null
                };

                if (details.standard === _transaction.TOKEN_STANDARDS.ERC20) {
                  asset.balance = (0, _ethereumjsUtil.addHexPrefix)((0, _transactionsControllerUtils.calcTokenAmount)(details.balance, details.decimals).toString(16));
                  await dispatch(addHistoryEntry(`sendFlow - user set asset to ERC20 token with symbol ${details.symbol} and address ${details.address}`));
                } else if (details.standard === _transaction.TOKEN_STANDARDS.ERC1155 && type === _transaction.ASSET_TYPES.COLLECTIBLE) {
                  throw new Error('Sends of ERC1155 tokens are not currently supported');
                } else if (details.standard === _transaction.TOKEN_STANDARDS.ERC1155 || details.standard === _transaction.TOKEN_STANDARDS.ERC721) {
                  if (type === _transaction.ASSET_TYPES.TOKEN && false) {
                    dispatch((0, _actions.showModal)({
                      name: 'CONVERT_TOKEN_TO_NFT',
                      tokenAddress: details.address
                    }));
                    asset.error = _errorKeys.INVALID_ASSET_TYPE;
                    throw new Error(_errorKeys.INVALID_ASSET_TYPE);
                  } else {
                    let isCurrentOwner = true;

                    try {
                      isCurrentOwner = await (0, _actions.isCollectibleOwner)(sendingAddress, details.address, details.tokenId);
                    } catch (err) {
                      if (err.message.includes('Unable to verify ownership.')) {// this would indicate that either our attempts to verify ownership failed because of network issues,
                        // or, somehow a token has been added to collectibles state with an incorrect chainId.
                      } else {
                        // Any other error is unexpected and should be surfaced.
                        dispatch((0, _actions.displayWarning)(err.message));
                      }
                    }

                    if (isCurrentOwner) {
                      asset.error = null;
                      asset.balance = '0x1';
                    } else {
                      throw new Error('Send slice initialized as collectible send with a collectible not currently owned by the select account');
                    }

                    await dispatch(addHistoryEntry(`sendFlow - user set asset to NFT with tokenId ${details.tokenId} and address ${details.address}`));
                  }
                }

                await dispatch(actions.updateAsset({
                  asset,
                  initialAssetSet
                }));
              }

              if (initialAssetSet === false) {
                await dispatch(computeEstimatedGasLimit());
              }
            };
          }
          /**
           * When a user has enabled hex data field in advanced settings they will be
           * able to supply hex data on a transaction. This method updates the user
           * supplied data. Note, when sending native assets this will result in
           * recomputing estimated gasLimit. When sending a ERC20 asset this is not done
           * because the data sent in the transaction will be determined by the asset,
           * recipient and value, NOT what the user has supplied.
           *
           * @param {string} hexData - hex encoded string representing transaction data.
           * @returns {ThunkAction<void>}
           */


          function updateSendHexData(hexData) {
            return async (dispatch, getState) => {
              await dispatch(addHistoryEntry(`sendFlow - user added custom hexData ${hexData}`));
              await dispatch(actions.updateUserInputHexData(hexData));
              const state = getState();
              const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];

              if (draftTransaction.asset.type === _transaction.ASSET_TYPES.NATIVE) {
                await dispatch(computeEstimatedGasLimit());
              }
            };
          }
          /**
           * Sets the recipient search mode to show a list of the user's contacts and
           * recently interacted with addresses.
           *
           * @returns {ThunkAction<void>}
           */


          function useContactListForRecipientSearch() {
            return dispatch => {
              dispatch(addHistoryEntry(`sendFlow - user selected back to all on recipient screen`));
              dispatch(updateRecipientSearchMode(RECIPIENT_SEARCH_MODES.CONTACT_LIST));
            };
          }
          /**
           * Sets the recipient search mode to show a list of the user's own accounts.
           *
           * @returns {ThunkAction<void>}
           */


          function useMyAccountsForRecipientSearch() {
            return dispatch => {
              dispatch(addHistoryEntry(`sendFlow - user selected transfer to my accounts on recipient screen`));
              dispatch(updateRecipientSearchMode(RECIPIENT_SEARCH_MODES.MY_ACCOUNTS));
            };
          }
          /**
           * Clears out the recipient user input, ENS resolution and recipient validation.
           *
           * @returns {ThunkAction<void>}
           */


          function resetRecipientInput() {
            return async (dispatch, getState) => {
              const state = getState();
              const chainId = (0, _selectors.getCurrentChainId)(state);
              await dispatch(addHistoryEntry(`sendFlow - user cleared recipient input`));
              await dispatch(updateRecipientUserInput(''));
              await dispatch(updateRecipient({
                address: '',
                nickname: ''
              }));
              await dispatch((0, _ens.resetEnsResolution)());
              await dispatch(validateRecipientUserInput({
                chainId
              }));
            };
          }
          /**
           * Resets the entire send state tree to the initial state. It also disconnects
           * polling from the gas controller if the token is present in state.
           *
           * @returns {ThunkAction<void>}
           */


          function resetSendState() {
            return async (dispatch, getState) => {
              const state = getState();
              dispatch(actions.resetSendState());

              if (state[name].gasEstimatePollToken) {
                await (0, _actions.disconnectGasFeeEstimatePoller)(state[name].gasEstimatePollToken);
                (0, _actions.removePollingTokenFromAppState)(state[name].gasEstimatePollToken);
              }
            };
          }
          /**
           * Signs a transaction or updates a transaction in state if editing.
           * This method is called when a user clicks the next button in the footer of
           * the send page, signaling that a transaction should be executed. This method
           * will create the transaction in state (by way of the various global provider
           * constructs) which will eventually (and fairly quickly from user perspective)
           * result in a confirmation window being displayed for the transaction.
           *
           * @returns {ThunkAction<void>}
           */


          function signTransaction() {
            return async (dispatch, getState) => {
              const state = getState();
              const {
                stage,
                eip1559support
              } = state[name];
              const txParams = (0, _helpers.generateTransactionParams)(state[name]);
              const draftTransaction = state[name].draftTransactions[state[name].currentTransactionUUID];

              if (stage === SEND_STAGES.EDIT) {
                var _unapprovedTx$sendFlo;

                // When dealing with the edit flow there is already a transaction in
                // state that we must update, this branch is responsible for that logic.
                // We first must grab the previous transaction object from state and then
                // merge in the modified txParams. Once the transaction has been modified
                // we can send that to the background to update the transaction in state.
                const unapprovedTxs = (0, _metamask.getUnapprovedTxs)(state);
                const unapprovedTx = unapprovedTxs[draftTransaction.id]; // We only update the tx params that can be changed via the edit flow UX

                const eip1559OnlyTxParamsToUpdate = {
                  data: txParams.data,
                  from: txParams.from,
                  to: txParams.to,
                  value: txParams.value,
                  gas: unapprovedTx.userEditedGasLimit ? unapprovedTx.txParams.gas : txParams.gas
                };
                unapprovedTx.originalGasEstimate = eip1559OnlyTxParamsToUpdate.gas;
                const editingTx = {
                  ...unapprovedTx,
                  txParams: Object.assign(unapprovedTx.txParams, eip1559support ? eip1559OnlyTxParamsToUpdate : txParams)
                };
                await dispatch(addHistoryEntry(`sendFlow - user clicked next and transaction should be updated in controller`));
                await dispatch((0, _actions.updateTransactionSendFlowHistory)(draftTransaction.id, ((_unapprovedTx$sendFlo = unapprovedTx.sendFlowHistory) === null || _unapprovedTx$sendFlo === void 0 ? void 0 : _unapprovedTx$sendFlo.length) || 0, draftTransaction.history));
                await dispatch((0, _actions.updateEditableParams)(draftTransaction.id, editingTx.txParams));
                await dispatch((0, _actions.updateTransactionGasFees)(draftTransaction.id, editingTx.txParams));
              } else {
                let transactionType = draftTransaction.recipient.type === _send.RECIPIENT_TYPES.SMART_CONTRACT ? _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION : _transaction.TRANSACTION_TYPES.SIMPLE_SEND;

                if (draftTransaction.asset.type !== _transaction.ASSET_TYPES.NATIVE) {
                  transactionType = draftTransaction.asset.type === _transaction.ASSET_TYPES.COLLECTIBLE ? _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM : _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER;
                }

                await dispatch(addHistoryEntry(`sendFlow - user clicked next and transaction should be added to controller`));
                dispatch((0, _actions.addUnapprovedTransactionAndRouteToConfirmationPage)(txParams, transactionType, draftTransaction.history));
              }
            };
          }
          /**
           * Toggles the amount.mode between INPUT and MAX modes.
           * As a result, the amount.value will change to either '0x0' when moving from
           * MAX to INPUT, or to the maximum allowable amount based on current asset when
           * moving from INPUT to MAX.
           *
           * @returns {ThunkAction<void>}
           */


          function toggleSendMaxMode() {
            return async (dispatch, getState) => {
              const state = getState();

              if (state[name].amountMode === AMOUNT_MODES.MAX) {
                await dispatch(actions.updateAmountMode(AMOUNT_MODES.INPUT));
                await dispatch(actions.updateSendAmount('0x0'));
                await dispatch(addHistoryEntry(`sendFlow - user toggled max mode off`));
              } else {
                await dispatch(actions.updateAmountMode(AMOUNT_MODES.MAX));
                await dispatch(actions.updateAmountToMax());
                await dispatch(addHistoryEntry(`sendFlow - user toggled max mode on`));
              }

              await dispatch(computeEstimatedGasLimit());
            };
          }
          /**
           * Begins a new draft transaction, clearing out the previous draft transactions
           * from state, and clearing the currentTransactionUUID. This action is one of
           * the two entry points into the send flow. NOTE: You must route to the send
           * page *after* dispatching this action resolves to ensure that the
           * draftTransaction is properly created.
           *
           * @param {Pick<Asset, 'type' | 'details'>} asset - A partial asset
           *  object containing at least the asset type. If specifying a non-native asset
           *  then the asset details must be included with at least the address.
           * @returns {ThunkAction<void>}
           */


          function startNewDraftTransaction(asset) {
            return async dispatch => {
              var _asset$type;

              await dispatch(actions.clearPreviousDrafts());
              await dispatch(actions.addNewDraft({
                ...draftTransactionInitialState,
                history: [`sendFlow - User started new draft transaction`]
              }));
              await dispatch(updateSendAsset({
                type: (_asset$type = asset.type) !== null && _asset$type !== void 0 ? _asset$type : _transaction.ASSET_TYPES.NATIVE,
                details: asset.details
              }));
              await dispatch(initializeSendState());
            };
          } // Selectors

          /**
           * The following typedef is a shortcut for typing selectors below. It uses a
           * generic type, T, so that each selector can specify it's return type.
           *
           * @template T
           * @typedef {(state: MetaMaskState) => T} Selector
           */

          /**
           * Selector that returns the current draft transaction's UUID.
           *
           * @type {Selector<string>}
           */


          function getCurrentTransactionUUID(state) {
            return state[name].currentTransactionUUID;
          }
          /**
           * Selector that returns the current draft transaction.
           *
           * @type {Selector<DraftTransaction>}
           */


          function getCurrentDraftTransaction(state) {
            var _state$name$draftTran;

            return (_state$name$draftTran = state[name].draftTransactions[getCurrentTransactionUUID(state)]) !== null && _state$name$draftTran !== void 0 ? _state$name$draftTran : {};
          }
          /**
           * Selector that returns true if a draft transaction exists.
           *
           * @type {Selector<boolean>}
           */


          function getDraftTransactionExists(state) {
            const draftTransaction = getCurrentDraftTransaction(state);

            if (Object.keys(draftTransaction).length === 0) {
              return false;
            }

            return true;
          } // Gas selectors

          /**
           * Selector that returns the current draft transaction's gasLimit.
           *
           * @type {Selector<?string>}
           */


          function getGasLimit(state) {
            var _getCurrentDraftTrans;

            return (_getCurrentDraftTrans = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans === void 0 ? void 0 : _getCurrentDraftTrans.gasLimit;
          }
          /**
           * Selector that returns the current draft transaction's gasPrice.
           *
           * @type {Selector<?string>}
           */


          function getGasPrice(state) {
            var _getCurrentDraftTrans2;

            return (_getCurrentDraftTrans2 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans2 === void 0 ? void 0 : _getCurrentDraftTrans2.gasPrice;
          }
          /**
           * Selector that returns the current draft transaction's gasTotal.
           *
           * @type {Selector<?string>}
           */


          function getGasTotal(state) {
            var _getCurrentDraftTrans3;

            return (_getCurrentDraftTrans3 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans3 === void 0 ? void 0 : _getCurrentDraftTrans3.gasTotal;
          }
          /**
           * Selector that returns the error, if present, for the gas fields.
           *
           * @type {Selector<?string>}
           */


          function gasFeeIsInError(state) {
            var _getCurrentDraftTrans4;

            return Boolean((_getCurrentDraftTrans4 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans4 === void 0 ? void 0 : _getCurrentDraftTrans4.error);
          }
          /**
           * Selector that returns the minimum gasLimit for the current network.
           *
           * @type {Selector<string>}
           */


          function getMinimumGasLimitForSend(state) {
            return state[name].gasLimitMinimum;
          }
          /**
           * Selector that returns the current draft transaction's gasLimit.
           *
           * @type {Selector<MapValuesToUnion<SendStateGasModes>>}
           */


          function getGasInputMode(state) {
            const isMainnet = (0, _selectors.getIsMainnet)(state);
            const gasEstimateType = (0, _metamask.getGasEstimateType)(state);
            const showAdvancedGasFields = (0, _selectors.getAdvancedInlineGasShown)(state);

            if (state[name].gasIsSetInModal) {
              return GAS_INPUT_MODES.CUSTOM;
            }

            if (!isMainnet && !false || showAdvancedGasFields) {
              return GAS_INPUT_MODES.INLINE;
            } // We get eth_gasPrice estimation if the legacy API fails but we need to
            // instruct the UI to render the INLINE inputs in this case, only on
            // mainnet or IN_TEST.


            if ((isMainnet || false) && gasEstimateType === _gas.GAS_ESTIMATE_TYPES.ETH_GASPRICE) {
              return GAS_INPUT_MODES.INLINE;
            }

            return GAS_INPUT_MODES.BASIC;
          } // Asset Selectors

          /**
           * Selector that returns the asset the current draft transaction is sending.
           *
           * @type {Selector<?Asset>}
           */


          function getSendAsset(state) {
            return getCurrentDraftTransaction(state).asset;
          }
          /**
           * Selector that returns the contract address of the non-native asset that
           * the current transaction is sending, if it exists.
           *
           * @type {Selector<?string>}
           */


          function getSendAssetAddress(state) {
            var _getSendAsset, _getSendAsset$details;

            return (_getSendAsset = getSendAsset(state)) === null || _getSendAsset === void 0 ? void 0 : (_getSendAsset$details = _getSendAsset.details) === null || _getSendAsset$details === void 0 ? void 0 : _getSendAsset$details.address;
          }
          /**
           * Selector that returns a boolean value describing whether the currently
           * selected asset is sendable, based upon the standard of the token.
           *
           * @type {Selector<boolean>}
           */


          function getIsAssetSendable(state) {
            var _getSendAsset2, _getSendAsset3, _getSendAsset3$detail;

            if (((_getSendAsset2 = getSendAsset(state)) === null || _getSendAsset2 === void 0 ? void 0 : _getSendAsset2.type) === _transaction.ASSET_TYPES.NATIVE) {
              return true;
            }

            return ((_getSendAsset3 = getSendAsset(state)) === null || _getSendAsset3 === void 0 ? void 0 : (_getSendAsset3$detail = _getSendAsset3.details) === null || _getSendAsset3$detail === void 0 ? void 0 : _getSendAsset3$detail.isERC721) === false;
          }
          /**
           * Selector that returns the asset error if it exists.
           *
           * @type {Selector<?string>}
           */


          function getAssetError(state) {
            return getSendAsset(state).error;
          } // Amount Selectors

          /**
           * Selector that returns the amount that current draft transaction is sending.
           *
           * @type {Selector<?string>}
           */


          function getSendAmount(state) {
            var _getCurrentDraftTrans5;

            return (_getCurrentDraftTrans5 = getCurrentDraftTransaction(state).amount) === null || _getCurrentDraftTrans5 === void 0 ? void 0 : _getCurrentDraftTrans5.value;
          }
          /**
           * Selector that returns true if the user has enough native asset balance to
           * cover the cost of the transaction.
           *
           * @type {Selector<boolean>}
           */


          function getIsBalanceInsufficient(state) {
            var _getCurrentDraftTrans6;

            return ((_getCurrentDraftTrans6 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans6 === void 0 ? void 0 : _getCurrentDraftTrans6.error) === _send.INSUFFICIENT_FUNDS_ERROR;
          }
          /**
           * Selector that returns the amoung send mode, either MAX or INPUT.
           *
           * @type {Selector<boolean>}
           */


          function getSendMaxModeState(state) {
            return state[name].amountMode === AMOUNT_MODES.MAX;
          }
          /**
           * Selector that returns the current draft transaction's data field.
           *
           * @type {Selector<?string>}
           */


          function getSendHexData(state) {
            return getCurrentDraftTransaction(state).userInputHexData;
          }
          /**
           * Selector that returns the current draft transaction's id, if present.
           *
           * @type {Selector<?string>}
           */


          function getDraftTransactionID(state) {
            return getCurrentDraftTransaction(state).id;
          }
          /**
           * Selector that returns true if there is an error on the amount field.
           *
           * @type {Selector<boolean>}
           */


          function sendAmountIsInError(state) {
            var _getCurrentDraftTrans7;

            return Boolean((_getCurrentDraftTrans7 = getCurrentDraftTransaction(state).amount) === null || _getCurrentDraftTrans7 === void 0 ? void 0 : _getCurrentDraftTrans7.error);
          } // Recipient Selectors

          /**
           * Selector that returns the current draft transaction's recipient.
           *
           * @type {Selector<DraftTransaction['recipient']>}
           */


          function getRecipient(state) {
            const draft = getCurrentDraftTransaction(state);

            if (!draft.recipient) {
              return {
                address: '',
                nickname: '',
                error: null,
                warning: null
              };
            }

            const checksummedAddress = (0, _hexstringUtils.toChecksumHexAddress)(draft.recipient.address);

            if (state.metamask.ensResolutionsByAddress) {
              return {
                ...draft.recipient,
                nickname: draft.recipient.nickname || (0, _selectors.getEnsResolutionByAddress)(state, checksummedAddress)
              };
            }

            return draft.recipient;
          }
          /**
           * Selector that returns the addres of the current draft transaction's
           * recipient.
           *
           * @type {Selector<?string>}
           */


          function getSendTo(state) {
            var _getRecipient;

            return (_getRecipient = getRecipient(state)) === null || _getRecipient === void 0 ? void 0 : _getRecipient.address;
          }
          /**
           * Selector that returns true if the current recipientMode is MY_ACCOUNTS
           *
           * @type {Selector<boolean>}
           */


          function getIsUsingMyAccountForRecipientSearch(state) {
            return state[name].recipientMode === RECIPIENT_SEARCH_MODES.MY_ACCOUNTS;
          }
          /**
           * Selector that returns the value that the user has typed into the recipient
           * input field.
           *
           * @type {Selector<?string>}
           */


          function getRecipientUserInput(state) {
            return state[name].recipientInput;
          }

          function getRecipientWarningAcknowledgement(state) {
            var _getCurrentDraftTrans8, _getCurrentDraftTrans9;

            return (_getCurrentDraftTrans8 = (_getCurrentDraftTrans9 = getCurrentDraftTransaction(state).recipient) === null || _getCurrentDraftTrans9 === void 0 ? void 0 : _getCurrentDraftTrans9.recipientWarningAcknowledged) !== null && _getCurrentDraftTrans8 !== void 0 ? _getCurrentDraftTrans8 : false;
          } // Overall validity and stage selectors

          /**
           * Selector that returns the gasFee and amount errors, if they exist.
           *
           * @type {Selector<{ gasFee?: string, amount?: string}>}
           */


          function getSendErrors(state) {
            var _getCurrentDraftTrans10, _getCurrentDraftTrans11;

            return {
              gasFee: (_getCurrentDraftTrans10 = getCurrentDraftTransaction(state).gas) === null || _getCurrentDraftTrans10 === void 0 ? void 0 : _getCurrentDraftTrans10.error,
              amount: (_getCurrentDraftTrans11 = getCurrentDraftTransaction(state).amount) === null || _getCurrentDraftTrans11 === void 0 ? void 0 : _getCurrentDraftTrans11.error
            };
          }
          /**
           * Selector that returns true if the stage is anything except INACTIVE
           *
           * @type {Selector<boolean>}
           */


          function isSendStateInitialized(state) {
            return state[name].stage !== SEND_STAGES.INACTIVE;
          }
          /**
           * Selector that returns true if the current draft transaction is valid and in
           * a sendable state.
           *
           * @type {Selector<boolean>}
           */


          function isSendFormInvalid(state) {
            const draftTransaction = getCurrentDraftTransaction(state);

            if (!draftTransaction) {
              return true;
            }

            return draftTransaction.status === SEND_STATUSES.INVALID;
          }
          /**
           * Selector that returns the current stage of the send flow
           *
           * @type {Selector<MapValuesToUnion<SendStateStages>>}
           */


          function getSendStage(state) {
            return state[name].stage;
          }


        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\common.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.WEI = exports.SUPPORT_REQUEST_LINK = exports.SECONDARY = exports.PRIMARY = exports.GWEI = exports.GAS_ESTIMATE_TYPES = exports.ETH = exports.CONTRACT_ADDRESS_LINK = void 0;
          const ETH = 'ETH';
          exports.ETH = ETH;
          const GWEI = 'GWEI';
          exports.GWEI = GWEI;
          const WEI = 'WEI';
          exports.WEI = WEI;
          const PRIMARY = 'PRIMARY';
          exports.PRIMARY = PRIMARY;
          const SECONDARY = 'SECONDARY';
          exports.SECONDARY = SECONDARY;
          const GAS_ESTIMATE_TYPES = {
            SLOW: 'SLOW',
            AVERAGE: 'AVERAGE',
            FAST: 'FAST',
            FASTEST: 'FASTEST'
          };
          exports.GAS_ESTIMATE_TYPES = GAS_ESTIMATE_TYPES;
          let _supportRequestLink = 'https://metamask.zendesk.com/hc/en-us';
          const _contractAddressLink = 'https://metamask.zendesk.com/hc/en-us/articles/360020028092-What-is-the-known-contract-address-warning-';
          const SUPPORT_REQUEST_LINK = _supportRequestLink;
          exports.SUPPORT_REQUEST_LINK = SUPPORT_REQUEST_LINK;
          const CONTRACT_ADDRESS_LINK = _contractAddressLink;
          exports.CONTRACT_ADDRESS_LINK = CONTRACT_ADDRESS_LINK;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\design-system.js", { "lodash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\design-system.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TYPOGRAPHY = exports.TEXT_TRANSFORM = exports.TEXT_COLORS = exports.TEXT_ALIGN = exports.TEXT = exports.SIZES = exports.SEVERITIES = exports.RESIZE = exports.OVERFLOW_WRAP = exports.JUSTIFY_CONTENT = exports.ICON_COLORS = exports.FRACTIONS = exports.FONT_WEIGHT = exports.FONT_STYLE = exports.FLEX_WRAP = exports.FLEX_DIRECTION = exports.DISPLAY = exports.COLORS = exports.BREAKPOINTS = exports.BORDER_STYLE = exports.BORDER_RADIUS = exports.BORDER_COLORS = exports.BLOCK_SIZES = exports.BACKGROUND_COLORS = exports.ALIGN_ITEMS = void 0;

          var _lodash = require("lodash");

          /**
           * A note about the existence of both singular and plural variable names here:
           * When dealing with a literal property name, e.g. ALIGN_ITEMS, the constant
           * should match the property. When detailing a collection of things, it should
           * match the plural form of the thing. e.g. COLORS, TYPOGRAPHY
           */
          const COLORS = {
            BACKGROUND_DEFAULT: 'background-default',
            BACKGROUND_ALTERNATIVE: 'background-alternative',
            TEXT_DEFAULT: 'text-default',
            TEXT_ALTERNATIVE: 'text-alternative',
            TEXT_MUTED: 'text-muted',
            ICON_DEFAULT: 'icon-default',
            ICON_ALTERNATIVE: 'icon-alternative',
            ICON_MUTED: 'icon-muted',
            BORDER_DEFAULT: 'border-default',
            BORDER_MUTED: 'border-muted',
            OVERLAY_DEFAULT: 'overlay-default',
            OVERLAY_INVERSE: 'overlay-inverse',
            PRIMARY_DEFAULT: 'primary-default',
            PRIMARY_ALTERNATIVE: 'primary-alternative',
            PRIMARY_MUTED: 'primary-muted',
            PRIMARY_INVERSE: 'primary-inverse',
            PRIMARY_DISABLED: 'primary-disabled',
            ERROR_DEFAULT: 'error-default',
            ERROR_ALTERNATIVE: 'error-alternative',
            ERROR_MUTED: 'error-muted',
            ERROR_INVERSE: 'error-inverse',
            ERROR_DISABLED: 'error-disabled',
            WARNING_DEFAULT: 'warning-default',
            WARNING_ALTERNATIVE: 'warning-alternative',
            WARNING_MUTED: 'warning-muted',
            WARNING_INVERSE: 'warning-inverse',
            WARNING_DISABLED: 'warning-disabled',
            SUCCESS_DEFAULT: 'success-default',
            SUCCESS_ALTERNATIVE: 'success-alternative',
            SUCCESS_MUTED: 'success-muted',
            SUCCESS_INVERSE: 'success-inverse',
            SUCCESS_DISABLED: 'success-disabled',
            INFO_DEFAULT: 'info-default',
            INFO_ALTERNATIVE: 'info-alternative',
            INFO_MUTED: 'info-muted',
            INFO_INVERSE: 'info-inverse',
            INFO_DISABLED: 'info-disabled',
            MAINNET: 'mainnet',
            GOERLI: 'goerli',
            SEPOLIA: 'sepolia',
            LOCALHOST: 'localhost',
            TRANSPARENT: 'transparent',
            INHERIT: 'inherit'
          };
          exports.COLORS = COLORS;
          const BACKGROUND_COLORS = (0, _lodash.pick)(COLORS, ['BACKGROUND_DEFAULT', 'BACKGROUND_ALTERNATIVE', 'OVERLAY_DEFAULT', 'PRIMARY_DEFAULT', 'PRIMARY_ALTERNATIVE', 'PRIMARY_MUTED', 'ERROR_DEFAULT', 'ERROR_ALTERNATIVE', 'ERROR_MUTED', 'WARNING_DEFAULT', 'WARNING_ALTERNATIVE', 'WARNING_MUTED', 'SUCCESS_DEFAULT', 'SUCCESS_ALTERNATIVE', 'SUCCESS_MUTED', 'INFO_DEFAULT', 'INFO_ALTERNATIVE', 'INFO_MUTED', 'MAINNET', 'GOERLI', 'SEPOLIA', 'TRANSPARENT', 'LOCALHOST']);
          exports.BACKGROUND_COLORS = BACKGROUND_COLORS;
          const BORDER_COLORS = (0, _lodash.pick)(COLORS, ['BORDER_DEFAULT', 'BORDER_MUTED', 'PRIMARY_DEFAULT', 'PRIMARY_ALTERNATIVE', 'PRIMARY_MUTED', 'ERROR_DEFAULT', 'ERROR_ALTERNATIVE', 'ERROR_MUTED', 'WARNING_DEFAULT', 'WARNING_ALTERNATIVE', 'WARNING_MUTED', 'SUCCESS_DEFAULT', 'SUCCESS_ALTERNATIVE', 'SUCCESS_MUTED', 'INFO_DEFAULT', 'INFO_ALTERNATIVE', 'INFO_MUTED', 'MAINNET', 'GOERLI', 'SEPOLIA', 'TRANSPARENT', 'LOCALHOST']);
          exports.BORDER_COLORS = BORDER_COLORS;
          const TEXT_COLORS = (0, _lodash.pick)(COLORS, ['TEXT_DEFAULT', 'TEXT_ALTERNATIVE', 'TEXT_MUTED', 'OVERLAY_INVERSE', 'PRIMARY_DEFAULT', 'PRIMARY_INVERSE', 'ERROR_DEFAULT', 'ERROR_INVERSE', 'SUCCESS_DEFAULT', 'SUCCESS_INVERSE', 'WARNING_DEFAULT', 'WARNING_INVERSE', 'INFO_DEFAULT', 'INFO_INVERSE', 'INHERIT']);
          exports.TEXT_COLORS = TEXT_COLORS;
          const ICON_COLORS = (0, _lodash.pick)(COLORS, ['ICON_DEFAULT', 'ICON_ALTERNATIVE', 'ICON_MUTED', 'OVERLAY_INVERSE', 'PRIMARY_DEFAULT', 'PRIMARY_INVERSE', 'ERROR_DEFAULT', 'ERROR_INVERSE', 'SUCCESS_DEFAULT', 'SUCCESS_INVERSE', 'WARNING_DEFAULT', 'WARNING_INVERSE', 'INFO_DEFAULT', 'INFO_INVERSE', 'INHERIT']);
          exports.ICON_COLORS = ICON_COLORS;
          const TYPOGRAPHY = {
            H1: 'h1',
            H2: 'h2',
            H3: 'h3',
            H4: 'h4',
            H5: 'h5',
            H6: 'h6',
            H7: 'h7',
            H8: 'h8',
            H9: 'h9',
            Paragraph: 'p'
          };
          exports.TYPOGRAPHY = TYPOGRAPHY;
          const TEXT = {
            DISPLAY_MD: 'display-md',
            HEADING_LG: 'heading-lg',
            HEADING_MD: 'heading-md',
            HEADING_SM: 'heading-sm',
            BODY_LG: 'body-lg-medium',
            BODY_MD: 'body-md',
            BODY_SM: 'body-sm',
            BODY_XS: 'body-xs',
            INHERIT: 'inherit'
          };
          exports.TEXT = TEXT;
          const NONE = 'none';
          const SIZES = {
            XXS: 'xxs',
            XS: 'xs',
            SM: 'sm',
            MD: 'md',
            LG: 'lg',
            XL: 'xl',
            AUTO: 'auto',
            // Used for Text, Icon, and Button components to inherit the parent elements font-size
            NONE
          };
          exports.SIZES = SIZES;
          const BORDER_STYLE = {
            DASHED: 'dashed',
            SOLID: 'solid',
            DOTTED: 'dotted',
            DOUBLE: 'double',
            NONE
          };
          exports.BORDER_STYLE = BORDER_STYLE;
          const BORDER_RADIUS = {
            XS: SIZES.XS,
            SM: SIZES.SM,
            MD: SIZES.MD,
            LG: SIZES.LG,
            XL: SIZES.XL,
            NONE,
            PILL: 'pill'
          };
          exports.BORDER_RADIUS = BORDER_RADIUS;
          const FLEX_END = 'flex-end';
          const FLEX_START = 'flex-start';
          const CENTER = 'center';
          const ALIGN_ITEMS = {
            FLEX_START,
            FLEX_END,
            CENTER,
            BASELINE: 'baseline',
            STRETCH: 'stretch'
          };
          exports.ALIGN_ITEMS = ALIGN_ITEMS;
          const JUSTIFY_CONTENT = {
            FLEX_START,
            FLEX_END,
            CENTER,
            SPACE_AROUND: 'space-around',
            SPACE_BETWEEN: 'space-between',
            SPACE_EVENLY: 'space-evenly'
          };
          exports.JUSTIFY_CONTENT = JUSTIFY_CONTENT;
          const FLEX_DIRECTION = {
            ROW: 'row',
            ROW_REVERSE: 'row-reverse',
            COLUMN: 'column',
            COLUMN_REVERSE: 'column-reverse'
          };
          exports.FLEX_DIRECTION = FLEX_DIRECTION;
          const FLEX_WRAP = {
            WRAP: 'wrap',
            WRAP_REVERSE: 'wrap-reverse',
            NO_WRAP: 'nowrap'
          };
          exports.FLEX_WRAP = FLEX_WRAP;
          const DISPLAY = {
            BLOCK: 'block',
            FLEX: 'flex',
            GRID: 'grid',
            INLINE_BLOCK: 'inline-block',
            INLINE: 'inline',
            INLINE_FLEX: 'inline-flex',
            INLINE_GRID: 'inline-grid',
            LIST_ITEM: 'list-item',
            NONE: 'none'
          };
          exports.DISPLAY = DISPLAY;
          const FRACTIONS = {
            HALF: '1/2',
            ONE_THIRD: '1/3',
            TWO_THIRDS: '2/3',
            ONE_FOURTH: '1/4',
            TWO_FOURTHS: '2/4',
            THREE_FOURTHS: '3/4',
            ONE_FIFTH: '1/5',
            TWO_FIFTHS: '2/5',
            THREE_FIFTHS: '3/5',
            FOUR_FIFTHS: '4/5',
            ONE_SIXTH: '1/6',
            TWO_SIXTHS: '2/6',
            THREE_SIXTHS: '3/6',
            FOUR_SIXTHS: '4/6',
            FIVE_SIXTHS: '5/6',
            ONE_TWELFTH: '1/12',
            TWO_TWELFTHS: '2/12',
            THREE_TWELFTHS: '3/12',
            FOUR_TWELFTHS: '4/12',
            FIVE_TWELFTHS: '5/12',
            SIX_TWELFTHS: '6/12',
            SEVEN_TWELFTHS: '7/12',
            EIGHT_TWELFTHS: '8/12',
            NINE_TWELFTHS: '9/12',
            TEN_TWELFTHS: '10/12',
            ELEVEN_TWELFTHS: '11/12'
          };
          exports.FRACTIONS = FRACTIONS;
          const BLOCK_SIZES = {
            ...FRACTIONS,
            SCREEN: 'screen',
            MAX: 'max',
            MIN: 'min',
            FULL: 'full'
          };
          exports.BLOCK_SIZES = BLOCK_SIZES;
          const TEXT_ALIGN = {
            LEFT: 'left',
            CENTER: 'center',
            RIGHT: 'right',
            JUSTIFY: 'justify',
            END: 'end'
          };
          exports.TEXT_ALIGN = TEXT_ALIGN;
          const TEXT_TRANSFORM = {
            UPPERCASE: 'uppercase',
            LOWERCASE: 'lowercase',
            CAPITALIZE: 'capitalize'
          };
          exports.TEXT_TRANSFORM = TEXT_TRANSFORM;
          const FONT_WEIGHT = {
            BOLD: 'bold',
            MEDIUM: 'medium',
            NORMAL: 'normal'
          };
          exports.FONT_WEIGHT = FONT_WEIGHT;
          const OVERFLOW_WRAP = {
            BREAK_WORD: 'break-word',
            NORMAL: 'normal'
          };
          exports.OVERFLOW_WRAP = OVERFLOW_WRAP;
          const FONT_STYLE = {
            ITALIC: 'italic',
            NORMAL: 'normal'
          };
          exports.FONT_STYLE = FONT_STYLE;
          const SEVERITIES = {
            DANGER: 'danger',
            WARNING: 'warning',
            INFO: 'info',
            SUCCESS: 'success'
          };
          exports.SEVERITIES = SEVERITIES;
          const RESIZE = {
            NONE: 'none',
            BOTH: 'both',
            HORIZONTAL: 'horizontal',
            VERTICAL: 'vertical',
            INITIAL: 'initial',
            INHERIT: 'inherit'
          };
          exports.RESIZE = RESIZE;
          const BREAKPOINTS = ['base', 'sm', 'md', 'lg'];
          exports.BREAKPOINTS = BREAKPOINTS;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\error-keys.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\error-keys.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.UNSENDABLE_ASSET_ERROR_KEY = exports.TRANSACTION_ERROR_KEY = exports.INVALID_ASSET_TYPE = exports.INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = exports.INSUFFICIENT_FUNDS_ERROR_KEY = exports.GAS_PRICE_FETCH_FAILURE_ERROR_KEY = exports.GAS_PRICE_EXCESSIVE_ERROR_KEY = exports.GAS_LIMIT_TOO_LOW_ERROR_KEY = exports.ETH_GAS_PRICE_FETCH_WARNING_KEY = void 0;
          const INSUFFICIENT_FUNDS_ERROR_KEY = 'insufficientFunds';
          exports.INSUFFICIENT_FUNDS_ERROR_KEY = INSUFFICIENT_FUNDS_ERROR_KEY;
          const GAS_LIMIT_TOO_LOW_ERROR_KEY = 'gasLimitTooLow';
          exports.GAS_LIMIT_TOO_LOW_ERROR_KEY = GAS_LIMIT_TOO_LOW_ERROR_KEY;
          const TRANSACTION_ERROR_KEY = 'transactionError';
          exports.TRANSACTION_ERROR_KEY = TRANSACTION_ERROR_KEY;
          const ETH_GAS_PRICE_FETCH_WARNING_KEY = 'ethGasPriceFetchWarning';
          exports.ETH_GAS_PRICE_FETCH_WARNING_KEY = ETH_GAS_PRICE_FETCH_WARNING_KEY;
          const GAS_PRICE_FETCH_FAILURE_ERROR_KEY = 'gasPriceFetchFailed';
          exports.GAS_PRICE_FETCH_FAILURE_ERROR_KEY = GAS_PRICE_FETCH_FAILURE_ERROR_KEY;
          const GAS_PRICE_EXCESSIVE_ERROR_KEY = 'gasPriceExcessive';
          exports.GAS_PRICE_EXCESSIVE_ERROR_KEY = GAS_PRICE_EXCESSIVE_ERROR_KEY;
          const UNSENDABLE_ASSET_ERROR_KEY = 'unsendableAsset';
          exports.UNSENDABLE_ASSET_ERROR_KEY = UNSENDABLE_ASSET_ERROR_KEY;
          const INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = 'insufficientFundsForGas';
          exports.INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY = INSUFFICIENT_FUNDS_FOR_GAS_ERROR_KEY;
          const INVALID_ASSET_TYPE = 'invalidAssetType';
          exports.INVALID_ASSET_TYPE = INVALID_ASSET_TYPE;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\routes.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\routes.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.VIEW_QUOTE_ROUTE = exports.UNLOCK_ROUTE = exports.TOKEN_DETAILS = exports.SWAPS_ROUTE = exports.SWAPS_MAINTENANCE_ROUTE = exports.SWAPS_ERROR_ROUTE = exports.SNAPS_VIEW_ROUTE = exports.SNAPS_LIST_ROUTE = exports.SMART_TRANSACTION_STATUS_ROUTE = exports.SIGNATURE_REQUEST_PATH = exports.SETTINGS_ROUTE = exports.SEND_ROUTE = exports.SECURITY_ROUTE = exports.REVEAL_SEED_ROUTE = exports.RESTORE_VAULT_ROUTE = exports.PATH_NAME_MAP = exports.ONBOARDING_WELCOME_ROUTE = exports.ONBOARDING_UNLOCK_ROUTE = exports.ONBOARDING_SECURE_YOUR_WALLET_ROUTE = exports.ONBOARDING_ROUTE = exports.ONBOARDING_REVIEW_SRP_ROUTE = exports.ONBOARDING_PRIVACY_SETTINGS_ROUTE = exports.ONBOARDING_PIN_EXTENSION_ROUTE = exports.ONBOARDING_METAMETRICS = exports.ONBOARDING_IMPORT_WITH_SRP_ROUTE = exports.ONBOARDING_IMPORT_MOBILE_ROUTE = exports.ONBOARDING_HELP_US_IMPROVE_ROUTE = exports.ONBOARDING_CREATE_PASSWORD_ROUTE = exports.ONBOARDING_CONFIRM_SRP_ROUTE = exports.ONBOARDING_COMPLETION_ROUTE = exports.NEW_ACCOUNT_ROUTE = exports.NETWORKS_ROUTE = exports.NETWORKS_FORM_ROUTE = exports.MOBILE_SYNC_ROUTE = exports.LOCK_ROUTE = exports.LOADING_QUOTES_ROUTE = exports.INITIALIZE_WELCOME_ROUTE = exports.INITIALIZE_UNLOCK_ROUTE = exports.INITIALIZE_SELECT_ACTION_ROUTE = exports.INITIALIZE_SEED_PHRASE_ROUTE = exports.INITIALIZE_SEED_PHRASE_INTRO_ROUTE = exports.INITIALIZE_ROUTE = exports.INITIALIZE_METAMETRICS_OPT_IN_ROUTE = exports.INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE = exports.INITIALIZE_END_OF_FLOW_ROUTE = exports.INITIALIZE_CREATE_PASSWORD_ROUTE = exports.INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE = exports.INITIALIZE_BACKUP_SEED_PHRASE_ROUTE = exports.IMPORT_TOKEN_ROUTE = exports.IMPORT_ACCOUNT_ROUTE = exports.GENERAL_ROUTE = exports.EXPERIMENTAL_ROUTE = exports.ENCRYPTION_PUBLIC_KEY_REQUEST_PATH = exports.DEFAULT_ROUTE = exports.DECRYPT_MESSAGE_REQUEST_PATH = exports.CONTACT_VIEW_ROUTE = exports.CONTACT_LIST_ROUTE = exports.CONTACT_EDIT_ROUTE = exports.CONTACT_ADD_ROUTE = exports.CONNECT_ROUTE = exports.CONNECT_HARDWARE_ROUTE = exports.CONNECT_CONFIRM_PERMISSIONS_ROUTE = exports.CONNECTED_ROUTE = exports.CONNECTED_ACCOUNTS_ROUTE = exports.CONFIRM_TRANSFER_FROM_PATH = exports.CONFIRM_TRANSACTION_ROUTE = exports.CONFIRM_TOKEN_METHOD_PATH = exports.CONFIRM_SET_APPROVAL_FOR_ALL_PATH = exports.CONFIRM_SEND_TOKEN_PATH = exports.CONFIRM_SEND_ETHER_PATH = exports.CONFIRM_SAFE_TRANSFER_FROM_PATH = exports.CONFIRM_IMPORT_TOKEN_ROUTE = exports.CONFIRM_DEPLOY_CONTRACT_PATH = exports.CONFIRM_APPROVE_PATH = exports.CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE = exports.CONFIRMATION_V_NEXT_ROUTE = exports.BUILD_QUOTE_ROUTE = exports.AWAITING_SWAP_ROUTE = exports.AWAITING_SIGNATURES_ROUTE = exports.ASSET_ROUTE = exports.ALERTS_ROUTE = exports.ADVANCED_ROUTE = exports.ADD_POPULAR_CUSTOM_NETWORK = exports.ADD_NETWORK_ROUTE = exports.ADD_COLLECTIBLE_ROUTE = exports.ABOUT_US_ROUTE = void 0;
          const DEFAULT_ROUTE = '/';
          exports.DEFAULT_ROUTE = DEFAULT_ROUTE;
          const UNLOCK_ROUTE = '/unlock';
          exports.UNLOCK_ROUTE = UNLOCK_ROUTE;
          const LOCK_ROUTE = '/lock';
          exports.LOCK_ROUTE = LOCK_ROUTE;
          const ASSET_ROUTE = '/asset';
          exports.ASSET_ROUTE = ASSET_ROUTE;
          const SETTINGS_ROUTE = '/settings';
          exports.SETTINGS_ROUTE = SETTINGS_ROUTE;
          const GENERAL_ROUTE = '/settings/general';
          exports.GENERAL_ROUTE = GENERAL_ROUTE;
          const ADVANCED_ROUTE = '/settings/advanced';
          exports.ADVANCED_ROUTE = ADVANCED_ROUTE;
          const EXPERIMENTAL_ROUTE = '/settings/experimental';
          exports.EXPERIMENTAL_ROUTE = EXPERIMENTAL_ROUTE;
          const SECURITY_ROUTE = '/settings/security';
          exports.SECURITY_ROUTE = SECURITY_ROUTE;
          const ABOUT_US_ROUTE = '/settings/about-us';
          exports.ABOUT_US_ROUTE = ABOUT_US_ROUTE;
          const ALERTS_ROUTE = '/settings/alerts';
          exports.ALERTS_ROUTE = ALERTS_ROUTE;
          const NETWORKS_ROUTE = '/settings/networks';
          exports.NETWORKS_ROUTE = NETWORKS_ROUTE;
          const NETWORKS_FORM_ROUTE = '/settings/networks/form';
          exports.NETWORKS_FORM_ROUTE = NETWORKS_FORM_ROUTE;
          const ADD_NETWORK_ROUTE = '/settings/networks/add-network';
          exports.ADD_NETWORK_ROUTE = ADD_NETWORK_ROUTE;
          const ADD_POPULAR_CUSTOM_NETWORK = '/settings/networks/add-popular-custom-network';
          exports.ADD_POPULAR_CUSTOM_NETWORK = ADD_POPULAR_CUSTOM_NETWORK;
          const SNAPS_LIST_ROUTE = '/settings/snaps-list';
          exports.SNAPS_LIST_ROUTE = SNAPS_LIST_ROUTE;
          const SNAPS_VIEW_ROUTE = '/settings/snaps-view';
          exports.SNAPS_VIEW_ROUTE = SNAPS_VIEW_ROUTE;
          const CONTACT_LIST_ROUTE = '/settings/contact-list';
          exports.CONTACT_LIST_ROUTE = CONTACT_LIST_ROUTE;
          const CONTACT_EDIT_ROUTE = '/settings/contact-list/edit-contact';
          exports.CONTACT_EDIT_ROUTE = CONTACT_EDIT_ROUTE;
          const CONTACT_ADD_ROUTE = '/settings/contact-list/add-contact';
          exports.CONTACT_ADD_ROUTE = CONTACT_ADD_ROUTE;
          const CONTACT_VIEW_ROUTE = '/settings/contact-list/view-contact';
          exports.CONTACT_VIEW_ROUTE = CONTACT_VIEW_ROUTE;
          const REVEAL_SEED_ROUTE = '/seed';
          exports.REVEAL_SEED_ROUTE = REVEAL_SEED_ROUTE;
          const MOBILE_SYNC_ROUTE = '/mobile-sync';
          exports.MOBILE_SYNC_ROUTE = MOBILE_SYNC_ROUTE;
          const RESTORE_VAULT_ROUTE = '/restore-vault';
          exports.RESTORE_VAULT_ROUTE = RESTORE_VAULT_ROUTE;
          const IMPORT_TOKEN_ROUTE = '/import-token';
          exports.IMPORT_TOKEN_ROUTE = IMPORT_TOKEN_ROUTE;
          const CONFIRM_IMPORT_TOKEN_ROUTE = '/confirm-import-token';
          exports.CONFIRM_IMPORT_TOKEN_ROUTE = CONFIRM_IMPORT_TOKEN_ROUTE;
          const CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE = '/confirm-add-suggested-token';
          exports.CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE = CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE;
          const NEW_ACCOUNT_ROUTE = '/new-account';
          exports.NEW_ACCOUNT_ROUTE = NEW_ACCOUNT_ROUTE;
          const IMPORT_ACCOUNT_ROUTE = '/new-account/import';
          exports.IMPORT_ACCOUNT_ROUTE = IMPORT_ACCOUNT_ROUTE;
          const CONNECT_HARDWARE_ROUTE = '/new-account/connect';
          exports.CONNECT_HARDWARE_ROUTE = CONNECT_HARDWARE_ROUTE;
          const SEND_ROUTE = '/send';
          exports.SEND_ROUTE = SEND_ROUTE;
          const TOKEN_DETAILS = '/token-details';
          exports.TOKEN_DETAILS = TOKEN_DETAILS;
          const CONNECT_ROUTE = '/connect';
          exports.CONNECT_ROUTE = CONNECT_ROUTE;
          const CONNECT_CONFIRM_PERMISSIONS_ROUTE = '/confirm-permissions';
          exports.CONNECT_CONFIRM_PERMISSIONS_ROUTE = CONNECT_CONFIRM_PERMISSIONS_ROUTE;
          const CONNECTED_ROUTE = '/connected';
          exports.CONNECTED_ROUTE = CONNECTED_ROUTE;
          const CONNECTED_ACCOUNTS_ROUTE = '/connected/accounts';
          exports.CONNECTED_ACCOUNTS_ROUTE = CONNECTED_ACCOUNTS_ROUTE;
          const SWAPS_ROUTE = '/swaps';
          exports.SWAPS_ROUTE = SWAPS_ROUTE;
          const BUILD_QUOTE_ROUTE = '/swaps/build-quote';
          exports.BUILD_QUOTE_ROUTE = BUILD_QUOTE_ROUTE;
          const VIEW_QUOTE_ROUTE = '/swaps/view-quote';
          exports.VIEW_QUOTE_ROUTE = VIEW_QUOTE_ROUTE;
          const LOADING_QUOTES_ROUTE = '/swaps/loading-quotes';
          exports.LOADING_QUOTES_ROUTE = LOADING_QUOTES_ROUTE;
          const AWAITING_SIGNATURES_ROUTE = '/swaps/awaiting-signatures';
          exports.AWAITING_SIGNATURES_ROUTE = AWAITING_SIGNATURES_ROUTE;
          const SMART_TRANSACTION_STATUS_ROUTE = '/swaps/smart-transaction-status';
          exports.SMART_TRANSACTION_STATUS_ROUTE = SMART_TRANSACTION_STATUS_ROUTE;
          const AWAITING_SWAP_ROUTE = '/swaps/awaiting-swap';
          exports.AWAITING_SWAP_ROUTE = AWAITING_SWAP_ROUTE;
          const SWAPS_ERROR_ROUTE = '/swaps/swaps-error';
          exports.SWAPS_ERROR_ROUTE = SWAPS_ERROR_ROUTE;
          const SWAPS_MAINTENANCE_ROUTE = '/swaps/maintenance';
          exports.SWAPS_MAINTENANCE_ROUTE = SWAPS_MAINTENANCE_ROUTE;
          const ADD_COLLECTIBLE_ROUTE = '/add-collectible';
          exports.ADD_COLLECTIBLE_ROUTE = ADD_COLLECTIBLE_ROUTE;
          const INITIALIZE_ROUTE = '/initialize';
          exports.INITIALIZE_ROUTE = INITIALIZE_ROUTE;
          const INITIALIZE_WELCOME_ROUTE = '/initialize/welcome';
          exports.INITIALIZE_WELCOME_ROUTE = INITIALIZE_WELCOME_ROUTE;
          const INITIALIZE_UNLOCK_ROUTE = '/initialize/unlock';
          exports.INITIALIZE_UNLOCK_ROUTE = INITIALIZE_UNLOCK_ROUTE;
          const INITIALIZE_CREATE_PASSWORD_ROUTE = '/initialize/create-password';
          exports.INITIALIZE_CREATE_PASSWORD_ROUTE = INITIALIZE_CREATE_PASSWORD_ROUTE;
          const INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE = '/initialize/create-password/import-with-seed-phrase';
          exports.INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE = INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE;
          const INITIALIZE_SELECT_ACTION_ROUTE = '/initialize/select-action';
          exports.INITIALIZE_SELECT_ACTION_ROUTE = INITIALIZE_SELECT_ACTION_ROUTE;
          const INITIALIZE_SEED_PHRASE_ROUTE = '/initialize/seed-phrase';
          exports.INITIALIZE_SEED_PHRASE_ROUTE = INITIALIZE_SEED_PHRASE_ROUTE;
          const INITIALIZE_BACKUP_SEED_PHRASE_ROUTE = '/initialize/backup-seed-phrase';
          exports.INITIALIZE_BACKUP_SEED_PHRASE_ROUTE = INITIALIZE_BACKUP_SEED_PHRASE_ROUTE;
          const INITIALIZE_SEED_PHRASE_INTRO_ROUTE = '/initialize/seed-phrase-intro';
          exports.INITIALIZE_SEED_PHRASE_INTRO_ROUTE = INITIALIZE_SEED_PHRASE_INTRO_ROUTE;
          const INITIALIZE_END_OF_FLOW_ROUTE = '/initialize/end-of-flow';
          exports.INITIALIZE_END_OF_FLOW_ROUTE = INITIALIZE_END_OF_FLOW_ROUTE;
          const INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE = '/initialize/seed-phrase/confirm';
          exports.INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE = INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE;
          const INITIALIZE_METAMETRICS_OPT_IN_ROUTE = '/initialize/metametrics-opt-in';
          exports.INITIALIZE_METAMETRICS_OPT_IN_ROUTE = INITIALIZE_METAMETRICS_OPT_IN_ROUTE;
          const ONBOARDING_ROUTE = '/onboarding';
          exports.ONBOARDING_ROUTE = ONBOARDING_ROUTE;
          const ONBOARDING_REVIEW_SRP_ROUTE = '/onboarding/review-recovery-phrase';
          exports.ONBOARDING_REVIEW_SRP_ROUTE = ONBOARDING_REVIEW_SRP_ROUTE;
          const ONBOARDING_CONFIRM_SRP_ROUTE = '/onboarding/confirm-recovery-phrase';
          exports.ONBOARDING_CONFIRM_SRP_ROUTE = ONBOARDING_CONFIRM_SRP_ROUTE;
          const ONBOARDING_CREATE_PASSWORD_ROUTE = '/onboarding/create-password';
          exports.ONBOARDING_CREATE_PASSWORD_ROUTE = ONBOARDING_CREATE_PASSWORD_ROUTE;
          const ONBOARDING_COMPLETION_ROUTE = '/onboarding/completion';
          exports.ONBOARDING_COMPLETION_ROUTE = ONBOARDING_COMPLETION_ROUTE;
          const ONBOARDING_UNLOCK_ROUTE = '/onboarding/unlock';
          exports.ONBOARDING_UNLOCK_ROUTE = ONBOARDING_UNLOCK_ROUTE;
          const ONBOARDING_HELP_US_IMPROVE_ROUTE = '/onboarding/help-us-improve';
          exports.ONBOARDING_HELP_US_IMPROVE_ROUTE = ONBOARDING_HELP_US_IMPROVE_ROUTE;
          const ONBOARDING_IMPORT_WITH_SRP_ROUTE = '/onboarding/import-with-recovery-phrase';
          exports.ONBOARDING_IMPORT_WITH_SRP_ROUTE = ONBOARDING_IMPORT_WITH_SRP_ROUTE;
          const ONBOARDING_IMPORT_MOBILE_ROUTE = '/onboarding/import-mobile';
          exports.ONBOARDING_IMPORT_MOBILE_ROUTE = ONBOARDING_IMPORT_MOBILE_ROUTE;
          const ONBOARDING_SECURE_YOUR_WALLET_ROUTE = '/onboarding/secure-your-wallet';
          exports.ONBOARDING_SECURE_YOUR_WALLET_ROUTE = ONBOARDING_SECURE_YOUR_WALLET_ROUTE;
          const ONBOARDING_PRIVACY_SETTINGS_ROUTE = '/onboarding/privacy-settings';
          exports.ONBOARDING_PRIVACY_SETTINGS_ROUTE = ONBOARDING_PRIVACY_SETTINGS_ROUTE;
          const ONBOARDING_PIN_EXTENSION_ROUTE = '/onboarding/pin-extension';
          exports.ONBOARDING_PIN_EXTENSION_ROUTE = ONBOARDING_PIN_EXTENSION_ROUTE;
          const ONBOARDING_WELCOME_ROUTE = '/onboarding/welcome';
          exports.ONBOARDING_WELCOME_ROUTE = ONBOARDING_WELCOME_ROUTE;
          const ONBOARDING_METAMETRICS = '/onboarding/metametrics';
          exports.ONBOARDING_METAMETRICS = ONBOARDING_METAMETRICS;
          const CONFIRM_TRANSACTION_ROUTE = '/confirm-transaction';
          exports.CONFIRM_TRANSACTION_ROUTE = CONFIRM_TRANSACTION_ROUTE;
          const CONFIRM_SEND_ETHER_PATH = '/send-ether';
          exports.CONFIRM_SEND_ETHER_PATH = CONFIRM_SEND_ETHER_PATH;
          const CONFIRM_SEND_TOKEN_PATH = '/send-token';
          exports.CONFIRM_SEND_TOKEN_PATH = CONFIRM_SEND_TOKEN_PATH;
          const CONFIRM_DEPLOY_CONTRACT_PATH = '/deploy-contract';
          exports.CONFIRM_DEPLOY_CONTRACT_PATH = CONFIRM_DEPLOY_CONTRACT_PATH;
          const CONFIRM_APPROVE_PATH = '/approve';
          exports.CONFIRM_APPROVE_PATH = CONFIRM_APPROVE_PATH;
          const CONFIRM_SET_APPROVAL_FOR_ALL_PATH = '/set-approval-for-all';
          exports.CONFIRM_SET_APPROVAL_FOR_ALL_PATH = CONFIRM_SET_APPROVAL_FOR_ALL_PATH;
          const CONFIRM_TRANSFER_FROM_PATH = '/transfer-from';
          exports.CONFIRM_TRANSFER_FROM_PATH = CONFIRM_TRANSFER_FROM_PATH;
          const CONFIRM_SAFE_TRANSFER_FROM_PATH = '/safe-transfer-from';
          exports.CONFIRM_SAFE_TRANSFER_FROM_PATH = CONFIRM_SAFE_TRANSFER_FROM_PATH;
          const CONFIRM_TOKEN_METHOD_PATH = '/token-method';
          exports.CONFIRM_TOKEN_METHOD_PATH = CONFIRM_TOKEN_METHOD_PATH;
          const SIGNATURE_REQUEST_PATH = '/signature-request';
          exports.SIGNATURE_REQUEST_PATH = SIGNATURE_REQUEST_PATH;
          const DECRYPT_MESSAGE_REQUEST_PATH = '/decrypt-message-request';
          exports.DECRYPT_MESSAGE_REQUEST_PATH = DECRYPT_MESSAGE_REQUEST_PATH;
          const ENCRYPTION_PUBLIC_KEY_REQUEST_PATH = '/encryption-public-key-request';
          exports.ENCRYPTION_PUBLIC_KEY_REQUEST_PATH = ENCRYPTION_PUBLIC_KEY_REQUEST_PATH;
          const CONFIRMATION_V_NEXT_ROUTE = '/confirmation'; // Used to pull a convenient name for analytics tracking events. The key must
          // be react-router ready path, and can include params such as :id for popup windows

          exports.CONFIRMATION_V_NEXT_ROUTE = CONFIRMATION_V_NEXT_ROUTE;
          const PATH_NAME_MAP = {
            [DEFAULT_ROUTE]: 'Home',
            [UNLOCK_ROUTE]: 'Unlock Page',
            [LOCK_ROUTE]: 'Lock Page',
            [`${ASSET_ROUTE}/:asset/:id`]: `Asset Page`,
            [SETTINGS_ROUTE]: 'Settings Page',
            [GENERAL_ROUTE]: 'General Settings Page',
            [ADVANCED_ROUTE]: 'Advanced Settings Page',
            [EXPERIMENTAL_ROUTE]: 'Experimental Settings Page',
            [SECURITY_ROUTE]: 'Security Settings Page',
            [ABOUT_US_ROUTE]: 'About Us Page',
            [ALERTS_ROUTE]: 'Alerts Settings Page',
            [NETWORKS_ROUTE]: 'Network Settings Page',
            [NETWORKS_FORM_ROUTE]: 'Network Settings Page Form',
            [ADD_NETWORK_ROUTE]: 'Add Network From Settings Page Form',
            [ADD_POPULAR_CUSTOM_NETWORK]: 'Add Network From A List Of Popular Custom Networks',
            [CONTACT_LIST_ROUTE]: 'Contact List Settings Page',
            [`${CONTACT_EDIT_ROUTE}/:address`]: 'Edit Contact Settings Page',
            [CONTACT_ADD_ROUTE]: 'Add Contact Settings Page',
            [`${CONTACT_VIEW_ROUTE}/:address`]: 'View Contact Settings Page',
            [REVEAL_SEED_ROUTE]: 'Reveal Secret Recovery Phrase Page',
            [MOBILE_SYNC_ROUTE]: 'Sync With Mobile Page',
            [RESTORE_VAULT_ROUTE]: 'Restore Vault Page',
            [IMPORT_TOKEN_ROUTE]: 'Import Token Page',
            [CONFIRM_IMPORT_TOKEN_ROUTE]: 'Confirm Import Token Page',
            [CONFIRM_ADD_SUGGESTED_TOKEN_ROUTE]: 'Confirm Add Suggested Token Page',
            [NEW_ACCOUNT_ROUTE]: 'New Account Page',
            [IMPORT_ACCOUNT_ROUTE]: 'Import Account Page',
            [CONNECT_HARDWARE_ROUTE]: 'Connect Hardware Wallet Page',
            [SEND_ROUTE]: 'Send Page',
            [`${TOKEN_DETAILS}/:address`]: 'Token Details Page',
            [`${CONNECT_ROUTE}/:id`]: 'Connect To Site Confirmation Page',
            [`${CONNECT_ROUTE}/:id${CONNECT_CONFIRM_PERMISSIONS_ROUTE}`]: 'Grant Connected Site Permissions Confirmation Page',
            [CONNECTED_ROUTE]: 'Sites Connected To This Account Page',
            [CONNECTED_ACCOUNTS_ROUTE]: 'Accounts Connected To This Site Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id`]: 'Confirmation Root Page',
            [CONFIRM_TRANSACTION_ROUTE]: 'Confirmation Root Page',
            // TODO: rename when this is the only confirmation page
            [CONFIRMATION_V_NEXT_ROUTE]: 'New Confirmation Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_TOKEN_METHOD_PATH}`]: 'Confirm Token Method Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SEND_ETHER_PATH}`]: 'Confirm Send Ether Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SEND_TOKEN_PATH}`]: 'Confirm Send Token Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_DEPLOY_CONTRACT_PATH}`]: 'Confirm Deploy Contract Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_APPROVE_PATH}`]: 'Confirm Approve Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SET_APPROVAL_FOR_ALL_PATH}`]: 'Confirm Set Approval For All Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_TRANSFER_FROM_PATH}`]: 'Confirm Transfer From Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${CONFIRM_SAFE_TRANSFER_FROM_PATH}`]: 'Confirm Safe Transfer From Transaction Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${SIGNATURE_REQUEST_PATH}`]: 'Signature Request Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${DECRYPT_MESSAGE_REQUEST_PATH}`]: 'Decrypt Message Request Page',
            [`${CONFIRM_TRANSACTION_ROUTE}/:id${ENCRYPTION_PUBLIC_KEY_REQUEST_PATH}`]: 'Encryption Public Key Request Page',
            [INITIALIZE_ROUTE]: 'Initialization Page',
            [INITIALIZE_WELCOME_ROUTE]: 'Install Welcome Page',
            [INITIALIZE_UNLOCK_ROUTE]: 'Initialization Unlock page',
            [INITIALIZE_CREATE_PASSWORD_ROUTE]: 'Initialization Create Password Page',
            [INITIALIZE_IMPORT_WITH_SEED_PHRASE_ROUTE]: 'Initialization Import Account With Secret Recovery Phrase Page',
            [INITIALIZE_SELECT_ACTION_ROUTE]: 'Initialization Choose Restore or New Account Page',
            [INITIALIZE_SEED_PHRASE_ROUTE]: 'Initialization Secret Recovery Phrase Page',
            [INITIALIZE_BACKUP_SEED_PHRASE_ROUTE]: 'Initialization Backup Secret Recovery Phrase Page',
            [INITIALIZE_SEED_PHRASE_INTRO_ROUTE]: 'Initialization Secret Recovery Phrase Intro Page',
            [INITIALIZE_END_OF_FLOW_ROUTE]: 'End of Initialization Page',
            [INITIALIZE_CONFIRM_SEED_PHRASE_ROUTE]: 'Initialization Confirm Secret Recovery Phrase Page',
            [INITIALIZE_METAMETRICS_OPT_IN_ROUTE]: 'MetaMetrics Opt In Page',
            [BUILD_QUOTE_ROUTE]: 'Swaps Build Quote Page',
            [VIEW_QUOTE_ROUTE]: 'Swaps View Quotes Page',
            [LOADING_QUOTES_ROUTE]: 'Swaps Loading Quotes Page',
            [AWAITING_SWAP_ROUTE]: 'Swaps Awaiting Swaps Page',
            [SWAPS_ERROR_ROUTE]: 'Swaps Error Page'
          };
          exports.PATH_NAME_MAP = PATH_NAME_MAP;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\transactions.js", { "../../../shared/constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\transactions.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TOKEN_CATEGORY_HASH = exports.PRIORITY_STATUS_HASH = exports.PENDING_STATUS_HASH = void 0;

          var _transaction = require("../../../shared/constants/transaction");

          const PENDING_STATUS_HASH = {
            [_transaction.TRANSACTION_STATUSES.UNAPPROVED]: true,
            [_transaction.TRANSACTION_STATUSES.APPROVED]: true,
            [_transaction.TRANSACTION_STATUSES.SUBMITTED]: true,
            [_transaction.TRANSACTION_STATUSES.PENDING]: true
          };
          exports.PENDING_STATUS_HASH = PENDING_STATUS_HASH;
          const PRIORITY_STATUS_HASH = {
            ...PENDING_STATUS_HASH,
            [_transaction.TRANSACTION_STATUSES.CONFIRMED]: true
          };
          exports.PRIORITY_STATUS_HASH = PRIORITY_STATUS_HASH;
          const TOKEN_CATEGORY_HASH = {
            [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE]: true,
            [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL]: true,
            [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER]: true,
            [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM]: true
          };
          exports.TOKEN_CATEGORY_HASH = TOKEN_CATEGORY_HASH;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\zendesk-url.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\constants\zendesk-url.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;
          const ZENDESK_URLS = {
            ADD_CUSTOM_TOKENS: 'https://metamask.zendesk.com/hc/en-us/articles/360015489031',
            ADD_MISSING_ACCOUNTS: 'https://metamask.zendesk.com/hc/en-us/articles/360015489271',
            BASIC_SAFETY: 'https://metamask.zendesk.com/hc/en-us/articles/360015489591-Basic-Safety-Tips',
            CUSTOMIZE_NONCE: 'https://metamask.zendesk.com/hc/en-us/articles/7417499333531-How-to-customize-a-transaction-nonce',
            HARDWARE_CONNECTION: 'https://metamask.zendesk.com/hc/en-us/articles/360020394612-How-to-connect-a-Trezor-or-Ledger-Hardware-Wallet',
            IMPORT_ACCOUNTS: 'https://metamask.zendesk.com/hc/en-us/articles/360015489331',
            IMPORTED_ACCOUNTS: 'https://metamask.zendesk.com/hc/en-us/articles/360015289932',
            INFURA_BLOCKAGE: 'https://metamask.zendesk.com/hc/en-us/articles/360059386712',
            LEGACY_WEB3: 'https://metamask.zendesk.com/hc/en-us/articles/360053147012',
            NFT_TOKENS: 'https://metamask.zendesk.com/hc/en-us/articles/360058238591-NFT-tokens-in-MetaMask-wallet',
            PASSWORD_ARTICLE: 'https://metamask.zendesk.com/hc/en-us/articles/4404722782107',
            SECRET_RECOVERY_PHRASE: 'https://metamask.zendesk.com/hc/en-us/articles/360060826432-What-is-a-Secret-Recovery-Phrase-and-how-to-keep-your-crypto-wallet-secure',
            SPEEDUP_CANCEL: 'https://metamask.zendesk.com/hc/en-us/articles/360015489251-How-to-speed-up-or-cancel-a-pending-transaction',
            TOKEN_SAFETY_PRACTICES: 'https://metamask.zendesk.com/hc/en-us/articles/4403988839451',
            UNKNOWN_NETWORK: 'https://metamask.zendesk.com/hc/en-us/articles/4417500466971',
            USER_GUIDE_CUSTOM_NETWORKS: 'https://metamask.zendesk.com/hc/en-us/articles/4404424659995',
            USER_GUIDE_DAPPS: 'https://metamask.zendesk.com/hc/en-us/articles/4405506066331-User-guide-Dapps',
            USER_GUIDE_GAS: 'https://metamask.zendesk.com/hc/en-us/articles/4404600179227-User-Guide-Gas',
            VERIFY_CUSTOM_NETWORK: 'https://metamask.zendesk.com/hc/en-us/articles/360057142392'
          };
          var _default = ZENDESK_URLS;
          exports.default = _default;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js", { "../../../app/scripts/lib/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "../../selectors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\selectors\\index.js", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js", "currency-formatter": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\currency-formatter\\index.js", "currency-formatter/currencies": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\currency-formatter\\currencies.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\confirm-tx.util.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.addEth = addEth;
          exports.addFiat = addFiat;
          exports.areDappSuggestedAndTxParamGasFeesTheSame = areDappSuggestedAndTxParamGasFeesTheSame;
          exports.convertTokenToFiat = convertTokenToFiat;
          exports.formatCurrency = formatCurrency;
          exports.getHexGasTotal = getHexGasTotal;
          exports.getTransactionFee = getTransactionFee;
          exports.getValueFromWeiHex = getValueFromWeiHex;
          exports.hasUnconfirmedTransactions = hasUnconfirmedTransactions;
          exports.hexGreaterThan = hexGreaterThan;
          exports.increaseLastGasPrice = increaseLastGasPrice;
          exports.roundExponential = roundExponential;

          var _currencyFormatter = _interopRequireDefault(require("currency-formatter"));

          var _currencies = _interopRequireDefault(require("currency-formatter/currencies"));

          var _bignumber = _interopRequireDefault(require("bignumber.js"));

          var _util = require("../../../app/scripts/lib/util");

          var _selectors = require("../../selectors");

          var _conversion = require("../../../shared/modules/conversion.utils");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          function increaseLastGasPrice(lastGasPrice) {
            return (0, _util.addHexPrefix)((0, _conversion.multiplyCurrencies)(lastGasPrice || '0x0', 1.1, {
              multiplicandBase: 16,
              multiplierBase: 10,
              toNumericBase: 'hex'
            }));
          }

          function hexGreaterThan(a, b) {
            return (0, _conversion.conversionGreaterThan)({
              value: a,
              fromNumericBase: 'hex'
            }, {
              value: b,
              fromNumericBase: 'hex'
            });
          }

          function getHexGasTotal({
            gasLimit,
            gasPrice
          }) {
            return (0, _util.addHexPrefix)((0, _conversion.multiplyCurrencies)(gasLimit || '0x0', gasPrice || '0x0', {
              toNumericBase: 'hex',
              multiplicandBase: 16,
              multiplierBase: 16
            }));
          }

          function addEth(...args) {
            return args.reduce((acc, ethAmount) => {
              return (0, _conversion.addCurrencies)(acc, ethAmount, {
                toNumericBase: 'dec',
                numberOfDecimals: 6,
                aBase: 10,
                bBase: 10
              });
            });
          }

          function addFiat(...args) {
            return args.reduce((acc, fiatAmount) => {
              return (0, _conversion.addCurrencies)(acc, fiatAmount, {
                toNumericBase: 'dec',
                numberOfDecimals: 2,
                aBase: 10,
                bBase: 10
              });
            });
          }

          function getValueFromWeiHex({
            value,
            fromCurrency = 'ETH',
            toCurrency,
            conversionRate,
            numberOfDecimals,
            toDenomination
          }) {
            return (0, _conversion.conversionUtil)(value, {
              fromNumericBase: 'hex',
              toNumericBase: 'dec',
              fromCurrency,
              toCurrency,
              numberOfDecimals,
              fromDenomination: 'WEI',
              toDenomination,
              conversionRate
            });
          }

          function getTransactionFee({
            value,
            fromCurrency = 'ETH',
            toCurrency,
            conversionRate,
            numberOfDecimals
          }) {
            return (0, _conversion.conversionUtil)(value, {
              fromNumericBase: 'BN',
              toNumericBase: 'dec',
              fromDenomination: 'WEI',
              fromCurrency,
              toCurrency,
              numberOfDecimals,
              conversionRate
            });
          }

          function formatCurrency(value, currencyCode) {
            const upperCaseCurrencyCode = currencyCode.toUpperCase();
            return _currencies.default.find(currency => currency.code === upperCaseCurrencyCode) ? _currencyFormatter.default.format(Number(value), {
              code: upperCaseCurrencyCode,
              style: 'currency'
            }) : value;
          }

          function convertTokenToFiat({
            value,
            fromCurrency = 'ETH',
            toCurrency,
            conversionRate,
            contractExchangeRate
          }) {
            const totalExchangeRate = conversionRate * contractExchangeRate;
            return (0, _conversion.conversionUtil)(value, {
              fromNumericBase: 'dec',
              toNumericBase: 'dec',
              fromCurrency,
              toCurrency,
              numberOfDecimals: 2,
              conversionRate: totalExchangeRate
            });
          }

          function hasUnconfirmedTransactions(state) {
            return (0, _selectors.unconfirmedTransactionsCountSelector)(state) > 0;
          }
          /**
           * Rounds the given decimal string to 4 significant digits.
           *
           * @param {string} decimalString - The base-ten number to round.
           * @returns {string} The rounded number, or the original number if no
           * rounding was necessary.
           */


          function roundExponential(decimalString) {
            const PRECISION = 4;
            const bigNumberValue = new _bignumber.default(decimalString); // In JS, numbers with exponentials greater than 20 get displayed as an exponential.

            return bigNumberValue.e > 20 ? bigNumberValue.toPrecision(PRECISION) : decimalString;
          }

          function areDappSuggestedAndTxParamGasFeesTheSame(txData = {}) {
            const {
              txParams,
              dappSuggestedGasFees
            } = txData;
            const {
              gasPrice: txParamsGasPrice,
              maxFeePerGas: txParamsMaxFeePerGas,
              maxPriorityFeePerGas: txParamsMaxPriorityFeePerGas
            } = txParams || {};
            const {
              gasPrice: dappGasPrice,
              maxFeePerGas: dappMaxFeePerGas,
              maxPriorityFeePerGas: dappMaxPriorityFeePerGas
            } = dappSuggestedGasFees || {};
            const txParamsDoesNotHaveFeeProperties = !txParamsGasPrice && !txParamsMaxFeePerGas && !txParamsMaxPriorityFeePerGas;
            const dappDidNotSuggestFeeProperties = !dappGasPrice && !dappMaxFeePerGas && !dappMaxPriorityFeePerGas;

            if (txParamsDoesNotHaveFeeProperties || dappDidNotSuggestFeeProperties) {
              return false;
            }

            const txParamsGasPriceMatchesDappSuggestedGasPrice = txParamsGasPrice && txParamsGasPrice === dappGasPrice;
            const txParamsEIP1559FeesMatchDappSuggestedGasPrice = [txParamsMaxFeePerGas, txParamsMaxPriorityFeePerGas].every(fee => fee === dappGasPrice);
            const txParamsEIP1559FeesMatchDappSuggestedEIP1559Fees = txParamsMaxFeePerGas && txParamsMaxFeePerGas === dappMaxFeePerGas && txParamsMaxPriorityFeePerGas === dappMaxPriorityFeePerGas;
            return txParamsGasPriceMatchesDappSuggestedGasPrice || txParamsEIP1559FeesMatchDappSuggestedGasPrice || txParamsEIP1559FeesMatchDappSuggestedEIP1559Fees;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\conversions.util.js", { "../../../app/scripts/lib/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "../constants/common": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\common.js", "./confirm-tx.util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\conversions.util.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.addHexWEIsToDec = addHexWEIsToDec;
          exports.addHexes = addHexes;
          exports.bnToHex = bnToHex;
          exports.decETHToDecWEI = decETHToDecWEI;
          exports.decEthToConvertedCurrency = decEthToConvertedCurrency;
          exports.decGWEIToHexWEI = decGWEIToHexWEI;
          exports.decWEIToDecETH = decWEIToDecETH;
          exports.getEthConversionFromWeiHex = getEthConversionFromWeiHex;
          exports.getValueFromWeiHex = getValueFromWeiHex;
          exports.getWeiHexFromDecimalValue = getWeiHexFromDecimalValue;
          exports.hexWEIToDecETH = hexWEIToDecETH;
          exports.subtractHexWEIsToDec = subtractHexWEIsToDec;
          exports.subtractHexes = subtractHexes;
          exports.sumHexWEIs = sumHexWEIs;
          exports.sumHexWEIsToRenderableFiat = sumHexWEIsToRenderableFiat;
          exports.sumHexWEIsToUnformattedFiat = sumHexWEIsToUnformattedFiat;

          var _common = require("../constants/common");

          var _util = require("../../../app/scripts/lib/util");

          var _conversion = require("../../../shared/modules/conversion.utils");

          var _confirmTx = require("./confirm-tx.util");

          function bnToHex(inputBn) {
            return (0, _util.addHexPrefix)(inputBn.toString(16));
          }

          function getEthConversionFromWeiHex({
            value,
            fromCurrency = _common.ETH,
            conversionRate,
            numberOfDecimals = 6
          }) {
            const denominations = [fromCurrency, _common.GWEI, _common.WEI];
            let nonZeroDenomination;

            for (let i = 0; i < denominations.length; i++) {
              const convertedValue = getValueFromWeiHex({
                value,
                conversionRate,
                fromCurrency,
                toCurrency: fromCurrency,
                numberOfDecimals,
                toDenomination: denominations[i]
              });

              if (convertedValue !== '0' || i === denominations.length - 1) {
                nonZeroDenomination = `${convertedValue} ${denominations[i]}`;
                break;
              }
            }

            return nonZeroDenomination;
          }

          function getValueFromWeiHex({
            value,
            fromCurrency = _common.ETH,
            toCurrency,
            conversionRate,
            numberOfDecimals,
            toDenomination
          }) {
            return (0, _conversion.conversionUtil)(value, {
              fromNumericBase: 'hex',
              toNumericBase: 'dec',
              fromCurrency,
              toCurrency,
              numberOfDecimals,
              fromDenomination: _common.WEI,
              toDenomination,
              conversionRate
            });
          }

          function getWeiHexFromDecimalValue({
            value,
            fromCurrency,
            conversionRate,
            fromDenomination,
            invertConversionRate
          }) {
            return (0, _conversion.conversionUtil)(value, {
              fromNumericBase: 'dec',
              toNumericBase: 'hex',
              toCurrency: _common.ETH,
              fromCurrency,
              conversionRate,
              invertConversionRate,
              fromDenomination,
              toDenomination: _common.WEI
            });
          }

          function addHexWEIsToDec(aHexWEI, bHexWEI) {
            return (0, _conversion.addCurrencies)(aHexWEI, bHexWEI, {
              aBase: 16,
              bBase: 16,
              fromDenomination: 'WEI',
              numberOfDecimals: 6
            });
          }

          function subtractHexWEIsToDec(aHexWEI, bHexWEI) {
            return (0, _conversion.subtractCurrencies)(aHexWEI, bHexWEI, {
              aBase: 16,
              bBase: 16,
              fromDenomination: 'WEI',
              numberOfDecimals: 6
            });
          }

          function decEthToConvertedCurrency(ethTotal, convertedCurrency, conversionRate) {
            return (0, _conversion.conversionUtil)(ethTotal, {
              fromNumericBase: 'dec',
              toNumericBase: 'dec',
              fromCurrency: 'ETH',
              toCurrency: convertedCurrency,
              numberOfDecimals: 2,
              conversionRate
            });
          }

          function decGWEIToHexWEI(decGWEI) {
            return (0, _conversion.conversionUtil)(decGWEI, {
              fromNumericBase: 'dec',
              toNumericBase: 'hex',
              fromDenomination: 'GWEI',
              toDenomination: 'WEI'
            });
          }

          function decETHToDecWEI(decEth) {
            return (0, _conversion.conversionUtil)(decEth, {
              fromNumericBase: 'dec',
              toNumericBase: 'dec',
              fromDenomination: 'ETH',
              toDenomination: 'WEI'
            });
          }

          function hexWEIToDecETH(hexWEI) {
            return (0, _conversion.conversionUtil)(hexWEI, {
              fromNumericBase: 'hex',
              toNumericBase: 'dec',
              fromDenomination: 'WEI',
              toDenomination: 'ETH'
            });
          }

          function decWEIToDecETH(hexWEI) {
            return (0, _conversion.conversionUtil)(hexWEI, {
              fromNumericBase: 'dec',
              toNumericBase: 'dec',
              fromDenomination: 'WEI',
              toDenomination: 'ETH'
            });
          }

          function addHexes(aHexWEI, bHexWEI) {
            return (0, _conversion.addCurrencies)(aHexWEI, bHexWEI, {
              aBase: 16,
              bBase: 16,
              toNumericBase: 'hex',
              numberOfDecimals: 6
            });
          }

          function subtractHexes(aHexWEI, bHexWEI) {
            return (0, _conversion.subtractCurrencies)(aHexWEI, bHexWEI, {
              aBase: 16,
              bBase: 16,
              toNumericBase: 'hex',
              numberOfDecimals: 6
            });
          }

          function sumHexWEIs(hexWEIs) {
            return hexWEIs.filter(Boolean).reduce(addHexes);
          }

          function sumHexWEIsToUnformattedFiat(hexWEIs, convertedCurrency, conversionRate) {
            const hexWEIsSum = sumHexWEIs(hexWEIs);
            const convertedTotal = decEthToConvertedCurrency(getValueFromWeiHex({
              value: hexWEIsSum,
              toCurrency: 'ETH',
              numberOfDecimals: 4
            }), convertedCurrency, conversionRate);
            return convertedTotal;
          }

          function sumHexWEIsToRenderableFiat(hexWEIs, convertedCurrency, conversionRate) {
            const convertedTotal = sumHexWEIsToUnformattedFiat(hexWEIs, convertedCurrency, conversionRate);
            return (0, _confirmTx.formatCurrency)(convertedTotal, convertedCurrency);
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\formatters.js", {}, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\formatters.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.formatETHFee = formatETHFee;

          // TODO: Rename to reflect that this function is used for more cases than ETH, and update all uses.
          function formatETHFee(ethFee, currencySymbol = 'ETH') {
            return `${ethFee} ${currencySymbol}`;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\i18n-helper.js", { "../../../shared/modules/fetch-with-timeout": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\fetch-with-timeout.js", "@sentry/browser": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@sentry\\browser\\dist\\index.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js", "react": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\i18n-helper.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.fetchLocale = fetchLocale;
          exports.getMessage = void 0;
          exports.loadRelativeTimeFormatLocaleData = loadRelativeTimeFormatLocaleData;

          var _react = _interopRequireDefault(require("react"));

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var Sentry = _interopRequireWildcard(require("@sentry/browser"));

          var _fetchWithTimeout = _interopRequireDefault(require("../../../shared/modules/fetch-with-timeout"));

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          // cross-browser connection to extension i18n API
          const fetchWithTimeout = (0, _fetchWithTimeout.default)();
          const warned = {};
          const missingMessageErrors = {};
          const missingSubstitutionErrors = {};
          /**
           * Returns a localized message for the given key
           *
           * @param {string} localeCode - The code for the current locale
           * @param {object} localeMessages - The map of messages for the current locale
           * @param {string} key - The message key
           * @param {string[]} substitutions - A list of message substitution replacements
           * @returns {null|string} The localized message
           */

          const getMessage = (localeCode, localeMessages, key, substitutions) => {
            if (!localeMessages) {
              return null;
            }

            if (!localeMessages[key]) {
              if (localeCode === 'en') {
                if (!missingMessageErrors[key]) {
                  missingMessageErrors[key] = new Error(`Unable to find value of key "${key}" for locale "${localeCode}"`);
                  Sentry.captureException(missingMessageErrors[key]);

                  _loglevel.default.error(missingMessageErrors[key]);

                  if (false) {
                    throw missingMessageErrors[key];
                  }
                }
              } else if (!warned[localeCode] || !warned[localeCode][key]) {
                if (!warned[localeCode]) {
                  warned[localeCode] = {};
                }

                warned[localeCode][key] = true;

                _loglevel.default.warn(`Translator - Unable to find value of key "${key}" for locale "${localeCode}"`);
              }

              return null;
            }

            const entry = localeMessages[key];
            let phrase = entry.message;
            const hasSubstitutions = Boolean(substitutions && substitutions.length);
            const hasReactSubstitutions = hasSubstitutions && substitutions.some(element => element !== null && (typeof element === 'function' || typeof element === 'object')); // perform substitutions

            if (hasSubstitutions) {
              const parts = phrase.split(/(\$\d)/gu);
              const substitutedParts = parts.map(part => {
                var _missingSubstitutionE;

                const subMatch = part.match(/\$(\d)/u);

                if (!subMatch) {
                  return part;
                }

                const substituteIndex = Number(subMatch[1]) - 1;

                if ((substitutions[substituteIndex] === null || substitutions[substituteIndex] === undefined) && !((_missingSubstitutionE = missingSubstitutionErrors[localeCode]) !== null && _missingSubstitutionE !== void 0 && _missingSubstitutionE[key])) {
                  if (!missingSubstitutionErrors[localeCode]) {
                    missingSubstitutionErrors[localeCode] = {};
                  }

                  missingSubstitutionErrors[localeCode][key] = true;
                  const error = new Error(`Insufficient number of substitutions for key "${key}" with locale "${localeCode}"`);

                  _loglevel.default.error(error);

                  Sentry.captureException(error);
                }

                return substitutions[substituteIndex];
              });
              phrase = hasReactSubstitutions ? /*#__PURE__*/_react.default.createElement("span", null, " ", substitutedParts, " ") : substitutedParts.join('');
            }

            return phrase;
          };

          exports.getMessage = getMessage;

          async function fetchLocale(localeCode) {
            try {
              const response = await fetchWithTimeout(`./_locales/${localeCode}/messages.json`);
              return await response.json();
            } catch (error) {
              _loglevel.default.error(`failed to fetch ${localeCode} locale because of ${error}`);

              return {};
            }
          }

          const relativeTimeFormatLocaleData = new Set();

          async function loadRelativeTimeFormatLocaleData(localeCode) {
            const languageTag = localeCode.split('_')[0];

            if (Intl.RelativeTimeFormat && typeof Intl.RelativeTimeFormat.__addLocaleData === 'function' && !relativeTimeFormatLocaleData.has(languageTag)) {
              const localeData = await fetchRelativeTimeFormatData(languageTag);

              Intl.RelativeTimeFormat.__addLocaleData(localeData);
            }
          }

          async function fetchRelativeTimeFormatData(languageTag) {
            const response = await fetchWithTimeout(`./intl/${languageTag}/relative-time-format-data.json`);
            return await response.json();
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\moonpay.js", { "../../../shared/constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\moonpay.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.formatMoonpaySymbol = void 0;

          var _network = require("../../../shared/constants/network");

          const formatMoonpaySymbol = (symbol, chainId = _network.CHAIN_IDS.MAINNET) => {
            if (!symbol) {
              return symbol;
            }

            let _symbol = symbol;

            if (chainId === _network.CHAIN_IDS.POLYGON || chainId === _network.CHAIN_IDS.BSC) {
              var _BUYABLE_CHAINS_MAP$c;

              _symbol = `${_symbol}_${_network.BUYABLE_CHAINS_MAP === null || _network.BUYABLE_CHAINS_MAP === void 0 ? void 0 : (_BUYABLE_CHAINS_MAP$c = _network.BUYABLE_CHAINS_MAP[chainId]) === null || _BUYABLE_CHAINS_MAP$c === void 0 ? void 0 : _BUYABLE_CHAINS_MAP$c.network.toUpperCase()}`;
            } else if (chainId === _network.CHAIN_IDS.AVALANCHE) {
              _symbol = `${_symbol}_CCHAIN`;
            }

            return _symbol;
          };

          exports.formatMoonpaySymbol = formatMoonpaySymbol;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js", { "../../../../shared/modules/hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "@ethereumjs/common": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\common\\dist.browser\\index.js", "@ethereumjs/tx": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@ethereumjs\\tx\\dist.browser\\index.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js", "lodash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\optimism\buildUnserializedTransaction.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = buildUnserializedTransaction;

          var _lodash = require("lodash");

          var _ethereumjsUtil = require("ethereumjs-util");

          var _common = _interopRequireWildcard(require("@ethereumjs/common"));

          var _tx = require("@ethereumjs/tx");

          var _hexstringUtils = require("../../../../shared/modules/hexstring-utils");

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function buildTxParams(txMeta) {
            return {
              ...(0, _lodash.omit)(txMeta.txParams, 'gas'),
              gasLimit: txMeta.txParams.gas
            };
          }

          function buildTransactionCommon(txMeta) {
            // This produces a transaction whose information does not completely match an
            // Optimism transaction — for instance, DEFAULT_CHAIN is still 'mainnet' and
            // genesis points to the mainnet genesis, not the Optimism genesis — but
            // considering that all we want to do is serialize a transaction, this works
            // fine for our use case.
            return _common.default.forCustomChain(_common.Chain.Mainnet, {
              chainId: new _ethereumjsUtil.BN((0, _hexstringUtils.stripHexPrefix)(txMeta.chainId), 16),
              networkId: new _ethereumjsUtil.BN(txMeta.metamaskNetworkId, 10),
              // Optimism only supports type-0 transactions; it does not support any of
              // the newer EIPs since EIP-155. Source:
              // <https://github.com/ethereum-optimism/optimism/blob/develop/specs/l2geth/transaction-types.md>
              defaultHardfork: _common.Hardfork.SpuriousDragon
            });
          }

          function buildUnserializedTransaction(txMeta) {
            const txParams = buildTxParams(txMeta);
            const common = buildTransactionCommon(txMeta);
            return _tx.TransactionFactory.fromTxData(txParams, {
              common
            });
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\fetchEstimatedL1Fee.js", { "./buildUnserializedTransaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\optimism\\buildUnserializedTransaction.js", "@eth-optimism/contracts/dist/contract-defs": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@eth-optimism\\contracts\\dist\\contract-defs.js", "@eth-optimism/contracts/dist/predeploys": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@eth-optimism\\contracts\\dist\\predeploys.js", "ethers": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethers\\lib\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\optimism\fetchEstimatedL1Fee.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = fetchEstimatedL1Fee;

          var ethers = _interopRequireWildcard(require("ethers"));

          var _contractDefs = require("@eth-optimism/contracts/dist/contract-defs");

          var _predeploys = require("@eth-optimism/contracts/dist/predeploys");

          var _buildUnserializedTransaction = _interopRequireDefault(require("./buildUnserializedTransaction"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          // The code in this file is largely drawn from https://community.optimism.io/docs/developers/l2/new-fees.html#for-frontend-and-wallet-developers
          function buildOVMGasPriceOracleContract(eth) {
            const OVMGasPriceOracle = (0, _contractDefs.getContractFactory)('OVM_GasPriceOracle').attach(_predeploys.predeploys.OVM_GasPriceOracle);
            const abi = JSON.parse(OVMGasPriceOracle.interface.format(ethers.utils.FormatTypes.json));
            return eth.contract(abi).at(OVMGasPriceOracle.address);
          }

          async function fetchEstimatedL1Fee(eth, txMeta) {
            var _result$;

            const contract = buildOVMGasPriceOracleContract(eth);
            const serializedTransaction = (0, _buildUnserializedTransaction.default)(txMeta).serialize();
            const result = await contract.getL1Fee(serializedTransaction);
            return result === null || result === void 0 ? void 0 : (_result$ = result[0]) === null || _result$ === void 0 ? void 0 : _result$.toString(16);
          }


        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\token-util.js", { "../../../shared/constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", "../../../shared/lib/metamask-controller-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\metamask-controller-utils.js", "../../../shared/lib/transactions-controller-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "../../../shared/modules/string-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\string-utils.js", "../../../shared/modules/transaction.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js", "../../store/actions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js", "./confirm-tx.util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\confirm-tx.util.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\token-util.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getAssetDetails = getAssetDetails;
          exports.getSymbolAndDecimals = getSymbolAndDecimals;
          exports.getTokenAddressParam = getTokenAddressParam;
          exports.getTokenApprovedParam = getTokenApprovedParam;
          exports.getTokenFiatAmount = getTokenFiatAmount;
          exports.getTokenIdParam = getTokenIdParam;
          exports.getTokenMetadata = getTokenMetadata;
          exports.tokenInfoGetter = tokenInfoGetter;

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var _conversion = require("../../../shared/modules/conversion.utils");

          var _actions = require("../../store/actions");

          var _stringUtils = require("../../../shared/modules/string-utils");

          var _transaction = require("../../../shared/modules/transaction.utils");

          var _transaction2 = require("../../../shared/constants/transaction");

          var _metamaskControllerUtils = require("../../../shared/lib/metamask-controller-utils");

          var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

          var util = _interopRequireWildcard(require("./util"));

          var _confirmTx = require("./confirm-tx.util");

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          const DEFAULT_SYMBOL = '';

          async function getSymbolFromContract(tokenAddress) {
            const token = util.getContractAtAddress(tokenAddress);

            try {
              const result = await token.symbol();
              return result[0];
            } catch (error) {
              _loglevel.default.warn(`symbol() call for token at address ${tokenAddress} resulted in error:`, error);

              return undefined;
            }
          }

          async function getDecimalsFromContract(tokenAddress) {
            const token = util.getContractAtAddress(tokenAddress);

            try {
              const result = await token.decimals();
              const decimalsBN = result[0];
              return decimalsBN === null || decimalsBN === void 0 ? void 0 : decimalsBN.toString();
            } catch (error) {
              _loglevel.default.warn(`decimals() call for token at address ${tokenAddress} resulted in error:`, error);

              return undefined;
            }
          }

          function getTokenMetadata(tokenAddress, tokenList) {
            return tokenAddress && tokenList[tokenAddress.toLowerCase()];
          }

          async function getSymbol(tokenAddress, tokenList) {
            let symbol = await getSymbolFromContract(tokenAddress);

            if (!symbol) {
              const contractMetadataInfo = getTokenMetadata(tokenAddress, tokenList);

              if (contractMetadataInfo) {
                symbol = contractMetadataInfo.symbol;
              }
            }

            return symbol;
          }

          async function getDecimals(tokenAddress, tokenList) {
            let decimals = await getDecimalsFromContract(tokenAddress);

            if (!decimals || decimals === '0') {
              const contractMetadataInfo = getTokenMetadata(tokenAddress, tokenList);

              if (contractMetadataInfo) {
                var _contractMetadataInfo;

                decimals = (_contractMetadataInfo = contractMetadataInfo.decimals) === null || _contractMetadataInfo === void 0 ? void 0 : _contractMetadataInfo.toString();
              }
            }

            return decimals;
          }

          async function getSymbolAndDecimals(tokenAddress, tokenList) {
            let symbol, decimals;

            try {
              symbol = await getSymbol(tokenAddress, tokenList);
              decimals = await getDecimals(tokenAddress, tokenList);
            } catch (error) {
              _loglevel.default.warn(`symbol() and decimal() calls for token at address ${tokenAddress} resulted in error:`, error);
            }

            return {
              symbol: symbol || DEFAULT_SYMBOL,
              decimals
            };
          }

          function tokenInfoGetter() {
            const tokens = {};
            return async (address, tokenList) => {
              if (tokens[address]) {
                return tokens[address];
              }

              tokens[address] = await getSymbolAndDecimals(address, tokenList);
              return tokens[address];
            };
          }
          /**
           * Attempts to get the address parameter of the given token transaction data
           * (i.e. function call) per the Human Standard Token ABI, in the following
           * order:
           *   - The '_to' parameter, if present
           *   - The first parameter, if present
           *
           * @param {object} tokenData - ethers Interface token data.
           * @returns {string | undefined} A lowercase address string.
           */


          function getTokenAddressParam(tokenData = {}) {
            var _tokenData$args, _tokenData$args2, _tokenData$args3;

            const value = (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args = tokenData.args) === null || _tokenData$args === void 0 ? void 0 : _tokenData$args._to) || (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args2 = tokenData.args) === null || _tokenData$args2 === void 0 ? void 0 : _tokenData$args2.to) || (tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args3 = tokenData.args) === null || _tokenData$args3 === void 0 ? void 0 : _tokenData$args3[0]);
            return value === null || value === void 0 ? void 0 : value.toString().toLowerCase();
          }
          /**
           * Gets the '_value' parameter of the given token transaction data
           * (i.e function call) per the Human Standard Token ABI, if present.
           *
           * @param {object} tokenData - ethers Interface token data.
           * @returns {string | undefined} A decimal string value.
           */

          /**
           * Gets either the '_tokenId' parameter or the 'id' param of the passed token transaction data.,
           * These are the parsed tokenId values returned by `parseStandardTokenTransactionData` as defined
           * in the ERC721 and ERC1155 ABIs from metamask-eth-abis (https://github.com/MetaMask/metamask-eth-abis/tree/main/src/abis)
           *
           * @param {object} tokenData - ethers Interface token data.
           * @returns {string | undefined} A decimal string value.
           */


          function getTokenIdParam(tokenData = {}) {
            var _tokenData$args$_toke, _tokenData$args4, _tokenData$args4$_tok, _tokenData$args5, _tokenData$args5$id;

            return (_tokenData$args$_toke = tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args4 = tokenData.args) === null || _tokenData$args4 === void 0 ? void 0 : (_tokenData$args4$_tok = _tokenData$args4._tokenId) === null || _tokenData$args4$_tok === void 0 ? void 0 : _tokenData$args4$_tok.toString()) !== null && _tokenData$args$_toke !== void 0 ? _tokenData$args$_toke : tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args5 = tokenData.args) === null || _tokenData$args5 === void 0 ? void 0 : (_tokenData$args5$id = _tokenData$args5.id) === null || _tokenData$args5$id === void 0 ? void 0 : _tokenData$args5$id.toString();
          }
          /**
           * Gets the '_approved' parameter of the given token transaction data
           * (i.e function call) per the Human Standard Token ABI, if present.
           *
           * @param {object} tokenData - ethers Interface token data.
           * @returns {boolean | undefined} A boolean indicating whether the function is being called to approve or revoke access.
           */


          function getTokenApprovedParam(tokenData = {}) {
            var _tokenData$args6;

            return tokenData === null || tokenData === void 0 ? void 0 : (_tokenData$args6 = tokenData.args) === null || _tokenData$args6 === void 0 ? void 0 : _tokenData$args6._approved;
          }
          /**
           * Get the token balance converted to fiat and optionally formatted for display
           *
           * @param {number} [contractExchangeRate] - The exchange rate between the current token and the native currency
           * @param {number} conversionRate - The exchange rate between the current fiat currency and the native currency
           * @param {string} currentCurrency - The currency code for the user's chosen fiat currency
           * @param {string} [tokenAmount] - The current token balance
           * @param {string} [tokenSymbol] - The token symbol
           * @param {boolean} [formatted] - Whether the return value should be formatted or not
           * @param {boolean} [hideCurrencySymbol] - excludes the currency symbol in the result if true
           * @returns {string|undefined} The token amount in the user's chosen fiat currency, optionally formatted and localize
           */


          function getTokenFiatAmount(contractExchangeRate, conversionRate, currentCurrency, tokenAmount, tokenSymbol, formatted = true, hideCurrencySymbol = false) {
            // If the conversionRate is 0 (i.e. unknown) or the contract exchange rate
            // is currently unknown, the fiat amount cannot be calculated so it is not
            // shown to the user
            if (conversionRate <= 0 || !contractExchangeRate || tokenAmount === undefined) {
              return undefined;
            }

            const currentTokenToFiatRate = (0, _conversion.multiplyCurrencies)(contractExchangeRate, conversionRate, {
              multiplicandBase: 10,
              multiplierBase: 10
            });
            const currentTokenInFiat = (0, _conversion.conversionUtil)(tokenAmount, {
              fromNumericBase: 'dec',
              fromCurrency: tokenSymbol,
              toCurrency: currentCurrency.toUpperCase(),
              numberOfDecimals: 2,
              conversionRate: currentTokenToFiatRate
            });
            let result;

            if (hideCurrencySymbol) {
              result = (0, _confirmTx.formatCurrency)(currentTokenInFiat, currentCurrency);
            } else if (formatted) {
              result = `${(0, _confirmTx.formatCurrency)(currentTokenInFiat, currentCurrency)} ${currentCurrency.toUpperCase()}`;
            } else {
              result = currentTokenInFiat;
            }

            return result;
          }

          async function getAssetDetails(tokenAddress, currentUserAddress, transactionData, existingCollectibles) {
            var _getTokenIdParam$toSt, _getTokenIdParam, _tokenDetails, _tokenDetails2, _tokenDetails3, _tokenDetails$decimal, _tokenDetails4;

            const tokenData = (0, _transaction.parseStandardTokenTransactionData)(transactionData);

            if (!tokenData) {
              throw new Error('Unable to detect valid token data');
            } // Sometimes the tokenId value is parsed as "_value" param. Not seeing this often any more, but still occasionally:
            // i.e. call approve() on BAYC contract - https://etherscan.io/token/0xbc4ca0eda7647a8ab7c2061c2e118a18a936f13d#writeContract, and tokenId shows up as _value,
            // not sure why since it doesn't match the ERC721 ABI spec we use to parse these transactions - https://github.com/MetaMask/metamask-eth-abis/blob/d0474308a288f9252597b7c93a3a8deaad19e1b2/src/abis/abiERC721.ts#L62.


            let tokenId = (_getTokenIdParam$toSt = (_getTokenIdParam = getTokenIdParam(tokenData)) === null || _getTokenIdParam === void 0 ? void 0 : _getTokenIdParam.toString()) !== null && _getTokenIdParam$toSt !== void 0 ? _getTokenIdParam$toSt : (0, _metamaskControllerUtils.getTokenValueParam)(tokenData);
            const toAddress = getTokenAddressParam(tokenData);
            let tokenDetails; // if a tokenId is present check if there is a collectible in state matching the address/tokenId
            // and avoid unnecessary network requests to query token details we already have

            if (existingCollectibles !== null && existingCollectibles !== void 0 && existingCollectibles.length && tokenId) {
              const existingCollectible = existingCollectibles.find(({
                address,
                tokenId: _tokenId
              }) => (0, _stringUtils.isEqualCaseInsensitive)(tokenAddress, address) && _tokenId === tokenId);

              if (existingCollectible) {
                return {
                  toAddress,
                  ...existingCollectible
                };
              }
            }

            try {
              tokenDetails = await (0, _actions.getTokenStandardAndDetails)(tokenAddress, currentUserAddress, tokenId);
            } catch (error) {
              _loglevel.default.warn(error); // if we can't determine any token standard or details return the data we can extract purely from the parsed transaction data


              return {
                toAddress,
                tokenId
              };
            }

            const tokenAmount = tokenData && ((_tokenDetails = tokenDetails) === null || _tokenDetails === void 0 ? void 0 : _tokenDetails.decimals) && (0, _transactionsControllerUtils.calcTokenAmount)((0, _metamaskControllerUtils.getTokenValueParam)(tokenData), (_tokenDetails2 = tokenDetails) === null || _tokenDetails2 === void 0 ? void 0 : _tokenDetails2.decimals).toString(10);
            const decimals = ((_tokenDetails3 = tokenDetails) === null || _tokenDetails3 === void 0 ? void 0 : _tokenDetails3.decimals) && Number((_tokenDetails$decimal = tokenDetails.decimals) === null || _tokenDetails$decimal === void 0 ? void 0 : _tokenDetails$decimal.toString(10));

            if (((_tokenDetails4 = tokenDetails) === null || _tokenDetails4 === void 0 ? void 0 : _tokenDetails4.standard) === _transaction2.ERC20) {
              tokenId = undefined;
            } // else if not a collectible already in state or standard === ERC20 return tokenDetails and tokenId


            return {
              tokenAmount,
              toAddress,
              decimals,
              tokenId,
              ...tokenDetails
            };
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\transactions.util.js", { "../../../app/scripts/lib/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js", "../../../shared/constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", "../../../shared/lib/fetch-with-cache": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js", "../../../shared/modules/contract-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\contract-utils.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "eth-method-registry": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-method-registry\\dist\\index.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\transactions.util.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.getFourBytePrefix = getFourBytePrefix;
          exports.getLatestSubmittedTxWithNonce = getLatestSubmittedTxWithNonce;
          exports.getMethodDataAsync = getMethodDataAsync;
          exports.getStatusKey = getStatusKey;
          exports.getTransactionTypeTitle = getTransactionTypeTitle;
          exports.isLegacyTransaction = isLegacyTransaction;
          exports.isSmartContractAddress = isSmartContractAddress;
          exports.isTokenMethodAction = isTokenMethodAction;
          exports.sumHexes = sumHexes;

          var _ethMethodRegistry = require("eth-method-registry");

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var _util = require("../../../app/scripts/lib/util");

          var _transaction = require("../../../shared/constants/transaction");

          var _conversion = require("../../../shared/modules/conversion.utils");

          var _contractUtils = require("../../../shared/modules/contract-utils");

          var _fetchWithCache = _interopRequireDefault(require("../../../shared/lib/fetch-with-cache"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          /**
           * @typedef EthersContractCall
           * @type object
           * @property {any[]} args - The args/params to the function call.
           * An array-like object with numerical and string indices.
           * @property {string} name - The name of the function.
           * @property {string} signature - The function signature.
           * @property {string} sighash - The function signature hash.
           * @property {EthersBigNumber} value - The ETH value associated with the call.
           * @property {FunctionFragment} functionFragment - The Ethers function fragment
           * representation of the function.
           */
          async function getMethodFrom4Byte(fourBytePrefix) {
            const fourByteResponse = await (0, _fetchWithCache.default)(`https://www.4byte.directory/api/v1/signatures/?hex_signature=${fourBytePrefix}`, {
              referrerPolicy: 'no-referrer-when-downgrade',
              body: null,
              method: 'GET',
              mode: 'cors'
            });
            fourByteResponse.results.sort((a, b) => {
              return new Date(a.created_at).getTime() < new Date(b.created_at).getTime() ? -1 : 1;
            });
            return fourByteResponse.results[0].text_signature;
          }

          let registry;
          /**
           * Attempts to return the method data from the MethodRegistry library, the message registry library and the token abi, in that order of preference
           *
           * @param {string} fourBytePrefix - The prefix from the method code associated with the data
           * @returns {object}
           */

          async function getMethodDataAsync(fourBytePrefix) {
            try {
              const fourByteSig = await getMethodFrom4Byte(fourBytePrefix).catch(e => {
                _loglevel.default.error(e);

                return null;
              });

              if (!registry) {
                registry = new _ethMethodRegistry.MethodRegistry({
                  provider: global.ethereumProvider
                });
              }

              if (!fourByteSig) {
                return {};
              }

              const parsedResult = registry.parse(fourByteSig);
              return {
                name: parsedResult.name,
                params: parsedResult.args
              };
            } catch (error) {
              _loglevel.default.error(error);

              return {};
            }
          }
          /**
           * Returns four-byte method signature from data
           *
           * @param {string} data - The hex data (@code txParams.data) of a transaction
           * @returns {string} The four-byte method signature
           */


          function getFourBytePrefix(data = '') {
            const prefixedData = (0, _util.addHexPrefix)(data);
            const fourBytePrefix = prefixedData.slice(0, 10);
            return fourBytePrefix;
          }
          /**
           * Given an transaction category, returns a boolean which indicates whether the transaction is calling an erc20 token method
           *
           * @param {TRANSACTION_TYPES[keyof TRANSACTION_TYPES]} type - The type of transaction being evaluated
           * @returns {boolean} whether the transaction is calling an erc20 token method
           */


          function isTokenMethodAction(type) {
            return [_transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM, _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM].includes(type);
          }

          function getLatestSubmittedTxWithNonce(transactions = [], nonce = '0x0') {
            if (!transactions.length) {
              return {};
            }

            return transactions.reduce((acc, current) => {
              const {
                submittedTime,
                txParams: {
                  nonce: currentNonce
                } = {}
              } = current;

              if (currentNonce === nonce) {
                if (!acc.submittedTime) {
                  return current;
                }

                return submittedTime > acc.submittedTime ? current : acc;
              }

              return acc;
            }, {});
          }

          async function isSmartContractAddress(address) {
            const {
              isContractAddress
            } = await (0, _contractUtils.readAddressAsContract)(global.eth, address);
            return isContractAddress;
          }

          function sumHexes(...args) {
            const total = args.reduce((acc, hexAmount) => {
              return (0, _conversion.addCurrencies)(acc, hexAmount, {
                toNumericBase: 'hex',
                aBase: 16,
                bBase: 16
              });
            });
            return (0, _util.addHexPrefix)(total);
          }

          function isLegacyTransaction(txParams) {
            return (txParams === null || txParams === void 0 ? void 0 : txParams.type) === _transaction.TRANSACTION_ENVELOPE_TYPES.LEGACY;
          }
          /**
           * Returns a status key for a transaction. Requires parsing the txMeta.txReceipt on top of
           * txMeta.status because txMeta.status does not reflect on-chain errors.
           *
           * @param {object} transaction - The txMeta object of a transaction.
           * @param {object} transaction.txReceipt - The transaction receipt.
           * @returns {string}
           */


          function getStatusKey(transaction) {
            const {
              txReceipt: {
                status: receiptStatus
              } = {},
              type,
              status
            } = transaction; // There was an on-chain failure

            if (receiptStatus === '0x0') {
              return _transaction.TRANSACTION_STATUSES.FAILED;
            }

            if (status === _transaction.TRANSACTION_STATUSES.CONFIRMED && type === _transaction.TRANSACTION_TYPES.CANCEL) {
              return _transaction.TRANSACTION_GROUP_STATUSES.CANCELLED;
            }

            return transaction.status;
          }
          /**
           * Returns a title for the given transaction category.
           *
           * This will throw an error if the transaction category is unrecognized and no default is provided.
           *
           * @param {Function} t - The translation function
           * @param {TRANSACTION_TYPES[keyof TRANSACTION_TYPES]} type - The transaction type constant
           * @param {string} nativeCurrency - The native currency of the currently selected network
           * @returns {string} The transaction category title
           */


          function getTransactionTypeTitle(t, type, nativeCurrency = 'ETH') {
            switch (type) {
              case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER:
                {
                  return t('transfer');
                }

              case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_TRANSFER_FROM:
                {
                  return t('transferFrom');
                }

              case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SAFE_TRANSFER_FROM:
                {
                  return t('safeTransferFrom');
                }

              case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_APPROVE:
                {
                  return t('approve');
                }

              case _transaction.TRANSACTION_TYPES.TOKEN_METHOD_SET_APPROVAL_FOR_ALL:
                {
                  return t('setApprovalForAll');
                }

              case _transaction.TRANSACTION_TYPES.SIMPLE_SEND:
                {
                  return t('sendingNativeAsset', [nativeCurrency]);
                }

              case _transaction.TRANSACTION_TYPES.CONTRACT_INTERACTION:
                {
                  return t('contractInteraction');
                }

              case _transaction.TRANSACTION_TYPES.DEPLOY_CONTRACT:
                {
                  return t('contractDeployment');
                }

              case _transaction.TRANSACTION_TYPES.SWAP:
                {
                  return t('swap');
                }

              case _transaction.TRANSACTION_TYPES.SWAP_APPROVAL:
                {
                  return t('swapApproval');
                }

              default:
                {
                  throw new Error(`Unrecognized transaction type: ${type}`);
                }
            }
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\tx-helper.js", { "../../../shared/modules/transaction.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\transaction.utils.js", "./util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js", "loglevel": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\loglevel\\lib\\loglevel.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\tx-helper.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = txHelper;

          var _loglevel = _interopRequireDefault(require("loglevel"));

          var _transaction = require("../../../shared/modules/transaction.utils");

          var _util = require("./util");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          function txHelper(unapprovedTxs, unapprovedMsgs, personalMsgs, decryptMsgs, encryptionPublicKeyMsgs, typedMessages, network, chainId) {
            _loglevel.default.debug('tx-helper called with params:');

            _loglevel.default.debug({
              unapprovedTxs,
              unapprovedMsgs,
              personalMsgs,
              decryptMsgs,
              encryptionPublicKeyMsgs,
              typedMessages,
              network,
              chainId
            });

            const txValues = network ? (0, _util.valuesFor)(unapprovedTxs).filter(txMeta => (0, _transaction.transactionMatchesNetwork)(txMeta, chainId, network)) : (0, _util.valuesFor)(unapprovedTxs);

            _loglevel.default.debug(`tx helper found ${txValues.length} unapproved txs`);

            const msgValues = (0, _util.valuesFor)(unapprovedMsgs);

            _loglevel.default.debug(`tx helper found ${msgValues.length} unsigned messages`);

            let allValues = txValues.concat(msgValues);
            const personalValues = (0, _util.valuesFor)(personalMsgs);

            _loglevel.default.debug(`tx helper found ${personalValues.length} unsigned personal messages`);

            allValues = allValues.concat(personalValues);
            const decryptValues = (0, _util.valuesFor)(decryptMsgs);

            _loglevel.default.debug(`tx helper found ${decryptValues.length} decrypt requests`);

            allValues = allValues.concat(decryptValues);
            const encryptionPublicKeyValues = (0, _util.valuesFor)(encryptionPublicKeyMsgs);

            _loglevel.default.debug(`tx helper found ${encryptionPublicKeyValues.length} encryptionPublicKey requests`);

            allValues = allValues.concat(encryptionPublicKeyValues);
            const typedValues = (0, _util.valuesFor)(typedMessages);

            _loglevel.default.debug(`tx helper found ${typedValues.length} unsigned typed messages`);

            allValues = allValues.concat(typedValues);
            allValues = allValues.sort((a, b) => {
              return a.time - b.time;
            });
            return allValues;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\utils\\util.js", { "../../../shared/constants/labels": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\labels.js", "../../../shared/constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "../../../shared/modules/hexstring-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\hexstring-utils.js", "@metamask/controllers/dist/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\controllers\\dist\\util.js", "@metamask/slip44": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\@metamask\\slip44\\slip44.json", "bignumber.js": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\bignumber.js\\bignumber.js", "ethereumjs-util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-util\\dist.browser\\index.js", "human-standard-token-abi": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\human-standard-token-abi\\index.js", "luxon": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\luxon\\build\\cjs-browser\\luxon.js", "punycode/punycode": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\punycode\\punycode.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\helpers\utils\util.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.addressSummary = addressSummary;
          exports.bnGreaterThan = bnGreaterThan;
          exports.bnGreaterThanEqualTo = bnGreaterThanEqualTo;
          exports.bnLessThan = bnLessThan;
          exports.bnLessThanEqualTo = bnLessThanEqualTo;
          exports.checkExistingAddresses = checkExistingAddresses;
          exports.clearClipboard = clearClipboard;
          exports.coinTypeToProtocolName = coinTypeToProtocolName;
          exports.formatBalance = formatBalance;
          exports.formatDate = formatDate;
          exports.formatDateWithYearContext = formatDateWithYearContext;
          exports.getAccountByAddress = getAccountByAddress;
          exports.getAssetImageURL = getAssetImageURL;
          exports.getContractAtAddress = getContractAtAddress;
          exports.getRandomFileName = getRandomFileName;
          exports.getURL = getURL;
          exports.getURLHost = getURLHost;
          exports.getURLHostName = getURLHostName;
          exports.isDefaultMetaMaskChain = isDefaultMetaMaskChain;
          exports.isExtensionUrl = isExtensionUrl;
          exports.isNullish = isNullish;
          exports.isOriginContractAddress = isOriginContractAddress;
          exports.isValidDomainName = isValidDomainName;
          exports.numericBalance = numericBalance;
          exports.parseBalance = parseBalance;
          exports.roundToDecimalPlacesRemovingExtraZeroes = roundToDecimalPlacesRemovingExtraZeroes;
          exports.sanitizeMessage = void 0;
          exports.shortenAddress = shortenAddress;
          exports.stripHttpSchemes = stripHttpSchemes;
          exports.stripHttpsScheme = stripHttpsScheme;
          exports.stripHttpsSchemeWithoutPort = stripHttpsSchemeWithoutPort;
          exports.toHumanReadableTime = void 0;
          exports.valuesFor = valuesFor;

          var _punycode = _interopRequireDefault(require("punycode/punycode"));

          var _humanStandardTokenAbi = _interopRequireDefault(require("human-standard-token-abi"));

          var _bignumber = _interopRequireDefault(require("bignumber.js"));

          var ethUtil = _interopRequireWildcard(require("ethereumjs-util"));

          var _luxon = require("luxon");

          var _util = require("@metamask/controllers/dist/util");

          var _slip = _interopRequireDefault(require("@metamask/slip44"));

          var _network = require("../../../shared/constants/network");

          var _hexstringUtils = require("../../../shared/modules/hexstring-utils");

          var _labels = require("../../../shared/constants/labels");

          var _conversion = require("../../../shared/modules/conversion.utils");

          function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

          function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          // formatData :: ( date: <Unix Timestamp> ) -> String
          function formatDate(date, format = "M/d/y 'at' T") {
            if (!date) {
              return '';
            }

            return _luxon.DateTime.fromMillis(date).toFormat(format);
          }

          function formatDateWithYearContext(date, formatThisYear = 'MMM d', fallback = 'MMM d, y') {
            if (!date) {
              return '';
            }

            const dateTime = _luxon.DateTime.fromMillis(date);

            const now = _luxon.DateTime.local();

            return dateTime.toFormat(now.year === dateTime.year ? formatThisYear : fallback);
          }
          /**
           * Determines if the provided chainId is a default MetaMask chain
           *
           * @param {string} chainId - chainId to check
           */


          function isDefaultMetaMaskChain(chainId) {
            if (!chainId || chainId === _network.CHAIN_IDS.MAINNET || chainId === _network.CHAIN_IDS.GOERLI || chainId === _network.CHAIN_IDS.SEPOLIA || chainId === _network.CHAIN_IDS.LOCALHOST) {
              return true;
            }

            return false;
          }

          function valuesFor(obj) {
            if (!obj) {
              return [];
            }

            return Object.keys(obj).map(function (key) {
              return obj[key];
            });
          }

          function addressSummary(address, firstSegLength = 10, lastSegLength = 4, includeHex = true) {
            if (!address) {
              return '';
            }

            let checked = (0, _hexstringUtils.toChecksumHexAddress)(address);

            if (!includeHex) {
              checked = (0, _hexstringUtils.stripHexPrefix)(checked);
            }

            return checked ? `${checked.slice(0, firstSegLength)}...${checked.slice(checked.length - lastSegLength)}` : '...';
          }

          function isValidDomainName(address) {
            const match = _punycode.default.toASCII(address).toLowerCase() // Checks that the domain consists of at least one valid domain pieces separated by periods, followed by a tld
              // Each piece of domain name has only the characters a-z, 0-9, and a hyphen (but not at the start or end of chunk)
              // A chunk has minimum length of 1, but minimum tld is set to 2 for now (no 1-character tlds exist yet)
              .match(/^(?:[a-z0-9](?:[-a-z0-9]*[a-z0-9])?\.)+[a-z0-9][-a-z0-9]*[a-z0-9]$/u);

            return match !== null;
          }

          function isOriginContractAddress(to, sendTokenAddress) {
            if (!to || !sendTokenAddress) {
              return false;
            }

            return to.toLowerCase() === sendTokenAddress.toLowerCase();
          } // Takes wei Hex, returns wei BN, even if input is null


          function numericBalance(balance) {
            if (!balance) {
              return new ethUtil.BN(0, 16);
            }

            const stripped = (0, _hexstringUtils.stripHexPrefix)(balance);
            return new ethUtil.BN(stripped, 16);
          } // Takes  hex, returns [beforeDecimal, afterDecimal]


          function parseBalance(balance) {
            let afterDecimal;
            const wei = numericBalance(balance);
            const weiString = wei.toString();
            const trailingZeros = /0+$/u;
            const beforeDecimal = weiString.length > 18 ? weiString.slice(0, weiString.length - 18) : '0';
            afterDecimal = `000000000000000000${wei}`.slice(-18).replace(trailingZeros, '');

            if (afterDecimal === '') {
              afterDecimal = '0';
            }

            return [beforeDecimal, afterDecimal];
          } // Takes wei hex, returns an object with three properties.
          // Its "formatted" property is what we generally use to render values.


          function formatBalance(balance, decimalsToKeep, needsParse = true, ticker = 'ETH') {
            const parsed = needsParse ? parseBalance(balance) : balance.split('.');
            const beforeDecimal = parsed[0];
            let afterDecimal = parsed[1];
            let formatted = 'None';

            if (decimalsToKeep === undefined) {
              if (beforeDecimal === '0') {
                if (afterDecimal !== '0') {
                  const sigFigs = afterDecimal.match(/^0*(.{2})/u); // default: grabs 2 most significant digits

                  if (sigFigs) {
                    afterDecimal = sigFigs[0];
                  }

                  formatted = `0.${afterDecimal} ${ticker}`;
                }
              } else {
                formatted = `${beforeDecimal}.${afterDecimal.slice(0, 3)} ${ticker}`;
              }
            } else {
              afterDecimal += Array(decimalsToKeep).join('0');
              formatted = `${beforeDecimal}.${afterDecimal.slice(0, decimalsToKeep)} ${ticker}`;
            }

            return formatted;
          }

          function getContractAtAddress(tokenAddress) {
            return global.eth.contract(_humanStandardTokenAbi.default).at(tokenAddress);
          }

          function getRandomFileName() {
            let fileName = '';
            const charBank = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'];
            const fileNameLength = Math.floor(Math.random() * 7 + 6);

            for (let i = 0; i < fileNameLength; i++) {
              fileName += charBank[Math.floor(Math.random() * charBank.length)];
            }

            return fileName;
          }
          /**
           * Shortens an Ethereum address for display, preserving the beginning and end.
           * Returns the given address if it is no longer than 10 characters.
           * Shortened addresses are 13 characters long.
           *
           * Example output: 0xabcd...1234
           *
           * @param {string} address - The address to shorten.
           * @returns {string} The shortened address, or the original if it was no longer
           * than 10 characters.
           */


          function shortenAddress(address = '') {
            if (address.length < _labels.TRUNCATED_NAME_CHAR_LIMIT) {
              return address;
            }

            return `${address.slice(0, _labels.TRUNCATED_ADDRESS_START_CHARS)}...${address.slice(-_labels.TRUNCATED_ADDRESS_END_CHARS)}`;
          }

          function getAccountByAddress(accounts = [], targetAddress) {
            return accounts.find(({
              address
            }) => address === targetAddress);
          }
          /**
           * Strips the following schemes from URL strings:
           * - http
           * - https
           *
           * @param {string} urlString - The URL string to strip the scheme from.
           * @returns {string} The URL string, without the scheme, if it was stripped.
           */


          function stripHttpSchemes(urlString) {
            return urlString.replace(/^https?:\/\//u, '');
          }
          /**
           * Strips the following schemes from URL strings:
           * - https
           *
           * @param {string} urlString - The URL string to strip the scheme from.
           * @returns {string} The URL string, without the scheme, if it was stripped.
           */


          function stripHttpsScheme(urlString) {
            return urlString.replace(/^https:\/\//u, '');
          }
          /**
           * Strips `https` schemes from URL strings, if the URL does not have a port.
           * This is useful
           *
           * @param {string} urlString - The URL string to strip the scheme from.
           * @returns {string} The URL string, without the scheme, if it was stripped.
           */


          function stripHttpsSchemeWithoutPort(urlString) {
            if (getURL(urlString).port) {
              return urlString;
            }

            return stripHttpsScheme(urlString);
          }
          /**
           * Checks whether a URL-like value (object or string) is an extension URL.
           *
           * @param {string | URL | object} urlLike - The URL-like value to test.
           * @returns {boolean} Whether the URL-like value is an extension URL.
           */


          function isExtensionUrl(urlLike) {
            const EXT_PROTOCOLS = ['chrome-extension:', 'moz-extension:'];

            if (typeof urlLike === 'string') {
              for (const protocol of EXT_PROTOCOLS) {
                if (urlLike.startsWith(protocol)) {
                  return true;
                }
              }
            }

            if (urlLike !== null && urlLike !== void 0 && urlLike.protocol) {
              return EXT_PROTOCOLS.includes(urlLike.protocol);
            }

            return false;
          }
          /**
           * Checks whether an address is in a passed list of objects with address properties. The check is performed on the
           * lowercased version of the addresses.
           *
           * @param {string} address - The hex address to check
           * @param {Array} list - The array of objects to check
           * @returns {boolean} Whether or not the address is in the list
           */


          function checkExistingAddresses(address, list = []) {
            if (!address) {
              return false;
            }

            const matchesAddress = obj => {
              return obj.address.toLowerCase() === address.toLowerCase();
            };

            return list.some(matchesAddress);
          }

          function bnGreaterThan(a, b) {
            if (a === null || a === undefined || b === null || b === undefined) {
              return null;
            }

            return new _bignumber.default(a, 10).gt(b, 10);
          }

          function bnLessThan(a, b) {
            if (a === null || a === undefined || b === null || b === undefined) {
              return null;
            }

            return new _bignumber.default(a, 10).lt(b, 10);
          }

          function bnGreaterThanEqualTo(a, b) {
            if (a === null || a === undefined || b === null || b === undefined) {
              return null;
            }

            return new _bignumber.default(a, 10).gte(b, 10);
          }

          function bnLessThanEqualTo(a, b) {
            if (a === null || a === undefined || b === null || b === undefined) {
              return null;
            }

            return new _bignumber.default(a, 10).lte(b, 10);
          }

          function getURL(url) {
            try {
              return new URL(url);
            } catch (err) {
              return '';
            }
          }

          function getURLHost(url) {
            var _getURL;

            return ((_getURL = getURL(url)) === null || _getURL === void 0 ? void 0 : _getURL.host) || '';
          }

          function getURLHostName(url) {
            var _getURL2;

            return ((_getURL2 = getURL(url)) === null || _getURL2 === void 0 ? void 0 : _getURL2.hostname) || '';
          } // Once we reach this threshold, we switch to higher unit


          const MINUTE_CUTOFF = 90 * 60;
          const SECOND_CUTOFF = 90;

          const toHumanReadableTime = (t, milliseconds) => {
            if (milliseconds === undefined || milliseconds === null) {
              return '';
            }

            const seconds = Math.ceil(milliseconds / 1000);

            if (seconds <= SECOND_CUTOFF) {
              return t('gasTimingSecondsShort', [seconds]);
            }

            if (seconds <= MINUTE_CUTOFF) {
              return t('gasTimingMinutesShort', [Math.ceil(seconds / 60)]);
            }

            return t('gasTimingHoursShort', [Math.ceil(seconds / 3600)]);
          };

          exports.toHumanReadableTime = toHumanReadableTime;

          function clearClipboard() {
            window.navigator.clipboard.writeText('');
          }

          const solidityTypes = () => {
            const types = ['bool', 'address', 'string', 'bytes', 'int', 'uint', 'fixed', 'ufixed'];
            const ints = Array.from(new Array(32)).map((_, index) => `int${(index + 1) * 8}`);
            const uints = Array.from(new Array(32)).map((_, index) => `uint${(index + 1) * 8}`);
            const bytes = Array.from(new Array(32)).map((_, index) => `bytes${index + 1}`);
            /**
             * fixed and ufixed
             * This value type also can be declared keywords such as ufixedMxN and fixedMxN.
             * The M represents the amount of bits that the type takes,
             * with N representing the number of decimal points that are available.
             *  M has to be divisible by 8, and a number from 8 to 256.
             * N has to be a value between 0 and 80, also being inclusive.
             */

            const fixedM = Array.from(new Array(32)).map((_, index) => `fixed${(index + 1) * 8}`);
            const ufixedM = Array.from(new Array(32)).map((_, index) => `ufixed${(index + 1) * 8}`);
            const fixed = Array.from(new Array(80)).map((_, index) => fixedM.map(aFixedM => `${aFixedM}x${index + 1}`));
            const ufixed = Array.from(new Array(80)).map((_, index) => ufixedM.map(auFixedM => `${auFixedM}x${index + 1}`));
            return [...types, ...ints, ...uints, ...bytes, ...fixed.flat(), ...ufixed.flat()];
          };

          const sanitizeMessage = (msg, baseType, types) => {
            if (!types) {
              throw new Error(`Invalid types definition`);
            }

            const baseTypeDefinitions = types[baseType];

            if (!baseTypeDefinitions) {
              throw new Error(`Invalid primary type definition`);
            }

            const sanitizedMessage = {};
            const msgKeys = Object.keys(msg);
            msgKeys.forEach(msgKey => {
              const definedType = Object.values(baseTypeDefinitions).find(baseTypeDefinition => baseTypeDefinition.name === msgKey);

              if (!definedType) {
                return;
              } // key has a type. check if the definedType is also a type


              const nestedType = definedType.type.replace(/\[\]$/u, '');
              const nestedTypeDefinition = types[nestedType];

              if (nestedTypeDefinition) {
                if (definedType.type.endsWith('[]') > 0) {
                  // nested array
                  sanitizedMessage[msgKey] = msg[msgKey].map(value => sanitizeMessage(value, nestedType, types));
                } else {
                  // nested object
                  sanitizedMessage[msgKey] = sanitizeMessage(msg[msgKey], definedType.type, types);
                }
              } else {
                // check if it's a valid solidity type
                const isSolidityType = solidityTypes().includes(nestedType);

                if (isSolidityType) {
                  sanitizedMessage[msgKey] = msg[msgKey];
                }
              }
            });
            return sanitizedMessage;
          };

          exports.sanitizeMessage = sanitizeMessage;

          function getAssetImageURL(image, ipfsGateway) {
            if (!image || !ipfsGateway || typeof image !== 'string') {
              return '';
            }

            if (image.startsWith('ipfs://')) {
              return (0, _util.getFormattedIpfsUrl)(ipfsGateway, image, true);
            }

            return image;
          }

          function roundToDecimalPlacesRemovingExtraZeroes(numberish, numberOfDecimalPlaces) {
            if (numberish === undefined || numberish === null) {
              return '';
            }

            return _conversion.toBigNumber.dec(_conversion.toBigNumber.dec(numberish).toFixed(numberOfDecimalPlaces)).toNumber();
          }
          /**
           * Gets the name of the SLIP-44 protocol corresponding to the specified
           * `coin_type`.
           *
           * @param {string | number} coinType - The SLIP-44 `coin_type` value whose name
           * to retrieve.
           * @returns {string | undefined} The name of the protocol if found.
           */


          function coinTypeToProtocolName(coinType) {
            var _slip44$coinType;

            if (String(coinType) === '1') {
              return 'Test Networks';
            }

            return ((_slip44$coinType = _slip.default[coinType]) === null || _slip44$coinType === void 0 ? void 0 : _slip44$coinType.name) || undefined;
          }
          /**
           * Tests "nullishness". Used to guard a section of a component from being
           * rendered based on a value.
           *
           * @param {any} value - A value (literally anything).
           * @returns `true` if the value is null or undefined, `false` otherwise.
           */


          function isNullish(value) {
            return value === null || value === undefined;
          }


        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\add-ethereum-chain.js", { "../../../../shared/constants/network": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\network.ts", "../../../../shared/lib/fetch-with-cache": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\fetch-with-cache.js", "../../../helpers/constants/design-system": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\design-system.js", "../../../helpers/constants/routes": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\routes.js", "../../../helpers/constants/zendesk-url": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\zendesk-url.js", "eth-rpc-errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js", "react": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\react\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\confirmation\templates\add-ethereum-chain.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _ethRpcErrors = require("eth-rpc-errors");

          var _react = _interopRequireDefault(require("react"));

          var _network = require("../../../../shared/constants/network");

          var _designSystem = require("../../../helpers/constants/design-system");

          var _routes = require("../../../helpers/constants/routes");

          var _zendeskUrl = _interopRequireDefault(require("../../../helpers/constants/zendesk-url"));

          var _fetchWithCache = _interopRequireDefault(require("../../../../shared/lib/fetch-with-cache"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          const UNRECOGNIZED_CHAIN = {
            id: 'UNRECOGNIZED_CHAIN',
            severity: _designSystem.SEVERITIES.WARNING,
            content: {
              element: 'span',
              children: {
                element: 'MetaMaskTranslation',
                props: {
                  translationKey: 'unrecognizedChain'
                }
              }
            }
          };
          const MISMATCHED_CHAIN_RECOMMENDATION = {
            id: 'MISMATCHED_CHAIN_RECOMMENDATION',
            content: {
              element: 'span',
              children: {
                element: 'MetaMaskTranslation',
                props: {
                  translationKey: 'mismatchedChainRecommendation',
                  variables: [{
                    element: 'a',
                    key: 'mismatchedChainLink',
                    props: {
                      href: _zendeskUrl.default.VERIFY_CUSTOM_NETWORK,
                      target: '__blank',
                      tabIndex: 0
                    },
                    children: {
                      element: 'MetaMaskTranslation',
                      props: {
                        translationKey: 'mismatchedChainLinkText'
                      }
                    }
                  }]
                }
              }
            }
          };
          const MISMATCHED_NETWORK_NAME = {
            id: 'MISMATCHED_NETWORK_NAME',
            severity: _designSystem.SEVERITIES.WARNING,
            content: {
              element: 'span',
              children: {
                element: 'MetaMaskTranslation',
                props: {
                  translationKey: 'mismatchedNetworkName'
                }
              }
            }
          };
          const MISMATCHED_NETWORK_SYMBOL = {
            id: 'MISMATCHED_NETWORK_SYMBOL',
            severity: _designSystem.SEVERITIES.DANGER,
            content: {
              element: 'span',
              children: {
                element: 'MetaMaskTranslation',
                props: {
                  translationKey: 'mismatchedNetworkSymbol'
                }
              }
            }
          };
          const MISMATCHED_NETWORK_RPC = {
            id: 'MISMATCHED_NETWORK_RPC',
            severity: _designSystem.SEVERITIES.DANGER,
            content: {
              element: 'span',
              children: {
                element: 'MetaMaskTranslation',
                props: {
                  translationKey: 'mismatchedRpcUrl'
                }
              }
            }
          };

          async function getAlerts(pendingApproval) {
            const alerts = [];
            const safeChainsList = (await (0, _fetchWithCache.default)('https://chainid.network/chains.json')) || [];
            const matchedChain = safeChainsList.find(chain => chain.chainId === parseInt(pendingApproval.requestData.chainId, 16));
            const originIsMetaMask = pendingApproval.origin === 'metamask';

            if (originIsMetaMask && Boolean(matchedChain)) {
              return [];
            }

            if (matchedChain) {
              var _matchedChain$nativeC;

              if (matchedChain.name.toLowerCase() !== pendingApproval.requestData.chainName.toLowerCase()) {
                alerts.push(MISMATCHED_NETWORK_NAME);
              }

              if (((_matchedChain$nativeC = matchedChain.nativeCurrency) === null || _matchedChain$nativeC === void 0 ? void 0 : _matchedChain$nativeC.symbol) !== pendingApproval.requestData.ticker) {
                alerts.push(MISMATCHED_NETWORK_SYMBOL);
              }

              const {
                origin
              } = new URL(pendingApproval.requestData.rpcUrl);

              if (!matchedChain.rpc.map(rpc => new URL(rpc).origin).includes(origin)) {
                alerts.push(MISMATCHED_NETWORK_RPC);
              }
            }

            if (!matchedChain) {
              alerts.push(UNRECOGNIZED_CHAIN);
            }

            if (alerts.length) {
              alerts.push(MISMATCHED_CHAIN_RECOMMENDATION);
            }

            return alerts;
          }

          function getValues(pendingApproval, t, actions, history) {
            var _pendingApproval$requ;

            const originIsMetaMask = pendingApproval.origin === 'metamask';
            return {
              content: [{
                hide: !originIsMetaMask,
                element: 'Box',
                key: 'network-box',
                props: {
                  textAlign: _designSystem.TEXT_ALIGN.CENTER,
                  display: _designSystem.DISPLAY.FLEX,
                  justifyContent: _designSystem.JUSTIFY_CONTENT.CENTER,
                  marginTop: 4,
                  marginBottom: 2
                },
                children: [{
                  element: 'Chip',
                  key: 'network-chip',
                  props: {
                    label: pendingApproval.requestData.chainName,
                    backgroundColor: _designSystem.COLORS.BACKGROUND_ALTERNATIVE,
                    leftIconUrl: pendingApproval.requestData.imageUrl
                  }
                }]
              }, {
                element: 'Typography',
                key: 'title',
                children: originIsMetaMask ? t('wantToAddThisNetwork') : t('addEthereumChainConfirmationTitle'),
                props: {
                  variant: _designSystem.TYPOGRAPHY.H3,
                  align: 'center',
                  fontWeight: 'bold',
                  boxProps: {
                    margin: [0, 0, 4]
                  }
                }
              }, {
                element: 'Typography',
                key: 'description',
                children: t('addEthereumChainConfirmationDescription'),
                props: {
                  variant: _designSystem.TYPOGRAPHY.H7,
                  align: 'center',
                  boxProps: {
                    margin: originIsMetaMask ? [0, 8, 4] : [0, 0, 4]
                  }
                }
              }, {
                element: 'Typography',
                key: 'only-add-networks-you-trust',
                children: [{
                  element: 'b',
                  key: 'bolded-text',
                  props: {
                    style: {
                      display: originIsMetaMask && '-webkit-box'
                    }
                  },
                  children: [`${t('addEthereumChainConfirmationRisks')} `, {
                    hide: !originIsMetaMask,
                    element: 'Tooltip',
                    key: 'tooltip-info',
                    props: {
                      position: 'bottom',
                      interactive: true,
                      trigger: 'mouseenter',
                      html: /*#__PURE__*/_react.default.createElement("div", {
                        style: {
                          width: '180px',
                          margin: '16px',
                          textAlign: 'left'
                        }
                      }, t('someNetworksMayPoseSecurity'), ' ', /*#__PURE__*/_react.default.createElement("a", {
                        key: "zendesk_page_link",
                        href: _zendeskUrl.default.UNKNOWN_NETWORK,
                        rel: "noreferrer",
                        target: "_blank",
                        style: {
                          color: 'var(--color-primary-default)'
                        }
                      }, t('learnMoreUpperCase')))
                    },
                    children: [{
                      element: 'i',
                      key: 'info-circle',
                      props: {
                        className: 'fas fa-info-circle',
                        style: {
                          marginLeft: '4px',
                          color: 'var(--color-icon-default)'
                        }
                      }
                    }]
                  }]
                }, {
                  element: 'MetaMaskTranslation',
                  key: 'learn-about-risks',
                  props: {
                    translationKey: 'addEthereumChainConfirmationRisksLearnMore',
                    variables: [{
                      element: 'a',
                      children: t('addEthereumChainConfirmationRisksLearnMoreLink'),
                      key: 'addEthereumChainConfirmationRisksLearnMoreLink',
                      props: {
                        href: _zendeskUrl.default.USER_GUIDE_CUSTOM_NETWORKS,
                        target: '__blank'
                      }
                    }]
                  }
                }],
                props: {
                  variant: _designSystem.TYPOGRAPHY.H7,
                  boxProps: {
                    margin: originIsMetaMask ? [0, 8] : 0,
                    display: _designSystem.DISPLAY.FLEX,
                    flexDirection: _designSystem.FLEX_DIRECTION.COLUMN,
                    alignItems: _designSystem.ALIGN_ITEMS.CENTER
                  }
                }
              }, {
                element: 'TruncatedDefinitionList',
                key: 'network-details',
                props: {
                  title: t('networkDetails'),
                  tooltips: {
                    [t('networkName')]: t('networkNameDefinition'),
                    [t('networkURL')]: t('networkURLDefinition'),
                    [t('chainId')]: t('chainIdDefinition'),
                    [t('currencySymbol')]: t('currencySymbolDefinition'),
                    [t('blockExplorerUrl')]: t('blockExplorerUrlDefinition')
                  },
                  dictionary: {
                    [t('networkName')]: pendingApproval.requestData.chainName,
                    [t('networkURL')]: (_pendingApproval$requ = pendingApproval.requestData.rpcUrl) !== null && _pendingApproval$requ !== void 0 && _pendingApproval$requ.includes(`/v3/${_network.infuraProjectId}`) ? pendingApproval.requestData.rpcUrl.replace(`/v3/${_network.infuraProjectId}`, '') : pendingApproval.requestData.rpcUrl,
                    [t('chainId')]: parseInt(pendingApproval.requestData.chainId, 16),
                    [t('currencySymbol')]: pendingApproval.requestData.ticker,
                    [t('blockExplorerUrl')]: pendingApproval.requestData.blockExplorerUrl
                  },
                  prefaceKeys: [t('networkName'), t('networkURL'), t('chainId'), t('currencySymbol')]
                }
              }],
              approvalText: t('approveButtonText'),
              cancelText: t('cancel'),
              onApprove: async () => {
                await actions.resolvePendingApproval(pendingApproval.id, pendingApproval.requestData);

                if (originIsMetaMask) {
                  actions.addCustomNetwork(pendingApproval.requestData);
                  history.push(_routes.DEFAULT_ROUTE);
                }
              },
              onCancel: () => actions.rejectPendingApproval(pendingApproval.id, _ethRpcErrors.ethErrors.provider.userRejectedRequest().serialize()),
              networkDisplay: !originIsMetaMask
            };
          }

          const addEthereumChain = {
            getAlerts,
            getValues
          };
          var _default = addEthereumChain;
          exports.default = _default;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\index.js", { "../../../../shared/constants/app": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\app.ts", "../../../store/actions": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\store\\actions.js", "./add-ethereum-chain": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\add-ethereum-chain.js", "./switch-ethereum-chain": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\switch-ethereum-chain.js", "lodash": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\lodash\\lodash.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\confirmation\templates\index.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TEMPLATED_CONFIRMATION_MESSAGE_TYPES = void 0;
          exports.getTemplateAlerts = getTemplateAlerts;
          exports.getTemplateState = getTemplateState;
          exports.getTemplateValues = getTemplateValues;

          var _lodash = require("lodash");

          var _app = require("../../../../shared/constants/app");

          var _actions = require("../../../store/actions");

          var _addEthereumChain = _interopRequireDefault(require("./add-ethereum-chain"));

          var _switchEthereumChain = _interopRequireDefault(require("./switch-ethereum-chain"));

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          const APPROVAL_TEMPLATES = {
            [_app.MESSAGE_TYPE.ADD_ETHEREUM_CHAIN]: _addEthereumChain.default,
            [_app.MESSAGE_TYPE.SWITCH_ETHEREUM_CHAIN]: _switchEthereumChain.default
          };
          const TEMPLATED_CONFIRMATION_MESSAGE_TYPES = Object.keys(APPROVAL_TEMPLATES);
          exports.TEMPLATED_CONFIRMATION_MESSAGE_TYPES = TEMPLATED_CONFIRMATION_MESSAGE_TYPES;
          const ALLOWED_TEMPLATE_KEYS = ['content', 'approvalText', 'cancelText', 'onApprove', 'onCancel', 'networkDisplay'];
          /**
           * @typedef {object} PendingApproval
           * @property {string} id - The randomly generated id of the approval
           * @property {string} origin - The origin of the site requesting this approval
           * @property {number} time - The time the approval was requested
           * @property {string} type - The type of approval being requested
           * @property {object} requestData - The data submitted with the request
           */

          /**
           * getTemplateAlerts calls the getAlerts function exported by the template if
           * it exists, and then returns the result of that function. In the confirmation
           * page the alerts returned from the getAlerts method will be set into the
           * alertState state object.
           *
           * @param {object} pendingApproval - the object representing the confirmation
           */

          async function getTemplateAlerts(pendingApproval) {
            var _APPROVAL_TEMPLATES$p;

            const fn = (_APPROVAL_TEMPLATES$p = APPROVAL_TEMPLATES[pendingApproval.type]) === null || _APPROVAL_TEMPLATES$p === void 0 ? void 0 : _APPROVAL_TEMPLATES$p.getAlerts;
            const results = fn ? await fn(pendingApproval) : [];

            if (!Array.isArray(results)) {
              throw new Error(`Template alerts must be an array, received: ${results}`);
            }

            if (results.some(result => (result === null || result === void 0 ? void 0 : result.id) === undefined)) {
              throw new Error(`Template alert entries must be objects with an id key. Received: ${results}`);
            }

            return results;
          }
          /**
           * The function call to return state must be a promise returning function
           * this "NOOP" is here to conform to the requirements for templates without
           * state.
           */


          async function emptyState() {
            return {};
          }
          /**
           * getTemplateState calls the getState function exported by the template if
           * it exists, and then returns the result of that function. In the confirmation
           * page the object returned from the getState method will be set into the
           * confirmationState state object. Note, this state is not consumed by the page
           * itself.
           *
           * @param {object} pendingApproval - the object representing the confirmation
           */


          async function getTemplateState(pendingApproval) {
            var _APPROVAL_TEMPLATES$p2, _APPROVAL_TEMPLATES$p3;

            const fn = (_APPROVAL_TEMPLATES$p2 = (_APPROVAL_TEMPLATES$p3 = APPROVAL_TEMPLATES[pendingApproval.type]) === null || _APPROVAL_TEMPLATES$p3 === void 0 ? void 0 : _APPROVAL_TEMPLATES$p3.getState) !== null && _APPROVAL_TEMPLATES$p2 !== void 0 ? _APPROVAL_TEMPLATES$p2 : emptyState;
            const result = await fn(pendingApproval);

            if (typeof result !== 'object' || Array.isArray(result)) {
              throw new Error(`Template state must be an object, received: ${result}`);
            } else if (result === null || result === undefined) {
              return {};
            }

            return result;
          }
          /**
           * We do not want to pass the entire dispatch function to the template.
           * This function should return an object of actions that we generally consider
           * to be safe for templates to invoke. In the future we could put these behind
           * permission sets so that snaps that wish to manipulate state must ask for
           * explicit permission to do so.
           *
           * @param {Function} dispatch - Redux dispatch function
           */


          function getAttenuatedDispatch(dispatch) {
            return {
              rejectPendingApproval: (...args) => dispatch((0, _actions.rejectPendingApproval)(...args)),
              resolvePendingApproval: (...args) => dispatch((0, _actions.resolvePendingApproval)(...args)),
              addCustomNetwork: (...args) => dispatch((0, _actions.addCustomNetwork)(...args))
            };
          }
          /**
           * Returns the templated values to be consumed in the confirmation page
           *
           * @param {object} pendingApproval - The pending confirmation object
           * @param {Function} t - Translation function
           * @param {Function} dispatch - Redux dispatch function
           * @param history
           */


          function getTemplateValues(pendingApproval, t, dispatch, history) {
            var _APPROVAL_TEMPLATES$p4;

            const fn = (_APPROVAL_TEMPLATES$p4 = APPROVAL_TEMPLATES[pendingApproval.type]) === null || _APPROVAL_TEMPLATES$p4 === void 0 ? void 0 : _APPROVAL_TEMPLATES$p4.getValues;

            if (!fn) {
              throw new Error(`MESSAGE_TYPE: '${pendingApproval.type}' is not specified in approval templates`);
            }

            const safeActions = getAttenuatedDispatch(dispatch);
            const values = fn(pendingApproval, t, safeActions, history);
            const extraneousKeys = (0, _lodash.omit)(values, ALLOWED_TEMPLATE_KEYS);
            const safeValues = (0, _lodash.pick)(values, ALLOWED_TEMPLATE_KEYS);

            if (extraneousKeys.length > 0) {
              throw new Error(`Received extraneous keys from ${pendingApproval.type}.getValues. These keys are not passed to the confirmation page: ${Object.keys(extraneousKeys)}`);
            }

            return safeValues;
          }

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\confirmation\\templates\\switch-ethereum-chain.js", { "../../../helpers/constants/design-system": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\helpers\\constants\\design-system.js", "eth-rpc-errors": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\eth-rpc-errors\\dist\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\confirmation\templates\switch-ethereum-chain.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.default = void 0;

          var _ethRpcErrors = require("eth-rpc-errors");

          var _designSystem = require("../../../helpers/constants/design-system");

          const PENDING_TX_DROP_NOTICE = {
            id: 'PENDING_TX_DROP_NOTICE',
            severity: _designSystem.SEVERITIES.WARNING,
            content: {
              element: 'span',
              children: {
                element: 'MetaMaskTranslation',
                props: {
                  translationKey: 'switchingNetworksCancelsPendingConfirmations'
                }
              }
            }
          };

          async function getAlerts() {
            return [PENDING_TX_DROP_NOTICE];
          }

          function getValues(pendingApproval, t, actions) {
            return {
              content: [{
                element: 'Typography',
                key: 'title',
                children: t('switchEthereumChainConfirmationTitle'),
                props: {
                  variant: _designSystem.TYPOGRAPHY.H3,
                  align: 'center',
                  fontWeight: 'normal',
                  boxProps: {
                    margin: [0, 0, 2],
                    padding: [0, 4, 0, 4]
                  }
                }
              }, {
                element: 'Typography',
                key: 'description',
                children: t('switchEthereumChainConfirmationDescription'),
                props: {
                  variant: _designSystem.TYPOGRAPHY.H7,
                  color: _designSystem.COLORS.TEXT_ALTERNATIVE,
                  align: 'center',
                  boxProps: {
                    padding: [0, 4, 0, 4]
                  }
                }
              }, {
                element: 'Box',
                key: 'status-box',
                props: {
                  justifyContent: _designSystem.JUSTIFY_CONTENT.CENTER
                },
                children: {
                  element: 'ConfirmationNetworkSwitch',
                  key: 'network-being-switched',
                  props: {
                    newNetwork: {
                      chainId: pendingApproval.requestData.chainId,
                      name: pendingApproval.requestData.nickname
                    }
                  }
                }
              }],
              approvalText: t('switchNetwork'),
              cancelText: t('cancel'),
              onApprove: () => actions.resolvePendingApproval(pendingApproval.id, pendingApproval.requestData),
              onCancel: () => actions.rejectPendingApproval(pendingApproval.id, _ethRpcErrors.ethErrors.provider.userRejectedRequest().serialize()),
              networkDisplay: true
            };
          }

          const switchEthereumChain = {
            getAlerts,
            getValues
          };
          var _default = switchEthereumChain;
          exports.default = _default;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js", { "../../../app/scripts/lib/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js", "../../../shared/constants/gas": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\gas.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\send\send.constants.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.TOKEN_TRANSFER_FUNCTION_SIGNATURE = exports.REQUIRED_ERROR = exports.RECIPIENT_TYPES = exports.NEGATIVE_ETH_ERROR = exports.MIN_GAS_TOTAL = exports.MIN_GAS_PRICE_HEX = exports.MIN_GAS_PRICE_GWEI = exports.MIN_GAS_PRICE_DEC = exports.MIN_GAS_LIMIT_DEC = exports.MAX_GAS_LIMIT_DEC = exports.KNOWN_RECIPIENT_ADDRESS_WARNING = exports.INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR = exports.INVALID_RECIPIENT_ADDRESS_ERROR = exports.INSUFFICIENT_TOKENS_ERROR = exports.INSUFFICIENT_FUNDS_ERROR = exports.HIGH_FEE_WARNING_MULTIPLIER = exports.ENS_UNKNOWN_ERROR = exports.ENS_REGISTRATION_ERROR = exports.ENS_NO_ADDRESS_FOR_NAME = exports.ENS_NOT_SUPPORTED_ON_NETWORK = exports.ENS_NOT_FOUND_ON_NETWORK = exports.ENS_ILLEGAL_CHARACTER = exports.CONTRACT_ADDRESS_ERROR = exports.CONFUSING_ENS_ERROR = exports.COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE = void 0;

          var _conversion = require("../../../shared/modules/conversion.utils");

          var _util = require("../../../app/scripts/lib/util");

          var _gas = require("../../../shared/constants/gas");

          const MIN_GAS_PRICE_DEC = '0';
          exports.MIN_GAS_PRICE_DEC = MIN_GAS_PRICE_DEC;
          const MIN_GAS_PRICE_HEX = parseInt(MIN_GAS_PRICE_DEC, 10).toString(16);
          exports.MIN_GAS_PRICE_HEX = MIN_GAS_PRICE_HEX;
          const MIN_GAS_LIMIT_DEC = '21000';
          exports.MIN_GAS_LIMIT_DEC = MIN_GAS_LIMIT_DEC;
          const MAX_GAS_LIMIT_DEC = '7920027';
          exports.MAX_GAS_LIMIT_DEC = MAX_GAS_LIMIT_DEC;
          const HIGH_FEE_WARNING_MULTIPLIER = 1.5;
          exports.HIGH_FEE_WARNING_MULTIPLIER = HIGH_FEE_WARNING_MULTIPLIER;
          const MIN_GAS_PRICE_GWEI = (0, _util.addHexPrefix)((0, _conversion.conversionUtil)(MIN_GAS_PRICE_HEX, {
            fromDenomination: 'WEI',
            toDenomination: 'GWEI',
            fromNumericBase: 'hex',
            toNumericBase: 'hex',
            numberOfDecimals: 1
          }));
          exports.MIN_GAS_PRICE_GWEI = MIN_GAS_PRICE_GWEI;
          const MIN_GAS_TOTAL = (0, _conversion.multiplyCurrencies)(_gas.MIN_GAS_LIMIT_HEX, MIN_GAS_PRICE_HEX, {
            toNumericBase: 'hex',
            multiplicandBase: 16,
            multiplierBase: 16
          });
          exports.MIN_GAS_TOTAL = MIN_GAS_TOTAL;
          const TOKEN_TRANSFER_FUNCTION_SIGNATURE = '0xa9059cbb';
          exports.TOKEN_TRANSFER_FUNCTION_SIGNATURE = TOKEN_TRANSFER_FUNCTION_SIGNATURE;
          const COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE = '0x23b872dd';
          exports.COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE = COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE;
          const INSUFFICIENT_FUNDS_ERROR = 'insufficientFunds';
          exports.INSUFFICIENT_FUNDS_ERROR = INSUFFICIENT_FUNDS_ERROR;
          const INSUFFICIENT_TOKENS_ERROR = 'insufficientTokens';
          exports.INSUFFICIENT_TOKENS_ERROR = INSUFFICIENT_TOKENS_ERROR;
          const NEGATIVE_ETH_ERROR = 'negativeETH';
          exports.NEGATIVE_ETH_ERROR = NEGATIVE_ETH_ERROR;
          const INVALID_RECIPIENT_ADDRESS_ERROR = 'invalidAddressRecipient';
          exports.INVALID_RECIPIENT_ADDRESS_ERROR = INVALID_RECIPIENT_ADDRESS_ERROR;
          const INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR = 'invalidAddressRecipientNotEthNetwork';
          exports.INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR = INVALID_RECIPIENT_ADDRESS_NOT_ETH_NETWORK_ERROR;
          const REQUIRED_ERROR = 'required';
          exports.REQUIRED_ERROR = REQUIRED_ERROR;
          const KNOWN_RECIPIENT_ADDRESS_WARNING = 'knownAddressRecipient';
          exports.KNOWN_RECIPIENT_ADDRESS_WARNING = KNOWN_RECIPIENT_ADDRESS_WARNING;
          const CONTRACT_ADDRESS_ERROR = 'contractAddressError';
          exports.CONTRACT_ADDRESS_ERROR = CONTRACT_ADDRESS_ERROR;
          const CONFUSING_ENS_ERROR = 'confusingEnsDomain';
          exports.CONFUSING_ENS_ERROR = CONFUSING_ENS_ERROR;
          const ENS_NO_ADDRESS_FOR_NAME = 'noAddressForName';
          exports.ENS_NO_ADDRESS_FOR_NAME = ENS_NO_ADDRESS_FOR_NAME;
          const ENS_NOT_FOUND_ON_NETWORK = 'ensNotFoundOnCurrentNetwork';
          exports.ENS_NOT_FOUND_ON_NETWORK = ENS_NOT_FOUND_ON_NETWORK;
          const ENS_NOT_SUPPORTED_ON_NETWORK = 'ensNotSupportedOnNetwork';
          exports.ENS_NOT_SUPPORTED_ON_NETWORK = ENS_NOT_SUPPORTED_ON_NETWORK;
          const ENS_ILLEGAL_CHARACTER = 'ensIllegalCharacter';
          exports.ENS_ILLEGAL_CHARACTER = ENS_ILLEGAL_CHARACTER;
          const ENS_UNKNOWN_ERROR = 'ensUnknownError';
          exports.ENS_UNKNOWN_ERROR = ENS_UNKNOWN_ERROR;
          const ENS_REGISTRATION_ERROR = 'ensRegistrationError';
          exports.ENS_REGISTRATION_ERROR = ENS_REGISTRATION_ERROR;
          const RECIPIENT_TYPES = {
            SMART_CONTRACT: 'SMART_CONTRACT',
            NON_CONTRACT: 'NON_CONTRACT'
          };
          exports.RECIPIENT_TYPES = RECIPIENT_TYPES;

        };
      };
    }
  }, { package: "$root$", }],
  ["C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.utils.js", { "../../../app/scripts/lib/util": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\app\\scripts\\lib\\util.js", "../../../shared/constants/transaction": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\constants\\transaction.js", "../../../shared/lib/transactions-controller-utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\lib\\transactions-controller-utils.js", "../../../shared/modules/conversion.utils": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\shared\\modules\\conversion.utils.js", "./send.constants": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\ui\\pages\\send\\send.constants.js", "ethereumjs-abi": "C:\\a_repos\\0_game7\\hyperplay\\metamask-extension\\node_modules\\ethereumjs-abi\\index.js" }, function () {
    with (this) {
      return function () {
        'use strict';
        // source: C:\a_repos\0_game7\hyperplay\metamask-extension\ui\pages\send\send.utils.js
        return function (require, module, exports) {
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.addGasBuffer = addGasBuffer;
          exports.ellipsify = ellipsify;
          exports.generateERC20TransferData = generateERC20TransferData;
          exports.generateERC721TransferData = generateERC721TransferData;
          exports.getAssetTransferData = getAssetTransferData;
          exports.isBalanceSufficient = isBalanceSufficient;
          exports.isTokenBalanceSufficient = isTokenBalanceSufficient;

          var _ethereumjsAbi = _interopRequireDefault(require("ethereumjs-abi"));

          var _conversion = require("../../../shared/modules/conversion.utils");

          var _util = require("../../../app/scripts/lib/util");

          var _transaction = require("../../../shared/constants/transaction");

          var _transactionsControllerUtils = require("../../../shared/lib/transactions-controller-utils");

          var _send = require("./send.constants");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          function isBalanceSufficient({
            amount = '0x0',
            balance = '0x0',
            conversionRate = 1,
            gasTotal = '0x0',
            primaryCurrency
          }) {
            const totalAmount = (0, _conversion.addCurrencies)(amount, gasTotal, {
              aBase: 16,
              bBase: 16,
              toNumericBase: 'hex'
            });
            const balanceIsSufficient = (0, _conversion.conversionGTE)({
              value: balance,
              fromNumericBase: 'hex',
              fromCurrency: primaryCurrency,
              conversionRate
            }, {
              value: totalAmount,
              fromNumericBase: 'hex',
              conversionRate,
              fromCurrency: primaryCurrency
            });
            return balanceIsSufficient;
          }

          function isTokenBalanceSufficient({
            amount = '0x0',
            tokenBalance,
            decimals
          }) {
            const amountInDec = (0, _conversion.conversionUtil)(amount, {
              fromNumericBase: 'hex'
            });
            const tokenBalanceIsSufficient = (0, _conversion.conversionGTE)({
              value: tokenBalance,
              fromNumericBase: 'hex'
            }, {
              value: (0, _transactionsControllerUtils.calcTokenAmount)(amountInDec, decimals)
            });
            return tokenBalanceIsSufficient;
          }

          function addGasBuffer(initialGasLimitHex, blockGasLimitHex, bufferMultiplier = 1.5) {
            const upperGasLimit = (0, _conversion.multiplyCurrencies)(blockGasLimitHex, 0.9, {
              toNumericBase: 'hex',
              multiplicandBase: 16,
              multiplierBase: 10,
              numberOfDecimals: '0'
            });
            const bufferedGasLimit = (0, _conversion.multiplyCurrencies)(initialGasLimitHex, bufferMultiplier, {
              toNumericBase: 'hex',
              multiplicandBase: 16,
              multiplierBase: 10,
              numberOfDecimals: '0'
            }); // if initialGasLimit is above blockGasLimit, dont modify it

            if ((0, _conversion.conversionGreaterThan)({
              value: initialGasLimitHex,
              fromNumericBase: 'hex'
            }, {
              value: upperGasLimit,
              fromNumericBase: 'hex'
            })) {
              return initialGasLimitHex;
            } // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit


            if ((0, _conversion.conversionLessThan)({
              value: bufferedGasLimit,
              fromNumericBase: 'hex'
            }, {
              value: upperGasLimit,
              fromNumericBase: 'hex'
            })) {
              return bufferedGasLimit;
            } // otherwise use blockGasLimit


            return upperGasLimit;
          }

          function generateERC20TransferData({
            toAddress = '0x0',
            amount = '0x0',
            sendToken
          }) {
            if (!sendToken) {
              return undefined;
            }

            return _send.TOKEN_TRANSFER_FUNCTION_SIGNATURE + Array.prototype.map.call(_ethereumjsAbi.default.rawEncode(['address', 'uint256'], [(0, _util.addHexPrefix)(toAddress), (0, _util.addHexPrefix)(amount)]), x => `00${x.toString(16)}`.slice(-2)).join('');
          }

          function generateERC721TransferData({
            toAddress = '0x0',
            fromAddress = '0x0',
            tokenId
          }) {
            if (!tokenId) {
              return undefined;
            }

            return _send.COLLECTIBLE_TRANSFER_FROM_FUNCTION_SIGNATURE + Array.prototype.map.call(_ethereumjsAbi.default.rawEncode(['address', 'address', 'uint256'], [(0, _util.addHexPrefix)(fromAddress), (0, _util.addHexPrefix)(toAddress), tokenId]), x => `00${x.toString(16)}`.slice(-2)).join('');
          }

          function getAssetTransferData({
            sendToken,
            fromAddress,
            toAddress,
            amount
          }) {
            switch (sendToken.standard) {
              case _transaction.ERC721:
                return generateERC721TransferData({
                  toAddress,
                  fromAddress,
                  tokenId: sendToken.tokenId
                });

              case _transaction.ERC20:
              default:
                return generateERC20TransferData({
                  toAddress,
                  amount,
                  sendToken
                });
            }
          }

          function ellipsify(text, first = 6, last = 4) {
            return `${text.slice(0, first)}...${text.slice(-last)}`;
          }

        };
      };
    }
  }, { package: "$root$", }]], [], {})

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy91dWlkL2Rpc3QvdmFsaWRhdGUuanMiLCJub2RlX21vZHVsZXMvdXVpZC9kaXN0L3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvdmFsaWQtdXJsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3ZtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ibG9jay10cmFja2VyL3NyYy9iYXNlLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGgtYmxvY2stdHJhY2tlci9zcmMvcG9sbGluZy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvYmxvY2stY2FjaGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2NhY2hlLXV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGgtanNvbi1ycGMtbWlkZGxld2FyZS9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLWpzb24tcnBjLW1pZGRsZXdhcmUvaW5mbGlnaHQtY2FjaGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGgtcnBjLWVycm9ycy9zcmMvY2xhc3Nlcy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvc3JjL2Vycm9yQ29kZXMuanNvbiIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLXJwYy1lcnJvcnMvc3JjL2Vycm9yVmFsdWVzLmpzb24iLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL3NyYy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aC1ycGMtZXJyb3JzL3NyYy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoLXNpZy11dGlsL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvZXRoZXJldW1qcy11dGlsL2Rpc3Qvc2VjcDI1NmsxLWFkYXB0ZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL2V0aGVyZXVtanMtdXRpbC9kaXN0L3NlY3AyNTZrMS1saWIvZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGhlcmV1bWpzLXV0aWwvZGlzdC9zZWNwMjU2azEtbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL25vZGVfbW9kdWxlcy9ldGhqcy11dGlsL2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9ub2RlX21vZHVsZXMvanNvbi1ycGMtZW5naW5lL3NyYy9jcmVhdGVBc3luY01pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvbm9kZV9tb2R1bGVzL3BpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvcGFja2FnZS5qc29uIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9jYWNoZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvZGVmYXVsdC1maXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9mZXRjaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvZmlsdGVycy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvZml4dHVyZS5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvaG9va2VkLXdhbGxldC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvaW5mbGlnaHQtY2FjaGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL2luZnVyYS5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS9zdWJwcm92aWRlcnMvanNvbi1ycGMtZW5naW5lLW1pZGRsZXdhcmUuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL25vbmNlLXRyYWNrZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL3Byb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9zYW5pdGl6ZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvc3VicHJvdmlkZXJzL3N1YnByb3ZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy9zdWJzY3JpcHRpb25zLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMtcHJvdmlkZXItZW5naW5lL3N1YnByb3ZpZGVycy93ZWJzb2NrZXQuanMiLCJub2RlX21vZHVsZXMvd2ViMy1wcm92aWRlci1lbmdpbmUvdXRpbC9jcmVhdGUtcGF5bG9hZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL2VzdGltYXRlLWdhcy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL3JhbmRvbS1pZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL3JwYy1jYWNoZS11dGlscy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS91dGlsL3N0b3BsaWdodC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzLXByb3ZpZGVyLWVuZ2luZS96ZXJvLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL0dsb2JhbFJlZ2lzdHJhci5qc29uIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL2NvbnRyYWN0cy9JQ0FQUmVnaXN0cmFyLmpzb24iLCJub2RlX21vZHVsZXMvd2ViMy9saWIvY29udHJhY3RzL1NtYXJ0RXhjaGFuZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS9hZGRyZXNzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Jvb2wuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvYnl0ZXMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvY29kZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvZHluYW1pY2J5dGVzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L2Zvcm1hdHRlcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvaW50LmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3BhcmFtLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3JlYWwuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvc3RyaW5nLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3NvbGlkaXR5L3R5cGUuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvc29saWRpdHkvdWludC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi9zb2xpZGl0eS91cmVhbC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9icm93c2VyLXhoci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy9jb25maWcuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvdXRpbHMvc2hhMy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi91dGlscy91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi92ZXJzaW9uLmpzb24iLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2FsbGV2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2JhdGNoLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvY29udHJhY3QuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9lcnJvcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9ldmVudC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2V4dGVuZC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2ZpbHRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2Zvcm1hdHRlcnMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9mdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2h0dHBwcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2liYW4uanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9pcGNwcm92aWRlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL2pzb25ycGMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2QuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL2RiLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvbWV0aG9kcy9ldGguanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL25ldC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvcGVyc29uYWwuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3NoaC5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL21ldGhvZHMvc3dhcm0uanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9tZXRob2RzL3dhdGNoZXMuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9uYW1lcmVnLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvcHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvd2ViMy9saWIvd2ViMy9yZXF1ZXN0bWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3NldHRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbGliL3dlYjMvc3luY2luZy5qcyIsIm5vZGVfbW9kdWxlcy93ZWIzL2xpYi93ZWIzL3RyYW5zZmVyLmpzIiwibm9kZV9tb2R1bGVzL3dlYjMvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanMiLCJub2RlX21vZHVsZXMvd2ViMy9ub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIiwibm9kZV9tb2R1bGVzL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9kaXN0L2Jyb3dzZXItcG9seWZpbGwuanMiLCJub2RlX21vZHVsZXMvd2hhdHdnLWZldGNoL2Rpc3QvZmV0Y2gudW1kLmpzIiwibm9kZV9tb2R1bGVzL3dyYXBweS93cmFwcHkuanMiLCJub2RlX21vZHVsZXMveGhyMi1jb29raWVzL2Rpc3QvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3Byb2dyZXNzLWV2ZW50LmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3htbC1odHRwLXJlcXVlc3QtZXZlbnQtdGFyZ2V0LmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3htbC1odHRwLXJlcXVlc3QtdXBsb2FkLmpzIiwibm9kZV9tb2R1bGVzL3hocjItY29va2llcy9kaXN0L3htbC1odHRwLXJlcXVlc3QuanMiLCJub2RlX21vZHVsZXMveGhyMi9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiLCJzaGFyZWQvY29uc3RhbnRzL2FsZXJ0cy5qcyIsInNoYXJlZC9jb25zdGFudHMvYXBwLnRzIiwic2hhcmVkL2NvbnN0YW50cy9nYXMuanMiLCJzaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMuanMiLCJzaGFyZWQvY29uc3RhbnRzL2xhYmVscy5qcyIsInNoYXJlZC9jb25zdGFudHMvbWV0YW1ldHJpY3MuanMiLCJzaGFyZWQvY29uc3RhbnRzL25ldHdvcmsudHMiLCJzaGFyZWQvY29uc3RhbnRzL3Blcm1pc3Npb25zLnRzIiwic2hhcmVkL2NvbnN0YW50cy9zd2Fwcy5qcyIsInNoYXJlZC9jb25zdGFudHMvdGltZS50cyIsInNoYXJlZC9jb25zdGFudHMvdG9rZW5zLmpzIiwic2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbi5qcyIsInNoYXJlZC9saWIvZmV0Y2gtd2l0aC1jYWNoZS5qcyIsInNoYXJlZC9saWIvbWV0YW1hc2stY29udHJvbGxlci11dGlscy5qcyIsInNoYXJlZC9saWIvc3RvcmFnZS1oZWxwZXJzLmpzIiwic2hhcmVkL2xpYi9zd2Fwcy11dGlscy5qcyIsInNoYXJlZC9saWIvc3dpdGNoLWRpcmVjdGlvbi5qcyIsInNoYXJlZC9saWIvdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9mZXRjaC13aXRoLXRpbWVvdXQuanMiLCJzaGFyZWQvbW9kdWxlcy9nYXMudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9tdjMudXRpbHMuanMiLCJzaGFyZWQvbW9kdWxlcy9uZXR3b3JrLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvb2JqZWN0LnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvcmFuZG9tLWlkLmpzIiwic2hhcmVkL21vZHVsZXMvcnBjLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvc2l3ZS5qcyIsInNoYXJlZC9tb2R1bGVzL3N0cmluZy11dGlscy5qcyIsInNoYXJlZC9tb2R1bGVzL3N3YXBzLnV0aWxzLmpzIiwic2hhcmVkL21vZHVsZXMvdHJhbnNhY3Rpb24udXRpbHMuanMiLCJzaGFyZWQvbm90aWZpY2F0aW9ucy9pbmRleC5qcyIsInVpL2R1Y2tzL2FsZXJ0cy9lbnVtcy5qcyIsInVpL2R1Y2tzL2FsZXJ0cy91bmNvbm5lY3RlZC1hY2NvdW50LmpzIiwidWkvZHVja3MvYXBwL2FwcC5qcyIsInVpL2R1Y2tzL2Vucy5qcyIsInVpL2R1Y2tzL2dhcy9nYXMtYWN0aW9uLWNvbnN0YW50cy5qcyIsInVpL2R1Y2tzL2dhcy9nYXMuZHVjay5qcyIsInVpL2R1Y2tzL21ldGFtYXNrL21ldGFtYXNrLmpzIiwidWkvZHVja3Mvc2VuZC9oZWxwZXJzLmpzIiwidWkvZHVja3Mvc2VuZC9pbmRleC5qcyIsInVpL2R1Y2tzL3NlbmQvc2VuZC5qcyIsInVpL2hlbHBlcnMvY29uc3RhbnRzL2NvbW1vbi5qcyIsInVpL2hlbHBlcnMvY29uc3RhbnRzL2Rlc2lnbi1zeXN0ZW0uanMiLCJ1aS9oZWxwZXJzL2NvbnN0YW50cy9lcnJvci1rZXlzLmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvcm91dGVzLmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvdHJhbnNhY3Rpb25zLmpzIiwidWkvaGVscGVycy9jb25zdGFudHMvemVuZGVzay11cmwuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL2NvbmZpcm0tdHgudXRpbC5qcyIsInVpL2hlbHBlcnMvdXRpbHMvY29udmVyc2lvbnMudXRpbC5qcyIsInVpL2hlbHBlcnMvdXRpbHMvZm9ybWF0dGVycy5qcyIsInVpL2hlbHBlcnMvdXRpbHMvaTE4bi1oZWxwZXIuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL21vb25wYXkuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL29wdGltaXNtL2J1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24uanMiLCJ1aS9oZWxwZXJzL3V0aWxzL29wdGltaXNtL2ZldGNoRXN0aW1hdGVkTDFGZWUuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL3Rva2VuLXV0aWwuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL3RyYW5zYWN0aW9ucy51dGlsLmpzIiwidWkvaGVscGVycy91dGlscy90eC1oZWxwZXIuanMiLCJ1aS9oZWxwZXJzL3V0aWxzL3V0aWwuanMiLCJ1aS9wYWdlcy9jb25maXJtYXRpb24vdGVtcGxhdGVzL2FkZC1ldGhlcmV1bS1jaGFpbi5qcyIsInVpL3BhZ2VzL2NvbmZpcm1hdGlvbi90ZW1wbGF0ZXMvaW5kZXguanMiLCJ1aS9wYWdlcy9jb25maXJtYXRpb24vdGVtcGxhdGVzL3N3aXRjaC1ldGhlcmV1bS1jaGFpbi5qcyIsInVpL3BhZ2VzL3NlbmQvc2VuZC5jb25zdGFudHMuanMiLCJ1aS9wYWdlcy9zZW5kL3NlbmQudXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNySkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDckhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3BTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUNwdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ2hZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQ3ZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM5UEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ25KQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN4SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9QQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMvRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDam9CQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUN0VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNyVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDM1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDbk9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNsV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ2hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM3RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNwUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzd2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQzVtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQzdFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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dEMsVUFDRSx1R0FOb0M7RUFPdEMsUUFBUSw0Q0FQOEI7RUFRdEMsWUFBWSx5REFSMEI7RUFTdEMsT0FDRSwrR0FBQTtDQVZHLENBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0RQO0FBQ08sTUFBTSx5QkFBeUIsR0FBRyxFQUFsQyxDLENBRVA7QUFDQTs7O0FBQ08sTUFBTSw2QkFBNkIsR0FBRyxDQUF0QyxDLENBRVA7QUFDQTs7O0FBQ08sTUFBTSwyQkFBMkIsR0FBRyxDQUFwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1RQOztBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LFNBQVMsQ0FBQztNQUhhLENBQUQsQ0FBakM7O0lBS0YsS0FBSyxrQkFBTDtJQUNBO01BQ0UsT0FBTyx5QkFBeUIsQ0FBQztRQUMvQixTQUQrQjtRQUUvQixNQUYrQjtRQUcvQjtNQUgrQixDQUFELENBQWhDO0VBVEo7QUFlRDs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsSUFBbkIsRUFBeUIsS0FBSyxHQUFHLENBQWpDLEVBQW9DLElBQUksR0FBRyxDQUEzQyxFQUE4QztFQUM1QyxPQUFRLEdBQUUsSUFBSSxDQUFDLEtBQUwsQ0FBVyxDQUFYLEVBQWMsS0FBZCxDQUFxQixNQUFLLElBQUksQ0FBQyxLQUFMLENBQVcsQ0FBQyxJQUFaLENBQWtCLEVBQXREO0FBQ0QiLCJmaWxlIjoiY29tbW9uLTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF9yZWdleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vcmVnZXguanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgX3JlZ2V4LmRlZmF1bHQudGVzdCh1dWlkKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmFsaWRhdGU7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIF92YWxpZGF0ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vdmFsaWRhdGUuanNcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCEoMCwgX3ZhbGlkYXRlLmRlZmF1bHQpKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnN1YnN0cigxNCwgMSksIDE2KTtcbn1cblxudmFyIF9kZWZhdWx0ID0gdmVyc2lvbjtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIihmdW5jdGlvbihtb2R1bGUpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICBtb2R1bGUuZXhwb3J0cy5pc191cmkgPSBpc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfaHR0cF91cmkgPSBpc19odHRwX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc19odHRwc191cmkgPSBpc19odHRwc19pcmk7XG4gICAgbW9kdWxlLmV4cG9ydHMuaXNfd2ViX3VyaSA9IGlzX3dlYl9pcmk7XG4gICAgLy8gQ3JlYXRlIGFsaWFzZXNcbiAgICBtb2R1bGUuZXhwb3J0cy5pc1VyaSA9IGlzX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc0h0dHBVcmkgPSBpc19odHRwX2lyaTtcbiAgICBtb2R1bGUuZXhwb3J0cy5pc0h0dHBzVXJpID0gaXNfaHR0cHNfaXJpO1xuICAgIG1vZHVsZS5leHBvcnRzLmlzV2ViVXJpID0gaXNfd2ViX2lyaTtcblxuXG4gICAgLy8gcHJpdmF0ZSBmdW5jdGlvblxuICAgIC8vIGludGVybmFsIFVSSSBzcGl0dGVyIG1ldGhvZCAtIGRpcmVjdCBmcm9tIFJGQyAzOTg2XG4gICAgdmFyIHNwbGl0VXJpID0gZnVuY3Rpb24odXJpKSB7XG4gICAgICAgIHZhciBzcGxpdHRlZCA9IHVyaS5tYXRjaCgvKD86KFteOlxcLz8jXSspOik/KD86XFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKD86XFw/KFteI10qKSk/KD86IyguKikpPy8pO1xuICAgICAgICByZXR1cm4gc3BsaXR0ZWQ7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzX2lyaSh2YWx1ZSkge1xuICAgICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjaGVjayBmb3IgaWxsZWdhbCBjaGFyYWN0ZXJzXG4gICAgICAgIGlmICgvW15hLXowLTlcXDpcXC9cXD9cXCNcXFtcXF1cXEBcXCFcXCRcXCZcXCdcXChcXClcXCpcXCtcXCxcXDtcXD1cXC5cXC1cXF9cXH5cXCVdL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcblxuICAgICAgICAvLyBjaGVjayBmb3IgaGV4IGVzY2FwZXMgdGhhdCBhcmVuJ3QgY29tcGxldGVcbiAgICAgICAgaWYgKC8lW14wLTlhLWZdL2kudGVzdCh2YWx1ZSkpIHJldHVybjtcbiAgICAgICAgaWYgKC8lWzAtOWEtZl0oOj9bXjAtOWEtZl18JCkvaS50ZXN0KHZhbHVlKSkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBzcGxpdHRlZCA9IFtdO1xuICAgICAgICB2YXIgc2NoZW1lID0gJyc7XG4gICAgICAgIHZhciBhdXRob3JpdHkgPSAnJztcbiAgICAgICAgdmFyIHBhdGggPSAnJztcbiAgICAgICAgdmFyIHF1ZXJ5ID0gJyc7XG4gICAgICAgIHZhciBmcmFnbWVudCA9ICcnO1xuICAgICAgICB2YXIgb3V0ID0gJyc7XG5cbiAgICAgICAgLy8gZnJvbSBSRkMgMzk4NlxuICAgICAgICBzcGxpdHRlZCA9IHNwbGl0VXJpKHZhbHVlKTtcbiAgICAgICAgc2NoZW1lID0gc3BsaXR0ZWRbMV07IFxuICAgICAgICBhdXRob3JpdHkgPSBzcGxpdHRlZFsyXTtcbiAgICAgICAgcGF0aCA9IHNwbGl0dGVkWzNdO1xuICAgICAgICBxdWVyeSA9IHNwbGl0dGVkWzRdO1xuICAgICAgICBmcmFnbWVudCA9IHNwbGl0dGVkWzVdO1xuXG4gICAgICAgIC8vIHNjaGVtZSBhbmQgcGF0aCBhcmUgcmVxdWlyZWQsIHRob3VnaCB0aGUgcGF0aCBjYW4gYmUgZW1wdHlcbiAgICAgICAgaWYgKCEoc2NoZW1lICYmIHNjaGVtZS5sZW5ndGggJiYgcGF0aC5sZW5ndGggPj0gMCkpIHJldHVybjtcblxuICAgICAgICAvLyBpZiBhdXRob3JpdHkgaXMgcHJlc2VudCwgdGhlIHBhdGggbXVzdCBiZSBlbXB0eSBvciBiZWdpbiB3aXRoIGEgL1xuICAgICAgICBpZiAoYXV0aG9yaXR5ICYmIGF1dGhvcml0eS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICghKHBhdGgubGVuZ3RoID09PSAwIHx8IC9eXFwvLy50ZXN0KHBhdGgpKSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgYXV0aG9yaXR5IGlzIG5vdCBwcmVzZW50LCB0aGUgcGF0aCBtdXN0IG5vdCBzdGFydCB3aXRoIC8vXG4gICAgICAgICAgICBpZiAoL15cXC9cXC8vLnRlc3QocGF0aCkpIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNjaGVtZSBtdXN0IGJlZ2luIHdpdGggYSBsZXR0ZXIsIHRoZW4gY29uc2lzdCBvZiBsZXR0ZXJzLCBkaWdpdHMsICssIC4sIG9yIC1cbiAgICAgICAgaWYgKCEvXlthLXpdW2EtejAtOVxcK1xcLVxcLl0qJC8udGVzdChzY2hlbWUudG9Mb3dlckNhc2UoKSkpICByZXR1cm47XG5cbiAgICAgICAgLy8gcmUtYXNzZW1ibGUgdGhlIFVSTCBwZXIgc2VjdGlvbiA1LjMgaW4gUkZDIDM5ODZcbiAgICAgICAgb3V0ICs9IHNjaGVtZSArICc6JztcbiAgICAgICAgaWYgKGF1dGhvcml0eSAmJiBhdXRob3JpdHkubGVuZ3RoKSB7XG4gICAgICAgICAgICBvdXQgKz0gJy8vJyArIGF1dGhvcml0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBwYXRoO1xuXG4gICAgICAgIGlmIChxdWVyeSAmJiBxdWVyeS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnPycgKyBxdWVyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIG91dCArPSAnIycgKyBmcmFnbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNfaHR0cF9pcmkodmFsdWUsIGFsbG93SHR0cHMpIHtcbiAgICAgICAgaWYgKCFpc19pcmkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3BsaXR0ZWQgPSBbXTtcbiAgICAgICAgdmFyIHNjaGVtZSA9ICcnO1xuICAgICAgICB2YXIgYXV0aG9yaXR5ID0gJyc7XG4gICAgICAgIHZhciBwYXRoID0gJyc7XG4gICAgICAgIHZhciBwb3J0ID0gJyc7XG4gICAgICAgIHZhciBxdWVyeSA9ICcnO1xuICAgICAgICB2YXIgZnJhZ21lbnQgPSAnJztcbiAgICAgICAgdmFyIG91dCA9ICcnO1xuXG4gICAgICAgIC8vIGZyb20gUkZDIDM5ODZcbiAgICAgICAgc3BsaXR0ZWQgPSBzcGxpdFVyaSh2YWx1ZSk7XG4gICAgICAgIHNjaGVtZSA9IHNwbGl0dGVkWzFdOyBcbiAgICAgICAgYXV0aG9yaXR5ID0gc3BsaXR0ZWRbMl07XG4gICAgICAgIHBhdGggPSBzcGxpdHRlZFszXTtcbiAgICAgICAgcXVlcnkgPSBzcGxpdHRlZFs0XTtcbiAgICAgICAgZnJhZ21lbnQgPSBzcGxpdHRlZFs1XTtcblxuICAgICAgICBpZiAoIXNjaGVtZSkgIHJldHVybjtcblxuICAgICAgICBpZihhbGxvd0h0dHBzKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1lLnRvTG93ZXJDYXNlKCkgIT0gJ2h0dHBzJykgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNjaGVtZS50b0xvd2VyQ2FzZSgpICE9ICdodHRwJykgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZnVsbHktcXVhbGlmaWVkIFVSSXMgbXVzdCBoYXZlIGFuIGF1dGhvcml0eSBzZWN0aW9uIHRoYXQgaXNcbiAgICAgICAgLy8gYSB2YWxpZCBob3N0XG4gICAgICAgIGlmICghYXV0aG9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBlbmFibGUgcG9ydCBjb21wb25lbnRcbiAgICAgICAgaWYgKC86KFxcZCspJC8udGVzdChhdXRob3JpdHkpKSB7XG4gICAgICAgICAgICBwb3J0ID0gYXV0aG9yaXR5Lm1hdGNoKC86KFxcZCspJC8pWzBdO1xuICAgICAgICAgICAgYXV0aG9yaXR5ID0gYXV0aG9yaXR5LnJlcGxhY2UoLzpcXGQrJC8sICcnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dCArPSBzY2hlbWUgKyAnOic7XG4gICAgICAgIG91dCArPSAnLy8nICsgYXV0aG9yaXR5O1xuICAgICAgICBcbiAgICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgICAgIG91dCArPSBwb3J0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBvdXQgKz0gcGF0aDtcbiAgICAgICAgXG4gICAgICAgIGlmKHF1ZXJ5ICYmIHF1ZXJ5Lmxlbmd0aCl7XG4gICAgICAgICAgICBvdXQgKz0gJz8nICsgcXVlcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZihmcmFnbWVudCAmJiBmcmFnbWVudC5sZW5ndGgpe1xuICAgICAgICAgICAgb3V0ICs9ICcjJyArIGZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX2h0dHBzX2lyaSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaXNfaHR0cF9pcmkodmFsdWUsIHRydWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzX3dlYl9pcmkodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIChpc19odHRwX2lyaSh2YWx1ZSkgfHwgaXNfaHR0cHNfaXJpKHZhbHVlKSk7XG4gICAgfVxuXG59KShtb2R1bGUpO1xuIiwidmFyIGluZGV4T2YgPSBmdW5jdGlvbiAoeHMsIGl0ZW0pIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoaXRlbSk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4c1tpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG52YXIgT2JqZWN0X2tleXMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgaWYgKE9iamVjdC5rZXlzKSByZXR1cm4gT2JqZWN0LmtleXMob2JqKVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgcmVzID0gW107XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxudmFyIGRlZmluZVByb3AgPSAoZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnXycsIHt9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHtcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgb2JqW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxufSgpKTtcblxudmFyIGdsb2JhbHMgPSBbJ0FycmF5JywgJ0Jvb2xlYW4nLCAnRGF0ZScsICdFcnJvcicsICdFdmFsRXJyb3InLCAnRnVuY3Rpb24nLFxuJ0luZmluaXR5JywgJ0pTT04nLCAnTWF0aCcsICdOYU4nLCAnTnVtYmVyJywgJ09iamVjdCcsICdSYW5nZUVycm9yJyxcbidSZWZlcmVuY2VFcnJvcicsICdSZWdFeHAnLCAnU3RyaW5nJywgJ1N5bnRheEVycm9yJywgJ1R5cGVFcnJvcicsICdVUklFcnJvcicsXG4nZGVjb2RlVVJJJywgJ2RlY29kZVVSSUNvbXBvbmVudCcsICdlbmNvZGVVUkknLCAnZW5jb2RlVVJJQ29tcG9uZW50JywgJ2VzY2FwZScsXG4nZXZhbCcsICdpc0Zpbml0ZScsICdpc05hTicsICdwYXJzZUZsb2F0JywgJ3BhcnNlSW50JywgJ3VuZGVmaW5lZCcsICd1bmVzY2FwZSddO1xuXG5mdW5jdGlvbiBDb250ZXh0KCkge31cbkNvbnRleHQucHJvdG90eXBlID0ge307XG5cbnZhciBTY3JpcHQgPSBleHBvcnRzLlNjcmlwdCA9IGZ1bmN0aW9uIE5vZGVTY3JpcHQgKGNvZGUpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU2NyaXB0KSkgcmV0dXJuIG5ldyBTY3JpcHQoY29kZSk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5Db250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICBpZiAoIShjb250ZXh0IGluc3RhbmNlb2YgQ29udGV4dCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm5lZWRzIGEgJ2NvbnRleHQnIGFyZ3VtZW50LlwiKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGlmICghaWZyYW1lLnN0eWxlKSBpZnJhbWUuc3R5bGUgPSB7fTtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgdmFyIHdpbiA9IGlmcmFtZS5jb250ZW50V2luZG93O1xuICAgIHZhciB3RXZhbCA9IHdpbi5ldmFsLCB3RXhlY1NjcmlwdCA9IHdpbi5leGVjU2NyaXB0O1xuXG4gICAgaWYgKCF3RXZhbCAmJiB3RXhlY1NjcmlwdCkge1xuICAgICAgICAvLyB3aW4uKDAsZXZhbCkoKSBtYWdpY2FsbHkgYXBwZWFycyB3aGVuIHRoaXMgaXMgY2FsbGVkIGluIElFOlxuICAgICAgICB3RXhlY1NjcmlwdC5jYWxsKHdpbiwgJ251bGwnKTtcbiAgICAgICAgd0V2YWwgPSB3aW4uZXZhbDtcbiAgICB9XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyhjb250ZXh0KSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB3aW5ba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICB9KTtcbiAgICBmb3JFYWNoKGdsb2JhbHMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKGNvbnRleHRba2V5XSkge1xuICAgICAgICAgICAgd2luW2tleV0gPSBjb250ZXh0W2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICB2YXIgd2luS2V5cyA9IE9iamVjdF9rZXlzKHdpbik7XG5cbiAgICB2YXIgcmVzID0gd0V2YWwuY2FsbCh3aW4sIHRoaXMuY29kZSk7XG4gICAgXG4gICAgZm9yRWFjaChPYmplY3Rfa2V5cyh3aW4pLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIEF2b2lkIGNvcHlpbmcgY2lyY3VsYXIgb2JqZWN0cyBsaWtlIGB0b3BgIGFuZCBgd2luZG93YCBieSBvbmx5XG4gICAgICAgIC8vIHVwZGF0aW5nIGV4aXN0aW5nIGNvbnRleHQgcHJvcGVydGllcyBvciBuZXcgcHJvcGVydGllcyBpbiB0aGUgYHdpbmBcbiAgICAgICAgLy8gdGhhdCB3YXMgb25seSBpbnRyb2R1Y2VkIGFmdGVyIHRoZSBldmFsLlxuICAgICAgICBpZiAoa2V5IGluIGNvbnRleHQgfHwgaW5kZXhPZih3aW5LZXlzLCBrZXkpID09PSAtMSkge1xuICAgICAgICAgICAgY29udGV4dFtrZXldID0gd2luW2tleV07XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvckVhY2goZ2xvYmFscywgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gY29udGV4dCkpIHtcbiAgICAgICAgICAgIGRlZmluZVByb3AoY29udGV4dCwga2V5LCB3aW5ba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgXG4gICAgcmV0dXJuIHJlcztcbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5UaGlzQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKDAsZXZhbCkodGhpcy5jb2RlKTsgLy8gbWF5YmUuLi5cbn07XG5cblNjcmlwdC5wcm90b3R5cGUucnVuSW5OZXdDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY3R4ID0gU2NyaXB0LmNyZWF0ZUNvbnRleHQoY29udGV4dCk7XG4gICAgdmFyIHJlcyA9IHRoaXMucnVuSW5Db250ZXh0KGN0eCk7XG5cbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBmb3JFYWNoKE9iamVjdF9rZXlzKGN0eCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnRleHRba2V5XSA9IGN0eFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xufTtcblxuZm9yRWFjaChPYmplY3Rfa2V5cyhTY3JpcHQucHJvdG90eXBlKSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBleHBvcnRzW25hbWVdID0gU2NyaXB0W25hbWVdID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICAgICAgdmFyIHMgPSBTY3JpcHQoY29kZSk7XG4gICAgICAgIHJldHVybiBzW25hbWVdLmFwcGx5KHMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gICAgfTtcbn0pO1xuXG5leHBvcnRzLmlzQ29udGV4dCA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNvbnRleHQgaW5zdGFuY2VvZiBDb250ZXh0O1xufTtcblxuZXhwb3J0cy5jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBleHBvcnRzLlNjcmlwdChjb2RlKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlQ29udGV4dCA9IFNjcmlwdC5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICB2YXIgY29weSA9IG5ldyBDb250ZXh0KCk7XG4gICAgaWYodHlwZW9mIGNvbnRleHQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGZvckVhY2goT2JqZWN0X2tleXMoY29udGV4dCksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGNvcHlba2V5XSA9IGNvbnRleHRba2V5XTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufTtcbiIsImNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IGV0aFV0aWwgPSByZXF1aXJlKCdldGhlcmV1bWpzLXV0aWwnKVxuY29uc3QgRXRoQmxvY2tUcmFja2VyID0gcmVxdWlyZSgnZXRoLWJsb2NrLXRyYWNrZXInKVxuY29uc3QgbWFwID0gcmVxdWlyZSgnYXN5bmMvbWFwJylcbmNvbnN0IGVhY2hTZXJpZXMgPSByZXF1aXJlKCdhc3luYy9lYWNoU2VyaWVzJylcbmNvbnN0IFN0b3BsaWdodCA9IHJlcXVpcmUoJy4vdXRpbC9zdG9wbGlnaHQuanMnKVxuY29uc3QgY2FjaGVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbC9ycGMtY2FjaGUtdXRpbHMuanMnKVxuY29uc3QgY3JlYXRlUGF5bG9hZCA9IHJlcXVpcmUoJy4vdXRpbC9jcmVhdGUtcGF5bG9hZC5qcycpXG5jb25zdCBub29wID0gZnVuY3Rpb24oKXt9XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViM1Byb3ZpZGVyRW5naW5lXG5cblxuaW5oZXJpdHMoV2ViM1Byb3ZpZGVyRW5naW5lLCBFdmVudEVtaXR0ZXIpXG5cbmZ1bmN0aW9uIFdlYjNQcm92aWRlckVuZ2luZShvcHRzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpXG4gIHNlbGYuc2V0TWF4TGlzdGVuZXJzKDMwKVxuICAvLyBwYXJzZSBvcHRpb25zXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgLy8gYmxvY2sgcG9sbGluZ1xuICBjb25zdCBkaXJlY3RQcm92aWRlciA9IHsgc2VuZEFzeW5jOiBzZWxmLl9oYW5kbGVBc3luYy5iaW5kKHNlbGYpIH1cbiAgY29uc3QgYmxvY2tUcmFja2VyUHJvdmlkZXIgPSBvcHRzLmJsb2NrVHJhY2tlclByb3ZpZGVyIHx8IGRpcmVjdFByb3ZpZGVyXG4gIHNlbGYuX2Jsb2NrVHJhY2tlciA9IG9wdHMuYmxvY2tUcmFja2VyIHx8IG5ldyBFdGhCbG9ja1RyYWNrZXIoe1xuICAgIHByb3ZpZGVyOiBibG9ja1RyYWNrZXJQcm92aWRlcixcbiAgICBwb2xsaW5nSW50ZXJ2YWw6IG9wdHMucG9sbGluZ0ludGVydmFsIHx8IDQwMDAsXG4gICAgc2V0U2tpcENhY2hlRmxhZzogdHJ1ZSxcbiAgfSlcblxuICAvLyBzZXQgaW5pdGlhbGl6YXRpb24gYmxvY2tlclxuICBzZWxmLl9yZWFkeSA9IG5ldyBTdG9wbGlnaHQoKVxuXG4gIC8vIGxvY2FsIHN0YXRlXG4gIHNlbGYuY3VycmVudEJsb2NrID0gbnVsbFxuICBzZWxmLl9wcm92aWRlcnMgPSBbXVxufVxuXG4vLyBwdWJsaWNcblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uKGNiID0gbm9vcCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgLy8gdHJpZ2dlciBzdGFydFxuICBzZWxmLl9yZWFkeS5nbygpXG5cbiAgLy8gb24gbmV3IGJsb2NrLCByZXF1ZXN0IGJsb2NrIGJvZHkgYW5kIGVtaXQgYXMgZXZlbnRzXG4gIHNlbGYuX2Jsb2NrVHJhY2tlci5vbignbGF0ZXN0JywgKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgLy8gZ2V0IGJsb2NrIGJvZHlcbiAgICBzZWxmLl9nZXRCbG9ja0J5TnVtYmVyV2l0aFJldHJ5KGJsb2NrTnVtYmVyLCAoZXJyLCBibG9jaykgPT4ge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgY29uc29sZS5sb2coYmxvY2spXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZmluZCBibG9ja1wiKSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCBidWZmZXJCbG9jayA9IHRvQnVmZmVyQmxvY2soYmxvY2spXG4gICAgICAvLyBzZXQgY3VycmVudCArIGVtaXQgXCJibG9ja1wiIGV2ZW50XG4gICAgICBzZWxmLl9zZXRDdXJyZW50QmxvY2soYnVmZmVyQmxvY2spXG4gICAgICAvLyBlbWl0IG90aGVyIGV2ZW50c1xuICAgICAgc2VsZi5lbWl0KCdyYXdCbG9jaycsIGJsb2NrKVxuICAgICAgc2VsZi5lbWl0KCdsYXRlc3QnLCBibG9jaylcbiAgICB9KVxuICB9KVxuXG4gIC8vIGZvcndhcmQgb3RoZXIgZXZlbnRzXG4gIHNlbGYuX2Jsb2NrVHJhY2tlci5vbignc3luYycsIHNlbGYuZW1pdC5iaW5kKHNlbGYsICdzeW5jJykpXG4gIHNlbGYuX2Jsb2NrVHJhY2tlci5vbignZXJyb3InLCBzZWxmLmVtaXQuYmluZChzZWxmLCAnZXJyb3InKSlcblxuICAvLyB1cGRhdGUgc3RhdGVcbiAgc2VsZi5fcnVubmluZyA9IHRydWVcbiAgLy8gc2lnbmFsIHRoYXQgd2Ugc3RhcnRlZFxuICBzZWxmLmVtaXQoJ3N0YXJ0Jylcbn1cblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLy8gc3RvcCBibG9jayBwb2xsaW5nIGJ5IHJlbW92aW5nIGV2ZW50IGxpc3RlbmVyc1xuICBzZWxmLl9ibG9ja1RyYWNrZXIucmVtb3ZlQWxsTGlzdGVuZXJzKClcbiAgLy8gdXBkYXRlIHN0YXRlXG4gIHNlbGYuX3J1bm5pbmcgPSBmYWxzZVxuICAvLyBzaWduYWwgdGhhdCB3ZSBzdG9wcGVkXG4gIHNlbGYuZW1pdCgnc3RvcCcpXG59XG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuaXNSdW5uaW5nID0gZnVuY3Rpb24oKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgcmV0dXJuIHNlbGYuX3J1bm5pbmdcbn1cblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5hZGRQcm92aWRlciA9IGZ1bmN0aW9uKHNvdXJjZSwgaW5kZXgpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgIHNlbGYuX3Byb3ZpZGVycy5zcGxpY2UoaW5kZXgsIDAsIHNvdXJjZSlcbiAgfSBlbHNlIHtcbiAgICBzZWxmLl9wcm92aWRlcnMucHVzaChzb3VyY2UpXG4gIH1cbiAgc291cmNlLnNldEVuZ2luZSh0aGlzKVxufVxuXG5XZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLnJlbW92ZVByb3ZpZGVyID0gZnVuY3Rpb24oc291cmNlKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgaW5kZXggPSBzZWxmLl9wcm92aWRlcnMuaW5kZXhPZihzb3VyY2UpXG4gIGlmIChpbmRleCA8IDApIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXIgbm90IGZvdW5kLicpXG4gIHNlbGYuX3Byb3ZpZGVycy5zcGxpY2UoaW5kZXgsIDEpXG59XG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBheWxvYWQpe1xuICB0aHJvdyBuZXcgRXJyb3IoJ1dlYjNQcm92aWRlckVuZ2luZSBkb2VzIG5vdCBzdXBwb3J0IHN5bmNocm9ub3VzIHJlcXVlc3RzLicpXG59XG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24ocGF5bG9hZCwgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLl9yZWFkeS5hd2FpdChmdW5jdGlvbigpe1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGF5bG9hZCkpIHtcbiAgICAgIC8vIGhhbmRsZSBiYXRjaFxuICAgICAgbWFwKHBheWxvYWQsIHNlbGYuX2hhbmRsZUFzeW5jLmJpbmQoc2VsZiksIGNiKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBoYW5kbGUgc2luZ2xlXG4gICAgICBzZWxmLl9oYW5kbGVBc3luYyhwYXlsb2FkLCBjYilcbiAgICB9XG5cbiAgfSlcbn1cblxuLy8gcHJpdmF0ZVxuXG5XZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLl9nZXRCbG9ja0J5TnVtYmVyV2l0aFJldHJ5ID0gZnVuY3Rpb24oYmxvY2tOdW1iZXIsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgbGV0IHJldHJpZXNSZW1haW5pbmcgPSA1XG5cbiAgYXR0ZW1wdFJlcXVlc3QoKVxuICByZXR1cm5cblxuICBmdW5jdGlvbiBhdHRlbXB0UmVxdWVzdCAoKSB7XG4gICAgc2VsZi5fZ2V0QmxvY2tCeU51bWJlcihibG9ja051bWJlciwgYWZ0ZXJSZXF1ZXN0KVxuICB9XG5cbiAgZnVuY3Rpb24gYWZ0ZXJSZXF1ZXN0IChlcnIsIGJsb2NrKSB7XG4gICAgLy8gYW5vbWFsb3VzIGVycm9yIG9jY3VycmVkXG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICAvLyBibG9jayBub3QgcmVhZHkgeWV0XG4gICAgaWYgKCFibG9jaykge1xuICAgICAgaWYgKHJldHJpZXNSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgIC8vIHdhaXQgMXMgdGhlbiB0cnkgYWdhaW5cbiAgICAgICAgcmV0cmllc1JlbWFpbmluZy0tXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGF0dGVtcHRSZXF1ZXN0KClcbiAgICAgICAgfSwgMTAwMClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnaXZlIHVwLCByZXR1cm4gYSBudWxsIGJsb2NrXG4gICAgICAgIGNiKG51bGwsIG51bGwpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UgcmV0dXJuIHJlc3VsdFxuICAgIGNiKG51bGwsIGJsb2NrKVxuICAgIHJldHVyblxuICB9XG59XG5cblxuV2ViM1Byb3ZpZGVyRW5naW5lLnByb3RvdHlwZS5fZ2V0QmxvY2tCeU51bWJlciA9IGZ1bmN0aW9uKGJsb2NrTnVtYmVyLCBjYikge1xuICBjb25zdCByZXEgPSBjcmVhdGVQYXlsb2FkKHsgbWV0aG9kOiAnZXRoX2dldEJsb2NrQnlOdW1iZXInLCBwYXJhbXM6IFtibG9ja051bWJlciwgZmFsc2VdLCBza2lwQ2FjaGU6IHRydWUgfSlcbiAgdGhpcy5faGFuZGxlQXN5bmMocmVxLCAoZXJyLCByZXMpID0+IHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIHJldHVybiBjYihudWxsLCByZXMucmVzdWx0KVxuICB9KVxufVxuXG5XZWIzUHJvdmlkZXJFbmdpbmUucHJvdG90eXBlLl9oYW5kbGVBc3luYyA9IGZ1bmN0aW9uKHBheWxvYWQsIGZpbmlzaGVkKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICB2YXIgY3VycmVudFByb3ZpZGVyID0gLTFcbiAgdmFyIHJlc3VsdCA9IG51bGxcbiAgdmFyIGVycm9yID0gbnVsbFxuXG4gIHZhciBzdGFjayA9IFtdXG5cbiAgbmV4dCgpXG5cbiAgZnVuY3Rpb24gbmV4dChhZnRlcikge1xuICAgIGN1cnJlbnRQcm92aWRlciArPSAxXG4gICAgc3RhY2sudW5zaGlmdChhZnRlcilcblxuICAgIC8vIEJ1YmJsZWQgZG93biBhcyBmYXIgYXMgd2UgY291bGQgZ28sIGFuZCB0aGUgcmVxdWVzdCB3YXNuJ3RcbiAgICAvLyBoYW5kbGVkLiBSZXR1cm4gYW4gZXJyb3IuXG4gICAgaWYgKGN1cnJlbnRQcm92aWRlciA+PSBzZWxmLl9wcm92aWRlcnMubGVuZ3RoKSB7XG4gICAgICBlbmQobmV3IEVycm9yKCdSZXF1ZXN0IGZvciBtZXRob2QgXCInICsgcGF5bG9hZC5tZXRob2QgKyAnXCIgbm90IGhhbmRsZWQgYnkgYW55IHN1YnByb3ZpZGVyLiBQbGVhc2UgY2hlY2sgeW91ciBzdWJwcm92aWRlciBjb25maWd1cmF0aW9uIHRvIGVuc3VyZSB0aGlzIG1ldGhvZCBpcyBoYW5kbGVkLicpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSBzZWxmLl9wcm92aWRlcnNbY3VycmVudFByb3ZpZGVyXVxuICAgICAgICBwcm92aWRlci5oYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZW5kKGUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kKF9lcnJvciwgX3Jlc3VsdCkge1xuICAgIGVycm9yID0gX2Vycm9yXG4gICAgcmVzdWx0ID0gX3Jlc3VsdFxuXG4gICAgZWFjaFNlcmllcyhzdGFjaywgZnVuY3Rpb24oZm4sIGNhbGxiYWNrKSB7XG5cbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbihlcnJvciwgcmVzdWx0LCBjYWxsYmFjaylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgIH1cbiAgICB9LCBmdW5jdGlvbigpIHtcblxuICAgICAgdmFyIHJlc3VsdE9iaiA9IHtcbiAgICAgICAgaWQ6IHBheWxvYWQuaWQsXG4gICAgICAgIGpzb25ycGM6IHBheWxvYWQuanNvbnJwYyxcbiAgICAgICAgcmVzdWx0OiByZXN1bHRcbiAgICAgIH1cblxuICAgICAgaWYgKGVycm9yICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0T2JqLmVycm9yID0ge1xuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLnN0YWNrIHx8IGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IsXG4gICAgICAgICAgY29kZTogLTMyMDAwXG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVzcG9uZCB3aXRoIGJvdGggZXJyb3IgZm9ybWF0c1xuICAgICAgICBmaW5pc2hlZChlcnJvciwgcmVzdWx0T2JqKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoZWQobnVsbCwgcmVzdWx0T2JqKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLy9cbi8vIGZyb20gcmVtb3RlLWRhdGFcbi8vXG5cbldlYjNQcm92aWRlckVuZ2luZS5wcm90b3R5cGUuX3NldEN1cnJlbnRCbG9jayA9IGZ1bmN0aW9uKGJsb2NrKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgc2VsZi5jdXJyZW50QmxvY2sgPSBibG9ja1xuICBzZWxmLmVtaXQoJ2Jsb2NrJywgYmxvY2spXG59XG5cbi8vIHV0aWxcblxuZnVuY3Rpb24gdG9CdWZmZXJCbG9jayAoanNvbkJsb2NrKSB7XG4gIHJldHVybiB7XG4gICAgbnVtYmVyOiAgICAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2subnVtYmVyKSxcbiAgICBoYXNoOiAgICAgICAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5oYXNoKSxcbiAgICBwYXJlbnRIYXNoOiAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5wYXJlbnRIYXNoKSxcbiAgICBub25jZTogICAgICAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5ub25jZSksXG4gICAgbWl4SGFzaDogICAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2subWl4SGFzaCksXG4gICAgc2hhM1VuY2xlczogICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2suc2hhM1VuY2xlcyksXG4gICAgbG9nc0Jsb29tOiAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2subG9nc0Jsb29tKSxcbiAgICB0cmFuc2FjdGlvbnNSb290OiBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay50cmFuc2FjdGlvbnNSb290KSxcbiAgICBzdGF0ZVJvb3Q6ICAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5zdGF0ZVJvb3QpLFxuICAgIHJlY2VpcHRzUm9vdDogICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLnJlY2VpcHRSb290IHx8IGpzb25CbG9jay5yZWNlaXB0c1Jvb3QpLFxuICAgIG1pbmVyOiAgICAgICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLm1pbmVyKSxcbiAgICBkaWZmaWN1bHR5OiAgICAgICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay5kaWZmaWN1bHR5KSxcbiAgICB0b3RhbERpZmZpY3VsdHk6ICBldGhVdGlsLnRvQnVmZmVyKGpzb25CbG9jay50b3RhbERpZmZpY3VsdHkpLFxuICAgIHNpemU6ICAgICAgICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLnNpemUpLFxuICAgIGV4dHJhRGF0YTogICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLmV4dHJhRGF0YSksXG4gICAgZ2FzTGltaXQ6ICAgICAgICAgZXRoVXRpbC50b0J1ZmZlcihqc29uQmxvY2suZ2FzTGltaXQpLFxuICAgIGdhc1VzZWQ6ICAgICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLmdhc1VzZWQpLFxuICAgIHRpbWVzdGFtcDogICAgICAgIGV0aFV0aWwudG9CdWZmZXIoanNvbkJsb2NrLnRpbWVzdGFtcCksXG4gICAgdHJhbnNhY3Rpb25zOiAgICAganNvbkJsb2NrLnRyYW5zYWN0aW9ucyxcbiAgfVxufVxuIiwiY29uc3QgRXRoUXVlcnkgPSByZXF1aXJlKCdldGgtcXVlcnknKVxuY29uc3QgcGlmeSA9IHJlcXVpcmUoJ3BpZnknKVxuY29uc3QgU2FmZUV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ3NhZmUtZXZlbnQtZW1pdHRlcicpXG5cbmNvbnN0IHNlYyA9IDEwMDBcblxuY29uc3QgY2FsY3VsYXRlU3VtID0gKGFjY3VtdWxhdG9yLCBjdXJyZW50VmFsdWUpID0+IGFjY3VtdWxhdG9yICsgY3VycmVudFZhbHVlXG5jb25zdCBibG9ja1RyYWNrZXJFdmVudHMgPSBbJ3N5bmMnLCAnbGF0ZXN0J11cblxuY2xhc3MgQmFzZUJsb2NrVHJhY2tlciBleHRlbmRzIFNhZmVFdmVudEVtaXR0ZXIge1xuXG4gIC8vXG4gIC8vIHB1YmxpY1xuICAvL1xuXG4gIGNvbnN0cnVjdG9yIChvcHRzID0ge30pIHtcbiAgICBzdXBlcigpXG4gICAgLy8gY29uZmlnXG4gICAgdGhpcy5fYmxvY2tSZXNldER1cmF0aW9uID0gb3B0cy5ibG9ja1Jlc2V0RHVyYXRpb24gfHwgMjAgKiBzZWNcbiAgICAvLyBzdGF0ZVxuICAgIHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0XG4gICAgdGhpcy5fY3VycmVudEJsb2NrID0gbnVsbFxuICAgIHRoaXMuX2lzUnVubmluZyA9IGZhbHNlXG4gICAgLy8gYmluZCBmdW5jdGlvbnMgZm9yIGludGVybmFsIHVzZVxuICAgIHRoaXMuX29uTmV3TGlzdGVuZXIgPSB0aGlzLl9vbk5ld0xpc3RlbmVyLmJpbmQodGhpcylcbiAgICB0aGlzLl9vblJlbW92ZUxpc3RlbmVyID0gdGhpcy5fb25SZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpXG4gICAgdGhpcy5fcmVzZXRDdXJyZW50QmxvY2sgPSB0aGlzLl9yZXNldEN1cnJlbnRCbG9jay5iaW5kKHRoaXMpXG4gICAgLy8gbGlzdGVuIGZvciBoYW5kbGVyIGNoYW5nZXNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgfVxuXG4gIGlzUnVubmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUnVubmluZ1xuICB9XG5cbiAgZ2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEJsb2NrXG4gIH1cblxuICBhc3luYyBnZXRMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gcmV0dXJuIGlmIGF2YWlsYWJsZVxuICAgIGlmICh0aGlzLl9jdXJyZW50QmxvY2spIHJldHVybiB0aGlzLl9jdXJyZW50QmxvY2tcbiAgICAvLyB3YWl0IGZvciBhIG5ldyBsYXRlc3QgYmxvY2tcbiAgICBjb25zdCBsYXRlc3RCbG9jayA9IGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gdGhpcy5vbmNlKCdsYXRlc3QnLCByZXNvbHZlKSlcbiAgICAvLyByZXR1cm4gbmV3bHkgc2V0IGN1cnJlbnQgYmxvY2tcbiAgICByZXR1cm4gbGF0ZXN0QmxvY2tcbiAgfVxuXG4gIC8vIGRvbnQgYWxsb3cgbW9kdWxlIGNvbnN1bWVyIHRvIHJlbW92ZSBvdXIgaW50ZXJuYWwgZXZlbnQgbGlzdGVuZXJzXG4gIHJlbW92ZUFsbExpc3RlbmVycyAoZXZlbnROYW1lKSB7XG4gICAgLy8gcGVyZm9ybSBkZWZhdWx0IGJlaGF2aW9yLCBwcmVzZXJ2ZSBmbiBhcml0eVxuICAgIGlmIChldmVudE5hbWUpIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldmVudE5hbWUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycygpXG4gICAgfVxuICAgIC8vIHJlLWFkZCBpbnRlcm5hbCBldmVudHNcbiAgICB0aGlzLl9zZXR1cEludGVybmFsRXZlbnRzKClcbiAgICAvLyB0cmlnZ2VyIHN0b3AgY2hlY2sganVzdCBpbiBjYXNlXG4gICAgdGhpcy5fb25SZW1vdmVMaXN0ZW5lcigpXG4gIH1cblxuICAvL1xuICAvLyB0byBiZSBpbXBsZW1lbnRlZCBpbiBzdWJjbGFzc1xuICAvL1xuXG4gIF9zdGFydCAoKSB7XG4gICAgLy8gZGVmYXVsdCBiZWhhdmlvciBpcyBub29wXG4gIH1cblxuICBfZW5kICgpIHtcbiAgICAvLyBkZWZhdWx0IGJlaGF2aW9yIGlzIG5vb3BcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc2V0dXBJbnRlcm5hbEV2ZW50cyAoKSB7XG4gICAgLy8gZmlyc3QgcmVtb3ZlIGxpc3RlbmVycyBmb3IgaWRlbXBvdGVuY2VcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICAgIC8vIHRoZW4gYWRkIHRoZW1cbiAgICB0aGlzLm9uKCduZXdMaXN0ZW5lcicsIHRoaXMuX29uTmV3TGlzdGVuZXIpXG4gICAgdGhpcy5vbigncmVtb3ZlTGlzdGVuZXInLCB0aGlzLl9vblJlbW92ZUxpc3RlbmVyKVxuICB9XG5cbiAgX29uTmV3TGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGBuZXdMaXN0ZW5lcmAgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBsaXN0ZW5lciBpcyBhZGRlZFxuICAgIGlmICghYmxvY2tUcmFja2VyRXZlbnRzLmluY2x1ZGVzKGV2ZW50TmFtZSkpIHJldHVyblxuICAgIHRoaXMuX21heWJlU3RhcnQoKVxuICB9XG5cbiAgX29uUmVtb3ZlTGlzdGVuZXIgKGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIC8vIGByZW1vdmVMaXN0ZW5lcmAgaXMgY2FsbGVkICphZnRlciogdGhlIGxpc3RlbmVyIGlzIHJlbW92ZWRcbiAgICBpZiAodGhpcy5fZ2V0QmxvY2tUcmFja2VyRXZlbnRDb3VudCgpID4gMCkgcmV0dXJuXG4gICAgdGhpcy5fbWF5YmVFbmQoKVxuICB9XG5cbiAgX21heWJlU3RhcnQgKCkge1xuICAgIGlmICh0aGlzLl9pc1J1bm5pbmcpIHJldHVyblxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWVcbiAgICAvLyBjYW5jZWwgc2V0dGluZyBsYXRlc3QgYmxvY2sgdG8gc3RhbGVcbiAgICB0aGlzLl9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCgpXG4gICAgdGhpcy5fc3RhcnQoKVxuICB9XG5cbiAgX21heWJlRW5kICgpIHtcbiAgICBpZiAoIXRoaXMuX2lzUnVubmluZykgcmV0dXJuXG4gICAgdGhpcy5faXNSdW5uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9zZXR1cEJsb2NrUmVzZXRUaW1lb3V0KClcbiAgICB0aGlzLl9lbmQoKVxuICB9XG5cbiAgX2dldEJsb2NrVHJhY2tlckV2ZW50Q291bnQgKCkge1xuICAgIHJldHVybiBibG9ja1RyYWNrZXJFdmVudHNcbiAgICAgIC5tYXAoZXZlbnROYW1lID0+IHRoaXMubGlzdGVuZXJDb3VudChldmVudE5hbWUpKVxuICAgICAgLnJlZHVjZShjYWxjdWxhdGVTdW0pXG4gIH1cblxuICBfbmV3UG90ZW50aWFsTGF0ZXN0IChuZXdCbG9jaykge1xuICAgIGNvbnN0IGN1cnJlbnRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIC8vIG9ubHkgdXBkYXRlIGlmIGJsb2sgbnVtYmVyIGlzIGhpZ2hlclxuICAgIGlmIChjdXJyZW50QmxvY2sgJiYgKGhleFRvSW50KG5ld0Jsb2NrKSA8PSBoZXhUb0ludChjdXJyZW50QmxvY2spKSkgcmV0dXJuXG4gICAgdGhpcy5fc2V0Q3VycmVudEJsb2NrKG5ld0Jsb2NrKVxuICB9XG5cbiAgX3NldEN1cnJlbnRCbG9jayAobmV3QmxvY2spIHtcbiAgICBjb25zdCBvbGRCbG9jayA9IHRoaXMuX2N1cnJlbnRCbG9ja1xuICAgIHRoaXMuX2N1cnJlbnRCbG9jayA9IG5ld0Jsb2NrXG4gICAgdGhpcy5lbWl0KCdsYXRlc3QnLCBuZXdCbG9jaylcbiAgICB0aGlzLmVtaXQoJ3N5bmMnLCB7IG9sZEJsb2NrLCBuZXdCbG9jayB9KVxuICB9XG5cbiAgX3NldHVwQmxvY2tSZXNldFRpbWVvdXQgKCkge1xuICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0XG4gICAgdGhpcy5fY2FuY2VsQmxvY2tSZXNldFRpbWVvdXQoKVxuICAgIC8vIGNsZWFyIGxhdGVzdCBibG9jayB3aGVuIHN0YWxlXG4gICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMuX3Jlc2V0Q3VycmVudEJsb2NrLCB0aGlzLl9ibG9ja1Jlc2V0RHVyYXRpb24pXG4gICAgLy8gbm9kZWpzIC0gZG9udCBob2xkIHByb2Nlc3Mgb3BlblxuICAgIGlmICh0aGlzLl9ibG9ja1Jlc2V0VGltZW91dC51bnJlZikge1xuICAgICAgdGhpcy5fYmxvY2tSZXNldFRpbWVvdXQudW5yZWYoKVxuICAgIH1cbiAgfVxuXG4gIF9jYW5jZWxCbG9ja1Jlc2V0VGltZW91dCAoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Jsb2NrUmVzZXRUaW1lb3V0KVxuICB9XG5cbiAgX3Jlc2V0Q3VycmVudEJsb2NrICgpIHtcbiAgICB0aGlzLl9jdXJyZW50QmxvY2sgPSBudWxsXG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2VCbG9ja1RyYWNrZXJcblxuZnVuY3Rpb24gaGV4VG9JbnQoaGV4SW50KSB7XG4gIHJldHVybiBOdW1iZXIucGFyc2VJbnQoaGV4SW50LCAxNilcbn1cbiIsImNvbnN0IHBpZnkgPSByZXF1aXJlKCdwaWZ5JylcbmNvbnN0IEJhc2VCbG9ja1RyYWNrZXIgPSByZXF1aXJlKCcuL2Jhc2UnKVxuXG5jb25zdCBzZWMgPSAxMDAwXG5cbmNsYXNzIFBvbGxpbmdCbG9ja1RyYWNrZXIgZXh0ZW5kcyBCYXNlQmxvY2tUcmFja2VyIHtcblxuICBjb25zdHJ1Y3RvciAob3B0cyA9IHt9KSB7XG4gICAgLy8gcGFyc2UgKyB2YWxpZGF0ZSBhcmdzXG4gICAgaWYgKCFvcHRzLnByb3ZpZGVyKSB0aHJvdyBuZXcgRXJyb3IoJ1BvbGxpbmdCbG9ja1RyYWNrZXIgLSBubyBwcm92aWRlciBzcGVjaWZpZWQuJylcbiAgICBjb25zdCBwb2xsaW5nSW50ZXJ2YWwgPSBvcHRzLnBvbGxpbmdJbnRlcnZhbCB8fCAyMCAqIHNlY1xuICAgIGNvbnN0IHJldHJ5VGltZW91dCA9IG9wdHMucmV0cnlUaW1lb3V0IHx8IHBvbGxpbmdJbnRlcnZhbCAvIDEwXG4gICAgY29uc3Qga2VlcEV2ZW50TG9vcEFjdGl2ZSA9IG9wdHMua2VlcEV2ZW50TG9vcEFjdGl2ZSAhPT0gdW5kZWZpbmVkID8gb3B0cy5rZWVwRXZlbnRMb29wQWN0aXZlIDogdHJ1ZVxuICAgIGNvbnN0IHNldFNraXBDYWNoZUZsYWcgPSBvcHRzLnNldFNraXBDYWNoZUZsYWcgfHwgZmFsc2VcbiAgICAvLyBCYXNlQmxvY2tUcmFja2VyIGNvbnN0cnVjdG9yXG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7XG4gICAgICBibG9ja1Jlc2V0RHVyYXRpb246IHBvbGxpbmdJbnRlcnZhbCxcbiAgICB9LCBvcHRzKSlcbiAgICAvLyBjb25maWdcbiAgICB0aGlzLl9wcm92aWRlciA9IG9wdHMucHJvdmlkZXJcbiAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSBwb2xsaW5nSW50ZXJ2YWxcbiAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSByZXRyeVRpbWVvdXRcbiAgICB0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlID0ga2VlcEV2ZW50TG9vcEFjdGl2ZVxuICAgIHRoaXMuX3NldFNraXBDYWNoZUZsYWcgPSBzZXRTa2lwQ2FjaGVGbGFnXG4gIH1cblxuICAvL1xuICAvLyBwdWJsaWNcbiAgLy9cblxuICAvLyB0cmlnZ2VyIGJsb2NrIHBvbGxpbmdcbiAgYXN5bmMgY2hlY2tGb3JMYXRlc3RCbG9jayAoKSB7XG4gICAgYXdhaXQgdGhpcy5fdXBkYXRlTGF0ZXN0QmxvY2soKVxuICAgIHJldHVybiBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NrKClcbiAgfVxuXG4gIC8vXG4gIC8vIHByaXZhdGVcbiAgLy9cblxuICBfc3RhcnQgKCkge1xuICAgIHRoaXMuX3BlcmZvcm1TeW5jKCkuY2F0Y2goZXJyID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpKVxuICB9XG5cbiAgYXN5bmMgX3BlcmZvcm1TeW5jICgpIHtcbiAgICB3aGlsZSAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVMYXRlc3RCbG9jaygpXG4gICAgICAgIGF3YWl0IHRpbWVvdXQodGhpcy5fcG9sbGluZ0ludGVydmFsLCAhdGhpcy5fa2VlcEV2ZW50TG9vcEFjdGl2ZSlcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBuZXdFcnIgPSBuZXcgRXJyb3IoYFBvbGxpbmdCbG9ja1RyYWNrZXIgLSBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBhdHRlbXB0aW5nIHRvIHVwZGF0ZSBsYXRlc3QgYmxvY2s6XFxuJHtlcnIuc3RhY2t9YClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3RXJyKVxuICAgICAgICB9IGNhdGNoIChlbWl0RXJyKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihuZXdFcnIpXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQsICF0aGlzLl9rZWVwRXZlbnRMb29wQWN0aXZlKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIF91cGRhdGVMYXRlc3RCbG9jayAoKSB7XG4gICAgLy8gZmV0Y2ggKyBzZXQgbGF0ZXN0IGJsb2NrXG4gICAgY29uc3QgbGF0ZXN0QmxvY2sgPSBhd2FpdCB0aGlzLl9mZXRjaExhdGVzdEJsb2NrKClcbiAgICB0aGlzLl9uZXdQb3RlbnRpYWxMYXRlc3QobGF0ZXN0QmxvY2spXG4gIH1cblxuICBhc3luYyBfZmV0Y2hMYXRlc3RCbG9jayAoKSB7XG4gICAgY29uc3QgcmVxID0geyBqc29ucnBjOiBcIjIuMFwiLCBpZDogMSwgbWV0aG9kOiAnZXRoX2Jsb2NrTnVtYmVyJywgcGFyYW1zOiBbXSB9XG4gICAgaWYgKHRoaXMuX3NldFNraXBDYWNoZUZsYWcpIHJlcS5za2lwQ2FjaGUgPSB0cnVlXG4gICAgY29uc3QgcmVzID0gYXdhaXQgcGlmeSgoY2IpID0+IHRoaXMuX3Byb3ZpZGVyLnNlbmRBc3luYyhyZXEsIGNiKSkoKVxuICAgIGlmIChyZXMuZXJyb3IpIHRocm93IG5ldyBFcnJvcihgUG9sbGluZ0Jsb2NrVHJhY2tlciAtIGVuY291bnRlcmVkIGVycm9yIGZldGNoaW5nIGJsb2NrOlxcbiR7cmVzLmVycm9yfWApXG4gICAgcmV0dXJuIHJlcy5yZXN1bHRcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZ0Jsb2NrVHJhY2tlclxuXG5mdW5jdGlvbiB0aW1lb3V0IChkdXJhdGlvbiwgdW5yZWYpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgIGNvbnN0IHRpbW91dFJlZiA9IHNldFRpbWVvdXQocmVzb2x2ZSwgZHVyYXRpb24pXG4gICAgLy8gZG9uJ3Qga2VlcCBwcm9jZXNzIG9wZW5cbiAgICBpZiAodGltb3V0UmVmLnVucmVmICYmIHVucmVmKSB7XG4gICAgICB0aW1vdXRSZWYudW5yZWYoKVxuICAgIH1cbiAgfSlcbn1cbiIsImNvbnN0IGNhY2hlVXRpbHMgPSByZXF1aXJlKCcuL2NhY2hlLXV0aWxzLmpzJylcbmNvbnN0IGNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2pzb24tcnBjLWVuZ2luZS9zcmMvY3JlYXRlQXN5bmNNaWRkbGV3YXJlJylcbi8vIGA8bmlsPmAgY29tZXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzE2OTI1XG5jb25zdCBlbXB0eVZhbHVlcyA9IFt1bmRlZmluZWQsIG51bGwsICdcXHUwMDNjbmlsXFx1MDAzZSddXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmVcblxuXG5mdW5jdGlvbiBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZShvcHRzID0ge30pIHtcbiAgLy8gdmFsaWRhdGUgb3B0aW9uc1xuICBjb25zdCB7IGJsb2NrVHJhY2tlciB9ID0gb3B0c1xuICBpZiAoIWJsb2NrVHJhY2tlcikgdGhyb3cgbmV3IEVycm9yKCdjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSAtIE5vIEJsb2NrVHJhY2tlciBzcGVjaWZpZWQnKVxuXG4gIC8vIGNyZWF0ZSBjYWNoaW5nIHN0cmF0ZWdpZXNcbiAgY29uc3QgYmxvY2tDYWNoZSA9IG5ldyBCbG9ja0NhY2hlU3RyYXRlZ3koKVxuICBjb25zdCBzdHJhdGVnaWVzID0ge1xuICAgIHBlcm1hOiBibG9ja0NhY2hlLFxuICAgIGJsb2NrOiBibG9ja0NhY2hlLFxuICAgIGZvcms6IGJsb2NrQ2FjaGUsXG4gIH1cblxuICByZXR1cm4gY3JlYXRlQXN5bmNNaWRkbGV3YXJlKGFzeW5jIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgIC8vIGFsbG93IGNhY2ggdG8gYmUgc2tpcHBlZCBpZiBzbyBzcGVjaWZpZWRcbiAgICBpZiAocmVxLnNraXBDYWNoZSkge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cbiAgICAvLyBjaGVjayB0eXBlIGFuZCBtYXRjaGluZyBzdHJhdGVneVxuICAgIGNvbnN0IHR5cGUgPSBjYWNoZVV0aWxzLmNhY2hlVHlwZUZvclBheWxvYWQocmVxKVxuICAgIGNvbnN0IHN0cmF0ZWd5ID0gc3RyYXRlZ2llc1t0eXBlXVxuICAgIC8vIElmIHRoZXJlJ3Mgbm8gc3RyYXRlZ3kgaW4gcGxhY2UsIHBhc3MgaXQgZG93biB0aGUgY2hhaW4uXG4gICAgaWYgKCFzdHJhdGVneSkge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3RyYXRlZ3kgY2FuJ3QgY2FjaGUgdGhpcyByZXF1ZXN0LCBpZ25vcmUgaXQuXG4gICAgaWYgKCFzdHJhdGVneS5jYW5DYWNoZVJlcXVlc3QocmVxKSkge1xuICAgICAgcmV0dXJuIG5leHQoKVxuICAgIH1cblxuICAgIC8vIGdldCBibG9jayByZWZlcmVuY2UgKG51bWJlciBvciBrZXl3b3JkKVxuICAgIGxldCBibG9ja1RhZyA9IGNhY2hlVXRpbHMuYmxvY2tUYWdGb3JQYXlsb2FkKHJlcSlcbiAgICBpZiAoIWJsb2NrVGFnKSBibG9ja1RhZyA9ICdsYXRlc3QnXG5cbiAgICAvLyBnZXQgZXhhY3QgYmxvY2sgbnVtYmVyXG4gICAgbGV0IHJlcXVlc3RlZEJsb2NrTnVtYmVyXG4gICAgaWYgKGJsb2NrVGFnID09PSAnZWFybGllc3QnKSB7XG4gICAgICAvLyB0aGlzIGp1c3QgZXhpc3RzIGZvciBzeW1tZXRyeSB3aXRoIFwibGF0ZXN0XCJcbiAgICAgIHJlcXVlc3RlZEJsb2NrTnVtYmVyID0gJzB4MDAnXG4gICAgfSBlbHNlIGlmIChibG9ja1RhZyA9PT0gJ2xhdGVzdCcpIHtcbiAgICAgIC8vIGZldGNoIGxhdGVzdCBibG9jayBudW1iZXJcbiAgICAgIGNvbnN0IGxhdGVzdEJsb2NrTnVtYmVyID0gYXdhaXQgYmxvY2tUcmFja2VyLmdldExhdGVzdEJsb2NrKClcbiAgICAgIC8vIGNsZWFyIGFsbCBjYWNoZSBiZWZvcmUgbGF0ZXN0IGJsb2NrXG4gICAgICBibG9ja0NhY2hlLmNsZWFyQmVmb3JlKGxhdGVzdEJsb2NrTnVtYmVyKVxuICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBsYXRlc3RCbG9ja051bWJlclxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBoYXZlIGEgaGV4IG51bWJlclxuICAgICAgcmVxdWVzdGVkQmxvY2tOdW1iZXIgPSBibG9ja1RhZ1xuICAgIH1cblxuICAgIC8vIGVuZCBvbiBhIGhpdCwgY29udGludWUgb24gYSBtaXNzXG4gICAgY29uc3QgY2FjaGVSZXN1bHQgPSBhd2FpdCBzdHJhdGVneS5nZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlcilcbiAgICBpZiAoY2FjaGVSZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gY2FjaGUgbWlzc1xuICAgICAgLy8gd2FpdCBmb3Igb3RoZXIgbWlkZGxld2FyZSB0byBoYW5kbGUgcmVxdWVzdFxuICAgICAgYXdhaXQgbmV4dCgpXG4gICAgICAvLyBhZGQgcmVzdWx0IHRvIGNhY2hlXG4gICAgICBhd2FpdCBzdHJhdGVneS5zZXQocmVxLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzLnJlc3VsdClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmlsbCBpbiByZXN1bHQgZnJvbSBjYWNoZVxuICAgICAgcmVzLnJlc3VsdCA9IGNhY2hlUmVzdWx0XG4gICAgfVxuICB9KVxufVxuXG5cbi8vXG4vLyBDYWNoZSBTdHJhdGVnaWVzXG4vL1xuXG5jbGFzcyBCbG9ja0NhY2hlU3RyYXRlZ3kge1xuICBcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fVxuICB9XG5cbiAgZ2V0QmxvY2tDYWNoZUZvclBheWxvYWQgKHBheWxvYWQsIGJsb2NrTnVtYmVySGV4KSB7XG4gICAgY29uc3QgYmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQoYmxvY2tOdW1iZXJIZXgsIDE2KVxuICAgIGxldCBibG9ja0NhY2hlID0gdGhpcy5jYWNoZVtibG9ja051bWJlcl1cbiAgICAvLyBjcmVhdGUgbmV3IGNhY2hlIGlmIG5lY2VzYXJ5XG4gICAgaWYgKCFibG9ja0NhY2hlKSB7XG4gICAgICBjb25zdCBuZXdDYWNoZSA9IHt9XG4gICAgICB0aGlzLmNhY2hlW2Jsb2NrTnVtYmVyXSA9IG5ld0NhY2hlXG4gICAgICBibG9ja0NhY2hlID0gbmV3Q2FjaGVcbiAgICB9XG4gICAgcmV0dXJuIGJsb2NrQ2FjaGVcbiAgfVxuXG4gIGFzeW5jIGdldCAocGF5bG9hZCwgcmVxdWVzdGVkQmxvY2tOdW1iZXIpIHtcbiAgICAvLyBsb29rdXAgYmxvY2sgY2FjaGVcbiAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcilcbiAgICBpZiAoIWJsb2NrQ2FjaGUpIHJldHVyblxuICAgIC8vIGxvb2t1cCBwYXlsb2FkIGluIGJsb2NrIGNhY2hlXG4gICAgY29uc3QgaWRlbnRpZmllciA9IGNhY2hlVXRpbHMuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZChwYXlsb2FkLCB0cnVlKVxuICAgIGNvbnN0IGNhY2hlZCA9IGJsb2NrQ2FjaGVbaWRlbnRpZmllcl1cbiAgICAvLyBtYXkgYmUgdW5kZWZpbmVkXG4gICAgcmV0dXJuIGNhY2hlZFxuICB9XG5cbiAgYXN5bmMgc2V0IChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlciwgcmVzdWx0KSB7XG4gICAgLy8gY2hlY2sgaWYgd2UgY2FuIGNhY2hlZCB0aGlzIHJlc3VsdFxuICAgIGNvbnN0IGNhbkNhY2hlID0gdGhpcy5jYW5DYWNoZVJlc3VsdChwYXlsb2FkLCByZXN1bHQpXG4gICAgaWYgKCFjYW5DYWNoZSkgcmV0dXJuXG4gICAgLy8gc2V0IHRoZSB2YWx1ZSBpbiB0aGUgY2FjaGVcbiAgICBjb25zdCBibG9ja0NhY2hlID0gdGhpcy5nZXRCbG9ja0NhY2hlRm9yUGF5bG9hZChwYXlsb2FkLCByZXF1ZXN0ZWRCbG9ja051bWJlcilcbiAgICBjb25zdCBpZGVudGlmaWVyID0gY2FjaGVVdGlscy5jYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkKHBheWxvYWQsIHRydWUpXG4gICAgYmxvY2tDYWNoZVtpZGVudGlmaWVyXSA9IHJlc3VsdFxuICB9XG5cbiAgY2FuQ2FjaGVSZXF1ZXN0IChwYXlsb2FkKSB7XG4gICAgLy8gY2hlY2sgcmVxdWVzdCBtZXRob2RcbiAgICBpZiAoIWNhY2hlVXRpbHMuY2FuQ2FjaGUocGF5bG9hZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICAvLyBjaGVjayBibG9ja1RhZ1xuICAgIGNvbnN0IGJsb2NrVGFnID0gY2FjaGVVdGlscy5ibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZClcbiAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIC8vIGNhbiBiZSBjYWNoZWRcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY2FuQ2FjaGVSZXN1bHQgKHBheWxvYWQsIHJlc3VsdCkge1xuICAgIC8vIG5ldmVyIGNhY2hlIGVtcHR5IHZhbHVlcyAoZS5nLiB1bmRlZmluZWQpXG4gICAgaWYgKGVtcHR5VmFsdWVzLmluY2x1ZGVzKHJlc3VsdCkpIHJldHVyblxuICAgIC8vIGNoZWNrIGlmIHRyYW5zYWN0aW9ucyBoYXZlIGJsb2NrIHJlZmVyZW5jZSBiZWZvcmUgY2FjaGluZ1xuICAgIGlmIChbJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0J10uaW5jbHVkZXMocGF5bG9hZC5tZXRob2QpKSB7XG4gICAgICBpZiAoIXJlc3VsdCB8fCAhcmVzdWx0LmJsb2NrSGFzaCB8fCByZXN1bHQuYmxvY2tIYXNoID09PSAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJykge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gb3RoZXJ3aXNlIHRydWVcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gcmVtb3ZlcyBhbGwgYmxvY2sgY2FjaGVzIHdpdGggYmxvY2sgbnVtYmVyIGxvd2VyIHRoYW4gYG9sZEJsb2NrSGV4YFxuICBjbGVhckJlZm9yZSAob2xkQmxvY2tIZXgpe1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzXG4gICAgY29uc3Qgb2xkQmxvY2tOdW1iZXIgPSBOdW1iZXIucGFyc2VJbnQob2xkQmxvY2tIZXgsIDE2KVxuICAgIC8vIGNsZWFyIG9sZCBjYWNoZXNcbiAgICBPYmplY3Qua2V5cyhzZWxmLmNhY2hlKVxuICAgICAgLm1hcChOdW1iZXIpXG4gICAgICAuZmlsdGVyKG51bSA9PiBudW0gPCBvbGRCbG9ja051bWJlcilcbiAgICAgIC5mb3JFYWNoKG51bSA9PiBkZWxldGUgc2VsZi5jYWNoZVtudW1dKVxuICB9XG5cbn1cbiIsImNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkOiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkLFxuICBjYW5DYWNoZTogY2FuQ2FjaGUsXG4gIGJsb2NrVGFnRm9yUGF5bG9hZDogYmxvY2tUYWdGb3JQYXlsb2FkLFxuICBwYXJhbXNXaXRob3V0QmxvY2tUYWc6IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyxcbiAgYmxvY2tUYWdQYXJhbUluZGV4OiBibG9ja1RhZ1BhcmFtSW5kZXgsXG4gIGNhY2hlVHlwZUZvclBheWxvYWQ6IGNhY2hlVHlwZUZvclBheWxvYWRcbn1cblxuZnVuY3Rpb24gY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZCAocGF5bG9hZCwgc2tpcEJsb2NrUmVmKSB7XG4gIGNvbnN0IHNpbXBsZVBhcmFtcyA9IHNraXBCbG9ja1JlZiA/IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyhwYXlsb2FkKSA6IHBheWxvYWQucGFyYW1zXG4gIGlmIChjYW5DYWNoZShwYXlsb2FkKSkge1xuICAgIHJldHVybiBwYXlsb2FkLm1ldGhvZCArICc6JyArIHN0cmluZ2lmeShzaW1wbGVQYXJhbXMpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5DYWNoZSAocGF5bG9hZCkge1xuICByZXR1cm4gY2FjaGVUeXBlRm9yUGF5bG9hZChwYXlsb2FkKSAhPT0gJ25ldmVyJ1xufVxuXG5mdW5jdGlvbiBibG9ja1RhZ0ZvclBheWxvYWQgKHBheWxvYWQpIHtcbiAgbGV0IGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpXG5cbiAgLy8gQmxvY2sgdGFnIHBhcmFtIG5vdCBwYXNzZWQuXG4gIGlmIChpbmRleCA+PSBwYXlsb2FkLnBhcmFtcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHBheWxvYWQucGFyYW1zW2luZGV4XVxufVxuXG5mdW5jdGlvbiBwYXJhbXNXaXRob3V0QmxvY2tUYWcgKHBheWxvYWQpIHtcbiAgY29uc3QgaW5kZXggPSBibG9ja1RhZ1BhcmFtSW5kZXgocGF5bG9hZClcblxuICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgaWYgKGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtc1xuICB9XG5cbiAgLy8gZXRoX2dldEJsb2NrQnlOdW1iZXIgaGFzIHRoZSBibG9jayB0YWcgZmlyc3QsIHRoZW4gdGhlIG9wdGlvbmFsIGluY2x1ZGVUeD8gcGFyYW1cbiAgaWYgKHBheWxvYWQubWV0aG9kID09PSAnZXRoX2dldEJsb2NrQnlOdW1iZXInKSB7XG4gICAgcmV0dXJuIHBheWxvYWQucGFyYW1zLnNsaWNlKDEpXG4gIH1cblxuICByZXR1cm4gcGF5bG9hZC5wYXJhbXMuc2xpY2UoMCwgaW5kZXgpXG59XG5cbmZ1bmN0aW9uIGJsb2NrVGFnUGFyYW1JbmRleCAocGF5bG9hZCkge1xuICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgLy8gYmxvY2tUYWcgaXMgYXQgaW5kZXggMlxuICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgcmV0dXJuIDJcbiAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAxXG4gICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgICAgcmV0dXJuIDFcbiAgICAvLyBibG9ja1RhZyBpcyBhdCBpbmRleCAwXG4gICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgICAgcmV0dXJuIDBcbiAgICAvLyB0aGVyZSBpcyBubyBibG9ja1RhZ1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cbn1cblxuZnVuY3Rpb24gY2FjaGVUeXBlRm9yUGF5bG9hZCAocGF5bG9hZCkge1xuICBzd2l0Y2ggKHBheWxvYWQubWV0aG9kKSB7XG4gICAgLy8gY2FjaGUgcGVybWFuZW50bHlcbiAgICBjYXNlICd3ZWIzX2NsaWVudFZlcnNpb24nOlxuICAgIGNhc2UgJ3dlYjNfc2hhMyc6XG4gICAgY2FzZSAnZXRoX3Byb3RvY29sVmVyc2lvbic6XG4gICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5SGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrSGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgIGNhc2UgJ2V0aF9nZXRCbG9ja0J5SGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoJzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JzpcbiAgICBjYXNlICdldGhfZ2V0VW5jbGVCeUJsb2NrSGFzaEFuZEluZGV4JzpcbiAgICBjYXNlICdldGhfZ2V0Q29tcGlsZXJzJzpcbiAgICBjYXNlICdldGhfY29tcGlsZUxMTCc6XG4gICAgY2FzZSAnZXRoX2NvbXBpbGVTb2xpZGl0eSc6XG4gICAgY2FzZSAnZXRoX2NvbXBpbGVTZXJwZW50JzpcbiAgICBjYXNlICdzaGhfdmVyc2lvbic6XG4gICAgY2FzZSAndGVzdF9wZXJtYUNhY2hlJzpcbiAgICAgIHJldHVybiAncGVybWEnXG5cbiAgICAvLyBjYWNoZSB1bnRpbCBmb3JrXG4gICAgY2FzZSAnZXRoX2dldEJsb2NrQnlOdW1iZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQ291bnRCeUJsb2NrTnVtYmVyJzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgnOlxuICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgY2FzZSAndGVzdF9mb3JrQ2FjaGUnOlxuICAgICAgcmV0dXJuICdmb3JrJ1xuXG4gICAgLy8gY2FjaGUgZm9yIGJsb2NrXG4gICAgY2FzZSAnZXRoX2dhc1ByaWNlJzpcbiAgICBjYXNlICdldGhfYmxvY2tOdW1iZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRCYWxhbmNlJzpcbiAgICBjYXNlICdldGhfZ2V0U3RvcmFnZUF0JzpcbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgY2FzZSAnZXRoX2NhbGwnOlxuICAgIGNhc2UgJ2V0aF9lc3RpbWF0ZUdhcyc6XG4gICAgY2FzZSAnZXRoX2dldEZpbHRlckxvZ3MnOlxuICAgIGNhc2UgJ2V0aF9nZXRMb2dzJzpcbiAgICBjYXNlICd0ZXN0X2Jsb2NrQ2FjaGUnOlxuICAgICAgcmV0dXJuICdibG9jaydcblxuICAgIC8vIG5ldmVyIGNhY2hlXG4gICAgY2FzZSAnbmV0X3ZlcnNpb24nOlxuICAgIGNhc2UgJ25ldF9wZWVyQ291bnQnOlxuICAgIGNhc2UgJ25ldF9saXN0ZW5pbmcnOlxuICAgIGNhc2UgJ2V0aF9zeW5jaW5nJzpcbiAgICBjYXNlICdldGhfc2lnbic6XG4gICAgY2FzZSAnZXRoX2NvaW5iYXNlJzpcbiAgICBjYXNlICdldGhfbWluaW5nJzpcbiAgICBjYXNlICdldGhfaGFzaHJhdGUnOlxuICAgIGNhc2UgJ2V0aF9hY2NvdW50cyc6XG4gICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgY2FzZSAnZXRoX3NlbmRSYXdUcmFuc2FjdGlvbic6XG4gICAgY2FzZSAnZXRoX25ld0ZpbHRlcic6XG4gICAgY2FzZSAnZXRoX25ld0Jsb2NrRmlsdGVyJzpcbiAgICBjYXNlICdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJzpcbiAgICBjYXNlICdldGhfdW5pbnN0YWxsRmlsdGVyJzpcbiAgICBjYXNlICdldGhfZ2V0RmlsdGVyQ2hhbmdlcyc6XG4gICAgY2FzZSAnZXRoX2dldFdvcmsnOlxuICAgIGNhc2UgJ2V0aF9zdWJtaXRXb3JrJzpcbiAgICBjYXNlICdldGhfc3VibWl0SGFzaHJhdGUnOlxuICAgIGNhc2UgJ2RiX3B1dFN0cmluZyc6XG4gICAgY2FzZSAnZGJfZ2V0U3RyaW5nJzpcbiAgICBjYXNlICdkYl9wdXRIZXgnOlxuICAgIGNhc2UgJ2RiX2dldEhleCc6XG4gICAgY2FzZSAnc2hoX3Bvc3QnOlxuICAgIGNhc2UgJ3NoaF9uZXdJZGVudGl0eSc6XG4gICAgY2FzZSAnc2hoX2hhc0lkZW50aXR5JzpcbiAgICBjYXNlICdzaGhfbmV3R3JvdXAnOlxuICAgIGNhc2UgJ3NoaF9hZGRUb0dyb3VwJzpcbiAgICBjYXNlICdzaGhfbmV3RmlsdGVyJzpcbiAgICBjYXNlICdzaGhfdW5pbnN0YWxsRmlsdGVyJzpcbiAgICBjYXNlICdzaGhfZ2V0RmlsdGVyQ2hhbmdlcyc6XG4gICAgY2FzZSAnc2hoX2dldE1lc3NhZ2VzJzpcbiAgICBjYXNlICd0ZXN0X25ldmVyQ2FjaGUnOlxuICAgICAgcmV0dXJuICduZXZlcidcbiAgfVxufVxuIiwiY29uc3QgZmV0Y2ggPSBnbG9iYWwuZmV0Y2ggfHwgcmVxdWlyZSgnbm9kZS1mZXRjaCcpXG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKVxuY29uc3QgeyBldGhFcnJvcnMgfSA9IHJlcXVpcmUoJ2V0aC1ycGMtZXJyb3JzJylcbmNvbnN0IGJ0b2EgPSByZXF1aXJlKCdidG9hJylcbmNvbnN0IGNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2pzb24tcnBjLWVuZ2luZS9zcmMvY3JlYXRlQXN5bmNNaWRkbGV3YXJlJylcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUZldGNoTWlkZGxld2FyZVxubW9kdWxlLmV4cG9ydHMuY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxID0gY3JlYXRlRmV0Y2hDb25maWdGcm9tUmVxXG5cbmNvbnN0IFJFVFJJQUJMRV9FUlJPUlMgPSBbXG4gIC8vIGlnbm9yZSBzZXJ2ZXIgb3ZlcmxvYWQgZXJyb3JzXG4gICdHYXRld2F5IHRpbWVvdXQnLFxuICAnRVRJTUVET1VUJyxcbiAgLy8gaWdub3JlIHNlcnZlciBzZW50IGh0bWwgZXJyb3IgcGFnZXNcbiAgLy8gb3IgdHJ1bmNhdGVkIGpzb24gcmVzcG9uc2VzXG4gICdmYWlsZWQgdG8gcGFyc2UgcmVzcG9uc2UgYm9keScsXG4gIC8vIGlnbm9yZSBlcnJvcnMgd2hlcmUgaHR0cCByZXEgZmFpbGVkIHRvIGVzdGFibGlzaFxuICAnRmFpbGVkIHRvIGZldGNoJyxcbl1cblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlICh7IHJwY1VybCwgb3JpZ2luSHR0cEhlYWRlcktleSB9KSB7XG4gIHJldHVybiBjcmVhdGVBc3luY01pZGRsZXdhcmUoYXN5bmMgKHJlcSwgcmVzLCBuZXh0KSA9PiB7XG4gICAgY29uc3QgeyBmZXRjaFVybCwgZmV0Y2hQYXJhbXMgfSA9IGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7IHJlcSwgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5IH0pXG5cbiAgICAvLyBhdHRlbXB0IHJlcXVlc3QgbXVsdGlwbGUgdGltZXNcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IDVcbiAgICBjb25zdCByZXRyeUludGVydmFsID0gMTAwMFxuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgbWF4QXR0ZW1wdHM7IGF0dGVtcHQrKykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZmV0Y2hSZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwgZmV0Y2hQYXJhbXMpXG4gICAgICAgIC8vIGNoZWNrIGZvciBodHRwIGVycnJvcnNcbiAgICAgICAgY2hlY2tGb3JIdHRwRXJyb3JzKGZldGNoUmVzKVxuICAgICAgICAvLyBwYXJzZSByZXNwb25zZSBib2R5XG4gICAgICAgIGNvbnN0IHJhd0JvZHkgPSBhd2FpdCBmZXRjaFJlcy50ZXh0KClcbiAgICAgICAgbGV0IGZldGNoQm9keVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZldGNoQm9keSA9IEpTT04ucGFyc2UocmF3Qm9keSlcbiAgICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmV0Y2hNaWRkbGV3YXJlIC0gZmFpbGVkIHRvIHBhcnNlIHJlc3BvbnNlIGJvZHk6IFwiJHtyYXdCb2R5fVwiYClcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBwYXJzZVJlc3BvbnNlKGZldGNoUmVzLCBmZXRjaEJvZHkpXG4gICAgICAgIC8vIHNldCByZXN1bHQgYW5kIGV4aXQgcmV0cnkgbG9vcFxuICAgICAgICByZXMucmVzdWx0ID0gcmVzdWx0XG4gICAgICAgIHJldHVyblxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGVyci50b1N0cmluZygpXG4gICAgICAgIGNvbnN0IGlzUmV0cmlhYmxlID0gUkVUUklBQkxFX0VSUk9SUy5zb21lKHBocmFzZSA9PiBlcnJNc2cuaW5jbHVkZXMocGhyYXNlKSlcbiAgICAgICAgLy8gcmUtdGhyb3cgZXJyb3IgaWYgbm90IHJldHJpYWJsZVxuICAgICAgICBpZiAoIWlzUmV0cmlhYmxlKSB0aHJvdyBlcnJcbiAgICAgIH1cbiAgICAgIC8vIGRlbGF5IGJlZm9yZSByZXRyeWluZ1xuICAgICAgYXdhaXQgdGltZW91dChyZXRyeUludGVydmFsKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tGb3JIdHRwRXJyb3JzIChmZXRjaFJlcykge1xuICAvLyBjaGVjayBmb3IgZXJyb3JzXG4gIHN3aXRjaCAoZmV0Y2hSZXMuc3RhdHVzKSB7XG4gICAgY2FzZSA0MDU6XG4gICAgICB0aHJvdyBldGhFcnJvcnMucnBjLm1ldGhvZE5vdEZvdW5kKClcblxuICAgIGNhc2UgNDE4OlxuICAgICAgdGhyb3cgY3JlYXRlUmF0ZWxpbWl0RXJyb3IoKVxuXG4gICAgY2FzZSA1MDM6XG4gICAgY2FzZSA1MDQ6XG4gICAgICB0aHJvdyBjcmVhdGVUaW1lb3V0RXJyb3IoKVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlUmVzcG9uc2UgKGZldGNoUmVzLCBib2R5KSB7XG4gIC8vIGNoZWNrIGZvciBlcnJvciBjb2RlXG4gIGlmIChmZXRjaFJlcy5zdGF0dXMgIT09IDIwMCkge1xuICAgIHRocm93IGV0aEVycm9ycy5ycGMuaW50ZXJuYWwoe1xuICAgICAgbWVzc2FnZTogYE5vbi0yMDAgc3RhdHVzIGNvZGU6ICcke2ZldGNoUmVzLnN0YXR1c30nYCxcbiAgICAgIGRhdGE6IGJvZHksXG4gICAgfSlcbiAgfVxuICAvLyBjaGVjayBmb3IgcnBjIGVycm9yXG4gIGlmIChib2R5LmVycm9yKSB0aHJvdyBldGhFcnJvcnMucnBjLmludGVybmFsKHtcbiAgICBkYXRhOiBib2R5LmVycm9yLFxuICB9KVxuICAvLyByZXR1cm4gc3VjY2Vzc2Z1bCByZXN1bHRcbiAgcmV0dXJuIGJvZHkucmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZldGNoQ29uZmlnRnJvbVJlcSh7IHJlcSwgcnBjVXJsLCBvcmlnaW5IdHRwSGVhZGVyS2V5IH0pIHtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHJwY1VybClcbiAgY29uc3QgZmV0Y2hVcmwgPSBub3JtYWxpemVVcmxGcm9tUGFyc2VkKHBhcnNlZFVybClcblxuICAvLyBwcmVwYXJlIHBheWxvYWRcbiAgLy8gY29weSBvbmx5IGNhbm9uaWNhbCBqc29uIHJwYyBwcm9wZXJ0aWVzXG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgaWQ6IHJlcS5pZCxcbiAgICBqc29ucnBjOiByZXEuanNvbnJwYyxcbiAgICBtZXRob2Q6IHJlcS5tZXRob2QsXG4gICAgcGFyYW1zOiByZXEucGFyYW1zLFxuICB9XG5cbiAgLy8gZXh0cmFjdCAnb3JpZ2luJyBwYXJhbWV0ZXIgZnJvbSByZXF1ZXN0XG4gIGNvbnN0IG9yaWdpbkRvbWFpbiA9IHJlcS5vcmlnaW5cblxuICAvLyBzZXJpYWxpemUgcmVxdWVzdCBib2R5XG4gIGNvbnN0IHNlcmlhbGl6ZWRQYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkocGF5bG9hZClcblxuICAvLyBjb25maWd1cmUgZmV0Y2ggcGFyYW1zXG4gIGNvbnN0IGZldGNoUGFyYW1zID0ge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgfSxcbiAgICBib2R5OiBzZXJpYWxpemVkUGF5bG9hZCxcbiAgfVxuXG4gIC8vIGVuY29kZWQgYXV0aCBkZXRhaWxzIGFzIGhlYWRlciAobm90IGFsbG93ZWQgaW4gZmV0Y2ggdXJsKVxuICBpZiAocGFyc2VkVXJsLmF1dGgpIHtcbiAgICBjb25zdCBlbmNvZGVkQXV0aCA9IGJ0b2EocGFyc2VkVXJsLmF1dGgpXG4gICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJhc2ljICR7ZW5jb2RlZEF1dGh9YFxuICB9XG5cbiAgLy8gb3B0aW9uYWw6IGFkZCByZXF1ZXN0IG9yaWdpbiBhcyBoZWFkZXJcbiAgaWYgKG9yaWdpbkh0dHBIZWFkZXJLZXkgJiYgb3JpZ2luRG9tYWluKSB7XG4gICAgZmV0Y2hQYXJhbXMuaGVhZGVyc1tvcmlnaW5IdHRwSGVhZGVyS2V5XSA9IG9yaWdpbkRvbWFpblxuICB9XG5cbiAgcmV0dXJuIHsgZmV0Y2hVcmwsIGZldGNoUGFyYW1zIH1cbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplVXJsRnJvbVBhcnNlZChwYXJzZWRVcmwpIHtcbiAgbGV0IHJlc3VsdCA9ICcnXG4gIHJlc3VsdCArPSBwYXJzZWRVcmwucHJvdG9jb2xcbiAgaWYgKHBhcnNlZFVybC5zbGFzaGVzKSByZXN1bHQgKz0gJy8vJ1xuICByZXN1bHQgKz0gcGFyc2VkVXJsLmhvc3RuYW1lXG4gIGlmIChwYXJzZWRVcmwucG9ydCkge1xuICAgIHJlc3VsdCArPSBgOiR7cGFyc2VkVXJsLnBvcnR9YFxuICB9XG4gIHJlc3VsdCArPSBgJHtwYXJzZWRVcmwucGF0aH1gXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmF0ZWxpbWl0RXJyb3IgKCkge1xuICByZXR1cm4gZXRoRXJyb3JzLnJwYy5pbnRlcm5hbCh7IG1lc3NhZ2U6IGBSZXF1ZXN0IGlzIGJlaW5nIHJhdGUgbGltaXRlZC5gIH0pXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRpbWVvdXRFcnJvciAoKSB7XG4gIGxldCBtc2cgPSBgR2F0ZXdheSB0aW1lb3V0LiBUaGUgcmVxdWVzdCB0b29rIHRvbyBsb25nIHRvIHByb2Nlc3MuIGBcbiAgbXNnICs9IGBUaGlzIGNhbiBoYXBwZW4gd2hlbiBxdWVyeWluZyBsb2dzIG92ZXIgdG9vIHdpZGUgYSBibG9jayByYW5nZS5gXG4gIHJldHVybiBldGhFcnJvcnMucnBjLmludGVybmFsKHsgbWVzc2FnZTogbXNnIH0pXG59XG5cbmZ1bmN0aW9uIHRpbWVvdXQoZHVyYXRpb24pIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbikpXG59XG4iLCJjb25zdCBjbG9uZSA9IHJlcXVpcmUoJ2Nsb25lJylcbmNvbnN0IGNyZWF0ZUFzeW5jTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2pzb24tcnBjLWVuZ2luZS9zcmMvY3JlYXRlQXN5bmNNaWRkbGV3YXJlJylcbmNvbnN0IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQgPSByZXF1aXJlKCcuL2NhY2hlLXV0aWxzJykuY2FjaGVJZGVudGlmaWVyRm9yUGF5bG9hZFxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUluZmxpZ2h0Q2FjaGVcblxuXG5mdW5jdGlvbiBjcmVhdGVJbmZsaWdodENhY2hlICgpIHtcbiAgY29uc3QgaW5mbGlnaHRSZXF1ZXN0cyA9IHt9XG5cbiAgcmV0dXJuIGNyZWF0ZUFzeW5jTWlkZGxld2FyZShhc3luYyAocmVxLCByZXMsIG5leHQpID0+IHtcbiAgICAvLyBhbGxvdyBjYWNoIHRvIGJlIHNraXBwZWQgaWYgc28gc3BlY2lmaWVkXG4gICAgaWYgKHJlcS5za2lwQ2FjaGUpIHJldHVybiBuZXh0KClcbiAgICAvLyBnZXQgY2FjaGVJZCwgaWYgY2FjaGVhYmxlXG4gICAgY29uc3QgY2FjaGVJZCA9IGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocmVxKVxuICAgIC8vIGlmIG5vdCBjYWNoZWFibGUsIHNraXBcbiAgICBpZiAoIWNhY2hlSWQpIHJldHVybiBuZXh0KClcbiAgICAvLyBjaGVjayBmb3IgbWF0Y2hpbmcgcmVxdWVzdHNcbiAgICBsZXQgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXVxuICAgIC8vIGlmIGZvdW5kLCB3YWl0IGZvciB0aGUgYWN0aXZlIHJlcXVlc3QgdG8gYmUgaGFuZGxlZFxuICAgIGlmIChhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAgIC8vIHNldHVwIHRoZSByZXNwb25zZSBsaXN0ZW5lciBhbmQgd2FpdCBmb3IgaXQgdG8gYmUgY2FsbGVkXG4gICAgICAvLyBpdCB3aWxsIGhhbmRsZSBjb3B5aW5nIHRoZSByZXN1bHQgYW5kIHJlcXVlc3QgZmllbGRzXG4gICAgICBhd2FpdCBjcmVhdGVBY3RpdmVSZXF1ZXN0SGFuZGxlcihyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBzZXR1cCByZXNwb25zZSBoYW5kbGVyIGFycmF5IGZvciBzdWJzZXF1ZW50IHJlcXVlc3RzXG4gICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzID0gW11cbiAgICBpbmZsaWdodFJlcXVlc3RzW2NhY2hlSWRdID0gYWN0aXZlUmVxdWVzdEhhbmRsZXJzXG4gICAgLy8gYWxsb3cgcmVxdWVzdCB0byBiZSBoYW5kbGVkIG5vcm1hbGx5XG4gICAgYXdhaXQgbmV4dCgpXG4gICAgLy8gY2xlYXIgaW5mbGlnaHQgcmVxdWVzdHNcbiAgICBkZWxldGUgaW5mbGlnaHRSZXF1ZXN0c1tjYWNoZUlkXVxuICAgIC8vIHNjaGVkdWxlIGFjdGl2ZVJlcXVlc3RIYW5kbGVycyB0byBiZSBoYW5kbGVkXG4gICAgaGFuZGxlQWN0aXZlUmVxdWVzdChyZXMsIGFjdGl2ZVJlcXVlc3RIYW5kbGVycylcbiAgICAvLyBjb21wbGV0ZVxuICAgIHJldHVyblxuICB9KVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFjdGl2ZVJlcXVlc3RIYW5kbGVyKHJlcywgYWN0aXZlUmVxdWVzdEhhbmRsZXJzKSB7XG4gICAgY29uc3QgeyByZXNvbHZlLCBwcm9taXNlIH0gPSBkZWZlcnJlZFByb21pc2UoKVxuICAgIGFjdGl2ZVJlcXVlc3RIYW5kbGVycy5wdXNoKChoYW5kbGVkUmVzKSA9PiB7XG4gICAgICAvLyBhcHBlbmQgYSBjb3B5IG9mIHRoZSByZXN1bHQgYW5kIGVycm9yIHRvIHRoZSByZXNwb25zZVxuICAgICAgcmVzLnJlc3VsdCA9IGNsb25lKGhhbmRsZWRSZXMucmVzdWx0KVxuICAgICAgcmVzLmVycm9yID0gY2xvbmUoaGFuZGxlZFJlcy5lcnJvcilcbiAgICAgIHJlc29sdmUoKVxuICAgIH0pXG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFjdGl2ZVJlcXVlc3QocmVzLCBhY3RpdmVSZXF1ZXN0SGFuZGxlcnMpIHtcbiAgICAvLyB1c2Ugc2V0VGltZW91dCBzbyB3ZSBjYW4gcmVzb2x2ZSBvdXIgb3JpZ2luYWwgcmVxdWVzdCBmaXJzdFxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgYWN0aXZlUmVxdWVzdEhhbmRsZXJzLmZvckVhY2goKGhhbmRsZXIpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBoYW5kbGVyKHJlcylcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgLy8gY2F0Y2ggZXJyb3Igc28gYWxsIHJlcXVlc3RzIGFyZSBoYW5kbGVkIGNvcnJlY3RseVxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmZXJyZWRQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZVxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoX3Jlc29sdmUgPT4geyByZXNvbHZlID0gX3Jlc29sdmUgfSlcbiAgcmV0dXJuIHsgcmVzb2x2ZSwgcHJvbWlzZSB9XG59XG4iLCJcbmNvbnN0IHsgRXRoZXJldW1ScGNFcnJvciwgRXRoZXJldW1Qcm92aWRlckVycm9yIH0gPSByZXF1aXJlKCcuL3NyYy9jbGFzc2VzJylcbmNvbnN0IHtcbiAgc2VyaWFsaXplRXJyb3IsIGdldE1lc3NhZ2VGcm9tQ29kZSxcbn0gPSByZXF1aXJlKCcuL3NyYy91dGlscycpXG5jb25zdCBldGhFcnJvcnMgPSByZXF1aXJlKCcuL3NyYy9lcnJvcnMnKVxuY29uc3QgRVJST1JfQ09ERVMgPSByZXF1aXJlKCcuL3NyYy9lcnJvckNvZGVzLmpzb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXRoRXJyb3JzLFxuICBFdGhlcmV1bVJwY0Vycm9yLFxuICBFdGhlcmV1bVByb3ZpZGVyRXJyb3IsXG4gIHNlcmlhbGl6ZUVycm9yLFxuICBnZXRNZXNzYWdlRnJvbUNvZGUsXG5cbiAgLyoqIEB0eXBlIEVycm9yQ29kZXMgKi9cbiAgRVJST1JfQ09ERVMsXG59XG5cbi8vIFR5cGVzXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRXRoZXJldW1Qcm92aWRlckVycm9yQ29kZXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB1c2VyUmVqZWN0ZWRSZXF1ZXN0XG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5hdXRob3JpemVkXG4gKiBAcHJvcGVydHkge251bWJlcn0gdW5zdXBwb3J0ZWRNZXRob2RcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaXNjb25uZWN0ZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBjaGFpbkRpc2Nvbm5lY3RlZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRXRoZXJldW1ScGNFcnJvckNvZGVzXG4gKiBAcHJvcGVydHkge251bWJlcn0gcGFyc2VcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnZhbGlkUmVxdWVzdFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludmFsaWRQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBtZXRob2ROb3RGb3VuZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGxpbWl0RXhjZWVkZWRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpbnRlcm5hbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGludmFsaWRJbnB1dFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJlc291cmNlTm90Rm91bmRcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSByZXNvdXJjZVVuYXZhaWxhYmxlXG4gKiBAcHJvcGVydHkge251bWJlcn0gdHJhbnNhY3Rpb25SZWplY3RlZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1ldGhvZE5vdFN1cHBvcnRlZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRXJyb3JDb2Rlc1xuICogQHByb3BlcnR5IHtFdGhlcmV1bVJwY0Vycm9yQ29kZXN9IHJwY1xuICogQHByb3BlcnR5IHtFdGhlcmV1bVByb3ZpZGVyRXJyb3JDb2Rlc30gcHJvdmlkZXJcbiAqL1xuIiwiXG5jb25zdCBzYWZlU3RyaW5naWZ5ID0gcmVxdWlyZSgnZmFzdC1zYWZlLXN0cmluZ2lmeScpXG5cbi8qKlxuICogQGNsYXNzIEpzb25ScGNFcnJvclxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEpTT04gUlBDIDIuMCBlcnJvcnMgYW5kIEV0aGVyZXVtIFJQQyBlcnJvcnNcbiAqIHBlciBFSVAgMTQ3NC5cbiAqIFBlcm1pdHMgYW55IGludGVnZXIgZXJyb3IgY29kZS5cbiAqL1xuY2xhc3MgRXRoZXJldW1ScGNFcnJvciBleHRlbmRzIEVycm9yIHtcblxuICAvKipcbiAgICogQ3JlYXRlIGFuIEV0aGVyZXVtIEpTT04gUlBDIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZSAtIFRoZSBpbnRlZ2VyIGVycm9yIGNvZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIHN0cmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge2FueX0gW2RhdGFdIC0gVGhlIGVycm9yIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIuJyxcbiAgICAgIClcbiAgICB9XG4gICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJtZXNzYWdlXCIgbXVzdCBiZSBhIG5vbmVtcHR5IHN0cmluZy4nLFxuICAgICAgKVxuICAgIH1cblxuICAgIHN1cGVyKG1lc3NhZ2UpXG4gICAgdGhpcy5jb2RlID0gY29kZVxuICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZGF0YSA9IGRhdGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHBsYWluIG9iamVjdCB3aXRoIGFsbCBwdWJsaWMgY2xhc3MgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gVGhlIHNlcmlhbGl6ZWQgZXJyb3IuXG4gICAqL1xuICBzZXJpYWxpemUgKCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSB7XG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VyaWFsaXplZC5kYXRhID0gdGhpcy5kYXRhXG4gICAgfVxuICAgIGlmICh0aGlzLnN0YWNrKSB7XG4gICAgICBzZXJpYWxpemVkLnN0YWNrID0gdGhpcy5zdGFja1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2VyaWFsaXplZCBlcnJvciwgb21pdHRpbmdcbiAgICogYW55IGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzZXJpYWxpemVkIGVycm9yIGFzIGEgc3RyaW5nLlxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiBzYWZlU3RyaW5naWZ5KFxuICAgICAgdGhpcy5zZXJpYWxpemUoKSxcbiAgICAgIHN0cmluZ2lmeVJlcGxhY2VyLFxuICAgICAgMixcbiAgICApXG4gIH1cbn1cblxuLyoqXG4gKiBAY2xhc3MgRXRoZXJldW1ScGNFcnJvclxuICogRXJyb3Igc3ViY2xhc3MgaW1wbGVtZW50aW5nIEV0aGVyZXVtIFByb3ZpZGVyIGVycm9ycyBwZXIgRUlQIDExOTMuXG4gKiBQZXJtaXRzIGludGVnZXIgZXJyb3IgY29kZXMgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gKi9cbmNsYXNzIEV0aGVyZXVtUHJvdmlkZXJFcnJvciBleHRlbmRzIEV0aGVyZXVtUnBjRXJyb3Ige1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gRXRoZXJldW0gSlNPTiBSUEMgZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gVGhlIGludGVnZXIgZXJyb3IgY29kZSwgaW4gdGhlIFsgMTAwMCA8PSA0OTk5IF0gcmFuZ2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIHN0cmluZyBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge2FueX0gW2RhdGFdIC0gVGhlIGVycm9yIGRhdGEuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuXG4gICAgaWYgKCFpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImNvZGVcIiBtdXN0IGJlIGFuIGludGVnZXIgc3VjaCB0aGF0OiAxMDAwIDw9IGNvZGUgPD0gNDk5OScsXG4gICAgICApXG4gICAgfVxuXG4gICAgc3VwZXIoY29kZSwgbWVzc2FnZSwgZGF0YSlcbiAgfVxufVxuXG4vLyBJbnRlcm5hbFxuXG5mdW5jdGlvbiBpc1ZhbGlkRXRoUHJvdmlkZXJDb2RlIChjb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpICYmIGNvZGUgPj0gMTAwMCAmJiBjb2RlIDw9IDQ5OTlcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5UmVwbGFjZXIgKF8sIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gJ1tDaXJjdWxhcl0nKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vLyBFeHBvcnRzXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFdGhlcmV1bVJwY0Vycm9yLFxuICBFdGhlcmV1bVByb3ZpZGVyRXJyb3IsXG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwicnBjXCI6IHtcbiAgICBcImludmFsaWRJbnB1dFwiOiAtMzIwMDAsXG4gICAgXCJyZXNvdXJjZU5vdEZvdW5kXCI6IC0zMjAwMSxcbiAgICBcInJlc291cmNlVW5hdmFpbGFibGVcIjogLTMyMDAyLFxuICAgIFwidHJhbnNhY3Rpb25SZWplY3RlZFwiOiAtMzIwMDMsXG4gICAgXCJtZXRob2ROb3RTdXBwb3J0ZWRcIjogLTMyMDA0LFxuICAgIFwibGltaXRFeGNlZWRlZFwiOiAtMzIwMDUsXG4gICAgXCJwYXJzZVwiOiAtMzI3MDAsXG4gICAgXCJpbnZhbGlkUmVxdWVzdFwiOiAtMzI2MDAsXG4gICAgXCJtZXRob2ROb3RGb3VuZFwiOiAtMzI2MDEsXG4gICAgXCJpbnZhbGlkUGFyYW1zXCI6IC0zMjYwMixcbiAgICBcImludGVybmFsXCI6IC0zMjYwM1xuICB9LFxuICBcInByb3ZpZGVyXCI6IHtcbiAgICBcInVzZXJSZWplY3RlZFJlcXVlc3RcIjogNDAwMSxcbiAgICBcInVuYXV0aG9yaXplZFwiOiA0MTAwLFxuICAgIFwidW5zdXBwb3J0ZWRNZXRob2RcIjogNDIwMCxcbiAgICBcImRpc2Nvbm5lY3RlZFwiOiA0OTAwLFxuICAgIFwiY2hhaW5EaXNjb25uZWN0ZWRcIjogNDkwMVxuICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cz17XG4gIFwiLTMyNzAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiSlNPTiBSUEMgMi4wXCIsXG4gICAgXCJtZXNzYWdlXCI6IFwiSW52YWxpZCBKU09OIHdhcyByZWNlaXZlZCBieSB0aGUgc2VydmVyLiBBbiBlcnJvciBvY2N1cnJlZCBvbiB0aGUgc2VydmVyIHdoaWxlIHBhcnNpbmcgdGhlIEpTT04gdGV4dC5cIlxuICB9LFxuICBcIi0zMjYwMFwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIlRoZSBKU09OIHNlbnQgaXMgbm90IGEgdmFsaWQgUmVxdWVzdCBvYmplY3QuXCJcbiAgfSxcbiAgXCItMzI2MDFcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJKU09OIFJQQyAyLjBcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUaGUgbWV0aG9kIGRvZXMgbm90IGV4aXN0IC8gaXMgbm90IGF2YWlsYWJsZS5cIlxuICB9LFxuICBcIi0zMjYwMlwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIkludmFsaWQgbWV0aG9kIHBhcmFtZXRlcihzKS5cIlxuICB9LFxuICBcIi0zMjYwM1wiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkpTT04gUlBDIDIuMFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIkludGVybmFsIEpTT04tUlBDIGVycm9yLlwiXG4gIH0sXG4gIFwiLTMyMDAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDE0NzRcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJJbnZhbGlkIGlucHV0LlwiXG4gIH0sXG4gIFwiLTMyMDAxXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDE0NzRcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJSZXNvdXJjZSBub3QgZm91bmQuXCJcbiAgfSxcbiAgXCItMzIwMDJcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJFSVAgMTQ3NFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIlJlc291cmNlIHVuYXZhaWxhYmxlLlwiXG4gIH0sXG4gIFwiLTMyMDAzXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDE0NzRcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUcmFuc2FjdGlvbiByZWplY3RlZC5cIlxuICB9LFxuICBcIi0zMjAwNFwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkVJUCAxNDc0XCIsXG4gICAgXCJtZXNzYWdlXCI6IFwiTWV0aG9kIG5vdCBzdXBwb3J0ZWQuXCJcbiAgfSxcbiAgXCItMzIwMDVcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJFSVAgMTQ3NFwiLFxuICAgIFwibWVzc2FnZVwiOiBcIlJlcXVlc3QgbGltaXQgZXhjZWVkZWQuXCJcbiAgfSxcbiAgXCI0MDAxXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDExOTNcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJVc2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LlwiXG4gIH0sXG4gIFwiNDEwMFwiOiB7XG4gICAgXCJzdGFuZGFyZFwiOiBcIkVJUCAxMTkzXCIsXG4gICAgXCJtZXNzYWdlXCI6IFwiVGhlIHJlcXVlc3RlZCBhY2NvdW50IGFuZC9vciBtZXRob2QgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuXCJcbiAgfSxcbiAgXCI0MjAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDExOTNcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUaGUgcmVxdWVzdGVkIG1ldGhvZCBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgRXRoZXJldW0gcHJvdmlkZXIuXCJcbiAgfSxcbiAgXCI0OTAwXCI6IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRUlQIDExOTNcIixcbiAgICBcIm1lc3NhZ2VcIjogXCJUaGUgcHJvdmlkZXIgaXMgZGlzY29ubmVjdGVkIGZyb20gYWxsIGNoYWlucy5cIlxuICB9LFxuICBcIjQ5MDFcIjoge1xuICAgIFwic3RhbmRhcmRcIjogXCJFSVAgMTE5M1wiLFxuICAgIFwibWVzc2FnZVwiOiBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIGNoYWluLlwiXG4gIH1cbn1cbiIsIlxuY29uc3QgeyBFdGhlcmV1bVJwY0Vycm9yLCBFdGhlcmV1bVByb3ZpZGVyRXJyb3IgfSA9IHJlcXVpcmUoJy4vY2xhc3NlcycpXG5jb25zdCB7IGdldE1lc3NhZ2VGcm9tQ29kZSB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBFUlJPUl9DT0RFUyA9IHJlcXVpcmUoJy4vZXJyb3JDb2Rlcy5qc29uJylcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJwYzoge1xuXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIFBhcnNlICgtMzI3MDApIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0c10gLSBPcHRpb25zIG9iamVjdCBvciBlcnJvciBtZXNzYWdlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tZXNzYWdlXSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVJwY0Vycm9yfSBUaGUgZXJyb3JcbiAgICAgKi9cbiAgICBwYXJzZTogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5wYXJzZSwgb3B0cyxcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgSlNPTiBSUEMgMi4wIEludmFsaWQgUmVxdWVzdCAoLTMyNjAwKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgaW52YWxpZFJlcXVlc3Q6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMuaW52YWxpZFJlcXVlc3QsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnZhbGlkIFBhcmFtcyAoLTMyNjAyKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgaW52YWxpZFBhcmFtczogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5pbnZhbGlkUGFyYW1zLCBvcHRzLFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSBKU09OIFJQQyAyLjAgTWV0aG9kIE5vdCBGb3VuZCAoLTMyNjAxKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgbWV0aG9kTm90Rm91bmQ6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMubWV0aG9kTm90Rm91bmQsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBJbnRlcm5hbCAoLTMyNjAzKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgaW50ZXJuYWw6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMuaW50ZXJuYWwsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIEpTT04gUlBDIDIuMCBTZXJ2ZXIgZXJyb3IuXG4gICAgICogUGVybWl0cyBpbnRlZ2VyIGVycm9yIGNvZGVzIGluIHRoZSBbIC0zMjA5OSA8PSAtMzIwMDUgXSByYW5nZS5cbiAgICAgKiBDb2RlcyAtMzIwMDAgdGhyb3VnaCAtMzIwMDQgYXJlIHJlc2VydmVkIGJ5IEVJUCAxNDc0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvcHRzIC0gT3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3B0cy5jb2RlIC0gVGhlIGVycm9yIGNvZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgc2VydmVyOiAob3B0cykgPT4ge1xuICAgICAgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXRoZXJldW0gUlBDIFNlcnZlciBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuJylcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29kZSB9ID0gb3B0c1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvZGUpIHx8IGNvZGUgPiAtMzIwMDUgfHwgY29kZSA8IC0zMjA5OSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1wiY29kZVwiIG11c3QgYmUgYW4gaW50ZWdlciBzdWNoIHRoYXQ6IC0zMjA5OSA8PSBjb2RlIDw9IC0zMjAwNScsXG4gICAgICAgIClcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRFdGhKc29uUnBjRXJyb3IoY29kZSwgb3B0cylcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIEludmFsaWQgSW5wdXQgKC0zMjAwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUnBjRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIGludmFsaWRJbnB1dDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5pbnZhbGlkSW5wdXQsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBSZXNvdXJjZSBOb3QgRm91bmQgKC0zMjAwMSkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUnBjRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIHJlc291cmNlTm90Rm91bmQ6IChvcHRzKSA9PiBnZXRFdGhKc29uUnBjRXJyb3IoXG4gICAgICBFUlJPUl9DT0RFUy5ycGMucmVzb3VyY2VOb3RGb3VuZCwgb3B0cyxcbiAgICApLFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIEpTT04gUlBDIFJlc291cmNlIFVuYXZhaWxhYmxlICgtMzIwMDIpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0c10gLSBPcHRpb25zIG9iamVjdCBvciBlcnJvciBtZXNzYWdlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tZXNzYWdlXSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVJwY0Vycm9yfSBUaGUgZXJyb3JcbiAgICAgKi9cbiAgICByZXNvdXJjZVVuYXZhaWxhYmxlOiAob3B0cykgPT4gZ2V0RXRoSnNvblJwY0Vycm9yKFxuICAgICAgRVJST1JfQ09ERVMucnBjLnJlc291cmNlVW5hdmFpbGFibGUsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBUcmFuc2FjdGlvbiBSZWplY3RlZCAoLTMyMDAzKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgdHJhbnNhY3Rpb25SZWplY3RlZDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy50cmFuc2FjdGlvblJlamVjdGVkLCBvcHRzLFxuICAgICksXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gSlNPTiBSUEMgTWV0aG9kIE5vdCBTdXBwb3J0ZWQgKC0zMjAwNCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUnBjRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIG1ldGhvZE5vdFN1cHBvcnRlZDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5tZXRob2ROb3RTdXBwb3J0ZWQsIG9wdHMsXG4gICAgKSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBKU09OIFJQQyBMaW1pdCBFeGNlZWRlZCAoLTMyMDA1KSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1ScGNFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgbGltaXRFeGNlZWRlZDogKG9wdHMpID0+IGdldEV0aEpzb25ScGNFcnJvcihcbiAgICAgIEVSUk9SX0NPREVTLnJwYy5saW1pdEV4Y2VlZGVkLCBvcHRzLFxuICAgICksXG4gIH0sXG5cbiAgcHJvdmlkZXI6IHtcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBVc2VyIFJlamVjdGVkIFJlcXVlc3QgKDQwMDEpIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBbb3B0c10gLSBPcHRpb25zIG9iamVjdCBvciBlcnJvciBtZXNzYWdlIHN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5tZXNzYWdlXSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIHVzZXJSZWplY3RlZFJlcXVlc3Q6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIudXNlclJlamVjdGVkUmVxdWVzdCwgb3B0cyxcbiAgICAgIClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuYXV0aG9yaXplZCAoNDEwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUHJvdmlkZXJFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgdW5hdXRob3JpemVkOiAob3B0cykgPT4ge1xuICAgICAgcmV0dXJuIGdldEV0aFByb3ZpZGVyRXJyb3IoXG4gICAgICAgIEVSUk9SX0NPREVTLnByb3ZpZGVyLnVuYXV0aG9yaXplZCwgb3B0cyxcbiAgICAgIClcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0IGFuIEV0aGVyZXVtIFByb3ZpZGVyIFVuc3VwcG9ydGVkIE1ldGhvZCAoNDIwMCkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUHJvdmlkZXJFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgdW5zdXBwb3J0ZWRNZXRob2Q6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIudW5zdXBwb3J0ZWRNZXRob2QsIG9wdHMsXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhbiBFdGhlcmV1bSBQcm92aWRlciBOb3QgQ29ubmVjdGVkICg0OTAwKSBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gW29wdHNdIC0gT3B0aW9ucyBvYmplY3Qgb3IgZXJyb3IgbWVzc2FnZSBzdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMubWVzc2FnZV0gLSBUaGUgZXJyb3IgbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7YW55fSBbb3B0cy5kYXRhXSAtIEVycm9yIGRhdGFcbiAgICAgKiBAcmV0dXJucyB7RXRoZXJldW1Qcm92aWRlckVycm9yfSBUaGUgZXJyb3JcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWQ6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIuZGlzY29ubmVjdGVkLCBvcHRzLFxuICAgICAgKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgYW4gRXRoZXJldW0gUHJvdmlkZXIgQ2hhaW4gTm90IENvbm5lY3RlZCAoNDkwMSkgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IFtvcHRzXSAtIE9wdGlvbnMgb2JqZWN0IG9yIGVycm9yIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLm1lc3NhZ2VdIC0gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0ge2FueX0gW29wdHMuZGF0YV0gLSBFcnJvciBkYXRhXG4gICAgICogQHJldHVybnMge0V0aGVyZXVtUHJvdmlkZXJFcnJvcn0gVGhlIGVycm9yXG4gICAgICovXG4gICAgY2hhaW5EaXNjb25uZWN0ZWQ6IChvcHRzKSA9PiB7XG4gICAgICByZXR1cm4gZ2V0RXRoUHJvdmlkZXJFcnJvcihcbiAgICAgICAgRVJST1JfQ09ERVMucHJvdmlkZXIuY2hhaW5EaXNjb25uZWN0ZWQsIG9wdHMsXG4gICAgICApXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhIGN1c3RvbSBFdGhlcmV1bSBQcm92aWRlciBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30gb3B0cyAtIE9wdGlvbnMgb2JqZWN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9wdHMuY29kZSAtIFRoZSBlcnJvciBjb2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdHMubWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlXG4gICAgICogQHBhcmFtIHthbnl9IFtvcHRzLmRhdGFdIC0gRXJyb3IgZGF0YVxuICAgICAqIEByZXR1cm5zIHtFdGhlcmV1bVByb3ZpZGVyRXJyb3J9IFRoZSBlcnJvclxuICAgICAqL1xuICAgIGN1c3RvbTogKG9wdHMpID0+IHtcbiAgICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V0aGVyZXVtIFByb3ZpZGVyIGN1c3RvbSBlcnJvcnMgbXVzdCBwcm92aWRlIHNpbmdsZSBvYmplY3QgYXJndW1lbnQuJylcbiAgICAgIH1cbiAgICAgIGNvbnN0IHsgY29kZSwgbWVzc2FnZSwgZGF0YSB9ID0gb3B0c1xuICAgICAgaWYgKCFtZXNzYWdlIHx8IHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ1wibWVzc2FnZVwiIG11c3QgYmUgYSBub25lbXB0eSBzdHJpbmcnLFxuICAgICAgICApXG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKVxuICAgIH0sXG4gIH0sXG59XG5cbi8vIEludGVybmFsXG5cbmZ1bmN0aW9uIGdldEV0aEpzb25ScGNFcnJvciAoY29kZSwgb3B0cykge1xuICBjb25zdCBbbWVzc2FnZSwgZGF0YV0gPSB2YWxpZGF0ZU9wdHMob3B0cylcbiAgcmV0dXJuIG5ldyBFdGhlcmV1bVJwY0Vycm9yKFxuICAgIGNvZGUsXG4gICAgbWVzc2FnZSB8fCBnZXRNZXNzYWdlRnJvbUNvZGUoY29kZSksXG4gICAgZGF0YSxcbiAgKVxufVxuXG5mdW5jdGlvbiBnZXRFdGhQcm92aWRlckVycm9yIChjb2RlLCBvcHRzKSB7XG4gIGNvbnN0IFttZXNzYWdlLCBkYXRhXSA9IHZhbGlkYXRlT3B0cyhvcHRzKVxuICByZXR1cm4gbmV3IEV0aGVyZXVtUHJvdmlkZXJFcnJvcihcbiAgICBjb2RlLFxuICAgIG1lc3NhZ2UgfHwgZ2V0TWVzc2FnZUZyb21Db2RlKGNvZGUpLFxuICAgIGRhdGEsXG4gIClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzIChvcHRzKSB7XG4gIGlmIChvcHRzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIFtvcHRzXVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgICBjb25zdCB7IG1lc3NhZ2UsIGRhdGEgfSA9IG9wdHNcbiAgICAgIHJldHVybiBbbWVzc2FnZSwgZGF0YV1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtdXG59XG4iLCJcbmNvbnN0IGVycm9yVmFsdWVzID0gcmVxdWlyZSgnLi9lcnJvclZhbHVlcy5qc29uJylcbmNvbnN0IEZBTExCQUNLX0VSUk9SX0NPREUgPSByZXF1aXJlKCcuL2Vycm9yQ29kZXMuanNvbicpLnJwYy5pbnRlcm5hbFxuY29uc3QgeyBFdGhlcmV1bVJwY0Vycm9yIH0gPSByZXF1aXJlKCcuL2NsYXNzZXMnKVxuXG5jb25zdCBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUVTU0FHRSA9ICdVbnNwZWNpZmllZCBzZXJ2ZXIgZXJyb3IuJ1xuXG5jb25zdCBGQUxMQkFDS19NRVNTQUdFID0gJ1Vuc3BlY2lmaWVkIGVycm9yIG1lc3NhZ2UuIFRoaXMgaXMgYSBidWcsIHBsZWFzZSByZXBvcnQgaXQuJ1xuXG5jb25zdCBGQUxMQkFDS19FUlJPUiA9IHtcbiAgY29kZTogRkFMTEJBQ0tfRVJST1JfQ09ERSxcbiAgbWVzc2FnZTogZ2V0TWVzc2FnZUZyb21Db2RlKEZBTExCQUNLX0VSUk9SX0NPREUpLFxufVxuXG4vKipcbiAqIEdldHMgdGhlIG1lc3NhZ2UgZm9yIGEgZ2l2ZW4gY29kZSwgb3IgYSBmYWxsYmFjayBtZXNzYWdlIGlmIHRoZSBjb2RlIGhhc1xuICogbm8gY29ycmVzcG9uZGluZyBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gVGhlIGludGVnZXIgZXJyb3IgY29kZVxuICogQHBhcmFtIHtzdHJpbmd9IGZhbGxiYWNrTWVzc2FnZSAtIFRoZSBmYWxsYmFjayBtZXNzYWdlXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBjb3JyZXNwb25kaW5nIG1lc3NhZ2Ugb3IgdGhlIGZhbGxiYWNrIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gZ2V0TWVzc2FnZUZyb21Db2RlIChjb2RlLCBmYWxsYmFja01lc3NhZ2UgPSBGQUxMQkFDS19NRVNTQUdFKSB7XG5cbiAgaWYgKE51bWJlci5pc0ludGVnZXIoY29kZSkpIHtcblxuICAgIGNvbnN0IGNvZGVTdHJpbmcgPSBjb2RlLnRvU3RyaW5nKClcblxuICAgIGlmIChlcnJvclZhbHVlc1tjb2RlU3RyaW5nXSkge1xuICAgICAgcmV0dXJuIGVycm9yVmFsdWVzW2NvZGVTdHJpbmddLm1lc3NhZ2VcbiAgICB9XG4gICAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgICByZXR1cm4gSlNPTl9SUENfU0VSVkVSX0VSUk9SX01FU1NBR0VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbGxiYWNrTWVzc2FnZVxufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gY29kZSBpcyB2YWxpZC5cbiAqIEEgY29kZSBpcyBvbmx5IHZhbGlkIGlmIGl0IGhhcyBhIG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGNvZGUgLSBUaGUgY29kZSB0byBjaGVja1xuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgY29kZSBpcyB2YWxpZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29kZSAoY29kZSkge1xuXG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihjb2RlKSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgY29uc3QgY29kZVN0cmluZyA9IGNvZGUudG9TdHJpbmcoKVxuICBpZiAoZXJyb3JWYWx1ZXNbY29kZVN0cmluZ10pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgaWYgKGlzSnNvblJwY1NlcnZlckVycm9yKGNvZGUpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIFRPRE86IGFsbG93IHZhbGlkIGNvZGVzIGFuZCBtZXNzYWdlcyB0byBiZSBleHRlbmRlZFxuICAvLyAvLyBFSVAgMTE5MyBTdGF0dXMgQ29kZXNcbiAgLy8gaWYgKGNvZGUgPj0gNDAwMCAmJiBjb2RlIDw9IDQ5OTkpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgZ2l2ZW4gZXJyb3IgdG8gYW4gRXRoZXJldW0gSlNPTiBSUEMtY29tcGF0aWJsZSBlcnJvciBvYmplY3QuXG4gKiBNZXJlbHkgY29waWVzIHRoZSBnaXZlbiBlcnJvcidzIHZhbHVlcyBpZiBpdCBpcyBhbHJlYWR5IGNvbXBhdGlibGUuXG4gKiBJZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgbm90IGZ1bGx5IGNvbXBhdGlibGUsIGl0IHdpbGwgYmUgcHJlc2VydmVkIG9uIHRoZVxuICogcmV0dXJuZWQgb2JqZWN0J3MgZGF0YS5vcmlnaW5hbEVycm9yIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7YW55fSBlcnJvciAtIFRoZSBlcnJvciB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gQW4gb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmFsbGJhY2tFcnJvcl0gLSBUaGUgY3VzdG9tIGZhbGxiYWNrIGVycm9yIHZhbHVlcyBpZlxuICogdGhlIGdpdmVuIGVycm9yIGlzIGludmFsaWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNob3VsZEluY2x1ZGVTdGFja10gLSBXaGV0aGVyIHRoZSAnc3RhY2snIHByb3BlcnR5XG4gKiBvZiB0aGUgZ2l2ZW4gZXJyb3Igc2hvdWxkIGJlIGluY2x1ZGVkIG9uIHRoZSBzZXJpYWxpemVkIGVycm9yLCBpZiBwcmVzZW50LlxuICogQHJldHVybiB7T2JqZWN0fSBBIHN0YW5kYXJkaXplZCwgcGxhaW4gZXJyb3Igb2JqZWN0LlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVFcnJvciAoXG4gIGVycm9yLFxuICB7IGZhbGxiYWNrRXJyb3IgPSBGQUxMQkFDS19FUlJPUiwgc2hvdWxkSW5jbHVkZVN0YWNrID0gZmFsc2UgfSA9IHt9LFxuKSB7XG5cbiAgaWYgKFxuICAgICFmYWxsYmFja0Vycm9yIHx8XG4gICAgIU51bWJlci5pc0ludGVnZXIoZmFsbGJhY2tFcnJvci5jb2RlKSB8fFxuICAgIHR5cGVvZiBmYWxsYmFja0Vycm9yLm1lc3NhZ2UgIT09ICdzdHJpbmcnXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdNdXN0IHByb3ZpZGUgZmFsbGJhY2sgZXJyb3Igd2l0aCBpbnRlZ2VyIG51bWJlciBjb2RlIGFuZCBzdHJpbmcgbWVzc2FnZS4nLFxuICAgIClcbiAgfVxuXG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEV0aGVyZXVtUnBjRXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3Iuc2VyaWFsaXplKClcbiAgfVxuXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSB7fVxuXG4gIGlmIChlcnJvciAmJiBpc1ZhbGlkQ29kZShlcnJvci5jb2RlKSkge1xuXG4gICAgc2VyaWFsaXplZC5jb2RlID0gZXJyb3IuY29kZVxuXG4gICAgaWYgKGVycm9yLm1lc3NhZ2UgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzZXJpYWxpemVkLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlXG4gICAgICBpZiAoJ2RhdGEnIGluIGVycm9yKSB7XG4gICAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IGVycm9yLmRhdGFcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2VyaWFsaXplZC5tZXNzYWdlID0gZ2V0TWVzc2FnZUZyb21Db2RlKHNlcmlhbGl6ZWQuY29kZSlcbiAgICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHsgb3JpZ2luYWxFcnJvcjogYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikgfVxuICAgIH1cblxuICB9IGVsc2Uge1xuICAgIHNlcmlhbGl6ZWQuY29kZSA9IGZhbGxiYWNrRXJyb3IuY29kZVxuICAgIHNlcmlhbGl6ZWQubWVzc2FnZSA9IChcbiAgICAgIGVycm9yICYmIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgPyBlcnJvci5tZXNzYWdlXG4gICAgICAgIDogZmFsbGJhY2tFcnJvci5tZXNzYWdlXG4gICAgKVxuICAgIHNlcmlhbGl6ZWQuZGF0YSA9IHsgb3JpZ2luYWxFcnJvcjogYXNzaWduT3JpZ2luYWxFcnJvcihlcnJvcikgfVxuICB9XG5cbiAgaWYgKHNob3VsZEluY2x1ZGVTdGFjayAmJiBlcnJvciAmJiB0eXBlb2YgZXJyb3Iuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgc2VyaWFsaXplZC5zdGFjayA9IGVycm9yLnN0YWNrXG4gIH1cbiAgcmV0dXJuIHNlcmlhbGl6ZWRcbn1cblxuLy8gSW50ZXJuYWxcblxuZnVuY3Rpb24gaXNKc29uUnBjU2VydmVyRXJyb3IgKGNvZGUpIHtcbiAgcmV0dXJuIGNvZGUgPj0gLTMyMDk5ICYmIGNvZGUgPD0gLTMyMDAwXG59XG5cbmZ1bmN0aW9uIGFzc2lnbk9yaWdpbmFsRXJyb3IgKGVycm9yKSB7XG4gIGlmIChlcnJvciAmJiB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGVycm9yKSkge1xuICAgIHJldHVybiB7IC4uLmVycm9yIH1cbiAgfVxuICByZXR1cm4gZXJyb3Jcbn1cblxuLy8gRXhwb3J0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0TWVzc2FnZUZyb21Db2RlLFxuICBpc1ZhbGlkQ29kZSxcbiAgc2VyaWFsaXplRXJyb3IsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NRVNTQUdFLFxufVxuIiwiY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBldGhBYmkgPSByZXF1aXJlKCdldGhlcmV1bWpzLWFiaScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXG4gIGNvbmNhdFNpZzogZnVuY3Rpb24gKHYsIHIsIHMpIHtcbiAgICBjb25zdCByU2lnID0gZXRoVXRpbC5mcm9tU2lnbmVkKHIpXG4gICAgY29uc3Qgc1NpZyA9IGV0aFV0aWwuZnJvbVNpZ25lZChzKVxuICAgIGNvbnN0IHZTaWcgPSBldGhVdGlsLmJ1ZmZlclRvSW50KHYpXG4gICAgY29uc3QgclN0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHJTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3Qgc1N0ciA9IHBhZFdpdGhaZXJvZXMoZXRoVXRpbC50b1Vuc2lnbmVkKHNTaWcpLnRvU3RyaW5nKCdoZXgnKSwgNjQpXG4gICAgY29uc3QgdlN0ciA9IGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgoZXRoVXRpbC5pbnRUb0hleCh2U2lnKSlcbiAgICByZXR1cm4gZXRoVXRpbC5hZGRIZXhQcmVmaXgoclN0ci5jb25jYXQoc1N0ciwgdlN0cikpLnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIG5vcm1hbGl6ZTogZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgaWYgKCFpbnB1dCkgcmV0dXJuXG5cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgYnVmZmVyID0gZXRoVXRpbC50b0J1ZmZlcihpbnB1dClcbiAgICAgIGlucHV0ID0gZXRoVXRpbC5idWZmZXJUb0hleChidWZmZXIpXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBtc2cgPSAnZXRoLXNpZy11dGlsLm5vcm1hbGl6ZSgpIHJlcXVpcmVzIGhleCBzdHJpbmcgb3IgaW50ZWdlciBpbnB1dC4nXG4gICAgICBtc2cgKz0gJyByZWNlaXZlZCAnICsgKHR5cGVvZiBpbnB1dCkgKyAnOiAnICsgaW5wdXRcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuXG4gICAgcmV0dXJuIGV0aFV0aWwuYWRkSGV4UHJlZml4KGlucHV0LnRvTG93ZXJDYXNlKCkpXG4gIH0sXG5cbiAgcGVyc29uYWxTaWduOiBmdW5jdGlvbiAocHJpdmF0ZUtleSwgbXNnUGFyYW1zKSB7XG4gICAgdmFyIG1lc3NhZ2UgPSBldGhVdGlsLnRvQnVmZmVyKG1zZ1BhcmFtcy5kYXRhKVxuICAgIHZhciBtc2dIYXNoID0gZXRoVXRpbC5oYXNoUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2UpXG4gICAgdmFyIHNpZyA9IGV0aFV0aWwuZWNzaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpXG4gICAgdmFyIHNlcmlhbGl6ZWQgPSBldGhVdGlsLmJ1ZmZlclRvSGV4KHRoaXMuY29uY2F0U2lnKHNpZy52LCBzaWcuciwgc2lnLnMpKVxuICAgIHJldHVybiBzZXJpYWxpemVkXG4gIH0sXG5cbiAgcmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlOiBmdW5jdGlvbiAobXNnUGFyYW1zKSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5Rm9yKG1zZ1BhcmFtcylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgY29uc3Qgc2VuZGVySGV4ID0gZXRoVXRpbC5idWZmZXJUb0hleChzZW5kZXIpXG4gICAgcmV0dXJuIHNlbmRlckhleFxuICB9LFxuXG4gIGV4dHJhY3RQdWJsaWNLZXk6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGb3IobXNnUGFyYW1zKVxuICAgIHJldHVybiAnMHgnICsgcHVibGljS2V5LnRvU3RyaW5nKCdoZXgnKVxuICB9LFxuXG4gIHR5cGVkU2lnbmF0dXJlSGFzaDogZnVuY3Rpb24gKHR5cGVkRGF0YSkge1xuICAgIGNvbnN0IGhhc2hCdWZmZXIgPSB0eXBlZFNpZ25hdHVyZUhhc2godHlwZWREYXRhKVxuICAgIHJldHVybiBldGhVdGlsLmJ1ZmZlclRvSGV4KGhhc2hCdWZmZXIpXG4gIH0sXG5cbiAgc2lnblR5cGVkRGF0YTogZnVuY3Rpb24gKHByaXZhdGVLZXksIG1zZ1BhcmFtcykge1xuICAgIGNvbnN0IG1zZ0hhc2ggPSB0eXBlZFNpZ25hdHVyZUhhc2gobXNnUGFyYW1zLmRhdGEpXG4gICAgY29uc3Qgc2lnID0gZXRoVXRpbC5lY3NpZ24obXNnSGFzaCwgcHJpdmF0ZUtleSlcbiAgICByZXR1cm4gZXRoVXRpbC5idWZmZXJUb0hleCh0aGlzLmNvbmNhdFNpZyhzaWcudiwgc2lnLnIsIHNpZy5zKSlcbiAgfSxcblxuICByZWNvdmVyVHlwZWRTaWduYXR1cmU6IGZ1bmN0aW9uIChtc2dQYXJhbXMpIHtcbiAgICBjb25zdCBtc2dIYXNoID0gdHlwZWRTaWduYXR1cmVIYXNoKG1zZ1BhcmFtcy5kYXRhKVxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCwgbXNnUGFyYW1zLnNpZylcbiAgICBjb25zdCBzZW5kZXIgPSBldGhVdGlsLnB1YmxpY1RvQWRkcmVzcyhwdWJsaWNLZXkpXG4gICAgcmV0dXJuIGV0aFV0aWwuYnVmZmVyVG9IZXgoc2VuZGVyKVxuICB9XG5cbn1cblxuLyoqXG4gKiBAcGFyYW0gdHlwZWREYXRhIC0gQXJyYXkgb2YgZGF0YSBhbG9uZyB3aXRoIHR5cGVzLCBhcyBwZXIgRUlQNzEyLlxuICogQHJldHVybnMgQnVmZmVyXG4gKi9cbmZ1bmN0aW9uIHR5cGVkU2lnbmF0dXJlSGFzaCh0eXBlZERhdGEpIHtcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0V4cGVjdCBhcmd1bWVudCB0byBiZSBub24tZW1wdHkgYXJyYXknKVxuICBpZiAodHlwZW9mIHR5cGVkRGF0YSAhPT0gJ29iamVjdCcgfHwgIXR5cGVkRGF0YS5sZW5ndGgpIHRocm93IGVycm9yXG5cbiAgY29uc3QgZGF0YSA9IHR5cGVkRGF0YS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICByZXR1cm4gZS50eXBlID09PSAnYnl0ZXMnID8gZXRoVXRpbC50b0J1ZmZlcihlLnZhbHVlKSA6IGUudmFsdWVcbiAgfSlcbiAgY29uc3QgdHlwZXMgPSB0eXBlZERhdGEubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnR5cGUgfSlcbiAgY29uc3Qgc2NoZW1hID0gdHlwZWREYXRhLm1hcChmdW5jdGlvbiAoZSkge1xuICAgIGlmICghZS5uYW1lKSB0aHJvdyBlcnJvclxuICAgIHJldHVybiBlLnR5cGUgKyAnICcgKyBlLm5hbWVcbiAgfSlcblxuICByZXR1cm4gZXRoQWJpLnNvbGlkaXR5U0hBMyhcbiAgICBbJ2J5dGVzMzInLCAnYnl0ZXMzMiddLFxuICAgIFtcbiAgICAgIGV0aEFiaS5zb2xpZGl0eVNIQTMobmV3IEFycmF5KHR5cGVkRGF0YS5sZW5ndGgpLmZpbGwoJ3N0cmluZycpLCBzY2hlbWEpLFxuICAgICAgZXRoQWJpLnNvbGlkaXR5U0hBMyh0eXBlcywgZGF0YSlcbiAgICBdXG4gIClcbn1cblxuZnVuY3Rpb24gcmVjb3ZlclB1YmxpY0tleShoYXNoLCBzaWcpIHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gZXRoVXRpbC50b0J1ZmZlcihzaWcpXG4gIGNvbnN0IHNpZ1BhcmFtcyA9IGV0aFV0aWwuZnJvbVJwY1NpZyhzaWduYXR1cmUpXG4gIHJldHVybiBldGhVdGlsLmVjcmVjb3ZlcihoYXNoLCBzaWdQYXJhbXMudiwgc2lnUGFyYW1zLnIsIHNpZ1BhcmFtcy5zKVxufVxuXG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGb3IgKG1zZ1BhcmFtcykge1xuICBjb25zdCBtZXNzYWdlID0gZXRoVXRpbC50b0J1ZmZlcihtc2dQYXJhbXMuZGF0YSlcbiAgY29uc3QgbXNnSGFzaCA9IGV0aFV0aWwuaGFzaFBlcnNvbmFsTWVzc2FnZShtZXNzYWdlKVxuICByZXR1cm4gcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoLCBtc2dQYXJhbXMuc2lnKVxufVxuXG5cbmZ1bmN0aW9uIHBhZFdpdGhaZXJvZXMgKG51bWJlciwgbGVuZ3RoKSB7XG4gIHZhciBteVN0cmluZyA9ICcnICsgbnVtYmVyXG4gIHdoaWxlIChteVN0cmluZy5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICBteVN0cmluZyA9ICcwJyArIG15U3RyaW5nXG4gIH1cbiAgcmV0dXJuIG15U3RyaW5nXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnZXRoZXJldW0tY3J5cHRvZ3JhcGh5L2tlY2NhaycpLFxuICAgIGtlY2NhazIyNCA9IF9yZXF1aXJlLmtlY2NhazIyNCxcbiAgICBrZWNjYWszODQgPSBfcmVxdWlyZS5rZWNjYWszODQsXG4gICAgazI1NiA9IF9yZXF1aXJlLmtlY2NhazI1NixcbiAgICBrZWNjYWs1MTIgPSBfcmVxdWlyZS5rZWNjYWs1MTI7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCcuL3NlY3AyNTZrMS1hZGFwdGVyJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgcmxwID0gcmVxdWlyZSgncmxwJyk7XG52YXIgQk4gPSByZXF1aXJlKCdibi5qcycpO1xudmFyIGNyZWF0ZUhhc2ggPSByZXF1aXJlKCdjcmVhdGUtaGFzaCcpO1xudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuT2JqZWN0LmFzc2lnbihleHBvcnRzLCByZXF1aXJlKCdldGhqcy11dGlsJykpO1xuXG4vKipcbiAqIHRoZSBtYXggaW50ZWdlciB0aGF0IHRoaXMgVk0gY2FuIGhhbmRsZSAoYSBgYGBCTmBgYClcbiAqIEB2YXIge0JOfSBNQVhfSU5URUdFUlxuICovXG5leHBvcnRzLk1BWF9JTlRFR0VSID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpO1xuXG4vKipcbiAqIDJeMjU2IChhIGBgYEJOYGBgKVxuICogQHZhciB7Qk59IFRXT19QT1cyNTZcbiAqL1xuZXhwb3J0cy5UV09fUE9XMjU2ID0gbmV3IEJOKCcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsIDE2KTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9OVUxMX1NcbiAqL1xuZXhwb3J0cy5LRUNDQUsyNTZfTlVMTF9TID0gJ2M1ZDI0NjAxODZmNzIzM2M5MjdlN2RiMmRjYzcwM2MwZTUwMGI2NTNjYTgyMjczYjdiZmFkODA0NWQ4NWE0NzAnO1xuZXhwb3J0cy5TSEEzX05VTExfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X05VTExfUztcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgbnVsbCAoYSBgYGBCdWZmZXJgYGApXG4gKiBAdmFyIHtCdWZmZXJ9IEtFQ0NBSzI1Nl9OVUxMXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X05VTEwgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9OVUxMX1MsICdoZXgnKTtcbmV4cG9ydHMuU0hBM19OVUxMID0gZXhwb3J0cy5LRUNDQUsyNTZfTlVMTDtcblxuLyoqXG4gKiBLZWNjYWstMjU2IG9mIGFuIFJMUCBvZiBhbiBlbXB0eSBhcnJheSAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfQVJSQVlfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUyA9ICcxZGNjNGRlOGRlYzc1ZDdhYWI4NWI1NjdiNmNjZDQxYWQzMTI0NTFiOTQ4YTc0MTNmMGExNDJmZDQwZDQ5MzQ3JztcbmV4cG9ydHMuU0hBM19STFBfQVJSQVlfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWV9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgb2YgYW4gUkxQIG9mIGFuIGVtcHR5IGFycmF5IChhIGBgYEJ1ZmZlcmBgYClcbiAqIEB2YXIge0J1ZmZlcn0gS0VDQ0FLMjU2X1JMUF9BUlJBWVxuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVkgPSBCdWZmZXIuZnJvbShleHBvcnRzLktFQ0NBSzI1Nl9STFBfQVJSQVlfUywgJ2hleCcpO1xuZXhwb3J0cy5TSEEzX1JMUF9BUlJBWSA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9BUlJBWTtcblxuLyoqXG4gKiBLZWNjYWstMjU2IGhhc2ggb2YgdGhlIFJMUCBvZiBudWxsICAoYSBgYGBTdHJpbmdgYGApXG4gKiBAdmFyIHtTdHJpbmd9IEtFQ0NBSzI1Nl9STFBfU1xuICovXG5leHBvcnRzLktFQ0NBSzI1Nl9STFBfUyA9ICc1NmU4MWYxNzFiY2M1NWE2ZmY4MzQ1ZTY5MmMwZjg2ZTViNDhlMDFiOTk2Y2FkYzAwMTYyMmZiNWUzNjNiNDIxJztcbmV4cG9ydHMuU0hBM19STFBfUyA9IGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TO1xuXG4vKipcbiAqIEtlY2Nhay0yNTYgaGFzaCBvZiB0aGUgUkxQIG9mIG51bGwgKGEgYGBgQnVmZmVyYGBgKVxuICogQHZhciB7QnVmZmVyfSBLRUNDQUsyNTZfUkxQXG4gKi9cbmV4cG9ydHMuS0VDQ0FLMjU2X1JMUCA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuS0VDQ0FLMjU2X1JMUF9TLCAnaGV4Jyk7XG5leHBvcnRzLlNIQTNfUkxQID0gZXhwb3J0cy5LRUNDQUsyNTZfUkxQO1xuXG4vKipcbiAqIFtgQk5gXShodHRwczovL2dpdGh1Yi5jb20vaW5kdXRueS9ibi5qcylcbiAqIEB2YXIge0Z1bmN0aW9ufVxuICovXG5leHBvcnRzLkJOID0gQk47XG5cbi8qKlxuICogW2BybHBgXShodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW1qcy9ybHApXG4gKiBAdmFyIHtGdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5ybHAgPSBybHA7XG5cbi8qKlxuICogW2BzZWNwMjU2azFgXShodHRwczovL2dpdGh1Yi5jb20vY3J5cHRvY29pbmpzL3NlY3AyNTZrMS1ub2RlLylcbiAqIEB2YXIge09iamVjdH1cbiAqL1xuZXhwb3J0cy5zZWNwMjU2azEgPSBzZWNwMjU2azE7XG5cbi8qKlxuICogUmV0dXJucyBhIGJ1ZmZlciBmaWxsZWQgd2l0aCAwc1xuICogQG1ldGhvZCB6ZXJvc1xuICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzICB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBidWZmZXIgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMuemVyb3MgPSBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgcmV0dXJuIEJ1ZmZlci5hbGxvY1Vuc2FmZShieXRlcykuZmlsbCgwKTtcbn07XG5cbi8qKlxuICAqIFJldHVybnMgYSB6ZXJvIGFkZHJlc3NcbiAgKiBAbWV0aG9kIHplcm9BZGRyZXNzXG4gICogQHJldHVybiB7U3RyaW5nfVxuICAqL1xuZXhwb3J0cy56ZXJvQWRkcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFkZHJlc3NMZW5ndGggPSAyMDtcbiAgdmFyIHplcm9BZGRyZXNzID0gZXhwb3J0cy56ZXJvcyhhZGRyZXNzTGVuZ3RoKTtcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoemVyb0FkZHJlc3MpO1xufTtcblxuLyoqXG4gKiBMZWZ0IFBhZHMgYW4gYEFycmF5YCBvciBgQnVmZmVyYCB3aXRoIGxlYWRpbmcgemVyb3MgdGlsbCBpdCBoYXMgYGxlbmd0aGAgYnl0ZXMuXG4gKiBPciBpdCB0cnVuY2F0ZXMgdGhlIGJlZ2lubmluZyBpZiBpdCBleGNlZWRzLlxuICogQG1ldGhvZCBsc2V0TGVuZ3RoXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheX0gbXNnIHRoZSB2YWx1ZSB0byBwYWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggdGhlIG51bWJlciBvZiBieXRlcyB0aGUgb3V0cHV0IHNob3VsZCBiZVxuICogQHBhcmFtIHtCb29sZWFufSBbcmlnaHQ9ZmFsc2VdIHdoZXRoZXIgdG8gc3RhcnQgcGFkZGluZyBmb3JtIHRoZSBsZWZ0IG9yIHJpZ2h0XG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoTGVmdCA9IGV4cG9ydHMuc2V0TGVuZ3RoID0gZnVuY3Rpb24gKG1zZywgbGVuZ3RoLCByaWdodCkge1xuICB2YXIgYnVmID0gZXhwb3J0cy56ZXJvcyhsZW5ndGgpO1xuICBtc2cgPSBleHBvcnRzLnRvQnVmZmVyKG1zZyk7XG4gIGlmIChyaWdodCkge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgwLCBsZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGlmIChtc2cubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICBtc2cuY29weShidWYsIGxlbmd0aCAtIG1zZy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG4gICAgcmV0dXJuIG1zZy5zbGljZSgtbGVuZ3RoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSaWdodCBQYWRzIGFuIGBBcnJheWAgb3IgYEJ1ZmZlcmAgd2l0aCBsZWFkaW5nIHplcm9zIHRpbGwgaXQgaGFzIGBsZW5ndGhgIGJ5dGVzLlxuICogT3IgaXQgdHJ1bmNhdGVzIHRoZSBiZWdpbm5pbmcgaWYgaXQgZXhjZWVkcy5cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBtc2cgdGhlIHZhbHVlIHRvIHBhZFxuICogQHBhcmFtIHtOdW1iZXJ9IGxlbmd0aCB0aGUgbnVtYmVyIG9mIGJ5dGVzIHRoZSBvdXRwdXQgc2hvdWxkIGJlXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl9XG4gKi9cbmV4cG9ydHMuc2V0TGVuZ3RoUmlnaHQgPSBmdW5jdGlvbiAobXNnLCBsZW5ndGgpIHtcbiAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKG1zZywgbGVuZ3RoLCB0cnVlKTtcbn07XG5cbi8qKlxuICogVHJpbXMgbGVhZGluZyB6ZXJvcyBmcm9tIGEgYEJ1ZmZlcmAgb3IgYW4gYEFycmF5YFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfSBhXG4gKiBAcmV0dXJuIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfVxuICovXG5leHBvcnRzLnVucGFkID0gZXhwb3J0cy5zdHJpcFplcm9zID0gZnVuY3Rpb24gKGEpIHtcbiAgYSA9IGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoYSk7XG4gIHZhciBmaXJzdCA9IGFbMF07XG4gIHdoaWxlIChhLmxlbmd0aCA+IDAgJiYgZmlyc3QudG9TdHJpbmcoKSA9PT0gJzAnKSB7XG4gICAgYSA9IGEuc2xpY2UoMSk7XG4gICAgZmlyc3QgPSBhWzBdO1xuICB9XG4gIHJldHVybiBhO1xufTtcbi8qKlxuICogQXR0ZW1wdHMgdG8gdHVybiBhIHZhbHVlIGludG8gYSBgQnVmZmVyYC4gQXMgaW5wdXQgaXQgc3VwcG9ydHMgYEJ1ZmZlcmAsIGBTdHJpbmdgLCBgTnVtYmVyYCwgbnVsbC91bmRlZmluZWQsIGBCTmAgYW5kIG90aGVyIG9iamVjdHMgd2l0aCBhIGB0b0FycmF5KClgIG1ldGhvZC5cbiAqIEBwYXJhbSB7Kn0gdiB0aGUgdmFsdWVcbiAqL1xuZXhwb3J0cy50b0J1ZmZlciA9IGZ1bmN0aW9uICh2KSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHYpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgIHYgPSBCdWZmZXIuZnJvbSh2KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xuICAgICAgaWYgKGV4cG9ydHMuaXNIZXhTdHJpbmcodikpIHtcbiAgICAgICAgdiA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMucGFkVG9FdmVuKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgodikpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gQnVmZmVyLmZyb20odik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcbiAgICAgIHYgPSBleHBvcnRzLmludFRvQnVmZmVyKHYpO1xuICAgIH0gZWxzZSBpZiAodiA9PT0gbnVsbCB8fCB2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMCk7XG4gICAgfSBlbHNlIGlmIChCTi5pc0JOKHYpKSB7XG4gICAgICB2ID0gdi50b0FycmF5TGlrZShCdWZmZXIpO1xuICAgIH0gZWxzZSBpZiAodi50b0FycmF5KSB7XG4gICAgICAvLyBjb252ZXJ0cyBhIEJOIHRvIGEgQnVmZmVyXG4gICAgICB2ID0gQnVmZmVyLmZyb20odi50b0FycmF5KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdHlwZScpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdjtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCB0byBhIGBOdW1iZXJgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAdGhyb3dzIElmIHRoZSBpbnB1dCBudW1iZXIgZXhjZWVkcyA1MyBiaXRzLlxuICovXG5leHBvcnRzLmJ1ZmZlclRvSW50ID0gZnVuY3Rpb24gKGJ1Zikge1xuICByZXR1cm4gbmV3IEJOKGV4cG9ydHMudG9CdWZmZXIoYnVmKSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBpbnRvIGEgaGV4IGBTdHJpbmdgXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYnVmZmVyVG9IZXggPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGJ1ZiA9IGV4cG9ydHMudG9CdWZmZXIoYnVmKTtcbiAgcmV0dXJuICcweCcgKyBidWYudG9TdHJpbmcoJ2hleCcpO1xufTtcblxuLyoqXG4gKiBJbnRlcnByZXRzIGEgYEJ1ZmZlcmAgYXMgYSBzaWduZWQgaW50ZWdlciBhbmQgcmV0dXJucyBhIGBCTmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCdWZmZXJ9IG51bVxuICogQHJldHVybiB7Qk59XG4gKi9cbmV4cG9ydHMuZnJvbVNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIG5ldyBCTihudW0pLmZyb21Ud29zKDI1Nik7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgYEJOYCB0byBhbiB1bnNpZ25lZCBpbnRlZ2VyIGFuZCByZXR1cm5zIGl0IGFzIGEgYEJ1ZmZlcmAuIEFzc3VtZXMgMjU2LWJpdCBudW1iZXJzLlxuICogQHBhcmFtIHtCTn0gbnVtXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMudG9VbnNpZ25lZCA9IGZ1bmN0aW9uIChudW0pIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKG51bS50b1R3b3MoMjU2KS50b0FycmF5KCkpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIEtlY2NhayBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ9IFtiaXRzPTI1Nl0gdGhlIEtlY2NhayB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLmtlY2NhayA9IGZ1bmN0aW9uIChhLCBiaXRzKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICBpZiAoIWJpdHMpIGJpdHMgPSAyNTY7XG5cbiAgc3dpdGNoIChiaXRzKSB7XG4gICAgY2FzZSAyMjQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrZWNjYWsyMjQoYSk7XG4gICAgICB9XG4gICAgY2FzZSAyNTY6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBrMjU2KGEpO1xuICAgICAgfVxuICAgIGNhc2UgMzg0OlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrMzg0KGEpO1xuICAgICAgfVxuICAgIGNhc2UgNTEyOlxuICAgICAge1xuICAgICAgICByZXR1cm4ga2VjY2FrNTEyKGEpO1xuICAgICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxkIGFsZ29yaXRobToga2VjY2FrJyArIGJpdHMpO1xuICAgICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgS2VjY2FrLTI1NiBoYXNoIG9mIHRoZSBpbnB1dCwgYWxpYXMgZm9yIGtlY2NhayhhLCAyNTYpXG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMua2VjY2FrMjU2ID0gZnVuY3Rpb24gKGEpIHtcbiAgcmV0dXJuIGV4cG9ydHMua2VjY2FrKGEpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIChLZWNjYWspIGhhc2ggb2YgdGhlIGlucHV0IFtPQlNPTEVURV1cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fFN0cmluZ3xOdW1iZXJ9IGEgdGhlIGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBbYml0cz0yNTZdIHRoZSBTSEEtMyB3aWR0aFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTMgPSBleHBvcnRzLmtlY2NhaztcblxuLyoqXG4gKiBDcmVhdGVzIFNIQTI1NiBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnNoYTI1NiA9IGZ1bmN0aW9uIChhKSB7XG4gIGEgPSBleHBvcnRzLnRvQnVmZmVyKGEpO1xuICByZXR1cm4gY3JlYXRlSGFzaCgnc2hhMjU2JykudXBkYXRlKGEpLmRpZ2VzdCgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIFJJUEVNRDE2MCBoYXNoIG9mIHRoZSBpbnB1dFxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXl8U3RyaW5nfE51bWJlcn0gYSB0aGUgaW5wdXQgZGF0YVxuICogQHBhcmFtIHtCb29sZWFufSBwYWRkZWQgd2hldGhlciBpdCBzaG91bGQgYmUgcGFkZGVkIHRvIDI1NiBiaXRzIG9yIG5vdFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5leHBvcnRzLnJpcGVtZDE2MCA9IGZ1bmN0aW9uIChhLCBwYWRkZWQpIHtcbiAgYSA9IGV4cG9ydHMudG9CdWZmZXIoYSk7XG4gIHZhciBoYXNoID0gY3JlYXRlSGFzaCgncm1kMTYwJykudXBkYXRlKGEpLmRpZ2VzdCgpO1xuICBpZiAocGFkZGVkID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuc2V0TGVuZ3RoKGhhc2gsIDMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxufTtcblxuLyoqXG4gKiBDcmVhdGVzIFNIQS0zIGhhc2ggb2YgdGhlIFJMUCBlbmNvZGVkIHZlcnNpb24gb2YgdGhlIGlucHV0XG4gKiBAcGFyYW0ge0J1ZmZlcnxBcnJheXxTdHJpbmd8TnVtYmVyfSBhIHRoZSBpbnB1dCBkYXRhXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucmxwaGFzaCA9IGZ1bmN0aW9uIChhKSB7XG4gIHJldHVybiBleHBvcnRzLmtlY2NhayhybHAuZW5jb2RlKGEpKTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcml2YXRlIGtleSBzYXRpc2ZpZXMgdGhlIHJ1bGVzIG9mIHRoZSBjdXJ2ZSBzZWNwMjU2azEuXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkUHJpdmF0ZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHJldHVybiBzZWNwMjU2azEucHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwdWJsaWMga2V5IHNhdGlzZmllcyB0aGUgcnVsZXMgb2YgdGhlIGN1cnZlIHNlY3AyNTZrMVxuICogYW5kIHRoZSByZXF1aXJlbWVudHMgb2YgRXRoZXJldW0uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IFRoZSB0d28gcG9pbnRzIG9mIGFuIHVuY29tcHJlc3NlZCBrZXksIHVubGVzcyBzYW5pdGl6ZSBpcyBlbmFibGVkXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtzYW5pdGl6ZT1mYWxzZV0gQWNjZXB0IHB1YmxpYyBrZXlzIGluIG90aGVyIGZvcm1hdHNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNWYWxpZFB1YmxpYyA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHNhbml0aXplKSB7XG4gIGlmIChwdWJsaWNLZXkubGVuZ3RoID09PSA2NCkge1xuICAgIC8vIENvbnZlcnQgdG8gU0VDMSBmb3Igc2VjcDI1NmsxXG4gICAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoQnVmZmVyLmNvbmNhdChbQnVmZmVyLmZyb20oWzRdKSwgcHVibGljS2V5XSkpO1xuICB9XG5cbiAgaWYgKCFzYW5pdGl6ZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBzZWNwMjU2azEucHVibGljS2V5VmVyaWZ5KHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwdWJsaWMga2V5LlxuICogQWNjZXB0cyBcIkV0aGVyZXVtIHB1YmxpYyBrZXlzXCIgYW5kIFNFQzEgZW5jb2RlZCBrZXlzLlxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YktleSBUaGUgdHdvIHBvaW50cyBvZiBhbiB1bmNvbXByZXNzZWQga2V5LCB1bmxlc3Mgc2FuaXRpemUgaXMgZW5hYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBbc2FuaXRpemU9ZmFsc2VdIEFjY2VwdCBwdWJsaWMga2V5cyBpbiBvdGhlciBmb3JtYXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbmV4cG9ydHMucHViVG9BZGRyZXNzID0gZXhwb3J0cy5wdWJsaWNUb0FkZHJlc3MgPSBmdW5jdGlvbiAocHViS2V5LCBzYW5pdGl6ZSkge1xuICBwdWJLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHB1YktleSk7XG4gIGlmIChzYW5pdGl6ZSAmJiBwdWJLZXkubGVuZ3RoICE9PSA2NCkge1xuICAgIHB1YktleSA9IHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KHB1YktleSwgZmFsc2UpLnNsaWNlKDEpO1xuICB9XG4gIGFzc2VydChwdWJLZXkubGVuZ3RoID09PSA2NCk7XG4gIC8vIE9ubHkgdGFrZSB0aGUgbG93ZXIgMTYwYml0cyBvZiB0aGUgaGFzaFxuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsocHViS2V5KS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBldGhlcmV1bSBwdWJsaWMga2V5IG9mIGEgZ2l2ZW4gcHJpdmF0ZSBrZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5IEEgcHJpdmF0ZSBrZXkgbXVzdCBiZSAyNTYgYml0cyB3aWRlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlVG9QdWJsaWMgPSBleHBvcnRzLnByaXZhdGVUb1B1YmxpYyA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHByaXZhdGVLZXkgPSBleHBvcnRzLnRvQnVmZmVyKHByaXZhdGVLZXkpO1xuICAvLyBza2lwIHRoZSB0eXBlIGZsYWcgYW5kIHVzZSB0aGUgWCwgWSBwb2ludHNcbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUocHJpdmF0ZUtleSwgZmFsc2UpLnNsaWNlKDEpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIHB1YmxpYyBrZXkgdG8gdGhlIEV0aGVyZXVtIGZvcm1hdC5cbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5pbXBvcnRQdWJsaWMgPSBmdW5jdGlvbiAocHVibGljS2V5KSB7XG4gIHB1YmxpY0tleSA9IGV4cG9ydHMudG9CdWZmZXIocHVibGljS2V5KTtcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDY0KSB7XG4gICAgcHVibGljS2V5ID0gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQocHVibGljS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07XG5cbi8qKlxuICogRUNEU0Egc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1zZ0hhc2hcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZWNzaWduID0gZnVuY3Rpb24gKG1zZ0hhc2gsIHByaXZhdGVLZXkpIHtcbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZhdGVLZXkpO1xuXG4gIHZhciByZXQgPSB7fTtcbiAgcmV0LnIgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDAsIDMyKTtcbiAgcmV0LnMgPSBzaWcuc2lnbmF0dXJlLnNsaWNlKDMyLCA2NCk7XG4gIHJldC52ID0gc2lnLnJlY292ZXJ5ICsgMjc7XG4gIHJldHVybiByZXQ7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtlY2Nhay0yNTYgaGFzaCBvZiBgbWVzc2FnZWAsIHByZWZpeGVkIHdpdGggdGhlIGhlYWRlciB1c2VkIGJ5IHRoZSBgZXRoX3NpZ25gIFJQQyBjYWxsLlxuICogVGhlIG91dHB1dCBvZiB0aGlzIGZ1bmN0aW9uIGNhbiBiZSBmZWQgaW50byBgZWNzaWduYCB0byBwcm9kdWNlIHRoZSBzYW1lIHNpZ25hdHVyZSBhcyB0aGUgYGV0aF9zaWduYFxuICogY2FsbCBmb3IgYSBnaXZlbiBgbWVzc2FnZWAsIG9yIGZlZCB0byBgZWNyZWNvdmVyYCBhbG9uZyB3aXRoIGEgc2lnbmF0dXJlIHRvIHJlY292ZXIgdGhlIHB1YmxpYyBrZXlcbiAqIHVzZWQgdG8gcHJvZHVjZSB0aGUgc2lnbmF0dXJlLlxuICogQHBhcmFtIG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtCdWZmZXJ9IGhhc2hcbiAqL1xuZXhwb3J0cy5oYXNoUGVyc29uYWxNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgdmFyIHByZWZpeCA9IGV4cG9ydHMudG9CdWZmZXIoJ1xceDE5RXRoZXJldW0gU2lnbmVkIE1lc3NhZ2U6XFxuJyArIG1lc3NhZ2UubGVuZ3RoLnRvU3RyaW5nKCkpO1xuICByZXR1cm4gZXhwb3J0cy5rZWNjYWsoQnVmZmVyLmNvbmNhdChbcHJlZml4LCBtZXNzYWdlXSkpO1xufTtcblxuLyoqXG4gKiBFQ0RTQSBwdWJsaWMga2V5IHJlY292ZXJ5IGZyb20gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbXNnSGFzaFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqL1xuZXhwb3J0cy5lY3JlY292ZXIgPSBmdW5jdGlvbiAobXNnSGFzaCwgdiwgciwgcykge1xuICB2YXIgc2lnbmF0dXJlID0gQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGgociwgMzIpLCBleHBvcnRzLnNldExlbmd0aChzLCAzMildLCA2NCk7XG4gIHZhciByZWNvdmVyeSA9IHYgLSAyNztcbiAgaWYgKHJlY292ZXJ5ICE9PSAwICYmIHJlY292ZXJ5ICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNpZ25hdHVyZSB2IHZhbHVlJyk7XG4gIH1cbiAgdmFyIHNlbmRlclB1YktleSA9IHNlY3AyNTZrMS5yZWNvdmVyKG1zZ0hhc2gsIHNpZ25hdHVyZSwgcmVjb3ZlcnkpO1xuICByZXR1cm4gc2VjcDI1NmsxLnB1YmxpY0tleUNvbnZlcnQoc2VuZGVyUHViS2V5LCBmYWxzZSkuc2xpY2UoMSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgc2lnbmF0dXJlIHBhcmFtZXRlcnMgaW50byB0aGUgZm9ybWF0IG9mIGBldGhfc2lnbmAgUlBDIG1ldGhvZFxuICogQHBhcmFtIHtOdW1iZXJ9IHZcbiAqIEBwYXJhbSB7QnVmZmVyfSByXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc1xuICogQHJldHVybiB7U3RyaW5nfSBzaWdcbiAqL1xuZXhwb3J0cy50b1JwY1NpZyA9IGZ1bmN0aW9uICh2LCByLCBzKSB7XG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZWNvdmVyeSBpZCcpO1xuICB9XG5cbiAgLy8gZ2V0aCAoYW5kIHRoZSBSUEMgZXRoX3NpZ24gbWV0aG9kKSB1c2VzIHRoZSA2NSBieXRlIGZvcm1hdCB1c2VkIGJ5IEJpdGNvaW5cbiAgLy8gRklYTUU6IHRoaXMgbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUgLSBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vZ28tZXRoZXJldW0vaXNzdWVzLzIwNTNcbiAgcmV0dXJuIGV4cG9ydHMuYnVmZmVyVG9IZXgoQnVmZmVyLmNvbmNhdChbZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHIsIDMyKSwgZXhwb3J0cy5zZXRMZW5ndGhMZWZ0KHMsIDMyKSwgZXhwb3J0cy50b0J1ZmZlcih2IC0gMjcpXSkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHNpZ25hdHVyZSBmb3JtYXQgb2YgdGhlIGBldGhfc2lnbmAgUlBDIG1ldGhvZCB0byBzaWduYXR1cmUgcGFyYW1ldGVyc1xuICogTk9URTogYWxsIGJlY2F1c2Ugb2YgYSBidWcgaW4gZ2V0aDogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL2dvLWV0aGVyZXVtL2lzc3Vlcy8yMDUzXG4gKiBAcGFyYW0ge1N0cmluZ30gc2lnXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZnJvbVJwY1NpZyA9IGZ1bmN0aW9uIChzaWcpIHtcbiAgc2lnID0gZXhwb3J0cy50b0J1ZmZlcihzaWcpO1xuXG4gIC8vIE5PVEU6IHdpdGggcG90ZW50aWFsIGludHJvZHVjdGlvbiBvZiBjaGFpbklkIHRoaXMgbWlnaHQgbmVlZCB0byBiZSB1cGRhdGVkXG4gIGlmIChzaWcubGVuZ3RoICE9PSA2NSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzaWduYXR1cmUgbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgdiA9IHNpZ1s2NF07XG4gIC8vIHN1cHBvcnQgYm90aCB2ZXJzaW9ucyBvZiBgZXRoX3NpZ25gIHJlc3BvbnNlc1xuICBpZiAodiA8IDI3KSB7XG4gICAgdiArPSAyNztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdjogdixcbiAgICByOiBzaWcuc2xpY2UoMCwgMzIpLFxuICAgIHM6IHNpZy5zbGljZSgzMiwgNjQpXG4gIH07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV0aGVyZXVtIGFkZHJlc3Mgb2YgYSBnaXZlbiBwcml2YXRlIGtleVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXkgQSBwcml2YXRlIGtleSBtdXN0IGJlIDI1NiBiaXRzIHdpZGVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5wcml2YXRlVG9BZGRyZXNzID0gZnVuY3Rpb24gKHByaXZhdGVLZXkpIHtcbiAgcmV0dXJuIGV4cG9ydHMucHVibGljVG9BZGRyZXNzKHByaXZhdGVUb1B1YmxpYyhwcml2YXRlS2V5KSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgYWRkcmVzcyBpcyBhIHZhbGlkLiBBY2NlcHRzIGNoZWNrc3VtbWVkIGFkZHJlc3NlcyB0b29cbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRBZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuICgvXjB4WzAtOWEtZkEtRl17NDB9JC8udGVzdChhZGRyZXNzKVxuICApO1xufTtcblxuLyoqXG4gICogQ2hlY2tzIGlmIGEgZ2l2ZW4gYWRkcmVzcyBpcyBhIHplcm8gYWRkcmVzc1xuICAqIEBtZXRob2QgaXNaZXJvQWRkcmVzc1xuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKi9cbmV4cG9ydHMuaXNaZXJvQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gIHZhciB6ZXJvQWRkcmVzcyA9IGV4cG9ydHMuemVyb0FkZHJlc3MoKTtcbiAgcmV0dXJuIHplcm9BZGRyZXNzID09PSBleHBvcnRzLmFkZEhleFByZWZpeChhZGRyZXNzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9DaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICBhZGRyZXNzID0gZXhwb3J0cy5zdHJpcEhleFByZWZpeChhZGRyZXNzKS50b0xvd2VyQ2FzZSgpO1xuICB2YXIgaGFzaCA9IGV4cG9ydHMua2VjY2FrKGFkZHJlc3MpLnRvU3RyaW5nKCdoZXgnKTtcbiAgdmFyIHJldCA9ICcweCc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhZGRyZXNzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHBhcnNlSW50KGhhc2hbaV0sIDE2KSA+PSA4KSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXQgKz0gYWRkcmVzc1tpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGFkZHJlc3MgaXMgYSB2YWxpZCBjaGVja3N1bW1lZCBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ZhbGlkQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgcmV0dXJuIGV4cG9ydHMuaXNWYWxpZEFkZHJlc3MoYWRkcmVzcykgJiYgZXhwb3J0cy50b0NoZWNrc3VtQWRkcmVzcyhhZGRyZXNzKSA9PT0gYWRkcmVzcztcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIGFuIGFkZHJlc3Mgb2YgYSBuZXdseSBjcmVhdGVkIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gZnJvbSB0aGUgYWRkcmVzcyB3aGljaCBpcyBjcmVhdGluZyB0aGlzIG5ldyBhZGRyZXNzXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbm9uY2UgdGhlIG5vbmNlIG9mIHRoZSBmcm9tIGFjY291bnRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUFkZHJlc3MgPSBmdW5jdGlvbiAoZnJvbSwgbm9uY2UpIHtcbiAgZnJvbSA9IGV4cG9ydHMudG9CdWZmZXIoZnJvbSk7XG4gIG5vbmNlID0gbmV3IEJOKG5vbmNlKTtcblxuICBpZiAobm9uY2UuaXNaZXJvKCkpIHtcbiAgICAvLyBpbiBSTFAgd2Ugd2FudCB0byBlbmNvZGUgbnVsbCBpbiB0aGUgY2FzZSBvZiB6ZXJvIG5vbmNlXG4gICAgLy8gcmVhZCB0aGUgUkxQIGRvY3VtZW50YXRpb24gZm9yIGFuIGFuc3dlciBpZiB5b3UgZGFyZVxuICAgIG5vbmNlID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICBub25jZSA9IEJ1ZmZlci5mcm9tKG5vbmNlLnRvQXJyYXkoKSk7XG4gIH1cblxuICAvLyBPbmx5IHRha2UgdGhlIGxvd2VyIDE2MGJpdHMgb2YgdGhlIGhhc2hcbiAgcmV0dXJuIGV4cG9ydHMucmxwaGFzaChbZnJvbSwgbm9uY2VdKS5zbGljZSgtMjApO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHN1cHBsaWVkIGFkZHJlc3MgYmVsb25ncyB0byBhIHByZWNvbXBpbGVkIGFjY291bnQgKEJ5emFudGl1bSlcbiAqIEBwYXJhbSB7QnVmZmVyfFN0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1ByZWNvbXBpbGVkID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgdmFyIGEgPSBleHBvcnRzLnVucGFkKGFkZHJlc3MpO1xuICByZXR1cm4gYS5sZW5ndGggPT09IDEgJiYgYVswXSA+PSAxICYmIGFbMF0gPD0gODtcbn07XG5cbi8qKlxuICogQWRkcyBcIjB4XCIgdG8gYSBnaXZlbiBgU3RyaW5nYCBpZiBpdCBkb2VzIG5vdCBhbHJlYWR5IHN0YXJ0IHdpdGggXCIweFwiXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMuYWRkSGV4UHJlZml4ID0gZnVuY3Rpb24gKHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMuaXNIZXhQcmVmaXhlZChzdHIpID8gc3RyIDogJzB4JyArIHN0cjtcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgRUNEU0Egc2lnbmF0dXJlXG4gKiBAbWV0aG9kIGlzVmFsaWRTaWduYXR1cmVcbiAqIEBwYXJhbSB7QnVmZmVyfSB2XG4gKiBAcGFyYW0ge0J1ZmZlcn0gclxuICogQHBhcmFtIHtCdWZmZXJ9IHNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2hvbWVzdGVhZD10cnVlXVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuXG5leHBvcnRzLmlzVmFsaWRTaWduYXR1cmUgPSBmdW5jdGlvbiAodiwgciwgcywgaG9tZXN0ZWFkKSB7XG4gIHZhciBTRUNQMjU2SzFfTl9ESVZfMiA9IG5ldyBCTignN2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmY1ZDU3NmU3MzU3YTQ1MDFkZGZlOTJmNDY2ODFiMjBhMCcsIDE2KTtcbiAgdmFyIFNFQ1AyNTZLMV9OID0gbmV3IEJOKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWJhYWVkY2U2YWY0OGEwM2JiZmQyNWU4Y2QwMzY0MTQxJywgMTYpO1xuXG4gIGlmIChyLmxlbmd0aCAhPT0gMzIgfHwgcy5sZW5ndGggIT09IDMyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHYgIT09IDI3ICYmIHYgIT09IDI4KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgciA9IG5ldyBCTihyKTtcbiAgcyA9IG5ldyBCTihzKTtcblxuICBpZiAoci5pc1plcm8oKSB8fCByLmd0KFNFQ1AyNTZLMV9OKSB8fCBzLmlzWmVybygpIHx8IHMuZ3QoU0VDUDI1NksxX04pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGhvbWVzdGVhZCA9PT0gZmFsc2UgJiYgbmV3IEJOKHMpLmNtcChTRUNQMjU2SzFfTl9ESVZfMikgPT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgYSBgQnVmZmVyYCBvciBgQXJyYXlgIHRvIEpTT05cbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5fSBiYVxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfG51bGx9XG4gKi9cbmV4cG9ydHMuYmFUb0pTT04gPSBmdW5jdGlvbiAoYmEpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihiYSkpIHtcbiAgICByZXR1cm4gJzB4JyArIGJhLnRvU3RyaW5nKCdoZXgnKTtcbiAgfSBlbHNlIGlmIChiYSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYS5sZW5ndGg7IGkrKykge1xuICAgICAgYXJyYXkucHVzaChleHBvcnRzLmJhVG9KU09OKGJhW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZWZpbmVzIHByb3BlcnRpZXMgb24gYSBgT2JqZWN0YC4gSXQgbWFrZSB0aGUgYXNzdW1wdGlvbiB0aGF0IHVuZGVybHlpbmcgZGF0YSBpcyBiaW5hcnkuXG4gKiBAcGFyYW0ge09iamVjdH0gc2VsZiB0aGUgYE9iamVjdGAgdG8gZGVmaW5lIHByb3BlcnRpZXMgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGZpZWxkcyBhbiBhcnJheSBmaWVsZHMgdG8gZGVmaW5lLiBGaWVsZHMgY2FuIGNvbnRhaW46XG4gKiAqIGBuYW1lYCAtIHRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0aWVzXG4gKiAqIGBsZW5ndGhgIC0gdGhlIG51bWJlciBvZiBieXRlcyB0aGUgZmllbGQgY2FuIGhhdmVcbiAqICogYGFsbG93TGVzc2AgLSBpZiB0aGUgZmllbGQgY2FuIGJlIGxlc3MgdGhhbiB0aGUgbGVuZ3RoXG4gKiAqIGBhbGxvd0VtcHR5YFxuICogQHBhcmFtIHsqfSBkYXRhIGRhdGEgdG8gYmUgdmFsaWRhdGVkIGFnYWluc3QgdGhlIGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydHMuZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChzZWxmLCBmaWVsZHMsIGRhdGEpIHtcbiAgc2VsZi5yYXcgPSBbXTtcbiAgc2VsZi5fZmllbGRzID0gW107XG5cbiAgLy8gYXR0YWNoIHRoZSBgdG9KU09OYFxuICBzZWxmLnRvSlNPTiA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIGlmIChsYWJlbCkge1xuICAgICAgdmFyIG9iaiA9IHt9O1xuICAgICAgc2VsZi5fZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkKSB7XG4gICAgICAgIG9ialtmaWVsZF0gPSAnMHgnICsgc2VsZltmaWVsZF0udG9TdHJpbmcoJ2hleCcpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICByZXR1cm4gZXhwb3J0cy5iYVRvSlNPTih0aGlzLnJhdyk7XG4gIH07XG5cbiAgc2VsZi5zZXJpYWxpemUgPSBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgcmV0dXJuIHJscC5lbmNvZGUoc2VsZi5yYXcpO1xuICB9O1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCwgaSkge1xuICAgIHNlbGYuX2ZpZWxkcy5wdXNoKGZpZWxkLm5hbWUpO1xuICAgIGZ1bmN0aW9uIGdldHRlcigpIHtcbiAgICAgIHJldHVybiBzZWxmLnJhd1tpXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0dGVyKHYpIHtcbiAgICAgIHYgPSBleHBvcnRzLnRvQnVmZmVyKHYpO1xuXG4gICAgICBpZiAodi50b1N0cmluZygnaGV4JykgPT09ICcwMCcgJiYgIWZpZWxkLmFsbG93WmVybykge1xuICAgICAgICB2ID0gQnVmZmVyLmFsbG9jVW5zYWZlKDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmllbGQuYWxsb3dMZXNzICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICB2ID0gZXhwb3J0cy5zdHJpcFplcm9zKHYpO1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID49IHYubGVuZ3RoLCAnVGhlIGZpZWxkICcgKyBmaWVsZC5uYW1lICsgJyBtdXN0IG5vdCBoYXZlIG1vcmUgJyArIGZpZWxkLmxlbmd0aCArICcgYnl0ZXMnKTtcbiAgICAgIH0gZWxzZSBpZiAoIShmaWVsZC5hbGxvd1plcm8gJiYgdi5sZW5ndGggPT09IDApICYmIGZpZWxkLmxlbmd0aCkge1xuICAgICAgICBhc3NlcnQoZmllbGQubGVuZ3RoID09PSB2Lmxlbmd0aCwgJ1RoZSBmaWVsZCAnICsgZmllbGQubmFtZSArICcgbXVzdCBoYXZlIGJ5dGUgbGVuZ3RoIG9mICcgKyBmaWVsZC5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLnJhd1tpXSA9IHY7XG4gICAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIGZpZWxkLm5hbWUsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGdldHRlcixcbiAgICAgIHNldDogc2V0dGVyXG4gICAgfSk7XG5cbiAgICBpZiAoZmllbGQuZGVmYXVsdCkge1xuICAgICAgc2VsZltmaWVsZC5uYW1lXSA9IGZpZWxkLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gYXR0YWNoIGFsaWFzXG4gICAgaWYgKGZpZWxkLmFsaWFzKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2VsZiwgZmllbGQuYWxpYXMsIHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgc2V0OiBzZXR0ZXIsXG4gICAgICAgIGdldDogZ2V0dGVyXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGlmIHRoZSBjb25zdHVjdG9yIGlzIHBhc3NlZCBkYXRhXG4gIGlmIChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgZGF0YSA9IEJ1ZmZlci5mcm9tKGV4cG9ydHMuc3RyaXBIZXhQcmVmaXgoZGF0YSksICdoZXgnKTtcbiAgICB9XG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICBkYXRhID0gcmxwLmRlY29kZShkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgaWYgKGRhdGEubGVuZ3RoID4gc2VsZi5fZmllbGRzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyb25nIG51bWJlciBvZiBmaWVsZHMgaW4gZGF0YScpO1xuICAgICAgfVxuXG4gICAgICAvLyBtYWtlIHN1cmUgYWxsIHRoZSBpdGVtcyBhcmUgYnVmZmVyc1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHNlbGZbc2VsZi5fZmllbGRzW2ldXSA9IGV4cG9ydHMudG9CdWZmZXIoZCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgICAgIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChmaWVsZCkge1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGZpZWxkLm5hbWUpICE9PSAtMSkgc2VsZltmaWVsZC5uYW1lXSA9IGRhdGFbZmllbGQubmFtZV07XG4gICAgICAgIGlmIChrZXlzLmluZGV4T2YoZmllbGQuYWxpYXMpICE9PSAtMSkgc2VsZltmaWVsZC5hbGlhc10gPSBkYXRhW2ZpZWxkLmFsaWFzXTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZGF0YScpO1xuICAgIH1cbiAgfVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBzZWNwMjU2azEgPSByZXF1aXJlKCdldGhlcmV1bS1jcnlwdG9ncmFwaHkvc2VjcDI1NmsxJyk7XG5cbnZhciBzZWNwMjU2azF2MyA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9pbmRleCcpO1xudmFyIGRlciA9IHJlcXVpcmUoJy4vc2VjcDI1NmsxLWxpYi9kZXInKTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0EgcHJpdmF0ZUtleVxuICogQG1ldGhvZCBwcml2YXRlS2V5VmVyaWZ5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHByaXZhdGVLZXlWZXJpZnkgPSBmdW5jdGlvbiBwcml2YXRlS2V5VmVyaWZ5KHByaXZhdGVLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHJpdmF0ZUtleSBsZW5ndGggaXMgbm90IDMyXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc2VjcDI1NmsxLnByaXZhdGVLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKTtcbn07XG5cbi8qKlxuICogRXhwb3J0IGEgcHJpdmF0ZUtleSBpbiBERVIgZm9ybWF0XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlFeHBvcnRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbnZhciBwcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUV4cG9ydChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIC8vIHByaXZhdGVLZXlFeHBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgaWYgKHByaXZhdGVLZXkubGVuZ3RoICE9PSAzMikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdwcml2YXRlIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHB1YmxpY0tleSA9IHNlY3AyNTZrMXYzLnByaXZhdGVLZXlFeHBvcnQocHJpdmF0ZUtleSwgY29tcHJlc3NlZCk7XG5cbiAgcmV0dXJuIGRlci5wcml2YXRlS2V5RXhwb3J0KHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCk7XG59O1xuXG4vKipcbiAqIEltcG9ydCBhIHByaXZhdGVLZXkgaW4gREVSIGZvcm1hdFxuICogQG1ldGhvZCBwcml2YXRlS2V5SW1wb3J0XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG5cbnZhciBwcml2YXRlS2V5SW1wb3J0ID0gZnVuY3Rpb24gcHJpdmF0ZUtleUltcG9ydChwcml2YXRlS2V5KSB7XG4gIC8vIHByaXZhdGVLZXlJbXBvcnQgbWV0aG9kIGlzIG5vdCBwYXJ0IG9mIHNlY3AyNTZrMSB2NCBwYWNrYWdlXG4gIC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdjNcbiAgcHJpdmF0ZUtleSA9IGRlci5wcml2YXRlS2V5SW1wb3J0KHByaXZhdGVLZXkpO1xuICBpZiAocHJpdmF0ZUtleSAhPT0gbnVsbCAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gMzIgJiYgcHJpdmF0ZUtleVZlcmlmeShwcml2YXRlS2V5KSkge1xuICAgIHJldHVybiBwcml2YXRlS2V5O1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiY291bGRuJ3QgaW1wb3J0IGZyb20gREVSIGZvcm1hdFwiKTtcbn07XG5cbi8qKlxuICogTmVnYXRlIGEgcHJpdmF0ZUtleSBieSBzdWJ0cmFjdGluZyBpdCBmcm9tIHRoZSBvcmRlciBvZiB0aGUgY3VydmUncyBiYXNlIHBvaW50XG4gKiBAbWV0aG9kIHByaXZhdGVLZXlOZWdhdGVcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwcml2YXRlS2V5TmVnYXRlID0gZnVuY3Rpb24gcHJpdmF0ZUtleU5lZ2F0ZShwcml2YXRlS2V5KSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleU5lZ2F0ZShVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSkpKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW52ZXJzZSBvZiBhIHByaXZhdGVLZXkgKG1vZHVsbyB0aGUgb3JkZXIgb2YgdGhlIGN1cnZlJ3MgYmFzZSBwb2ludCkuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlNb2RJbnZlcnNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleU1vZEludmVyc2UgPSBmdW5jdGlvbiBwcml2YXRlS2V5TW9kSW52ZXJzZShwcml2YXRlS2V5KSB7XG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3ByaXZhdGUga2V5IGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxdjMucHJpdmF0ZUtleU1vZEludmVyc2UoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpKSk7XG59O1xuXG4vKipcbiAqIFR3ZWFrIGEgcHJpdmF0ZUtleSBieSBhZGRpbmcgdHdlYWsgdG8gaXQuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha0FkZFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrQWRkID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrQWRkKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrQWRkKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgdHdlYWspKTtcbn07XG5cbi8qKlxuICogVHdlYWsgYSBwcml2YXRlS2V5IGJ5IG11bHRpcGx5aW5nIGl0IGJ5IGEgdHdlYWsuXG4gKiBAbWV0aG9kIHByaXZhdGVLZXlUd2Vha011bFxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHJpdmF0ZUtleVR3ZWFrTXVsID0gZnVuY3Rpb24gcHJpdmF0ZUtleVR3ZWFrTXVsKHByaXZhdGVLZXksIHR3ZWFrKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHJpdmF0ZUtleVR3ZWFrTXVsKFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBwdWJsaWMga2V5IGZvciBhIHByaXZhdGVLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleUNyZWF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5Q3JlYXRlID0gZnVuY3Rpb24gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDcmVhdGUoVWludDhBcnJheS5mcm9tKHByaXZhdGVLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgYSBwdWJsaWNLZXkgdG8gY29tcHJlc3NlZCBvciB1bmNvbXByZXNzZWQgZm9ybS5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29udmVydFxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlDb252ZXJ0ID0gZnVuY3Rpb24gcHVibGljS2V5Q29udmVydChwdWJsaWNLZXksIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlDb252ZXJ0KFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBjb21wcmVzc2VkKSk7XG59O1xuXG4vKipcbiAqIFZlcmlmeSBhbiBFQ0RTQSBwdWJsaWNLZXkuXG4gKiBAbWV0aG9kIHB1YmxpY0tleVZlcmlmeVxuICogQHBhcmFtIHtCdWZmZXJ9IHB1YmxpY0tleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xudmFyIHB1YmxpY0tleVZlcmlmeSA9IGZ1bmN0aW9uIHB1YmxpY0tleVZlcmlmeShwdWJsaWNLZXkpIHtcbiAgLy8gc2VjcDI1NmsxIHY0IHZlcnNpb24gdGhyb3dzIHdoZW4gcHVibGljS2V5IGxlbmd0aCBpcyBub3QgMzMgb3IgNjVcbiAgaWYgKHB1YmxpY0tleS5sZW5ndGggIT09IDMzICYmIHB1YmxpY0tleS5sZW5ndGggIT09IDY1KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMS5wdWJsaWNLZXlWZXJpZnkoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBhZGRpbmcgdHdlYWsgdGltZXMgdGhlIGdlbmVyYXRvciB0byBpdC5cbiAqIEBtZXRob2QgcHVibGljS2V5VHdlYWtBZGRcbiAqIEBwYXJhbSB7QnVmZmVyfSBwdWJsaWNLZXlcbiAqIEBwYXJhbSB7QnVmZmVyfSB0d2Vha1xuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBwdWJsaWNLZXlUd2Vha0FkZCA9IGZ1bmN0aW9uIHB1YmxpY0tleVR3ZWFrQWRkKHB1YmxpY0tleSwgdHdlYWssIGNvbXByZXNzZWQpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlY3AyNTZrMS5wdWJsaWNLZXlUd2Vha0FkZChVaW50OEFycmF5LmZyb20ocHVibGljS2V5KSwgVWludDhBcnJheS5mcm9tKHR3ZWFrKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBUd2VhayBhIHB1YmxpY0tleSBieSBtdWx0aXBseWluZyBpdCBieSBhIHR3ZWFrIHZhbHVlXG4gKiBAbWV0aG9kIHB1YmxpY0tleVR3ZWFrTXVsXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gdHdlYWtcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29tcHJlc3NlZFxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgcHVibGljS2V5VHdlYWtNdWwgPSBmdW5jdGlvbiBwdWJsaWNLZXlUd2Vha011bChwdWJsaWNLZXksIHR3ZWFrLCBjb21wcmVzc2VkKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azEucHVibGljS2V5VHdlYWtNdWwoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbSh0d2VhayksIGNvbXByZXNzZWQpKTtcbn07XG5cbi8qKlxuICogQWRkIGEgZ2l2ZW4gcHVibGljS2V5cyB0b2dldGhlci5cbiAqIEBtZXRob2QgcHVibGljS2V5Q29tYmluZVxuICogQHBhcmFtIHtBcnJheTxCdWZmZXI+fSBwdWJsaWNLZXlzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHB1YmxpY0tleUNvbWJpbmUgPSBmdW5jdGlvbiBwdWJsaWNLZXlDb21iaW5lKHB1YmxpY0tleXMsIGNvbXByZXNzZWQpIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgcHVibGljS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICBrZXlzLnB1c2goVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSkpO1xuICB9KTtcblxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnB1YmxpY0tleUNvbWJpbmUoa2V5cywgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgc2lnbmF0dXJlIHRvIGEgbm9ybWFsaXplZCBsb3dlci1TIGZvcm0uXG4gKiBAbWV0aG9kIHNpZ25hdHVyZU5vcm1hbGl6ZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlTm9ybWFsaXplID0gZnVuY3Rpb24gc2lnbmF0dXJlTm9ybWFsaXplKHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZU5vcm1hbGl6ZShVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYW4gRUNEU0Egc2lnbmF0dXJlIGluIERFUiBmb3JtYXQuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUV4cG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlRXhwb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlRXhwb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUV4cG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKGZvbGxvdyBieSBbQklQNjZdKGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwNjYubWVkaWF3aWtpKSkuXG4gKiBAbWV0aG9kIHNpZ25hdHVyZUltcG9ydFxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbmF0dXJlSW1wb3J0ID0gZnVuY3Rpb24gc2lnbmF0dXJlSW1wb3J0KHNpZ25hdHVyZSkge1xuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLnNpZ25hdHVyZUltcG9ydChVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSkpO1xufTtcblxuLyoqXG4gKiBQYXJzZSBhIERFUiBFQ0RTQSBzaWduYXR1cmUgKG5vdCBmb2xsb3cgYnkgW0JJUDY2XShodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMDY2Lm1lZGlhd2lraSkpLlxuICogQG1ldGhvZCBzaWduYXR1cmVJbXBvcnRMYXhcbiAqIEBwYXJhbSB7QnVmZmVyfSBzaWduYXR1cmVcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIHNpZ25hdHVyZUltcG9ydExheChzaWduYXR1cmUpIHtcbiAgLy8gc2lnbmF0dXJlSW1wb3J0TGF4IG1ldGhvZCBpcyBub3QgcGFydCBvZiBzZWNwMjU2azEgdjQgcGFja2FnZVxuICAvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIGJhc2VkIG9uIHYzXG4gIC8vIGVuc3VyZSB0aGF0IHNpZ25hdHVyZSBpcyBncmVhdGVyIHRoYW4gMFxuICBpZiAoc2lnbmF0dXJlLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzaWduYXR1cmUgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHZhciBzaWdPYmogPSBkZXIuc2lnbmF0dXJlSW1wb3J0TGF4KHNpZ25hdHVyZSk7XG4gIGlmIChzaWdPYmogPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBwYXJzZSBERVIgc2lnbmF0dXJlXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlY3AyNTZrMXYzLnNpZ25hdHVyZUltcG9ydChzaWdPYmopO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRUNEU0Egc2lnbmF0dXJlLiBBbHdheXMgcmV0dXJuIGxvdy1TIHNpZ25hdHVyZS5cbiAqIEBtZXRob2Qgc2lnblxuICogQHBhcmFtIHtCdWZmZXJ9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7QnVmZmVyfSBwcml2YXRlS2V5XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgc2hvdWxkIGJlIGFuIE9iamVjdCcpO1xuICB9XG5cbiAgdmFyIHNpZ25PcHRpb25zID0gdm9pZCAwO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgc2lnbk9wdGlvbnMgPSB7fTtcblxuICAgIGlmIChvcHRpb25zLmRhdGEgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMuZGF0YSBzaG91bGQgYmUgYSBCdWZmZXInKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5kYXRhKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBvcHRpb24uZGF0YSBsZW5ndGhcbiAgICAgIGlmIChvcHRpb25zLmRhdGEubGVuZ3RoICE9PSAzMikge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3B0aW9ucy5kYXRhIGxlbmd0aCBpcyBpbnZhbGlkJyk7XG4gICAgICB9XG5cbiAgICAgIHNpZ25PcHRpb25zLmRhdGEgPSBuZXcgVWludDhBcnJheShvcHRpb25zLmRhdGEpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4gPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMubm9uY2VmbiBzaG91bGQgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgIC8vICBjb252ZXJ0IG9wdGlvbi5ub25jZWZuIGZ1bmN0aW9uIHNpZ25hdHVyZVxuICAgICAgc2lnbk9wdGlvbnMubm9uY2VmbiA9IGZ1bmN0aW9uIChtZXNzYWdlLCBwcml2YXRlS2V5LCBhbGdvLCBkYXRhLCBhdHRlbXB0KSB7XG4gICAgICAgIHZhciBidWZmZXJBbGdvID0gYWxnbyAhPSBudWxsID8gQnVmZmVyLmZyb20oYWxnbykgOiBudWxsO1xuICAgICAgICB2YXIgYnVmZmVyRGF0YSA9IGRhdGEgIT0gbnVsbCA/IEJ1ZmZlci5mcm9tKGRhdGEpIDogbnVsbDtcblxuICAgICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmZyb20oJycpO1xuXG4gICAgICAgIGlmIChvcHRpb25zLm5vbmNlZm4pIHtcbiAgICAgICAgICBidWZmZXIgPSBvcHRpb25zLm5vbmNlZm4oQnVmZmVyLmZyb20obWVzc2FnZSksIEJ1ZmZlci5mcm9tKHByaXZhdGVLZXkpLCBidWZmZXJBbGdvLCBidWZmZXJEYXRhLCBhdHRlbXB0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNpZyA9IHNlY3AyNTZrMS5lY2RzYVNpZ24oVWludDhBcnJheS5mcm9tKG1lc3NhZ2UpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIHNpZ25PcHRpb25zKTtcblxuICByZXR1cm4ge1xuICAgIHNpZ25hdHVyZTogQnVmZmVyLmZyb20oc2lnLnNpZ25hdHVyZSksXG4gICAgcmVjb3Zlcnk6IHNpZy5yZWNpZFxuICB9O1xufTtcblxuLyoqXG4gKiBWZXJpZnkgYW4gRUNEU0Egc2lnbmF0dXJlLlxuICogQG1ldGhvZCB2ZXJpZnlcbiAqIEBwYXJhbSB7QnVmZmVyfSBtZXNzYWdlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG52YXIgdmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2NCB2ZXJpZnkgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gc2VjcDI1NmsxLmVjZHNhVmVyaWZ5KFVpbnQ4QXJyYXkuZnJvbShzaWduYXR1cmUpLCBVaW50OEFycmF5LmZyb20obWVzc2FnZSksIHB1YmxpY0tleSk7XG59O1xuXG4vKipcbiAqIFJlY292ZXIgYW4gRUNEU0EgcHVibGljIGtleSBmcm9tIGEgc2lnbmF0dXJlLlxuICogQG1ldGhvZCByZWNvdmVyXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWVzc2FnZVxuICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJlY2lkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGNvbXByZXNzZWRcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xudmFyIHJlY292ZXIgPSBmdW5jdGlvbiByZWNvdmVyKG1lc3NhZ2UsIHNpZ25hdHVyZSwgcmVjaWQsIGNvbXByZXNzZWQpIHtcbiAgLy8gbm90ZTogc2VjcDI1NmsxIHY0IHJlY292ZXIgbWV0aG9kIGhhcyBhIGRpZmZlcmVudCBhcmd1bWVudCBvcmRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZHNhUmVjb3ZlcihVaW50OEFycmF5LmZyb20oc2lnbmF0dXJlKSwgcmVjaWQsIFVpbnQ4QXJyYXkuZnJvbShtZXNzYWdlKSwgY29tcHJlc3NlZCkpO1xufTtcblxuLyoqXG4gKiBDb21wdXRlIGFuIEVDIERpZmZpZS1IZWxsbWFuIHNlY3JldCBhbmQgYXBwbGllZCBzaGEyNTYgdG8gY29tcHJlc3NlZCBwdWJsaWMga2V5LlxuICogQG1ldGhvZCBlY2RoXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHJldHVybiB7QnVmZmVyfVxuICovXG52YXIgZWNkaCA9IGZ1bmN0aW9uIGVjZGgocHVibGljS2V5LCBwcml2YXRlS2V5KSB7XG4gIC8vIG5vdGU6IHNlY3AyNTZrMSB2MyBkb2Vzbid0IGFsbG93IG9wdGlvbmFsIHBhcmFtZXRlclxuICByZXR1cm4gQnVmZmVyLmZyb20oc2VjcDI1NmsxLmVjZGgoVWludDhBcnJheS5mcm9tKHB1YmxpY0tleSksIFVpbnQ4QXJyYXkuZnJvbShwcml2YXRlS2V5KSwge30pKTtcbn07XG5cbi8qKlxuICogQ29tcHV0ZSBhbiBFQyBEaWZmaWUtSGVsbG1hbiBzZWNyZXQgYW5kIHJldHVybiBwdWJsaWMga2V5IGFzIHJlc3VsdFxuICogQG1ldGhvZCBlY2RoVW5zYWZlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5XG4gKiBAcGFyYW0ge0J1ZmZlcn0gcHJpdmF0ZUtleVxuICogQHBhcmFtIHtib29sZWFufSBjb21wcmVzc2VkXG4gKiBAcmV0dXJuIHtCdWZmZXJ9XG4gKi9cbnZhciBlY2RoVW5zYWZlID0gZnVuY3Rpb24gZWNkaFVuc2FmZShwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgLy8gZWNkaFVuc2FmZSBtZXRob2QgaXMgbm90IHBhcnQgb2Ygc2VjcDI1NmsxIHY0IHBhY2thZ2VcbiAgLy8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB2M1xuICAvLyBlbnN1cmUgdmFsaWQgcHVibGljS2V5IGxlbmd0aFxuICBpZiAocHVibGljS2V5Lmxlbmd0aCAhPT0gMzMgJiYgcHVibGljS2V5Lmxlbmd0aCAhPT0gNjUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHVibGljIGtleSBsZW5ndGggaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgLy8gZW5zdXJlIHZhbGlkIHByaXZhdGVLZXkgbGVuZ3RoXG4gIGlmIChwcml2YXRlS2V5Lmxlbmd0aCAhPT0gMzIpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigncHJpdmF0ZSBrZXkgbGVuZ3RoIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuZnJvbShzZWNwMjU2azF2My5lY2RoVW5zYWZlKFVpbnQ4QXJyYXkuZnJvbShwdWJsaWNLZXkpLCBVaW50OEFycmF5LmZyb20ocHJpdmF0ZUtleSksIGNvbXByZXNzZWQpKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwcml2YXRlS2V5VmVyaWZ5OiBwcml2YXRlS2V5VmVyaWZ5LFxuICBwcml2YXRlS2V5RXhwb3J0OiBwcml2YXRlS2V5RXhwb3J0LFxuICBwcml2YXRlS2V5SW1wb3J0OiBwcml2YXRlS2V5SW1wb3J0LFxuICBwcml2YXRlS2V5TmVnYXRlOiBwcml2YXRlS2V5TmVnYXRlLFxuICBwcml2YXRlS2V5TW9kSW52ZXJzZTogcHJpdmF0ZUtleU1vZEludmVyc2UsXG4gIHByaXZhdGVLZXlUd2Vha0FkZDogcHJpdmF0ZUtleVR3ZWFrQWRkLFxuICBwcml2YXRlS2V5VHdlYWtNdWw6IHByaXZhdGVLZXlUd2Vha011bCxcblxuICBwdWJsaWNLZXlDcmVhdGU6IHB1YmxpY0tleUNyZWF0ZSxcbiAgcHVibGljS2V5Q29udmVydDogcHVibGljS2V5Q29udmVydCxcbiAgcHVibGljS2V5VmVyaWZ5OiBwdWJsaWNLZXlWZXJpZnksXG4gIHB1YmxpY0tleVR3ZWFrQWRkOiBwdWJsaWNLZXlUd2Vha0FkZCxcbiAgcHVibGljS2V5VHdlYWtNdWw6IHB1YmxpY0tleVR3ZWFrTXVsLFxuICBwdWJsaWNLZXlDb21iaW5lOiBwdWJsaWNLZXlDb21iaW5lLFxuXG4gIHNpZ25hdHVyZU5vcm1hbGl6ZTogc2lnbmF0dXJlTm9ybWFsaXplLFxuICBzaWduYXR1cmVFeHBvcnQ6IHNpZ25hdHVyZUV4cG9ydCxcbiAgc2lnbmF0dXJlSW1wb3J0OiBzaWduYXR1cmVJbXBvcnQsXG4gIHNpZ25hdHVyZUltcG9ydExheDogc2lnbmF0dXJlSW1wb3J0TGF4LFxuXG4gIHNpZ246IHNpZ24sXG4gIHZlcmlmeTogdmVyaWZ5LFxuICByZWNvdmVyOiByZWNvdmVyLFxuXG4gIGVjZGg6IGVjZGgsXG4gIGVjZGhVbnNhZmU6IGVjZGhVbnNhZmVcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfQ09NUFJFU1NFRCA9IEJ1ZmZlci5mcm9tKFtcbi8vIGJlZ2luXG4weDMwLCAweDgxLCAweGQzLCAweDAyLCAweDAxLCAweDAxLCAweDA0LCAweDIwLFxuLy8gcHJpdmF0ZSBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsXG4vLyBtaWRkbGVcbjB4YTAsIDB4ODEsIDB4ODUsIDB4MzAsIDB4ODEsIDB4ODIsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MzAsIDB4MmMsIDB4MDYsIDB4MDcsIDB4MmEsIDB4ODYsIDB4NDgsIDB4Y2UsIDB4M2QsIDB4MDEsIDB4MDEsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4ZmYsIDB4ZmYsIDB4ZmMsIDB4MmYsIDB4MzAsIDB4MDYsIDB4MDQsIDB4MDEsIDB4MDAsIDB4MDQsIDB4MDEsIDB4MDcsIDB4MDQsIDB4MjEsIDB4MDIsIDB4NzksIDB4YmUsIDB4NjYsIDB4N2UsIDB4ZjksIDB4ZGMsIDB4YmIsIDB4YWMsIDB4NTUsIDB4YTAsIDB4NjIsIDB4OTUsIDB4Y2UsIDB4ODcsIDB4MGIsIDB4MDcsIDB4MDIsIDB4OWIsIDB4ZmMsIDB4ZGIsIDB4MmQsIDB4Y2UsIDB4MjgsIDB4ZDksIDB4NTksIDB4ZjIsIDB4ODEsIDB4NWIsIDB4MTYsIDB4ZjgsIDB4MTcsIDB4OTgsIDB4MDIsIDB4MjEsIDB4MDAsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmYsIDB4ZmUsIDB4YmEsIDB4YWUsIDB4ZGMsIDB4ZTYsIDB4YWYsIDB4NDgsIDB4YTAsIDB4M2IsIDB4YmYsIDB4ZDIsIDB4NWUsIDB4OGMsIDB4ZDAsIDB4MzYsIDB4NDEsIDB4NDEsIDB4MDIsIDB4MDEsIDB4MDEsIDB4YTEsIDB4MjQsIDB4MDMsIDB4MjIsIDB4MDAsXG4vLyBwdWJsaWMga2V5XG4weDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXSk7XG5cbnZhciBFQ19QUklWS0VZX0VYUE9SVF9ERVJfVU5DT01QUkVTU0VEID0gQnVmZmVyLmZyb20oW1xuLy8gYmVnaW5cbjB4MzAsIDB4ODIsIDB4MDEsIDB4MTMsIDB4MDIsIDB4MDEsIDB4MDEsIDB4MDQsIDB4MjAsXG4vLyBwcml2YXRlIGtleVxuMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCxcbi8vIG1pZGRsZVxuMHhhMCwgMHg4MSwgMHhhNSwgMHgzMCwgMHg4MSwgMHhhMiwgMHgwMiwgMHgwMSwgMHgwMSwgMHgzMCwgMHgyYywgMHgwNiwgMHgwNywgMHgyYSwgMHg4NiwgMHg0OCwgMHhjZSwgMHgzZCwgMHgwMSwgMHgwMSwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhmZiwgMHhmZiwgMHhmYywgMHgyZiwgMHgzMCwgMHgwNiwgMHgwNCwgMHgwMSwgMHgwMCwgMHgwNCwgMHgwMSwgMHgwNywgMHgwNCwgMHg0MSwgMHgwNCwgMHg3OSwgMHhiZSwgMHg2NiwgMHg3ZSwgMHhmOSwgMHhkYywgMHhiYiwgMHhhYywgMHg1NSwgMHhhMCwgMHg2MiwgMHg5NSwgMHhjZSwgMHg4NywgMHgwYiwgMHgwNywgMHgwMiwgMHg5YiwgMHhmYywgMHhkYiwgMHgyZCwgMHhjZSwgMHgyOCwgMHhkOSwgMHg1OSwgMHhmMiwgMHg4MSwgMHg1YiwgMHgxNiwgMHhmOCwgMHgxNywgMHg5OCwgMHg0OCwgMHgzYSwgMHhkYSwgMHg3NywgMHgyNiwgMHhhMywgMHhjNCwgMHg2NSwgMHg1ZCwgMHhhNCwgMHhmYiwgMHhmYywgMHgwZSwgMHgxMSwgMHgwOCwgMHhhOCwgMHhmZCwgMHgxNywgMHhiNCwgMHg0OCwgMHhhNiwgMHg4NSwgMHg1NCwgMHgxOSwgMHg5YywgMHg0NywgMHhkMCwgMHg4ZiwgMHhmYiwgMHgxMCwgMHhkNCwgMHhiOCwgMHgwMiwgMHgyMSwgMHgwMCwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZiwgMHhmZSwgMHhiYSwgMHhhZSwgMHhkYywgMHhlNiwgMHhhZiwgMHg0OCwgMHhhMCwgMHgzYiwgMHhiZiwgMHhkMiwgMHg1ZSwgMHg4YywgMHhkMCwgMHgzNiwgMHg0MSwgMHg0MSwgMHgwMiwgMHgwMSwgMHgwMSwgMHhhMSwgMHg0NCwgMHgwMywgMHg0MiwgMHgwMCxcbi8vIHB1YmxpYyBrZXlcbjB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBdKTtcblxuZXhwb3J0cy5wcml2YXRlS2V5RXhwb3J0ID0gZnVuY3Rpb24gKHByaXZhdGVLZXksIHB1YmxpY0tleSwgY29tcHJlc3NlZCkge1xuICB2YXIgcmVzdWx0ID0gQnVmZmVyLmZyb20oY29tcHJlc3NlZCA/IEVDX1BSSVZLRVlfRVhQT1JUX0RFUl9DT01QUkVTU0VEIDogRUNfUFJJVktFWV9FWFBPUlRfREVSX1VOQ09NUFJFU1NFRCk7XG4gIHByaXZhdGVLZXkuY29weShyZXN1bHQsIGNvbXByZXNzZWQgPyA4IDogOSk7XG4gIHB1YmxpY0tleS5jb3B5KHJlc3VsdCwgY29tcHJlc3NlZCA/IDE4MSA6IDIxNCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5leHBvcnRzLnByaXZhdGVLZXlJbXBvcnQgPSBmdW5jdGlvbiAocHJpdmF0ZUtleSkge1xuICB2YXIgbGVuZ3RoID0gcHJpdmF0ZUtleS5sZW5ndGg7XG5cbiAgLy8gc2VxdWVuY2UgaGVhZGVyXG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIDEgfHwgcHJpdmF0ZUtleVtpbmRleF0gIT09IDB4MzApIHJldHVybiBudWxsO1xuICBpbmRleCArPSAxO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aCBjb25zdHJ1Y3RvclxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAxIHx8ICEocHJpdmF0ZUtleVtpbmRleF0gJiAweDgwKSkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGxlbmIgPSBwcml2YXRlS2V5W2luZGV4XSAmIDB4N2Y7XG4gIGluZGV4ICs9IDE7XG4gIGlmIChsZW5iIDwgMSB8fCBsZW5iID4gMikgcmV0dXJuIG51bGw7XG4gIGlmIChsZW5ndGggPCBpbmRleCArIGxlbmIpIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGxlbmd0aFxuICB2YXIgbGVuID0gcHJpdmF0ZUtleVtpbmRleCArIGxlbmIgLSAxXSB8IChsZW5iID4gMSA/IHByaXZhdGVLZXlbaW5kZXggKyBsZW5iIC0gMl0gPDwgOCA6IDApO1xuICBpbmRleCArPSBsZW5iO1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyBsZW4pIHJldHVybiBudWxsO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMDogdmVyc2lvbiBudW1iZXIgKD0xKVxuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAzIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDAyIHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSAhPT0gMHgwMSB8fCBwcml2YXRlS2V5W2luZGV4ICsgMl0gIT09IDB4MDEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpbmRleCArPSAzO1xuXG4gIC8vIHNlcXVlbmNlIGVsZW1lbnQgMTogb2N0ZXQgc3RyaW5nLCB1cCB0byAzMiBieXRlc1xuICBpZiAobGVuZ3RoIDwgaW5kZXggKyAyIHx8IHByaXZhdGVLZXlbaW5kZXhdICE9PSAweDA0IHx8IHByaXZhdGVLZXlbaW5kZXggKyAxXSA+IDB4MjAgfHwgbGVuZ3RoIDwgaW5kZXggKyAyICsgcHJpdmF0ZUtleVtpbmRleCArIDFdKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcHJpdmF0ZUtleS5zbGljZShpbmRleCArIDIsIGluZGV4ICsgMiArIHByaXZhdGVLZXlbaW5kZXggKyAxXSk7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydExheCA9IGZ1bmN0aW9uIChzaWduYXR1cmUpIHtcbiAgdmFyIHIgPSBCdWZmZXIuYWxsb2MoMzIsIDApO1xuICB2YXIgcyA9IEJ1ZmZlci5hbGxvYygzMiwgMCk7XG5cbiAgdmFyIGxlbmd0aCA9IHNpZ25hdHVyZS5sZW5ndGg7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGVcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgzMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gc2VxdWVuY2UgbGVuZ3RoIGJ5dGVcbiAgdmFyIGxlbmJ5dGUgPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChsZW5ieXRlICYgMHg4MCkge1xuICAgIGluZGV4ICs9IGxlbmJ5dGUgLSAweDgwO1xuICAgIGlmIChpbmRleCA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gc2VxdWVuY2UgdGFnIGJ5dGUgZm9yIHJcbiAgaWYgKHNpZ25hdHVyZVtpbmRleCsrXSAhPT0gMHgwMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gbGVuZ3RoIGZvciByXG4gIHZhciBybGVuID0gc2lnbmF0dXJlW2luZGV4KytdO1xuICBpZiAocmxlbiAmIDB4ODApIHtcbiAgICBsZW5ieXRlID0gcmxlbiAtIDB4ODA7XG4gICAgaWYgKGluZGV4ICsgbGVuYnl0ZSA+IGxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGZvciAoOyBsZW5ieXRlID4gMCAmJiBzaWduYXR1cmVbaW5kZXhdID09PSAweDAwOyBpbmRleCArPSAxLCBsZW5ieXRlIC09IDEpIHt9XG4gICAgZm9yIChybGVuID0gMDsgbGVuYnl0ZSA+IDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge1xuICAgICAgcmxlbiA9IChybGVuIDw8IDgpICsgc2lnbmF0dXJlW2luZGV4XTtcbiAgICB9XG4gIH1cbiAgaWYgKHJsZW4gPiBsZW5ndGggLSBpbmRleCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByaW5kZXggPSBpbmRleDtcbiAgaW5kZXggKz0gcmxlbjtcblxuICAvLyBzZXF1ZW5jZSB0YWcgYnl0ZSBmb3Igc1xuICBpZiAoc2lnbmF0dXJlW2luZGV4KytdICE9PSAweDAyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBsZW5ndGggZm9yIHNcbiAgdmFyIHNsZW4gPSBzaWduYXR1cmVbaW5kZXgrK107XG4gIGlmIChzbGVuICYgMHg4MCkge1xuICAgIGxlbmJ5dGUgPSBzbGVuIC0gMHg4MDtcbiAgICBpZiAoaW5kZXggKyBsZW5ieXRlID4gbGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZm9yICg7IGxlbmJ5dGUgPiAwICYmIHNpZ25hdHVyZVtpbmRleF0gPT09IDB4MDA7IGluZGV4ICs9IDEsIGxlbmJ5dGUgLT0gMSkge31cbiAgICBmb3IgKHNsZW4gPSAwOyBsZW5ieXRlID4gMDsgaW5kZXggKz0gMSwgbGVuYnl0ZSAtPSAxKSB7XG4gICAgICBzbGVuID0gKHNsZW4gPDwgOCkgKyBzaWduYXR1cmVbaW5kZXhdO1xuICAgIH1cbiAgfVxuICBpZiAoc2xlbiA+IGxlbmd0aCAtIGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHNpbmRleCA9IGluZGV4O1xuICBpbmRleCArPSBzbGVuO1xuXG4gIC8vIGlnbm9yZSBsZWFkaW5nIHplcm9zIGluIHJcbiAgZm9yICg7IHJsZW4gPiAwICYmIHNpZ25hdHVyZVtyaW5kZXhdID09PSAweDAwOyBybGVuIC09IDEsIHJpbmRleCArPSAxKSB7fVxuICAvLyBjb3B5IHIgdmFsdWVcbiAgaWYgKHJsZW4gPiAzMikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBydmFsdWUgPSBzaWduYXR1cmUuc2xpY2UocmluZGV4LCByaW5kZXggKyBybGVuKTtcbiAgcnZhbHVlLmNvcHkociwgMzIgLSBydmFsdWUubGVuZ3RoKTtcblxuICAvLyBpZ25vcmUgbGVhZGluZyB6ZXJvcyBpbiBzXG4gIGZvciAoOyBzbGVuID4gMCAmJiBzaWduYXR1cmVbc2luZGV4XSA9PT0gMHgwMDsgc2xlbiAtPSAxLCBzaW5kZXggKz0gMSkge31cbiAgLy8gY29weSBzIHZhbHVlXG4gIGlmIChzbGVuID4gMzIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgc3ZhbHVlID0gc2lnbmF0dXJlLnNsaWNlKHNpbmRleCwgc2luZGV4ICsgc2xlbik7XG4gIHN2YWx1ZS5jb3B5KHMsIDMyIC0gc3ZhbHVlLmxlbmd0aCk7XG5cbiAgcmV0dXJuIHsgcjogciwgczogcyB9O1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmlsZSBpcyBpbXBvcnRlZCBmcm9tIHNlY3AyNTZrMSB2M1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NyeXB0b2NvaW5qcy9zZWNwMjU2azEtbm9kZS9ibG9iL21hc3Rlci9MSUNFTlNFXG5cbnZhciBCTiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG52YXIgRUMgPSByZXF1aXJlKCdlbGxpcHRpYycpLmVjO1xuXG52YXIgZWMgPSBuZXcgRUMoJ3NlY3AyNTZrMScpO1xudmFyIGVjcGFyYW1zID0gZWMuY3VydmU7XG5cbmV4cG9ydHMucHJpdmF0ZUtleUV4cG9ydCA9IGZ1bmN0aW9uIChwcml2YXRlS2V5LCBjb21wcmVzc2VkKSB7XG4gIHZhciBkID0gbmV3IEJOKHByaXZhdGVLZXkpO1xuICBpZiAoZC51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvdWxkblxcJ3QgZXhwb3J0IHRvIERFUiBmb3JtYXQnKTtcbiAgfVxuXG4gIHZhciBwb2ludCA9IGVjLmcubXVsKGQpO1xuICByZXR1cm4gdG9QdWJsaWNLZXkocG9pbnQuZ2V0WCgpLCBwb2ludC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxuZXhwb3J0cy5wcml2YXRlS2V5TW9kSW52ZXJzZSA9IGZ1bmN0aW9uIChwcml2YXRlS2V5KSB7XG4gIHZhciBibiA9IG5ldyBCTihwcml2YXRlS2V5KTtcbiAgaWYgKGJuLnVjbXAoZWNwYXJhbXMubikgPj0gMCB8fCBibi5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJpdmF0ZSBrZXkgcmFuZ2UgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIGJuLmludm0oZWNwYXJhbXMubikudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMik7XG59O1xuXG5leHBvcnRzLnNpZ25hdHVyZUltcG9ydCA9IGZ1bmN0aW9uIChzaWdPYmopIHtcbiAgdmFyIHIgPSBuZXcgQk4oc2lnT2JqLnIpO1xuICBpZiAoci51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICByID0gbmV3IEJOKDApO1xuICB9XG5cbiAgdmFyIHMgPSBuZXcgQk4oc2lnT2JqLnMpO1xuICBpZiAocy51Y21wKGVjcGFyYW1zLm4pID49IDApIHtcbiAgICBzID0gbmV3IEJOKDApO1xuICB9XG5cbiAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3IudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMiksIHMudG9BcnJheUxpa2UoQnVmZmVyLCAnYmUnLCAzMildKTtcbn07XG5cbmV4cG9ydHMuZWNkaFVuc2FmZSA9IGZ1bmN0aW9uIChwdWJsaWNLZXksIHByaXZhdGVLZXksIGNvbXByZXNzZWQpIHtcbiAgdmFyIHBvaW50ID0gZWMua2V5RnJvbVB1YmxpYyhwdWJsaWNLZXkpO1xuXG4gIHZhciBzY2FsYXIgPSBuZXcgQk4ocHJpdmF0ZUtleSk7XG4gIGlmIChzY2FsYXIudWNtcChlY3BhcmFtcy5uKSA+PSAwIHx8IHNjYWxhci5pc1plcm8oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2NhbGFyIHdhcyBpbnZhbGlkICh6ZXJvIG9yIG92ZXJmbG93KScpO1xuICB9XG5cbiAgdmFyIHNoYXJlZCA9IHBvaW50LnB1Yi5tdWwoc2NhbGFyKTtcbiAgcmV0dXJuIHRvUHVibGljS2V5KHNoYXJlZC5nZXRYKCksIHNoYXJlZC5nZXRZKCksIGNvbXByZXNzZWQpO1xufTtcblxudmFyIHRvUHVibGljS2V5ID0gZnVuY3Rpb24gdG9QdWJsaWNLZXkoeCwgeSwgY29tcHJlc3NlZCkge1xuICB2YXIgcHVibGljS2V5ID0gdm9pZCAwO1xuXG4gIGlmIChjb21wcmVzc2VkKSB7XG4gICAgcHVibGljS2V5ID0gQnVmZmVyLmFsbG9jKDMzKTtcbiAgICBwdWJsaWNLZXlbMF0gPSB5LmlzT2RkKCkgPyAweDAzIDogMHgwMjtcbiAgICB4LnRvQXJyYXlMaWtlKEJ1ZmZlciwgJ2JlJywgMzIpLmNvcHkocHVibGljS2V5LCAxKTtcbiAgfSBlbHNlIHtcbiAgICBwdWJsaWNLZXkgPSBCdWZmZXIuYWxsb2MoNjUpO1xuICAgIHB1YmxpY0tleVswXSA9IDB4MDQ7XG4gICAgeC50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMSk7XG4gICAgeS50b0FycmF5TGlrZShCdWZmZXIsICdiZScsIDMyKS5jb3B5KHB1YmxpY0tleSwgMzMpO1xuICB9XG5cbiAgcmV0dXJuIHB1YmxpY0tleTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNIZXhQcmVmaXhlZCA9IHJlcXVpcmUoJ2lzLWhleC1wcmVmaXhlZCcpO1xudmFyIHN0cmlwSGV4UHJlZml4ID0gcmVxdWlyZSgnc3RyaXAtaGV4LXByZWZpeCcpO1xuXG4vKipcbiAqIFBhZHMgYSBgU3RyaW5nYCB0byBoYXZlIGFuIGV2ZW4gbGVuZ3RoXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIHBhZFRvRXZlbih2YWx1ZSkge1xuICB2YXIgYSA9IHZhbHVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIHBhZGRpbmcgdG8gZXZlbiwgdmFsdWUgbXVzdCBiZSBzdHJpbmcsIGlzIGN1cnJlbnRseSAnICsgdHlwZW9mIGEgKyAnLCB3aGlsZSBwYWRUb0V2ZW4uJyk7XG4gIH1cblxuICBpZiAoYS5sZW5ndGggJSAyKSB7XG4gICAgYSA9ICcwJyArIGE7XG4gIH1cblxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGBOdW1iZXJgIGludG8gYSBoZXggYFN0cmluZ2BcbiAqIEBwYXJhbSB7TnVtYmVyfSBpXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGludFRvSGV4KGkpIHtcbiAgdmFyIGhleCA9IGkudG9TdHJpbmcoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbiAgcmV0dXJuICcweCcgKyBoZXg7XG59XG5cbi8qKlxuICogQ29udmVydHMgYW4gYE51bWJlcmAgdG8gYSBgQnVmZmVyYFxuICogQHBhcmFtIHtOdW1iZXJ9IGlcbiAqIEByZXR1cm4ge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gaW50VG9CdWZmZXIoaSkge1xuICB2YXIgaGV4ID0gaW50VG9IZXgoaSk7XG5cbiAgcmV0dXJuIG5ldyBCdWZmZXIocGFkVG9FdmVuKGhleC5zbGljZSgyKSksICdoZXgnKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGJpbmFyeSBzaXplIG9mIGEgc3RyaW5nXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGdldEJpbmFyeVNpemUoc3RyKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIHdoaWxlIGdldHRpbmcgYmluYXJ5IHNpemUsIG1ldGhvZCBnZXRCaW5hcnlTaXplIHJlcXVpcmVzIGlucHV0IFxcJ3N0clxcJyB0byBiZSB0eXBlIFN0cmluZywgZ290IFxcJycgKyB0eXBlb2Ygc3RyICsgJ1xcJy4nKTtcbiAgfVxuXG4gIHJldHVybiBCdWZmZXIuYnl0ZUxlbmd0aChzdHIsICd1dGY4Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyBUUlVFIGlmIHRoZSBmaXJzdCBzcGVjaWZpZWQgYXJyYXkgY29udGFpbnMgYWxsIGVsZW1lbnRzXG4gKiBmcm9tIHRoZSBzZWNvbmQgb25lLiBGQUxTRSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHthcnJheX0gc3VwZXJzZXRcbiAqIEBwYXJhbSB7YXJyYXl9IHN1YnNldFxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBhcnJheUNvbnRhaW5zQXJyYXkoc3VwZXJzZXQsIHN1YnNldCwgc29tZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShzdXBlcnNldCkgIT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1tldGhqcy11dGlsXSBtZXRob2QgYXJyYXlDb250YWluc0FycmF5IHJlcXVpcmVzIGlucHV0IFxcJ3N1cGVyc2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3VwZXJzZXQgKyAnXFwnJyk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoc3Vic2V0KSAhPT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBhcnJheUNvbnRhaW5zQXJyYXkgcmVxdWlyZXMgaW5wdXQgXFwnc3Vic2V0XFwnIHRvIGJlIGFuIGFycmF5IGdvdCB0eXBlIFxcJycgKyB0eXBlb2Ygc3Vic2V0ICsgJ1xcJycpO1xuICB9XG5cbiAgcmV0dXJuIHN1YnNldFtCb29sZWFuKHNvbWUpICYmICdzb21lJyB8fCAnZXZlcnknXShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gc3VwZXJzZXQuaW5kZXhPZih2YWx1ZSkgPj0gMDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdXRmOCBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b1V0ZjhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgaW4gaGV4XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhc2NpaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgaGV4IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHRvVXRmOChoZXgpIHtcbiAgdmFyIGJ1ZmZlclZhbHVlID0gbmV3IEJ1ZmZlcihwYWRUb0V2ZW4oc3RyaXBIZXhQcmVmaXgoaGV4KS5yZXBsYWNlKC9eMCt8MCskL2csICcnKSksICdoZXgnKTtcblxuICByZXR1cm4gYnVmZmVyVmFsdWUudG9TdHJpbmcoJ3V0ZjgnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBhc2NpaSBmcm9tIGl0J3MgaGV4IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZCB0b0FzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0FzY2lpKGhleCkge1xuICB2YXIgc3RyID0gJyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgdmFyIGkgPSAwLFxuICAgICAgbCA9IGhleC5sZW5ndGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgIGkgPSAyO1xuICB9XG5cbiAgZm9yICg7IGkgPCBsOyBpICs9IDIpIHtcbiAgICB2YXIgY29kZSA9IHBhcnNlSW50KGhleC5zdWJzdHIoaSwgMiksIDE2KTtcbiAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgfVxuXG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaGV4IHJlcHJlc2VudGF0aW9uIChwcmVmaXhlZCBieSAweCkgb2YgdXRmOCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG5mdW5jdGlvbiBmcm9tVXRmOChzdHJpbmdWYWx1ZSkge1xuICB2YXIgc3RyID0gbmV3IEJ1ZmZlcihzdHJpbmdWYWx1ZSwgJ3V0ZjgnKTtcblxuICByZXR1cm4gJzB4JyArIHBhZFRvRXZlbihzdHIudG9TdHJpbmcoJ2hleCcpKS5yZXBsYWNlKC9eMCt8MCskL2csICcnKTtcbn1cblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBoZXggcmVwcmVzZW50YXRpb24gKHByZWZpeGVkIGJ5IDB4KSBvZiBhc2NpaSBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZyb21Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbmFsIHBhZGRpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGhleCByZXByZXNlbnRhdGlvbiBvZiBpbnB1dCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZnJvbUFzY2lpKHN0cmluZ1ZhbHVlKSB7XG4gIHZhciBoZXggPSAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ1ZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBjb2RlID0gc3RyaW5nVmFsdWUuY2hhckNvZGVBdChpKTtcbiAgICB2YXIgbiA9IGNvZGUudG9TdHJpbmcoMTYpO1xuICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgfVxuXG4gIHJldHVybiAnMHgnICsgaGV4O1xufVxuXG4vKipcbiAqIGdldEtleXMoW3thOiAxLCBiOiAyfSwge2E6IDMsIGI6IDR9XSwgJ2EnKSA9PiBbMSwgM11cbiAqXG4gKiBAbWV0aG9kIGdldEtleXMgZ2V0IHNwZWNpZmljIGtleSBmcm9tIGlubmVyIG9iamVjdCBhcnJheSBvZiBvYmplY3RzXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93RW1wdHlcbiAqIEByZXR1cm5zIHtBcnJheX0gb3V0cHV0IGp1c3QgYSBzaW1wbGUgYXJyYXkgb2Ygb3V0cHV0IGtleXNcbiAqL1xuZnVuY3Rpb24gZ2V0S2V5cyhwYXJhbXMsIGtleSwgYWxsb3dFbXB0eSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIEFycmF5IGFzIFxcJ3BhcmFtc1xcJyBpbnB1dCwgZ290IFxcJycgKyB0eXBlb2YgcGFyYW1zICsgJ1xcJycpO1xuICB9XG4gIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBFcnJvcignW2V0aGpzLXV0aWxdIG1ldGhvZCBnZXRLZXlzIGV4cGVjdGluZyB0eXBlIFN0cmluZyBmb3IgaW5wdXQgXFwna2V5XFwnIGdvdCBcXCcnICsgdHlwZW9mIGtleSArICdcXCcuJyk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gW107IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmFtcy5sZW5ndGg7IGkrKykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB2YXIgdmFsdWUgPSBwYXJhbXNbaV1ba2V5XTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIGlmIChhbGxvd0VtcHR5ICYmICF2YWx1ZSkge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhYmknKTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBJcyB0aGUgc3RyaW5nIGEgaGV4IHN0cmluZy5cbiAqXG4gKiBAbWV0aG9kIGNoZWNrIGlmIHN0cmluZyBpcyBoZXggc3RyaW5nIG9mIHNwZWNpZmljIGxlbmd0aFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gb3V0cHV0IHRoZSBzdHJpbmcgaXMgYSBoZXggc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGlzSGV4U3RyaW5nKHZhbHVlLCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgfHwgIXZhbHVlLm1hdGNoKC9eMHhbMC05QS1GYS1mXSokLykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gMiArIDIgKiBsZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFycmF5Q29udGFpbnNBcnJheTogYXJyYXlDb250YWluc0FycmF5LFxuICBpbnRUb0J1ZmZlcjogaW50VG9CdWZmZXIsXG4gIGdldEJpbmFyeVNpemU6IGdldEJpbmFyeVNpemUsXG4gIGlzSGV4UHJlZml4ZWQ6IGlzSGV4UHJlZml4ZWQsXG4gIHN0cmlwSGV4UHJlZml4OiBzdHJpcEhleFByZWZpeCxcbiAgcGFkVG9FdmVuOiBwYWRUb0V2ZW4sXG4gIGludFRvSGV4OiBpbnRUb0hleCxcbiAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gIGZyb21VdGY4OiBmcm9tVXRmOCxcbiAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgdG9VdGY4OiB0b1V0ZjgsXG4gIGdldEtleXM6IGdldEtleXMsXG4gIGlzSGV4U3RyaW5nOiBpc0hleFN0cmluZ1xufTsiLCIvKipcbiAqIEpzb25ScGNFbmdpbmUgb25seSBhY2NlcHRzIGNhbGxiYWNrLWJhc2VkIG1pZGRsZXdhcmUgZGlyZWN0bHkuXG4gKiBjcmVhdGVBc3luY01pZGRsZXdhcmUgZXhpc3RzIHRvIGVuYWJsZSBjb25zdW1lcnMgdG8gcGFzcyBpbiBhc3luYyBtaWRkbGV3YXJlXG4gKiBmdW5jdGlvbnMuXG4gKlxuICogQXN5bmMgbWlkZGxld2FyZSBoYXZlIG5vIFwiZW5kXCIgZnVuY3Rpb24uIEluc3RlYWQsIHRoZXkgXCJlbmRcIiBpZiB0aGV5IHJldHVyblxuICogd2l0aG91dCBjYWxsaW5nIFwibmV4dFwiLiBSYXRoZXIgdGhhbiBwYXNzaW5nIGluIGV4cGxpY2l0IHJldHVybiBoYW5kbGVycyxcbiAqIGFzeW5jIG1pZGRsZXdhcmUgY2FuIHNpbXBseSBhd2FpdCBcIm5leHRcIiwgYW5kIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiB0aGVcbiAqIHJlc3BvbnNlIG9iamVjdCB3aGVuIGV4ZWN1dGlvbiByZXN1bWVzLlxuICpcbiAqIFRvIGFjY29tcGxpc2ggdGhpcywgY3JlYXRlQXN5bmNNaWRkbGV3YXJlIHBhc3NlcyB0aGUgYXN5bmMgbWlkZGxld2FyZSBhXG4gKiB3cmFwcGVkIFwibmV4dFwiIGZ1bmN0aW9uLiBUaGF0IGZ1bmN0aW9uIGNhbGxzIHRoZSBpbnRlcm5hbCBKc29uUnBjRW5naW5lXG4gKiBcIm5leHRcIiBmdW5jdGlvbiB3aXRoIGEgcmV0dXJuIGhhbmRsZXIgdGhhdCByZXNvbHZlcyBhIHByb21pc2Ugd2hlbiBjYWxsZWQuXG4gKlxuICogVGhlIHJldHVybiBoYW5kbGVyIHdpbGwgYWx3YXlzIGJlIGNhbGxlZC4gSXRzIHJlc29sdXRpb24gb2YgdGhlIHByb21pc2VcbiAqIGVuYWJsZXMgdGhlIGNvbnRyb2wgZmxvdyBkZXNjcmliZWQgYWJvdmUuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVBc3luY01pZGRsZXdhcmUgKGFzeW5jTWlkZGxld2FyZSkge1xuICByZXR1cm4gKHJlcSwgcmVzLCBuZXh0LCBlbmQpID0+IHtcblxuICAgIC8vIG5leHRQcm9taXNlIGlzIHRoZSBrZXkgdG8gdGhlIGltcGxlbWVudGF0aW9uXG4gICAgLy8gaXQgaXMgcmVzb2x2ZWQgYnkgdGhlIHJldHVybiBoYW5kbGVyIHBhc3NlZCB0byB0aGVcbiAgICAvLyBcIm5leHRcIiBmdW5jdGlvblxuICAgIGxldCByZXNvbHZlTmV4dFByb21pc2VcbiAgICBjb25zdCBuZXh0UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICByZXNvbHZlTmV4dFByb21pc2UgPSByZXNvbHZlXG4gICAgfSlcblxuICAgIGxldCByZXR1cm5IYW5kbGVyQ2FsbGJhY2ssIG5leHRXYXNDYWxsZWRcblxuICAgIGNvbnN0IGFzeW5jTmV4dCA9IGFzeW5jICgpID0+IHtcblxuICAgICAgbmV4dFdhc0NhbGxlZCA9IHRydWVcblxuICAgICAgbmV4dCgoY2FsbGJhY2spID0+IHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrID0gY2FsbGJhY2tcbiAgICAgICAgcmVzb2x2ZU5leHRQcm9taXNlKClcbiAgICAgIH0pXG4gICAgICBhd2FpdCBuZXh0UHJvbWlzZVxuICAgIH1cblxuICAgIGFzeW5jTWlkZGxld2FyZShyZXEsIHJlcywgYXN5bmNOZXh0KVxuICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAobmV4dFdhc0NhbGxlZCkge1xuICAgICAgICAgIGF3YWl0IG5leHRQcm9taXNlIC8vIHdlIG11c3Qgd2FpdCB1bnRpbCB0aGUgcmV0dXJuIGhhbmRsZXIgaXMgY2FsbGVkXG4gICAgICAgICAgcmV0dXJuSGFuZGxlckNhbGxiYWNrKG51bGwpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kKG51bGwpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChyZXR1cm5IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICByZXR1cm5IYW5kbGVyQ2FsbGJhY2soZXJyb3IpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5kKGVycm9yKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3NGbiA9IChmbiwgb3B0cykgPT4gZnVuY3Rpb24gKCkge1xuXHRjb25zdCBQID0gb3B0cy5wcm9taXNlTW9kdWxlO1xuXHRjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0YXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0fVxuXG5cdHJldHVybiBuZXcgUCgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0aWYgKG9wdHMuZXJyb3JGaXJzdCkge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuXHRcdFx0XHRpZiAob3B0cy5tdWx0aUFyZ3MpIHtcblx0XHRcdFx0XHRjb25zdCByZXN1bHRzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcblxuXHRcdFx0XHRcdGZvciAobGV0IGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRzLnVuc2hpZnQoZXJyKTtcblx0XHRcdFx0XHRcdHJlamVjdChyZXN1bHRzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHRzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoZXJyKSB7XG5cdFx0XHRcdFx0cmVqZWN0KGVycik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXN1bHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJncy5wdXNoKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0aWYgKG9wdHMubXVsdGlBcmdzKSB7XG5cdFx0XHRcdFx0Y29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG5cblx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0cmVzdWx0c1tpXSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXNvbHZlKHJlc3VsdHMpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzdWx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Zm4uYXBwbHkodGhpcywgYXJncyk7XG5cdH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAob2JqLCBvcHRzKSA9PiB7XG5cdG9wdHMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRleGNsdWRlOiBbLy4rKFN5bmN8U3RyZWFtKSQvXSxcblx0XHRlcnJvckZpcnN0OiB0cnVlLFxuXHRcdHByb21pc2VNb2R1bGU6IFByb21pc2Vcblx0fSwgb3B0cyk7XG5cblx0Y29uc3QgZmlsdGVyID0ga2V5ID0+IHtcblx0XHRjb25zdCBtYXRjaCA9IHBhdHRlcm4gPT4gdHlwZW9mIHBhdHRlcm4gPT09ICdzdHJpbmcnID8ga2V5ID09PSBwYXR0ZXJuIDogcGF0dGVybi50ZXN0KGtleSk7XG5cdFx0cmV0dXJuIG9wdHMuaW5jbHVkZSA/IG9wdHMuaW5jbHVkZS5zb21lKG1hdGNoKSA6ICFvcHRzLmV4Y2x1ZGUuc29tZShtYXRjaCk7XG5cdH07XG5cblx0bGV0IHJldDtcblx0aWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcblx0XHRyZXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAob3B0cy5leGNsdWRlTWFpbikge1xuXHRcdFx0XHRyZXR1cm4gb2JqLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9jZXNzRm4ob2JqLCBvcHRzKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSk7XG5cdH1cblxuXHRmb3IgKGNvbnN0IGtleSBpbiBvYmopIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBndWFyZC1mb3ItaW5cblx0XHRjb25zdCB4ID0gb2JqW2tleV07XG5cdFx0cmV0W2tleV0gPSB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyAmJiBmaWx0ZXIoa2V5KSA/IHByb2Nlc3NGbih4LCBvcHRzKSA6IHg7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJuYW1lXCI6IFwid2ViMy1wcm92aWRlci1lbmdpbmVcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMTYuMC4zXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJBIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgY29tcG9zaW5nIEV0aGVyZXVtIHByb3ZpZGVyIG9iamVjdHMgdXNpbmcgbWlkZGxld2FyZSBtb2R1bGVzXCIsXG4gIFwicmVwb3NpdG9yeVwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay93ZWIzLXByb3ZpZGVyLWVuZ2luZVwiLFxuICBcIm1haW5cIjogXCJpbmRleC5qc1wiLFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49MTIuMC4wXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJub2RlIHRlc3QvaW5kZXguanMgJiYgeWFybiBsaW50XCIsXG4gICAgXCJwcmVwdWJsaXNoT25seVwiOiBcInlhcm4gYnVpbGQgJiYgeWFybiBidW5kbGVcIixcbiAgICBcImJ1aWxkXCI6IFwiYmFiZWwgemVyby5qcyBpbmRleC5qcyAtZCBkaXN0L2VzNSAmJiBiYWJlbCBzdWJwcm92aWRlcnMgLWQgZGlzdC9lczUvc3VicHJvdmlkZXJzICYmIGJhYmVsIHV0aWwgLWQgZGlzdC9lczUvdXRpbFwiLFxuICAgIFwiYnVuZGxlXCI6IFwibWtkaXIgLXAgLi9kaXN0ICYmIHlhcm4gYnVuZGxlLWVuZ2luZSAmJiB5YXJuIGJ1bmRsZS16ZXJvXCIsXG4gICAgXCJidW5kbGUtemVyb1wiOiBcImJyb3dzZXJpZnkgLXMgWmVyb0NsaWVudFByb3ZpZGVyIC1lIHplcm8uanMgLXQgWyBiYWJlbGlmeSAtLXByZXNldHMgWyBAYmFiZWwvcHJlc2V0LWVudiBdIF0gPiBkaXN0L1plcm9DbGllbnRQcm92aWRlci5qc1wiLFxuICAgIFwiYnVuZGxlLWVuZ2luZVwiOiBcImJyb3dzZXJpZnkgLXMgUHJvdmlkZXJFbmdpbmUgLWUgaW5kZXguanMgLXQgWyBiYWJlbGlmeSAtLXByZXNldHMgWyBAYmFiZWwvcHJlc2V0LWVudiBdIF0gPiBkaXN0L1Byb3ZpZGVyRW5naW5lLmpzXCIsXG4gICAgXCJsaW50XCI6IFwiZXNsaW50IC0tcXVpZXQgLS1pZ25vcmUtcGF0aCAuZ2l0aWdub3JlIC5cIlxuICB9LFxuICBcImZpbGVzXCI6IFtcbiAgICBcIiouanNcIixcbiAgICBcImRpc3RcIixcbiAgICBcInN1YnByb3ZpZGVyc1wiLFxuICAgIFwidXRpbFwiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcInJlc29sdXRpb25zXCI6IHtcbiAgICBcImdhbmFjaGUtY29yZS8qKi9lbGxpcHRpY1wiOiBcIl42LjUuMlwiXG4gIH0sXG4gIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBldGhlcmV1bWpzL3R4XCI6IFwiXjMuMy4wXCIsXG4gICAgXCJhc3luY1wiOiBcIl4yLjUuMFwiLFxuICAgIFwiYmFja29mZlwiOiBcIl4yLjUuMFwiLFxuICAgIFwiY2xvbmVcIjogXCJeMi4wLjBcIixcbiAgICBcImNyb3NzLWZldGNoXCI6IFwiXjIuMS4wXCIsXG4gICAgXCJldGgtYmxvY2stdHJhY2tlclwiOiBcIl40LjQuMlwiLFxuICAgIFwiZXRoLWpzb24tcnBjLWZpbHRlcnNcIjogXCJeNC4yLjFcIixcbiAgICBcImV0aC1qc29uLXJwYy1pbmZ1cmFcIjogXCJeNS4xLjBcIixcbiAgICBcImV0aC1qc29uLXJwYy1taWRkbGV3YXJlXCI6IFwiXjYuMC4wXCIsXG4gICAgXCJldGgtcnBjLWVycm9yc1wiOiBcIl4zLjAuMFwiLFxuICAgIFwiZXRoLXNpZy11dGlsXCI6IFwiXjEuNC4yXCIsXG4gICAgXCJldGhlcmV1bWpzLWJsb2NrXCI6IFwiXjEuMi4yXCIsXG4gICAgXCJldGhlcmV1bWpzLXV0aWxcIjogXCJeNS4xLjVcIixcbiAgICBcImV0aGVyZXVtanMtdm1cIjogXCJeMi4zLjRcIixcbiAgICBcImpzb24tc3RhYmxlLXN0cmluZ2lmeVwiOiBcIl4xLjAuMVwiLFxuICAgIFwicHJvbWlzZS10by1jYWxsYmFja1wiOiBcIl4xLjAuMFwiLFxuICAgIFwicmVhZGFibGUtc3RyZWFtXCI6IFwiXjIuMi45XCIsXG4gICAgXCJyZXF1ZXN0XCI6IFwiXjIuODUuMFwiLFxuICAgIFwic2VtYXBob3JlXCI6IFwiXjEuMC4zXCIsXG4gICAgXCJ3c1wiOiBcIl41LjEuMVwiLFxuICAgIFwieGhyXCI6IFwiXjIuMi4wXCIsXG4gICAgXCJ4dGVuZFwiOiBcIl40LjAuMVwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIkBiYWJlbC9jbGlcIjogXCJeNy41LjVcIixcbiAgICBcIkBiYWJlbC9jb3JlXCI6IFwiXjcuNS41XCIsXG4gICAgXCJAYmFiZWwvcHJlc2V0LWVudlwiOiBcIl43LjUuNVwiLFxuICAgIFwiYmFiZWxpZnlcIjogXCJeMTAuMC4wXCIsXG4gICAgXCJicm93c2VyaWZ5XCI6IFwiXjE2LjUuMFwiLFxuICAgIFwiZXNsaW50XCI6IFwiXjYuMi4wXCIsXG4gICAgXCJldGhqc1wiOiBcIl4wLjMuNlwiLFxuICAgIFwiZ2FuYWNoZS1jb3JlXCI6IFwiXjIuNy4wXCIsXG4gICAgXCJ0YXBlXCI6IFwiXjQuNC4wXCJcbiAgfSxcbiAgXCJicm93c2VyXCI6IHtcbiAgICBcInJlcXVlc3RcIjogZmFsc2UsXG4gICAgXCJ3c1wiOiBmYWxzZVxuICB9XG59XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVCbG9ja0NhY2hlTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2Jsb2NrLWNhY2hlJylcblxuY2xhc3MgQmxvY2tDYWNoZVN1YnByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcigoeyBibG9ja1RyYWNrZXIgfSkgPT4gY3JlYXRlQmxvY2tDYWNoZU1pZGRsZXdhcmUoT2JqZWN0LmFzc2lnbih7IGJsb2NrVHJhY2tlciB9LCBvcHRzKSkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBCbG9ja0NhY2hlU3VicHJvdmlkZXJcbiIsImNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5jb25zdCBGaXh0dXJlUHJvdmlkZXIgPSByZXF1aXJlKCcuL2ZpeHR1cmUuanMnKVxuY29uc3QgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpLnZlcnNpb25cblxubW9kdWxlLmV4cG9ydHMgPSBEZWZhdWx0Rml4dHVyZXNcblxuaW5oZXJpdHMoRGVmYXVsdEZpeHR1cmVzLCBGaXh0dXJlUHJvdmlkZXIpXG5cbmZ1bmN0aW9uIERlZmF1bHRGaXh0dXJlcyhvcHRzKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIG9wdHMgPSBvcHRzIHx8IHt9XG4gIHZhciByZXNwb25zZXMgPSBleHRlbmQoe1xuICAgIHdlYjNfY2xpZW50VmVyc2lvbjogJ1Byb3ZpZGVyRW5naW5lL3YnK3ZlcnNpb24rJy9qYXZhc2NyaXB0JyxcbiAgICBuZXRfbGlzdGVuaW5nOiB0cnVlLFxuICAgIGV0aF9oYXNocmF0ZTogJzB4MDAnLFxuICAgIGV0aF9taW5pbmc6IGZhbHNlLFxuICB9LCBvcHRzKVxuICBGaXh0dXJlUHJvdmlkZXIuY2FsbChzZWxmLCByZXNwb25zZXMpXG59XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVGZXRjaE1pZGRsZXdhcmUgPSByZXF1aXJlKCdldGgtanNvbi1ycGMtbWlkZGxld2FyZS9mZXRjaCcpXG5cbmNsYXNzIEZldGNoU3VicHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlclN1YnByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIHN1cGVyKCh7IGJsb2NrVHJhY2tlciwgcHJvdmlkZXIsIGVuZ2luZSB9KSA9PiB7XG4gICAgICByZXR1cm4gY3JlYXRlRmV0Y2hNaWRkbGV3YXJlKG9wdHMpXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZldGNoU3VicHJvdmlkZXJcbiIsImNvbnN0IFByb3ZpZGVyU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL2pzb24tcnBjLWVuZ2luZS1taWRkbGV3YXJlJylcbmNvbnN0IGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUgPSByZXF1aXJlKCdldGgtanNvbi1ycGMtZmlsdGVycycpXG5cbmNsYXNzIFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlciBleHRlbmRzIFByb3ZpZGVyU3VicHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyLCBlbmdpbmUgfSkgPT4ge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpbHRlck1pZGRsZXdhcmUoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0pXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlclxuIiwiY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gRml4dHVyZVByb3ZpZGVyXG5cbmluaGVyaXRzKEZpeHR1cmVQcm92aWRlciwgU3VicHJvdmlkZXIpXG5cbmZ1bmN0aW9uIEZpeHR1cmVQcm92aWRlcihzdGF0aWNSZXNwb25zZXMpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzdGF0aWNSZXNwb25zZXMgPSBzdGF0aWNSZXNwb25zZXMgfHwge31cbiAgc2VsZi5zdGF0aWNSZXNwb25zZXMgPSBzdGF0aWNSZXNwb25zZXNcbn1cblxuRml4dHVyZVByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCwgbmV4dCwgZW5kKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgdmFyIHN0YXRpY1Jlc3BvbnNlID0gc2VsZi5zdGF0aWNSZXNwb25zZXNbcGF5bG9hZC5tZXRob2RdXG4gIC8vIGFzeW5jIGZ1bmN0aW9uXG4gIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2Ygc3RhdGljUmVzcG9uc2UpIHtcbiAgICBzdGF0aWNSZXNwb25zZShwYXlsb2FkLCBuZXh0LCBlbmQpXG4gIC8vIHN0YXRpYyByZXNwb25zZSAtIG51bGwgaXMgdmFsaWQgcmVzcG9uc2VcbiAgfSBlbHNlIGlmIChzdGF0aWNSZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gcmV0dXJuIHJlc3VsdCBhc3luY2hyb25vdXNseVxuICAgIHNldFRpbWVvdXQoKCkgPT4gZW5kKG51bGwsIHN0YXRpY1Jlc3BvbnNlKSlcbiAgLy8gbm8gcHJlcGFyZWQgcmVzcG9uc2UgLSBza2lwXG4gIH0gZWxzZSB7XG4gICAgbmV4dCgpXG4gIH1cbn1cbiIsIi8qXG4gKiBFbXVsYXRlICdldGhfYWNjb3VudHMnIC8gJ2V0aF9zZW5kVHJhbnNhY3Rpb24nIHVzaW5nICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJ1xuICpcbiAqIFRoZSB0d28gY2FsbGJhY2tzIGEgdXNlciBuZWVkcyB0byBpbXBsZW1lbnQgYXJlOlxuICogLSBnZXRBY2NvdW50cygpIC0tIGFycmF5IG9mIGFkZHJlc3NlcyBzdXBwb3J0ZWRcbiAqIC0gc2lnblRyYW5zYWN0aW9uKHR4KSAtLSBzaWduIGEgcmF3IHRyYW5zYWN0aW9uIG9iamVjdFxuICovXG5cbmNvbnN0IHdhdGVyZmFsbCA9IHJlcXVpcmUoJ2FzeW5jL3dhdGVyZmFsbCcpXG5jb25zdCBwYXJhbGxlbCA9IHJlcXVpcmUoJ2FzeW5jL3BhcmFsbGVsJylcbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcbmNvbnN0IHNpZ1V0aWwgPSByZXF1aXJlKCdldGgtc2lnLXV0aWwnKVxuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuY29uc3QgU2VtYXBob3JlID0gcmVxdWlyZSgnc2VtYXBob3JlJylcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5jb25zdCBlc3RpbWF0ZUdhcyA9IHJlcXVpcmUoJy4uL3V0aWwvZXN0aW1hdGUtZ2FzLmpzJylcbmNvbnN0IGhleFJlZ2V4ID0gL15bMC05QS1GYS1mXSskL2dcblxubW9kdWxlLmV4cG9ydHMgPSBIb29rZWRXYWxsZXRTdWJwcm92aWRlclxuXG4vLyBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgUlBDIG1ldGhvZHM6XG4vLyAgIGV0aF9jb2luYmFzZVxuLy8gICBldGhfYWNjb3VudHNcbi8vICAgZXRoX3NlbmRUcmFuc2FjdGlvblxuLy8gICBldGhfc2lnblxuLy8gICBldGhfc2lnblR5cGVkRGF0YVxuLy8gICBldGhfc2lnblR5cGVkRGF0YV92M1xuLy8gICBldGhfc2lnblR5cGVkRGF0YV92NFxuLy8gICBwZXJzb25hbF9zaWduXG4vLyAgIGV0aF9kZWNyeXB0TWVzc2FnZVxuLy8gICBlbmNyeXB0aW9uX3B1YmxpY19rZXlcbi8vICAgcGVyc29uYWxfZWNSZWNvdmVyXG4vLyAgIHBhcml0eV9wb3N0VHJhbnNhY3Rpb25cbi8vICAgcGFyaXR5X2NoZWNrUmVxdWVzdFxuLy8gICBwYXJpdHlfZGVmYXVsdEFjY291bnRcblxuLy9cbi8vIFR4IFNpZ25hdHVyZSBGbG93XG4vL1xuLy8gaGFuZGxlUmVxdWVzdDogZXRoX3NlbmRUcmFuc2FjdGlvblxuLy8gICB2YWxpZGF0ZVRyYW5zYWN0aW9uIChiYXNpYyB2YWxpZGl0eSBjaGVjaylcbi8vICAgICB2YWxpZGF0ZVNlbmRlciAoY2hlY2tzIHRoYXQgc2VuZGVyIGlzIGluIGFjY291bnRzKVxuLy8gICBwcm9jZXNzVHJhbnNhY3Rpb24gKHNpZ24gdHggYW5kIHN1Ym1pdCB0byBuZXR3b3JrKVxuLy8gICAgIGFwcHJvdmVUcmFuc2FjdGlvbiAoVUkgYXBwcm92YWwgaG9vaylcbi8vICAgICBjaGVja0FwcHJvdmFsXG4vLyAgICAgZmluYWxpemVBbmRTdWJtaXRUeCAodHggc2lnbmluZylcbi8vICAgICAgIG5vbmNlTG9jay50YWtlIChib3R0bGUgbmVjayB0byBlbnN1cmUgYXRvbWljIG5vbmNlKVxuLy8gICAgICAgICBmaWxsSW5UeEV4dHJhcyAoc2V0IGZhbGxiYWNrIGdhc1ByaWNlLCBub25jZSwgZXRjKVxuLy8gICAgICAgICBzaWduVHJhbnNhY3Rpb24gKHBlcmZvcm0gdGhlIHNpZ25hdHVyZSlcbi8vICAgICAgICAgcHVibGlzaFRyYW5zYWN0aW9uIChwdWJsaXNoIHNpZ25lZCB0eCB0byBuZXR3b3JrKVxuLy9cblxuXG5pbmhlcml0cyhIb29rZWRXYWxsZXRTdWJwcm92aWRlciwgU3VicHJvdmlkZXIpXG5cbmZ1bmN0aW9uIEhvb2tlZFdhbGxldFN1YnByb3ZpZGVyKG9wdHMpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvLyBjb250cm9sIGZsb3dcbiAgc2VsZi5ub25jZUxvY2sgPSBTZW1hcGhvcmUoMSlcblxuICAvLyBkYXRhIGxvb2t1cFxuICBpZiAob3B0cy5nZXRBY2NvdW50cykgc2VsZi5nZXRBY2NvdW50cyA9IG9wdHMuZ2V0QWNjb3VudHNcbiAgLy8gaGlnaCBsZXZlbCBvdmVycmlkZVxuICBpZiAob3B0cy5wcm9jZXNzVHJhbnNhY3Rpb24pIHNlbGYucHJvY2Vzc1RyYW5zYWN0aW9uID0gb3B0cy5wcm9jZXNzVHJhbnNhY3Rpb25cbiAgaWYgKG9wdHMucHJvY2Vzc01lc3NhZ2UpIHNlbGYucHJvY2Vzc01lc3NhZ2UgPSBvcHRzLnByb2Nlc3NNZXNzYWdlXG4gIGlmIChvcHRzLnByb2Nlc3NQZXJzb25hbE1lc3NhZ2UpIHNlbGYucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSA9IG9wdHMucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZVxuICBpZiAob3B0cy5wcm9jZXNzVHlwZWRNZXNzYWdlKSBzZWxmLnByb2Nlc3NUeXBlZE1lc3NhZ2UgPSBvcHRzLnByb2Nlc3NUeXBlZE1lc3NhZ2VcbiAgLy8gYXBwcm92YWwgaG9va3NcbiAgc2VsZi5hcHByb3ZlVHJhbnNhY3Rpb24gPSBvcHRzLmFwcHJvdmVUcmFuc2FjdGlvbiB8fCBzZWxmLmF1dG9BcHByb3ZlXG4gIHNlbGYuYXBwcm92ZU1lc3NhZ2UgPSBvcHRzLmFwcHJvdmVNZXNzYWdlIHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgc2VsZi5hcHByb3ZlUGVyc29uYWxNZXNzYWdlID0gb3B0cy5hcHByb3ZlUGVyc29uYWxNZXNzYWdlIHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgc2VsZi5hcHByb3ZlRGVjcnlwdE1lc3NhZ2UgPSBvcHRzLmFwcHJvdmVEZWNyeXB0TWVzc2FnZSB8fCBzZWxmLmF1dG9BcHByb3ZlXG4gIHNlbGYuYXBwcm92ZUVuY3J5cHRpb25QdWJsaWNLZXkgPSBvcHRzLmFwcHJvdmVFbmNyeXB0aW9uUHVibGljS2V5IHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgc2VsZi5hcHByb3ZlVHlwZWRNZXNzYWdlID0gb3B0cy5hcHByb3ZlVHlwZWRNZXNzYWdlIHx8IHNlbGYuYXV0b0FwcHJvdmVcbiAgLy8gYWN0dWFsbHkgcGVyZm9ybSB0aGUgc2lnbmF0dXJlXG4gIGlmIChvcHRzLnNpZ25UcmFuc2FjdGlvbikgc2VsZi5zaWduVHJhbnNhY3Rpb24gPSBvcHRzLnNpZ25UcmFuc2FjdGlvbiAgfHwgbXVzdFByb3ZpZGVJbkNvbnN0cnVjdG9yKCdzaWduVHJhbnNhY3Rpb24nKVxuICBpZiAob3B0cy5zaWduTWVzc2FnZSkgc2VsZi5zaWduTWVzc2FnZSA9IG9wdHMuc2lnbk1lc3NhZ2UgIHx8IG11c3RQcm92aWRlSW5Db25zdHJ1Y3Rvcignc2lnbk1lc3NhZ2UnKVxuICBpZiAob3B0cy5zaWduUGVyc29uYWxNZXNzYWdlKSBzZWxmLnNpZ25QZXJzb25hbE1lc3NhZ2UgPSBvcHRzLnNpZ25QZXJzb25hbE1lc3NhZ2UgIHx8IG11c3RQcm92aWRlSW5Db25zdHJ1Y3Rvcignc2lnblBlcnNvbmFsTWVzc2FnZScpXG4gIGlmIChvcHRzLmRlY3J5cHRNZXNzYWdlKSBzZWxmLmRlY3J5cHRNZXNzYWdlID0gb3B0cy5kZWNyeXB0TWVzc2FnZSAgfHwgbXVzdFByb3ZpZGVJbkNvbnN0cnVjdG9yKCdkZWNyeXB0TWVzc2FnZScpXG4gIGlmIChvcHRzLmVuY3J5cHRpb25QdWJsaWNLZXkpIHNlbGYuZW5jcnlwdGlvblB1YmxpY0tleSA9IG9wdHMuZW5jcnlwdGlvblB1YmxpY0tleSAgfHwgbXVzdFByb3ZpZGVJbkNvbnN0cnVjdG9yKCdlbmNyeXB0aW9uUHVibGljS2V5JylcbiAgaWYgKG9wdHMuc2lnblR5cGVkTWVzc2FnZSkgc2VsZi5zaWduVHlwZWRNZXNzYWdlID0gb3B0cy5zaWduVHlwZWRNZXNzYWdlICB8fCBtdXN0UHJvdmlkZUluQ29uc3RydWN0b3IoJ3NpZ25UeXBlZE1lc3NhZ2UnKVxuICBpZiAob3B0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUpIHNlbGYucmVjb3ZlclBlcnNvbmFsU2lnbmF0dXJlID0gb3B0cy5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmVcbiAgLy8gcHVibGlzaCB0byBuZXR3b3JrXG4gIGlmIChvcHRzLnB1Ymxpc2hUcmFuc2FjdGlvbikgc2VsZi5wdWJsaXNoVHJhbnNhY3Rpb24gPSBvcHRzLnB1Ymxpc2hUcmFuc2FjdGlvblxuICAvLyBnYXMgb3B0aW9uc1xuICBzZWxmLmVzdGltYXRlR2FzID0gb3B0cy5lc3RpbWF0ZUdhcyB8fCBzZWxmLmVzdGltYXRlR2FzXG4gIHNlbGYuZ2V0R2FzUHJpY2UgPSBvcHRzLmdldEdhc1ByaWNlIHx8IHNlbGYuZ2V0R2FzUHJpY2Vcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbihwYXlsb2FkLCBuZXh0LCBlbmQpe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBzZWxmLl9wYXJpdHlSZXF1ZXN0cyA9IHt9XG4gIHNlbGYuX3Bhcml0eVJlcXVlc3RDb3VudCA9IDBcblxuICAvLyBzd2l0Y2ggc3RhdGVtZW50IGlzIG5vdCBibG9jayBzY29wZWRcbiAgLy8gc3Agd2UgY2FudCByZXBlYXQgdmFyIGRlY2xhcmF0aW9uc1xuICBsZXQgdHhQYXJhbXMsIG1zZ1BhcmFtcywgZXh0cmFQYXJhbXNcbiAgbGV0IG1lc3NhZ2UsIGFkZHJlc3NcblxuICBzd2l0Y2gocGF5bG9hZC5tZXRob2QpIHtcblxuICAgIGNhc2UgJ2V0aF9jb2luYmFzZSc6XG4gICAgICAvLyBwcm9jZXNzIG5vcm1hbGx5XG4gICAgICBzZWxmLmdldEFjY291bnRzKGZ1bmN0aW9uKGVyciwgYWNjb3VudHMpe1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZW5kKGVycilcbiAgICAgICAgbGV0IHJlc3VsdCA9IGFjY291bnRzWzBdIHx8IG51bGxcbiAgICAgICAgZW5kKG51bGwsIHJlc3VsdClcbiAgICAgIH0pXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgJ2V0aF9hY2NvdW50cyc6XG4gICAgICAvLyBwcm9jZXNzIG5vcm1hbGx5XG4gICAgICBzZWxmLmdldEFjY291bnRzKGZ1bmN0aW9uKGVyciwgYWNjb3VudHMpe1xuICAgICAgICBpZiAoZXJyKSByZXR1cm4gZW5kKGVycilcbiAgICAgICAgZW5kKG51bGwsIGFjY291bnRzKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAnZXRoX3NlbmRUcmFuc2FjdGlvbic6XG4gICAgICB0eFBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAoY2IpID0+IHNlbGYudmFsaWRhdGVUcmFuc2FjdGlvbih0eFBhcmFtcywgY2IpLFxuICAgICAgICAoY2IpID0+IHNlbGYucHJvY2Vzc1RyYW5zYWN0aW9uKHR4UGFyYW1zLCBjYiksXG4gICAgICBdLCBlbmQpXG4gICAgICByZXR1cm5cblxuICAgIGNhc2UgJ2V0aF9zaWduVHJhbnNhY3Rpb24nOlxuICAgICAgdHhQYXJhbXMgPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgKGNiKSA9PiBzZWxmLnZhbGlkYXRlVHJhbnNhY3Rpb24odHhQYXJhbXMsIGNiKSxcbiAgICAgICAgKGNiKSA9PiBzZWxmLnByb2Nlc3NTaWduVHJhbnNhY3Rpb24odHhQYXJhbXMsIGNiKSxcbiAgICAgIF0sIGVuZClcbiAgICAgIHJldHVyblxuXG4gICAgY2FzZSAnZXRoX3NpZ24nOlxuICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgYWRkcmVzcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAvLyBnb29kIHBsYWNlIGZvciBtZXRhZGF0YVxuICAgICAgZXh0cmFQYXJhbXMgPSBwYXlsb2FkLnBhcmFtc1syXSB8fCB7fVxuICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgIGZyb206IGFkZHJlc3MsXG4gICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICB9KVxuICAgICAgd2F0ZXJmYWxsKFtcbiAgICAgICAgKGNiKSA9PiBzZWxmLnZhbGlkYXRlTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgKGNiKSA9PiBzZWxmLnByb2Nlc3NNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICAgICAgXSwgZW5kKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdwZXJzb25hbF9zaWduJzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgICBjb25zdCBmaXJzdCA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHBheWxvYWQucGFyYW1zWzFdXG5cbiAgICAgICAgLy8gV2UgaW5pdGlhbGx5IGluY29ycmVjdGx5IG9yZGVyZWQgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgICAgLy8gVG8gZ3JhY2VmdWxseSByZXNwZWN0IHVzZXJzIHdobyBhZG9wdGVkIHRoaXMgQVBJIGVhcmx5LFxuICAgICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGdyYWNlZnVsbHkgcmVjb3ZlcmluZyBmcm9tIHRoZSB3cm9uZyBwYXJhbSBvcmRlclxuICAgICAgICAvLyB3aGVuIGl0IGlzIGNsZWFybHkgaWRlbnRpZmlhYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGF0IG1lYW5zIHdoZW4gdGhlIGZpcnN0IHBhcmFtIGlzIGRlZmluaXRlbHkgYW4gYWRkcmVzcyxcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgcGFyYW0gaXMgZGVmaW5pdGVseSBub3QsIGJ1dCBpcyBoZXguXG4gICAgICAgIGlmIChyZXNlbWJsZXNEYXRhKHNlY29uZCkgJiYgcmVzZW1ibGVzQWRkcmVzcyhmaXJzdCkpIHtcbiAgICAgICAgICBsZXQgd2FybmluZyA9IGBUaGUgZXRoX3BlcnNvbmFsU2lnbiBtZXRob2QgcmVxdWlyZXMgcGFyYW1zIG9yZGVyZWQgYFxuICAgICAgICAgIHdhcm5pbmcgKz0gYFttZXNzYWdlLCBhZGRyZXNzXS4gVGhpcyB3YXMgcHJldmlvdXNseSBoYW5kbGVkIGluY29ycmVjdGx5LCBgXG4gICAgICAgICAgd2FybmluZyArPSBgYW5kIGhhcyBiZWVuIGNvcnJlY3RlZCBhdXRvbWF0aWNhbGx5LiBgXG4gICAgICAgICAgd2FybmluZyArPSBgUGxlYXNlIHN3aXRjaCB0aGlzIHBhcmFtIG9yZGVyIGZvciBzbW9vdGggYmVoYXZpb3IgaW4gdGhlIGZ1dHVyZS5gXG4gICAgICAgICAgY29uc29sZS53YXJuKHdhcm5pbmcpXG5cbiAgICAgICAgICBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgICBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAgIC8vIGdvb2QgcGxhY2UgZm9yIG1ldGFkYXRhXG4gICAgICAgIGV4dHJhUGFyYW1zID0gcGF5bG9hZC5wYXJhbXNbMl0gfHwge31cbiAgICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICB9KVxuICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgIChjYikgPT4gc2VsZi52YWxpZGF0ZVBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgICAoY2IpID0+IHNlbGYucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgXSwgZW5kKVxuICAgICAgfSkoKVxuXG4gICAgY2FzZSAnZXRoX2RlY3J5cHRNZXNzYWdlJzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gcHJvY2VzcyBub3JtYWxseVxuICAgICAgICBjb25zdCBmaXJzdCA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHBheWxvYWQucGFyYW1zWzFdXG5cbiAgICAgICAgLy8gV2UgaW5pdGlhbGx5IGluY29ycmVjdGx5IG9yZGVyZWQgdGhlc2UgcGFyYW1ldGVycy5cbiAgICAgICAgLy8gVG8gZ3JhY2VmdWxseSByZXNwZWN0IHVzZXJzIHdobyBhZG9wdGVkIHRoaXMgQVBJIGVhcmx5LFxuICAgICAgICAvLyB3ZSBhcmUgY3VycmVudGx5IGdyYWNlZnVsbHkgcmVjb3ZlcmluZyBmcm9tIHRoZSB3cm9uZyBwYXJhbSBvcmRlclxuICAgICAgICAvLyB3aGVuIGl0IGlzIGNsZWFybHkgaWRlbnRpZmlhYmxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGF0IG1lYW5zIHdoZW4gdGhlIGZpcnN0IHBhcmFtIGlzIGRlZmluaXRlbHkgYW4gYWRkcmVzcyxcbiAgICAgICAgLy8gYW5kIHRoZSBzZWNvbmQgcGFyYW0gaXMgZGVmaW5pdGVseSBub3QsIGJ1dCBpcyBoZXguXG4gICAgICAgIGlmIChyZXNlbWJsZXNEYXRhKHNlY29uZCkgJiYgcmVzZW1ibGVzQWRkcmVzcyhmaXJzdCkpIHtcbiAgICAgICAgICBsZXQgd2FybmluZyA9IGBUaGUgZXRoX2RlY3J5cHRNZXNzYWdlIG1ldGhvZCByZXF1aXJlcyBwYXJhbXMgb3JkZXJlZCBgXG4gICAgICAgICAgd2FybmluZyArPSBgW21lc3NhZ2UsIGFkZHJlc3NdLiBUaGlzIHdhcyBwcmV2aW91c2x5IGhhbmRsZWQgaW5jb3JyZWN0bHksIGBcbiAgICAgICAgICB3YXJuaW5nICs9IGBhbmQgaGFzIGJlZW4gY29ycmVjdGVkIGF1dG9tYXRpY2FsbHkuIGBcbiAgICAgICAgICB3YXJuaW5nICs9IGBQbGVhc2Ugc3dpdGNoIHRoaXMgcGFyYW0gb3JkZXIgZm9yIHNtb290aCBiZWhhdmlvciBpbiB0aGUgZnV0dXJlLmBcbiAgICAgICAgICBjb25zb2xlLndhcm4od2FybmluZylcblxuICAgICAgICAgIGFkZHJlc3MgPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICAgIG1lc3NhZ2UgPSBwYXlsb2FkLnBhcmFtc1sxXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICAgIGFkZHJlc3MgPSBwYXlsb2FkLnBhcmFtc1sxXVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gbm9uLXN0YW5kYXJkIFwiZXh0cmFQYXJhbXNcIiB0byBiZSBhcHBlbmRlZCB0byBvdXIgXCJtc2dQYXJhbXNcIiBvYmpcbiAgICAgICAgLy8gZ29vZCBwbGFjZSBmb3IgbWV0YWRhdGFcbiAgICAgICAgZXh0cmFQYXJhbXMgPSBwYXlsb2FkLnBhcmFtc1syXSB8fCB7fVxuICAgICAgICBtc2dQYXJhbXMgPSBleHRlbmQoZXh0cmFQYXJhbXMsIHtcbiAgICAgICAgICBmcm9tOiBhZGRyZXNzLFxuICAgICAgICAgIGRhdGE6IG1lc3NhZ2UsXG4gICAgICAgIH0pXG4gICAgICAgIHdhdGVyZmFsbChbXG4gICAgICAgICAgKGNiKSA9PiBzZWxmLnZhbGlkYXRlRGVjcnlwdE1lc3NhZ2UobXNnUGFyYW1zLCBjYiksXG4gICAgICAgICAgKGNiKSA9PiBzZWxmLnByb2Nlc3NEZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgXSwgZW5kKVxuICAgICAgfSkoKVxuICAgICAgXG4gICAgY2FzZSAnZW5jcnlwdGlvbl9wdWJsaWNfa2V5JzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIFxuICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgIChjYikgPT4gc2VsZi52YWxpZGF0ZUVuY3J5cHRpb25QdWJsaWNLZXkoYWRkcmVzcywgY2IpLFxuICAgICAgICAgIChjYikgPT4gc2VsZi5wcm9jZXNzRW5jcnlwdGlvblB1YmxpY0tleShhZGRyZXNzLCBjYiksXG4gICAgICAgIF0sIGVuZClcbiAgICAgIH0pKClcbiAgICAgIFxuICAgIGNhc2UgJ3BlcnNvbmFsX2VjUmVjb3Zlcic6XG4gICAgICByZXR1cm4gKGZ1bmN0aW9uKCl7ICAgIFxuICAgICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHBheWxvYWQucGFyYW1zWzFdXG4gICAgICAgIC8vIG5vbi1zdGFuZGFyZCBcImV4dHJhUGFyYW1zXCIgdG8gYmUgYXBwZW5kZWQgdG8gb3VyIFwibXNnUGFyYW1zXCIgb2JqXG4gICAgICAgIC8vIGdvb2QgcGxhY2UgZm9yIG1ldGFkYXRhXG4gICAgICAgIGV4dHJhUGFyYW1zID0gcGF5bG9hZC5wYXJhbXNbMl0gfHwge31cbiAgICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgICAgc2lnOiBzaWduYXR1cmUsXG4gICAgICAgICAgZGF0YTogbWVzc2FnZSxcbiAgICAgICAgfSlcbiAgICAgICAgc2VsZi5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUobXNnUGFyYW1zLCBlbmQpXG4gICAgICB9KSgpXG5cbiAgICBjYXNlICdldGhfc2lnblR5cGVkRGF0YSc6XG4gICAgY2FzZSAnZXRoX3NpZ25UeXBlZERhdGFfdjMnOlxuICAgIGNhc2UgJ2V0aF9zaWduVHlwZWREYXRhX3Y0JzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXsgXG4gICAgICAgIC8vIHByb2Nlc3Mgbm9ybWFsbHlcbiAgICAgIFxuICAgICAgICBjb25zdCBmaXJzdCA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICAgIGNvbnN0IHNlY29uZCA9IHBheWxvYWQucGFyYW1zWzFdXG5cbiAgICAgICAgaWYgKHJlc2VtYmxlc0FkZHJlc3MoZmlyc3QpKSB7XG4gICAgICAgICAgYWRkcmVzcyA9IGZpcnN0XG4gICAgICAgICAgbWVzc2FnZSA9IHNlY29uZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lc3NhZ2UgPSBmaXJzdFxuICAgICAgICAgIGFkZHJlc3MgPSBzZWNvbmRcbiAgICAgICAgfVxuXG4gICAgICAgIGV4dHJhUGFyYW1zID0gcGF5bG9hZC5wYXJhbXNbMl0gfHwge31cbiAgICAgICAgbXNnUGFyYW1zID0gZXh0ZW5kKGV4dHJhUGFyYW1zLCB7XG4gICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICBkYXRhOiBtZXNzYWdlLFxuICAgICAgICB9KVxuICAgICAgICB3YXRlcmZhbGwoW1xuICAgICAgICAgIChjYikgPT4gc2VsZi52YWxpZGF0ZVR5cGVkTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgICAoY2IpID0+IHNlbGYucHJvY2Vzc1R5cGVkTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAgICAgXSwgZW5kKVxuICAgICAgfSkoKVxuXG4gICAgY2FzZSAncGFyaXR5X3Bvc3RUcmFuc2FjdGlvbic6XG4gICAgICB0eFBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICBzZWxmLnBhcml0eVBvc3RUcmFuc2FjdGlvbih0eFBhcmFtcywgZW5kKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdwYXJpdHlfcG9zdFNpZ24nOlxuICAgICAgYWRkcmVzcyA9IHBheWxvYWQucGFyYW1zWzBdXG4gICAgICBtZXNzYWdlID0gcGF5bG9hZC5wYXJhbXNbMV1cbiAgICAgIHNlbGYucGFyaXR5UG9zdFNpZ24oYWRkcmVzcywgbWVzc2FnZSwgZW5kKVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdwYXJpdHlfY2hlY2tSZXF1ZXN0JzpcbiAgICAgIHJldHVybiAoZnVuY3Rpb24oKXtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gcGF5bG9hZC5wYXJhbXNbMF1cbiAgICAgICAgc2VsZi5wYXJpdHlDaGVja1JlcXVlc3QocmVxdWVzdElkLCBlbmQpXG4gICAgICB9KSgpXG5cbiAgICBjYXNlICdwYXJpdHlfZGVmYXVsdEFjY291bnQnOlxuICAgICAgc2VsZi5nZXRBY2NvdW50cyhmdW5jdGlvbihlcnIsIGFjY291bnRzKXtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIGVuZChlcnIpXG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBhY2NvdW50c1swXSB8fCBudWxsXG4gICAgICAgIGVuZChudWxsLCBhY2NvdW50KVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuXG4gICAgZGVmYXVsdDpcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG5cbiAgfVxufVxuXG4vL1xuLy8gZGF0YSBsb29rdXBcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5nZXRBY2NvdW50cyA9IGZ1bmN0aW9uKGNiKSB7XG4gIGNiKG51bGwsIFtdKVxufVxuXG5cbi8vXG4vLyBcInByb2Nlc3NcIiBoaWdoIGxldmVsIGZsb3dcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzVHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IHNlbGYuYXBwcm92ZVRyYW5zYWN0aW9uKHR4UGFyYW1zLCBjYiksXG4gICAgKGRpZEFwcHJvdmUsIGNiKSA9PiBzZWxmLmNoZWNrQXBwcm92YWwoJ3RyYW5zYWN0aW9uJywgZGlkQXBwcm92ZSwgY2IpLFxuICAgIChjYikgPT4gc2VsZi5maW5hbGl6ZUFuZFN1Ym1pdFR4KHR4UGFyYW1zLCBjYiksXG4gIF0sIGNiKVxufVxuXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzU2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHdhdGVyZmFsbChbXG4gICAgKGNiKSA9PiBzZWxmLmFwcHJvdmVUcmFuc2FjdGlvbih0eFBhcmFtcywgY2IpLFxuICAgIChkaWRBcHByb3ZlLCBjYikgPT4gc2VsZi5jaGVja0FwcHJvdmFsKCd0cmFuc2FjdGlvbicsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuZmluYWxpemVUeCh0eFBhcmFtcywgY2IpLFxuICBdLCBjYilcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnByb2Nlc3NNZXNzYWdlID0gZnVuY3Rpb24obXNnUGFyYW1zLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gc2VsZi5hcHByb3ZlTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnbWVzc2FnZScsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuc2lnbk1lc3NhZ2UobXNnUGFyYW1zLCBjYiksXG4gIF0sIGNiKVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZ1BhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgd2F0ZXJmYWxsKFtcbiAgICAoY2IpID0+IHNlbGYuYXBwcm92ZVBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnbWVzc2FnZScsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuc2lnblBlcnNvbmFsTWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgXSwgY2IpXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzRGVjcnlwdE1lc3NhZ2UgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHdhdGVyZmFsbChbXG4gICAgKGNiKSA9PiBzZWxmLmFwcHJvdmVEZWNyeXB0TWVzc2FnZShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnZGVjcnlwdE1lc3NhZ2UnLCBkaWRBcHByb3ZlLCBjYiksXG4gICAgKGNiKSA9PiBzZWxmLmRlY3J5cHRNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICBdLCBjYilcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnByb2Nlc3NFbmNyeXB0aW9uUHVibGljS2V5ID0gZnVuY3Rpb24obXNnUGFyYW1zLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gc2VsZi5hcHByb3ZlRW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMsIGNiKSxcbiAgICAoZGlkQXBwcm92ZSwgY2IpID0+IHNlbGYuY2hlY2tBcHByb3ZhbCgnZW5jcnlwdGlvblB1YmxpY0tleScsIGRpZEFwcHJvdmUsIGNiKSxcbiAgICAoY2IpID0+IHNlbGYuZW5jcnlwdGlvblB1YmxpY0tleShtc2dQYXJhbXMsIGNiKSxcbiAgXSwgY2IpXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wcm9jZXNzVHlwZWRNZXNzYWdlID0gZnVuY3Rpb24obXNnUGFyYW1zLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICB3YXRlcmZhbGwoW1xuICAgIChjYikgPT4gc2VsZi5hcHByb3ZlVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICAgIChkaWRBcHByb3ZlLCBjYikgPT4gc2VsZi5jaGVja0FwcHJvdmFsKCdtZXNzYWdlJywgZGlkQXBwcm92ZSwgY2IpLFxuICAgIChjYikgPT4gc2VsZi5zaWduVHlwZWRNZXNzYWdlKG1zZ1BhcmFtcywgY2IpLFxuICBdLCBjYilcbn1cblxuLy9cbi8vIGFwcHJvdmFsXG4vL1xuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUuYXV0b0FwcHJvdmUgPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY2IobnVsbCwgdHJ1ZSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmNoZWNrQXBwcm92YWwgPSBmdW5jdGlvbih0eXBlLCBkaWRBcHByb3ZlLCBjYikge1xuICBjYiggZGlkQXBwcm92ZSA/IG51bGwgOiBuZXcgRXJyb3IoJ1VzZXIgZGVuaWVkICcrdHlwZSsnIHNpZ25hdHVyZS4nKSApXG59XG5cbi8vXG4vLyBwYXJpdHlcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wYXJpdHlQb3N0VHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICAvLyBnZXQgbmV4dCBpZFxuICBjb25zdCBjb3VudCA9IHNlbGYuX3Bhcml0eVJlcXVlc3RDb3VudFxuICBjb25zdCByZXFJZCA9IGAweCR7Y291bnQudG9TdHJpbmcoMTYpfWBcbiAgc2VsZi5fcGFyaXR5UmVxdWVzdENvdW50KytcblxuICBzZWxmLmVtaXRQYXlsb2FkKHtcbiAgICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICBwYXJhbXM6IFt0eFBhcmFtc10sXG4gIH0sIGZ1bmN0aW9uKGVycm9yLCByZXMpe1xuICAgIGlmIChlcnJvcikge1xuICAgICAgc2VsZi5fcGFyaXR5UmVxdWVzdHNbcmVxSWRdID0geyBlcnJvciB9XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgdHhIYXNoID0gcmVzLnJlc3VsdFxuICAgIHNlbGYuX3Bhcml0eVJlcXVlc3RzW3JlcUlkXSA9IHR4SGFzaFxuICB9KVxuXG4gIGNiKG51bGwsIHJlcUlkKVxufVxuXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5wYXJpdHlQb3N0U2lnbiA9IGZ1bmN0aW9uKGFkZHJlc3MsIG1lc3NhZ2UsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgLy8gZ2V0IG5leHQgaWRcbiAgY29uc3QgY291bnQgPSBzZWxmLl9wYXJpdHlSZXF1ZXN0Q291bnRcbiAgY29uc3QgcmVxSWQgPSBgMHgke2NvdW50LnRvU3RyaW5nKDE2KX1gXG4gIHNlbGYuX3Bhcml0eVJlcXVlc3RDb3VudCsrXG5cbiAgc2VsZi5lbWl0UGF5bG9hZCh7XG4gICAgbWV0aG9kOiAnZXRoX3NpZ24nLFxuICAgIHBhcmFtczogW2FkZHJlc3MsIG1lc3NhZ2VdLFxuICB9LCBmdW5jdGlvbihlcnJvciwgcmVzKXtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHNlbGYuX3Bhcml0eVJlcXVlc3RzW3JlcUlkXSA9IHsgZXJyb3IgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHRcbiAgICBzZWxmLl9wYXJpdHlSZXF1ZXN0c1tyZXFJZF0gPSByZXN1bHRcbiAgfSlcblxuICBjYihudWxsLCByZXFJZClcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnBhcml0eUNoZWNrUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcUlkLCBjYikge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBjb25zdCByZXN1bHQgPSBzZWxmLl9wYXJpdHlSZXF1ZXN0c1tyZXFJZF0gfHwgbnVsbFxuICAvLyB0eCBub3QgaGFuZGxlZCB5ZXRcbiAgaWYgKCFyZXN1bHQpIHJldHVybiBjYihudWxsLCBudWxsKVxuICAvLyB0eCB3YXMgcmVqZWN0ZWQgKG9yIG90aGVyIGVycm9yKVxuICBpZiAocmVzdWx0LmVycm9yKSByZXR1cm4gY2IocmVzdWx0LmVycm9yKVxuICAvLyB0eCBzZW50XG4gIGNiKG51bGwsIHJlc3VsdClcbn1cblxuLy9cbi8vIHNpZ25hdHVyZSBhbmQgcmVjb3Zlcnlcbi8vXG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5yZWNvdmVyUGVyc29uYWxTaWduYXR1cmUgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKSB7XG4gIGxldCBzZW5kZXJIZXhcbiAgdHJ5IHtcbiAgICBzZW5kZXJIZXggPSBzaWdVdGlsLnJlY292ZXJQZXJzb25hbFNpZ25hdHVyZShtc2dQYXJhbXMpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBjYihlcnIpXG4gIH1cbiAgY2IobnVsbCwgc2VuZGVySGV4KVxufVxuXG4vL1xuLy8gdmFsaWRhdGlvblxuLy9cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnZhbGlkYXRlVHJhbnNhY3Rpb24gPSBmdW5jdGlvbih0eFBhcmFtcywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICAvLyBzaG9ydGN1dDogdW5kZWZpbmVkIHNlbmRlciBpcyBpbnZhbGlkXG4gIGlmICh0eFBhcmFtcy5mcm9tID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBhZGRyZXNzIC0gZnJvbSBhZGRyZXNzIHJlcXVpcmVkIHRvIHNpZ24gdHJhbnNhY3Rpb24uYCkpXG4gIHNlbGYudmFsaWRhdGVTZW5kZXIodHhQYXJhbXMuZnJvbSwgZnVuY3Rpb24oZXJyLCBzZW5kZXJJc1ZhbGlkKXtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmICghc2VuZGVySXNWYWxpZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5rbm93biBhZGRyZXNzIC0gdW5hYmxlIHRvIHNpZ24gdHJhbnNhY3Rpb24gZm9yIHRoaXMgYWRkcmVzczogXCIke3R4UGFyYW1zLmZyb219XCJgKSlcbiAgICBjYigpXG4gIH0pXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS52YWxpZGF0ZU1lc3NhZ2UgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgaWYgKG1zZ1BhcmFtcy5mcm9tID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBhZGRyZXNzIC0gZnJvbSBhZGRyZXNzIHJlcXVpcmVkIHRvIHNpZ24gbWVzc2FnZS5gKSlcbiAgc2VsZi52YWxpZGF0ZVNlbmRlcihtc2dQYXJhbXMuZnJvbSwgZnVuY3Rpb24oZXJyLCBzZW5kZXJJc1ZhbGlkKXtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgIGlmICghc2VuZGVySXNWYWxpZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5rbm93biBhZGRyZXNzIC0gdW5hYmxlIHRvIHNpZ24gbWVzc2FnZSBmb3IgdGhpcyBhZGRyZXNzOiBcIiR7bXNnUGFyYW1zLmZyb219XCJgKSlcbiAgICBjYigpXG4gIH0pXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS52YWxpZGF0ZVBlcnNvbmFsTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZ1BhcmFtcywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAobXNnUGFyYW1zLmZyb20gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIGFkZHJlc3MgLSBmcm9tIGFkZHJlc3MgcmVxdWlyZWQgdG8gc2lnbiBwZXJzb25hbCBtZXNzYWdlLmApKVxuICBpZiAobXNnUGFyYW1zLmRhdGEgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIG1lc3NhZ2UgLSBtZXNzYWdlIHJlcXVpcmVkIHRvIHNpZ24gcGVyc29uYWwgbWVzc2FnZS5gKSlcbiAgaWYgKCFpc1ZhbGlkSGV4KG1zZ1BhcmFtcy5kYXRhKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgSG9va2VkV2FsbGV0U3VicHJvdmlkZXIgLSB2YWxpZGF0ZU1lc3NhZ2UgLSBtZXNzYWdlIHdhcyBub3QgZW5jb2RlZCBhcyBoZXguYCkpXG4gIHNlbGYudmFsaWRhdGVTZW5kZXIobXNnUGFyYW1zLmZyb20sIGZ1bmN0aW9uKGVyciwgc2VuZGVySXNWYWxpZCl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXNlbmRlcklzVmFsaWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gYWRkcmVzcyAtIHVuYWJsZSB0byBzaWduIG1lc3NhZ2UgZm9yIHRoaXMgYWRkcmVzczogXCIke21zZ1BhcmFtcy5mcm9tfVwiYCkpXG4gICAgY2IoKVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUudmFsaWRhdGVEZWNyeXB0TWVzc2FnZSA9IGZ1bmN0aW9uKG1zZ1BhcmFtcywgY2Ipe1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAobXNnUGFyYW1zLmZyb20gPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIGFkZHJlc3MgLSBmcm9tIGFkZHJlc3MgcmVxdWlyZWQgdG8gZGVjcnlwdCBtZXNzYWdlLmApKVxuICBpZiAobXNnUGFyYW1zLmRhdGEgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNiKG5ldyBFcnJvcihgVW5kZWZpbmVkIG1lc3NhZ2UgLSBtZXNzYWdlIHJlcXVpcmVkIHRvIGRlY3J5cHQgbWVzc2FnZS5gKSlcbiAgaWYgKCFpc1ZhbGlkSGV4KG1zZ1BhcmFtcy5kYXRhKSkgcmV0dXJuIGNiKG5ldyBFcnJvcihgSG9va2VkV2FsbGV0U3VicHJvdmlkZXIgLSB2YWxpZGF0ZURlY3J5cHRNZXNzYWdlIC0gbWVzc2FnZSB3YXMgbm90IGVuY29kZWQgYXMgaGV4LmApKVxuICBzZWxmLnZhbGlkYXRlU2VuZGVyKG1zZ1BhcmFtcy5mcm9tLCBmdW5jdGlvbihlcnIsIHNlbmRlcklzVmFsaWQpe1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgaWYgKCFzZW5kZXJJc1ZhbGlkKSByZXR1cm4gY2IobmV3IEVycm9yKGBVbmtub3duIGFkZHJlc3MgLSB1bmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlIGZvciB0aGlzIGFkZHJlc3M6IFwiJHttc2dQYXJhbXMuZnJvbX1cImApKVxuICAgIGNiKClcbiAgfSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLnZhbGlkYXRlRW5jcnlwdGlvblB1YmxpY0tleSA9IGZ1bmN0aW9uKGFkZHJlc3MsIGNiKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICBzZWxmLnZhbGlkYXRlU2VuZGVyKGFkZHJlc3MsIGZ1bmN0aW9uKGVyciwgc2VuZGVySXNWYWxpZCl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXNlbmRlcklzVmFsaWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gYWRkcmVzcyAtIHVuYWJsZSB0byBvYnRhaW4gZW5jcnlwdGlvbiBwdWJsaWMga2V5IGZvciB0aGlzIGFkZHJlc3M6IFwiJHthZGRyZXNzfVwiYCkpXG4gICAgY2IoKVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUudmFsaWRhdGVUeXBlZE1lc3NhZ2UgPSBmdW5jdGlvbihtc2dQYXJhbXMsIGNiKXtcbiAgaWYgKG1zZ1BhcmFtcy5mcm9tID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBhZGRyZXNzIC0gZnJvbSBhZGRyZXNzIHJlcXVpcmVkIHRvIHNpZ24gdHlwZWQgZGF0YS5gKSlcbiAgaWYgKG1zZ1BhcmFtcy5kYXRhID09PSB1bmRlZmluZWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVuZGVmaW5lZCBkYXRhIC0gbWVzc2FnZSByZXF1aXJlZCB0byBzaWduIHR5cGVkIGRhdGEuYCkpXG4gIHRoaXMudmFsaWRhdGVTZW5kZXIobXNnUGFyYW1zLmZyb20sIGZ1bmN0aW9uKGVyciwgc2VuZGVySXNWYWxpZCl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBpZiAoIXNlbmRlcklzVmFsaWQpIHJldHVybiBjYihuZXcgRXJyb3IoYFVua25vd24gYWRkcmVzcyAtIHVuYWJsZSB0byBzaWduIG1lc3NhZ2UgZm9yIHRoaXMgYWRkcmVzczogXCIke21zZ1BhcmFtcy5mcm9tfVwiYCkpXG4gICAgY2IoKVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUudmFsaWRhdGVTZW5kZXIgPSBmdW5jdGlvbihzZW5kZXJBZGRyZXNzLCBjYil7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8vIHNob3J0Y3V0OiB1bmRlZmluZWQgc2VuZGVyIGlzIGludmFsaWRcbiAgaWYgKCFzZW5kZXJBZGRyZXNzKSByZXR1cm4gY2IobnVsbCwgZmFsc2UpXG4gIHNlbGYuZ2V0QWNjb3VudHMoZnVuY3Rpb24oZXJyLCBhY2NvdW50cyl7XG4gICAgaWYgKGVycikgcmV0dXJuIGNiKGVycilcbiAgICBjb25zdCBzZW5kZXJJc1ZhbGlkID0gKGFjY291bnRzLm1hcCh0b0xvd2VyQ2FzZSkuaW5kZXhPZihzZW5kZXJBZGRyZXNzLnRvTG93ZXJDYXNlKCkpICE9PSAtMSlcbiAgICBjYihudWxsLCBzZW5kZXJJc1ZhbGlkKVxuICB9KVxufVxuXG4vL1xuLy8gdHggaGVscGVyc1xuLy9cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmZpbmFsaXplQW5kU3VibWl0VHggPSBmdW5jdGlvbih0eFBhcmFtcywgY2IpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgLy8gY2FuIG9ubHkgYWxsb3cgb25lIHR4IHRvIHBhc3MgdGhyb3VnaCB0aGlzIGZsb3cgYXQgYSB0aW1lXG4gIC8vIHNvIHdlIGNhbiBhdG9taWNhbGx5IGNvbnN1bWUgYSBub25jZVxuICBzZWxmLm5vbmNlTG9jay50YWtlKGZ1bmN0aW9uKCl7XG4gICAgd2F0ZXJmYWxsKFtcbiAgICAgIHNlbGYuZmlsbEluVHhFeHRyYXMuYmluZChzZWxmLCB0eFBhcmFtcyksXG4gICAgICBzZWxmLnNpZ25UcmFuc2FjdGlvbi5iaW5kKHNlbGYpLFxuICAgICAgc2VsZi5wdWJsaXNoVHJhbnNhY3Rpb24uYmluZChzZWxmKSxcbiAgICBdLCBmdW5jdGlvbihlcnIsIHR4SGFzaCl7XG4gICAgICBzZWxmLm5vbmNlTG9jay5sZWF2ZSgpXG4gICAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuICAgICAgY2IobnVsbCwgdHhIYXNoKVxuICAgIH0pXG4gIH0pXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5maW5hbGl6ZVR4ID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIC8vIGNhbiBvbmx5IGFsbG93IG9uZSB0eCB0byBwYXNzIHRocm91Z2ggdGhpcyBmbG93IGF0IGEgdGltZVxuICAvLyBzbyB3ZSBjYW4gYXRvbWljYWxseSBjb25zdW1lIGEgbm9uY2VcbiAgc2VsZi5ub25jZUxvY2sudGFrZShmdW5jdGlvbigpe1xuICAgIHdhdGVyZmFsbChbXG4gICAgICBzZWxmLmZpbGxJblR4RXh0cmFzLmJpbmQoc2VsZiwgdHhQYXJhbXMpLFxuICAgICAgc2VsZi5zaWduVHJhbnNhY3Rpb24uYmluZChzZWxmKSxcbiAgICBdLCBmdW5jdGlvbihlcnIsIHNpZ25lZFR4KXtcbiAgICAgIHNlbGYubm9uY2VMb2NrLmxlYXZlKClcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgICBjYihudWxsLCB7cmF3OiBzaWduZWRUeCwgdHg6IHR4UGFyYW1zfSlcbiAgICB9KVxuICB9KVxufVxuXG5Ib29rZWRXYWxsZXRTdWJwcm92aWRlci5wcm90b3R5cGUucHVibGlzaFRyYW5zYWN0aW9uID0gZnVuY3Rpb24ocmF3VHgsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuZW1pdFBheWxvYWQoe1xuICAgIG1ldGhvZDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLFxuICAgIHBhcmFtczogW3Jhd1R4XSxcbiAgfSwgZnVuY3Rpb24oZXJyLCByZXMpe1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY2IobnVsbCwgcmVzLnJlc3VsdClcbiAgfSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmVzdGltYXRlR2FzID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGVzdGltYXRlR2FzKHNlbGYuZW5naW5lLCB0eFBhcmFtcywgY2IpXG59XG5cbkhvb2tlZFdhbGxldFN1YnByb3ZpZGVyLnByb3RvdHlwZS5nZXRHYXNQcmljZSA9IGZ1bmN0aW9uKGNiKSB7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuZW1pdFBheWxvYWQoeyBtZXRob2Q6ICdldGhfZ2FzUHJpY2UnLCBwYXJhbXM6IFtdIH0sIGZ1bmN0aW9uIChlcnIsIHJlcykge1xuICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpXG4gICAgY2IobnVsbCwgcmVzLnJlc3VsdClcbiAgfSlcbn1cblxuSG9va2VkV2FsbGV0U3VicHJvdmlkZXIucHJvdG90eXBlLmZpbGxJblR4RXh0cmFzID0gZnVuY3Rpb24odHhQYXJhbXMsIGNiKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgY29uc3QgYWRkcmVzcyA9IHR4UGFyYW1zLmZyb21cbiAgLy8gY29uc29sZS5sb2coJ2ZpbGxJblR4RXh0cmFzIC0gYWRkcmVzczonLCBhZGRyZXNzKVxuXG4gIGNvbnN0IHRhc2tzID0ge31cblxuICBpZiAodHhQYXJhbXMuZ2FzUHJpY2UgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwibmVlZCB0byBnZXQgZ2FzcHJpY2VcIilcbiAgICB0YXNrcy5nYXNQcmljZSA9IHNlbGYuZ2V0R2FzUHJpY2UuYmluZChzZWxmKVxuICB9XG5cbiAgaWYgKHR4UGFyYW1zLm5vbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBjb25zb2xlLmxvZyhcIm5lZWQgdG8gZ2V0IG5vbmNlXCIpXG4gICAgdGFza3Mubm9uY2UgPSBzZWxmLmVtaXRQYXlsb2FkLmJpbmQoc2VsZiwgeyBtZXRob2Q6ICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCcsIHBhcmFtczogW2FkZHJlc3MsICdwZW5kaW5nJ10gfSlcbiAgfVxuXG4gIGlmICh0eFBhcmFtcy5nYXMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIGNvbnNvbGUubG9nKFwibmVlZCB0byBnZXQgZ2FzXCIpXG4gICAgdGFza3MuZ2FzID0gc2VsZi5lc3RpbWF0ZUdhcy5iaW5kKHNlbGYsIGNsb25lVHhQYXJhbXModHhQYXJhbXMpKVxuICB9XG5cbiAgcGFyYWxsZWwodGFza3MsIGZ1bmN0aW9uKGVyciwgdGFza1Jlc3VsdHMpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2IoZXJyKVxuXG4gICAgY29uc3QgcmVzdWx0ID0ge31cbiAgICBpZiAodGFza1Jlc3VsdHMuZ2FzUHJpY2UpIHJlc3VsdC5nYXNQcmljZSA9IHRhc2tSZXN1bHRzLmdhc1ByaWNlXG4gICAgaWYgKHRhc2tSZXN1bHRzLm5vbmNlKSByZXN1bHQubm9uY2UgPSB0YXNrUmVzdWx0cy5ub25jZS5yZXN1bHRcbiAgICBpZiAodGFza1Jlc3VsdHMuZ2FzKSByZXN1bHQuZ2FzID0gdGFza1Jlc3VsdHMuZ2FzXG5cbiAgICBjYihudWxsLCBleHRlbmQodHhQYXJhbXMsIHJlc3VsdCkpXG4gIH0pXG59XG5cbi8vIHV0aWxcblxuLy8gd2UgdXNlIHRoaXMgdG8gY2xlYW4gYW55IGN1c3RvbSBwYXJhbXMgZnJvbSB0aGUgdHhQYXJhbXNcbmZ1bmN0aW9uIGNsb25lVHhQYXJhbXModHhQYXJhbXMpe1xuICByZXR1cm4ge1xuICAgIGZyb206IHR4UGFyYW1zLmZyb20sXG4gICAgdG86IHR4UGFyYW1zLnRvLFxuICAgIHZhbHVlOiB0eFBhcmFtcy52YWx1ZSxcbiAgICBkYXRhOiB0eFBhcmFtcy5kYXRhLFxuICAgIGdhczogdHhQYXJhbXMuZ2FzLFxuICAgIGdhc1ByaWNlOiB0eFBhcmFtcy5nYXNQcmljZSxcbiAgICBub25jZTogdHhQYXJhbXMubm9uY2UsXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9Mb3dlckNhc2Uoc3RyaW5nKXtcbiAgcmV0dXJuIHN0cmluZy50b0xvd2VyQ2FzZSgpXG59XG5cbmZ1bmN0aW9uIHJlc2VtYmxlc0FkZHJlc3MgKHN0cmluZykge1xuICBjb25zdCBmaXhlZCA9IGV0aFV0aWwuYWRkSGV4UHJlZml4KHN0cmluZylcbiAgY29uc3QgaXNWYWxpZCA9IGV0aFV0aWwuaXNWYWxpZEFkZHJlc3MoZml4ZWQpXG4gIHJldHVybiBpc1ZhbGlkXG59XG5cbi8vIFJldHVybnMgdHJ1ZSBpZiByZXNlbWJsZXMgaGV4IGRhdGFcbi8vIGJ1dCBkZWZpbml0ZWx5IG5vdCBhIHZhbGlkIGFkZHJlc3MuXG5mdW5jdGlvbiByZXNlbWJsZXNEYXRhIChzdHJpbmcpIHtcbiAgY29uc3QgZml4ZWQgPSBldGhVdGlsLmFkZEhleFByZWZpeChzdHJpbmcpXG4gIGNvbnN0IGlzVmFsaWRBZGRyZXNzID0gZXRoVXRpbC5pc1ZhbGlkQWRkcmVzcyhmaXhlZClcbiAgcmV0dXJuICFpc1ZhbGlkQWRkcmVzcyAmJiBpc1ZhbGlkSGV4KHN0cmluZylcbn1cblxuZnVuY3Rpb24gaXNWYWxpZEhleChkYXRhKSB7XG4gIGNvbnN0IGlzU3RyaW5nID0gdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnXG4gIGlmICghaXNTdHJpbmcpIHJldHVybiBmYWxzZVxuICBjb25zdCBpc0hleFByZWZpeGVkID0gZGF0YS5zbGljZSgwLDIpID09PSAnMHgnXG4gIGlmICghaXNIZXhQcmVmaXhlZCkgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IG5vblByZWZpeGVkID0gZGF0YS5zbGljZSgyKVxuICBjb25zdCBpc1ZhbGlkID0gbm9uUHJlZml4ZWQubWF0Y2goaGV4UmVnZXgpXG4gIHJldHVybiBpc1ZhbGlkXG59XG5cbmZ1bmN0aW9uIG11c3RQcm92aWRlSW5Db25zdHJ1Y3RvcihtZXRob2ROYW1lKSB7XG4gIHJldHVybiBmdW5jdGlvbihwYXJhbXMsIGNiKSB7XG4gICAgY2IobmV3IEVycm9yKCdQcm92aWRlckVuZ2luZSAtIEhvb2tlZFdhbGxldFN1YnByb3ZpZGVyIC0gTXVzdCBwcm92aWRlIFwiJyArIG1ldGhvZE5hbWUgKyAnXCIgZm4gaW4gY29uc3RydWN0b3Igb3B0aW9ucycpKVxuICB9XG59XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZSA9IHJlcXVpcmUoJ2V0aC1qc29uLXJwYy1taWRkbGV3YXJlL2luZmxpZ2h0LWNhY2hlJylcblxuY2xhc3MgSW5mbGlnaHRDYWNoZVN1YnByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMpIHtcbiAgICBzdXBlcigoKSA9PiBjcmVhdGVJbmZsaWdodENhY2hlTWlkZGxld2FyZShvcHRzKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZmxpZ2h0Q2FjaGVTdWJwcm92aWRlclxuIiwiY29uc3QgY3JlYXRlSW5mdXJhUHJvdmlkZXIgPSByZXF1aXJlKCdldGgtanNvbi1ycGMtaW5mdXJhL3NyYy9jcmVhdGVQcm92aWRlcicpXG5jb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9wcm92aWRlci5qcycpXG5cbmNsYXNzIEluZnVyYVN1YnByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXJTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gY3JlYXRlSW5mdXJhUHJvdmlkZXIob3B0cylcbiAgICBzdXBlcihwcm92aWRlcilcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEluZnVyYVN1YnByb3ZpZGVyXG4iLCJjb25zdCBTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXIuanMnKVxuXG4vLyB3cmFwcyBhIGpzb24tcnBjLWVuZ2luZSBtaWRkbGV3YXJlIGluIGEgc3VicHJvdmlkZXIgaW50ZXJmYWNlXG5cbmNsYXNzIEpzb25ScGNFbmdpbmVNaWRkbGV3YXJlU3VicHJvdmlkZXIgZXh0ZW5kcyBTdWJwcm92aWRlciB7XG5cbiAgLy8gdGFrZSBhIGNvbnN0cnVjdG9yRm4gdG8gY2FsbCBvbmNlIHdlIGhhdmUgYSByZWZlcmVuY2UgdG8gdGhlIGVuZ2luZVxuICBjb25zdHJ1Y3RvciAoY29uc3RydWN0b3JGbikge1xuICAgIHN1cGVyKClcbiAgICBpZiAoIWNvbnN0cnVjdG9yRm4pIHRocm93IG5ldyBFcnJvcignSnNvblJwY0VuZ2luZU1pZGRsZXdhcmVTdWJwcm92aWRlciAtIG5vIGNvbnN0cnVjdG9yRm4gc3BlY2lmaWVkJylcbiAgICB0aGlzLl9jb25zdHJ1Y3RvckZuID0gY29uc3RydWN0b3JGblxuICB9XG5cbiAgLy8gdGhpcyBpcyBjYWxsZWQgb25jZSB0aGUgc3VicHJvdmlkZXIgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHByb3ZpZGVyIGVuZ2luZVxuICBzZXRFbmdpbmUgKGVuZ2luZSkge1xuICAgIGlmICh0aGlzLm1pZGRsZXdhcmUpIHRocm93IG5ldyBFcnJvcignSnNvblJwY0VuZ2luZU1pZGRsZXdhcmVTdWJwcm92aWRlciAtIHN1YnByb3ZpZGVyIGFkZGVkIHRvIGVuZ2luZSB0d2ljZScpXG4gICAgY29uc3QgYmxvY2tUcmFja2VyID0gZW5naW5lLl9ibG9ja1RyYWNrZXJcbiAgICBjb25zdCBtaWRkbGV3YXJlID0gdGhpcy5fY29uc3RydWN0b3JGbih7IGVuZ2luZSwgcHJvdmlkZXI6IGVuZ2luZSwgYmxvY2tUcmFja2VyIH0pXG4gICAgaWYgKCFtaWRkbGV3YXJlKSB0aHJvdyBuZXcgRXJyb3IoJ0pzb25ScGNFbmdpbmVNaWRkbGV3YXJlU3VicHJvdmlkZXIgLSBfY29uc3RydWN0b3JGbiBkaWQgbm90IHJldHVybiBtaWRkbGV3YXJlJylcbiAgICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFcnJvcignSnNvblJwY0VuZ2luZU1pZGRsZXdhcmVTdWJwcm92aWRlciAtIHNwZWNpZmllZCBtaWRkbGV3YXJlIGlzIG5vdCBhIGZ1bmN0aW9uJylcbiAgICB0aGlzLm1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlXG4gIH1cblxuICBoYW5kbGVSZXF1ZXN0IChyZXEsIHByb3ZFbmdOZXh0LCBwcm92RW5nRW5kKSB7XG4gICAgY29uc3QgcmVzID0geyBpZDogcmVxLmlkIH1cbiAgICB0aGlzLm1pZGRsZXdhcmUocmVxLCByZXMsIG1pZGRsZXdhcmVOZXh0LCBtaWRkbGV3YXJlRW5kKVxuXG4gICAgZnVuY3Rpb24gbWlkZGxld2FyZU5leHQgKGhhbmRsZXIpIHtcbiAgICAgIHByb3ZFbmdOZXh0KChlcnIsIHJlc3VsdCwgY2IpID0+IHtcbiAgICAgICAgLy8gdXBkYXRlIHJlc3BvbnNlIG9iamVjdCB3aXRoIHJlc3VsdCBvciBlcnJvclxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgZGVsZXRlIHJlcy5yZXN1bHRcbiAgICAgICAgICByZXMuZXJyb3IgPSB7IG1lc3NhZ2U6IGVyci5tZXNzYWdlIHx8IGVyciB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzLnJlc3VsdCA9IHJlc3VsdFxuICAgICAgICB9XG4gICAgICAgIC8vIGNhbGwgbWlkZGxld2FyZSdzIG5leHQgaGFuZGxlciAoZXZlbiBpZiBlcnJvcilcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICBoYW5kbGVyKGNiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtaWRkbGV3YXJlRW5kIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBwcm92RW5nRW5kKGVycilcbiAgICAgIHByb3ZFbmdFbmQobnVsbCwgcmVzLnJlc3VsdClcbiAgICB9XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25ScGNFbmdpbmVNaWRkbGV3YXJlU3VicHJvdmlkZXJcbiIsImNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9ID0gcmVxdWlyZSgnQGV0aGVyZXVtanMvdHgnKVxuY29uc3QgZXRoVXRpbCA9IHJlcXVpcmUoJ2V0aGVyZXVtanMtdXRpbCcpXG5jb25zdCBTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXIuanMnKVxuY29uc3QgYmxvY2tUYWdGb3JQYXlsb2FkID0gcmVxdWlyZSgnLi4vdXRpbC9ycGMtY2FjaGUtdXRpbHMnKS5ibG9ja1RhZ0ZvclBheWxvYWRcblxubW9kdWxlLmV4cG9ydHMgPSBOb25jZVRyYWNrZXJTdWJwcm92aWRlclxuXG4vLyBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgUlBDIG1ldGhvZHM6XG4vLyAgIGV0aF9nZXRUcmFuc2FjdGlvbkNvdW50IChwZW5kaW5nIG9ubHkpXG4vL1xuLy8gb2JzZXJ2ZXMgdGhlIGZvbGxvd2luZyBSUEMgbWV0aG9kczpcbi8vICAgZXRoX3NlbmRSYXdUcmFuc2FjdGlvblxuLy8gICBldm1fcmV2ZXJ0ICh0byBjbGVhciB0aGUgbm9uY2UgY2FjaGUpXG5cbmluaGVyaXRzKE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyLCBTdWJwcm92aWRlcilcblxuZnVuY3Rpb24gTm9uY2VUcmFja2VyU3VicHJvdmlkZXIoKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcblxuICBzZWxmLm5vbmNlQ2FjaGUgPSB7fVxufVxuXG5Ob25jZVRyYWNrZXJTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uKHBheWxvYWQsIG5leHQsIGVuZCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG5cbiAgc3dpdGNoKHBheWxvYWQubWV0aG9kKSB7XG5cbiAgICBjYXNlICdldGhfZ2V0VHJhbnNhY3Rpb25Db3VudCc6XG4gICAgICB2YXIgYmxvY2tUYWcgPSBibG9ja1RhZ0ZvclBheWxvYWQocGF5bG9hZClcbiAgICAgIHZhciBhZGRyZXNzID0gcGF5bG9hZC5wYXJhbXNbMF0udG9Mb3dlckNhc2UoKVxuICAgICAgdmFyIGNhY2hlZFJlc3VsdCA9IHNlbGYubm9uY2VDYWNoZVthZGRyZXNzXVxuICAgICAgLy8gb25seSBoYW5kbGUgcmVxdWVzdHMgYWdhaW5zdCB0aGUgJ3BlbmRpbmcnIGJsb2NrVGFnXG4gICAgICBpZiAoYmxvY2tUYWcgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAvLyBoYXMgYSByZXN1bHRcbiAgICAgICAgaWYgKGNhY2hlZFJlc3VsdCkge1xuICAgICAgICAgIGVuZChudWxsLCBjYWNoZWRSZXN1bHQpXG4gICAgICAgIC8vIGZhbGx0aHJvdWdoIHRoZW4gcG9wdWxhdGUgY2FjaGVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0KGZ1bmN0aW9uKGVyciwgcmVzdWx0LCBjYil7XG4gICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY2IoKVxuICAgICAgICAgICAgaWYgKHNlbGYubm9uY2VDYWNoZVthZGRyZXNzXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHNlbGYubm9uY2VDYWNoZVthZGRyZXNzXSA9IHJlc3VsdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2IoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG5cbiAgICBjYXNlICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJzpcbiAgICAgIC8vIGFsbG93IHRoZSByZXF1ZXN0IHRvIGNvbnRpbnVlIG5vcm1hbGx5XG4gICAgICBuZXh0KGZ1bmN0aW9uKGVyciwgcmVzdWx0LCBjYil7XG4gICAgICAgIC8vIG9ubHkgdXBkYXRlIGxvY2FsIG5vbmNlIGlmIHR4IHdhcyBzdWJtaXR0ZWQgY29ycmVjdGx5XG4gICAgICAgIGlmIChlcnIpIHJldHVybiBjYigpXG4gICAgICAgIC8vIHBhcnNlIHJhdyB0eFxuICAgICAgICB2YXIgcmF3VHggPSBwYXlsb2FkLnBhcmFtc1swXVxuICAgICAgICB2YXIgcmF3RGF0YSA9IEJ1ZmZlci5mcm9tKGV0aFV0aWwuc3RyaXBIZXhQcmVmaXgocmF3VHgpLCAnaGV4JylcbiAgICAgICAgY29uc3QgdHggPSBUcmFuc2FjdGlvbkZhY3RvcnkuZnJvbVNlcmlhbGl6ZWREYXRhKHJhd0RhdGEpXG4gICAgICAgIC8vIGV4dHJhY3QgYWRkcmVzc1xuICAgICAgICB2YXIgYWRkcmVzcyA9IHR4LmdldFNlbmRlckFkZHJlc3MoKS50b1N0cmluZygnaGV4JykudG9Mb3dlckNhc2UoKVxuICAgICAgICAvLyBleHRyYWN0IG5vbmNlIGFuZCBpbmNyZW1lbnRcbiAgICAgICAgdmFyIG5vbmNlID0gZXRoVXRpbC5idWZmZXJUb0ludCh0eC5ub25jZSlcbiAgICAgICAgbm9uY2UrK1xuICAgICAgICAvLyBoZXhpZnkgYW5kIG5vcm1hbGl6ZVxuICAgICAgICB2YXIgaGV4Tm9uY2UgPSBub25jZS50b1N0cmluZygxNilcbiAgICAgICAgaWYgKGhleE5vbmNlLmxlbmd0aCUyKSBoZXhOb25jZSA9ICcwJytoZXhOb25jZVxuICAgICAgICBoZXhOb25jZSA9ICcweCcraGV4Tm9uY2VcbiAgICAgICAgLy8gZG9udCB1cGRhdGUgb3VyIHJlY29yZCBvbiB0aGUgbm9uY2UgdW50aWwgdGhlIHN1Ym1pdCB3YXMgc3VjY2Vzc2Z1bFxuICAgICAgICAvLyB1cGRhdGUgY2FjaGVcbiAgICAgICAgc2VsZi5ub25jZUNhY2hlW2FkZHJlc3NdID0gaGV4Tm9uY2VcbiAgICAgICAgY2IoKVxuICAgICAgfSlcbiAgICAgIHJldHVyblxuXG4gICAvLyBDbGVhciBjYWNoZSBvbiBhIHRlc3RycGMgcmV2ZXJ0XG4gICBjYXNlICdldm1fcmV2ZXJ0JzpcbiAgICAgIHNlbGYubm9uY2VDYWNoZSA9IHt9XG4gICAgICBuZXh0KClcbiAgICAgIHJldHVyblxuXG4gICAgZGVmYXVsdDpcbiAgICAgIG5leHQoKVxuICAgICAgcmV0dXJuXG5cbiAgfVxufVxuIiwiY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5cbi8vIHdyYXBzIGEgcHJvdmlkZXIgaW4gYSBzdWJwcm92aWRlciBpbnRlcmZhY2VcblxubW9kdWxlLmV4cG9ydHMgPSBQcm92aWRlclN1YnByb3ZpZGVyXG5cbmluaGVyaXRzKFByb3ZpZGVyU3VicHJvdmlkZXIsIFN1YnByb3ZpZGVyKVxuXG5mdW5jdGlvbiBQcm92aWRlclN1YnByb3ZpZGVyKHByb3ZpZGVyKXtcbiAgaWYgKCFwcm92aWRlcikgdGhyb3cgbmV3IEVycm9yKCdQcm92aWRlclN1YnByb3ZpZGVyIC0gbm8gcHJvdmlkZXIgc3BlY2lmaWVkJylcbiAgaWYgKCFwcm92aWRlci5zZW5kQXN5bmMpIHRocm93IG5ldyBFcnJvcignUHJvdmlkZXJTdWJwcm92aWRlciAtIHNwZWNpZmllZCBwcm92aWRlciBkb2VzIG5vdCBoYXZlIGEgc2VuZEFzeW5jIG1ldGhvZCcpXG4gIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlclxufVxuXG5Qcm92aWRlclN1YnByb3ZpZGVyLnByb3RvdHlwZS5oYW5kbGVSZXF1ZXN0ID0gZnVuY3Rpb24ocGF5bG9hZCwgbmV4dCwgZW5kKXtcbiAgdGhpcy5wcm92aWRlci5zZW5kQXN5bmMocGF5bG9hZCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIGlmIChlcnIpIHJldHVybiBlbmQoZXJyKVxuICAgIGlmIChyZXNwb25zZS5lcnJvcikgcmV0dXJuIGVuZChuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSkpXG4gICAgZW5kKG51bGwsIHJlc3BvbnNlLnJlc3VsdClcbiAgfSlcbn1cbiIsIi8qIFNhbml0aXphdGlvbiBTdWJwcm92aWRlclxuICogRm9yIFBhcml0eSBjb21wYXRpYmlsaXR5XG4gKiByZW1vdmVzIGlycmVndWxhciBrZXlzXG4gKi9cblxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCd1dGlsJykuaW5oZXJpdHNcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlci5qcycpXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCd4dGVuZCcpXG5jb25zdCBldGhVdGlsID0gcmVxdWlyZSgnZXRoZXJldW1qcy11dGlsJylcblxubW9kdWxlLmV4cG9ydHMgPSBTYW5pdGl6ZXJTdWJwcm92aWRlclxuXG5pbmhlcml0cyhTYW5pdGl6ZXJTdWJwcm92aWRlciwgU3VicHJvdmlkZXIpXG5cbmZ1bmN0aW9uIFNhbml0aXplclN1YnByb3ZpZGVyKG9wdHMpe1xuICBjb25zdCBzZWxmID0gdGhpc1xufVxuXG5TYW5pdGl6ZXJTdWJwcm92aWRlci5wcm90b3R5cGUuaGFuZGxlUmVxdWVzdCA9IGZ1bmN0aW9uKHBheWxvYWQsIG5leHQsIGVuZCl7XG4gIHZhciB0eFBhcmFtcyA9IHBheWxvYWQucGFyYW1zWzBdXG5cbiAgaWYgKHR5cGVvZiB0eFBhcmFtcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkodHhQYXJhbXMpKSB7XG4gICAgdmFyIHNhbml0aXplZCA9IGNsb25lVHhQYXJhbXModHhQYXJhbXMpXG4gICAgcGF5bG9hZC5wYXJhbXNbMF0gPSBzYW5pdGl6ZWRcbiAgfVxuXG4gIG5leHQoKVxufVxuXG4vLyB3ZSB1c2UgdGhpcyB0byBjbGVhbiBhbnkgY3VzdG9tIHBhcmFtcyBmcm9tIHRoZSB0eFBhcmFtc1xudmFyIHBlcm1pdHRlZCA9IFtcbiAgJ2Zyb20nLFxuICAndG8nLFxuICAndmFsdWUnLFxuICAnZGF0YScsXG4gICdnYXMnLFxuICAnZ2FzUHJpY2UnLFxuICAnbm9uY2UnLFxuICAnZnJvbUJsb2NrJyxcbiAgJ3RvQmxvY2snLFxuICAnYWRkcmVzcycsXG4gICd0b3BpY3MnLFxuXVxuXG5mdW5jdGlvbiBjbG9uZVR4UGFyYW1zKHR4UGFyYW1zKXtcbiAgdmFyIHNhbml0aXplZCAgPSAgcGVybWl0dGVkLnJlZHVjZShmdW5jdGlvbihjb3B5LCBwZXJtaXR0ZWQpIHtcbiAgICBpZiAocGVybWl0dGVkIGluIHR4UGFyYW1zKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0eFBhcmFtc1twZXJtaXR0ZWRdKSkge1xuICAgICAgICBjb3B5W3Blcm1pdHRlZF0gPSB0eFBhcmFtc1twZXJtaXR0ZWRdXG4gICAgICAgIC5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgIHJldHVybiBzYW5pdGl6ZShpdGVtKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29weVtwZXJtaXR0ZWRdID0gc2FuaXRpemUodHhQYXJhbXNbcGVybWl0dGVkXSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHlcbiAgfSwge30pXG5cbiAgcmV0dXJuIHNhbml0aXplZFxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZSh2YWx1ZSkge1xuICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgY2FzZSAnbGF0ZXN0JzpcbiAgICAgIHJldHVybiB2YWx1ZVxuICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgY2FzZSAnZWFybGllc3QnOlxuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBldGhVdGlsLmFkZEhleFByZWZpeCh2YWx1ZS50b0xvd2VyQ2FzZSgpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICB9XG4gIH1cbn1cbiIsImNvbnN0IGNyZWF0ZVBheWxvYWQgPSByZXF1aXJlKCcuLi91dGlsL2NyZWF0ZS1wYXlsb2FkLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBTdWJQcm92aWRlclxuXG4vLyB0aGlzIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhIHN1YnByb3ZpZGVyIC0tIG1vc3RseSBoZWxwZXJzXG5cblxuZnVuY3Rpb24gU3ViUHJvdmlkZXIoKSB7XG5cbn1cblxuU3ViUHJvdmlkZXIucHJvdG90eXBlLnNldEVuZ2luZSA9IGZ1bmN0aW9uKGVuZ2luZSkge1xuICBjb25zdCBzZWxmID0gdGhpc1xuICBpZiAoc2VsZi5lbmdpbmUpIHJldHVyblxuICBzZWxmLmVuZ2luZSA9IGVuZ2luZVxuICBlbmdpbmUub24oJ2Jsb2NrJywgZnVuY3Rpb24oYmxvY2spIHtcbiAgICBzZWxmLmN1cnJlbnRCbG9jayA9IGJsb2NrXG4gIH0pXG5cbiAgZW5naW5lLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLnN0YXJ0KClcbiAgfSlcblxuICBlbmdpbmUub24oJ3N0b3AnLCBmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5zdG9wKClcbiAgfSlcbn1cblxuU3ViUHJvdmlkZXIucHJvdG90eXBlLmhhbmRsZVJlcXVlc3QgPSBmdW5jdGlvbihwYXlsb2FkLCBuZXh0LCBlbmQpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdTdWJwcm92aWRlcnMgc2hvdWxkIG92ZXJyaWRlIGBoYW5kbGVSZXF1ZXN0YC4nKVxufVxuXG5TdWJQcm92aWRlci5wcm90b3R5cGUuZW1pdFBheWxvYWQgPSBmdW5jdGlvbihwYXlsb2FkLCBjYil7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuZW5naW5lLnNlbmRBc3luYyhjcmVhdGVQYXlsb2FkKHBheWxvYWQpLCBjYilcbn1cblxuLy8gZHVtbWllcyBmb3Igb3ZlcnJpZGluZ1xuXG5TdWJQcm92aWRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHt9XG5cblN1YlByb3ZpZGVyLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHt9XG4iLCJjb25zdCBQcm92aWRlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9qc29uLXJwYy1lbmdpbmUtbWlkZGxld2FyZScpXG5jb25zdCBjcmVhdGVTdWJzY3JpcHRpb25NYW5hZ2VyID0gcmVxdWlyZSgnZXRoLWpzb24tcnBjLWZpbHRlcnMvc3Vic2NyaXB0aW9uTWFuYWdlcicpXG5cbmNsYXNzIFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlciBleHRlbmRzIFByb3ZpZGVyU3VicHJvdmlkZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyLCBlbmdpbmUgfSkgPT4ge1xuICAgICAgY29uc3QgeyBldmVudHMsIG1pZGRsZXdhcmUgfSA9IGNyZWF0ZVN1YnNjcmlwdGlvbk1hbmFnZXIoeyBibG9ja1RyYWNrZXIsIHByb3ZpZGVyIH0pXG4gICAgICAvLyBmb3J3YXJkIHN1YnNjcmlwdGlvbiBldmVudHMgb24gdGhlIGVuZ2luZVxuICAgICAgZXZlbnRzLm9uKCdub3RpZmljYXRpb24nLCAoZGF0YSkgPT4gZW5naW5lLmVtaXQoJ2RhdGEnLCBudWxsLCBkYXRhKSlcbiAgICAgIC8vIHJldHVybiB0aGUgc3Vic2NyaXB0aW9uIGluc3RhbGwvcmVtb3ZlIG1pZGRsZXdhcmVcbiAgICAgIHJldHVybiBtaWRkbGV3YXJlXG4gICAgfSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN1YnNjcmlwdGlvbnNTdWJwcm92aWRlclxuIiwiY29uc3QgQmFja29mZiA9IHJlcXVpcmUoJ2JhY2tvZmYnKVxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzXG5jb25zdCBXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IHJlcXVpcmUoJ3dzJylcbmNvbnN0IFN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcicpXG5jb25zdCBjcmVhdGVQYXlsb2FkID0gcmVxdWlyZSgnLi4vdXRpbC9jcmVhdGUtcGF5bG9hZCcpXG5cbmNsYXNzIFdlYnNvY2tldFN1YnByb3ZpZGVyXG4gZXh0ZW5kcyBTdWJwcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHsgcnBjVXJsLCBkZWJ1Zywgb3JpZ2luIH0pIHtcbiAgICBzdXBlcigpXG5cbiAgICAvLyBpbmhlcml0IGZyb20gRXZlbnRFbWl0dGVyXG4gICAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcylcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRoaXMsIHtcbiAgICAgIF9iYWNrb2ZmOiB7XG4gICAgICAgIHZhbHVlOiBCYWNrb2ZmLmV4cG9uZW50aWFsKHtcbiAgICAgICAgICByYW5kb21pc2F0aW9uRmFjdG9yOiAwLjIsXG4gICAgICAgICAgbWF4RGVsYXk6IDUwMDBcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBfY29ubmVjdFRpbWU6IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgX2xvZzoge1xuICAgICAgICB2YWx1ZTogZGVidWdcbiAgICAgICAgICA/ICguLi5hcmdzKSA9PiBjb25zb2xlLmluZm8uYXBwbHkoY29uc29sZSwgWydbV1NQcm92aWRlcl0nLCAuLi5hcmdzXSlcbiAgICAgICAgICA6ICgpID0+IHsgfVxuICAgICAgfSxcbiAgICAgIF9vcmlnaW46IHtcbiAgICAgICAgdmFsdWU6IG9yaWdpblxuICAgICAgfSxcbiAgICAgIF9wZW5kaW5nUmVxdWVzdHM6IHtcbiAgICAgICAgdmFsdWU6IG5ldyBNYXAoKVxuICAgICAgfSxcbiAgICAgIF9zb2NrZXQ6IHtcbiAgICAgICAgdmFsdWU6IG51bGwsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9LFxuICAgICAgX3VuaGFuZGxlZFJlcXVlc3RzOiB7XG4gICAgICAgIHZhbHVlOiBbXVxuICAgICAgfSxcbiAgICAgIF91cmw6IHtcbiAgICAgICAgdmFsdWU6IHJwY1VybFxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9oYW5kbGVTb2NrZXRDbG9zZSA9IHRoaXMuX2hhbmRsZVNvY2tldENsb3NlLmJpbmQodGhpcylcbiAgICB0aGlzLl9oYW5kbGVTb2NrZXRNZXNzYWdlID0gdGhpcy5faGFuZGxlU29ja2V0TWVzc2FnZS5iaW5kKHRoaXMpXG4gICAgdGhpcy5faGFuZGxlU29ja2V0T3BlbiA9IHRoaXMuX2hhbmRsZVNvY2tldE9wZW4uYmluZCh0aGlzKVxuXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBiYWNrb2ZmIHRpbWVvdXQgaGFzIGZpbmlzaGVkLiBUaW1lIHRvIHRyeSByZWNvbm5lY3RpbmcuXG4gICAgdGhpcy5fYmFja29mZi5vbigncmVhZHknLCAoKSA9PiB7XG4gICAgICB0aGlzLl9vcGVuU29ja2V0KClcbiAgICB9KVxuXG4gICAgdGhpcy5fb3BlblNvY2tldCgpXG4gIH1cblxuICBoYW5kbGVSZXF1ZXN0KHBheWxvYWQsIG5leHQsIGVuZCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0IHx8IHRoaXMuX3NvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgdGhpcy5fdW5oYW5kbGVkUmVxdWVzdHMucHVzaChBcnJheS5mcm9tKGFyZ3VtZW50cykpXG4gICAgICB0aGlzLl9sb2coJ1NvY2tldCBub3Qgb3Blbi4gUmVxdWVzdCBxdWV1ZWQuJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zZXQocGF5bG9hZC5pZCwgW3BheWxvYWQsIGVuZF0pXG5cbiAgICBjb25zdCBuZXdQYXlsb2FkID0gY3JlYXRlUGF5bG9hZChwYXlsb2FkKVxuICAgIGRlbGV0ZSBuZXdQYXlsb2FkLm9yaWdpblxuXG4gICAgdGhpcy5fc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobmV3UGF5bG9hZCkpXG4gICAgdGhpcy5fbG9nKGBTZW50OiAke25ld1BheWxvYWQubWV0aG9kfSAjJHtuZXdQYXlsb2FkLmlkfWApXG4gIH1cblxuICBfaGFuZGxlU29ja2V0Q2xvc2UoeyByZWFzb24sIGNvZGUgfSkge1xuICAgIHRoaXMuX2xvZyhgU29ja2V0IGNsb3NlZCwgY29kZSAke2NvZGV9ICgke3JlYXNvbiB8fCAnbm8gcmVhc29uJ30pYClcbiAgICAvLyBJZiB0aGUgc29ja2V0IGhhcyBiZWVuIG9wZW4gZm9yIGxvbmdlciB0aGFuIDUgc2Vjb25kcywgcmVzZXQgdGhlIGJhY2tvZmZcbiAgICBpZiAodGhpcy5fY29ubmVjdFRpbWUgJiYgRGF0ZS5ub3coKSAtIHRoaXMuX2Nvbm5lY3RUaW1lID4gNTAwMCkge1xuICAgICAgdGhpcy5fYmFja29mZi5yZXNldCgpXG4gICAgfVxuXG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5faGFuZGxlU29ja2V0Q2xvc2UpXG4gICAgdGhpcy5fc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9oYW5kbGVTb2NrZXRNZXNzYWdlKVxuICAgIHRoaXMuX3NvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5faGFuZGxlU29ja2V0T3BlbilcblxuICAgIHRoaXMuX3NvY2tldCA9IG51bGxcbiAgICB0aGlzLl9iYWNrb2ZmLmJhY2tvZmYoKVxuICB9XG5cbiAgX2hhbmRsZVNvY2tldE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIGxldCBwYXlsb2FkXG5cbiAgICB0cnkge1xuICAgICAgcGF5bG9hZCA9IEpTT04ucGFyc2UobWVzc2FnZS5kYXRhKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuX2xvZygnUmVjZWl2ZWQgYSBtZXNzYWdlIHRoYXQgaXMgbm90IHZhbGlkIEpTT046JywgcGF5bG9hZClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGNoZWNrIGlmIHNlcnZlci1zZW50IG5vdGlmaWNhdGlvblxuICAgIGlmIChwYXlsb2FkLmlkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmVuZ2luZS5lbWl0KCdkYXRhJywgbnVsbCwgcGF5bG9hZClcbiAgICB9XG5cbiAgICAvLyBpZ25vcmUgaWYgbWlzc2luZ1xuICAgIGlmICghdGhpcy5fcGVuZGluZ1JlcXVlc3RzLmhhcyhwYXlsb2FkLmlkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV0cmlldmUgcGF5bG9hZCArIGFyZ3VtZW50c1xuICAgIGNvbnN0IFtvcmlnaW5hbFJlcSwgZW5kXSA9IHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5nZXQocGF5bG9hZC5pZClcbiAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKHBheWxvYWQuaWQpXG5cbiAgICB0aGlzLl9sb2coYFJlY2VpdmVkOiAke29yaWdpbmFsUmVxLm1ldGhvZH0gIyR7cGF5bG9hZC5pZH1gKVxuXG4gICAgLy8gZm9yd2FyZCByZXNwb25zZVxuICAgIGlmIChwYXlsb2FkLmVycm9yKSB7XG4gICAgICByZXR1cm4gZW5kKG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpKVxuICAgIH1cbiAgICBlbmQobnVsbCwgcGF5bG9hZC5yZXN1bHQpXG4gIH1cblxuICBfaGFuZGxlU29ja2V0T3BlbigpIHtcbiAgICB0aGlzLl9sb2coJ1NvY2tldCBvcGVuLicpXG4gICAgdGhpcy5fY29ubmVjdFRpbWUgPSBEYXRlLm5vdygpXG5cbiAgICAvLyBBbnkgcGVuZGluZyByZXF1ZXN0cyBuZWVkIHRvIGJlIHJlc2VudCBiZWNhdXNlIG91ciBzZXNzaW9uIHdhcyBsb3N0XG4gICAgLy8gYW5kIHdpbGwgbm90IGdldCByZXNwb25zZXMgZm9yIHRoZW0gaW4gb3VyIG5ldyBzZXNzaW9uLlxuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5mb3JFYWNoKChbcGF5bG9hZCwgZW5kXSkgPT4ge1xuICAgICAgdGhpcy5fdW5oYW5kbGVkUmVxdWVzdHMucHVzaChbcGF5bG9hZCwgbnVsbCwgZW5kXSlcbiAgICB9KVxuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5jbGVhcigpXG5cbiAgICBjb25zdCB1bmhhbmRsZWRSZXF1ZXN0cyA9IHRoaXMuX3VuaGFuZGxlZFJlcXVlc3RzLnNwbGljZSgwLCB0aGlzLl91bmhhbmRsZWRSZXF1ZXN0cy5sZW5ndGgpXG4gICAgdW5oYW5kbGVkUmVxdWVzdHMuZm9yRWFjaChyZXF1ZXN0ID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlUmVxdWVzdC5hcHBseSh0aGlzLCByZXF1ZXN0KVxuICAgIH0pXG4gIH1cblxuICBfb3BlblNvY2tldCgpIHtcbiAgICB0aGlzLl9sb2coJ09wZW5pbmcgc29ja2V0Li4uJylcbiAgICB0aGlzLl9zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHRoaXMuX3VybCwgW10sIHRoaXMuX29yaWdpbiA/IHtoZWFkZXJzOntvcmlnaW46IHRoaXMuX29yaWdpbn19IDoge30pXG4gICAgdGhpcy5fc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgdGhpcy5faGFuZGxlU29ja2V0Q2xvc2UpXG4gICAgdGhpcy5fc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLl9oYW5kbGVTb2NrZXRNZXNzYWdlKVxuICAgIHRoaXMuX3NvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgdGhpcy5faGFuZGxlU29ja2V0T3BlbilcbiAgfVxufVxuXG4vLyBtdWx0aXBsZSBpbmhlcml0YW5jZVxuT2JqZWN0LmFzc2lnbihXZWJzb2NrZXRTdWJwcm92aWRlci5wcm90b3R5cGUsIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpXG5cbm1vZHVsZS5leHBvcnRzID0gV2Vic29ja2V0U3VicHJvdmlkZXJcbiIsImNvbnN0IGdldFJhbmRvbUlkID0gcmVxdWlyZSgnLi9yYW5kb20taWQuanMnKVxuY29uc3QgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVBheWxvYWRcblxuXG5mdW5jdGlvbiBjcmVhdGVQYXlsb2FkKGRhdGEpe1xuICByZXR1cm4gZXh0ZW5kKHtcbiAgICAvLyBkZWZhdWx0c1xuICAgIGlkOiBnZXRSYW5kb21JZCgpLFxuICAgIGpzb25ycGM6ICcyLjAnLFxuICAgIHBhcmFtczogW10sXG4gICAgLy8gdXNlci1zcGVjaWZpZWRcbiAgfSwgZGF0YSlcbn1cbiIsImNvbnN0IGNyZWF0ZVBheWxvYWQgPSByZXF1aXJlKCcuL2NyZWF0ZS1wYXlsb2FkLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSBlc3RpbWF0ZUdhc1xuXG4vKlxuXG5UaGlzIGlzIGEgd29yayBhcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9pc3N1ZXMvMjU3N1xuXG4qL1xuXG5cbmZ1bmN0aW9uIGVzdGltYXRlR2FzKHByb3ZpZGVyLCB0eFBhcmFtcywgY2IpIHtcbiAgcHJvdmlkZXIuc2VuZEFzeW5jKGNyZWF0ZVBheWxvYWQoe1xuICAgIG1ldGhvZDogJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICAgcGFyYW1zOiBbdHhQYXJhbXNdXG4gIH0pLCBmdW5jdGlvbihlcnIsIHJlcyl7XG4gICAgaWYgKGVycikge1xuICAgICAgLy8gaGFuZGxlIHNpbXBsZSB2YWx1ZSB0cmFuc2ZlciBjYXNlXG4gICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09ICdubyBjb250cmFjdCBjb2RlIGF0IGdpdmVuIGFkZHJlc3MnKSB7XG4gICAgICAgIHJldHVybiBjYihudWxsLCAnMHhjZjA4JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjYihlcnIpICAgICAgICBcbiAgICAgIH1cbiAgICB9XG4gICAgY2IobnVsbCwgcmVzLnJlc3VsdClcbiAgfSlcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJhbmRvbUlkXG5cblxuZnVuY3Rpb24gY3JlYXRlUmFuZG9tSWQgKCkge1xuICAvLyByYW5kb20gaWRcbiAgcmV0dXJuIE1hdGguZmxvb3IoTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgKiBNYXRoLnJhbmRvbSgpKVxufSIsImNvbnN0IHN0cmluZ2lmeSA9IHJlcXVpcmUoJ2pzb24tc3RhYmxlLXN0cmluZ2lmeScpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkOiBjYWNoZUlkZW50aWZpZXJGb3JQYXlsb2FkLFxuICBjYW5DYWNoZTogY2FuQ2FjaGUsXG4gIGJsb2NrVGFnRm9yUGF5bG9hZDogYmxvY2tUYWdGb3JQYXlsb2FkLFxuICBwYXJhbXNXaXRob3V0QmxvY2tUYWc6IHBhcmFtc1dpdGhvdXRCbG9ja1RhZyxcbiAgYmxvY2tUYWdQYXJhbUluZGV4OiBibG9ja1RhZ1BhcmFtSW5kZXgsXG4gIGNhY2hlVHlwZUZvclBheWxvYWQ6IGNhY2hlVHlwZUZvclBheWxvYWQsXG59XG5cbmZ1bmN0aW9uIGNhY2hlSWRlbnRpZmllckZvclBheWxvYWQocGF5bG9hZCwgb3B0cyA9IHt9KXtcbiAgaWYgKCFjYW5DYWNoZShwYXlsb2FkKSkgcmV0dXJuIG51bGxcbiAgY29uc3QgeyBpbmNsdWRlQmxvY2tSZWYgfSA9IG9wdHNcbiAgY29uc3QgcGFyYW1zID0gaW5jbHVkZUJsb2NrUmVmID8gcGF5bG9hZC5wYXJhbXMgOiBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZClcbiAgcmV0dXJuIHBheWxvYWQubWV0aG9kICsgJzonICsgc3RyaW5naWZ5KHBhcmFtcylcbn1cblxuZnVuY3Rpb24gY2FuQ2FjaGUocGF5bG9hZCl7XG4gIHJldHVybiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpICE9PSAnbmV2ZXInXG59XG5cbmZ1bmN0aW9uIGJsb2NrVGFnRm9yUGF5bG9hZChwYXlsb2FkKXtcbiAgdmFyIGluZGV4ID0gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpO1xuXG4gIC8vIEJsb2NrIHRhZyBwYXJhbSBub3QgcGFzc2VkLlxuICBpZiAoaW5kZXggPj0gcGF5bG9hZC5wYXJhbXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gcGF5bG9hZC5wYXJhbXNbaW5kZXhdO1xufVxuXG5mdW5jdGlvbiBwYXJhbXNXaXRob3V0QmxvY2tUYWcocGF5bG9hZCl7XG4gIHZhciBpbmRleCA9IGJsb2NrVGFnUGFyYW1JbmRleChwYXlsb2FkKTtcblxuICAvLyBCbG9jayB0YWcgcGFyYW0gbm90IHBhc3NlZC5cbiAgaWYgKGluZGV4ID49IHBheWxvYWQucGFyYW1zLmxlbmd0aCkge1xuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcztcbiAgfVxuXG4gIC8vIGV0aF9nZXRCbG9ja0J5TnVtYmVyIGhhcyB0aGUgYmxvY2sgdGFnIGZpcnN0LCB0aGVuIHRoZSBvcHRpb25hbCBpbmNsdWRlVHg/IHBhcmFtXG4gIGlmIChwYXlsb2FkLm1ldGhvZCA9PT0gJ2V0aF9nZXRCbG9ja0J5TnVtYmVyJykge1xuICAgIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgxKTtcbiAgfVxuXG4gIHJldHVybiBwYXlsb2FkLnBhcmFtcy5zbGljZSgwLGluZGV4KTtcbn1cblxuZnVuY3Rpb24gYmxvY2tUYWdQYXJhbUluZGV4KHBheWxvYWQpe1xuICBzd2l0Y2gocGF5bG9hZC5tZXRob2QpIHtcbiAgICAvLyBibG9ja1RhZyBpcyB0aGlyZCBwYXJhbVxuICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgICAgcmV0dXJuIDJcbiAgICAvLyBibG9ja1RhZyBpcyBzZWNvbmQgcGFyYW1cbiAgICBjYXNlICdldGhfZ2V0QmFsYW5jZSc6XG4gICAgY2FzZSAnZXRoX2dldENvZGUnOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgY2FzZSAnZXRoX2VzdGltYXRlR2FzJzpcbiAgICAgIHJldHVybiAxXG4gICAgLy8gYmxvY2tUYWcgaXMgZmlyc3QgcGFyYW1cbiAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgICByZXR1cm4gMFxuICAgIC8vIHRoZXJlIGlzIG5vIGJsb2NrVGFnXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWNoZVR5cGVGb3JQYXlsb2FkKHBheWxvYWQpIHtcbiAgc3dpdGNoIChwYXlsb2FkLm1ldGhvZCkge1xuICAgIC8vIGNhY2hlIHBlcm1hbmVudGx5XG4gICAgY2FzZSAnd2ViM19jbGllbnRWZXJzaW9uJzpcbiAgICBjYXNlICd3ZWIzX3NoYTMnOlxuICAgIGNhc2UgJ2V0aF9wcm90b2NvbFZlcnNpb24nOlxuICAgIGNhc2UgJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnOlxuICAgIGNhc2UgJ2V0aF9nZXRVbmNsZUNvdW50QnlCbG9ja0hhc2gnOlxuICAgIGNhc2UgJ2V0aF9nZXRDb2RlJzpcbiAgICBjYXNlICdldGhfZ2V0QmxvY2tCeUhhc2gnOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCc6XG4gICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgY2FzZSAnZXRoX2dldFRyYW5zYWN0aW9uUmVjZWlwdCc6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja0hhc2hBbmRJbmRleCc6XG4gICAgY2FzZSAnZXRoX2dldENvbXBpbGVycyc6XG4gICAgY2FzZSAnZXRoX2NvbXBpbGVMTEwnOlxuICAgIGNhc2UgJ2V0aF9jb21waWxlU29saWRpdHknOlxuICAgIGNhc2UgJ2V0aF9jb21waWxlU2VycGVudCc6XG4gICAgY2FzZSAnc2hoX3ZlcnNpb24nOlxuICAgICAgcmV0dXJuICdwZXJtYSdcblxuICAgIC8vIGNhY2hlIHVudGlsIGZvcmtcbiAgICBjYXNlICdldGhfZ2V0QmxvY2tCeU51bWJlcic6XG4gICAgY2FzZSAnZXRoX2dldEJsb2NrVHJhbnNhY3Rpb25Db3VudEJ5TnVtYmVyJzpcbiAgICBjYXNlICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5QmxvY2tOdW1iZXJBbmRJbmRleCc6XG4gICAgY2FzZSAnZXRoX2dldFVuY2xlQnlCbG9ja051bWJlckFuZEluZGV4JzpcbiAgICAgIHJldHVybiAnZm9yaydcblxuICAgIC8vIGNhY2hlIGZvciBibG9ja1xuICAgIGNhc2UgJ2V0aF9nYXNQcmljZSc6XG4gICAgY2FzZSAnZXRoX2dldEJhbGFuY2UnOlxuICAgIGNhc2UgJ2V0aF9nZXRTdG9yYWdlQXQnOlxuICAgIGNhc2UgJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JzpcbiAgICBjYXNlICdldGhfY2FsbCc6XG4gICAgY2FzZSAnZXRoX2VzdGltYXRlR2FzJzpcbiAgICBjYXNlICdldGhfZ2V0RmlsdGVyTG9ncyc6XG4gICAgY2FzZSAnZXRoX2dldExvZ3MnOlxuICAgIGNhc2UgJ2V0aF9ibG9ja051bWJlcic6XG4gICAgICByZXR1cm4gJ2Jsb2NrJ1xuXG4gICAgLy8gbmV2ZXIgY2FjaGVcbiAgICBjYXNlICduZXRfdmVyc2lvbic6XG4gICAgY2FzZSAnbmV0X3BlZXJDb3VudCc6XG4gICAgY2FzZSAnbmV0X2xpc3RlbmluZyc6XG4gICAgY2FzZSAnZXRoX3N5bmNpbmcnOlxuICAgIGNhc2UgJ2V0aF9zaWduJzpcbiAgICBjYXNlICdldGhfY29pbmJhc2UnOlxuICAgIGNhc2UgJ2V0aF9taW5pbmcnOlxuICAgIGNhc2UgJ2V0aF9oYXNocmF0ZSc6XG4gICAgY2FzZSAnZXRoX2FjY291bnRzJzpcbiAgICBjYXNlICdldGhfc2VuZFRyYW5zYWN0aW9uJzpcbiAgICBjYXNlICdldGhfc2VuZFJhd1RyYW5zYWN0aW9uJzpcbiAgICBjYXNlICdldGhfbmV3RmlsdGVyJzpcbiAgICBjYXNlICdldGhfbmV3QmxvY2tGaWx0ZXInOlxuICAgIGNhc2UgJ2V0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXInOlxuICAgIGNhc2UgJ2V0aF91bmluc3RhbGxGaWx0ZXInOlxuICAgIGNhc2UgJ2V0aF9nZXRGaWx0ZXJDaGFuZ2VzJzpcbiAgICBjYXNlICdldGhfZ2V0V29yayc6XG4gICAgY2FzZSAnZXRoX3N1Ym1pdFdvcmsnOlxuICAgIGNhc2UgJ2V0aF9zdWJtaXRIYXNocmF0ZSc6XG4gICAgY2FzZSAnZGJfcHV0U3RyaW5nJzpcbiAgICBjYXNlICdkYl9nZXRTdHJpbmcnOlxuICAgIGNhc2UgJ2RiX3B1dEhleCc6XG4gICAgY2FzZSAnZGJfZ2V0SGV4JzpcbiAgICBjYXNlICdzaGhfcG9zdCc6XG4gICAgY2FzZSAnc2hoX25ld0lkZW50aXR5JzpcbiAgICBjYXNlICdzaGhfaGFzSWRlbnRpdHknOlxuICAgIGNhc2UgJ3NoaF9uZXdHcm91cCc6XG4gICAgY2FzZSAnc2hoX2FkZFRvR3JvdXAnOlxuICAgIGNhc2UgJ3NoaF9uZXdGaWx0ZXInOlxuICAgIGNhc2UgJ3NoaF91bmluc3RhbGxGaWx0ZXInOlxuICAgIGNhc2UgJ3NoaF9nZXRGaWx0ZXJDaGFuZ2VzJzpcbiAgICBjYXNlICdzaGhfZ2V0TWVzc2FnZXMnOlxuICAgICAgcmV0dXJuICduZXZlcidcbiAgfVxufVxuIiwiY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3BsaWdodFxuXG5cbmluaGVyaXRzKFN0b3BsaWdodCwgRXZlbnRFbWl0dGVyKVxuXG5mdW5jdGlvbiBTdG9wbGlnaHQoKXtcbiAgY29uc3Qgc2VsZiA9IHRoaXNcbiAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZilcbiAgc2VsZi5pc0xvY2tlZCA9IHRydWVcbn1cblxuU3RvcGxpZ2h0LnByb3RvdHlwZS5nbyA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuaXNMb2NrZWQgPSBmYWxzZVxuICBzZWxmLmVtaXQoJ3VubG9jaycpXG59XG5cblN0b3BsaWdodC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCl7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIHNlbGYuaXNMb2NrZWQgPSB0cnVlXG4gIHNlbGYuZW1pdCgnbG9jaycpXG59XG5cblN0b3BsaWdodC5wcm90b3R5cGUuYXdhaXQgPSBmdW5jdGlvbihmbil7XG4gIGNvbnN0IHNlbGYgPSB0aGlzXG4gIGlmIChzZWxmLmlzTG9ja2VkKSB7XG4gICAgc2VsZi5vbmNlKCd1bmxvY2snLCBmbilcbiAgfSBlbHNlIHtcbiAgICBzZXRUaW1lb3V0KGZuKVxuICB9XG59IiwiY29uc3QgUHJvdmlkZXJFbmdpbmUgPSByZXF1aXJlKCcuL2luZGV4LmpzJylcbmNvbnN0IERlZmF1bHRGaXh0dXJlID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvZGVmYXVsdC1maXh0dXJlLmpzJylcbmNvbnN0IE5vbmNlVHJhY2tlclN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvbm9uY2UtdHJhY2tlci5qcycpXG5jb25zdCBDYWNoZVN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvY2FjaGUuanMnKVxuY29uc3QgRmlsdGVyU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL3N1YnByb3ZpZGVycy9maWx0ZXJzJylcbmNvbnN0IFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvc3Vic2NyaXB0aW9ucycpXG5jb25zdCBJbmZsaWdodENhY2hlU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL3N1YnByb3ZpZGVycy9pbmZsaWdodC1jYWNoZScpXG5jb25zdCBIb29rZWRXYWxsZXRTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXJzL2hvb2tlZC13YWxsZXQuanMnKVxuY29uc3QgU2FuaXRpemluZ1N1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvc2FuaXRpemVyLmpzJylcbmNvbnN0IEluZnVyYVN1YnByb3ZpZGVyID0gcmVxdWlyZSgnLi9zdWJwcm92aWRlcnMvaW5mdXJhLmpzJylcbmNvbnN0IEZldGNoU3VicHJvdmlkZXIgPSByZXF1aXJlKCcuL3N1YnByb3ZpZGVycy9mZXRjaC5qcycpXG5jb25zdCBXZWJTb2NrZXRTdWJwcm92aWRlciA9IHJlcXVpcmUoJy4vc3VicHJvdmlkZXJzL3dlYnNvY2tldC5qcycpXG5cblxubW9kdWxlLmV4cG9ydHMgPSBaZXJvQ2xpZW50UHJvdmlkZXJcblxuXG5mdW5jdGlvbiBaZXJvQ2xpZW50UHJvdmlkZXIob3B0cyA9IHt9KXtcbiAgY29uc3QgY29ubmVjdGlvblR5cGUgPSBnZXRDb25uZWN0aW9uVHlwZShvcHRzKVxuXG4gIGNvbnN0IGVuZ2luZSA9IG5ldyBQcm92aWRlckVuZ2luZShvcHRzLmVuZ2luZVBhcmFtcylcblxuICAvLyBzdGF0aWNcbiAgY29uc3Qgc3RhdGljU3VicHJvdmlkZXIgPSBuZXcgRGVmYXVsdEZpeHR1cmUob3B0cy5zdGF0aWMpXG4gIGVuZ2luZS5hZGRQcm92aWRlcihzdGF0aWNTdWJwcm92aWRlcilcblxuICAvLyBub25jZSB0cmFja2VyXG4gIGVuZ2luZS5hZGRQcm92aWRlcihuZXcgTm9uY2VUcmFja2VyU3VicHJvdmlkZXIoKSlcblxuICAvLyBzYW5pdGl6YXRpb25cbiAgY29uc3Qgc2FuaXRpemVyID0gbmV3IFNhbml0aXppbmdTdWJwcm92aWRlcigpXG4gIGVuZ2luZS5hZGRQcm92aWRlcihzYW5pdGl6ZXIpXG5cbiAgLy8gY2FjaGUgbGF5ZXJcbiAgY29uc3QgY2FjaGVTdWJwcm92aWRlciA9IG5ldyBDYWNoZVN1YnByb3ZpZGVyKClcbiAgZW5naW5lLmFkZFByb3ZpZGVyKGNhY2hlU3VicHJvdmlkZXIpXG5cbiAgLy8gZmlsdGVycyArIHN1YnNjcmlwdGlvbnNcbiAgLy8gb25seSBwb2x5ZmlsbCBpZiBub3Qgd2Vic29ja2V0c1xuICBpZiAoY29ubmVjdGlvblR5cGUgIT09ICd3cycpIHtcbiAgICBlbmdpbmUuYWRkUHJvdmlkZXIobmV3IFN1YnNjcmlwdGlvblN1YnByb3ZpZGVyKCkpXG4gICAgZW5naW5lLmFkZFByb3ZpZGVyKG5ldyBGaWx0ZXJTdWJwcm92aWRlcigpKVxuICB9XG5cbiAgLy8gaW5mbGlnaHQgY2FjaGVcbiAgY29uc3QgaW5mbGlnaHRDYWNoZSA9IG5ldyBJbmZsaWdodENhY2hlU3VicHJvdmlkZXIoKVxuICBlbmdpbmUuYWRkUHJvdmlkZXIoaW5mbGlnaHRDYWNoZSlcblxuICAvLyBpZCBtZ210XG4gIGNvbnN0IGlkbWdtdFN1YnByb3ZpZGVyID0gbmV3IEhvb2tlZFdhbGxldFN1YnByb3ZpZGVyKHtcbiAgICAvLyBhY2NvdW50c1xuICAgIGdldEFjY291bnRzOiBvcHRzLmdldEFjY291bnRzLFxuICAgIC8vIHRyYW5zYWN0aW9uc1xuICAgIHByb2Nlc3NUcmFuc2FjdGlvbjogb3B0cy5wcm9jZXNzVHJhbnNhY3Rpb24sXG4gICAgYXBwcm92ZVRyYW5zYWN0aW9uOiBvcHRzLmFwcHJvdmVUcmFuc2FjdGlvbixcbiAgICBzaWduVHJhbnNhY3Rpb246IG9wdHMuc2lnblRyYW5zYWN0aW9uLFxuICAgIHB1Ymxpc2hUcmFuc2FjdGlvbjogb3B0cy5wdWJsaXNoVHJhbnNhY3Rpb24sXG4gICAgLy8gbWVzc2FnZXNcbiAgICAvLyBvbGQgZXRoX3NpZ25cbiAgICBwcm9jZXNzTWVzc2FnZTogb3B0cy5wcm9jZXNzTWVzc2FnZSxcbiAgICBhcHByb3ZlTWVzc2FnZTogb3B0cy5hcHByb3ZlTWVzc2FnZSxcbiAgICBzaWduTWVzc2FnZTogb3B0cy5zaWduTWVzc2FnZSxcbiAgICAvLyBuZXcgcGVyc29uYWxfc2lnblxuICAgIHByb2Nlc3NQZXJzb25hbE1lc3NhZ2U6IG9wdHMucHJvY2Vzc1BlcnNvbmFsTWVzc2FnZSxcbiAgICBwcm9jZXNzVHlwZWRNZXNzYWdlOiBvcHRzLnByb2Nlc3NUeXBlZE1lc3NhZ2UsXG4gICAgYXBwcm92ZVBlcnNvbmFsTWVzc2FnZTogb3B0cy5hcHByb3ZlUGVyc29uYWxNZXNzYWdlLFxuICAgIGFwcHJvdmVUeXBlZE1lc3NhZ2U6IG9wdHMuYXBwcm92ZVR5cGVkTWVzc2FnZSxcbiAgICBzaWduUGVyc29uYWxNZXNzYWdlOiBvcHRzLnNpZ25QZXJzb25hbE1lc3NhZ2UsXG4gICAgc2lnblR5cGVkTWVzc2FnZTogb3B0cy5zaWduVHlwZWRNZXNzYWdlLFxuICAgIHBlcnNvbmFsUmVjb3ZlclNpZ25lcjogb3B0cy5wZXJzb25hbFJlY292ZXJTaWduZXIsXG4gIH0pXG4gIGVuZ2luZS5hZGRQcm92aWRlcihpZG1nbXRTdWJwcm92aWRlcilcblxuICAvLyBkYXRhIHNvdXJjZVxuICBjb25zdCBkYXRhU3VicHJvdmlkZXIgPSBvcHRzLmRhdGFTdWJwcm92aWRlciB8fCBjcmVhdGVEYXRhU3VicHJvdmlkZXIoY29ubmVjdGlvblR5cGUsIG9wdHMpXG4gIGVuZ2luZS5hZGRQcm92aWRlcihkYXRhU3VicHJvdmlkZXIpXG5cbiAgLy8gc3RhcnQgcG9sbGluZ1xuICBpZiAoIW9wdHMuc3RvcHBlZCkge1xuICAgIGVuZ2luZS5zdGFydCgpXG4gIH1cblxuICByZXR1cm4gZW5naW5lXG5cbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0YVN1YnByb3ZpZGVyKGNvbm5lY3Rpb25UeXBlLCBvcHRzKSB7XG4gIGNvbnN0IHsgcnBjVXJsLCBkZWJ1ZyB9ID0gb3B0c1xuXG4gIC8vIGRlZmF1bHQgdG8gaW5mdXJhXG4gIGlmICghY29ubmVjdGlvblR5cGUpIHtcbiAgICByZXR1cm4gbmV3IEluZnVyYVN1YnByb3ZpZGVyKClcbiAgfVxuICBpZiAoY29ubmVjdGlvblR5cGUgPT09ICdodHRwJykge1xuICAgIHJldHVybiBuZXcgRmV0Y2hTdWJwcm92aWRlcih7IHJwY1VybCwgZGVidWcgfSlcbiAgfVxuICBpZiAoY29ubmVjdGlvblR5cGUgPT09ICd3cycpIHtcbiAgICByZXR1cm4gbmV3IFdlYlNvY2tldFN1YnByb3ZpZGVyKHsgcnBjVXJsLCBkZWJ1ZyB9KVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBQcm92aWRlckVuZ2luZSAtIHVucmVjb2duaXplZCBjb25uZWN0aW9uVHlwZSBcIiR7Y29ubmVjdGlvblR5cGV9XCJgKVxufVxuXG5mdW5jdGlvbiBnZXRDb25uZWN0aW9uVHlwZSh7IHJwY1VybCB9KSB7XG4gIGlmICghcnBjVXJsKSByZXR1cm4gdW5kZWZpbmVkXG5cbiAgY29uc3QgcHJvdG9jb2wgPSBycGNVcmwuc3BsaXQoJzonKVswXS50b0xvd2VyQ2FzZSgpXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICdodHRwcyc6XG4gICAgICByZXR1cm4gJ2h0dHAnXG4gICAgY2FzZSAnd3MnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgICByZXR1cm4gJ3dzJ1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb3ZpZGVyRW5naW5lIC0gdW5yZWNvZ25pemVkIHByb3RvY29sIGluIFwiJHtycGNVcmx9XCJgKVxuICB9XG59XG4iLCJ2YXIgV2ViMyA9IHJlcXVpcmUoJy4vbGliL3dlYjMnKTtcblxuLy8gZG9udCBvdmVycmlkZSBnbG9iYWwgdmFyaWFibGVcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LldlYjMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgd2luZG93LldlYjMgPSBXZWIzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYjM7XG4iLCJtb2R1bGUuZXhwb3J0cz1bXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IHRydWUsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfb3duZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJuYW1lXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwib19uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiY29udGVudFwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogdHJ1ZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiYWRkclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcInJlc2VydmVcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJzdWJSZWdpc3RyYXJcIixcbiAgICBcIm91dHB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmV3T3duZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJ0cmFuc2ZlclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfcmVnaXN0cmFyXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwic2V0U3ViUmVnaXN0cmFyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW10sXG4gICAgXCJuYW1lXCI6IFwiUmVnaXN0cmFyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9hXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX3ByaW1hcnlcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYm9vbFwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJzZXRBZGRyZXNzXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9jb250ZW50XCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwic2V0Q29udGVudFwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJkaXNvd25cIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogZmFsc2UsXG4gICAgICAgIFwibmFtZVwiOiBcIl93aW5uZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJBdWN0aW9uRW5kZWRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiX2JpZGRlclwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiX3ZhbHVlXCIsXG4gICAgICAgIFwidHlwZVwiOiBcInVpbnQyNTZcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiTmV3QmlkXCIsXG4gICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwibmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkNoYW5nZWRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJuYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgIFwibmFtZVwiOiBcImFkZHJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJQcmltYXJ5Q2hhbmdlZFwiLFxuICAgIFwidHlwZVwiOiBcImV2ZW50XCJcbiAgfVxuXVxuIiwibW9kdWxlLmV4cG9ydHM9W1xuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJvd25lclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIlwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9yZWZ1bmRcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJkaXNvd25cIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiB0cnVlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJhZGRyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcIl9uYW1lXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwicmVzZXJ2ZVwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfbmV3T3duZXJcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJ0cmFuc2ZlclwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImNvbnN0YW50XCI6IGZhbHNlLFxuICAgIFwiaW5wdXRzXCI6IFtcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwiX25hbWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYnl0ZXMzMlwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJfYVwiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcInNldEFkZHJcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwibmFtZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkNoYW5nZWRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH1cbl1cbiIsIm1vZHVsZS5leHBvcnRzPVtcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcInRyYW5zZmVyXCIsXG4gICAgXCJvdXRwdXRzXCI6IFtdLFxuICAgIFwidHlwZVwiOiBcImZ1bmN0aW9uXCJcbiAgfSxcbiAge1xuICAgIFwiY29uc3RhbnRcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidG9cIixcbiAgICAgICAgXCJ0eXBlXCI6IFwiYWRkcmVzc1wiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBcIm5hbWVcIjogXCJpbmRpcmVjdElkXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJuYW1lXCI6IFwidmFsdWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJpY2FwVHJhbnNmZXJcIixcbiAgICBcIm91dHB1dHNcIjogW10sXG4gICAgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIlxuICB9LFxuICB7XG4gICAgXCJjb25zdGFudFwiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwibmFtZVwiOiBcInRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfVxuICAgIF0sXG4gICAgXCJuYW1lXCI6IFwiZGVwb3NpdFwiLFxuICAgIFwib3V0cHV0c1wiOiBbXSxcbiAgICBcInBheWFibGVcIjogdHJ1ZSxcbiAgICBcInR5cGVcIjogXCJmdW5jdGlvblwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkFub255bW91c0RlcG9zaXRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgIFwibmFtZVwiOiBcInRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIkRlcG9zaXRcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH0sXG4gIHtcbiAgICBcImFub255bW91c1wiOiBmYWxzZSxcbiAgICBcImlucHV0c1wiOiBbXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJmcm9tXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImJ5dGVzMzJcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IHRydWUsXG4gICAgICAgIFwibmFtZVwiOiBcInRvXCIsXG4gICAgICAgIFwidHlwZVwiOiBcImFkZHJlc3NcIlxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgXCJpbmRleGVkXCI6IGZhbHNlLFxuICAgICAgICBcIm5hbWVcIjogXCJ2YWx1ZVwiLFxuICAgICAgICBcInR5cGVcIjogXCJ1aW50MjU2XCJcbiAgICAgIH1cbiAgICBdLFxuICAgIFwibmFtZVwiOiBcIlRyYW5zZmVyXCIsXG4gICAgXCJ0eXBlXCI6IFwiZXZlbnRcIlxuICB9LFxuICB7XG4gICAgXCJhbm9ueW1vdXNcIjogZmFsc2UsXG4gICAgXCJpbnB1dHNcIjogW1xuICAgICAge1xuICAgICAgICBcImluZGV4ZWRcIjogdHJ1ZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiZnJvbVwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiB0cnVlLFxuICAgICAgICBcIm5hbWVcIjogXCJ0b1wiLFxuICAgICAgICBcInR5cGVcIjogXCJhZGRyZXNzXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwiaW5kaXJlY3RJZFwiLFxuICAgICAgICBcInR5cGVcIjogXCJieXRlczMyXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIFwiaW5kZXhlZFwiOiBmYWxzZSxcbiAgICAgICAgXCJuYW1lXCI6IFwidmFsdWVcIixcbiAgICAgICAgXCJ0eXBlXCI6IFwidWludDI1NlwiXG4gICAgICB9XG4gICAgXSxcbiAgICBcIm5hbWVcIjogXCJJY2FwVHJhbnNmZXJcIixcbiAgICBcInR5cGVcIjogXCJldmVudFwiXG4gIH1cbl1cbiIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbi8qKlxuICogU29saWRpdHlUeXBlQWRkcmVzcyBpcyBhIHByb290eXBlIHRoYXQgcmVwcmVzZW50cyBhZGRyZXNzIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBhZGRyZXNzXG4gKiBhZGRyZXNzW11cbiAqIGFkZHJlc3NbNF1cbiAqIGFkZHJlc3NbXVtdXG4gKiBhZGRyZXNzWzNdW11cbiAqIGFkZHJlc3NbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0SW50O1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0QWRkcmVzcztcbn07XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVBZGRyZXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG5cblNvbGlkaXR5VHlwZUFkZHJlc3MucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvYWRkcmVzcyhcXFsoWzAtOV0qKVxcXSk/Lyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZUFkZHJlc3M7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZUJvb2wgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgYm9vbCB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogYm9vbFxuICogYm9vbFtdXG4gKiBib29sWzRdXG4gKiBib29sW11bXVxuICogYm9vbFszXVtdXG4gKiBib29sW11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVCb29sID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEJvb2w7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRCb29sO1xufTtcblxuU29saWRpdHlUeXBlQm9vbC5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZUJvb2wucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlQm9vbDtcblxuU29saWRpdHlUeXBlQm9vbC5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9eYm9vbChcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVCb29sO1xuIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVCeXRlcyBpcyBhIHByb3RvdHlwZSB0aGF0IHJlcHJlc2VudHMgdGhlIGJ5dGVzIHR5cGUuXG4gKiBJdCBtYXRjaGVzOlxuICogYnl0ZXNcbiAqIGJ5dGVzW11cbiAqIGJ5dGVzWzRdXG4gKiBieXRlc1tdW11cbiAqIGJ5dGVzWzNdW11cbiAqIGJ5dGVzW11bNl1bXSwgLi4uXG4gKiBieXRlczMyXG4gKiBieXRlczhbNF1cbiAqIGJ5dGVzWzNdW11cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUJ5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEJ5dGVzO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0Qnl0ZXM7XG59O1xuXG5Tb2xpZGl0eVR5cGVCeXRlcy5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZUJ5dGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUJ5dGVzO1xuXG5Tb2xpZGl0eVR5cGVCeXRlcy5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9eYnl0ZXMoWzAtOV17MSx9KShcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVCeXRlcztcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGNvZGVyLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVBZGRyZXNzID0gcmVxdWlyZSgnLi9hZGRyZXNzJyk7XG52YXIgU29saWRpdHlUeXBlQm9vbCA9IHJlcXVpcmUoJy4vYm9vbCcpO1xudmFyIFNvbGlkaXR5VHlwZUludCA9IHJlcXVpcmUoJy4vaW50Jyk7XG52YXIgU29saWRpdHlUeXBlVUludCA9IHJlcXVpcmUoJy4vdWludCcpO1xudmFyIFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcyA9IHJlcXVpcmUoJy4vZHluYW1pY2J5dGVzJyk7XG52YXIgU29saWRpdHlUeXBlU3RyaW5nID0gcmVxdWlyZSgnLi9zdHJpbmcnKTtcbnZhciBTb2xpZGl0eVR5cGVSZWFsID0gcmVxdWlyZSgnLi9yZWFsJyk7XG52YXIgU29saWRpdHlUeXBlVVJlYWwgPSByZXF1aXJlKCcuL3VyZWFsJyk7XG52YXIgU29saWRpdHlUeXBlQnl0ZXMgPSByZXF1aXJlKCcuL2J5dGVzJyk7XG5cbnZhciBpc0R5bmFtaWMgPSBmdW5jdGlvbiAoc29saWRpdHlUeXBlLCB0eXBlKSB7XG4gICByZXR1cm4gc29saWRpdHlUeXBlLmlzRHluYW1pY1R5cGUodHlwZSkgfHxcbiAgICAgICAgICBzb2xpZGl0eVR5cGUuaXNEeW5hbWljQXJyYXkodHlwZSk7XG59O1xuXG4vKipcbiAqIFNvbGlkaXR5Q29kZXIgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGVuY29kZS9kZWNvZGUgc29saWRpdHkgcGFyYW1zIG9mIGFueSB0eXBlXG4gKi9cbnZhciBTb2xpZGl0eUNvZGVyID0gZnVuY3Rpb24gKHR5cGVzKSB7XG4gICAgdGhpcy5fdHlwZXMgPSB0eXBlcztcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gdHJhbnNmb3JtIHR5cGUgdG8gU29saWRpdHlUeXBlXG4gKlxuICogQG1ldGhvZCBfcmVxdWlyZVR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJucyB7U29saWRpdHlUeXBlfVxuICogQHRocm93cyB7RXJyb3J9IHRocm93cyBpZiBubyBtYXRjaGluZyB0eXBlIGlzIGZvdW5kXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLl9yZXF1aXJlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZSA9IHRoaXMuX3R5cGVzLmZpbHRlcihmdW5jdGlvbiAodCkge1xuICAgICAgICByZXR1cm4gdC5pc1R5cGUodHlwZSk7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoIXNvbGlkaXR5VHlwZSkge1xuICAgICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBzb2xpZGl0eSB0eXBlITogJyArIHR5cGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzb2xpZGl0eVR5cGU7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGVuY29kZSBwbGFpbiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZW5jb2RlUGFyYW1cbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gcGxhaW4gcGFyYW1cbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCBwbGFpbiBwYXJhbVxuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVQYXJhbSA9IGZ1bmN0aW9uICh0eXBlLCBwYXJhbSkge1xuICAgIHJldHVybiB0aGlzLmVuY29kZVBhcmFtcyhbdHlwZV0sIFtwYXJhbV0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgbGlzdCBvZiBwYXJhbXNcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVBhcmFtc1xuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtc1xuICogQHJldHVybiB7U3RyaW5nfSBlbmNvZGVkIGxpc3Qgb2YgcGFyYW1zXG4gKi9cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZVBhcmFtcyA9IGZ1bmN0aW9uICh0eXBlcywgcGFyYW1zKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZXMgPSB0aGlzLmdldFNvbGlkaXR5VHlwZXModHlwZXMpO1xuXG4gICAgdmFyIGVuY29kZWRzID0gc29saWRpdHlUeXBlcy5tYXAoZnVuY3Rpb24gKHNvbGlkaXR5VHlwZSwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHNvbGlkaXR5VHlwZS5lbmNvZGUocGFyYW1zW2luZGV4XSwgdHlwZXNbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIHZhciBkeW5hbWljT2Zmc2V0ID0gc29saWRpdHlUeXBlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICB2YXIgc3RhdGljUGFydExlbmd0aCA9IHNvbGlkaXR5VHlwZS5zdGF0aWNQYXJ0TGVuZ3RoKHR5cGVzW2luZGV4XSk7XG4gICAgICAgIHZhciByb3VuZGVkU3RhdGljUGFydExlbmd0aCA9IE1hdGguZmxvb3IoKHN0YXRpY1BhcnRMZW5ndGggKyAzMSkgLyAzMikgKiAzMjtcblxuICAgICAgICByZXR1cm4gYWNjICsgKGlzRHluYW1pYyhzb2xpZGl0eVR5cGVzW2luZGV4XSwgdHlwZXNbaW5kZXhdKSA/XG4gICAgICAgICAgICAzMiA6XG4gICAgICAgICAgICByb3VuZGVkU3RhdGljUGFydExlbmd0aCk7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5lbmNvZGVNdWx0aVdpdGhPZmZzZXQodHlwZXMsIHNvbGlkaXR5VHlwZXMsIGVuY29kZWRzLCBkeW5hbWljT2Zmc2V0KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5lbmNvZGVNdWx0aVdpdGhPZmZzZXQgPSBmdW5jdGlvbiAodHlwZXMsIHNvbGlkaXR5VHlwZXMsIGVuY29kZWRzLCBkeW5hbWljT2Zmc2V0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSwgaSkge1xuICAgICAgICBpZiAoaXNEeW5hbWljKHNvbGlkaXR5VHlwZXNbaV0sIHR5cGVzW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IGYuZm9ybWF0SW5wdXRJbnQoZHluYW1pY09mZnNldCkuZW5jb2RlKCk7XG4gICAgICAgICAgICB2YXIgZSA9IHNlbGYuZW5jb2RlV2l0aE9mZnNldCh0eXBlc1tpXSwgc29saWRpdHlUeXBlc1tpXSwgZW5jb2RlZHNbaV0sIGR5bmFtaWNPZmZzZXQpO1xuICAgICAgICAgICAgZHluYW1pY09mZnNldCArPSBlLmxlbmd0aCAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBkb24ndCBhZGQgbGVuZ3RoIHRvIGR5bmFtaWNPZmZzZXQuIGl0J3MgYWxyZWFkeSBjb3VudGVkXG4gICAgICAgICAgICByZXN1bHQgKz0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBmaWd1cmUgb3V0IG5lc3RlZCBhcnJheXNcbiAgICB9KTtcblxuICAgIHR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUsIGkpIHtcbiAgICAgICAgaWYgKGlzRHluYW1pYyhzb2xpZGl0eVR5cGVzW2ldLCB0eXBlc1tpXSkpIHtcbiAgICAgICAgICAgIHZhciBlID0gc2VsZi5lbmNvZGVXaXRoT2Zmc2V0KHR5cGVzW2ldLCBzb2xpZGl0eVR5cGVzW2ldLCBlbmNvZGVkc1tpXSwgZHluYW1pY09mZnNldCk7XG4gICAgICAgICAgICBkeW5hbWljT2Zmc2V0ICs9IGUubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmVuY29kZVdpdGhPZmZzZXQgPSBmdW5jdGlvbiAodHlwZSwgc29saWRpdHlUeXBlLCBlbmNvZGVkLCBvZmZzZXQpIHtcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTogMTcgKi9cbiAgICAvKiBqc2hpbnQgbWF4ZGVwdGg6IDUgKi9cblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZW5jb2RpbmdNb2RlPXtkeW5hbWljOjEsc3RhdGljOjIsb3RoZXI6M307XG5cbiAgICB2YXIgbW9kZT0oc29saWRpdHlUeXBlLmlzRHluYW1pY0FycmF5KHR5cGUpP2VuY29kaW5nTW9kZS5keW5hbWljOihzb2xpZGl0eVR5cGUuaXNTdGF0aWNBcnJheSh0eXBlKT9lbmNvZGluZ01vZGUuc3RhdGljOmVuY29kaW5nTW9kZS5vdGhlcikpO1xuXG4gICAgaWYobW9kZSAhPT0gZW5jb2RpbmdNb2RlLm90aGVyKXtcbiAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzb2xpZGl0eVR5cGUubmVzdGVkTmFtZSh0eXBlKTtcbiAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGUuc3RhdGljUGFydExlbmd0aChuZXN0ZWROYW1lKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IChtb2RlID09PSBlbmNvZGluZ01vZGUuZHluYW1pYyA/IGVuY29kZWRbMF0gOiAnJyk7XG5cbiAgICAgICAgaWYgKHNvbGlkaXR5VHlwZS5pc0R5bmFtaWNBcnJheShuZXN0ZWROYW1lKSkge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzTGVuZ3RoID0gKG1vZGUgPT09IGVuY29kaW5nTW9kZS5keW5hbWljID8gMiA6IDApO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjdWxhdGUgbGVuZ3RoIG9mIHByZXZpb3VzIGl0ZW1cbiAgICAgICAgICAgICAgICBpZihtb2RlID09PSBlbmNvZGluZ01vZGUuZHluYW1pYyl7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTGVuZ3RoICs9ICsoZW5jb2RlZFtpIC0gMV0pWzBdIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYobW9kZSA9PT0gZW5jb2RpbmdNb2RlLnN0YXRpYyl7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzTGVuZ3RoICs9ICsoZW5jb2RlZFtpIC0gMV0gfHwgW10pWzBdIHx8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmLmZvcm1hdElucHV0SW50KG9mZnNldCArIGkgKiBuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgcHJldmlvdXNMZW5ndGggKiAzMikuZW5jb2RlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuPSAobW9kZSA9PT0gZW5jb2RpbmdNb2RlLmR5bmFtaWMgPyBlbmNvZGVkLmxlbmd0aC0xIDogZW5jb2RlZC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGxlbjsgYysrKSB7XG4gICAgICAgICAgICB2YXIgYWRkaXRpb25hbE9mZnNldCA9IHJlc3VsdCAvIDI7XG4gICAgICAgICAgICBpZihtb2RlID09PSBlbmNvZGluZ01vZGUuZHluYW1pYyl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHNlbGYuZW5jb2RlV2l0aE9mZnNldChuZXN0ZWROYW1lLCBzb2xpZGl0eVR5cGUsIGVuY29kZWRbYyArIDFdLCBvZmZzZXQgKyAgYWRkaXRpb25hbE9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmKG1vZGUgPT09IGVuY29kaW5nTW9kZS5zdGF0aWMpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBzZWxmLmVuY29kZVdpdGhPZmZzZXQobmVzdGVkTmFtZSwgc29saWRpdHlUeXBlLCBlbmNvZGVkW2NdLCBvZmZzZXQgKyBhZGRpdGlvbmFsT2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVuY29kZWQ7XG59O1xuXG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGJ5dGVzIHRvIHBsYWluIHBhcmFtXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbVxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7T2JqZWN0fSBwbGFpbiBwYXJhbVxuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbSA9IGZ1bmN0aW9uICh0eXBlLCBieXRlcykge1xuICAgIHJldHVybiB0aGlzLmRlY29kZVBhcmFtcyhbdHlwZV0sIGJ5dGVzKVswXTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGxpc3Qgb2YgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVQYXJhbVxuICogQHBhcmFtIHtBcnJheX0gdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBieXRlc1xuICogQHJldHVybiB7QXJyYXl9IGFycmF5IG9mIHBsYWluIHBhcmFtc1xuICovXG5Tb2xpZGl0eUNvZGVyLnByb3RvdHlwZS5kZWNvZGVQYXJhbXMgPSBmdW5jdGlvbiAodHlwZXMsIGJ5dGVzKSB7XG4gICAgdmFyIHNvbGlkaXR5VHlwZXMgPSB0aGlzLmdldFNvbGlkaXR5VHlwZXModHlwZXMpO1xuICAgIHZhciBvZmZzZXRzID0gdGhpcy5nZXRPZmZzZXRzKHR5cGVzLCBzb2xpZGl0eVR5cGVzKTtcblxuICAgIHJldHVybiBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLmRlY29kZShieXRlcywgb2Zmc2V0c1tpbmRleF0sICB0eXBlc1tpbmRleF0sIGluZGV4KTtcbiAgICB9KTtcbn07XG5cblNvbGlkaXR5Q29kZXIucHJvdG90eXBlLmdldE9mZnNldHMgPSBmdW5jdGlvbiAodHlwZXMsIHNvbGlkaXR5VHlwZXMpIHtcbiAgICB2YXIgbGVuZ3RocyA9ICBzb2xpZGl0eVR5cGVzLm1hcChmdW5jdGlvbiAoc29saWRpdHlUeXBlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gc29saWRpdHlUeXBlLnN0YXRpY1BhcnRMZW5ndGgodHlwZXNbaW5kZXhdKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3Rocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgLy8gc3VtIHdpdGggbGVuZ3RoIG9mIHByZXZpb3VzIGVsZW1lbnRcbiAgICAgICAgbGVuZ3Roc1tpXSArPSBsZW5ndGhzW2kgLSAxXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVuZ3Rocy5tYXAoZnVuY3Rpb24gKGxlbmd0aCwgaW5kZXgpIHtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBjdXJyZW50IGxlbmd0aCwgc28gdGhlIGxlbmd0aCBpcyBzdW0gb2YgcHJldmlvdXMgZWxlbWVudHNcbiAgICAgICAgdmFyIHN0YXRpY1BhcnRMZW5ndGggPSBzb2xpZGl0eVR5cGVzW2luZGV4XS5zdGF0aWNQYXJ0TGVuZ3RoKHR5cGVzW2luZGV4XSk7XG4gICAgICAgIHJldHVybiBsZW5ndGggLSBzdGF0aWNQYXJ0TGVuZ3RoO1xuICAgIH0pO1xufTtcblxuU29saWRpdHlDb2Rlci5wcm90b3R5cGUuZ2V0U29saWRpdHlUeXBlcyA9IGZ1bmN0aW9uICh0eXBlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZXF1aXJlVHlwZSh0eXBlKTtcbiAgICB9KTtcbn07XG5cbnZhciBjb2RlciA9IG5ldyBTb2xpZGl0eUNvZGVyKFtcbiAgICBuZXcgU29saWRpdHlUeXBlQWRkcmVzcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVCb29sKCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUludCgpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVVSW50KCksXG4gICAgbmV3IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVCeXRlcygpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVTdHJpbmcoKSxcbiAgICBuZXcgU29saWRpdHlUeXBlUmVhbCgpLFxuICAgIG5ldyBTb2xpZGl0eVR5cGVVUmVhbCgpXG5dKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb2RlcjtcbiIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlUeXBlID0gcmVxdWlyZSgnLi90eXBlJyk7XG5cbnZhciBTb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdElucHV0RHluYW1pY0J5dGVzO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzO1xufTtcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZUR5bmFtaWNCeXRlcztcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL15ieXRlcyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxuU29saWRpdHlUeXBlRHluYW1pY0J5dGVzLnByb3RvdHlwZS5pc0R5bmFtaWNUeXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVEeW5hbWljQnl0ZXM7XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmb3JtYXR0ZXJzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgYyA9IHJlcXVpcmUoJy4uL3V0aWxzL2NvbmZpZycpO1xudmFyIFNvbGlkaXR5UGFyYW0gPSByZXF1aXJlKCcuL3BhcmFtJyk7XG5cblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgaW50XG4gKiBJZiB2YWx1ZSBpcyBuZWdhdGl2ZSwgcmV0dXJuIGl0J3MgdHdvJ3MgY29tcGxlbWVudFxuICogSWYgdGhlIHZhbHVlIGlzIGZsb2F0aW5nIHBvaW50LCByb3VuZCBpdCBkb3duXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dEludFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn0gdmFsdWUgdGhhdCBuZWVkcyB0byBiZSBmb3JtYXR0ZWRcbiAqIEByZXR1cm5zIHtTb2xpZGl0eVBhcmFtfVxuICovXG52YXIgZm9ybWF0SW5wdXRJbnQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBCaWdOdW1iZXIuY29uZmlnKGMuRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFKTtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbHMucGFkTGVmdCh1dGlscy50b1R3b3NDb21wbGVtZW50KHZhbHVlKS50b1N0cmluZygxNiksIDY0KTtcbiAgICByZXR1cm4gbmV3IFNvbGlkaXR5UGFyYW0ocmVzdWx0KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyBpbnB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRCeXRlc1xuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0Qnl0ZXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdXRpbHMudG9IZXgodmFsdWUpLnN1YnN0cigyKTtcbiAgICB2YXIgbCA9IE1hdGguZmxvb3IoKHJlc3VsdC5sZW5ndGggKyA2MykgLyA2NCk7XG4gICAgcmVzdWx0ID0gdXRpbHMucGFkUmlnaHQocmVzdWx0LCBsICogNjQpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShyZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IGJ5dGVzXG4gKlxuICogQG1ldGhvZCBmb3JtYXREeW5hbWljSW5wdXRCeXRlc1xuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0RHluYW1pY0J5dGVzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLnRvSGV4KHZhbHVlKS5zdWJzdHIoMik7XG4gICAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGggLyAyO1xuICAgIHZhciBsID0gTWF0aC5mbG9vcigocmVzdWx0Lmxlbmd0aCArIDYzKSAvIDY0KTtcbiAgICByZXN1bHQgPSB1dGlscy5wYWRSaWdodChyZXN1bHQsIGwgKiA2NCk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKGZvcm1hdElucHV0SW50KGxlbmd0aCkudmFsdWUgKyByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2Ygc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmb3JtYXRJbnB1dFN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0U3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHV0aWxzLmZyb21VdGY4KHZhbHVlKS5zdWJzdHIoMik7XG4gICAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGggLyAyO1xuICAgIHZhciBsID0gTWF0aC5mbG9vcigocmVzdWx0Lmxlbmd0aCArIDYzKSAvIDY0KTtcbiAgICByZXN1bHQgPSB1dGlscy5wYWRSaWdodChyZXN1bHQsIGwgKiA2NCk7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKGZvcm1hdElucHV0SW50KGxlbmd0aCkudmFsdWUgKyByZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgYm9vbFxuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRCb29sXG4gKiBAcGFyYW0ge0Jvb2xlYW59XG4gKiBAcmV0dXJucyB7U29saWRpdHlQYXJhbX1cbiAqL1xudmFyIGZvcm1hdElucHV0Qm9vbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyArICh2YWx1ZSA/ICAnMScgOiAnMCcpO1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbShyZXN1bHQpO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIGlucHV0IHZhbHVlIHRvIGJ5dGUgcmVwcmVzZW50YXRpb24gb2YgcmVhbFxuICogVmFsdWVzIGFyZSBtdWx0aXBsaWVkIGJ5IDJebSBhbmQgZW5jb2RlZCBhcyBpbnRlZ2Vyc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRSZWFsXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfVxuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19XG4gKi9cbnZhciBmb3JtYXRJbnB1dFJlYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gZm9ybWF0SW5wdXRJbnQobmV3IEJpZ051bWJlcih2YWx1ZSkudGltZXMobmV3IEJpZ051bWJlcigyKS5wb3coMTI4KSkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBpbnB1dCB2YWx1ZSBpcyBuZWdhdGl2ZVxuICpcbiAqIEBtZXRob2Qgc2lnbmVkSXNOZWdhdGl2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIGlzIGhleCBmb3JtYXRcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzIG5lZ2F0aXZlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIHNpZ25lZElzTmVnYXRpdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gKG5ldyBCaWdOdW1iZXIodmFsdWUuc3Vic3RyKDAsIDEpLCAxNikudG9TdHJpbmcoMikuc3Vic3RyKDAsIDEpKSA9PT0gJzEnO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHJpZ2h0LWFsaWduZWQgb3V0cHV0IGJ5dGVzIHRvIGludFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0SW50XG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IHBhcmFtXG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gYmlnIG51bWJlclxuICovXG52YXIgZm9ybWF0T3V0cHV0SW50ID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyYW0uc3RhdGljUGFydCgpIHx8IFwiMFwiO1xuXG4gICAgLy8gY2hlY2sgaWYgaXQncyBuZWdhdGl2ZSBudW1iZXJcbiAgICAvLyBpdCBpdCBpcywgcmV0dXJuIHR3bydzIGNvbXBsZW1lbnRcbiAgICBpZiAoc2lnbmVkSXNOZWdhdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDE2KS5taW51cyhuZXcgQmlnTnVtYmVyKCdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJywgMTYpKS5taW51cygxKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDE2KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byB1aW50XG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRVSW50XG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7QmlnTnVtZWJlcn0gcmlnaHQtYWxpZ25lZCBvdXRwdXQgYnl0ZXMgZm9ybWF0dGVkIHRvIHVpbnRcbiAqL1xudmFyIGZvcm1hdE91dHB1dFVJbnQgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgdmFsdWUgPSBwYXJhbS5zdGF0aWNQYXJ0KCkgfHwgXCIwXCI7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsdWUsIDE2KTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byByZWFsXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRSZWFsXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19XG4gKiBAcmV0dXJucyB7QmlnTnVtYmVyfSBpbnB1dCBieXRlcyBmb3JtYXR0ZWQgdG8gcmVhbFxuICovXG52YXIgZm9ybWF0T3V0cHV0UmVhbCA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBmb3JtYXRPdXRwdXRJbnQocGFyYW0pLmRpdmlkZWRCeShuZXcgQmlnTnVtYmVyKDIpLnBvdygxMjgpKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyByaWdodC1hbGlnbmVkIG91dHB1dCBieXRlcyB0byB1cmVhbFxuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0VVJlYWxcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX1cbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IGlucHV0IGJ5dGVzIGZvcm1hdHRlZCB0byB1cmVhbFxuICovXG52YXIgZm9ybWF0T3V0cHV0VVJlYWwgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICByZXR1cm4gZm9ybWF0T3V0cHV0VUludChwYXJhbSkuZGl2aWRlZEJ5KG5ldyBCaWdOdW1iZXIoMikucG93KDEyOCkpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IGJvb2xcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dEJvb2xcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX1cbiAqIEByZXR1cm5zIHtCb29sZWFufSByaWdodC1hbGlnbmVkIGlucHV0IGJ5dGVzIGZvcm1hdHRlZCB0byBib29sXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRCb29sID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgcmV0dXJuIHBhcmFtLnN0YXRpY1BhcnQoKSA9PT0gJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnID8gdHJ1ZSA6IGZhbHNlO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBmb3JtYXQgb3V0cHV0IGJ5dGVzXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRCeXRlc1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBsZWZ0LWFsaWduZWQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgdHlwZSBuYW1lXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggc3RyaW5nXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRCeXRlcyA9IGZ1bmN0aW9uIChwYXJhbSwgbmFtZSkge1xuICAgIHZhciBtYXRjaGVzID0gbmFtZS5tYXRjaCgvXmJ5dGVzKFswLTldKikvKTtcbiAgICB2YXIgc2l6ZSA9IHBhcnNlSW50KG1hdGNoZXNbMV0pO1xuICAgIHJldHVybiAnMHgnICsgcGFyYW0uc3RhdGljUGFydCgpLnNsaWNlKDAsIDIgKiBzaXplKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBieXRlc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0RHluYW1pY0J5dGVzXG4gKiBAcGFyYW0ge1NvbGlkaXR5UGFyYW19IGxlZnQtYWxpZ25lZCBoZXggcmVwcmVzZW50YXRpb24gb2Ygc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggc3RyaW5nXG4gKi9cbnZhciBmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXMgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gKG5ldyBCaWdOdW1iZXIocGFyYW0uZHluYW1pY1BhcnQoKS5zbGljZSgwLCA2NCksIDE2KSkudG9OdW1iZXIoKSAqIDI7XG4gICAgcmV0dXJuICcweCcgKyBwYXJhbS5keW5hbWljUGFydCgpLnN1YnN0cig2NCwgbGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZm9ybWF0IG91dHB1dCBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFN0cmluZ1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSBsZWZ0LWFsaWduZWQgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRTdHJpbmcgPSBmdW5jdGlvbiAocGFyYW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gKG5ldyBCaWdOdW1iZXIocGFyYW0uZHluYW1pY1BhcnQoKS5zbGljZSgwLCA2NCksIDE2KSkudG9OdW1iZXIoKSAqIDI7XG4gICAgcmV0dXJuIHV0aWxzLnRvVXRmOChwYXJhbS5keW5hbWljUGFydCgpLnN1YnN0cig2NCwgbGVuZ3RoKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGZvcm1hdCBvdXRwdXQgYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgZm9ybWF0T3V0cHV0QWRkcmVzc1xuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSByaWdodC1hbGlnbmVkIGlucHV0IGJ5dGVzXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBhZGRyZXNzXG4gKi9cbnZhciBmb3JtYXRPdXRwdXRBZGRyZXNzID0gZnVuY3Rpb24gKHBhcmFtKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyYW0uc3RhdGljUGFydCgpO1xuICAgIHJldHVybiBcIjB4XCIgKyB2YWx1ZS5zbGljZSh2YWx1ZS5sZW5ndGggLSA0MCwgdmFsdWUubGVuZ3RoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvcm1hdElucHV0SW50OiBmb3JtYXRJbnB1dEludCxcbiAgICBmb3JtYXRJbnB1dEJ5dGVzOiBmb3JtYXRJbnB1dEJ5dGVzLFxuICAgIGZvcm1hdElucHV0RHluYW1pY0J5dGVzOiBmb3JtYXRJbnB1dER5bmFtaWNCeXRlcyxcbiAgICBmb3JtYXRJbnB1dFN0cmluZzogZm9ybWF0SW5wdXRTdHJpbmcsXG4gICAgZm9ybWF0SW5wdXRCb29sOiBmb3JtYXRJbnB1dEJvb2wsXG4gICAgZm9ybWF0SW5wdXRSZWFsOiBmb3JtYXRJbnB1dFJlYWwsXG4gICAgZm9ybWF0T3V0cHV0SW50OiBmb3JtYXRPdXRwdXRJbnQsXG4gICAgZm9ybWF0T3V0cHV0VUludDogZm9ybWF0T3V0cHV0VUludCxcbiAgICBmb3JtYXRPdXRwdXRSZWFsOiBmb3JtYXRPdXRwdXRSZWFsLFxuICAgIGZvcm1hdE91dHB1dFVSZWFsOiBmb3JtYXRPdXRwdXRVUmVhbCxcbiAgICBmb3JtYXRPdXRwdXRCb29sOiBmb3JtYXRPdXRwdXRCb29sLFxuICAgIGZvcm1hdE91dHB1dEJ5dGVzOiBmb3JtYXRPdXRwdXRCeXRlcyxcbiAgICBmb3JtYXRPdXRwdXREeW5hbWljQnl0ZXM6IGZvcm1hdE91dHB1dER5bmFtaWNCeXRlcyxcbiAgICBmb3JtYXRPdXRwdXRTdHJpbmc6IGZvcm1hdE91dHB1dFN0cmluZyxcbiAgICBmb3JtYXRPdXRwdXRBZGRyZXNzOiBmb3JtYXRPdXRwdXRBZGRyZXNzXG59O1xuIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVJbnQgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgaW50IHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiBpbnRcbiAqIGludFtdXG4gKiBpbnRbNF1cbiAqIGludFtdW11cbiAqIGludFszXVtdXG4gKiBpbnRbXVs2XVtdLCAuLi5cbiAqIGludDMyXG4gKiBpbnQ2NFtdXG4gKiBpbnQ4WzRdXG4gKiBpbnQyNTZbXVtdXG4gKiBpbnRbM11bXVxuICogaW50NjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZUludCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRJbnQ7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRJbnQ7XG59O1xuXG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlSW50O1xuXG5Tb2xpZGl0eVR5cGVJbnQucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvXmludChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVJbnQ7XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgcGFyYW0uanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVBhcmFtIG9iamVjdCBwcm90b3R5cGUuXG4gKiBTaG91bGQgYmUgdXNlZCB3aGVuIGVuY29kaW5nLCBkZWNvZGluZyBzb2xpZGl0eSBieXRlc1xuICovXG52YXIgU29saWRpdHlQYXJhbSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlIHx8ICcnO1xuICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0OyAvLyBvZmZzZXQgaW4gYnl0ZXNcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGxlbmd0aCBvZiBwYXJhbXMncyBkeW5hbWljIHBhcnRcbiAqIFxuICogQG1ldGhvZCBkeW5hbWljUGFydExlbmd0aFxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGR5bmFtaWMgcGFydCAoaW4gYnl0ZXMpXG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmR5bmFtaWNQYXJ0TGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmR5bmFtaWNQYXJ0KCkubGVuZ3RoIC8gMjtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGNvcHkgb2Ygc29saWRpdHkgcGFyYW0gd2l0aCBkaWZmZXJlbnQgb2Zmc2V0XG4gKlxuICogQG1ldGhvZCB3aXRoT2Zmc2V0XG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IGxlbmd0aCBpbiBieXRlc1xuICogQHJldHVybnMge1NvbGlkaXR5UGFyYW19IG5ldyBzb2xpZGl0eSBwYXJhbSB3aXRoIGFwcGxpZWQgb2Zmc2V0XG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLndpdGhPZmZzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgcmV0dXJuIG5ldyBTb2xpZGl0eVBhcmFtKHRoaXMudmFsdWUsIG9mZnNldCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNvbWJpbmUgc29saWRpdHkgcGFyYW1zIHRvZ2V0aGVyXG4gKiBlZy4gd2hlbiBhcHBlbmRpbmcgYW4gYXJyYXlcbiAqXG4gKiBAbWV0aG9kIGNvbWJpbmVcbiAqIEBwYXJhbSB7U29saWRpdHlQYXJhbX0gcGFyYW0gd2l0aCB3aGljaCB3ZSBzaG91bGQgY29tYmluZVxuICogQHBhcmFtIHtTb2xpZGl0eVBhcmFtfSByZXN1bHQgb2YgY29tYmluYXRpb25cbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuY29tYmluZSA9IGZ1bmN0aW9uIChwYXJhbSkge1xuICAgIHJldHVybiBuZXcgU29saWRpdHlQYXJhbSh0aGlzLnZhbHVlICsgcGFyYW0udmFsdWUpOyBcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBwYXJhbSBoYXMgZHluYW1pYyBzaXplLlxuICogSWYgaXQgaGFzLCBpdCByZXR1cm5zIHRydWUsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNEeW5hbWljXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuaXNEeW5hbWljID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldCAhPT0gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIHRvIHRyYW5zZm9ybSBvZmZzZXQgdG8gYnl0ZXNcbiAqXG4gKiBAbWV0aG9kIG9mZnNldEFzQnl0ZXNcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGJ5dGVzIHJlcHJlc2VudGF0aW9uIG9mIG9mZnNldFxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5vZmZzZXRBc0J5dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0R5bmFtaWMoKSA/ICcnIDogdXRpbHMucGFkTGVmdCh1dGlscy50b1R3b3NDb21wbGVtZW50KHRoaXMub2Zmc2V0KS50b1N0cmluZygxNiksIDY0KTtcbn07XG5cbi8qKlxuICogVGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgc3RhdGljIHBhcnQgb2YgcGFyYW1cbiAqXG4gKiBAbWV0aG9kIHN0YXRpY1BhcnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IG9mZnNldCBpZiBpdCBpcyBhIGR5bmFtaWMgcGFyYW0sIG90aGVyd2lzZSB2YWx1ZVxuICovXG5Tb2xpZGl0eVBhcmFtLnByb3RvdHlwZS5zdGF0aWNQYXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0R5bmFtaWMoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTsgXG4gICAgfSBcbiAgICByZXR1cm4gdGhpcy5vZmZzZXRBc0J5dGVzKCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGR5bmFtaWMgcGFydCBvZiBwYXJhbVxuICpcbiAqIEBtZXRob2QgZHluYW1pY1BhcnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJldHVybnMgYSB2YWx1ZSBpZiBpdCBpcyBhIGR5bmFtaWMgcGFyYW0sIG90aGVyd2lzZSBlbXB0eSBzdHJpbmdcbiAqL1xuU29saWRpdHlQYXJhbS5wcm90b3R5cGUuZHluYW1pY1BhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNEeW5hbWljKCkgPyB0aGlzLnZhbHVlIDogJyc7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZW5jb2RlIHBhcmFtXG4gKlxuICogQG1ldGhvZCBlbmNvZGVcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblNvbGlkaXR5UGFyYW0ucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0aWNQYXJ0KCkgKyB0aGlzLmR5bmFtaWNQYXJ0KCk7XG59O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgdG8gZW5jb2RlIGFycmF5IG9mIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlTGlzdFxuICogQHBhcmFtIHtBcnJheVtTb2xpZGl0eVBhcmFtXX0gcGFyYW1zXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5Tb2xpZGl0eVBhcmFtLmVuY29kZUxpc3QgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgXG4gICAgLy8gdXBkYXRpbmcgb2Zmc2V0c1xuICAgIHZhciB0b3RhbE9mZnNldCA9IHBhcmFtcy5sZW5ndGggKiAzMjtcbiAgICB2YXIgb2Zmc2V0UGFyYW1zID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcbiAgICAgICAgaWYgKCFwYXJhbS5pc0R5bmFtaWMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvZmZzZXQgPSB0b3RhbE9mZnNldDtcbiAgICAgICAgdG90YWxPZmZzZXQgKz0gcGFyYW0uZHluYW1pY1BhcnRMZW5ndGgoKTtcbiAgICAgICAgcmV0dXJuIHBhcmFtLndpdGhPZmZzZXQob2Zmc2V0KTtcbiAgICB9KTtcblxuICAgIC8vIGVuY29kZSBldmVyeXRoaW5nIVxuICAgIHJldHVybiBvZmZzZXRQYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIHBhcmFtKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBwYXJhbS5keW5hbWljUGFydCgpO1xuICAgIH0sIG9mZnNldFBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKHJlc3VsdCwgcGFyYW0pIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIHBhcmFtLnN0YXRpY1BhcnQoKTtcbiAgICB9LCAnJykpO1xufTtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gU29saWRpdHlQYXJhbTtcblxuIiwidmFyIGYgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBTb2xpZGl0eVR5cGUgPSByZXF1aXJlKCcuL3R5cGUnKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGVSZWFsIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIHJlYWwgdHlwZVxuICogSXQgbWF0Y2hlczpcbiAqIHJlYWxcbiAqIHJlYWxbXVxuICogcmVhbFs0XVxuICogcmVhbFtdW11cbiAqIHJlYWxbM11bXVxuICogcmVhbFtdWzZdW10sIC4uLlxuICogcmVhbDMyXG4gKiByZWFsNjRbXVxuICogcmVhbDhbNF1cbiAqIHJlYWwyNTZbXVtdXG4gKiByZWFsWzNdW11cbiAqIHJlYWw2NFtdWzZdW10sIC4uLlxuICovXG52YXIgU29saWRpdHlUeXBlUmVhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9pbnB1dEZvcm1hdHRlciA9IGYuZm9ybWF0SW5wdXRSZWFsO1xuICAgIHRoaXMuX291dHB1dEZvcm1hdHRlciA9IGYuZm9ybWF0T3V0cHV0UmVhbDtcbn07XG5cblNvbGlkaXR5VHlwZVJlYWwucHJvdG90eXBlID0gbmV3IFNvbGlkaXR5VHlwZSh7fSk7XG5Tb2xpZGl0eVR5cGVSZWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvbGlkaXR5VHlwZVJlYWw7XG5cblNvbGlkaXR5VHlwZVJlYWwucHJvdG90eXBlLmlzVHlwZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICEhbmFtZS5tYXRjaCgvcmVhbChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSk/Lyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVJlYWw7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG52YXIgU29saWRpdHlUeXBlU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFN0cmluZztcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFN0cmluZztcbn07XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUgPSBuZXcgU29saWRpdHlUeXBlKHt9KTtcblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVTdHJpbmc7XG5cblNvbGlkaXR5VHlwZVN0cmluZy5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gISFuYW1lLm1hdGNoKC9ec3RyaW5nKFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5Tb2xpZGl0eVR5cGVTdHJpbmcucHJvdG90eXBlLmlzRHluYW1pY1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVN0cmluZztcbiIsInZhciBmID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgU29saWRpdHlQYXJhbSA9IHJlcXVpcmUoJy4vcGFyYW0nKTtcblxuLyoqXG4gKiBTb2xpZGl0eVR5cGUgcHJvdG90eXBlIGlzIHVzZWQgdG8gZW5jb2RlL2RlY29kZSBzb2xpZGl0eSBwYXJhbXMgb2YgY2VydGFpbiB0eXBlXG4gKi9cbnZhciBTb2xpZGl0eVR5cGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgdGhpcy5faW5wdXRGb3JtYXR0ZXIgPSBjb25maWcuaW5wdXRGb3JtYXR0ZXI7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gY29uZmlnLm91dHB1dEZvcm1hdHRlcjtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHRoaXMgU29saWRpdHlUeXBlIGRvIG1hdGNoIGdpdmVuIG5hbWVcbiAqXG4gKiBAbWV0aG9kIGlzVHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2x9IHRydWUgaWYgdHlwZSBtYXRjaCB0aGlzIFNvbGlkaXR5VHlwZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUuaXNUeXBlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBcInRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycndyaXR0ZW4gZm9yIHR5cGUgXCIgKyBuYW1lO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXRlcm1pbmUgd2hhdCBpcyB0aGUgbGVuZ3RoIG9mIHN0YXRpYyBwYXJ0IGluIGdpdmVuIHR5cGVcbiAqXG4gKiBAbWV0aG9kIHN0YXRpY1BhcnRMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiBzdGF0aWMgcGFydCBpbiBieXRlc1xuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLnN0YXRpY1BhcnRMZW5ndGggPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIElmIG5hbWUgaXNuJ3QgYW4gYXJyYXkgdGhlbiB0cmVhdCBpdCBsaWtlIGEgc2luZ2xlIGVsZW1lbnQgYXJyYXkuXG4gICAgcmV0dXJuICh0aGlzLm5lc3RlZFR5cGVzKG5hbWUpIHx8IFsnWzFdJ10pXG4gICAgICAgIC5tYXAoZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgICAgIC8vIHRoZSBsZW5ndGggb2YgdGhlIG5lc3RlZCBhcnJheVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KHR5cGUuc2xpY2UoMSwgLTEpLCAxMCkgfHwgMTtcbiAgICAgICAgfSlcbiAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91cyAqIGN1cnJlbnQ7XG4gICAgICAgIC8vIGFsbCBiYXNpYyB0eXBlcyBhcmUgMzIgYnl0ZXMgbG9uZ1xuICAgICAgICB9LCAzMik7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB0eXBlIGlzIGR5bmFtaWMgYXJyYXlcbiAqIGVnOlxuICogXCJ0eXBlW11cIiA9PiB0cnVlXG4gKiBcInR5cGVbNF1cIiA9PiBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNEeW5hbWljQXJyYXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIHRoZSB0eXBlIGlzIGR5bmFtaWMgYXJyYXlcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5pc0R5bmFtaWNBcnJheSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG5lc3RlZFR5cGVzID0gdGhpcy5uZXN0ZWRUeXBlcyhuYW1lKTtcbiAgICByZXR1cm4gISFuZXN0ZWRUeXBlcyAmJiAhbmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1swLTldezEsfS9nKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIHR5cGUgaXMgc3RhdGljIGFycmF5XG4gKiBlZzpcbiAqIFwidHlwZVtdXCIgPT4gZmFsc2VcbiAqIFwidHlwZVs0XVwiID0+IHRydWVcbiAqXG4gKiBAbWV0aG9kIGlzU3RhdGljQXJyYXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIHRoZSB0eXBlIGlzIHN0YXRpYyBhcnJheVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmlzU3RhdGljQXJyYXkgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBuZXN0ZWRUeXBlcyA9IHRoaXMubmVzdGVkVHlwZXMobmFtZSk7XG4gICAgcmV0dXJuICEhbmVzdGVkVHlwZXMgJiYgISFuZXN0ZWRUeXBlc1tuZXN0ZWRUeXBlcy5sZW5ndGggLSAxXS5tYXRjaCgvWzAtOV17MSx9L2cpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIGxlbmd0aCBvZiBzdGF0aWMgYXJyYXlcbiAqIGVnLlxuICogXCJpbnRbMzJdXCIgPT4gMzJcbiAqIFwiaW50MjU2WzE0XVwiID0+IDE0XG4gKiBcImludFsyXVszXVwiID0+IDNcbiAqIFwiaW50XCIgPT4gMVxuICogXCJpbnRbMV1cIiA9PiAxXG4gKiBcImludFtdXCIgPT4gMVxuICpcbiAqIEBtZXRob2Qgc3RhdGljQXJyYXlMZW5ndGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHN0YXRpYyBhcnJheSBsZW5ndGhcbiAqL1xuU29saWRpdHlUeXBlLnByb3RvdHlwZS5zdGF0aWNBcnJheUxlbmd0aCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIG5lc3RlZFR5cGVzID0gdGhpcy5uZXN0ZWRUeXBlcyhuYW1lKTtcbiAgICBpZiAobmVzdGVkVHlwZXMpIHtcbiAgICAgICByZXR1cm4gcGFyc2VJbnQobmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1swLTldezEsfS9nKSB8fCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIDE7XG59O1xuXG4vKipcbiAqIFNob3VsZCByZXR1cm4gbmVzdGVkIHR5cGVcbiAqIGVnLlxuICogXCJpbnRbMzJdXCIgPT4gXCJpbnRcIlxuICogXCJpbnQyNTZbMTRdXCIgPT4gXCJpbnQyNTZcIlxuICogXCJpbnRbMl1bM11cIiA9PiBcImludFsyXVwiXG4gKiBcImludFwiID0+IFwiaW50XCJcbiAqIFwiaW50W11cIiA9PiBcImludFwiXG4gKlxuICogQG1ldGhvZCBuZXN0ZWROYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7U3RyaW5nfSBuZXN0ZWQgbmFtZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLm5lc3RlZE5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIHJlbW92ZSBsYXN0IFtdIGluIG5hbWVcbiAgICB2YXIgbmVzdGVkVHlwZXMgPSB0aGlzLm5lc3RlZFR5cGVzKG5hbWUpO1xuICAgIGlmICghbmVzdGVkVHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hbWUuc3Vic3RyKDAsIG5hbWUubGVuZ3RoIC0gbmVzdGVkVHlwZXNbbmVzdGVkVHlwZXMubGVuZ3RoIC0gMV0ubGVuZ3RoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIHJldHVybiB0cnVlIGlmIHR5cGUgaGFzIGR5bmFtaWMgc2l6ZSBieSBkZWZhdWx0XG4gKiBzdWNoIHR5cGVzIGFyZSBcInN0cmluZ1wiLCBcImJ5dGVzXCJcbiAqXG4gKiBAbWV0aG9kIGlzRHluYW1pY1R5cGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sfSB0cnVlIGlmIGlzIGR5bmFtaWMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmlzRHluYW1pY1R5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBTaG91bGQgcmV0dXJuIGFycmF5IG9mIG5lc3RlZCB0eXBlc1xuICogZWcuXG4gKiBcImludFsyXVszXVtdXCIgPT4gW1wiWzJdXCIsIFwiWzNdXCIsIFwiW11cIl1cbiAqIFwiaW50W10gPT4gW1wiW11cIl1cbiAqIFwiaW50XCIgPT4gbnVsbFxuICpcbiAqIEBtZXRob2QgbmVzdGVkVHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtBcnJheX0gYXJyYXkgb2YgbmVzdGVkIHR5cGVzXG4gKi9cblNvbGlkaXR5VHlwZS5wcm90b3R5cGUubmVzdGVkVHlwZXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIC8vIHJldHVybiBsaXN0IG9mIHN0cmluZ3MgZWcuIFwiW11cIiwgXCJbM11cIiwgXCJbXVwiLCBcIlsyXVwiXG4gICAgcmV0dXJuIG5hbWUubWF0Y2goLyhcXFtbMC05XSpcXF0pL2cpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBlbmNvZGUgdGhlIHZhbHVlXG4gKlxuICogQG1ldGhvZCBlbmNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZCB2YWx1ZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5pc0R5bmFtaWNBcnJheShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGludFxuICAgICAgICAgICAgdmFyIG5lc3RlZE5hbWUgPSBzZWxmLm5lc3RlZE5hbWUobmFtZSk7XG5cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYuZm9ybWF0SW5wdXRJbnQobGVuZ3RoKS5lbmNvZGUoKSk7XG5cbiAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLmVuY29kZSh2LCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcblxuICAgIH0gZWxzZSBpZiAodGhpcy5pc1N0YXRpY0FycmF5KG5hbWUpKSB7XG5cbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gc2VsZi5zdGF0aWNBcnJheUxlbmd0aChuYW1lKTsgICAgICAgICAgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgbmVzdGVkTmFtZSA9IHNlbGYubmVzdGVkTmFtZShuYW1lKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHNlbGYuZW5jb2RlKHZhbHVlW2ldLCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5faW5wdXRGb3JtYXR0ZXIodmFsdWUsIG5hbWUpLmVuY29kZSgpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZWNvZGUgdmFsdWUgZnJvbSBieXRlc1xuICpcbiAqIEBtZXRob2QgZGVjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gYnl0ZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgaW4gYnl0ZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHR5cGUgbmFtZVxuICogQHJldHVybnMge09iamVjdH0gZGVjb2RlZCB2YWx1ZVxuICovXG5Tb2xpZGl0eVR5cGUucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChieXRlcywgb2Zmc2V0LCBuYW1lKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuaXNEeW5hbWljQXJyYXkobmFtZSkpIHtcblxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcnJheU9mZnNldCA9IHBhcnNlSW50KCcweCcgKyBieXRlcy5zdWJzdHIob2Zmc2V0ICogMiwgNjQpKTsgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKGFycmF5T2Zmc2V0ICogMiwgNjQpKTsgLy8gaW4gaW50XG4gICAgICAgICAgICB2YXIgYXJyYXlTdGFydCA9IGFycmF5T2Zmc2V0ICsgMzI7IC8vIGFycmF5IHN0YXJ0cyBhZnRlciBsZW5ndGg7IC8vIGluIGJ5dGVzXG5cbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc2VsZi5uZXN0ZWROYW1lKG5hbWUpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzZWxmLnN0YXRpY1BhcnRMZW5ndGgobmVzdGVkTmFtZSk7ICAvLyBpbiBieXRlc1xuICAgICAgICAgICAgdmFyIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoID0gTWF0aC5mbG9vcigobmVzdGVkU3RhdGljUGFydExlbmd0aCArIDMxKSAvIDMyKSAqIDMyO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aCAqIHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoOyBpICs9IHJvdW5kZWROZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VsZi5kZWNvZGUoYnl0ZXMsIGFycmF5U3RhcnQgKyBpLCBuZXN0ZWROYW1lKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKCk7XG5cbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNTdGF0aWNBcnJheShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxlbmd0aCA9IHNlbGYuc3RhdGljQXJyYXlMZW5ndGgobmFtZSk7ICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGludFxuICAgICAgICAgICAgdmFyIGFycmF5U3RhcnQgPSBvZmZzZXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluIGJ5dGVzXG5cbiAgICAgICAgICAgIHZhciBuZXN0ZWROYW1lID0gc2VsZi5uZXN0ZWROYW1lKG5hbWUpO1xuICAgICAgICAgICAgdmFyIG5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBzZWxmLnN0YXRpY1BhcnRMZW5ndGgobmVzdGVkTmFtZSk7IC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGggPSBNYXRoLmZsb29yKChuZXN0ZWRTdGF0aWNQYXJ0TGVuZ3RoICsgMzEpIC8gMzIpICogMzI7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoICogcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGg7IGkgKz0gcm91bmRlZE5lc3RlZFN0YXRpY1BhcnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChzZWxmLmRlY29kZShieXRlcywgYXJyYXlTdGFydCArIGksIG5lc3RlZE5hbWUpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSkoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNEeW5hbWljVHlwZShuYW1lKSkge1xuXG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGR5bmFtaWNPZmZzZXQgPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKG9mZnNldCAqIDIsIDY0KSk7ICAgICAgLy8gaW4gYnl0ZXNcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludCgnMHgnICsgYnl0ZXMuc3Vic3RyKGR5bmFtaWNPZmZzZXQgKiAyLCA2NCkpOyAgICAgIC8vIGluIGJ5dGVzXG4gICAgICAgICAgICB2YXIgcm91bmRlZExlbmd0aCA9IE1hdGguZmxvb3IoKGxlbmd0aCArIDMxKSAvIDMyKTsgICAgICAgICAgICAgICAgICAgICAvLyBpbiBpbnRcbiAgICAgICAgICAgIHZhciBwYXJhbSA9IG5ldyBTb2xpZGl0eVBhcmFtKGJ5dGVzLnN1YnN0cihkeW5hbWljT2Zmc2V0ICogMiwgKCAxICsgcm91bmRlZExlbmd0aCkgKiA2NCksIDApO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGYuX291dHB1dEZvcm1hdHRlcihwYXJhbSwgbmFtZSk7XG4gICAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuc3RhdGljUGFydExlbmd0aChuYW1lKTtcbiAgICB2YXIgcGFyYW0gPSBuZXcgU29saWRpdHlQYXJhbShieXRlcy5zdWJzdHIob2Zmc2V0ICogMiwgbGVuZ3RoICogMikpO1xuICAgIHJldHVybiB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIocGFyYW0sIG5hbWUpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGU7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVVJbnQgaXMgYSBwcm9vdHlwZSB0aGF0IHJlcHJlc2VudHMgdWludCB0eXBlXG4gKiBJdCBtYXRjaGVzOlxuICogdWludFxuICogdWludFtdXG4gKiB1aW50WzRdXG4gKiB1aW50W11bXVxuICogdWludFszXVtdXG4gKiB1aW50W11bNl1bXSwgLi4uXG4gKiB1aW50MzJcbiAqIHVpbnQ2NFtdXG4gKiB1aW50OFs0XVxuICogdWludDI1NltdW11cbiAqIHVpbnRbM11bXVxuICogdWludDY0W11bNl1bXSwgLi4uXG4gKi9cbnZhciBTb2xpZGl0eVR5cGVVSW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dEludDtcbiAgICB0aGlzLl9vdXRwdXRGb3JtYXR0ZXIgPSBmLmZvcm1hdE91dHB1dFVJbnQ7XG59O1xuXG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlVUludC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb2xpZGl0eVR5cGVVSW50O1xuXG5Tb2xpZGl0eVR5cGVVSW50LnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL151aW50KFswLTldKik/KFxcWyhbMC05XSopXFxdKSokLyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNvbGlkaXR5VHlwZVVJbnQ7XG4iLCJ2YXIgZiA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIFNvbGlkaXR5VHlwZSA9IHJlcXVpcmUoJy4vdHlwZScpO1xuXG4vKipcbiAqIFNvbGlkaXR5VHlwZVVSZWFsIGlzIGEgcHJvb3R5cGUgdGhhdCByZXByZXNlbnRzIHVyZWFsIHR5cGVcbiAqIEl0IG1hdGNoZXM6XG4gKiB1cmVhbFxuICogdXJlYWxbXVxuICogdXJlYWxbNF1cbiAqIHVyZWFsW11bXVxuICogdXJlYWxbM11bXVxuICogdXJlYWxbXVs2XVtdLCAuLi5cbiAqIHVyZWFsMzJcbiAqIHVyZWFsNjRbXVxuICogdXJlYWw4WzRdXG4gKiB1cmVhbDI1NltdW11cbiAqIHVyZWFsWzNdW11cbiAqIHVyZWFsNjRbXVs2XVtdLCAuLi5cbiAqL1xudmFyIFNvbGlkaXR5VHlwZVVSZWFsID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2lucHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRJbnB1dFJlYWw7XG4gICAgdGhpcy5fb3V0cHV0Rm9ybWF0dGVyID0gZi5mb3JtYXRPdXRwdXRVUmVhbDtcbn07XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZSA9IG5ldyBTb2xpZGl0eVR5cGUoe30pO1xuU29saWRpdHlUeXBlVVJlYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU29saWRpdHlUeXBlVVJlYWw7XG5cblNvbGlkaXR5VHlwZVVSZWFsLnByb3RvdHlwZS5pc1R5cGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiAhIW5hbWUubWF0Y2goL151cmVhbChbMC05XSopPyhcXFsoWzAtOV0qKVxcXSkqJC8pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eVR5cGVVUmVhbDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZ28gZW52IGRvZXNuJ3QgaGF2ZSBhbmQgbmVlZCBYTUxIdHRwUmVxdWVzdFxuaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBleHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0ge307XG59IGVsc2Uge1xuICAgIGV4cG9ydHMuWE1MSHR0cFJlcXVlc3QgPSBYTUxIdHRwUmVxdWVzdDsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG59XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgY29uZmlnLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuLyoqXG4gKiBVdGlsc1xuICogXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICogXG4gKiBAY2xhc3MgW3V0aWxzXSBjb25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cblxuLy8vIHJlcXVpcmVkIHRvIGRlZmluZSBFVEhfQklHTlVNQkVSX1JPVU5ESU5HX01PREVcbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxudmFyIEVUSF9VTklUUyA9IFtcbiAgICAnd2VpJyxcbiAgICAna3dlaScsXG4gICAgJ013ZWknLFxuICAgICdHd2VpJyxcbiAgICAnc3phYm8nLFxuICAgICdmaW5uZXknLFxuICAgICdmZW10b2V0aGVyJyxcbiAgICAncGljb2V0aGVyJyxcbiAgICAnbmFub2V0aGVyJyxcbiAgICAnbWljcm9ldGhlcicsXG4gICAgJ21pbGxpZXRoZXInLFxuICAgICduYW5vJyxcbiAgICAnbWljcm8nLFxuICAgICdtaWxsaScsXG4gICAgJ2V0aGVyJyxcbiAgICAnZ3JhbmQnLFxuICAgICdNZXRoZXInLFxuICAgICdHZXRoZXInLFxuICAgICdUZXRoZXInLFxuICAgICdQZXRoZXInLFxuICAgICdFZXRoZXInLFxuICAgICdaZXRoZXInLFxuICAgICdZZXRoZXInLFxuICAgICdOZXRoZXInLFxuICAgICdEZXRoZXInLFxuICAgICdWZXRoZXInLFxuICAgICdVZXRoZXInXG5dO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBFVEhfUEFERElORzogMzIsXG4gICAgRVRIX1NJR05BVFVSRV9MRU5HVEg6IDQsXG4gICAgRVRIX1VOSVRTOiBFVEhfVU5JVFMsXG4gICAgRVRIX0JJR05VTUJFUl9ST1VORElOR19NT0RFOiB7IFJPVU5ESU5HX01PREU6IEJpZ051bWJlci5ST1VORF9ET1dOIH0sXG4gICAgRVRIX1BPTExJTkdfVElNRU9VVDogMTAwMC8yLFxuICAgIGRlZmF1bHRCbG9jazogJ2xhdGVzdCcsXG4gICAgZGVmYXVsdEFjY291bnQ6IHVuZGVmaW5lZFxufTtcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIHNoYTMuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIENyeXB0b0pTID0gcmVxdWlyZSgnY3J5cHRvLWpzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJ2NyeXB0by1qcy9zaGEzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZyA9PT0gJ2hleCcpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgJiYgdmFsdWUuc3Vic3RyKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cigyKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IENyeXB0b0pTLmVuYy5IZXgucGFyc2UodmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGEzKHZhbHVlLCB7XG4gICAgICAgIG91dHB1dExlbmd0aDogMjU2XG4gICAgfSkudG9TdHJpbmcoKTtcbn07XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIHV0aWxzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbi8qKlxuICogVXRpbHNcbiAqXG4gKiBAbW9kdWxlIHV0aWxzXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uc1xuICpcbiAqIEBjbGFzcyBbdXRpbHNdIHV0aWxzXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi9zaGEzLmpzJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxudmFyIHVuaXRNYXAgPSB7XG4gICAgJ25vZXRoZXInOiAgICAgICcwJyxcbiAgICAnd2VpJzogICAgICAgICAgJzEnLFxuICAgICdrd2VpJzogICAgICAgICAnMTAwMCcsXG4gICAgJ0t3ZWknOiAgICAgICAgICcxMDAwJyxcbiAgICAnYmFiYmFnZSc6ICAgICAgJzEwMDAnLFxuICAgICdmZW10b2V0aGVyJzogICAnMTAwMCcsXG4gICAgJ213ZWknOiAgICAgICAgICcxMDAwMDAwJyxcbiAgICAnTXdlaSc6ICAgICAgICAgJzEwMDAwMDAnLFxuICAgICdsb3ZlbGFjZSc6ICAgICAnMTAwMDAwMCcsXG4gICAgJ3BpY29ldGhlcic6ICAgICcxMDAwMDAwJyxcbiAgICAnZ3dlaSc6ICAgICAgICAgJzEwMDAwMDAwMDAnLFxuICAgICdHd2VpJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3NoYW5ub24nOiAgICAgICcxMDAwMDAwMDAwJyxcbiAgICAnbmFub2V0aGVyJzogICAgJzEwMDAwMDAwMDAnLFxuICAgICduYW5vJzogICAgICAgICAnMTAwMDAwMDAwMCcsXG4gICAgJ3N6YWJvJzogICAgICAgICcxMDAwMDAwMDAwMDAwJyxcbiAgICAnbWljcm9ldGhlcic6ICAgJzEwMDAwMDAwMDAwMDAnLFxuICAgICdtaWNybyc6ICAgICAgICAnMTAwMDAwMDAwMDAwMCcsXG4gICAgJ2Zpbm5leSc6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnbWlsbGlldGhlcic6ICAgJzEwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdtaWxsaSc6ICAgICAgICAnMTAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2V0aGVyJzogICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAna2V0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdncmFuZCc6ICAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ21ldGhlcic6ICAgICAgICcxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnZ2V0aGVyJzogICAgICAgJzEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICd0ZXRoZXInOiAgICAgICAnMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcGFkTGVmdFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyB0byBiZSBwYWRkZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBjaGFyYWN0ZXJzIHRoYXQgcmVzdWx0IHN0cmluZyBzaG91bGQgaGF2ZVxuICogQHBhcmFtIHtTdHJpbmd9IHNpZ24sIGJ5IGRlZmF1bHQgMFxuICogQHJldHVybnMge1N0cmluZ30gcmlnaHQgYWxpZ25lZCBzdHJpbmdcbiAqL1xudmFyIHBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBjaGFycywgc2lnbikge1xuICAgIHJldHVybiBuZXcgQXJyYXkoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSkuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSArIHN0cmluZztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwYWQgc3RyaW5nIHRvIGV4cGVjdGVkIGxlbmd0aFxuICpcbiAqIEBtZXRob2QgcGFkUmlnaHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdG8gYmUgcGFkZGVkXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhcmFjdGVycyB0aGF0IHJlc3VsdCBzdHJpbmcgc2hvdWxkIGhhdmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzaWduLCBieSBkZWZhdWx0IDBcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHJpZ2h0IGFsaWduZWQgc3RyaW5nXG4gKi9cbnZhciBwYWRSaWdodCA9IGZ1bmN0aW9uIChzdHJpbmcsIGNoYXJzLCBzaWduKSB7XG4gICAgcmV0dXJuIHN0cmluZyArIChuZXcgQXJyYXkoY2hhcnMgLSBzdHJpbmcubGVuZ3RoICsgMSkuam9pbihzaWduID8gc2lnbiA6IFwiMFwiKSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IHV0ZjggZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9VdGY4XG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIGluIGhleFxuICogQHJldHVybnMge1N0cmluZ30gYXNjaWkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGhleCB2YWx1ZVxuICovXG52YXIgdG9VdGY4ID0gZnVuY3Rpb24oaGV4KSB7XG4vLyBGaW5kIHRlcm1pbmF0aW9uXG4gICAgdmFyIHN0ciA9IFwiXCI7XG4gICAgdmFyIGkgPSAwLCBsID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAoaGV4LnN1YnN0cmluZygwLCAyKSA9PT0gJzB4Jykge1xuICAgICAgICBpID0gMjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBsOyBpKz0yKSB7XG4gICAgICAgIHZhciBjb2RlID0gcGFyc2VJbnQoaGV4LnN1YnN0cihpLCAyKSwgMTYpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMClcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXRmOC5kZWNvZGUoc3RyKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYXNjaWkgZnJvbSBpdCdzIGhleCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBtZXRob2QgdG9Bc2NpaVxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBpbiBoZXhcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGFzY2lpIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBoZXggdmFsdWVcbiAqL1xudmFyIHRvQXNjaWkgPSBmdW5jdGlvbihoZXgpIHtcbi8vIEZpbmQgdGVybWluYXRpb25cbiAgICB2YXIgc3RyID0gXCJcIjtcbiAgICB2YXIgaSA9IDAsIGwgPSBoZXgubGVuZ3RoO1xuICAgIGlmIChoZXguc3Vic3RyaW5nKDAsIDIpID09PSAnMHgnKSB7XG4gICAgICAgIGkgPSAyO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IGw7IGkrPTIpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBwYXJzZUludChoZXguc3Vic3RyKGksIDIpLCAxNik7XG4gICAgICAgIHN0ciArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIHV0Zjggc3RyaW5nXG4gKlxuICogQG1ldGhvZCBmcm9tVXRmOFxuICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZ1xuICogQHBhcmFtIHtCb29sZWFufSBhbGxvd1plcm8gdG8gY29udmVydCBjb2RlIHBvaW50IHplcm8gdG8gMDAgaW5zdGVhZCBvZiBlbmQgb2Ygc3RyaW5nXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBoZXggcmVwcmVzZW50YXRpb24gb2YgaW5wdXQgc3RyaW5nXG4gKi9cbnZhciBmcm9tVXRmOCA9IGZ1bmN0aW9uKHN0ciwgYWxsb3daZXJvKSB7XG4gICAgc3RyID0gdXRmOC5lbmNvZGUoc3RyKTtcbiAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlID09PSAwKSB7XG4gICAgICAgICAgICBpZiAoYWxsb3daZXJvKSB7XG4gICAgICAgICAgICAgICAgaGV4ICs9ICcwMCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG4gPSBjb2RlLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGhleCByZXByZXNlbnRhdGlvbiAocHJlZml4ZWQgYnkgMHgpIG9mIGFzY2lpIHN0cmluZ1xuICpcbiAqIEBtZXRob2QgZnJvbUFzY2lpXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gb3B0aW9uYWwgcGFkZGluZ1xuICogQHJldHVybnMge1N0cmluZ30gaGV4IHJlcHJlc2VudGF0aW9uIG9mIGlucHV0IHN0cmluZ1xuICovXG52YXIgZnJvbUFzY2lpID0gZnVuY3Rpb24oc3RyLCBudW0pIHtcbiAgICB2YXIgaGV4ID0gXCJcIjtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIHZhciBuID0gY29kZS50b1N0cmluZygxNik7XG4gICAgICAgIGhleCArPSBuLmxlbmd0aCA8IDIgPyAnMCcgKyBuIDogbjtcbiAgICB9XG5cbiAgICByZXR1cm4gXCIweFwiICsgaGV4LnBhZEVuZChudW0sJzAnKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIGZ1bGwgZnVuY3Rpb24vZXZlbnQgbmFtZSBmcm9tIGpzb24gYWJpXG4gKlxuICogQG1ldGhvZCB0cmFuc2Zvcm1Ub0Z1bGxOYW1lXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbi1hYmlcbiAqIEByZXR1cm4ge1N0cmluZ30gZnVsbCBmbmN0aW9uL2V2ZW50IG5hbWVcbiAqL1xudmFyIHRyYW5zZm9ybVRvRnVsbE5hbWUgPSBmdW5jdGlvbiAoanNvbikge1xuICAgIGlmIChqc29uLm5hbWUuaW5kZXhPZignKCcpICE9PSAtMSkge1xuICAgICAgICByZXR1cm4ganNvbi5uYW1lO1xuICAgIH1cblxuICAgIHZhciB0eXBlTmFtZSA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbihpKXtyZXR1cm4gaS50eXBlOyB9KS5qb2luKCk7XG4gICAgcmV0dXJuIGpzb24ubmFtZSArICcoJyArIHR5cGVOYW1lICsgJyknO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBkaXNwbGF5IG5hbWUgb2YgY29udHJhY3QgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIGV4dHJhY3REaXNwbGF5TmFtZVxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgZnVuY3Rpb24vZXZlbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGRpc3BsYXkgbmFtZSBmb3IgZnVuY3Rpb24vZXZlbnQgZWcuIG11bHRpcGx5KHVpbnQyNTYpIC0+IG11bHRpcGx5XG4gKi9cbnZhciBleHRyYWN0RGlzcGxheU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdEJyYWNrZXQgPSBuYW1lLmluZGV4T2YoJygnKTtcbiAgICB2YXIgZW5kQnJhY2tldCA9IG5hbWUuaW5kZXhPZignKScpO1xuICAgIHJldHVybiAoc3RCcmFja2V0ICE9PSAtMSAmJiBlbmRCcmFja2V0ICE9PSAtMSkgPyBuYW1lLnN1YnN0cigwLCBzdEJyYWNrZXQpIDogbmFtZTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgdHlwZSBuYW1lIG9mIGNvbnRyYWN0IGZ1bmN0aW9uXG4gKlxuICogQG1ldGhvZCBleHRyYWN0VHlwZU5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIGZ1bmN0aW9uL2V2ZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0eXBlIG5hbWUgZm9yIGZ1bmN0aW9uL2V2ZW50IGVnLiBtdWx0aXBseSh1aW50MjU2KSAtPiB1aW50MjU2XG4gKi9cbnZhciBleHRyYWN0VHlwZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHZhciBzdEJyYWNrZXQgPSBuYW1lLmluZGV4T2YoJygnKTtcbiAgICB2YXIgZW5kQnJhY2tldCA9IG5hbWUuaW5kZXhPZignKScpO1xuICAgIHJldHVybiAoc3RCcmFja2V0ICE9PSAtMSAmJiBlbmRCcmFja2V0ICE9PSAtMSkgPyBuYW1lLnN1YnN0cihzdEJyYWNrZXQgKyAxLCBlbmRCcmFja2V0IC0gc3RCcmFja2V0IC0gMSkucmVwbGFjZSgnICcsICcnKSA6IFwiXCI7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHZhbHVlIHRvIGl0J3MgZGVjaW1hbCByZXByZXNlbnRhdGlvbiBpbiBzdHJpbmdcbiAqXG4gKiBAbWV0aG9kIHRvRGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfEJpZ051bWJlcn1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvRGVjaW1hbCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0b0JpZ051bWJlcih2YWx1ZSkudG9OdW1iZXIoKTtcbn07XG5cbi8qKlxuICogQ29udmVydHMgdmFsdWUgdG8gaXQncyBoZXggcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kIGZyb21EZWNpbWFsXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfVxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG52YXIgZnJvbURlY2ltYWwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgbnVtYmVyID0gdG9CaWdOdW1iZXIodmFsdWUpO1xuICAgIHZhciByZXN1bHQgPSBudW1iZXIudG9TdHJpbmcoMTYpO1xuXG4gICAgcmV0dXJuIG51bWJlci5sZXNzVGhhbigwKSA/ICctMHgnICsgcmVzdWx0LnN1YnN0cigxKSA6ICcweCcgKyByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEF1dG8gY29udmVydHMgYW55IGdpdmVuIHZhbHVlIGludG8gaXQncyBoZXggcmVwcmVzZW50YXRpb24uXG4gKlxuICogQW5kIGV2ZW4gc3RyaW5naWZ5cyBvYmplY3RzIGJlZm9yZS5cbiAqXG4gKiBAbWV0aG9kIHRvSGV4XG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfE9iamVjdH1cbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xudmFyIHRvSGV4ID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDggKi9cblxuICAgIGlmIChpc0Jvb2xlYW4odmFsKSlcbiAgICAgICAgcmV0dXJuIGZyb21EZWNpbWFsKCt2YWwpO1xuXG4gICAgaWYgKGlzQmlnTnVtYmVyKHZhbCkpXG4gICAgICAgIHJldHVybiBmcm9tRGVjaW1hbCh2YWwpO1xuXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gZnJvbVV0ZjgoSlNPTi5zdHJpbmdpZnkodmFsKSk7XG5cbiAgICAvLyBpZiBpdHMgYSBuZWdhdGl2ZSBudW1iZXIsIHBhc3MgaXQgdGhyb3VnaCBmcm9tRGVjaW1hbFxuICAgIGlmIChpc1N0cmluZyh2YWwpKSB7XG4gICAgICAgIGlmICh2YWwuaW5kZXhPZignLTB4JykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcbiAgICAgICAgZWxzZSBpZih2YWwuaW5kZXhPZignMHgnKSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWwpKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21VdGY4KHZhbCwxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbURlY2ltYWwodmFsKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB2YWx1ZSBvZiB1bml0IGluIFdlaVxuICpcbiAqIEBtZXRob2QgZ2V0VmFsdWVPZlVuaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm5zIHtCaWdOdW1iZXJ9IHZhbHVlIG9mIHRoZSB1bml0IChpbiBXZWkpXG4gKiBAdGhyb3dzIGVycm9yIGlmIHRoZSB1bml0IGlzIG5vdCBjb3JyZWN0OndcbiAqL1xudmFyIGdldFZhbHVlT2ZVbml0ID0gZnVuY3Rpb24gKHVuaXQpIHtcbiAgICB1bml0ID0gdW5pdCA/IHVuaXQudG9Mb3dlckNhc2UoKSA6ICdldGhlcic7XG4gICAgdmFyIHVuaXRWYWx1ZSA9IHVuaXRNYXBbdW5pdF07XG4gICAgaWYgKHVuaXRWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IGRvZXNuXFwndCBleGlzdHMsIHBsZWFzZSB1c2UgdGhlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHVuaXRzJyArIEpTT04uc3RyaW5naWZ5KHVuaXRNYXAsIG51bGwsIDIpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodW5pdFZhbHVlLCAxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGEgbnVtYmVyIG9mIHdlaSBhbmQgY29udmVydHMgaXQgdG8gYW55IG90aGVyIGV0aGVyIHVuaXQuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIGZyb21XZWlcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gbnVtYmVyIGNhbiBiZSBhIG51bWJlciwgbnVtYmVyIHN0cmluZyBvciBhIEhFWCBvZiBhIGRlY2ltYWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB1bml0IHRoZSB1bml0IHRvIGNvbnZlcnQgdG8sIGRlZmF1bHQgZXRoZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xPYmplY3R9IFdoZW4gZ2l2ZW4gYSBCaWdOdW1iZXIgb2JqZWN0IGl0IHJldHVybnMgb25lIGFzIHdlbGwsIG90aGVyd2lzZSBhIG51bWJlclxuKi9cbnZhciBmcm9tV2VpID0gZnVuY3Rpb24obnVtYmVyLCB1bml0KSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gdG9CaWdOdW1iZXIobnVtYmVyKS5kaXZpZGVkQnkoZ2V0VmFsdWVPZlVuaXQodW5pdCkpO1xuXG4gICAgcmV0dXJuIGlzQmlnTnVtYmVyKG51bWJlcikgPyByZXR1cm5WYWx1ZSA6IHJldHVyblZhbHVlLnRvU3RyaW5nKDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYSBudW1iZXIgb2YgYSB1bml0IGFuZCBjb252ZXJ0cyBpdCB0byB3ZWkuXG4gKlxuICogUG9zc2libGUgdW5pdHMgYXJlOlxuICogICBTSSBTaG9ydCAgIFNJIEZ1bGwgICAgICAgIEVmZmlneSAgICAgICBPdGhlclxuICogLSBrd2VpICAgICAgIGZlbXRvZXRoZXIgICAgIGJhYmJhZ2VcbiAqIC0gbXdlaSAgICAgICBwaWNvZXRoZXIgICAgICBsb3ZlbGFjZVxuICogLSBnd2VpICAgICAgIG5hbm9ldGhlciAgICAgIHNoYW5ub24gICAgICBuYW5vXG4gKiAtIC0tICAgICAgICAgbWljcm9ldGhlciAgICAgc3phYm8gICAgICAgIG1pY3JvXG4gKiAtIC0tICAgICAgICAgbWlsbGlldGhlciAgICAgZmlubmV5ICAgICAgIG1pbGxpXG4gKiAtIGV0aGVyICAgICAgLS0gICAgICAgICAgICAgLS1cbiAqIC0ga2V0aGVyICAgICAgICAgICAgICAgICAgICAtLSAgICAgICAgICAgZ3JhbmRcbiAqIC0gbWV0aGVyXG4gKiAtIGdldGhlclxuICogLSB0ZXRoZXJcbiAqXG4gKiBAbWV0aG9kIHRvV2VpXG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8QmlnTnVtYmVyfSBudW1iZXIgY2FuIGJlIGEgbnVtYmVyLCBudW1iZXIgc3RyaW5nIG9yIGEgSEVYIG9mIGEgZGVjaW1hbFxuICogQHBhcmFtIHtTdHJpbmd9IHVuaXQgdGhlIHVuaXQgdG8gY29udmVydCBmcm9tLCBkZWZhdWx0IGV0aGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8T2JqZWN0fSBXaGVuIGdpdmVuIGEgQmlnTnVtYmVyIG9iamVjdCBpdCByZXR1cm5zIG9uZSBhcyB3ZWxsLCBvdGhlcndpc2UgYSBudW1iZXJcbiovXG52YXIgdG9XZWkgPSBmdW5jdGlvbihudW1iZXIsIHVuaXQpIHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSB0b0JpZ051bWJlcihudW1iZXIpLnRpbWVzKGdldFZhbHVlT2ZVbml0KHVuaXQpKTtcblxuICAgIHJldHVybiBpc0JpZ051bWJlcihudW1iZXIpID8gcmV0dXJuVmFsdWUgOiByZXR1cm5WYWx1ZS50b1N0cmluZygxMCk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGlucHV0IGFuZCB0cmFuc2Zvcm1zIGl0IGludG8gYW4gYmlnbnVtYmVyXG4gKlxuICogQG1ldGhvZCB0b0JpZ051bWJlclxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfEJpZ051bWJlcn0gYSBudW1iZXIsIHN0cmluZywgSEVYIHN0cmluZyBvciBCaWdOdW1iZXJcbiAqIEByZXR1cm4ge0JpZ051bWJlcn0gQmlnTnVtYmVyXG4qL1xudmFyIHRvQmlnTnVtYmVyID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG4gICAgbnVtYmVyID0gbnVtYmVyIHx8IDA7XG4gICAgaWYgKGlzQmlnTnVtYmVyKG51bWJlcikpXG4gICAgICAgIHJldHVybiBudW1iZXI7XG5cbiAgICBpZiAoaXNTdHJpbmcobnVtYmVyKSAmJiAobnVtYmVyLmluZGV4T2YoJzB4JykgPT09IDAgfHwgbnVtYmVyLmluZGV4T2YoJy0weCcpID09PSAwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihudW1iZXIucmVwbGFjZSgnMHgnLCcnKSwgMTYpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKG51bWJlci50b1N0cmluZygxMCksIDEwKTtcbn07XG5cbi8qKlxuICogVGFrZXMgYW5kIGlucHV0IHRyYW5zZm9ybXMgaXQgaW50byBiaWdudW1iZXIgYW5kIGlmIGl0IGlzIG5lZ2F0aXZlIHZhbHVlLCBpbnRvIHR3bydzIGNvbXBsZW1lbnRcbiAqXG4gKiBAbWV0aG9kIHRvVHdvc0NvbXBsZW1lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xCaWdOdW1iZXJ9XG4gKiBAcmV0dXJuIHtCaWdOdW1iZXJ9XG4gKi9cbnZhciB0b1R3b3NDb21wbGVtZW50ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICAgIHZhciBiaWdOdW1iZXIgPSB0b0JpZ051bWJlcihudW1iZXIpLnJvdW5kKCk7XG4gICAgaWYgKGJpZ051bWJlci5sZXNzVGhhbigwKSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihcImZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIiwgMTYpLnBsdXMoYmlnTnVtYmVyKS5wbHVzKDEpO1xuICAgIH1cbiAgICByZXR1cm4gYmlnTnVtYmVyO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBzdHJpY3RseSBhbiBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBpc1N0cmljdEFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cbnZhciBpc1N0cmljdEFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIHJldHVybiAvXjB4WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcyk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gc3RyaW5nIGlzIGFuIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgdGhlIGdpdmVuIEhFWCBhZHJlc3NcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xudmFyIGlzQWRkcmVzcyA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NDB9JC9pLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaGFzIHRoZSBiYXNpYyByZXF1aXJlbWVudHMgb2YgYW4gYWRkcmVzc1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmICgvXigweCk/WzAtOWEtZl17NDB9JC8udGVzdChhZGRyZXNzKSB8fCAvXigweCk/WzAtOUEtRl17NDB9JC8udGVzdChhZGRyZXNzKSkge1xuICAgICAgICAvLyBJZiBpdCdzIGFsbCBzbWFsbCBjYXBzIG9yIGFsbCBhbGwgY2FwcywgcmV0dXJuIHRydWVcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIGNoZWNrIGVhY2ggY2FzZVxuICAgICAgICByZXR1cm4gaXNDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIHN0cmluZyBpcyBhIGNoZWNrc3VtbWVkIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIGlzQ2hlY2tzdW1BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyB0aGUgZ2l2ZW4gSEVYIGFkcmVzc1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiovXG52YXIgaXNDaGVja3N1bUFkZHJlc3MgPSBmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgIC8vIENoZWNrIGVhY2ggY2FzZVxuICAgIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzLnRvTG93ZXJDYXNlKCkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0MDsgaSsrICkge1xuICAgICAgICAvLyB0aGUgbnRoIGxldHRlciBzaG91bGQgYmUgdXBwZXJjYXNlIGlmIHRoZSBudGggZGlnaXQgb2YgY2FzZW1hcCBpcyAxXG4gICAgICAgIGlmICgocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcgJiYgYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpICE9PSBhZGRyZXNzW2ldKSB8fCAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA8PSA3ICYmIGFkZHJlc3NbaV0udG9Mb3dlckNhc2UoKSAhPT0gYWRkcmVzc1tpXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblxuXG4vKipcbiAqIE1ha2VzIGEgY2hlY2tzdW0gYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgdG9DaGVja3N1bUFkZHJlc3NcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIHRoZSBnaXZlbiBIRVggYWRyZXNzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4qL1xudmFyIHRvQ2hlY2tzdW1BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAodHlwZW9mIGFkZHJlc3MgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gJyc7XG5cbiAgICBhZGRyZXNzID0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoJzB4JywnJyk7XG4gICAgdmFyIGFkZHJlc3NIYXNoID0gc2hhMyhhZGRyZXNzKTtcbiAgICB2YXIgY2hlY2tzdW1BZGRyZXNzID0gJzB4JztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWRkcmVzcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgLy8gSWYgaXRoIGNoYXJhY3RlciBpcyA5IHRvIGYgdGhlbiBtYWtlIGl0IHVwcGVyY2FzZVxuICAgICAgICBpZiAocGFyc2VJbnQoYWRkcmVzc0hhc2hbaV0sIDE2KSA+IDcpIHtcbiAgICAgICAgICBjaGVja3N1bUFkZHJlc3MgKz0gYWRkcmVzc1tpXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tzdW1BZGRyZXNzICs9IGFkZHJlc3NbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNoZWNrc3VtQWRkcmVzcztcbn07XG5cbi8qKlxuICogVHJhbnNmb3JtcyBnaXZlbiBzdHJpbmcgdG8gdmFsaWQgMjAgYnl0ZXMtbGVuZ3RoIGFkZHJlcyB3aXRoIDB4IHByZWZpeFxuICpcbiAqIEBtZXRob2QgdG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzc1xuICogQHJldHVybiB7U3RyaW5nfSBmb3JtYXR0ZWQgYWRkcmVzc1xuICovXG52YXIgdG9BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICBpZiAoaXNTdHJpY3RBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBhZGRyZXNzO1xuICAgIH1cblxuICAgIGlmICgvXlswLTlhLWZdezQwfSQvLnRlc3QoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBhZGRyZXNzO1xuICAgIH1cblxuICAgIHJldHVybiAnMHgnICsgcGFkTGVmdCh0b0hleChhZGRyZXNzKS5zdWJzdHIoMiksIDQwKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBCaWdOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCaWdOdW1iZXJcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzQmlnTnVtYmVyID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiBCaWdOdW1iZXIgfHxcbiAgICAgICAgKG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3IgJiYgb2JqZWN0LmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCaWdOdW1iZXInKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBzdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNTdHJpbmdcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAob2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvciAmJiBvYmplY3QuY29uc3RydWN0b3IubmFtZSA9PT0gJ1N0cmluZycpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqXG4gKiBAbWV0aG9kIGlzRnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmplY3QgaXMgT2JqZXQsIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgIT09IG51bGwgJiYgIShBcnJheS5pc0FycmF5KG9iamVjdCkpICYmIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqZWN0IGlzIGJvb2xlYW4sIG90aGVyd2lzZSBmYWxzZVxuICpcbiAqIEBtZXRob2QgaXNCb29sZWFuXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0Jvb2xlYW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdib29sZWFuJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iamVjdCBpcyBhcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKlxuICogQG1ldGhvZCBpc0FycmF5XG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KG9iamVjdCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgdmFsaWQganNvbiBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGlzSnNvblxuICogQHBhcmFtIHtTdHJpbmd9XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNKc29uID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiAhIUpTT04ucGFyc2Uoc3RyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBFdGhlcmV1bSBibG9jayBoZWFkZXIgYmxvb20uXG4gKlxuICogQG1ldGhvZCBpc0Jsb29tXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IGVuY29kZWQgYmxvb20gZmlsdGVyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNCbG9vbSA9IGZ1bmN0aW9uIChibG9vbSkge1xuICAgIGlmICghL14oMHgpP1swLTlhLWZdezUxMn0kL2kudGVzdChibG9vbSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoL14oMHgpP1swLTlhLWZdezUxMn0kLy50ZXN0KGJsb29tKSB8fCAvXigweCk/WzAtOUEtRl17NTEyfSQvLnRlc3QoYmxvb20pKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBnaXZlbiBzdHJpbmcgaXMgYSB2YWxpZCBsb2cgdG9waWMuXG4gKlxuICogQG1ldGhvZCBpc1RvcGljXG4gKiBAcGFyYW0ge1N0cmluZ30gaGV4IGVuY29kZWQgdG9waWNcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbnZhciBpc1RvcGljID0gZnVuY3Rpb24gKHRvcGljKSB7XG4gICAgaWYgKCEvXigweCk/WzAtOWEtZl17NjR9JC9pLnRlc3QodG9waWMpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKC9eKDB4KT9bMC05YS1mXXs2NH0kLy50ZXN0KHRvcGljKSB8fCAvXigweCk/WzAtOUEtRl17NjR9JC8udGVzdCh0b3BpYykpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHBhZExlZnQ6IHBhZExlZnQsXG4gICAgcGFkUmlnaHQ6IHBhZFJpZ2h0LFxuICAgIHRvSGV4OiB0b0hleCxcbiAgICB0b0RlY2ltYWw6IHRvRGVjaW1hbCxcbiAgICBmcm9tRGVjaW1hbDogZnJvbURlY2ltYWwsXG4gICAgdG9VdGY4OiB0b1V0ZjgsXG4gICAgdG9Bc2NpaTogdG9Bc2NpaSxcbiAgICBmcm9tVXRmODogZnJvbVV0ZjgsXG4gICAgZnJvbUFzY2lpOiBmcm9tQXNjaWksXG4gICAgdHJhbnNmb3JtVG9GdWxsTmFtZTogdHJhbnNmb3JtVG9GdWxsTmFtZSxcbiAgICBleHRyYWN0RGlzcGxheU5hbWU6IGV4dHJhY3REaXNwbGF5TmFtZSxcbiAgICBleHRyYWN0VHlwZU5hbWU6IGV4dHJhY3RUeXBlTmFtZSxcbiAgICB0b1dlaTogdG9XZWksXG4gICAgZnJvbVdlaTogZnJvbVdlaSxcbiAgICB0b0JpZ051bWJlcjogdG9CaWdOdW1iZXIsXG4gICAgdG9Ud29zQ29tcGxlbWVudDogdG9Ud29zQ29tcGxlbWVudCxcbiAgICB0b0FkZHJlc3M6IHRvQWRkcmVzcyxcbiAgICBpc0JpZ051bWJlcjogaXNCaWdOdW1iZXIsXG4gICAgaXNTdHJpY3RBZGRyZXNzOiBpc1N0cmljdEFkZHJlc3MsXG4gICAgaXNBZGRyZXNzOiBpc0FkZHJlc3MsXG4gICAgaXNDaGVja3N1bUFkZHJlc3M6IGlzQ2hlY2tzdW1BZGRyZXNzLFxuICAgIHRvQ2hlY2tzdW1BZGRyZXNzOiB0b0NoZWNrc3VtQWRkcmVzcyxcbiAgICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICAgIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgICBpc09iamVjdDogaXNPYmplY3QsXG4gICAgaXNCb29sZWFuOiBpc0Jvb2xlYW4sXG4gICAgaXNBcnJheTogaXNBcnJheSxcbiAgICBpc0pzb246IGlzSnNvbixcbiAgICBpc0Jsb29tOiBpc0Jsb29tLFxuICAgIGlzVG9waWM6IGlzVG9waWMsXG59O1xuIiwibW9kdWxlLmV4cG9ydHM9e1xuICAgIFwidmVyc2lvblwiOiBcIjAuMjAuN1wiXG59XG4iLCIvKiFcbiAqIHdlYjMuanMgLSBFdGhlcmV1bSBKYXZhU2NyaXB0IEFQSVxuICpcbiAqIEBsaWNlbnNlIGxncGwtMy4wXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93ZWIzLmpzXG4qL1xuXG4vKlxuICogVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cbiAqIFxuICogd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gKiAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICogXG4gKiB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKiBcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICpcbiAqIEBmaWxlIHdlYjMuanNcbiAqIEBhdXRob3JzOlxuICogICBKZWZmcmV5IFdpbGNrZSA8amVmZkBldGhkZXYuY29tPlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqICAgTWFyaWFuIE9hbmNlYSA8bWFyaWFuQGV0aGRldi5jb20+XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogICBHYXYgV29vZCA8Z0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciBSZXF1ZXN0TWFuYWdlciA9IHJlcXVpcmUoJy4vd2ViMy9yZXF1ZXN0bWFuYWdlcicpO1xudmFyIEliYW4gPSByZXF1aXJlKCcuL3dlYjMvaWJhbicpO1xudmFyIEV0aCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL2V0aCcpO1xudmFyIERCID0gcmVxdWlyZSgnLi93ZWIzL21ldGhvZHMvZGInKTtcbnZhciBTaGggPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9zaGgnKTtcbnZhciBOZXQgPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9uZXQnKTtcbnZhciBQZXJzb25hbCA9IHJlcXVpcmUoJy4vd2ViMy9tZXRob2RzL3BlcnNvbmFsJyk7XG52YXIgU3dhcm0gPSByZXF1aXJlKCcuL3dlYjMvbWV0aG9kcy9zd2FybScpO1xudmFyIFNldHRpbmdzID0gcmVxdWlyZSgnLi93ZWIzL3NldHRpbmdzJyk7XG52YXIgdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbi5qc29uJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3V0aWxzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJy4vdXRpbHMvc2hhMycpO1xudmFyIGV4dGVuZCA9IHJlcXVpcmUoJy4vd2ViMy9leHRlbmQnKTtcbnZhciBCYXRjaCA9IHJlcXVpcmUoJy4vd2ViMy9iYXRjaCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi93ZWIzL3Byb3BlcnR5Jyk7XG52YXIgSHR0cFByb3ZpZGVyID0gcmVxdWlyZSgnLi93ZWIzL2h0dHBwcm92aWRlcicpO1xudmFyIElwY1Byb3ZpZGVyID0gcmVxdWlyZSgnLi93ZWIzL2lwY3Byb3ZpZGVyJyk7XG52YXIgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5cblxuXG5mdW5jdGlvbiBXZWIzIChwcm92aWRlcikge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gbmV3IFJlcXVlc3RNYW5hZ2VyKHByb3ZpZGVyKTtcbiAgICB0aGlzLmN1cnJlbnRQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIHRoaXMuZXRoID0gbmV3IEV0aCh0aGlzKTtcbiAgICB0aGlzLmRiID0gbmV3IERCKHRoaXMpO1xuICAgIHRoaXMuc2hoID0gbmV3IFNoaCh0aGlzKTtcbiAgICB0aGlzLm5ldCA9IG5ldyBOZXQodGhpcyk7XG4gICAgdGhpcy5wZXJzb25hbCA9IG5ldyBQZXJzb25hbCh0aGlzKTtcbiAgICB0aGlzLmJ6eiA9IG5ldyBTd2FybSh0aGlzKTtcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG4gICAgdGhpcy52ZXJzaW9uID0ge1xuICAgICAgICBhcGk6IHZlcnNpb24udmVyc2lvblxuICAgIH07XG4gICAgdGhpcy5wcm92aWRlcnMgPSB7XG4gICAgICAgIEh0dHBQcm92aWRlcjogSHR0cFByb3ZpZGVyLFxuICAgICAgICBJcGNQcm92aWRlcjogSXBjUHJvdmlkZXJcbiAgICB9O1xuICAgIHRoaXMuX2V4dGVuZCA9IGV4dGVuZCh0aGlzKTtcbiAgICB0aGlzLl9leHRlbmQoe1xuICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzKClcbiAgICB9KTtcbn1cblxuLy8gZXhwb3NlIHByb3ZpZGVycyBvbiB0aGUgY2xhc3NcbldlYjMucHJvdmlkZXJzID0ge1xuICAgIEh0dHBQcm92aWRlcjogSHR0cFByb3ZpZGVyLFxuICAgIElwY1Byb3ZpZGVyOiBJcGNQcm92aWRlclxufTtcblxuV2ViMy5wcm90b3R5cGUuc2V0UHJvdmlkZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlci5zZXRQcm92aWRlcihwcm92aWRlcik7XG4gICAgdGhpcy5jdXJyZW50UHJvdmlkZXIgPSBwcm92aWRlcjtcbn07XG5cbldlYjMucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKGtlZXBJc1N5bmNpbmcpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlci5yZXNldChrZWVwSXNTeW5jaW5nKTtcbiAgICB0aGlzLnNldHRpbmdzID0gbmV3IFNldHRpbmdzKCk7XG59O1xuXG5XZWIzLnByb3RvdHlwZS5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XG5XZWIzLnByb3RvdHlwZS50b0hleCA9IHV0aWxzLnRvSGV4O1xuV2ViMy5wcm90b3R5cGUudG9Bc2NpaSA9IHV0aWxzLnRvQXNjaWk7XG5XZWIzLnByb3RvdHlwZS50b1V0ZjggPSB1dGlscy50b1V0Zjg7XG5XZWIzLnByb3RvdHlwZS5mcm9tQXNjaWkgPSB1dGlscy5mcm9tQXNjaWk7XG5XZWIzLnByb3RvdHlwZS5mcm9tVXRmOCA9IHV0aWxzLmZyb21VdGY4O1xuV2ViMy5wcm90b3R5cGUudG9EZWNpbWFsID0gdXRpbHMudG9EZWNpbWFsO1xuV2ViMy5wcm90b3R5cGUuZnJvbURlY2ltYWwgPSB1dGlscy5mcm9tRGVjaW1hbDtcbldlYjMucHJvdG90eXBlLnRvQmlnTnVtYmVyID0gdXRpbHMudG9CaWdOdW1iZXI7XG5XZWIzLnByb3RvdHlwZS50b1dlaSA9IHV0aWxzLnRvV2VpO1xuV2ViMy5wcm90b3R5cGUuZnJvbVdlaSA9IHV0aWxzLmZyb21XZWk7XG5XZWIzLnByb3RvdHlwZS5pc0FkZHJlc3MgPSB1dGlscy5pc0FkZHJlc3M7XG5XZWIzLnByb3RvdHlwZS5pc0NoZWNrc3VtQWRkcmVzcyA9IHV0aWxzLmlzQ2hlY2tzdW1BZGRyZXNzO1xuV2ViMy5wcm90b3R5cGUudG9DaGVja3N1bUFkZHJlc3MgPSB1dGlscy50b0NoZWNrc3VtQWRkcmVzcztcbldlYjMucHJvdG90eXBlLmlzSUJBTiA9IHV0aWxzLmlzSUJBTjtcbldlYjMucHJvdG90eXBlLnBhZExlZnQgPSB1dGlscy5wYWRMZWZ0O1xuV2ViMy5wcm90b3R5cGUucGFkUmlnaHQgPSB1dGlscy5wYWRSaWdodDtcblxuXG5XZWIzLnByb3RvdHlwZS5zaGEzID0gZnVuY3Rpb24oc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuICcweCcgKyBzaGEzKHN0cmluZywgb3B0aW9ucyk7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgZGlyZWN0IGljYXAgdG8gYWRkcmVzc1xuICovXG5XZWIzLnByb3RvdHlwZS5mcm9tSUNBUCA9IGZ1bmN0aW9uIChpY2FwKSB7XG4gICAgdmFyIGliYW4gPSBuZXcgSWJhbihpY2FwKTtcbiAgICByZXR1cm4gaWJhbi5hZGRyZXNzKCk7XG59O1xuXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24ubm9kZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICd3ZWIzX2NsaWVudFZlcnNpb24nXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24ubmV0d29yaycsXG4gICAgICAgICAgICBnZXR0ZXI6ICduZXRfdmVyc2lvbicsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24uZXRoZXJldW0nLFxuICAgICAgICAgICAgZ2V0dGVyOiAnZXRoX3Byb3RvY29sVmVyc2lvbicsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3ZlcnNpb24ud2hpc3BlcicsXG4gICAgICAgICAgICBnZXR0ZXI6ICdzaGhfdmVyc2lvbicsXG4gICAgICAgICAgICBpbnB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pXG4gICAgXTtcbn07XG5cbldlYjMucHJvdG90eXBlLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gKHRoaXMuY3VycmVudFByb3ZpZGVyICYmIHRoaXMuY3VycmVudFByb3ZpZGVyLmlzQ29ubmVjdGVkKCkpO1xufTtcblxuV2ViMy5wcm90b3R5cGUuY3JlYXRlQmF0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBCYXRjaCh0aGlzKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViMztcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgYWxsZXZlbnRzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xudmFyIFNvbGlkaXR5RXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIHdhdGNoZXMgPSByZXF1aXJlKCcuL21ldGhvZHMvd2F0Y2hlcycpO1xuXG52YXIgQWxsU29saWRpdHlFdmVudHMgPSBmdW5jdGlvbiAocmVxdWVzdE1hbmFnZXIsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHJlcXVlc3RNYW5hZ2VyO1xuICAgIHRoaXMuX2pzb24gPSBqc29uO1xuICAgIHRoaXMuX2FkZHJlc3MgPSBhZGRyZXNzO1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgWydmcm9tQmxvY2snLCAndG9CbG9jayddLmZpbHRlcihmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gb3B0aW9uc1tmXSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmVzdWx0W2ZdID0gZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyKG9wdGlvbnNbZl0pO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0LmFkZHJlc3MgPSB0aGlzLl9hZGRyZXNzO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkFsbFNvbGlkaXR5RXZlbnRzLnByb3RvdHlwZS5kZWNvZGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEuZGF0YSA9IGRhdGEuZGF0YSB8fCAnJztcblxuXG4gICAgdmFyIGV2ZW50VG9waWMgPSAodXRpbHMuaXNBcnJheShkYXRhLnRvcGljcykgJiYgdXRpbHMuaXNTdHJpbmcoZGF0YS50b3BpY3NbMF0pKSA/IGRhdGEudG9waWNzWzBdLnNsaWNlKDIpIDogJyc7XG4gICAgdmFyIG1hdGNoID0gdGhpcy5fanNvbi5maWx0ZXIoZnVuY3Rpb24gKGopIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50VG9waWMgPT09IHNoYTModXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqKSk7XG4gICAgfSlbMF07XG5cbiAgICBpZiAoIW1hdGNoKSB7IC8vIGNhbm5vdCBmaW5kIG1hdGNoaW5nIGV2ZW50P1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIoZGF0YSk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50ID0gbmV3IFNvbGlkaXR5RXZlbnQodGhpcy5fcmVxdWVzdE1hbmFnZXIsIG1hdGNoLCB0aGlzLl9hZGRyZXNzKTtcbiAgICByZXR1cm4gZXZlbnQuZGVjb2RlKGRhdGEpO1xufTtcblxuQWxsU29saWRpdHlFdmVudHMucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAob3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUob3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIobywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXIsIGNhbGxiYWNrKTtcbn07XG5cbkFsbFNvbGlkaXR5RXZlbnRzLnByb3RvdHlwZS5hdHRhY2hUb0NvbnRyYWN0ID0gZnVuY3Rpb24gKGNvbnRyYWN0KSB7XG4gICAgdmFyIGV4ZWN1dGUgPSB0aGlzLmV4ZWN1dGUuYmluZCh0aGlzKTtcbiAgICBjb250cmFjdC5hbGxFdmVudHMgPSBleGVjdXRlO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGxTb2xpZGl0eUV2ZW50cztcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGJhdGNoLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBKc29ucnBjID0gcmVxdWlyZSgnLi9qc29ucnBjJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxudmFyIEJhdGNoID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5yZXF1ZXN0cyA9IFtdO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFkZCBjcmVhdGUgbmV3IHJlcXVlc3QgdG8gYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgYWRkXG4gKiBAcGFyYW0ge09iamVjdH0ganNvbnJwYyByZXF1ZXQgb2JqZWN0XG4gKi9cbkJhdGNoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgIHRoaXMucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBleGVjdXRlIGJhdGNoIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqL1xuQmF0Y2gucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlcXVlc3RzID0gdGhpcy5yZXF1ZXN0cztcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyLnNlbmRCYXRjaChyZXF1ZXN0cywgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcbiAgICAgICAgcmVxdWVzdHMubWFwKGZ1bmN0aW9uIChyZXF1ZXN0LCBpbmRleCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbaW5kZXhdIHx8IHt9O1xuICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uIChyZXN1bHQsIGluZGV4KSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdHNbaW5kZXhdLmNhbGxiYWNrKSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RzW2luZGV4XS5jYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlcXVlc3RzW2luZGV4XS5jYWxsYmFjayhudWxsLCAocmVxdWVzdHNbaW5kZXhdLmZvcm1hdCA/IHJlcXVlc3RzW2luZGV4XS5mb3JtYXQocmVzdWx0LnJlc3VsdCkgOiByZXN1bHQucmVzdWx0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pOyBcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQmF0Y2g7XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGNvbnRyYWN0LmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNFxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIFNvbGlkaXR5RXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50Jyk7XG52YXIgU29saWRpdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZnVuY3Rpb24nKTtcbnZhciBBbGxFdmVudHMgPSByZXF1aXJlKCcuL2FsbGV2ZW50cycpO1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZW5jb2RlIGNvbnN0cnVjdG9yIHBhcmFtc1xuICpcbiAqIEBtZXRob2QgZW5jb2RlQ29uc3RydWN0b3JQYXJhbXNcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICogQHBhcmFtIHtBcnJheX0gY29uc3RydWN0b3IgcGFyYW1zXG4gKi9cbnZhciBlbmNvZGVDb25zdHJ1Y3RvclBhcmFtcyA9IGZ1bmN0aW9uIChhYmksIHBhcmFtcykge1xuICAgIHJldHVybiBhYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdjb25zdHJ1Y3RvcicgJiYganNvbi5pbnB1dHMubGVuZ3RoID09PSBwYXJhbXMubGVuZ3RoO1xuICAgIH0pLm1hcChmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4ganNvbi5pbnB1dHMubWFwKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LnR5cGU7XG4gICAgICAgIH0pO1xuICAgIH0pLm1hcChmdW5jdGlvbiAodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVyLmVuY29kZVBhcmFtcyh0eXBlcywgcGFyYW1zKTtcbiAgICB9KVswXSB8fCAnJztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgZnVuY3Rpb25zIHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYWRkRnVuY3Rpb25zVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgYWRkRnVuY3Rpb25zVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIGNvbnRyYWN0LmFiaS5maWx0ZXIoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2Z1bmN0aW9uJztcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGpzb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTb2xpZGl0eUZ1bmN0aW9uKGNvbnRyYWN0Ll9ldGgsIGpzb24sIGNvbnRyYWN0LmFkZHJlc3MpO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgZi5hdHRhY2hUb0NvbnRyYWN0KGNvbnRyYWN0KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBhZGQgZXZlbnRzIHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYWRkRXZlbnRzVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH0gY29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgYWRkRXZlbnRzVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBldmVudHMgPSBjb250cmFjdC5hYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBqc29uLnR5cGUgPT09ICdldmVudCc7XG4gICAgfSk7XG5cbiAgICB2YXIgQWxsID0gbmV3IEFsbEV2ZW50cyhjb250cmFjdC5fZXRoLl9yZXF1ZXN0TWFuYWdlciwgZXZlbnRzLCBjb250cmFjdC5hZGRyZXNzKTtcbiAgICBBbGwuYXR0YWNoVG9Db250cmFjdChjb250cmFjdCk7XG5cbiAgICBldmVudHMubWFwKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgIHJldHVybiBuZXcgU29saWRpdHlFdmVudChjb250cmFjdC5fZXRoLl9yZXF1ZXN0TWFuYWdlciwganNvbiwgY29udHJhY3QuYWRkcmVzcyk7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLmF0dGFjaFRvQ29udHJhY3QoY29udHJhY3QpO1xuICAgIH0pO1xufTtcblxuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIGNvbnRyYWN0IGdldHMgcHJvcGVybHkgZGVwbG95ZWQgb24gdGhlIGJsb2NrY2hhaW4uXG4gKlxuICogQG1ldGhvZCBjaGVja0ZvckNvbnRyYWN0QWRkcmVzc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRyYWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge1VuZGVmaW5lZH1cbiAqL1xudmFyIGNoZWNrRm9yQ29udHJhY3RBZGRyZXNzID0gZnVuY3Rpb24oY29udHJhY3QsIGNhbGxiYWNrKXtcbiAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICBjYWxsYmFja0ZpcmVkID0gZmFsc2U7XG5cbiAgICAvLyB3YWl0IGZvciByZWNlaXB0XG4gICAgdmFyIGZpbHRlciA9IGNvbnRyYWN0Ll9ldGguZmlsdGVyKCdsYXRlc3QnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYgKCFlICYmICFjYWxsYmFja0ZpcmVkKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuXG4gICAgICAgICAgICAvLyBzdG9wIHdhdGNoaW5nIGFmdGVyIDUwIGJsb2NrcyAodGltZW91dClcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDUwKSB7XG5cbiAgICAgICAgICAgICAgICBmaWx0ZXIuc3RvcFdhdGNoaW5nKGZ1bmN0aW9uKCkge30pO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrRmlyZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoJ0NvbnRyYWN0IHRyYW5zYWN0aW9uIGNvdWxkblxcJ3QgYmUgZm91bmQgYWZ0ZXIgNTAgYmxvY2tzJykpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCB0cmFuc2FjdGlvbiBjb3VsZG5cXCd0IGJlIGZvdW5kIGFmdGVyIDUwIGJsb2NrcycpO1xuXG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICBjb250cmFjdC5fZXRoLmdldFRyYW5zYWN0aW9uUmVjZWlwdChjb250cmFjdC50cmFuc2FjdGlvbkhhc2gsIGZ1bmN0aW9uKGUsIHJlY2VpcHQpe1xuICAgICAgICAgICAgICAgICAgICBpZihyZWNlaXB0ICYmIHJlY2VpcHQuYmxvY2tIYXNoICYmICFjYWxsYmFja0ZpcmVkKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0Ll9ldGguZ2V0Q29kZShyZWNlaXB0LmNvbnRyYWN0QWRkcmVzcywgZnVuY3Rpb24oZSwgY29kZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTogNiAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2FsbGJhY2tGaXJlZCB8fCAhY29kZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLnN0b3BXYXRjaGluZyhmdW5jdGlvbigpIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja0ZpcmVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNvZGUubGVuZ3RoID4gMykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdDb250cmFjdCBjb2RlIGRlcGxveWVkIScpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyYWN0LmFkZHJlc3MgPSByZWNlaXB0LmNvbnRyYWN0QWRkcmVzcztcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhdHRhY2ggZXZlbnRzIGFuZCBtZXRob2RzIGFnYWluIGFmdGVyIHdlIGhhdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRnVuY3Rpb25zVG9Db250cmFjdChjb250cmFjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEV2ZW50c1RvQ29udHJhY3QoY29udHJhY3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNhbGwgY2FsbGJhY2sgZm9yIHRoZSBzZWNvbmQgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbnRyYWN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKCdUaGUgY29udHJhY3QgY29kZSBjb3VsZG5cXCd0IGJlIHN0b3JlZCwgcGxlYXNlIGNoZWNrIHlvdXIgZ2FzIGFtb3VudC4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGNvbnRyYWN0IGNvZGUgY291bGRuXFwndCBiZSBzdG9yZWQsIHBsZWFzZSBjaGVjayB5b3VyIGdhcyBhbW91bnQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgQ29udHJhY3RGYWN0b3J5IGluc3RhbmNlXG4gKlxuICogQG1ldGhvZCBDb250cmFjdEZhY3RvcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICovXG52YXIgQ29udHJhY3RGYWN0b3J5ID0gZnVuY3Rpb24gKGV0aCwgYWJpKSB7XG4gICAgdGhpcy5ldGggPSBldGg7XG4gICAgdGhpcy5hYmkgPSBhYmk7XG5cbiAgICAvKipcbiAgICAgKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBuZXcgY29udHJhY3Qgb24gYSBibG9ja2NoYWluXG4gICAgICpcbiAgICAgKiBAbWV0aG9kIG5ld1xuICAgICAqIEBwYXJhbSB7QW55fSBjb250cmFjdCBjb25zdHJ1Y3RvciBwYXJhbTEgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSB7QW55fSBjb250cmFjdCBjb25zdHJ1Y3RvciBwYXJhbTIgKG9wdGlvbmFsKVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb250cmFjdCB0cmFuc2FjdGlvbiBvYmplY3QgKHJlcXVpcmVkKVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICogQHJldHVybnMge0NvbnRyYWN0fSByZXR1cm5zIGNvbnRyYWN0IGluc3RhbmNlXG4gICAgICovXG4gICAgdGhpcy5uZXcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDcgKi9cblxuICAgICAgICB2YXIgY29udHJhY3QgPSBuZXcgQ29udHJhY3QodGhpcy5ldGgsIHRoaXMuYWJpKTtcblxuICAgICAgICAvLyBwYXJzZSBhcmd1bWVudHNcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7fTsgLy8gcmVxdWlyZWQhXG4gICAgICAgIHZhciBjYWxsYmFjaztcblxuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXJncy5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0ID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodXRpbHMuaXNPYmplY3QobGFzdCkgJiYgIXV0aWxzLmlzQXJyYXkobGFzdCkpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBhcmdzLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudmFsdWUgPiAwKSB7XG4gICAgICAgICAgICB2YXIgY29uc3RydWN0b3JBYmkgPSBhYmkuZmlsdGVyKGZ1bmN0aW9uIChqc29uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb24udHlwZSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiBqc29uLmlucHV0cy5sZW5ndGggPT09IGFyZ3MubGVuZ3RoO1xuICAgICAgICAgICAgfSlbMF0gfHwge307XG5cbiAgICAgICAgICAgIGlmICghY29uc3RydWN0b3JBYmkucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNlbmQgdmFsdWUgdG8gbm9uLXBheWFibGUgY29uc3RydWN0b3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBieXRlcyA9IGVuY29kZUNvbnN0cnVjdG9yUGFyYW1zKHRoaXMuYWJpLCBhcmdzKTtcbiAgICAgICAgb3B0aW9ucy5kYXRhICs9IGJ5dGVzO1xuXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuXG4gICAgICAgICAgICAvLyB3YWl0IGZvciB0aGUgY29udHJhY3QgYWRkcmVzcyBhbmQgY2hlY2sgaWYgdGhlIGNvZGUgd2FzIGRlcGxveWVkXG4gICAgICAgICAgICB0aGlzLmV0aC5zZW5kVHJhbnNhY3Rpb24ob3B0aW9ucywgZnVuY3Rpb24gKGVyciwgaGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAgICAgY29udHJhY3QudHJhbnNhY3Rpb25IYXNoID0gaGFzaDtcblxuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIGNhbGxiYWNrIGZvciB0aGUgZmlyc3QgdGltZVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBjb250cmFjdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2hlY2tGb3JDb250cmFjdEFkZHJlc3MoY29udHJhY3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5ldGguc2VuZFRyYW5zYWN0aW9uKG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gYWRkIHRoZSB0cmFuc2FjdGlvbiBoYXNoXG4gICAgICAgICAgICBjb250cmFjdC50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgY2hlY2tGb3JDb250cmFjdEFkZHJlc3MoY29udHJhY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0O1xuICAgIH07XG5cbiAgICB0aGlzLm5ldy5nZXREYXRhID0gdGhpcy5nZXREYXRhLmJpbmQodGhpcyk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBDb250cmFjdEZhY3RvcnlcbiAqXG4gKiBAbWV0aG9kIGNvbnRyYWN0XG4gKiBAcGFyYW0ge0FycmF5fSBhYmlcbiAqIEByZXR1cm5zIHtDb250cmFjdEZhY3Rvcnl9IG5ldyBjb250cmFjdCBmYWN0b3J5XG4gKi9cbi8vdmFyIGNvbnRyYWN0ID0gZnVuY3Rpb24gKGFiaSkge1xuICAgIC8vcmV0dXJuIG5ldyBDb250cmFjdEZhY3RvcnkoYWJpKTtcbi8vfTtcblxuXG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgYWNjZXNzIHRvIGV4aXN0aW5nIGNvbnRyYWN0IG9uIGEgYmxvY2tjaGFpblxuICpcbiAqIEBtZXRob2QgYXRcbiAqIEBwYXJhbSB7QWRkcmVzc30gY29udHJhY3QgYWRkcmVzcyAocmVxdWlyZWQpXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB7b3B0aW9uYWwpXG4gKiBAcmV0dXJucyB7Q29udHJhY3R9IHJldHVybnMgY29udHJhY3QgaWYgbm8gY2FsbGJhY2sgd2FzIHBhc3NlZCxcbiAqIG90aGVyd2lzZSBjYWxscyBjYWxsYmFjayBmdW5jdGlvbiAoZXJyLCBjb250cmFjdClcbiAqL1xuQ29udHJhY3RGYWN0b3J5LnByb3RvdHlwZS5hdCA9IGZ1bmN0aW9uIChhZGRyZXNzLCBjYWxsYmFjaykge1xuICAgIHZhciBjb250cmFjdCA9IG5ldyBDb250cmFjdCh0aGlzLmV0aCwgdGhpcy5hYmksIGFkZHJlc3MpO1xuXG4gICAgLy8gdGhpcyBmdW5jdGlvbnMgYXJlIG5vdCBwYXJ0IG9mIHByb3RvdHlwZSxcbiAgICAvLyBiZWNhdXNlIHdlIGRvbnQgd2FudCB0byBzcG9pbCB0aGUgaW50ZXJmYWNlXG4gICAgYWRkRnVuY3Rpb25zVG9Db250cmFjdChjb250cmFjdCk7XG4gICAgYWRkRXZlbnRzVG9Db250cmFjdChjb250cmFjdCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY29udHJhY3QpO1xuICAgIH1cbiAgICByZXR1cm4gY29udHJhY3Q7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGRhdGEsIHdoaWNoIGlzIGRhdGEgdG8gZGVwbG95IHBsdXMgY29uc3RydWN0b3IgcGFyYW1zXG4gKlxuICogQG1ldGhvZCBnZXREYXRhXG4gKi9cbkNvbnRyYWN0RmFjdG9yeS5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9OyAvLyByZXF1aXJlZCFcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICB2YXIgbGFzdCA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICBpZiAodXRpbHMuaXNPYmplY3QobGFzdCkgJiYgIXV0aWxzLmlzQXJyYXkobGFzdCkpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3MucG9wKCk7XG4gICAgfVxuXG4gICAgdmFyIGJ5dGVzID0gZW5jb2RlQ29uc3RydWN0b3JQYXJhbXModGhpcy5hYmksIGFyZ3MpO1xuICAgIG9wdGlvbnMuZGF0YSArPSBieXRlcztcblxuICAgIHJldHVybiBvcHRpb25zLmRhdGE7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY3JlYXRlIG5ldyBjb250cmFjdCBpbnN0YW5jZVxuICpcbiAqIEBtZXRob2QgQ29udHJhY3RcbiAqIEBwYXJhbSB7QXJyYXl9IGFiaVxuICogQHBhcmFtIHtBZGRyZXNzfSBjb250cmFjdCBhZGRyZXNzXG4gKi9cbnZhciBDb250cmFjdCA9IGZ1bmN0aW9uIChldGgsIGFiaSwgYWRkcmVzcykge1xuICAgIHRoaXMuX2V0aCA9IGV0aDtcbiAgICB0aGlzLnRyYW5zYWN0aW9uSGFzaCA9IG51bGw7XG4gICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLmFiaSA9IGFiaTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29udHJhY3RGYWN0b3J5O1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBcbiAqIEBmaWxlIGVycm9ycy5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBJbnZhbGlkTnVtYmVyT2ZTb2xpZGl0eUFyZ3M6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIHRvIFNvbGlkaXR5IGZ1bmN0aW9uJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgaW5wdXQgcGFyYW1ldGVycyB0byBSUEMgbWV0aG9kJyk7XG4gICAgfSxcbiAgICBJbnZhbGlkQ29ubmVjdGlvbjogZnVuY3Rpb24gKGhvc3Qpe1xuICAgICAgICByZXR1cm4gbmV3IEVycm9yKCdDT05ORUNUSU9OIEVSUk9SOiBDb3VsZG5cXCd0IGNvbm5lY3QgdG8gbm9kZSAnKyBob3N0ICsnLicpO1xuICAgIH0sXG4gICAgSW52YWxpZFByb3ZpZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1Byb3ZpZGVyIG5vdCBzZXQgb3IgaW52YWxpZCcpO1xuICAgIH0sXG4gICAgSW52YWxpZFJlc3BvbnNlOiBmdW5jdGlvbiAocmVzdWx0KXtcbiAgICAgICAgdmFyIG1lc3NhZ2UgPSAhIXJlc3VsdCAmJiAhIXJlc3VsdC5lcnJvciAmJiAhIXJlc3VsdC5lcnJvci5tZXNzYWdlID8gcmVzdWx0LmVycm9yLm1lc3NhZ2UgOiAnSW52YWxpZCBKU09OIFJQQyByZXNwb25zZTogJyArIEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSxcbiAgICBDb25uZWN0aW9uVGltZW91dDogZnVuY3Rpb24gKG1zKXtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignQ09OTkVDVElPTiBUSU1FT1VUOiB0aW1lb3V0IG9mICcgKyBtcyArICcgbXMgYWNoaXZlZCcpO1xuICAgIH1cbn07XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBldmVudC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xudmFyIGNvZGVyID0gcmVxdWlyZSgnLi4vc29saWRpdHkvY29kZXInKTtcbnZhciBmb3JtYXR0ZXJzID0gcmVxdWlyZSgnLi9mb3JtYXR0ZXJzJyk7XG52YXIgc2hhMyA9IHJlcXVpcmUoJy4uL3V0aWxzL3NoYTMnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuL2ZpbHRlcicpO1xudmFyIHdhdGNoZXMgPSByZXF1aXJlKCcuL21ldGhvZHMvd2F0Y2hlcycpO1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBldmVudCBmaWx0ZXJzXG4gKi9cbnZhciBTb2xpZGl0eUV2ZW50ID0gZnVuY3Rpb24gKHJlcXVlc3RNYW5hZ2VyLCBqc29uLCBhZGRyZXNzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSByZXF1ZXN0TWFuYWdlcjtcbiAgICB0aGlzLl9wYXJhbXMgPSBqc29uLmlucHV0cztcbiAgICB0aGlzLl9uYW1lID0gdXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqc29uKTtcbiAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbiAgICB0aGlzLl9hbm9ueW1vdXMgPSBqc29uLmFub255bW91cztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZpbHRlcmVkIHBhcmFtIHR5cGVzXG4gKlxuICogQG1ldGhvZCB0eXBlc1xuICogQHBhcmFtIHtCb29sfSBkZWNpZGUgaWYgcmV0dXJuZWQgdHlwZWQgc2hvdWxkIGJlIGluZGV4ZWRcbiAqIEByZXR1cm4ge0FycmF5fSBhcnJheSBvZiB0eXBlc1xuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS50eXBlcyA9IGZ1bmN0aW9uIChpbmRleGVkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkuaW5kZXhlZCA9PT0gaW5kZXhlZDtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkudHlwZTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGV2ZW50IGRpc3BsYXkgbmFtZVxuICpcbiAqIEBtZXRob2QgZGlzcGxheU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gZXZlbnQgZGlzcGxheSBuYW1lXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmRpc3BsYXlOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1dGlscy5leHRyYWN0RGlzcGxheU5hbWUodGhpcy5fbmFtZSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBldmVudCB0eXBlIG5hbWVcbiAqXG4gKiBAbWV0aG9kIHR5cGVOYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGV2ZW50IHR5cGUgbmFtZVxuICovXG5Tb2xpZGl0eUV2ZW50LnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdFR5cGVOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBnZXQgZXZlbnQgc2lnbmF0dXJlXG4gKlxuICogQG1ldGhvZCBzaWduYXR1cmVcbiAqIEByZXR1cm4ge1N0cmluZ30gZXZlbnQgc2lnbmF0dXJlXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLnNpZ25hdHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2hhMyh0aGlzLl9uYW1lKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZW5jb2RlIGluZGV4ZWQgcGFyYW1zIGFuZCBvcHRpb25zIHRvIG9uZSBmaW5hbCBvYmplY3RcbiAqXG4gKiBAbWV0aG9kIGVuY29kZVxuICogQHBhcmFtIHtPYmplY3R9IGluZGV4ZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGV2ZXJ5dGhpbmcgY29tYmluZWQgdG9nZXRoZXIgYW5kIGVuY29kZWRcbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gKGluZGV4ZWQsIG9wdGlvbnMpIHtcbiAgICBpbmRleGVkID0gaW5kZXhlZCB8fCB7fTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgcmVzdWx0ID0ge307XG5cbiAgICBbJ2Zyb21CbG9jaycsICd0b0Jsb2NrJ10uZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zW2ZdICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICByZXN1bHRbZl0gPSBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9uc1tmXSk7XG4gICAgfSk7XG5cbiAgICByZXN1bHQudG9waWNzID0gW107XG5cbiAgICByZXN1bHQuYWRkcmVzcyA9IHRoaXMuX2FkZHJlc3M7XG4gICAgaWYgKCF0aGlzLl9hbm9ueW1vdXMpIHtcbiAgICAgICAgcmVzdWx0LnRvcGljcy5wdXNoKCcweCcgKyB0aGlzLnNpZ25hdHVyZSgpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXhlZFRvcGljcyA9IHRoaXMuX3BhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgcmV0dXJuIGkuaW5kZXhlZCA9PT0gdHJ1ZTtcbiAgICB9KS5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaW5kZXhlZFtpLm5hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJzB4JyArIGNvZGVyLmVuY29kZVBhcmFtKGkudHlwZSwgdik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJzB4JyArIGNvZGVyLmVuY29kZVBhcmFtKGkudHlwZSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgcmVzdWx0LnRvcGljcyA9IHJlc3VsdC50b3BpY3MuY29uY2F0KGluZGV4ZWRUb3BpY3MpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGVjb2RlIGluZGV4ZWQgcGFyYW1zIGFuZCBvcHRpb25zXG4gKlxuICogQG1ldGhvZCBkZWNvZGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdCBvYmplY3Qgd2l0aCBkZWNvZGVkIGluZGV4ZWQgJiYgbm90IGluZGV4ZWQgcGFyYW1zXG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmRlY29kZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG5cbiAgICBkYXRhLmRhdGEgPSBkYXRhLmRhdGEgfHwgJyc7XG4gICAgZGF0YS50b3BpY3MgPSBkYXRhLnRvcGljcyB8fCBbXTtcblxuXG4gICAgdmFyIGFyZ1RvcGljcyA9IHRoaXMuX2Fub255bW91cyA/IGRhdGEudG9waWNzIDogZGF0YS50b3BpY3Muc2xpY2UoMSk7XG4gICAgdmFyIGluZGV4ZWREYXRhID0gYXJnVG9waWNzLm1hcChmdW5jdGlvbiAodG9waWNzKSB7IHJldHVybiB0b3BpY3Muc2xpY2UoMik7IH0pLmpvaW4oXCJcIik7XG4gICAgdmFyIGluZGV4ZWRQYXJhbXMgPSBjb2Rlci5kZWNvZGVQYXJhbXModGhpcy50eXBlcyh0cnVlKSwgaW5kZXhlZERhdGEpO1xuXG4gICAgdmFyIG5vdEluZGV4ZWREYXRhID0gZGF0YS5kYXRhLnNsaWNlKDIpO1xuICAgIHZhciBub3RJbmRleGVkUGFyYW1zID0gY29kZXIuZGVjb2RlUGFyYW1zKHRoaXMudHlwZXMoZmFsc2UpLCBub3RJbmRleGVkRGF0YSk7XG5cbiAgICB2YXIgcmVzdWx0ID0gZm9ybWF0dGVycy5vdXRwdXRMb2dGb3JtYXR0ZXIoZGF0YSk7XG4gICAgcmVzdWx0LmV2ZW50ID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIHJlc3VsdC5hZGRyZXNzID0gZGF0YS5hZGRyZXNzO1xuXG4gICAgcmVzdWx0LmFyZ3MgPSB0aGlzLl9wYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGN1cnJlbnQpIHtcbiAgICAgICAgYWNjW2N1cnJlbnQubmFtZV0gPSBjdXJyZW50LmluZGV4ZWQgPyBpbmRleGVkUGFyYW1zLnNoaWZ0KCkgOiBub3RJbmRleGVkUGFyYW1zLnNoaWZ0KCk7XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuXG4gICAgZGVsZXRlIHJlc3VsdC5kYXRhO1xuICAgIGRlbGV0ZSByZXN1bHQudG9waWNzO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIG5ldyBmaWx0ZXIgb2JqZWN0IGZyb20gZXZlbnRcbiAqXG4gKiBAbWV0aG9kIGV4ZWN1dGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbmRleGVkXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSBmaWx0ZXIgb2JqZWN0XG4gKi9cblNvbGlkaXR5RXZlbnQucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoaW5kZXhlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcblxuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3VtZW50c1thcmd1bWVudHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgICAgIGluZGV4ZWQgPSB7fTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBvID0gdGhpcy5lbmNvZGUoaW5kZXhlZCwgb3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZGVjb2RlLmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIobywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXIsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gYXR0YWNoIGV2ZW50IHRvIGNvbnRyYWN0IG9iamVjdFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH1cbiAqL1xuU29saWRpdHlFdmVudC5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgdmFyIGRpc3BsYXlOYW1lID0gdGhpcy5kaXNwbGF5TmFtZSgpO1xuICAgIGlmICghY29udHJhY3RbZGlzcGxheU5hbWVdKSB7XG4gICAgICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXSA9IGV4ZWN1dGU7XG4gICAgfVxuICAgIGNvbnRyYWN0W2Rpc3BsYXlOYW1lXVt0aGlzLnR5cGVOYW1lKCldID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcywgY29udHJhY3QpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eUV2ZW50O1xuXG4iLCJ2YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscy91dGlscycpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4vbWV0aG9kJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuL3Byb3BlcnR5Jyk7XG5cbi8vIFRPRE86IHJlZmFjdG9yLCBzbyB0aGUgaW5wdXQgcGFyYW1zIGFyZSBub3QgYWx0ZXJlZC5cbi8vIGl0J3MgbmVjZXNzYXJ5IHRvIG1ha2Ugc2FtZSAnZXh0ZW5zaW9uJyB3b3JrIHdpdGggbXVsdGlwbGUgcHJvdmlkZXJzXG52YXIgZXh0ZW5kID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICAvKiBqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG4gICAgdmFyIGV4ID0gZnVuY3Rpb24gKGV4dGVuc2lvbikge1xuXG4gICAgICAgIHZhciBleHRlbmRlZE9iamVjdDtcbiAgICAgICAgaWYgKGV4dGVuc2lvbi5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKCF3ZWIzW2V4dGVuc2lvbi5wcm9wZXJ0eV0pIHtcbiAgICAgICAgICAgICAgICB3ZWIzW2V4dGVuc2lvbi5wcm9wZXJ0eV0gPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4dGVuZGVkT2JqZWN0ID0gd2ViM1tleHRlbnNpb24ucHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXh0ZW5kZWRPYmplY3QgPSB3ZWIzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4dGVuc2lvbi5tZXRob2RzKSB7XG4gICAgICAgICAgICBleHRlbnNpb24ubWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBtZXRob2QuYXR0YWNoVG9PYmplY3QoZXh0ZW5kZWRPYmplY3QpO1xuICAgICAgICAgICAgICAgIG1ldGhvZC5zZXRSZXF1ZXN0TWFuYWdlcih3ZWIzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleHRlbnNpb24ucHJvcGVydGllcykge1xuICAgICAgICAgICAgZXh0ZW5zaW9uLnByb3BlcnRpZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5hdHRhY2hUb09iamVjdChleHRlbmRlZE9iamVjdCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkuc2V0UmVxdWVzdE1hbmFnZXIod2ViMy5fcmVxdWVzdE1hbmFnZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZXguZm9ybWF0dGVycyA9IGZvcm1hdHRlcnM7IFxuICAgIGV4LnV0aWxzID0gdXRpbHM7XG4gICAgZXguTWV0aG9kID0gTWV0aG9kO1xuICAgIGV4LlByb3BlcnR5ID0gUHJvcGVydHk7XG5cbiAgICByZXR1cm4gZXg7XG59O1xuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBleHRlbmQ7XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgZmlsdGVyLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiAgIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqICAgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxuLyoqXG4qIENvbnZlcnRzIGEgZ2l2ZW4gdG9waWMgdG8gYSBoZXggc3RyaW5nLCBidXQgYWxzbyBhbGxvd3MgbnVsbCB2YWx1ZXMuXG4qXG4qIEBwYXJhbSB7TWl4ZWR9IHZhbHVlXG4qIEByZXR1cm4ge1N0cmluZ31cbiovXG52YXIgdG9Ub3BpYyA9IGZ1bmN0aW9uKHZhbHVlKXtcblxuICAgIGlmKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiBudWxsO1xuXG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuXG4gICAgaWYodmFsdWUuaW5kZXhPZignMHgnKSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHV0aWxzLmZyb21VdGY4KHZhbHVlKTtcbn07XG5cbi8vLyBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uIG9wdGlvbnMgb2JqZWN0LCB0byB2ZXJpZnkgZGVwcmVjYXRlZCBwcm9wZXJ0aWVzICYmIGxhenkgbG9hZCBkeW5hbWljIG9uZXNcbi8vLyBAcGFyYW0gc2hvdWxkIGJlIHN0cmluZyBvciBvYmplY3Rcbi8vLyBAcmV0dXJucyBvcHRpb25zIHN0cmluZyBvciBvYmplY3RcbnZhciBnZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHR5cGUpIHtcbiAgICAvKmpzaGludCBtYXhjb21wbGV4aXR5OiA2ICovXG5cbiAgICBpZiAodXRpbHMuaXNTdHJpbmcob3B0aW9ucykpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblxuICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2V0aCc6XG5cbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0b3BpY3MsIGdldCBjb252ZXJ0ZWQgdG8gaGV4XG4gICAgICAgICAgICBvcHRpb25zLnRvcGljcyA9IG9wdGlvbnMudG9waWNzIHx8IFtdO1xuICAgICAgICAgICAgb3B0aW9ucy50b3BpY3MgPSBvcHRpb25zLnRvcGljcy5tYXAoZnVuY3Rpb24odG9waWMpe1xuICAgICAgICAgICAgICAgIHJldHVybiAodXRpbHMuaXNBcnJheSh0b3BpYykpID8gdG9waWMubWFwKHRvVG9waWMpIDogdG9Ub3BpYyh0b3BpYyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3BpY3M6IG9wdGlvbnMudG9waWNzLFxuICAgICAgICAgICAgICAgIGZyb206IG9wdGlvbnMuZnJvbSxcbiAgICAgICAgICAgICAgICB0bzogb3B0aW9ucy50byxcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBvcHRpb25zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZnJvbUJsb2NrOiBmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIob3B0aW9ucy5mcm9tQmxvY2spLFxuICAgICAgICAgICAgICAgIHRvQmxvY2s6IGZvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcihvcHRpb25zLnRvQmxvY2spXG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdzaGgnOlxuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxufTtcblxuLyoqXG5BZGRzIHRoZSBjYWxsYmFjayBhbmQgc2V0cyB1cCB0aGUgbWV0aG9kcywgdG8gaXRlcmF0ZSBvdmVyIHRoZSByZXN1bHRzLlxuXG5AbWV0aG9kIGdldExvZ3NBdFN0YXJ0XG5AcGFyYW0ge09iamVjdH0gc2VsZlxuQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiovXG52YXIgZ2V0TG9nc0F0U3RhcnQgPSBmdW5jdGlvbihzZWxmLCBjYWxsYmFjayl7XG4gICAgLy8gY2FsbCBnZXRGaWx0ZXJMb2dzIGZvciB0aGUgZmlyc3Qgd2F0Y2ggY2FsbGJhY2sgc3RhcnRcbiAgICBpZiAoIXV0aWxzLmlzU3RyaW5nKHNlbGYub3B0aW9ucykpIHtcbiAgICAgICAgc2VsZi5nZXQoZnVuY3Rpb24gKGVyciwgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgIC8vIGRvbid0IHNlbmQgYWxsIHRoZSByZXNwb25zZXMgdG8gYWxsIHRoZSB3YXRjaGVzIGFnYWluLi4uIGp1c3QgdG8gc2VsZiBvbmVcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZih1dGlscy5pc0FycmF5KG1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VzLmZvckVhY2goZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbi8qKlxuQWRkcyB0aGUgY2FsbGJhY2sgYW5kIHNldHMgdXAgdGhlIG1ldGhvZHMsIHRvIGl0ZXJhdGUgb3ZlciB0aGUgcmVzdWx0cy5cblxuQG1ldGhvZCBwb2xsRmlsdGVyXG5AcGFyYW0ge09iamVjdH0gc2VsZlxuKi9cbnZhciBwb2xsRmlsdGVyID0gZnVuY3Rpb24oc2VsZikge1xuXG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uIChlcnJvciwgbWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHV0aWxzLmlzQXJyYXkobWVzc2FnZXMpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobWVzc2FnZSkgOiBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2VsZi5yZXF1ZXN0TWFuYWdlci5zdGFydFBvbGxpbmcoe1xuICAgICAgICBtZXRob2Q6IHNlbGYuaW1wbGVtZW50YXRpb24ucG9sbC5jYWxsLFxuICAgICAgICBwYXJhbXM6IFtzZWxmLmZpbHRlcklkXSxcbiAgICB9LCBzZWxmLmZpbHRlcklkLCBvbk1lc3NhZ2UsIHNlbGYuc3RvcFdhdGNoaW5nLmJpbmQoc2VsZikpO1xuXG59O1xuXG52YXIgRmlsdGVyID0gZnVuY3Rpb24gKG9wdGlvbnMsIHR5cGUsIHJlcXVlc3RNYW5hZ2VyLCBtZXRob2RzLCBmb3JtYXR0ZXIsIGNhbGxiYWNrLCBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGltcGxlbWVudGF0aW9uID0ge307XG4gICAgbWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHJlcXVlc3RNYW5hZ2VyKTtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KGltcGxlbWVudGF0aW9uKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5vcHRpb25zID0gZ2V0T3B0aW9ucyhvcHRpb25zLCB0eXBlKTtcbiAgICB0aGlzLmltcGxlbWVudGF0aW9uID0gaW1wbGVtZW50YXRpb247XG4gICAgdGhpcy5maWx0ZXJJZCA9IG51bGw7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmdldExvZ3NDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLnBvbGxGaWx0ZXJzID0gW107XG4gICAgdGhpcy5mb3JtYXR0ZXIgPSBmb3JtYXR0ZXI7XG4gICAgdGhpcy5pbXBsZW1lbnRhdGlvbi5uZXdGaWx0ZXIodGhpcy5vcHRpb25zLCBmdW5jdGlvbihlcnJvciwgaWQpe1xuICAgICAgICBpZihlcnJvcikge1xuICAgICAgICAgICAgc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbihjYil7XG4gICAgICAgICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBmaWx0ZXJDcmVhdGlvbkVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5maWx0ZXJJZCA9IGlkO1xuXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgZ2V0IHBlbmRpbmcgY2FsbGJhY2tzIGFzIGEgY29uc2VxdWVuY2VcbiAgICAgICAgICAgIC8vIG9mIGNhbGxpbmcgZ2V0KCkgd2l0aCBmaWx0ZXJJZCB1bmFzc2lnbmVkLlxuICAgICAgICAgICAgc2VsZi5nZXRMb2dzQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKXtcbiAgICAgICAgICAgICAgICBzZWxmLmdldChjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGYuZ2V0TG9nc0NhbGxiYWNrcyA9IFtdO1xuXG4gICAgICAgICAgICAvLyBnZXQgZmlsdGVyIGxvZ3MgZm9yIHRoZSBhbHJlYWR5IGV4aXN0aW5nIHdhdGNoIGNhbGxzXG4gICAgICAgICAgICBzZWxmLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKXtcbiAgICAgICAgICAgICAgICBnZXRMb2dzQXRTdGFydChzZWxmLCBjYik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmKHNlbGYuY2FsbGJhY2tzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgcG9sbEZpbHRlcihzZWxmKTtcblxuICAgICAgICAgICAgLy8gc3RhcnQgdG8gd2F0Y2ggaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLndhdGNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cbiAgICBpZih0aGlzLmZpbHRlcklkKSB7XG4gICAgICAgIGdldExvZ3NBdFN0YXJ0KHRoaXMsIGNhbGxiYWNrKTtcbiAgICAgICAgcG9sbEZpbHRlcih0aGlzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkZpbHRlci5wcm90b3R5cGUuc3RvcFdhdGNoaW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5zdG9wUG9sbGluZyh0aGlzLmZpbHRlcklkKTtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIC8vIHJlbW92ZSBmaWx0ZXIgYXN5bmNcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pbXBsZW1lbnRhdGlvbi51bmluc3RhbGxGaWx0ZXIodGhpcy5maWx0ZXJJZCwgY2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltcGxlbWVudGF0aW9uLnVuaW5zdGFsbEZpbHRlcih0aGlzLmZpbHRlcklkKTtcbiAgICB9XG59O1xuXG5GaWx0ZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodXRpbHMuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIGZpbHRlcklkIGlzIG5vdCBzZXQgeWV0LCBjYWxsIGl0IGJhY2tcbiAgICAgICAgICAgIC8vIHdoZW4gbmV3RmlsdGVyKCkgYXNzaWducyBpdC5cbiAgICAgICAgICAgIHRoaXMuZ2V0TG9nc0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW1wbGVtZW50YXRpb24uZ2V0TG9ncyh0aGlzLmZpbHRlcklkLCBmdW5jdGlvbihlcnIsIHJlcyl7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcy5tYXAoZnVuY3Rpb24gKGxvZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZm9ybWF0dGVyID8gc2VsZi5mb3JtYXR0ZXIobG9nKSA6IGxvZztcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVySWQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmlsdGVyIElEIEVycm9yOiBmaWx0ZXIoKS5nZXQoKSBjYW5cXCd0IGJlIGNoYWluZWQgc3luY2hyb25vdXMsIHBsZWFzZSBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIHRoZSBnZXQoKSBtZXRob2QuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ3MgPSB0aGlzLmltcGxlbWVudGF0aW9uLmdldExvZ3ModGhpcy5maWx0ZXJJZCk7XG4gICAgICAgIHJldHVybiBsb2dzLm1hcChmdW5jdGlvbiAobG9nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5mb3JtYXR0ZXIgPyBzZWxmLmZvcm1hdHRlcihsb2cpIDogbG9nO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVyO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmb3JtYXR0ZXJzLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjb25maWcgPSByZXF1aXJlKCcuLi91dGlscy9jb25maWcnKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnLi9pYmFuJyk7XG5cbi8qKlxuICogU2hvdWxkIHRoZSBmb3JtYXQgb3V0cHV0IHRvIGEgYmlnIG51bWJlclxuICpcbiAqIEBtZXRob2Qgb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8QmlnTnVtYmVyfVxuICogQHJldHVybnMge0JpZ051bWJlcn0gb2JqZWN0XG4gKi9cbnZhciBvdXRwdXRCaWdOdW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgcmV0dXJuIHV0aWxzLnRvQmlnTnVtYmVyKG51bWJlcik7XG59O1xuXG52YXIgaXNQcmVkZWZpbmVkQmxvY2tOdW1iZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICByZXR1cm4gYmxvY2tOdW1iZXIgPT09ICdsYXRlc3QnIHx8IGJsb2NrTnVtYmVyID09PSAncGVuZGluZycgfHwgYmxvY2tOdW1iZXIgPT09ICdlYXJsaWVzdCc7XG59O1xuXG52YXIgaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICBpZiAoYmxvY2tOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gY29uZmlnLmRlZmF1bHRCbG9jaztcbiAgICB9XG4gICAgcmV0dXJuIGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIoYmxvY2tOdW1iZXIpO1xufTtcblxudmFyIGlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIgPSBmdW5jdGlvbiAoYmxvY2tOdW1iZXIpIHtcbiAgICBpZiAoYmxvY2tOdW1iZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAoaXNQcmVkZWZpbmVkQmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpKSB7XG4gICAgICAgIHJldHVybiBibG9ja051bWJlcjtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4KGJsb2NrTnVtYmVyKTtcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgaW5wdXQgb2YgYSB0cmFuc2FjdGlvbiBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0Q2FsbEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIG9iamVjdFxuKi9cbnZhciBpbnB1dENhbGxGb3JtYXR0ZXIgPSBmdW5jdGlvbiAob3B0aW9ucyl7XG5cbiAgICBvcHRpb25zLmZyb20gPSBvcHRpb25zLmZyb20gfHwgY29uZmlnLmRlZmF1bHRBY2NvdW50O1xuXG4gICAgaWYgKG9wdGlvbnMuZnJvbSkge1xuICAgICAgICBvcHRpb25zLmZyb20gPSBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy5mcm9tKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy50bykgeyAvLyBpdCBtaWdodCBiZSBjb250cmFjdCBjcmVhdGlvblxuICAgICAgICBvcHRpb25zLnRvID0gaW5wdXRBZGRyZXNzRm9ybWF0dGVyKG9wdGlvbnMudG8pO1xuICAgIH1cblxuICAgIFsnZ2FzUHJpY2UnLCAnZ2FzJywgJ3ZhbHVlJywgJ25vbmNlJ10uZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcbiAgICAgICAgb3B0aW9uc1trZXldID0gdXRpbHMuZnJvbURlY2ltYWwob3B0aW9uc1trZXldKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBvcHRpb25zO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBpbnB1dCBvZiBhIHRyYW5zYWN0aW9uIGFuZCBjb252ZXJ0cyBhbGwgdmFsdWVzIHRvIEhFWFxuICpcbiAqIEBtZXRob2QgaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm5zIG9iamVjdFxuKi9cbnZhciBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyID0gZnVuY3Rpb24gKG9wdGlvbnMpe1xuXG4gICAgb3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tIHx8IGNvbmZpZy5kZWZhdWx0QWNjb3VudDtcbiAgICBvcHRpb25zLmZyb20gPSBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy5mcm9tKTtcblxuICAgIGlmIChvcHRpb25zLnRvKSB7IC8vIGl0IG1pZ2h0IGJlIGNvbnRyYWN0IGNyZWF0aW9uXG4gICAgICAgIG9wdGlvbnMudG8gPSBpbnB1dEFkZHJlc3NGb3JtYXR0ZXIob3B0aW9ucy50byk7XG4gICAgfVxuXG4gICAgWydnYXNQcmljZScsICdnYXMnLCAndmFsdWUnLCAnbm9uY2UnXS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gb3B0aW9uc1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihrZXkpe1xuICAgICAgICBvcHRpb25zW2tleV0gPSB1dGlscy5mcm9tRGVjaW1hbChvcHRpb25zW2tleV0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIG9wdGlvbnM7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIHRyYW5zYWN0aW9uIHRvIGl0cyBwcm9wZXIgdmFsdWVzXG4gKlxuICogQG1ldGhvZCBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHR4XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuKi9cbnZhciBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlciA9IGZ1bmN0aW9uICh0eCl7XG4gICAgaWYodHguYmxvY2tOdW1iZXIgIT09IG51bGwpXG4gICAgICAgIHR4LmJsb2NrTnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKHR4LmJsb2NrTnVtYmVyKTtcbiAgICBpZih0eC50cmFuc2FjdGlvbkluZGV4ICE9PSBudWxsKVxuICAgICAgICB0eC50cmFuc2FjdGlvbkluZGV4ID0gdXRpbHMudG9EZWNpbWFsKHR4LnRyYW5zYWN0aW9uSW5kZXgpO1xuICAgIHR4Lm5vbmNlID0gdXRpbHMudG9EZWNpbWFsKHR4Lm5vbmNlKTtcbiAgICB0eC5nYXMgPSB1dGlscy50b0RlY2ltYWwodHguZ2FzKTtcbiAgICB0eC5nYXNQcmljZSA9IHV0aWxzLnRvQmlnTnVtYmVyKHR4Lmdhc1ByaWNlKTtcbiAgICB0eC52YWx1ZSA9IHV0aWxzLnRvQmlnTnVtYmVyKHR4LnZhbHVlKTtcbiAgICByZXR1cm4gdHg7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIHRyYW5zYWN0aW9uIHJlY2VpcHQgdG8gaXRzIHByb3BlciB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kIG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHJlY2VpcHRcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4qL1xudmFyIG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlciA9IGZ1bmN0aW9uIChyZWNlaXB0KXtcbiAgICBpZihyZWNlaXB0LmJsb2NrTnVtYmVyICE9PSBudWxsKVxuICAgICAgICByZWNlaXB0LmJsb2NrTnVtYmVyID0gdXRpbHMudG9EZWNpbWFsKHJlY2VpcHQuYmxvY2tOdW1iZXIpO1xuICAgIGlmKHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCAhPT0gbnVsbClcbiAgICAgICAgcmVjZWlwdC50cmFuc2FjdGlvbkluZGV4ID0gdXRpbHMudG9EZWNpbWFsKHJlY2VpcHQudHJhbnNhY3Rpb25JbmRleCk7XG4gICAgcmVjZWlwdC5jdW11bGF0aXZlR2FzVXNlZCA9IHV0aWxzLnRvRGVjaW1hbChyZWNlaXB0LmN1bXVsYXRpdmVHYXNVc2VkKTtcbiAgICByZWNlaXB0Lmdhc1VzZWQgPSB1dGlscy50b0RlY2ltYWwocmVjZWlwdC5nYXNVc2VkKTtcblxuICAgIGlmKHV0aWxzLmlzQXJyYXkocmVjZWlwdC5sb2dzKSkge1xuICAgICAgICByZWNlaXB0LmxvZ3MgPSByZWNlaXB0LmxvZ3MubWFwKGZ1bmN0aW9uKGxvZyl7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0TG9nRm9ybWF0dGVyKGxvZyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZWNlaXB0O1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBvdXRwdXQgb2YgYSBibG9jayB0byBpdHMgcHJvcGVyIHZhbHVlc1xuICpcbiAqIEBtZXRob2Qgb3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBibG9ja1xuICogQHJldHVybnMge09iamVjdH1cbiovXG52YXIgb3V0cHV0QmxvY2tGb3JtYXR0ZXIgPSBmdW5jdGlvbihibG9jaykge1xuXG4gICAgLy8gdHJhbnNmb3JtIHRvIG51bWJlclxuICAgIGJsb2NrLmdhc0xpbWl0ID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLmdhc0xpbWl0KTtcbiAgICBibG9jay5nYXNVc2VkID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLmdhc1VzZWQpO1xuICAgIGJsb2NrLnNpemUgPSB1dGlscy50b0RlY2ltYWwoYmxvY2suc2l6ZSk7XG4gICAgYmxvY2sudGltZXN0YW1wID0gdXRpbHMudG9EZWNpbWFsKGJsb2NrLnRpbWVzdGFtcCk7XG4gICAgaWYoYmxvY2subnVtYmVyICE9PSBudWxsKVxuICAgICAgICBibG9jay5udW1iZXIgPSB1dGlscy50b0RlY2ltYWwoYmxvY2subnVtYmVyKTtcblxuICAgIGJsb2NrLmRpZmZpY3VsdHkgPSB1dGlscy50b0JpZ051bWJlcihibG9jay5kaWZmaWN1bHR5KTtcbiAgICBibG9jay50b3RhbERpZmZpY3VsdHkgPSB1dGlscy50b0JpZ051bWJlcihibG9jay50b3RhbERpZmZpY3VsdHkpO1xuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXkoYmxvY2sudHJhbnNhY3Rpb25zKSkge1xuICAgICAgICBibG9jay50cmFuc2FjdGlvbnMuZm9yRWFjaChmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgIGlmKCF1dGlscy5pc1N0cmluZyhpdGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0VHJhbnNhY3Rpb25Gb3JtYXR0ZXIoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBibG9jaztcbn07XG5cbi8qKlxuICogRm9ybWF0cyB0aGUgb3V0cHV0IG9mIGEgbG9nXG4gKlxuICogQG1ldGhvZCBvdXRwdXRMb2dGb3JtYXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2cgb2JqZWN0XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2dcbiovXG52YXIgb3V0cHV0TG9nRm9ybWF0dGVyID0gZnVuY3Rpb24obG9nKSB7XG4gICAgaWYobG9nLmJsb2NrTnVtYmVyKVxuICAgICAgICBsb2cuYmxvY2tOdW1iZXIgPSB1dGlscy50b0RlY2ltYWwobG9nLmJsb2NrTnVtYmVyKTtcbiAgICBpZihsb2cudHJhbnNhY3Rpb25JbmRleClcbiAgICAgICAgbG9nLnRyYW5zYWN0aW9uSW5kZXggPSB1dGlscy50b0RlY2ltYWwobG9nLnRyYW5zYWN0aW9uSW5kZXgpO1xuICAgIGlmKGxvZy5sb2dJbmRleClcbiAgICAgICAgbG9nLmxvZ0luZGV4ID0gdXRpbHMudG9EZWNpbWFsKGxvZy5sb2dJbmRleCk7XG5cbiAgICByZXR1cm4gbG9nO1xufTtcblxuLyoqXG4gKiBGb3JtYXRzIHRoZSBpbnB1dCBvZiBhIHdoaXNwZXIgcG9zdCBhbmQgY29udmVydHMgYWxsIHZhbHVlcyB0byBIRVhcbiAqXG4gKiBAbWV0aG9kIGlucHV0UG9zdEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9IHRyYW5zYWN0aW9uIG9iamVjdFxuICogQHJldHVybnMge09iamVjdH1cbiovXG52YXIgaW5wdXRQb3N0Rm9ybWF0dGVyID0gZnVuY3Rpb24ocG9zdCkge1xuXG4gICAgLy8gcG9zdC5wYXlsb2FkID0gdXRpbHMudG9IZXgocG9zdC5wYXlsb2FkKTtcbiAgICBwb3N0LnR0bCA9IHV0aWxzLmZyb21EZWNpbWFsKHBvc3QudHRsKTtcbiAgICBwb3N0LndvcmtUb1Byb3ZlID0gdXRpbHMuZnJvbURlY2ltYWwocG9zdC53b3JrVG9Qcm92ZSk7XG4gICAgcG9zdC5wcmlvcml0eSA9IHV0aWxzLmZyb21EZWNpbWFsKHBvc3QucHJpb3JpdHkpO1xuXG4gICAgLy8gZmFsbGJhY2tcbiAgICBpZiAoIXV0aWxzLmlzQXJyYXkocG9zdC50b3BpY3MpKSB7XG4gICAgICAgIHBvc3QudG9waWNzID0gcG9zdC50b3BpY3MgPyBbcG9zdC50b3BpY3NdIDogW107XG4gICAgfVxuXG4gICAgLy8gZm9ybWF0IHRoZSBmb2xsb3dpbmcgb3B0aW9uc1xuICAgIHBvc3QudG9waWNzID0gcG9zdC50b3BpY3MubWFwKGZ1bmN0aW9uKHRvcGljKXtcbiAgICAgICAgLy8gY29udmVydCBvbmx5IGlmIG5vdCBoZXhcbiAgICAgICAgcmV0dXJuICh0b3BpYy5pbmRleE9mKCcweCcpID09PSAwKSA/IHRvcGljIDogdXRpbHMuZnJvbVV0ZjgodG9waWMpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHBvc3Q7XG59O1xuXG4vKipcbiAqIEZvcm1hdHMgdGhlIG91dHB1dCBvZiBhIHJlY2VpdmVkIHBvc3QgbWVzc2FnZVxuICpcbiAqIEBtZXRob2Qgb3V0cHV0UG9zdEZvcm1hdHRlclxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG52YXIgb3V0cHV0UG9zdEZvcm1hdHRlciA9IGZ1bmN0aW9uKHBvc3Qpe1xuXG4gICAgcG9zdC5leHBpcnkgPSB1dGlscy50b0RlY2ltYWwocG9zdC5leHBpcnkpO1xuICAgIHBvc3Quc2VudCA9IHV0aWxzLnRvRGVjaW1hbChwb3N0LnNlbnQpO1xuICAgIHBvc3QudHRsID0gdXRpbHMudG9EZWNpbWFsKHBvc3QudHRsKTtcbiAgICBwb3N0LndvcmtQcm92ZWQgPSB1dGlscy50b0RlY2ltYWwocG9zdC53b3JrUHJvdmVkKTtcbiAgICAvLyBwb3N0LnBheWxvYWRSYXcgPSBwb3N0LnBheWxvYWQ7XG4gICAgLy8gcG9zdC5wYXlsb2FkID0gdXRpbHMudG9Bc2NpaShwb3N0LnBheWxvYWQpO1xuXG4gICAgLy8gaWYgKHV0aWxzLmlzSnNvbihwb3N0LnBheWxvYWQpKSB7XG4gICAgLy8gICAgIHBvc3QucGF5bG9hZCA9IEpTT04ucGFyc2UocG9zdC5wYXlsb2FkKTtcbiAgICAvLyB9XG5cbiAgICAvLyBmb3JtYXQgdGhlIGZvbGxvd2luZyBvcHRpb25zXG4gICAgaWYgKCFwb3N0LnRvcGljcykge1xuICAgICAgICBwb3N0LnRvcGljcyA9IFtdO1xuICAgIH1cbiAgICBwb3N0LnRvcGljcyA9IHBvc3QudG9waWNzLm1hcChmdW5jdGlvbih0b3BpYyl7XG4gICAgICAgIHJldHVybiB1dGlscy50b0FzY2lpKHRvcGljKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBwb3N0O1xufTtcblxudmFyIGlucHV0QWRkcmVzc0Zvcm1hdHRlciA9IGZ1bmN0aW9uIChhZGRyZXNzKSB7XG4gICAgdmFyIGliYW4gPSBuZXcgSWJhbihhZGRyZXNzKTtcbiAgICBpZiAoaWJhbi5pc1ZhbGlkKCkgJiYgaWJhbi5pc0RpcmVjdCgpKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgaWJhbi5hZGRyZXNzKCk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmljdEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FkZHJlc3MoYWRkcmVzcykpIHtcbiAgICAgICAgcmV0dXJuICcweCcgKyBhZGRyZXNzO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWRkcmVzcycpO1xufTtcblxuXG52YXIgb3V0cHV0U3luY2luZ0Zvcm1hdHRlciA9IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnN0YXJ0aW5nQmxvY2sgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0LnN0YXJ0aW5nQmxvY2spO1xuICAgIHJlc3VsdC5jdXJyZW50QmxvY2sgPSB1dGlscy50b0RlY2ltYWwocmVzdWx0LmN1cnJlbnRCbG9jayk7XG4gICAgcmVzdWx0LmhpZ2hlc3RCbG9jayA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQuaGlnaGVzdEJsb2NrKTtcbiAgICBpZiAocmVzdWx0Lmtub3duU3RhdGVzKSB7XG4gICAgICAgIHJlc3VsdC5rbm93blN0YXRlcyA9IHV0aWxzLnRvRGVjaW1hbChyZXN1bHQua25vd25TdGF0ZXMpO1xuICAgICAgICByZXN1bHQucHVsbGVkU3RhdGVzID0gdXRpbHMudG9EZWNpbWFsKHJlc3VsdC5wdWxsZWRTdGF0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcjogaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsXG4gICAgaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcjogaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcixcbiAgICBpbnB1dENhbGxGb3JtYXR0ZXI6IGlucHV0Q2FsbEZvcm1hdHRlcixcbiAgICBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOiBpbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLFxuICAgIGlucHV0QWRkcmVzc0Zvcm1hdHRlcjogaW5wdXRBZGRyZXNzRm9ybWF0dGVyLFxuICAgIGlucHV0UG9zdEZvcm1hdHRlcjogaW5wdXRQb3N0Rm9ybWF0dGVyLFxuICAgIG91dHB1dEJpZ051bWJlckZvcm1hdHRlcjogb3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyLFxuICAgIG91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyOiBvdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlcixcbiAgICBvdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXI6IG91dHB1dFRyYW5zYWN0aW9uUmVjZWlwdEZvcm1hdHRlcixcbiAgICBvdXRwdXRCbG9ja0Zvcm1hdHRlcjogb3V0cHV0QmxvY2tGb3JtYXR0ZXIsXG4gICAgb3V0cHV0TG9nRm9ybWF0dGVyOiBvdXRwdXRMb2dGb3JtYXR0ZXIsXG4gICAgb3V0cHV0UG9zdEZvcm1hdHRlcjogb3V0cHV0UG9zdEZvcm1hdHRlcixcbiAgICBvdXRwdXRTeW5jaW5nRm9ybWF0dGVyOiBvdXRwdXRTeW5jaW5nRm9ybWF0dGVyXG59O1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBmdW5jdGlvbi5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgY29kZXIgPSByZXF1aXJlKCcuLi9zb2xpZGl0eS9jb2RlcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuL2Zvcm1hdHRlcnMnKTtcbnZhciBzaGEzID0gcmVxdWlyZSgnLi4vdXRpbHMvc2hhMycpO1xuXG4vKipcbiAqIFRoaXMgcHJvdG90eXBlIHNob3VsZCBiZSB1c2VkIHRvIGNhbGwvc2VuZFRyYW5zYWN0aW9uIHRvIHNvbGlkaXR5IGZ1bmN0aW9uc1xuICovXG52YXIgU29saWRpdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIChldGgsIGpzb24sIGFkZHJlc3MpIHtcbiAgICB0aGlzLl9ldGggPSBldGg7XG4gICAgdGhpcy5faW5wdXRUeXBlcyA9IGpzb24uaW5wdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX291dHB1dFR5cGVzID0ganNvbi5vdXRwdXRzLm1hcChmdW5jdGlvbiAoaSkge1xuICAgICAgICByZXR1cm4gaS50eXBlO1xuICAgIH0pO1xuICAgIHRoaXMuX2NvbnN0YW50ID0gKGpzb24uc3RhdGVNdXRhYmlsaXR5ID09PSBcInZpZXdcIiB8fCBqc29uLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwdXJlXCIgfHwganNvbi5jb25zdGFudCk7XG4gICAgdGhpcy5fcGF5YWJsZSA9IChqc29uLnN0YXRlTXV0YWJpbGl0eSA9PT0gXCJwYXlhYmxlXCIgfHwganNvbi5wYXlhYmxlKTtcbiAgICB0aGlzLl9uYW1lID0gdXRpbHMudHJhbnNmb3JtVG9GdWxsTmFtZShqc29uKTtcbiAgICB0aGlzLl9hZGRyZXNzID0gYWRkcmVzcztcbn07XG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gYXJncy5wb3AoKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmV4dHJhY3REZWZhdWx0QmxvY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoICYmICF1dGlscy5pc09iamVjdChhcmdzW2FyZ3MubGVuZ3RoIC0xXSkpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXIoYXJncy5wb3AoKSk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgY29ycmVjdFxuICpcbiAqIEBtZXRob2QgdmFsaWRhdGVBcmdzXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBpcyBub3RcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgaW5wdXRBcmdzID0gYXJncy5maWx0ZXIoZnVuY3Rpb24gKGEpIHtcbiAgICAgIC8vIGZpbHRlciB0aGUgb3B0aW9ucyBvYmplY3QgYnV0IG5vdCBhcmd1bWVudHMgdGhhdCBhcmUgYXJyYXlzXG4gICAgICByZXR1cm4gISggKHV0aWxzLmlzT2JqZWN0KGEpID09PSB0cnVlKSAmJlxuICAgICAgICAgICAgICAgICh1dGlscy5pc0FycmF5KGEpID09PSBmYWxzZSkgJiZcbiAgICAgICAgICAgICAgICAodXRpbHMuaXNCaWdOdW1iZXIoYSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICApO1xuICAgIH0pO1xuICAgIGlmIChpbnB1dEFyZ3MubGVuZ3RoICE9PSB0aGlzLl9pbnB1dFR5cGVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZE51bWJlck9mU29saWRpdHlBcmdzKCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgcGF5bG9hZCBmcm9tIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0FycmF5fSBzb2xpZGl0eSBmdW5jdGlvbiBwYXJhbXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25hbCBwYXlsb2FkIG9wdGlvbnNcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUudG9QYXlsb2FkID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IHRoaXMuX2lucHV0VHlwZXMubGVuZ3RoICYmIHV0aWxzLmlzT2JqZWN0KGFyZ3NbYXJncy5sZW5ndGggLTFdKSkge1xuICAgICAgICBvcHRpb25zID0gYXJnc1thcmdzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICB0aGlzLnZhbGlkYXRlQXJncyhhcmdzKTtcbiAgICBvcHRpb25zLnRvID0gdGhpcy5fYWRkcmVzcztcbiAgICBvcHRpb25zLmRhdGEgPSAnMHgnICsgdGhpcy5zaWduYXR1cmUoKSArIGNvZGVyLmVuY29kZVBhcmFtcyh0aGlzLl9pbnB1dFR5cGVzLCBhcmdzKTtcbiAgICByZXR1cm4gb3B0aW9ucztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZ1bmN0aW9uIHNpZ25hdHVyZVxuICpcbiAqIEBtZXRob2Qgc2lnbmF0dXJlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGZ1bmN0aW9uIHNpZ25hdHVyZVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5zaWduYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNoYTModGhpcy5fbmFtZSkuc2xpY2UoMCwgOCk7XG59O1xuXG5cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnVucGFja091dHB1dCA9IGZ1bmN0aW9uIChvdXRwdXQpIHtcbiAgICBpZiAoIW91dHB1dCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3V0cHV0ID0gb3V0cHV0Lmxlbmd0aCA+PSAyID8gb3V0cHV0LnNsaWNlKDIpIDogb3V0cHV0O1xuICAgIHZhciByZXN1bHQgPSBjb2Rlci5kZWNvZGVQYXJhbXModGhpcy5fb3V0cHV0VHlwZXMsIG91dHB1dCk7XG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDEgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIENhbGxzIGEgY29udHJhY3QgZnVuY3Rpb24uXG4gKlxuICogQG1ldGhvZCBjYWxsXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gQ29udHJhY3QgZnVuY3Rpb24gYXJndW1lbnRzXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBJZiB0aGUgbGFzdCBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLCB0aGUgY29udHJhY3QgZnVuY3Rpb25cbiAqICAgY2FsbCB3aWxsIGJlIGFzeW5jaHJvbm91cywgYW5kIHRoZSBjYWxsYmFjayB3aWxsIGJlIHBhc3NlZCB0aGVcbiAqICAgZXJyb3IgYW5kIHJlc3VsdC5cbiAqIEByZXR1cm4ge1N0cmluZ30gb3V0cHV0IGJ5dGVzXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmNhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmZpbHRlcihmdW5jdGlvbiAoYSkge3JldHVybiBhICE9PSB1bmRlZmluZWQ7IH0pO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBkZWZhdWx0QmxvY2sgPSB0aGlzLmV4dHJhY3REZWZhdWx0QmxvY2soYXJncyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcblxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fZXRoLmNhbGwocGF5bG9hZCwgZGVmYXVsdEJsb2NrKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5wYWNrT3V0cHV0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2V0aC5jYWxsKHBheWxvYWQsIGRlZmF1bHRCbG9jaywgZnVuY3Rpb24gKGVycm9yLCBvdXRwdXQpIHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuXG4gICAgICAgIHZhciB1bnBhY2tlZCA9IG51bGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB1bnBhY2tlZCA9IHNlbGYudW5wYWNrT3V0cHV0KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGVycm9yID0gZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCB1bnBhY2tlZCk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHNlbmRUcmFuc2FjdGlvbiB0byBzb2xpZGl0eSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2Qgc2VuZFRyYW5zYWN0aW9uXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLnNlbmRUcmFuc2FjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChhKSB7cmV0dXJuIGEgIT09IHVuZGVmaW5lZDsgfSk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcblxuICAgIGlmIChwYXlsb2FkLnZhbHVlID4gMCAmJiAhdGhpcy5fcGF5YWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZW5kIHZhbHVlIHRvIG5vbi1wYXlhYmxlIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXRoLnNlbmRUcmFuc2FjdGlvbihwYXlsb2FkKTtcbiAgICB9XG5cbiAgICB0aGlzLl9ldGguc2VuZFRyYW5zYWN0aW9uKHBheWxvYWQsIGNhbGxiYWNrKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZXN0aW1hdGVHYXMgb2Ygc29saWRpdHkgZnVuY3Rpb25cbiAqXG4gKiBAbWV0aG9kIGVzdGltYXRlR2FzXG4gKi9cblNvbGlkaXR5RnVuY3Rpb24ucHJvdG90eXBlLmVzdGltYXRlR2FzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLmV4dHJhY3RDYWxsYmFjayhhcmdzKTtcbiAgICB2YXIgcGF5bG9hZCA9IHRoaXMudG9QYXlsb2FkKGFyZ3MpO1xuXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXRoLmVzdGltYXRlR2FzKHBheWxvYWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2V0aC5lc3RpbWF0ZUdhcyhwYXlsb2FkLCBjYWxsYmFjayk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgZW5jb2RlZCBkYXRhIG9mIHRoZSBjYWxsXG4gKlxuICogQG1ldGhvZCBnZXREYXRhXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBlbmNvZGVkIGRhdGFcbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcblxuICAgIHJldHVybiBwYXlsb2FkLmRhdGE7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGdldCBmdW5jdGlvbiBkaXNwbGF5IG5hbWVcbiAqXG4gKiBAbWV0aG9kIGRpc3BsYXlOYW1lXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRpc3BsYXkgbmFtZSBvZiB0aGUgZnVuY3Rpb25cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuZGlzcGxheU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHV0aWxzLmV4dHJhY3REaXNwbGF5TmFtZSh0aGlzLl9uYW1lKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZ2V0IGZ1bmN0aW9uIHR5cGUgbmFtZVxuICpcbiAqIEBtZXRob2QgdHlwZU5hbWVcbiAqIEByZXR1cm4ge1N0cmluZ30gdHlwZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS50eXBlTmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdXRpbHMuZXh0cmFjdFR5cGVOYW1lKHRoaXMuX25hbWUpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGdldCBycGMgcmVxdWVzdHMgZnJvbSBzb2xpZGl0eSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgcmVxdWVzdFxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5leHRyYWN0Q2FsbGJhY2soYXJncyk7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChhcmdzKTtcbiAgICB2YXIgZm9ybWF0ID0gdGhpcy51bnBhY2tPdXRwdXQuYmluZCh0aGlzKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIG1ldGhvZDogdGhpcy5fY29uc3RhbnQgPyAnZXRoX2NhbGwnIDogJ2V0aF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIHBhcmFtczogW3BheWxvYWRdLFxuICAgICAgICBmb3JtYXQ6IGZvcm1hdFxuICAgIH07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZXhlY3V0ZSBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgZXhlY3V0ZVxuICovXG5Tb2xpZGl0eUZ1bmN0aW9uLnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cmFuc2FjdGlvbiA9ICF0aGlzLl9jb25zdGFudDtcblxuICAgIC8vIHNlbmQgdHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH1cblxuICAgIC8vIGNhbGxcbiAgICByZXR1cm4gdGhpcy5jYWxsLmFwcGx5KHRoaXMsIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGF0dGFjaCBmdW5jdGlvbiB0byBjb250cmFjdFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9Db250cmFjdFxuICogQHBhcmFtIHtDb250cmFjdH1cbiAqL1xuU29saWRpdHlGdW5jdGlvbi5wcm90b3R5cGUuYXR0YWNoVG9Db250cmFjdCA9IGZ1bmN0aW9uIChjb250cmFjdCkge1xuICAgIHZhciBleGVjdXRlID0gdGhpcy5leGVjdXRlLmJpbmQodGhpcyk7XG4gICAgZXhlY3V0ZS5yZXF1ZXN0ID0gdGhpcy5yZXF1ZXN0LmJpbmQodGhpcyk7XG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShleGVjdXRlLCAnY2FsbCcsIHRoaXMuY2FsbC5iaW5kKHRoaXMpKTtcclxuICAgIGV4ZWN1dGUuc2VuZFRyYW5zYWN0aW9uID0gdGhpcy5zZW5kVHJhbnNhY3Rpb24uYmluZCh0aGlzKTtcbiAgICBleGVjdXRlLmVzdGltYXRlR2FzID0gdGhpcy5lc3RpbWF0ZUdhcy5iaW5kKHRoaXMpO1xuICAgIGV4ZWN1dGUuZ2V0RGF0YSA9IHRoaXMuZ2V0RGF0YS5iaW5kKHRoaXMpO1xuICAgIHZhciBkaXNwbGF5TmFtZSA9IHRoaXMuZGlzcGxheU5hbWUoKTtcbiAgICBpZiAoIWNvbnRyYWN0W2Rpc3BsYXlOYW1lXSkge1xuICAgICAgICBjb250cmFjdFtkaXNwbGF5TmFtZV0gPSBleGVjdXRlO1xuICAgIH1cbiAgICBjb250cmFjdFtkaXNwbGF5TmFtZV1bdGhpcy50eXBlTmFtZSgpXSA9IGV4ZWN1dGU7IC8vIGNpcmN1bGFyISEhIVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTb2xpZGl0eUZ1bmN0aW9uO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBodHRwcHJvdmlkZXIuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqICAgTWFyaWFuIE9hbmNlYSA8bWFyaWFuQGV0aGRldi5jb20+XG4gKiAgIEZhYmlhbiBWb2dlbHN0ZWxsZXIgPGZhYmlhbkBldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG4vLyB3b3JrYXJvdW5kIHRvIHVzZSBodHRwcHJvdmlkZXIgaW4gZGlmZmVyZW50IGVudnNcblxuLy8gYnJvd3NlclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5YTUxIdHRwUmVxdWVzdCkge1xuICBYTUxIdHRwUmVxdWVzdCA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdDsgLy8ganNoaW50IGlnbm9yZTogbGluZVxuLy8gbm9kZVxufSBlbHNlIHtcbiAgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpLlhNTEh0dHBSZXF1ZXN0OyAvLyBqc2hpbnQgaWdub3JlOiBsaW5lXG59XG5cbnZhciBYSFIyID0gcmVxdWlyZSgneGhyMi1jb29raWVzJykuWE1MSHR0cFJlcXVlc3Q7IC8vIGpzaGludCBpZ25vcmU6IGxpbmVcblxuLyoqXG4gKiBIdHRwUHJvdmlkZXIgc2hvdWxkIGJlIHVzZWQgdG8gc2VuZCBycGMgY2FsbHMgb3ZlciBodHRwXG4gKi9cbnZhciBIdHRwUHJvdmlkZXIgPSBmdW5jdGlvbiAoaG9zdCwgdGltZW91dCwgdXNlciwgcGFzc3dvcmQsIGhlYWRlcnMpIHtcbiAgdGhpcy5ob3N0ID0gaG9zdCB8fCAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JztcbiAgdGhpcy50aW1lb3V0ID0gdGltZW91dCB8fCAwO1xuICB0aGlzLnVzZXIgPSB1c2VyO1xuICB0aGlzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcHJlcGFyZSBuZXcgWE1MSHR0cFJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHByZXBhcmVSZXF1ZXN0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUgaWYgcmVxdWVzdCBzaG91bGQgYmUgYXN5bmNcbiAqIEByZXR1cm4ge1hNTEh0dHBSZXF1ZXN0fSBvYmplY3RcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5wcmVwYXJlUmVxdWVzdCA9IGZ1bmN0aW9uIChhc3luYykge1xuICB2YXIgcmVxdWVzdDtcblxuICBpZiAoYXN5bmMpIHtcbiAgICByZXF1ZXN0ID0gbmV3IFhIUjIoKTtcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSB0aGlzLnRpbWVvdXQ7XG4gIH0gZWxzZSB7XG4gICAgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICB9XG4gIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICByZXF1ZXN0Lm9wZW4oJ1BPU1QnLCB0aGlzLmhvc3QsIGFzeW5jKTtcbiAgaWYgKHRoaXMudXNlciAmJiB0aGlzLnBhc3N3b3JkKSB7XG4gICAgdmFyIGF1dGggPSAnQmFzaWMgJyArIG5ldyBCdWZmZXIodGhpcy51c2VyICsgJzonICsgdGhpcy5wYXNzd29yZCkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsIGF1dGgpO1xuICB9IHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgaWYodGhpcy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihoZWFkZXIpIHtcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLm5hbWUsIGhlYWRlci52YWx1ZSk7XG4gICAgICB9KTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBtYWtlIHN5bmMgcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZFxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEByZXR1cm4ge09iamVjdH0gcmVzdWx0XG4gKi9cbkh0dHBQcm92aWRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gIHZhciByZXF1ZXN0ID0gdGhpcy5wcmVwYXJlUmVxdWVzdChmYWxzZSk7XG5cbiAgdHJ5IHtcbiAgICByZXF1ZXN0LnNlbmQoSlNPTi5zdHJpbmdpZnkocGF5bG9hZCkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IGVycm9ycy5JbnZhbGlkQ29ubmVjdGlvbih0aGlzLmhvc3QpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuXG4gIHRyeSB7XG4gICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBtYWtlIGFzeW5jIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHNlbmRBc3luY1xuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIHRyaWdnZXJlZCBvbiBlbmQgd2l0aCAoZXJyLCByZXN1bHQpXG4gKi9cbkh0dHBQcm92aWRlci5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24gKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIHZhciByZXF1ZXN0ID0gdGhpcy5wcmVwYXJlUmVxdWVzdCh0cnVlKTtcblxuICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVxdWVzdC5yZWFkeVN0YXRlID09PSA0ICYmIHJlcXVlc3QudGltZW91dCAhPT0gMSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICAgICAgdmFyIGVycm9yID0gbnVsbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmVzdWx0ID0gSlNPTi5wYXJzZShyZXN1bHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvciA9IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UocmVxdWVzdC5yZXNwb25zZVRleHQpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhlcnJvciwgcmVzdWx0KTtcbiAgICB9XG4gIH07XG5cbiAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soZXJyb3JzLkNvbm5lY3Rpb25UaW1lb3V0KHRoaXMudGltZW91dCkpO1xuICB9O1xuXG4gIHRyeSB7XG4gICAgcmVxdWVzdC5zZW5kKEpTT04uc3RyaW5naWZ5KHBheWxvYWQpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYWxsYmFjayhlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24odGhpcy5ob3N0KSk7XG4gIH1cbn07XG5cbi8qKlxuICogU3luY2hyb25vdXNseSB0cmllcyB0byBtYWtlIEh0dHAgcmVxdWVzdFxuICpcbiAqIEBtZXRob2QgaXNDb25uZWN0ZWRcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHJldHVybnMgdHJ1ZSBpZiByZXF1ZXN0IGhhdmVuJ3QgZmFpbGVkLiBPdGhlcndpc2UgZmFsc2VcbiAqL1xuSHR0cFByb3ZpZGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB0aGlzLnNlbmQoe1xuICAgICAgaWQ6IDk5OTk5OTk5OTksXG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgIG1ldGhvZDogJ25ldF9saXN0ZW5pbmcnLFxuICAgICAgcGFyYW1zOiBbXVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0dHBQcm92aWRlcjtcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBpYmFuLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBCaWdOdW1iZXIgPSByZXF1aXJlKCdiaWdudW1iZXIuanMnKTtcblxudmFyIHBhZExlZnQgPSBmdW5jdGlvbiAoc3RyaW5nLCBieXRlcykge1xuICAgIHZhciByZXN1bHQgPSBzdHJpbmc7XG4gICAgd2hpbGUgKHJlc3VsdC5sZW5ndGggPCBieXRlcyAqIDIpIHtcbiAgICAgICAgcmVzdWx0ID0gJzAnICsgcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBQcmVwYXJlIGFuIElCQU4gZm9yIG1vZCA5NyBjb21wdXRhdGlvbiBieSBtb3ZpbmcgdGhlIGZpcnN0IDQgY2hhcnMgdG8gdGhlIGVuZCBhbmQgdHJhbnNmb3JtaW5nIHRoZSBsZXR0ZXJzIHRvXG4gKiBudW1iZXJzIChBID0gMTAsIEIgPSAxMSwgLi4uLCBaID0gMzUpLCBhcyBzcGVjaWZpZWQgaW4gSVNPMTM2MTYuXG4gKlxuICogQG1ldGhvZCBpc28xMzYxNlByZXBhcmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuIHRoZSBJQkFOXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcHJlcGFyZWQgSUJBTlxuICovXG52YXIgaXNvMTM2MTZQcmVwYXJlID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICB2YXIgQSA9ICdBJy5jaGFyQ29kZUF0KDApO1xuICAgIHZhciBaID0gJ1onLmNoYXJDb2RlQXQoMCk7XG5cbiAgICBpYmFuID0gaWJhbi50b1VwcGVyQ2FzZSgpO1xuICAgIGliYW4gPSBpYmFuLnN1YnN0cig0KSArIGliYW4uc3Vic3RyKDAsNCk7XG5cbiAgICByZXR1cm4gaWJhbi5zcGxpdCgnJykubWFwKGZ1bmN0aW9uKG4pe1xuICAgICAgICB2YXIgY29kZSA9IG4uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgaWYgKGNvZGUgPj0gQSAmJiBjb2RlIDw9IFope1xuICAgICAgICAgICAgLy8gQSA9IDEwLCBCID0gMTEsIC4uLiBaID0gMzVcbiAgICAgICAgICAgIHJldHVybiBjb2RlIC0gQSArIDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cbiAgICB9KS5qb2luKCcnKTtcbn07XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgTU9EIDk3IDEwIG9mIHRoZSBwYXNzZWQgSUJBTiBhcyBzcGVjaWZpZWQgaW4gSVNPNzA2NC5cbiAqXG4gKiBAbWV0aG9kIG1vZDk3MTBcbiAqIEBwYXJhbSB7U3RyaW5nfSBpYmFuXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG52YXIgbW9kOTcxMCA9IGZ1bmN0aW9uIChpYmFuKSB7XG4gICAgdmFyIHJlbWFpbmRlciA9IGliYW4sXG4gICAgICAgIGJsb2NrO1xuXG4gICAgd2hpbGUgKHJlbWFpbmRlci5sZW5ndGggPiAyKXtcbiAgICAgICAgYmxvY2sgPSByZW1haW5kZXIuc2xpY2UoMCwgOSk7XG4gICAgICAgIHJlbWFpbmRlciA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIHJlbWFpbmRlci5zbGljZShibG9jay5sZW5ndGgpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZUludChyZW1haW5kZXIsIDEwKSAlIDk3O1xufTtcblxuLyoqXG4gKiBUaGlzIHByb3RvdHlwZSBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgaWJhbiBvYmplY3QgZnJvbSBpYmFuIGNvcnJlY3Qgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGliYW5cbiAqL1xudmFyIEliYW4gPSBmdW5jdGlvbiAoaWJhbikge1xuICAgIHRoaXMuX2liYW4gPSBpYmFuO1xufTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgdXNlZCB0byBjcmVhdGUgaWJhbiBvYmplY3QgZnJvbSBldGhlcmV1bSBhZGRyZXNzXG4gKlxuICogQG1ldGhvZCBmcm9tQWRkcmVzc1xuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3NcbiAqIEByZXR1cm4ge0liYW59IHRoZSBJQkFOIG9iamVjdFxuICovXG5JYmFuLmZyb21BZGRyZXNzID0gZnVuY3Rpb24gKGFkZHJlc3MpIHtcbiAgICB2YXIgYXNCbiA9IG5ldyBCaWdOdW1iZXIoYWRkcmVzcywgMTYpO1xuICAgIHZhciBiYXNlMzYgPSBhc0JuLnRvU3RyaW5nKDM2KTtcbiAgICB2YXIgcGFkZGVkID0gcGFkTGVmdChiYXNlMzYsIDE1KTtcbiAgICByZXR1cm4gSWJhbi5mcm9tQmJhbihwYWRkZWQudG9VcHBlckNhc2UoKSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnQgdGhlIHBhc3NlZCBCQkFOIHRvIGFuIElCQU4gZm9yIHRoaXMgY291bnRyeSBzcGVjaWZpY2F0aW9uLlxuICogUGxlYXNlIG5vdGUgdGhhdCA8aT5cImdlbmVyYXRpb24gb2YgdGhlIElCQU4gc2hhbGwgYmUgdGhlIGV4Y2x1c2l2ZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgYmFuay9icmFuY2ggc2VydmljaW5nIHRoZSBhY2NvdW50XCI8L2k+LlxuICogVGhpcyBtZXRob2QgaW1wbGVtZW50cyB0aGUgcHJlZmVycmVkIGFsZ29yaXRobSBkZXNjcmliZWQgaW4gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9JbnRlcm5hdGlvbmFsX0JhbmtfQWNjb3VudF9OdW1iZXIjR2VuZXJhdGluZ19JQkFOX2NoZWNrX2RpZ2l0c1xuICpcbiAqIEBtZXRob2QgZnJvbUJiYW5cbiAqIEBwYXJhbSB7U3RyaW5nfSBiYmFuIHRoZSBCQkFOIHRvIGNvbnZlcnQgdG8gSUJBTlxuICogQHJldHVybnMge0liYW59IHRoZSBJQkFOIG9iamVjdFxuICovXG5JYmFuLmZyb21CYmFuID0gZnVuY3Rpb24gKGJiYW4pIHtcbiAgICB2YXIgY291bnRyeUNvZGUgPSAnWEUnO1xuXG4gICAgdmFyIHJlbWFpbmRlciA9IG1vZDk3MTAoaXNvMTM2MTZQcmVwYXJlKGNvdW50cnlDb2RlICsgJzAwJyArIGJiYW4pKTtcbiAgICB2YXIgY2hlY2tEaWdpdCA9ICgnMCcgKyAoOTggLSByZW1haW5kZXIpKS5zbGljZSgtMik7XG5cbiAgICByZXR1cm4gbmV3IEliYW4oY291bnRyeUNvZGUgKyBjaGVja0RpZ2l0ICsgYmJhbik7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBJQkFOIG9iamVjdCBmb3IgZ2l2ZW4gaW5zdGl0dXRpb24gYW5kIGlkZW50aWZpZXJcbiAqXG4gKiBAbWV0aG9kIGNyZWF0ZUluZGlyZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucywgcmVxdWlyZWQgb3B0aW9ucyBhcmUgXCJpbnN0aXR1dGlvblwiIGFuZCBcImlkZW50aWZpZXJcIlxuICogQHJldHVybiB7SWJhbn0gdGhlIElCQU4gb2JqZWN0XG4gKi9cbkliYW4uY3JlYXRlSW5kaXJlY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBJYmFuLmZyb21CYmFuKCdFVEgnICsgb3B0aW9ucy5pbnN0aXR1dGlvbiArIG9wdGlvbnMuaWRlbnRpZmllcik7XG59O1xuXG4vKipcbiAqIFRob3MgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIGNoZWNrIGlmIGdpdmVuIHN0cmluZyBpcyB2YWxpZCBpYmFuIG9iamVjdFxuICpcbiAqIEBtZXRob2QgaXNWYWxpZFxuICogQHBhcmFtIHtTdHJpbmd9IGliYW4gc3RyaW5nXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzIHZhbGlkIElCQU5cbiAqL1xuSWJhbi5pc1ZhbGlkID0gZnVuY3Rpb24gKGliYW4pIHtcbiAgICB2YXIgaSA9IG5ldyBJYmFuKGliYW4pO1xuICAgIHJldHVybiBpLmlzVmFsaWQoKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIGlzIGNvcnJlY3RcbiAqXG4gKiBAbWV0aG9kIGlzVmFsaWRcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIGl0IGlzLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuSWJhbi5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gL15YRVswLTldezJ9KEVUSFswLTlBLVpdezEzfXxbMC05QS1aXXszMCwzMX0pJC8udGVzdCh0aGlzLl9pYmFuKSAmJlxuICAgICAgICBtb2Q5NzEwKGlzbzEzNjE2UHJlcGFyZSh0aGlzLl9pYmFuKSkgPT09IDE7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgaWJhbiBudW1iZXIgaXMgZGlyZWN0XG4gKlxuICogQG1ldGhvZCBpc0RpcmVjdFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5JYmFuLnByb3RvdHlwZS5pc0RpcmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faWJhbi5sZW5ndGggPT09IDM0IHx8IHRoaXMuX2liYW4ubGVuZ3RoID09PSAzNTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBjaGVjayBpZiBpYmFuIG51bWJlciBpZiBpbmRpcmVjdFxuICpcbiAqIEBtZXRob2QgaXNJbmRpcmVjdFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMsIG90aGVyd2lzZSBmYWxzZVxuICovXG5JYmFuLnByb3RvdHlwZS5pc0luZGlyZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pYmFuLmxlbmd0aCA9PT0gMjA7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGliYW4gY2hlY2tzdW1cbiAqIFVzZXMgdGhlIG1vZC05Ny0xMCBjaGVja3N1bW1pbmcgcHJvdG9jb2wgKElTTy9JRUMgNzA2NDoyMDAzKVxuICpcbiAqIEBtZXRob2QgY2hlY2tzdW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGNoZWNrc3VtXG4gKi9cbkliYW4ucHJvdG90eXBlLmNoZWNrc3VtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9pYmFuLnN1YnN0cigyLCAyKTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBnZXQgaW5zdGl0dXRpb24gaWRlbnRpZmllclxuICogZWcuIFhSRUdcbiAqXG4gKiBAbWV0aG9kIGluc3RpdHV0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBpbnN0aXR1dGlvbiBpZGVudGlmaWVyXG4gKi9cbkliYW4ucHJvdG90eXBlLmluc3RpdHV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlzSW5kaXJlY3QoKSA/IHRoaXMuX2liYW4uc3Vic3RyKDcsIDQpIDogJyc7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGNsaWVudCBpZGVudGlmaWVyIHdpdGhpbiBpbnN0aXR1dGlvblxuICogZWcuIEdBVk9GWU9SS1xuICpcbiAqIEBtZXRob2QgY2xpZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBjbGllbnQgaWRlbnRpZmllclxuICovXG5JYmFuLnByb3RvdHlwZS5jbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbmRpcmVjdCgpID8gdGhpcy5faWJhbi5zdWJzdHIoMTEpIDogJyc7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZ2V0IGNsaWVudCBkaXJlY3QgYWRkcmVzc1xuICpcbiAqIEBtZXRob2QgYWRkcmVzc1xuICogQHJldHVybnMge1N0cmluZ30gY2xpZW50IGRpcmVjdCBhZGRyZXNzXG4gKi9cbkliYW4ucHJvdG90eXBlLmFkZHJlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXJlY3QoKSkge1xuICAgICAgICB2YXIgYmFzZTM2ID0gdGhpcy5faWJhbi5zdWJzdHIoNCk7XG4gICAgICAgIHZhciBhc0JuID0gbmV3IEJpZ051bWJlcihiYXNlMzYsIDM2KTtcbiAgICAgICAgcmV0dXJuIHBhZExlZnQoYXNCbi50b1N0cmluZygxNiksIDIwKTtcbiAgICB9IFxuXG4gICAgcmV0dXJuICcnO1xufTtcblxuSWJhbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2liYW47XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEliYW47XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgaXBjcHJvdmlkZXIuanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG5cbnZhciBJcGNQcm92aWRlciA9IGZ1bmN0aW9uIChwYXRoLCBuZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3MgPSB7fTtcbiAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgIFxuICAgIHRoaXMuY29ubmVjdGlvbiA9IG5ldC5jb25uZWN0KHtwYXRoOiB0aGlzLnBhdGh9KTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbignZXJyb3InLCBmdW5jdGlvbihlKXtcbiAgICAgICAgY29uc29sZS5lcnJvcignSVBDIENvbm5lY3Rpb24gRXJyb3InLCBlKTtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuY29ubmVjdGlvbi5vbignZW5kJywgZnVuY3Rpb24oKXtcbiAgICAgICAgX3RoaXMuX3RpbWVvdXQoKTtcbiAgICB9KTsgXG5cblxuICAgIC8vIExJU1RFTiBGT1IgQ09OTkVDVElPTiBSRVNQT05TRVNcbiAgICB0aGlzLmNvbm5lY3Rpb24ub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDYgKi9cblxuICAgICAgICBfdGhpcy5fcGFyc2VSZXNwb25zZShkYXRhLnRvU3RyaW5nKCkpLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0KXtcblxuICAgICAgICAgICAgdmFyIGlkID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBpZCB3aGljaCBtYXRjaGVzIHRoZSByZXR1cm5lZCBpZFxuICAgICAgICAgICAgaWYodXRpbHMuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24obG9hZCl7XG4gICAgICAgICAgICAgICAgICAgIGlmKF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2xvYWQuaWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWQgPSBsb2FkLmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IHJlc3VsdC5pZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmlyZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgIGlmKF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2lkXShudWxsLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxuLyoqXG5XaWxsIHBhcnNlIHRoZSByZXNwb25zZSBhbmQgbWFrZSBhbiBhcnJheSBvdXQgb2YgaXQuXG5cbkBtZXRob2QgX3BhcnNlUmVzcG9uc2VcbkBwYXJhbSB7U3RyaW5nfSBkYXRhXG4qL1xuSXBjUHJvdmlkZXIucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICAgIHJldHVyblZhbHVlcyA9IFtdO1xuICAgIFxuICAgIC8vIERFLUNIVU5LRVJcbiAgICB2YXIgZGVjaHVua2VkRGF0YSA9IGRhdGFcbiAgICAgICAgLnJlcGxhY2UoL1xcfVtcXG5cXHJdP1xcey9nLCd9fC0tfHsnKSAvLyB9e1xuICAgICAgICAucmVwbGFjZSgvXFx9XFxdW1xcblxccl0/XFxbXFx7L2csJ31dfC0tfFt7JykgLy8gfV1be1xuICAgICAgICAucmVwbGFjZSgvXFx9W1xcblxccl0/XFxbXFx7L2csJ318LS18W3snKSAvLyB9W3tcbiAgICAgICAgLnJlcGxhY2UoL1xcfVxcXVtcXG5cXHJdP1xcey9nLCd9XXwtLXx7JykgLy8gfV17XG4gICAgICAgIC5zcGxpdCgnfC0tfCcpO1xuXG4gICAgZGVjaHVua2VkRGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpe1xuXG4gICAgICAgIC8vIHByZXBlbmQgdGhlIGxhc3QgY2h1bmtcbiAgICAgICAgaWYoX3RoaXMubGFzdENodW5rKVxuICAgICAgICAgICAgZGF0YSA9IF90aGlzLmxhc3RDaHVuayArIGRhdGE7XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG5cbiAgICAgICAgfSBjYXRjaChlKSB7XG5cbiAgICAgICAgICAgIF90aGlzLmxhc3RDaHVuayA9IGRhdGE7XG5cbiAgICAgICAgICAgIC8vIHN0YXJ0IHRpbWVvdXQgdG8gY2FuY2VsIGFsbCByZXF1ZXN0c1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICAgICAgX3RoaXMubGFzdENodW5rVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBfdGhpcy5fdGltZW91dCgpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkUmVzcG9uc2UoZGF0YSk7XG4gICAgICAgICAgICB9LCAxMDAwICogMTUpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBjYW5jZWwgdGltZW91dCBhbmQgc2V0IGNodW5rIHRvIG51bGxcbiAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmxhc3RDaHVua1RpbWVvdXQpO1xuICAgICAgICBfdGhpcy5sYXN0Q2h1bmsgPSBudWxsO1xuXG4gICAgICAgIGlmKHJlc3VsdClcbiAgICAgICAgICAgIHJldHVyblZhbHVlcy5wdXNoKHJlc3VsdCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufTtcblxuXG4vKipcbkdldCB0aGUgYWRkcyBhIGNhbGxiYWNrIHRvIHRoZSByZXNwb25zZUNhbGxiYWNrcyBvYmplY3QsXG53aGljaCB3aWxsIGJlIGNhbGxlZCBpZiBhIHJlc3BvbnNlIG1hdGNoaW5nIHRoZSByZXNwb25zZSBJZCB3aWxsIGFycml2ZS5cblxuQG1ldGhvZCBfYWRkUmVzcG9uc2VDYWxsYmFja1xuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fYWRkUmVzcG9uc2VDYWxsYmFjayA9IGZ1bmN0aW9uKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gcGF5bG9hZC5pZCB8fCBwYXlsb2FkWzBdLmlkO1xuICAgIHZhciBtZXRob2QgPSBwYXlsb2FkLm1ldGhvZCB8fCBwYXlsb2FkWzBdLm1ldGhvZDtcblxuICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3NbaWRdID0gY2FsbGJhY2s7XG4gICAgdGhpcy5yZXNwb25zZUNhbGxiYWNrc1tpZF0ubWV0aG9kID0gbWV0aG9kO1xufTtcblxuLyoqXG5UaW1lb3V0IGFsbCByZXF1ZXN0cyB3aGVuIHRoZSBlbmQvZXJyb3IgZXZlbnQgaXMgZmlyZWRcblxuQG1ldGhvZCBfdGltZW91dFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5fdGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIga2V5IGluIHRoaXMucmVzcG9uc2VDYWxsYmFja3MpIHtcbiAgICAgICAgaWYodGhpcy5yZXNwb25zZUNhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2VDYWxsYmFja3Nba2V5XShlcnJvcnMuSW52YWxpZENvbm5lY3Rpb24oJ29uIElQQycpKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlc3BvbnNlQ2FsbGJhY2tzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuQ2hlY2sgaWYgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBpcyBzdGlsbCB2YWxpZC5cblxuQG1ldGhvZCBpc0Nvbm5lY3RlZFxuKi9cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5pc0Nvbm5lY3RlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyB0cnkgcmVjb25uZWN0LCB3aGVuIGNvbm5lY3Rpb24gaXMgZ29uZVxuICAgIGlmKCFfdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICBfdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IF90aGlzLnBhdGh9KTtcblxuICAgIHJldHVybiAhIXRoaXMuY29ubmVjdGlvbi53cml0YWJsZTtcbn07XG5cbklwY1Byb3ZpZGVyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcblxuICAgIGlmKHRoaXMuY29ubmVjdGlvbi53cml0ZVN5bmMpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcblxuICAgICAgICAvLyB0cnkgcmVjb25uZWN0LCB3aGVuIGNvbm5lY3Rpb24gaXMgZ29uZVxuICAgICAgICBpZighdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3Qoe3BhdGg6IHRoaXMucGF0aH0pO1xuXG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5jb25uZWN0aW9uLndyaXRlU3luYyhKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShkYXRhKTsgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgdHJpZWQgdG8gc2VuZCBcIicrIHBheWxvYWQubWV0aG9kICsnXCIgc3luY2hyb25vdXNseS4gU3luY2hyb25vdXMgcmVxdWVzdHMgYXJlIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIElQQyBwcm92aWRlci4nKTtcbiAgICB9XG59O1xuXG5JcGNQcm92aWRlci5wcm90b3R5cGUuc2VuZEFzeW5jID0gZnVuY3Rpb24gKHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgLy8gdHJ5IHJlY29ubmVjdCwgd2hlbiBjb25uZWN0aW9uIGlzIGdvbmVcbiAgICBpZighdGhpcy5jb25uZWN0aW9uLndyaXRhYmxlKVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCh7cGF0aDogdGhpcy5wYXRofSk7XG5cblxuICAgIHRoaXMuY29ubmVjdGlvbi53cml0ZShKU09OLnN0cmluZ2lmeShwYXlsb2FkKSk7XG4gICAgdGhpcy5fYWRkUmVzcG9uc2VDYWxsYmFjayhwYXlsb2FkLCBjYWxsYmFjayk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElwY1Byb3ZpZGVyO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGpzb25ycGMuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqICAgQWFyb24gS3VtYXZpcyA8YWFyb25Aa3VtYXZpcy5tZT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG4vLyBJbml0aWFsaXplIEpzb25ycGMgYXMgYSBzaW1wbGUgb2JqZWN0IHdpdGggdXRpbGl0eSBmdW5jdGlvbnMuXG52YXIgSnNvbnJwYyA9IHtcbiAgICBtZXNzYWdlSWQ6IDBcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byB2YWxpZCBqc29uIGNyZWF0ZSBwYXlsb2FkIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdG9QYXlsb2FkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXRob2Qgb2YganNvbnJwYyBjYWxsLCByZXF1aXJlZFxuICogQHBhcmFtIHtBcnJheX0gcGFyYW1zLCBhbiBhcnJheSBvZiBtZXRob2QgcGFyYW1zLCBvcHRpb25hbFxuICogQHJldHVybnMge09iamVjdH0gdmFsaWQganNvbnJwYyBwYXlsb2FkIG9iamVjdFxuICovXG5Kc29ucnBjLnRvUGF5bG9hZCA9IGZ1bmN0aW9uIChtZXRob2QsIHBhcmFtcykge1xuICAgIGlmICghbWV0aG9kKVxuICAgICAgICBjb25zb2xlLmVycm9yKCdqc29ucnBjIG1ldGhvZCBzaG91bGQgYmUgc3BlY2lmaWVkIScpO1xuXG4gICAgLy8gYWR2YW5jZSBtZXNzYWdlIElEXG4gICAgSnNvbnJwYy5tZXNzYWdlSWQrKztcblxuICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICBpZDogSnNvbnJwYy5tZXNzYWdlSWQsXG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCBbXVxuICAgIH07XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYganNvbnJwYyByZXNwb25zZSBpcyB2YWxpZFxuICpcbiAqIEBtZXRob2QgaXNWYWxpZFJlc3BvbnNlXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEByZXR1cm5zIHtCb29sZWFufSB0cnVlIGlmIHJlc3BvbnNlIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXNwb25zZSkgPyByZXNwb25zZS5ldmVyeSh2YWxpZGF0ZVNpbmdsZU1lc3NhZ2UpIDogdmFsaWRhdGVTaW5nbGVNZXNzYWdlKHJlc3BvbnNlKTtcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2luZ2xlTWVzc2FnZShtZXNzYWdlKXtcbiAgICAgIHJldHVybiAhIW1lc3NhZ2UgJiZcbiAgICAgICAgIW1lc3NhZ2UuZXJyb3IgJiZcbiAgICAgICAgbWVzc2FnZS5qc29ucnBjID09PSAnMi4wJyAmJlxuICAgICAgICB0eXBlb2YgbWVzc2FnZS5pZCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgbWVzc2FnZS5yZXN1bHQgIT09IHVuZGVmaW5lZDsgLy8gb25seSB1bmRlZmluZWQgaXMgbm90IHZhbGlkIGpzb24gb2JqZWN0XG4gICAgfVxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBiYXRjaCBwYXlsb2FkIG9iamVjdFxuICpcbiAqIEBtZXRob2QgdG9CYXRjaFBheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2VzLCBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggbWV0aG9kIChyZXF1aXJlZCkgYW5kIHBhcmFtcyAob3B0aW9uYWwpIGZpZWxkc1xuICogQHJldHVybnMge0FycmF5fSBiYXRjaCBwYXlsb2FkXG4gKi9cbkpzb25ycGMudG9CYXRjaFBheWxvYWQgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICByZXR1cm4gbWVzc2FnZXMubWFwKGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBKc29ucnBjLnRvUGF5bG9hZChtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZS5wYXJhbXMpO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucnBjO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqXG4gKiBAZmlsZSBtZXRob2QuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBlcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuXG52YXIgTWV0aG9kID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLm5hbWUgPSBvcHRpb25zLm5hbWU7XG4gICAgdGhpcy5jYWxsID0gb3B0aW9ucy5jYWxsO1xuICAgIHRoaXMucGFyYW1zID0gb3B0aW9ucy5wYXJhbXMgfHwgMDtcbiAgICB0aGlzLmlucHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLm91dHB1dEZvcm1hdHRlciA9IG9wdGlvbnMub3V0cHV0Rm9ybWF0dGVyO1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBudWxsO1xufTtcblxuTWV0aG9kLnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChybSkge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBybTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIG5hbWUgb2YgdGhlIGpzb25ycGMgbWV0aG9kIGJhc2VkIG9uIGFyZ3VtZW50c1xuICpcbiAqIEBtZXRob2QgZ2V0Q2FsbFxuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG5hbWUgb2YganNvbnJwYyBtZXRob2RcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5nZXRDYWxsID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICByZXR1cm4gdXRpbHMuaXNGdW5jdGlvbih0aGlzLmNhbGwpID8gdGhpcy5jYWxsKGFyZ3MpIDogdGhpcy5jYWxsO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBleHRyYWN0IGNhbGxiYWNrIGZyb20gYXJyYXkgb2YgYXJndW1lbnRzLiBNb2RpZmllcyBpbnB1dCBwYXJhbVxuICpcbiAqIEBtZXRob2QgZXh0cmFjdENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufE51bGx9IGNhbGxiYWNrLCBpZiBleGlzdHNcbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5leHRyYWN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIGlmICh1dGlscy5pc0Z1bmN0aW9uKGFyZ3NbYXJncy5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3MucG9wKCk7IC8vIG1vZGlmeSB0aGUgYXJncyBhcnJheSFcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gY2hlY2sgaWYgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgaXMgY29ycmVjdFxuICogXG4gKiBAbWV0aG9kIHZhbGlkYXRlQXJnc1xuICogQHBhcmFtIHtBcnJheX0gYXJndW1lbnRzXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgaXQgaXMgbm90XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUudmFsaWRhdGVBcmdzID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggIT09IHRoaXMucGFyYW1zKSB7XG4gICAgICAgIHRocm93IGVycm9ycy5JbnZhbGlkTnVtYmVyT2ZSUENQYXJhbXMoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gZm9ybWF0IGlucHV0IGFyZ3Mgb2YgbWV0aG9kXG4gKiBcbiAqIEBtZXRob2QgZm9ybWF0SW5wdXRcbiAqIEBwYXJhbSB7QXJyYXl9XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS5mb3JtYXRJbnB1dCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKCF0aGlzLmlucHV0Rm9ybWF0dGVyKSB7XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmlucHV0Rm9ybWF0dGVyLm1hcChmdW5jdGlvbiAoZm9ybWF0dGVyLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZm9ybWF0dGVyID8gZm9ybWF0dGVyKGFyZ3NbaW5kZXhdKSA6IGFyZ3NbaW5kZXhdO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGZvcm1hdCBvdXRwdXQocmVzdWx0KSBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdE91dHB1dFxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbk1ldGhvZC5wcm90b3R5cGUuZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciAmJiByZXN1bHQgPyB0aGlzLm91dHB1dEZvcm1hdHRlcihyZXN1bHQpIDogcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgY3JlYXRlIHBheWxvYWQgZnJvbSBnaXZlbiBpbnB1dCBhcmdzXG4gKlxuICogQG1ldGhvZCB0b1BheWxvYWRcbiAqIEBwYXJhbSB7QXJyYXl9IGFyZ3NcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuTWV0aG9kLnByb3RvdHlwZS50b1BheWxvYWQgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHZhciBjYWxsID0gdGhpcy5nZXRDYWxsKGFyZ3MpO1xuICAgIHZhciBjYWxsYmFjayA9IHRoaXMuZXh0cmFjdENhbGxiYWNrKGFyZ3MpO1xuICAgIHZhciBwYXJhbXMgPSB0aGlzLmZvcm1hdElucHV0KGFyZ3MpO1xuICAgIHRoaXMudmFsaWRhdGVBcmdzKHBhcmFtcyk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2Q6IGNhbGwsXG4gICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9O1xufTtcblxuTWV0aG9kLnByb3RvdHlwZS5hdHRhY2hUb09iamVjdCA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZnVuYyA9IHRoaXMuYnVpbGRDYWxsKCk7XG4gICAgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShmdW5jLCAnY2FsbCcsIHsgdmFsdWU6IHRoaXMuY2FsbCB9KVxyXG4gICAgdmFyIG5hbWUgPSB0aGlzLm5hbWUuc3BsaXQoJy4nKTtcbiAgICBpZiAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgIG9ialtuYW1lWzBdXSA9IG9ialtuYW1lWzBdXSB8fCB7fTtcbiAgICAgICAgb2JqW25hbWVbMF1dW25hbWVbMV1dID0gZnVuYztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvYmpbbmFtZVswXV0gPSBmdW5jOyBcbiAgICB9XG59O1xuXG5NZXRob2QucHJvdG90eXBlLmJ1aWxkQ2FsbCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBtZXRob2QgPSB0aGlzO1xuICAgIHZhciBzZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGF5bG9hZCA9IG1ldGhvZC50b1BheWxvYWQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgIGlmIChwYXlsb2FkLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kLnJlcXVlc3RNYW5hZ2VyLnNlbmRBc3luYyhwYXlsb2FkLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGxiYWNrKGVyciwgbWV0aG9kLmZvcm1hdE91dHB1dChyZXN1bHQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRob2QuZm9ybWF0T3V0cHV0KG1ldGhvZC5yZXF1ZXN0TWFuYWdlci5zZW5kKHBheWxvYWQpKTtcbiAgICB9O1xuICAgIHNlbmQucmVxdWVzdCA9IHRoaXMucmVxdWVzdC5iaW5kKHRoaXMpO1xuICAgIHJldHVybiBzZW5kO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBwdXJlIEpTT05SUEMgcmVxdWVzdCB3aGljaCBjYW4gYmUgdXNlZCBpbiBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcGFyYW0gey4uLn0gcGFyYW1zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb25ycGMgcmVxdWVzdFxuICovXG5NZXRob2QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBheWxvYWQgPSB0aGlzLnRvUGF5bG9hZChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICBwYXlsb2FkLmZvcm1hdCA9IHRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1ldGhvZDtcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogQGZpbGUgZGIuanNcbiAqIEBhdXRob3JzOlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZSgnLi4vbWV0aG9kJyk7XG5cbnZhciBEQiA9IGZ1bmN0aW9uICh3ZWIzKSB7XG4gICAgdGhpcy5fcmVxdWVzdE1hbmFnZXIgPSB3ZWIzLl9yZXF1ZXN0TWFuYWdlcjtcblxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBcbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHsgXG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHdlYjMuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn07XG5cbnZhciBtZXRob2RzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwdXRTdHJpbmcgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3B1dFN0cmluZycsXG4gICAgICAgIGNhbGw6ICdkYl9wdXRTdHJpbmcnLFxuICAgICAgICBwYXJhbXM6IDNcbiAgICB9KTtcblxuICAgIHZhciBnZXRTdHJpbmcgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFN0cmluZycsXG4gICAgICAgIGNhbGw6ICdkYl9nZXRTdHJpbmcnLFxuICAgICAgICBwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHZhciBwdXRIZXggPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3B1dEhleCcsXG4gICAgICAgIGNhbGw6ICdkYl9wdXRIZXgnLFxuICAgICAgICBwYXJhbXM6IDNcbiAgICB9KTtcblxuICAgIHZhciBnZXRIZXggPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldEhleCcsXG4gICAgICAgIGNhbGw6ICdkYl9nZXRIZXgnLFxuICAgICAgICBwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHB1dFN0cmluZywgZ2V0U3RyaW5nLCBwdXRIZXgsIGdldEhleFxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERCO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgZXRoLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGZvcm1hdHRlcnMgPSByZXF1aXJlKCcuLi9mb3JtYXR0ZXJzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91dGlscycpO1xudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcbnZhciBjID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgQ29udHJhY3QgPSByZXF1aXJlKCcuLi9jb250cmFjdCcpO1xudmFyIHdhdGNoZXMgPSByZXF1aXJlKCcuL3dhdGNoZXMnKTtcbnZhciBGaWx0ZXIgPSByZXF1aXJlKCcuLi9maWx0ZXInKTtcbnZhciBJc1N5bmNpbmcgPSByZXF1aXJlKCcuLi9zeW5jaW5nJyk7XG52YXIgbmFtZXJlZyA9IHJlcXVpcmUoJy4uL25hbWVyZWcnKTtcbnZhciBJYmFuID0gcmVxdWlyZSgnLi4vaWJhbicpO1xudmFyIHRyYW5zZmVyID0gcmVxdWlyZSgnLi4vdHJhbnNmZXInKTtcblxudmFyIGJsb2NrQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiA6IFwiZXRoX2dldEJsb2NrQnlOdW1iZXJcIjtcbn07XG5cbnZhciB0cmFuc2FjdGlvbkZyb21CbG9ja0NhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrSGFzaEFuZEluZGV4JyA6ICdldGhfZ2V0VHJhbnNhY3Rpb25CeUJsb2NrTnVtYmVyQW5kSW5kZXgnO1xufTtcblxudmFyIHVuY2xlQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRVbmNsZUJ5QmxvY2tIYXNoQW5kSW5kZXgnIDogJ2V0aF9nZXRVbmNsZUJ5QmxvY2tOdW1iZXJBbmRJbmRleCc7XG59O1xuXG52YXIgZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50Q2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgcmV0dXJuICh1dGlscy5pc1N0cmluZyhhcmdzWzBdKSAmJiBhcmdzWzBdLmluZGV4T2YoJzB4JykgPT09IDApID8gJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeUhhc2gnIDogJ2V0aF9nZXRCbG9ja1RyYW5zYWN0aW9uQ291bnRCeU51bWJlcic7XG59O1xuXG52YXIgdW5jbGVDb3VudENhbGwgPSBmdW5jdGlvbiAoYXJncykge1xuICAgIHJldHVybiAodXRpbHMuaXNTdHJpbmcoYXJnc1swXSkgJiYgYXJnc1swXS5pbmRleE9mKCcweCcpID09PSAwKSA/ICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tIYXNoJyA6ICdldGhfZ2V0VW5jbGVDb3VudEJ5QmxvY2tOdW1iZXInO1xufTtcblxuZnVuY3Rpb24gRXRoKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcblxuICAgIHByb3BlcnRpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgcC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgcC5zZXRSZXF1ZXN0TWFuYWdlcihzZWxmLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG5cblxuICAgIHRoaXMuaWJhbiA9IEliYW47XG4gICAgdGhpcy5zZW5kSUJBTlRyYW5zYWN0aW9uID0gdHJhbnNmZXIuYmluZChudWxsLCB0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0aC5wcm90b3R5cGUsICdkZWZhdWx0QmxvY2snLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjLmRlZmF1bHRCbG9jaztcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICBjLmRlZmF1bHRCbG9jayA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV0aC5wcm90b3R5cGUsICdkZWZhdWx0QWNjb3VudCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGMuZGVmYXVsdEFjY291bnQ7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgYy5kZWZhdWx0QWNjb3VudCA9IHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG59KTtcblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGdldEJhbGFuY2UgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldEJhbGFuY2UnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldEJhbGFuY2UnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0U3RvcmFnZUF0ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRTdG9yYWdlQXQnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldFN0b3JhZ2VBdCcsXG4gICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCB1dGlscy50b0hleCwgZm9ybWF0dGVycy5pbnB1dERlZmF1bHRCbG9ja051bWJlckZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBnZXRDb2RlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRDb2RlJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRDb2RlJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBmb3JtYXR0ZXJzLmlucHV0RGVmYXVsdEJsb2NrTnVtYmVyRm9ybWF0dGVyXVxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCbG9jaycsXG4gICAgICAgIGNhbGw6IGJsb2NrQ2FsbCxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlciwgZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gISF2YWw7IH1dLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmxvY2tGb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRVbmNsZSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VW5jbGUnLFxuICAgICAgICBjYWxsOiB1bmNsZUNhbGwsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QmxvY2tOdW1iZXJGb3JtYXR0ZXIsIHV0aWxzLnRvSGV4XSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dEJsb2NrRm9ybWF0dGVyLFxuXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0Q29tcGlsZXJzID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRDb21waWxlcnMnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldENvbXBpbGVycycsXG4gICAgICAgIHBhcmFtczogMFxuICAgIH0pO1xuXG4gICAgdmFyIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgY2FsbDogZ2V0QmxvY2tUcmFuc2FjdGlvbkNvdW50Q2FsbCxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0QmxvY2tVbmNsZUNvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRCbG9ja1VuY2xlQ291bnQnLFxuICAgICAgICBjYWxsOiB1bmNsZUNvdW50Q2FsbCxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRCbG9ja051bWJlckZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkJ5SGFzaCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgb3V0cHV0Rm9ybWF0dGVyOiBmb3JtYXR0ZXJzLm91dHB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0VHJhbnNhY3Rpb25Gcm9tQmxvY2sgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFRyYW5zYWN0aW9uRnJvbUJsb2NrJyxcbiAgICAgICAgY2FsbDogdHJhbnNhY3Rpb25Gcm9tQmxvY2tDYWxsLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dEJsb2NrTnVtYmVyRm9ybWF0dGVyLCB1dGlscy50b0hleF0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvbkZvcm1hdHRlclxuICAgIH0pO1xuXG4gICAgdmFyIGdldFRyYW5zYWN0aW9uUmVjZWlwdCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0VHJhbnNhY3Rpb25SZWNlaXB0JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRUcmFuc2FjdGlvblJlY2VpcHRGb3JtYXR0ZXJcbiAgICB9KTtcblxuICAgIHZhciBnZXRUcmFuc2FjdGlvbkNvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdnZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgY2FsbDogJ2V0aF9nZXRUcmFuc2FjdGlvbkNvdW50JyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdLFxuICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgIH0pO1xuXG4gICAgdmFyIHNlbmRSYXdUcmFuc2FjdGlvbiA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc2VuZFJhd1RyYW5zYWN0aW9uJyxcbiAgICAgICAgY2FsbDogJ2V0aF9zZW5kUmF3VHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzZW5kVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBzaWduVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NpZ25UcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdldGhfc2lnblRyYW5zYWN0aW9uJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRUcmFuc2FjdGlvbkZvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHZhciBzaWduID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduJyxcbiAgICAgICAgY2FsbDogJ2V0aF9zaWduJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW2Zvcm1hdHRlcnMuaW5wdXRBZGRyZXNzRm9ybWF0dGVyLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGNhbGwgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2NhbGwnLFxuICAgICAgICBjYWxsOiAnZXRoX2NhbGwnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dENhbGxGb3JtYXR0ZXIsIGZvcm1hdHRlcnMuaW5wdXREZWZhdWx0QmxvY2tOdW1iZXJGb3JtYXR0ZXJdXG4gICAgfSk7XG5cbiAgICB2YXIgZXN0aW1hdGVHYXMgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2VzdGltYXRlR2FzJyxcbiAgICAgICAgY2FsbDogJ2V0aF9lc3RpbWF0ZUdhcycsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0Q2FsbEZvcm1hdHRlcl0sXG4gICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgfSk7XG5cbiAgICB2YXIgY29tcGlsZVNvbGlkaXR5ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLnNvbGlkaXR5JyxcbiAgICAgICAgY2FsbDogJ2V0aF9jb21waWxlU29saWRpdHknLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciBjb21waWxlTExMID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLmxsbCcsXG4gICAgICAgIGNhbGw6ICdldGhfY29tcGlsZUxMTCcsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIGNvbXBpbGVTZXJwZW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdjb21waWxlLnNlcnBlbnQnLFxuICAgICAgICBjYWxsOiAnZXRoX2NvbXBpbGVTZXJwZW50JyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgc3VibWl0V29yayA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3VibWl0V29yaycsXG4gICAgICAgIGNhbGw6ICdldGhfc3VibWl0V29yaycsXG4gICAgICAgIHBhcmFtczogM1xuICAgIH0pO1xuXG4gICAgdmFyIGdldFdvcmsgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldFdvcmsnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldFdvcmsnLFxuICAgICAgICBwYXJhbXM6IDBcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGdldEJhbGFuY2UsXG4gICAgICAgIGdldFN0b3JhZ2VBdCxcbiAgICAgICAgZ2V0Q29kZSxcbiAgICAgICAgZ2V0QmxvY2ssXG4gICAgICAgIGdldFVuY2xlLFxuICAgICAgICBnZXRDb21waWxlcnMsXG4gICAgICAgIGdldEJsb2NrVHJhbnNhY3Rpb25Db3VudCxcbiAgICAgICAgZ2V0QmxvY2tVbmNsZUNvdW50LFxuICAgICAgICBnZXRUcmFuc2FjdGlvbixcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb25Gcm9tQmxvY2ssXG4gICAgICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdCxcbiAgICAgICAgZ2V0VHJhbnNhY3Rpb25Db3VudCxcbiAgICAgICAgY2FsbCxcbiAgICAgICAgZXN0aW1hdGVHYXMsXG4gICAgICAgIHNlbmRSYXdUcmFuc2FjdGlvbixcbiAgICAgICAgc2lnblRyYW5zYWN0aW9uLFxuICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgIHNpZ24sXG4gICAgICAgIGNvbXBpbGVTb2xpZGl0eSxcbiAgICAgICAgY29tcGlsZUxMTCxcbiAgICAgICAgY29tcGlsZVNlcnBlbnQsXG4gICAgICAgIHN1Ym1pdFdvcmssXG4gICAgICAgIGdldFdvcmtcbiAgICBdO1xufTtcblxuXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2NvaW5iYXNlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9jb2luYmFzZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbWluaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9taW5pbmcnXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc2hyYXRlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9oYXNocmF0ZScsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdzeW5jaW5nJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9zeW5jaW5nJyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogZm9ybWF0dGVycy5vdXRwdXRTeW5jaW5nRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2dhc1ByaWNlJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9nYXNQcmljZScsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IGZvcm1hdHRlcnMub3V0cHV0QmlnTnVtYmVyRm9ybWF0dGVyXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2FjY291bnRzJyxcbiAgICAgICAgICAgIGdldHRlcjogJ2V0aF9hY2NvdW50cydcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnYmxvY2tOdW1iZXInLFxuICAgICAgICAgICAgZ2V0dGVyOiAnZXRoX2Jsb2NrTnVtYmVyJyxcbiAgICAgICAgICAgIG91dHB1dEZvcm1hdHRlcjogdXRpbHMudG9EZWNpbWFsXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ3Byb3RvY29sVmVyc2lvbicsXG4gICAgICAgICAgICBnZXR0ZXI6ICdldGhfcHJvdG9jb2xWZXJzaW9uJ1xuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5FdGgucHJvdG90eXBlLmNvbnRyYWN0ID0gZnVuY3Rpb24gKGFiaSkge1xuICAgIHZhciBmYWN0b3J5ID0gbmV3IENvbnRyYWN0KHRoaXMsIGFiaSk7XG4gICAgcmV0dXJuIGZhY3Rvcnk7XG59O1xuXG5FdGgucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIob3B0aW9ucywgJ2V0aCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLmV0aCgpLCBmb3JtYXR0ZXJzLm91dHB1dExvZ0Zvcm1hdHRlciwgY2FsbGJhY2ssIGZpbHRlckNyZWF0aW9uRXJyb3JDYWxsYmFjayk7XG59O1xuXG5FdGgucHJvdG90eXBlLm5hbWVyZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QobmFtZXJlZy5nbG9iYWwuYWJpKS5hdChuYW1lcmVnLmdsb2JhbC5hZGRyZXNzKTtcbn07XG5cbkV0aC5wcm90b3R5cGUuaWNhcE5hbWVyZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJhY3QobmFtZXJlZy5pY2FwLmFiaSkuYXQobmFtZXJlZy5pY2FwLmFkZHJlc3MpO1xufTtcblxuRXRoLnByb3RvdHlwZS5pc1N5bmNpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IElzU3luY2luZyh0aGlzLl9yZXF1ZXN0TWFuYWdlciwgY2FsbGJhY2spO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdGg7XG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvcnM6XG4gKiAgIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3V0aWxzJyk7XG52YXIgUHJvcGVydHkgPSByZXF1aXJlKCcuLi9wcm9wZXJ0eScpO1xuXG52YXIgTmV0ID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkgeyBcbiAgICAgICAgcC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgcC5zZXRSZXF1ZXN0TWFuYWdlcih3ZWIzLl9yZXF1ZXN0TWFuYWdlcik7XG4gICAgfSk7XG59O1xuXG4vLy8gQHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIHdlYjMuZXRoIGFwaSBwcm9wZXJ0aWVzXG52YXIgcHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgUHJvcGVydHkoe1xuICAgICAgICAgICAgbmFtZTogJ2xpc3RlbmluZycsXG4gICAgICAgICAgICBnZXR0ZXI6ICduZXRfbGlzdGVuaW5nJ1xuICAgICAgICB9KSxcbiAgICAgICAgbmV3IFByb3BlcnR5KHtcbiAgICAgICAgICAgIG5hbWU6ICdwZWVyQ291bnQnLFxuICAgICAgICAgICAgZ2V0dGVyOiAnbmV0X3BlZXJDb3VudCcsXG4gICAgICAgICAgICBvdXRwdXRGb3JtYXR0ZXI6IHV0aWxzLnRvRGVjaW1hbFxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5ldDtcbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKipcbiAqIEBmaWxlIGV0aC5qc1xuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBNZXRob2QgPSByZXF1aXJlKCcuLi9tZXRob2QnKTtcbnZhciBQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL3Byb3BlcnR5Jyk7XG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4uL2Zvcm1hdHRlcnMnKTtcblxuZnVuY3Rpb24gUGVyc29uYWwod2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ25ld0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfbmV3QWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGltcG9ydFJhd0tleSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnaW1wb3J0UmF3S2V5Jyxcblx0XHRjYWxsOiAncGVyc29uYWxfaW1wb3J0UmF3S2V5Jyxcblx0XHRwYXJhbXM6IDJcbiAgICB9KTtcblxuICAgIHZhciBzaWduID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzaWduJyxcblx0XHRjYWxsOiAncGVyc29uYWxfc2lnbicsXG5cdFx0cGFyYW1zOiAzLFxuXHRcdGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgZm9ybWF0dGVycy5pbnB1dEFkZHJlc3NGb3JtYXR0ZXIsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgZWNSZWNvdmVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdlY1JlY292ZXInLFxuXHRcdGNhbGw6ICdwZXJzb25hbF9lY1JlY292ZXInLFxuXHRcdHBhcmFtczogMlxuICAgIH0pO1xuXG4gICAgdmFyIHVubG9ja0FjY291bnQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VubG9ja0FjY291bnQnLFxuICAgICAgICBjYWxsOiAncGVyc29uYWxfdW5sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMyxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlciwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzZW5kVHJhbnNhY3Rpb24gPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3NlbmRUcmFuc2FjdGlvbicsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9zZW5kVHJhbnNhY3Rpb24nLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbZm9ybWF0dGVycy5pbnB1dFRyYW5zYWN0aW9uRm9ybWF0dGVyLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGxvY2tBY2NvdW50ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdsb2NrQWNjb3VudCcsXG4gICAgICAgIGNhbGw6ICdwZXJzb25hbF9sb2NrQWNjb3VudCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtmb3JtYXR0ZXJzLmlucHV0QWRkcmVzc0Zvcm1hdHRlcl1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ld0FjY291bnQsXG4gICAgICAgIGltcG9ydFJhd0tleSxcbiAgICAgICAgdW5sb2NrQWNjb3VudCxcbiAgICAgICAgZWNSZWNvdmVyLFxuICAgICAgICBzaWduLFxuICAgICAgICBzZW5kVHJhbnNhY3Rpb24sXG4gICAgICAgIGxvY2tBY2NvdW50XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnbGlzdEFjY291bnRzJyxcbiAgICAgICAgICAgIGdldHRlcjogJ3BlcnNvbmFsX2xpc3RBY2NvdW50cydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlcnNvbmFsO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSBzaGguanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZXJldW0ub3JnPlxuICogICBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoY29yZS5pbz5cbiAqIEBkYXRlIDIwMTdcbiAqL1xuXG52YXIgTWV0aG9kID0gcmVxdWlyZSgnLi4vbWV0aG9kJyk7XG52YXIgRmlsdGVyID0gcmVxdWlyZSgnLi4vZmlsdGVyJyk7XG52YXIgd2F0Y2hlcyA9IHJlcXVpcmUoJy4vd2F0Y2hlcycpO1xuXG52YXIgU2hoID0gZnVuY3Rpb24gKHdlYjMpIHtcbiAgICB0aGlzLl9yZXF1ZXN0TWFuYWdlciA9IHdlYjMuX3JlcXVlc3RNYW5hZ2VyO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgbWV0aG9kcygpLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5hdHRhY2hUb09iamVjdChzZWxmKTtcbiAgICAgICAgbWV0aG9kLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn07XG5cblNoaC5wcm90b3R5cGUubmV3TWVzc2FnZUZpbHRlciA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGaWx0ZXIob3B0aW9ucywgJ3NoaCcsIHRoaXMuX3JlcXVlc3RNYW5hZ2VyLCB3YXRjaGVzLnNoaCgpLCBudWxsLCBjYWxsYmFjaywgZmlsdGVyQ3JlYXRpb25FcnJvckNhbGxiYWNrKTtcbn07XG5cbnZhciBtZXRob2RzID0gZnVuY3Rpb24gKCkge1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3ZlcnNpb24nLFxuICAgICAgICAgICAgcGFyYW1zOiAwXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdpbmZvJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfaW5mbycsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3NldE1heE1lc3NhZ2VTaXplJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfc2V0TWF4TWVzc2FnZVNpemUnLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdzZXRNaW5Qb1cnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9zZXRNaW5Qb1cnLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdtYXJrVHJ1c3RlZFBlZXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9tYXJrVHJ1c3RlZFBlZXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICduZXdLZXlQYWlyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfbmV3S2V5UGFpcicsXG4gICAgICAgICAgICBwYXJhbXM6IDBcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2FkZFByaXZhdGVLZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9hZGRQcml2YXRlS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZGVsZXRlS2V5UGFpcicsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2RlbGV0ZUtleVBhaXInLFxuICAgICAgICAgICAgcGFyYW1zOiAxXG4gICAgICAgIH0pLFxuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICdoYXNLZXlQYWlyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfaGFzS2V5UGFpcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFB1YmxpY0tleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldFB1YmxpY0tleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFByaXZhdGVLZXknLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZXRQcml2YXRlS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnbmV3U3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfbmV3U3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMFxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnYWRkU3ltS2V5JyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfYWRkU3ltS2V5JyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAnZ2VuZXJhdGVTeW1LZXlGcm9tUGFzc3dvcmQnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZW5lcmF0ZVN5bUtleUZyb21QYXNzd29yZCcsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2hhc1N5bUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2hhc1N5bUtleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldFN5bUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2dldFN5bUtleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2RlbGV0ZVN5bUtleScsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX2RlbGV0ZVN5bUtleScsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG5cbiAgICAgICAgLy8gc3Vic2NyaWJlIGFuZCB1bnN1YnNjcmliZSBtaXNzaW5nXG5cbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAncG9zdCcsXG4gICAgICAgICAgICBjYWxsOiAnc2hoX3Bvc3QnLFxuICAgICAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgICAgICB9KVxuICAgIF07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoaDtcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgYnp6LmpzXG4gKiBAYXV0aG9yIEFsZXggQmVyZWdzemFzemkgPGFsZXhAcnRmcy5odT5cbiAqIEBkYXRlIDIwMTZcbiAqXG4gKiBSZWZlcmVuY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9nby1ldGhlcmV1bS9ibG9iL3N3YXJtL2ludGVybmFsL3dlYjNleHQvd2ViM2V4dC5nbyNMMzNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xudmFyIFByb3BlcnR5ID0gcmVxdWlyZSgnLi4vcHJvcGVydHknKTtcblxuZnVuY3Rpb24gU3dhcm0od2ViMykge1xuICAgIHRoaXMuX3JlcXVlc3RNYW5hZ2VyID0gd2ViMy5fcmVxdWVzdE1hbmFnZXI7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBtZXRob2RzKCkuZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBtZXRob2Quc2V0UmVxdWVzdE1hbmFnZXIoc2VsZi5fcmVxdWVzdE1hbmFnZXIpO1xuICAgIH0pO1xuXG4gICAgcHJvcGVydGllcygpLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICBwLmF0dGFjaFRvT2JqZWN0KHNlbGYpO1xuICAgICAgICBwLnNldFJlcXVlc3RNYW5hZ2VyKHNlbGYuX3JlcXVlc3RNYW5hZ2VyKTtcbiAgICB9KTtcbn1cblxudmFyIG1ldGhvZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJsb2NrTmV0d29ya1JlYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBjYWxsOiAnYnp6X2Jsb2NrTmV0d29ya1JlYWQnLFxuICAgICAgICBwYXJhbXM6IDEsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBzeW5jRW5hYmxlZCA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnc3luY0VuYWJsZWQnLFxuICAgICAgICBjYWxsOiAnYnp6X3N5bmNFbmFibGVkJyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgc3dhcEVuYWJsZWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3N3YXBFbmFibGVkJyxcbiAgICAgICAgY2FsbDogJ2J6el9zd2FwRW5hYmxlZCcsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIGRvd25sb2FkID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdkb3dubG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfZG93bmxvYWQnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciB1cGxvYWQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VwbG9hZCcsXG4gICAgICAgIGNhbGw6ICdienpfdXBsb2FkJyxcbiAgICAgICAgcGFyYW1zOiAyLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGwsIG51bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcmV0cmlldmUgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3JldHJpZXZlJyxcbiAgICAgICAgY2FsbDogJ2J6el9yZXRyaWV2ZScsXG4gICAgICAgIHBhcmFtczogMSxcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIHN0b3JlID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdzdG9yZScsXG4gICAgICAgIGNhbGw6ICdienpfc3RvcmUnLFxuICAgICAgICBwYXJhbXM6IDIsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHZhciBnZXQgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ2dldCcsXG4gICAgICAgIGNhbGw6ICdienpfZ2V0JyxcbiAgICAgICAgcGFyYW1zOiAxLFxuICAgICAgICBpbnB1dEZvcm1hdHRlcjogW251bGxdXG4gICAgfSk7XG5cbiAgICB2YXIgcHV0ID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICdwdXQnLFxuICAgICAgICBjYWxsOiAnYnp6X3B1dCcsXG4gICAgICAgIHBhcmFtczogMixcbiAgICAgICAgaW5wdXRGb3JtYXR0ZXI6IFtudWxsLCBudWxsXVxuICAgIH0pO1xuXG4gICAgdmFyIG1vZGlmeSA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnbW9kaWZ5JyxcbiAgICAgICAgY2FsbDogJ2J6el9tb2RpZnknLFxuICAgICAgICBwYXJhbXM6IDQsXG4gICAgICAgIGlucHV0Rm9ybWF0dGVyOiBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF1cbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIGJsb2NrTmV0d29ya1JlYWQsXG4gICAgICAgIHN5bmNFbmFibGVkLFxuICAgICAgICBzd2FwRW5hYmxlZCxcbiAgICAgICAgZG93bmxvYWQsXG4gICAgICAgIHVwbG9hZCxcbiAgICAgICAgcmV0cmlldmUsXG4gICAgICAgIHN0b3JlLFxuICAgICAgICBnZXQsXG4gICAgICAgIHB1dCxcbiAgICAgICAgbW9kaWZ5XG4gICAgXTtcbn07XG5cbnZhciBwcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaGl2ZScsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaGl2ZSdcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBQcm9wZXJ0eSh7XG4gICAgICAgICAgICBuYW1lOiAnaW5mbycsXG4gICAgICAgICAgICBnZXR0ZXI6ICdienpfaW5mbydcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IFN3YXJtO1xuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKiBAZmlsZSB3YXRjaGVzLmpzXG4gKiBAYXV0aG9yczpcbiAqICAgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIE1ldGhvZCA9IHJlcXVpcmUoJy4uL21ldGhvZCcpO1xuXG4vLy8gQHJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBkZXNjcmliaW5nIHdlYjMuZXRoLmZpbHRlciBhcGkgbWV0aG9kc1xudmFyIGV0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3RmlsdGVyQ2FsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciB0eXBlID0gYXJnc1swXTtcblxuICAgICAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbGF0ZXN0JzpcbiAgICAgICAgICAgICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiAnZXRoX25ld0Jsb2NrRmlsdGVyJztcbiAgICAgICAgICAgIGNhc2UgJ3BlbmRpbmcnOlxuICAgICAgICAgICAgICAgIGFyZ3Muc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmFtcyA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdldGhfbmV3UGVuZGluZ1RyYW5zYWN0aW9uRmlsdGVyJztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdldGhfbmV3RmlsdGVyJztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbmV3RmlsdGVyID0gbmV3IE1ldGhvZCh7XG4gICAgICAgIG5hbWU6ICduZXdGaWx0ZXInLFxuICAgICAgICBjYWxsOiBuZXdGaWx0ZXJDYWxsLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHZhciB1bmluc3RhbGxGaWx0ZXIgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3VuaW5zdGFsbEZpbHRlcicsXG4gICAgICAgIGNhbGw6ICdldGhfdW5pbnN0YWxsRmlsdGVyJyxcbiAgICAgICAgcGFyYW1zOiAxXG4gICAgfSk7XG5cbiAgICB2YXIgZ2V0TG9ncyA9IG5ldyBNZXRob2Qoe1xuICAgICAgICBuYW1lOiAnZ2V0TG9ncycsXG4gICAgICAgIGNhbGw6ICdldGhfZ2V0RmlsdGVyTG9ncycsXG4gICAgICAgIHBhcmFtczogMVxuICAgIH0pO1xuXG4gICAgdmFyIHBvbGwgPSBuZXcgTWV0aG9kKHtcbiAgICAgICAgbmFtZTogJ3BvbGwnLFxuICAgICAgICBjYWxsOiAnZXRoX2dldEZpbHRlckNoYW5nZXMnLFxuICAgICAgICBwYXJhbXM6IDFcbiAgICB9KTtcblxuICAgIHJldHVybiBbXG4gICAgICAgIG5ld0ZpbHRlcixcbiAgICAgICAgdW5pbnN0YWxsRmlsdGVyLFxuICAgICAgICBnZXRMb2dzLFxuICAgICAgICBwb2xsXG4gICAgXTtcbn07XG5cbi8vLyBAcmV0dXJucyBhbiBhcnJheSBvZiBvYmplY3RzIGRlc2NyaWJpbmcgd2ViMy5zaGgud2F0Y2ggYXBpIG1ldGhvZHNcbnZhciBzaGggPSBmdW5jdGlvbiAoKSB7XG5cbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgTWV0aG9kKHtcbiAgICAgICAgICAgIG5hbWU6ICduZXdGaWx0ZXInLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9uZXdNZXNzYWdlRmlsdGVyJyxcbiAgICAgICAgICAgIHBhcmFtczogMVxuICAgICAgICB9KSxcbiAgICAgICAgbmV3IE1ldGhvZCh7XG4gICAgICAgICAgICBuYW1lOiAndW5pbnN0YWxsRmlsdGVyJyxcbiAgICAgICAgICAgIGNhbGw6ICdzaGhfZGVsZXRlTWVzc2FnZUZpbHRlcicsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ2dldExvZ3MnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZXRGaWx0ZXJNZXNzYWdlcycsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSksXG4gICAgICAgIG5ldyBNZXRob2Qoe1xuICAgICAgICAgICAgbmFtZTogJ3BvbGwnLFxuICAgICAgICAgICAgY2FsbDogJ3NoaF9nZXRGaWx0ZXJNZXNzYWdlcycsXG4gICAgICAgICAgICBwYXJhbXM6IDFcbiAgICAgICAgfSlcbiAgICBdO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZXRoOiBldGgsXG4gICAgc2hoOiBzaGhcbn07XG5cbiIsIi8qXG4gICAgVGhpcyBmaWxlIGlzIHBhcnQgb2Ygd2ViMy5qcy5cblxuICAgIHdlYjMuanMgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIHdlYjMuanMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggd2ViMy5qcy4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG4vKiogXG4gKiBAZmlsZSBuYW1lcmVnLmpzXG4gKiBAYXV0aG9yIE1hcmVrIEtvdGV3aWN6IDxtYXJla0BldGhkZXYuY29tPlxuICogQGRhdGUgMjAxNVxuICovXG5cbnZhciBnbG9iYWxSZWdpc3RyYXJBYmkgPSByZXF1aXJlKCcuLi9jb250cmFjdHMvR2xvYmFsUmVnaXN0cmFyLmpzb24nKTtcbnZhciBpY2FwUmVnaXN0cmFyQWJpPSByZXF1aXJlKCcuLi9jb250cmFjdHMvSUNBUFJlZ2lzdHJhci5qc29uJyk7XG5cbnZhciBnbG9iYWxOYW1lcmVnQWRkcmVzcyA9ICcweGM2ZDlkMmNkNDQ5YTc1NGM0OTQyNjRlMTgwOWM1MGUzNGQ2NDU2MmInO1xudmFyIGljYXBOYW1lcmVnQWRkcmVzcyA9ICcweGExYTExMWJjMDc0YzljZmE3ODFmMGMzOGU2M2JkNTFjOTFiOGFmMDAnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnbG9iYWw6IHtcbiAgICAgICAgYWJpOiBnbG9iYWxSZWdpc3RyYXJBYmksXG4gICAgICAgIGFkZHJlc3M6IGdsb2JhbE5hbWVyZWdBZGRyZXNzXG4gICAgfSxcbiAgICBpY2FwOiB7XG4gICAgICAgIGFiaTogaWNhcFJlZ2lzdHJhckFiaSxcbiAgICAgICAgYWRkcmVzczogaWNhcE5hbWVyZWdBZGRyZXNzXG4gICAgfVxufTtcblxuIiwiLypcbiAgICBUaGlzIGZpbGUgaXMgcGFydCBvZiB3ZWIzLmpzLlxuXG4gICAgd2ViMy5qcyBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgd2ViMy5qcyBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCB3ZWIzLmpzLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbi8qKlxuICogQGZpbGUgcHJvcGVydHkuanNcbiAqIEBhdXRob3IgRmFiaWFuIFZvZ2Vsc3RlbGxlciA8ZmFiaWFuQGZyb3plbWFuLmRlPlxuICogQGF1dGhvciBNYXJlayBLb3Rld2ljeiA8bWFyZWtAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91dGlscycpO1xuXG52YXIgUHJvcGVydHkgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZTtcbiAgICB0aGlzLmdldHRlciA9IG9wdGlvbnMuZ2V0dGVyO1xuICAgIHRoaXMuc2V0dGVyID0gb3B0aW9ucy5zZXR0ZXI7XG4gICAgdGhpcy5vdXRwdXRGb3JtYXR0ZXIgPSBvcHRpb25zLm91dHB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLmlucHV0Rm9ybWF0dGVyID0gb3B0aW9ucy5pbnB1dEZvcm1hdHRlcjtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gbnVsbDtcbn07XG5cblByb3BlcnR5LnByb3RvdHlwZS5zZXRSZXF1ZXN0TWFuYWdlciA9IGZ1bmN0aW9uIChybSkge1xuICAgIHRoaXMucmVxdWVzdE1hbmFnZXIgPSBybTtcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgaW5wdXQgYXJncyBvZiBtZXRob2RcbiAqXG4gKiBAbWV0aG9kIGZvcm1hdElucHV0XG4gKiBAcGFyYW0ge0FycmF5fVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblByb3BlcnR5LnByb3RvdHlwZS5mb3JtYXRJbnB1dCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dEZvcm1hdHRlciA/IHRoaXMuaW5wdXRGb3JtYXR0ZXIoYXJnKSA6IGFyZztcbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBmb3JtYXQgb3V0cHV0KHJlc3VsdCkgb2YgbWV0aG9kXG4gKlxuICogQG1ldGhvZCBmb3JtYXRPdXRwdXRcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUuZm9ybWF0T3V0cHV0ID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJldHVybiB0aGlzLm91dHB1dEZvcm1hdHRlciAmJiByZXN1bHQgIT09IG51bGwgJiYgcmVzdWx0ICE9PSB1bmRlZmluZWQgPyB0aGlzLm91dHB1dEZvcm1hdHRlcihyZXN1bHQpIDogcmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBleHRyYWN0IGNhbGxiYWNrIGZyb20gYXJyYXkgb2YgYXJndW1lbnRzLiBNb2RpZmllcyBpbnB1dCBwYXJhbVxuICpcbiAqIEBtZXRob2QgZXh0cmFjdENhbGxiYWNrXG4gKiBAcGFyYW0ge0FycmF5fSBhcmd1bWVudHNcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufE51bGx9IGNhbGxiYWNrLCBpZiBleGlzdHNcbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLmV4dHJhY3RDYWxsYmFjayA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKHV0aWxzLmlzRnVuY3Rpb24oYXJnc1thcmdzLmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gYXJncy5wb3AoKTsgLy8gbW9kaWZ5IHRoZSBhcmdzIGFycmF5IVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBTaG91bGQgYXR0YWNoIGZ1bmN0aW9uIHRvIG1ldGhvZFxuICpcbiAqIEBtZXRob2QgYXR0YWNoVG9PYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fVxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqL1xuUHJvcGVydHkucHJvdG90eXBlLmF0dGFjaFRvT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBwcm90byA9IHtcbiAgICAgICAgZ2V0OiB0aGlzLmJ1aWxkR2V0KCksXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICB9O1xuXG4gICAgdmFyIG5hbWVzID0gdGhpcy5uYW1lLnNwbGl0KCcuJyk7XG4gICAgdmFyIG5hbWUgPSBuYW1lc1swXTtcbiAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICBvYmpbbmFtZXNbMF1dID0gb2JqW25hbWVzWzBdXSB8fCB7fTtcbiAgICAgICAgb2JqID0gb2JqW25hbWVzWzBdXTtcbiAgICAgICAgbmFtZSA9IG5hbWVzWzFdO1xuICAgIH1cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIG5hbWUsIHByb3RvKTtcbiAgICBvYmpbYXN5bmNHZXR0ZXJOYW1lKG5hbWUpXSA9IHRoaXMuYnVpbGRBc3luY0dldCgpO1xufTtcblxudmFyIGFzeW5jR2V0dGVyTmFtZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuICdnZXQnICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG59O1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuYnVpbGRHZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByb3BlcnR5ID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHkuZm9ybWF0T3V0cHV0KHByb3BlcnR5LnJlcXVlc3RNYW5hZ2VyLnNlbmQoe1xuICAgICAgICAgICAgbWV0aG9kOiBwcm9wZXJ0eS5nZXR0ZXJcbiAgICAgICAgfSkpO1xuICAgIH07XG59O1xuXG5Qcm9wZXJ0eS5wcm90b3R5cGUuYnVpbGRBc3luY0dldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydHkgPSB0aGlzO1xuICAgIHZhciBnZXQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgcHJvcGVydHkucmVxdWVzdE1hbmFnZXIuc2VuZEFzeW5jKHtcbiAgICAgICAgICAgIG1ldGhvZDogcHJvcGVydHkuZ2V0dGVyXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCBwcm9wZXJ0eS5mb3JtYXRPdXRwdXQocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZ2V0LnJlcXVlc3QgPSB0aGlzLnJlcXVlc3QuYmluZCh0aGlzKTtcbiAgICByZXR1cm4gZ2V0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGNyZWF0ZSBwdXJlIEpTT05SUEMgcmVxdWVzdCB3aGljaCBjYW4gYmUgdXNlZCBpbiBiYXRjaCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCByZXF1ZXN0XG4gKiBAcGFyYW0gey4uLn0gcGFyYW1zXG4gKiBAcmV0dXJuIHtPYmplY3R9IGpzb25ycGMgcmVxdWVzdFxuICovXG5Qcm9wZXJ0eS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgbWV0aG9kOiB0aGlzLmdldHRlcixcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgY2FsbGJhY2s6IHRoaXMuZXh0cmFjdENhbGxiYWNrKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgfTtcbiAgICBwYXlsb2FkLmZvcm1hdCA9IHRoaXMuZm9ybWF0T3V0cHV0LmJpbmQodGhpcyk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb3BlcnR5O1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgcmVxdWVzdG1hbmFnZXIuanNcbiAqIEBhdXRob3IgSmVmZnJleSBXaWxja2UgPGplZmZAZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAYXV0aG9yIE1hcmlhbiBPYW5jZWEgPG1hcmlhbkBldGhkZXYuY29tPlxuICogQGF1dGhvciBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBhdXRob3IgR2F2IFdvb2QgPGdAZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTRcbiAqL1xuXG52YXIgSnNvbnJwYyA9IHJlcXVpcmUoJy4vanNvbnJwYycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcbnZhciBjID0gcmVxdWlyZSgnLi4vdXRpbHMvY29uZmlnJyk7XG52YXIgZXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuLyoqXG4gKiBJdCdzIHJlc3BvbnNpYmxlIGZvciBwYXNzaW5nIG1lc3NhZ2VzIHRvIHByb3ZpZGVyc1xuICogSXQncyBhbHNvIHJlc3BvbnNpYmxlIGZvciBwb2xsaW5nIHRoZSBldGhlcmV1bSBub2RlIGZvciBpbmNvbWluZyBtZXNzYWdlc1xuICogRGVmYXVsdCBwb2xsIHRpbWVvdXQgaXMgMSBzZWNvbmRcbiAqIFNpbmdsZXRvblxuICovXG52YXIgUmVxdWVzdE1hbmFnZXIgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgdGhpcy5wb2xscyA9IHt9O1xuICAgIHRoaXMudGltZW91dCA9IG51bGw7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN5bmNocm9ub3VzbHkgc2VuZCByZXF1ZXN0XG4gKlxuICogQG1ldGhvZCBzZW5kXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvUGF5bG9hZChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLnByb3ZpZGVyLnNlbmQocGF5bG9hZCk7XG5cbiAgICBpZiAoIUpzb25ycGMuaXNWYWxpZFJlc3BvbnNlKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBhc3luY2hyb25vdXNseSBzZW5kIHJlcXVlc3RcbiAqXG4gKiBAbWV0aG9kIHNlbmRBc3luY1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZW5kQXN5bmMgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycm9ycy5JbnZhbGlkUHJvdmlkZXIoKSk7XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvUGF5bG9hZChkYXRhLm1ldGhvZCwgZGF0YS5wYXJhbXMpO1xuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCFKc29ucnBjLmlzVmFsaWRSZXNwb25zZShyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuICAgIH0pO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgY2FsbGVkIHRvIGFzeW5jaHJvbm91c2x5IHNlbmQgYmF0Y2ggcmVxdWVzdFxuICpcbiAqIEBtZXRob2Qgc2VuZEJhdGNoXG4gKiBAcGFyYW0ge0FycmF5fSBiYXRjaCBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5SZXF1ZXN0TWFuYWdlci5wcm90b3R5cGUuc2VuZEJhdGNoID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFByb3ZpZGVyKCkpO1xuICAgIH1cblxuICAgIHZhciBwYXlsb2FkID0gSnNvbnJwYy50b0JhdGNoUGF5bG9hZChkYXRhKTtcblxuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXV0aWxzLmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdHMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0cyk7XG4gICAgfSk7IFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBzZXQgcHJvdmlkZXIgb2YgcmVxdWVzdCBtYW5hZ2VyXG4gKlxuICogQG1ldGhvZCBzZXRQcm92aWRlclxuICogQHBhcmFtIHtPYmplY3R9XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zZXRQcm92aWRlciA9IGZ1bmN0aW9uIChwKSB7XG4gICAgdGhpcy5wcm92aWRlciA9IHA7XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN0YXJ0IHBvbGxpbmdcbiAqXG4gKiBAbWV0aG9kIHN0YXJ0UG9sbGluZ1xuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb2xsSWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1bmluc3RhbGxcbiAqXG4gKiBAdG9kbyBjbGVhbnVwIG51bWJlciBvZiBwYXJhbXNcbiAqL1xuUmVxdWVzdE1hbmFnZXIucHJvdG90eXBlLnN0YXJ0UG9sbGluZyA9IGZ1bmN0aW9uIChkYXRhLCBwb2xsSWQsIGNhbGxiYWNrLCB1bmluc3RhbGwpIHtcbiAgICB0aGlzLnBvbGxzW3BvbGxJZF0gPSB7ZGF0YTogZGF0YSwgaWQ6IHBvbGxJZCwgY2FsbGJhY2s6IGNhbGxiYWNrLCB1bmluc3RhbGw6IHVuaW5zdGFsbH07XG5cblxuICAgIC8vIHN0YXJ0IHBvbGxpbmdcbiAgICBpZiAoIXRoaXMudGltZW91dCkge1xuICAgICAgICB0aGlzLnBvbGwoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSB1c2VkIHRvIHN0b3AgcG9sbGluZyBmb3IgZmlsdGVyIHdpdGggZ2l2ZW4gaWRcbiAqXG4gKiBAbWV0aG9kIHN0b3BQb2xsaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gcG9sbElkXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5zdG9wUG9sbGluZyA9IGZ1bmN0aW9uIChwb2xsSWQpIHtcbiAgICBkZWxldGUgdGhpcy5wb2xsc1twb2xsSWRdO1xuXG4gICAgLy8gc3RvcCBwb2xsaW5nXG4gICAgaWYoT2JqZWN0LmtleXModGhpcy5wb2xscykubGVuZ3RoID09PSAwICYmIHRoaXMudGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgdG8gcmVzZXQgdGhlIHBvbGxpbmcgbWVjaGFuaXNtIG9mIHRoZSByZXF1ZXN0IG1hbmFnZXJcbiAqXG4gKiBAbWV0aG9kIHJlc2V0XG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChrZWVwSXNTeW5jaW5nKSB7XG4gICAgLypqc2hpbnQgbWF4Y29tcGxleGl0eTo1ICovXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wb2xscykge1xuICAgICAgICAvLyByZW1vdmUgYWxsIHBvbGxzLCBleGNlcHQgc3luYyBwb2xscyxcbiAgICAgICAgLy8gdGhleSBuZWVkIHRvIGJlIHJlbW92ZWQgbWFudWFsbHkgYnkgY2FsbGluZyBzeW5jaW5nLnN0b3BXYXRjaGluZygpXG4gICAgICAgIGlmKCFrZWVwSXNTeW5jaW5nIHx8IGtleS5pbmRleE9mKCdzeW5jUG9sbF8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMucG9sbHNba2V5XS51bmluc3RhbGwoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnBvbGxzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBzdG9wIHBvbGxpbmdcbiAgICBpZihPYmplY3Qua2V5cyh0aGlzLnBvbGxzKS5sZW5ndGggPT09IDAgJiYgdGhpcy50aW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuICAgICAgICB0aGlzLnRpbWVvdXQgPSBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogU2hvdWxkIGJlIGNhbGxlZCB0byBwb2xsIGZvciBjaGFuZ2VzIG9uIGZpbHRlciB3aXRoIGdpdmVuIGlkXG4gKlxuICogQG1ldGhvZCBwb2xsXG4gKi9cblJlcXVlc3RNYW5hZ2VyLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24gKCkge1xuICAgIC8qanNoaW50IG1heGNvbXBsZXhpdHk6IDYgKi9cbiAgICB0aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KHRoaXMucG9sbC5iaW5kKHRoaXMpLCBjLkVUSF9QT0xMSU5HX1RJTUVPVVQpO1xuXG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMucG9sbHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3JzLkludmFsaWRQcm92aWRlcigpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2xsc0RhdGEgPSBbXTtcbiAgICB2YXIgcG9sbHNJZHMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5wb2xscykge1xuICAgICAgICBwb2xsc0RhdGEucHVzaCh0aGlzLnBvbGxzW2tleV0uZGF0YSk7XG4gICAgICAgIHBvbGxzSWRzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBpZiAocG9sbHNEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBheWxvYWQgPSBKc29ucnBjLnRvQmF0Y2hQYXlsb2FkKHBvbGxzRGF0YSk7XG4gICAgXG4gICAgLy8gbWFwIHRoZSByZXF1ZXN0IGlkIHRvIHRoZXkgcG9sbCBpZFxuICAgIHZhciBwb2xsc0lkTWFwID0ge307XG4gICAgcGF5bG9hZC5mb3JFYWNoKGZ1bmN0aW9uKGxvYWQsIGluZGV4KXtcbiAgICAgICAgcG9sbHNJZE1hcFtsb2FkLmlkXSA9IHBvbGxzSWRzW2luZGV4XTtcbiAgICB9KTtcblxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMucHJvdmlkZXIuc2VuZEFzeW5jKHBheWxvYWQsIGZ1bmN0aW9uIChlcnJvciwgcmVzdWx0cykge1xuXG5cbiAgICAgICAgLy8gVE9ETzogY29uc29sZSBsb2c/XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHJlc3VsdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcnMuSW52YWxpZFJlc3BvbnNlKHJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdHMubWFwKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHBvbGxzSWRNYXBbcmVzdWx0LmlkXTtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmaWx0ZXIgaXMgc3RpbGwgaW5zdGFsbGVkIGFmdGVyIGFycml2YWwgb2YgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgIGlmIChzZWxmLnBvbGxzW2lkXSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jYWxsYmFjayA9IHNlbGYucG9sbHNbaWRdLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gISFyZXN1bHQ7IFxuICAgICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgdmFyIHZhbGlkID0gSnNvbnJwYy5pc1ZhbGlkUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuY2FsbGJhY2soZXJyb3JzLkludmFsaWRSZXNwb25zZShyZXN1bHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWxpZDtcbiAgICAgICAgfSkuZm9yRWFjaChmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHQuY2FsbGJhY2sobnVsbCwgcmVzdWx0LnJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0TWFuYWdlcjtcblxuIiwiXG5cbnZhciBTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRCbG9jayA9ICdsYXRlc3QnO1xuICAgIHRoaXMuZGVmYXVsdEFjY291bnQgPSB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldHRpbmdzO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIEBmaWxlIHN5bmNpbmcuanNcbiAqIEBhdXRob3JzOlxuICogICBGYWJpYW4gVm9nZWxzdGVsbGVyIDxmYWJpYW5AZXRoZGV2LmNvbT5cbiAqIEBkYXRlIDIwMTVcbiAqL1xuXG52YXIgZm9ybWF0dGVycyA9IHJlcXVpcmUoJy4vZm9ybWF0dGVycycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXRpbHMnKTtcblxudmFyIGNvdW50ID0gMTtcblxuLyoqXG5BZGRzIHRoZSBjYWxsYmFjayBhbmQgc2V0cyB1cCB0aGUgbWV0aG9kcywgdG8gaXRlcmF0ZSBvdmVyIHRoZSByZXN1bHRzLlxuXG5AbWV0aG9kIHBvbGxTeW5jaW5nXG5AcGFyYW0ge09iamVjdH0gc2VsZlxuKi9cbnZhciBwb2xsU3luY2luZyA9IGZ1bmN0aW9uKHNlbGYpIHtcblxuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbiAoZXJyb3IsIHN5bmMpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKHV0aWxzLmlzT2JqZWN0KHN5bmMpICYmIHN5bmMuc3RhcnRpbmdCbG9jaylcbiAgICAgICAgICAgIHN5bmMgPSBmb3JtYXR0ZXJzLm91dHB1dFN5bmNpbmdGb3JtYXR0ZXIoc3luYyk7XG5cbiAgICAgICAgc2VsZi5jYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChzZWxmLmxhc3RTeW5jU3RhdGUgIT09IHN5bmMpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRydWUgZmlyc3Qgc28gdGhlIGFwcCBjYW4gc3RvcCBhbnl0aGluZywgYmVmb3JlIHJlY2VpdmluZyB0aGUgc3luYyBkYXRhXG4gICAgICAgICAgICAgICAgaWYoIXNlbGYubGFzdFN5bmNTdGF0ZSAmJiB1dGlscy5pc09iamVjdChzeW5jKSlcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gY2FsbCBvbiB0aGUgbmV4dCBDUFUgY3ljbGUsIHNvIHRoZSBhY3Rpb25zIG9mIHRoZSBzeW5jIHN0b3AgY2FuIGJlIHByb2Nlc3NlcyBmaXJzdFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHN5bmMpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNlbGYubGFzdFN5bmNTdGF0ZSA9IHN5bmM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBzZWxmLnJlcXVlc3RNYW5hZ2VyLnN0YXJ0UG9sbGluZyh7XG4gICAgICAgIG1ldGhvZDogJ2V0aF9zeW5jaW5nJyxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICB9LCBzZWxmLnBvbGxJZCwgb25NZXNzYWdlLCBzZWxmLnN0b3BXYXRjaGluZy5iaW5kKHNlbGYpKTtcblxufTtcblxudmFyIElzU3luY2luZyA9IGZ1bmN0aW9uIChyZXF1ZXN0TWFuYWdlciwgY2FsbGJhY2spIHtcbiAgICB0aGlzLnJlcXVlc3RNYW5hZ2VyID0gcmVxdWVzdE1hbmFnZXI7XG4gICAgdGhpcy5wb2xsSWQgPSAnc3luY1BvbGxfJysgY291bnQrKztcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuYWRkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIHRoaXMubGFzdFN5bmNTdGF0ZSA9IGZhbHNlO1xuICAgIHBvbGxTeW5jaW5nKHRoaXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Jc1N5bmNpbmcucHJvdG90eXBlLmFkZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYoY2FsbGJhY2spXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuSXNTeW5jaW5nLnByb3RvdHlwZS5zdG9wV2F0Y2hpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXF1ZXN0TWFuYWdlci5zdG9wUG9sbGluZyh0aGlzLnBvbGxJZCk7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBbXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSXNTeW5jaW5nO1xuXG4iLCIvKlxuICAgIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIHdlYjMuanMuXG5cbiAgICB3ZWIzLmpzIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICB3ZWIzLmpzIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIHdlYjMuanMuICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuLyoqIFxuICogQGZpbGUgdHJhbnNmZXIuanNcbiAqIEBhdXRob3IgTWFyZWsgS290ZXdpY3ogPG1hcmVrQGV0aGRldi5jb20+XG4gKiBAZGF0ZSAyMDE1XG4gKi9cblxudmFyIEliYW4gPSByZXF1aXJlKCcuL2liYW4nKTtcbnZhciBleGNoYW5nZUFiaSA9IHJlcXVpcmUoJy4uL2NvbnRyYWN0cy9TbWFydEV4Y2hhbmdlLmpzb24nKTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBtYWtlIEliYW4gdHJhbnNmZXJcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvIGliYW5cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5mZXJlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2ssIGNhbGxiYWNrXG4gKi9cbnZhciB0cmFuc2ZlciA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgaWJhbiA9IG5ldyBJYmFuKHRvKTsgXG4gICAgaWYgKCFpYmFuLmlzVmFsaWQoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaWJhbiBhZGRyZXNzJyk7XG4gICAgfVxuXG4gICAgaWYgKGliYW4uaXNEaXJlY3QoKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmZXJUb0FkZHJlc3MoZXRoLCBmcm9tLCBpYmFuLmFkZHJlc3MoKSwgdmFsdWUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgXG4gICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICB2YXIgYWRkcmVzcyA9IGV0aC5pY2FwTmFtZXJlZygpLmFkZHIoaWJhbi5pbnN0aXR1dGlvbigpKTtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSk7XG4gICAgfVxuXG4gICAgZXRoLmljYXBOYW1lcmVnKCkuYWRkcihpYmFuLmluc3RpdHV0aW9uKCksIGZ1bmN0aW9uIChlcnIsIGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGRlcG9zaXQoZXRoLCBmcm9tLCBhZGRyZXNzLCB2YWx1ZSwgaWJhbi5jbGllbnQoKSwgY2FsbGJhY2spO1xuICAgIH0pO1xuICAgIFxufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byB0cmFuc2ZlciBmdW5kcyB0byBjZXJ0YWluIGFkZHJlc3NcbiAqXG4gKiBAbWV0aG9kIHRyYW5zZmVyVG9BZGRyZXNzXG4gKiBAcGFyYW0ge1N0cmluZ30gZnJvbVxuICogQHBhcmFtIHtTdHJpbmd9IHRvXG4gKiBAcGFyYW0ge1ZhbHVlfSB2YWx1ZSB0byBiZSB0cmFuZmVyZWRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgdHJhbnNmZXJUb0FkZHJlc3MgPSBmdW5jdGlvbiAoZXRoLCBmcm9tLCB0bywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGV0aC5zZW5kVHJhbnNhY3Rpb24oe1xuICAgICAgICBhZGRyZXNzOiB0byxcbiAgICAgICAgZnJvbTogZnJvbSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgfSwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBTaG91bGQgYmUgdXNlZCB0byBkZXBvc2l0IGZ1bmRzIHRvIGdlbmVyaWMgRXhjaGFuZ2UgY29udHJhY3QgKG11c3QgaW1wbGVtZW50IGRlcG9zaXQoYnl0ZXMzMikgbWV0aG9kISlcbiAqXG4gKiBAbWV0aG9kIGRlcG9zaXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBmcm9tXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9cbiAqIEBwYXJhbSB7VmFsdWV9IHZhbHVlIHRvIGJlIHRyYW5zZmVyZWRcbiAqIEBwYXJhbSB7U3RyaW5nfSBjbGllbnQgdW5pcXVlIGlkZW50aWZpZXJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrLCBjYWxsYmFja1xuICovXG52YXIgZGVwb3NpdCA9IGZ1bmN0aW9uIChldGgsIGZyb20sIHRvLCB2YWx1ZSwgY2xpZW50LCBjYWxsYmFjaykge1xuICAgIHZhciBhYmkgPSBleGNoYW5nZUFiaTtcbiAgICByZXR1cm4gZXRoLmNvbnRyYWN0KGFiaSkuYXQodG8pLmRlcG9zaXQoY2xpZW50LCB7XG4gICAgICAgIGZyb206IGZyb20sXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgIH0sIGNhbGxiYWNrKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNmZXI7XG5cbiIsIi8qISBiaWdudW1iZXIuanMgdjIuMC43IGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qcy9MSUNFTkNFICovXHJcblxyXG47KGZ1bmN0aW9uIChnbG9iYWwpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICAvKlxyXG4gICAgICBiaWdudW1iZXIuanMgdjIuMC43XHJcbiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2JpZ251bWJlci5qc1xyXG4gICAgICBDb3B5cmlnaHQgKGMpIDIwMTUgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICAgICAgTUlUIEV4cGF0IExpY2VuY2VcclxuICAgICovXHJcblxyXG5cclxuICAgIHZhciBCaWdOdW1iZXIsIGNyeXB0bywgcGFyc2VOdW1lcmljLFxyXG4gICAgICAgIGlzTnVtZXJpYyA9IC9eLT8oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxyXG4gICAgICAgIG1hdGhjZWlsID0gTWF0aC5jZWlsLFxyXG4gICAgICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcbiAgICAgICAgbm90Qm9vbCA9ICcgbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQnLFxyXG4gICAgICAgIHJvdW5kaW5nTW9kZSA9ICdyb3VuZGluZyBtb2RlJyxcclxuICAgICAgICB0b29NYW55RGlnaXRzID0gJ251bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzJyxcclxuICAgICAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiRfJyxcclxuICAgICAgICBCQVNFID0gMWUxNCxcclxuICAgICAgICBMT0dfQkFTRSA9IDE0LFxyXG4gICAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAgICAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICAgICAgICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gICAgICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAgICAgICAgKiB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24sIGJleW9uZCB3aGljaCBhblxyXG4gICAgICAgICAqIGV4Y2VwdGlvbiBpcyB0aHJvd24gKGlmIEVSUk9SUyBpcyB0cnVlKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBCaWdOdW1iZXIgY29uc3RydWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGFub3RoZXIoY29uZmlnT2JqKSB7XHJcbiAgICAgICAgdmFyIGRpdixcclxuXHJcbiAgICAgICAgICAgIC8vIGlkIHRyYWNrcyB0aGUgY2FsbGVyIGZ1bmN0aW9uLCBzbyBpdHMgbmFtZSBjYW4gYmUgaW5jbHVkZWQgaW4gZXJyb3IgbWVzc2FnZXMuXHJcbiAgICAgICAgICAgIGlkID0gMCxcclxuICAgICAgICAgICAgUCA9IEJpZ051bWJlci5wcm90b3R5cGUsXHJcbiAgICAgICAgICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgICAgICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiBFRElUQUJMRSBERUZBVUxUUyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlcyBiZWxvdyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgaW5jbHVzaXZlIHJhbmdlcyBzdGF0ZWQuXHJcbiAgICAgICAgICAgICAqIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuY29uZmlnLlxyXG4gICAgICAgICAgICAgKi9cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgICAqIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgICAgICAgICAqIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgICAgICAgICogVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAgICAgICAgKiBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAgICAgICAgKiBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICAgICAgICogSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgICAgICAgICogSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAgICAgICAgKiBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgICAgICAgICAqIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgICAgICAgICAgLy8gRVhQT05FTlRJQUxfQVQgOiBbVE9fRVhQX05FRyAsIFRPX0VYUF9QT1NdXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtNywgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAtTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGFib3ZlIHdoaWNoIHRvU3RyaW5nIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgICAgICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgICAgICAgICBUT19FWFBfUE9TID0gMjEsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBSQU5HRSA6IFtNSU5fRVhQLCBNQVhfRVhQXVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogLTMyNCAgKDVlLTMyNClcclxuICAgICAgICAgICAgTUlOX0VYUCA9IC0xZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtTUFYXHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAgICAgICAvLyBOdW1iZXIgdHlwZTogIDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICAgICAgICAvLyBGb3IgTUFYX0VYUCA+IDFlNywgZS5nLiBuZXcgQmlnTnVtYmVyKCcxZTEwMDAwMDAwMCcpLnBsdXMoMSkgbWF5IGJlIHNsb3cuXHJcbiAgICAgICAgICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAgICAgICAgIC8vIFdoZXRoZXIgQmlnTnVtYmVyIEVycm9ycyBhcmUgZXZlciB0aHJvd24uXHJcbiAgICAgICAgICAgIEVSUk9SUyA9IHRydWUsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgICAgICAgLy8gQ2hhbmdlIHRvIGludFZhbGlkYXRvck5vRXJyb3JzIGlmIEVSUk9SUyBpcyBmYWxzZS5cclxuICAgICAgICAgICAgaXNWYWxpZEludCA9IGludFZhbGlkYXRvcldpdGhFcnJvcnMsICAgICAvLyBpbnRWYWxpZGF0b3JXaXRoRXJyb3JzL2ludFZhbGlkYXRvck5vRXJyb3JzXHJcblxyXG4gICAgICAgICAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ1ZSBvciBmYWxzZVxyXG5cclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICogVGhlIG1vZHVsbyBtb2RlIHVzZWQgd2hlbiBjYWxjdWxhdGluZyB0aGUgbW9kdWx1czogYSBtb2Qgbi5cclxuICAgICAgICAgICAgICogVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAgICAgICAgICAqIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAgICAgICAgKiBET1dOICAgICAgMSBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpZGVuZC5cclxuICAgICAgICAgICAgICogICAgICAgICAgICAgVGhpcyBtb2R1bG8gbW9kZSBpcyBjb21tb25seSBrbm93biBhcyAndHJ1bmNhdGVkIGRpdmlzaW9uJyBhbmQgaXNcclxuICAgICAgICAgICAgICogICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAgICAgICAgICAqIEZMT09SICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgICAgICAgICAgICogSEFMRl9FVkVOIDYgVGhpcyBtb2R1bG8gbW9kZSBpbXBsZW1lbnRzIHRoZSBJRUVFIDc1NCByZW1haW5kZXIgZnVuY3Rpb24uXHJcbiAgICAgICAgICAgICAqIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgICAgICAgICAgICogICAgICAgICAgICAgVGhlIHJlbWFpbmRlciBpcyBhbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAgICAgICAgICAqIG1vZGVzIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uXHJcbiAgICAgICAgICAgICAqIEFsdGhvdWdoIHRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzbyBiZSB1c2VkLCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIHRvUG93ZXIgb3BlcmF0aW9uLlxyXG4gICAgICAgICAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDEwMCwgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGZvcm1hdCBzcGVjaWZpY2F0aW9uIHVzZWQgYnkgdGhlIEJpZ051bWJlci5wcm90b3R5cGUudG9Gb3JtYXQgbWV0aG9kLlxyXG4gICAgICAgICAgICBGT1JNQVQgPSB7XHJcbiAgICAgICAgICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgICAgICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICAgICAgICAgICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICAgICAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICAgICAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwXHJcbiAgICAgICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xyXG5cclxuXHJcbiAgICAgICAgLy8gQ09OU1RSVUNUT1JcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogVGhlIEJpZ051bWJlciBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICAgICAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCaWdOdW1iZXIgb2JqZWN0LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAgICAgKiBbYl0ge251bWJlcn0gVGhlIGJhc2Ugb2Ygbi4gSW50ZWdlciwgMiB0byA2NCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gQmlnTnVtYmVyKCBuLCBiICkge1xyXG4gICAgICAgICAgICB2YXIgYywgZSwgaSwgbnVtLCBsZW4sIHN0cixcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIHVzYWdlIHdpdGhvdXQgbmV3LlxyXG4gICAgICAgICAgICBpZiAoICEoIHggaW5zdGFuY2VvZiBCaWdOdW1iZXIgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAnQmlnTnVtYmVyKCkgY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IG5ldzoge259J1xyXG4gICAgICAgICAgICAgICAgaWYgKEVSUk9SUykgcmFpc2UoIDI2LCAnY29uc3RydWN0b3IgY2FsbCB3aXRob3V0IG5ldycsIG4gKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCBuLCBiICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vICduZXcgQmlnTnVtYmVyKCkgYmFzZSBub3QgYW4gaW50ZWdlcjoge2J9J1xyXG4gICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIGJhc2Ugb3V0IG9mIHJhbmdlOiB7Yn0nXHJcbiAgICAgICAgICAgIGlmICggYiA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBiLCAyLCA2NCwgaWQsICdiYXNlJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIER1cGxpY2F0ZS5cclxuICAgICAgICAgICAgICAgIGlmICggbiBpbnN0YW5jZW9mIEJpZ051bWJlciApIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSBuLnM7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5lID0gbi5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9ICggbiA9IG4uYyApID8gbi5zbGljZSgpIDogbjtcclxuICAgICAgICAgICAgICAgICAgICBpZCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggKCBudW0gPSB0eXBlb2YgbiA9PSAnbnVtYmVyJyApICYmIG4gKiAwID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5zID0gMSAvIG4gPCAwID8gKCBuID0gLW4sIC0xICkgOiAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBGYXN0IHBhdGggZm9yIGludGVnZXJzLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggbiA9PT0gfn5uICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBlID0gMCwgaSA9IG47IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4LmMgPSBbbl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gbiArICcnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFpc051bWVyaWMudGVzdCggc3RyID0gbiArICcnICkgKSByZXR1cm4gcGFyc2VOdW1lcmljKCB4LCBzdHIsIG51bSApO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/ICggc3RyID0gc3RyLnNsaWNlKDEpLCAtMSApIDogMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGIgPSBiIHwgMDtcclxuICAgICAgICAgICAgICAgIHN0ciA9IG4gKyAnJztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFbnN1cmUgcmV0dXJuIHZhbHVlIGlzIHJvdW5kZWQgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICAgICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LlxyXG4gICAgICAgICAgICAgICAgaWYgKCBiID09IDEwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXcgQmlnTnVtYmVyKCBuIGluc3RhbmNlb2YgQmlnTnVtYmVyID8gbiA6IHN0ciApO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByb3VuZCggeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgICAgICAgICAgLy8gQW55IG51bWJlciBpbiBleHBvbmVudGlhbCBmb3JtIHdpbGwgZmFpbCBkdWUgdG8gdGhlIFtFZV1bKy1dLlxyXG4gICAgICAgICAgICAgICAgaWYgKCAoIG51bSA9IHR5cGVvZiBuID09ICdudW1iZXInICkgJiYgbiAqIDAgIT0gMCB8fFxyXG4gICAgICAgICAgICAgICAgICAhKCBuZXcgUmVnRXhwKCAnXi0/JyArICggYyA9ICdbJyArIEFMUEhBQkVULnNsaWNlKCAwLCBiICkgKyAnXSsnICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICcoPzpcXFxcLicgKyBjICsgJyk/JCcsYiA8IDM3ID8gJ2knIDogJycgKSApLnRlc3Qoc3RyKSApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKCB4LCBzdHIsIG51bSwgYiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChudW0pIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSAxIC8gbiA8IDAgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggRVJST1JTICYmIHN0ci5yZXBsYWNlKCAvXjBcXC4wKnxcXC4vLCAnJyApLmxlbmd0aCA+IDE1ICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBudW1iZXIgdHlwZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSggaWQsIHRvb01hbnlEaWdpdHMsIG4gKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICAgICAgICAgICAgICAgIG51bSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PT0gNDUgPyAoIHN0ciA9IHN0ci5zbGljZSgxKSwgLTEgKSA6IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3RyID0gY29udmVydEJhc2UoIHN0ciwgMTAsIGIsIHgucyApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgICAgICBpZiAoICggZSA9IHN0ci5pbmRleE9mKCcuJykgKSA+IC0xICkgc3RyID0gc3RyLnJlcGxhY2UoICcuJywgJycgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGZvcm0/XHJcbiAgICAgICAgICAgIGlmICggKCBpID0gc3RyLnNlYXJjaCggL2UvaSApICkgPiAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgICAgICAgIGlmICggZSA8IDAgKSBlID0gaTtcclxuICAgICAgICAgICAgICAgIGUgKz0gK3N0ci5zbGljZSggaSArIDEgKTtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoIDAsIGkgKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrICk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgIGZvciAoIGxlbiA9IHN0ci5sZW5ndGg7IHN0ci5jaGFyQ29kZUF0KC0tbGVuKSA9PT0gNDg7ICk7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggaSwgbGVuICsgMSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHN0cikge1xyXG4gICAgICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEaXNhbGxvdyBudW1iZXJzIHdpdGggb3ZlciAxNSBzaWduaWZpY2FudCBkaWdpdHMgaWYgbnVtYmVyIHR5cGUuXHJcbiAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG51bWJlciB0eXBlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICAgICAgICBpZiAoIG51bSAmJiBFUlJPUlMgJiYgbGVuID4gMTUgKSByYWlzZSggaWQsIHRvb01hbnlEaWdpdHMsIHgucyAqIG4gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBlID0gZSAtIGkgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICAgICAgICAgIGlmICggZSA+IE1BWF9FWFAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IE1JTl9FWFAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jID0gW107XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaSBpcyB3aGVyZSB0byBzbGljZSBzdHIgdG8gZ2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBjb2VmZmljaWVudCBhcnJheS5cclxuICAgICAgICAgICAgICAgICAgICBpID0gKCBlICsgMSApICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBlIDwgMCApIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IGxlbiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCArc3RyLnNsaWNlKCAwLCBpICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4LmMucHVzaCggK3N0ci5zbGljZSggaSwgaSArPSBMT0dfQkFTRSApICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaS0tOyBzdHIgKz0gJzAnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeC5jLnB1c2goICtzdHIgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgeC5jID0gWyB4LmUgPSAwIF07XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgICAgICBCaWdOdW1iZXIuYW5vdGhlciA9IGFub3RoZXI7XHJcblxyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICAgICAgQmlnTnVtYmVyLlJPVU5EX0RPV04gPSAxO1xyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9DRUlMID0gMjtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgICAgIEJpZ051bWJlci5ST1VORF9IQUxGX1VQID0gNDtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOID0gNTtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9DRUlMID0gNztcclxuICAgICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9GTE9PUiA9IDg7XHJcbiAgICAgICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIENvbmZpZ3VyZSBpbmZyZXF1ZW50bHktY2hhbmdpbmcgbGlicmFyeS13aWRlIHNldHRpbmdzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQWNjZXB0IGFuIG9iamVjdCBvciBhbiBhcmd1bWVudCBsaXN0LCB3aXRoIG9uZSBvciBtYW55IG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyBvclxyXG4gICAgICAgICAqIHBhcmFtZXRlcnMgcmVzcGVjdGl2ZWx5OlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogICBERUNJTUFMX1BMQUNFUyAge251bWJlcn0gIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZVxyXG4gICAgICAgICAqICAgUk9VTkRJTkdfTU9ERSAgIHtudW1iZXJ9ICBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlXHJcbiAgICAgICAgICogICBFWFBPTkVOVElBTF9BVCAge251bWJlcnxudW1iZXJbXX0gIEludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaW50ZWdlciAtTUFYIHRvIDAgaW5jbC4sIDAgdG8gTUFYIGluY2wuXVxyXG4gICAgICAgICAqICAgUkFOR0UgICAgICAgICAgIHtudW1iZXJ8bnVtYmVyW119ICBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsLiwgaW50ZWdlciAxIHRvIE1BWCBpbmNsLl1cclxuICAgICAgICAgKiAgIEVSUk9SUyAgICAgICAgICB7Ym9vbGVhbnxudW1iZXJ9ICAgdHJ1ZSwgZmFsc2UsIDEgb3IgMFxyXG4gICAgICAgICAqICAgQ1JZUFRPICAgICAgICAgIHtib29sZWFufG51bWJlcn0gICB0cnVlLCBmYWxzZSwgMSBvciAwXHJcbiAgICAgICAgICogICBNT0RVTE9fTU9ERSAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOSBpbmNsdXNpdmVcclxuICAgICAgICAgKiAgIFBPV19QUkVDSVNJT04gICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVggaW5jbHVzaXZlXHJcbiAgICAgICAgICogICBGT1JNQVQgICAgICAgICAge29iamVjdH0gICAgICAgICAgIFNlZSBCaWdOdW1iZXIucHJvdG90eXBlLnRvRm9ybWF0XHJcbiAgICAgICAgICogICAgICBkZWNpbWFsU2VwYXJhdG9yICAgICAgIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBncm91cFNpemUgICAgICAgICAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICAgICBzZWNvbmRhcnlHcm91cFNpemUgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2l6ZSAgICAgIHtudW1iZXJ9XHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAoVGhlIHZhbHVlcyBhc3NpZ25lZCB0byB0aGUgYWJvdmUgRk9STUFUIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3QgY2hlY2tlZCBmb3IgdmFsaWRpdHkuKVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRS5nLlxyXG4gICAgICAgICAqIEJpZ051bWJlci5jb25maWcoMjAsIDQpIGlzIGVxdWl2YWxlbnQgdG9cclxuICAgICAgICAgKiBCaWdOdW1iZXIuY29uZmlnKHsgREVDSU1BTF9QTEFDRVMgOiAyMCwgUk9VTkRJTkdfTU9ERSA6IDQgfSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIElnbm9yZSBwcm9wZXJ0aWVzL3BhcmFtZXRlcnMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgICAgICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIuY29uZmlnID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdiwgcCxcclxuICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgciA9IHt9LFxyXG4gICAgICAgICAgICAgICAgYSA9IGFyZ3VtZW50cyxcclxuICAgICAgICAgICAgICAgIG8gPSBhWzBdLFxyXG4gICAgICAgICAgICAgICAgaGFzID0gbyAmJiB0eXBlb2YgbyA9PSAnb2JqZWN0J1xyXG4gICAgICAgICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHsgaWYgKCBvLmhhc093blByb3BlcnR5KHApICkgcmV0dXJuICggdiA9IG9bcF0gKSAhPSBudWxsOyB9XHJcbiAgICAgICAgICAgICAgICAgIDogZnVuY3Rpb24gKCkgeyBpZiAoIGEubGVuZ3RoID4gaSApIHJldHVybiAoIHYgPSBhW2krK10gKSAhPSBudWxsOyB9O1xyXG5cclxuICAgICAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgREVDSU1BTF9QTEFDRVMgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIERFQ0lNQUxfUExBQ0VTIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdERUNJTUFMX1BMQUNFUycgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgIERFQ0lNQUxfUExBQ0VTID0gdiB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IERFQ0lNQUxfUExBQ0VTO1xyXG5cclxuICAgICAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUk9VTkRJTkdfTU9ERSBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUk9VTkRJTkdfTU9ERSBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnUk9VTkRJTkdfTU9ERScgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCA4LCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICBST1VORElOR19NT0RFID0gdiB8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgICAgICAvLyBFWFBPTkVOVElBTF9BVCB7bnVtYmVyfG51bWJlcltdfVxyXG4gICAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3IgW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIEVYUE9ORU5USUFMX0FUIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBFWFBPTkVOVElBTF9BVCBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnRVhQT05FTlRJQUxfQVQnICkgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBpc0FycmF5KHYpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaXNWYWxpZEludCggdlswXSwgLU1BWCwgMCwgMiwgcCApICYmIGlzVmFsaWRJbnQoIHZbMV0sIDAsIE1BWCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBUT19FWFBfTkVHID0gdlswXSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBpc1ZhbGlkSW50KCB2LCAtTUFYLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgICAgICBUT19FWFBfTkVHID0gLSggVE9fRVhQX1BPUyA9ICggdiA8IDAgPyAtdiA6IHYgKSB8IDAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gWyBUT19FWFBfTkVHLCBUT19FWFBfUE9TIF07XHJcblxyXG4gICAgICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIFJBTkdFIG5vdCBhbiBpbnRlZ2VyOiB7dn0nXHJcbiAgICAgICAgICAgIC8vICdjb25maWcoKSBSQU5HRSBjYW5ub3QgYmUgemVybzoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUkFOR0Ugb3V0IG9mIHJhbmdlOiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ1JBTkdFJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaXNBcnJheSh2KSApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGlzVmFsaWRJbnQoIHZbMF0sIC1NQVgsIC0xLCAyLCBwICkgJiYgaXNWYWxpZEludCggdlsxXSwgMSwgTUFYLCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgTUFYX0VYUCA9IHZbMV0gfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGlzVmFsaWRJbnQoIHYsIC1NQVgsIE1BWCwgMiwgcCApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdiB8IDAgKSBNSU5fRVhQID0gLSggTUFYX0VYUCA9ICggdiA8IDAgPyAtdiA6IHYgKSB8IDAgKTtcclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChFUlJPUlMpIHJhaXNlKCAyLCBwICsgJyBjYW5ub3QgYmUgemVybycsIHYgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gWyBNSU5fRVhQLCBNQVhfRVhQIF07XHJcblxyXG4gICAgICAgICAgICAvLyBFUlJPUlMge2Jvb2xlYW58bnVtYmVyfSB0cnVlLCBmYWxzZSwgMSBvciAwLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRVJST1JTIG5vdCBhIGJvb2xlYW4gb3IgYmluYXJ5IGRpZ2l0OiB7dn0nXHJcbiAgICAgICAgICAgIGlmICggaGFzKCBwID0gJ0VSUk9SUycgKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHYgPT09ICEhdiB8fCB2ID09PSAxIHx8IHYgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzVmFsaWRJbnQgPSAoIEVSUk9SUyA9ICEhdiApID8gaW50VmFsaWRhdG9yV2l0aEVycm9ycyA6IGludFZhbGlkYXRvck5vRXJyb3JzO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICByYWlzZSggMiwgcCArIG5vdEJvb2wsIHYgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gRVJST1JTO1xyXG5cclxuICAgICAgICAgICAgLy8gQ1JZUFRPIHtib29sZWFufG51bWJlcn0gdHJ1ZSwgZmFsc2UsIDEgb3IgMC5cclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIENSWVBUTyBub3QgYSBib29sZWFuIG9yIGJpbmFyeSBkaWdpdDoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgY3J5cHRvIHVuYXZhaWxhYmxlOiB7Y3J5cHRvfSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnQ1JZUFRPJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdiA9PT0gISF2IHx8IHYgPT09IDEgfHwgdiA9PT0gMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBDUllQVE8gPSAhISggdiAmJiBjcnlwdG8gJiYgdHlwZW9mIGNyeXB0byA9PSAnb2JqZWN0JyApO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICggdiAmJiAhQ1JZUFRPICYmIEVSUk9SUyApIHJhaXNlKCAyLCAnY3J5cHRvIHVuYXZhaWxhYmxlJywgY3J5cHRvICk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEVSUk9SUykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJhaXNlKCAyLCBwICsgbm90Qm9vbCwgdiApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBDUllQVE87XHJcblxyXG4gICAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgTU9EVUxPX01PREUgbm90IGFuIGludGVnZXI6IHt2fSdcclxuICAgICAgICAgICAgLy8gJ2NvbmZpZygpIE1PRFVMT19NT0RFIG91dCBvZiByYW5nZToge3Z9J1xyXG4gICAgICAgICAgICBpZiAoIGhhcyggcCA9ICdNT0RVTE9fTU9ERScgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCA5LCAyLCBwICkgKSB7XHJcbiAgICAgICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHYgfCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJbcF0gPSBNT0RVTE9fTU9ERTtcclxuXHJcbiAgICAgICAgICAgIC8vIFBPV19QUkVDSVNJT04ge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUE9XX1BSRUNJU0lPTiBub3QgYW4gaW50ZWdlcjoge3Z9J1xyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgUE9XX1BSRUNJU0lPTiBvdXQgb2YgcmFuZ2U6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnUE9XX1BSRUNJU0lPTicgKSAmJiBpc1ZhbGlkSW50KCB2LCAwLCBNQVgsIDIsIHAgKSApIHtcclxuICAgICAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2IHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByW3BdID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgICAvLyAnY29uZmlnKCkgRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICAgICAgaWYgKCBoYXMoIHAgPSAnRk9STUFUJyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggdHlwZW9mIHYgPT0gJ29iamVjdCcgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgRk9STUFUID0gdjtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoRVJST1JTKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDIsIHAgKyAnIG5vdCBhbiBvYmplY3QnLCB2ICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcltwXSA9IEZPUk1BVDtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiByO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgQmlnTnVtYmVyLm1heCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heE9yTWluKCBhcmd1bWVudHMsIFAubHQgKTsgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWF4T3JNaW4oIGFyZ3VtZW50cywgUC5ndCApOyB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLFxyXG4gICAgICAgICAqIGFuZCB3aXRoIGRwLCBvciBERUNJTUFMX1BMQUNFUyBpZiBkcCBpcyBvbWl0dGVkLCBkZWNpbWFsIHBsYWNlcyAob3IgbGVzcyBpZiB0cmFpbGluZ1xyXG4gICAgICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAncmFuZG9tKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3JhbmRvbSgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAncmFuZG9tKCkgY3J5cHRvIHVuYXZhaWxhYmxlOiB7Y3J5cHRvfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHBvdzJfNTMgPSAweDIwMDAwMDAwMDAwMDAwO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIGEgNTMgYml0IGludGVnZXIgbiwgd2hlcmUgMCA8PSBuIDwgOTAwNzE5OTI1NDc0MDk5Mi5cclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgICAgICAgICAvLyBJZiBpdCBkb2VzLCBhc3N1bWUgYXQgbGVhc3QgNTMgYml0cyBhcmUgcHJvZHVjZWQsIG90aGVyd2lzZSBhc3N1bWUgYXQgbGVhc3QgMzAgYml0cy5cclxuICAgICAgICAgICAgLy8gMHg0MDAwMDAwMCBpcyAyXjMwLCAweDgwMDAwMCBpcyAyXjIzLCAweDFmZmZmZiBpcyAyXjIxIC0gMS5cclxuICAgICAgICAgICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgICAgICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoIE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzICk7IH1cclxuICAgICAgICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgICAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICAgICAgICAgIHZhciBhLCBiLCBlLCBrLCB2LFxyXG4gICAgICAgICAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICByYW5kID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICAgICAgICAgIGRwID0gZHAgPT0gbnVsbCB8fCAhaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMTQgKSA/IERFQ0lNQUxfUExBQ0VTIDogZHAgfCAwO1xyXG4gICAgICAgICAgICAgICAgayA9IG1hdGhjZWlsKCBkcCAvIExPR19CQVNFICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKENSWVBUTykge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBjcnlwdG8gJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCBuZXcgVWludDMyQXJyYXkoIGsgKj0gMiApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBrOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA1MyBiaXRzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSAqIE1hdGgucG93KDIsIDIxKSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpID4+PiAxMSkudG9TdHJpbmcoMilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gYVtpXSAqIDB4MjAwMDAgKyAoYVtpICsgMV0gPj4+IDExKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWplY3Rpb24gc2FtcGxpbmc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9iYWJpbGl0eSB0aGF0IHYgPj0gOWUxNSwgaXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDcxOTkyNTQ3NDA5OTIgLyA5MDA3MTk5MjU0NzQwOTkyIH49IDAuMDAwOCwgaS5lLiAxIGluIDEyNTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggdiA+PSA5ZTE1ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKCBuZXcgVWludDMyQXJyYXkoMikgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhW2kgKyAxXSA9IGJbMV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIDw9IHYgPD0gODk5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gKHYgJSAxZTE0KSA8PSA5OTk5OTk5OTk5OTk5OVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMucHVzaCggdiAlIDFlMTQgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIGNyeXB0byAmJiBjcnlwdG8ucmFuZG9tQnl0ZXMgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidWZmZXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9IGNyeXB0by5yYW5kb21CeXRlcyggayAqPSA3ICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBrOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMDAwMDAgaXMgMl40OCwgMHgxMDAwMDAwMDAwMCBpcyAyXjQwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8IDkwMDcxOTkyNTQ3NDA5OTJcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSAoICggYVtpXSAmIDMxICkgKiAweDEwMDAwMDAwMDAwMDAgKSArICggYVtpICsgMV0gKiAweDEwMDAwMDAwMDAwICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhW2kgKyAyXSAqIDB4MTAwMDAwMDAwICkgKyAoIGFbaSArIDNdICogMHgxMDAwMDAwICkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKCBhW2kgKyA0XSA8PCAxNiApICsgKCBhW2kgKyA1XSA8PCA4ICkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHYgPj0gOWUxNSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNykuY29weSggYSwgaSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCA8PSAodiAlIDFlMTQpIDw9IDk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5wdXNoKCB2ICUgMWUxNCApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gayAvIDc7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChFUlJPUlMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmFpc2UoIDE0LCAnY3J5cHRvIHVuYXZhaWxhYmxlJywgY3J5cHRvICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFVzZSBNYXRoLnJhbmRvbTogQ1JZUFRPIGlzIGZhbHNlIG9yIGNyeXB0byBpcyB1bmF2YWlsYWJsZSBhbmQgRVJST1JTIGlzIGZhbHNlLlxyXG4gICAgICAgICAgICAgICAgaWYgKCFpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIDsgaSA8IGs7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB2IDwgOWUxNSApIGNbaSsrXSA9IHYgJSAxZTE0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBrID0gY1stLWldO1xyXG4gICAgICAgICAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIGRwLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBrICYmIGRwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHYgPSBQT1dTX1RFTltMT0dfQkFTRSAtIGRwXTtcclxuICAgICAgICAgICAgICAgICAgICBjW2ldID0gbWF0aGZsb29yKCBrIC8gdiApICogdjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgICAgICAgICAgICBmb3IgKCA7IGNbaV0gPT09IDA7IGMucG9wKCksIGktLSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSBbIGUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGUgPSAtMSA7IGNbMF0gPT09IDA7IGMuc2hpZnQoKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBhZGp1c3QgdGhlIGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggaSA8IExPR19CQVNFICkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmFuZC5lID0gZTtcclxuICAgICAgICAgICAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAgICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgYSBudW1lcmljIHN0cmluZyBvZiBiYXNlSW4gdG8gYSBudW1lcmljIHN0cmluZyBvZiBiYXNlT3V0LlxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbnZlcnRCYXNlKCBzdHIsIGJhc2VPdXQsIGJhc2VJbiwgc2lnbiApIHtcclxuICAgICAgICAgICAgdmFyIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgICAgICAgICAgaSA9IHN0ci5pbmRleE9mKCAnLicgKSxcclxuICAgICAgICAgICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgICAgICAgICBybSA9IFJPVU5ESU5HX01PREU7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGJhc2VJbiA8IDM3ICkgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBOb24taW50ZWdlci5cclxuICAgICAgICAgICAgaWYgKCBpID49IDAgKSB7XHJcbiAgICAgICAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBVbmxpbWl0ZWQgcHJlY2lzaW9uLlxyXG4gICAgICAgICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IDA7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSggJy4nLCAnJyApO1xyXG4gICAgICAgICAgICAgICAgeSA9IG5ldyBCaWdOdW1iZXIoYmFzZUluKTtcclxuICAgICAgICAgICAgICAgIHggPSB5LnBvdyggc3RyLmxlbmd0aCAtIGkgKTtcclxuICAgICAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuICAgICAgICAgICAgICAgIHkuYyA9IHRvQmFzZU91dCggdG9GaXhlZFBvaW50KCBjb2VmZlRvU3RyaW5nKCB4LmMgKSwgeC5lICksIDEwLCBiYXNlT3V0ICk7XHJcbiAgICAgICAgICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuICAgICAgICAgICAgeGMgPSB0b0Jhc2VPdXQoIHN0ciwgYmFzZUluLCBiYXNlT3V0ICk7XHJcbiAgICAgICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICBmb3IgKCA7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkgKTtcclxuICAgICAgICAgICAgaWYgKCAheGNbMF0gKSByZXR1cm4gJzAnO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpIDwgMCApIHtcclxuICAgICAgICAgICAgICAgIC0tZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgICAgICAgICAgeC5lID0gZTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICAgICAgICAgIHgucyA9IHNpZ247XHJcbiAgICAgICAgICAgICAgICB4ID0gZGl2KCB4LCB5LCBkcCwgcm0sIGJhc2VPdXQgKTtcclxuICAgICAgICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCB0byB0aGUgcmlnaHQgb2YgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgICAgIGkgPSB4Y1tkXTtcclxuICAgICAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgICAgICByID0gciB8fCBkIDwgMCB8fCB4Y1tkICsgMV0gIT0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIHIgPSBybSA8IDQgPyAoIGkgIT0gbnVsbCB8fCByICkgJiYgKCBybSA9PSAwIHx8IHJtID09ICggeC5zIDwgMCA/IDMgOiAyICkgKVxyXG4gICAgICAgICAgICAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKCBybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICBybSA9PSAoIHgucyA8IDAgPyA4IDogNyApICk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIGQgPCAxIHx8ICF4Y1swXSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAxXi1kcCBvciAwLlxyXG4gICAgICAgICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludCggJzEnLCAtZHAgKSA6ICcwJztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCAtLWJhc2VPdXQ7ICsreGNbLS1kXSA+IGJhc2VPdXQ7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Y1tkXSA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICFkICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGMudW5zaGlmdCgxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBrID0geGMubGVuZ3RoOyAheGNbLS1rXTsgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgICAgICAgZm9yICggaSA9IDAsIHN0ciA9ICcnOyBpIDw9IGs7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoIHhjW2krK10gKSApO1xyXG4gICAgICAgICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gVGhlIGNhbGxlciB3aWxsIGFkZCB0aGUgc2lnbi5cclxuICAgICAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS4gQ2FsbGVkIGJ5IGRpdiBhbmQgY29udmVydEJhc2UuXHJcbiAgICAgICAgZGl2ID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFzc3VtZSBub24temVybyB4IGFuZCBrLlxyXG4gICAgICAgICAgICBmdW5jdGlvbiBtdWx0aXBseSggeCwgaywgYmFzZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgICAgICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICAgICAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yICggeCA9IHguc2xpY2UoKTsgaS0tOyApIHtcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgICAgICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgICAgICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICggKCBtICUgU1FSVF9CQVNFICkgKiBTUVJUX0JBU0UgKSArIGNhcnJ5O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhcnJ5ID0gKCB0ZW1wIC8gYmFzZSB8IDAgKSArICggbSAvIFNRUlRfQkFTRSB8IDAgKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgICAgICAgICAgICB4W2ldID0gdGVtcCAlIGJhc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGNhcnJ5KSB4LnVuc2hpZnQoY2FycnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wYXJlKCBhLCBiLCBhTCwgYkwgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYUwgIT0gYkwgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY21wID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYVtpXSAhPSBiW2ldICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjbXA7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0KCBhLCBiLCBhTCwgYmFzZSApIHtcclxuICAgICAgICAgICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgICAgICAgICAgIGZvciAoIDsgYUwtLTsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyAhYVswXSAmJiBhLmxlbmd0aCA+IDE7IGEuc2hpZnQoKSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICggeCwgeSwgZHAsIHJtLCBiYXNlICkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgICAgICAgICAgICAgIHlMLCB5eixcclxuICAgICAgICAgICAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCBJbmZpbml0eSBvciAwP1xyXG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgICAgICAgICAgICAgIXgucyB8fCAheS5zIHx8ICggeGMgPyB5YyAmJiB4Y1swXSA9PSB5Y1swXSA6ICF5YyApID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICAgICAgICAgIHFjID0gcS5jID0gW107XHJcbiAgICAgICAgICAgICAgICBlID0geC5lIC0geS5lO1xyXG4gICAgICAgICAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCAhYmFzZSApIHtcclxuICAgICAgICAgICAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgICAgICAgICAgICBlID0gYml0Rmxvb3IoIHguZSAvIExPR19CQVNFICkgLSBiaXRGbG9vciggeS5lIC8gTE9HX0JBU0UgKTtcclxuICAgICAgICAgICAgICAgICAgICBzID0gcyAvIExPR19CQVNFIHwgMDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAgICAgICAgIC8vIFRoZSBjb2VmZmljaWVudHMgb2YgdGhlIEJpZ051bWJlcnMgZnJvbSBjb252ZXJ0QmFzZSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgICAgIGZvciAoIGkgPSAwOyB5Y1tpXSA9PSAoIHhjW2ldIHx8IDAgKTsgaSsrICk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHljW2ldID4gKCB4Y1tpXSB8fCAwICkgKSBlLS07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzIDwgMCApIHtcclxuICAgICAgICAgICAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBzICs9IDI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vcm1hbGlzZSB4YyBhbmQgeWMgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5YyBpcyA+PSBiYXNlIC8gMi5cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggYmFzZSAvICggeWNbMF0gKyAxICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKCBiYXNlIC8gMiApIC0gMS5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBuID4gMSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeWMgPSBtdWx0aXBseSggeWMsIG4sIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeGMgPSBtdWx0aXBseSggeGMsIG4sIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgICAgICAgICAgICByZW0gPSB4Yy5zbGljZSggMCwgeUwgKTtcclxuICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwICk7XHJcbiAgICAgICAgICAgICAgICAgICAgeXogPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHl6LnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB5Y1sxXSA+PSBiYXNlIC8gMiApIHljMCsrO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIGlmICggYmFzZSA9PSAzICYmIHljMCA9PSAxICkgeWMwID0gMSArIDFlLTE1O1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUoIHljLCByZW0sIHlMLCByZW1MICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGNtcCA8IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRyaWFsIGRpZ2l0LCBuLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHlMICE9IHJlbUwgKSByZW0wID0gcmVtMCAqIGJhc2UgKyAoIHJlbVsxXSB8fCAwICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG1hdGhmbG9vciggcmVtMCAvIHljMCApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgMS4gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdCAobilcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAyLiBpZiBwcm9kdWN0ID4gcmVtYWluZGVyOiBwcm9kdWN0IC09IGRpdmlzb3IsIG4tLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gIDMuIHJlbWFpbmRlciAtPSBwcm9kdWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgNC4gaWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIgYXQgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgIDUuIGNvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgNi4gSWYgcmVtYWluZGVyID4gZGl2aXNvcjogcmVtYWluZGVyIC09IGRpdmlzb3IsIG4rK1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA+IDEgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gbWF5IGJlID4gYmFzZSBvbmx5IHdoZW4gYmFzZSBpcyAzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9kID0gbXVsdGlwbHkoIHljLCBuLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gaGlnaCBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIGlzIG5vdCBrbm93biB0byBoYXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlciBiZWVuIG1vcmUgdGhhbiAxIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY29tcGFyZSggcHJvZCwgcmVtLCBwcm9kTCwgcmVtTCApID09IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4tLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0cmFjdCggcHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuID09IDAgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkaXZpc29yIDwgcmVtYWluZGVyLCBzbyBuIG11c3QgYmUgYXQgbGVhc3QgMS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBwcm9kTCA8IHJlbUwgKSBwcm9kLnVuc2hpZnQoMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KCByZW0sIHByb2QsIHJlbUwsIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICggY21wID09IC0xICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpYWwgZGlnaXQgbiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICggY29tcGFyZSggeWMsIHJlbSwgeUwsIHJlbUwgKSA8IDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4rKztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KCByZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCBjbXAgPT09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gLy8gZWxzZSBjbXAgPT09IDEgYW5kIG4gd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHFjW2krK10gPSBuO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggcmVtWzBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbSA9IFsgeGNbeGldIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKCAoIHhpKysgPCB4TCB8fCByZW1bMF0gIT0gbnVsbCApICYmIHMtLSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFxY1swXSApIHFjLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBiYXNlID09IEJBU0UgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIGNhbGN1bGF0ZSBxLmUsIGZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBxY1swXS5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgcyA9IHFjWzBdOyBzID49IDEwOyBzIC89IDEwLCBpKysgKTtcclxuICAgICAgICAgICAgICAgICAgICByb3VuZCggcSwgZHAgKyAoIHEuZSA9IGkgKyBlICogTE9HX0JBU0UgLSAxICkgKyAxLCBybSwgbW9yZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENhbGxlciBpcyBjb252ZXJ0QmFzZS5cclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcS5lID0gZTtcclxuICAgICAgICAgICAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KSgpO1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAgICAgICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIGlzIGEgQmlnTnVtYmVyLlxyXG4gICAgICAgICAqIGkgaXMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAgICAgKiBybSBpcyB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAgICAgKiBjYWxsZXIgaXMgY2FsbGVyIGlkOiB0b0V4cG9uZW50aWFsIDE5LCB0b0ZpeGVkIDIwLCB0b0Zvcm1hdCAyMSwgdG9QcmVjaXNpb24gMjQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gZm9ybWF0KCBuLCBpLCBybSwgY2FsbGVyICkge1xyXG4gICAgICAgICAgICB2YXIgYzAsIGUsIG5lLCBsZW4sIHN0cjtcclxuXHJcbiAgICAgICAgICAgIHJtID0gcm0gIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBybSwgMCwgOCwgY2FsbGVyLCByb3VuZGluZ01vZGUgKVxyXG4gICAgICAgICAgICAgID8gcm0gfCAwIDogUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgICAgIGlmICggIW4uYyApIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGMwID0gbi5jWzBdO1xyXG4gICAgICAgICAgICBuZSA9IG4uZTtcclxuXHJcbiAgICAgICAgICAgIGlmICggaSA9PSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgc3RyID0gY29lZmZUb1N0cmluZyggbi5jICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgPSBjYWxsZXIgPT0gMTkgfHwgY2FsbGVyID09IDI0ICYmIG5lIDw9IFRPX0VYUF9ORUdcclxuICAgICAgICAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKCBzdHIsIG5lIClcclxuICAgICAgICAgICAgICAgICAgOiB0b0ZpeGVkUG9pbnQoIHN0ciwgbmUgKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG4gPSByb3VuZCggbmV3IEJpZ051bWJlcihuKSwgaSwgcm0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgICAgICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xyXG4gICAgICAgICAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXJcclxuICAgICAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgaWYgKCBjYWxsZXIgPT0gMTkgfHwgY2FsbGVyID09IDI0ICYmICggaSA8PSBlIHx8IGUgPD0gVE9fRVhQX05FRyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICggOyBsZW4gPCBpOyBzdHIgKz0gJzAnLCBsZW4rKyApO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoIHN0ciwgZSApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeGVkLXBvaW50IG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpIC09IG5lO1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IHRvRml4ZWRQb2ludCggc3RyLCBlICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGUgKyAxID4gbGVuICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIC0taSA+IDAgKSBmb3IgKCBzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcgKTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGUgLSBsZW47XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggaSA+IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGUgKyAxID09IGxlbiApIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGktLTsgc3RyICs9ICcwJyApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgQmlnTnVtYmVyLm1heCBhbmQgQmlnTnVtYmVyLm1pbi5cclxuICAgICAgICBmdW5jdGlvbiBtYXhPck1pbiggYXJncywgbWV0aG9kICkge1xyXG4gICAgICAgICAgICB2YXIgbSwgbixcclxuICAgICAgICAgICAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBpc0FycmF5KCBhcmdzWzBdICkgKSBhcmdzID0gYXJnc1swXTtcclxuICAgICAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoIGFyZ3NbMF0gKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoIDsgKytpIDwgYXJncy5sZW5ndGg7ICkge1xyXG4gICAgICAgICAgICAgICAgbiA9IG5ldyBCaWdOdW1iZXIoIGFyZ3NbaV0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBhbnkgbnVtYmVyIGlzIE5hTiwgcmV0dXJuIE5hTi5cclxuICAgICAgICAgICAgICAgIGlmICggIW4ucyApIHtcclxuICAgICAgICAgICAgICAgICAgICBtID0gbjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIG1ldGhvZC5jYWxsKCBtLCBuICkgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBtO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgbiBpcyBhbiBpbnRlZ2VyIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICAgICAgICogVXNlIGZvciBhcmd1bWVudCB2YWxpZGF0aW9uIHdoZW4gRVJST1JTIGlzIHRydWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gaW50VmFsaWRhdG9yV2l0aEVycm9ycyggbiwgbWluLCBtYXgsIGNhbGxlciwgbmFtZSApIHtcclxuICAgICAgICAgICAgaWYgKCBuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPSB0cnVuY2F0ZShuKSApIHtcclxuICAgICAgICAgICAgICAgIHJhaXNlKCBjYWxsZXIsICggbmFtZSB8fCAnZGVjaW1hbCBwbGFjZXMnICkgK1xyXG4gICAgICAgICAgICAgICAgICAoIG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlJyA6ICcgbm90IGFuIGludGVnZXInICksIG4gKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBTdHJpcCB0cmFpbGluZyB6ZXJvcywgY2FsY3VsYXRlIGJhc2UgMTAgZXhwb25lbnQgYW5kIGNoZWNrIGFnYWluc3QgTUlOX0VYUCBhbmQgTUFYX0VYUC5cclxuICAgICAgICAgKiBDYWxsZWQgYnkgbWludXMsIHBsdXMgYW5kIHRpbWVzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGlzZSggbiwgYywgZSApIHtcclxuICAgICAgICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgICAgICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggOyAhY1stLWpdOyBjLnBvcCgpICk7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQuIEZpcnN0IGdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgICAgICBmb3IgKCBqID0gY1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrICk7XHJcblxyXG4gICAgICAgICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgICAgICAgaWYgKCAoIGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSApID4gTUFYX0VYUCApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgIG4uYyA9IG4uZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIGUgPCBNSU5fRVhQICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICBuLmMgPSBbIG4uZSA9IDAgXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgICAgICAgICBuLmMgPSBjO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAvLyBIYW5kbGUgdmFsdWVzIHRoYXQgZmFpbCB0aGUgdmFsaWRpdHkgdGVzdCBpbiBCaWdOdW1iZXIuXHJcbiAgICAgICAgcGFyc2VOdW1lcmljID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKS9pLFxyXG4gICAgICAgICAgICAgICAgZG90QWZ0ZXIgPSAvXihbXi5dKylcXC4kLyxcclxuICAgICAgICAgICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgICAgICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgICAgICAgICAgICB3aGl0ZXNwYWNlT3JQbHVzID0gL15cXHMqXFwrfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCB4LCBzdHIsIG51bSwgYiApIHtcclxuICAgICAgICAgICAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgICAgICAgICAgICAgIHMgPSBudW0gPyBzdHIgOiBzdHIucmVwbGFjZSggd2hpdGVzcGFjZU9yUGx1cywgJycgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBObyBleGNlcHRpb24gb24gwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgICAgICAgICAgICBpZiAoIGlzSW5maW5pdHlPck5hTi50ZXN0KHMpICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IGlzTmFOKHMpID8gbnVsbCA6IHMgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoICFudW0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBiYXNlUHJlZml4LCBmdW5jdGlvbiAoIG0sIHAxLCBwMiApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2UgPSAoIHAyID0gcDIudG9Mb3dlckNhc2UoKSApID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWIgfHwgYiA9PSBiYXNlID8gcDEgOiBtO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFLmcuICcxLicgdG8gJzEnLCAnLjEnIHRvICcwLjEnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzID0gcy5yZXBsYWNlKCBkb3RBZnRlciwgJyQxJyApLnJlcGxhY2UoIGRvdEJlZm9yZSwgJzAuJDEnICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggc3RyICE9IHMgKSByZXR1cm4gbmV3IEJpZ051bWJlciggcywgYmFzZSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gJ25ldyBCaWdOdW1iZXIoKSBub3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgICAgICAgICAgICAvLyAnbmV3IEJpZ051bWJlcigpIG5vdCBhIGJhc2Uge2J9IG51bWJlcjoge259J1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCBpZCwgJ25vdCBhJyArICggYiA/ICcgYmFzZSAnICsgYiA6ICcnICkgKyAnIG51bWJlcicsIHN0ciApO1xyXG4gICAgICAgICAgICAgICAgICAgIHgucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pKCk7XHJcblxyXG5cclxuICAgICAgICAvLyBUaHJvdyBhIEJpZ051bWJlciBFcnJvci5cclxuICAgICAgICBmdW5jdGlvbiByYWlzZSggY2FsbGVyLCBtc2csIHZhbCApIHtcclxuICAgICAgICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCBbXHJcbiAgICAgICAgICAgICAgICAnbmV3IEJpZ051bWJlcicsICAgICAvLyAwXHJcbiAgICAgICAgICAgICAgICAnY21wJywgICAgICAgICAgICAgICAvLyAxXHJcbiAgICAgICAgICAgICAgICAnY29uZmlnJywgICAgICAgICAgICAvLyAyXHJcbiAgICAgICAgICAgICAgICAnZGl2JywgICAgICAgICAgICAgICAvLyAzXHJcbiAgICAgICAgICAgICAgICAnZGl2VG9JbnQnLCAgICAgICAgICAvLyA0XHJcbiAgICAgICAgICAgICAgICAnZXEnLCAgICAgICAgICAgICAgICAvLyA1XHJcbiAgICAgICAgICAgICAgICAnZ3QnLCAgICAgICAgICAgICAgICAvLyA2XHJcbiAgICAgICAgICAgICAgICAnZ3RlJywgICAgICAgICAgICAgICAvLyA3XHJcbiAgICAgICAgICAgICAgICAnbHQnLCAgICAgICAgICAgICAgICAvLyA4XHJcbiAgICAgICAgICAgICAgICAnbHRlJywgICAgICAgICAgICAgICAvLyA5XHJcbiAgICAgICAgICAgICAgICAnbWludXMnLCAgICAgICAgICAgICAvLyAxMFxyXG4gICAgICAgICAgICAgICAgJ21vZCcsICAgICAgICAgICAgICAgLy8gMTFcclxuICAgICAgICAgICAgICAgICdwbHVzJywgICAgICAgICAgICAgIC8vIDEyXHJcbiAgICAgICAgICAgICAgICAncHJlY2lzaW9uJywgICAgICAgICAvLyAxM1xyXG4gICAgICAgICAgICAgICAgJ3JhbmRvbScsICAgICAgICAgICAgLy8gMTRcclxuICAgICAgICAgICAgICAgICdyb3VuZCcsICAgICAgICAgICAgIC8vIDE1XHJcbiAgICAgICAgICAgICAgICAnc2hpZnQnLCAgICAgICAgICAgICAvLyAxNlxyXG4gICAgICAgICAgICAgICAgJ3RpbWVzJywgICAgICAgICAgICAgLy8gMTdcclxuICAgICAgICAgICAgICAgICd0b0RpZ2l0cycsICAgICAgICAgIC8vIDE4XHJcbiAgICAgICAgICAgICAgICAndG9FeHBvbmVudGlhbCcsICAgICAvLyAxOVxyXG4gICAgICAgICAgICAgICAgJ3RvRml4ZWQnLCAgICAgICAgICAgLy8gMjBcclxuICAgICAgICAgICAgICAgICd0b0Zvcm1hdCcsICAgICAgICAgIC8vIDIxXHJcbiAgICAgICAgICAgICAgICAndG9GcmFjdGlvbicsICAgICAgICAvLyAyMlxyXG4gICAgICAgICAgICAgICAgJ3BvdycsICAgICAgICAgICAgICAgLy8gMjNcclxuICAgICAgICAgICAgICAgICd0b1ByZWNpc2lvbicsICAgICAgIC8vIDI0XHJcbiAgICAgICAgICAgICAgICAndG9TdHJpbmcnLCAgICAgICAgICAvLyAyNVxyXG4gICAgICAgICAgICAgICAgJ0JpZ051bWJlcicgICAgICAgICAgLy8gMjZcclxuICAgICAgICAgICAgXVtjYWxsZXJdICsgJygpICcgKyBtc2cgKyAnOiAnICsgdmFsICk7XHJcblxyXG4gICAgICAgICAgICBlcnJvci5uYW1lID0gJ0JpZ051bWJlciBFcnJvcic7XHJcbiAgICAgICAgICAgIGlkID0gMDtcclxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAgICAgICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZnVuY3Rpb24gcm91bmQoIHgsIHNkLCBybSwgciApIHtcclxuICAgICAgICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgICAgICAgICAvLyBpZiB4IGlzIG5vdCBJbmZpbml0eSBvciBOYU4uLi5cclxuICAgICAgICAgICAgaWYgKHhjKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgICAgICAgICAgICAvLyBuaSBpcyB0aGUgaW5kZXggb2YgbiB3aXRoaW4geC5jLlxyXG4gICAgICAgICAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgICAvLyBqIGlzIHRoZSBhY3R1YWwgaW5kZXggb2YgcmQgd2l0aGluIG4gKGlmIDwgMCwgcmQgaXMgYSBsZWFkaW5nIHplcm8pLlxyXG4gICAgICAgICAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKysgKTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gc2QgLSBkO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIGkgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSB4Y1sgbmkgPSAwIF07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmQgPSBuIC8gcG93czEwWyBkIC0gaiAtIDEgXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuaSA9IG1hdGhjZWlsKCAoIGkgKyAxICkgLyBMT0dfQkFTRSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuaSA+PSB4Yy5sZW5ndGggKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggOyB4Yy5sZW5ndGggPD0gbmk7IHhjLnB1c2goMCkgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGQgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBrID0geGNbbmldO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICggZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4sIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGQ7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbIGQgLSBqIC0gMSBdICUgMTAgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwWyBkIC0gaiAtIDEgXSAgcmV0dXJucyBhbGwgZGlnaXRzIG9mIG4gdG8gdGhlIHJpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8ICggaiA8IDAgPyBuIDogbiAlIHBvd3MxMFsgZCAtIGogLSAxIF0gKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgciA9IHJtIDwgNFxyXG4gICAgICAgICAgICAgICAgICAgICAgPyAoIHJkIHx8IHIgKSAmJiAoIHJtID09IDAgfHwgcm0gPT0gKCB4LnMgPCAwID8gMyA6IDIgKSApXHJcbiAgICAgICAgICAgICAgICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmICggcm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICggKCBpID4gMCA/IGogPiAwID8gbiAvIHBvd3MxMFsgZCAtIGogXSA6IDAgOiB4Y1tuaSAtIDFdICkgJSAxMCApICYgMSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJtID09ICggeC5zIDwgMCA/IDggOiA3ICkgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBzZCA8IDEgfHwgIXhjWzBdICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbIHNkICUgTE9HX0JBU0UgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4Y1swXSA9IHguZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4Y2VzcyBkaWdpdHMuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBpID09IDAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmktLTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBwb3dzMTBbIExPR19CQVNFIC0gaSBdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygbi5cclxuICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmldID0gaiA+IDAgPyBtYXRoZmxvb3IoIG4gLyBwb3dzMTBbIGQgLSBqIF0gJSBwb3dzMTBbal0gKSAqIGsgOiAwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUm91bmQgdXA/XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoIDsgOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBuaSA9PSAwICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpIHdpbGwgYmUgdGhlIGxlbmd0aCBvZiB4Y1swXSBiZWZvcmUgayBpcyBhZGRlZC5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gMSwgaiA9IHhjWzBdOyBqID49IDEwOyBqIC89IDEwLCBpKysgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKCBrID0gMTsgaiA+PSAxMDsgaiAvPSAxMCwgaysrICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCBpICE9IGsgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHhjWzBdID09IEJBU0UgKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGNbbmldICs9IGs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1tuaV0gIT0gQkFTRSApIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrID0gMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoIGkgPSB4Yy5sZW5ndGg7IHhjWy0taV0gPT09IDA7IHhjLnBvcCgpICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgaWYgKCB4LmUgPiBNQVhfRVhQICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICggeC5lIDwgTUlOX0VYUCApIHtcclxuICAgICAgICAgICAgICAgICAgICB4LmMgPSBbIHguZSA9IDAgXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgLy8gUFJPVE9UWVBFL0lOU1RBTkNFIE1FVEhPRFNcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgICAgICAgaWYgKCB4LnMgPCAwICkgeC5zID0gMTtcclxuICAgICAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBhIHdob2xlXHJcbiAgICAgICAgICogbnVtYmVyIGluIHRoZSBkaXJlY3Rpb24gb2YgSW5maW5pdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5jZWlsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm91bmQoIG5ldyBCaWdOdW1iZXIodGhpcyksIHRoaXMuZSArIDEsIDIgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm5cclxuICAgICAgICAgKiAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAgICAgKiAtMSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgICAgICogMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICAgICAgICogb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmNvbXBhcmVkVG8gPSBQLmNtcCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSAxO1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLCBvciBudWxsIGlmIHRoZSB2YWx1ZVxyXG4gICAgICAgICAqIG9mIHRoaXMgQmlnTnVtYmVyIGlzIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuLCB2LFxyXG4gICAgICAgICAgICAgICAgYyA9IHRoaXMuYztcclxuXHJcbiAgICAgICAgICAgIGlmICggIWMgKSByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgbiA9ICggKCB2ID0gYy5sZW5ndGggLSAxICkgLSBiaXRGbG9vciggdGhpcy5lIC8gTE9HX0JBU0UgKSApICogTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IG51bWJlci5cclxuICAgICAgICAgICAgaWYgKCB2ID0gY1t2XSApIGZvciAoIDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSApO1xyXG4gICAgICAgICAgICBpZiAoIG4gPCAwICkgbiA9IDA7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgbiAvIDAgPSBJXHJcbiAgICAgICAgICogIG4gLyBOID0gTlxyXG4gICAgICAgICAqICBuIC8gSSA9IDBcclxuICAgICAgICAgKiAgMCAvIG4gPSAwXHJcbiAgICAgICAgICogIDAgLyAwID0gTlxyXG4gICAgICAgICAqICAwIC8gTiA9IE5cclxuICAgICAgICAgKiAgMCAvIEkgPSAwXHJcbiAgICAgICAgICogIE4gLyBuID0gTlxyXG4gICAgICAgICAqICBOIC8gMCA9IE5cclxuICAgICAgICAgKiAgTiAvIE4gPSBOXHJcbiAgICAgICAgICogIE4gLyBJID0gTlxyXG4gICAgICAgICAqICBJIC8gbiA9IElcclxuICAgICAgICAgKiAgSSAvIDAgPSBJXHJcbiAgICAgICAgICogIEkgLyBOID0gTlxyXG4gICAgICAgICAqICBJIC8gSSA9IE5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLCByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDM7XHJcbiAgICAgICAgICAgIHJldHVybiBkaXYoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSwgREVDSU1BTF9QTEFDRVMsIFJPVU5ESU5HX01PREUgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXNcclxuICAgICAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuZGl2VG9JbnQgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gNDtcclxuICAgICAgICAgICAgcmV0dXJuIGRpdiggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApLCAwLCAxICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgICAgICogb3RoZXJ3aXNlIHJldHVybnMgZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5lcXVhbHMgPSBQLmVxID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDU7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA9PT0gMDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciByb3VuZGVkIHRvIGEgd2hvbGVcclxuICAgICAgICAgKiBudW1iZXIgaW4gdGhlIGRpcmVjdGlvbiBvZiAtSW5maW5pdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5mbG9vciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCBuZXcgQmlnTnVtYmVyKHRoaXMpLCB0aGlzLmUgKyAxLCAzICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICAgICAqIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZ3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICBpZCA9IDY7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJlKCB0aGlzLCBuZXcgQmlnTnVtYmVyKCB5LCBiICkgKSA+IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuZ3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA3O1xyXG4gICAgICAgICAgICByZXR1cm4gKCBiID0gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmM7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IoIHRoaXMuZSAvIExPR19CQVNFICkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXRoaXMucztcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm5zIGZhbHNlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnMgPCAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmlzWmVybyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAgICAgKiBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICggeSwgYiApIHtcclxuICAgICAgICAgICAgaWQgPSA4O1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyZSggdGhpcywgbmV3IEJpZ051bWJlciggeSwgYiApICkgPCAwO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBQLmxlc3NUaGFuT3JFcXVhbFRvID0gUC5sdGUgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIGlkID0gOTtcclxuICAgICAgICAgICAgcmV0dXJuICggYiA9IGNvbXBhcmUoIHRoaXMsIG5ldyBCaWdOdW1iZXIoIHksIGIgKSApICkgPT09IC0xIHx8IGIgPT09IDA7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIG4gLSAwID0gblxyXG4gICAgICAgICAqICBuIC0gTiA9IE5cclxuICAgICAgICAgKiAgbiAtIEkgPSAtSVxyXG4gICAgICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgICAgICogIDAgLSAwID0gMFxyXG4gICAgICAgICAqICAwIC0gTiA9IE5cclxuICAgICAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICAgICAqICBOIC0gbiA9IE5cclxuICAgICAgICAgKiAgTiAtIDAgPSBOXHJcbiAgICAgICAgICogIE4gLSBOID0gTlxyXG4gICAgICAgICAqICBOIC0gSSA9IE5cclxuICAgICAgICAgKiAgSSAtIG4gPSBJXHJcbiAgICAgICAgICogIEkgLSAwID0gSVxyXG4gICAgICAgICAqICBJIC0gTiA9IE5cclxuICAgICAgICAgKiAgSSAtIEkgPSBOXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtaW51cyB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5taW51cyA9IFAuc3ViID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgaSwgaiwgdCwgeExUeSxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgICAgICAgIGlkID0gMTA7XHJcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XHJcbiAgICAgICAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgICAgICBpZiAoICFhIHx8ICFiICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICAgICAgaWYgKCBhICE9IGIgKSB7XHJcbiAgICAgICAgICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciB4ZSA9IHguZSAvIExPR19CQVNFLFxyXG4gICAgICAgICAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgICAgICBpZiAoICF4ZSB8fCAheWUgKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljICkgcmV0dXJuIHhjID8gKCB5LnMgPSAtYiwgeSApIDogbmV3IEJpZ051bWJlciggeWMgPyB4IDogTmFOICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgICAgICAgICBpZiAoICF4Y1swXSB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5Y1swXSA/ICggeS5zID0gLWIsIHkgKSA6IG5ldyBCaWdOdW1iZXIoIHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgUk9VTkRJTkdfTU9ERSA9PSAzID8gLTAgOiAwICk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICAgICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGlzIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgICAgICAgICBpZiAoIGEgPSB4ZSAtIHllICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggeExUeSA9IGEgPCAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICAgICAgICAgICAgZm9yICggYiA9IGE7IGItLTsgdC5wdXNoKDApICk7XHJcbiAgICAgICAgICAgICAgICB0LnJldmVyc2UoKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgaiA9ICggeExUeSA9ICggYSA9IHhjLmxlbmd0aCApIDwgKCBiID0geWMubGVuZ3RoICkgKSA/IGEgOiBiO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoIGEgPSBiID0gMDsgYiA8IGo7IGIrKyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB4Y1tiXSAhPSB5Y1tiXSApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgICAgICAgYiA9ICggaiA9IHljLmxlbmd0aCApIC0gKCBpID0geGMubGVuZ3RoICk7XHJcblxyXG4gICAgICAgICAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBhZGQgemVyb3MgdG8geWMgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdCBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IHljLmxlbmd0aC5cclxuICAgICAgICAgICAgaWYgKCBiID4gMCApIGZvciAoIDsgYi0tOyB4Y1tpKytdID0gMCApO1xyXG4gICAgICAgICAgICBiID0gQkFTRSAtIDE7XHJcblxyXG4gICAgICAgICAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgICAgICAgICBmb3IgKCA7IGogPiBhOyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIHhjWy0tal0gPCB5Y1tqXSApIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCBpID0gajsgaSAmJiAheGNbLS1pXTsgeGNbaV0gPSBiICk7XHJcbiAgICAgICAgICAgICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgICAgICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHhjW2pdIC09IHljW2pdO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgICBmb3IgKCA7IHhjWzBdID09IDA7IHhjLnNoaWZ0KCksIC0teWUgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8/XHJcbiAgICAgICAgICAgIGlmICggIXhjWzBdICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgICAgICAgICAgLy8gbiAtIG4gPSArMCAgYnV0ICBuIC0gbiA9IC0wICB3aGVuIHJvdW5kaW5nIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgeS5zID0gUk9VTkRJTkdfTU9ERSA9PSAzID8gLTEgOiAxO1xyXG4gICAgICAgICAgICAgICAgeS5jID0gWyB5LmUgPSAwIF07XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgSW5maW5pdHkgYXMgK3ggLSAreSAhPSBJbmZpbml0eSAmJiAteCAtIC15ICE9IEluZmluaXR5XHJcbiAgICAgICAgICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGlzZSggeSwgeGMsIHllICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgICAgICogICBuICUgTiA9ICBOXHJcbiAgICAgICAgICogICBuICUgSSA9ICBuXHJcbiAgICAgICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgICAgICogIC0wICUgbiA9IC0wXHJcbiAgICAgICAgICogICAwICUgMCA9ICBOXHJcbiAgICAgICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgICAgICogICAwICUgSSA9ICAwXHJcbiAgICAgICAgICogICBOICUgbiA9ICBOXHJcbiAgICAgICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgICAgICogICBOICUgTiA9ICBOXHJcbiAgICAgICAgICogICBOICUgSSA9ICBOXHJcbiAgICAgICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgICAgICogICBJICUgMCA9ICBOXHJcbiAgICAgICAgICogICBJICUgTiA9ICBOXHJcbiAgICAgICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBtb2R1bG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAubW9kdWxvID0gUC5tb2QgPSBmdW5jdGlvbiAoIHksIGIgKSB7XHJcbiAgICAgICAgICAgIHZhciBxLCBzLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICBpZCA9IDExO1xyXG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlciggeSwgYiApO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgICAgICAgICAgaWYgKCAheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoICF5LmMgfHwgeC5jICYmICF4LmNbMF0gKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBNT0RVTE9fTU9ERSA9PSA5ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEV1Y2xpZGlhbiBkaXZpc2lvbjogcSA9IHNpZ24oeSkgKiBmbG9vcih4IC8gYWJzKHkpKVxyXG4gICAgICAgICAgICAgICAgLy8gciA9IHggLSBxeSAgICB3aGVyZSAgMCA8PSByIDwgYWJzKHkpXHJcbiAgICAgICAgICAgICAgICBzID0geS5zO1xyXG4gICAgICAgICAgICAgICAgeS5zID0gMTtcclxuICAgICAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIDMgKTtcclxuICAgICAgICAgICAgICAgIHkucyA9IHM7XHJcbiAgICAgICAgICAgICAgICBxLnMgKj0gcztcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHEgPSBkaXYoIHgsIHksIDAsIE1PRFVMT19NT0RFICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB4Lm1pbnVzKCBxLnRpbWVzKHkpICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAgICAgKiBpLmUuIG11bHRpcGxpZWQgYnkgLTEuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5uZWdhdGVkID0gUC5uZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgICAgICAgeC5zID0gLXgucyB8fCBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiAgbiArIDAgPSBuXHJcbiAgICAgICAgICogIG4gKyBOID0gTlxyXG4gICAgICAgICAqICBuICsgSSA9IElcclxuICAgICAgICAgKiAgMCArIG4gPSBuXHJcbiAgICAgICAgICogIDAgKyAwID0gMFxyXG4gICAgICAgICAqICAwICsgTiA9IE5cclxuICAgICAgICAgKiAgMCArIEkgPSBJXHJcbiAgICAgICAgICogIE4gKyBuID0gTlxyXG4gICAgICAgICAqICBOICsgMCA9IE5cclxuICAgICAgICAgKiAgTiArIE4gPSBOXHJcbiAgICAgICAgICogIE4gKyBJID0gTlxyXG4gICAgICAgICAqICBJICsgbiA9IElcclxuICAgICAgICAgKiAgSSArIDAgPSBJXHJcbiAgICAgICAgICogIEkgKyBOID0gTlxyXG4gICAgICAgICAqICBJICsgSSA9IElcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAucGx1cyA9IFAuYWRkID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgdCxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgICAgICAgIGlkID0gMTI7XHJcbiAgICAgICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKCB5LCBiICk7XHJcbiAgICAgICAgICAgIGIgPSB5LnM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgICAgICAgICBpZiAoICFhIHx8ICFiICkgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgICAgICAgIGlmICggYSAhPSBiICkge1xyXG4gICAgICAgICAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgICAgICAgICB5ZSA9IHkuZSAvIExPR19CQVNFLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgICAgICAgIGlmICggIXhlIHx8ICF5ZSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgwrFJbmZpbml0eS5cclxuICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHJldHVybiBuZXcgQmlnTnVtYmVyKCBhIC8gMCApO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgICAgICAgICAgICBpZiAoICF4Y1swXSB8fCAheWNbMF0gKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlciggeGNbMF0gPyB4IDogYSAqIDAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgICAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICAgICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICAgICAgICAgIGlmICggYSA9IHhlIC0geWUgKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIGEgPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHljO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHhjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICggOyBhLS07IHQucHVzaCgwKSApO1xyXG4gICAgICAgICAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgICAgICAgIGlmICggYSAtIGIgPCAwICkgdCA9IHljLCB5YyA9IHhjLCB4YyA9IHQsIGIgPSBhO1xyXG5cclxuICAgICAgICAgICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWMubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGMgY2FuIGJlIGlnbm9yZWQuXHJcbiAgICAgICAgICAgIGZvciAoIGEgPSAwOyBiOyApIHtcclxuICAgICAgICAgICAgICAgIGEgPSAoIHhjWy0tYl0gPSB4Y1tiXSArIHljW2JdICsgYSApIC8gQkFTRSB8IDA7XHJcbiAgICAgICAgICAgICAgICB4Y1tiXSAlPSBCQVNFO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICAgICAgeGMudW5zaGlmdChhKTtcclxuICAgICAgICAgICAgICAgICsreWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2hlY2sgZm9yIHplcm8sIGFzICt4ICsgK3kgIT0gMCAmJiAteCArIC15ICE9IDBcclxuICAgICAgICAgICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB4YywgeWUgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW3pdIHtib29sZWFufG51bWJlcn0gV2hldGhlciB0byBjb3VudCBpbnRlZ2VyLXBhcnQgdHJhaWxpbmcgemVyb3M6IHRydWUsIGZhbHNlLCAxIG9yIDAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHopIHtcclxuICAgICAgICAgICAgdmFyIG4sIHYsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIGMgPSB4LmM7XHJcblxyXG4gICAgICAgICAgICAvLyAncHJlY2lzaW9uKCkgYXJndW1lbnQgbm90IGEgYm9vbGVhbiBvciBiaW5hcnkgZGlnaXQ6IHt6fSdcclxuICAgICAgICAgICAgaWYgKCB6ICE9IG51bGwgJiYgeiAhPT0gISF6ICYmIHogIT09IDEgJiYgeiAhPT0gMCApIHtcclxuICAgICAgICAgICAgICAgIGlmIChFUlJPUlMpIHJhaXNlKCAxMywgJ2FyZ3VtZW50JyArIG5vdEJvb2wsIHogKTtcclxuICAgICAgICAgICAgICAgIGlmICggeiAhPSAhIXogKSB6ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAhYyApIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICBuID0gdiAqIExPR19CQVNFICsgMTtcclxuXHJcbiAgICAgICAgICAgIGlmICggdiA9IGNbdl0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tICk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgICAgICAgICAgZm9yICggdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoIHogJiYgeC5lICsgMSA+IG4gKSBuID0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mXHJcbiAgICAgICAgICogZHAgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgdG8gMCBhbmQgUk9VTkRJTkdfTU9ERSByZXNwZWN0aXZlbHkgaWZcclxuICAgICAgICAgKiBvbWl0dGVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICdyb3VuZCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAncm91bmQoKSBkZWNpbWFsIHBsYWNlcyBub3QgYW4gaW50ZWdlcjoge2RwfSdcclxuICAgICAgICAgKiAncm91bmQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICdyb3VuZCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAucm91bmQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcclxuICAgICAgICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBkcCA9PSBudWxsIHx8IGlzVmFsaWRJbnQoIGRwLCAwLCBNQVgsIDE1ICkgKSB7XHJcbiAgICAgICAgICAgICAgICByb3VuZCggbiwgfn5kcCArIHRoaXMuZSArIDEsIHJtID09IG51bGwgfHxcclxuICAgICAgICAgICAgICAgICAgIWlzVmFsaWRJbnQoIHJtLCAwLCA4LCAxNSwgcm91bmRpbmdNb2RlICkgPyBST1VORElOR19NT0RFIDogcm0gfCAwICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBuO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgICAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogSWYgayBpcyBvdXQgb2YgcmFuZ2UgYW5kIEVSUk9SUyBpcyBmYWxzZSwgdGhlIHJlc3VsdCB3aWxsIGJlIMKxMCBpZiBrIDwgMCwgb3IgwrFJbmZpbml0eVxyXG4gICAgICAgICAqIG90aGVyd2lzZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICdzaGlmdCgpIGFyZ3VtZW50IG5vdCBhbiBpbnRlZ2VyOiB7a30nXHJcbiAgICAgICAgICogJ3NoaWZ0KCkgYXJndW1lbnQgb3V0IG9mIHJhbmdlOiB7a30nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC5zaGlmdCA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRJbnQoIGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSLCAxNiwgJ2FyZ3VtZW50JyApXHJcblxyXG4gICAgICAgICAgICAgIC8vIGsgPCAxZSsyMSwgb3IgdHJ1bmNhdGUoaykgd2lsbCBwcm9kdWNlIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAgICAgID8gbi50aW1lcyggJzFlJyArIHRydW5jYXRlKGspIClcclxuICAgICAgICAgICAgICA6IG5ldyBCaWdOdW1iZXIoIG4uYyAmJiBuLmNbMF0gJiYgKCBrIDwgLU1BWF9TQUZFX0lOVEVHRVIgfHwgayA+IE1BWF9TQUZFX0lOVEVHRVIgKVxyXG4gICAgICAgICAgICAgICAgPyBuLnMgKiAoIGsgPCAwID8gMCA6IDEgLyAwIClcclxuICAgICAgICAgICAgICAgIDogbiApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgICAgICogIHNxcnQoIE4pID0gIE5cclxuICAgICAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICAgICAqICBzcXJ0KCBJKSA9ICBJXHJcbiAgICAgICAgICogIHNxcnQoIDApID0gIDBcclxuICAgICAgICAgKiAgc3FydCgtMCkgPSAtMFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLFxyXG4gICAgICAgICAqIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYyA9IHguYyxcclxuICAgICAgICAgICAgICAgIHMgPSB4LnMsXHJcbiAgICAgICAgICAgICAgICBlID0geC5lLFxyXG4gICAgICAgICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyArIDQsXHJcbiAgICAgICAgICAgICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICAgICAgICAgICAgaWYgKCBzICE9PSAxIHx8ICFjIHx8ICFjWzBdICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoICFzIHx8IHMgPCAwICYmICggIWMgfHwgY1swXSApID8gTmFOIDogYyA/IHggOiAxIC8gMCApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICAgICAgICBzID0gTWF0aC5zcXJ0KCAreCApO1xyXG5cclxuICAgICAgICAgICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAgICAgICAgLy8gUGFzcyB4IHRvIE1hdGguc3FydCBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICAgICAgICAgICAgaWYgKCBzID09IDAgfHwgcyA9PSAxIC8gMCApIHtcclxuICAgICAgICAgICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCAoIG4ubGVuZ3RoICsgZSApICUgMiA9PSAwICkgbiArPSAnMCc7XHJcbiAgICAgICAgICAgICAgICBzID0gTWF0aC5zcXJ0KG4pO1xyXG4gICAgICAgICAgICAgICAgZSA9IGJpdEZsb29yKCAoIGUgKyAxICkgLyAyICkgLSAoIGUgPCAwIHx8IGUgJSAyICk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKCBzID09IDEgLyAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSAnMWUnICsgZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLnNsaWNlKCAwLCBuLmluZGV4T2YoJ2UnKSArIDEgKSArIGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByID0gbmV3IEJpZ051bWJlciggcyArICcnICk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgICAgICAgICAvLyByIGNvdWxkIGJlIHplcm8gaWYgTUlOX0VYUCBpcyBjaGFuZ2VkIGFmdGVyIHRoZSB0aGlzIHZhbHVlIHdhcyBjcmVhdGVkLlxyXG4gICAgICAgICAgICAvLyBUaGlzIHdvdWxkIGNhdXNlIGEgZGl2aXNpb24gYnkgemVybyAoeC90KSBhbmQgaGVuY2UgSW5maW5pdHkgYmVsb3csIHdoaWNoIHdvdWxkIGNhdXNlXHJcbiAgICAgICAgICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICAgICAgICAgIGlmICggci5jWzBdICkge1xyXG4gICAgICAgICAgICAgICAgZSA9IHIuZTtcclxuICAgICAgICAgICAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgICAgICAgICAgICBpZiAoIHMgPCAzICkgcyA9IDA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gTmV3dG9uLVJhcGhzb24gaXRlcmF0aW9uLlxyXG4gICAgICAgICAgICAgICAgZm9yICggOyA7ICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgICAgICAgICAgIHIgPSBoYWxmLnRpbWVzKCB0LnBsdXMoIGRpdiggeCwgdCwgZHAsIDEgKSApICk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggY29lZmZUb1N0cmluZyggdC5jICAgKS5zbGljZSggMCwgcyApID09PSAoIG4gPVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29lZmZUb1N0cmluZyggci5jICkgKS5zbGljZSggMCwgcyApICkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlLmcgMC4wMDA5OTk5IChlLTQpIC0tID4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIHIuZSA8IGUgKSAtLXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG4gPSBuLnNsaWNlKCBzIC0gMywgcyArIDEgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhcmUgOTk5OSBvciA0OTk5IChpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnkpIGNvbnRpbnVlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRpb24uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggbiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4YWN0IHJlc3VsdCBhcyB0aGUgbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhcmVwICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCB0LCB0LmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCB0LnRpbWVzKHQpLmVxKHgpICkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRwICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBleGFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1JyApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJvdW5kKCByLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByb3VuZCggciwgci5lICsgREVDSU1BTF9QTEFDRVMgKyAxLCBST1VORElOR19NT0RFLCBtICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogIG4gKiAwID0gMFxyXG4gICAgICAgICAqICBuICogTiA9IE5cclxuICAgICAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgICAgICogIDAgKiBuID0gMFxyXG4gICAgICAgICAqICAwICogMCA9IDBcclxuICAgICAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgICAgICogIDAgKiBJID0gTlxyXG4gICAgICAgICAqICBOICogbiA9IE5cclxuICAgICAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgICAgICogIE4gKiBOID0gTlxyXG4gICAgICAgICAqICBOICogSSA9IE5cclxuICAgICAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgICAgICogIEkgKiAwID0gTlxyXG4gICAgICAgICAqICBJICogTiA9IE5cclxuICAgICAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciB0aW1lcyB0aGUgdmFsdWUgb2ZcclxuICAgICAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50aW1lcyA9IFAubXVsID0gZnVuY3Rpb24gKCB5LCBiICkge1xyXG4gICAgICAgICAgICB2YXIgYywgZSwgaSwgaiwgaywgbSwgeGNMLCB4bG8sIHhoaSwgeWNMLCB5bG8sIHloaSwgemMsXHJcbiAgICAgICAgICAgICAgICBiYXNlLCBzcXJ0QmFzZSxcclxuICAgICAgICAgICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgICAgICAgICAgeGMgPSB4LmMsXHJcbiAgICAgICAgICAgICAgICB5YyA9ICggaWQgPSAxNywgeSA9IG5ldyBCaWdOdW1iZXIoIHksIGIgKSApLmM7XHJcblxyXG4gICAgICAgICAgICAvLyBFaXRoZXIgTmFOLCDCsUluZmluaXR5IG9yIMKxMD9cclxuICAgICAgICAgICAgaWYgKCAheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0gKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgaWYgKCAheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkuYyA9IHkuZSA9IHkucyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICggIXhjIHx8ICF5YyApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHkuYyA9IFswXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgeS5lID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGUgPSBiaXRGbG9vciggeC5lIC8gTE9HX0JBU0UgKSArIGJpdEZsb29yKCB5LmUgLyBMT0dfQkFTRSApO1xyXG4gICAgICAgICAgICB5LnMgKj0geC5zO1xyXG4gICAgICAgICAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHljTCA9IHljLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB4YyBwb2ludHMgdG8gbG9uZ2VyIGFycmF5IGFuZCB4Y0wgdG8gaXRzIGxlbmd0aC5cclxuICAgICAgICAgICAgaWYgKCB4Y0wgPCB5Y0wgKSB6YyA9IHhjLCB4YyA9IHljLCB5YyA9IHpjLCBpID0geGNMLCB4Y0wgPSB5Y0wsIHljTCA9IGk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggaSA9IHhjTCArIHljTCwgemMgPSBbXTsgaS0tOyB6Yy5wdXNoKDApICk7XHJcblxyXG4gICAgICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCBpID0geWNMOyAtLWkgPj0gMDsgKSB7XHJcbiAgICAgICAgICAgICAgICBjID0gMDtcclxuICAgICAgICAgICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgICAgICAgICB5aGkgPSB5Y1tpXSAvIHNxcnRCYXNlIHwgMDtcclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKCBrID0geGNMLCBqID0gaSArIGs7IGogPiBpOyApIHtcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB4Y1stLWtdICUgc3FydEJhc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhpID0geGNba10gLyBzcXJ0QmFzZSB8IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgICAgICAgICAgICB4bG8gPSB5bG8gKiB4bG8gKyAoICggbSAlIHNxcnRCYXNlICkgKiBzcXJ0QmFzZSApICsgemNbal0gKyBjO1xyXG4gICAgICAgICAgICAgICAgICAgIGMgPSAoIHhsbyAvIGJhc2UgfCAwICkgKyAoIG0gLyBzcXJ0QmFzZSB8IDAgKSArIHloaSAqIHhoaTtcclxuICAgICAgICAgICAgICAgICAgICB6Y1tqLS1dID0geGxvICUgYmFzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB6Yy5zaGlmdCgpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXNlKCB5LCB6YywgZSApO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mXHJcbiAgICAgICAgICogc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcHJlY2lzaW9uIG91dCBvZiByYW5nZToge3NkfSdcclxuICAgICAgICAgKiAndG9EaWdpdHMoKSBwcmVjaXNpb24gbm90IGFuIGludGVnZXI6IHtzZH0nXHJcbiAgICAgICAgICogJ3RvRGlnaXRzKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgICAgICAgKiAndG9EaWdpdHMoKSByb3VuZGluZyBtb2RlIG91dCBvZiByYW5nZToge3JtfSdcclxuICAgICAgICAgKi9cclxuICAgICAgICBQLnRvRGlnaXRzID0gZnVuY3Rpb24gKCBzZCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHZhciBuID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgICAgICAgc2QgPSBzZCA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBzZCwgMSwgTUFYLCAxOCwgJ3ByZWNpc2lvbicgKSA/IG51bGwgOiBzZCB8IDA7XHJcbiAgICAgICAgICAgIHJtID0gcm0gPT0gbnVsbCB8fCAhaXNWYWxpZEludCggcm0sIDAsIDgsIDE4LCByb3VuZGluZ01vZGUgKSA/IFJPVU5ESU5HX01PREUgOiBybSB8IDA7XHJcbiAgICAgICAgICAgIHJldHVybiBzZCA/IHJvdW5kKCBuLCBzZCwgcm0gKSA6IG47XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgICAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRXhwb25lbnRpYWwoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRXhwb25lbnRpYWwoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b0V4cG9uZW50aWFsKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsXHJcbiAgICAgICAgICAgICAgZHAgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAxOSApID8gfn5kcCArIDEgOiBudWxsLCBybSwgMTkgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGluZ1xyXG4gICAgICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGU6IGFzIHdpdGggSmF2YVNjcmlwdCdzIG51bWJlciB0eXBlLCAoLTApLnRvRml4ZWQoMCkgaXMgJzAnLFxyXG4gICAgICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0ZpeGVkKCkgZGVjaW1hbCBwbGFjZXMgbm90IGFuIGludGVnZXI6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRml4ZWQoKSBkZWNpbWFsIHBsYWNlcyBvdXQgb2YgcmFuZ2U6IHtkcH0nXHJcbiAgICAgICAgICogJ3RvRml4ZWQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b0ZpeGVkKCkgcm91bmRpbmcgbW9kZSBvdXQgb2YgcmFuZ2U6IHtybX0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKCBkcCwgcm0gKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXQoIHRoaXMsIGRwICE9IG51bGwgJiYgaXNWYWxpZEludCggZHAsIDAsIE1BWCwgMjAgKVxyXG4gICAgICAgICAgICAgID8gfn5kcCArIHRoaXMuZSArIDEgOiBudWxsLCBybSwgMjAgKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgICAgICogdXNpbmcgcm0gb3IgUk9VTkRJTkdfTU9ERSB0byBkcCBkZWNpbWFsIHBsYWNlcywgYW5kIGZvcm1hdHRlZCBhY2NvcmRpbmcgdG8gdGhlIHByb3BlcnRpZXNcclxuICAgICAgICAgKiBvZiB0aGUgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5jb25maWcpLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogRk9STUFUID0ge1xyXG4gICAgICAgICAqICAgICAgZGVjaW1hbFNlcGFyYXRvciA6ICcuJyxcclxuICAgICAgICAgKiAgICAgIGdyb3VwU2VwYXJhdG9yIDogJywnLFxyXG4gICAgICAgICAqICAgICAgZ3JvdXBTaXplIDogMyxcclxuICAgICAgICAgKiAgICAgIHNlY29uZGFyeUdyb3VwU2l6ZSA6IDAsXHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIDogJ1xceEEwJywgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgICAgICogICAgICBmcmFjdGlvbkdyb3VwU2l6ZSA6IDBcclxuICAgICAgICAgKiB9O1xyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIGRlY2ltYWwgcGxhY2VzIG5vdCBhbiBpbnRlZ2VyOiB7ZHB9J1xyXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIGRlY2ltYWwgcGxhY2VzIG91dCBvZiByYW5nZToge2RwfSdcclxuICAgICAgICAgKiAndG9Gb3JtYXQoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b0Zvcm1hdCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9Gb3JtYXQgPSBmdW5jdGlvbiAoIGRwLCBybSApIHtcclxuICAgICAgICAgICAgdmFyIHN0ciA9IGZvcm1hdCggdGhpcywgZHAgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBkcCwgMCwgTUFYLCAyMSApXHJcbiAgICAgICAgICAgICAgPyB+fmRwICsgdGhpcy5lICsgMSA6IG51bGwsIHJtLCAyMSApO1xyXG5cclxuICAgICAgICAgICAgaWYgKCB0aGlzLmMgKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaSxcclxuICAgICAgICAgICAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgICAgICAgICAgICBnMSA9ICtGT1JNQVQuZ3JvdXBTaXplLFxyXG4gICAgICAgICAgICAgICAgICAgIGcyID0gK0ZPUk1BVC5zZWNvbmRhcnlHcm91cFNpemUsXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBGT1JNQVQuZ3JvdXBTZXBhcmF0b3IsXHJcbiAgICAgICAgICAgICAgICAgICAgaW50UGFydCA9IGFyclswXSxcclxuICAgICAgICAgICAgICAgICAgICBmcmFjdGlvblBhcnQgPSBhcnJbMV0sXHJcbiAgICAgICAgICAgICAgICAgICAgaXNOZWcgPSB0aGlzLnMgPCAwLFxyXG4gICAgICAgICAgICAgICAgICAgIGludERpZ2l0cyA9IGlzTmVnID8gaW50UGFydC5zbGljZSgxKSA6IGludFBhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgbGVuID0gaW50RGlnaXRzLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZzIpIGkgPSBnMSwgZzEgPSBnMiwgZzIgPSBpLCBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIGcxID4gMCAmJiBsZW4gPiAwICkge1xyXG4gICAgICAgICAgICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgICAgICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0ciggMCwgaSApO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKCA7IGkgPCBsZW47IGkgKz0gZzEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKCBpLCBnMSApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBnMiA+IDAgKSBpbnRQYXJ0ICs9IGdyb3VwU2VwYXJhdG9yICsgaW50RGlnaXRzLnNsaWNlKGkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05lZykgaW50UGFydCA9ICctJyArIGludFBhcnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgICAgICAgICAgID8gaW50UGFydCArIEZPUk1BVC5kZWNpbWFsU2VwYXJhdG9yICsgKCAoIGcyID0gK0ZPUk1BVC5mcmFjdGlvbkdyb3VwU2l6ZSApXHJcbiAgICAgICAgICAgICAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZSggbmV3IFJlZ0V4cCggJ1xcXFxkeycgKyBnMiArICd9XFxcXEInLCAnZycgKSxcclxuICAgICAgICAgICAgICAgICAgICAgICckJicgKyBGT1JNQVQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciApXHJcbiAgICAgICAgICAgICAgICAgICAgOiBmcmFjdGlvblBhcnQgKVxyXG4gICAgICAgICAgICAgICAgICA6IGludFBhcnQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIGFycmF5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgYXMgYSBzaW1wbGUgZnJhY3Rpb24gd2l0aFxyXG4gICAgICAgICAqIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLiBUaGUgZGVub21pbmF0b3Igd2lsbCBiZSBhIHBvc2l0aXZlXHJcbiAgICAgICAgICogbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtXHJcbiAgICAgICAgICogZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgdGhlIGxvd2VzdCB2YWx1ZSBuZWNlc3NhcnkgdG9cclxuICAgICAgICAgKiByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW21kXSB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IEludGVnZXIgPj0gMSBhbmQgPCBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9GcmFjdGlvbigpIG1heCBkZW5vbWluYXRvciBub3QgYW4gaW50ZWdlcjoge21kfSdcclxuICAgICAgICAgKiAndG9GcmFjdGlvbigpIG1heCBkZW5vbWluYXRvciBvdXQgb2YgcmFuZ2U6IHttZH0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1kKSB7XHJcbiAgICAgICAgICAgIHZhciBhcnIsIGQwLCBkMiwgZSwgZXhwLCBuLCBuMCwgcSwgcyxcclxuICAgICAgICAgICAgICAgIGsgPSBFUlJPUlMsXHJcbiAgICAgICAgICAgICAgICB4ID0gdGhpcyxcclxuICAgICAgICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKSxcclxuICAgICAgICAgICAgICAgIG4xID0gZDAgPSBuZXcgQmlnTnVtYmVyKE9ORSksXHJcbiAgICAgICAgICAgICAgICBkMSA9IG4wID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKCBtZCAhPSBudWxsICkge1xyXG4gICAgICAgICAgICAgICAgRVJST1JTID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcbiAgICAgICAgICAgICAgICBFUlJPUlMgPSBrO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggISggayA9IG4uaXNJbnQoKSApIHx8IG4ubHQoT05FKSApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKEVSUk9SUykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByYWlzZSggMjIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ21heCBkZW5vbWluYXRvciAnICsgKCBrID8gJ291dCBvZiByYW5nZScgOiAnbm90IGFuIGludGVnZXInICksIG1kICk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBFUlJPUlMgaXMgZmFsc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgbWQgaXMgYSBmaW5pdGUgbm9uLWludGVnZXIgPj0gMSwgcm91bmQgaXQgdG8gYW4gaW50ZWdlciBhbmQgdXNlIGl0LlxyXG4gICAgICAgICAgICAgICAgICAgIG1kID0gIWsgJiYgbi5jICYmIHJvdW5kKCBuLCBuLmUgKyAxLCAxICkuZ3RlKE9ORSkgPyBuIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCAheGMgKSByZXR1cm4geC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBzID0gY29lZmZUb1N0cmluZyh4Yyk7XHJcblxyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgICAgICAgICAgLy8gZCBpcyBhIHBvd2VyIG9mIDEwIGFuZCB0aGUgbWluaW11bSBtYXggZGVub21pbmF0b3IgdGhhdCBzcGVjaWZpZXMgdGhlIHZhbHVlIGV4YWN0bHkuXHJcbiAgICAgICAgICAgIGUgPSBkLmUgPSBzLmxlbmd0aCAtIHguZSAtIDE7XHJcbiAgICAgICAgICAgIGQuY1swXSA9IFBPV1NfVEVOWyAoIGV4cCA9IGUgJSBMT0dfQkFTRSApIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwIF07XHJcbiAgICAgICAgICAgIG1kID0gIW1kIHx8IG4uY21wKGQpID4gMCA/ICggZSA+IDAgPyBkIDogbjEgKSA6IG47XHJcblxyXG4gICAgICAgICAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgICAgICAgICBNQVhfRVhQID0gMSAvIDA7XHJcbiAgICAgICAgICAgIG4gPSBuZXcgQmlnTnVtYmVyKHMpO1xyXG5cclxuICAgICAgICAgICAgLy8gbjAgPSBkMSA9IDBcclxuICAgICAgICAgICAgbjAuY1swXSA9IDA7XHJcblxyXG4gICAgICAgICAgICBmb3IgKCA7IDsgKSAge1xyXG4gICAgICAgICAgICAgICAgcSA9IGRpdiggbiwgZCwgMCwgMSApO1xyXG4gICAgICAgICAgICAgICAgZDIgPSBkMC5wbHVzKCBxLnRpbWVzKGQxKSApO1xyXG4gICAgICAgICAgICAgICAgaWYgKCBkMi5jbXAobWQpID09IDEgKSBicmVhaztcclxuICAgICAgICAgICAgICAgIGQwID0gZDE7XHJcbiAgICAgICAgICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgICAgICAgICAgbjEgPSBuMC5wbHVzKCBxLnRpbWVzKCBkMiA9IG4xICkgKTtcclxuICAgICAgICAgICAgICAgIG4wID0gZDI7XHJcbiAgICAgICAgICAgICAgICBkID0gbi5taW51cyggcS50aW1lcyggZDIgPSBkICkgKTtcclxuICAgICAgICAgICAgICAgIG4gPSBkMjtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgZDIgPSBkaXYoIG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEgKTtcclxuICAgICAgICAgICAgbjAgPSBuMC5wbHVzKCBkMi50aW1lcyhuMSkgKTtcclxuICAgICAgICAgICAgZDAgPSBkMC5wbHVzKCBkMi50aW1lcyhkMSkgKTtcclxuICAgICAgICAgICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcbiAgICAgICAgICAgIGUgKj0gMjtcclxuXHJcbiAgICAgICAgICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgICAgICAgICAgYXJyID0gZGl2KCBuMSwgZDEsIGUsIFJPVU5ESU5HX01PREUgKS5taW51cyh4KS5hYnMoKS5jbXAoXHJcbiAgICAgICAgICAgICAgICAgIGRpdiggbjAsIGQwLCBlLCBST1VORElOR19NT0RFICkubWludXMoeCkuYWJzKCkgKSA8IDFcclxuICAgICAgICAgICAgICAgICAgICA/IFsgbjEudG9TdHJpbmcoKSwgZDEudG9TdHJpbmcoKSBdXHJcbiAgICAgICAgICAgICAgICAgICAgOiBbIG4wLnRvU3RyaW5nKCksIGQwLnRvU3RyaW5nKCkgXTtcclxuXHJcbiAgICAgICAgICAgIE1BWF9FWFAgPSBleHA7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnI7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB4ID0gdGhpcztcclxuXHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB6ZXJvIGhhcyBjb3JyZWN0IHNpZ24uXHJcbiAgICAgICAgICAgIHJldHVybiAreCB8fCAoIHgucyA/IHgucyAqIDAgOiBOYU4gKTtcclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgLypcclxuICAgICAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJhaXNlZCB0byB0aGUgcG93ZXIgbi5cclxuICAgICAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAgICAgKiBJZiBQT1dfUFJFQ0lTSU9OIGlzIG5vdCAwLCByb3VuZCB0byBQT1dfUFJFQ0lTSU9OIHVzaW5nIFJPVU5ESU5HX01PREUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBuIHtudW1iZXJ9IEludGVnZXIsIC05MDA3MTk5MjU0NzQwOTkyIHRvIDkwMDcxOTkyNTQ3NDA5OTIgaW5jbHVzaXZlLlxyXG4gICAgICAgICAqIChQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5Mi4pXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAncG93KCkgZXhwb25lbnQgbm90IGFuIGludGVnZXI6IHtufSdcclxuICAgICAgICAgKiAncG93KCkgZXhwb25lbnQgb3V0IG9mIHJhbmdlOiB7bn0nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgUC50b1Bvd2VyID0gUC5wb3cgPSBmdW5jdGlvbiAobikge1xyXG4gICAgICAgICAgICB2YXIgaywgeSxcclxuICAgICAgICAgICAgICAgIGkgPSBtYXRoZmxvb3IoIG4gPCAwID8gLW4gOiArbiApLFxyXG4gICAgICAgICAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICAgICAgICAvLyBQYXNzIMKxSW5maW5pdHkgdG8gTWF0aC5wb3cgaWYgZXhwb25lbnQgaXMgb3V0IG9mIHJhbmdlLlxyXG4gICAgICAgICAgICBpZiAoICFpc1ZhbGlkSW50KCBuLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUiwgMjMsICdleHBvbmVudCcgKSAmJlxyXG4gICAgICAgICAgICAgICggIWlzRmluaXRlKG4pIHx8IGkgPiBNQVhfU0FGRV9JTlRFR0VSICYmICggbiAvPSAwICkgfHxcclxuICAgICAgICAgICAgICAgIHBhcnNlRmxvYXQobikgIT0gbiAmJiAhKCBuID0gTmFOICkgKSApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCBNYXRoLnBvdyggK3gsIG4gKSApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uIGVxdWF0ZXNcclxuICAgICAgICAgICAgLy8gdG8gdHJ1bmNhdGluZyBzaWduaWZpY2FudCBkaWdpdHMgdG8gUE9XX1BSRUNJU0lPTiArIFsyOCwgNDFdLCBpLmUuIHRoZXJlIHdpbGwgYmUgYVxyXG4gICAgICAgICAgICAvLyBtaW5pbXVtIG9mIDI4IGd1YXJkIGRpZ2l0cyByZXRhaW5lZC4gKFVzaW5nICsgMS41IHdvdWxkIGdpdmUgWzksIDIxXSBndWFyZCBkaWdpdHMuKVxyXG4gICAgICAgICAgICBrID0gUE9XX1BSRUNJU0lPTiA/IG1hdGhjZWlsKCBQT1dfUFJFQ0lTSU9OIC8gTE9HX0JBU0UgKyAyICkgOiAwO1xyXG4gICAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyA7ICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggaSAlIDIgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAheS5jICkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBrICYmIHkuYy5sZW5ndGggPiBrICkgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaSA9IG1hdGhmbG9vciggaSAvIDIgKTtcclxuICAgICAgICAgICAgICAgIGlmICggIWkgKSBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICB4ID0geC50aW1lcyh4KTtcclxuICAgICAgICAgICAgICAgIGlmICggayAmJiB4LmMgJiYgeC5jLmxlbmd0aCA+IGsgKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaWYgKCBuIDwgMCApIHkgPSBPTkUuZGl2KHkpO1xyXG4gICAgICAgICAgICByZXR1cm4gayA/IHJvdW5kKCB5LCBQT1dfUFJFQ0lTSU9OLCBST1VORElOR19NT0RFICkgOiB5O1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSBvciBST1VORElOR19NT0RFLiBJZiBzZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHNcclxuICAgICAgICAgKiBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyIHBhcnQgb2YgdGhlIHZhbHVlIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uLCB0aGVuIHVzZVxyXG4gICAgICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSBwcmVjaXNpb24gbm90IGFuIGludGVnZXI6IHtzZH0nXHJcbiAgICAgICAgICogJ3RvUHJlY2lzaW9uKCkgcHJlY2lzaW9uIG91dCBvZiByYW5nZToge3NkfSdcclxuICAgICAgICAgKiAndG9QcmVjaXNpb24oKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gICAgICAgICAqICd0b1ByZWNpc2lvbigpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoIHNkLCBybSApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdCggdGhpcywgc2QgIT0gbnVsbCAmJiBpc1ZhbGlkSW50KCBzZCwgMSwgTUFYLCAyNCwgJ3ByZWNpc2lvbicgKVxyXG4gICAgICAgICAgICAgID8gc2QgfCAwIDogbnVsbCwgcm0sIDI0ICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG4gICAgICAgIC8qXHJcbiAgICAgICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgICAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICAgICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAgICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAgICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIDY0IGluY2x1c2l2ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqICd0b1N0cmluZygpIGJhc2Ugbm90IGFuIGludGVnZXI6IHtifSdcclxuICAgICAgICAgKiAndG9TdHJpbmcoKSBiYXNlIG91dCBvZiByYW5nZToge2J9J1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgICAgICB2YXIgc3RyLFxyXG4gICAgICAgICAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBzID0gbi5zLFxyXG4gICAgICAgICAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgICAgICAgIC8vIEluZmluaXR5IG9yIE5hTj9cclxuICAgICAgICAgICAgaWYgKCBlID09PSBudWxsICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gJ0luZmluaXR5JztcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIHMgPCAwICkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzdHIgPSAnTmFOJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcoIG4uYyApO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYiA9PSBudWxsIHx8ICFpc1ZhbGlkSW50KCBiLCAyLCA2NCwgMjUsICdiYXNlJyApICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgICAgICAgICAgICAgICAgID8gdG9FeHBvbmVudGlhbCggc3RyLCBlIClcclxuICAgICAgICAgICAgICAgICAgICAgIDogdG9GaXhlZFBvaW50KCBzdHIsIGUgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyID0gY29udmVydEJhc2UoIHRvRml4ZWRQb2ludCggc3RyLCBlICksIGIgfCAwLCAxMCwgcyApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmICggcyA8IDAgJiYgbi5jWzBdICkgc3RyID0gJy0nICsgc3RyO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHRydW5jYXRlZCB0byBhIHdob2xlXHJcbiAgICAgICAgICogbnVtYmVyLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvdW5kKCBuZXcgQmlnTnVtYmVyKHRoaXMpLCB0aGlzLmUgKyAxLCAxICk7XHJcbiAgICAgICAgfTtcclxuXHJcblxyXG5cclxuICAgICAgICAvKlxyXG4gICAgICAgICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICAvLyBBbGlhc2VzIGZvciBCaWdEZWNpbWFsIG1ldGhvZHMuXHJcbiAgICAgICAgLy9QLmFkZCA9IFAucGx1czsgICAgICAgICAvLyBQLmFkZCBpbmNsdWRlZCBhYm92ZVxyXG4gICAgICAgIC8vUC5zdWJ0cmFjdCA9IFAubWludXM7ICAgLy8gUC5zdWIgaW5jbHVkZWQgYWJvdmVcclxuICAgICAgICAvL1AubXVsdGlwbHkgPSBQLnRpbWVzOyAgIC8vIFAubXVsIGluY2x1ZGVkIGFib3ZlXHJcbiAgICAgICAgLy9QLmRpdmlkZSA9IFAuZGl2O1xyXG4gICAgICAgIC8vUC5yZW1haW5kZXIgPSBQLm1vZDtcclxuICAgICAgICAvL1AuY29tcGFyZVRvID0gUC5jbXA7XHJcbiAgICAgICAgLy9QLm5lZ2F0ZSA9IFAubmVnO1xyXG5cclxuXHJcbiAgICAgICAgaWYgKCBjb25maWdPYmogIT0gbnVsbCApIEJpZ051bWJlci5jb25maWcoY29uZmlnT2JqKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlcjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG5cclxuICAgIGZ1bmN0aW9uIGJpdEZsb29yKG4pIHtcclxuICAgICAgICB2YXIgaSA9IG4gfCAwO1xyXG4gICAgICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBSZXR1cm4gYSBjb2VmZmljaWVudCBhcnJheSBhcyBhIHN0cmluZyBvZiBiYXNlIDEwIGRpZ2l0cy5cclxuICAgIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgICAgIHZhciBzLCB6LFxyXG4gICAgICAgICAgICBpID0gMSxcclxuICAgICAgICAgICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgICAgICAgICByID0gYVswXSArICcnO1xyXG5cclxuICAgICAgICBmb3IgKCA7IGkgPCBqOyApIHtcclxuICAgICAgICAgICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgICAgICAgICB6ID0gTE9HX0JBU0UgLSBzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yICggOyB6LS07IHMgPSAnMCcgKyBzICk7XHJcbiAgICAgICAgICAgIHIgKz0gcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKCBqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODsgKTtcclxuICAgICAgICByZXR1cm4gci5zbGljZSggMCwgaiArIDEgfHwgMSApO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDb21wYXJlIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXJzIHggYW5kIHkuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlKCB4LCB5ICkge1xyXG4gICAgICAgIHZhciBhLCBiLFxyXG4gICAgICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICAgICAgeWMgPSB5LmMsXHJcbiAgICAgICAgICAgIGkgPSB4LnMsXHJcbiAgICAgICAgICAgIGogPSB5LnMsXHJcbiAgICAgICAgICAgIGsgPSB4LmUsXHJcbiAgICAgICAgICAgIGwgPSB5LmU7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgICAgaWYgKCAhaSB8fCAhaiApIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgICAgIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIGlmICggYSB8fCBiICkgcmV0dXJuIGEgPyBiID8gMCA6IC1qIDogaTtcclxuXHJcbiAgICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICAgIGlmICggaSAhPSBqICkgcmV0dXJuIGk7XHJcblxyXG4gICAgICAgIGEgPSBpIDwgMDtcclxuICAgICAgICBiID0gayA9PSBsO1xyXG5cclxuICAgICAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICAgICAgaWYgKCAheGMgfHwgIXljICkgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAgICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICAgICAgaWYgKCAhYiApIHJldHVybiBrID4gbCBeIGEgPyAxIDogLTE7XHJcblxyXG4gICAgICAgIGogPSAoIGsgPSB4Yy5sZW5ndGggKSA8ICggbCA9IHljLmxlbmd0aCApID8gayA6IGw7XHJcblxyXG4gICAgICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCBqOyBpKysgKSBpZiAoIHhjW2ldICE9IHljW2ldICkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgICAgICAvLyBDb21wYXJlIGxlbmd0aHMuXHJcbiAgICAgICAgcmV0dXJuIGsgPT0gbCA/IDAgOiBrID4gbCBeIGEgPyAxIDogLTE7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiBuIGlzIGEgdmFsaWQgbnVtYmVyIGluIHJhbmdlLCBvdGhlcndpc2UgZmFsc2UuXHJcbiAgICAgKiBVc2UgZm9yIGFyZ3VtZW50IHZhbGlkYXRpb24gd2hlbiBFUlJPUlMgaXMgZmFsc2UuXHJcbiAgICAgKiBOb3RlOiBwYXJzZUludCgnMWUrMScpID09IDEgYnV0IHBhcnNlRmxvYXQoJzFlKzEnKSA9PSAxMC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gaW50VmFsaWRhdG9yTm9FcnJvcnMoIG4sIG1pbiwgbWF4ICkge1xyXG4gICAgICAgIHJldHVybiAoIG4gPSB0cnVuY2F0ZShuKSApID49IG1pbiAmJiBuIDw9IG1heDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gaXNBcnJheShvYmopIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQXJyYXldJztcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgKiBFZy4gY29udmVydEJhc2UoJzI1NScsIDEwLCAxNikgcmV0dXJucyBbMTUsIDE1XS5cclxuICAgICAqIEVnLiBjb252ZXJ0QmFzZSgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0b0Jhc2VPdXQoIHN0ciwgYmFzZUluLCBiYXNlT3V0ICkge1xyXG4gICAgICAgIHZhciBqLFxyXG4gICAgICAgICAgICBhcnIgPSBbMF0sXHJcbiAgICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICBmb3IgKCA7IGkgPCBsZW47ICkge1xyXG4gICAgICAgICAgICBmb3IgKCBhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluICk7XHJcbiAgICAgICAgICAgIGFyclsgaiA9IDAgXSArPSBBTFBIQUJFVC5pbmRleE9mKCBzdHIuY2hhckF0KCBpKysgKSApO1xyXG5cclxuICAgICAgICAgICAgZm9yICggOyBqIDwgYXJyLmxlbmd0aDsgaisrICkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICggYXJyW2pdID4gYmFzZU91dCAtIDEgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCBhcnJbaiArIDFdID09IG51bGwgKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbCggc3RyLCBlICkge1xyXG4gICAgICAgIHJldHVybiAoIHN0ci5sZW5ndGggPiAxID8gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKSA6IHN0ciApICtcclxuICAgICAgICAgICggZSA8IDAgPyAnZScgOiAnZSsnICkgKyBlO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB0b0ZpeGVkUG9pbnQoIHN0ciwgZSApIHtcclxuICAgICAgICB2YXIgbGVuLCB6O1xyXG5cclxuICAgICAgICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICAgICAgICBpZiAoIGUgPCAwICkge1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcy5cclxuICAgICAgICAgICAgZm9yICggeiA9ICcwLic7ICsrZTsgeiArPSAnMCcgKTtcclxuICAgICAgICAgICAgc3RyID0geiArIHN0cjtcclxuXHJcbiAgICAgICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgLy8gQXBwZW5kIHplcm9zLlxyXG4gICAgICAgICAgICBpZiAoICsrZSA+IGxlbiApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoIHogPSAnMCcsIGUgLT0gbGVuOyAtLWU7IHogKz0gJzAnICk7XHJcbiAgICAgICAgICAgICAgICBzdHIgKz0gejtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICggZSA8IGxlbiApIHtcclxuICAgICAgICAgICAgICAgIHN0ciA9IHN0ci5zbGljZSggMCwgZSApICsgJy4nICsgc3RyLnNsaWNlKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gc3RyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiB0cnVuY2F0ZShuKSB7XHJcbiAgICAgICAgbiA9IHBhcnNlRmxvYXQobik7XHJcbiAgICAgICAgcmV0dXJuIG4gPCAwID8gbWF0aGNlaWwobikgOiBtYXRoZmxvb3Iobik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgICBCaWdOdW1iZXIgPSBhbm90aGVyKCk7XHJcblxyXG4gICAgLy8gQU1ELlxyXG4gICAgaWYgKCB0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCApIHtcclxuICAgICAgICBkZWZpbmUoIGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJpZ051bWJlcjsgfSApO1xyXG5cclxuICAgIC8vIE5vZGUgYW5kIG90aGVyIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMuXHJcbiAgICB9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzICkge1xyXG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gQmlnTnVtYmVyO1xyXG4gICAgICAgIGlmICggIWNyeXB0byApIHRyeSB7IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpOyB9IGNhdGNoIChlKSB7fVxyXG5cclxuICAgIC8vIEJyb3dzZXIuXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGdsb2JhbC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgICB9XHJcbn0pKHRoaXMpO1xyXG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3V0ZjhqcyB2Mi4xLjIgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlcyBgZXhwb3J0c2Bcblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYFxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgXG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0ZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB7XG5cdFx0XHR0aHJvdyBFcnJvcihcblx0XHRcdFx0J0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG5cdFx0XHRcdCcgaXMgbm90IGEgc2NhbGFyIHZhbHVlJ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0Y2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQpO1xuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHg4MCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwODAwKSB7XG5cdFx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDA3KSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4xLjInLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShcIndlYmV4dGVuc2lvbi1wb2x5ZmlsbFwiLCBbXCJtb2R1bGVcIl0sIGZhY3RvcnkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZmFjdG9yeShtb2R1bGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBtb2QgPSB7XG4gICAgICBleHBvcnRzOiB7fVxuICAgIH07XG4gICAgZmFjdG9yeShtb2QpO1xuICAgIGdsb2JhbC5icm93c2VyID0gbW9kLmV4cG9ydHM7XG4gIH1cbn0pKHR5cGVvZiBnbG9iYWxUaGlzICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHRoaXMsIGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgLyogd2ViZXh0ZW5zaW9uLXBvbHlmaWxsIC0gdjAuOC4wIC0gVHVlIEFwciAyMCAyMDIxIDExOjI3OjM4ICovXG5cbiAgLyogLSotIE1vZGU6IGluZGVudC10YWJzLW1vZGU6IG5pbDsganMtaW5kZW50LWxldmVsOiAyIC0qLSAqL1xuXG4gIC8qIHZpbTogc2V0IHN0cz0yIHN3PTIgZXQgdHc9ODA6ICovXG5cbiAgLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICAgKiBMaWNlbnNlLCB2LiAyLjAuIElmIGEgY29weSBvZiB0aGUgTVBMIHdhcyBub3QgZGlzdHJpYnV0ZWQgd2l0aCB0aGlzXG4gICAqIGZpbGUsIFlvdSBjYW4gb2J0YWluIG9uZSBhdCBodHRwOi8vbW96aWxsYS5vcmcvTVBMLzIuMC8uICovXG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGlmICh0eXBlb2YgYnJvd3NlciA9PT0gXCJ1bmRlZmluZWRcIiB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYnJvd3NlcikgIT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBDSFJPTUVfU0VORF9NRVNTQUdFX0NBTExCQUNLX05PX1JFU1BPTlNFX01FU1NBR0UgPSBcIlRoZSBtZXNzYWdlIHBvcnQgY2xvc2VkIGJlZm9yZSBhIHJlc3BvbnNlIHdhcyByZWNlaXZlZC5cIjtcbiAgICBjb25zdCBTRU5EX1JFU1BPTlNFX0RFUFJFQ0FUSU9OX1dBUk5JTkcgPSBcIlJldHVybmluZyBhIFByb21pc2UgaXMgdGhlIHByZWZlcnJlZCB3YXkgdG8gc2VuZCBhIHJlcGx5IGZyb20gYW4gb25NZXNzYWdlL29uTWVzc2FnZUV4dGVybmFsIGxpc3RlbmVyLCBhcyB0aGUgc2VuZFJlc3BvbnNlIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBzcGVjcyAoU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvTW96aWxsYS9BZGQtb25zL1dlYkV4dGVuc2lvbnMvQVBJL3J1bnRpbWUvb25NZXNzYWdlKVwiOyAvLyBXcmFwcGluZyB0aGUgYnVsayBvZiB0aGlzIHBvbHlmaWxsIGluIGEgb25lLXRpbWUtdXNlIGZ1bmN0aW9uIGlzIGEgbWlub3JcbiAgICAvLyBvcHRpbWl6YXRpb24gZm9yIEZpcmVmb3guIFNpbmNlIFNwaWRlcm1vbmtleSBkb2VzIG5vdCBmdWxseSBwYXJzZSB0aGVcbiAgICAvLyBjb250ZW50cyBvZiBhIGZ1bmN0aW9uIHVudGlsIHRoZSBmaXJzdCB0aW1lIGl0J3MgY2FsbGVkLCBhbmQgc2luY2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGFjdHVhbGx5IG5lZWQgdG8gYmUgY2FsbGVkLCB0aGlzIGFsbG93cyB0aGUgcG9seWZpbGwgdG8gYmUgaW5jbHVkZWRcbiAgICAvLyBpbiBGaXJlZm94IG5lYXJseSBmb3IgZnJlZS5cblxuICAgIGNvbnN0IHdyYXBBUElzID0gZXh0ZW5zaW9uQVBJcyA9PiB7XG4gICAgICAvLyBOT1RFOiBhcGlNZXRhZGF0YSBpcyBhc3NvY2lhdGVkIHRvIHRoZSBjb250ZW50IG9mIHRoZSBhcGktbWV0YWRhdGEuanNvbiBmaWxlXG4gICAgICAvLyBhdCBidWlsZCB0aW1lIGJ5IHJlcGxhY2luZyB0aGUgZm9sbG93aW5nIFwiaW5jbHVkZVwiIHdpdGggdGhlIGNvbnRlbnQgb2YgdGhlXG4gICAgICAvLyBKU09OIGZpbGUuXG4gICAgICBjb25zdCBhcGlNZXRhZGF0YSA9IHtcbiAgICAgICAgXCJhbGFybXNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjbGVhckFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImJvb2ttYXJrc1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDaGlsZHJlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFJlY2VudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFN1YlRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRUcmVlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwibW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVRyZWVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJicm93c2VyQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImRpc2FibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlbmFibGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJvcGVuUG9wdXBcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRCYWRnZUJhY2tncm91bmRDb2xvclwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEJhZGdlVGV4dFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldEljb25cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRQb3B1cFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFRpdGxlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiYnJvd3NpbmdEYXRhXCI6IHtcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUNhY2hlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlQ29va2llc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZURvd25sb2Fkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUZvcm1EYXRhXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlSGlzdG9yeVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZUxvY2FsU3RvcmFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBhc3N3b3Jkc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVBsdWdpbkRhdGFcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXR0aW5nc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbW1hbmRzXCI6IHtcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImNvbnRleHRNZW51c1wiOiB7XG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJjb29raWVzXCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbENvb2tpZVN0b3Jlc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImRldnRvb2xzXCI6IHtcbiAgICAgICAgICBcImluc3BlY3RlZFdpbmRvd1wiOiB7XG4gICAgICAgICAgICBcImV2YWxcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDIsXG4gICAgICAgICAgICAgIFwic2luZ2xlQ2FsbGJhY2tBcmdcIjogZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicGFuZWxzXCI6IHtcbiAgICAgICAgICAgIFwiY3JlYXRlXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDMsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzLFxuICAgICAgICAgICAgICBcInNpbmdsZUNhbGxiYWNrQXJnXCI6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImVsZW1lbnRzXCI6IHtcbiAgICAgICAgICAgICAgXCJjcmVhdGVTaWRlYmFyUGFuZVwiOiB7XG4gICAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJkb3dubG9hZHNcIjoge1xuICAgICAgICAgIFwiY2FuY2VsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZG93bmxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJlcmFzZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZpbGVJY29uXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwib3BlblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJmYWxsYmFja1RvTm9DYWxsYmFja1wiOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInBhdXNlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicmVtb3ZlRmlsZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlc3VtZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlYXJjaFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNob3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJleHRlbnNpb25cIjoge1xuICAgICAgICAgIFwiaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImlzQWxsb3dlZEluY29nbml0b0FjY2Vzc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcImhpc3RvcnlcIjoge1xuICAgICAgICAgIFwiYWRkVXJsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlQWxsXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZGVsZXRlUmFuZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZWxldGVVcmxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRWaXNpdHNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZWFyY2hcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpMThuXCI6IHtcbiAgICAgICAgICBcImRldGVjdExhbmd1YWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0QWNjZXB0TGFuZ3VhZ2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwiaWRlbnRpdHlcIjoge1xuICAgICAgICAgIFwibGF1bmNoV2ViQXV0aEZsb3dcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJpZGxlXCI6IHtcbiAgICAgICAgICBcInF1ZXJ5U3RhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJtYW5hZ2VtZW50XCI6IHtcbiAgICAgICAgICBcImdldFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEFsbFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFNlbGZcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRFbmFibGVkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwidW5pbnN0YWxsU2VsZlwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcIm5vdGlmaWNhdGlvbnNcIjoge1xuICAgICAgICAgIFwiY2xlYXJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRQZXJtaXNzaW9uTGV2ZWxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJwYWdlQWN0aW9uXCI6IHtcbiAgICAgICAgICBcImdldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWRlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0SWNvblwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFBvcHVwXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2V0VGl0bGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwiZmFsbGJhY2tUb05vQ2FsbGJhY2tcIjogdHJ1ZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzaG93XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDEsXG4gICAgICAgICAgICBcImZhbGxiYWNrVG9Ob0NhbGxiYWNrXCI6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicGVybWlzc2lvbnNcIjoge1xuICAgICAgICAgIFwiY29udGFpbnNcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXF1ZXN0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwicnVudGltZVwiOiB7XG4gICAgICAgICAgXCJnZXRCYWNrZ3JvdW5kUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFBsYXRmb3JtSW5mb1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm9wZW5PcHRpb25zUGFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInJlcXVlc3RVcGRhdGVDaGVja1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNlbmRNZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDNcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic2VuZE5hdGl2ZU1lc3NhZ2VcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRVbmluc3RhbGxVUkxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzZXNzaW9uc1wiOiB7XG4gICAgICAgICAgXCJnZXREZXZpY2VzXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0UmVjZW50bHlDbG9zZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZXN0b3JlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwic3RvcmFnZVwiOiB7XG4gICAgICAgICAgXCJsb2NhbFwiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1hbmFnZWRcIjoge1xuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic3luY1wiOiB7XG4gICAgICAgICAgICBcImNsZWFyXCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdldEJ5dGVzSW5Vc2VcIjoge1xuICAgICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcInJlbW92ZVwiOiB7XG4gICAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwic2V0XCI6IHtcbiAgICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInRhYnNcIjoge1xuICAgICAgICAgIFwiY2FwdHVyZVZpc2libGVUYWJcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkZXRlY3RMYW5ndWFnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImRpc2NhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJkdXBsaWNhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJleGVjdXRlU2NyaXB0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0Q3VycmVudFwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMCxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0JhY2tcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnb0ZvcndhcmRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoaWdobGlnaHRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJpbnNlcnRDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJtb3ZlXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAyLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwicXVlcnlcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZWxvYWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVDU1NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZW5kTWVzc2FnZVwiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMixcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAzXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcInNldFpvb21cIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJzZXRab29tU2V0dGluZ3NcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ0b3BTaXRlc1wiOiB7XG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMFxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJ3ZWJOYXZpZ2F0aW9uXCI6IHtcbiAgICAgICAgICBcImdldEFsbEZyYW1lc1wiOiB7XG4gICAgICAgICAgICBcIm1pbkFyZ3NcIjogMSxcbiAgICAgICAgICAgIFwibWF4QXJnc1wiOiAxXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcImdldEZyYW1lXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAxLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2ViUmVxdWVzdFwiOiB7XG4gICAgICAgICAgXCJoYW5kbGVyQmVoYXZpb3JDaGFuZ2VkXCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDBcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFwid2luZG93c1wiOiB7XG4gICAgICAgICAgXCJjcmVhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRBbGxcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJnZXRDdXJyZW50XCI6IHtcbiAgICAgICAgICAgIFwibWluQXJnc1wiOiAwLFxuICAgICAgICAgICAgXCJtYXhBcmdzXCI6IDFcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiZ2V0TGFzdEZvY3VzZWRcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDAsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJyZW1vdmVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDEsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMVxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJ1cGRhdGVcIjoge1xuICAgICAgICAgICAgXCJtaW5BcmdzXCI6IDIsXG4gICAgICAgICAgICBcIm1heEFyZ3NcIjogMlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgaWYgKE9iamVjdC5rZXlzKGFwaU1ldGFkYXRhKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXBpLW1ldGFkYXRhLmpzb24gaGFzIG5vdCBiZWVuIGluY2x1ZGVkIGluIGJyb3dzZXItcG9seWZpbGxcIik7XG4gICAgICB9XG4gICAgICAvKipcbiAgICAgICAqIEEgV2Vha01hcCBzdWJjbGFzcyB3aGljaCBjcmVhdGVzIGFuZCBzdG9yZXMgYSB2YWx1ZSBmb3IgYW55IGtleSB3aGljaCBkb2VzXG4gICAgICAgKiBub3QgZXhpc3Qgd2hlbiBhY2Nlc3NlZCwgYnV0IGJlaGF2ZXMgZXhhY3RseSBhcyBhbiBvcmRpbmFyeSBXZWFrTWFwXG4gICAgICAgKiBvdGhlcndpc2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY3JlYXRlSXRlbVxuICAgICAgICogICAgICAgIEEgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgaW4gb3JkZXIgdG8gY3JlYXRlIHRoZSB2YWx1ZSBmb3IgYW55XG4gICAgICAgKiAgICAgICAga2V5IHdoaWNoIGRvZXMgbm90IGV4aXN0LCB0aGUgZmlyc3QgdGltZSBpdCBpcyBhY2Nlc3NlZC4gVGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gcmVjZWl2ZXMsIGFzIGl0cyBvbmx5IGFyZ3VtZW50LCB0aGUga2V5IGJlaW5nIGNyZWF0ZWQuXG4gICAgICAgKi9cblxuXG4gICAgICBjbGFzcyBEZWZhdWx0V2Vha01hcCBleHRlbmRzIFdlYWtNYXAge1xuICAgICAgICBjb25zdHJ1Y3RvcihjcmVhdGVJdGVtLCBpdGVtcyA9IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHN1cGVyKGl0ZW1zKTtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUl0ZW0gPSBjcmVhdGVJdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2V0KGtleSkge1xuICAgICAgICAgIGlmICghdGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoa2V5LCB0aGlzLmNyZWF0ZUl0ZW0oa2V5KSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN1cGVyLmdldChrZXkpO1xuICAgICAgICB9XG5cbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gb2JqZWN0IHdpdGggYSBgdGhlbmAgbWV0aG9kLCBhbmQgY2FuXG4gICAgICAgKiB0aGVyZWZvcmUgYmUgYXNzdW1lZCB0byBiZWhhdmUgYXMgYSBQcm9taXNlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdGhlbmFibGUuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCBpc1RoZW5hYmxlID0gdmFsdWUgPT4ge1xuICAgICAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB9O1xuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZnVuY3Rpb24gd2hpY2gsIHdoZW4gY2FsbGVkLCB3aWxsIHJlc29sdmUgb3IgcmVqZWN0XG4gICAgICAgKiB0aGUgZ2l2ZW4gcHJvbWlzZSBiYXNlZCBvbiBob3cgaXQgaXMgY2FsbGVkOlxuICAgICAgICpcbiAgICAgICAqIC0gSWYsIHdoZW4gY2FsbGVkLCBgY2hyb21lLnJ1bnRpbWUubGFzdEVycm9yYCBjb250YWlucyBhIG5vbi1udWxsIG9iamVjdCxcbiAgICAgICAqICAgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgd2l0aCB0aGF0IHZhbHVlLlxuICAgICAgICogLSBJZiB0aGUgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZXhhY3RseSBvbmUgYXJndW1lbnQsIHRoZSBwcm9taXNlIGlzXG4gICAgICAgKiAgIHJlc29sdmVkIHRvIHRoYXQgdmFsdWUuXG4gICAgICAgKiAtIE90aGVyd2lzZSwgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWQgdG8gYW4gYXJyYXkgY29udGFpbmluZyBhbGwgb2YgdGhlXG4gICAgICAgKiAgIGZ1bmN0aW9uJ3MgYXJndW1lbnRzLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9taXNlXG4gICAgICAgKiAgICAgICAgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlc29sdXRpb24gYW5kIHJlamVjdGlvbiBmdW5jdGlvbnMgb2YgYVxuICAgICAgICogICAgICAgIHByb21pc2UuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlc29sdmVcbiAgICAgICAqICAgICAgICBUaGUgcHJvbWlzZSdzIHJlc29sdXRpb24gZnVuY3Rpb24uXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcm9taXNlLnJlamVjdFxuICAgICAgICogICAgICAgIFRoZSBwcm9taXNlJ3MgcmVqZWN0aW9uIGZ1bmN0aW9uLlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IG1ldGFkYXRhXG4gICAgICAgKiAgICAgICAgTWV0YWRhdGEgYWJvdXQgdGhlIHdyYXBwZWQgbWV0aG9kIHdoaWNoIGhhcyBjcmVhdGVkIHRoZSBjYWxsYmFjay5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gbWV0YWRhdGEuc2luZ2xlQ2FsbGJhY2tBcmdcbiAgICAgICAqICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgcHJvbWlzZSBpcyByZXNvbHZlZCB3aXRoIG9ubHkgdGhlIGZpcnN0XG4gICAgICAgKiAgICAgICAgYXJndW1lbnQgb2YgdGhlIGNhbGxiYWNrLCBhbHRlcm5hdGl2ZWx5IGFuIGFycmF5IG9mIGFsbCB0aGVcbiAgICAgICAqICAgICAgICBjYWxsYmFjayBhcmd1bWVudHMgaXMgcmVzb2x2ZWQuIEJ5IGRlZmF1bHQsIGlmIHRoZSBjYWxsYmFja1xuICAgICAgICogICAgICAgIGZ1bmN0aW9uIGlzIGludm9rZWQgd2l0aCBvbmx5IGEgc2luZ2xlIGFyZ3VtZW50LCB0aGF0IHdpbGwgYmVcbiAgICAgICAqICAgICAgICByZXNvbHZlZCB0byB0aGUgcHJvbWlzZSwgd2hpbGUgYWxsIGFyZ3VtZW50cyB3aWxsIGJlIHJlc29sdmVkIGFzXG4gICAgICAgKiAgICAgICAgYW4gYXJyYXkgaWYgbXVsdGlwbGUgYXJlIGdpdmVuLlxuICAgICAgICpcbiAgICAgICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICAgICAqICAgICAgICBUaGUgZ2VuZXJhdGVkIGNhbGxiYWNrIGZ1bmN0aW9uLlxuICAgICAgICovXG5cblxuICAgICAgY29uc3QgbWFrZUNhbGxiYWNrID0gKHByb21pc2UsIG1ldGFkYXRhKSA9PiB7XG4gICAgICAgIHJldHVybiAoLi4uY2FsbGJhY2tBcmdzKSA9PiB7XG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihleHRlbnNpb25BUElzLnJ1bnRpbWUubGFzdEVycm9yLm1lc3NhZ2UpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLnNpbmdsZUNhbGxiYWNrQXJnIHx8IGNhbGxiYWNrQXJncy5sZW5ndGggPD0gMSAmJiBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShjYWxsYmFja0FyZ3NbMF0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUoY2FsbGJhY2tBcmdzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBwbHVyYWxpemVBcmd1bWVudHMgPSBudW1BcmdzID0+IG51bUFyZ3MgPT0gMSA/IFwiYXJndW1lbnRcIiA6IFwiYXJndW1lbnRzXCI7XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIGZvciBhIG1ldGhvZCB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBtZXRhZGF0YS5cbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAgICogICAgICAgIFRoZSBuYW1lIG9mIHRoZSBtZXRob2Qgd2hpY2ggaXMgYmVpbmcgd3JhcHBlZC5cbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtZXRhZGF0YVxuICAgICAgICogICAgICAgIE1ldGFkYXRhIGFib3V0IHRoZSBtZXRob2QgYmVpbmcgd3JhcHBlZC5cbiAgICAgICAqIEBwYXJhbSB7aW50ZWdlcn0gbWV0YWRhdGEubWluQXJnc1xuICAgICAgICogICAgICAgIFRoZSBtaW5pbXVtIG51bWJlciBvZiBhcmd1bWVudHMgd2hpY2ggbXVzdCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24uIElmIGNhbGxlZCB3aXRoIGZld2VyIHRoYW4gdGhpcyBudW1iZXIgb2YgYXJndW1lbnRzLCB0aGVcbiAgICAgICAqICAgICAgICB3cmFwcGVyIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtpbnRlZ2VyfSBtZXRhZGF0YS5tYXhBcmdzXG4gICAgICAgKiAgICAgICAgVGhlIG1heGltdW0gbnVtYmVyIG9mIGFyZ3VtZW50cyB3aGljaCBtYXkgYmUgcGFzc2VkIHRvIHRoZVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uLiBJZiBjYWxsZWQgd2l0aCBtb3JlIHRoYW4gdGhpcyBudW1iZXIgb2YgYXJndW1lbnRzLCB0aGVcbiAgICAgICAqICAgICAgICB3cmFwcGVyIHdpbGwgcmFpc2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBtZXRhZGF0YS5zaW5nbGVDYWxsYmFja0FyZ1xuICAgICAgICogICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBwcm9taXNlIGlzIHJlc29sdmVkIHdpdGggb25seSB0aGUgZmlyc3RcbiAgICAgICAqICAgICAgICBhcmd1bWVudCBvZiB0aGUgY2FsbGJhY2ssIGFsdGVybmF0aXZlbHkgYW4gYXJyYXkgb2YgYWxsIHRoZVxuICAgICAgICogICAgICAgIGNhbGxiYWNrIGFyZ3VtZW50cyBpcyByZXNvbHZlZC4gQnkgZGVmYXVsdCwgaWYgdGhlIGNhbGxiYWNrXG4gICAgICAgKiAgICAgICAgZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIG9ubHkgYSBzaW5nbGUgYXJndW1lbnQsIHRoYXQgd2lsbCBiZVxuICAgICAgICogICAgICAgIHJlc29sdmVkIHRvIHRoZSBwcm9taXNlLCB3aGlsZSBhbGwgYXJndW1lbnRzIHdpbGwgYmUgcmVzb2x2ZWQgYXNcbiAgICAgICAqICAgICAgICBhbiBhcnJheSBpZiBtdWx0aXBsZSBhcmUgZ2l2ZW4uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge2Z1bmN0aW9uKG9iamVjdCwgLi4uKil9XG4gICAgICAgKiAgICAgICBUaGUgZ2VuZXJhdGVkIHdyYXBwZXIgZnVuY3Rpb24uXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwQXN5bmNGdW5jdGlvbiA9IChuYW1lLCBtZXRhZGF0YSkgPT4ge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gYXN5bmNGdW5jdGlvbldyYXBwZXIodGFyZ2V0LCAuLi5hcmdzKSB7XG4gICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgbWV0YWRhdGEubWluQXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPiBtZXRhZGF0YS5tYXhBcmdzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmIChtZXRhZGF0YS5mYWxsYmFja1RvTm9DYWxsYmFjaykge1xuICAgICAgICAgICAgICAvLyBUaGlzIEFQSSBtZXRob2QgaGFzIGN1cnJlbnRseSBubyBjYWxsYmFjayBvbiBDaHJvbWUsIGJ1dCBpdCByZXR1cm4gYSBwcm9taXNlIG9uIEZpcmVmb3gsXG4gICAgICAgICAgICAgIC8vIGFuZCBzbyB0aGUgcG9seWZpbGwgd2lsbCB0cnkgdG8gY2FsbCBpdCB3aXRoIGEgY2FsbGJhY2sgZmlyc3QsIGFuZCBpdCB3aWxsIGZhbGxiYWNrXG4gICAgICAgICAgICAgIC8vIHRvIG5vdCBwYXNzaW5nIHRoZSBjYWxsYmFjayBpZiB0aGUgZmlyc3QgY2FsbCBmYWlscy5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICByZWplY3RcbiAgICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChjYkVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGAke25hbWV9IEFQSSBtZXRob2QgZG9lc24ndCBzZWVtIHRvIHN1cHBvcnQgdGhlIGNhbGxiYWNrIHBhcmFtZXRlciwgYCArIFwiZmFsbGluZyBiYWNrIHRvIGNhbGwgaXQgd2l0aG91dCBhIGNhbGxiYWNrOiBcIiwgY2JFcnJvcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpOyAvLyBVcGRhdGUgdGhlIEFQSSBtZXRob2QgbWV0YWRhdGEsIHNvIHRoYXQgdGhlIG5leHQgQVBJIGNhbGxzIHdpbGwgbm90IHRyeSB0b1xuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgdW5zdXBwb3J0ZWQgY2FsbGJhY2sgYW55bW9yZS5cblxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLmZhbGxiYWNrVG9Ob0NhbGxiYWNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGEubm9DYWxsYmFjayA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1ldGFkYXRhLm5vQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0oLi4uYXJncywgbWFrZUNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgICAgICB9LCBtZXRhZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIC8qKlxuICAgICAgICogV3JhcHMgYW4gZXhpc3RpbmcgbWV0aG9kIG9mIHRoZSB0YXJnZXQgb2JqZWN0LCBzbyB0aGF0IGNhbGxzIHRvIGl0IGFyZVxuICAgICAgICogaW50ZXJjZXB0ZWQgYnkgdGhlIGdpdmVuIHdyYXBwZXIgZnVuY3Rpb24uIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHJlY2VpdmVzLFxuICAgICAgICogYXMgaXRzIGZpcnN0IGFyZ3VtZW50LCB0aGUgb3JpZ2luYWwgYHRhcmdldGAgb2JqZWN0LCBmb2xsb3dlZCBieSBlYWNoIG9mXG4gICAgICAgKiB0aGUgYXJndW1lbnRzIHBhc3NlZCB0byB0aGUgb3JpZ2luYWwgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXRcbiAgICAgICAqICAgICAgICBUaGUgb3JpZ2luYWwgdGFyZ2V0IG9iamVjdCB0aGF0IHRoZSB3cmFwcGVkIG1ldGhvZCBiZWxvbmdzIHRvLlxuICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kXG4gICAgICAgKiAgICAgICAgVGhlIG1ldGhvZCBiZWluZyB3cmFwcGVkLiBUaGlzIGlzIHVzZWQgYXMgdGhlIHRhcmdldCBvZiB0aGUgUHJveHlcbiAgICAgICAqICAgICAgICBvYmplY3Qgd2hpY2ggaXMgY3JlYXRlZCB0byB3cmFwIHRoZSBtZXRob2QuXG4gICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgVGhlIHdyYXBwZXIgZnVuY3Rpb24gd2hpY2ggaXMgY2FsbGVkIGluIHBsYWNlIG9mIGEgZGlyZWN0IGludm9jYXRpb25cbiAgICAgICAqICAgICAgICBvZiB0aGUgd3JhcHBlZCBtZXRob2QuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PGZ1bmN0aW9uPn1cbiAgICAgICAqICAgICAgICBBIFByb3h5IG9iamVjdCBmb3IgdGhlIGdpdmVuIG1ldGhvZCwgd2hpY2ggaW52b2tlcyB0aGUgZ2l2ZW4gd3JhcHBlclxuICAgICAgICogICAgICAgIG1ldGhvZCBpbiBpdHMgcGxhY2UuXG4gICAgICAgKi9cblxuXG4gICAgICBjb25zdCB3cmFwTWV0aG9kID0gKHRhcmdldCwgbWV0aG9kLCB3cmFwcGVyKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkobWV0aG9kLCB7XG4gICAgICAgICAgYXBwbHkodGFyZ2V0TWV0aG9kLCB0aGlzT2JqLCBhcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlci5jYWxsKHRoaXNPYmosIHRhcmdldCwgLi4uYXJncyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgbGV0IGhhc093blByb3BlcnR5ID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuICAgICAgLyoqXG4gICAgICAgKiBXcmFwcyBhbiBvYmplY3QgaW4gYSBQcm94eSB3aGljaCBpbnRlcmNlcHRzIGFuZCB3cmFwcyBjZXJ0YWluIG1ldGhvZHNcbiAgICAgICAqIGJhc2VkIG9uIHRoZSBnaXZlbiBgd3JhcHBlcnNgIGFuZCBgbWV0YWRhdGFgIG9iamVjdHMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IHRhcmdldFxuICAgICAgICogICAgICAgIFRoZSB0YXJnZXQgb2JqZWN0IHRvIHdyYXAuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtvYmplY3R9IFt3cmFwcGVycyA9IHt9XVxuICAgICAgICogICAgICAgIEFuIG9iamVjdCB0cmVlIGNvbnRhaW5pbmcgd3JhcHBlciBmdW5jdGlvbnMgZm9yIHNwZWNpYWwgY2FzZXMuIEFueVxuICAgICAgICogICAgICAgIGZ1bmN0aW9uIHByZXNlbnQgaW4gdGhpcyBvYmplY3QgdHJlZSBpcyBjYWxsZWQgaW4gcGxhY2Ugb2YgdGhlXG4gICAgICAgKiAgICAgICAgbWV0aG9kIGluIHRoZSBzYW1lIGxvY2F0aW9uIGluIHRoZSBgdGFyZ2V0YCBvYmplY3QgdHJlZS4gVGhlc2VcbiAgICAgICAqICAgICAgICB3cmFwcGVyIG1ldGhvZHMgYXJlIGludm9rZWQgYXMgZGVzY3JpYmVkIGluIHtAc2VlIHdyYXBNZXRob2R9LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbbWV0YWRhdGEgPSB7fV1cbiAgICAgICAqICAgICAgICBBbiBvYmplY3QgdHJlZSBjb250YWluaW5nIG1ldGFkYXRhIHVzZWQgdG8gYXV0b21hdGljYWxseSBnZW5lcmF0ZVxuICAgICAgICogICAgICAgIFByb21pc2UtYmFzZWQgd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFzeW5jaHJvbm91cy4gQW55IGZ1bmN0aW9uIGluXG4gICAgICAgKiAgICAgICAgdGhlIGB0YXJnZXRgIG9iamVjdCB0cmVlIHdoaWNoIGhhcyBhIGNvcnJlc3BvbmRpbmcgbWV0YWRhdGEgb2JqZWN0XG4gICAgICAgKiAgICAgICAgaW4gdGhlIHNhbWUgbG9jYXRpb24gaW4gdGhlIGBtZXRhZGF0YWAgdHJlZSBpcyByZXBsYWNlZCB3aXRoIGFuXG4gICAgICAgKiAgICAgICAgYXV0b21hdGljYWxseS1nZW5lcmF0ZWQgd3JhcHBlciBmdW5jdGlvbiwgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgKiAgICAgICAge0BzZWUgd3JhcEFzeW5jRnVuY3Rpb259XG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1Byb3h5PG9iamVjdD59XG4gICAgICAgKi9cblxuICAgICAgY29uc3Qgd3JhcE9iamVjdCA9ICh0YXJnZXQsIHdyYXBwZXJzID0ge30sIG1ldGFkYXRhID0ge30pID0+IHtcbiAgICAgICAgbGV0IGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGhhbmRsZXJzID0ge1xuICAgICAgICAgIGhhcyhwcm94eVRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3AgaW4gdGFyZ2V0IHx8IHByb3AgaW4gY2FjaGU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGdldChwcm94eVRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWNoZVtwcm9wXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCEocHJvcCBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRhcmdldFtwcm9wXTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBtZXRob2Qgb24gdGhlIHVuZGVybHlpbmcgb2JqZWN0LiBDaGVjayBpZiB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAgIC8vIGFueSB3cmFwcGluZy5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cmFwcGVyc1twcm9wXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHNwZWNpYWwtY2FzZSB3cmFwcGVyIGZvciB0aGlzIG1ldGhvZC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBNZXRob2QodGFyZ2V0LCB0YXJnZXRbcHJvcF0sIHdyYXBwZXJzW3Byb3BdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShtZXRhZGF0YSwgcHJvcCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIG1ldGhvZCB0aGF0IHdlIGhhdmUgbWV0YWRhdGEgZm9yLiBDcmVhdGUgYVxuICAgICAgICAgICAgICAgIC8vIFByb21pc2Ugd3JhcHBlciBmb3IgaXQuXG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZXIgPSB3cmFwQXN5bmNGdW5jdGlvbihwcm9wLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwTWV0aG9kKHRhcmdldCwgdGFyZ2V0W3Byb3BdLCB3cmFwcGVyKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgbWV0aG9kIHRoYXQgd2UgZG9uJ3Qga25vdyBvciBjYXJlIGFib3V0LiBSZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gb3JpZ2luYWwgbWV0aG9kLCBib3VuZCB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5iaW5kKHRhcmdldCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIChoYXNPd25Qcm9wZXJ0eSh3cmFwcGVycywgcHJvcCkgfHwgaGFzT3duUHJvcGVydHkobWV0YWRhdGEsIHByb3ApKSkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGFuIG9iamVjdCB0aGF0IHdlIG5lZWQgdG8gZG8gc29tZSB3cmFwcGluZyBmb3IgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgIC8vIG9mLiBDcmVhdGUgYSBzdWItb2JqZWN0IHdyYXBwZXIgZm9yIGl0IHdpdGggdGhlIGFwcHJvcHJpYXRlIGNoaWxkXG4gICAgICAgICAgICAgIC8vIG1ldGFkYXRhLlxuICAgICAgICAgICAgICB2YWx1ZSA9IHdyYXBPYmplY3QodmFsdWUsIHdyYXBwZXJzW3Byb3BdLCBtZXRhZGF0YVtwcm9wXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KG1ldGFkYXRhLCBcIipcIikpIHtcbiAgICAgICAgICAgICAgLy8gV3JhcCBhbGwgcHJvcGVydGllcyBpbiAqIG5hbWVzcGFjZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB3cmFwT2JqZWN0KHZhbHVlLCB3cmFwcGVyc1twcm9wXSwgbWV0YWRhdGFbXCIqXCJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gZG8gYW55IHdyYXBwaW5nIGZvciB0aGlzIHByb3BlcnR5LFxuICAgICAgICAgICAgICAvLyBzbyBqdXN0IGZvcndhcmQgYWxsIGFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBvYmplY3QuXG4gICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuXG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FjaGVbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgc2V0KHByb3h5VGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIGNhY2hlKSB7XG4gICAgICAgICAgICAgIGNhY2hlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlZmluZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wLCBkZXNjKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eShjYWNoZSwgcHJvcCwgZGVzYyk7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIGRlbGV0ZVByb3BlcnR5KHByb3h5VGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShjYWNoZSwgcHJvcCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIH07IC8vIFBlciBjb250cmFjdCBvZiB0aGUgUHJveHkgQVBJLCB0aGUgXCJnZXRcIiBwcm94eSBoYW5kbGVyIG11c3QgcmV0dXJuIHRoZVxuICAgICAgICAvLyBvcmlnaW5hbCB2YWx1ZSBvZiB0aGUgdGFyZ2V0IGlmIHRoYXQgdmFsdWUgaXMgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZFxuICAgICAgICAvLyBub24tY29uZmlndXJhYmxlLiBGb3IgdGhpcyByZWFzb24sIHdlIGNyZWF0ZSBhbiBvYmplY3Qgd2l0aCB0aGVcbiAgICAgICAgLy8gcHJvdG90eXBlIHNldCB0byBgdGFyZ2V0YCBpbnN0ZWFkIG9mIHVzaW5nIGB0YXJnZXRgIGRpcmVjdGx5LlxuICAgICAgICAvLyBPdGhlcndpc2Ugd2UgY2Fubm90IHJldHVybiBhIGN1c3RvbSBvYmplY3QgZm9yIEFQSXMgdGhhdFxuICAgICAgICAvLyBhcmUgZGVjbGFyZWQgcmVhZC1vbmx5IGFuZCBub24tY29uZmlndXJhYmxlLCBzdWNoIGFzIGBjaHJvbWUuZGV2dG9vbHNgLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgcHJveHkgaGFuZGxlcnMgdGhlbXNlbHZlcyB3aWxsIHN0aWxsIHVzZSB0aGUgb3JpZ2luYWwgYHRhcmdldGBcbiAgICAgICAgLy8gaW5zdGVhZCBvZiB0aGUgYHByb3h5VGFyZ2V0YCwgc28gdGhhdCB0aGUgbWV0aG9kcyBhbmQgcHJvcGVydGllcyBhcmVcbiAgICAgICAgLy8gZGVyZWZlcmVuY2VkIHZpYSB0aGUgb3JpZ2luYWwgdGFyZ2V0cy5cblxuICAgICAgICBsZXQgcHJveHlUYXJnZXQgPSBPYmplY3QuY3JlYXRlKHRhcmdldCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkocHJveHlUYXJnZXQsIGhhbmRsZXJzKTtcbiAgICAgIH07XG4gICAgICAvKipcbiAgICAgICAqIENyZWF0ZXMgYSBzZXQgb2Ygd3JhcHBlciBmdW5jdGlvbnMgZm9yIGFuIGV2ZW50IG9iamVjdCwgd2hpY2ggaGFuZGxlc1xuICAgICAgICogd3JhcHBpbmcgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRoYXQgdGhvc2UgbWVzc2FnZXMgYXJlIHBhc3NlZC5cbiAgICAgICAqXG4gICAgICAgKiBBIHNpbmdsZSB3cmFwcGVyIGlzIGNyZWF0ZWQgZm9yIGVhY2ggbGlzdGVuZXIgZnVuY3Rpb24sIGFuZCBzdG9yZWQgaW4gYVxuICAgICAgICogbWFwLiBTdWJzZXF1ZW50IGNhbGxzIHRvIGBhZGRMaXN0ZW5lcmAsIGBoYXNMaXN0ZW5lcmAsIG9yIGByZW1vdmVMaXN0ZW5lcmBcbiAgICAgICAqIHJldHJpZXZlIHRoZSBvcmlnaW5hbCB3cmFwcGVyLCBzbyB0aGF0ICBhdHRlbXB0cyB0byByZW1vdmUgYVxuICAgICAgICogcHJldmlvdXNseS1hZGRlZCBsaXN0ZW5lciB3b3JrIGFzIGV4cGVjdGVkLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7RGVmYXVsdFdlYWtNYXA8ZnVuY3Rpb24sIGZ1bmN0aW9uPn0gd3JhcHBlck1hcFxuICAgICAgICogICAgICAgIEEgRGVmYXVsdFdlYWtNYXAgb2JqZWN0IHdoaWNoIHdpbGwgY3JlYXRlIHRoZSBhcHByb3ByaWF0ZSB3cmFwcGVyXG4gICAgICAgKiAgICAgICAgZm9yIGEgZ2l2ZW4gbGlzdGVuZXIgZnVuY3Rpb24gd2hlbiBvbmUgZG9lcyBub3QgZXhpc3QsIGFuZCByZXRyaWV2ZVxuICAgICAgICogICAgICAgIGFuIGV4aXN0aW5nIG9uZSB3aGVuIGl0IGRvZXMuXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAqL1xuXG5cbiAgICAgIGNvbnN0IHdyYXBFdmVudCA9IHdyYXBwZXJNYXAgPT4gKHtcbiAgICAgICAgYWRkTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lciwgLi4uYXJncykge1xuICAgICAgICAgIHRhcmdldC5hZGRMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lciksIC4uLmFyZ3MpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGhhc0xpc3RlbmVyKHRhcmdldCwgbGlzdGVuZXIpIHtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0Lmhhc0xpc3RlbmVyKHdyYXBwZXJNYXAuZ2V0KGxpc3RlbmVyKSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlTGlzdGVuZXIodGFyZ2V0LCBsaXN0ZW5lcikge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVMaXN0ZW5lcih3cmFwcGVyTWFwLmdldChsaXN0ZW5lcikpO1xuICAgICAgICB9XG5cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBvblJlcXVlc3RGaW5pc2hlZFdyYXBwZXJzID0gbmV3IERlZmF1bHRXZWFrTWFwKGxpc3RlbmVyID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgcmV0dXJuIGxpc3RlbmVyO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXcmFwcyBhbiBvblJlcXVlc3RGaW5pc2hlZCBsaXN0ZW5lciBmdW5jdGlvbiBzbyB0aGF0IGl0IHdpbGwgcmV0dXJuIGFcbiAgICAgICAgICogYGdldENvbnRlbnQoKWAgcHJvcGVydHkgd2hpY2ggcmV0dXJucyBhIGBQcm9taXNlYCByYXRoZXIgdGhhbiB1c2luZyBhXG4gICAgICAgICAqIGNhbGxiYWNrIEFQSS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHJlcVxuICAgICAgICAgKiAgICAgICAgVGhlIEhBUiBlbnRyeSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBuZXR3b3JrIHJlcXVlc3QuXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG9uUmVxdWVzdEZpbmlzaGVkKHJlcSkge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRSZXEgPSB3cmFwT2JqZWN0KHJlcSwge31cbiAgICAgICAgICAvKiB3cmFwcGVycyAqL1xuICAgICAgICAgICwge1xuICAgICAgICAgICAgZ2V0Q29udGVudDoge1xuICAgICAgICAgICAgICBtaW5BcmdzOiAwLFxuICAgICAgICAgICAgICBtYXhBcmdzOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbGlzdGVuZXIod3JhcHBlZFJlcSk7XG4gICAgICAgIH07XG4gICAgICB9KTsgLy8gS2VlcCB0cmFjayBpZiB0aGUgZGVwcmVjYXRpb24gd2FybmluZyBoYXMgYmVlbiBsb2dnZWQgYXQgbGVhc3Qgb25jZS5cblxuICAgICAgbGV0IGxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZyA9IGZhbHNlO1xuICAgICAgY29uc3Qgb25NZXNzYWdlV3JhcHBlcnMgPSBuZXcgRGVmYXVsdFdlYWtNYXAobGlzdGVuZXIgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gbGlzdGVuZXI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyYXBzIGEgbWVzc2FnZSBsaXN0ZW5lciBmdW5jdGlvbiBzbyB0aGF0IGl0IG1heSBzZW5kIHJlc3BvbnNlcyBiYXNlZCBvblxuICAgICAgICAgKiBpdHMgcmV0dXJuIHZhbHVlLCByYXRoZXIgdGhhbiBieSByZXR1cm5pbmcgYSBzZW50aW5lbCB2YWx1ZSBhbmQgY2FsbGluZyBhXG4gICAgICAgICAqIGNhbGxiYWNrLiBJZiB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gcmV0dXJucyBhIFByb21pc2UsIHRoZSByZXNwb25zZSBpc1xuICAgICAgICAgKiBzZW50IHdoZW4gdGhlIHByb21pc2UgZWl0aGVyIHJlc29sdmVzIG9yIHJlamVjdHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gbWVzc2FnZVxuICAgICAgICAgKiAgICAgICAgVGhlIG1lc3NhZ2Ugc2VudCBieSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjaGFubmVsLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gc2VuZGVyXG4gICAgICAgICAqICAgICAgICBEZXRhaWxzIGFib3V0IHRoZSBzZW5kZXIgb2YgdGhlIG1lc3NhZ2UuXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKil9IHNlbmRSZXNwb25zZVxuICAgICAgICAgKiAgICAgICAgQSBjYWxsYmFjayB3aGljaCwgd2hlbiBjYWxsZWQgd2l0aCBhbiBhcmJpdHJhcnkgYXJndW1lbnQsIHNlbmRzXG4gICAgICAgICAqICAgICAgICB0aGF0IHZhbHVlIGFzIGEgcmVzcG9uc2UuXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAgICAgKiAgICAgICAgVHJ1ZSBpZiB0aGUgd3JhcHBlZCBsaXN0ZW5lciByZXR1cm5lZCBhIFByb21pc2UsIHdoaWNoIHdpbGwgbGF0ZXJcbiAgICAgICAgICogICAgICAgIHlpZWxkIGEgcmVzcG9uc2UuIEZhbHNlIG90aGVyd2lzZS5cbiAgICAgICAgICovXG5cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gb25NZXNzYWdlKG1lc3NhZ2UsIHNlbmRlciwgc2VuZFJlc3BvbnNlKSB7XG4gICAgICAgICAgbGV0IGRpZENhbGxTZW5kUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICBsZXQgd3JhcHBlZFNlbmRSZXNwb25zZTtcbiAgICAgICAgICBsZXQgc2VuZFJlc3BvbnNlUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgd3JhcHBlZFNlbmRSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICBpZiAoIWxvZ2dlZFNlbmRSZXNwb25zZURlcHJlY2F0aW9uV2FybmluZykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihTRU5EX1JFU1BPTlNFX0RFUFJFQ0FUSU9OX1dBUk5JTkcsIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgICAgICAgICBsb2dnZWRTZW5kUmVzcG9uc2VEZXByZWNhdGlvbldhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZGlkQ2FsbFNlbmRSZXNwb25zZSA9IHRydWU7XG4gICAgICAgICAgICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZXQgcmVzdWx0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGxpc3RlbmVyKG1lc3NhZ2UsIHNlbmRlciwgd3JhcHBlZFNlbmRSZXNwb25zZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBQcm9taXNlLnJlamVjdChlcnIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGlzUmVzdWx0VGhlbmFibGUgPSByZXN1bHQgIT09IHRydWUgJiYgaXNUaGVuYWJsZShyZXN1bHQpOyAvLyBJZiB0aGUgbGlzdGVuZXIgZGlkbid0IHJldHVybmVkIHRydWUgb3IgYSBQcm9taXNlLCBvciBjYWxsZWRcbiAgICAgICAgICAvLyB3cmFwcGVkU2VuZFJlc3BvbnNlIHN5bmNocm9ub3VzbHksIHdlIGNhbiBleGl0IGVhcmxpZXJcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIHdpbGwgYmUgbm8gcmVzcG9uc2Ugc2VudCBmcm9tIHRoaXMgbGlzdGVuZXIuXG5cbiAgICAgICAgICBpZiAocmVzdWx0ICE9PSB0cnVlICYmICFpc1Jlc3VsdFRoZW5hYmxlICYmICFkaWRDYWxsU2VuZFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSAvLyBBIHNtYWxsIGhlbHBlciB0byBzZW5kIHRoZSBtZXNzYWdlIGlmIHRoZSBwcm9taXNlIHJlc29sdmVzXG4gICAgICAgICAgLy8gYW5kIGFuIGVycm9yIGlmIHRoZSBwcm9taXNlIHJlamVjdHMgKGEgd3JhcHBlZCBzZW5kTWVzc2FnZSBoYXNcbiAgICAgICAgICAvLyB0byB0cmFuc2xhdGUgdGhlIG1lc3NhZ2UgaW50byBhIHJlc29sdmVkIHByb21pc2Ugb3IgYSByZWplY3RlZFxuICAgICAgICAgIC8vIHByb21pc2UpLlxuXG5cbiAgICAgICAgICBjb25zdCBzZW5kUHJvbWlzZWRSZXN1bHQgPSBwcm9taXNlID0+IHtcbiAgICAgICAgICAgIHByb21pc2UudGhlbihtc2cgPT4ge1xuICAgICAgICAgICAgICAvLyBzZW5kIHRoZSBtZXNzYWdlIHZhbHVlLlxuICAgICAgICAgICAgICBzZW5kUmVzcG9uc2UobXNnKTtcbiAgICAgICAgICAgIH0sIGVycm9yID0+IHtcbiAgICAgICAgICAgICAgLy8gU2VuZCBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGVycm9yIGlmIHRoZSByZWplY3RlZCB2YWx1ZVxuICAgICAgICAgICAgICAvLyBpcyBhbiBpbnN0YW5jZSBvZiBlcnJvciwgb3IgdGhlIG9iamVjdCBpdHNlbGYgb3RoZXJ3aXNlLlxuICAgICAgICAgICAgICBsZXQgbWVzc2FnZTtcblxuICAgICAgICAgICAgICBpZiAoZXJyb3IgJiYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgfHwgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiQW4gdW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZFwiO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2VuZFJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICBfX21veldlYkV4dGVuc2lvblBvbHlmaWxsUmVqZWN0X186IHRydWUsXG4gICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgIC8vIFByaW50IGFuIGVycm9yIG9uIHRoZSBjb25zb2xlIGlmIHVuYWJsZSB0byBzZW5kIHRoZSByZXNwb25zZS5cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBzZW5kIG9uTWVzc2FnZSByZWplY3RlZCByZXBseVwiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfTsgLy8gSWYgdGhlIGxpc3RlbmVyIHJldHVybmVkIGEgUHJvbWlzZSwgc2VuZCB0aGUgcmVzb2x2ZWQgdmFsdWUgYXMgYVxuICAgICAgICAgIC8vIHJlc3VsdCwgb3RoZXJ3aXNlIHdhaXQgdGhlIHByb21pc2UgcmVsYXRlZCB0byB0aGUgd3JhcHBlZFNlbmRSZXNwb25zZVxuICAgICAgICAgIC8vIGNhbGxiYWNrIHRvIHJlc29sdmUgYW5kIHNlbmQgaXQgYXMgYSByZXNwb25zZS5cblxuXG4gICAgICAgICAgaWYgKGlzUmVzdWx0VGhlbmFibGUpIHtcbiAgICAgICAgICAgIHNlbmRQcm9taXNlZFJlc3VsdChyZXN1bHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZW5kUHJvbWlzZWRSZXN1bHQoc2VuZFJlc3BvbnNlUHJvbWlzZSk7XG4gICAgICAgICAgfSAvLyBMZXQgQ2hyb21lIGtub3cgdGhhdCB0aGUgbGlzdGVuZXIgaXMgcmVwbHlpbmcuXG5cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHdyYXBwZWRTZW5kTWVzc2FnZUNhbGxiYWNrID0gKHtcbiAgICAgICAgcmVqZWN0LFxuICAgICAgICByZXNvbHZlXG4gICAgICB9LCByZXBseSkgPT4ge1xuICAgICAgICBpZiAoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvcikge1xuICAgICAgICAgIC8vIERldGVjdCB3aGVuIG5vbmUgb2YgdGhlIGxpc3RlbmVycyByZXBsaWVkIHRvIHRoZSBzZW5kTWVzc2FnZSBjYWxsIGFuZCByZXNvbHZlXG4gICAgICAgICAgLy8gdGhlIHByb21pc2UgdG8gdW5kZWZpbmVkIGFzIGluIEZpcmVmb3guXG4gICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3dlYmV4dGVuc2lvbi1wb2x5ZmlsbC9pc3N1ZXMvMTMwXG4gICAgICAgICAgaWYgKGV4dGVuc2lvbkFQSXMucnVudGltZS5sYXN0RXJyb3IubWVzc2FnZSA9PT0gQ0hST01FX1NFTkRfTUVTU0FHRV9DQUxMQkFDS19OT19SRVNQT05TRV9NRVNTQUdFKSB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoZXh0ZW5zaW9uQVBJcy5ydW50aW1lLmxhc3RFcnJvci5tZXNzYWdlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHJlcGx5ICYmIHJlcGx5Ll9fbW96V2ViRXh0ZW5zaW9uUG9seWZpbGxSZWplY3RfXykge1xuICAgICAgICAgIC8vIENvbnZlcnQgYmFjayB0aGUgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IgaW50b1xuICAgICAgICAgIC8vIGFuIEVycm9yIGluc3RhbmNlLlxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVwbHkubWVzc2FnZSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUocmVwbHkpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB3cmFwcGVkU2VuZE1lc3NhZ2UgPSAobmFtZSwgbWV0YWRhdGEsIGFwaU5hbWVzcGFjZU9iaiwgLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPCBtZXRhZGF0YS5taW5BcmdzKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCBhdCBsZWFzdCAke21ldGFkYXRhLm1pbkFyZ3N9ICR7cGx1cmFsaXplQXJndW1lbnRzKG1ldGFkYXRhLm1pbkFyZ3MpfSBmb3IgJHtuYW1lfSgpLCBnb3QgJHthcmdzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IG1ldGFkYXRhLm1heEFyZ3MpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGF0IG1vc3QgJHttZXRhZGF0YS5tYXhBcmdzfSAke3BsdXJhbGl6ZUFyZ3VtZW50cyhtZXRhZGF0YS5tYXhBcmdzKX0gZm9yICR7bmFtZX0oKSwgZ290ICR7YXJncy5sZW5ndGh9YCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHdyYXBwZWRDYiA9IHdyYXBwZWRTZW5kTWVzc2FnZUNhbGxiYWNrLmJpbmQobnVsbCwge1xuICAgICAgICAgICAgcmVzb2x2ZSxcbiAgICAgICAgICAgIHJlamVjdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFyZ3MucHVzaCh3cmFwcGVkQ2IpO1xuICAgICAgICAgIGFwaU5hbWVzcGFjZU9iai5zZW5kTWVzc2FnZSguLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCBzdGF0aWNXcmFwcGVycyA9IHtcbiAgICAgICAgZGV2dG9vbHM6IHtcbiAgICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgICBvblJlcXVlc3RGaW5pc2hlZDogd3JhcEV2ZW50KG9uUmVxdWVzdEZpbmlzaGVkV3JhcHBlcnMpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBydW50aW1lOiB7XG4gICAgICAgICAgb25NZXNzYWdlOiB3cmFwRXZlbnQob25NZXNzYWdlV3JhcHBlcnMpLFxuICAgICAgICAgIG9uTWVzc2FnZUV4dGVybmFsOiB3cmFwRXZlbnQob25NZXNzYWdlV3JhcHBlcnMpLFxuICAgICAgICAgIHNlbmRNZXNzYWdlOiB3cmFwcGVkU2VuZE1lc3NhZ2UuYmluZChudWxsLCBcInNlbmRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgICBtYXhBcmdzOiAzXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgdGFiczoge1xuICAgICAgICAgIHNlbmRNZXNzYWdlOiB3cmFwcGVkU2VuZE1lc3NhZ2UuYmluZChudWxsLCBcInNlbmRNZXNzYWdlXCIsIHtcbiAgICAgICAgICAgIG1pbkFyZ3M6IDIsXG4gICAgICAgICAgICBtYXhBcmdzOiAzXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHNldHRpbmdNZXRhZGF0YSA9IHtcbiAgICAgICAgY2xlYXI6IHtcbiAgICAgICAgICBtaW5BcmdzOiAxLFxuICAgICAgICAgIG1heEFyZ3M6IDFcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiB7XG4gICAgICAgICAgbWluQXJnczogMSxcbiAgICAgICAgICBtYXhBcmdzOiAxXG4gICAgICAgIH0sXG4gICAgICAgIHNldDoge1xuICAgICAgICAgIG1pbkFyZ3M6IDEsXG4gICAgICAgICAgbWF4QXJnczogMVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYXBpTWV0YWRhdGEucHJpdmFjeSA9IHtcbiAgICAgICAgbmV0d29yazoge1xuICAgICAgICAgIFwiKlwiOiBzZXR0aW5nTWV0YWRhdGFcbiAgICAgICAgfSxcbiAgICAgICAgc2VydmljZXM6IHtcbiAgICAgICAgICBcIipcIjogc2V0dGluZ01ldGFkYXRhXG4gICAgICAgIH0sXG4gICAgICAgIHdlYnNpdGVzOiB7XG4gICAgICAgICAgXCIqXCI6IHNldHRpbmdNZXRhZGF0YVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHdyYXBPYmplY3QoZXh0ZW5zaW9uQVBJcywgc3RhdGljV3JhcHBlcnMsIGFwaU1ldGFkYXRhKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBjaHJvbWUgIT0gXCJvYmplY3RcIiB8fCAhY2hyb21lIHx8ICFjaHJvbWUucnVudGltZSB8fCAhY2hyb21lLnJ1bnRpbWUuaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2NyaXB0IHNob3VsZCBvbmx5IGJlIGxvYWRlZCBpbiBhIGJyb3dzZXIgZXh0ZW5zaW9uLlwiKTtcbiAgICB9IC8vIFRoZSBidWlsZCBwcm9jZXNzIGFkZHMgYSBVTUQgd3JhcHBlciBhcm91bmQgdGhpcyBmaWxlLCB3aGljaCBtYWtlcyB0aGVcbiAgICAvLyBgbW9kdWxlYCB2YXJpYWJsZSBhdmFpbGFibGUuXG5cblxuICAgIG1vZHVsZS5leHBvcnRzID0gd3JhcEFQSXMoY2hyb21lKTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGJyb3dzZXI7XG4gIH1cbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnJvd3Nlci1wb2x5ZmlsbC5qcy5tYXBcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoWydleHBvcnRzJ10sIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKGdsb2JhbC5XSEFUV0dGZXRjaCA9IHt9KSkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKGV4cG9ydHMpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBnbG9iYWwgPVxuICAgICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsVGhpcykgfHxcbiAgICAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYpIHx8XG4gICAgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbCk7XG5cbiAgdmFyIHN1cHBvcnQgPSB7XG4gICAgc2VhcmNoUGFyYW1zOiAnVVJMU2VhcmNoUGFyYW1zJyBpbiBnbG9iYWwsXG4gICAgaXRlcmFibGU6ICdTeW1ib2wnIGluIGdsb2JhbCAmJiAnaXRlcmF0b3InIGluIFN5bWJvbCxcbiAgICBibG9iOlxuICAgICAgJ0ZpbGVSZWFkZXInIGluIGdsb2JhbCAmJlxuICAgICAgJ0Jsb2InIGluIGdsb2JhbCAmJlxuICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG5ldyBCbG9iKCk7XG4gICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KSgpLFxuICAgIGZvcm1EYXRhOiAnRm9ybURhdGEnIGluIGdsb2JhbCxcbiAgICBhcnJheUJ1ZmZlcjogJ0FycmF5QnVmZmVyJyBpbiBnbG9iYWxcbiAgfTtcblxuICBmdW5jdGlvbiBpc0RhdGFWaWV3KG9iaikge1xuICAgIHJldHVybiBvYmogJiYgRGF0YVZpZXcucHJvdG90eXBlLmlzUHJvdG90eXBlT2Yob2JqKVxuICB9XG5cbiAgaWYgKHN1cHBvcnQuYXJyYXlCdWZmZXIpIHtcbiAgICB2YXIgdmlld0NsYXNzZXMgPSBbXG4gICAgICAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgICAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgVWludDMyQXJyYXldJyxcbiAgICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgICAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSdcbiAgICBdO1xuXG4gICAgdmFyIGlzQXJyYXlCdWZmZXJWaWV3ID1cbiAgICAgIEFycmF5QnVmZmVyLmlzVmlldyB8fFxuICAgICAgZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdmlld0NsYXNzZXMuaW5kZXhPZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSkgPiAtMVxuICAgICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU5hbWUobmFtZSkge1xuICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgfVxuICAgIGlmICgvW15hLXowLTlcXC0jJCUmJyorLl5fYHx+IV0vaS50ZXN0KG5hbWUpIHx8IG5hbWUgPT09ICcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGNoYXJhY3RlciBpbiBoZWFkZXIgZmllbGQgbmFtZTogXCInICsgbmFtZSArICdcIicpXG4gICAgfVxuICAgIHJldHVybiBuYW1lLnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvLyBCdWlsZCBhIGRlc3RydWN0aXZlIGl0ZXJhdG9yIGZvciB0aGUgdmFsdWUgbGlzdFxuICBmdW5jdGlvbiBpdGVyYXRvckZvcihpdGVtcykge1xuICAgIHZhciBpdGVyYXRvciA9IHtcbiAgICAgIG5leHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBpdGVtcy5zaGlmdCgpO1xuICAgICAgICByZXR1cm4ge2RvbmU6IHZhbHVlID09PSB1bmRlZmluZWQsIHZhbHVlOiB2YWx1ZX1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuaXRlcmFibGUpIHtcbiAgICAgIGl0ZXJhdG9yW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBpdGVyYXRvclxuICB9XG5cbiAgZnVuY3Rpb24gSGVhZGVycyhoZWFkZXJzKSB7XG4gICAgdGhpcy5tYXAgPSB7fTtcblxuICAgIGlmIChoZWFkZXJzIGluc3RhbmNlb2YgSGVhZGVycykge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kKG5hbWUsIHZhbHVlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShoZWFkZXJzKSkge1xuICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlcikge1xuICAgICAgICB0aGlzLmFwcGVuZChoZWFkZXJbMF0sIGhlYWRlclsxXSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMpIHtcbiAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB0aGlzLmFwcGVuZChuYW1lLCBoZWFkZXJzW25hbWVdKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIEhlYWRlcnMucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgdmFsdWUgPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgdmFyIG9sZFZhbHVlID0gdGhpcy5tYXBbbmFtZV07XG4gICAgdGhpcy5tYXBbbmFtZV0gPSBvbGRWYWx1ZSA/IG9sZFZhbHVlICsgJywgJyArIHZhbHVlIDogdmFsdWU7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGVbJ2RlbGV0ZSddID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGRlbGV0ZSB0aGlzLm1hcFtub3JtYWxpemVOYW1lKG5hbWUpXTtcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgbmFtZSA9IG5vcm1hbGl6ZU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIHRoaXMuaGFzKG5hbWUpID8gdGhpcy5tYXBbbmFtZV0gOiBudWxsXG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLm1hcC5oYXNPd25Qcm9wZXJ0eShub3JtYWxpemVOYW1lKG5hbWUpKVxuICB9O1xuXG4gIEhlYWRlcnMucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBbbm9ybWFsaXplTmFtZShuYW1lKV0gPSBub3JtYWxpemVWYWx1ZSh2YWx1ZSk7XG4gIH07XG5cbiAgSGVhZGVycy5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzLm1hcCkge1xuICAgICAgaWYgKHRoaXMubWFwLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdGhpcy5tYXBbbmFtZV0sIG5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5rZXlzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGl0ZW1zLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGl0ZW1zID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICBpdGVtcy5wdXNoKFtuYW1lLCB2YWx1ZV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBpdGVyYXRvckZvcihpdGVtcylcbiAgfTtcblxuICBpZiAoc3VwcG9ydC5pdGVyYWJsZSkge1xuICAgIEhlYWRlcnMucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBIZWFkZXJzLnByb3RvdHlwZS5lbnRyaWVzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uc3VtZWQoYm9keSkge1xuICAgIGlmIChib2R5LmJvZHlVc2VkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcignQWxyZWFkeSByZWFkJykpXG4gICAgfVxuICAgIGJvZHkuYm9keVVzZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlsZVJlYWRlclJlYWR5KHJlYWRlcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZShyZWFkZXIucmVzdWx0KTtcbiAgICAgIH07XG4gICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZWplY3QocmVhZGVyLmVycm9yKTtcbiAgICAgIH07XG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNBcnJheUJ1ZmZlcihibG9iKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgdmFyIHByb21pc2UgPSBmaWxlUmVhZGVyUmVhZHkocmVhZGVyKTtcbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoYmxvYik7XG4gICAgcmV0dXJuIHByb21pc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRCbG9iQXNUZXh0KGJsb2IpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICB2YXIgcHJvbWlzZSA9IGZpbGVSZWFkZXJSZWFkeShyZWFkZXIpO1xuICAgIHJlYWRlci5yZWFkQXNUZXh0KGJsb2IpO1xuICAgIHJldHVybiBwcm9taXNlXG4gIH1cblxuICBmdW5jdGlvbiByZWFkQXJyYXlCdWZmZXJBc1RleHQoYnVmKSB7XG4gICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShidWYpO1xuICAgIHZhciBjaGFycyA9IG5ldyBBcnJheSh2aWV3Lmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZSh2aWV3W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoYXJzLmpvaW4oJycpXG4gIH1cblxuICBmdW5jdGlvbiBidWZmZXJDbG9uZShidWYpIHtcbiAgICBpZiAoYnVmLnNsaWNlKSB7XG4gICAgICByZXR1cm4gYnVmLnNsaWNlKDApXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ5dGVMZW5ndGgpO1xuICAgICAgdmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmKSk7XG4gICAgICByZXR1cm4gdmlldy5idWZmZXJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBCb2R5KCkge1xuICAgIHRoaXMuYm9keVVzZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuX2luaXRCb2R5ID0gZnVuY3Rpb24oYm9keSkge1xuICAgICAgLypcbiAgICAgICAgZmV0Y2gtbW9jayB3cmFwcyB0aGUgUmVzcG9uc2Ugb2JqZWN0IGluIGFuIEVTNiBQcm94eSB0b1xuICAgICAgICBwcm92aWRlIHVzZWZ1bCB0ZXN0IGhhcm5lc3MgZmVhdHVyZXMgc3VjaCBhcyBmbHVzaC4gSG93ZXZlciwgb25cbiAgICAgICAgRVM1IGJyb3dzZXJzIHdpdGhvdXQgZmV0Y2ggb3IgUHJveHkgc3VwcG9ydCBwb2xseWZpbGxzIG11c3QgYmUgdXNlZDtcbiAgICAgICAgdGhlIHByb3h5LXBvbGx5ZmlsbCBpcyB1bmFibGUgdG8gcHJveHkgYW4gYXR0cmlidXRlIHVubGVzcyBpdCBleGlzdHNcbiAgICAgICAgb24gdGhlIG9iamVjdCBiZWZvcmUgdGhlIFByb3h5IGlzIGNyZWF0ZWQuIFRoaXMgY2hhbmdlIGVuc3VyZXNcbiAgICAgICAgUmVzcG9uc2UuYm9keVVzZWQgZXhpc3RzIG9uIHRoZSBpbnN0YW5jZSwgd2hpbGUgbWFpbnRhaW5pbmcgdGhlXG4gICAgICAgIHNlbWFudGljIG9mIHNldHRpbmcgUmVxdWVzdC5ib2R5VXNlZCBpbiB0aGUgY29uc3RydWN0b3IgYmVmb3JlXG4gICAgICAgIF9pbml0Qm9keSBpcyBjYWxsZWQuXG4gICAgICAqL1xuICAgICAgdGhpcy5ib2R5VXNlZCA9IHRoaXMuYm9keVVzZWQ7XG4gICAgICB0aGlzLl9ib2R5SW5pdCA9IGJvZHk7XG4gICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgdGhpcy5fYm9keVRleHQgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX2JvZHlUZXh0ID0gYm9keTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5ibG9iICYmIEJsb2IucHJvdG90eXBlLmlzUHJvdG90eXBlT2YoYm9keSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUJsb2IgPSBib2R5O1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmZvcm1EYXRhICYmIEZvcm1EYXRhLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgIHRoaXMuX2JvZHlGb3JtRGF0YSA9IGJvZHk7XG4gICAgICB9IGVsc2UgaWYgKHN1cHBvcnQuc2VhcmNoUGFyYW1zICYmIFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkudG9TdHJpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5hcnJheUJ1ZmZlciAmJiBzdXBwb3J0LmJsb2IgJiYgaXNEYXRhVmlldyhib2R5KSkge1xuICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIgPSBidWZmZXJDbG9uZShib2R5LmJ1ZmZlcik7XG4gICAgICAgIC8vIElFIDEwLTExIGNhbid0IGhhbmRsZSBhIERhdGFWaWV3IGJvZHkuXG4gICAgICAgIHRoaXMuX2JvZHlJbml0ID0gbmV3IEJsb2IoW3RoaXMuX2JvZHlBcnJheUJ1ZmZlcl0pO1xuICAgICAgfSBlbHNlIGlmIChzdXBwb3J0LmFycmF5QnVmZmVyICYmIChBcnJheUJ1ZmZlci5wcm90b3R5cGUuaXNQcm90b3R5cGVPZihib2R5KSB8fCBpc0FycmF5QnVmZmVyVmlldyhib2R5KSkpIHtcbiAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyID0gYnVmZmVyQ2xvbmUoYm9keSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ib2R5VGV4dCA9IGJvZHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYm9keSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5zZXQoJ2NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QmxvYiAmJiB0aGlzLl9ib2R5QmxvYi50eXBlKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgdGhpcy5fYm9keUJsb2IudHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydC5zZWFyY2hQYXJhbXMgJiYgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mKGJvZHkpKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLnNldCgnY29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKHN1cHBvcnQuYmxvYikge1xuICAgICAgdGhpcy5ibG9iID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgICBpZiAocmVqZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gcmVqZWN0ZWRcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9ib2R5QmxvYikge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keUJsb2IpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShuZXcgQmxvYihbdGhpcy5fYm9keUFycmF5QnVmZmVyXSkpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjb3VsZCBub3QgcmVhZCBGb3JtRGF0YSBib2R5IGFzIGJsb2InKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IEJsb2IoW3RoaXMuX2JvZHlUZXh0XSkpXG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJyYXlCdWZmZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHlBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIHZhciBpc0NvbnN1bWVkID0gY29uc3VtZWQodGhpcyk7XG4gICAgICAgICAgaWYgKGlzQ29uc3VtZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0NvbnN1bWVkXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodGhpcy5fYm9keUFycmF5QnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShcbiAgICAgICAgICAgICAgdGhpcy5fYm9keUFycmF5QnVmZmVyLmJ1ZmZlci5zbGljZShcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCxcbiAgICAgICAgICAgICAgICB0aGlzLl9ib2R5QXJyYXlCdWZmZXIuYnl0ZU9mZnNldCArIHRoaXMuX2JvZHlBcnJheUJ1ZmZlci5ieXRlTGVuZ3RoXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0aGlzLmJsb2IoKS50aGVuKHJlYWRCbG9iQXNBcnJheUJ1ZmZlcilcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnRleHQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZWplY3RlZCA9IGNvbnN1bWVkKHRoaXMpO1xuICAgICAgaWYgKHJlamVjdGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3RlZFxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm9keUJsb2IpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRCbG9iQXNUZXh0KHRoaXMuX2JvZHlCbG9iKVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9ib2R5QXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFkQXJyYXlCdWZmZXJBc1RleHQodGhpcy5fYm9keUFycmF5QnVmZmVyKSlcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYm9keUZvcm1EYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY291bGQgbm90IHJlYWQgRm9ybURhdGEgYm9keSBhcyB0ZXh0JylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYm9keVRleHQpXG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmIChzdXBwb3J0LmZvcm1EYXRhKSB7XG4gICAgICB0aGlzLmZvcm1EYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQoKS50aGVuKGRlY29kZSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5qc29uID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50ZXh0KCkudGhlbihKU09OLnBhcnNlKVxuICAgIH07XG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gSFRUUCBtZXRob2RzIHdob3NlIGNhcGl0YWxpemF0aW9uIHNob3VsZCBiZSBub3JtYWxpemVkXG4gIHZhciBtZXRob2RzID0gWydERUxFVEUnLCAnR0VUJywgJ0hFQUQnLCAnT1BUSU9OUycsICdQT1NUJywgJ1BVVCddO1xuXG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZU1ldGhvZChtZXRob2QpIHtcbiAgICB2YXIgdXBjYXNlZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiBtZXRob2RzLmluZGV4T2YodXBjYXNlZCkgPiAtMSA/IHVwY2FzZWQgOiBtZXRob2RcbiAgfVxuXG4gIGZ1bmN0aW9uIFJlcXVlc3QoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVxdWVzdCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1BsZWFzZSB1c2UgdGhlIFwibmV3XCIgb3BlcmF0b3IsIHRoaXMgRE9NIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uJylcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keTtcblxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgIGlmIChpbnB1dC5ib2R5VXNlZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHJlYWR5IHJlYWQnKVxuICAgICAgfVxuICAgICAgdGhpcy51cmwgPSBpbnB1dC51cmw7XG4gICAgICB0aGlzLmNyZWRlbnRpYWxzID0gaW5wdXQuY3JlZGVudGlhbHM7XG4gICAgICBpZiAoIW9wdGlvbnMuaGVhZGVycykge1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBuZXcgSGVhZGVycyhpbnB1dC5oZWFkZXJzKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWV0aG9kID0gaW5wdXQubWV0aG9kO1xuICAgICAgdGhpcy5tb2RlID0gaW5wdXQubW9kZTtcbiAgICAgIHRoaXMuc2lnbmFsID0gaW5wdXQuc2lnbmFsO1xuICAgICAgaWYgKCFib2R5ICYmIGlucHV0Ll9ib2R5SW5pdCAhPSBudWxsKSB7XG4gICAgICAgIGJvZHkgPSBpbnB1dC5fYm9keUluaXQ7XG4gICAgICAgIGlucHV0LmJvZHlVc2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cmwgPSBTdHJpbmcoaW5wdXQpO1xuICAgIH1cblxuICAgIHRoaXMuY3JlZGVudGlhbHMgPSBvcHRpb25zLmNyZWRlbnRpYWxzIHx8IHRoaXMuY3JlZGVudGlhbHMgfHwgJ3NhbWUtb3JpZ2luJztcbiAgICBpZiAob3B0aW9ucy5oZWFkZXJzIHx8ICF0aGlzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMuaGVhZGVycyA9IG5ldyBIZWFkZXJzKG9wdGlvbnMuaGVhZGVycyk7XG4gICAgfVxuICAgIHRoaXMubWV0aG9kID0gbm9ybWFsaXplTWV0aG9kKG9wdGlvbnMubWV0aG9kIHx8IHRoaXMubWV0aG9kIHx8ICdHRVQnKTtcbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zLm1vZGUgfHwgdGhpcy5tb2RlIHx8IG51bGw7XG4gICAgdGhpcy5zaWduYWwgPSBvcHRpb25zLnNpZ25hbCB8fCB0aGlzLnNpZ25hbDtcbiAgICB0aGlzLnJlZmVycmVyID0gbnVsbDtcblxuICAgIGlmICgodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpICYmIGJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvZHkgbm90IGFsbG93ZWQgZm9yIEdFVCBvciBIRUFEIHJlcXVlc3RzJylcbiAgICB9XG4gICAgdGhpcy5faW5pdEJvZHkoYm9keSk7XG5cbiAgICBpZiAodGhpcy5tZXRob2QgPT09ICdHRVQnIHx8IHRoaXMubWV0aG9kID09PSAnSEVBRCcpIHtcbiAgICAgIGlmIChvcHRpb25zLmNhY2hlID09PSAnbm8tc3RvcmUnIHx8IG9wdGlvbnMuY2FjaGUgPT09ICduby1jYWNoZScpIHtcbiAgICAgICAgLy8gU2VhcmNoIGZvciBhICdfJyBwYXJhbWV0ZXIgaW4gdGhlIHF1ZXJ5IHN0cmluZ1xuICAgICAgICB2YXIgcmVQYXJhbVNlYXJjaCA9IC8oWz8mXSlfPVteJl0qLztcbiAgICAgICAgaWYgKHJlUGFyYW1TZWFyY2gudGVzdCh0aGlzLnVybCkpIHtcbiAgICAgICAgICAvLyBJZiBpdCBhbHJlYWR5IGV4aXN0cyB0aGVuIHNldCB0aGUgdmFsdWUgd2l0aCB0aGUgY3VycmVudCB0aW1lXG4gICAgICAgICAgdGhpcy51cmwgPSB0aGlzLnVybC5yZXBsYWNlKHJlUGFyYW1TZWFyY2gsICckMV89JyArIG5ldyBEYXRlKCkuZ2V0VGltZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGEgbmV3ICdfJyBwYXJhbWV0ZXIgdG8gdGhlIGVuZCB3aXRoIHRoZSBjdXJyZW50IHRpbWVcbiAgICAgICAgICB2YXIgcmVRdWVyeVN0cmluZyA9IC9cXD8vO1xuICAgICAgICAgIHRoaXMudXJsICs9IChyZVF1ZXJ5U3RyaW5nLnRlc3QodGhpcy51cmwpID8gJyYnIDogJz8nKSArICdfPScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFJlcXVlc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBSZXF1ZXN0KHRoaXMsIHtib2R5OiB0aGlzLl9ib2R5SW5pdH0pXG4gIH07XG5cbiAgZnVuY3Rpb24gZGVjb2RlKGJvZHkpIHtcbiAgICB2YXIgZm9ybSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGJvZHlcbiAgICAgIC50cmltKClcbiAgICAgIC5zcGxpdCgnJicpXG4gICAgICAuZm9yRWFjaChmdW5jdGlvbihieXRlcykge1xuICAgICAgICBpZiAoYnl0ZXMpIHtcbiAgICAgICAgICB2YXIgc3BsaXQgPSBieXRlcy5zcGxpdCgnPScpO1xuICAgICAgICAgIHZhciBuYW1lID0gc3BsaXQuc2hpZnQoKS5yZXBsYWNlKC9cXCsvZywgJyAnKTtcbiAgICAgICAgICB2YXIgdmFsdWUgPSBzcGxpdC5qb2luKCc9JykucmVwbGFjZSgvXFwrL2csICcgJyk7XG4gICAgICAgICAgZm9ybS5hcHBlbmQoZGVjb2RlVVJJQ29tcG9uZW50KG5hbWUpLCBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgcmV0dXJuIGZvcm1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhyYXdIZWFkZXJzKSB7XG4gICAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICAgIC8vIFJlcGxhY2UgaW5zdGFuY2VzIG9mIFxcclxcbiBhbmQgXFxuIGZvbGxvd2VkIGJ5IGF0IGxlYXN0IG9uZSBzcGFjZSBvciBob3Jpem9udGFsIHRhYiB3aXRoIGEgc3BhY2VcbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMCNzZWN0aW9uLTMuMlxuICAgIHZhciBwcmVQcm9jZXNzZWRIZWFkZXJzID0gcmF3SGVhZGVycy5yZXBsYWNlKC9cXHI/XFxuW1xcdCBdKy9nLCAnICcpO1xuICAgIC8vIEF2b2lkaW5nIHNwbGl0IHZpYSByZWdleCB0byB3b3JrIGFyb3VuZCBhIGNvbW1vbiBJRTExIGJ1ZyB3aXRoIHRoZSBjb3JlLWpzIDMuNi4wIHJlZ2V4IHBvbHlmaWxsXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2dpdGh1Yi9mZXRjaC9pc3N1ZXMvNzQ4XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzc1MVxuICAgIHByZVByb2Nlc3NlZEhlYWRlcnNcbiAgICAgIC5zcGxpdCgnXFxyJylcbiAgICAgIC5tYXAoZnVuY3Rpb24oaGVhZGVyKSB7XG4gICAgICAgIHJldHVybiBoZWFkZXIuaW5kZXhPZignXFxuJykgPT09IDAgPyBoZWFkZXIuc3Vic3RyKDEsIGhlYWRlci5sZW5ndGgpIDogaGVhZGVyXG4gICAgICB9KVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgICB2YXIgcGFydHMgPSBsaW5lLnNwbGl0KCc6Jyk7XG4gICAgICAgIHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpLnRyaW0oKTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcnRzLmpvaW4oJzonKS50cmltKCk7XG4gICAgICAgICAgaGVhZGVycy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIHJldHVybiBoZWFkZXJzXG4gIH1cblxuICBCb2R5LmNhbGwoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4gIGZ1bmN0aW9uIFJlc3BvbnNlKGJvZHlJbml0LCBvcHRpb25zKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUGxlYXNlIHVzZSB0aGUgXCJuZXdcIiBvcGVyYXRvciwgdGhpcyBET00gb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi4nKVxuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5zdGF0dXMgPSBvcHRpb25zLnN0YXR1cyA9PT0gdW5kZWZpbmVkID8gMjAwIDogb3B0aW9ucy5zdGF0dXM7XG4gICAgdGhpcy5vayA9IHRoaXMuc3RhdHVzID49IDIwMCAmJiB0aGlzLnN0YXR1cyA8IDMwMDtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBvcHRpb25zLnN0YXR1c1RleHQgPT09IHVuZGVmaW5lZCA/ICcnIDogJycgKyBvcHRpb25zLnN0YXR1c1RleHQ7XG4gICAgdGhpcy5oZWFkZXJzID0gbmV3IEhlYWRlcnMob3B0aW9ucy5oZWFkZXJzKTtcbiAgICB0aGlzLnVybCA9IG9wdGlvbnMudXJsIHx8ICcnO1xuICAgIHRoaXMuX2luaXRCb2R5KGJvZHlJbml0KTtcbiAgfVxuXG4gIEJvZHkuY2FsbChSZXNwb25zZS5wcm90b3R5cGUpO1xuXG4gIFJlc3BvbnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy5fYm9keUluaXQsIHtcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBzdGF0dXNUZXh0OiB0aGlzLnN0YXR1c1RleHQsXG4gICAgICBoZWFkZXJzOiBuZXcgSGVhZGVycyh0aGlzLmhlYWRlcnMpLFxuICAgICAgdXJsOiB0aGlzLnVybFxuICAgIH0pXG4gIH07XG5cbiAgUmVzcG9uc2UuZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UobnVsbCwge3N0YXR1czogMCwgc3RhdHVzVGV4dDogJyd9KTtcbiAgICByZXNwb25zZS50eXBlID0gJ2Vycm9yJztcbiAgICByZXR1cm4gcmVzcG9uc2VcbiAgfTtcblxuICB2YXIgcmVkaXJlY3RTdGF0dXNlcyA9IFszMDEsIDMwMiwgMzAzLCAzMDcsIDMwOF07XG5cbiAgUmVzcG9uc2UucmVkaXJlY3QgPSBmdW5jdGlvbih1cmwsIHN0YXR1cykge1xuICAgIGlmIChyZWRpcmVjdFN0YXR1c2VzLmluZGV4T2Yoc3RhdHVzKSA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHN0YXR1cyBjb2RlJylcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtzdGF0dXM6IHN0YXR1cywgaGVhZGVyczoge2xvY2F0aW9uOiB1cmx9fSlcbiAgfTtcblxuICBleHBvcnRzLkRPTUV4Y2VwdGlvbiA9IGdsb2JhbC5ET01FeGNlcHRpb247XG4gIHRyeSB7XG4gICAgbmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uID0gZnVuY3Rpb24obWVzc2FnZSwgbmFtZSkge1xuICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB2YXIgZXJyb3IgPSBFcnJvcihtZXNzYWdlKTtcbiAgICAgIHRoaXMuc3RhY2sgPSBlcnJvci5zdGFjaztcbiAgICB9O1xuICAgIGV4cG9ydHMuRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgICBleHBvcnRzLkRPTUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBleHBvcnRzLkRPTUV4Y2VwdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZldGNoKGlucHV0LCBpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgUmVxdWVzdChpbnB1dCwgaW5pdCk7XG5cbiAgICAgIGlmIChyZXF1ZXN0LnNpZ25hbCAmJiByZXF1ZXN0LnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHJldHVybiByZWplY3QobmV3IGV4cG9ydHMuRE9NRXhjZXB0aW9uKCdBYm9ydGVkJywgJ0Fib3J0RXJyb3InKSlcbiAgICAgIH1cblxuICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICBmdW5jdGlvbiBhYm9ydFhocigpIHtcbiAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICB9XG5cbiAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgc3RhdHVzOiB4aHIuc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHhoci5zdGF0dXNUZXh0LFxuICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkgfHwgJycpXG4gICAgICAgIH07XG4gICAgICAgIG9wdGlvbnMudXJsID0gJ3Jlc3BvbnNlVVJMJyBpbiB4aHIgPyB4aHIucmVzcG9uc2VVUkwgOiBvcHRpb25zLmhlYWRlcnMuZ2V0KCdYLVJlcXVlc3QtVVJMJyk7XG4gICAgICAgIHZhciBib2R5ID0gJ3Jlc3BvbnNlJyBpbiB4aHIgPyB4aHIucmVzcG9uc2UgOiB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKGJvZHksIG9wdGlvbnMpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgVHlwZUVycm9yKCdOZXR3b3JrIHJlcXVlc3QgZmFpbGVkJykpO1xuICAgICAgICB9LCAwKTtcbiAgICAgIH07XG5cbiAgICAgIHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZWplY3QobmV3IFR5cGVFcnJvcignTmV0d29yayByZXF1ZXN0IGZhaWxlZCcpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICB4aHIub25hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlamVjdChuZXcgZXhwb3J0cy5ET01FeGNlcHRpb24oJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICB9O1xuXG4gICAgICBmdW5jdGlvbiBmaXhVcmwodXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIHVybCA9PT0gJycgJiYgZ2xvYmFsLmxvY2F0aW9uLmhyZWYgPyBnbG9iYWwubG9jYXRpb24uaHJlZiA6IHVybFxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHVybFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHhoci5vcGVuKHJlcXVlc3QubWV0aG9kLCBmaXhVcmwocmVxdWVzdC51cmwpLCB0cnVlKTtcblxuICAgICAgaWYgKHJlcXVlc3QuY3JlZGVudGlhbHMgPT09ICdpbmNsdWRlJykge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVxdWVzdC5jcmVkZW50aWFscyA9PT0gJ29taXQnKSB7XG4gICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCdyZXNwb25zZVR5cGUnIGluIHhocikge1xuICAgICAgICBpZiAoc3VwcG9ydC5ibG9iKSB7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdibG9iJztcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBzdXBwb3J0LmFycmF5QnVmZmVyICYmXG4gICAgICAgICAgcmVxdWVzdC5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgJiZcbiAgICAgICAgICByZXF1ZXN0LmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKS5pbmRleE9mKCdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSAhPT0gLTFcbiAgICAgICAgKSB7XG4gICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGluaXQgJiYgdHlwZW9mIGluaXQuaGVhZGVycyA9PT0gJ29iamVjdCcgJiYgIShpbml0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSkge1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhpbml0LmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKG5hbWUsIG5vcm1hbGl6ZVZhbHVlKGluaXQuaGVhZGVyc1tuYW1lXSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcXVlc3QuaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIobmFtZSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlcXVlc3Quc2lnbmFsKSB7XG4gICAgICAgIHJlcXVlc3Quc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRYaHIpO1xuXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvLyBET05FIChzdWNjZXNzIG9yIGZhaWx1cmUpXG4gICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0WGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHhoci5zZW5kKHR5cGVvZiByZXF1ZXN0Ll9ib2R5SW5pdCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogcmVxdWVzdC5fYm9keUluaXQpO1xuICAgIH0pXG4gIH1cblxuICBmZXRjaC5wb2x5ZmlsbCA9IHRydWU7XG5cbiAgaWYgKCFnbG9iYWwuZmV0Y2gpIHtcbiAgICBnbG9iYWwuZmV0Y2ggPSBmZXRjaDtcbiAgICBnbG9iYWwuSGVhZGVycyA9IEhlYWRlcnM7XG4gICAgZ2xvYmFsLlJlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIGdsb2JhbC5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICB9XG5cbiAgZXhwb3J0cy5IZWFkZXJzID0gSGVhZGVycztcbiAgZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcbiAgZXhwb3J0cy5SZXNwb25zZSA9IFJlc3BvbnNlO1xuICBleHBvcnRzLmZldGNoID0gZmV0Y2g7XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpKTtcbiIsIi8vIFJldHVybnMgYSB3cmFwcGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHdyYXBwZWQgY2FsbGJhY2tcbi8vIFRoZSB3cmFwcGVyIGZ1bmN0aW9uIHNob3VsZCBkbyBzb21lIHN0dWZmLCBhbmQgcmV0dXJuIGFcbi8vIHByZXN1bWFibHkgZGlmZmVyZW50IGNhbGxiYWNrIGZ1bmN0aW9uLlxuLy8gVGhpcyBtYWtlcyBzdXJlIHRoYXQgb3duIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkLCBzbyB0aGF0XG4vLyBkZWNvcmF0aW9ucyBhbmQgc3VjaCBhcmUgbm90IGxvc3QgYWxvbmcgdGhlIHdheS5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHB5XG5mdW5jdGlvbiB3cmFwcHkgKGZuLCBjYikge1xuICBpZiAoZm4gJiYgY2IpIHJldHVybiB3cmFwcHkoZm4pKGNiKVxuXG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbmVlZCB3cmFwcGVyIGZ1bmN0aW9uJylcblxuICBPYmplY3Qua2V5cyhmbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIHdyYXBwZXJba10gPSBmbltrXVxuICB9KVxuXG4gIHJldHVybiB3cmFwcGVyXG5cbiAgZnVuY3Rpb24gd3JhcHBlcigpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgICB2YXIgcmV0ID0gZm4uYXBwbHkodGhpcywgYXJncylcbiAgICB2YXIgY2IgPSBhcmdzW2FyZ3MubGVuZ3RoLTFdXG4gICAgaWYgKHR5cGVvZiByZXQgPT09ICdmdW5jdGlvbicgJiYgcmV0ICE9PSBjYikge1xuICAgICAgT2JqZWN0LmtleXMoY2IpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0W2tdID0gY2Jba11cbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBTZWN1cml0eUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTZWN1cml0eUVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNlY3VyaXR5RXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFNlY3VyaXR5RXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLlNlY3VyaXR5RXJyb3IgPSBTZWN1cml0eUVycm9yO1xudmFyIEludmFsaWRTdGF0ZUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhJbnZhbGlkU3RhdGVFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBJbnZhbGlkU3RhdGVFcnJvcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gSW52YWxpZFN0YXRlRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLkludmFsaWRTdGF0ZUVycm9yID0gSW52YWxpZFN0YXRlRXJyb3I7XG52YXIgTmV0d29ya0Vycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOZXR3b3JrRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTmV0d29ya0Vycm9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBOZXR3b3JrRXJyb3I7XG59KEVycm9yKSk7XG5leHBvcnRzLk5ldHdvcmtFcnJvciA9IE5ldHdvcmtFcnJvcjtcbnZhciBTeW50YXhFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3ludGF4RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3ludGF4RXJyb3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFN5bnRheEVycm9yO1xufShFcnJvcikpO1xuZXhwb3J0cy5TeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZnVuY3Rpb24gX19leHBvcnQobSkge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKCFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBleHBvcnRzW3BdID0gbVtwXTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL3htbC1odHRwLXJlcXVlc3RcIikpO1xudmFyIHhtbF9odHRwX3JlcXVlc3RfZXZlbnRfdGFyZ2V0XzEgPSByZXF1aXJlKFwiLi94bWwtaHR0cC1yZXF1ZXN0LWV2ZW50LXRhcmdldFwiKTtcbmV4cG9ydHMuWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCA9IHhtbF9odHRwX3JlcXVlc3RfZXZlbnRfdGFyZ2V0XzEuWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFByb2dyZXNzRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvZ3Jlc3NFdmVudCh0eXBlKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYnViYmxlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSAwO1xuICAgICAgICB0aGlzLmxlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBQcm9ncmVzc0V2ZW50O1xufSgpKTtcbmV4cG9ydHMuUHJvZ3Jlc3NFdmVudCA9IFByb2dyZXNzRXZlbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9ncmVzcy1ldmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBldmVudFR5cGUgPSBldmVudFR5cGUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0gfHwgW107XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0ucHVzaChsaXN0ZW5lci5oYW5kbGVFdmVudCB8fCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV0uaW5kZXhPZihsaXN0ZW5lci5oYW5kbGVFdmVudCB8fCBsaXN0ZW5lcik7XG4gICAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3RlbmVyc1tldmVudFR5cGVdLnNwbGljZShpbmRleCwgMSk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBldmVudFR5cGUgPSBldmVudC50eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGV2ZW50LnRhcmdldCA9IHRoaXM7IC8vIFRPRE86IHNldCBldmVudC5jdXJyZW50VGFyZ2V0P1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnNbZXZlbnRUeXBlXSkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHRoaXMubGlzdGVuZXJzW2V2ZW50VHlwZV07IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyXzEgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJfMS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdGVuZXIgPSB0aGlzW1wib25cIiArIGV2ZW50VHlwZV07XG4gICAgICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICByZXR1cm4gWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldDtcbn0oKSk7XG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQgPSBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eG1sLWh0dHAtcmVxdWVzdC1ldmVudC10YXJnZXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB4bWxfaHR0cF9yZXF1ZXN0X2V2ZW50X3RhcmdldF8xID0gcmVxdWlyZShcIi4veG1sLWh0dHAtcmVxdWVzdC1ldmVudC10YXJnZXRcIik7XG52YXIgWE1MSHR0cFJlcXVlc3RVcGxvYWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFhNTEh0dHBSZXF1ZXN0VXBsb2FkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFhNTEh0dHBSZXF1ZXN0VXBsb2FkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY29udGVudFR5cGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5fYm9keSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9yZXNldCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFhNTEh0dHBSZXF1ZXN0VXBsb2FkLnByb3RvdHlwZS5fcmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRUeXBlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fYm9keSA9IG51bGw7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3NldERhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY29udGVudFR5cGUgPSAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JvZHkgPSBuZXcgQnVmZmVyKGRhdGEsICd1dGYtOCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgdGhpcy5fYm9keSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCdWZmZXIoZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYm9keVtpXSA9IHZpZXdbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ib2R5ID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkYXRhLmJ1ZmZlciAmJiBkYXRhLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICB2YXIgYm9keSA9IG5ldyBCdWZmZXIoZGF0YS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQ7XG4gICAgICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGRhdGEuYnVmZmVyKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5ieXRlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBib2R5W2ldID0gdmlld1tpICsgb2Zmc2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2JvZHkgPSBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgc2VuZCgpIGRhdGEgXCIgKyBkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3RVcGxvYWQucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbiAoaGVhZGVycywgbG93ZXJlZEhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvbnRlbnRUeXBlICYmICFsb3dlcmVkSGVhZGVyc1snY29udGVudC10eXBlJ10pIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdGhpcy5fY29udGVudFR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2JvZHkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbJ0NvbnRlbnQtTGVuZ3RoJ10gPSB0aGlzLl9ib2R5Lmxlbmd0aC50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdFVwbG9hZC5wcm90b3R5cGUuX3N0YXJ0VXBsb2FkID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX2JvZHkpIHtcbiAgICAgICAgICAgIHJlcXVlc3Qud3JpdGUodGhpcy5fYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5lbmQoKTtcbiAgICB9O1xuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdFVwbG9hZDtcbn0oeG1sX2h0dHBfcmVxdWVzdF9ldmVudF90YXJnZXRfMS5YTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KSk7XG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0VXBsb2FkID0gWE1MSHR0cFJlcXVlc3RVcGxvYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14bWwtaHR0cC1yZXF1ZXN0LXVwbG9hZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xudmFyIGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xudmFyIG9zID0gcmVxdWlyZShcIm9zXCIpO1xudmFyIHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG52YXIgcHJvZ3Jlc3NfZXZlbnRfMSA9IHJlcXVpcmUoXCIuL3Byb2dyZXNzLWV2ZW50XCIpO1xudmFyIGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xudmFyIHhtbF9odHRwX3JlcXVlc3RfZXZlbnRfdGFyZ2V0XzEgPSByZXF1aXJlKFwiLi94bWwtaHR0cC1yZXF1ZXN0LWV2ZW50LXRhcmdldFwiKTtcbnZhciB4bWxfaHR0cF9yZXF1ZXN0X3VwbG9hZF8xID0gcmVxdWlyZShcIi4veG1sLWh0dHAtcmVxdWVzdC11cGxvYWRcIik7XG52YXIgQ29va2llID0gcmVxdWlyZShcImNvb2tpZWphclwiKTtcbnZhciBYTUxIdHRwUmVxdWVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWE1MSHR0cFJlcXVlc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gWE1MSHR0cFJlcXVlc3Qob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5VTlNFTlQgPSBYTUxIdHRwUmVxdWVzdC5VTlNFTlQ7XG4gICAgICAgIF90aGlzLk9QRU5FRCA9IFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRDtcbiAgICAgICAgX3RoaXMuSEVBREVSU19SRUNFSVZFRCA9IFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQ7XG4gICAgICAgIF90aGlzLkxPQURJTkcgPSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HO1xuICAgICAgICBfdGhpcy5ET05FID0gWE1MSHR0cFJlcXVlc3QuRE9ORTtcbiAgICAgICAgX3RoaXMub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgX3RoaXMucmVhZHlTdGF0ZSA9IFhNTEh0dHBSZXF1ZXN0LlVOU0VOVDtcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgICBfdGhpcy5yZXNwb25zZVRleHQgPSAnJztcbiAgICAgICAgX3RoaXMucmVzcG9uc2VUeXBlID0gJyc7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9IDA7IC8vIFRPRE86IFVOU0VOVD9cbiAgICAgICAgX3RoaXMuc3RhdHVzVGV4dCA9ICcnO1xuICAgICAgICBfdGhpcy50aW1lb3V0ID0gMDtcbiAgICAgICAgX3RoaXMudXBsb2FkID0gbmV3IHhtbF9odHRwX3JlcXVlc3RfdXBsb2FkXzEuWE1MSHR0cFJlcXVlc3RVcGxvYWQoKTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2VVcmwgPSAnJztcbiAgICAgICAgX3RoaXMud2l0aENyZWRlbnRpYWxzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9tZXRob2QgPSBudWxsO1xuICAgICAgICBfdGhpcy5fdXJsID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3N5bmMgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgX3RoaXMuX2xvd2VyZWRIZWFkZXJzID0ge307XG4gICAgICAgIF90aGlzLl9taW1lT3ZlcnJpZGUgPSBudWxsOyAvLyBUT0RPOiBpcyB0eXBlIHJpZ2h0P1xuICAgICAgICBfdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICAgIF90aGlzLl9yZXNwb25zZSA9IG51bGw7XG4gICAgICAgIF90aGlzLl9yZXNwb25zZVBhcnRzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IG51bGw7XG4gICAgICAgIF90aGlzLl9hYm9ydGluZyA9IG51bGw7IC8vIFRPRE86IHR5cGU/XG4gICAgICAgIF90aGlzLl9lcnJvciA9IG51bGw7IC8vIFRPRE86IHR5cGU/XG4gICAgICAgIF90aGlzLl9sb2FkZWRCeXRlcyA9IDA7XG4gICAgICAgIF90aGlzLl90b3RhbEJ5dGVzID0gMDtcbiAgICAgICAgX3RoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuX3Jlc3RyaWN0ZWRNZXRob2RzID0geyBDT05ORUNUOiB0cnVlLCBUUkFDRTogdHJ1ZSwgVFJBQ0s6IHRydWUgfTtcbiAgICAgICAgX3RoaXMuX3Jlc3RyaWN0ZWRIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2FjY2VwdC1jaGFyc2V0JzogdHJ1ZSxcbiAgICAgICAgICAgICdhY2NlcHQtZW5jb2RpbmcnOiB0cnVlLFxuICAgICAgICAgICAgJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycyc6IHRydWUsXG4gICAgICAgICAgICAnYWNjZXNzLWNvbnRyb2wtcmVxdWVzdC1tZXRob2QnOiB0cnVlLFxuICAgICAgICAgICAgY29ubmVjdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICdjb250ZW50LWxlbmd0aCc6IHRydWUsXG4gICAgICAgICAgICBjb29raWU6IHRydWUsXG4gICAgICAgICAgICBjb29raWUyOiB0cnVlLFxuICAgICAgICAgICAgZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGRudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIGhvc3Q6IHRydWUsXG4gICAgICAgICAgICAna2VlcC1hbGl2ZSc6IHRydWUsXG4gICAgICAgICAgICBvcmlnaW46IHRydWUsXG4gICAgICAgICAgICByZWZlcmVyOiB0cnVlLFxuICAgICAgICAgICAgdGU6IHRydWUsXG4gICAgICAgICAgICB0cmFpbGVyOiB0cnVlLFxuICAgICAgICAgICAgJ3RyYW5zZmVyLWVuY29kaW5nJzogdHJ1ZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRydWUsXG4gICAgICAgICAgICAndXNlci1hZ2VudCc6IHRydWUsXG4gICAgICAgICAgICB2aWE6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuX3ByaXZhdGVIZWFkZXJzID0geyAnc2V0LWNvb2tpZSc6IHRydWUsICdzZXQtY29va2llMic6IHRydWUgfTtcbiAgICAgICAgX3RoaXMuX3VzZXJBZ2VudCA9IFwiTW96aWxsYS81LjAgKFwiICsgb3MudHlwZSgpICsgXCIgXCIgKyBvcy5hcmNoKCkgKyBcIikgbm9kZS5qcy9cIiArIHByb2Nlc3MudmVyc2lvbnMubm9kZSArIFwiIHY4L1wiICsgcHJvY2Vzcy52ZXJzaW9ucy52ODtcbiAgICAgICAgX3RoaXMuX2Fub255bW91cyA9IG9wdGlvbnMuYW5vbiB8fCBmYWxzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUub3BlbiA9IGZ1bmN0aW9uIChtZXRob2QsIHVybCwgYXN5bmMsIHVzZXIsIHBhc3N3b3JkKSB7XG4gICAgICAgIGlmIChhc3luYyA9PT0gdm9pZCAwKSB7IGFzeW5jID0gdHJ1ZTsgfVxuICAgICAgICBtZXRob2QgPSBtZXRob2QudG9VcHBlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3RyaWN0ZWRNZXRob2RzW21ldGhvZF0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBYTUxIdHRwUmVxdWVzdC5TZWN1cml0eUVycm9yKFwiSFRUUCBtZXRob2QgXCIgKyBtZXRob2QgKyBcIiBpcyBub3QgYWxsb3dlZCBpbiBYSFJcIik7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICB2YXIgeGhyVXJsID0gdGhpcy5fcGFyc2VVcmwodXJsLCB1c2VyLCBwYXNzd29yZCk7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkhFQURFUlNfUkVDRUlWRUQgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5MT0FESU5HKSB7XG4gICAgICAgICAgICAvLyBUT0RPKHB3bmFsbCk6IHRlcm1pbmF0ZSBhYm9ydCgpLCB0ZXJtaW5hdGUgc2VuZCgpXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xuICAgICAgICB0aGlzLl91cmwgPSB4aHJVcmw7XG4gICAgICAgIHRoaXMuX3N5bmMgPSAhYXN5bmM7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fbG93ZXJlZEhlYWRlcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fbWltZU92ZXJyaWRlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5PUEVORUQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IDA7XG4gICAgICAgIHRoaXMuc3RhdHVzVGV4dCA9ICcnO1xuICAgICAgICB0aGlzLl9yZXNwb25zZVBhcnRzID0gW107XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVycyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xvYWRlZEJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy5fdG90YWxCeXRlcyA9IDA7XG4gICAgICAgIHRoaXMuX2xlbmd0aENvbXB1dGFibGUgPSBmYWxzZTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZXRSZXF1ZXN0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFhNTEh0dHBSZXF1ZXN0LkludmFsaWRTdGF0ZUVycm9yKCdYSFIgcmVhZHlTdGF0ZSBtdXN0IGJlIE9QRU5FRCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb3dlcmVkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRoaXMuX3Jlc3RyaWN0ZWRIZWFkZXJzW2xvd2VyZWROYW1lXSB8fCAvXnNlYy0vLnRlc3QobG93ZXJlZE5hbWUpIHx8IC9ecHJveHktLy50ZXN0KGxvd2VyZWROYW1lKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUmVmdXNlZCB0byBzZXQgdW5zYWZlIGhlYWRlciBcXFwiXCIgKyBuYW1lICsgXCJcXFwiXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHRoaXMuX2xvd2VyZWRIZWFkZXJzW2xvd2VyZWROYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5fbG93ZXJlZEhlYWRlcnNbbG93ZXJlZE5hbWVdO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyc1tuYW1lXSA9IHRoaXMuX2hlYWRlcnNbbmFtZV0gKyBcIiwgXCIgKyB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xvd2VyZWRIZWFkZXJzW2xvd2VyZWROYW1lXSA9IG5hbWU7XG4gICAgICAgICAgICB0aGlzLl9oZWFkZXJzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuT1BFTkVEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWE1MSHR0cFJlcXVlc3QuSW52YWxpZFN0YXRlRXJyb3IoJ1hIUiByZWFkeVN0YXRlIG11c3QgYmUgT1BFTkVEJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBYTUxIdHRwUmVxdWVzdC5JbnZhbGlkU3RhdGVFcnJvcignc2VuZCgpIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLl91cmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZpbGU6JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc2VuZEZpbGUoZGF0YSk7XG4gICAgICAgICAgICBjYXNlICdodHRwOic6XG4gICAgICAgICAgICBjYXNlICdodHRwczonOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kSHR0cChkYXRhKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFhNTEh0dHBSZXF1ZXN0Lk5ldHdvcmtFcnJvcihcIlVuc3VwcG9ydGVkIHByb3RvY29sIFwiICsgdGhpcy5fdXJsLnByb3RvY29sKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdhYm9ydCcpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2VIZWFkZXJzID09IG51bGwgfHwgbmFtZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG93ZXJlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNwb25zZUhlYWRlcnMuaGFzT3duUHJvcGVydHkobG93ZXJlZE5hbWUpXG4gICAgICAgICAgICA/IHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2VIZWFkZXJzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fcmVzcG9uc2VIZWFkZXJzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5ICsgXCI6IFwiICsgX3RoaXMuX3Jlc3BvbnNlSGVhZGVyc1trZXldOyB9KS5qb2luKCdcXHJcXG4nKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5vdmVycmlkZU1pbWVUeXBlID0gZnVuY3Rpb24gKG1pbWVUeXBlKSB7XG4gICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFhNTEh0dHBSZXF1ZXN0LkxPQURJTkcgfHwgdGhpcy5yZWFkeVN0YXRlID09PSBYTUxIdHRwUmVxdWVzdC5ET05FKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgWE1MSHR0cFJlcXVlc3QuSW52YWxpZFN0YXRlRXJyb3IoJ292ZXJyaWRlTWltZVR5cGUoKSBub3QgYWxsb3dlZCBpbiBMT0FESU5HIG9yIERPTkUnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9taW1lT3ZlcnJpZGUgPSBtaW1lVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLm5vZGVqc1NldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMubm9kZWpzSHR0cEFnZW50ID0gb3B0aW9ucy5odHRwQWdlbnQgfHwgdGhpcy5ub2RlanNIdHRwQWdlbnQ7XG4gICAgICAgIHRoaXMubm9kZWpzSHR0cHNBZ2VudCA9IG9wdGlvbnMuaHR0cHNBZ2VudCB8fCB0aGlzLm5vZGVqc0h0dHBzQWdlbnQ7XG4gICAgICAgIGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KCdiYXNlVXJsJykpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJhc2VVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZWRVcmwgPSB1cmwucGFyc2Uob3B0aW9ucy5iYXNlVXJsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFhNTEh0dHBSZXF1ZXN0LlN5bnRheEVycm9yKFwiYmFzZVVybCBtdXN0IGJlIGFuIGFic29sdXRlIFVSTFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vZGVqc0Jhc2VVcmwgPSBvcHRpb25zLmJhc2VVcmw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0Lm5vZGVqc1NldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNTZXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NldFJlYWR5U3RhdGUgPSBmdW5jdGlvbiAocmVhZHlTdGF0ZSkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSByZWFkeVN0YXRlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IHByb2dyZXNzX2V2ZW50XzEuUHJvZ3Jlc3NFdmVudCgncmVhZHlzdGF0ZWNoYW5nZScpKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fc2VuZEZpbGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvdG9jb2wgZmlsZTogbm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3NlbmRIdHRwID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKHRoaXMuX3N5bmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3luY2hyb25vdXMgWEhSIHByb2Nlc3Npbmcgbm90IGltcGxlbWVudGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEgJiYgKHRoaXMuX21ldGhvZCA9PT0gJ0dFVCcgfHwgdGhpcy5fbWV0aG9kID09PSAnSEVBRCcpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEaXNjYXJkaW5nIGVudGl0eSBib2R5IGZvciBcIiArIHRoaXMuX21ldGhvZCArIFwiIHJlcXVlc3RzXCIpO1xuICAgICAgICAgICAgZGF0YSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkYXRhID0gZGF0YSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwbG9hZC5fc2V0RGF0YShkYXRhKTtcbiAgICAgICAgdGhpcy5fZmluYWxpemVIZWFkZXJzKCk7XG4gICAgICAgIHRoaXMuX3NlbmRIeHhwUmVxdWVzdCgpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZW5kSHh4cFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLndpdGhDcmVkZW50aWFscykge1xuICAgICAgICAgICAgdmFyIGNvb2tpZSA9IFhNTEh0dHBSZXF1ZXN0LmNvb2tpZUphclxuICAgICAgICAgICAgICAgIC5nZXRDb29raWVzKENvb2tpZS5Db29raWVBY2Nlc3NJbmZvKHRoaXMuX3VybC5ob3N0bmFtZSwgdGhpcy5fdXJsLnBhdGhuYW1lLCB0aGlzLl91cmwucHJvdG9jb2wgPT09ICdodHRwczonKSkudG9WYWx1ZVN0cmluZygpO1xuICAgICAgICAgICAgdGhpcy5faGVhZGVycy5jb29raWUgPSB0aGlzLl9oZWFkZXJzLmNvb2tpZTIgPSBjb29raWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5fdXJsLnByb3RvY29sID09PSAnaHR0cDonID8gW2h0dHAsIHRoaXMubm9kZWpzSHR0cEFnZW50XSA6IFtodHRwcywgdGhpcy5ub2RlanNIdHRwc0FnZW50XSwgaHh4cCA9IF9hWzBdLCBhZ2VudCA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVxdWVzdE1ldGhvZCA9IGh4eHAucmVxdWVzdC5iaW5kKGh4eHApO1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHJlcXVlc3RNZXRob2Qoe1xuICAgICAgICAgICAgaG9zdG5hbWU6IHRoaXMuX3VybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6ICt0aGlzLl91cmwucG9ydCxcbiAgICAgICAgICAgIHBhdGg6IHRoaXMuX3VybC5wYXRoLFxuICAgICAgICAgICAgYXV0aDogdGhpcy5fdXJsLmF1dGgsXG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMuX21ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMuX2hlYWRlcnMsXG4gICAgICAgICAgICBhZ2VudDogYWdlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICAgICAgICByZXF1ZXN0LnNldFRpbWVvdXQodGhpcy50aW1lb3V0LCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25IdHRwVGltZW91dChyZXF1ZXN0KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdC5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzcG9uc2UpIHsgcmV0dXJuIF90aGlzLl9vbkh0dHBSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSk7IH0pO1xuICAgICAgICByZXF1ZXN0Lm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gX3RoaXMuX29uSHR0cFJlcXVlc3RFcnJvcihyZXF1ZXN0LCBlcnJvcik7IH0pO1xuICAgICAgICB0aGlzLnVwbG9hZC5fc3RhcnRVcGxvYWQocmVxdWVzdCk7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ID09PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2Fkc3RhcnQnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9maW5hbGl6ZUhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSBfX2Fzc2lnbih7fSwgdGhpcy5faGVhZGVycywgeyBDb25uZWN0aW9uOiAna2VlcC1hbGl2ZScsIEhvc3Q6IHRoaXMuX3VybC5ob3N0LCAnVXNlci1BZ2VudCc6IHRoaXMuX3VzZXJBZ2VudCB9LCB0aGlzLl9hbm9ueW1vdXMgPyB7IFJlZmVyZXI6ICdhYm91dDpibGFuaycgfSA6IHt9KTtcbiAgICAgICAgdGhpcy51cGxvYWQuX2ZpbmFsaXplSGVhZGVycyh0aGlzLl9oZWFkZXJzLCB0aGlzLl9sb3dlcmVkSGVhZGVycyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlID0gZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2l0aENyZWRlbnRpYWxzICYmIChyZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llJ10gfHwgcmVzcG9uc2UuaGVhZGVyc1snc2V0LWNvb2tpZTInXSkpIHtcbiAgICAgICAgICAgIFhNTEh0dHBSZXF1ZXN0LmNvb2tpZUphclxuICAgICAgICAgICAgICAgIC5zZXRDb29raWVzKHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXSB8fCByZXNwb25zZS5oZWFkZXJzWydzZXQtY29va2llMiddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoWzMwMSwgMzAyLCAzMDMsIDMwNywgMzA4XS5pbmRleE9mKHJlc3BvbnNlLnN0YXR1c0NvZGUpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3VybCA9IHRoaXMuX3BhcnNlVXJsKHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5fbWV0aG9kID0gJ0dFVCc7XG4gICAgICAgICAgICBpZiAodGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbdGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbG93ZXJlZEhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuX2hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1snQ29udGVudC1UeXBlJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1snQ29udGVudC1MZW5ndGgnXTtcbiAgICAgICAgICAgIHRoaXMudXBsb2FkLl9yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fZmluYWxpemVIZWFkZXJzKCk7XG4gICAgICAgICAgICB0aGlzLl9zZW5kSHh4cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICB0aGlzLl9yZXNwb25zZS5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7IHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VEYXRhKHJlc3BvbnNlLCBkYXRhKTsgfSk7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fb25IdHRwUmVzcG9uc2VFbmQocmVzcG9uc2UpOyB9KTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2Uub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uSHR0cFJlc3BvbnNlQ2xvc2UocmVzcG9uc2UpOyB9KTtcbiAgICAgICAgdGhpcy5yZXNwb25zZVVybCA9IHRoaXMuX3VybC5ocmVmLnNwbGl0KCcjJylbMF07XG4gICAgICAgIHRoaXMuc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgICAgdGhpcy5zdGF0dXNUZXh0ID0gaHR0cC5TVEFUVVNfQ09ERVNbdGhpcy5zdGF0dXNdO1xuICAgICAgICB0aGlzLl9wYXJzZVJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgICAgIHZhciBsZW5ndGhTdHJpbmcgPSB0aGlzLl9yZXNwb25zZUhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ10gfHwgJyc7XG4gICAgICAgIHRoaXMuX3RvdGFsQnl0ZXMgPSArbGVuZ3RoU3RyaW5nO1xuICAgICAgICB0aGlzLl9sZW5ndGhDb21wdXRhYmxlID0gISFsZW5ndGhTdHJpbmc7XG4gICAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX29uSHR0cFJlc3BvbnNlRGF0YSA9IGZ1bmN0aW9uIChyZXNwb25zZSwgZGF0YSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cy5wdXNoKG5ldyBCdWZmZXIoZGF0YSkpO1xuICAgICAgICB0aGlzLl9sb2FkZWRCeXRlcyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuTE9BRElORykge1xuICAgICAgICAgICAgdGhpcy5fc2V0UmVhZHlTdGF0ZShYTUxIdHRwUmVxdWVzdC5MT0FESU5HKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdwcm9ncmVzcycpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9vbkh0dHBSZXNwb25zZUVuZCA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGFyc2VSZXNwb25zZSgpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2UgPSBudWxsO1xuICAgICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkJyk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVzcG9uc2VDbG9zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVzcG9uc2UgIT09IHJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3QgPSB0aGlzLl9yZXF1ZXN0O1xuICAgICAgICB0aGlzLl9zZXRFcnJvcigpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHRoaXMuX3NldFJlYWR5U3RhdGUoWE1MSHR0cFJlcXVlc3QuRE9ORSk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2Vycm9yJyk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwVGltZW91dCA9IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCd0aW1lb3V0Jyk7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUHJvZ3Jlc3MoJ2xvYWRlbmQnKTtcbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fb25IdHRwUmVxdWVzdEVycm9yID0gZnVuY3Rpb24gKHJlcXVlc3QsIGVycm9yKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXF1ZXN0ICE9PSByZXF1ZXN0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2V0RXJyb3IoKTtcbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICB0aGlzLl9zZXRSZWFkeVN0YXRlKFhNTEh0dHBSZXF1ZXN0LkRPTkUpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdlcnJvcicpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaFByb2dyZXNzKCdsb2FkZW5kJyk7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX2Rpc3BhdGNoUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBYTUxIdHRwUmVxdWVzdC5Qcm9ncmVzc0V2ZW50KGV2ZW50VHlwZSk7XG4gICAgICAgIGV2ZW50Lmxlbmd0aENvbXB1dGFibGUgPSB0aGlzLl9sZW5ndGhDb21wdXRhYmxlO1xuICAgICAgICBldmVudC5sb2FkZWQgPSB0aGlzLl9sb2FkZWRCeXRlcztcbiAgICAgICAgZXZlbnQudG90YWwgPSB0aGlzLl90b3RhbEJ5dGVzO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9zZXRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IG51bGw7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2VQYXJ0cyA9IG51bGw7XG4gICAgfTtcbiAgICBYTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUuX3BhcnNlVXJsID0gZnVuY3Rpb24gKHVybFN0cmluZywgdXNlciwgcGFzc3dvcmQpIHtcbiAgICAgICAgdmFyIGFic29sdXRlVXJsID0gdGhpcy5ub2RlanNCYXNlVXJsID09IG51bGwgPyB1cmxTdHJpbmcgOiB1cmwucmVzb2x2ZSh0aGlzLm5vZGVqc0Jhc2VVcmwsIHVybFN0cmluZyk7XG4gICAgICAgIHZhciB4aHJVcmwgPSB1cmwucGFyc2UoYWJzb2x1dGVVcmwsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgeGhyVXJsLmhhc2ggPSBudWxsO1xuICAgICAgICB2YXIgX2EgPSAoeGhyVXJsLmF1dGggfHwgJycpLnNwbGl0KCc6JyksIHhoclVzZXIgPSBfYVswXSwgeGhyUGFzc3dvcmQgPSBfYVsxXTtcbiAgICAgICAgaWYgKHhoclVzZXIgfHwgeGhyUGFzc3dvcmQgfHwgdXNlciB8fCBwYXNzd29yZCkge1xuICAgICAgICAgICAgeGhyVXJsLmF1dGggPSAodXNlciB8fCB4aHJVc2VyIHx8ICcnKSArIFwiOlwiICsgKHBhc3N3b3JkIHx8IHhoclBhc3N3b3JkIHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geGhyVXJsO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlSGVhZGVycyA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB0aGlzLl9yZXNwb25zZUhlYWRlcnMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIHJlc3BvbnNlLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHZhciBsb3dlcmVkTmFtZSA9IG5hbWVfMS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByaXZhdGVIZWFkZXJzW2xvd2VyZWROYW1lXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2VIZWFkZXJzW2xvd2VyZWROYW1lXSA9IHJlc3BvbnNlLmhlYWRlcnNbbmFtZV8xXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fbWltZU92ZXJyaWRlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc3BvbnNlSGVhZGVyc1snY29udGVudC10eXBlJ10gPSB0aGlzLl9taW1lT3ZlcnJpZGU7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQodGhpcy5fcmVzcG9uc2VQYXJ0cyk7XG4gICAgICAgIHRoaXMuX3Jlc3BvbnNlUGFydHMgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlICdqc29uJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZSA9IEpTT04ucGFyc2UoYnVmZmVyLnRvU3RyaW5nKCd1dGYtOCcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2VUZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5YnVmZmVyJzpcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlVGV4dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdbaV0gPSBidWZmZXJbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBhcnJheUJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBidWZmZXIudG9TdHJpbmcodGhpcy5fcGFyc2VSZXNwb25zZUVuY29kaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNwb25zZVRleHQgPSBidWZmZXIudG9TdHJpbmcoJ2JpbmFyeScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnJlc3BvbnNlID0gdGhpcy5yZXNwb25zZVRleHQ7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZUVuY29kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gLztcXHMqY2hhcnNldD0oLiopJC8uZXhlYyh0aGlzLl9yZXNwb25zZUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnKVsxXSB8fCAndXRmLTgnO1xuICAgIH07XG4gICAgWE1MSHR0cFJlcXVlc3QuUHJvZ3Jlc3NFdmVudCA9IHByb2dyZXNzX2V2ZW50XzEuUHJvZ3Jlc3NFdmVudDtcbiAgICBYTUxIdHRwUmVxdWVzdC5JbnZhbGlkU3RhdGVFcnJvciA9IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yO1xuICAgIFhNTEh0dHBSZXF1ZXN0Lk5ldHdvcmtFcnJvciA9IGVycm9yc18xLk5ldHdvcmtFcnJvcjtcbiAgICBYTUxIdHRwUmVxdWVzdC5TZWN1cml0eUVycm9yID0gZXJyb3JzXzEuU2VjdXJpdHlFcnJvcjtcbiAgICBYTUxIdHRwUmVxdWVzdC5TeW50YXhFcnJvciA9IGVycm9yc18xLlN5bnRheEVycm9yO1xuICAgIFhNTEh0dHBSZXF1ZXN0LlhNTEh0dHBSZXF1ZXN0VXBsb2FkID0geG1sX2h0dHBfcmVxdWVzdF91cGxvYWRfMS5YTUxIdHRwUmVxdWVzdFVwbG9hZDtcbiAgICBYTUxIdHRwUmVxdWVzdC5VTlNFTlQgPSAwO1xuICAgIFhNTEh0dHBSZXF1ZXN0Lk9QRU5FRCA9IDE7XG4gICAgWE1MSHR0cFJlcXVlc3QuSEVBREVSU19SRUNFSVZFRCA9IDI7XG4gICAgWE1MSHR0cFJlcXVlc3QuTE9BRElORyA9IDM7XG4gICAgWE1MSHR0cFJlcXVlc3QuRE9ORSA9IDQ7XG4gICAgWE1MSHR0cFJlcXVlc3QuY29va2llSmFyID0gQ29va2llLkNvb2tpZUphcigpO1xuICAgIHJldHVybiBYTUxIdHRwUmVxdWVzdDtcbn0oeG1sX2h0dHBfcmVxdWVzdF9ldmVudF90YXJnZXRfMS5YTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0KSk7XG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0gWE1MSHR0cFJlcXVlc3Q7XG5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzSHR0cEFnZW50ID0gaHR0cC5nbG9iYWxBZ2VudDtcblhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZS5ub2RlanNIdHRwc0FnZW50ID0gaHR0cHMuZ2xvYmFsQWdlbnQ7XG5YTUxIdHRwUmVxdWVzdC5wcm90b3R5cGUubm9kZWpzQmFzZVVybCA9IG51bGw7XG4vLyMgc291cmNlTWFwcGluZ1VSTD14bWwtaHR0cC1yZXF1ZXN0LmpzLm1hcCIsIm1vZHVsZS5leHBvcnRzID0gWE1MSHR0cFJlcXVlc3Q7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwiZXhwb3J0IGNvbnN0IEFMRVJUX1RZUEVTID0ge1xyXG4gIHVuY29ubmVjdGVkQWNjb3VudDogJ3VuY29ubmVjdGVkQWNjb3VudCcsXHJcbiAgd2ViM1NoaW1Vc2FnZTogJ3dlYjNTaGltVXNhZ2UnLFxyXG4gIGludmFsaWRDdXN0b21OZXR3b3JrOiAnaW52YWxpZEN1c3RvbU5ldHdvcmsnLFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFsZXJ0cyB0aGF0IGNhbiBiZSBlbmFibGVkIG9yIGRpc2FibGVkIGJ5IHRoZSB1c2VyLlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFRPR0dMRUFCTEVfQUxFUlRfVFlQRVMgPSBbXHJcbiAgQUxFUlRfVFlQRVMudW5jb25uZWN0ZWRBY2NvdW50LFxyXG4gIEFMRVJUX1RZUEVTLndlYjNTaGltVXNhZ2UsXHJcbl07XHJcblxyXG5leHBvcnQgY29uc3QgV0VCM19TSElNX1VTQUdFX0FMRVJUX1NUQVRFUyA9IHtcclxuICBSRUNPUkRFRDogMSxcclxuICBESVNNSVNTRUQ6IDIsXHJcbn07XHJcbiIsImltcG9ydCB7IFJlc3RyaWN0ZWRNZXRob2RzIH0gZnJvbSAnLi9wZXJtaXNzaW9ucyc7XG5cbi8qKlxuICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB0eXBlIG9mIGVudmlyb25tZW50IHRoZSBhcHBsaWNhdGlvbiBpcyBjdXJyZW50bHkgcnVubmluZyBpblxuICogcG9wdXAgLSBXaGVuIHRoZSB1c2VyIGNsaWNrJ3MgdGhlIGljb24gaW4gdGhlaXIgYnJvd3NlcidzIGV4dGVuc2lvbiBiYXI7IHRoZSBkZWZhdWx0IHZpZXdcbiAqIG5vdGlmaWNhdGlvbiAtIFdoZW4gdGhlIGV4dGVuc2lvbiBvcGVucyBkdWUgdG8gaW50ZXJhY3Rpb24gd2l0aCBhIFdlYjMgZW5hYmxlZCB3ZWJzaXRlXG4gKiBmdWxsc2NyZWVuIC0gV2hlbiB0aGUgdXNlciBjbGlja3MgJ2V4cGFuZCB2aWV3JyB0byBvcGVuIHRoZSBleHRlbnNpb24gaW4gYSBuZXcgdGFiXG4gKiBiYWNrZ3JvdW5kIC0gVGhlIGJhY2tncm91bmQgcHJvY2VzcyB0aGF0IHBvd2VycyB0aGUgZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydCB0eXBlIEVudmlyb25tZW50VHlwZSA9XG4gIHwgJ3BvcHVwJ1xuICB8ICdub3RpZmljYXRpb24nXG4gIHwgJ2Z1bGxzY3JlZW4nXG4gIHwgJ2JhY2tncm91bmQnO1xuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfUE9QVVAgPSAncG9wdXAnO1xuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfTk9USUZJQ0FUSU9OID0gJ25vdGlmaWNhdGlvbic7XG5leHBvcnQgY29uc3QgRU5WSVJPTk1FTlRfVFlQRV9GVUxMU0NSRUVOID0gJ2Z1bGxzY3JlZW4nO1xuZXhwb3J0IGNvbnN0IEVOVklST05NRU5UX1RZUEVfQkFDS0dST1VORCA9ICdiYWNrZ3JvdW5kJztcblxuLyoqXG4gKiBUaGUgZGlzdHJpYnV0aW9uIHRoaXMgYnVpbGQgaXMgaW50ZW5kZWQgZm9yLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGtlcHQgaW4tc3luYyB3aXRoIHRoZSBgQnVpbGRUeXBlYCBtYXAgaW4gYGRldmVsb3BtZW50L2J1aWxkL3V0aWxzLmpzYC5cbiAqL1xuZXhwb3J0IGNvbnN0IEJ1aWxkVHlwZSA9IHtcbiAgYmV0YTogJ2JldGEnLFxuICBmbGFzazogJ2ZsYXNrJyxcbiAgbWFpbjogJ21haW4nLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0JSQVZFID0gJ0JyYXZlJztcbmV4cG9ydCBjb25zdCBQTEFURk9STV9DSFJPTUUgPSAnQ2hyb21lJztcbmV4cG9ydCBjb25zdCBQTEFURk9STV9FREdFID0gJ0VkZ2UnO1xuZXhwb3J0IGNvbnN0IFBMQVRGT1JNX0ZJUkVGT1ggPSAnRmlyZWZveCc7XG5leHBvcnQgY29uc3QgUExBVEZPUk1fT1BFUkEgPSAnT3BlcmEnO1xuXG5leHBvcnQgY29uc3QgTUVTU0FHRV9UWVBFID0ge1xuICBBRERfRVRIRVJFVU1fQ0hBSU46ICd3YWxsZXRfYWRkRXRoZXJldW1DaGFpbicsXG4gIEVUSF9BQ0NPVU5UUzogUmVzdHJpY3RlZE1ldGhvZHMuZXRoX2FjY291bnRzLFxuICBFVEhfREVDUllQVDogJ2V0aF9kZWNyeXB0JyxcbiAgRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVk6ICdldGhfZ2V0RW5jcnlwdGlvblB1YmxpY0tleScsXG4gIEVUSF9SRVFVRVNUX0FDQ09VTlRTOiAnZXRoX3JlcXVlc3RBY2NvdW50cycsXG4gIEVUSF9TSUdOOiAnZXRoX3NpZ24nLFxuICBFVEhfU0lHTl9UWVBFRF9EQVRBOiAnZXRoX3NpZ25UeXBlZERhdGEnLFxuICBFVEhfU0lHTl9UWVBFRF9EQVRBX1YzOiAnZXRoX3NpZ25UeXBlZERhdGFfdjMnLFxuICBFVEhfU0lHTl9UWVBFRF9EQVRBX1Y0OiAnZXRoX3NpZ25UeXBlZERhdGFfdjQnLFxuICBHRVRfUFJPVklERVJfU1RBVEU6ICdtZXRhbWFza19nZXRQcm92aWRlclN0YXRlJyxcbiAgTE9HX1dFQjNfU0hJTV9VU0FHRTogJ21ldGFtYXNrX2xvZ1dlYjNTaGltVXNhZ2UnLFxuICBQRVJTT05BTF9TSUdOOiAncGVyc29uYWxfc2lnbicsXG4gIFNFTkRfTUVUQURBVEE6ICdtZXRhbWFza19zZW5kRG9tYWluTWV0YWRhdGEnLFxuICBTV0lUQ0hfRVRIRVJFVU1fQ0hBSU46ICd3YWxsZXRfc3dpdGNoRXRoZXJldW1DaGFpbicsXG4gIFdBTExFVF9SRVFVRVNUX1BFUk1JU1NJT05TOiAnd2FsbGV0X3JlcXVlc3RQZXJtaXNzaW9ucycsXG4gIFdBVENIX0FTU0VUOiAnd2FsbGV0X3dhdGNoQXNzZXQnLFxuICBXQVRDSF9BU1NFVF9MRUdBQ1k6ICdtZXRhbWFza193YXRjaEFzc2V0JyxcbiAgLy8vOiBCRUdJTjpPTkxZX0lOQ0xVREVfSU4oZmxhc2spXG4gIFNOQVBfQ09ORklSTTogUmVzdHJpY3RlZE1ldGhvZHMuc25hcF9jb25maXJtLFxuICAvLy86IEVORDpPTkxZX0lOQ0xVREVfSU5cbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogVGhlIGRpZmZlcmVudCBraW5kcyBvZiBzdWJqZWN0cyB0aGF0IE1ldGFNYXNrIG1heSBpbnRlcmFjdCB3aXRoLCBpbmNsdWRpbmdcbiAqIHRoaXJkIHBhcnRpZXMgYW5kIGl0c2VsZiAoZS5nLiB3aGVuIHRoZSBiYWNrZ3JvdW5kIGNvbW11bmljYXRlZCB3aXRoIHRoZSBVSSkuXG4gKi9cbmV4cG9ydCBjb25zdCBTVUJKRUNUX1RZUEVTID0ge1xuICBFWFRFTlNJT046ICdleHRlbnNpb24nLFxuICBJTlRFUk5BTDogJ2ludGVybmFsJyxcbiAgVU5LTk9XTjogJ3Vua25vd24nLFxuICBXRUJTSVRFOiAnd2Vic2l0ZScsXG4gIC8vLzogQkVHSU46T05MWV9JTkNMVURFX0lOKGZsYXNrKVxuICBTTkFQOiAnc25hcCcsXG4gIC8vLzogRU5EOk9OTFlfSU5DTFVERV9JTlxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFBPTExJTkdfVE9LRU5fRU5WSVJPTk1FTlRfVFlQRVMgPSB7XG4gIFtFTlZJUk9OTUVOVF9UWVBFX1BPUFVQXTogJ3BvcHVwR2FzUG9sbFRva2VucycsXG4gIFtFTlZJUk9OTUVOVF9UWVBFX05PVElGSUNBVElPTl06ICdub3RpZmljYXRpb25HYXNQb2xsVG9rZW5zJyxcbiAgW0VOVklST05NRU5UX1RZUEVfRlVMTFNDUkVFTl06ICdmdWxsU2NyZWVuR2FzUG9sbFRva2VucycsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgT1JJR0lOX01FVEFNQVNLID0gJ21ldGFtYXNrJztcblxuZXhwb3J0IGNvbnN0IE1FVEFNQVNLX0JFVEFfQ0hST01FX0lEID0gJ3BiYmthbWZnbWFlZGNjbmZrbWpjb2ZjZWNqaGZnbGRuJztcbmV4cG9ydCBjb25zdCBNRVRBTUFTS19QUk9EX0NIUk9NRV9JRCA9ICdua2JpaGZiZW9nYWVhb2VobGVmbmtvZGJlZmdwZ2tubic7XG5leHBvcnQgY29uc3QgTUVUQU1BU0tfRkxBU0tfQ0hST01FX0lEID0gJ2xqZm9laW5qcGFlZGpmZWNibWdnamdvZGJna21qa2prJztcblxuZXhwb3J0IGNvbnN0IENIUk9NRV9CVUlMRF9JRFMgPSBbXG4gIE1FVEFNQVNLX0JFVEFfQ0hST01FX0lELFxuICBNRVRBTUFTS19QUk9EX0NIUk9NRV9JRCxcbiAgTUVUQU1BU0tfRkxBU0tfQ0hST01FX0lELFxuXSBhcyBjb25zdDtcblxuY29uc3QgTUVUQU1BU0tfQkVUQV9GSVJFRk9YX0lEID0gJ3dlYmV4dGVuc2lvbi1iZXRhQG1ldGFtYXNrLmlvJztcbmNvbnN0IE1FVEFNQVNLX1BST0RfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb25AbWV0YW1hc2suaW8nO1xuY29uc3QgTUVUQU1BU0tfRkxBU0tfRklSRUZPWF9JRCA9ICd3ZWJleHRlbnNpb24tZmxhc2tAbWV0YW1hc2suaW8nO1xuXG5leHBvcnQgY29uc3QgRklSRUZPWF9CVUlMRF9JRFMgPSBbXG4gIE1FVEFNQVNLX0JFVEFfRklSRUZPWF9JRCxcbiAgTUVUQU1BU0tfUFJPRF9GSVJFRk9YX0lELFxuICBNRVRBTUFTS19GTEFTS19GSVJFRk9YX0lELFxuXSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFVOS05PV05fVElDS0VSX1NZTUJPTCA9ICdVTktOT1dOJztcbiIsImltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XHJcblxyXG5jb25zdCBPTkVfSFVORFJFRF9USE9VU0FORCA9IDEwMDAwMDtcclxuY29uc3QgTUlOX0dBU19MSU1JVF9ERUMgPSAnMjEwMDAnO1xyXG5cclxuZXhwb3J0IGNvbnN0IE1JTl9HQVNfTElNSVRfSEVYID0gcGFyc2VJbnQoTUlOX0dBU19MSU1JVF9ERUMsIDEwKS50b1N0cmluZygxNik7XHJcblxyXG5leHBvcnQgY29uc3QgR0FTX0xJTUlUUyA9IHtcclxuICAvLyBtYXhpbXVtIGdhc0xpbWl0IG9mIGEgc2ltcGxlIHNlbmRcclxuICBTSU1QTEU6IGFkZEhleFByZWZpeChNSU5fR0FTX0xJTUlUX0hFWCksXHJcbiAgLy8gYSBiYXNlIGVzdGltYXRlIGZvciB0b2tlbiB0cmFuc2ZlcnMuXHJcbiAgQkFTRV9UT0tFTl9FU1RJTUFURTogYWRkSGV4UHJlZml4KE9ORV9IVU5EUkVEX1RIT1VTQU5ELnRvU3RyaW5nKDE2KSksXHJcbn07XHJcblxyXG4vKipcclxuICogQHR5cGVkZWYge29iamVjdH0gR2FzRXN0aW1hdGVUeXBlc1xyXG4gKiBAcHJvcGVydHkgeydmZWUtbWFya2V0J30gRkVFX01BUktFVCAtIEEgZ2FzIGVzdGltYXRlIGZvciBhIGZlZSBtYXJrZXRcclxuICogIHRyYW5zYWN0aW9uIGdlbmVyYXRlZCBieSBvdXIgZ2FzIGVzdGltYXRpb24gQVBJLlxyXG4gKiBAcHJvcGVydHkgeydsZWdhY3knfSBMRUdBQ1kgLSBBIGdhcyBlc3RpbWF0ZSBmb3IgYSBsZWdhY3kgVHJhbnNhY3Rpb25cclxuICogIGdlbmVyYXRlZCBieSBvdXIgZ2FzIGVzdGltYXRpb24gQVBJLlxyXG4gKiBAcHJvcGVydHkgeydldGhfZ2FzUHJpY2UnfSBFVEhfR0FTX1BSSUNFIC0gQSBnYXMgZXN0aW1hdGUgcHJvdmlkZWQgYnkgdGhlXHJcbiAqICBFdGhlcmV1bSBub2RlIHZpYSBldGhfZ2FzUHJpY2UuXHJcbiAqIEBwcm9wZXJ0eSB7J25vbmUnfSBOT05FIC0gTm8gZ2FzIGVzdGltYXRlIGF2YWlsYWJsZS5cclxuICovXHJcblxyXG4vKipcclxuICogVGhlc2UgYXJlIGFscmVhZHkgZGVjbGFyZWQgaW4gQG1ldGFtYXNrL2NvbnRyb2xsZXJzIGJ1dCBpbXBvcnRpbmcgdGhlbSBmcm9tXHJcbiAqIHRoYXQgbW9kdWxlIGFuZCByZS1leHBvcnRpbmcgY2F1c2VzIHRoZSBVSSBidW5kbGUgc2l6ZSB0byBleHBhbmQgYmV5b25kIDRNQlxyXG4gKlxyXG4gKiBAdHlwZSB7R2FzRXN0aW1hdGVUeXBlc31cclxuICovXHJcbmV4cG9ydCBjb25zdCBHQVNfRVNUSU1BVEVfVFlQRVMgPSB7XHJcbiAgRkVFX01BUktFVDogJ2ZlZS1tYXJrZXQnLFxyXG4gIExFR0FDWTogJ2xlZ2FjeScsXHJcbiAgRVRIX0dBU1BSSUNFOiAnZXRoX2dhc1ByaWNlJyxcclxuICBOT05FOiAnbm9uZScsXHJcbn07XHJcblxyXG4vKipcclxuICogVGhlc2UgcmVwcmVzZW50IGdhcyByZWNvbW1lbmRhdGlvbiBsZXZlbHMgcHJlc2VudGVkIGluIHRoZSBVSVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEdBU19SRUNPTU1FTkRBVElPTlMgPSB7XHJcbiAgTE9XOiAnbG93JyxcclxuICBNRURJVU06ICdtZWRpdW0nLFxyXG4gIEhJR0g6ICdoaWdoJyxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgdHlwZXMgb2YgZ2FzIGVzdGltYXRpb25cclxuICovXHJcbmV4cG9ydCBjb25zdCBQUklPUklUWV9MRVZFTFMgPSB7XHJcbiAgVEVOX1BFUkNFTlRfSU5DUkVBU0VEOiAndGVuUGVyY2VudEluY3JlYXNlZCcsXHJcbiAgTE9XOiAnbG93JyxcclxuICBNRURJVU06ICdtZWRpdW0nLFxyXG4gIEhJR0g6ICdoaWdoJyxcclxuICBDVVNUT006ICdjdXN0b20nLFxyXG4gIERBUFBfU1VHR0VTVEVEOiAnZGFwcFN1Z2dlc3RlZCcsXHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyB0aGUgdXNlciBjdXN0b21pemluZyB0aGVpciBnYXMgcHJlZmVyZW5jZVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENVU1RPTV9HQVNfRVNUSU1BVEUgPSAnY3VzdG9tJztcclxuXHJcbi8qKlxyXG4gKiBUaGVzZSByZXByZXNlbnQgdGhlIGRpZmZlcmVudCBlZGl0IG1vZGVzIHByZXNlbnRlZCBpbiB0aGUgVUlcclxuICovXHJcbmV4cG9ydCBjb25zdCBFRElUX0dBU19NT0RFUyA9IHtcclxuICBTUEVFRF9VUDogJ3NwZWVkLXVwJyxcclxuICBDQU5DRUw6ICdjYW5jZWwnLFxyXG4gIE1PRElGWV9JTl9QTEFDRTogJ21vZGlmeS1pbi1wbGFjZScsXHJcbiAgU1dBUFM6ICdzd2FwcycsXHJcbn07XHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBsZXZlbHMgZm9yIGBuZXR3b3JrQ29uZ2VzdGlvbmAgKGNhbGN1bGF0ZWQgYWxvbmcgd2l0aCBnYXMgZmVlXHJcbiAqIGVzdGltYXRlczsgcmVwcmVzZW50cyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEpIHRoYXQgd2UgdXNlIHRvIHJlbmRlciB0aGVcclxuICogbmV0d29yayBzdGF0dXMgc2xpZGVyIG9uIHRoZSBzZW5kIHRyYW5zYWN0aW9uIHNjcmVlbiBhbmQgaW5mb3JtIHVzZXJzIHdoZW5cclxuICogZ2FzIGZlZXMgYXJlIGhpZ2hcclxuICovXHJcbmV4cG9ydCBjb25zdCBORVRXT1JLX0NPTkdFU1RJT05fVEhSRVNIT0xEUyA9IHtcclxuICBOT1RfQlVTWTogMCxcclxuICBTVEFCTEU6IDAuMzMsXHJcbiAgQlVTWTogMC42NixcclxufTtcclxuIiwiLyoqXG4gKiBBY2NvdW50cyBjYW4gYmUgaW5zdGFudGlhdGVkIGZyb20gc2ltcGxlLCBIRCBvciB0aGUgbXVsdGlwbGUgaGFyZHdhcmUgd2FsbGV0XG4gKiBrZXlyaW5nIHR5cGVzLiBCb3RoIHNpbXBsZSBhbmQgSEQgYXJlIHRyZWF0ZWQgYXMgZGVmYXVsdCBidXQgd2UgZG8gc3BlY2lhbFxuICogY2FzZSBhY2NvdW50cyBtYW5hZ2VkIGJ5IGEgaGFyZHdhcmUgd2FsbGV0LlxuICovXG5leHBvcnQgY29uc3QgS0VZUklOR19UWVBFUyA9IHtcbiAgTEVER0VSOiAnTGVkZ2VyIEhhcmR3YXJlJyxcbiAgVFJFWk9SOiAnVHJlem9yIEhhcmR3YXJlJyxcbiAgTEFUVElDRTogJ0xhdHRpY2UgSGFyZHdhcmUnLFxuICBRUjogJ1FSIEhhcmR3YXJlIFdhbGxldCBEZXZpY2UnLFxuICBJTVBPUlRFRDogJ1NpbXBsZSBLZXkgUGFpcicsXG59O1xuXG5leHBvcnQgY29uc3QgREVWSUNFX05BTUVTID0ge1xuICBMRURHRVI6ICdsZWRnZXInLFxuICBUUkVaT1I6ICd0cmV6b3InLFxuICBRUjogJ1FSIEhhcmR3YXJlJyxcbiAgTEFUVElDRTogJ2xhdHRpY2UnLFxufTtcblxuZXhwb3J0IGNvbnN0IEtFWVJJTkdfTkFNRVMgPSB7XG4gIExFREdFUjogJ0xlZGdlcicsXG4gIFRSRVpPUjogJ1RyZXpvcicsXG4gIFFSOiAnUVInLFxuICBMQVRUSUNFOiAnTGF0dGljZTEnLFxufTtcblxuLyoqXG4gKiBVc2VkIGZvciBzZXR0aW5nIHRoZSB1c2VycyBwcmVmZXJlbmNlIGZvciBsZWRnZXIgdHJhbnNwb3J0IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IExFREdFUl9UUkFOU1BPUlRfVFlQRVMgPSB7XG4gIExJVkU6ICdsZWRnZXJMaXZlJyxcbiAgV0VCSElEOiAnd2ViaGlkJyxcbiAgVTJGOiAndTJmJyxcbn07XG5cbmV4cG9ydCBjb25zdCBMRURHRVJfVVNCX1ZFTkRPUl9JRCA9ICcweDJjOTcnO1xuXG5leHBvcnQgY29uc3QgV0VCSElEX0NPTk5FQ1RFRF9TVEFUVVNFUyA9IHtcbiAgQ09OTkVDVEVEOiAnY29ubmVjdGVkJyxcbiAgTk9UX0NPTk5FQ1RFRDogJ25vdENvbm5lY3RlZCcsXG4gIFVOS05PV046ICd1bmtub3duJyxcbn07XG5cbmV4cG9ydCBjb25zdCBUUkFOU1BPUlRfU1RBVEVTID0ge1xuICBOT05FOiAnTk9ORScsXG4gIFZFUklGSUVEOiAnVkVSSUZJRUQnLFxuICBERVZJQ0VfT1BFTl9GQUlMVVJFOiAnREVWSUNFX09QRU5fRkFJTFVSRScsXG4gIFVOS05PV05fRkFJTFVSRTogJ1VOS05PV05fRkFJTFVSRScsXG59O1xuXG5leHBvcnQgY29uc3QgQUZGSUxJQVRFX0xJTktTID0ge1xuICBMRURHRVI6ICdodHRwczovL3Nob3AubGVkZ2VyLmNvbS8/cj0xN2M0OTkxYTAzZmEnLFxuICBHUklEUExVUzogJ2h0dHBzOi8vZ3JpZHBsdXMuaW8vP2FmbWM9N3AnLFxuICBUUkVaT1I6XG4gICAgJ2h0dHBzOi8vc2hvcC50cmV6b3IuaW8vcHJvZHVjdC90cmV6b3Itb25lLWJsYWNrP29mZmVyX2lkPTM1JmFmZl9pZD0xMTAwOScsXG4gIEtFWVNUT05FOlxuICAgICdodHRwczovL3Nob3Aua2V5c3Qub25lLz9yZnNuPTYwODgyNTcuNjU2YjNlOSZ1dG1fc291cmNlPXJlZmVyc2lvbiZ1dG1fbWVkaXVtPWFmZmlsaWF0ZSZ1dG1fY2FtcGFpZ249NjA4ODI1Ny42NTZiM2U5JyxcbiAgQUlSR0FQOiAnaHR0cHM6Ly9haXJnYXAuaXQvJyxcbiAgQ09PTFdBTExFVDogJ2h0dHBzOi8vd3d3LmNvb2x3YWxsZXQuaW8vJyxcbiAgRENFTlQ6ICdodHRwczovL2RjZW50d2FsbGV0LmNvbS8nLFxufTtcblxuZXhwb3J0IGNvbnN0IEFGRklMSUFURV9UVVRPUklBTF9MSU5LUyA9IHtcbiAgTEVER0VSOlxuICAgICdodHRwczovL3N1cHBvcnQubGVkZ2VyLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDA0MzY2ODY0NjU3LVNldC11cC1hbmQtdXNlLU1ldGFNYXNrLXRvLWFjY2Vzcy15b3VyLUxlZGdlci1FdGhlcmV1bS1FVEgtYWNjb3VudD9kb2NzPXRydWUnLFxuICBHUklEUExVUzogJ2h0dHBzOi8vZG9jcy5ncmlkcGx1cy5pby9zZXR1cC9tZXRhbWFzaycsXG4gIFRSRVpPUjogJ2h0dHBzOi8vd2lraS50cmV6b3IuaW8vQXBwczpNZXRhTWFzaycsXG4gIEtFWVNUT05FOlxuICAgICdodHRwczovL3N1cHBvcnQua2V5c3Qub25lLzNyZC1wYXJ0eS13YWxsZXRzL2V0aC1hbmQtd2ViMy13YWxsZXRzLWtleXN0b25lL2JpbmQtbWV0YW1hc2std2l0aC1rZXlzdG9uZScsXG4gIEFJUkdBUDogJ2h0dHBzOi8vc3VwcG9ydC5haXJnYXAuaXQvZ3VpZGVzL21ldGFtYXNrLycsXG4gIENPT0xXQUxMRVQ6ICdodHRwczovL3d3dy5jb29sd2FsbGV0LmlvL21ldGFtYXNrLXN0ZXAtYnktc3RlcC1ndWlkZXMvJyxcbiAgRENFTlQ6XG4gICAgJ2h0dHBzOi8vbWVkaXVtLmNvbS9kY2VudHdhbGxldC9kY2VudC13YWxsZXQtbm93LXN1cHBvcnRzLXFyLWJhc2VkLXByb3RvY29sLXRvLWxpbmstd2l0aC1tZXRhbWFzay01NzU1NWYwMjYwM2YnLFxufTtcbiIsIi8vIFRoZSBjaGFyYWN0ZXIgbGltaXQgb24gRU5TIG5hbWVzLCBuaWNrbmFtZXMgYW5kIGFkZHJlc3NlcyBiZWZvcmUgd2UgdHJ1bmNhdGVcclxuZXhwb3J0IGNvbnN0IFRSVU5DQVRFRF9OQU1FX0NIQVJfTElNSVQgPSAxMTtcclxuXHJcbi8vIFRoZSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBzbGljZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYW4gYWRkcmVzcyBmb3IgdHJ1bmNhdGVkIGZvcm1hdDpcclxuLy8gYCR7VFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlN9Li4uJHtUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlN9YFxyXG5leHBvcnQgY29uc3QgVFJVTkNBVEVEX0FERFJFU1NfU1RBUlRfQ0hBUlMgPSA1O1xyXG5cclxuLy8gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHNsaWNlIGZyb20gdGhlIGVuZCBvZiBhbiBhZGRyZXNzIGZvciB0cnVuY2F0ZWQgZm9ybWF0OlxyXG4vLyBgJHtUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSU30uLi4ke1RSVU5DQVRFRF9BRERSRVNTX0VORF9DSEFSU31gXHJcbmV4cG9ydCBjb25zdCBUUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlMgPSA0O1xyXG4iLCIvLyBUeXBlIEltcG9ydHNcbi8qKlxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnKS5FbnZpcm9ubWVudFR5cGV9IEVudmlyb25tZW50VHlwZVxuICovXG5cbi8vIFR5cGUgRGVjbGFyYXRpb25zXG4vKipcbiAqIFVzZWQgdG8gYXR0YWNoIGNvbnRleHQgb2Ygd2hlcmUgdGhlIHVzZXIgd2FzIGF0IGluIHRoZSBhcHBsaWNhdGlvbiB3aGVuIHRoZVxuICogZXZlbnQgd2FzIHRyaWdnZXJlZC4gQWxzbyBpbmNsdWRlZCBhcyBmdWxsIGRldGFpbHMgb2YgdGhlIGN1cnJlbnQgcGFnZSBpblxuICogcGFnZSBldmVudHMuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NQYWdlT2JqZWN0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3BhdGhdIC0gdGhlIHBhdGggb2YgdGhlIGN1cnJlbnQgcGFnZSAoZS5nIC9ob21lKVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt0aXRsZV0gLSB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgcGFnZSAoZS5nICdob21lJylcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSAtIHRoZSBmdWxseSBxdWFsaWZpZWQgdXJsIG9mIHRoZSBjdXJyZW50IHBhZ2VcbiAqL1xuXG4vKipcbiAqIEZvciBtZXRhbWFzaywgdGhpcyBpcyB0aGUgZGFwcCB0aGF0IHRyaWdnZXJlZCBhbiBpbnRlcmFjdGlvblxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IE1ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3RcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXJsXSAtIHRoZSBvcmlnaW4gb2YgdGhlIGRhcHAgaXNzdWluZyB0aGVcbiAqICBub3RpZmljYXRpb25cbiAqL1xuXG4vKipcbiAqIFdlIGF0dGFjaCBjb250ZXh0IHRvIGV2ZXJ5IG1ldGEgbWV0cmljcyBldmVudCB0aGF0IGhlbHAgdG8gcXVhbGlmeSBvdXJcbiAqIGFuYWx5dGljcy4gVGhpcyB0eXBlIGhhcyBhbGwgb3B0aW9uYWwgdmFsdWVzIGJlY2F1c2UgaXQgcmVwcmVzZW50cyBhXG4gKiByZXR1cm5lZCBvYmplY3QgZnJvbSBhIG1ldGhvZCBjYWxsLiBJZGVhbGx5IGFwcCBhbmQgdXNlckFnZW50IGFyZVxuICogZGVmaW5lZCBvbiBldmVyeSBldmVudC4gVGhpcyBpcyBjb25maXJtZWQgaW4gdGhlIGdldFRyYWNrTWV0YU1ldHJpY3NFdmVudFxuICogZnVuY3Rpb24sIGJ1dCBzdGlsbCBwcm92aWRlcyB0aGUgY29uc3VtZXIgYSB3YXkgdG8gb3ZlcnJpZGUgdGhlc2UgdmFsdWVzIGlmXG4gKiBuZWNlc3NhcnkuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NDb250ZXh0XG4gKiBAcHJvcGVydHkge29iamVjdH0gYXBwIC0gQXBwbGljYXRpb24gbWV0YWRhdGEuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXBwLm5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24gdHJhY2tpbmcgdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYXBwLnZlcnNpb24gLSB0aGUgdmVyc2lvbiBvZiB0aGUgYXBwbGljYXRpb25cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VyQWdlbnQgLSB0aGUgdXNlcmFnZW50IHN0cmluZyBvZiB0aGUgdXNlclxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9IFtwYWdlXSAtIGFuIG9iamVjdCByZXByZXNlbnRpbmcgZGV0YWlscyBvZlxuICogIHRoZSBjdXJyZW50IHBhZ2VcbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdH0gW3JlZmVycmVyXSAtIGZvciBtZXRhbWFzaywgdGhpcyBpcyB0aGVcbiAqICBkYXBwIHRoYXQgdHJpZ2dlcmVkIGFuIGludGVyYWN0aW9uXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWV0cmljc0V2ZW50UGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZSB0byB0cmFja1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGNhdGVnb3J5IC0gY2F0ZWdvcnkgdG8gYXNzb2NpYXRlIGV2ZW50IHRvXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Vudmlyb25tZW50VHlwZV0gLSBUaGUgdHlwZSBvZiBlbnZpcm9ubWVudCB0aGlzIGV2ZW50XG4gKiAgb2NjdXJyZWQgaW4uIERlZmF1bHRzIHRvIHRoZSBiYWNrZ3JvdW5kIHByb2Nlc3MgdHlwZVxuICogQHByb3BlcnR5IHtvYmplY3R9IFtwcm9wZXJ0aWVzXSAtIG9iamVjdCBvZiBjdXN0b20gdmFsdWVzIHRvIHRyYWNrLCBrZXlzXG4gKiAgaW4gdGhpcyBvYmplY3QgbXVzdCBiZSBpbiBzbmFrZV9jYXNlXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3NlbnNpdGl2ZVByb3BlcnRpZXNdIC0gT2JqZWN0IG9mIHNlbnNpdGl2ZSB2YWx1ZXMgdG9cbiAqICB0cmFjay4gS2V5cyBpbiB0aGlzIG9iamVjdCBtdXN0IGJlIGluIHNuYWtlX2Nhc2UuIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZVxuICogIHNlbnQgaW4gYW4gYWRkaXRpb25hbCBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgbWV0YU1ldHJpY3NJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXZlbnVlXSAtIGFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IGV2ZW50IGNyZWF0ZXMgaW5cbiAqICByZXZlbnVlIGZvciBNZXRhTWFza1xuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjdXJyZW5jeV0gLSBJU08gNDEyNyBmb3JtYXQgY3VycmVuY3kgZm9yIGV2ZW50cyB3aXRoXG4gKiAgcmV2ZW51ZSwgZGVmYXVsdHMgdG8gVVMgZG9sbGFyc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV0gLSBBYnN0cmFjdCBidXNpbmVzcyBcInZhbHVlXCIgYXR0cmlidXRhYmxlIHRvXG4gKiAgY3VzdG9tZXJzIHdobyB0cmlnZ2VyIHRoaXMgZXZlbnRcbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NQYWdlT2JqZWN0fSBbcGFnZV0gLSB0aGUgcGFnZS9yb3V0ZSB0aGF0IHRoZSBldmVudFxuICogIG9jY3VycmVkIG9uXG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzUmVmZXJyZXJPYmplY3R9IFtyZWZlcnJlcl0gLSB0aGUgb3JpZ2luIG9mIHRoZSBkYXBwXG4gKiAgdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWV0cmljc0V2ZW50T3B0aW9uc1xuICogQHByb3BlcnR5IHtib29sZWFufSBbaXNPcHRJbl0gLSBoYXBwZW5lZCBkdXJpbmcgb3B0IGluL291dCB3b3JrZmxvd1xuICogQHByb3BlcnR5IHtib29sZWFufSBbZmx1c2hJbW1lZGlhdGVseV0gLSBXaGVuIHRydWUgd2lsbCBhdXRvbWF0aWNhbGx5IGZsdXNoXG4gKiAgdGhlIHNlZ21lbnQgcXVldWUgYWZ0ZXIgdHJhY2tpbmcgdGhlIGV2ZW50LiBSZWNvbW1lbmRlZCBpZiB0aGUgcmVzdWx0IG9mXG4gKiAgdHJhY2tpbmcgdGhlIGV2ZW50IG11c3QgYmUga25vd24gYmVmb3JlIFVJIHRyYW5zaXRpb24gb3IgdXBkYXRlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtleGNsdWRlTWV0YU1ldHJpY3NJZF0gLSB3aGV0aGVyIHRvIGV4Y2x1ZGUgdGhlIHVzZXInc1xuICogIG1ldGFtZXRyaWNzIGlkIGZvciBhbm9ueW1pdHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbbWV0YU1ldHJpY3NJZF0gLSBhbiBvdmVycmlkZSBmb3IgdGhlIG1ldGFNZXRyaWNzSWQgaW5cbiAqICB0aGUgZXZlbnQgb25lIGlzIGNyZWF0ZWQgYXMgcGFydCBvZiBhbiBhc3luY2hyb25vdXMgd29ya2Zsb3csIHN1Y2ggYXNcbiAqICBhd2FpdGluZyB0aGUgcmVzdWx0IG9mIHRoZSBtZXRhbWV0cmljcyBvcHQtaW4gZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlXG4gKiAgdXNlcidzIG1ldGFtZXRyaWNzIGlkXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFttYXRvbW9FdmVudF0gLSBpcyB0aGlzIGV2ZW50IGEgaG9sZG92ZXIgZnJvbSBtYXRvbW9cbiAqICB0aGF0IG5lZWRzIGZ1cnRoZXIgbWlncmF0aW9uPyB3aGVuIHRydWUsIHNlbmRzIHRoZSBkYXRhIHRvIGEgc3BlY2lhbFxuICogIHNlZ21lbnQgc291cmNlIHRoYXQgbWFya3MgdGhlIGV2ZW50IGRhdGEgYXMgbm90IGNvbmZvcm1pbmcgdG8gb3VyIHNjaGVtYVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NFdmVudEZyYWdtZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gc3VjY2Vzc0V2ZW50IC0gVGhlIGV2ZW50IG5hbWUgdG8gZmlyZSB3aGVuIHRoZSBmcmFnbWVudFxuICogIGlzIGNsb3NlZCBpbiBhbiBhZmZpcm1hdGl2ZSBhY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2ZhaWx1cmVFdmVudF0gLSBUaGUgZXZlbnQgbmFtZSB0byBmaXJlIHdoZW4gdGhlIGZyYWdtZW50XG4gKiAgaXMgY2xvc2VkIHdpdGggYSByZWplY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2luaXRpYWxFdmVudF0gLSBBbiBldmVudCBuYW1lIHRvIGZpcmUgaW1tZWRpYXRlbHkgdXBvblxuICogIGZyYWdtZW50IGNyZWF0aW9uLiBUaGlzIGlzIHVzZWZ1bCBmb3IgYnVpbGRpbmcgZnVubmVscyBpbiBtaXhwYW5lbCBhbmQgZm9yXG4gKiAgcmVkdWN0aW9uIG9mIGNvZGUgZHVwbGljYXRpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY2F0ZWdvcnkgLSB0aGUgZXZlbnQgY2F0ZWdvcnkgdG8gdXNlIGZvciBib3RoIHRoZSBzdWNjZXNzXG4gKiAgYW5kIGZhaWx1cmUgZXZlbnRzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtwZXJzaXN0XSAtIFNob3VsZCB0aGlzIGZyYWdtZW50IGJlIHBlcnNpc3RlZCBpblxuICogIHN0YXRlIGFuZCBwcm9ncmVzc2VkIGFmdGVyIHRoZSBleHRlbnNpb24gaXMgbG9ja2VkIGFuZCB1bmxvY2tlZC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbdGltZW91dF0gLSBUaW1lIGluIHNlY29uZHMgdGhlIGV2ZW50IHNob3VsZCBiZSBwZXJzaXN0ZWRcbiAqICBmb3IuIEFmdGVyIHRoZSB0aW1lb3V0IHRoZSBmcmFnbWVudCB3aWxsIGJlIGNsb3NlZCBhcyBhYmFuZG9uZWQuIGlmIG5vdFxuICogIHN1cHBsaWVkIHRoZSBmcmFnbWVudCBpcyBzdG9yZWQgaW5kZWZpbml0ZWx5LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtsYXN0VXBkYXRlZF0gLSBEYXRlLm5vdygpIHdoZW4gdGhlIGZyYWdtZW50IHdhcyBsYXN0XG4gKiAgdXBkYXRlZC4gVXNlZCB0byBkZXRlcm1pbmUgaWYgdGhlIHRpbWVvdXQgaGFzIGV4cGlyZWQgYW5kIHRoZSBmcmFnbWVudFxuICogIHNob3VsZCBiZSBjbG9zZWQuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3Byb3BlcnRpZXNdIC0gT2JqZWN0IG9mIGN1c3RvbSB2YWx1ZXMgdG8gdHJhY2ssIGtleXMgaW5cbiAqICB0aGlzIG9iamVjdCBtdXN0IGJlIGluIHNuYWtlX2Nhc2UuXG4gKiBAcHJvcGVydHkge29iamVjdH0gW3NlbnNpdGl2ZVByb3BlcnRpZXNdIC0gT2JqZWN0IG9mIHNlbnNpdGl2ZSB2YWx1ZXMgdG9cbiAqICB0cmFjay4gS2V5cyBpbiB0aGlzIG9iamVjdCBtdXN0IGJlIGluIHNuYWtlX2Nhc2UuIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZVxuICogIHNlbnQgaW4gYW4gYWRkaXRpb25hbCBldmVudCB0aGF0IGV4Y2x1ZGVzIHRoZSB1c2VyJ3MgbWV0YU1ldHJpY3NJZFxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtyZXZlbnVlXSAtIGFtb3VudCBvZiBjdXJyZW5jeSB0aGF0IGV2ZW50IGNyZWF0ZXMgaW5cbiAqICByZXZlbnVlIGZvciBNZXRhTWFzayBpZiBmcmFnbWVudCBpcyBzdWNjZXNzZnVsLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtjdXJyZW5jeV0gLSBJU08gNDEyNyBmb3JtYXQgY3VycmVuY3kgZm9yIGV2ZW50cyB3aXRoXG4gKiAgcmV2ZW51ZSwgZGVmYXVsdHMgdG8gVVMgZG9sbGFyc1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFt2YWx1ZV0gLSBBYnN0cmFjdCBidXNpbmVzcyBcInZhbHVlXCIgYXR0cmlidXRhYmxlIHRvXG4gKiAgY3VzdG9tZXJzIHdobyBzdWNjZXNzZnVsbHkgY29tcGxldGUgdGhpcyBmcmFnbWVudFxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9IFtwYWdlXSAtIHRoZSBwYWdlL3JvdXRlIHRoYXQgdGhlIGV2ZW50XG4gKiAgb2NjdXJyZWQgb25cbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NSZWZlcnJlck9iamVjdH0gW3JlZmVycmVyXSAtIHRoZSBvcmlnaW4gb2YgdGhlIGRhcHBcbiAqICB0aGF0IGluaXRpYXRlZCB0aGUgZXZlbnQgZnJhZ21lbnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VuaXF1ZUlkZW50aWZpZXJdIC0gb3B0aW9uYWwgYXJndW1lbnQgdG8gb3ZlcnJpZGUgdGhlXG4gKiAgYXV0b21hdGljIGdlbmVyYXRpb24gb2YgVVVJRCBmb3IgdGhlIGV2ZW50IGZyYWdtZW50LiBUaGlzIGlzIHVzZWZ1bCB3aGVuXG4gKiAgdHJhY2tpbmcgZXZlbnRzIGZvciBzdWJzeXN0ZW1zIHRoYXQgYWxyZWFkeSBnZW5lcmF0ZSBVVUlEcyBzbyB0byBhdm9pZFxuICogIHVubmVjZXNzYXJ5IGxvb2t1cHMgYW5kIHJlZHVjZSBhY2NpZGVudGFsIGR1cGxpY2F0aW9uLlxuICovXG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgc2hhcGUgb2YgZGF0YSBzZW50IHRvIHRoZSBzZWdtZW50LnRyYWNrIG1ldGhvZC5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZWdtZW50RXZlbnRQYXlsb2FkXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3VzZXJJZF0gLSBUaGUgbWV0YW1ldHJpY3MgaWQgZm9yIHRoZSB1c2VyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Fub255bW91c0lkXSAtIEFuIGFub255bW91c0lkIHRoYXQgaXMgdXNlZCB0byB0cmFja1xuICogIHNlbnNpdGl2ZSBkYXRhIHdoaWxlIHByZXNlcnZpbmcgYW5vbnltaXR5LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGV2ZW50IC0gbmFtZSBvZiB0aGUgZXZlbnQgdG8gdHJhY2tcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gcHJvcGVydGllcyB0byBhdHRhY2ggdG8gdGhlIGV2ZW50XG4gKiBAcHJvcGVydHkge01ldGFNZXRyaWNzQ29udGV4dH0gY29udGV4dCAtIHRoZSBjb250ZXh0IHRoZSBldmVudCBvY2N1cnJlZCBpblxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gTWV0YU1ldHJpY3NQYWdlUGF5bG9hZFxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFnZSB0aGF0IHdhcyB2aWV3ZWRcbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSB2YXJpYWRpYyBwYXJ0cyBvZiB0aGUgcGFnZSB1cmxcbiAqICBleGFtcGxlIChyb3V0ZTogYC9hc3NldC86YXNzZXRgLCBwYXRoOiBgL2Fzc2V0L0VUSGApXG4gKiAgcGFyYW1zOiB7IGFzc2V0OiAnRVRIJyB9XG4gKiBAcHJvcGVydHkge0Vudmlyb25tZW50VHlwZX0gZW52aXJvbm1lbnRUeXBlIC0gdGhlIGVudmlyb25tZW50IHR5cGUgdGhhdCB0aGVcbiAqICBwYWdlIHdhcyB2aWV3ZWQgaW5cbiAqIEBwcm9wZXJ0eSB7TWV0YU1ldHJpY3NQYWdlT2JqZWN0fSBbcGFnZV0gLSB0aGUgZGV0YWlscyBvZiB0aGUgcGFnZVxuICogQHByb3BlcnR5IHtNZXRhTWV0cmljc1JlZmVycmVyT2JqZWN0fSBbcmVmZXJyZXJdIC0gZGFwcCB0aGF0IHRyaWdnZXJlZCB0aGUgcGFnZVxuICogIHZpZXdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IE1ldGFNZXRyaWNzUGFnZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lzT3B0SW5QYXRoXSAtIGlzIHRoZSBjdXJyZW50IHBhdGggb25lIG9mIHRoZSBwYWdlcyBpblxuICogIHRoZSBvbmJvYXJkaW5nIHdvcmtmbG93PyBJZiB0cnVlIGFuZCBwYXJ0aWNpcGF0ZUluTWV0YU1ldHJpY3MgaXMgbnVsbCB0cmFja1xuICogIHRoZSBwYWdlIHZpZXdcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYWl0c1xuICogQHByb3BlcnR5IHsnYWRkcmVzc19ib29rX2VudHJpZXMnfSBBRERSRVNTX0JPT0tfRU5UUklFUyAtIFdoZW4gdGhlIHVzZXJcbiAqICBhZGRzIG9yIG1vZGlmaWVzIGFkZHJlc3NlcyBpbiBhZGRyZXNzIGJvb2sgdGhlIGFkZHJlc3NfYm9va19lbnRyaWVzIHRyYWl0XG4gKiAgaXMgaWRlbnRpZmllZC5cbiAqIEBwcm9wZXJ0eSB7J2xlZGdlcl9jb25uZWN0aW9uX3R5cGUnfSBMRURHRVJfQ09OTkVDVElPTl9UWVBFIC0gd2hlbiBsZWRnZXJcbiAqICBsaXZlIGNvbm5uZWN0aW9uIHR5cGUgaXMgY2hhbmdlZCB3ZSBpZGVudGlmeSB0aGUgbGVkZ2VyX2Nvbm5lY3Rpb25fdHlwZVxuICogIHRyYWl0XG4gKiBAcHJvcGVydHkgeyduZXR3b3Jrc19hZGRlZCd9IE5FVFdPUktTX0FEREVEIC0gd2hlbiB1c2VyIG1vZGlmaWVzIG5ldHdvcmtzXG4gKiAgd2UgaWRlbnRpZnkgdGhlIG5ldHdvcmtzX2FkZGVkIHRyYWl0XG4gKiBAcHJvcGVydHkgeyduZXR3b3Jrc193aXRob3V0X3RpY2tlcid9IE5FVFdPUktTX1dJVEhPVVRfVElDS0VSIC0gd2hlbiB1c2VyXG4gKiAgbW9kaWZpZXMgbmV0d29ya3Mgd2UgaWRlbnRpZnkgdGhlIG5ldHdvcmtzX3dpdGhvdXRfdGlja2VyIHRyYWl0IGZvclxuICogIG5ldHdvcmtzIHdpdGhvdXQgYSB0aWNrZXIuXG4gKiBAcHJvcGVydHkgeyduZnRfYXV0b2RldGVjdGlvbl9lbmFibGVkJ30gTkZUX0FVVE9ERVRFQ1RJT05fRU5BQkxFRCAtIHdoZW4gQXV0b2RldGVjdCBORlRzXG4gKiBmZWF0dXJlIGlzIHRvZ2dsZWQgd2UgaWRlbnRpZnkgdGhlIG5mdF9hdXRvZGV0ZWN0aW9uX2VuYWJsZWQgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl9hY2NvdW50cyd9IE5VTUJFUl9PRl9BQ0NPVU5UUyAtIHdoZW4gaWRlbnRpdGllc1xuICogIGNoYW5nZSwgd2UgaWRlbnRpZnkgdGhlIG5ldyBudW1iZXJfb2ZfYWNjb3VudHMgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl9uZnRfY29sbGVjdGlvbnMnfSBOVU1CRVJfT0ZfTkZUX0NPTExFQ1RJT05TIC0gdXNlclxuICogIHRyYWl0IGZvciBudW1iZXIgb2YgdW5pcXVlIE5GVCBhZGRyZXNzZXNcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl9uZnRzJ30gTlVNQkVSX09GX05GVFMgLSB1c2VyIHRyYWl0IGZvciBudW1iZXIgb2YgYWxsIE5GVCBhZGRyZXNzZXNcbiAqIEBwcm9wZXJ0eSB7J251bWJlcl9vZl90b2tlbnMnfSBOVU1CRVJfT0ZfVE9LRU5TIC0gd2hlbiB0aGUgbnVtYmVyIG9mIHRva2VucyBjaGFuZ2UsIHdlXG4gKiBpZGVudGlmeSB0aGUgbmV3IG51bWJlcl9vZl90b2tlbnMgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J29wZW5zZWFfYXBpX2VuYWJsZWQnfSBPUEVOU0VBX0FQSV9FTkFCTEVEIC0gd2hlbiB0aGUgT3BlblNlYSBBUEkgaXMgZW5hYmxlZFxuICogd2UgaWRlbnRpZnkgdGhlIG9wZW5zZWFfYXBpX2VuYWJsZWQgdHJhaXRcbiAqIEBwcm9wZXJ0eSB7J3RocmVlX2JveF9lbmFibGVkJ30gVEhSRUVfQk9YX0VOQUJMRUQgLSBXaGVuIDNCb3ggZmVhdHVyZSBpc1xuICogIHRvZ2dsZWQgd2UgaWRlbnRpZnkgdGhlIDNib3hfZW5hYmxlZCB0cmFpdC4gVGhpcyB0cmFpdCBoYXMgYmVlbiBkZXByZWNhdGVkLlxuICogQHByb3BlcnR5IHsndGhlbWUnfSBUSEVNRSAtIHdoZW4gdGhlIHVzZXIncyB0aGVtZSBjaGFuZ2VzIHdlIGlkZW50aWZ5IHRoZSB0aGVtZSB0cmFpdFxuICogQHByb3BlcnR5IHsndG9rZW5fZGV0ZWN0aW9uX2VuYWJsZWQnfSBUT0tFTl9ERVRFQ1RJT05fRU5BQkxFRCAtIHdoZW4gdG9rZW4gZGV0ZWN0aW9uIGZlYXR1cmUgaXMgdG9nZ2xlZCB3ZVxuICogaWRlbnRpZnkgdGhlIHRva2VuX2RldGVjdGlvbl9lbmFibGVkIHRyYWl0XG4gKiBAcHJvcGVydHkgeydpbnN0YWxsX2RhdGVfZXh0J30gSU5TVEFMTF9EQVRFX0VYVCAtIHdoZW4gdGhlIHVzZXIgaW5zdGFsbGVkIHRoZSBleHRlbnNpb25cbiAqL1xuXG4vKipcbiAqXG4gKiBAdHlwZSB7VHJhaXRzfVxuICovXG5cbmV4cG9ydCBjb25zdCBUUkFJVFMgPSB7XG4gIEFERFJFU1NfQk9PS19FTlRSSUVTOiAnYWRkcmVzc19ib29rX2VudHJpZXMnLFxuICBJTlNUQUxMX0RBVEVfRVhUOiAnaW5zdGFsbF9kYXRlX2V4dCcsXG4gIExFREdFUl9DT05ORUNUSU9OX1RZUEU6ICdsZWRnZXJfY29ubmVjdGlvbl90eXBlJyxcbiAgTkVUV09SS1NfQURERUQ6ICduZXR3b3Jrc19hZGRlZCcsXG4gIE5FVFdPUktTX1dJVEhPVVRfVElDS0VSOiAnbmV0d29ya3Nfd2l0aG91dF90aWNrZXInLFxuICBORlRfQVVUT0RFVEVDVElPTl9FTkFCTEVEOiAnbmZ0X2F1dG9kZXRlY3Rpb25fZW5hYmxlZCcsXG4gIE5VTUJFUl9PRl9BQ0NPVU5UUzogJ251bWJlcl9vZl9hY2NvdW50cycsXG4gIE5VTUJFUl9PRl9ORlRfQ09MTEVDVElPTlM6ICdudW1iZXJfb2ZfbmZ0X2NvbGxlY3Rpb25zJyxcbiAgTlVNQkVSX09GX05GVFM6ICdudW1iZXJfb2ZfbmZ0cycsXG4gIE5VTUJFUl9PRl9UT0tFTlM6ICdudW1iZXJfb2ZfdG9rZW5zJyxcbiAgT1BFTlNFQV9BUElfRU5BQkxFRDogJ29wZW5zZWFfYXBpX2VuYWJsZWQnLFxuICBUSEVNRTogJ3RoZW1lJyxcbiAgVEhSRUVfQk9YX0VOQUJMRUQ6ICd0aHJlZV9ib3hfZW5hYmxlZCcsXG4gIFRPS0VOX0RFVEVDVElPTl9FTkFCTEVEOiAndG9rZW5fZGV0ZWN0aW9uX2VuYWJsZWQnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWV0cmljc1RyYWl0c1xuICogQHByb3BlcnR5IHtudW1iZXJ9IFthZGRyZXNzX2Jvb2tfZW50cmllc10gLSBUaGUgbnVtYmVyIG9mIGVudHJpZXMgaW4gdGhlXG4gKiAgdXNlcidzIGFkZHJlc3MgYm9vay5cbiAqIEBwcm9wZXJ0eSB7J2xlZGdlckxpdmUnIHwgJ3dlYmhpZCcgfCAndTJmJ30gW2xlZGdlcl9jb25uZWN0aW9uX3R5cGVdIC0gdGhlXG4gKiAgdHlwZSBvZiBsZWRnZXIgY29ubmVjdGlvbiBzZXQgYnkgdXNlciBwcmVmZXJlbmNlLlxuICogQHByb3BlcnR5IHtBcnJheTxzdHJpbmc+fSBbbmV0d29ya3NfYWRkZWRdIC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiBjaGFpbklkc1xuICogIHRoYXQgaW5kaWNhdGUgdGhlIG5ldHdvcmtzIGEgdXNlciBoYXMgYWRkZWQgdG8gdGhlaXIgTWV0YU1hc2suXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFtuZXR3b3Jrc193aXRob3V0X3RpY2tlcl0gLSBBbiBhcnJheSBjb25zaXN0aW5nIG9mXG4gKiAgY2hhaW5JZHMgdGhhdCBpbmRpY2F0ZSB0aGUgbmV0d29ya3MgYWRkZWQgYnkgdGhlIHVzZXIgdGhhdCBkbyBub3QgaGF2ZSBhXG4gKiAgdGlja2VyLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtuZnRfYXV0b2RldGVjdGlvbl9lbmFibGVkXSAtIGRvZXMgdGhlIHVzZXIgaGF2ZSB0aGVcbiAqIHVzZSBjb2xsZWN0aW9uL25mdCBkZXRlY3Rpb24gZW5hYmxlZD9cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyX29mX2FjY291bnRzXSAtIEEgbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyXG4gKiAgb2YgaWRlbnRpdGllcyhhY2NvdW50cykgYWRkZWQgdG8gdGhlIHVzZXIncyBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyX29mX25mdF9jb2xsZWN0aW9uc10gLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlXG4gKiAgYW1vdW50IG9mIGRpZmZlcmVudCBORlQgY29sbGVjdGlvbnMgdGhlIHVzZXIgcG9zc2Vzc2VzIGFuIE5GVCBmcm9tLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFtudW1iZXJfb2ZfbmZ0c10gLSBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlXG4gKiAgYW1vdW50IG9mIGFsbCBORlRzIHRoZSB1c2VyIHBvc3Nlc3NlcyBhY3Jvc3MgYWxsIG5ldHdvcmtzIGFuZCBhY2NvdW50cy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbbnVtYmVyX29mX3Rva2Vuc10gLSBUaGUgdG90YWwgbnVtYmVyIG9mIHRva2VuIGNvbnRyYWN0c1xuICogIHRoZSB1c2VyIGhhcyBhY3Jvc3MgYWxsIG5ldHdvcmtzIGFuZCBhY2NvdW50cy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW29wZW5zZWFfYXBpX2VuYWJsZWRdIC0gZG9lcyB0aGUgdXNlciBoYXZlIHRoZSBPcGVuU2VhXG4gKiAgQVBJIGVuYWJsZWQ/XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt0aHJlZV9ib3hfZW5hYmxlZF0gLSBEb2VzIHRoZSB1c2VyIGhhdmUgM2JveCBzeW5jXG4gKiAgZW5hYmxlZD8gKGRlcHJlY2F0ZWQpXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3RoZW1lXSAtIHdoaWNoIHRoZW1lIHRoZSB1c2VyIGhhcyBzZWxlY3RlZFxuICogQHByb3BlcnR5IHtib29sZWFufSBbdG9rZW5fZGV0ZWN0aW9uX2VuYWJsZWRdIC0gZG9lcyB0aGUgdXNlciBoYXZlIHRva2VuIGRldGVjdGlvbiBpcyBlbmFibGVkP1xuICovXG5cbi8vIE1peHBhbmVsIGNvbnZlcnRzIHRoZSB6ZXJvIGFkZHJlc3MgdmFsdWUgdG8gYSB0cnVseSBhbm9ueW1vdXMgZXZlbnQsIHdoaWNoXG4vLyBzcGVlZHMgdXAgcmVwb3J0aW5nXG5leHBvcnQgY29uc3QgTUVUQU1FVFJJQ1NfQU5PTllNT1VTX0lEID0gJzB4MDAwMDAwMDAwMDAwMDAwMCc7XG5cbi8qKlxuICogVGhpcyBvYmplY3QgaXMgdXNlZCB0byBpZGVudGlmeSBldmVudHMgdGhhdCBhcmUgdHJpZ2dlcmVkIGJ5IHRoZSBiYWNrZ3JvdW5kXG4gKiBwcm9jZXNzLlxuICpcbiAqIEB0eXBlIHtNZXRhTWV0cmljc1BhZ2VPYmplY3R9XG4gKi9cbmV4cG9ydCBjb25zdCBNRVRBTUVUUklDU19CQUNLR1JPVU5EX1BBR0VfT0JKRUNUID0ge1xuICBwYXRoOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG4gIHRpdGxlOiAnQmFja2dyb3VuZCBQcm9jZXNzJyxcbiAgdXJsOiAnL2JhY2tncm91bmQtcHJvY2VzcycsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlZ21lbnRJbnRlcmZhY2VcbiAqIEBwcm9wZXJ0eSB7U2VnbWVudEV2ZW50UGF5bG9hZFtdfSBxdWV1ZSAtIEEgcXVldWUgb2YgZXZlbnRzIHRvIGJlIHNlbnQgd2hlblxuICogIHRoZSBmbHVzaEF0IGxpbWl0IGhhcyBiZWVuIHJlYWNoZWQsIG9yIGZsdXNoSW50ZXJ2YWwgb2NjdXJzXG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGZsdXNoIC0gSW1tZWRpYXRlbHkgZmx1c2ggdGhlIHF1ZXVlLCByZXNldHRpbmcgaXQgdG9cbiAqICBhbiBlbXB0eSBhcnJheSBhbmQgc2VuZGluZyB0aGUgcGVuZGluZyBldmVudHMgdG8gU2VnbWVudFxuICogQHByb3BlcnR5IHsoXG4gKiAgcGF5bG9hZDogU2VnbWVudEV2ZW50UGF5bG9hZCxcbiAqICBjYWxsYmFjazogKGVycj86IEVycm9yKSA9PiB2b2lkXG4gKiApID0+IHZvaWR9IHRyYWNrIC0gVHJhY2sgYW4gZXZlbnQgd2l0aCBTZWdtZW50LCB1c2luZyB0aGUgaW50ZXJuYWwgYmF0Y2hpbmdcbiAqICBtZWNoYW5pc20gdG8gb3B0aW1pemUgbmV0d29yayByZXF1ZXN0c1xuICogQHByb3BlcnR5IHsocGF5bG9hZDogb2JqZWN0KSA9PiB2b2lkfSBwYWdlIC0gVHJhY2sgYSBwYWdlIHZpZXcgd2l0aCBTZWdtZW50XG4gKiBAcHJvcGVydHkgeygpID0+IHZvaWR9IGlkZW50aWZ5IC0gSWRlbnRpZnkgYW4gYW5vbnltb3VzIHVzZXIuIFdlIGRvIG5vdFxuICogIGN1cnJlbnRseSB1c2UgdGhpcyBtZXRob2QuXG4gKi9cblxuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0UgPSAnQ2FuY2VsIFZpYSBOb3RpZmljYXRpb24gQ2xvc2UnO1xuZXhwb3J0IGNvbnN0IFJFSkVDVF9OT1RGSUNJQVRJT05fQ0xPU0VfU0lHID1cbiAgJ0NhbmNlbCBTaWcgUmVxdWVzdCBWaWEgTm90aWZpY2F0aW9uIENsb3NlJztcblxuLyoqXG4gKiBFVkVOVFNcbiAqL1xuXG5leHBvcnQgY29uc3QgRVZFTlRfTkFNRVMgPSB7XG4gIEFDQ09VTlRfQURERUQ6ICdBY2NvdW50IEFkZGVkJyxcbiAgQUNDT1VOVF9BRERfU0VMRUNURUQ6ICdBY2NvdW50IEFkZCBTZWxlY3RlZCcsXG4gIEFDQ09VTlRfQUREX0ZBSUxFRDogJ0FjY291bnQgQWRkIEZhaWxlZCcsXG4gIEFDQ09VTlRfUEFTU1dPUkRfQ1JFQVRFRDogJ1dhbGxldCBQYXNzd29yZCBDcmVhdGVkJyxcbiAgQUNDT1VOVF9SRVNFVDogJ0FjY291bnQgUmVzZXQnLFxuICBBUFBfSU5TVEFMTEVEOiAnQXBwIEluc3RhbGxlZCcsXG4gIEFQUF9VTkxPQ0tFRDogJ0FwcCBVbmxvY2tlZCcsXG4gIEFQUF9VTkxPQ0tFRF9GQUlMRUQ6ICdBcHAgVW5sb2NrZWQgRmFpbGVkJyxcbiAgQVBQX1dJTkRPV19FWFBBTkRFRDogJ0FwcCBXaW5kb3cgRXhwYW5kZWQnLFxuICBERUNSWVBUSU9OX0FQUFJPVkVEOiAnRGVjcnlwdGlvbiBBcHByb3ZlZCcsXG4gIERFQ1JZUFRJT05fUkVKRUNURUQ6ICdEZWNyeXB0aW9uIFJlamVjdGVkJyxcbiAgREVDUllQVElPTl9SRVFVRVNURUQ6ICdEZWNyeXB0aW9uIFJlcXVlc3RlZCcsXG4gIEVOQ1JZUFRJT05fUFVCTElDX0tFWV9BUFBST1ZFRDogJ0VuY3J5cHRpb24gQXBwcm92ZWQnLFxuICBFTkNSWVBUSU9OX1BVQkxJQ19LRVlfUkVKRUNURUQ6ICdFbmNyeXB0aW9uIFJlamVjdGVkJyxcbiAgRU5DUllQVElPTl9QVUJMSUNfS0VZX1JFUVVFU1RFRDogJ0VuY3J5cHRpb24gUmVxdWVzdGVkJyxcbiAgRVhURVJOQUxfTElOS19DTElDS0VEOiAnRXh0ZXJuYWwgTGluayBDbGlja2VkJyxcbiAgS0VZX0VYUE9SVF9TRUxFQ1RFRDogJ0tleSBFeHBvcnQgU2VsZWN0ZWQnLFxuICBLRVlfRVhQT1JUX1JFUVVFU1RFRDogJ0tleSBFeHBvcnQgUmVxdWVzdGVkJyxcbiAgS0VZX0VYUE9SVF9GQUlMRUQ6ICdLZXkgRXhwb3J0IEZhaWxlZCcsXG4gIEtFWV9FWFBPUlRfQ0FOQ0VMRUQ6ICdLZXkgRXhwb3J0IENhbmNlbGVkJyxcbiAgS0VZX0VYUE9SVF9SRVZFQUxFRDogJ0tleSBNYXRlcmlhbCBSZXZlYWxlZCcsXG4gIEtFWV9FWFBPUlRfQ09QSUVEOiAnS2V5IE1hdGVyaWFsIENvcGllZCcsXG4gIE1FVFJJQ1NfT1BUX0lOOiAnTWV0cmljcyBPcHQgSW4nLFxuICBNRVRSSUNTX09QVF9PVVQ6ICdNZXRyaWNzIE9wdCBPdXQnLFxuICBOQVZfQUNDT1VOVF9NRU5VX09QRU5FRDogJ0FjY291bnQgTWVudSBPcGVuZWQnLFxuICBOQVZfQUNDT1VOVF9ERVRBSUxTX09QRU5FRDogJ0FjY291bnQgRGV0YWlscyBPcGVuZWQnLFxuICBOQVZfQ09OTkVDVEVEX1NJVEVTX09QRU5FRDogJ0Nvbm5lY3RlZCBTaXRlcyBPcGVuZWQnLFxuICBOQVZfTUFJTl9NRU5VX09QRU5FRDogJ01haW4gTWVudSBPcGVuZWQnLFxuICBOQVZfTkVUV09SS19NRU5VX09QRU5FRDogJ05ldHdvcmsgTWVudSBPcGVuZWQnLFxuICBOQVZfU0VUVElOR1NfT1BFTkVEOiAnU2V0dGluZ3MgT3BlbmVkJyxcbiAgTkFWX0FDQ09VTlRfU1dJVENIRUQ6ICdBY2NvdW50IFN3aXRjaGVkJyxcbiAgTkFWX05FVFdPUktfU1dJVENIRUQ6ICdOZXR3b3JrIFN3aXRjaGVkJyxcbiAgTkFWX0JVWV9CVVRUT05fQ0xJQ0tFRDogJ0J1eSBCdXR0b24gQ2xpY2tlZCcsXG4gIE5BVl9TRU5EX0JVVFRPTl9DTElDS0VEOiAnU2VuZCBCdXR0b24gQ2xpY2tlZCcsXG4gIE5BVl9TV0FQX0JVVFRPTl9DTElDS0VEOiAnU3dhcCBCdXR0b24gQ2xpY2tlZCcsXG4gIFNSUF9UT19DT05GSVJNX0JBQ0tVUDogJ1NSUCBCYWNrdXAgQ29uZmlybSBEaXNwbGF5ZWQnLFxuICBXQUxMRVRfU0VUVVBfU1RBUlRFRDogJ1dhbGxldCBTZXR1cCBTZWxlY3RlZCcsXG4gIFdBTExFVF9TRVRVUF9DQU5DRUxFRDogJ1dhbGxldCBTZXR1cCBDYW5jZWxlZCcsXG4gIFdBTExFVF9TRVRVUF9GQUlMRUQ6ICdXYWxsZXQgU2V0dXAgRmFpbGVkJyxcbiAgV0FMTEVUX0NSRUFURUQ6ICdXYWxsZXQgQ3JlYXRlZCcsXG4gIE5GVF9BRERFRDogJ05GVCBBZGRlZCcsXG4gIE9OUkFNUF9QUk9WSURFUl9TRUxFQ1RFRDogJ09uLXJhbXAgUHJvdmlkZXIgU2VsZWN0ZWQnLFxuICBQRVJNSVNTSU9OU19BUFBST1ZFRDogJ1Blcm1pc3Npb25zIEFwcHJvdmVkJyxcbiAgUEVSTUlTU0lPTlNfUkVKRUNURUQ6ICdQZXJtaXNzaW9ucyBSZWplY3RlZCcsXG4gIFBFUk1JU1NJT05TX1JFUVVFU1RFRDogJ1Blcm1pc3Npb25zIFJlcXVlc3RlZCcsXG4gIFBPUlRGT0xJT19MSU5LX0NMSUNLRUQ6ICdQb3J0Zm9saW8gTGluayBDbGlja2VkJyxcbiAgUFVCTElDX0FERFJFU1NfQ09QSUVEOiAnUHVibGljIEFkZHJlc3MgQ29waWVkJyxcbiAgUFJPVklERVJfTUVUSE9EX0NBTExFRDogJ1Byb3ZpZGVyIE1ldGhvZCBDYWxsZWQnLFxuICBTSUdOQVRVUkVfQVBQUk9WRUQ6ICdTaWduYXR1cmUgQXBwcm92ZWQnLFxuICBTSUdOQVRVUkVfUkVKRUNURUQ6ICdTaWduYXR1cmUgUmVqZWN0ZWQnLFxuICBTSUdOQVRVUkVfUkVRVUVTVEVEOiAnU2lnbmF0dXJlIFJlcXVlc3RlZCcsXG4gIFRPS0VOX0lNUE9SVF9CVVRUT05fQ0xJQ0tFRDogJ0ltcG9ydCBUb2tlbiBCdXR0b24gQ2xpY2tlZCcsXG4gIFRPS0VOX1NDUkVFTl9PUEVORUQ6ICdUb2tlbiBTY3JlZW4gT3BlbmVkJyxcbiAgU1VQUE9SVF9MSU5LX0NMSUNLRUQ6ICdTdXBwb3J0IExpbmsgQ2xpY2tlZCcsXG4gIFRPS0VOX0FEREVEOiAnVG9rZW4gQWRkZWQnLFxuICBUT0tFTl9ERVRFQ1RFRDogJ1Rva2VuIERldGVjdGVkJyxcbiAgVE9LRU5fSElEREVOOiAnVG9rZW4gSGlkZGVuJyxcbiAgVE9LRU5fSU1QT1JUX0NBTkNFTEVEOiAnVG9rZW4gSW1wb3J0IENhbmNlbGVkJyxcbiAgVE9LRU5fSU1QT1JUX0NMSUNLRUQ6ICdUb2tlbiBJbXBvcnQgQ2xpY2tlZCcsXG59O1xuXG5leHBvcnQgY29uc3QgRVZFTlQgPSB7XG4gIEFDQ09VTlRfVFlQRVM6IHtcbiAgICBERUZBVUxUOiAnbWV0YW1hc2snLFxuICAgIElNUE9SVEVEOiAnaW1wb3J0ZWQnLFxuICAgIEhBUkRXQVJFOiAnaGFyZHdhcmUnLFxuICB9LFxuICBBQ0NPVU5UX0lNUE9SVF9UWVBFUzoge1xuICAgIEpTT046ICdqc29uJyxcbiAgICBQUklWQVRFX0tFWTogJ3ByaXZhdGVfa2V5JyxcbiAgICBTUlA6ICdzcnAnLFxuICB9LFxuICBDQVRFR09SSUVTOiB7XG4gICAgQUNDT1VOVFM6ICdBY2NvdW50cycsXG4gICAgQVBQOiAnQXBwJyxcbiAgICBBVVRIOiAnQXV0aCcsXG4gICAgQkFDS0dST1VORDogJ0JhY2tncm91bmQnLFxuICAgIEVSUk9SOiAnRXJyb3InLFxuICAgIEZPT1RFUjogJ0Zvb3RlcicsXG4gICAgSE9NRTogJ0hvbWUnLFxuICAgIElOUEFHRV9QUk9WSURFUjogJ2lucGFnZV9wcm92aWRlcicsXG4gICAgS0VZUzogJ0tleXMnLFxuICAgIE1FU1NBR0VTOiAnTWVzc2FnZXMnLFxuICAgIE5BVklHQVRJT046ICdOYXZpZ2F0aW9uJyxcbiAgICBORVRXT1JLOiAnTmV0d29yaycsXG4gICAgT05CT0FSRElORzogJ09uYm9hcmRpbmcnLFxuICAgIFJFVEVOVElPTjogJ1JldGVudGlvbicsXG4gICAgU0VUVElOR1M6ICdTZXR0aW5ncycsXG4gICAgU05BUFM6ICdTbmFwcycsXG4gICAgU1dBUFM6ICdTd2FwcycsXG4gICAgVFJBTlNBQ1RJT05TOiAnVHJhbnNhY3Rpb25zJyxcbiAgICBXQUxMRVQ6ICdXYWxsZXQnLFxuICB9LFxuICBFWFRFUk5BTF9MSU5LX1RZUEVTOiB7XG4gICAgVFJBTlNBQ1RJT05fQkxPQ0tfRVhQTE9SRVI6ICdUcmFuc2FjdGlvbiBCbG9jayBFeHBsb3JlcicsXG4gICAgQkxPQ0tfRVhQTE9SRVI6ICdCbG9jayBFeHBsb3JlcicsXG4gICAgQUNDT1VOVF9UUkFDS0VSOiAnQWNjb3VudCBUcmFja2VyJyxcbiAgICBUT0tFTl9UUkFDS0VSOiAnVG9rZW4gVHJhY2tlcicsXG4gIH0sXG4gIEtFWV9UWVBFUzoge1xuICAgIFBLRVk6ICdwcml2YXRlX2tleScsXG4gICAgU1JQOiAnc3JwJyxcbiAgfSxcbiAgT05SQU1QX1BST1ZJREVSX1RZUEVTOiB7XG4gICAgQ09JTkJBU0U6ICdjb2luYmFzZScsXG4gICAgTU9PTlBBWTogJ21vb25wYXknLFxuICAgIFdZUkU6ICd3eXJlJyxcbiAgICBUUkFOU0FLOiAndHJhbnNhaycsXG4gICAgU0VMRl9ERVBPU0lUOiAnZGlyZWN0X2RlcG9zaXQnLFxuICB9LFxuICBTT1VSQ0U6IHtcbiAgICBORVRXT1JLOiB7XG4gICAgICBDVVNUT01fTkVUV09SS19GT1JNOiAnY3VzdG9tX25ldHdvcmtfZm9ybScsXG4gICAgICBQT1BVTEFSX05FVFdPUktfTElTVDogJ3BvcHVsYXJfbmV0d29ya19saXN0JyxcbiAgICB9LFxuICAgIFNXQVBTOiB7XG4gICAgICBNQUlOX1ZJRVc6ICdNYWluIFZpZXcnLFxuICAgICAgVE9LRU5fVklFVzogJ1Rva2VuIFZpZXcnLFxuICAgIH0sXG4gICAgVE9LRU46IHtcbiAgICAgIENVU1RPTTogJ2N1c3RvbScsXG4gICAgICBEQVBQOiAnZGFwcCcsXG4gICAgICBERVRFQ1RFRDogJ2RldGVjdGVkJyxcbiAgICAgIExJU1Q6ICdsaXN0JyxcbiAgICB9LFxuICAgIFRSQU5TQUNUSU9OOiB7XG4gICAgICBEQVBQOiAnZGFwcCcsXG4gICAgICBVU0VSOiAndXNlcicsXG4gICAgfSxcbiAgfSxcbiAgTE9DQVRJT046IHtcbiAgICBUT0tFTl9ERVRBSUxTOiAndG9rZW5fZGV0YWlscycsXG4gICAgVE9LRU5fREVURUNUSU9OOiAndG9rZW5fZGV0ZWN0aW9uJyxcbiAgICBUT0tFTl9NRU5VOiAndG9rZW5fbWVudScsXG4gIH0sXG59O1xuXG4vLyBWYWx1ZXMgYmVsb3cgKGUuZy4gJ2xvY2F0aW9uJykgY2FuIGJlIHVzZWQgaW4gdGhlIFwicHJvcGVydGllc1wiXG4vLyB0cmFja2luZyBvYmplY3QgYXMga2V5cywgZS5nLiB7IGxvY2F0aW9uOiAnSG9tZScgfVxuZXhwb3J0IGNvbnN0IENPTlRFWFRfUFJPUFMgPSB7XG4gIFBBR0VfVElUTEU6ICdsb2NhdGlvbicsXG59O1xuIiwiaW1wb3J0IHsgY2FwaXRhbGl6ZSB9IGZyb20gJ2xvZGFzaCc7XG4vKipcbiAqIEEgdHlwZSByZXByZXNlbnRpbmcgYW55IHZhbGlkIHZhbHVlIGZvciAndHlwZScgZm9yIHNldFByb3ZpZGVyVHlwZSBhbmQgb3RoZXJcbiAqIG1ldGhvZHMgdGhhdCBhZGQgb3IgbWFuaXB1bGF0ZSBuZXR3b3JrcyBpbiBNZXRhTWFzayBzdGF0ZS5cbiAqL1xuZXhwb3J0IHR5cGUgTmV0d29ya1R5cGUgPSB0eXBlb2YgTkVUV09SS19UWVBFU1trZXlvZiB0eXBlb2YgTkVUV09SS19UWVBFU107XG5cbi8qKlxuICogQSB1bmlvbiB0eXBlIG9mIGFsbCBwb3NzaWJsZSBoYXJkLWNvZGVkIGNoYWluIGlkcy4gVGhpcyB0eXBlIGlzIG5vdFxuICogZXhoYXVzdGl2ZSBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIHR5cGluZyBjaGFpbklkIGluIGFyZWFzIHdoZXJlIHRoZSB1c2VyIG9yXG4gKiBkYXBwIG1heSBzcGVjaWZ5IGFueSBjaGFpbklkLlxuICovXG5leHBvcnQgdHlwZSBDaGFpbklkID0gdHlwZW9mIENIQUlOX0lEU1trZXlvZiB0eXBlb2YgQ0hBSU5fSURTXTtcblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBpcyBhIHVuaW9uIHR5cGUgb2YgYWxsIHBvc3NpYmxlIGhhcmRjb2RlZCBjdXJyZW5jeSBzeW1ib2xzLlxuICogVGhpcyB0eXBlIGlzIG5vbi1leGhhdXN0aXZlLCBhbmQgY2Fubm90IGJlIHVzZWQgZm9yIGFyZWFzIHdoZXJlIHRoZSB1c2VyXG4gKiBvciBkYXBwIG1heSBzdXBwbHkgdGhlaXIgb3duIHN5bWJvbC5cbiAqL1xudHlwZSBDdXJyZW5jeVN5bWJvbCA9IHR5cGVvZiBDVVJSRU5DWV9TWU1CT0xTW2tleW9mIHR5cGVvZiBDVVJSRU5DWV9TWU1CT0xTXTtcbi8qKlxuICogQSB0eXBlIHRoYXQgaXMgYSB1bmlvbiB0eXBlIGZvciB0aGUgc3VwcG9ydGVkIHN5bWJvbHMgb24gZGlmZmVyZW50IG9ucmFtcCBwcm92aWRlcnMuXG4gKi9cbnR5cGUgU3VwcG9ydGVkQ3VycmVuY3lTeW1ib2wgPVxuICB0eXBlb2YgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFNba2V5b2YgdHlwZW9mIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTXTtcbi8qKlxuICogVGVzdCBuZXR3b3JrcyBoYXZlIHNwZWNpYWwgc3ltYm9scyB0aGF0IGNvbWJpbmUgdGhlIG5ldHdvcmsgbmFtZSBhbmQgJ0VUSCdcbiAqIHNvIHRoYXQgdGhleSBhcmUgZGlzdGluY3QgZnJvbSBtYWlubmV0IGFuZCBvdGhlciBuZXR3b3JrcyB0aGF0IHVzZSAnRVRIJy5cbiAqL1xuZXhwb3J0IHR5cGUgVGVzdE5ldHdvcmtDdXJyZW5jeVN5bWJvbCA9XG4gIHR5cGVvZiBURVNUX05FVFdPUktfVElDS0VSX01BUFtrZXlvZiB0eXBlb2YgVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBdO1xuXG4vKipcbiAqIE1vb25QYXkgaXMgYSBmaWF0IG9ucmFtcCBwcm92aWRlciwgYW5kIHRoZXJlIGFyZSBzb21lIHNwZWNpYWwgc3RyaW5ncyB0aGF0XG4gKiBpbmZvcm0gdGhlIE1vb25QYXkgQVBJIHdoaWNoIG5ldHdvcmsgdGhlIHVzZXIgaXMgYXR0ZW1wdGluZyB0byBvbnJhbXAgaW50by5cbiAqIFRoaXMgdHlwZSByZWZsZWN0cyB0aG9zZSBwb3NzaWJsZSB2YWx1ZXMuXG4gKi9cbnR5cGUgTW9vblBheU5ldHdvcmtBYmJyZXZpYXRpb24gPSAnQlNDJyB8ICdDQ0hBSU4nIHwgJ1BPTFlHT04nO1xuXG4vKipcbiAqIE1vb25QYXkgcmVxdWlyZXMgc29tZSBzZXR0aW5ncyB0aGF0IGFyZSBjb25maWd1cmVkIHBlciBuZXR3b3JrIHRoYXQgaXQgaXNcbiAqIGVuYWJsZWQgb24uIFRoaXMgdHlwZSBkZXNjcmliZXMgdGhvc2Ugc2V0dGluZ3MuXG4gKi9cbnR5cGUgTW9vblBheUNoYWluU2V0dGluZ3MgPSB7XG4gIC8qKlxuICAgKiBXaGF0IHNob3VsZCB0aGUgZGVmYXVsdCBvbnJhbXAgY3VycmVuY3kgYmUsIGZvciBleGFtcGxlICdldGgnIG9uICdtYWlubmV0J1xuICAgKiBUaGlzIHR5cGUgbWF0Y2hlcyBhIHNpbmdsZSBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbCBvciBhXG4gICAqIFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sIGFuZCBhIE1vb25QYXlOZXR3b3JrQWJicmV2aWF0aW9uIGpvaW5lZCBieSBhICdfJy5cbiAgICovXG4gIGRlZmF1bHRDdXJyZW5jeUNvZGU6XG4gICAgfCBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbFxuICAgIHwgYCR7U3VwcG9ydGVkQ3VycmVuY3lTeW1ib2x9XyR7TW9vblBheU5ldHdvcmtBYmJyZXZpYXRpb259YDtcbiAgLyoqXG4gICAqIFdlIG11c3QgYWxzbyBjb25maWd1cmUgYWxsIHBvc3NpYmxlIG9ucmFtcCBjdXJyZW5jaWVzIHdlIHdpc2ggdG8gc3VwcG9ydC5cbiAgICogVGhpcyB0eXBlIG1hdGNoZXMgZWl0aGVyIGFuIGFycmF5IG9mIFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sIG9yXG4gICAqIGFuIGFycmF5IG9mIFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sIGFuZCBhIE1vb25QYXlOZXR3b3JrQWJicmV2aWF0aW9uIGpvaW5lZCBieSBhICdfJy5cbiAgICovXG4gIHNob3dPbmx5Q3VycmVuY2llczpcbiAgICB8IFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sW11cbiAgICB8IGAke1N1cHBvcnRlZEN1cnJlbmN5U3ltYm9sfV8ke01vb25QYXlOZXR3b3JrQWJicmV2aWF0aW9ufWBbXTtcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJlZmVyZW5jZXMgZm9yIGFuIFJQQyBkZWZpbml0aW9uXG4gKi9cbnR5cGUgUlBDUHJlZmVyZW5jZXMgPSB7XG4gIC8qKlxuICAgKiBBIFVSTCBmb3IgdGhlIGJsb2NrIGV4cGxvcmVyIGZvciB0aGUgUlBDJ3MgbmV0d29ya1xuICAgKi9cbiAgYmxvY2tFeHBsb3JlclVybDogYGh0dHBzOi8vJHtzdHJpbmd9YDtcbiAgLyoqXG4gICAqIEEgaW1hZ2UgcmVmbGVjdGluZyB0aGUgYXNzZXQgc3ltYm9sIGZvciB0aGUgbmV0d29ya1xuICAgKi9cbiAgaW1hZ2VVcmw6IHN0cmluZztcbn07XG5cbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIGEgbmV0d29yayB0byBiZSB1c2VkIGluc2lkZSBvZiBNZXRhTWFza1xuICovXG50eXBlIFJQQ0RlZmluaXRpb24gPSB7XG4gIC8qKlxuICAgKiBUaGUgaGV4IGVuY29kZWQgQ2hhaW5JZCBmb3IgdGhlIG5ldHdvcmtcbiAgICovXG4gIGNoYWluSWQ6IENoYWluSWQ7XG4gIC8qKlxuICAgKiBUaGUgbmlja25hbWUgZm9yIHRoZSBuZXR3b3JrXG4gICAqL1xuICBuaWNrbmFtZTogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIFVSTCBmb3IgdGhlIGNsaWVudCB0byBzZW5kIG5ldHdvcmsgcmVxdWVzdHMgdG9cbiAgICovXG4gIHJwY1VybDogYGh0dHBzOi8vJHtzdHJpbmd9YDtcbiAgLyoqXG4gICAqIFRoZSBDdXJyZW5jeSBTeW1ib2wgZm9yIHRoZSBuZXR3b3JrXG4gICAqL1xuICB0aWNrZXI6IHN0cmluZztcbiAgLyoqXG4gICAqIEFkZGl0aW9uYWwgcHJlZmVyZW5jZXMgZm9yIHRoZSBuZXR3b3JrLCBzdWNoIGFzIGJsb2NrRXhwbG9yZXJVcmxcbiAgICovXG4gIHJwY1ByZWZzOiBSUENQcmVmZXJlbmNlcztcbn07XG5cbi8qKlxuICogV3lyZSBpcyBhIGZpYXQgb25yYW1wIHByb3ZpZGVyLiBXZSBtdXN0IHByb3ZpZGUgc29tZSBzZXR0aW5ncyBmb3IgbmV0d29ya3NcbiAqIHRoYXQgc3VwcG9ydCBXeXJlLlxuICovXG50eXBlIFd5cmVDaGFpblNldHRpbmdzID0ge1xuICAvKipcbiAgICogVGhlIG5ldHdvcmsgbmFtZVxuICAgKi9cbiAgc3JuOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBUaGUgbmF0aXZlIGN1cnJlbmN5IGZvciB0aGUgbmV0d29ya1xuICAgKi9cbiAgY3VycmVuY3lDb2RlOiBDdXJyZW5jeVN5bWJvbDtcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBjdXJyZW5jaWVzIGZvciB0aGUgV3lyZSBvbnJhbXAgcHJvdmlkZXJcbiAgICovXG4gIGN1cnJlbmNpZXM6IFN1cHBvcnRlZEN1cnJlbmN5U3ltYm9sW107XG59O1xuXG4vKipcbiAqIEZvciBlYWNoIGNoYWluIHRoYXQgd2Ugc3VwcG9ydCBmaWF0IG9ucmFtcHMgZm9yLCB3ZSBwcm92aWRlIGEgc2V0IG9mXG4gKiBjb25maWd1cmF0aW9uIG9wdGlvbnMgdGhhdCBoZWxwIGZvciBpbml0aWFsaXppbmcgdGhlIGNvbm5lY3Rpb25nIHRvIHRoZVxuICogb25yYW1wIHByb3ZpZGVycy5cbiAqL1xudHlwZSBCdXlhYmxlQ2hhaW5TZXR0aW5ncyA9IHtcbiAgLyoqXG4gICAqIFRoZSBuYXRpdmUgY3VycmVuY3kgZm9yIHRoZSBnaXZlbiBjaGFpblxuICAgKi9cbiAgbmF0aXZlQ3VycmVuY3k6IEN1cnJlbmN5U3ltYm9sIHwgVGVzdE5ldHdvcmtDdXJyZW5jeVN5bWJvbDtcbiAgLyoqXG4gICAqIFRoZSBuZXR3b3JrIG5hbWUgb3IgaWRlbnRpZmllclxuICAgKi9cbiAgbmV0d29yazogc3RyaW5nO1xuICAvKipcbiAgICogVGhlIGxpc3Qgb2Ygc3VwcG9ydGVkIGN1cnJlbmNpZXMgZm9yIHRoZSBUcmFuc2FrIG9ucmFtcCBwcm92aWRlclxuICAgKi9cbiAgdHJhbnNha0N1cnJlbmNpZXM/OiBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbFtdO1xuICAvKipcbiAgICogQSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIE1vb25QYXkgb25yYW1wIHByb3ZpZGVyXG4gICAqL1xuICBtb29uUGF5PzogTW9vblBheUNoYWluU2V0dGluZ3M7XG4gIC8qKlxuICAgKiBBIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciB0aGUgV3lyZSBvbnJhbXAgcHJvdmlkZXJcbiAgICovXG4gIHd5cmU/OiBXeXJlQ2hhaW5TZXR0aW5ncztcbiAgLyoqXG4gICAqIFRoZSBsaXN0IG9mIHN1cHBvcnRlZCBjdXJyZW5jaWVzIGZvciB0aGUgQ29pbmJhc2VQYXkgb25yYW1wIHByb3ZpZGVyXG4gICAqL1xuICBjb2luYmFzZVBheUN1cnJlbmNpZXM/OiBTdXBwb3J0ZWRDdXJyZW5jeVN5bWJvbFtdO1xufTtcblxuLyoqXG4gKiBUaHJvdWdob3V0IHRoZSBleHRlbnNpb24gd2Ugc2V0IHRoZSBjdXJyZW50IHByb3ZpZGVyIGJ5IHJlZmVyZW5jaW5nIGl0c1xuICogXCJ0eXBlXCIsIHdoaWNoIGNhbiBiZSBhbnkgb2YgdGhlIHZhbHVlcyBpbiB0aGUgYmVsb3cgb2JqZWN0LiBUaGVzZSB2YWx1ZXNcbiAqIHJlcHJlc2VudCB0aGUgYnVpbHQtaW4gbmV0d29ya3Mgb2YgTWV0YU1hc2ssIGluY2x1ZGluZyB0ZXN0IG5ldHMsIGFzIHdlbGxcbiAqIGFzIFwicnBjXCIgd2hpY2ggaXMgdGhlIFwidHlwZVwiIG9mIGEgY3VzdG9tIG5ldHdvcmsgYWRkZWQgYnkgdGhlIHVzZXIgb3IgdmlhXG4gKiB3YWxsZXRfYWRkRXRoZXJldW1DaGFpbi5cbiAqL1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfVFlQRVMgPSB7XG4gIEdPRVJMSTogJ2dvZXJsaScsXG4gIExPQ0FMSE9TVDogJ2xvY2FsaG9zdCcsXG4gIE1BSU5ORVQ6ICdtYWlubmV0JyxcbiAgUlBDOiAncnBjJyxcbiAgU0VQT0xJQTogJ3NlcG9saWEnLFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyBzaG9ydGN1dCBuYW1lcyBmb3IgYW55IG5vbi1idWlsdGluIG5ldHdvcmsuIFdlIG5lZWRcbiAqIHRoaXMgdG8gYmUgYWJsZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbmV0d29ya3MgdGhhdCByZXF1aXJlIGN1c3RvbVxuICogc2VjdGlvbnMgb2YgY29kZSBmb3Igb3VyIHZhcmlvdXMgZmVhdHVyZXMsIHN1Y2ggYXMgc3dhcHMgb3IgdG9rZW4gbGlzdHMuXG4gKi9cbmV4cG9ydCBjb25zdCBORVRXT1JLX05BTUVTID0ge1xuICBIT01FU1RFQUQ6ICdob21lc3RlYWQnLFxufTtcblxuLyoqXG4gKiBUaGUgTmV0d29yayBJRCBmb3Igb3VyIGJ1aWx0aW4gbmV0d29ya3MuIFRoaXMgaXMgdGhlIGRlY2ltYWwgZXF1aXZhbGVudCBvZlxuICogdGhlIGNoYWluIGlkIGZvciB0aGUgbmV0d29yaywgYnV0IGlzIGV4cHJlc3NzZWQgYXMgYSBzdHJpbmcuIE1hbnkgbW9vbnMgYWdvXG4gKiB0aGUgZGVjaXNpb24gd2FzIG1hZGUgb24gdGhlIGV4dGVuc2lvbiB0ZWFtIHRvIGV4cHJlc3NseSB1c2UgY2hhaW5JZCB3aXRoXG4gKiBoZXggZW5jb2Rpbmcgb3ZlciBuZXR3b3JrIGlkLiBDb25zaWRlciB0aGF0IHdoZW4gYWNjZXNzaW5nIHRoaXMgb2JqZWN0LiBOb3RlXG4gKiBmb3IgY3Jvc3MgcHJvZHVjdCBwdXJwb3NlczogYWxpZ25tZW50IHdpdGggbW9iaWxlIG9uIHRoaXMgbWF0dGVyIGhhcyBub3RcbiAqIGJlZW4gZnVsbHkgYWNoaWV2ZWQsIHRodXMgaXQgaXMgcG9zc2libGUgZm9yIHNvbWUgZGVwZW5kZW5jaWVzIHRvIHN0aWxsXG4gKiBhc2sgZm9yIG9yIHJlcXVpcmUgbmV0d29yayBpZC5cbiAqL1xuZXhwb3J0IGNvbnN0IE5FVFdPUktfSURTID0ge1xuICBNQUlOTkVUOiAnMScsXG4gIEdPRVJMSTogJzUnLFxuICBMT0NBTEhPU1Q6ICcxMzM3JyxcbiAgU0VQT0xJQTogJzExMTU1MTExJyxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogQW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBjaGFpbiBpZHMgZm9yIG5ldHdvcmtzIGJvdGggYnVpbHQgaW4gYW5kXG4gKiB0aG9zZSB0aGF0IHdlIGhhdmUgYWRkZWQgY3VzdG9tIGNvZGUgdG8gc3VwcG9ydCBvdXIgZmVhdHVyZSBzZXQuXG4gKi9cbmV4cG9ydCBjb25zdCBDSEFJTl9JRFMgPSB7XG4gIE1BSU5ORVQ6ICcweDEnLFxuICBHT0VSTEk6ICcweDUnLFxuICBMT0NBTEhPU1Q6ICcweDUzOScsXG4gIEJTQzogJzB4MzgnLFxuICBPUFRJTUlTTTogJzB4YScsXG4gIE9QVElNSVNNX1RFU1RORVQ6ICcweDFhNCcsXG4gIFBPTFlHT046ICcweDg5JyxcbiAgQVZBTEFOQ0hFOiAnMHhhODZhJyxcbiAgRkFOVE9NOiAnMHhmYScsXG4gIENFTE86ICcweGE0ZWMnLFxuICBBUkJJVFJVTTogJzB4YTRiMScsXG4gIEhBUk1PTlk6ICcweDYzNTY0YzQwJyxcbiAgUEFMTTogJzB4MmExNWMzMDhkJyxcbiAgU0VQT0xJQTogJzB4YWEzNmE3JyxcbiAgQVVST1JBOiAnMHg0ZTQ1NDE1MicsXG59IGFzIGNvbnN0O1xuXG4vKipcbiAqIFRoZSBsYXJnZXN0IHBvc3NpYmxlIGNoYWluIElEIHdlIGNhbiBoYW5kbGUuXG4gKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcmVrbWFya3MvYTQ3YmQ1ZjI1MjU5MzZjNGI4ZWVlMzFhMTYzNDU1NTNcbiAqL1xuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0NIQUlOX0lEID0gNDUwMzU5OTYyNzM3MDQ3NjtcblxuZXhwb3J0IGNvbnN0IE1BSU5ORVRfRElTUExBWV9OQU1FID0gJ0V0aGVyZXVtIE1haW5uZXQnO1xuZXhwb3J0IGNvbnN0IEdPRVJMSV9ESVNQTEFZX05BTUUgPSAnR29lcmxpJztcbmV4cG9ydCBjb25zdCBTRVBPTElBX0RJU1BMQVlfTkFNRSA9ICdTZXBvbGlhJztcbmV4cG9ydCBjb25zdCBMT0NBTEhPU1RfRElTUExBWV9OQU1FID0gJ0xvY2FsaG9zdCA4NTQ1JztcbmV4cG9ydCBjb25zdCBCU0NfRElTUExBWV9OQU1FID0gJ0JpbmFuY2UgU21hcnQgQ2hhaW4nO1xuZXhwb3J0IGNvbnN0IFBPTFlHT05fRElTUExBWV9OQU1FID0gJ1BvbHlnb24nO1xuZXhwb3J0IGNvbnN0IEFWQUxBTkNIRV9ESVNQTEFZX05BTUUgPSAnQXZhbGFuY2hlIE5ldHdvcmsgQy1DaGFpbic7XG5leHBvcnQgY29uc3QgQVJCSVRSVU1fRElTUExBWV9OQU1FID0gJ0FyYml0cnVtIE9uZSc7XG5leHBvcnQgY29uc3QgQk5CX0RJU1BMQVlfTkFNRSA9XG4gICdCTkIgU21hcnQgQ2hhaW4gKHByZXZpb3VzbHkgQmluYW5jZSBTbWFydCBDaGFpbiBNYWlubmV0KSc7XG5leHBvcnQgY29uc3QgT1BUSU1JU01fRElTUExBWV9OQU1FID0gJ09wdGltaXNtJztcbmV4cG9ydCBjb25zdCBGQU5UT01fRElTUExBWV9OQU1FID0gJ0ZhbnRvbSBPcGVyYSc7XG5leHBvcnQgY29uc3QgSEFSTU9OWV9ESVNQTEFZX05BTUUgPSAnSGFybW9ueSBNYWlubmV0IFNoYXJkIDAnO1xuZXhwb3J0IGNvbnN0IFBBTE1fRElTUExBWV9OQU1FID0gJ1BhbG0nO1xuZXhwb3J0IGNvbnN0IEFVUk9SQV9ESVNQTEFZX05BTUUgPSAnQXVyb3JhIE1haW5uZXQnO1xuXG5leHBvcnQgY29uc3QgaW5mdXJhUHJvamVjdElkID0gcHJvY2Vzcy5lbnYuSU5GVVJBX1BST0pFQ1RfSUQ7XG5leHBvcnQgY29uc3QgZ2V0UnBjVXJsID0gKHtcbiAgbmV0d29yayxcbiAgZXhjbHVkZVByb2plY3RJZCA9IGZhbHNlLFxufToge1xuICBuZXR3b3JrOiBOZXR3b3JrVHlwZTtcbiAgZXhjbHVkZVByb2plY3RJZD86IGJvb2xlYW47XG59KSA9PlxuICBgaHR0cHM6Ly8ke25ldHdvcmt9LmluZnVyYS5pby92My8ke2V4Y2x1ZGVQcm9qZWN0SWQgPyAnJyA6IGluZnVyYVByb2plY3RJZH1gO1xuXG5leHBvcnQgY29uc3QgTUFJTk5FVF9SUENfVVJMID0gZ2V0UnBjVXJsKHtcbiAgbmV0d29yazogTkVUV09SS19UWVBFUy5NQUlOTkVULFxufSk7XG5leHBvcnQgY29uc3QgR09FUkxJX1JQQ19VUkwgPSBnZXRScGNVcmwoeyBuZXR3b3JrOiBORVRXT1JLX1RZUEVTLkdPRVJMSSB9KTtcbmV4cG9ydCBjb25zdCBTRVBPTElBX1JQQ19VUkwgPSBnZXRScGNVcmwoeyBuZXR3b3JrOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEgfSk7XG5leHBvcnQgY29uc3QgTE9DQUxIT1NUX1JQQ19VUkwgPSAnaHR0cDovL2xvY2FsaG9zdDo4NTQ1JztcblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW4gc3ltYm9scyBmb3IgdmFyaW91cyB0b2tlbnMgdGhhdCBhcmUgZWl0aGVyXG4gKiBuYXRpdmUgY3VycmVuY2llcyBvciB0aG9zZSB0aGF0IGhhdmUgYmVlbiBzcGVjaWFsIGNhc2VkIGJ5IHRoZSBleHRlbnNpb25cbiAqIGZvciBzdXBwb3J0aW5nIG91ciBmZWF0dXJlIHNldC5cbiAqL1xuZXhwb3J0IGNvbnN0IENVUlJFTkNZX1NZTUJPTFMgPSB7XG4gIEFSQklUUlVNOiAnRVRIJyxcbiAgQVVST1JBOiAnQXVyb3JhIEVUSCcsXG4gIEFWQUxBTkNIRTogJ0FWQVgnLFxuICBCTkI6ICdCTkInLFxuICBCVVNEOiAnQlVTRCcsXG4gIENFTE86ICdDRUxPJyxcbiAgREFJOiAnREFJJyxcbiAgRVRIOiAnRVRIJyxcbiAgRkFOVE9NOiAnRlRNJyxcbiAgSEFSTU9OWTogJ09ORScsXG4gIFBBTE06ICdQQUxNJyxcbiAgTUFUSUM6ICdNQVRJQycsXG4gIFRFU1RfRVRIOiAnVEVTVEVUSCcsXG4gIFVTREM6ICdVU0RDJyxcbiAgVVNEVDogJ1VTRFQnLFxuICBXRVRIOiAnV0VUSCcsXG4gIE9QVElNSVNNOiAnT1AnLFxufSBhcyBjb25zdDtcblxuLyoqXG4gKiBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW4gc3ltYm9scyBmb3IgdmFyaW91cyB0b2tlbnMgdGhhdCBhcmUgc3VwcG9ydGVkXG4gKiBvbiBkaWZmZXJlbnQgb24gcmFtcCBwcm92aWRlcnMuIFRoaXMgb2JqZWN0IGlzIG1lYW50IGZvciBpbnRlcm5hbCBjb25zdW1wdGlvbixcbiAqIGhlbmNlIHdoeSBpdCBpcyBub3QgZXhwb3J0ZWQuXG4gKi9cbmNvbnN0IFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTID0ge1xuICAuLi5DVVJSRU5DWV9TWU1CT0xTLFxuICAnMUlOQ0gnOiAnMUlOQ0gnLFxuICBBQVZFOiAnQUFWRScsXG4gIEFCVDogJ0FCVCcsXG4gIEFDSDogJ0FDSCcsXG4gIEFHRVVSOiAnQUdFVVInLFxuICBBR0xEOiAnQUdMRCcsXG4gIEFNUDogJ0FNUCcsXG4gIEFOS1I6ICdBTktSJyxcbiAgQVBFOiAnQVBFJyxcbiAgQVJQQTogJ0FSUEEnLFxuICBBU006ICdBU00nLFxuICBBVUNUSU9OOiAnQVVDVElPTicsXG4gIEFYUzogJ0FYUycsXG4gIEFWQVg6ICdBVkFYJyxcbiAgQVZBWEM6ICdBVkFYQycsXG4gIEFWQVhDVVNEQzogJ0FWQVhDVVNEQycsXG4gIEJBREdFUjogJ0JBREdFUicsXG4gIEJBTDogJ0JBTCcsXG4gIEJBTkQ6ICdCQU5EJyxcbiAgQkFUOiAnQkFUJyxcbiAgQk5UOiAnQk5UJyxcbiAgQk9CQTogJ0JPQkEnLFxuICBCT05EOiAnQk9ORCcsXG4gIEJUUlNUOiAnQlRSU1QnLFxuICBDSEFJTjogJ0NIQUlOJyxcbiAgQ0haOiAnQ0haJyxcbiAgQ0xWOiAnQ0xWJyxcbiAgQ09NUDogJ0NPTVAnLFxuICBDT1RJOiAnQ09USScsXG4gIENSTzogJ0NSTycsXG4gIENSVjogJ0NSVicsXG4gIENUU0k6ICdDVFNJJyxcbiAgQ1ZDOiAnQ1ZDJyxcbiAgREFPOiAnREFPJyxcbiAgRERYOiAnRERYJyxcbiAgRE5UOiAnRE5UJyxcbiAgRU5KOiAnRU5KJyxcbiAgRU5TOiAnRU5TJyxcbiAgRVVSVDogJ0VVUlQnLFxuICBGQVJNOiAnRkFSTScsXG4gIEZFVDogJ0ZFVCcsXG4gIEZPUlRIOiAnRk9SVEgnLFxuICBGWDogJ0ZYJyxcbiAgR05POiAnR05PJyxcbiAgR1JUOiAnR1JUJyxcbiAgR1RDOiAnR1RDJyxcbiAgR1RIOiAnR1RIJyxcbiAgR1VTRDogJ0dVU0QnLFxuICBHWUVOOiAnR1lFTicsXG4gIEhFWDogJ0hFWCcsXG4gIElPVFg6ICdJT1RYJyxcbiAgSU1YOiAnSU1YJyxcbiAgSkFTTVk6ICdKQVNNWScsXG4gIEtFRVA6ICdLRUVQJyxcbiAgS05DOiAnS05DJyxcbiAgS1JMOiAnS1JMJyxcbiAgTENYOiAnTENYJyxcbiAgTElOSzogJ0xJTksnLFxuICBMUFQ6ICdMUFQnLFxuICBMUkM6ICdMUkMnLFxuICBNQU5BOiAnTUFOQScsXG4gIE1BU0s6ICdNQVNLJyxcbiAgTUlORFM6ICdNSU5EUycsXG4gIE1JUjogJ01JUicsXG4gIE1LUjogJ01LUicsXG4gIE1MTjogJ01MTicsXG4gIE1UTDogJ01UTCcsXG4gIE1VU0RDOiAnbVVTREMnLFxuICBOS046ICdOS04nLFxuICBOTVI6ICdOTVInLFxuICBOVTogJ05VJyxcbiAgT0dOOiAnT0dOJyxcbiAgT01HOiAnT01HJyxcbiAgT1JOOiAnT1JOJyxcbiAgT1hUOiAnT1hUJyxcbiAgUEFYOiAnUEFYJyxcbiAgUEVSUDogJ1BFUlAnLFxuICBQTEE6ICdQTEEnLFxuICBQT0xTOiAnUE9MUycsXG4gIFBPTFk6ICdQT0xZJyxcbiAgUU5UOiAnUU5UJyxcbiAgUVVJQ0s6ICdRVUlDSycsXG4gIFJBRDogJ1JBRCcsXG4gIFJBSTogJ1JBSScsXG4gIFJBUkk6ICdSQVJJJyxcbiAgUkVOOiAnUkVOJyxcbiAgUkVQOiAnUkVQJyxcbiAgUkVROiAnUkVRJyxcbiAgUkxDOiAnUkxDJyxcbiAgUkxZOiAnUkxZJyxcbiAgU0FORDogJ1NBTkQnLFxuICBTSElCOiAnU0hJQicsXG4gIFNLTDogJ1NLTCcsXG4gIFNOWDogJ1NOWCcsXG4gIFNQQTogJ1NQQScsXG4gIFNURVRIOiAnU1RFVEgnLFxuICBTVE9SSjogJ1NUT1JKJyxcbiAgU1VLVTogJ1NVS1UnLFxuICBTVVNISTogJ1NVU0hJJyxcbiAgU1dBUDogJ1NXQVAnLFxuICBTV0ZUQzogJ1NXRlRDJyxcbiAgVFJBQzogJ1RSQUMnLFxuICBUUkI6ICdUUkInLFxuICBUUklCRTogJ1RSSUJFJyxcbiAgVFJVOiAnVFJVJyxcbiAgVFhMOiAnVFhMJyxcbiAgVU1BOiAnVU1BJyxcbiAgVU5JOiAnVU5JJyxcbiAgVVNEUzogJ1VTRFMnLFxuICBWUkE6ICdWUkEnLFxuICBXQlRDOiAnV0JUQycsXG4gIFdDRkc6ICdXQ0ZHJyxcbiAgWFlPOiAnWFlPJyxcbiAgWUZJSTogJ1lGSUknLFxuICBZRkk6ICdZRkknLFxuICBZTEQ6ICdZTEQnLFxuICBaUlg6ICdaUlgnLFxuICBaVVNEOiAnWlVTRCcsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgRVRIX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ldGhfbG9nby5zdmcnO1xuZXhwb3J0IGNvbnN0IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9ibGFjay1ldGgtbG9nby5zdmcnO1xuZXhwb3J0IGNvbnN0IEJOQl9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvYm5iLnBuZyc7XG5leHBvcnQgY29uc3QgTUFUSUNfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL21hdGljLXRva2VuLnBuZyc7XG5leHBvcnQgY29uc3QgQVZBWF9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvYXZheC10b2tlbi5wbmcnO1xuZXhwb3J0IGNvbnN0IEFFVEhfVE9LRU5fSU1BR0VfVVJMID0gJy4vaW1hZ2VzL2FyYml0cnVtLnN2Zyc7XG5leHBvcnQgY29uc3QgRlRNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9mYW50b20tb3BlcmEuc3ZnJztcbmV4cG9ydCBjb25zdCBIQVJNT05ZX09ORV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvaGFybW9ueS1vbmUuc3ZnJztcbmV4cG9ydCBjb25zdCBPUFRJTUlTTV9UT0tFTl9JTUFHRV9VUkwgPSAnLi9pbWFnZXMvb3B0aW1pc20uc3ZnJztcbmV4cG9ydCBjb25zdCBQQUxNX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9wYWxtLnN2Zyc7XG5leHBvcnQgY29uc3QgQVVST1JBX1RPS0VOX0lNQUdFX1VSTCA9ICcuL2ltYWdlcy9hdXJvcmEucG5nJztcblxuZXhwb3J0IGNvbnN0IElORlVSQV9QUk9WSURFUl9UWVBFUyA9IFtcbiAgTkVUV09SS19UWVBFUy5NQUlOTkVULFxuICBORVRXT1JLX1RZUEVTLkdPRVJMSSxcbiAgTkVUV09SS19UWVBFUy5TRVBPTElBLFxuXTtcblxuZXhwb3J0IGNvbnN0IFRFU1RfQ0hBSU5TID0gW1xuICBDSEFJTl9JRFMuR09FUkxJLFxuICBDSEFJTl9JRFMuU0VQT0xJQSxcbiAgQ0hBSU5fSURTLkxPQ0FMSE9TVCxcbl07XG5cbmNvbnN0IHR5cGVkQ2FwaXRhbGl6ZSA9IDxLIGV4dGVuZHMgc3RyaW5nPihrOiBLKTogQ2FwaXRhbGl6ZTxLPiA9PlxuICBjYXBpdGFsaXplKGspIGFzIENhcGl0YWxpemU8dHlwZW9mIGs+O1xuXG5leHBvcnQgY29uc3QgVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVA6IHtcbiAgW0sgaW4gRXhjbHVkZTxcbiAgICBOZXR3b3JrVHlwZSxcbiAgICAnbG9jYWxob3N0JyB8ICdtYWlubmV0JyB8ICdycGMnXG4gID5dOiBgJHtDYXBpdGFsaXplPEs+fSR7dHlwZW9mIENVUlJFTkNZX1NZTUJPTFMuRVRIfWA7XG59ID0ge1xuICBbTkVUV09SS19UWVBFUy5HT0VSTEldOiBgJHt0eXBlZENhcGl0YWxpemUoTkVUV09SS19UWVBFUy5HT0VSTEkpfSR7XG4gICAgQ1VSUkVOQ1lfU1lNQk9MUy5FVEhcbiAgfWAsXG4gIFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdOiBgJHt0eXBlZENhcGl0YWxpemUoTkVUV09SS19UWVBFUy5TRVBPTElBKX0ke1xuICAgIENVUlJFTkNZX1NZTUJPTFMuRVRIXG4gIH1gLFxufTtcblxuLyoqXG4gKiBNYXAgb2YgYWxsIGJ1aWxkLWluIEluZnVyYSBuZXR3b3JrcyB0byB0aGVpciBuZXR3b3JrLCB0aWNrZXIgYW5kIGNoYWluIElEcy5cbiAqL1xuZXhwb3J0IGNvbnN0IEJVSUxUX0lOX05FVFdPUktTID0ge1xuICBbTkVUV09SS19UWVBFUy5HT0VSTEldOiB7XG4gICAgbmV0d29ya0lkOiBORVRXT1JLX0lEUy5HT0VSTEksXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkdPRVJMSSxcbiAgICB0aWNrZXI6IFRFU1RfTkVUV09SS19USUNLRVJfTUFQW05FVFdPUktfVFlQRVMuR09FUkxJXSxcbiAgfSxcbiAgW05FVFdPUktfVFlQRVMuU0VQT0xJQV06IHtcbiAgICBuZXR3b3JrSWQ6IE5FVFdPUktfSURTLlNFUE9MSUEsXG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLlNFUE9MSUEsXG4gICAgdGlja2VyOiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLlNFUE9MSUFdLFxuICB9LFxuICBbTkVUV09SS19UWVBFUy5NQUlOTkVUXToge1xuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuTUFJTk5FVCxcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuTUFJTk5FVCxcbiAgfSxcbiAgW05FVFdPUktfVFlQRVMuTE9DQUxIT1NUXToge1xuICAgIG5ldHdvcmtJZDogTkVUV09SS19JRFMuTE9DQUxIT1NULFxuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5MT0NBTEhPU1QsXG4gIH0sXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgTkVUV09SS19UT19OQU1FX01BUCA9IHtcbiAgW05FVFdPUktfVFlQRVMuTUFJTk5FVF06IE1BSU5ORVRfRElTUExBWV9OQU1FLFxuICBbTkVUV09SS19UWVBFUy5HT0VSTEldOiBHT0VSTElfRElTUExBWV9OQU1FLFxuICBbTkVUV09SS19UWVBFUy5TRVBPTElBXTogU0VQT0xJQV9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX1RZUEVTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9ESVNQTEFZX05BTUUsXG5cbiAgW05FVFdPUktfSURTLkdPRVJMSV06IEdPRVJMSV9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX0lEUy5TRVBPTElBXTogU0VQT0xJQV9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX0lEUy5NQUlOTkVUXTogTUFJTk5FVF9ESVNQTEFZX05BTUUsXG4gIFtORVRXT1JLX0lEUy5MT0NBTEhPU1RdOiBMT0NBTEhPU1RfRElTUExBWV9OQU1FLFxuXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogR09FUkxJX0RJU1BMQVlfTkFNRSxcbiAgW0NIQUlOX0lEUy5TRVBPTElBXTogU0VQT0xJQV9ESVNQTEFZX05BTUUsXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE1BSU5ORVRfRElTUExBWV9OQU1FLFxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IExPQ0FMSE9TVF9ESVNQTEFZX05BTUUsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgQ0hBSU5fSURfVE9fVFlQRV9NQVAgPSB7XG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE5FVFdPUktfVFlQRVMuTUFJTk5FVCxcbiAgW0NIQUlOX0lEUy5HT0VSTEldOiBORVRXT1JLX1RZUEVTLkdPRVJMSSxcbiAgW0NIQUlOX0lEUy5TRVBPTElBXTogTkVUV09SS19UWVBFUy5TRVBPTElBLFxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IE5FVFdPUktfVFlQRVMuTE9DQUxIT1NULFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IENIQUlOX0lEX1RPX1JQQ19VUkxfTUFQID0ge1xuICBbQ0hBSU5fSURTLkdPRVJMSV06IEdPRVJMSV9SUENfVVJMLFxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBTRVBPTElBX1JQQ19VUkwsXG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE1BSU5ORVRfUlBDX1VSTCxcbiAgW0NIQUlOX0lEUy5MT0NBTEhPU1RdOiBMT0NBTEhPU1RfUlBDX1VSTCxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBDSEFJTl9JRF9UT19ORVRXT1JLX0lNQUdFX1VSTF9NQVAgPSB7XG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IEVUSF9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogQVZBWF9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuQlNDXTogQk5CX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5QT0xZR09OXTogTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogQUVUSF9UT0tFTl9JTUFHRV9VUkwsXG4gIFtDSEFJTl9JRFMuRkFOVE9NXTogRlRNX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5IQVJNT05ZXTogSEFSTU9OWV9PTkVfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogT1BUSU1JU01fVE9LRU5fSU1BR0VfVVJMLFxuICBbQ0hBSU5fSURTLlBBTE1dOiBQQUxNX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NIQUlOX0lEUy5BVVJPUkFdOiBBVVJPUkFfVE9LRU5fSU1BR0VfVVJMLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IE5FVFdPUktfSURfVE9fRVRIRVJTX05FVFdPUktfTkFNRV9NQVAgPSB7XG4gIFtORVRXT1JLX0lEUy5HT0VSTEldOiBORVRXT1JLX1RZUEVTLkdPRVJMSSxcbiAgW05FVFdPUktfSURTLlNFUE9MSUFdOiBORVRXT1JLX1RZUEVTLlNFUE9MSUEsXG4gIFtORVRXT1JLX0lEUy5NQUlOTkVUXTogTkVUV09SS19OQU1FUy5IT01FU1RFQUQsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVAgPSB7XG4gIFtDSEFJTl9JRFMuTUFJTk5FVF06IE5FVFdPUktfSURTLk1BSU5ORVQsXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogTkVUV09SS19JRFMuR09FUkxJLFxuICBbQ0hBSU5fSURTLlNFUE9MSUFdOiBORVRXT1JLX0lEUy5TRVBPTElBLFxuICBbQ0hBSU5fSURTLkxPQ0FMSE9TVF06IE5FVFdPUktfSURTLkxPQ0FMSE9TVCxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBOQVRJVkVfQ1VSUkVOQ1lfVE9LRU5fSU1BR0VfTUFQID0ge1xuICBbQ1VSUkVOQ1lfU1lNQk9MUy5FVEhdOiBFVEhfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5URVNUX0VUSF06IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NVUlJFTkNZX1NZTUJPTFMuQk5CXTogQk5CX1RPS0VOX0lNQUdFX1VSTCxcbiAgW0NVUlJFTkNZX1NZTUJPTFMuTUFUSUNdOiBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXG4gIFtDVVJSRU5DWV9TWU1CT0xTLkFWQUxBTkNIRV06IEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxuICBbQ1VSUkVOQ1lfU1lNQk9MUy5PUFRJTUlTTV06IE9QVElNSVNNX1RPS0VOX0lNQUdFX1VSTCxcbn0gYXMgY29uc3Q7XG5cbmV4cG9ydCBjb25zdCBJTkZVUkFfQkxPQ0tFRF9LRVkgPSAnY291bnRyeUJsb2NrZWQnO1xuXG4vKipcbiAqIEhhcmRmb3JrcyBhcmUgcG9pbnRzIGluIHRoZSBjaGFpbiB3aGVyZSBsb2dpYyBpcyBjaGFuZ2VkIHNpZ25pZmljYW50bHlcbiAqIGVub3VnaCB3aGVyZSB0aGVyZSBpcyBhIGZvcmsgYW5kIHRoZSBuZXcgZm9yayBiZWNvbWVzIHRoZSBhY3RpdmUgY2hhaW4uXG4gKiBUaGVzZSBjb25zdGFudHMgYXJlIHByZXNlbnRlZCBpbiBjaHJvbm9sb2dpY2FsIG9yZGVyIHN0YXJ0aW5nIHdpdGggQkVSTElOXG4gKiBiZWNhdXNlIHdoZW4gd2UgZmlyc3QgbmVlZGVkIHRvIHRyYWNrIHRoZSBoYXJkZm9yayB3ZSBoYWQgbGF1bmNoZWQgc3VwcG9ydFxuICogZm9yIEVJUC0yNzE4ICh3aGVyZSB0cmFuc2FjdGlvbnMgY2FuIGhhdmUgdHlwZXMgYW5kIGRpZmZlcmVudCBzaGFwZXMpIGFuZFxuICogRUlQLTI5MzAgKG9wdGlvbmFsIGFjY2VzcyBsaXN0cyksIHdoaWNoIHdlcmUgaW5jbHVkZWQgaW4gQkVSTElOLlxuICpcbiAqIEJFUkxJTiAtIGZvcmtlZCBhdCBibG9jayBudW1iZXIgMTIsMjQ0LDAwMCwgaW5jbHVkZWQgdHlwZWQgdHJhbnNhY3Rpb25zIGFuZFxuICogb3B0aW9uYWwgYWNjZXNzIGxpc3RzXG4gKiBMT05ET04gLSBmdXR1cmUsIHVwY29taW5nIGZvcmsgdGhhdCBpbnRyb2R1Y2VzIHRoZSBiYXNlRmVlUGVyR2FzLCBhbiBhbW91bnRcbiAqIG9mIHRoZSBFVEggdHJhbnNhY3Rpb24gZmVlcyB0aGF0IHdpbGwgYmUgYnVybmVkIGluc3RlYWQgb2YgZ2l2ZW4gdG8gdGhlXG4gKiBtaW5lci4gVGhpcyBjaGFuZ2UgbmVjZXNzaXRhdGVkIHRoZSB0aGlyZCB0eXBlIG9mIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvXG4gKiBzcGVjaWZ5IG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgbW92aW5nIHRoZSBmZWUgYmlkZGluZyBzeXN0ZW1cbiAqIHRvIGEgc2Vjb25kIHByaWNlIGF1Y3Rpb24gbW9kZWwuXG4gKi9cbmV4cG9ydCBjb25zdCBIQVJERk9SS1MgPSB7XG4gIEJFUkxJTjogJ2JlcmxpbicsXG4gIExPTkRPTjogJ2xvbmRvbicsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVAgPSB7XG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiAxLFxuICBbQ0hBSU5fSURTLk9QVElNSVNNX1RFU1RORVRdOiAxLFxufTtcblxuLyoqXG4gKiBFdGhlcmV1bSBKU09OLVJQQyBtZXRob2RzIHRoYXQgYXJlIGtub3duIHRvIGV4aXN0IGJ1dCB0aGF0IHdlIGludGVudGlvbmFsbHlcbiAqIGRvIG5vdCBzdXBwb3J0LlxuICovXG5leHBvcnQgY29uc3QgVU5TVVBQT1JURURfUlBDX01FVEhPRFMgPSBuZXcgU2V0KFtcbiAgLy8gVGhpcyBpcyBpbXBsZW1lbnRlZCBsYXRlciBpbiBvdXIgbWlkZGxld2FyZSBzdGFjayDigJMgc3BlY2lmaWNhbGx5LCBpblxuICAvLyBldGgtanNvbi1ycGMtbWlkZGxld2FyZSDigJMgYnV0IG91ciBVSSBkb2VzIG5vdCBzdXBwb3J0IGl0LlxuICAnZXRoX3NpZ25UcmFuc2FjdGlvbicgYXMgY29uc3QsXG5dKTtcblxuZXhwb3J0IGNvbnN0IElQRlNfREVGQVVMVF9HQVRFV0FZX1VSTCA9ICdkd2ViLmxpbmsnO1xuXG4vLyBUaGUgZmlyc3QgaXRlbSBpbiB0cmFuc2FrQ3VycmVuY2llcyBtdXN0IGJlIHRoZVxuLy8gZGVmYXVsdCBjcnlwdG8gY3VycmVuY3kgZm9yIHRoZSBuZXR3b3JrXG5jb25zdCBCVVlBQkxFX0NIQUlOX0VUSEVSRVVNX05FVFdPUktfTkFNRSA9ICdldGhlcmV1bSc7XG5cbmV4cG9ydCBjb25zdCBCVVlBQkxFX0NIQUlOU19NQVA6IHtcbiAgW0sgaW4gRXhjbHVkZTxcbiAgICBDaGFpbklkLFxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5MT0NBTEhPU1RcbiAgICB8IHR5cGVvZiBDSEFJTl9JRFMuUEFMTVxuICAgIHwgdHlwZW9mIENIQUlOX0lEUy5IQVJNT05ZXG4gICAgfCB0eXBlb2YgQ0hBSU5fSURTLk9QVElNSVNNX1RFU1RORVRcbiAgPl06IEJ1eWFibGVDaGFpblNldHRpbmdzO1xufSA9IHtcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICBuZXR3b3JrOiBCVVlBQkxFX0NIQUlOX0VUSEVSRVVNX05FVFdPUktfTkFNRSxcbiAgICB0cmFuc2FrQ3VycmVuY2llczogW1xuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFNbJzFJTkNIJ10sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BQVZFLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQUdFVVIsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CVVNELFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ0hBSU4sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DTFYsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DT01QLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ1RTSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkRBSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkRBTyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVOSixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVVUlQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5HVEgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5IRVgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5MSU5LLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUFOQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BU0ssXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NSU5EUyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1LUixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlBMQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlBPTFMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TQU5ELFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU1RFVEgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TVVNISSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNXQVAsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5UWEwsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VTkksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlZSQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLldCVEMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5ZTEQsXG4gICAgXSxcbiAgICBtb29uUGF5OiB7XG4gICAgICBkZWZhdWx0Q3VycmVuY3lDb2RlOiBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXG4gICAgICBzaG93T25seUN1cnJlbmNpZXM6IFtcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RULFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RDLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5EQUksXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5PUk4sXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLldFVEgsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLklNWCxcbiAgICAgIF0sXG4gICAgfSxcbiAgICB3eXJlOiB7XG4gICAgICBzcm46ICdldGhlcmV1bScsXG4gICAgICBjdXJyZW5jeUNvZGU6IENVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgICAgY3VycmVuY2llczogW1xuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFBVkUsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJBVCxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQlVTRCxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ09NUCxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ1JWLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5EQUksXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkdVU0QsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkdZRU4sXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkxJTkssXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1LUixcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUEFYLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5SQUksXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNOWCxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVU1BLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VTkksXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTREMsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTRFMsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTRFQsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLldCVEMsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLldFVEgsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLllGSSxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuWlVTRCxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBjb2luYmFzZVBheUN1cnJlbmNpZXM6IFtcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTWycxSU5DSCddLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQUFWRSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFCVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFDSCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFHTEQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BTVAsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BTktSLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQVBFLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQVJQQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFTTSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFVQ1RJT04sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BWFMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CQURHRVIsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CQUwsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CQU5ELFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQkFULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQk5ULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQk9CQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJPTkQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CVFJTVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNIWixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNMVixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNPTVAsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DT1RJLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ1JPLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ1JWLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ1RTSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkNWQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkRBSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkREWCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkROVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVOSixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkVOUyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkZBUk0sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5GRVQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5GT1JUSCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkZYLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuR05PLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuR1JULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuR1RDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuSU9UWCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkpBU01ZLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuS0VFUCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLktOQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLktSTCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkxDWCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkxJTkssXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5MUFQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5MUkMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NQU5BLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUFTSyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUlSLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUtSLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUxOLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTVRMLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTktOLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTk1SLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTlUsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5PR04sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5PTUcsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5PWFQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5QQVgsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5QRVJQLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUExBLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUE9MWSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlFOVCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlFVSUNLLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUkFELFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUkFJLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuUkFSSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJFTixcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJFUCxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJFUSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJMQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlJMWSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlNBTkQsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TSElCLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU0tMLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU05YLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU1RPUkosXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TVUtVLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU1VTSEksXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5TV0ZUQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlRSQUMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5UUkIsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5UUklCRSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlRSVSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVNQSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVOSSxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTREMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuV0JUQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLldDRkcsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5YWU8sXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5ZRklJLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuWlJYLFxuICAgIF0sXG4gIH0sXG4gIFtDSEFJTl9JRFMuR09FUkxJXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBURVNUX05FVFdPUktfVElDS0VSX01BUFtORVRXT1JLX1RZUEVTLkdPRVJMSV0sXG4gICAgbmV0d29yazogQlVZQUJMRV9DSEFJTl9FVEhFUkVVTV9ORVRXT1JLX05BTUUsXG4gIH0sXG4gIFtDSEFJTl9JRFMuU0VQT0xJQV06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogVEVTVF9ORVRXT1JLX1RJQ0tFUl9NQVBbTkVUV09SS19UWVBFUy5TRVBPTElBXSxcbiAgICBuZXR3b3JrOiBCVVlBQkxFX0NIQUlOX0VUSEVSRVVNX05FVFdPUktfTkFNRSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5CU0NdOiB7XG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQk5CLFxuICAgIG5ldHdvcms6ICdic2MnLFxuICAgIHRyYW5zYWtDdXJyZW5jaWVzOiBbXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CTkIsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5CVVNELFxuICAgIF0sXG4gICAgbW9vblBheToge1xuICAgICAgZGVmYXVsdEN1cnJlbmN5Q29kZTogYCR7U1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQk5CfV9CU0NgLFxuICAgICAgc2hvd09ubHlDdXJyZW5jaWVzOiBbXG4gICAgICAgIGAke1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJOQn1fQlNDYCxcbiAgICAgICAgYCR7U1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQlVTRH1fQlNDYCxcbiAgICAgIF0sXG4gICAgfSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5QT0xZR09OXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICAgIG5ldHdvcms6ICdwb2x5Z29uJyxcbiAgICB0cmFuc2FrQ3VycmVuY2llczogW1xuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUFUSUMsXG4gICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RULFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkRBSSxcbiAgICBdLFxuICAgIG1vb25QYXk6IHtcbiAgICAgIGRlZmF1bHRDdXJyZW5jeUNvZGU6IGAke1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkJOQn1fUE9MWUdPTmAsXG4gICAgICBzaG93T25seUN1cnJlbmNpZXM6IFtcbiAgICAgICAgYCR7U1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuTUFUSUN9X1BPTFlHT05gLFxuICAgICAgICBgJHtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5VU0RDfV9QT0xZR09OYCxcbiAgICAgIF0sXG4gICAgfSxcbiAgICB3eXJlOiB7XG4gICAgICBzcm46ICdtYXRpYycsXG4gICAgICBjdXJyZW5jeUNvZGU6IENVUlJFTkNZX1NZTUJPTFMuTUFUSUMsXG4gICAgICBjdXJyZW5jaWVzOiBbXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICAgICAgICBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5NVVNEQyxcbiAgICAgIF0sXG4gICAgfSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiB7XG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFLFxuICAgIG5ldHdvcms6ICdhdmF4Y2NoYWluJyxcbiAgICB0cmFuc2FrQ3VycmVuY2llczogW1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFWQUxBTkNIRV0sXG4gICAgbW9vblBheToge1xuICAgICAgZGVmYXVsdEN1cnJlbmN5Q29kZTogYCR7U1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQVZBWH1fQ0NIQUlOYCxcbiAgICAgIHNob3dPbmx5Q3VycmVuY2llczogW2Ake1NVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFWQVh9X0NDSEFJTmBdLFxuICAgIH0sXG4gICAgd3lyZToge1xuICAgICAgc3JuOiAnYXZhbGFuY2hlJyxcbiAgICAgIGN1cnJlbmN5Q29kZTogQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEUsXG4gICAgICBjdXJyZW5jaWVzOiBbXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFWQUxBTkNIRSxcbiAgICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQVZBWEMsXG4gICAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFWQVhDVVNEQyxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBjb2luYmFzZVBheUN1cnJlbmNpZXM6IFtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5BVkFMQU5DSEVdLFxuICB9LFxuICBbQ0hBSU5fSURTLkZBTlRPTV06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5GQU5UT00sXG4gICAgbmV0d29yazogJ2ZhbnRvbScsXG4gICAgdHJhbnNha0N1cnJlbmNpZXM6IFtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5GQU5UT01dLFxuICB9LFxuICBbQ0hBSU5fSURTLkNFTE9dOiB7XG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQ0VMTyxcbiAgICBuZXR3b3JrOiAnY2VsbycsXG4gICAgdHJhbnNha0N1cnJlbmNpZXM6IFtTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DRUxPXSxcbiAgICBtb29uUGF5OiB7XG4gICAgICBkZWZhdWx0Q3VycmVuY3lDb2RlOiBTVVBQT1JURURfQ1VSUkVOQ1lfU1lNQk9MUy5DRUxPLFxuICAgICAgc2hvd09ubHlDdXJyZW5jaWVzOiBbU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQ0VMT10sXG4gICAgfSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5PUFRJTUlTTV06IHtcbiAgICBuYXRpdmVDdXJyZW5jeTogQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXG4gICAgbmV0d29yazogJ29wdGltaXNtJyxcbiAgICB0cmFuc2FrQ3VycmVuY2llczogW1xuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuRVRILFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEQyxcbiAgICBdLFxuICB9LFxuICBbQ0hBSU5fSURTLkFSQklUUlVNXToge1xuICAgIG5hdGl2ZUN1cnJlbmN5OiBDVVJSRU5DWV9TWU1CT0xTLkFSQklUUlVNLFxuICAgIG5ldHdvcms6ICdhcmJpdHJ1bScsXG4gICAgdHJhbnNha0N1cnJlbmNpZXM6IFtcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLkFSQklUUlVNLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuU1BBLFxuICAgICAgU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuVVNEQyxcbiAgICAgIFNVUFBPUlRFRF9DVVJSRU5DWV9TWU1CT0xTLlVTRFMsXG4gICAgXSxcbiAgfSxcbiAgW0NIQUlOX0lEUy5BVVJPUkFdOiB7XG4gICAgbmF0aXZlQ3VycmVuY3k6IENVUlJFTkNZX1NZTUJPTFMuQVVST1JBLFxuICAgIG5ldHdvcms6ICdhdXJvcmEnLFxuICAgIHRyYW5zYWtDdXJyZW5jaWVzOiBbU1VQUE9SVEVEX0NVUlJFTkNZX1NZTUJPTFMuQVVST1JBXSxcbiAgfSxcbn07XG5cbmV4cG9ydCBjb25zdCBGRUFUVVJFRF9SUENTOiBSUENEZWZpbml0aW9uW10gPSBbXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuQVJCSVRSVU0sXG4gICAgbmlja25hbWU6IEFSQklUUlVNX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6IGBodHRwczovL2FyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLkFSQklUUlVNLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5hcmJpdHJ1bS5pbycsXG4gICAgICBpbWFnZVVybDogQUVUSF9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5BVVJPUkEsXG4gICAgbmlja25hbWU6IEFVUk9SQV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hdXJvcmEtbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuQVVST1JBLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9hdXJvcmFzY2FuLmRldi8nLFxuICAgICAgaW1hZ2VVcmw6IEFVUk9SQV9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5BVkFMQU5DSEUsXG4gICAgbmlja25hbWU6IEFWQUxBTkNIRV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9hdmFsYW5jaGUtbWFpbm5ldC5pbmZ1cmEuaW8vdjMvJHtpbmZ1cmFQcm9qZWN0SWR9YCxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9zbm93dHJhY2UuaW8vJyxcbiAgICAgIGltYWdlVXJsOiBBVkFYX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkJTQyxcbiAgICBuaWNrbmFtZTogQk5CX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6ICdodHRwczovL2JzYy1kYXRhc2VlZC5iaW5hbmNlLm9yZy8nLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5CTkIsXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL2JzY3NjYW4uY29tLycsXG4gICAgICBpbWFnZVVybDogQk5CX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLkZBTlRPTSxcbiAgICBuaWNrbmFtZTogRkFOVE9NX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6ICdodHRwczovL3JwYy5mdG0udG9vbHMvJyxcbiAgICB0aWNrZXI6IENVUlJFTkNZX1NZTUJPTFMuRkFOVE9NLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9mdG1zY2FuLmNvbS8nLFxuICAgICAgaW1hZ2VVcmw6IEZUTV9UT0tFTl9JTUFHRV9VUkwsXG4gICAgfSxcbiAgfSxcbiAge1xuICAgIGNoYWluSWQ6IENIQUlOX0lEUy5IQVJNT05ZLFxuICAgIG5pY2tuYW1lOiBIQVJNT05ZX0RJU1BMQVlfTkFNRSxcbiAgICBycGNVcmw6ICdodHRwczovL2FwaS5oYXJtb255Lm9uZS8nLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5IQVJNT05ZLFxuICAgIHJwY1ByZWZzOiB7XG4gICAgICBibG9ja0V4cGxvcmVyVXJsOiAnaHR0cHM6Ly9leHBsb3Jlci5oYXJtb255Lm9uZS8nLFxuICAgICAgaW1hZ2VVcmw6IEhBUk1PTllfT05FX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLk9QVElNSVNNLFxuICAgIG5pY2tuYW1lOiBPUFRJTUlTTV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9vcHRpbWlzbS1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5FVEgsXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL29wdGltaXN0aWMuZXRoZXJzY2FuLmlvLycsXG4gICAgICBpbWFnZVVybDogT1BUSU1JU01fVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG4gIHtcbiAgICBjaGFpbklkOiBDSEFJTl9JRFMuUEFMTSxcbiAgICBuaWNrbmFtZTogUEFMTV9ESVNQTEFZX05BTUUsXG4gICAgcnBjVXJsOiBgaHR0cHM6Ly9wYWxtLW1haW5uZXQuaW5mdXJhLmlvL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgdGlja2VyOiBDVVJSRU5DWV9TWU1CT0xTLlBBTE0sXG4gICAgcnBjUHJlZnM6IHtcbiAgICAgIGJsb2NrRXhwbG9yZXJVcmw6ICdodHRwczovL2V4cGxvcmVyLnBhbG0uaW8vJyxcbiAgICAgIGltYWdlVXJsOiBQQUxNX1RPS0VOX0lNQUdFX1VSTCxcbiAgICB9LFxuICB9LFxuICB7XG4gICAgY2hhaW5JZDogQ0hBSU5fSURTLlBPTFlHT04sXG4gICAgbmlja25hbWU6IGAke1BPTFlHT05fRElTUExBWV9OQU1FfSAke2NhcGl0YWxpemUoTkVUV09SS19UWVBFUy5NQUlOTkVUKX1gLFxuICAgIHJwY1VybDogYGh0dHBzOi8vcG9seWdvbi1tYWlubmV0LmluZnVyYS5pby92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgIHRpY2tlcjogQ1VSUkVOQ1lfU1lNQk9MUy5NQVRJQyxcbiAgICBycGNQcmVmczoge1xuICAgICAgYmxvY2tFeHBsb3JlclVybDogJ2h0dHBzOi8vcG9seWdvbnNjYW4uY29tLycsXG4gICAgICBpbWFnZVVybDogTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxuICAgIH0sXG4gIH0sXG5dO1xuIiwiZXhwb3J0IGNvbnN0IENhdmVhdFR5cGVzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHJlc3RyaWN0UmV0dXJuZWRBY2NvdW50czogJ3Jlc3RyaWN0UmV0dXJuZWRBY2NvdW50cycgYXMgY29uc3QsXG59KTtcblxuZXhwb3J0IGNvbnN0IFJlc3RyaWN0ZWRNZXRob2RzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIGV0aF9hY2NvdW50czogJ2V0aF9hY2NvdW50cycsXG4gIC8vLzogQkVHSU46T05MWV9JTkNMVURFX0lOKGZsYXNrKVxuICBzbmFwX2NvbmZpcm06ICdzbmFwX2NvbmZpcm0nLFxuICBzbmFwX25vdGlmeTogJ3NuYXBfbm90aWZ5JyxcbiAgc25hcF9tYW5hZ2VTdGF0ZTogJ3NuYXBfbWFuYWdlU3RhdGUnLFxuICBzbmFwX2dldEJpcDMyUHVibGljS2V5OiAnc25hcF9nZXRCaXAzMlB1YmxpY0tleScsXG4gIHNuYXBfZ2V0QmlwMzJFbnRyb3B5OiAnc25hcF9nZXRCaXAzMkVudHJvcHknLFxuICBzbmFwX2dldEJpcDQ0RW50cm9weTogJ3NuYXBfZ2V0QmlwNDRFbnRyb3B5JyxcbiAgJ3dhbGxldF9zbmFwXyonOiAnd2FsbGV0X3NuYXBfKicsXG4gIC8vLzogRU5EOk9OTFlfSU5DTFVERV9JTlxufSBhcyBjb25zdCk7XG5cbi8vLzogQkVHSU46T05MWV9JTkNMVURFX0lOKGZsYXNrKVxuZXhwb3J0IGNvbnN0IFBlcm1pc3Npb25OYW1lc3BhY2VzID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHdhbGxldF9zbmFwXzogJ3dhbGxldF9zbmFwXyonLFxufSBhcyBjb25zdCk7XG5cbmV4cG9ydCBjb25zdCBFbmRvd21lbnRQZXJtaXNzaW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICAnZW5kb3dtZW50Om5ldHdvcmstYWNjZXNzJzogJ2VuZG93bWVudDpuZXR3b3JrLWFjY2VzcycsXG4gICdlbmRvd21lbnQ6bG9uZy1ydW5uaW5nJzogJ2VuZG93bWVudDpsb25nLXJ1bm5pbmcnLFxuICAnZW5kb3dtZW50OnRyYW5zYWN0aW9uLWluc2lnaHQnOiAnZW5kb3dtZW50OnRyYW5zYWN0aW9uLWluc2lnaHQnLFxuICAnZW5kb3dtZW50OmNyb25qb2InOiAnZW5kb3dtZW50OmNyb25qb2InLFxufSBhcyBjb25zdCk7XG5cbi8vIE1ldGhvZHMgLyBwZXJtaXNzaW9ucyBpbiBleHRlcm5hbCBwYWNrYWdlcyB0aGF0IHdlIGFyZSB0ZW1wb3JhcmlseSBleGNsdWRpbmcuXG5leHBvcnQgY29uc3QgRXhjbHVkZWRTbmFwUGVybWlzc2lvbnMgPSBuZXcgU2V0KFsnc25hcF9kaWFsb2cnXSk7XG5leHBvcnQgY29uc3QgRXhjbHVkZWRTbmFwRW5kb3dtZW50cyA9IG5ldyBTZXQoWydlbmRvd21lbnQ6a2V5cmluZyddKTtcbi8vLzogRU5EOk9OTFlfSU5DTFVERV9JTlxuIiwiaW1wb3J0IHtcbiAgRVRIX1RPS0VOX0lNQUdFX1VSTCxcbiAgVEVTVF9FVEhfVE9LRU5fSU1BR0VfVVJMLFxuICBCTkJfVE9LRU5fSU1BR0VfVVJMLFxuICBNQVRJQ19UT0tFTl9JTUFHRV9VUkwsXG4gIEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxuICBDVVJSRU5DWV9TWU1CT0xTLFxuICBDSEFJTl9JRFMsXG59IGZyb20gJy4vbmV0d29yayc7XG5cbmV4cG9ydCBjb25zdCBRVU9URVNfRVhQSVJFRF9FUlJPUiA9ICdxdW90ZXMtZXhwaXJlZCc7XG5leHBvcnQgY29uc3QgU1dBUF9GQUlMRURfRVJST1IgPSAnc3dhcC1mYWlsZWQtZXJyb3InO1xuZXhwb3J0IGNvbnN0IEVSUk9SX0ZFVENISU5HX1FVT1RFUyA9ICdlcnJvci1mZXRjaGluZy1xdW90ZXMnO1xuZXhwb3J0IGNvbnN0IFFVT1RFU19OT1RfQVZBSUxBQkxFX0VSUk9SID0gJ3F1b3Rlcy1ub3QtYXZpbGFibGUnO1xuZXhwb3J0IGNvbnN0IENPTlRSQUNUX0RBVEFfRElTQUJMRURfRVJST1IgPSAnY29udHJhY3QtZGF0YS1kaXNhYmxlZCc7XG5leHBvcnQgY29uc3QgT0ZGTElORV9GT1JfTUFJTlRFTkFOQ0UgPSAnb2ZmbGluZS1mb3ItbWFpbnRlbmFuY2UnO1xuZXhwb3J0IGNvbnN0IFNXQVBTX0ZFVENIX09SREVSX0NPTkZMSUNUID0gJ3N3YXBzLWZldGNoLW9yZGVyLWNvbmZsaWN0JztcblxuLy8gQW4gYWRkcmVzcyB0aGF0IHRoZSBtZXRhc3dhcC1hcGkgcmVjb2duaXplcyBhcyB0aGUgZGVmYXVsdCB0b2tlbiBmb3IgdGhlIGN1cnJlbnQgbmV0d29yaywgaW4gcGxhY2Ugb2YgdGhlIHRva2VuIGFkZHJlc3MgdGhhdCBFUkMtMjAgdG9rZW5zIGhhdmVcbmNvbnN0IERFRkFVTFRfVE9LRU5fQUREUkVTUyA9ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xuXG5leHBvcnQgY29uc3QgRVRIX1NXQVBTX1RPS0VOX09CSkVDVCA9IHtcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgbmFtZTogJ0V0aGVyJyxcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxuICBkZWNpbWFsczogMTgsXG4gIGljb25Vcmw6IEVUSF9UT0tFTl9JTUFHRV9VUkwsXG59O1xuXG5leHBvcnQgY29uc3QgQk5CX1NXQVBTX1RPS0VOX09CSkVDVCA9IHtcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLkJOQixcbiAgbmFtZTogJ0JpbmFuY2UgQ29pbicsXG4gIGFkZHJlc3M6IERFRkFVTFRfVE9LRU5fQUREUkVTUyxcbiAgZGVjaW1hbHM6IDE4LFxuICBpY29uVXJsOiBCTkJfVE9LRU5fSU1BR0VfVVJMLFxufTtcblxuZXhwb3J0IGNvbnN0IE1BVElDX1NXQVBTX1RPS0VOX09CSkVDVCA9IHtcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLk1BVElDLFxuICBuYW1lOiAnTWF0aWMnLFxuICBhZGRyZXNzOiBERUZBVUxUX1RPS0VOX0FERFJFU1MsXG4gIGRlY2ltYWxzOiAxOCxcbiAgaWNvblVybDogTUFUSUNfVE9LRU5fSU1BR0VfVVJMLFxufTtcblxuZXhwb3J0IGNvbnN0IEFWQVhfU1dBUFNfVE9LRU5fT0JKRUNUID0ge1xuICBzeW1ib2w6IENVUlJFTkNZX1NZTUJPTFMuQVZBTEFOQ0hFLFxuICBuYW1lOiAnQXZhbGFuY2hlJyxcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxuICBkZWNpbWFsczogMTgsXG4gIGljb25Vcmw6IEFWQVhfVE9LRU5fSU1BR0VfVVJMLFxufTtcblxuZXhwb3J0IGNvbnN0IFRFU1RfRVRIX1NXQVBTX1RPS0VOX09CSkVDVCA9IHtcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLlRFU1RfRVRILFxuICBuYW1lOiAnVGVzdCBFdGhlcicsXG4gIGFkZHJlc3M6IERFRkFVTFRfVE9LRU5fQUREUkVTUyxcbiAgZGVjaW1hbHM6IDE4LFxuICBpY29uVXJsOiBURVNUX0VUSF9UT0tFTl9JTUFHRV9VUkwsXG59O1xuXG5leHBvcnQgY29uc3QgR09FUkxJX1NXQVBTX1RPS0VOX09CSkVDVCA9IHtcbiAgc3ltYm9sOiBDVVJSRU5DWV9TWU1CT0xTLkVUSCxcbiAgbmFtZTogJ0V0aGVyJyxcbiAgYWRkcmVzczogREVGQVVMVF9UT0tFTl9BRERSRVNTLFxuICBkZWNpbWFsczogMTgsXG4gIGljb25Vcmw6IFRFU1RfRVRIX1RPS0VOX0lNQUdFX1VSTCxcbn07XG5cbmV4cG9ydCBjb25zdCBBUkJJVFJVTV9TV0FQU19UT0tFTl9PQkpFQ1QgPSB7IC4uLkVUSF9TV0FQU19UT0tFTl9PQkpFQ1QgfTtcblxuZXhwb3J0IGNvbnN0IE9QVElNSVNNX1NXQVBTX1RPS0VOX09CSkVDVCA9IHsgLi4uRVRIX1NXQVBTX1RPS0VOX09CSkVDVCB9O1xuXG4vLyBBIGdhcyB2YWx1ZSBmb3IgRVJDMjAgYXBwcm92ZSBjYWxscyB0aGF0IHNob3VsZCBiZSBzdWZmaWNpZW50IGZvciBhbGwgRVJDMjAgYXBwcm92ZSBpbXBsZW1lbnRhdGlvbnNcbmV4cG9ydCBjb25zdCBERUZBVUxUX0VSQzIwX0FQUFJPVkVfR0FTID0gJzB4MWQ0YzAnO1xuXG5jb25zdCBNQUlOTkVUX0NPTlRSQUNUX0FERFJFU1MgPSAnMHg4ODFkNDAyMzc2NTljMjUxODExY2VjOWMzNjRlZjkxZGMwOGQzMDBjJztcblxuY29uc3QgVEVTVE5FVF9DT05UUkFDVF9BRERSRVNTID0gJzB4ODgxZDQwMjM3NjU5YzI1MTgxMWNlYzljMzY0ZWY5MWRjMDhkMzAwYyc7XG5cbmNvbnN0IEJTQ19DT05UUkFDVF9BRERSRVNTID0gJzB4MWExZWMyNWRjMDhlOThlNWU5M2YxMTA0YjVlNWNkZDI5ODcwN2QzMSc7XG5cbi8vIEl0J3MgdGhlIHNhbWUgYXMgd2UgdXNlIGZvciBCU0MuXG5jb25zdCBQT0xZR09OX0NPTlRSQUNUX0FERFJFU1MgPSAnMHgxYTFlYzI1ZGMwOGU5OGU1ZTkzZjExMDRiNWU1Y2RkMjk4NzA3ZDMxJztcbmNvbnN0IEFWQUxBTkNIRV9DT05UUkFDVF9BRERSRVNTID0gJzB4MWExZWMyNWRjMDhlOThlNWU5M2YxMTA0YjVlNWNkZDI5ODcwN2QzMSc7XG5jb25zdCBPUFRJTUlTTV9DT05UUkFDVF9BRERSRVNTID0gJzB4OWREQTZFZjNEOTE5YzliQzg4ODVENTU2MDk5OUEzNjQwNDMxZThlNic7XG5jb25zdCBBUkJJVFJVTV9DT05UUkFDVF9BRERSRVNTID0gJzB4OWREQTZFZjNEOTE5YzliQzg4ODVENTU2MDk5OUEzNjQwNDMxZThlNic7XG5cbmV4cG9ydCBjb25zdCBXRVRIX0NPTlRSQUNUX0FERFJFU1MgPVxuICAnMHhjMDJhYWEzOWIyMjNmZThkMGEwZTVjNGYyN2VhZDkwODNjNzU2Y2MyJztcbmV4cG9ydCBjb25zdCBXRVRIX0dPRVJMSV9DT05UUkFDVF9BRERSRVNTID1cbiAgJzB4QjRGQkYyNzExNDNGNEZCZjdCOTFBNWRlZDMxODA1ZTQyYjIyMDhkNic7XG5leHBvcnQgY29uc3QgV0JOQl9DT05UUkFDVF9BRERSRVNTID1cbiAgJzB4YmI0Y2RiOWNiZDM2YjAxYmQxY2JhZWJmMmRlMDhkOTE3M2JjMDk1Yyc7XG5leHBvcnQgY29uc3QgV01BVElDX0NPTlRSQUNUX0FERFJFU1MgPVxuICAnMHgwZDUwMGIxZDhlOGVmMzFlMjFjOTlkMWRiOWE2NDQ0ZDNhZGYxMjcwJztcbmV4cG9ydCBjb25zdCBXQVZBWF9DT05UUkFDVF9BRERSRVNTID1cbiAgJzB4YjMxZjY2YWEzYzFlNzg1MzYzZjA4NzVhMWI3NGUyN2I4NWZkNjZjNyc7XG5cbmV4cG9ydCBjb25zdCBXRVRIX09QVElNSVNNX0NPTlRSQUNUX0FERFJFU1MgPVxuICAnMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA2JztcbmV4cG9ydCBjb25zdCBXRVRIX0FSQklUUlVNX0NPTlRSQUNUX0FERFJFU1MgPVxuICAnMHg4MmFGNDk0NDdEOGEwN2UzYmQ5NUJEMGQ1NmYzNTI0MTUyM2ZCYWIxJztcblxuY29uc3QgU1dBUFNfVEVTVE5FVF9DSEFJTl9JRCA9ICcweDUzOSc7XG5cbmV4cG9ydCBjb25zdCBTV0FQU19BUElfVjJfQkFTRV9VUkwgPSAnaHR0cHM6Ly9zd2FwLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrJztcbmV4cG9ydCBjb25zdCBTV0FQU19ERVZfQVBJX1YyX0JBU0VfVVJMID1cbiAgJ2h0dHBzOi8vc3dhcC5tZXRhc3dhcC1kZXYuY29kZWZpLm5ldHdvcmsnO1xuZXhwb3J0IGNvbnN0IEdBU19BUElfQkFTRV9VUkwgPSAnaHR0cHM6Ly9nYXMtYXBpLm1ldGFzd2FwLmNvZGVmaS5uZXR3b3JrJztcbmV4cG9ydCBjb25zdCBHQVNfREVWX0FQSV9CQVNFX1VSTCA9XG4gICdodHRwczovL2dhcy1hcGkubWV0YXN3YXAtZGV2LmNvZGVmaS5uZXR3b3JrJztcblxuY29uc3QgQlNDX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMID0gJ2h0dHBzOi8vYnNjc2Nhbi5jb20vJztcbmNvbnN0IE1BSU5ORVRfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9ldGhlcnNjYW4uaW8vJztcbmNvbnN0IEdPRVJMSV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL2dvZXJsaS5ldGhlcnNjYW4uaW8vJztcbmNvbnN0IFBPTFlHT05fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9wb2x5Z29uc2Nhbi5jb20vJztcbmNvbnN0IEFWQUxBTkNIRV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCA9ICdodHRwczovL3Nub3d0cmFjZS5pby8nO1xuY29uc3QgT1BUSU1JU01fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9vcHRpbWlzdGljLmV0aGVyc2Nhbi5pby8nO1xuY29uc3QgQVJCSVRSVU1fREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwgPSAnaHR0cHM6Ly9hcmJpc2Nhbi5pby8nO1xuXG5leHBvcnQgY29uc3QgQUxMT1dFRF9QUk9EX1NXQVBTX0NIQUlOX0lEUyA9IFtcbiAgQ0hBSU5fSURTLk1BSU5ORVQsXG4gIFNXQVBTX1RFU1RORVRfQ0hBSU5fSUQsXG4gIENIQUlOX0lEUy5CU0MsXG4gIENIQUlOX0lEUy5QT0xZR09OLFxuICBDSEFJTl9JRFMuQVZBTEFOQ0hFLFxuICBDSEFJTl9JRFMuT1BUSU1JU00sXG4gIENIQUlOX0lEUy5BUkJJVFJVTSxcbl07XG5cbmV4cG9ydCBjb25zdCBBTExPV0VEX0RFVl9TV0FQU19DSEFJTl9JRFMgPSBbXG4gIC4uLkFMTE9XRURfUFJPRF9TV0FQU19DSEFJTl9JRFMsXG4gIENIQUlOX0lEUy5HT0VSTEksXG5dO1xuXG5leHBvcnQgY29uc3QgQUxMT1dFRF9TTUFSVF9UUkFOU0FDVElPTlNfQ0hBSU5fSURTID0gW1xuICBDSEFJTl9JRFMuTUFJTk5FVCxcbiAgQ0hBSU5fSURTLkdPRVJMSSxcbl07XG5cbmV4cG9ydCBjb25zdCBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQID0ge1xuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXTogVEVTVE5FVF9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLkJTQ106IEJTQ19DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBQT0xZR09OX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogVEVTVE5FVF9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLkFWQUxBTkNIRV06IEFWQUxBTkNIRV9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogT1BUSU1JU01fQ09OVFJBQ1RfQUREUkVTUyxcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IEFSQklUUlVNX0NPTlRSQUNUX0FERFJFU1MsXG59O1xuXG5leHBvcnQgY29uc3QgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTID0ge1xuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBXRVRIX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXTogV0VUSF9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLkJTQ106IFdCTkJfQ09OVFJBQ1RfQUREUkVTUyxcbiAgW0NIQUlOX0lEUy5QT0xZR09OXTogV01BVElDX0NPTlRSQUNUX0FERFJFU1MsXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogV0VUSF9HT0VSTElfQ09OVFJBQ1RfQUREUkVTUyxcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBXQVZBWF9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogV0VUSF9PUFRJTUlTTV9DT05UUkFDVF9BRERSRVNTLFxuICBbQ0hBSU5fSURTLkFSQklUUlVNXTogV0VUSF9BUkJJVFJVTV9DT05UUkFDVF9BRERSRVNTLFxufTtcblxuZXhwb3J0IGNvbnN0IEFMTE9XRURfQ09OVFJBQ1RfQUREUkVTU0VTID0ge1xuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBbXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtDSEFJTl9JRFMuTUFJTk5FVF0sXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5NQUlOTkVUXSxcbiAgXSxcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBbXG4gICAgU1dBUFNfQ0hBSU5JRF9DT05UUkFDVF9BRERSRVNTX01BUFtTV0FQU19URVNUTkVUX0NIQUlOX0lEXSxcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbU1dBUFNfVEVTVE5FVF9DSEFJTl9JRF0sXG4gIF0sXG4gIFtDSEFJTl9JRFMuR09FUkxJXTogW1xuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLkdPRVJMSV0sXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5HT0VSTEldLFxuICBdLFxuICBbQ0hBSU5fSURTLkJTQ106IFtcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5CU0NdLFxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuQlNDXSxcbiAgXSxcbiAgW0NIQUlOX0lEUy5QT0xZR09OXTogW1xuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLlBPTFlHT05dLFxuICAgIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFU1tDSEFJTl9JRFMuUE9MWUdPTl0sXG4gIF0sXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogW1xuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLkFWQUxBTkNIRV0sXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5BVkFMQU5DSEVdLFxuICBdLFxuICBbQ0hBSU5fSURTLk9QVElNSVNNXTogW1xuICAgIFNXQVBTX0NIQUlOSURfQ09OVFJBQ1RfQUREUkVTU19NQVBbQ0hBSU5fSURTLk9QVElNSVNNXSxcbiAgICBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbQ0hBSU5fSURTLk9QVElNSVNNXSxcbiAgXSxcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IFtcbiAgICBTV0FQU19DSEFJTklEX0NPTlRSQUNUX0FERFJFU1NfTUFQW0NIQUlOX0lEUy5BUkJJVFJVTV0sXG4gICAgU1dBUFNfV1JBUFBFRF9UT0tFTlNfQUREUkVTU0VTW0NIQUlOX0lEUy5BUkJJVFJVTV0sXG4gIF0sXG59O1xuXG5leHBvcnQgY29uc3QgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUCA9IHtcbiAgW0NIQUlOX0lEUy5NQUlOTkVUXTogRVRIX1NXQVBTX1RPS0VOX09CSkVDVCxcbiAgW1NXQVBTX1RFU1RORVRfQ0hBSU5fSURdOiBURVNUX0VUSF9TV0FQU19UT0tFTl9PQkpFQ1QsXG4gIFtDSEFJTl9JRFMuQlNDXTogQk5CX1NXQVBTX1RPS0VOX09CSkVDVCxcbiAgW0NIQUlOX0lEUy5QT0xZR09OXTogTUFUSUNfU1dBUFNfVE9LRU5fT0JKRUNULFxuICBbQ0hBSU5fSURTLkdPRVJMSV06IEdPRVJMSV9TV0FQU19UT0tFTl9PQkpFQ1QsXG4gIFtDSEFJTl9JRFMuQVZBTEFOQ0hFXTogQVZBWF9TV0FQU19UT0tFTl9PQkpFQ1QsXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBPUFRJTUlTTV9TV0FQU19UT0tFTl9PQkpFQ1QsXG4gIFtDSEFJTl9JRFMuQVJCSVRSVU1dOiBBUkJJVFJVTV9TV0FQU19UT0tFTl9PQkpFQ1QsXG59O1xuXG5leHBvcnQgY29uc3QgU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTF9NQVAgPSB7XG4gIFtDSEFJTl9JRFMuQlNDXTogQlNDX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxuICBbQ0hBSU5fSURTLk1BSU5ORVRdOiBNQUlOTkVUX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxuICBbQ0hBSU5fSURTLlBPTFlHT05dOiBQT0xZR09OX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxuICBbQ0hBSU5fSURTLkdPRVJMSV06IEdPRVJMSV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcbiAgW0NIQUlOX0lEUy5BVkFMQU5DSEVdOiBBVkFMQU5DSEVfREVGQVVMVF9CTE9DS19FWFBMT1JFUl9VUkwsXG4gIFtDSEFJTl9JRFMuT1BUSU1JU01dOiBPUFRJTUlTTV9ERUZBVUxUX0JMT0NLX0VYUExPUkVSX1VSTCxcbiAgW0NIQUlOX0lEUy5BUkJJVFJVTV06IEFSQklUUlVNX0RFRkFVTFRfQkxPQ0tfRVhQTE9SRVJfVVJMLFxufTtcblxuZXhwb3J0IGNvbnN0IEVUSEVSRVVNID0gJ2V0aGVyZXVtJztcbmV4cG9ydCBjb25zdCBQT0xZR09OID0gJ3BvbHlnb24nO1xuZXhwb3J0IGNvbnN0IEJTQyA9ICdic2MnO1xuZXhwb3J0IGNvbnN0IEdPRVJMSSA9ICdnb2VybGknO1xuZXhwb3J0IGNvbnN0IEFWQUxBTkNIRSA9ICdhdmFsYW5jaGUnO1xuZXhwb3J0IGNvbnN0IE9QVElNSVNNID0gJ29wdGltaXNtJztcbmV4cG9ydCBjb25zdCBBUkJJVFJVTSA9ICdhcmJpdHJ1bSc7XG5cbmV4cG9ydCBjb25zdCBTV0FQU19DTElFTlRfSUQgPSAnZXh0ZW5zaW9uJztcblxuZXhwb3J0IGNvbnN0IFRPS0VOX0JVQ0tFVF9QUklPUklUWSA9IHtcbiAgT1dORUQ6ICdvd25lZCcsXG4gIFRPUDogJ3RvcCcsXG59O1xuXG5leHBvcnQgY29uc3QgU0xJUFBBR0UgPSB7XG4gIERFRkFVTFQ6IDIsXG4gIEhJR0g6IDMsXG59O1xuIiwiZXhwb3J0IGNvbnN0IE1JTExJU0VDT05EID0gMTtcclxuZXhwb3J0IGNvbnN0IFNFQ09ORCA9IE1JTExJU0VDT05EICogMTAwMDtcclxuZXhwb3J0IGNvbnN0IE1JTlVURSA9IFNFQ09ORCAqIDYwO1xyXG5leHBvcnQgY29uc3QgSE9VUiA9IE1JTlVURSAqIDYwO1xyXG5leHBvcnQgY29uc3QgREFZID0gSE9VUiAqIDI0O1xyXG4iLCJpbXBvcnQgY29udHJhY3RNYXAgZnJvbSAnQG1ldGFtYXNrL2NvbnRyYWN0LW1ldGFkYXRhJztcblxuLyoqXG4gKiBBIG5vcm1hbGl6ZWQgbGlzdCBvZiBhZGRyZXNzZXMgZXhwb3J0ZWQgYXMgcGFydCBvZiB0aGUgY29udHJhY3RNYXAgaW5cbiAqIGBAbWV0YW1hc2svY29udHJhY3QtbWV0YWRhdGFgLiBVc2VkIHByaW1hcmlseSB0byB2YWxpZGF0ZSBpZiBtYW51YWxseSBlbnRlcmVkXG4gKiBjb250cmFjdCBhZGRyZXNzZXMgZG8gbm90IG1hdGNoIG9uZSBvZiBvdXIgbGlzdGVkIHRva2Vuc1xuICovXG5leHBvcnQgY29uc3QgTElTVEVEX0NPTlRSQUNUX0FERFJFU1NFUyA9IE9iamVjdC5rZXlzKGNvbnRyYWN0TWFwKS5tYXAoXG4gIChhZGRyZXNzKSA9PiBhZGRyZXNzLnRvTG93ZXJDYXNlKCksXG4pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRva2VuRGV0YWlsc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VsZWN0ZWQgJ1RPS0VOJyBvclxuICogICdDT0xMRUNUSUJMRScgY29udHJhY3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N5bWJvbF0gLSBUaGUgc3ltYm9sIG9mIHRoZSB0b2tlbi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBbZGVjaW1hbHNdIC0gVGhlIG51bWJlciBvZiBkZWNpbWFscyBvZiB0aGUgc2VsZWN0ZWRcbiAqICAnRVJDMjAnIGFzc2V0LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IFt0b2tlbklkXSAtIFRoZSBpZCBvZiB0aGUgc2VsZWN0ZWQgJ0NPTExFQ1RJQkxFJyBhc3NldC5cbiAqIEBwcm9wZXJ0eSB7VG9rZW5TdGFuZGFyZFN0cmluZ3N9IFtzdGFuZGFyZF0gLSBUaGUgc3RhbmRhcmQgb2YgdGhlIHNlbGVjdGVkXG4gKiAgYXNzZXQuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpc0VSQzcyMV0gLSBUcnVlIHdoZW4gdGhlIGFzc2V0IGlzIGEgRVJDNzIxIHRva2VuLlxuICovXG5leHBvcnQgY29uc3QgU1RBVElDX01BSU5ORVRfVE9LRU5fTElTVCA9IE9iamVjdC5rZXlzKGNvbnRyYWN0TWFwKS5yZWR1Y2UoXG4gIChhY2MsIGJhc2UpID0+IHtcbiAgICBjb25zdCB7IGxvZ28sIC4uLnRva2VuTWV0YWRhdGEgfSA9IGNvbnRyYWN0TWFwW2Jhc2VdO1xuICAgIHJldHVybiB7XG4gICAgICAuLi5hY2MsXG4gICAgICBbYmFzZS50b0xvd2VyQ2FzZSgpXToge1xuICAgICAgICAuLi50b2tlbk1ldGFkYXRhLFxuICAgICAgICBhZGRyZXNzOiBiYXNlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIGljb25Vcmw6IGBpbWFnZXMvY29udHJhY3QvJHtsb2dvfWAsXG4gICAgICAgIGFnZ3JlZ2F0b3JzOiBbXSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbiAge30sXG4pO1xuXG5leHBvcnQgY29uc3QgVE9LRU5fQVBJX01FVEFTV0FQX0NPREVGSV9VUkwgPVxuICAnaHR0cHM6Ly90b2tlbi1hcGkubWV0YXN3YXAuY29kZWZpLm5ldHdvcmsvdG9rZW5zLyc7XG4iLCJpbXBvcnQgeyBNRVNTQUdFX1RZUEUgfSBmcm9tICcuL2FwcCc7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gVHlwZSBpcyBhIE1ldGFNYXNrIGNvbnN0cnVjdCB1c2VkIGludGVybmFsbHlcbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvblR5cGVzXG4gKiBAcHJvcGVydHkgeyd0cmFuc2Zlcid9IFRPS0VOX01FVEhPRF9UUkFOU0ZFUiAtIEEgdG9rZW4gdHJhbnNhY3Rpb24gd2hlcmUgdGhlIHVzZXJcbiAqICBpcyBzZW5kaW5nIHRva2VucyB0aGF0IHRoZXkgb3duIHRvIGFub3RoZXIgYWRkcmVzc1xuICogQHByb3BlcnR5IHsndHJhbnNmZXJmcm9tJ30gVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST00gLSBBIHRva2VuIHRyYW5zYWN0aW9uXG4gKiAgdHJhbnNmZXJyaW5nIHRva2VucyBmcm9tIGFuIGFjY291bnQgdGhhdCB0aGUgc2VuZGVyIGhhcyBhbiBhbGxvd2FuY2Ugb2YuXG4gKiAgRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gYWxsb3dhbmNlcywgc2VlIHRoZSBhcHByb3ZlIHR5cGUuXG4gKiBAcHJvcGVydHkgeydzYWZldHJhbnNmZXJmcm9tJ30gVE9LRU5fTUVUSE9EX1NBRkVfVFJBTlNGRVJfRlJPTSAtIEEgdG9rZW4gdHJhbnNhY3Rpb25cbiAqICB0cmFuc2ZlcnJpbmcgdG9rZW5zIGZyb20gYW4gYWNjb3VudCB0aGF0IHRoZSBzZW5kZXIgaGFzIGFuIGFsbG93YW5jZSBvZi5cbiAqICBUaGUgbWV0aG9kIGlzIHByZWZpeGVkIHdpdGggc2FmZSBiZWNhdXNlIHdoZW4gY2FsbGluZyB0aGlzIG1ldGhvZCB0aGUgY29udHJhY3QgY2hlY2tzXG4gKiAgdG8gZW5zdXJlIHRoYXQgdGhlIHJlY2VpdmVyIGlzIGFuIGFkZHJlc3MgY2FwYWJsZSBvZiBoYW5kbGluZyB3aXRoIHRoZSB0b2tlbiBiZWluZyBzZW50LlxuICogQHByb3BlcnR5IHsnYXBwcm92ZSd9IFRPS0VOX01FVEhPRF9BUFBST1ZFIC0gQSB0b2tlbiB0cmFuc2FjdGlvbiByZXF1ZXN0aW5nIGFuXG4gKiAgYWxsb3dhbmNlIG9mIHRoZSB0b2tlbiB0byBzcGVuZCBvbiBiZWhhbGYgb2YgdGhlIHVzZXJcbiAqIEBwcm9wZXJ0eSB7J3NldGFwcHJvdmFsZm9yYWxsJ30gVE9LRU5fTUVUSE9EX1NFVF9BUFBST1ZBTF9GT1JfQUxMIC0gQSB0b2tlbiB0cmFuc2FjdGlvbiByZXF1ZXN0aW5nIGFuXG4gKiAgYWxsb3dhbmNlIG9mIGFsbCBvZiBhIHVzZXIncyB0b2tlbiB0byBzcGVuZCBvbiBiZWhhbGYgb2YgdGhlIHVzZXJcbiAqIEBwcm9wZXJ0eSB7J2luY29taW5nJ30gSU5DT01JTkcgLSBBbiBpbmNvbWluZyAoZGVwb3NpdCkgdHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7J3NpbXBsZVNlbmQnfSBTSU1QTEVfU0VORCAtIEEgdHJhbnNhY3Rpb24gc2VuZGluZyBhIG5ldHdvcmsncyBuYXRpdmUgYXNzZXQgdG8gYSByZWNpcGllbnRcbiAqIEBwcm9wZXJ0eSB7J2NvbnRyYWN0SW50ZXJhY3Rpb24nfSBDT05UUkFDVF9JTlRFUkFDVElPTiAtIEEgdHJhbnNhY3Rpb24gdGhhdCBpc1xuICogIGludGVyYWN0aW5nIHdpdGggYSBzbWFydCBjb250cmFjdCdzIG1ldGhvZHMgdGhhdCB3ZSBoYXZlIG5vdCB0cmVhdGVkIGFzIGEgc3BlY2lhbFxuICogIGNhc2UsIHN1Y2ggYXMgYXBwcm92ZSwgdHJhbnNmZXIsIGFuZCB0cmFuc2ZlcmZyb21cbiAqIEBwcm9wZXJ0eSB7J2NvbnRyYWN0RGVwbG95bWVudCd9IERFUExPWV9DT05UUkFDVCAtIEEgdHJhbnNhY3Rpb24gdGhhdCBkZXBsb3llZFxuICogIGEgc21hcnQgY29udHJhY3RcbiAqIEBwcm9wZXJ0eSB7J3N3YXAnfSBTV0FQIC0gQSB0cmFuc2FjdGlvbiBzd2FwcGluZyBvbmUgdG9rZW4gZm9yIGFub3RoZXIgdGhyb3VnaFxuICogIE1ldGFNYXNrIFN3YXBzXG4gKiBAcHJvcGVydHkgeydzd2FwQXBwcm92YWwnfSBTV0FQX0FQUFJPVkFMIC0gU2ltaWxhciB0byB0aGUgYXBwcm92ZSB0eXBlLCBhIHN3YXBcbiAqICBhcHByb3ZhbCBpcyBhIHNwZWNpYWwgY2FzZSBvZiBFUkMyMCBhcHByb3ZlIG1ldGhvZCB0aGF0IHJlcXVlc3RzIGFuIGFsbG93YW5jZSBvZlxuICogIHRoZSB0b2tlbiB0byBzcGVuZCBvbiBiZWhhbGYgb2YgdGhlIHVzZXIgZm9yIHRoZSBNZXRhTWFzayBTd2FwcyBjb250cmFjdC4gVGhlIGZpcnN0XG4gKiAgc3dhcCBmb3IgYW55IHRva2VuIHdpbGwgaGF2ZSBhbiBhY2NvbXBhbnlpbmcgc3dhcEFwcHJvdmFsIHRyYW5zYWN0aW9uLlxuICogQHByb3BlcnR5IHsnY2FuY2VsJ30gQ0FOQ0VMIC0gQSB0cmFuc2FjdGlvbiBzdWJtaXR0ZWQgd2l0aCB0aGUgc2FtZSBub25jZSBhcyBhXG4gKiAgcHJldmlvdXMgdHJhbnNhY3Rpb24sIGEgaGlnaGVyIGdhcyBwcmljZSBhbmQgYSB6ZXJvZWQgb3V0IHNlbmQgYW1vdW50LiBVc2VmdWxcbiAqICBmb3IgdXNlcnMgd2hvIGFjY2lkZW50YWxseSBzZW5kIHRvIGVycm9uZW91cyBhZGRyZXNzZXMgb3IgaWYgdGhleSBzZW5kIHRvbyBtdWNoLlxuICogQHByb3BlcnR5IHsncmV0cnknfSBSRVRSWSAtIFdoZW4gYSB0cmFuc2FjdGlvbiBpcyBmYWlsZWQgaXQgY2FuIGJlIHJldHJpZWQgYnlcbiAqICByZXN1Ym1pdHRpbmcgdGhlIHNhbWUgdHJhbnNhY3Rpb24gd2l0aCBhIGhpZ2hlciBnYXMgZmVlLiBUaGlzIHR5cGUgaXMgYWxzbyB1c2VkXG4gKiAgdG8gc3BlZWQgdXAgcGVuZGluZyB0cmFuc2FjdGlvbnMuIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IGNyZWF0aW5nIGEgbmV3IHR4IHdpdGhcbiAqICB0aGUgc2FtZSBub25jZSBhbmQgaGlnaGVyIGdhcyBmZWVzLlxuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHdpbGwgd29yayBhbnl3aGVyZSB5b3UgZXhwZWN0IGEgc3RyaW5nIHRoYXQgY2FuIGJlIG9uZSBvZiB0aGVcbiAqIGFib3ZlIHRyYW5zYWN0aW9uIHR5cGVzLlxuICpcbiAqIEB0eXBlZGVmIHtUcmFuc2FjdGlvblR5cGVzW2tleW9mIFRyYW5zYWN0aW9uVHlwZXNdfSBUcmFuc2FjdGlvblR5cGVTdHJpbmdcbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtUcmFuc2FjdGlvblR5cGVzfVxuICovXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fVFlQRVMgPSB7XG4gIENBTkNFTDogJ2NhbmNlbCcsXG4gIENPTlRSQUNUX0lOVEVSQUNUSU9OOiAnY29udHJhY3RJbnRlcmFjdGlvbicsXG4gIERFUExPWV9DT05UUkFDVDogJ2NvbnRyYWN0RGVwbG95bWVudCcsXG4gIEVUSF9ERUNSWVBUOiBNRVNTQUdFX1RZUEUuRVRIX0RFQ1JZUFQsXG4gIEVUSF9HRVRfRU5DUllQVElPTl9QVUJMSUNfS0VZOiBNRVNTQUdFX1RZUEUuRVRIX0dFVF9FTkNSWVBUSU9OX1BVQkxJQ19LRVksXG4gIElOQ09NSU5HOiAnaW5jb21pbmcnLFxuICBQRVJTT05BTF9TSUdOOiBNRVNTQUdFX1RZUEUuUEVSU09OQUxfU0lHTixcbiAgUkVUUlk6ICdyZXRyeScsXG4gIFNJR046IE1FU1NBR0VfVFlQRS5FVEhfU0lHTixcbiAgU0lHTl9UWVBFRF9EQVRBOiBNRVNTQUdFX1RZUEUuRVRIX1NJR05fVFlQRURfREFUQSxcbiAgU0lNUExFX1NFTkQ6ICdzaW1wbGVTZW5kJyxcbiAgU01BUlQ6ICdzbWFydCcsXG4gIFNXQVA6ICdzd2FwJyxcbiAgU1dBUF9BUFBST1ZBTDogJ3N3YXBBcHByb3ZhbCcsXG4gIFRPS0VOX01FVEhPRF9BUFBST1ZFOiAnYXBwcm92ZScsXG4gIFRPS0VOX01FVEhPRF9TQUZFX1RSQU5TRkVSX0ZST006ICdzYWZldHJhbnNmZXJmcm9tJyxcbiAgVE9LRU5fTUVUSE9EX1RSQU5TRkVSOiAndHJhbnNmZXInLFxuICBUT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTTogJ3RyYW5zZmVyZnJvbScsXG4gIFRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTDogJ3NldGFwcHJvdmFsZm9yYWxsJyxcbn07XG5cbi8qKlxuICogSW4gRUlQLTI3MTggdHlwZWQgdHJhbnNhY3Rpb24gZW52ZWxvcGVzIHdlcmUgc3BlY2lmaWVkLCB3aXRoIHRoZSB2ZXJ5IGZpcnN0XG4gKiB0eXBlZCBlbnZlbG9wZSBiZWluZyAnbGVnYWN5JyBhbmQgZGVzY3JpYmluZyB0aGUgc2hhcGUgb2YgdGhlIGJhc2VcbiAqIHRyYW5zYWN0aW9uIHBhcmFtcyB0aGF0IHdlcmUgaGl0aGVydG8gdGhlIG9ubHkgdHJhbnNhY3Rpb24gdHlwZSBzZW50IG9uXG4gKiBFdGhlcmV1bS5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvbkVudmVsb3BlVHlwZXNcbiAqIEBwcm9wZXJ0eSB7JzB4MCd9IExFR0FDWSAtIEEgbGVnYWN5IHRyYW5zYWN0aW9uLCB0aGUgdmVyeSBmaXJzdCB0eXBlLlxuICogQHByb3BlcnR5IHsnMHgxJ30gQUNDRVNTX0xJU1QgLSBFSVAtMjkzMCBkZWZpbmVkIHRoZSBhY2Nlc3MgbGlzdCB0cmFuc2FjdGlvblxuICogIHR5cGUgdGhhdCBhbGxvd2VkIGZvciBzcGVjaWZ5aW5nIHRoZSBzdGF0ZSB0aGF0IGEgdHJhbnNhY3Rpb24gd291bGQgYWN0XG4gKiAgdXBvbiBpbiBhZHZhbmNlIGFuZCB0aGVvcmV0aWNhbGx5IHNhdmUgb24gZ2FzIGZlZXMuXG4gKiBAcHJvcGVydHkgeycweDInfSBGRUVfTUFSS0VUIC0gVGhlIHR5cGUgaW50cm9kdWNlZCBjb21lcyBmcm9tIEVJUC0xNTU5LFxuICogIEZlZSBNYXJrZXQgZGVzY3JpYmVzIHRoZSBhZGRpdGlvbiBvZiBhIGJhc2VGZWUgdG8gYmxvY2tzIHRoYXQgd2lsbCBiZVxuICogIGJ1cm5lZCBpbnN0ZWFkIG9mIGRpc3RyaWJ1dGVkIHRvIG1pbmVycy4gVHJhbnNhY3Rpb25zIG9mIHRoaXMgdHlwZSBoYXZlXG4gKiAgYm90aCBhIG1heEZlZVBlckdhcyAobWF4aW11bSB0b3RhbCBhbW91bnQgaW4gZ3dlaSBwZXIgZ2FzIHRvIHNwZW5kIG9uIHRoZVxuICogIHRyYW5zYWN0aW9uKSB3aGljaCBpcyBpbmNsdXNpdmUgb2YgdGhlIG1heFByaW9yaXR5RmVlUGVyR2FzIChtYXhpbXVtIGFtb3VudFxuICogIG9mIGd3ZWkgcGVyIGdhcyBmcm9tIHRoZSB0cmFuc2FjdGlvbiBmZWUgdG8gZGlzdHJpYnV0ZSB0byBtaW5lcikuXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7VHJhbnNhY3Rpb25FbnZlbG9wZVR5cGVzfVxuICovXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMgPSB7XG4gIExFR0FDWTogJzB4MCcsXG4gIEFDQ0VTU19MSVNUOiAnMHgxJyxcbiAgRkVFX01BUktFVDogJzB4MicsXG59O1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIFN0YXR1cyBpcyBhIG1peCBvZiBFdGhlcmV1bSBhbmQgTWV0YU1hc2sgdGVybWlub2xvZ3ksIHVzZWQgaW50ZXJuYWxseVxuICogZm9yIHRyYW5zYWN0aW9uIHByb2Nlc3NpbmcuXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJhbnNhY3Rpb25TdGF0dXNlc1xuICogQHByb3BlcnR5IHsndW5hcHByb3ZlZCd9IFVOQVBQUk9WRUQgLSBBIG5ldyB0cmFuc2FjdGlvbiB0aGF0IHRoZSB1c2VyIGhhcyBub3RcbiAqICBhcHByb3ZlZCBvciByZWplY3RlZFxuICogQHByb3BlcnR5IHsnYXBwcm92ZWQnfSBBUFBST1ZFRCAtIFRoZSB1c2VyIGhhcyBhcHByb3ZlZCB0aGUgdHJhbnNhY3Rpb24gaW4gdGhlXG4gKiAgTWV0YU1hc2sgVUlcbiAqIEBwcm9wZXJ0eSB7J3JlamVjdGVkJ30gUkVKRUNURUQgLSBUaGUgdXNlciBoYXMgcmVqZWN0ZWQgdGhlIHRyYW5zYWN0aW9uIGluIHRoZVxuICogIE1ldGFNYXNrIFVJXG4gKiBAcHJvcGVydHkgeydzaWduZWQnfSBTSUdORUQgLSBUaGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc2lnbmVkXG4gKiBAcHJvcGVydHkgeydzdWJtaXR0ZWQnfSBTVUJNSVRURUQgLSBUaGUgdHJhbnNhY3Rpb24gaGFzIGJlZW4gc3VibWl0dGVkIHRvIG5ldHdvcmtcbiAqIEBwcm9wZXJ0eSB7J2ZhaWxlZCd9IEZBSUxFRCAtIFRoZSB0cmFuc2FjdGlvbiBoYXMgZmFpbGVkIGZvciBzb21lIHJlYXNvblxuICogQHByb3BlcnR5IHsnZHJvcHBlZCd9IERST1BQRUQgLSBUaGUgdHJhbnNhY3Rpb24gd2FzIGRyb3BwZWQgZHVlIHRvIGEgdHggd2l0aCBzYW1lXG4gKiAgbm9uY2UgYmVpbmcgYWNjZXB0ZWRcbiAqIEBwcm9wZXJ0eSB7J2NvbmZpcm1lZCd9IENPTkZJUk1FRCAtIFRoZSB0cmFuc2FjdGlvbiB3YXMgY29uZmlybWVkIGJ5IHRoZSBuZXR3b3JrXG4gKi9cblxuLyoqXG4gKiBUaGlzIHR5cGUgd2lsbCB3b3JrIGFueXdoZXJlIHlvdSBleHBlY3QgYSBzdHJpbmcgdGhhdCBjYW4gYmUgb25lIG9mIHRoZVxuICogYWJvdmUgdHJhbnNhY3Rpb24gc3RhdHVzZXMuXG4gKlxuICogQHR5cGVkZWYge1RyYW5zYWN0aW9uU3RhdHVzZXNba2V5b2YgVHJhbnNhY3Rpb25TdGF0dXNlc119IFRyYW5zYWN0aW9uU3RhdHVzU3RyaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7VHJhbnNhY3Rpb25TdGF0dXNlc31cbiAqL1xuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX1NUQVRVU0VTID0ge1xuICBVTkFQUFJPVkVEOiAndW5hcHByb3ZlZCcsXG4gIEFQUFJPVkVEOiAnYXBwcm92ZWQnLFxuICBSRUpFQ1RFRDogJ3JlamVjdGVkJyxcbiAgU0lHTkVEOiAnc2lnbmVkJyxcbiAgU1VCTUlUVEVEOiAnc3VibWl0dGVkJyxcbiAgRkFJTEVEOiAnZmFpbGVkJyxcbiAgRFJPUFBFRDogJ2Ryb3BwZWQnLFxuICBDT05GSVJNRUQ6ICdjb25maXJtZWQnLFxuICBQRU5ESU5HOiAncGVuZGluZycsXG59O1xuXG4vKipcbiAqIFdpdGggdGhpcyBsaXN0IHdlIGNhbiBkZXRlY3QgaWYgYSB0cmFuc2FjdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzcy5cbiAqL1xuZXhwb3J0IGNvbnN0IElOX1BST0dSRVNTX1RSQU5TQUNUSU9OX1NUQVRVU0VTID0gW1xuICBUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVELFxuICBUUkFOU0FDVElPTl9TVEFUVVNFUy5BUFBST1ZFRCxcbiAgVFJBTlNBQ1RJT05fU1RBVFVTRVMuU0lHTkVELFxuICBUUkFOU0FDVElPTl9TVEFUVVNFUy5TVUJNSVRURUQsXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLlBFTkRJTkcsXG5dO1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEdyb3VwIFN0YXR1cyBpcyBhIE1ldGFNYXNrIGNvbnN0cnVjdCB0byB0cmFjayB0aGUgc3RhdHVzIG9mIGdyb3Vwc1xuICogb2YgdHJhbnNhY3Rpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYW5zYWN0aW9uR3JvdXBTdGF0dXNlc1xuICogQHByb3BlcnR5IHsnY2FuY2VsbGVkJ30gQ0FOQ0VMTEVEIC0gQSBjYW5jZWwgdHlwZSB0cmFuc2FjdGlvbiBpbiB0aGUgZ3JvdXAgd2FzXG4gKiAgY29uZmlybWVkXG4gKiBAcHJvcGVydHkgeydwZW5kaW5nJ30gUEVORElORyAtIFRoZSBwcmltYXJ5VHJhbnNhY3Rpb24gb2YgdGhlIGdyb3VwIGhhcyBhIHN0YXR1c1xuICogIHRoYXQgaXMgb25lIG9mIFRSQU5TQUNUSU9OX1NUQVRVU0VTLkFQUFJPVkVELCBUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVEXG4gKiAgb3IgVFJBTlNBQ1RJT05fU1RBVFVTRVMuU1VCTUlUVEVEXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7VHJhbnNhY3Rpb25Hcm91cFN0YXR1c2VzfVxuICovXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fR1JPVVBfU1RBVFVTRVMgPSB7XG4gIENBTkNFTExFRDogJ2NhbmNlbGxlZCcsXG4gIFBFTkRJTkc6ICdwZW5kaW5nJyxcbn07XG5cbi8qKlxuICogU3RhdHVzZXMgdGhhdCBhcmUgc3BlY2lmaWMgdG8gU21hcnQgVHJhbnNhY3Rpb25zLlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNtYXJ0VHJhbnNhY3Rpb25TdGF0dXNlc1xuICogQHByb3BlcnR5IHsnY2FuY2VsbGVkJ30gQ0FOQ0VMTEVEIC0gSXQgY2FuIGJlIGNhbmNlbGxlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICogQHByb3BlcnR5IHsncGVuZGluZyd9IFBFTkRJTkcgLSBTbWFydCB0cmFuc2FjdGlvbiBpcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcHJvcGVydHkgeydzdWNjZXNzJ30gU1VDQ0VTUyAtIFNtYXJ0IHRyYW5zYWN0aW9uIHdhcyBzdWNjZXNzZnVsbHkgbWluZWQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7U21hcnRUcmFuc2FjdGlvblN0YXR1c2VzfVxuICovXG5leHBvcnQgY29uc3QgU01BUlRfVFJBTlNBQ1RJT05fU1RBVFVTRVMgPSB7XG4gIENBTkNFTExFRDogJ2NhbmNlbGxlZCcsXG4gIFBFTkRJTkc6ICdwZW5kaW5nJyxcbiAgU1VDQ0VTUzogJ3N1Y2Nlc3MnLFxufTtcblxuLyoqXG4gKiBUeXBlcyB0aGF0IGFyZSBzcGVjaWZpYyB0byB0aGUgdHJhbnNhY3Rpb24gYXBwcm92YWwgYW1vdW50LlxuICpcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFRyYW5zYWN0aW9uQXBwcm92YWxBbW91bnRUeXBlXG4gKiBAcHJvcGVydHkgeydjdXN0b20nfSBDVVNUT00gLSBUaGUgdXNlciBoYXMgZWRpdGVkIHRoZSB0b2tlbiBhbW91bnQuXG4gKiBAcHJvcGVydHkgeydyZXZva2UnfSBSRVZPS0UgLSBUaGUgc2VsZWN0ZWQgYW1vdW50IChlaXRoZXIgQ1VTVE9NIG9yIERBUFBfUFJPUE9TRUQpIGlzIDAuXG4gKiBAcHJvcGVydHkgeydkYXBwX3Byb3Bvc2VkJ30gREFQUF9QUk9QT1NFRCAtIFRoZSBkYXBwIHByb3Bvc2VkIHRva2VuIGFtb3VudC5cbiAqL1xuXG4vKipcbiAqIEB0eXBlIHtUcmFuc2FjdGlvbkFwcHJvdmFsQW1vdW50VHlwZX1cbiAqL1xuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0FQUFJPVkFMX0FNT1VOVF9UWVBFID0ge1xuICBDVVNUT006ICdjdXN0b20nLFxuICBSRVZPS0U6ICdyZXZva2UnLFxuICBEQVBQX1BST1BPU0VEOiAnZGFwcF9wcm9wb3NlZCcsXG59O1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIEdyb3VwIENhdGVnb3J5IGlzIGEgTWV0YU1hc2sgY29uc3RydWN0IHRvIGNhdGVnb3JpemUgdGhlIGludGVudFxuICogb2YgYSBncm91cCBvZiB0cmFuc2FjdGlvbnMgZm9yIHB1cnBvc2VzIG9mIGRpc3BsYXlpbmcgaW4gdGhlIFVJXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJhbnNhY3Rpb25Hcm91cENhdGVnb3JpZXNcbiAqIEBwcm9wZXJ0eSB7J3NlbmQnfSBTRU5EIC0gVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGV0aGVyIGJlaW5nIHNlbnQgZnJvbVxuICogIHRoZSB1c2VyLlxuICogQHByb3BlcnR5IHsncmVjZWl2ZSd9IFJFQ0VJVkUgLSBUcmFuc2FjdGlvbiBncm91cCByZXByZXNlbnRpbmcgYSBkZXBvc2l0L2luY29taW5nXG4gKiAgdHJhbnNhY3Rpb24uIFRoaXMgY2F0ZWdvcnkgbWFwcyAxOjEgd2l0aCBUUkFOU0FDVElPTl9DQVRFR09SSUVTLklOQ09NSU5HLlxuICogQHByb3BlcnR5IHsnaW50ZXJhY3Rpb24nfSBJTlRFUkFDVElPTiAtIFRyYW5zYWN0aW9uIGdyb3VwIHJlcHJlc2VudGluZ1xuICogIGFuIGludGVyYWN0aW9uIHdpdGggYSBzbWFydCBjb250cmFjdCdzIG1ldGhvZHMuXG4gKiBAcHJvcGVydHkgeydhcHByb3ZhbCd9IEFQUFJPVkFMIC0gVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGEgcmVxdWVzdCBmb3IgYW5cbiAqICBhbGxvd2FuY2Ugb2YgYSB0b2tlbiB0byBzcGVuZCBvbiB0aGUgdXNlcidzIGJlaGFsZi5cbiAqIEBwcm9wZXJ0eSB7J3NpZ25hdHVyZS1yZXF1ZXN0J30gU0lHTkFUVVJFX1JFUVVFU1QgLSBUcmFuc2FjdGlvbiBncm91cCByZXByZXNlbnRpbmdcbiAqICBhIHNpZ25hdHVyZSByZXF1ZXN0IFRoaXMgY3VycmVudGx5IG9ubHkgc2hvd3MgdXAgaW4gdGhlIFVJIHdoZW4gaXRzIHBlbmRpbmcgdXNlclxuICogIGFwcHJvdmFsIGluIHRoZSBVSS4gT25jZSB0aGUgdXNlciBhcHByb3ZlcyBvciByZWplY3RzIGl0IHdpbGwgbm8gbG9uZ2VyIHNob3cgaW5cbiAqICBhY3Rpdml0eS5cbiAqIEBwcm9wZXJ0eSB7J3N3YXAnfSBTV0FQIC0gVHJhbnNhY3Rpb24gZ3JvdXAgcmVwcmVzZW50aW5nIGEgdG9rZW4gc3dhcCB0aHJvdWdoXG4gKiAgTWV0YU1hc2sgU3dhcHMuIFRoaXMgdHJhbnNhY3Rpb24gZ3JvdXAncyBwcmltYXJ5IGN1cnJlbmN5IGNoYW5nZXMgZGVwZW5kaW5nXG4gKiAgb24gY29udGV4dC4gSWYgdGhlIHVzZXIgaXMgdmlld2luZyBhbiBhc3NldCBwYWdlIGZvciBhIHRva2VuIHJlY2VpdmVkIGZyb20gYSBzd2FwLFxuICogIHRoZSBwcmltYXJ5IGN1cnJlbmN5IHdpbGwgYmUgdGhlIHJlY2VpdmVkIHRva2VuLiBPdGhlcndpc2UgdGhlIHRva2VuIGV4Y2hhbmdlZFxuICogIHdpbGwgYmUgc2hvd24uXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7VHJhbnNhY3Rpb25Hcm91cENhdGVnb3JpZXN9XG4gKi9cbmV4cG9ydCBjb25zdCBUUkFOU0FDVElPTl9HUk9VUF9DQVRFR09SSUVTID0ge1xuICBBUFBST1ZBTDogJ2FwcHJvdmFsJyxcbiAgSU5URVJBQ1RJT046ICdpbnRlcmFjdGlvbicsXG4gIFJFQ0VJVkU6ICdyZWNlaXZlJyxcbiAgU0VORDogJ3NlbmQnLFxuICBTSUdOQVRVUkVfUkVRVUVTVDogJ3NpZ25hdHVyZS1yZXF1ZXN0JyxcbiAgU1dBUDogJ3N3YXAnLFxufTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUeFBhcmFtc1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGZyb20gLSBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gaXMgc2VudCBmcm9tXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdG8gLSBUaGUgYWRkcmVzcyB0aGUgdHJhbnNhY3Rpb24gaXMgc2VudCB0b1xuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlIC0gVGhlIGFtb3VudCBvZiB3ZWksIGluIGhleGFkZWNpbWFsLCB0byBzZW5kXG4gKiBAcHJvcGVydHkge251bWJlcn0gbm9uY2UgLSBUaGUgdHJhbnNhY3Rpb24gY291bnQgZm9yIHRoZSBjdXJyZW50IGFjY291bnQvbmV0d29ya1xuICogQHByb3BlcnR5IHtzdHJpbmd9IGdhc1ByaWNlIC0gVGhlIGFtb3VudCBvZiBnd2VpLCBpbiBoZXhhZGVjaW1hbCwgcGVyIHVuaXQgb2YgZ2FzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzIC0gVGhlIG1heCBhbW91bnQgb2YgZ3dlaSwgaW4gaGV4YWRlY2ltYWwsIHRoZSB1c2VyIGlzIHdpbGxpbmcgdG8gcGF5XG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2RhdGFdIC0gSGV4YWRlY2ltYWwgZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIGNhbGxzIHRvIHRoZSBFVk0ncyBBQklcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFR4RXJyb3JcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgZnJvbSB0aGUgZW5jb3VudGVyZWQgZXJyb3IuXG4gKiBAcHJvcGVydHkge2FueX0gcnBjIC0gVGhlIFwidmFsdWVcIiBvZiB0aGUgZXJyb3IuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3N0YWNrXSAtIHRoZSBzdGFjayB0cmFjZSBmcm9tIHRoZSBlcnJvciwgaWYgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyBhIHRyYW5zYWN0aW9uLCBpbiB3aGF0ZXZlciBzdGF0ZSBpdCBpcyBpbi5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUcmFuc2FjdGlvbk1ldGFcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYmxvY2tOdW1iZXJdIC0gVGhlIGJsb2NrIG51bWJlciB0aGlzIHRyYW5zYWN0aW9uIHdhc1xuICogIGluY2x1ZGVkIGluLiBDdXJyZW50bHkgb25seSBwcmVzZW50IG9uIGluY29taW5nIHRyYW5zYWN0aW9ucyFcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpZCAtIEFuIGludGVybmFsbHkgdW5pcXVlIHR4IGlkZW50aWZpZXIuXG4gKiBAcHJvcGVydHkge251bWJlcn0gdGltZSAtIFRpbWUgdGhlIHRyYW5zYWN0aW9uIHdhcyBmaXJzdCBzdWdnZXN0ZWQsIGluIHVuaXhcbiAqICBlcG9jaCB0aW1lIChtcykuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29udHJhY3RNZXRob2ROYW1lIC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgbmFtZSBvZlxuICogdHJhbnNhY3Rpb24gY29udHJhY3QgbWV0aG9kLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGN1c3RvbVRva2VuQW1vdW50IC0gVGhlIGN1c3RvbSB0b2tlbiBhbW91bnQgaXMgdGhlIGFtb3VudFxuICogc2V0IGJ5IHRoZSB1c2VyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZGFwcFByb3Bvc2VkVG9rZW5BbW91bnQgLSBUaGUgZGFwcCBwcm9wb3NlZCB0b2tlbiBhbW91bnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50VG9rZW5CYWxhbmNlIC0gVGhlIGJhbGFuY2Ugb2YgdGhlIHRva2VuIHRoYXQgaXNcbiAqIGJlaW5nIHNlbmRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcmlnaW5hbEFwcHJvdmFsQW1vdW50IC0gVGhlIG9yaWdpbmFsIGFwcHJvdmFsIGFtb3VudFxuICogaXMgdGhlIG9yaWdpbmFsbHkgZGFwcCBwcm9wb3NlZCB0b2tlbiBhbW91bnRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmaW5hbEFwcHJvdmFsQW1vdW50IC0gVGhlIGNob3NlbiBhbW91bnQgd2hpY2ggd2lsbCBiZSB0aGVcbiAqIHNhbWUgYXMgdGhlIG9yaWdpbmFsbHkgcHJvcG9zZWQgdG9rZW4gYW1vdW50IGlmIHRoZSB1c2VyIGRvZXMgbm90IGVkaXQgdGhlXG4gKiBhbW91bnQgb3Igd2lsbCBiZSBhIGN1c3RvbSB0b2tlbiBhbW91bnQgc2V0IGJ5IHRoZSB1c2VyXG4gKiBAcHJvcGVydHkge1RyYW5zYWN0aW9uVHlwZVN0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRyYW5zYWN0aW9uIHRoaXMgdHhNZXRhXG4gKiAgcmVwcmVzZW50cy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvcmlnaW5hbFR5cGUgLSBXaGVuIHdlIHNwZWVkIHVwIGEgdHJhbnNhY3Rpb24sXG4gKiAgd2Ugc2V0IHRoZSB0eXBlIGFzIFJldHJ5IGFuZCB3ZSBsb3NlIGluZm9ybWF0aW9uIGFib3V0IHR5cGUgb2YgdHJhbnNhY3Rpb25cbiAqICB0aGF0IGlzIGJlaW5nIHNldCB1cCwgc28gd2UgdXNlIG9yaWdpbmFsIHR5cGUgdG8gdHJhY2sgdGhhdCBpbmZvcm1hdGlvbi5cbiAqIEBwcm9wZXJ0eSB7VHJhbnNhY3Rpb25TdGF0dXNTdHJpbmd9IHN0YXR1cyAtIFRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGVcbiAqICB0cmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZXRhbWFza05ldHdvcmtJZCAtIFRoZSB0cmFuc2FjdGlvbidzIG5ldHdvcmsgSUQsIHVzZWRcbiAqICBmb3IgRUlQLTE1NSBjb21wbGlhbmNlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBsb2FkaW5nRGVmYXVsdHMgLSBUT0RPOiBEb2N1bWVudFxuICogQHByb3BlcnR5IHtUeFBhcmFtc30gdHhQYXJhbXMgLSBUaGUgdHJhbnNhY3Rpb24gcGFyYW1zIGFzIHBhc3NlZCB0byB0aGVcbiAqICBuZXR3b3JrIHByb3ZpZGVyLlxuICogQHByb3BlcnR5IHtvYmplY3RbXX0gaGlzdG9yeSAtIEEgaGlzdG9yeSBvZiBtdXRhdGlvbnMgdG8gdGhpc1xuICogIFRyYW5zYWN0aW9uTWV0YSBvYmplY3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3JpZ2luIC0gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBpbnRlcmZhY2UgdGhhdFxuICogIHN1Z2dlc3RlZCB0aGUgdHJhbnNhY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gb3JpZ2luYWxHYXNFc3RpbWF0ZSAtIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgb3JpZ2luYWxcbiAqIGdhcyBlc3RpbWF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvbiBtZXRhZGF0YS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gdXNlckVkaXRlZEdhc0xpbWl0IC0gQSBib29sZWFuIHJlcHJlc2VudGluZyB3aGVuIHRoZVxuICogdXNlciBtYW51YWxseSBlZGl0ZWQgdGhlIGdhcyBsaW1pdC5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBub25jZURldGFpbHMgLSBBIG1ldGFkYXRhIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uXG4gKiAgdXNlZCB0byBkZXJpdmUgdGhlIHN1Z2dlc3RlZCBub25jZSwgdXNlZnVsIGZvciBkZWJ1Z2dpbmcgbm9uY2UgaXNzdWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHJhd1R4IC0gQSBoZXggc3RyaW5nIG9mIHRoZSBmaW5hbCBzaWduZWQgdHJhbnNhY3Rpb24sXG4gKiAgcmVhZHkgdG8gc3VibWl0IHRvIHRoZSBuZXR3b3JrLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhhc2ggLSBBIGhleCBzdHJpbmcgb2YgdGhlIHRyYW5zYWN0aW9uIGhhc2gsIHVzZWQgdG9cbiAqICBpZGVudGlmeSB0aGUgdHJhbnNhY3Rpb24gb24gdGhlIG5ldHdvcmsuXG4gKiBAcHJvcGVydHkge251bWJlcn0gW3N1Ym1pdHRlZFRpbWVdIC0gVGhlIHRpbWUgdGhlIHRyYW5zYWN0aW9uIHdhcyBzdWJtaXR0ZWQgdG9cbiAqICB0aGUgbmV0d29yaywgaW4gVW5peCBlcG9jaCB0aW1lIChtcykuXG4gKiBAcHJvcGVydHkge1R4RXJyb3J9IFtlcnJdIC0gVGhlIGVycm9yIGVuY291bnRlcmVkIGR1cmluZyB0aGUgdHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAqIERlZmluZXMgdGhlIHBvc3NpYmxlIHR5cGVzXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gVHJhbnNhY3Rpb25NZXRhTWV0cmljc0V2ZW50c1xuICogQHByb3BlcnR5IHsnVHJhbnNhY3Rpb24gQWRkZWQnfSBBRERFRCAtIEFsbCB0cmFuc2FjdGlvbnMsIGV4Y2VwdCBpbmNvbWluZ1xuICogIG9uZXMsIGFyZSBhZGRlZCB0byB0aGUgY29udHJvbGxlciBzdGF0ZSBpbiBhbiB1bmFwcHJvdmVkIHN0YXR1cy4gV2hlbiB0aGlzXG4gKiAgaGFwcGVucyB3ZSBmaXJlIHRoZSBUcmFuc2FjdGlvbiBBZGRlZCBldmVudCB0byBzaG93IHRoYXQgdGhlIHRyYW5zYWN0aW9uXG4gKiAgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIHVzZXIncyBNZXRhTWFzay5cbiAqIEBwcm9wZXJ0eSB7J1RyYW5zYWN0aW9uIEFwcHJvdmVkJ30gQVBQUk9WRUQgLSBXaGVuIGFuIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25cbiAqICBpcyBpbiB0aGUgY29udHJvbGxlciBzdGF0ZSwgTWV0YU1hc2sgd2lsbCByZW5kZXIgYSBjb25maXJtYXRpb24gc2NyZWVuIGZvclxuICogIHRoYXQgdHJhbnNhY3Rpb24uIElmIHRoZSB1c2VyIGFwcHJvdmVzIHRoZSB0cmFuc2FjdGlvbiB3ZSBmaXJlIHRoaXMgZXZlbnRcbiAqICB0byBpbmRpY2F0ZSB0aGF0IHRoZSB1c2VyIGhhcyBhcHByb3ZlZCB0aGUgdHJhbnNhY3Rpb24gZm9yIHN1Ym1pc3Npb24gdG9cbiAqICB0aGUgbmV0d29yay5cbiAqIEBwcm9wZXJ0eSB7J1RyYW5zYWN0aW9uIFJlamVjdGVkJ30gUkVKRUNURUQgLSBXaGVuIGFuIHVuYXBwcm92ZWQgdHJhbnNhY3Rpb25cbiAqICBpcyBpbiB0aGUgY29udHJvbGxlciBzdGF0ZSwgTWV0YU1hc2sgd2lsbCByZW5kZXIgYSBjb25maXJtYXRpb24gc2NyZWVuIGZvclxuICogIHRoYXQgdHJhbnNhY3Rpb24uIElmIHRoZSB1c2VyIHJlamVjdHMgdGhlIHRyYW5zYWN0aW9uIHdlIGZpcmUgdGhpcyBldmVudFxuICogIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZXIgaGFzIHJlamVjdGVkIHRoZSB0cmFuc2FjdGlvbi4gSXQgd2lsbCBiZSByZW1vdmVkXG4gKiAgZnJvbSBzdGF0ZSBhcyBhIHJlc3VsdC5cbiAqIEBwcm9wZXJ0eSB7J1RyYW5zYWN0aW9uIFN1Ym1pdHRlZCd9IFNVQk1JVFRFRCAtIEFmdGVyIGEgdHJhbnNhY3Rpb24gaXNcbiAqICBhcHByb3ZlZCBieSB0aGUgdXNlciwgaXQgaXMgdGhlbiBzdWJtaXR0ZWQgdG8gdGhlIG5ldHdvcmsgZm9yIGluY2x1c2lvbiBpblxuICogIGEgYmxvY2suIFdoZW4gdGhpcyBoYXBwZW5zIHdlIGZpcmUgdGhlIFRyYW5zYWN0aW9uIFN1Ym1pdHRlZCBldmVudCB0b1xuICogIGluZGljYXRlIHRoYXQgTWV0YU1hc2sgaXMgc3VibWl0dGluZyBhIHRyYW5zYWN0aW9uIGF0IHRoZSB1c2VyJ3MgcmVxdWVzdC5cbiAqIEBwcm9wZXJ0eSB7J1RyYW5zYWN0aW9uIEZpbmFsaXplZCd9IEZJTkFMSVpFRCAtIEFsbCB0cmFuc2FjdGlvbnMgdGhhdCBhcmVcbiAqICBzdWJtaXR0ZWQgd2lsbCBmaW5hbGl6ZWQgKGV2ZW50dWFsbHkpIGJ5IGVpdGhlciBiZWluZyBkcm9wcGVkLCBmYWlsaW5nXG4gKiAgb3IgYmVpbmcgY29uZmlybWVkLiBXaGVuIHRoaXMgaGFwcGVucyB3ZSB0cmFjayB0aGlzIGV2ZW50LCBhbG9uZyB3aXRoIHRoZVxuICogIHN0YXR1cy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgdHlwZSB3aWxsIHdvcmsgYW55d2hlcmUgeW91IGV4cGVjdCBhIHN0cmluZyB0aGF0IGNhbiBiZSBvbmUgb2YgdGhlXG4gKiBhYm92ZSB0cmFuc2FjdGlvbiBldmVudCB0eXBlcy5cbiAqXG4gKiBAdHlwZWRlZiB7VHJhbnNhY3Rpb25NZXRhTWV0cmljc0V2ZW50c1trZXlvZiBUcmFuc2FjdGlvbk1ldGFNZXRyaWNzRXZlbnRzXX0gVHJhbnNhY3Rpb25NZXRhTWV0cmljc0V2ZW50U3RyaW5nXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7VHJhbnNhY3Rpb25NZXRhTWV0cmljc0V2ZW50c31cbiAqL1xuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0VWRU5UUyA9IHtcbiAgQURERUQ6ICdUcmFuc2FjdGlvbiBBZGRlZCcsXG4gIEFQUFJPVkVEOiAnVHJhbnNhY3Rpb24gQXBwcm92ZWQnLFxuICBGSU5BTElaRUQ6ICdUcmFuc2FjdGlvbiBGaW5hbGl6ZWQnLFxuICBSRUpFQ1RFRDogJ1RyYW5zYWN0aW9uIFJlamVjdGVkJyxcbiAgU1VCTUlUVEVEOiAnVHJhbnNhY3Rpb24gU3VibWl0dGVkJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQXNzZXRUeXBlc1xuICogQHByb3BlcnR5IHsnTkFUSVZFJ30gTkFUSVZFIC0gVGhlIG5hdGl2ZSBhc3NldCBmb3IgdGhlIGN1cnJlbnQgbmV0d29yaywgc3VjaFxuICogIGFzIEVUSFxuICogQHByb3BlcnR5IHsnVE9LRU4nfSBUT0tFTiAtIEFuIEVSQzIwIHRva2VuLlxuICogQHByb3BlcnR5IHsnQ09MTEVDVElCTEUnfSBDT0xMRUNUSUJMRSAtIEFuIEVSQzcyMSBvciBFUkMxMTU1IHRva2VuLlxuICogQHByb3BlcnR5IHsnVU5LTk9XTid9IFVOS05PV04gLSBBIHRyYW5zYWN0aW9uIGludGVyYWN0aW5nIHdpdGggYSBjb250cmFjdFxuICogIHRoYXQgaXNuJ3QgYSB0b2tlbiBtZXRob2QgaW50ZXJhY3Rpb24gd2lsbCBiZSBtYXJrZWQgYXMgZGVhbGluZyB3aXRoIGFuXG4gKiAgdW5rbm93biBhc3NldCB0eXBlLlxuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHdpbGwgd29yayBhbnl3aGVyZSB5b3UgZXhwZWN0IGEgc3RyaW5nIHRoYXQgY2FuIGJlIG9uZSBvZiB0aGVcbiAqIGFib3ZlIGFzc2V0IHR5cGVzXG4gKlxuICogQHR5cGVkZWYge0Fzc2V0VHlwZXNba2V5b2YgQXNzZXRUeXBlc119IEFzc2V0VHlwZXNTdHJpbmdcbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlcyBvZiBhc3NldHMgdGhhdCBhIHVzZXIgY2FuIHNlbmRcbiAqXG4gKiBAdHlwZSB7QXNzZXRUeXBlc31cbiAqL1xuZXhwb3J0IGNvbnN0IEFTU0VUX1RZUEVTID0ge1xuICBOQVRJVkU6ICdOQVRJVkUnLFxuICBUT0tFTjogJ1RPS0VOJyxcbiAgQ09MTEVDVElCTEU6ICdDT0xMRUNUSUJMRScsXG4gIFVOS05PV046ICdVTktOT1dOJyxcbn07XG5cbmV4cG9ydCBjb25zdCBFUkMyMCA9ICdFUkMyMCc7XG5leHBvcnQgY29uc3QgRVJDNzIxID0gJ0VSQzcyMSc7XG5leHBvcnQgY29uc3QgRVJDMTE1NSA9ICdFUkMxMTU1JztcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBUb2tlblN0YW5kYXJkc1xuICogQHByb3BlcnR5IHsnRVJDMjAnfSBFUkMyMCAtIEEgdG9rZW4gdGhhdCBjb25mb3JtcyB0byB0aGUgRVJDMjAgc3RhbmRhcmQuXG4gKiBAcHJvcGVydHkgeydFUkM3MjEnfSBFUkM3MjEgLSBBIHRva2VuIHRoYXQgY29uZm9ybXMgdG8gdGhlIEVSQzcyMSBzdGFuZGFyZC5cbiAqIEBwcm9wZXJ0eSB7J0VSQzExNTUnfSBFUkMxMTU1IC0gQSB0b2tlbiB0aGF0IGNvbmZvcm1zIHRvIHRoZSBFUkMxMTU1XG4gKiAgc3RhbmRhcmQuXG4gKiBAcHJvcGVydHkgeydOT05FJ30gTk9ORSAtIE5vdCBhIHRva2VuLCBidXQgcmF0aGVyIHRoZSBiYXNlIGFzc2V0IG9mIHRoZVxuICogIHNlbGVjdGVkIGNoYWluLlxuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHdpbGwgd29yayBhbnl3aGVyZSB5b3UgZXhwZWN0IGEgc3RyaW5nIHRoYXQgY2FuIGJlIG9uZSBvZiB0aGVcbiAqIGFib3ZlIHN0YXR1c2VzXG4gKlxuICogQHR5cGVkZWYge1Rva2VuU3RhbmRhcmRzW2tleW9mIFRva2VuU3RhbmRhcmRzXX0gVG9rZW5TdGFuZGFyZFN0cmluZ3NcbiAqL1xuXG4vKipcbiAqIERlc2NyaWJlcyB0aGUgc3RhbmRhcmQgd2hpY2ggYSB0b2tlbiBjb25mb3JtcyB0by5cbiAqXG4gKiBAdHlwZSB7VG9rZW5TdGFuZGFyZHN9XG4gKi9cbmV4cG9ydCBjb25zdCBUT0tFTl9TVEFOREFSRFMgPSB7XG4gIEVSQzIwLFxuICBFUkM3MjEsXG4gIEVSQzExNTUsXG4gIE5PTkU6ICdOT05FJyxcbn07XG4iLCJpbXBvcnQgeyBNSU5VVEUsIFNFQ09ORCB9IGZyb20gJy4uL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCBnZXRGZXRjaFdpdGhUaW1lb3V0IGZyb20gJy4uL21vZHVsZXMvZmV0Y2gtd2l0aC10aW1lb3V0JztcbmltcG9ydCB7IGdldFN0b3JhZ2VJdGVtLCBzZXRTdG9yYWdlSXRlbSB9IGZyb20gJy4vc3RvcmFnZS1oZWxwZXJzJztcblxuY29uc3QgZmV0Y2hXaXRoQ2FjaGUgPSBhc3luYyAoXG4gIHVybCxcbiAgZmV0Y2hPcHRpb25zID0ge30sXG4gIHsgY2FjaGVSZWZyZXNoVGltZSA9IE1JTlVURSAqIDYsIHRpbWVvdXQgPSBTRUNPTkQgKiAzMCB9ID0ge30sXG4pID0+IHtcbiAgaWYgKFxuICAgIGZldGNoT3B0aW9ucy5ib2R5IHx8XG4gICAgKGZldGNoT3B0aW9ucy5tZXRob2QgJiYgZmV0Y2hPcHRpb25zLm1ldGhvZCAhPT0gJ0dFVCcpXG4gICkge1xuICAgIHRocm93IG5ldyBFcnJvcignZmV0Y2hXaXRoQ2FjaGUgb25seSBzdXBwb3J0cyBHRVQgcmVxdWVzdHMnKTtcbiAgfVxuICBpZiAoIShmZXRjaE9wdGlvbnMuaGVhZGVycyBpbnN0YW5jZW9mIHdpbmRvdy5IZWFkZXJzKSkge1xuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzID0gbmV3IHdpbmRvdy5IZWFkZXJzKGZldGNoT3B0aW9ucy5oZWFkZXJzKTtcbiAgfVxuICBpZiAoXG4gICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMuaGFzKCdDb250ZW50LVR5cGUnKSAmJlxuICAgIGZldGNoT3B0aW9ucy5oZWFkZXJzLmdldCgnQ29udGVudC1UeXBlJykgIT09ICdhcHBsaWNhdGlvbi9qc29uJ1xuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZldGNoV2l0aENhY2hlIG9ubHkgc3VwcG9ydHMgSlNPTiByZXNwb25zZXMnKTtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgY29uc3QgY2FjaGVLZXkgPSBgY2FjaGVkRmV0Y2g6JHt1cmx9YDtcbiAgY29uc3QgeyBjYWNoZWRSZXNwb25zZSwgY2FjaGVkVGltZSB9ID0gKGF3YWl0IGdldFN0b3JhZ2VJdGVtKGNhY2hlS2V5KSkgfHwge307XG4gIGlmIChjYWNoZWRSZXNwb25zZSAmJiBjdXJyZW50VGltZSAtIGNhY2hlZFRpbWUgPCBjYWNoZVJlZnJlc2hUaW1lKSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3BvbnNlO1xuICB9XG4gIGZldGNoT3B0aW9ucy5oZWFkZXJzLnNldCgnQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQodGltZW91dCk7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dCh1cmwsIHtcbiAgICByZWZlcnJlclBvbGljeTogJ25vLXJlZmVycmVyLXdoZW4tZG93bmdyYWRlJyxcbiAgICBib2R5OiBudWxsLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgbW9kZTogJ2NvcnMnLFxuICAgIC4uLmZldGNoT3B0aW9ucyxcbiAgfSk7XG4gIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgRmV0Y2ggZmFpbGVkIHdpdGggc3RhdHVzICcke3Jlc3BvbnNlLnN0YXR1c30nOiAnJHtyZXNwb25zZS5zdGF0dXNUZXh0fSdgLFxuICAgICk7XG4gIH1cbiAgY29uc3QgcmVzcG9uc2VKc29uID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICBjb25zdCBjYWNoZUVudHJ5ID0ge1xuICAgIGNhY2hlZFJlc3BvbnNlOiByZXNwb25zZUpzb24sXG4gICAgY2FjaGVkVGltZTogY3VycmVudFRpbWUsXG4gIH07XG5cbiAgYXdhaXQgc2V0U3RvcmFnZUl0ZW0oY2FjaGVLZXksIGNhY2hlRW50cnkpO1xuICByZXR1cm4gcmVzcG9uc2VKc29uO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgZmV0Y2hXaXRoQ2FjaGU7XG4iLCJpbXBvcnQgeyBjb252ZXJzaW9uVXRpbCB9IGZyb20gJy4uL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0RlY2ltYWwoaGV4VmFsdWUpIHtcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKGhleFZhbHVlLCB7XG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb2tlblZhbHVlUGFyYW0odG9rZW5EYXRhID0ge30pIHtcbiAgcmV0dXJuIHRva2VuRGF0YT8uYXJncz8uX3ZhbHVlPy50b1N0cmluZygpO1xufVxuIiwiaW1wb3J0IGxvY2FsZm9yYWdlIGZyb20gJ2xvY2FsZm9yYWdlJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JhZ2VJdGVtKGtleSkge1xuICB0cnkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0gYXdhaXQgbG9jYWxmb3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgIGlmIChzZXJpYWxpemVkRGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICByZXR1cm4gSlNPTi5wYXJzZShzZXJpYWxpemVkRGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNldFN0b3JhZ2VJdGVtKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzZXJpYWxpemVkRGF0YSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICBhd2FpdCBsb2NhbGZvcmFnZS5zZXRJdGVtKGtleSwgc2VyaWFsaXplZERhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLndhcm4oZXJyKTtcbiAgfVxufVxuIiwiaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgeyBDSEFJTl9JRFMgfSBmcm9tICcuLi9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICBHQVNfQVBJX0JBU0VfVVJMLFxuICBHQVNfREVWX0FQSV9CQVNFX1VSTCxcbiAgU1dBUFNfQVBJX1YyX0JBU0VfVVJMLFxuICBTV0FQU19DSEFJTklEX0RFRkFVTFRfVE9LRU5fTUFQLFxuICBTV0FQU19DTElFTlRfSUQsXG4gIFNXQVBTX0RFVl9BUElfVjJfQkFTRV9VUkwsXG4gIFNXQVBTX1dSQVBQRURfVE9LRU5TX0FERFJFU1NFUyxcbn0gZnJvbSAnLi4vY29uc3RhbnRzL3N3YXBzJztcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uL2NvbnN0YW50cy90aW1lJztcbmltcG9ydCB7IGlzVmFsaWRIZXhBZGRyZXNzIH0gZnJvbSAnLi4vbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xuaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vYXBwL3NjcmlwdHMvbGliL3V0aWwnO1xuaW1wb3J0IGZldGNoV2l0aENhY2hlIGZyb20gJy4vZmV0Y2gtd2l0aC1jYWNoZSc7XG5pbXBvcnQgeyBkZWNpbWFsVG9IZXggfSBmcm9tICcuL3RyYW5zYWN0aW9ucy1jb250cm9sbGVyLXV0aWxzJztcblxuY29uc3QgVEVTVF9DSEFJTl9JRFMgPSBbQ0hBSU5fSURTLkdPRVJMSSwgQ0hBSU5fSURTLkxPQ0FMSE9TVF07XG5cbmNvbnN0IGNsaWVudElkSGVhZGVyID0geyAnWC1DbGllbnQtSWQnOiBTV0FQU19DTElFTlRfSUQgfTtcblxuZXhwb3J0IGNvbnN0IHZhbGlkSGV4ID0gKHN0cmluZykgPT4gQm9vbGVhbihzdHJpbmc/Lm1hdGNoKC9eMHhbYS1mMC05XSskL3UpKTtcbmV4cG9ydCBjb25zdCB0cnV0aHlTdHJpbmcgPSAoc3RyaW5nKSA9PiBCb29sZWFuKHN0cmluZz8ubGVuZ3RoKTtcbmV4cG9ydCBjb25zdCB0cnV0aHlEaWdpdFN0cmluZyA9IChzdHJpbmcpID0+XG4gIHRydXRoeVN0cmluZyhzdHJpbmcpICYmIEJvb2xlYW4oc3RyaW5nLm1hdGNoKC9eXFxkKyQvdSkpO1xuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVEYXRhKHZhbGlkYXRvcnMsIG9iamVjdCwgdXJsVXNlZCwgbG9nRXJyb3IgPSB0cnVlKSB7XG4gIHJldHVybiB2YWxpZGF0b3JzLmV2ZXJ5KCh7IHByb3BlcnR5LCB0eXBlLCB2YWxpZGF0b3IgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGVzID0gdHlwZS5zcGxpdCgnfCcpO1xuXG4gICAgY29uc3QgdmFsaWQgPVxuICAgICAgdHlwZXMuc29tZSgoX3R5cGUpID0+IHR5cGVvZiBvYmplY3RbcHJvcGVydHldID09PSBfdHlwZSkgJiZcbiAgICAgICghdmFsaWRhdG9yIHx8IHZhbGlkYXRvcihvYmplY3RbcHJvcGVydHldKSk7XG4gICAgaWYgKCF2YWxpZCAmJiBsb2dFcnJvcikge1xuICAgICAgbG9nLmVycm9yKFxuICAgICAgICBgcmVzcG9uc2UgdG8gR0VUICR7dXJsVXNlZH0gaW52YWxpZCBmb3IgcHJvcGVydHkgJHtwcm9wZXJ0eX07IHZhbHVlIHdhczpgLFxuICAgICAgICBvYmplY3RbcHJvcGVydHldLFxuICAgICAgICAnfCB0eXBlIHdhczogJyxcbiAgICAgICAgdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV0sXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWQ7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgUVVPVEVfVkFMSURBVE9SUyA9IFtcbiAge1xuICAgIHByb3BlcnR5OiAndHJhZGUnLFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHZhbGlkYXRvcjogKHRyYWRlKSA9PlxuICAgICAgdHJhZGUgJiZcbiAgICAgIHZhbGlkSGV4KHRyYWRlLmRhdGEpICYmXG4gICAgICBpc1ZhbGlkSGV4QWRkcmVzcyh0cmFkZS50bywgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSAmJlxuICAgICAgaXNWYWxpZEhleEFkZHJlc3ModHJhZGUuZnJvbSwgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSAmJlxuICAgICAgdHJ1dGh5U3RyaW5nKHRyYWRlLnZhbHVlKSxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnYXBwcm92YWxOZWVkZWQnLFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHZhbGlkYXRvcjogKGFwcHJvdmFsVHgpID0+XG4gICAgICBhcHByb3ZhbFR4ID09PSBudWxsIHx8XG4gICAgICAoYXBwcm92YWxUeCAmJlxuICAgICAgICB2YWxpZEhleChhcHByb3ZhbFR4LmRhdGEpICYmXG4gICAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKGFwcHJvdmFsVHgudG8sIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSkgJiZcbiAgICAgICAgaXNWYWxpZEhleEFkZHJlc3MoYXBwcm92YWxUeC5mcm9tLCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pKSxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnc291cmNlQW1vdW50JyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeURpZ2l0U3RyaW5nLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdkZXN0aW5hdGlvbkFtb3VudCcsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiB0cnV0aHlEaWdpdFN0cmluZyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnc291cmNlVG9rZW4nLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIHZhbGlkYXRvcjogKGlucHV0KSA9PiBpc1ZhbGlkSGV4QWRkcmVzcyhpbnB1dCwgeyBhbGxvd05vblByZWZpeGVkOiBmYWxzZSB9KSxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnZGVzdGluYXRpb25Ub2tlbicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiAoaW5wdXQpID0+IGlzVmFsaWRIZXhBZGRyZXNzKGlucHV0LCB7IGFsbG93Tm9uUHJlZml4ZWQ6IGZhbHNlIH0pLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdhZ2dyZWdhdG9yJyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICB2YWxpZGF0b3I6IHRydXRoeVN0cmluZyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnYWdnVHlwZScsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsaWRhdG9yOiB0cnV0aHlTdHJpbmcsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2Vycm9yJyxcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICB2YWxpZGF0b3I6IChlcnJvcikgPT4gZXJyb3IgPT09IG51bGwgfHwgdHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyxcbiAgfSxcbiAge1xuICAgIHByb3BlcnR5OiAnYXZlcmFnZUdhcycsXG4gICAgdHlwZTogJ251bWJlcicsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ21heEdhcycsXG4gICAgdHlwZTogJ251bWJlcicsXG4gIH0sXG4gIHtcbiAgICBwcm9wZXJ0eTogJ2dhc0VzdGltYXRlJyxcbiAgICB0eXBlOiAnbnVtYmVyfHVuZGVmaW5lZCcsXG4gICAgdmFsaWRhdG9yOiAoZ2FzRXN0aW1hdGUpID0+IGdhc0VzdGltYXRlID09PSB1bmRlZmluZWQgfHwgZ2FzRXN0aW1hdGUgPiAwLFxuICB9LFxuICB7XG4gICAgcHJvcGVydHk6ICdmZWUnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICB9LFxuXTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFR5cGUgb2YgYW4gQVBJIGNhbGwsIGUuZy4gXCJ0b2tlbnNcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWRcbiAqIEByZXR1cm5zIHN0cmluZ1xuICovXG5jb25zdCBnZXRCYXNlVXJsRm9yTmV3U3dhcHNBcGkgPSAodHlwZSwgY2hhaW5JZCkgPT4ge1xuICBjb25zdCB1c2VEZXZBcGlzID0gcHJvY2Vzcy5lbnYuU1dBUFNfVVNFX0RFVl9BUElTO1xuICBjb25zdCB2MkFwaUJhc2VVcmwgPSB1c2VEZXZBcGlzXG4gICAgPyBTV0FQU19ERVZfQVBJX1YyX0JBU0VfVVJMXG4gICAgOiBTV0FQU19BUElfVjJfQkFTRV9VUkw7XG4gIGNvbnN0IGdhc0FwaUJhc2VVcmwgPSB1c2VEZXZBcGlzID8gR0FTX0RFVl9BUElfQkFTRV9VUkwgOiBHQVNfQVBJX0JBU0VfVVJMO1xuICBjb25zdCBub05ldHdvcmtTcGVjaWZpY1R5cGVzID0gWydyZWZyZXNoVGltZSddOyAvLyBUaGVzZSB0eXBlcyBkb24ndCBuZWVkIG5ldHdvcmsgaW5mbyBpbiB0aGUgVVJMLlxuICBpZiAobm9OZXR3b3JrU3BlY2lmaWNUeXBlcy5pbmNsdWRlcyh0eXBlKSkge1xuICAgIHJldHVybiB2MkFwaUJhc2VVcmw7XG4gIH1cbiAgY29uc3QgY2hhaW5JZERlY2ltYWwgPSBjaGFpbklkICYmIHBhcnNlSW50KGNoYWluSWQsIDE2KTtcbiAgY29uc3QgZ2FzQXBpVHlwZXMgPSBbJ2dhc1ByaWNlcyddO1xuICBpZiAoZ2FzQXBpVHlwZXMuaW5jbHVkZXModHlwZSkpIHtcbiAgICByZXR1cm4gYCR7Z2FzQXBpQmFzZVVybH0vbmV0d29ya3MvJHtjaGFpbklkRGVjaW1hbH1gOyAvLyBHYXMgY2FsY3VsYXRpb25zIGFyZSBpbiBpdHMgb3duIHJlcG8uXG4gIH1cbiAgcmV0dXJuIGAke3YyQXBpQmFzZVVybH0vbmV0d29ya3MvJHtjaGFpbklkRGVjaW1hbH1gO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEJhc2VBcGkgPSBmdW5jdGlvbiAodHlwZSwgY2hhaW5JZCA9IENIQUlOX0lEUy5NQUlOTkVUKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjaGFpbklkID0gVEVTVF9DSEFJTl9JRFMuaW5jbHVkZXMoY2hhaW5JZCkgPyBDSEFJTl9JRFMuTUFJTk5FVCA6IGNoYWluSWQ7XG4gIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsRm9yTmV3U3dhcHNBcGkodHlwZSwgY2hhaW5JZCk7XG4gIGlmICghYmFzZVVybCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgU3dhcHMgQVBJIGNhbGxzIGFyZSBkaXNhYmxlZCBmb3IgY2hhaW5JZDogJHtjaGFpbklkfWApO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3RyYWRlJzpcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS90cmFkZXM/YDtcbiAgICBjYXNlICd0b2tlbnMnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3Rva2Vuc2A7XG4gICAgY2FzZSAndG9rZW4nOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3Rva2VuYDtcbiAgICBjYXNlICd0b3BBc3NldHMnOlxuICAgICAgcmV0dXJuIGAke2Jhc2VVcmx9L3RvcEFzc2V0c2A7XG4gICAgY2FzZSAnYWdncmVnYXRvck1ldGFkYXRhJzpcbiAgICAgIHJldHVybiBgJHtiYXNlVXJsfS9hZ2dyZWdhdG9yTWV0YWRhdGFgO1xuICAgIGNhc2UgJ2dhc1ByaWNlcyc6XG4gICAgICByZXR1cm4gYCR7YmFzZVVybH0vZ2FzUHJpY2VzYDtcbiAgICBjYXNlICduZXR3b3JrJzpcbiAgICAgIHJldHVybiBiYXNlVXJsO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldEJhc2VBcGkgcmVxdWlyZXMgYW4gYXBpIGNhbGwgdHlwZScpO1xuICB9XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2FsY1Rva2VuVmFsdWUodmFsdWUsIGRlY2ltYWxzKSB7XG4gIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTnVtYmVyKGRlY2ltYWxzIHx8IDApKTtcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoU3RyaW5nKHZhbHVlKSkudGltZXMobXVsdGlwbGllcik7XG59XG5cbmV4cG9ydCBjb25zdCBzaG91bGRFbmFibGVEaXJlY3RXcmFwcGluZyA9IChcbiAgY2hhaW5JZCxcbiAgc291cmNlVG9rZW4sXG4gIGRlc3RpbmF0aW9uVG9rZW4sXG4pID0+IHtcbiAgaWYgKCFzb3VyY2VUb2tlbiB8fCAhZGVzdGluYXRpb25Ub2tlbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB3cmFwcGVkVG9rZW4gPSBTV0FQU19XUkFQUEVEX1RPS0VOU19BRERSRVNTRVNbY2hhaW5JZF07XG4gIGNvbnN0IG5hdGl2ZVRva2VuID0gU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUFtjaGFpbklkXT8uYWRkcmVzcztcbiAgY29uc3Qgc291cmNlVG9rZW5Mb3dlckNhc2UgPSBzb3VyY2VUb2tlbi50b0xvd2VyQ2FzZSgpO1xuICBjb25zdCBkZXN0aW5hdGlvblRva2VuTG93ZXJDYXNlID0gZGVzdGluYXRpb25Ub2tlbi50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gKFxuICAgIChzb3VyY2VUb2tlbkxvd2VyQ2FzZSA9PT0gd3JhcHBlZFRva2VuICYmXG4gICAgICBkZXN0aW5hdGlvblRva2VuTG93ZXJDYXNlID09PSBuYXRpdmVUb2tlbikgfHxcbiAgICAoc291cmNlVG9rZW5Mb3dlckNhc2UgPT09IG5hdGl2ZVRva2VuICYmXG4gICAgICBkZXN0aW5hdGlvblRva2VuTG93ZXJDYXNlID09PSB3cmFwcGVkVG9rZW4pXG4gICk7XG59O1xuXG4vKipcbiAqIEdpdmVuIGFuZCBvYmplY3Qgd2hlcmUgYWxsIHZhbHVlcyBhcmUgc3RyaW5ncywgcmV0dXJucyB0aGUgc2FtZSBvYmplY3Qgd2l0aCBhbGwgdmFsdWVzXG4gKiBub3cgcHJlZml4ZWQgd2l0aCAnMHgnXG4gKlxuICogQHBhcmFtIG9ialxuICovXG5leHBvcnQgZnVuY3Rpb24gYWRkSGV4UHJlZml4VG9PYmplY3RWYWx1ZXMob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLnJlZHVjZSgobmV3T2JqLCBrZXkpID0+IHtcbiAgICByZXR1cm4geyAuLi5uZXdPYmosIFtrZXldOiBhZGRIZXhQcmVmaXgob2JqW2tleV0pIH07XG4gIH0sIHt9KTtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgc3RhbmRhcmQgc2V0IG9mIGluZm9ybWF0aW9uIGFib3V0IGEgdHJhbnNhY3Rpb24sIHJldHVybnMgYSB0cmFuc2FjdGlvbiBwcm9wZXJseSBmb3JtYXR0ZWQgZm9yXG4gKiBwdWJsaXNoaW5nIHZpYSBKU09OIFJQQyBhbmQgd2ViM1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnNlbmRUb2tlbl0gLSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIHRyYW5zYWNpdG9uIGlzIGEgdG9rZW4gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmRhdGEgLSBBIGhleCBzdHJpbmcgY29udGFpbmluZyB0aGUgZGF0YSB0byBpbmNsdWRlIGluIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMudG8gLSBBIGhleCBhZGRyZXNzIG9mIHRoZSB0eCByZWNpcGllbnQgYWRkcmVzc1xuICogQHBhcmFtIG9wdGlvbnMuYW1vdW50XG4gKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5mcm9tIC0gQSBoZXggYWRkcmVzcyBvZiB0aGUgdHggc2VuZGVyIGFkZHJlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25zLmdhcyAtIEEgaGV4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnYXMgdmFsdWUgZm9yIHRoZSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMuZ2FzUHJpY2UgLSBBIGhleCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2FzIHByaWNlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCByZWFkeSBmb3Igc3VibWlzc2lvbiB0byB0aGUgYmxvY2tjaGFpbiwgd2l0aCBhbGwgdmFsdWVzIGFwcHJvcHJpYXRlbHkgaGV4IHByZWZpeGVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25zdHJ1Y3RUeFBhcmFtcyh7XG4gIHNlbmRUb2tlbixcbiAgZGF0YSxcbiAgdG8sXG4gIGFtb3VudCxcbiAgZnJvbSxcbiAgZ2FzLFxuICBnYXNQcmljZSxcbn0pIHtcbiAgY29uc3QgdHhQYXJhbXMgPSB7XG4gICAgZGF0YSxcbiAgICBmcm9tLFxuICAgIHZhbHVlOiAnMCcsXG4gICAgZ2FzLFxuICAgIGdhc1ByaWNlLFxuICB9O1xuXG4gIGlmICghc2VuZFRva2VuKSB7XG4gICAgdHhQYXJhbXMudmFsdWUgPSBhbW91bnQ7XG4gICAgdHhQYXJhbXMudG8gPSB0bztcbiAgfVxuICByZXR1cm4gYWRkSGV4UHJlZml4VG9PYmplY3RWYWx1ZXModHhQYXJhbXMpO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hUcmFkZXNJbmZvKFxuICB7XG4gICAgc2xpcHBhZ2UsXG4gICAgc291cmNlVG9rZW4sXG4gICAgc291cmNlRGVjaW1hbHMsXG4gICAgZGVzdGluYXRpb25Ub2tlbixcbiAgICB2YWx1ZSxcbiAgICBmcm9tQWRkcmVzcyxcbiAgICBleGNoYW5nZUxpc3QsXG4gIH0sXG4gIHsgY2hhaW5JZCB9LFxuKSB7XG4gIGNvbnN0IHVybFBhcmFtcyA9IHtcbiAgICBkZXN0aW5hdGlvblRva2VuLFxuICAgIHNvdXJjZVRva2VuLFxuICAgIHNvdXJjZUFtb3VudDogY2FsY1Rva2VuVmFsdWUodmFsdWUsIHNvdXJjZURlY2ltYWxzKS50b1N0cmluZygxMCksXG4gICAgc2xpcHBhZ2UsXG4gICAgdGltZW91dDogU0VDT05EICogMTAsXG4gICAgd2FsbGV0QWRkcmVzczogZnJvbUFkZHJlc3MsXG4gIH07XG5cbiAgaWYgKGV4Y2hhbmdlTGlzdCkge1xuICAgIHVybFBhcmFtcy5leGNoYW5nZUxpc3QgPSBleGNoYW5nZUxpc3Q7XG4gIH1cbiAgaWYgKHNob3VsZEVuYWJsZURpcmVjdFdyYXBwaW5nKGNoYWluSWQsIHNvdXJjZVRva2VuLCBkZXN0aW5hdGlvblRva2VuKSkge1xuICAgIHVybFBhcmFtcy5lbmFibGVEaXJlY3RXcmFwcGluZyA9IHRydWU7XG4gIH1cblxuICBjb25zdCBxdWVyeVN0cmluZyA9IG5ldyBVUkxTZWFyY2hQYXJhbXModXJsUGFyYW1zKS50b1N0cmluZygpO1xuICBjb25zdCB0cmFkZVVSTCA9IGAke2dldEJhc2VBcGkoJ3RyYWRlJywgY2hhaW5JZCl9JHtxdWVyeVN0cmluZ31gO1xuICBjb25zdCB0cmFkZXNSZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aENhY2hlKFxuICAgIHRyYWRlVVJMLFxuICAgIHsgbWV0aG9kOiAnR0VUJywgaGVhZGVyczogY2xpZW50SWRIZWFkZXIgfSxcbiAgICB7IGNhY2hlUmVmcmVzaFRpbWU6IDAsIHRpbWVvdXQ6IFNFQ09ORCAqIDE1IH0sXG4gICk7XG4gIGNvbnN0IG5ld1F1b3RlcyA9IHRyYWRlc1Jlc3BvbnNlLnJlZHVjZSgoYWdnSWRUcmFkZU1hcCwgcXVvdGUpID0+IHtcbiAgICBpZiAoXG4gICAgICBxdW90ZS50cmFkZSAmJlxuICAgICAgIXF1b3RlLmVycm9yICYmXG4gICAgICB2YWxpZGF0ZURhdGEoUVVPVEVfVkFMSURBVE9SUywgcXVvdGUsIHRyYWRlVVJMKVxuICAgICkge1xuICAgICAgY29uc3QgY29uc3RydWN0ZWRUcmFkZSA9IGNvbnN0cnVjdFR4UGFyYW1zKHtcbiAgICAgICAgdG86IHF1b3RlLnRyYWRlLnRvLFxuICAgICAgICBmcm9tOiBxdW90ZS50cmFkZS5mcm9tLFxuICAgICAgICBkYXRhOiBxdW90ZS50cmFkZS5kYXRhLFxuICAgICAgICBhbW91bnQ6IGRlY2ltYWxUb0hleChxdW90ZS50cmFkZS52YWx1ZSksXG4gICAgICAgIGdhczogZGVjaW1hbFRvSGV4KHF1b3RlLm1heEdhcyksXG4gICAgICB9KTtcblxuICAgICAgbGV0IHsgYXBwcm92YWxOZWVkZWQgfSA9IHF1b3RlO1xuXG4gICAgICBpZiAoYXBwcm92YWxOZWVkZWQpIHtcbiAgICAgICAgYXBwcm92YWxOZWVkZWQgPSBjb25zdHJ1Y3RUeFBhcmFtcyh7XG4gICAgICAgICAgLi4uYXBwcm92YWxOZWVkZWQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hZ2dJZFRyYWRlTWFwLFxuICAgICAgICBbcXVvdGUuYWdncmVnYXRvcl06IHtcbiAgICAgICAgICAuLi5xdW90ZSxcbiAgICAgICAgICBzbGlwcGFnZSxcbiAgICAgICAgICB0cmFkZTogY29uc3RydWN0ZWRUcmFkZSxcbiAgICAgICAgICBhcHByb3ZhbE5lZWRlZCxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBhZ2dJZFRyYWRlTWFwO1xuICB9LCB7fSk7XG5cbiAgcmV0dXJuIG5ld1F1b3Rlcztcbn1cbiIsIi8qKlxuICogU3dpdGNoIHRoZSBDU1Mgc3R5bGVzaGVldCB1c2VkIGJldHdlZW4gJ3J0bCcgYW5kICdsdHInXG4gKlxuICogQHBhcmFtIHsoJ2x0cicgfCAncnRsJyB8ICdhdXRvJyl9IGRpcmVjdGlvbiAtIFRleHQgZGlyZWN0aW9uLCBlaXRoZXIgbGVmdC10by1yaWdodCAobHRyKSBvciByaWdodC10by1sZWZ0IChydGwpXG4gKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3Qgc3dpdGNoRGlyZWN0aW9uID0gYXN5bmMgKGRpcmVjdGlvbikgPT4ge1xuICBpZiAoZGlyZWN0aW9uID09PSAnYXV0bycpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICBkaXJlY3Rpb24gPSAnbHRyJztcbiAgfVxuXG4gIGxldCB1cGRhdGVkTGluaztcbiAgWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPXN0eWxlc2hlZXRdJyldLmZvckVhY2goKGxpbmspID0+IHtcbiAgICBpZiAobGluay50aXRsZSA9PT0gZGlyZWN0aW9uICYmIGxpbmsuZGlzYWJsZWQpIHtcbiAgICAgIGxpbmsuZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZWRMaW5rID0gbGluaztcbiAgICB9IGVsc2UgaWYgKGxpbmsudGl0bGUgIT09IGRpcmVjdGlvbiAmJiAhbGluay5kaXNhYmxlZCkge1xuICAgICAgbGluay5kaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICBpZiAodXBkYXRlZExpbmspIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdXBkYXRlZExpbmsub25sb2FkID0gKCkgPT4ge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9O1xuICAgICAgdXBkYXRlZExpbmsub25lcnJvciA9ICgpID0+XG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkICcke2RpcmVjdGlvbn0nIHN0eWxlc2hlZXRgKSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgc3dpdGNoRGlyZWN0aW9uO1xuIiwiaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IHsgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMgfSBmcm9tICcuLi9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHtcbiAgY29udmVyc2lvblV0aWwsXG4gIG11bHRpcGx5Q3VycmVuY2llcyxcbiAgc3VidHJhY3RDdXJyZW5jaWVzLFxufSBmcm9tICcuLi9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMnO1xuaW1wb3J0IHsgaXNTd2Fwc0RlZmF1bHRUb2tlblN5bWJvbCB9IGZyb20gJy4uL21vZHVsZXMvc3dhcHMudXRpbHMnO1xuXG5jb25zdCBUT0tFTl9UUkFOU0ZFUl9MT0dfVE9QSUNfSEFTSCA9XG4gICcweGRkZjI1MmFkMWJlMmM4OWI2OWMyYjA2OGZjMzc4ZGFhOTUyYmE3ZjE2M2M0YTExNjI4ZjU1YTRkZjUyM2IzZWYnO1xuXG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fTk9fQ09OVFJBQ1RfRVJST1JfS0VZID0gJ3RyYW5zYWN0aW9uRXJyb3JOb0NvbnRyYWN0JztcblxuZXhwb3J0IGNvbnN0IFRFTl9TRUNPTkRTX0lOX01JTExJU0VDT05EUyA9IDEwXzAwMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNHYXNUb3RhbChnYXNMaW1pdCA9ICcwJywgZ2FzUHJpY2UgPSAnMCcpIHtcbiAgcmV0dXJuIG11bHRpcGx5Q3VycmVuY2llcyhnYXNMaW1pdCwgZ2FzUHJpY2UsIHtcbiAgICB0b051bWVyaWNCYXNlOiAnaGV4JyxcbiAgICBtdWx0aXBsaWNhbmRCYXNlOiAxNixcbiAgICBtdWx0aXBsaWVyQmFzZTogMTYsXG4gIH0pO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgbnVtYmVyIGFuZCBzcGVjaWZpZWQgcHJlY2lzaW9uLCByZXR1cm5zIHRoYXQgbnVtYmVyIGluIGJhc2UgMTAgd2l0aCBhIG1heGltdW0gb2YgcHJlY2lzaW9uXG4gKiBzaWduaWZpY2FudCBkaWdpdHMsIGJ1dCB3aXRob3V0IGFueSB0cmFpbGluZyB6ZXJvcyBhZnRlciB0aGUgZGVjaW1hbCBwb2ludCBUbyBiZSB1c2VkIHdoZW4gd2lzaGluZ1xuICogdG8gZGlzcGxheSBvbmx5IGFzIG11Y2ggZGlnaXRzIHRvIHRoZSB1c2VyIGFzIG5lY2Vzc2FyeVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgQmlnTnVtYmVyfSBuIC0gVGhlIG51bWJlciB0byBmb3JtYXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBwcmVjaXNpb24gLSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIGluIHRoZSByZXR1cm4gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBudW1iZXIgaW4gZGVjaW1hbCBmb3JtLCB3aXRoIDw9IHByZWNpc2lvbiBzaWduaWZpY2FudCBkaWdpdHMgYW5kIG5vIGRlY2ltYWwgdHJhaWxpbmcgemVyb3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUHJlY2lzaW9uV2l0aG91dFRyYWlsaW5nWmVyb3MobiwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKG4pXG4gICAgLnRvUHJlY2lzaW9uKHByZWNpc2lvbilcbiAgICAucmVwbGFjZSgvKFxcLlswLTldKlsxLTldKTAqfChcXC4wKikvdSwgJyQxJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjVG9rZW5BbW91bnQodmFsdWUsIGRlY2ltYWxzKSB7XG4gIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTnVtYmVyKGRlY2ltYWxzIHx8IDApKTtcbiAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoU3RyaW5nKHZhbHVlKSkuZGl2KG11bHRpcGxpZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3dhcHNUb2tlbnNSZWNlaXZlZEZyb21UeE1ldGEoXG4gIHRva2VuU3ltYm9sLFxuICB0eE1ldGEsXG4gIHRva2VuQWRkcmVzcyxcbiAgYWNjb3VudEFkZHJlc3MsXG4gIHRva2VuRGVjaW1hbHMsXG4gIGFwcHJvdmFsVHhNZXRhLFxuICBjaGFpbklkLFxuKSB7XG4gIGNvbnN0IHR4UmVjZWlwdCA9IHR4TWV0YT8udHhSZWNlaXB0O1xuICBjb25zdCBuZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OSA9XG4gICAgdHhNZXRhPy50eFJlY2VpcHQ/LnR5cGUgPT09IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkZFRV9NQVJLRVQ7XG4gIGlmIChpc1N3YXBzRGVmYXVsdFRva2VuU3ltYm9sKHRva2VuU3ltYm9sLCBjaGFpbklkKSkge1xuICAgIGlmIChcbiAgICAgICF0eFJlY2VpcHQgfHxcbiAgICAgICF0eE1ldGEgfHxcbiAgICAgICF0eE1ldGEucG9zdFR4QmFsYW5jZSB8fFxuICAgICAgIXR4TWV0YS5wcmVUeEJhbGFuY2VcbiAgICApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICh0eE1ldGEuc3dhcE1ldGFEYXRhICYmIHR4TWV0YS5wcmVUeEJhbGFuY2UgPT09IHR4TWV0YS5wb3N0VHhCYWxhbmNlKSB7XG4gICAgICAvLyBJZiBwcmVUeEJhbGFuY2UgYW5kIHBvc3RUeEJhbGFuY2UgYXJlIGVxdWFsLCBwb3N0VHhCYWxhbmNlIGhhc24ndCBiZWVuIHVwZGF0ZWQgb24gdGltZVxuICAgICAgLy8gYmVjYXVzZSBvZiB0aGUgUlBDIHByb3ZpZGVyIGRlbGF5LCBzbyB3ZSByZXR1cm4gYW4gZXN0aW1hdGVkIHJlY2VpdmluZyBhbW91bnQgaW5zdGVhZC5cbiAgICAgIHJldHVybiB0eE1ldGEuc3dhcE1ldGFEYXRhLnRva2VuX3RvX2Ftb3VudDtcbiAgICB9XG5cbiAgICBsZXQgYXBwcm92YWxUeEdhc0Nvc3QgPSAnMHgwJztcbiAgICBpZiAoYXBwcm92YWxUeE1ldGEgJiYgYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0KSB7XG4gICAgICBhcHByb3ZhbFR4R2FzQ29zdCA9IGNhbGNHYXNUb3RhbChcbiAgICAgICAgYXBwcm92YWxUeE1ldGEudHhSZWNlaXB0Lmdhc1VzZWQsXG4gICAgICAgIG5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5XG4gICAgICAgICAgPyBhcHByb3ZhbFR4TWV0YS50eFJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2UgLy8gQmFzZSBmZWUgKyBwcmlvcml0eSBmZWUuXG4gICAgICAgICAgOiBhcHByb3ZhbFR4TWV0YS50eFBhcmFtcy5nYXNQcmljZSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZ2FzQ29zdCA9IGNhbGNHYXNUb3RhbChcbiAgICAgIHR4UmVjZWlwdC5nYXNVc2VkLFxuICAgICAgbmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTlcbiAgICAgICAgPyB0eFJlY2VpcHQuZWZmZWN0aXZlR2FzUHJpY2VcbiAgICAgICAgOiB0eE1ldGEudHhQYXJhbXMuZ2FzUHJpY2UsXG4gICAgKTtcbiAgICBjb25zdCB0b3RhbEdhc0Nvc3QgPSBuZXcgQmlnTnVtYmVyKGdhc0Nvc3QsIDE2KVxuICAgICAgLnBsdXMoYXBwcm92YWxUeEdhc0Nvc3QsIDE2KVxuICAgICAgLnRvU3RyaW5nKDE2KTtcblxuICAgIGNvbnN0IHByZVR4QmFsYW5jZUxlc3NHYXNDb3N0ID0gc3VidHJhY3RDdXJyZW5jaWVzKFxuICAgICAgdHhNZXRhLnByZVR4QmFsYW5jZSxcbiAgICAgIHRvdGFsR2FzQ29zdCxcbiAgICAgIHtcbiAgICAgICAgYUJhc2U6IDE2LFxuICAgICAgICBiQmFzZTogMTYsXG4gICAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgICAgfSxcbiAgICApO1xuXG4gICAgY29uc3QgZXRoUmVjZWl2ZWQgPSBzdWJ0cmFjdEN1cnJlbmNpZXMoXG4gICAgICB0eE1ldGEucG9zdFR4QmFsYW5jZSxcbiAgICAgIHByZVR4QmFsYW5jZUxlc3NHYXNDb3N0LFxuICAgICAge1xuICAgICAgICBhQmFzZTogMTYsXG4gICAgICAgIGJCYXNlOiAxNixcbiAgICAgICAgZnJvbURlbm9taW5hdGlvbjogJ1dFSScsXG4gICAgICAgIHRvRGVub21pbmF0aW9uOiAnRVRIJyxcbiAgICAgICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gICAgICB9LFxuICAgICk7XG4gICAgcmV0dXJuIGV0aFJlY2VpdmVkO1xuICB9XG4gIGNvbnN0IHR4UmVjZWlwdExvZ3MgPSB0eFJlY2VpcHQ/LmxvZ3M7XG4gIGlmICh0eFJlY2VpcHRMb2dzICYmIHR4UmVjZWlwdD8uc3RhdHVzICE9PSAnMHgwJykge1xuICAgIGNvbnN0IHRva2VuVHJhbnNmZXJMb2cgPSB0eFJlY2VpcHRMb2dzLmZpbmQoKHR4UmVjZWlwdExvZykgPT4ge1xuICAgICAgY29uc3QgaXNUb2tlblRyYW5zZmVyID1cbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljcyAmJlxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzBdID09PSBUT0tFTl9UUkFOU0ZFUl9MT0dfVE9QSUNfSEFTSDtcbiAgICAgIGNvbnN0IGlzVHJhbnNmZXJGcm9tR2l2ZW5Ub2tlbiA9IHR4UmVjZWlwdExvZy5hZGRyZXNzID09PSB0b2tlbkFkZHJlc3M7XG4gICAgICBjb25zdCBpc1RyYW5zZmVyRnJvbUdpdmVuQWRkcmVzcyA9XG4gICAgICAgIHR4UmVjZWlwdExvZy50b3BpY3MgJiZcbiAgICAgICAgdHhSZWNlaXB0TG9nLnRvcGljc1syXSAmJlxuICAgICAgICB0eFJlY2VpcHRMb2cudG9waWNzWzJdLm1hdGNoKGFjY291bnRBZGRyZXNzLnNsaWNlKDIpKTtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzVG9rZW5UcmFuc2ZlciAmJlxuICAgICAgICBpc1RyYW5zZmVyRnJvbUdpdmVuVG9rZW4gJiZcbiAgICAgICAgaXNUcmFuc2ZlckZyb21HaXZlbkFkZHJlc3NcbiAgICAgICk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRva2VuVHJhbnNmZXJMb2dcbiAgICAgID8gdG9QcmVjaXNpb25XaXRob3V0VHJhaWxpbmdaZXJvcyhcbiAgICAgICAgICBjYWxjVG9rZW5BbW91bnQodG9rZW5UcmFuc2ZlckxvZy5kYXRhLCB0b2tlbkRlY2ltYWxzKS50b1N0cmluZygxMCksXG4gICAgICAgICAgNixcbiAgICAgICAgKVxuICAgICAgOiAnJztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVfTkFNRVMgPSB7XG4gIEZFRV9NQVJLRVQ6ICdmZWUtbWFya2V0JyxcbiAgTEVHQUNZOiAnbGVnYWN5Jyxcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBoZXhXRUlUb0RlY0dXRUkoZGVjR1dFSSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoZGVjR1dFSSwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ1dFSScsXG4gICAgdG9EZW5vbWluYXRpb246ICdHV0VJJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNpbWFsVG9IZXgoZGVjaW1hbCkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoZGVjaW1hbCwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGV4V0VJVG9EZWNFVEgoaGV4V0VJKSB7XG4gIHJldHVybiBjb252ZXJzaW9uVXRpbChoZXhXRUksIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgIHRvRGVub21pbmF0aW9uOiAnRVRIJyxcbiAgfSk7XG59XG4iLCJleHBvcnQgY29uc3QgcmVhZEFkZHJlc3NBc0NvbnRyYWN0ID0gYXN5bmMgKGV0aFF1ZXJ5LCBhZGRyZXNzKSA9PiB7XHJcbiAgbGV0IGNvbnRyYWN0Q29kZTtcclxuICB0cnkge1xyXG4gICAgY29udHJhY3RDb2RlID0gYXdhaXQgZXRoUXVlcnkuZ2V0Q29kZShhZGRyZXNzKTtcclxuICB9IGNhdGNoIChlKSB7XHJcbiAgICBjb250cmFjdENvZGUgPSBudWxsO1xyXG4gIH1cclxuXHJcbiAgY29uc3QgaXNDb250cmFjdEFkZHJlc3MgPVxyXG4gICAgY29udHJhY3RDb2RlICYmIGNvbnRyYWN0Q29kZSAhPT0gJzB4JyAmJiBjb250cmFjdENvZGUgIT09ICcweDAnO1xyXG4gIHJldHVybiB7IGNvbnRyYWN0Q29kZSwgaXNDb250cmFjdEFkZHJlc3MgfTtcclxufTtcclxuIiwiLyoqXG4gKiBDdXJyZW5jeSBDb252ZXJzaW9uIFV0aWxpdHlcbiAqIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBjYW4gYmUgdXNlZCBmb3IgY29udmVydGluZyBjdXJyZW5jeSByZWxhdGVkIHZhbHVlcyB3aXRoaW4gbWV0YW1hc2suXG4gKiBUaGUgY2FsbGVyIHNob3VsZCBiZSBhYmxlIHRvIHBhc3MgaXQgYSB2YWx1ZSwgYWxvbmcgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmFsdWUnc1xuICogbnVtZXJpYyBiYXNlLCBkZW5vbWluYXRpb24gYW5kIGN1cnJlbmN5LCBhbmQgdGhlIGRlc2lyZWQgbnVtZXJpYyBiYXNlLCBkZW5vbWluYXRpb24gYW5kXG4gKiBjdXJyZW5jeS4gSXQgc2hvdWxkIHJldHVybiBhIHNpbmdsZSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0geyhudW1iZXIgfCBzdHJpbmcgfCBCTil9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyB0byBzcGVjaWZ5IGRldGFpbHMgb2YgdGhlIGNvbnZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mcm9tQ3VycmVuY3kgPSAnRVRIJyB8ICdVU0QnXSAtIFRoZSBjdXJyZW5jeSBvZiB0aGUgcGFzc2VkIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9DdXJyZW5jeSA9ICdFVEgnIHwgJ1VTRCddIC0gVGhlIGRlc2lyZWQgY3VycmVuY3kgb2YgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZyb21OdW1lcmljQmFzZSA9ICdoZXgnIHwgJ2RlYycgfCAnQk4nXSAtIFRoZSBudW1lcmljIGJhc2ljIG9mIHRoZSBwYXNzZWQgdmFsdWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudG9OdW1lcmljQmFzZSA9ICdoZXgnIHwgJ2RlYycgfCAnQk4nXSAtIFRoZSBkZXNpcmVkIG51bWVyaWMgYmFzaWMgb2YgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5mcm9tRGVub21pbmF0aW9uID0gJ1dFSSddIC0gVGhlIGRlbm9taW5hdGlvbiBvZiB0aGUgcGFzc2VkIHZhbHVlXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubnVtYmVyT2ZEZWNpbWFsc10gLSBUaGUgZGVzaXJlZCBudW1iZXIgb2YgZGVjaW1hbHMgaW4gdGhlIHJlc3VsdFxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnJvdW5kRG93bl0gLSBUaGUgZGVzaXJlZCBudW1iZXIgb2YgZGVjaW1hbHMgdG8gcm91bmQgZG93biB0b1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmNvbnZlcnNpb25SYXRlXSAtIFRoZSByYXRlIHRvIHVzZSB0byBtYWtlIHRoZSBmcm9tQ3VycmVuY3kgLT4gdG9DdXJyZW5jeSBjb252ZXJzaW9uXG4gKiBAcmV0dXJucyB7KG51bWJlciB8IHN0cmluZyB8IEJOKX1cbiAqXG4gKiBUaGUgdXRpbGl0eSBwYXNzZXMgdmFsdWUgYWxvbmcgd2l0aCB0aGUgb3B0aW9ucyBhcyBhIHNpbmdsZSBvYmplY3QgdG8gdGhlIGBjb252ZXJ0ZXJgIGZ1bmN0aW9uLlxuICogYGNvbnZlcnRlcmAgY29uZGl0aW9uYWwgbW9kaWZpZXMgdGhlIHN1cHBsaWVkIGB2YWx1ZWAgcHJvcGVydHksIGRlcGVuZGluZ1xuICogb24gdGhlIGFjY29tcGFueWluZyBvcHRpb25zLlxuICovXG5cbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcblxuaW1wb3J0IHsgQk4gfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuXG5pbXBvcnQgeyBzdHJpcEhleFByZWZpeCB9IGZyb20gJy4vaGV4c3RyaW5nLXV0aWxzJztcblxuLy8gQmlnIE51bWJlciBDb25zdGFudHNcbmNvbnN0IEJJR19OVU1CRVJfV0VJX01VTFRJUExJRVIgPSBuZXcgQmlnTnVtYmVyKCcxMDAwMDAwMDAwMDAwMDAwMDAwJyk7XG5jb25zdCBCSUdfTlVNQkVSX0dXRUlfTVVMVElQTElFUiA9IG5ldyBCaWdOdW1iZXIoJzEwMDAwMDAwMDAnKTtcbmNvbnN0IEJJR19OVU1CRVJfRVRIX01VTFRJUExJRVIgPSBuZXcgQmlnTnVtYmVyKCcxJyk7XG5cbi8vIFNldHRlciBNYXBzXG5jb25zdCB0b0JpZ051bWJlciA9IHtcbiAgaGV4OiAobikgPT4gbmV3IEJpZ051bWJlcihzdHJpcEhleFByZWZpeChuKSwgMTYpLFxuICBkZWM6IChuKSA9PiBuZXcgQmlnTnVtYmVyKFN0cmluZyhuKSwgMTApLFxuICBCTjogKG4pID0+IG5ldyBCaWdOdW1iZXIobi50b1N0cmluZygxNiksIDE2KSxcbn07XG5jb25zdCB0b05vcm1hbGl6ZWREZW5vbWluYXRpb24gPSB7XG4gIFdFSTogKGJpZ051bWJlcikgPT4gYmlnTnVtYmVyLmRpdihCSUdfTlVNQkVSX1dFSV9NVUxUSVBMSUVSKSxcbiAgR1dFSTogKGJpZ051bWJlcikgPT4gYmlnTnVtYmVyLmRpdihCSUdfTlVNQkVSX0dXRUlfTVVMVElQTElFUiksXG4gIEVUSDogKGJpZ051bWJlcikgPT4gYmlnTnVtYmVyLmRpdihCSUdfTlVNQkVSX0VUSF9NVUxUSVBMSUVSKSxcbn07XG5jb25zdCB0b1NwZWNpZmllZERlbm9taW5hdGlvbiA9IHtcbiAgV0VJOiAoYmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIudGltZXMoQklHX05VTUJFUl9XRUlfTVVMVElQTElFUikucm91bmQoKSxcbiAgR1dFSTogKGJpZ051bWJlcikgPT4gYmlnTnVtYmVyLnRpbWVzKEJJR19OVU1CRVJfR1dFSV9NVUxUSVBMSUVSKS5yb3VuZCg5KSxcbiAgRVRIOiAoYmlnTnVtYmVyKSA9PiBiaWdOdW1iZXIudGltZXMoQklHX05VTUJFUl9FVEhfTVVMVElQTElFUikucm91bmQoOSksXG59O1xuY29uc3QgYmFzZUNoYW5nZSA9IHtcbiAgaGV4OiAobikgPT4gbi50b1N0cmluZygxNiksXG4gIGRlYzogKG4pID0+IG5ldyBCaWdOdW1iZXIobikudG9TdHJpbmcoMTApLFxuICBCTjogKG4pID0+IG5ldyBCTihuLnRvU3RyaW5nKDE2KSksXG59O1xuXG4vLyBVdGlsaXR5IGZ1bmN0aW9uIGZvciBjaGVja2luZyBiYXNlIHR5cGVzXG5jb25zdCBpc1ZhbGlkQmFzZSA9IChiYXNlKSA9PiB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGJhc2UpICYmIGJhc2UgPiAxO1xufTtcblxuLyoqXG4gKiBEZWZpbmVzIHRoZSBiYXNlIHR5cGUgb2YgbnVtZXJpYyB2YWx1ZVxuICpcbiAqIEB0eXBlZGVmIHsoJ2hleCcgfCAnZGVjJyB8ICdCTicpfSBOdW1lcmljQmFzZVxuICovXG5cbi8qKlxuICogRGVmaW5lcyB3aGljaCB0eXBlIG9mIGRlbm9taW5hdGlvbiBhIHZhbHVlIGlzIGluXG4gKlxuICogQHR5cGVkZWYgeygnV0VJJyB8ICdHV0VJJyB8ICdFVEgnKX0gRXRoRGVub21pbmF0aW9uXG4gKi9cblxuLyoqXG4gKiBVdGlsaXR5IG1ldGhvZCB0byBjb252ZXJ0IGEgdmFsdWUgYmV0d2VlbiBkZW5vbWluYXRpb25zLCBmb3JtYXRzIGFuZCBjdXJyZW5jaWVzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFxuICogQHBhcmFtIHtzdHJpbmcgfCBCaWdOdW1iZXJ9IGlucHV0LnZhbHVlXG4gKiBAcGFyYW0ge051bWVyaWNCYXNlfSBpbnB1dC5mcm9tTnVtZXJpY0Jhc2VcbiAqIEBwYXJhbSB7RXRoRGVub21pbmF0aW9ufSBbaW5wdXQuZnJvbURlbm9taW5hdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXQuZnJvbUN1cnJlbmN5XVxuICogQHBhcmFtIHtOdW1lcmljQmFzZX0gaW5wdXQudG9OdW1lcmljQmFzZVxuICogQHBhcmFtIHtFdGhEZW5vbWluYXRpb259IFtpbnB1dC50b0Rlbm9taW5hdGlvbl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXQudG9DdXJyZW5jeV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXQubnVtYmVyT2ZEZWNpbWFsc11cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXQuY29udmVyc2lvblJhdGVdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnB1dC5pbnZlcnRDb252ZXJzaW9uUmF0ZV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbaW5wdXQucm91bmREb3duXVxuICovXG5jb25zdCBjb252ZXJ0ZXIgPSAoe1xuICB2YWx1ZSxcbiAgZnJvbU51bWVyaWNCYXNlLFxuICBmcm9tRGVub21pbmF0aW9uLFxuICBmcm9tQ3VycmVuY3ksXG4gIHRvTnVtZXJpY0Jhc2UsXG4gIHRvRGVub21pbmF0aW9uLFxuICB0b0N1cnJlbmN5LFxuICBudW1iZXJPZkRlY2ltYWxzLFxuICBjb252ZXJzaW9uUmF0ZSxcbiAgaW52ZXJ0Q29udmVyc2lvblJhdGUsXG4gIHJvdW5kRG93bixcbn0pID0+IHtcbiAgbGV0IGNvbnZlcnRlZFZhbHVlID0gZnJvbU51bWVyaWNCYXNlXG4gICAgPyB0b0JpZ051bWJlcltmcm9tTnVtZXJpY0Jhc2VdKHZhbHVlKVxuICAgIDogdmFsdWU7XG5cbiAgaWYgKGZyb21EZW5vbWluYXRpb24pIHtcbiAgICBjb252ZXJ0ZWRWYWx1ZSA9IHRvTm9ybWFsaXplZERlbm9taW5hdGlvbltmcm9tRGVub21pbmF0aW9uXShjb252ZXJ0ZWRWYWx1ZSk7XG4gIH1cblxuICBpZiAoZnJvbUN1cnJlbmN5ICE9PSB0b0N1cnJlbmN5KSB7XG4gICAgaWYgKGNvbnZlcnNpb25SYXRlID09PSBudWxsIHx8IGNvbnZlcnNpb25SYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENvbnZlcnRpbmcgZnJvbSAke2Zyb21DdXJyZW5jeX0gdG8gJHt0b0N1cnJlbmN5fSByZXF1aXJlcyBhIGNvbnZlcnNpb25SYXRlLCBidXQgb25lIHdhcyBub3QgcHJvdmlkZWRgLFxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHJhdGUgPSB0b0JpZ051bWJlci5kZWMoY29udmVyc2lvblJhdGUpO1xuICAgIGlmIChpbnZlcnRDb252ZXJzaW9uUmF0ZSkge1xuICAgICAgcmF0ZSA9IG5ldyBCaWdOdW1iZXIoMS4wKS5kaXYoY29udmVyc2lvblJhdGUpO1xuICAgIH1cbiAgICBjb252ZXJ0ZWRWYWx1ZSA9IGNvbnZlcnRlZFZhbHVlLnRpbWVzKHJhdGUpO1xuICB9XG5cbiAgaWYgKHRvRGVub21pbmF0aW9uKSB7XG4gICAgY29udmVydGVkVmFsdWUgPSB0b1NwZWNpZmllZERlbm9taW5hdGlvblt0b0Rlbm9taW5hdGlvbl0oY29udmVydGVkVmFsdWUpO1xuICB9XG5cbiAgaWYgKG51bWJlck9mRGVjaW1hbHMgIT09IHVuZGVmaW5lZCAmJiBudW1iZXJPZkRlY2ltYWxzICE9PSBudWxsKSB7XG4gICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZS5yb3VuZChcbiAgICAgIG51bWJlck9mRGVjaW1hbHMsXG4gICAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9ET1dOLFxuICAgICk7XG4gIH1cblxuICBpZiAocm91bmREb3duKSB7XG4gICAgY29udmVydGVkVmFsdWUgPSBjb252ZXJ0ZWRWYWx1ZS5yb3VuZChyb3VuZERvd24sIEJpZ051bWJlci5ST1VORF9ET1dOKTtcbiAgfVxuXG4gIGlmICh0b051bWVyaWNCYXNlKSB7XG4gICAgY29udmVydGVkVmFsdWUgPSBiYXNlQ2hhbmdlW3RvTnVtZXJpY0Jhc2VdKGNvbnZlcnRlZFZhbHVlKTtcbiAgfVxuICByZXR1cm4gY29udmVydGVkVmFsdWU7XG59O1xuXG5jb25zdCBjb252ZXJzaW9uVXRpbCA9IChcbiAgdmFsdWUsXG4gIHtcbiAgICBmcm9tQ3VycmVuY3kgPSBudWxsLFxuICAgIHRvQ3VycmVuY3kgPSBmcm9tQ3VycmVuY3ksXG4gICAgZnJvbU51bWVyaWNCYXNlLFxuICAgIHRvTnVtZXJpY0Jhc2UsXG4gICAgZnJvbURlbm9taW5hdGlvbixcbiAgICB0b0Rlbm9taW5hdGlvbixcbiAgICBudW1iZXJPZkRlY2ltYWxzLFxuICAgIGNvbnZlcnNpb25SYXRlLFxuICAgIGludmVydENvbnZlcnNpb25SYXRlLFxuICB9LFxuKSA9PiB7XG4gIGlmIChmcm9tQ3VycmVuY3kgIT09IHRvQ3VycmVuY3kgJiYgIWNvbnZlcnNpb25SYXRlKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIGNvbnZlcnRlcih7XG4gICAgZnJvbUN1cnJlbmN5LFxuICAgIHRvQ3VycmVuY3ksXG4gICAgZnJvbU51bWVyaWNCYXNlLFxuICAgIHRvTnVtZXJpY0Jhc2UsXG4gICAgZnJvbURlbm9taW5hdGlvbixcbiAgICB0b0Rlbm9taW5hdGlvbixcbiAgICBudW1iZXJPZkRlY2ltYWxzLFxuICAgIGNvbnZlcnNpb25SYXRlLFxuICAgIGludmVydENvbnZlcnNpb25SYXRlLFxuICAgIHZhbHVlOiB2YWx1ZSB8fCAnMCcsXG4gIH0pO1xufTtcblxuY29uc3QgZ2V0QmlnTnVtYmVyID0gKHZhbHVlLCBiYXNlKSA9PiB7XG4gIGlmICghaXNWYWxpZEJhc2UoYmFzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSB2YWxpZCBiYXNlJyk7XG4gIH1cblxuICAvLyBXZSBkb24ndCBpbmNsdWRlICdudW1iZXInIGhlcmUsIGJlY2F1c2UgQmlnTnVtYmVyIHdpbGwgdGhyb3cgaWYgcGFzc2VkXG4gIC8vIGEgbnVtYmVyIHByaW1pdGl2ZSBpdCBjb25zaWRlcnMgdW5zYWZlLlxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIEJpZ051bWJlcikge1xuICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbHVlLCBiYXNlKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKFN0cmluZyh2YWx1ZSksIGJhc2UpO1xufTtcblxuY29uc3QgYWRkQ3VycmVuY2llcyA9IChhLCBiLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBhQmFzZSwgYkJhc2UsIC4uLmNvbnZlcnNpb25PcHRpb25zIH0gPSBvcHRpb25zO1xuXG4gIGlmICghaXNWYWxpZEJhc2UoYUJhc2UpIHx8ICFpc1ZhbGlkQmFzZShiQmFzZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ011c3Qgc3BlY2lmeSB2YWxpZCBhQmFzZSBhbmQgYkJhc2UnKTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gZ2V0QmlnTnVtYmVyKGEsIGFCYXNlKS5hZGQoZ2V0QmlnTnVtYmVyKGIsIGJCYXNlKSk7XG5cbiAgcmV0dXJuIGNvbnZlcnRlcih7XG4gICAgdmFsdWUsXG4gICAgLi4uY29udmVyc2lvbk9wdGlvbnMsXG4gIH0pO1xufTtcblxuY29uc3Qgc3VidHJhY3RDdXJyZW5jaWVzID0gKGEsIGIsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICBjb25zdCB7IGFCYXNlLCBiQmFzZSwgLi4uY29udmVyc2lvbk9wdGlvbnMgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFpc1ZhbGlkQmFzZShhQmFzZSkgfHwgIWlzVmFsaWRCYXNlKGJCYXNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHZhbGlkIGFCYXNlIGFuZCBiQmFzZScpO1xuICB9XG5cbiAgY29uc3QgdmFsdWUgPSBnZXRCaWdOdW1iZXIoYSwgYUJhc2UpLm1pbnVzKGdldEJpZ051bWJlcihiLCBiQmFzZSkpO1xuXG4gIHJldHVybiBjb252ZXJ0ZXIoe1xuICAgIHZhbHVlLFxuICAgIC4uLmNvbnZlcnNpb25PcHRpb25zLFxuICB9KTtcbn07XG5cbmNvbnN0IG11bHRpcGx5Q3VycmVuY2llcyA9IChhLCBiLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBtdWx0aXBsaWNhbmRCYXNlLCBtdWx0aXBsaWVyQmFzZSwgLi4uY29udmVyc2lvbk9wdGlvbnMgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFpc1ZhbGlkQmFzZShtdWx0aXBsaWNhbmRCYXNlKSB8fCAhaXNWYWxpZEJhc2UobXVsdGlwbGllckJhc2UpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHNwZWNpZnkgdmFsaWQgbXVsdGlwbGljYW5kQmFzZSBhbmQgbXVsdGlwbGllckJhc2UnKTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gZ2V0QmlnTnVtYmVyKGEsIG11bHRpcGxpY2FuZEJhc2UpLnRpbWVzKFxuICAgIGdldEJpZ051bWJlcihiLCBtdWx0aXBsaWVyQmFzZSksXG4gICk7XG5cbiAgcmV0dXJuIGNvbnZlcnRlcih7XG4gICAgdmFsdWUsXG4gICAgLi4uY29udmVyc2lvbk9wdGlvbnMsXG4gIH0pO1xufTtcblxuY29uc3QgZGl2aWRlQ3VycmVuY2llcyA9IChhLCBiLCBvcHRpb25zID0ge30pID0+IHtcbiAgY29uc3QgeyBkaXZpZGVuZEJhc2UsIGRpdmlzb3JCYXNlLCAuLi5jb252ZXJzaW9uT3B0aW9ucyB9ID0gb3B0aW9ucztcblxuICBpZiAoIWlzVmFsaWRCYXNlKGRpdmlkZW5kQmFzZSkgfHwgIWlzVmFsaWRCYXNlKGRpdmlzb3JCYXNlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHZhbGlkIGRpdmlkZW5kQmFzZSBhbmQgZGl2aXNvckJhc2UnKTtcbiAgfVxuXG4gIGNvbnN0IHZhbHVlID0gZ2V0QmlnTnVtYmVyKGEsIGRpdmlkZW5kQmFzZSkuZGl2KGdldEJpZ051bWJlcihiLCBkaXZpc29yQmFzZSkpO1xuXG4gIHJldHVybiBjb252ZXJ0ZXIoe1xuICAgIHZhbHVlLFxuICAgIC4uLmNvbnZlcnNpb25PcHRpb25zLFxuICB9KTtcbn07XG5cbmNvbnN0IGNvbnZlcnNpb25HcmVhdGVyVGhhbiA9ICh7IC4uLmZpcnN0UHJvcHMgfSwgeyAuLi5zZWNvbmRQcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGZpcnN0VmFsdWUgPSBjb252ZXJ0ZXIoeyAuLi5maXJzdFByb3BzIH0pO1xuICBjb25zdCBzZWNvbmRWYWx1ZSA9IGNvbnZlcnRlcih7IC4uLnNlY29uZFByb3BzIH0pO1xuXG4gIHJldHVybiBmaXJzdFZhbHVlLmd0KHNlY29uZFZhbHVlKTtcbn07XG5cbmNvbnN0IGNvbnZlcnNpb25MZXNzVGhhbiA9ICh7IC4uLmZpcnN0UHJvcHMgfSwgeyAuLi5zZWNvbmRQcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGZpcnN0VmFsdWUgPSBjb252ZXJ0ZXIoeyAuLi5maXJzdFByb3BzIH0pO1xuICBjb25zdCBzZWNvbmRWYWx1ZSA9IGNvbnZlcnRlcih7IC4uLnNlY29uZFByb3BzIH0pO1xuXG4gIHJldHVybiBmaXJzdFZhbHVlLmx0KHNlY29uZFZhbHVlKTtcbn07XG5cbmNvbnN0IGNvbnZlcnNpb25NYXggPSAoeyAuLi5maXJzdFByb3BzIH0sIHsgLi4uc2Vjb25kUHJvcHMgfSkgPT4ge1xuICBjb25zdCBmaXJzdElzR3JlYXRlciA9IGNvbnZlcnNpb25HcmVhdGVyVGhhbihcbiAgICB7IC4uLmZpcnN0UHJvcHMgfSxcbiAgICB7IC4uLnNlY29uZFByb3BzIH0sXG4gICk7XG5cbiAgcmV0dXJuIGZpcnN0SXNHcmVhdGVyID8gZmlyc3RQcm9wcy52YWx1ZSA6IHNlY29uZFByb3BzLnZhbHVlO1xufTtcblxuY29uc3QgY29udmVyc2lvbkdURSA9ICh7IC4uLmZpcnN0UHJvcHMgfSwgeyAuLi5zZWNvbmRQcm9wcyB9KSA9PiB7XG4gIGNvbnN0IGZpcnN0VmFsdWUgPSBjb252ZXJ0ZXIoeyAuLi5maXJzdFByb3BzIH0pO1xuICBjb25zdCBzZWNvbmRWYWx1ZSA9IGNvbnZlcnRlcih7IC4uLnNlY29uZFByb3BzIH0pO1xuICByZXR1cm4gZmlyc3RWYWx1ZS5ncmVhdGVyVGhhbk9yRXF1YWxUbyhzZWNvbmRWYWx1ZSk7XG59O1xuXG5jb25zdCBjb252ZXJzaW9uTFRFID0gKHsgLi4uZmlyc3RQcm9wcyB9LCB7IC4uLnNlY29uZFByb3BzIH0pID0+IHtcbiAgY29uc3QgZmlyc3RWYWx1ZSA9IGNvbnZlcnRlcih7IC4uLmZpcnN0UHJvcHMgfSk7XG4gIGNvbnN0IHNlY29uZFZhbHVlID0gY29udmVydGVyKHsgLi4uc2Vjb25kUHJvcHMgfSk7XG4gIHJldHVybiBmaXJzdFZhbHVlLmxlc3NUaGFuT3JFcXVhbFRvKHNlY29uZFZhbHVlKTtcbn07XG5cbmNvbnN0IHRvTmVnYXRpdmUgPSAobiwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gIHJldHVybiBtdWx0aXBseUN1cnJlbmNpZXMobiwgLTEsIG9wdGlvbnMpO1xufTtcblxuZnVuY3Rpb24gZGVjR1dFSVRvSGV4V0VJKGRlY0dXRUkpIHtcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKGRlY0dXRUksIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIGZyb21EZW5vbWluYXRpb246ICdHV0VJJyxcbiAgICB0b0Rlbm9taW5hdGlvbjogJ1dFSScsXG4gIH0pO1xufVxuXG5leHBvcnQge1xuICBjb252ZXJzaW9uVXRpbCxcbiAgYWRkQ3VycmVuY2llcyxcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxuICBjb252ZXJzaW9uR3JlYXRlclRoYW4sXG4gIGNvbnZlcnNpb25MZXNzVGhhbixcbiAgY29udmVyc2lvbkdURSxcbiAgY29udmVyc2lvbkxURSxcbiAgY29udmVyc2lvbk1heCxcbiAgdG9OZWdhdGl2ZSxcbiAgc3VidHJhY3RDdXJyZW5jaWVzLFxuICBkZWNHV0VJVG9IZXhXRUksXG4gIHRvQmlnTnVtYmVyLFxuICB0b05vcm1hbGl6ZWREZW5vbWluYXRpb24sXG4gIGRpdmlkZUN1cnJlbmNpZXMsXG59O1xuIiwiaW1wb3J0IHsgbWVtb2l6ZSB9IGZyb20gJ2xvZGFzaCc7XHJcbmltcG9ydCB7IFNFQ09ORCB9IGZyb20gJy4uL2NvbnN0YW50cy90aW1lJztcclxuXHJcbmNvbnN0IGdldEZldGNoV2l0aFRpbWVvdXQgPSBtZW1vaXplKCh0aW1lb3V0ID0gU0VDT05EICogMzApID0+IHtcclxuICBpZiAoIU51bWJlci5pc0ludGVnZXIodGltZW91dCkgfHwgdGltZW91dCA8IDEpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBzcGVjaWZ5IHBvc2l0aXZlIGludGVnZXIgdGltZW91dC4nKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiBfZmV0Y2godXJsLCBvcHRzKSB7XHJcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgd2luZG93LkFib3J0Q29udHJvbGxlcigpO1xyXG4gICAgY29uc3QgeyBzaWduYWwgfSA9IGFib3J0Q29udHJvbGxlcjtcclxuICAgIGNvbnN0IGYgPSB3aW5kb3cuZmV0Y2godXJsLCB7XHJcbiAgICAgIC4uLm9wdHMsXHJcbiAgICAgIHNpZ25hbCxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiBhYm9ydENvbnRyb2xsZXIuYWJvcnQoKSwgdGltZW91dCk7XHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcmVzID0gYXdhaXQgZjtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgcmV0dXJuIHJlcztcclxuICAgIH0gY2F0Y2ggKGUpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuICAgICAgdGhyb3cgZTtcclxuICAgIH1cclxuICB9O1xyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGdldEZldGNoV2l0aFRpbWVvdXQ7XHJcbiIsImltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XHJcbmltcG9ydCB7XHJcbiAgYWRkQ3VycmVuY2llcyxcclxuICBjb252ZXJzaW9uR3JlYXRlclRoYW4sXHJcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxyXG59IGZyb20gJy4vY29udmVyc2lvbi51dGlscyc7XHJcblxyXG4vKipcclxuICogQWNjZXB0cyBhbiBvcHRpb25zIGJhZyBjb250YWluaW5nIGdhcyBmZWUgcGFyYW1ldGVycyBpbiBoZXggZm9ybWF0IGFuZFxyXG4gKiByZXR1cm5zIGEgZ2FzVG90YWwgcGFyYW1ldGVyIHJlcHJlc2VudGluZyB0aGUgbWF4aW11bSBhbW91bnQgb2Ygd2VpIHRoZVxyXG4gKiB0cmFuc2FjdGlvbiB3aWxsIGNvc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gZ2FzIGZlZSBwYXJhbWV0ZXJzIG9iamVjdFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuZ2FzTGltaXRdIC0gdGhlIG1heGltdW0gYW1vdW50IG9mIGdhcyB0byBhbGxvdyB0aGlzXHJcbiAqICB0cmFuc2FjdGlvbiB0byBjb25zdW1lLiBWYWx1ZSBpcyBhIGhleCBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmdhc1ByaWNlXSAtIFRoZSBmZWUgaW4gd2VpIHRvIHBheSBwZXIgZ2FzIHVzZWQuXHJcbiAqICBnYXNQcmljZSBpcyBvbmx5IHNldCBvbiBMZWdhY3kgdHlwZSB0cmFuc2FjdGlvbnMuIFZhbHVlIGlzIGhleCBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1heEZlZVBlckdhc10gLSBUaGUgbWF4aW11bSBmZWUgaW4gd2VpIHRvIHBheSBwZXJcclxuICogIGdhcyB1c2VkLiBtYXhGZWVQZXJHYXMgaXMgaW50cm9kdWNlZCBpbiBFSVAgMTU1OSBhbmQgcmVwcmVzZW50cyB0aGUgbWF4XHJcbiAqICB0b3RhbCBhIHVzZXIgd2lsbCBwYXkgcGVyIGdhcy4gQWN0dWFsIGNvc3QgaXMgZGV0ZXJtaW5lZCBieSBiYXNlRmVlUGVyR2FzXHJcbiAqICBvbiB0aGUgYmxvY2sgKyBtYXhQcmlvcml0eUZlZVBlckdhcy4gVmFsdWUgaXMgaGV4IHN0cmluZ1xyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbWF4aW11bSB0b3RhbCBjb3N0IG9mIHRyYW5zYWN0aW9uIGluIGhleCB3ZWkgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWF4aW11bUdhc1RvdGFsSW5IZXhXZWkoe1xyXG4gIGdhc0xpbWl0ID0gJzB4MCcsXHJcbiAgZ2FzUHJpY2UsXHJcbiAgbWF4RmVlUGVyR2FzLFxyXG59ID0ge30pIHtcclxuICBpZiAobWF4RmVlUGVyR2FzKSB7XHJcbiAgICByZXR1cm4gYWRkSGV4UHJlZml4KFxyXG4gICAgICBtdWx0aXBseUN1cnJlbmNpZXMoZ2FzTGltaXQsIG1heEZlZVBlckdhcywge1xyXG4gICAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxyXG4gICAgICAgIG11bHRpcGxpZXJCYXNlOiAxNixcclxuICAgICAgfSksXHJcbiAgICApO1xyXG4gIH1cclxuICBpZiAoIWdhc1ByaWNlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICdnZXRNYXhpbXVtR2FzVG90YWxJbkhleFdlaSByZXF1aXJlcyBnYXNQcmljZSBiZSBwcm92aWRlZCB0byBjYWxjdWxhdGUgbGVnYWN5IGdhcyB0b3RhbCcsXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gYWRkSGV4UHJlZml4KFxyXG4gICAgbXVsdGlwbHlDdXJyZW5jaWVzKGdhc0xpbWl0LCBnYXNQcmljZSwge1xyXG4gICAgICB0b051bWVyaWNCYXNlOiAnaGV4JyxcclxuICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTYsXHJcbiAgICAgIG11bHRpcGxpZXJCYXNlOiAxNixcclxuICAgIH0pLFxyXG4gICk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBY2NlcHRzIGFuIG9wdGlvbnMgYmFnIGNvbnRhaW5pbmcgZ2FzIGZlZSBwYXJhbWV0ZXJzIGluIGhleCBmb3JtYXQgYW5kXHJcbiAqIHJldHVybnMgYSBnYXNUb3RhbCBwYXJhbWV0ZXIgcmVwcmVzZW50aW5nIHRoZSBtaW5pbXVtIGFtb3VudCBvZiB3ZWkgdGhlXHJcbiAqIHRyYW5zYWN0aW9uIHdpbGwgY29zdC4gRm9yIGdhc1ByaWNlIHR5cGVzIHRoaXMgaXMgdGhlIHNhbWUgYXMgbWF4LlxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGdhcyBmZWUgcGFyYW1ldGVycyBvYmplY3RcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmdhc0xpbWl0XSAtIHRoZSBtYXhpbXVtIGFtb3VudCBvZiBnYXMgdG8gYWxsb3cgdGhpc1xyXG4gKiAgdHJhbnNhY3Rpb24gdG8gY29uc3VtZS4gVmFsdWUgaXMgYSBoZXggc3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5nYXNQcmljZV0gLSBUaGUgZmVlIGluIHdlaSB0byBwYXkgcGVyIGdhcyB1c2VkLlxyXG4gKiAgZ2FzUHJpY2UgaXMgb25seSBzZXQgb24gTGVnYWN5IHR5cGUgdHJhbnNhY3Rpb25zLiBWYWx1ZSBpcyBoZXggc3RyaW5nXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5tYXhGZWVQZXJHYXNdIC0gVGhlIG1heGltdW0gZmVlIGluIHdlaSB0byBwYXkgcGVyXHJcbiAqICBnYXMgdXNlZC4gbWF4RmVlUGVyR2FzIGlzIGludHJvZHVjZWQgaW4gRUlQIDE1NTkgYW5kIHJlcHJlc2VudHMgdGhlIG1heFxyXG4gKiAgdG90YWwgYSB1c2VyIHdpbGwgcGF5IHBlciBnYXMuIEFjdHVhbCBjb3N0IGlzIGRldGVybWluZWQgYnkgYmFzZUZlZVBlckdhc1xyXG4gKiAgb24gdGhlIGJsb2NrICsgbWF4UHJpb3JpdHlGZWVQZXJHYXMuIFZhbHVlIGlzIGhleCBzdHJpbmdcclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1heFByaW9yaXR5RmVlUGVyR2FzXSAtIFRoZSBtYXhpbXVtIGZlZSBpbiB3ZWkgdG9cclxuICogIHBheSBhIG1pbmVyIHRvIGluY2x1ZGUgdGhpcyB0cmFuc2FjdGlvbi5cclxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJhc2VGZWVQZXJHYXNdIC0gVGhlIGVzdGltYXRlZCBibG9jayBiYXNlRmVlUGVyR2FzXHJcbiAqICB0aGF0IHdpbGwgYmUgYnVybmVkLiBJbnRyb2R1Y2VkIGluIEVJUCAxNTU5LiBWYWx1ZSBpbiBoZXggd2VpLlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgbWluaW11bSB0b3RhbCBjb3N0IG9mIHRyYW5zYWN0aW9uIGluIGhleCB3ZWkgc3RyaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluaW11bUdhc1RvdGFsSW5IZXhXZWkoe1xyXG4gIGdhc0xpbWl0ID0gJzB4MCcsXHJcbiAgZ2FzUHJpY2UsXHJcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXHJcbiAgbWF4RmVlUGVyR2FzLFxyXG4gIGJhc2VGZWVQZXJHYXMsXHJcbn0gPSB7fSkge1xyXG4gIGNvbnN0IGlzRUlQMTU1OUVzdGltYXRlID0gQm9vbGVhbihcclxuICAgIG1heEZlZVBlckdhcyB8fCBtYXhQcmlvcml0eUZlZVBlckdhcyB8fCBiYXNlRmVlUGVyR2FzLFxyXG4gICk7XHJcbiAgaWYgKGlzRUlQMTU1OUVzdGltYXRlICYmIGdhc1ByaWNlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBnZXRNaW5pbXVtR2FzVG90YWxJbkhleFdlaSBleHBlY3RzIGVpdGhlciBnYXNQcmljZSBPUiB0aGUgRUlQLTE1NTkgZ2FzIGZpZWxkcywgYnV0IGJvdGggd2VyZSBwcm92aWRlZGAsXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgaWYgKGlzRUlQMTU1OUVzdGltYXRlID09PSBmYWxzZSAmJiAhZ2FzUHJpY2UpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYGdldE1pbmltdW1HYXNUb3RhbEluSGV4V2VpIGV4cGVjdHMgZWl0aGVyIGdhc1ByaWNlIE9SIHRoZSBFSVAtMTU1OSBnYXMgZmllbGRzLCBidXQgbmVpdGhlciB3ZXJlIHByb3ZpZGVkYCxcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBpZiAoaXNFSVAxNTU5RXN0aW1hdGUgJiYgIWJhc2VGZWVQZXJHYXMpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYGdldE1pbmltdW1HYXNUb3RhbEluSGV4V2VpIHJlcXVpcmVzIGJhc2VGZWVQZXJHYXMgYmUgcHJvdmlkZWQgd2hlbiBjYWxjdWxhdGluZyBFSVAtMTU1OSB0b3RhbHNgLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGlmIChpc0VJUDE1NTlFc3RpbWF0ZSAmJiAoIW1heEZlZVBlckdhcyB8fCAhbWF4UHJpb3JpdHlGZWVQZXJHYXMpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBnZXRNaW5pbXVtR2FzVG90YWxJbkhleFdlaSByZXF1aXJlcyBtYXhGZWVQZXJHYXMgYW5kIG1heFByaW9yaXR5RmVlUGVyR2FzIGJlIHByb3ZpZGVkIHdoZW4gY2FsY3VsYXRpbmcgRUlQLTE1NTkgdG90YWxzYCxcclxuICAgICk7XHJcbiAgfVxyXG4gIGlmIChpc0VJUDE1NTlFc3RpbWF0ZSA9PT0gZmFsc2UpIHtcclxuICAgIHJldHVybiBnZXRNYXhpbXVtR2FzVG90YWxJbkhleFdlaSh7IGdhc0xpbWl0LCBnYXNQcmljZSB9KTtcclxuICB9XHJcbiAgY29uc3QgbWluaW11bUZlZVBlckdhcyA9IGFkZEN1cnJlbmNpZXMoYmFzZUZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIHtcclxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgYUJhc2U6IDE2LFxyXG4gICAgYkJhc2U6IDE2LFxyXG4gIH0pO1xyXG5cclxuICBpZiAoXHJcbiAgICBjb252ZXJzaW9uR3JlYXRlclRoYW4oXHJcbiAgICAgIHsgdmFsdWU6IG1pbmltdW1GZWVQZXJHYXMsIGZyb21OdW1lcmljQmFzZTogJ2hleCcgfSxcclxuICAgICAgeyB2YWx1ZTogbWF4RmVlUGVyR2FzLCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXHJcbiAgICApXHJcbiAgKSB7XHJcbiAgICByZXR1cm4gZ2V0TWF4aW11bUdhc1RvdGFsSW5IZXhXZWkoeyBnYXNMaW1pdCwgbWF4RmVlUGVyR2FzIH0pO1xyXG4gIH1cclxuICByZXR1cm4gYWRkSGV4UHJlZml4KFxyXG4gICAgbXVsdGlwbHlDdXJyZW5jaWVzKGdhc0xpbWl0LCBtaW5pbXVtRmVlUGVyR2FzLCB7XHJcbiAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgICBtdWx0aXBsaWNhbmRCYXNlOiAxNixcclxuICAgICAgbXVsdGlwbGllckJhc2U6IDE2LFxyXG4gICAgfSksXHJcbiAgKTtcclxufVxyXG4iLCJpbXBvcnQge1xuICBpc0hleFN0cmluZyxcbiAgaXNWYWxpZEFkZHJlc3MsXG4gIGlzVmFsaWRDaGVja3N1bUFkZHJlc3MsXG4gIGFkZEhleFByZWZpeCxcbiAgdG9DaGVja3N1bUFkZHJlc3MsXG4gIHplcm9BZGRyZXNzLFxuICBpc0hleFByZWZpeGVkLFxufSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuXG5leHBvcnQgY29uc3QgQlVSTl9BRERSRVNTID0gemVyb0FkZHJlc3MoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzQnVybkFkZHJlc3MoYWRkcmVzcykge1xuICByZXR1cm4gYWRkcmVzcyA9PT0gQlVSTl9BRERSRVNTO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyB0aGF0IHRoZSBpbnB1dCBpcyBhIGhleCBhZGRyZXNzLiBUaGlzIHV0aWxpdHkgbWV0aG9kIGlzIGEgdGhpblxuICogd3JhcHBlciBhcm91bmQgZXRoZXJldW1qcy11dGlsLmlzVmFsaWRBZGRyZXNzLCB3aXRoIHRoZSBleGNlcHRpb24gdGhhdCBpdFxuICogZG9lcyBub3QgdGhyb3cgYW4gZXJyb3Igd2hlbiBwcm92aWRlZCB2YWx1ZXMgdGhhdCBhcmUgbm90IGhleCBzdHJpbmdzLiBJblxuICogYWRkaXRpb24sIGFuZCBieSBkZWZhdWx0LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiB0cnVlIGZvciBoZXggc3RyaW5ncyB0aGF0XG4gKiBtZWV0IHRoZSBsZW5ndGggcmVxdWlyZW1lbnQgb2YgYSBoZXggYWRkcmVzcywgYnV0IGFyZSBub3QgcHJlZml4ZWQgd2l0aCBgMHhgXG4gKiBGaW5hbGx5LCBpZiB0aGUgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gZmxhZyBpcyB0cnVlIGFuZCBhIG1peGVkIGNhc2Ugc3RyaW5nIGlzXG4gKiBwcm92aWRlZCB0aGlzIG1ldGhvZCB3aWxsIHZhbGlkYXRlIGl0IGhhcyB0aGUgcHJvcGVyIGNoZWNrc3VtIGZvcm1hdHRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBvc3NpYmxlQWRkcmVzcyAtIElucHV0IHBhcmFtZXRlciB0byBjaGVjayBhZ2FpbnN0XG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gb3B0aW9ucyBiYWdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYWxsb3dOb25QcmVmaXhlZF0gLSBJZiB0cnVlIHdpbGwgZmlyc3QgZW5zdXJlICcweCdcbiAqICBpcyBwcmVwZW5kZWQgdG8gdGhlIHN0cmluZ1xuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5taXhlZENhc2VVc2VDaGVja3N1bV0gLSBJZiB0cnVlIHdpbGwgdHJlYXQgbWl4ZWRcbiAqICBjYXNlIGFkZHJlc3NlcyBhcyBjaGVja3N1bSBhZGRyZXNzZXMgYW5kIHZhbGlkYXRlIHRoYXQgcHJvcGVyIGNoZWNrc3VtXG4gKiAgZm9ybWF0IGlzIHVzZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgaW5wdXQgaXMgYSB2YWxpZCBoZXggYWRkcmVzc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEhleEFkZHJlc3MoXG4gIHBvc3NpYmxlQWRkcmVzcyxcbiAgeyBhbGxvd05vblByZWZpeGVkID0gdHJ1ZSwgbWl4ZWRDYXNlVXNlQ2hlY2tzdW0gPSBmYWxzZSB9ID0ge30sXG4pIHtcbiAgY29uc3QgYWRkcmVzc1RvQ2hlY2sgPSBhbGxvd05vblByZWZpeGVkXG4gICAgPyBhZGRIZXhQcmVmaXgocG9zc2libGVBZGRyZXNzKVxuICAgIDogcG9zc2libGVBZGRyZXNzO1xuICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3NUb0NoZWNrKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChtaXhlZENhc2VVc2VDaGVja3N1bSkge1xuICAgIGNvbnN0IHByZWZpeFJlbW92ZWQgPSBhZGRyZXNzVG9DaGVjay5zbGljZSgyKTtcbiAgICBjb25zdCBsb3dlciA9IHByZWZpeFJlbW92ZWQudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCB1cHBlciA9IHByZWZpeFJlbW92ZWQudG9VcHBlckNhc2UoKTtcbiAgICBjb25zdCBhbGxPbmVDYXNlID0gcHJlZml4UmVtb3ZlZCA9PT0gbG93ZXIgfHwgcHJlZml4UmVtb3ZlZCA9PT0gdXBwZXI7XG4gICAgaWYgKCFhbGxPbmVDYXNlKSB7XG4gICAgICByZXR1cm4gaXNWYWxpZENoZWNrc3VtQWRkcmVzcyhhZGRyZXNzVG9DaGVjayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzVmFsaWRBZGRyZXNzKGFkZHJlc3NUb0NoZWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpIHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgLy8gb3VyIGludGVybmFsIGNoZWNrc3VtQWRkcmVzcyBmdW5jdGlvbiB0aGF0IHRoaXMgbWV0aG9kIHJlcGxhY2VzIHdvdWxkXG4gICAgLy8gcmV0dXJuIGFuIGVtcHR5IHN0cmluZyBmb3IgbnVsbGlzaCBpbnB1dC4gSWYgYW55IGRpcmVjdCB1c2FnZXMgb2ZcbiAgICAvLyBldGhlcmV1bWpzLXV0aWwudG9DaGVja3N1bUFkZHJlc3Mgd2VyZSBjYWxsZWQgd2l0aCBudWxsaXNoIGlucHV0IGl0XG4gICAgLy8gd291bGQgaGF2ZSByZXN1bHRlZCBpbiBhbiBlcnJvciBvbiB2ZXJzaW9uIDUuMS5cbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgY29uc3QgaGV4UHJlZml4ZWQgPSBhZGRIZXhQcmVmaXgoYWRkcmVzcyk7XG4gIGlmICghaXNIZXhTdHJpbmcoaGV4UHJlZml4ZWQpKSB7XG4gICAgLy8gVmVyc2lvbiA1LjEgb2YgZXRoZXJldW1qcy11dGlscyB3b3VsZCBoYXZlIHJldHVybmVkICcweFknIGZvciBpbnB1dCAneSdcbiAgICAvLyBidXQgd2Ugc2hvdWxkbid0IHdhc3RlIGVmZm9ydCB0cnlpbmcgdG8gY2hhbmdlIGNhc2Ugb24gYSBjbGVhcmx5IGludmFsaWRcbiAgICAvLyBzdHJpbmcuIEluc3RlYWQganVzdCByZXR1cm4gdGhlIGhleCBwcmVmaXhlZCBvcmlnaW5hbCBzdHJpbmcgd2hpY2ggbW9zdFxuICAgIC8vIGNsb3NlbHkgbWltaWNzIHRoZSBvcmlnaW5hbCBiZWhhdmlvci5cbiAgICByZXR1cm4gaGV4UHJlZml4ZWQ7XG4gIH1cbiAgcmV0dXJuIHRvQ2hlY2tzdW1BZGRyZXNzKGhleFByZWZpeGVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KHN0cikge1xuICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIHJldHVybiBpc0hleFByZWZpeGVkKHN0cikgPyBzdHIuc2xpY2UoMikgOiBzdHI7XG59XG4iLCJpbXBvcnQgYnJvd3NlciBmcm9tICd3ZWJleHRlbnNpb24tcG9seWZpbGwnO1xyXG5cclxuZXhwb3J0IGNvbnN0IGlzTWFuaWZlc3RWMyA9XHJcbiAgYnJvd3Nlci5ydW50aW1lLmdldE1hbmlmZXN0KCkubWFuaWZlc3RfdmVyc2lvbiA9PT0gMztcclxuIiwiaW1wb3J0IHsgQ0hBSU5fSURTLCBNQVhfU0FGRV9DSEFJTl9JRCB9IGZyb20gJy4uL2NvbnN0YW50cy9uZXR3b3JrJztcclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbnVtYmVyIHByaW1pdGl2ZSBjaGFpbiBJRCBpcyBzYWZlLlxyXG4gKiBCZWNhdXNlIHNvbWUgY3J5cHRvZ3JhcGhpYyBsaWJyYXJpZXMgd2UgdXNlIGV4cGVjdCB0aGUgY2hhaW4gSUQgdG8gYmUgYVxyXG4gKiBudW1iZXIgcHJpbWl0aXZlLCBpdCBtdXN0IG5vdCBleGNlZWQgYSBjZXJ0YWluIHNpemUuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjaGFpbklkIC0gVGhlIGNoYWluIElEIHRvIGNoZWNrIGZvciBzYWZldHkuXHJcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBnaXZlbiBjaGFpbiBJRCBpcyBzYWZlLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzU2FmZUNoYWluSWQoY2hhaW5JZCkge1xyXG4gIHJldHVybiAoXHJcbiAgICBOdW1iZXIuaXNTYWZlSW50ZWdlcihjaGFpbklkKSAmJiBjaGFpbklkID4gMCAmJiBjaGFpbklkIDw9IE1BWF9TQUZFX0NIQUlOX0lEXHJcbiAgKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIDB4LXByZWZpeGVkLCBub24temVybywgbm9uLXplcm8tcGFkZGVkLFxyXG4gKiBoZXhhZGVjaW1hbCBzdHJpbmcuXHJcbiAqXHJcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBjaGVjay5cclxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIGEgY29ycmVjdGx5IGZvcm1hdHRlZCBoZXggc3RyaW5nLFxyXG4gKiBmYWxzZSBvdGhlcndpc2UuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNQcmVmaXhlZEZvcm1hdHRlZEhleFN0cmluZyh2YWx1ZSkge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG4gIHJldHVybiAvXjB4WzEtOWEtZl0rWzAtOWEtZl0qJC9pdS50ZXN0KHZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRva2VuIGRldGVjdGlvbiBpcyBlbmFibGVkIGZvciBjZXJ0YWluIG5ldHdvcmtzXHJcbiAqXHJcbiAqIEBwYXJhbSBjaGFpbklkIC0gQ2hhaW5JRCBvZiBuZXR3b3JrXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhlIGN1cnJlbnQgbmV0d29yayBzdXBwb3J0cyB0b2tlbiBkZXRlY3Rpb25cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1Rva2VuRGV0ZWN0aW9uRW5hYmxlZEZvck5ldHdvcmsoY2hhaW5JZCkge1xyXG4gIHN3aXRjaCAoY2hhaW5JZCkge1xyXG4gICAgY2FzZSBDSEFJTl9JRFMuTUFJTk5FVDpcclxuICAgIGNhc2UgQ0hBSU5fSURTLkJTQzpcclxuICAgIGNhc2UgQ0hBSU5fSURTLlBPTFlHT046XHJcbiAgICBjYXNlIENIQUlOX0lEUy5BVkFMQU5DSEU6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxufVxyXG4iLCIvKipcclxuICogUmV0dXJuIGEgXCJtYXNrZWRcIiBjb3B5IG9mIHRoZSBnaXZlbiBvYmplY3QuXHJcbiAqXHJcbiAqIFRoZSByZXR1cm5lZCBvYmplY3QgaW5jbHVkZXMgb25seSB0aGUgcHJvcGVydGllcyBwcmVzZW50IGluIHRoZSBtYXNrLiBUaGVcclxuICogbWFzayBpcyBhbiBvYmplY3QgdGhhdCBtaXJyb3JzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIG9iamVjdCwgZXhjZXB0XHJcbiAqIHRoZSBvbmx5IHZhbHVlcyBhcmUgYHRydWVgIG9yIGEgc3ViLW1hc2suIGB0cnVlYCBpbXBsaWVzIHRoZSBwcm9wZXJ0eVxyXG4gKiBzaG91bGQgYmUgaW5jbHVkZWQsIGFuZCBhIHN1Yi1tYXNrIGltcGxpZXMgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBmdXJ0aGVyXHJcbiAqIG1hc2tlZCBhY2NvcmRpbmcgdG8gdGhhdCBzdWItbWFzay5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCAtIFRoZSBvYmplY3QgdG8gbWFza1xyXG4gKiBAcGFyYW0ge09iamVjdDxvYmplY3QgfCBib29sZWFuPn0gbWFzayAtIFRoZSBtYXNrIHRvIGFwcGx5IHRvIHRoZSBvYmplY3RcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXNrT2JqZWN0KG9iamVjdCwgbWFzaykge1xyXG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmplY3QpLnJlZHVjZSgoc3RhdGUsIGtleSkgPT4ge1xyXG4gICAgaWYgKG1hc2tba2V5XSA9PT0gdHJ1ZSkge1xyXG4gICAgICBzdGF0ZVtrZXldID0gb2JqZWN0W2tleV07XHJcbiAgICB9IGVsc2UgaWYgKG1hc2tba2V5XSkge1xyXG4gICAgICBzdGF0ZVtrZXldID0gbWFza09iamVjdChvYmplY3Rba2V5XSwgbWFza1trZXldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdGF0ZTtcclxuICB9LCB7fSk7XHJcbn1cclxuIiwiY29uc3QgTUFYID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcblxyXG5sZXQgaWRDb3VudGVyID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogTUFYKTtcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUmFuZG9tSWQoKSB7XHJcbiAgaWRDb3VudGVyICU9IE1BWDtcclxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGx1c3BsdXNcclxuICByZXR1cm4gaWRDb3VudGVyKys7XHJcbn1cclxuIiwiaW1wb3J0IGdldEZldGNoV2l0aFRpbWVvdXQgZnJvbSAnLi9mZXRjaC13aXRoLXRpbWVvdXQnO1xyXG5cclxuY29uc3QgZmV0Y2hXaXRoVGltZW91dCA9IGdldEZldGNoV2l0aFRpbWVvdXQoKTtcclxuXHJcbi8qKlxyXG4gKiBNYWtlcyBhIEpTT04gUlBDIHJlcXVlc3QgdG8gdGhlIGdpdmVuIFVSTCwgd2l0aCB0aGUgZ2l2ZW4gUlBDIG1ldGhvZCBhbmQgcGFyYW1zLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcnBjVXJsIC0gVGhlIFJQQyBlbmRwb2ludCBVUkwgdG8gdGFyZ2V0LlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gcnBjTWV0aG9kIC0gVGhlIFJQQyBtZXRob2QgdG8gcmVxdWVzdC5cclxuICogQHBhcmFtIHtBcnJheTx1bmtub3duPn0gW3JwY1BhcmFtc10gLSBUaGUgUlBDIG1ldGhvZCBwYXJhbXMuXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlPHVua25vd258dW5kZWZpbmVkPn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBSUEMgbWV0aG9kIGNhbGwsXHJcbiAqIG9yIHRocm93cyBhbiBlcnJvciBpbiBjYXNlIG9mIGZhaWx1cmUuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24ganNvblJwY1JlcXVlc3QocnBjVXJsLCBycGNNZXRob2QsIHJwY1BhcmFtcyA9IFtdKSB7XHJcbiAgbGV0IGZldGNoVXJsID0gcnBjVXJsO1xyXG4gIGNvbnN0IGhlYWRlcnMgPSB7XHJcbiAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG4gIH07XHJcbiAgLy8gQ29udmVydCBiYXNpYyBhdXRoIFVSTCBjb21wb25lbnQgdG8gQXV0aG9yaXphdGlvbiBoZWFkZXJcclxuICBjb25zdCB7IG9yaWdpbiwgcGF0aG5hbWUsIHVzZXJuYW1lLCBwYXNzd29yZCwgc2VhcmNoIH0gPSBuZXcgVVJMKHJwY1VybCk7XHJcbiAgLy8gVVJMcyBjb250YWluaW5nIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBuZWVkcyBzcGVjaWFsIHByb2Nlc3NpbmdcclxuICBpZiAodXNlcm5hbWUgJiYgcGFzc3dvcmQpIHtcclxuICAgIGNvbnN0IGVuY29kZWRBdXRoID0gQnVmZmVyLmZyb20oYCR7dXNlcm5hbWV9OiR7cGFzc3dvcmR9YCkudG9TdHJpbmcoXHJcbiAgICAgICdiYXNlNjQnLFxyXG4gICAgKTtcclxuICAgIGhlYWRlcnMuQXV0aG9yaXphdGlvbiA9IGBCYXNpYyAke2VuY29kZWRBdXRofWA7XHJcbiAgICBmZXRjaFVybCA9IGAke29yaWdpbn0ke3BhdGhuYW1lfSR7c2VhcmNofWA7XHJcbiAgfVxyXG4gIGNvbnN0IGpzb25ScGNSZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoZmV0Y2hVcmwsIHtcclxuICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xyXG4gICAgICBpZDogRGF0ZS5ub3coKS50b1N0cmluZygpLFxyXG4gICAgICBqc29ucnBjOiAnMi4wJyxcclxuICAgICAgbWV0aG9kOiBycGNNZXRob2QsXHJcbiAgICAgIHBhcmFtczogcnBjUGFyYW1zLFxyXG4gICAgfSksXHJcbiAgICBoZWFkZXJzLFxyXG4gICAgY2FjaGU6ICdkZWZhdWx0JyxcclxuICB9KS50aGVuKChodHRwUmVzcG9uc2UpID0+IGh0dHBSZXNwb25zZS5qc29uKCkpO1xyXG5cclxuICBpZiAoXHJcbiAgICAhanNvblJwY1Jlc3BvbnNlIHx8XHJcbiAgICBBcnJheS5pc0FycmF5KGpzb25ScGNSZXNwb25zZSkgfHxcclxuICAgIHR5cGVvZiBqc29uUnBjUmVzcG9uc2UgIT09ICdvYmplY3QnXHJcbiAgKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJQQyBlbmRwb2ludCAke3JwY1VybH0gcmV0dXJuZWQgbm9uLW9iamVjdCByZXNwb25zZS5gKTtcclxuICB9XHJcbiAgY29uc3QgeyBlcnJvciwgcmVzdWx0IH0gPSBqc29uUnBjUmVzcG9uc2U7XHJcblxyXG4gIGlmIChlcnJvcikge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKGVycm9yPy5tZXNzYWdlIHx8IGVycm9yKTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4iLCJpbXBvcnQgeyBQYXJzZWRNZXNzYWdlIH0gZnJvbSAnQHNwcnVjZWlkL3Npd2UtcGFyc2VyJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHsgc3RyaXBIZXhQcmVmaXggfSBmcm9tICcuL2hleHN0cmluZy11dGlscyc7XG5cbmNvbnN0IG1zZ0hleFRvVGV4dCA9IChoZXgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGhleCk7XG4gICAgY29uc3QgYnVmZiA9IEJ1ZmZlci5mcm9tKHN0cmlwcGVkLCAnaGV4Jyk7XG4gICAgcmV0dXJuIGJ1ZmYubGVuZ3RoID09PSAzMiA/IGhleCA6IGJ1ZmYudG9TdHJpbmcoJ3V0ZjgnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGxvZy5lcnJvcihlKTtcbiAgICByZXR1cm4gaGV4O1xuICB9XG59O1xuXG4vKipcbiAqIEEgbG9jYWxseSBkZWZpbmVkIG9iamVjdCB1c2VkIHRvIHByb3ZpZGUgZGF0YSB0byBpZGVudGlmeSBhIFNpZ24tSW4gV2l0aCBFdGhlcmV1bSAoU0lXRSkoRUlQLTQzNjEpIG1lc3NhZ2UgYW5kIHByb3ZpZGUgdGhlIHBhcnNlZCBtZXNzYWdlXG4gKlxuICogQHR5cGVkZWYgbG9jYWxTSVdFT2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU0lXRU1lc3NhZ2UgLSBEb2VzIHRoZSBpbnRlcmNlcHRlZCBtZXNzYWdlIGNvbmZvcm0gdG8gdGhlIFNJV0Ugc3BlY2lmaWNhdGlvbj9cbiAqIEBwYXJhbSB7UGFyc2VkTWVzc2FnZX0gcGFyc2VkTWVzc2FnZSAtIFRoZSBkYXRhIHBhcnNlZCBvdXQgb2YgdGhlIG1lc3NhZ2VcbiAqL1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaW50ZXJjZXB0cyBhIHNpZ24gbWVzc2FnZSwgZGV0ZWN0cyBpZiBpdCdzIGFcbiAqIFNpZ24tSW4gV2l0aCBFdGhlcmV1bSAoU0lXRSkoRUlQLTQzNjEpIG1lc3NhZ2UsIGFuZCByZXR1cm5zIGFuIG9iamVjdCB3aXRoXG4gKiByZWxldmFudCBTSVdFIGRhdGEuXG4gKlxuICoge0BzZWUge0BsaW5rIGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNDM2MX19XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG1zZ1BhcmFtcyAtIFRoZSBwYXJhbXMgb2YgdGhlIG1lc3NhZ2UgdG8gc2lnblxuICogQHJldHVybnMge2xvY2FsU0lXRU9iamVjdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRldGVjdFNJV0UgPSAobXNnUGFyYW1zKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBkYXRhIH0gPSBtc2dQYXJhbXM7XG4gICAgY29uc3QgbWVzc2FnZSA9IG1zZ0hleFRvVGV4dChkYXRhKTtcbiAgICBjb25zdCBwYXJzZWRNZXNzYWdlID0gbmV3IFBhcnNlZE1lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaXNTSVdFTWVzc2FnZTogdHJ1ZSxcbiAgICAgIHBhcnNlZE1lc3NhZ2UsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBpZ25vcmUgZXJyb3IsIGl0J3Mgbm90IGEgdmFsaWQgU0lXRSBtZXNzYWdlXG4gICAgcmV0dXJuIHtcbiAgICAgIGlzU0lXRU1lc3NhZ2U6IGZhbHNlLFxuICAgICAgcGFyc2VkTWVzc2FnZTogbnVsbCxcbiAgICB9O1xuICB9XG59O1xuXG4vKipcbiAqIFRha2VzIGluIGEgcGFyc2VkIFNpZ24tSW4gd2l0aCBFdGhlcmV1bSBNZXNzYWdlIChFSVAtNDM2MSlcbiAqIGFuZCBnZW5lcmF0ZXMgYW4gYXJyYXkgb2YgbGFiZWwtdmFsdWUgcGFpcnNcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyc2VkTWVzc2FnZSAtIEEgcGFyc2VkIFNJV0UgbWVzc2FnZSB3aXRoIG1lc3NhZ2UgY29udGVudHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHQgLSBpMThuIGZ1bmN0aW9uXG4gKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGxhYmVsLXZhbHVlIHBhaXJzIHdpdGggdGhlIHR5cGUgb2YgdGhlIHZhbHVlIGFzIHRoZSBsYWJlbFxuICovXG5leHBvcnQgY29uc3QgZm9ybWF0TWVzc2FnZVBhcmFtcyA9IChwYXJzZWRNZXNzYWdlLCB0KSA9PiB7XG4gIGNvbnN0IG91dHB1dCA9IFtdO1xuXG4gIGNvbnN0IHtcbiAgICBzdGF0ZW1lbnQsXG4gICAgdXJpLFxuICAgIHZlcnNpb24sXG4gICAgY2hhaW5JZCxcbiAgICBub25jZSxcbiAgICBpc3N1ZWRBdCxcbiAgICBleHBpcmF0aW9uVGltZSxcbiAgICBub3RCZWZvcmUsXG4gICAgcmVxdWVzdElkLFxuICAgIHJlc291cmNlcyxcbiAgfSA9IHBhcnNlZE1lc3NhZ2U7XG5cbiAgaWYgKHN0YXRlbWVudCkge1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIGxhYmVsOiB0KCdTSVdFTGFiZWxNZXNzYWdlJyksXG4gICAgICB2YWx1ZTogc3RhdGVtZW50LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIGxhYmVsOiB0KCdTSVdFTGFiZWxVUkknKSxcbiAgICAgIHZhbHVlOiB1cmksXG4gICAgfSk7XG4gIH1cblxuICBpZiAodmVyc2lvbikge1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIGxhYmVsOiB0KCdTSVdFTGFiZWxWZXJzaW9uJyksXG4gICAgICB2YWx1ZTogdmVyc2lvbixcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChjaGFpbklkKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbENoYWluSUQnKSxcbiAgICAgIHZhbHVlOiBjaGFpbklkLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG5vbmNlKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbE5vbmNlJyksXG4gICAgICB2YWx1ZTogbm9uY2UsXG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNzdWVkQXQpIHtcbiAgICBvdXRwdXQucHVzaCh7XG4gICAgICBsYWJlbDogdCgnU0lXRUxhYmVsSXNzdWVkQXQnKSxcbiAgICAgIHZhbHVlOiBpc3N1ZWRBdCxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChleHBpcmF0aW9uVGltZSkge1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIGxhYmVsOiB0KCdTSVdFTGFiZWxFeHBpcmF0aW9uVGltZScpLFxuICAgICAgdmFsdWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKG5vdEJlZm9yZSkge1xuICAgIG91dHB1dC5wdXNoKHtcbiAgICAgIGxhYmVsOiB0KCdTSVdFTGFiZWxOb3RCZWZvcmUnKSxcbiAgICAgIHZhbHVlOiBub3RCZWZvcmUsXG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVxdWVzdElkKSB7XG4gICAgb3V0cHV0LnB1c2goe1xuICAgICAgbGFiZWw6IHQoJ1NJV0VMYWJlbFJlcXVlc3RJRCcpLFxuICAgICAgdmFsdWU6IHJlcXVlc3RJZCxcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChyZXNvdXJjZXMgJiYgcmVzb3VyY2VzLmxlbmd0aCA+IDApIHtcbiAgICBvdXRwdXQucHVzaCh7XG4gICAgICBsYWJlbDogdCgnU0lXRUxhYmVsUmVzb3VyY2VzJywgW3Jlc291cmNlcy5sZW5ndGhdKSxcbiAgICAgIHZhbHVlOiByZXNvdXJjZXNcbiAgICAgICAgLnJlZHVjZSgocHJldmlvdXMsIHJlc291cmNlKSA9PiBgJHtwcmV2aW91c30ke3Jlc291cmNlfVxcbmAsICcnKVxuICAgICAgICAudHJpbSgpLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn07XG4iLCJleHBvcnQgZnVuY3Rpb24gaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSh2YWx1ZTEsIHZhbHVlMikge1xyXG4gIGlmICh0eXBlb2YgdmFsdWUxICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUyICE9PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWUxLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlMi50b0xvd2VyQ2FzZSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcHJlcGVuZFplcm8obnVtLCBtYXhMZW5ndGgpIHtcclxuICByZXR1cm4gbnVtLnRvU3RyaW5nKCkucGFkU3RhcnQobWF4TGVuZ3RoLCAnMCcpO1xyXG59XHJcbiIsImltcG9ydCB7IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVAgfSBmcm9tICcuLi9jb25zdGFudHMvc3dhcHMnO1xyXG5cclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBwcm92aWRlZCBhZGRyZXNzIGlzIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBhZGRyZXNzIGZvclxyXG4gKiB0aGUgZGVmYXVsdCBzd2FwcyB0b2tlbiBvZiB0aGUgcHJvdmlkZWQgY2hhaW4uXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIHN0cmluZyB0byBjb21wYXJlIHRvIHRoZSBkZWZhdWx0IHRva2VuIGFkZHJlc3NcclxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBUaGUgaGV4IGVuY29kZWQgY2hhaW4gSUQgb2YgdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gdG8gY2hlY2tcclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGFkZHJlc3MgaXMgdGhlIHByb3ZpZGVkIGNoYWluJ3MgZGVmYXVsdCB0b2tlbiBhZGRyZXNzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTd2Fwc0RlZmF1bHRUb2tlbkFkZHJlc3MoYWRkcmVzcywgY2hhaW5JZCkge1xyXG4gIGlmICghYWRkcmVzcyB8fCAhY2hhaW5JZCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGFkZHJlc3MgPT09IFNXQVBTX0NIQUlOSURfREVGQVVMVF9UT0tFTl9NQVBbY2hhaW5JZF0/LmFkZHJlc3M7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgcHJvdmlkZWQgc3ltYm9sIGlzIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBzeW1ib2wgZm9yXHJcbiAqIHRoZSBkZWZhdWx0IHN3YXBzIHRva2VuIG9mIHRoZSBwcm92aWRlZCBjaGFpbi5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHN5bWJvbCAtIFRoZSBzdHJpbmcgdG8gY29tcGFyZSB0byB0aGUgZGVmYXVsdCB0b2tlbiBzeW1ib2xcclxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBUaGUgaGV4IGVuY29kZWQgY2hhaW4gSUQgb2YgdGhlIGRlZmF1bHQgc3dhcHMgdG9rZW4gdG8gY2hlY2tcclxuICogQHJldHVybnMge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHN5bWJsIGlzIHRoZSBwcm92aWRlZCBjaGFpbidzIGRlZmF1bHQgdG9rZW4gc3ltYm9sXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNTd2Fwc0RlZmF1bHRUb2tlblN5bWJvbChzeW1ib2wsIGNoYWluSWQpIHtcclxuICBpZiAoIXN5bWJvbCB8fCAhY2hhaW5JZCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHN5bWJvbCA9PT0gU1dBUFNfQ0hBSU5JRF9ERUZBVUxUX1RPS0VOX01BUFtjaGFpbklkXT8uc3ltYm9sO1xyXG59XHJcbiIsImltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5pbXBvcnQgeyBhYmlFUkM3MjEsIGFiaUVSQzIwLCBhYmlFUkMxMTU1IH0gZnJvbSAnQG1ldGFtYXNrL21ldGFtYXNrLWV0aC1hYmlzJztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHtcbiAgQVNTRVRfVFlQRVMsXG4gIFRPS0VOX1NUQU5EQVJEUyxcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG59IGZyb20gJy4uL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyByZWFkQWRkcmVzc0FzQ29udHJhY3QgfSBmcm9tICcuL2NvbnRyYWN0LXV0aWxzJztcbmltcG9ydCB7IGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUgfSBmcm9tICcuL3N0cmluZy11dGlscyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyAndHJhbnNmZXInIHwgJ2FwcHJvdmUnIHwgJ3NldGFwcHJvdmFsZm9yYWxsJyB8ICd0cmFuc2ZlcmZyb20nIHwgJ2NvbnRyYWN0SW50ZXJhY3Rpb24nfCAnc2ltcGxlU2VuZCcgfSBJbmZlcnJhYmxlVHJhbnNhY3Rpb25UeXBlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gSW5mZXJUcmFuc2FjdGlvblR5cGVSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7SW5mZXJyYWJsZVRyYW5zYWN0aW9uVHlwZXN9IHR5cGUgLSBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdldENvZGVSZXNwb25zZSAtIFRoZSBjb250cmFjdCBjb2RlLCBpbiBoZXggZm9ybWF0IGlmXG4gKiAgaXQgZXhpc3RzLiAnMHgwJyBvciAnMHgnIGFyZSBhbHNvIGluZGljYXRvcnMgb2Ygbm9uLWV4aXN0ZW50IGNvbnRyYWN0XG4gKiAgY29kZVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYgRXRoZXJzQ29udHJhY3RDYWxsXG4gKiBAdHlwZSBvYmplY3RcbiAqIEBwcm9wZXJ0eSB7YW55W119IGFyZ3MgLSBUaGUgYXJncy9wYXJhbXMgdG8gdGhlIGZ1bmN0aW9uIGNhbGwuXG4gKiBBbiBhcnJheS1saWtlIG9iamVjdCB3aXRoIG51bWVyaWNhbCBhbmQgc3RyaW5nIGluZGljZXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzaWduYXR1cmUgLSBUaGUgZnVuY3Rpb24gc2lnbmF0dXJlLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ2hhc2ggLSBUaGUgZnVuY3Rpb24gc2lnbmF0dXJlIGhhc2guXG4gKiBAcHJvcGVydHkge0V0aGVyc0JpZ051bWJlcn0gdmFsdWUgLSBUaGUgRVRIIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2FsbC5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb25GcmFnbWVudH0gZnVuY3Rpb25GcmFnbWVudCAtIFRoZSBFdGhlcnMgZnVuY3Rpb24gZnJhZ21lbnRcbiAqIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBmdW5jdGlvbi5cbiAqL1xuXG5jb25zdCBlcmMyMEludGVyZmFjZSA9IG5ldyBldGhlcnMudXRpbHMuSW50ZXJmYWNlKGFiaUVSQzIwKTtcbmNvbnN0IGVyYzcyMUludGVyZmFjZSA9IG5ldyBldGhlcnMudXRpbHMuSW50ZXJmYWNlKGFiaUVSQzcyMSk7XG5jb25zdCBlcmMxMTU1SW50ZXJmYWNlID0gbmV3IGV0aGVycy51dGlscy5JbnRlcmZhY2UoYWJpRVJDMTE1NSk7XG5cbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2FjdGlvbk1hdGNoZXNOZXR3b3JrKHRyYW5zYWN0aW9uLCBjaGFpbklkLCBuZXR3b3JrSWQpIHtcbiAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbi5jaGFpbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5jaGFpbklkID09PSBjaGFpbklkO1xuICB9XG4gIHJldHVybiB0cmFuc2FjdGlvbi5tZXRhbWFza05ldHdvcmtJZCA9PT0gbmV0d29ya0lkO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIG1heEZlZVBlckdhcyBhbmQgbWF4UHJpb3JpdHlGZWVQZXJHYXMgZmllbGRzIGFyZSBzdXBwbGllZFxuICogYW5kIHZhbGlkIGlucHV0cy4gVGhpcyB3aWxsIHJldHVybiBmYWxzZSBmb3Igbm9uIGhleCBzdHJpbmcgaW5wdXRzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdHJhbnNhY3Rpb24gdXNlcyB2YWxpZCBFSVAxNTU5IGZpZWxkc1xuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFSVAxNTU5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIChcbiAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbj8udHhQYXJhbXM/Lm1heEZlZVBlckdhcykgJiZcbiAgICBpc0hleFN0cmluZyh0cmFuc2FjdGlvbj8udHhQYXJhbXM/Lm1heFByaW9yaXR5RmVlUGVyR2FzKVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB0aGUgbWF4RmVlUGVyR2FzIGFuZCBtYXhQcmlvcml0eUZlZVBlckdhcyBmaWVsZHMgYXJlIG5vdFxuICogc3VwcGxpZWQgYW5kIHRoYXQgdGhlIGdhc1ByaWNlIGZpZWxkIGlzIHZhbGlkIGlmIGl0IGlzIHByb3ZpZGVkLiBUaGlzIHdpbGxcbiAqIHJldHVybiBmYWxzZSBpZiBnYXNQcmljZSBpcyBhIG5vbiBoZXggc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KFwiLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uXCIpLlRyYW5zYWN0aW9uTWV0YX0gdHJhbnNhY3Rpb24gLVxuICogIHRoZSB0cmFuc2FjdGlvbiB0byBjaGVja1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdHJhbnNhY3Rpb24gdXNlcyB2YWxpZCBMZWdhY3kgZmllbGRzIE9SIGxhY2tzXG4gKiAgRUlQMTU1OSBmaWVsZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGVnYWN5VHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdHJhbnNhY3Rpb24udHhQYXJhbXMubWF4RmVlUGVyR2FzID09PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB0cmFuc2FjdGlvbi50eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAodHlwZW9mIHRyYW5zYWN0aW9uLnR4UGFyYW1zLmdhc1ByaWNlID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgaXNIZXhTdHJpbmcodHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzUHJpY2UpKVxuICApO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHRyYW5zYWN0aW9ucyBnYXMgZmVlcyBpbiB0eFBhcmFtcyBtYXRjaCB0aG9zZSBpbiBpdHMgZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgcHJvcGVydHlcbiAqXG4gKiBAcGFyYW0ge2ltcG9ydChcIi4uL2NvbnN0YW50cy90cmFuc2FjdGlvblwiKS5UcmFuc2FjdGlvbk1ldGF9IHRyYW5zYWN0aW9uIC1cbiAqICB0aGUgdHJhbnNhY3Rpb24gdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGJvdGggdGhlIHR4UGFyYW1zIGFuZCBkYXBwU3VnZ2VzdGVkR2FzRmVlcyBhcmUgb2JqZWN0cyB3aXRoIHRydXRoeSBnYXMgZmVlIHByb3BlcnRpZXMsXG4gKiAgIGFuZCB0aG9zZSBwcm9wZXJ0aWVzIGFyZSBzdHJpY3RseSBlcXVhbFxuICovXG5leHBvcnQgZnVuY3Rpb24gdHhQYXJhbXNBcmVEYXBwU3VnZ2VzdGVkKHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHsgZ2FzUHJpY2UsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBtYXhGZWVQZXJHYXMgfSA9XG4gICAgdHJhbnNhY3Rpb24/LnR4UGFyYW1zIHx8IHt9O1xuICByZXR1cm4gKFxuICAgIChnYXNQcmljZSAmJiBnYXNQcmljZSA9PT0gdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5nYXNQcmljZSkgfHxcbiAgICAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgIG1heEZlZVBlckdhcyAmJlxuICAgICAgdHJhbnNhY3Rpb24/LmRhcHBTdWdnZXN0ZWRHYXNGZWVzPy5tYXhQcmlvcml0eUZlZVBlckdhcyA9PT1cbiAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgIHRyYW5zYWN0aW9uPy5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8ubWF4RmVlUGVyR2FzID09PSBtYXhGZWVQZXJHYXMpXG4gICk7XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGVjb2RlIHRyYW5zYWN0aW9uIGRhdGEgdXNpbmcgQUJJcyBmb3IgdGhyZWUgZGlmZmVyZW50IHRva2VuIHN0YW5kYXJkczogRVJDMjAsIEVSQzcyMSwgRVJDMTE1NS5cbiAqIFRoZSBkYXRhIHdpbGwgZGVjb2RlIGNvcnJlY3RseSBpZiB0aGUgdHJhbnNhY3Rpb24gaXMgYW4gaW50ZXJhY3Rpb24gd2l0aCBhIGNvbnRyYWN0IHRoYXQgbWF0Y2hlcyBvbmUgb2YgdGhlc2VcbiAqIGNvbnRyYWN0IHN0YW5kYXJkc1xuICpcbiAqIEBwYXJhbSBkYXRhIC0gZW5jb2RlZCB0cmFuc2FjdGlvbiBkYXRhXG4gKiBAcmV0dXJucyB7RXRoZXJzQ29udHJhY3RDYWxsIHwgdW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdGFuZGFyZFRva2VuVHJhbnNhY3Rpb25EYXRhKGRhdGEpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZXJjMjBJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBhbmQgbmV4dCB0cnkgdG8gcGFyc2Ugd2l0aCBlcmM3MjEgQUJJXG4gIH1cblxuICB0cnkge1xuICAgIHJldHVybiBlcmM3MjFJbnRlcmZhY2UucGFyc2VUcmFuc2FjdGlvbih7IGRhdGEgfSk7XG4gIH0gY2F0Y2gge1xuICAgIC8vIGlnbm9yZSBhbmQgbmV4dCB0cnkgdG8gcGFyc2Ugd2l0aCBlcmMxMTU1IEFCSVxuICB9XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXJjMTE1NUludGVyZmFjZS5wYXJzZVRyYW5zYWN0aW9uKHsgZGF0YSB9KTtcbiAgfSBjYXRjaCB7XG4gICAgLy8gaWdub3JlIGFuZCByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIGNvbnRyYWN0Q29kZSBvZiB0aGUgdHJhbnNhY3Rpb24gYnkgYW5hbHl6aW5nIHRoZSB0eFBhcmFtcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHhQYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uQ29udHJhY3RDb2RlKHR4UGFyYW1zLCBxdWVyeSkge1xuICBjb25zdCB7IHRvIH0gPSB0eFBhcmFtcztcbiAgY29uc3QgeyBjb250cmFjdENvZGUgfSA9IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChxdWVyeSwgdG8pO1xuICByZXR1cm4gY29udHJhY3RDb2RlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgdGhlIHR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uIGJ5IGFuYWx5emluZyB0aGUgdHhQYXJhbXMuXG4gKiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBvbmUgb2YgdGhlIHR5cGVzIGRlZmluZWQgaW4gc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbnNcbiAqIEl0IHdpbGwgbmV2ZXIgcmV0dXJuIFRSQU5TQUNUSU9OX1RZUEVfQ0FOQ0VMIG9yIFRSQU5TQUNUSU9OX1RZUEVfUkVUUlkgYXMgdGhlc2VcbiAqIHJlcHJlc2VudCBzcGVjaWZpYyBldmVudHMgdGhhdCB3ZSBjb250cm9sIGZyb20gdGhlIGV4dGVuc2lvbiBhbmQgYXJlIGFkZGVkIG1hbnVhbGx5XG4gKiBhdCB0cmFuc2FjdGlvbiBjcmVhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHhQYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RXRoUXVlcnl9IHF1ZXJ5IC0gRXRoUXVlcnkgaW5zdGFuY2VcbiAqIEByZXR1cm5zIHtJbmZlclRyYW5zYWN0aW9uVHlwZVJlc3VsdH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRldGVybWluZVRyYW5zYWN0aW9uVHlwZSh0eFBhcmFtcywgcXVlcnkpIHtcbiAgY29uc3QgeyBkYXRhLCB0byB9ID0gdHhQYXJhbXM7XG4gIGxldCBuYW1lO1xuICB0cnkge1xuICAgICh7IG5hbWUgfSA9IGRhdGEgJiYgcGFyc2VTdGFuZGFyZFRva2VuVHJhbnNhY3Rpb25EYXRhKGRhdGEpKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cuZGVidWcoJ0ZhaWxlZCB0byBwYXJzZSB0cmFuc2FjdGlvbiBkYXRhLicsIGVycm9yLCBkYXRhKTtcbiAgfVxuXG4gIGxldCByZXN1bHQ7XG4gIGxldCBjb250cmFjdENvZGU7XG5cbiAgaWYgKGRhdGEgJiYgIXRvKSB7XG4gICAgcmVzdWx0ID0gVFJBTlNBQ1RJT05fVFlQRVMuREVQTE9ZX0NPTlRSQUNUO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHsgY29udHJhY3RDb2RlOiByZXN1bHRDb2RlLCBpc0NvbnRyYWN0QWRkcmVzcyB9ID1cbiAgICAgIGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChxdWVyeSwgdG8pO1xuXG4gICAgY29udHJhY3RDb2RlID0gcmVzdWx0Q29kZTtcblxuICAgIGlmIChpc0NvbnRyYWN0QWRkcmVzcykge1xuICAgICAgY29uc3QgdG9rZW5NZXRob2ROYW1lID0gW1xuICAgICAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfQVBQUk9WRSxcbiAgICAgICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1NFVF9BUFBST1ZBTF9GT1JfQUxMLFxuICAgICAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVIsXG4gICAgICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUl9GUk9NLFxuICAgICAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NLFxuICAgICAgXS5maW5kKChtZXRob2ROYW1lKSA9PiBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKG1ldGhvZE5hbWUsIG5hbWUpKTtcblxuICAgICAgcmVzdWx0ID1cbiAgICAgICAgZGF0YSAmJiB0b2tlbk1ldGhvZE5hbWVcbiAgICAgICAgICA/IHRva2VuTWV0aG9kTmFtZVxuICAgICAgICAgIDogVFJBTlNBQ1RJT05fVFlQRVMuQ09OVFJBQ1RfSU5URVJBQ1RJT047XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFRSQU5TQUNUSU9OX1RZUEVTLlNJTVBMRV9TRU5EO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHJlc3VsdCwgZ2V0Q29kZVJlc3BvbnNlOiBjb250cmFjdENvZGUgfTtcbn1cblxuY29uc3QgSU5GRVJSQUJMRV9UUkFOU0FDVElPTl9UWVBFUyA9IFtcbiAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX0FQUFJPVkUsXG4gIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTCxcbiAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSLFxuICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSxcbiAgVFJBTlNBQ1RJT05fVFlQRVMuQ09OVFJBQ1RfSU5URVJBQ1RJT04sXG4gIFRSQU5TQUNUSU9OX1RZUEVTLlNJTVBMRV9TRU5ELFxuXTtcblxuLyoqXG4gKiBHaXZlbiBhIHRyYW5zYWN0aW9uIG1ldGEgb2JqZWN0LCBkZXRlcm1pbmUgdGhlIGFzc2V0IHR5cGUgdGhhdCB0aGVcbiAqIHRyYW5zYWN0aW9uIGlzIGRlYWxpbmcgd2l0aCwgYXMgd2VsbCBhcyB0aGUgc3RhbmRhcmQgZm9yIHRoZSB0b2tlbiBpZiBpdFxuICogaXMgYSB0b2tlbiB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuVHJhbnNhY3Rpb25NZXRhfSB0eE1ldGEgLVxuICogIHRyYW5zYWN0aW9uIG1ldGEgb2JqZWN0XG4gKiBAcGFyYW0ge0V0aFF1ZXJ5fSBxdWVyeSAtIEV0aFF1ZXJ5IGluc3RhbmNlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyAtIGZ1bmN0aW9uIHRvIGdldCB0b2tlblxuICogIHN0YW5kYXJkcyBhbmQgZGV0YWlscy5cbiAqIEByZXR1cm5zIHt7IGFzc2V0VHlwZTogc3RyaW5nLCB0b2tlblN0YW5kYXJkOiBzdHJpbmd9fVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZXJtaW5lVHJhbnNhY3Rpb25Bc3NldFR5cGUoXG4gIHR4TWV0YSxcbiAgcXVlcnksXG4gIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzLFxuKSB7XG4gIC8vIElmIHRoZSB0cmFuc2FjdGlvbiB0eXBlIGlzIGFscmVhZHkgb25lIG9mIHRoZSBpbmZlcnJhYmxlIHR5cGVzLCB0aGVuIHdlIGRvXG4gIC8vIG5vdCBuZWVkIHRvIHJlLWVzdGFibGlzaCB0aGUgdHlwZS5cbiAgbGV0IGluZmVycmFibGVUeXBlID0gdHhNZXRhLnR5cGU7XG4gIGlmIChJTkZFUlJBQkxFX1RSQU5TQUNUSU9OX1RZUEVTLmluY2x1ZGVzKHR4TWV0YS50eXBlKSA9PT0gZmFsc2UpIHtcbiAgICAvLyBCZWNhdXNlIHdlIHdpbGwgZGVhbCB3aXRoIGFsbCB0eXBlcyBvZiB0cmFuc2FjdGlvbnMgKGluY2x1ZGluZyBzd2FwcylcbiAgICAvLyB3ZSB3YW50IHRvIGdldCBhbiBpbmZlcnJhYmxlIHR5cGUgb2YgdHJhbnNhY3Rpb24gdGhhdCBpc24ndCBzcGVjaWFsIGNhc2VkXG4gICAgLy8gdGhhdCB3YXkgd2UgY2FuIG5hcnJvdyB0aGUgbnVtYmVyIG9mIGxvZ2ljIGdhdGVzIHJlcXVpcmVkLlxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRldGVybWluZVRyYW5zYWN0aW9uVHlwZSh0eE1ldGEudHhQYXJhbXMsIHF1ZXJ5KTtcbiAgICBpbmZlcnJhYmxlVHlwZSA9IHJlc3VsdC50eXBlO1xuICB9XG5cbiAgLy8gSWYgdGhlIGluZmVycmVkIHR5cGUgb2YgdGhlIHRyYW5zYWN0aW9uIGlzIG9uZSBvZiB0aG9zZSB0aGF0IGFyZSBwYXJ0IG9mXG4gIC8vIHRoZSB0b2tlbiBjb250cmFjdCBzdGFuZGFyZHMsIHdlIGNhbiB1c2UgdGhlIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzXG4gIC8vIG1ldGhvZCB0byBnZXQgdGhlIGFzc2V0IHR5cGUuXG4gIGNvbnN0IGlzVG9rZW5NZXRob2QgPSBbXG4gICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX0FQUFJPVkUsXG4gICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1NFVF9BUFBST1ZBTF9GT1JfQUxMLFxuICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUixcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSxcbiAgXS5maW5kKChtZXRob2ROYW1lKSA9PiBtZXRob2ROYW1lID09PSBpbmZlcnJhYmxlVHlwZSk7XG5cbiAgaWYgKFxuICAgIGlzVG9rZW5NZXRob2QgfHxcbiAgICAvLyBXZSBjYW4gYWxzbyBjaGVjayBhbnkgY29udHJhY3QgaW50ZXJhY3Rpb24gdHlwZSB0byBzZWUgaWYgdGhlIHRvIGFkZHJlc3NcbiAgICAvLyBpcyBhIHRva2VuIGNvbnRyYWN0LiBJZiBpdCBpc24ndCwgdGhlbiB0aGUgbWV0aG9kIHdpbGwgdGhyb3cgYW5kIHdlIGNhblxuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgb3RoZXIgY2hlY2tzLlxuICAgIGluZmVycmFibGVUeXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5DT05UUkFDVF9JTlRFUkFDVElPTlxuICApIHtcbiAgICB0cnkge1xuICAgICAgLy8gV2UgZG9uJ3QgbmVlZCBhIGJhbGFuY2UgY2hlY2ssIHNvIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvXG4gICAgICAvLyBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyBpcyBvbWl0dGVkLlxuICAgICAgY29uc3QgZGV0YWlscyA9IGF3YWl0IGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKHR4TWV0YS50eFBhcmFtcy50byk7XG4gICAgICBpZiAoZGV0YWlscy5zdGFuZGFyZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGFzc2V0VHlwZTpcbiAgICAgICAgICAgIGRldGFpbHMuc3RhbmRhcmQgPT09IFRPS0VOX1NUQU5EQVJEUy5FUkMyMFxuICAgICAgICAgICAgICA/IEFTU0VUX1RZUEVTLlRPS0VOXG4gICAgICAgICAgICAgIDogQVNTRVRfVFlQRVMuQ09MTEVDVElCTEUsXG4gICAgICAgICAgdG9rZW5TdGFuZGFyZDogZGV0YWlscy5zdGFuZGFyZCxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIHtcbiAgICAgIC8vIG5vb3AsIFdlIGV4cGVjdCBlcnJvcnMgaGVyZSBidXQgd2UgZG9uJ3QgbmVlZCB0byByZXBvcnQgdGhlbSBvciBkb1xuICAgICAgLy8gYW55dGhpbmcgaW4gcmVzcG9uc2UuXG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlIHRyYW5zYWN0aW9uIGlzIGludGVyYWN0aW5nIHdpdGggYSBjb250cmFjdCBidXQgaXNuJ3QgYSB0b2tlbiBtZXRob2RcbiAgLy8gd2UgdXNlIHRoZSAnVU5LTk9XTicgdmFsdWUgdG8gc2hvdyB0aGF0IGl0IGlzbid0IGEgdHJhbnNhY3Rpb24gc2VuZGluZyBhbnlcbiAgLy8gcGFydGljdWxhciBhc3NldC5cbiAgaWYgKGluZmVycmFibGVUeXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5DT05UUkFDVF9JTlRFUkFDVElPTikge1xuICAgIHJldHVybiB7XG4gICAgICBhc3NldFR5cGU6IEFTU0VUX1RZUEVTLlVOS05PV04sXG4gICAgICB0b2tlblN0YW5kYXJkOiBUT0tFTl9TVEFOREFSRFMuTk9ORSxcbiAgICB9O1xuICB9XG4gIHJldHVybiB7IGFzc2V0VHlwZTogQVNTRVRfVFlQRVMuTkFUSVZFLCB0b2tlblN0YW5kYXJkOiBUT0tFTl9TVEFOREFSRFMuTk9ORSB9O1xufVxuIiwiLy8gTWVzc2FnZXMgYW5kIGRlc2NyaXB0aW9ucyBmb3IgdGhlc2UgbG9jYWxlIGtleXMgYXJlIGluIGFwcC9fbG9jYWxlcy9lbi9tZXNzYWdlcy5qc29uXG5leHBvcnQgY29uc3QgVUlfTk9USUZJQ0FUSU9OUyA9IHtcbiAgMToge1xuICAgIGlkOiAxLFxuICAgIGRhdGU6ICcyMDIxLTAzLTE3JyxcbiAgICBpbWFnZToge1xuICAgICAgc3JjOiAnaW1hZ2VzL21vYmlsZS1saW5rLXFyLnN2ZycsXG4gICAgICBoZWlnaHQ6ICcyMzBweCcsXG4gICAgICB3aWR0aDogJzIzMHB4JyxcbiAgICAgIHBsYWNlSW1hZ2VCZWxvd0Rlc2NyaXB0aW9uOiB0cnVlLFxuICAgIH0sXG4gIH0sXG4gIDM6IHtcbiAgICBpZDogMyxcbiAgICBkYXRlOiAnMjAyMS0wMy0wOCcsXG4gIH0sXG4gIDQ6IHtcbiAgICBpZDogNCxcbiAgICBkYXRlOiAnMjAyMS0wNS0xMScsXG4gICAgaW1hZ2U6IHtcbiAgICAgIHNyYzogJ2ltYWdlcy9zb3VyY2UtbG9nb3MtYnNjLnN2ZycsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH0sXG4gIH0sXG4gIDU6IHtcbiAgICBpZDogNSxcbiAgICBkYXRlOiAnMjAyMS0wNi0wOScsXG4gIH0sXG4gIDY6IHtcbiAgICBpZDogNixcbiAgICBkYXRlOiAnMjAyMS0wNS0yNicsXG4gIH0sXG4gIDc6IHtcbiAgICBpZDogNyxcbiAgICBkYXRlOiAnMjAyMS0wOS0xNycsXG4gIH0sXG4gIDg6IHtcbiAgICBpZDogOCxcbiAgICBkYXRlOiAnMjAyMS0xMS0wMScsXG4gIH0sXG4gIDk6IHtcbiAgICBpZDogOSxcbiAgICBkYXRlOiAnMjAyMS0xMi0wNycsXG4gICAgaW1hZ2U6IHtcbiAgICAgIHNyYzogJ2ltYWdlcy90eGluc2lnaHRzLnBuZycsXG4gICAgICB3aWR0aDogJzgwJScsXG4gICAgfSxcbiAgfSxcbiAgMTA6IHtcbiAgICBpZDogMTAsXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxuICAgIGltYWdlOiB7XG4gICAgICBzcmM6ICdpbWFnZXMvdG9rZW4tZGV0ZWN0aW9uLnN2ZycsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH0sXG4gIH0sXG4gIDExOiB7XG4gICAgaWQ6IDExLFxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcbiAgfSxcbiAgMTI6IHtcbiAgICBpZDogMTIsXG4gICAgZGF0ZTogJzIwMjItMDUtMTgnLFxuICAgIGltYWdlOiB7XG4gICAgICBzcmM6ICdpbWFnZXMvZGFya21vZGUtYmFubmVyLnBuZycsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgIH0sXG4gIH0sXG4gIDEzOiB7XG4gICAgaWQ6IDEzLFxuICAgIGRhdGU6ICcyMDIyLTA5LTE1JyxcbiAgfSxcbiAgMTQ6IHtcbiAgICBpZDogMTQsXG4gICAgZGF0ZTogJzIwMjItMDktMTUnLFxuICB9LFxuICAxNToge1xuICAgIGlkOiAxNSxcbiAgICBkYXRlOiAnMjAyMi0wOS0xNScsXG4gIH0sXG4gIDE2OiB7XG4gICAgaWQ6IDE2LFxuICAgIGRhdGU6IG51bGwsXG4gIH0sXG59O1xuXG5leHBvcnQgY29uc3QgZ2V0VHJhbnNsYXRlZFVJTm90aWZpY2F0aW9ucyA9ICh0LCBsb2NhbGUpID0+IHtcbiAgY29uc3QgZm9ybWF0dGVkTG9jYWxlID0gbG9jYWxlLnJlcGxhY2UoJ18nLCAnLScpO1xuICByZXR1cm4ge1xuICAgIDE6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMV0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczFUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxRGVzY3JpcHRpb24nKSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzFdLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDM6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbM10sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczNUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMzRGVzY3JpcHRpb24nKSxcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMzQWN0aW9uVGV4dCcpLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbM10uZGF0ZSksXG4gICAgICApLFxuICAgIH0sXG4gICAgNDoge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1s0XSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zNFRpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczREZXNjcmlwdGlvbicpLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczRBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s0XS5kYXRlKSxcbiAgICAgICksXG4gICAgfSxcbiAgICA1OiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzVdLFxuICAgICAgdGl0bGU6IHQoJ3NlY3JldFJlY292ZXJ5UGhyYXNlJyksXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczVEZXNjcmlwdGlvbicpLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczNBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s1XS5kYXRlKSxcbiAgICAgICksXG4gICAgfSxcbiAgICA2OiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzZdLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM2VGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM2RGVzY3JpcHRpb25PbmUnKSxcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczZEZXNjcmlwdGlvblR3bycpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zNkRlc2NyaXB0aW9uVGhyZWUnKSxcbiAgICAgIF0sXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1s2XS5kYXRlKSxcbiAgICAgICksXG4gICAgfSxcbiAgICA3OiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzddLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM3VGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM3RGVzY3JpcHRpb25PbmUnKSxcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczdEZXNjcmlwdGlvblR3bycpLFxuICAgICAgXSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzddLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDg6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbOF0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczhUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczhEZXNjcmlwdGlvbk9uZScpLFxuICAgICAgICB0KCdub3RpZmljYXRpb25zOERlc2NyaXB0aW9uVHdvJyksXG4gICAgICBdLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbOF0uZGF0ZSksXG4gICAgICApLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczhBY3Rpb25UZXh0JyksXG4gICAgfSxcbiAgICA5OiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzldLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnM5VGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBbXG4gICAgICAgIHQoJ25vdGlmaWNhdGlvbnM5RGVzY3JpcHRpb25PbmUnKSxcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczlEZXNjcmlwdGlvblR3bycpLFxuICAgICAgXSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzldLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDEwOiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzEwXSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTBUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IFtcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczEwRGVzY3JpcHRpb25PbmUnKSxcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczEwRGVzY3JpcHRpb25Ud28nKSxcbiAgICAgICAgdCgnbm90aWZpY2F0aW9uczEwRGVzY3JpcHRpb25UaHJlZScpLFxuICAgICAgXSxcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxMEFjdGlvblRleHQnKSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzEwXS5kYXRlKSxcbiAgICAgICksXG4gICAgfSxcbiAgICAxMToge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxMV0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczExVGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTFEZXNjcmlwdGlvbicpLFxuICAgICAgZGF0ZTogbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTFdLmRhdGUpLFxuICAgICAgKSxcbiAgICB9LFxuICAgIDEyOiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzEyXSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTJUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxMkRlc2NyaXB0aW9uJyksXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTJBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxMl0uZGF0ZSksXG4gICAgICApLFxuICAgIH0sXG4gICAgMTM6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTNdLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxM1RpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczEzRGVzY3JpcHRpb24nKSxcbiAgICAgIGFjdGlvblRleHQ6IHQoJ25vdGlmaWNhdGlvbnMxM0FjdGlvblRleHQnKSxcbiAgICAgIGRhdGU6IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzEzXS5kYXRlKSxcbiAgICAgICksXG4gICAgfSxcbiAgICAxNDoge1xuICAgICAgLi4uVUlfTk9USUZJQ0FUSU9OU1sxNF0sXG4gICAgICB0aXRsZTogdCgnbm90aWZpY2F0aW9uczE0VGl0bGUnKSxcbiAgICAgIGRlc2NyaXB0aW9uOiB0KCdub3RpZmljYXRpb25zMTREZXNjcmlwdGlvbicpLFxuICAgICAgYWN0aW9uVGV4dDogdCgnbm90aWZpY2F0aW9uczE0QWN0aW9uVGV4dCcpLFxuICAgICAgZGF0ZTogVUlfTk9USUZJQ0FUSU9OU1sxNF0uZGF0ZVxuICAgICAgICA/IG5ldyBJbnRsLkRhdGVUaW1lRm9ybWF0KGZvcm1hdHRlZExvY2FsZSkuZm9ybWF0KFxuICAgICAgICAgICAgbmV3IERhdGUoVUlfTk9USUZJQ0FUSU9OU1sxNF0uZGF0ZSksXG4gICAgICAgICAgKVxuICAgICAgICA6ICcnLFxuICAgIH0sXG4gICAgMTU6IHtcbiAgICAgIC4uLlVJX05PVElGSUNBVElPTlNbMTVdLFxuICAgICAgdGl0bGU6IHQoJ25vdGlmaWNhdGlvbnMxNVRpdGxlJyksXG4gICAgICBkZXNjcmlwdGlvbjogdCgnbm90aWZpY2F0aW9uczE1RGVzY3JpcHRpb24nKSxcbiAgICAgIGRhdGU6IFVJX05PVElGSUNBVElPTlNbMTVdLmRhdGVcbiAgICAgICAgPyBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChmb3JtYXR0ZWRMb2NhbGUpLmZvcm1hdChcbiAgICAgICAgICAgIG5ldyBEYXRlKFVJX05PVElGSUNBVElPTlNbMTVdLmRhdGUpLFxuICAgICAgICAgIClcbiAgICAgICAgOiAnJyxcbiAgICB9LFxuICAgIDE2OiB7XG4gICAgICAuLi5VSV9OT1RJRklDQVRJT05TWzE2XSxcbiAgICAgIHRpdGxlOiB0KCdub3RpZmljYXRpb25zMTZUaXRsZScpLFxuICAgICAgZGVzY3JpcHRpb246IHQoJ25vdGlmaWNhdGlvbnMxNkRlc2NyaXB0aW9uJyksXG4gICAgICBhY3Rpb25UZXh0OiB0KCdub3RpZmljYXRpb25zMTZBY3Rpb25UZXh0JyksXG4gICAgICBkYXRlOiBVSV9OT1RJRklDQVRJT05TWzE2XS5kYXRlXG4gICAgICAgID8gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoZm9ybWF0dGVkTG9jYWxlKS5mb3JtYXQoXG4gICAgICAgICAgICBuZXcgRGF0ZShVSV9OT1RJRklDQVRJT05TWzE2XS5kYXRlKSxcbiAgICAgICAgICApXG4gICAgICAgIDogJycsXG4gICAgfSxcbiAgfTtcbn07XG4iLCJleHBvcnQgY29uc3QgQUxFUlRfU1RBVEUgPSB7XHJcbiAgQ0xPU0VEOiAnQ0xPU0VEJyxcclxuICBFUlJPUjogJ0VSUk9SJyxcclxuICBMT0FESU5HOiAnTE9BRElORycsXHJcbiAgT1BFTjogJ09QRU4nLFxyXG59O1xyXG4iLCJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xyXG5pbXBvcnQgeyBjYXB0dXJlRXhjZXB0aW9uIH0gZnJvbSAnQHNlbnRyeS9icm93c2VyJztcclxuXHJcbmltcG9ydCB7IEFMRVJUX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hbGVydHMnO1xyXG5pbXBvcnQgKiBhcyBhY3Rpb25Db25zdGFudHMgZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9uQ29uc3RhbnRzJztcclxuaW1wb3J0IHtcclxuICBhZGRQZXJtaXR0ZWRBY2NvdW50LFxyXG4gIHNldEFsZXJ0RW5hYmxlZG5lc3MsXHJcbiAgc2V0U2VsZWN0ZWRBZGRyZXNzLFxyXG59IGZyb20gJy4uLy4uL3N0b3JlL2FjdGlvbnMnO1xyXG5pbXBvcnQgeyBnZXRPcmlnaW5PZkN1cnJlbnRUYWIsIGdldFNlbGVjdGVkQWRkcmVzcyB9IGZyb20gJy4uLy4uL3NlbGVjdG9ycyc7XHJcbmltcG9ydCB7IEFMRVJUX1NUQVRFIH0gZnJvbSAnLi9lbnVtcyc7XHJcblxyXG4vLyBDb25zdGFudHNcclxuXHJcbmNvbnN0IG5hbWUgPSBBTEVSVF9UWVBFUy51bmNvbm5lY3RlZEFjY291bnQ7XHJcblxyXG5jb25zdCBpbml0aWFsU3RhdGUgPSB7XHJcbiAgc3RhdGU6IEFMRVJUX1NUQVRFLkNMT1NFRCxcclxufTtcclxuXHJcbi8vIFNsaWNlIChyZWR1Y2VyIHBsdXMgYXV0by1nZW5lcmF0ZWQgYWN0aW9ucyBhbmQgYWN0aW9uIGNyZWF0b3JzKVxyXG5cclxuY29uc3Qgc2xpY2UgPSBjcmVhdGVTbGljZSh7XHJcbiAgbmFtZSxcclxuICBpbml0aWFsU3RhdGUsXHJcbiAgcmVkdWNlcnM6IHtcclxuICAgIGNvbm5lY3RBY2NvdW50RmFpbGVkOiAoc3RhdGUpID0+IHtcclxuICAgICAgc3RhdGUuc3RhdGUgPSBBTEVSVF9TVEFURS5FUlJPUjtcclxuICAgIH0sXHJcbiAgICBjb25uZWN0QWNjb3VudFJlcXVlc3RlZDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuTE9BRElORztcclxuICAgIH0sXHJcbiAgICBjb25uZWN0QWNjb3VudFN1Y2NlZWRlZDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuQ0xPU0VEO1xyXG4gICAgfSxcclxuICAgIGRpc2FibGVBbGVydEZhaWxlZDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuRVJST1I7XHJcbiAgICB9LFxyXG4gICAgZGlzYWJsZUFsZXJ0UmVxdWVzdGVkOiAoc3RhdGUpID0+IHtcclxuICAgICAgc3RhdGUuc3RhdGUgPSBBTEVSVF9TVEFURS5MT0FESU5HO1xyXG4gICAgfSxcclxuICAgIGRpc2FibGVBbGVydFN1Y2NlZWRlZDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuQ0xPU0VEO1xyXG4gICAgfSxcclxuICAgIGRpc21pc3NBbGVydDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuQ0xPU0VEO1xyXG4gICAgfSxcclxuICAgIHN3aXRjaEFjY291bnRGYWlsZWQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkVSUk9SO1xyXG4gICAgfSxcclxuICAgIHN3aXRjaEFjY291bnRSZXF1ZXN0ZWQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkxPQURJTkc7XHJcbiAgICB9LFxyXG4gICAgc3dpdGNoQWNjb3VudFN1Y2NlZWRlZDogKHN0YXRlKSA9PiB7XHJcbiAgICAgIHN0YXRlLnN0YXRlID0gQUxFUlRfU1RBVEUuQ0xPU0VEO1xyXG4gICAgfSxcclxuICAgIHN3aXRjaGVkVG9VbmNvbm5lY3RlZEFjY291bnQ6IChzdGF0ZSkgPT4ge1xyXG4gICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLk9QRU47XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgZXh0cmFSZWR1Y2Vyczoge1xyXG4gICAgW2FjdGlvbkNvbnN0YW50cy5TRUxFQ1RFRF9BRERSRVNTX0NIQU5HRURdOiAoc3RhdGUpID0+IHtcclxuICAgICAgLy8gY2xvc2UgdGhlIGFsZXJ0IGlmIHRoZSBhY2NvdW50IGlzIHN3aXRjaGVkIHdoaWxlIGl0J3Mgb3BlblxyXG4gICAgICBpZiAoc3RhdGUuc3RhdGUgPT09IEFMRVJUX1NUQVRFLk9QRU4pIHtcclxuICAgICAgICBzdGF0ZS5zdGF0ZSA9IEFMRVJUX1NUQVRFLkNMT1NFRDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICB9LFxyXG59KTtcclxuXHJcbmNvbnN0IHsgYWN0aW9ucywgcmVkdWNlciB9ID0gc2xpY2U7XHJcblxyXG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xyXG5cclxuLy8gU2VsZWN0b3JzXHJcblxyXG5leHBvcnQgY29uc3QgZ2V0QWxlcnRTdGF0ZSA9IChzdGF0ZSkgPT4gc3RhdGVbbmFtZV0uc3RhdGU7XHJcblxyXG5leHBvcnQgY29uc3QgYWxlcnRJc09wZW4gPSAoc3RhdGUpID0+IHN0YXRlW25hbWVdLnN0YXRlICE9PSBBTEVSVF9TVEFURS5DTE9TRUQ7XHJcblxyXG4vLyBBY3Rpb25zIC8gYWN0aW9uLWNyZWF0b3JzXHJcblxyXG5jb25zdCB7XHJcbiAgY29ubmVjdEFjY291bnRGYWlsZWQsXHJcbiAgY29ubmVjdEFjY291bnRSZXF1ZXN0ZWQsXHJcbiAgY29ubmVjdEFjY291bnRTdWNjZWVkZWQsXHJcbiAgZGlzYWJsZUFsZXJ0RmFpbGVkLFxyXG4gIGRpc2FibGVBbGVydFJlcXVlc3RlZCxcclxuICBkaXNhYmxlQWxlcnRTdWNjZWVkZWQsXHJcbiAgZGlzbWlzc0FsZXJ0LFxyXG4gIHN3aXRjaEFjY291bnRGYWlsZWQsXHJcbiAgc3dpdGNoQWNjb3VudFJlcXVlc3RlZCxcclxuICBzd2l0Y2hBY2NvdW50U3VjY2VlZGVkLFxyXG4gIHN3aXRjaGVkVG9VbmNvbm5lY3RlZEFjY291bnQsXHJcbn0gPSBhY3Rpb25zO1xyXG5cclxuZXhwb3J0IHsgZGlzbWlzc0FsZXJ0LCBzd2l0Y2hlZFRvVW5jb25uZWN0ZWRBY2NvdW50IH07XHJcblxyXG5leHBvcnQgY29uc3QgZGlzbWlzc0FuZERpc2FibGVBbGVydCA9ICgpID0+IHtcclxuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBhd2FpdCBkaXNwYXRjaChkaXNhYmxlQWxlcnRSZXF1ZXN0ZWQoKSk7XHJcbiAgICAgIGF3YWl0IHNldEFsZXJ0RW5hYmxlZG5lc3MobmFtZSwgZmFsc2UpO1xyXG4gICAgICBhd2FpdCBkaXNwYXRjaChkaXNhYmxlQWxlcnRTdWNjZWVkZWQoKSk7XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcclxuICAgICAgY2FwdHVyZUV4Y2VwdGlvbihlcnJvcik7XHJcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGRpc2FibGVBbGVydEZhaWxlZCgpKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IHN3aXRjaFRvQWNjb3VudCA9IChhZGRyZXNzKSA9PiB7XHJcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCkgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goc3dpdGNoQWNjb3VudFJlcXVlc3RlZCgpKTtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goc2V0U2VsZWN0ZWRBZGRyZXNzKGFkZHJlc3MpKTtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goc3dpdGNoQWNjb3VudFN1Y2NlZWRlZCgpKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xyXG4gICAgICBjYXB0dXJlRXhjZXB0aW9uKGVycm9yKTtcclxuICAgICAgYXdhaXQgZGlzcGF0Y2goc3dpdGNoQWNjb3VudEZhaWxlZCgpKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvbm5lY3RBY2NvdW50ID0gKCkgPT4ge1xyXG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XHJcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XHJcbiAgICBjb25zdCBzZWxlY3RlZEFkZHJlc3MgPSBnZXRTZWxlY3RlZEFkZHJlc3Moc3RhdGUpO1xyXG4gICAgY29uc3Qgb3JpZ2luID0gZ2V0T3JpZ2luT2ZDdXJyZW50VGFiKHN0YXRlKTtcclxuICAgIHRyeSB7XHJcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGNvbm5lY3RBY2NvdW50UmVxdWVzdGVkKCkpO1xyXG4gICAgICBhd2FpdCBkaXNwYXRjaChhZGRQZXJtaXR0ZWRBY2NvdW50KG9yaWdpbiwgc2VsZWN0ZWRBZGRyZXNzKSk7XHJcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGNvbm5lY3RBY2NvdW50U3VjY2VlZGVkKCkpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XHJcbiAgICAgIGNhcHR1cmVFeGNlcHRpb24oZXJyb3IpO1xyXG4gICAgICBhd2FpdCBkaXNwYXRjaChjb25uZWN0QWNjb3VudEZhaWxlZCgpKTtcclxuICAgIH1cclxuICB9O1xyXG59O1xyXG4iLCJpbXBvcnQge1xuICBXRUJISURfQ09OTkVDVEVEX1NUQVRVU0VTLFxuICBUUkFOU1BPUlRfU1RBVEVTLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2hhcmR3YXJlLXdhbGxldHMnO1xuaW1wb3J0ICogYXMgYWN0aW9uQ29uc3RhbnRzIGZyb20gJy4uLy4uL3N0b3JlL2FjdGlvbkNvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZHVjZUFwcChzdGF0ZSA9IHt9LCBhY3Rpb24pIHtcbiAgLy8gZGVmYXVsdCBzdGF0ZVxuICBjb25zdCBhcHBTdGF0ZSA9IHtcbiAgICBzaG91bGRDbG9zZTogZmFsc2UsXG4gICAgbWVudU9wZW46IGZhbHNlLFxuICAgIG1vZGFsOiB7XG4gICAgICBvcGVuOiBmYWxzZSxcbiAgICAgIG1vZGFsU3RhdGU6IHtcbiAgICAgICAgbmFtZTogbnVsbCxcbiAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgfSxcbiAgICAgIHByZXZpb3VzTW9kYWxTdGF0ZToge1xuICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgfSxcbiAgICB9LFxuICAgIGFsZXJ0T3BlbjogZmFsc2UsXG4gICAgYWxlcnRNZXNzYWdlOiBudWxsLFxuICAgIHFyQ29kZURhdGE6IG51bGwsXG4gICAgbmV0d29ya0Ryb3Bkb3duT3BlbjogZmFsc2UsXG4gICAgYWNjb3VudERldGFpbDoge1xuICAgICAgc3VidmlldzogJ3RyYW5zYWN0aW9ucycsXG4gICAgfSxcbiAgICAvLyBVc2VkIHRvIGRpc3BsYXkgbG9hZGluZyBpbmRpY2F0b3JcbiAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgIC8vIFVzZWQgdG8gZGlzcGxheSBlcnJvciB0ZXh0XG4gICAgd2FybmluZzogbnVsbCxcbiAgICBidXlWaWV3OiB7fSxcbiAgICBpc01vdXNlVXNlcjogZmFsc2UsXG4gICAgZGVmYXVsdEhkUGF0aHM6IHtcbiAgICAgIHRyZXpvcjogYG0vNDQnLzYwJy8wJy8wYCxcbiAgICAgIGxlZGdlcjogYG0vNDQnLzYwJy8wJy8wLzBgLFxuICAgICAgbGF0dGljZTogYG0vNDQnLzYwJy8wJy8wYCxcbiAgICB9LFxuICAgIG5ldHdvcmtzVGFiU2VsZWN0ZWRScGNVcmw6ICcnLFxuICAgIGxvYWRpbmdNZXRob2REYXRhOiBmYWxzZSxcbiAgICByZXF1ZXN0QWNjb3VudFRhYnM6IHt9LFxuICAgIG9wZW5NZXRhTWFza1RhYnM6IHt9LFxuICAgIGN1cnJlbnRXaW5kb3dUYWI6IHt9LFxuICAgIHNob3dXaGF0c05ld1BvcHVwOiB0cnVlLFxuICAgIHNpbmdsZUV4Y2VwdGlvbnM6IHtcbiAgICAgIHRlc3RLZXk6IG51bGwsXG4gICAgfSxcbiAgICBnYXNMb2FkaW5nQW5pbWF0aW9uSXNTaG93aW5nOiBmYWxzZSxcbiAgICBzbWFydFRyYW5zYWN0aW9uc0Vycm9yOiBudWxsLFxuICAgIHNtYXJ0VHJhbnNhY3Rpb25zRXJyb3JNZXNzYWdlRGlzbWlzc2VkOiBmYWxzZSxcbiAgICBsZWRnZXJXZWJIaWRDb25uZWN0ZWRTdGF0dXM6IFdFQkhJRF9DT05ORUNURURfU1RBVFVTRVMuVU5LTk9XTixcbiAgICBsZWRnZXJUcmFuc3BvcnRTdGF0dXM6IFRSQU5TUE9SVF9TVEFURVMuTk9ORSxcbiAgICBuZXdOZXR3b3JrQWRkZWQ6ICcnLFxuICAgIG5ld0NvbGxlY3RpYmxlQWRkZWRNZXNzYWdlOiAnJyxcbiAgICBwb3J0Zm9saW9Ub29sdGlwV2FzU2hvd25JblRoaXNTZXNzaW9uOiBmYWxzZSxcbiAgICBzZW5kSW5wdXRDdXJyZW5jeVN3aXRjaGVkOiBmYWxzZSxcbiAgICBuZXdUb2tlbnNJbXBvcnRlZDogJycsXG4gICAgbmV3Q3VzdG9tTmV0d29ya0FkZGVkOiB7fSxcbiAgICBvbmJvYXJkZWRJblRoaXNVSVNlc3Npb246IGZhbHNlLFxuICAgIGN1c3RvbVRva2VuQW1vdW50OiAnJyxcbiAgICAuLi5zdGF0ZSxcbiAgfTtcblxuICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgLy8gZHJvcGRvd24gbWV0aG9kc1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLk5FVFdPUktfRFJPUERPV05fT1BFTjpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBuZXR3b3JrRHJvcGRvd25PcGVuOiB0cnVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLk5FVFdPUktfRFJPUERPV05fQ0xPU0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV0d29ya0Ryb3Bkb3duT3BlbjogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgLy8gYWxlcnQgbWV0aG9kc1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkFMRVJUX09QRU46XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWxlcnRPcGVuOiB0cnVlLFxuICAgICAgICBhbGVydE1lc3NhZ2U6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5BTEVSVF9DTE9TRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBhbGVydE9wZW46IGZhbHNlLFxuICAgICAgICBhbGVydE1lc3NhZ2U6IG51bGwsXG4gICAgICB9O1xuXG4gICAgLy8gcXIgc2Nhbm5lciBtZXRob2RzXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuUVJfQ09ERV9ERVRFQ1RFRDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBxckNvZGVEYXRhOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgLy8gU21hcnQgVHJhbnNhY3Rpb25zIGVycm9ycy5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfU01BUlRfVFJBTlNBQ1RJT05TX0VSUk9SOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHNtYXJ0VHJhbnNhY3Rpb25zRXJyb3I6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkRJU01JU1NfU01BUlRfVFJBTlNBQ1RJT05TX0VSUk9SX01FU1NBR0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgc21hcnRUcmFuc2FjdGlvbnNFcnJvck1lc3NhZ2VEaXNtaXNzZWQ6IHRydWUsXG4gICAgICB9O1xuXG4gICAgLy8gbW9kYWwgbWV0aG9kczpcbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5NT0RBTF9PUEVOOiB7XG4gICAgICBjb25zdCB7IG5hbWUsIC4uLm1vZGFsUHJvcHMgfSA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbW9kYWw6IHtcbiAgICAgICAgICBvcGVuOiB0cnVlLFxuICAgICAgICAgIG1vZGFsU3RhdGU6IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBwcm9wczogeyAuLi5tb2RhbFByb3BzIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwcmV2aW91c01vZGFsU3RhdGU6IHsgLi4uYXBwU3RhdGUubW9kYWwubW9kYWxTdGF0ZSB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5NT0RBTF9DTE9TRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBtb2RhbDogT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBhcHBTdGF0ZS5tb2RhbCxcbiAgICAgICAgICB7IG9wZW46IGZhbHNlIH0sXG4gICAgICAgICAgeyBtb2RhbFN0YXRlOiB7IG5hbWU6IG51bGwsIHByb3BzOiB7fSB9IH0sXG4gICAgICAgICAgeyBwcmV2aW91c01vZGFsU3RhdGU6IGFwcFN0YXRlLm1vZGFsLm1vZGFsU3RhdGUgfSxcbiAgICAgICAgKSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5DTEVBUl9BQ0NPVU5UX0RFVEFJTFM6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWNjb3VudERldGFpbDoge30sXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuRk9SR09UX1BBU1NXT1JEOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0hPV19TRU5EX1RPS0VOX1BBR0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgd2FybmluZzogbnVsbCxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5MT0NLX01FVEFNQVNLOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICB9O1xuXG4gICAgLy8gYWNjb3VudHNcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkdPX0hPTUU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWNjb3VudERldGFpbDoge1xuICAgICAgICAgIHN1YnZpZXc6ICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICAgIGFjY291bnRFeHBvcnQ6ICdub25lJyxcbiAgICAgICAgICBwcml2YXRlS2V5OiAnJyxcbiAgICAgICAgfSxcbiAgICAgICAgd2FybmluZzogbnVsbCxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TSE9XX0FDQ09VTlRfREVUQUlMOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBhcHBTdGF0ZS5mb3Jnb3R0ZW5QYXNzd29yZFxuICAgICAgICAgID8gIWFwcFN0YXRlLmZvcmdvdHRlblBhc3N3b3JkXG4gICAgICAgICAgOiBudWxsLFxuICAgICAgICBhY2NvdW50RGV0YWlsOiB7XG4gICAgICAgICAgc3VidmlldzogJ3RyYW5zYWN0aW9ucycsXG4gICAgICAgICAgYWNjb3VudEV4cG9ydDogJ25vbmUnLFxuICAgICAgICAgIHByaXZhdGVLZXk6ICcnLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfQUNDT1VOVFNfUEFHRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICB3YXJuaW5nOiBudWxsLFxuICAgICAgICBzY3JvbGxUb0JvdHRvbTogZmFsc2UsXG4gICAgICAgIGZvcmdvdHRlblBhc3N3b3JkOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TSE9XX0NPTkZfVFhfUEFHRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICB0eElkOiBhY3Rpb24uaWQsXG4gICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuQ09NUExFVEVEX1RYOlxuICAgICAgaWYgKGFjdGlvbi52YWx1ZS51bmNvbmZpcm1lZEFjdGlvbnNDb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgICB0eElkOiBudWxsLFxuICAgICAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgLy8gaW5kaWNhdGUgbm90aWZpY2F0aW9uIHNob3VsZCBjbG9zZVxuICAgICAgICBzaG91bGRDbG9zZTogdHJ1ZSxcbiAgICAgICAgd2FybmluZzogbnVsbCxcbiAgICAgICAgdHhJZDogbnVsbCxcbiAgICAgICAgYWNjb3VudERldGFpbDoge1xuICAgICAgICAgIHN1YnZpZXc6ICd0cmFuc2FjdGlvbnMnLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRSQU5TQUNUSU9OX0VSUk9SOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuVU5MT0NLX0ZBSUxFRDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICB3YXJuaW5nOiBhY3Rpb24udmFsdWUgfHwgJ0luY29ycmVjdCBwYXNzd29yZC4gVHJ5IGFnYWluLicsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuVU5MT0NLX1NVQ0NFRURFRDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICB3YXJuaW5nOiAnJyxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfSEFSRFdBUkVfV0FMTEVUX0RFRkFVTFRfSERfUEFUSDoge1xuICAgICAgY29uc3QgeyBkZXZpY2UsIHBhdGggfSA9IGFjdGlvbi52YWx1ZTtcbiAgICAgIGNvbnN0IG5ld0RlZmF1bHRzID0geyAuLi5hcHBTdGF0ZS5kZWZhdWx0SGRQYXRocyB9O1xuICAgICAgbmV3RGVmYXVsdHNbZGV2aWNlXSA9IHBhdGg7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBkZWZhdWx0SGRQYXRoczogbmV3RGVmYXVsdHMsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfTE9BRElORzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgIGxvYWRpbmdNZXNzYWdlOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuSElERV9MT0FESU5HOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuRElTUExBWV9XQVJOSU5HOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHdhcm5pbmc6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5ISURFX1dBUk5JTkc6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgd2FybmluZzogdW5kZWZpbmVkLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfUFJJVkFURV9LRVk6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgYWNjb3VudERldGFpbDoge1xuICAgICAgICAgIHN1YnZpZXc6ICdleHBvcnQnLFxuICAgICAgICAgIGFjY291bnRFeHBvcnQ6ICdjb21wbGV0ZWQnLFxuICAgICAgICAgIHByaXZhdGVLZXk6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTU9VU0VfVVNFUl9TVEFURTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBpc01vdXNlVXNlcjogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9TRUxFQ1RFRF9TRVRUSU5HU19SUENfVVJMOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIG5ldHdvcmtzVGFiU2VsZWN0ZWRScGNVcmw6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTkVXX05FVFdPUktfQURERUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3TmV0d29ya0FkZGVkOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0VUX05FV19UT0tFTlNfSU1QT1JURUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3VG9rZW5zSW1wb3J0ZWQ6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTkVXX0NPTExFQ1RJQkxFX0FEREVEX01FU1NBR0U6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3Q29sbGVjdGlibGVBZGRlZE1lc3NhZ2U6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5QT1JURk9MSU9fVE9PTFRJUF9XQVNfU0hPV05fSU5fVEhJU19TRVNTSU9OOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHBvcnRmb2xpb1Rvb2x0aXBXYXNTaG93bkluVGhpc1Nlc3Npb246IHRydWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuTE9BRElOR19NRVRIT0RfREFUQV9TVEFSVEVEOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGxvYWRpbmdNZXRob2REYXRhOiB0cnVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLkxPQURJTkdfTUVUSE9EX0RBVEFfRklOSVNIRUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbG9hZGluZ01ldGhvZERhdGE6IGZhbHNlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9SRVFVRVNUX0FDQ09VTlRfVEFCUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICByZXF1ZXN0QWNjb3VudFRhYnM6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfT1BFTl9NRVRBTUFTS19UQUJfSURTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIG9wZW5NZXRhTWFza1RhYnM6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfQ1VSUkVOVF9XSU5ET1dfVEFCOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGN1cnJlbnRXaW5kb3dUYWI6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5ISURFX1dIQVRTX05FV19QT1BVUDpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBzaG93V2hhdHNOZXdQb3B1cDogZmFsc2UsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuQ0FQVFVSRV9TSU5HTEVfRVhDRVBUSU9OOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIHNpbmdsZUV4Y2VwdGlvbnM6IHtcbiAgICAgICAgICAuLi5hcHBTdGF0ZS5zaW5nbGVFeGNlcHRpb25zLFxuICAgICAgICAgIFthY3Rpb24udmFsdWVdOiBudWxsLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9HQVNfTE9BRElOR19BTklNQVRJT046XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgZ2FzTG9hZGluZ0FuaW1hdGlvbklzU2hvd2luZzogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9XRUJISURfQ09OTkVDVEVEX1NUQVRVUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmFwcFN0YXRlLFxuICAgICAgICBsZWRnZXJXZWJIaWRDb25uZWN0ZWRTdGF0dXM6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfTEVER0VSX1RSQU5TUE9SVF9TVEFUVVM6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbGVkZ2VyVHJhbnNwb3J0U3RhdHVzOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9DVVJSRU5DWV9JTlBVVF9TV0lUQ0g6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgc2VuZElucHV0Q3VycmVuY3lTd2l0Y2hlZDogIWFwcFN0YXRlLnNlbmRJbnB1dEN1cnJlbmN5U3dpdGNoZWQsXG4gICAgICB9O1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9ORVdfQ1VTVE9NX05FVFdPUktfQURERUQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgbmV3Q3VzdG9tTmV0d29ya0FkZGVkOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLk9OQk9BUkRFRF9JTl9USElTX1VJX1NFU1NJT046XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5hcHBTdGF0ZSxcbiAgICAgICAgb25ib2FyZGVkSW5UaGlzVUlTZXNzaW9uOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9DVVNUT01fVE9LRU5fQU1PVU5UOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uYXBwU3RhdGUsXG4gICAgICAgIGN1c3RvbVRva2VuQW1vdW50OiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gYXBwU3RhdGU7XG4gIH1cbn1cblxuLy8gQWN0aW9uIENyZWF0b3JzXG5leHBvcnQgZnVuY3Rpb24gaGlkZVdoYXRzTmV3UG9wdXAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogYWN0aW9uQ29uc3RhbnRzLkhJREVfV0hBVFNfTkVXX1BPUFVQLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UG9ydGZvbGlvVG9vbHRpcFdhc1Nob3duSW5UaGlzU2Vzc2lvbigpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBhY3Rpb25Db25zdGFudHMuUE9SVEZPTElPX1RPT0xUSVBfV0FTX1NIT1dOX0lOX1RISVNfU0VTU0lPTixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvZ2dsZUdhc0xvYWRpbmdBbmltYXRpb24odmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9HQVNfTE9BRElOR19BTklNQVRJT04sIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRMZWRnZXJXZWJIaWRDb25uZWN0ZWRTdGF0dXModmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLlNFVF9XRUJISURfQ09OTkVDVEVEX1NUQVRVUywgdmFsdWUgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldExlZGdlclRyYW5zcG9ydFN0YXR1cyh2YWx1ZSkge1xuICByZXR1cm4geyB0eXBlOiBhY3Rpb25Db25zdGFudHMuU0VUX0xFREdFUl9UUkFOU1BPUlRfU1RBVFVTLCB2YWx1ZSB9O1xufVxuXG4vLyBTZWxlY3RvcnNcbmV4cG9ydCBmdW5jdGlvbiBnZXRRckNvZGVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5hcHBTdGF0ZS5xckNvZGVEYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2FzTG9hZGluZ0FuaW1hdGlvbklzU2hvd2luZyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuYXBwU3RhdGUuZ2FzTG9hZGluZ0FuaW1hdGlvbklzU2hvd2luZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExlZGdlcldlYkhpZENvbm5lY3RlZFN0YXR1cyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuYXBwU3RhdGUubGVkZ2VyV2ViSGlkQ29ubmVjdGVkU3RhdHVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVkZ2VyVHJhbnNwb3J0U3RhdHVzKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5hcHBTdGF0ZS5sZWRnZXJUcmFuc3BvcnRTdGF0dXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQb3J0Zm9saW9Ub29sdGlwV2FzU2hvd25JblRoaXNTZXNzaW9uKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5hcHBTdGF0ZS5wb3J0Zm9saW9Ub29sdGlwV2FzU2hvd25JblRoaXNTZXNzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlQ3VycmVuY3lTd2l0Y2goKSB7XG4gIHJldHVybiB7IHR5cGU6IGFjdGlvbkNvbnN0YW50cy5UT0dHTEVfQ1VSUkVOQ1lfSU5QVVRfU1dJVENIIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXROZXdDdXN0b21OZXR3b3JrQWRkZWQodmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLlNFVF9ORVdfQ1VTVE9NX05FVFdPUktfQURERUQsIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRPbkJvYXJkZWRJblRoaXNVSVNlc3Npb24odmFsdWUpIHtcbiAgcmV0dXJuIHsgdHlwZTogYWN0aW9uQ29uc3RhbnRzLk9OQk9BUkRFRF9JTl9USElTX1VJX1NFU1NJT04sIHZhbHVlIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXN0b21Ub2tlbkFtb3VudCh2YWx1ZSkge1xuICByZXR1cm4geyB0eXBlOiBhY3Rpb25Db25zdGFudHMuU0VUX0NVU1RPTV9UT0tFTl9BTU9VTlQsIHZhbHVlIH07XG59XG4iLCJpbXBvcnQgeyBjcmVhdGVTbGljZSB9IGZyb20gJ0ByZWR1eGpzL3Rvb2xraXQnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgbmV0d29ya01hcCBmcm9tICdldGhlcmV1bS1lbnMtbmV0d29yay1tYXAnO1xuaW1wb3J0IHsgaXNDb25mdXNpbmcgfSBmcm9tICd1bmljb2RlLWNvbmZ1c2FibGVzJztcbmltcG9ydCB7IGlzSGV4U3RyaW5nIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IGV0aGVycyB9IGZyb20gJ2V0aGVycyc7XG5cbmltcG9ydCB7IGdldEN1cnJlbnRDaGFpbklkIH0gZnJvbSAnLi4vc2VsZWN0b3JzJztcbmltcG9ydCB7XG4gIENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQLFxuICBORVRXT1JLX0lEUyxcbiAgTkVUV09SS19JRF9UT19FVEhFUlNfTkVUV09SS19OQU1FX01BUCxcbn0gZnJvbSAnLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcbmltcG9ydCB7XG4gIENPTkZVU0lOR19FTlNfRVJST1IsXG4gIEVOU19JTExFR0FMX0NIQVJBQ1RFUixcbiAgRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLLFxuICBFTlNfTk9UX1NVUFBPUlRFRF9PTl9ORVRXT1JLLFxuICBFTlNfTk9fQUREUkVTU19GT1JfTkFNRSxcbiAgRU5TX1JFR0lTVFJBVElPTl9FUlJPUixcbiAgRU5TX1VOS05PV05fRVJST1IsXG59IGZyb20gJy4uL3BhZ2VzL3NlbmQvc2VuZC5jb25zdGFudHMnO1xuaW1wb3J0IHsgaXNWYWxpZERvbWFpbk5hbWUgfSBmcm9tICcuLi9oZWxwZXJzL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHsgQ0hBSU5fQ0hBTkdFRCB9IGZyb20gJy4uL3N0b3JlL2FjdGlvbkNvbnN0YW50cyc7XG5pbXBvcnQge1xuICBCVVJOX0FERFJFU1MsXG4gIGlzQnVybkFkZHJlc3MsXG4gIGlzVmFsaWRIZXhBZGRyZXNzLFxufSBmcm9tICcuLi8uLi9zaGFyZWQvbW9kdWxlcy9oZXhzdHJpbmctdXRpbHMnO1xuXG4vLyBMb2NhbCBDb25zdGFudHNcbmNvbnN0IFpFUk9fWF9FUlJPUl9BRERSRVNTID0gJzB4JztcblxuY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICBzdGFnZTogJ1VOSU5JVElBTElaRUQnLFxuICByZXNvbHV0aW9uOiBudWxsLFxuICBlcnJvcjogbnVsbCxcbiAgd2FybmluZzogbnVsbCxcbiAgbmV0d29yazogbnVsbCxcbn07XG5cbmV4cG9ydCBjb25zdCBlbnNJbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGU7XG5cbmNvbnN0IG5hbWUgPSAnRU5TJztcblxubGV0IHdlYjNQcm92aWRlciA9IG51bGw7XG5cbmNvbnN0IHNsaWNlID0gY3JlYXRlU2xpY2Uoe1xuICBuYW1lLFxuICBpbml0aWFsU3RhdGUsXG4gIHJlZHVjZXJzOiB7XG4gICAgZW5zTG9va3VwOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgLy8gZmlyc3QgY2xlYXIgb3V0IHRoZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgc3RhdGUucmVzb2x1dGlvbiA9IG51bGw7XG4gICAgICBzdGF0ZS5lcnJvciA9IG51bGw7XG4gICAgICBzdGF0ZS53YXJuaW5nID0gbnVsbDtcbiAgICAgIGNvbnN0IHsgYWRkcmVzcywgZW5zTmFtZSwgZXJyb3IsIG5ldHdvcmsgfSA9IGFjdGlvbi5wYXlsb2FkO1xuXG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGlzVmFsaWREb21haW5OYW1lKGVuc05hbWUpICYmXG4gICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT0gJ0VOUyBuYW1lIG5vdCBkZWZpbmVkLidcbiAgICAgICAgKSB7XG4gICAgICAgICAgc3RhdGUuZXJyb3IgPVxuICAgICAgICAgICAgbmV0d29yayA9PT0gTkVUV09SS19JRFMuTUFJTk5FVFxuICAgICAgICAgICAgICA/IEVOU19OT19BRERSRVNTX0ZPUl9OQU1FXG4gICAgICAgICAgICAgIDogRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLO1xuICAgICAgICB9IGVsc2UgaWYgKGVycm9yLm1lc3NhZ2UgPT09ICdJbGxlZ2FsIGNoYXJhY3RlciBmb3IgRU5TLicpIHtcbiAgICAgICAgICBzdGF0ZS5lcnJvciA9IEVOU19JTExFR0FMX0NIQVJBQ1RFUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2cuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgIHN0YXRlLmVycm9yID0gRU5TX1VOS05PV05fRVJST1I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyA9PT0gQlVSTl9BRERSRVNTKSB7XG4gICAgICAgICAgc3RhdGUuZXJyb3IgPSBFTlNfTk9fQUREUkVTU19GT1JfTkFNRTtcbiAgICAgICAgfSBlbHNlIGlmIChhZGRyZXNzID09PSBaRVJPX1hfRVJST1JfQUREUkVTUykge1xuICAgICAgICAgIHN0YXRlLmVycm9yID0gRU5TX1JFR0lTVFJBVElPTl9FUlJPUjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZS5yZXNvbHV0aW9uID0gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNWYWxpZERvbWFpbk5hbWUoYWRkcmVzcykgJiYgaXNDb25mdXNpbmcoYWRkcmVzcykpIHtcbiAgICAgICAgICBzdGF0ZS53YXJuaW5nID0gQ09ORlVTSU5HX0VOU19FUlJPUjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUuZXJyb3IgPSBFTlNfTk9fQUREUkVTU19GT1JfTkFNRTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVuYWJsZUVuc0xvb2t1cDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLnN0YWdlID0gJ0lOSVRJQUxJWkVEJztcbiAgICAgIHN0YXRlLmVycm9yID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlc29sdXRpb24gPSBudWxsO1xuICAgICAgc3RhdGUud2FybmluZyA9IG51bGw7XG4gICAgICBzdGF0ZS5uZXR3b3JrID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcbiAgICBkaXNhYmxlRW5zTG9va3VwOiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLnN0YWdlID0gJ05PX05FVFdPUktfU1VQUE9SVCc7XG4gICAgICBzdGF0ZS5lcnJvciA9IG51bGw7XG4gICAgICBzdGF0ZS53YXJuaW5nID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlc29sdXRpb24gPSBudWxsO1xuICAgICAgc3RhdGUubmV0d29yayA9IG51bGw7XG4gICAgfSxcbiAgICBlbnNOb3RTdXBwb3J0ZWQ6IChzdGF0ZSkgPT4ge1xuICAgICAgc3RhdGUucmVzb2x1dGlvbiA9IG51bGw7XG4gICAgICBzdGF0ZS53YXJuaW5nID0gbnVsbDtcbiAgICAgIHN0YXRlLmVycm9yID0gRU5TX05PVF9TVVBQT1JURURfT05fTkVUV09SSztcbiAgICB9LFxuICAgIHJlc2V0RW5zUmVzb2x1dGlvbjogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5yZXNvbHV0aW9uID0gbnVsbDtcbiAgICAgIHN0YXRlLndhcm5pbmcgPSBudWxsO1xuICAgICAgc3RhdGUuZXJyb3IgPSBudWxsO1xuICAgIH0sXG4gIH0sXG4gIGV4dHJhUmVkdWNlcnM6IChidWlsZGVyKSA9PiB7XG4gICAgYnVpbGRlci5hZGRDYXNlKENIQUlOX0NIQU5HRUQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoYWN0aW9uLnBheWxvYWQgIT09IHN0YXRlLmN1cnJlbnRDaGFpbklkKSB7XG4gICAgICAgIHN0YXRlLnN0YWdlID0gJ1VOSU5JVElBTElaRUQnO1xuICAgICAgICB3ZWIzUHJvdmlkZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxufSk7XG5cbmNvbnN0IHsgcmVkdWNlciwgYWN0aW9ucyB9ID0gc2xpY2U7XG5leHBvcnQgZGVmYXVsdCByZWR1Y2VyO1xuXG5jb25zdCB7XG4gIGRpc2FibGVFbnNMb29rdXAsXG4gIGVuc0xvb2t1cCxcbiAgZW5hYmxlRW5zTG9va3VwLFxuICBlbnNOb3RTdXBwb3J0ZWQsXG4gIHJlc2V0RW5zUmVzb2x1dGlvbixcbn0gPSBhY3Rpb25zO1xuZXhwb3J0IHsgcmVzZXRFbnNSZXNvbHV0aW9uIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplRW5zU2xpY2UoKSB7XG4gIHJldHVybiAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSk7XG4gICAgY29uc3QgbmV0d29yayA9IENIQUlOX0lEX1RPX05FVFdPUktfSURfTUFQW2NoYWluSWRdO1xuICAgIGNvbnN0IG5ldHdvcmtOYW1lID0gTkVUV09SS19JRF9UT19FVEhFUlNfTkVUV09SS19OQU1FX01BUFtuZXR3b3JrXTtcbiAgICBjb25zdCBlbnNBZGRyZXNzID0gbmV0d29ya01hcFtuZXR3b3JrXTtcbiAgICBjb25zdCBuZXR3b3JrSXNTdXBwb3J0ZWQgPSBCb29sZWFuKGVuc0FkZHJlc3MpO1xuICAgIGlmIChuZXR3b3JrSXNTdXBwb3J0ZWQpIHtcbiAgICAgIHdlYjNQcm92aWRlciA9IG5ldyBldGhlcnMucHJvdmlkZXJzLldlYjNQcm92aWRlcihcbiAgICAgICAgZ2xvYmFsLmV0aGVyZXVtUHJvdmlkZXIsXG4gICAgICAgIHtcbiAgICAgICAgICBjaGFpbklkOiBwYXJzZUludChuZXR3b3JrLCAxMCksXG4gICAgICAgICAgbmFtZTogbmV0d29ya05hbWUsXG4gICAgICAgICAgZW5zQWRkcmVzcyxcbiAgICAgICAgfSxcbiAgICAgICk7XG4gICAgICBkaXNwYXRjaChlbmFibGVFbnNMb29rdXAobmV0d29yaykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3ZWIzUHJvdmlkZXIgPSBudWxsO1xuICAgICAgZGlzcGF0Y2goZGlzYWJsZUVuc0xvb2t1cCgpKTtcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXBFbnNOYW1lKGVuc05hbWUpIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCB0cmltbWVkRW5zTmFtZSA9IGVuc05hbWUudHJpbSgpO1xuICAgIGxldCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgaWYgKHN0YXRlW25hbWVdLnN0YWdlID09PSAnVU5JTklUSUFMSVpFRCcpIHtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGluaXRpYWxpemVFbnNTbGljZSgpKTtcbiAgICB9XG4gICAgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGlmIChcbiAgICAgIHN0YXRlW25hbWVdLnN0YWdlID09PSAnTk9fTkVUV09SS19TVVBQT1JUJyAmJlxuICAgICAgIShcbiAgICAgICAgaXNCdXJuQWRkcmVzcyh0cmltbWVkRW5zTmFtZSkgPT09IGZhbHNlICYmXG4gICAgICAgIGlzVmFsaWRIZXhBZGRyZXNzKHRyaW1tZWRFbnNOYW1lLCB7IG1peGVkQ2FzZVVzZUNoZWNrc3VtOiB0cnVlIH0pXG4gICAgICApICYmXG4gICAgICAhaXNIZXhTdHJpbmcodHJpbW1lZEVuc05hbWUpXG4gICAgKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChlbnNOb3RTdXBwb3J0ZWQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxvZy5pbmZvKGBFTlMgYXR0ZW1wdGluZyB0byByZXNvbHZlIG5hbWU6ICR7dHJpbW1lZEVuc05hbWV9YCk7XG4gICAgICBsZXQgYWRkcmVzcztcbiAgICAgIGxldCBlcnJvcjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHRoZSB3cml0YWJsZSBwcm9wZXJ0eSBvbiB0aGUgJ3Byb3ZpZGVyJyBvYmplY3Qgb24gdGhlICd3ZWIzUHJvdmlkZXInIGZsaXBzIHRvIGZhbHNlIHdoZW4gc3RhbGVcbiAgICAgICAgLy8gVGhpcyBoZWxwcyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHByb3ZpZGVyIGlzIGJlY29tZXMgdW5yZXNwb25zaXZlIGlmL3doZW4sIGluIE1WMywgdGhlIHNlcnZpY2Ugd29ya2VyIGRpZXMgYWZ0ZXIgdGhlIEVOUyBzbGljZSBpcyBpbnN0YW50aWF0ZWRcbiAgICAgICAgY29uc3QgaXNQcm92aWRlckFjdGl2ZSA9IHdlYjNQcm92aWRlci5wcm92aWRlcj8ud3JpdGFibGU7XG4gICAgICAgIGlmICghaXNQcm92aWRlckFjdGl2ZSkge1xuICAgICAgICAgIGF3YWl0IGRpc3BhdGNoKGluaXRpYWxpemVFbnNTbGljZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRyZXNzID0gYXdhaXQgd2ViM1Byb3ZpZGVyLnJlc29sdmVOYW1lKHRyaW1tZWRFbnNOYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSk7XG4gICAgICBjb25zdCBuZXR3b3JrID0gQ0hBSU5fSURfVE9fTkVUV09SS19JRF9NQVBbY2hhaW5JZF07XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgZW5zTG9va3VwKHtcbiAgICAgICAgICBlbnNOYW1lOiB0cmltbWVkRW5zTmFtZSxcbiAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgbmV0d29yayxcbiAgICAgICAgfSksXG4gICAgICApO1xuICAgIH1cbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVuc1Jlc29sdXRpb24oc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLnJlc29sdXRpb247XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnNFcnJvcihzdGF0ZSkge1xuICByZXR1cm4gc3RhdGVbbmFtZV0uZXJyb3I7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnNXYXJuaW5nKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZVtuYW1lXS53YXJuaW5nO1xufVxuIiwiLy8gVGhpcyBmaWxlIGhhcyBiZWVuIHNlcGFyYXRlZCBiZWNhdXNlIGl0IGlzIHJlcXVpcmVkIGluIGJvdGggdGhlIGdhcyBhbmQgc2VuZFxyXG4vLyBzbGljZXMuIFRoaXMgY3JlYXRlZCBhIGNpcmN1bGFyIGRlcGVuZGVuY3kgcHJvYmxlbSBhcyBib3RoIHNsaWNlcyBhbHNvXHJcbi8vIGltcG9ydCBmcm9tIHRoZSBhY3Rpb25zIGFuZCBzZWxlY3RvcnMgZmlsZXMuIFRoaXMgZWFzaWVzdCBwYXRoIGZvclxyXG4vLyB1bnRhbmdsaW5nIGlzIGhhdmluZyB0aGUgY29uc3RhbnRzIHNlcGFyYXRlLlxyXG5cclxuLy8gQWN0aW9uc1xyXG5leHBvcnQgY29uc3QgUkVTRVRfQ1VTVE9NX0RBVEEgPSAnbWV0YW1hc2svZ2FzL1JFU0VUX0NVU1RPTV9EQVRBJztcclxuZXhwb3J0IGNvbnN0IFNFVF9DVVNUT01fR0FTX0xJTUlUID0gJ21ldGFtYXNrL2dhcy9TRVRfQ1VTVE9NX0dBU19MSU1JVCc7XHJcbmV4cG9ydCBjb25zdCBTRVRfQ1VTVE9NX0dBU19QUklDRSA9ICdtZXRhbWFzay9nYXMvU0VUX0NVU1RPTV9HQVNfUFJJQ0UnO1xyXG4iLCJpbXBvcnQgeyBjbG9uZURlZXAgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHtcbiAgUkVTRVRfQ1VTVE9NX0RBVEEsXG4gIFNFVF9DVVNUT01fR0FTX0xJTUlULFxuICBTRVRfQ1VTVE9NX0dBU19QUklDRSxcbn0gZnJvbSAnLi9nYXMtYWN0aW9uLWNvbnN0YW50cyc7XG5cbmNvbnN0IGluaXRTdGF0ZSA9IHtcbiAgY3VzdG9tRGF0YToge1xuICAgIHByaWNlOiBudWxsLFxuICAgIGxpbWl0OiBudWxsLFxuICB9LFxufTtcblxuLy8gUmVkdWNlclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVkdWNlcihzdGF0ZSA9IGluaXRTdGF0ZSwgYWN0aW9uKSB7XG4gIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICBjYXNlIFNFVF9DVVNUT01fR0FTX1BSSUNFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGN1c3RvbURhdGE6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5jdXN0b21EYXRhLFxuICAgICAgICAgIHByaWNlOiBhY3Rpb24udmFsdWUsXG4gICAgICAgIH0sXG4gICAgICB9O1xuICAgIGNhc2UgU0VUX0NVU1RPTV9HQVNfTElNSVQ6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgY3VzdG9tRGF0YToge1xuICAgICAgICAgIC4uLnN0YXRlLmN1c3RvbURhdGEsXG4gICAgICAgICAgbGltaXQ6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG4gICAgY2FzZSBSRVNFVF9DVVNUT01fREFUQTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBjdXN0b21EYXRhOiBjbG9uZURlZXAoaW5pdFN0YXRlLmN1c3RvbURhdGEpLFxuICAgICAgfTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHN0YXRlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRDdXN0b21HYXNQcmljZShuZXdQcmljZSkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFNFVF9DVVNUT01fR0FTX1BSSUNFLFxuICAgIHZhbHVlOiBuZXdQcmljZSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEN1c3RvbUdhc0xpbWl0KG5ld0xpbWl0KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogU0VUX0NVU1RPTV9HQVNfTElNSVQsXG4gICAgdmFsdWU6IG5ld0xpbWl0LFxuICB9O1xufVxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4LCBpc0hleFN0cmluZyB9IGZyb20gJ2V0aGVyZXVtanMtdXRpbCc7XG5pbXBvcnQgKiBhcyBhY3Rpb25Db25zdGFudHMgZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9uQ29uc3RhbnRzJztcbmltcG9ydCB7IEFMRVJUX1RZUEVTIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hbGVydHMnO1xuaW1wb3J0IHtcbiAgR0FTX0VTVElNQVRFX1RZUEVTLFxuICBORVRXT1JLX0NPTkdFU1RJT05fVEhSRVNIT0xEUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xuaW1wb3J0IHsgTkVUV09SS19UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICBhY2NvdW50c1dpdGhTZW5kRXRoZXJJbmZvU2VsZWN0b3IsXG4gIGNoZWNrTmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTksXG4gIGdldEFkZHJlc3NCb29rLFxufSBmcm9tICcuLi8uLi9zZWxlY3RvcnMnO1xuaW1wb3J0IHsgdXBkYXRlVHJhbnNhY3Rpb25HYXNGZWVzIH0gZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgeyBzZXRDdXN0b21HYXNMaW1pdCwgc2V0Q3VzdG9tR2FzUHJpY2UgfSBmcm9tICcuLi9nYXMvZ2FzLmR1Y2snO1xuaW1wb3J0IHsgZGVjR1dFSVRvSGV4V0VJIH0gZnJvbSAnLi4vLi4vaGVscGVycy91dGlscy9jb252ZXJzaW9ucy51dGlsJztcblxuaW1wb3J0IHsgS0VZUklOR19UWVBFUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvaGFyZHdhcmUtd2FsbGV0cyc7XG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvc3RyaW5nLXV0aWxzJztcbmltcG9ydCB7IHN0cmlwSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVkdWNlTWV0YW1hc2soc3RhdGUgPSB7fSwgYWN0aW9uKSB7XG4gIGNvbnN0IG1ldGFtYXNrU3RhdGUgPSB7XG4gICAgaXNJbml0aWFsaXplZDogZmFsc2UsXG4gICAgaXNVbmxvY2tlZDogZmFsc2UsXG4gICAgaXNBY2NvdW50TWVudU9wZW46IGZhbHNlLFxuICAgIGlkZW50aXRpZXM6IHt9LFxuICAgIHVuYXBwcm92ZWRUeHM6IHt9LFxuICAgIGZyZXF1ZW50UnBjTGlzdDogW10sXG4gICAgYWRkcmVzc0Jvb2s6IFtdLFxuICAgIGNvbnRyYWN0RXhjaGFuZ2VSYXRlczoge30sXG4gICAgcGVuZGluZ1Rva2Vuczoge30sXG4gICAgY3VzdG9tTm9uY2VWYWx1ZTogJycsXG4gICAgdXNlQmxvY2tpZTogZmFsc2UsXG4gICAgZmVhdHVyZUZsYWdzOiB7fSxcbiAgICB3ZWxjb21lU2NyZWVuU2VlbjogZmFsc2UsXG4gICAgY3VycmVudExvY2FsZTogJycsXG4gICAgY3VycmVudEJsb2NrR2FzTGltaXQ6ICcnLFxuICAgIHByZWZlcmVuY2VzOiB7XG4gICAgICBhdXRvTG9ja1RpbWVMaW1pdDogdW5kZWZpbmVkLFxuICAgICAgc2hvd0ZpYXRJblRlc3RuZXRzOiBmYWxzZSxcbiAgICAgIHNob3dUZXN0TmV0d29ya3M6IGZhbHNlLFxuICAgICAgdXNlTmF0aXZlQ3VycmVuY3lBc1ByaW1hcnlDdXJyZW5jeTogdHJ1ZSxcbiAgICB9LFxuICAgIGZpcnN0VGltZUZsb3dUeXBlOiBudWxsLFxuICAgIGNvbXBsZXRlZE9uYm9hcmRpbmc6IGZhbHNlLFxuICAgIGtub3duTWV0aG9kRGF0YToge30sXG4gICAgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOiBudWxsLFxuICAgIG5leHROb25jZTogbnVsbCxcbiAgICBjb252ZXJzaW9uUmF0ZTogbnVsbCxcbiAgICBuYXRpdmVDdXJyZW5jeTogJ0VUSCcsXG4gICAgLi4uc3RhdGUsXG4gIH07XG5cbiAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlVQREFURV9NRVRBTUFTS19TVEFURTpcbiAgICAgIHJldHVybiB7IC4uLm1ldGFtYXNrU3RhdGUsIC4uLmFjdGlvbi52YWx1ZSB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuTE9DS19NRVRBTUFTSzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIGlzVW5sb2NrZWQ6IGZhbHNlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9SUENfVEFSR0VUOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcHJvdmlkZXI6IHtcbiAgICAgICAgICB0eXBlOiBORVRXT1JLX1RZUEVTLlJQQyxcbiAgICAgICAgICBycGNVcmw6IGFjdGlvbi52YWx1ZSxcbiAgICAgICAgfSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfUFJPVklERVJfVFlQRTpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIHByb3ZpZGVyOiB7XG4gICAgICAgICAgdHlwZTogYWN0aW9uLnZhbHVlLFxuICAgICAgICB9LFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNIT1dfQUNDT1VOVF9ERVRBSUw6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBpc1VubG9ja2VkOiB0cnVlLFxuICAgICAgICBpc0luaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICBzZWxlY3RlZEFkZHJlc3M6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfQUNDT1VOVF9MQUJFTDoge1xuICAgICAgY29uc3QgeyBhY2NvdW50IH0gPSBhY3Rpb24udmFsdWU7XG4gICAgICBjb25zdCBuYW1lID0gYWN0aW9uLnZhbHVlLmxhYmVsO1xuICAgICAgY29uc3QgaWQgPSB7fTtcbiAgICAgIGlkW2FjY291bnRdID0geyAuLi5tZXRhbWFza1N0YXRlLmlkZW50aXRpZXNbYWNjb3VudF0sIG5hbWUgfTtcbiAgICAgIGNvbnN0IGlkZW50aXRpZXMgPSB7IC4uLm1ldGFtYXNrU3RhdGUuaWRlbnRpdGllcywgLi4uaWQgfTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG1ldGFtYXNrU3RhdGUsIHsgaWRlbnRpdGllcyB9KTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5VUERBVEVfQ1VTVE9NX05PTkNFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgY3VzdG9tTm9uY2VWYWx1ZTogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlRPR0dMRV9BQ0NPVU5UX01FTlU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBpc0FjY291bnRNZW51T3BlbjogIW1ldGFtYXNrU3RhdGUuaXNBY2NvdW50TWVudU9wZW4sXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuVVBEQVRFX1RSQU5TQUNUSU9OX1BBUkFNUzoge1xuICAgICAgY29uc3QgeyBpZDogdHhJZCwgdmFsdWUgfSA9IGFjdGlvbjtcbiAgICAgIGxldCB7IGN1cnJlbnROZXR3b3JrVHhMaXN0IH0gPSBtZXRhbWFza1N0YXRlO1xuICAgICAgY3VycmVudE5ldHdvcmtUeExpc3QgPSBjdXJyZW50TmV0d29ya1R4TGlzdC5tYXAoKHR4KSA9PiB7XG4gICAgICAgIGlmICh0eC5pZCA9PT0gdHhJZCkge1xuICAgICAgICAgIGNvbnN0IG5ld1R4ID0geyAuLi50eCB9O1xuICAgICAgICAgIG5ld1R4LnR4UGFyYW1zID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG5ld1R4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBjdXJyZW50TmV0d29ya1R4TGlzdCxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0VUX1BBUlRJQ0lQQVRFX0lOX01FVEFNRVRSSUNTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcGFydGljaXBhdGVJbk1ldGFNZXRyaWNzOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuU0VUX1VTRV9CTE9DS0lFOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgdXNlQmxvY2tpZTogYWN0aW9uLnZhbHVlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlVQREFURV9GRUFUVVJFX0ZMQUdTOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgZmVhdHVyZUZsYWdzOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuXG4gICAgY2FzZSBhY3Rpb25Db25zdGFudHMuQ0xPU0VfV0VMQ09NRV9TQ1JFRU46XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICB3ZWxjb21lU2NyZWVuU2VlbjogdHJ1ZSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfQ1VSUkVOVF9MT0NBTEU6XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBjdXJyZW50TG9jYWxlOiBhY3Rpb24udmFsdWUubG9jYWxlLFxuICAgICAgfTtcblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9QRU5ESU5HX1RPS0VOUzpcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIHBlbmRpbmdUb2tlbnM6IHsgLi4uYWN0aW9uLnBheWxvYWQgfSxcbiAgICAgIH07XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5DTEVBUl9QRU5ESU5HX1RPS0VOUzoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcGVuZGluZ1Rva2Vuczoge30sXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlVQREFURV9QUkVGRVJFTkNFUzoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ubWV0YW1hc2tTdGF0ZSxcbiAgICAgICAgcHJlZmVyZW5jZXM6IHtcbiAgICAgICAgICAuLi5tZXRhbWFza1N0YXRlLnByZWZlcmVuY2VzLFxuICAgICAgICAgIC4uLmFjdGlvbi5wYXlsb2FkLFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5DT01QTEVURV9PTkJPQVJESU5HOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBjb21wbGV0ZWRPbmJvYXJkaW5nOiB0cnVlLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjYXNlIGFjdGlvbkNvbnN0YW50cy5TRVRfRklSU1RfVElNRV9GTE9XX1RZUEU6IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGFtYXNrU3RhdGUsXG4gICAgICAgIGZpcnN0VGltZUZsb3dUeXBlOiBhY3Rpb24udmFsdWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNhc2UgYWN0aW9uQ29uc3RhbnRzLlNFVF9ORVhUX05PTkNFOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5tZXRhbWFza1N0YXRlLFxuICAgICAgICBuZXh0Tm9uY2U6IGFjdGlvbi52YWx1ZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBtZXRhbWFza1N0YXRlO1xuICB9XG59XG5cbmNvbnN0IHRvSGV4V2VpID0gKHZhbHVlLCBleHBlY3RIZXhXZWkpID0+IHtcbiAgcmV0dXJuIGFkZEhleFByZWZpeChleHBlY3RIZXhXZWkgPyB2YWx1ZSA6IGRlY0dXRUlUb0hleFdFSSh2YWx1ZSkpO1xufTtcblxuLy8gQWN0aW9uIENyZWF0b3JzXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlR2FzRmVlcyh7XG4gIGdhc1ByaWNlLFxuICBnYXNMaW1pdCxcbiAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gIG1heEZlZVBlckdhcyxcbiAgdHJhbnNhY3Rpb24sXG4gIGV4cGVjdEhleFdlaSA9IGZhbHNlLFxufSkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XG4gICAgY29uc3QgdHhQYXJhbXNDb3B5ID0geyAuLi50cmFuc2FjdGlvbi50eFBhcmFtcywgZ2FzOiBnYXNMaW1pdCB9O1xuICAgIGlmIChnYXNQcmljZSkge1xuICAgICAgZGlzcGF0Y2goXG4gICAgICAgIHNldEN1c3RvbUdhc1ByaWNlKHRvSGV4V2VpKHR4UGFyYW1zQ29weS5nYXNQcmljZSwgZXhwZWN0SGV4V2VpKSksXG4gICAgICApO1xuICAgICAgdHhQYXJhbXNDb3B5Lmdhc1ByaWNlID0gdG9IZXhXZWkoZ2FzUHJpY2UsIGV4cGVjdEhleFdlaSk7XG4gICAgfSBlbHNlIGlmIChtYXhGZWVQZXJHYXMgJiYgbWF4UHJpb3JpdHlGZWVQZXJHYXMpIHtcbiAgICAgIHR4UGFyYW1zQ29weS5tYXhGZWVQZXJHYXMgPSB0b0hleFdlaShtYXhGZWVQZXJHYXMsIGV4cGVjdEhleFdlaSk7XG4gICAgICB0eFBhcmFtc0NvcHkubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBhZGRIZXhQcmVmaXgoXG4gICAgICAgIGRlY0dXRUlUb0hleFdFSShtYXhQcmlvcml0eUZlZVBlckdhcyksXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCB1cGRhdGVkVHggPSB7XG4gICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgIHR4UGFyYW1zOiB0eFBhcmFtc0NvcHksXG4gICAgfTtcblxuICAgIGNvbnN0IGN1c3RvbUdhc0xpbWl0ID0gaXNIZXhTdHJpbmcoYWRkSGV4UHJlZml4KGdhc0xpbWl0KSlcbiAgICAgID8gYWRkSGV4UHJlZml4KGdhc0xpbWl0KVxuICAgICAgOiBhZGRIZXhQcmVmaXgoZ2FzTGltaXQudG9TdHJpbmcoMTYpKTtcbiAgICBkaXNwYXRjaChzZXRDdXN0b21HYXNMaW1pdChjdXN0b21HYXNMaW1pdCkpO1xuICAgIGF3YWl0IGRpc3BhdGNoKHVwZGF0ZVRyYW5zYWN0aW9uR2FzRmVlcyh1cGRhdGVkVHguaWQsIHVwZGF0ZWRUeCkpO1xuICB9O1xufVxuXG4vLyBTZWxlY3RvcnNcblxuZXhwb3J0IGNvbnN0IGdldEN1cnJlbnRMb2NhbGUgPSAoc3RhdGUpID0+IHN0YXRlLm1ldGFtYXNrLmN1cnJlbnRMb2NhbGU7XG5cbmV4cG9ydCBjb25zdCBnZXRBbGVydEVuYWJsZWRuZXNzID0gKHN0YXRlKSA9PiBzdGF0ZS5tZXRhbWFzay5hbGVydEVuYWJsZWRuZXNzO1xuXG5leHBvcnQgY29uc3QgZ2V0VW5jb25uZWN0ZWRBY2NvdW50QWxlcnRFbmFibGVkbmVzcyA9IChzdGF0ZSkgPT5cbiAgZ2V0QWxlcnRFbmFibGVkbmVzcyhzdGF0ZSlbQUxFUlRfVFlQRVMudW5jb25uZWN0ZWRBY2NvdW50XTtcblxuZXhwb3J0IGNvbnN0IGdldFdlYjNTaGltVXNhZ2VBbGVydEVuYWJsZWRuZXNzID0gKHN0YXRlKSA9PlxuICBnZXRBbGVydEVuYWJsZWRuZXNzKHN0YXRlKVtBTEVSVF9UWVBFUy53ZWIzU2hpbVVzYWdlXTtcblxuZXhwb3J0IGNvbnN0IGdldFVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd24gPSAoc3RhdGUpID0+XG4gIHN0YXRlLm1ldGFtYXNrLnVuY29ubmVjdGVkQWNjb3VudEFsZXJ0U2hvd25PcmlnaW5zO1xuXG5leHBvcnQgY29uc3QgZ2V0UGVuZGluZ1Rva2VucyA9IChzdGF0ZSkgPT4gc3RhdGUubWV0YW1hc2sucGVuZGluZ1Rva2VucztcblxuZXhwb3J0IGNvbnN0IGdldFRva2VucyA9IChzdGF0ZSkgPT4gc3RhdGUubWV0YW1hc2sudG9rZW5zO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29sbGVjdGlibGVzRGV0ZWN0aW9uTm90aWNlRGlzbWlzc2VkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5jb2xsZWN0aWJsZXNEZXRlY3Rpb25Ob3RpY2VEaXNtaXNzZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5jb2xsZWN0aWJsZXNEcm9wZG93blN0YXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RW5hYmxlRUlQMTU1OVYyTm90aWNlRGlzbWlzc2VkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5lbmFibGVFSVAxNTU5VjJOb3RpY2VEaXNtaXNzZWQ7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb2xsZWN0aWJsZXMgPSAoc3RhdGUpID0+IHtcbiAgY29uc3Qge1xuICAgIG1ldGFtYXNrOiB7XG4gICAgICBhbGxDb2xsZWN0aWJsZXMsXG4gICAgICBwcm92aWRlcjogeyBjaGFpbklkIH0sXG4gICAgICBzZWxlY3RlZEFkZHJlc3MsXG4gICAgfSxcbiAgfSA9IHN0YXRlO1xuXG4gIHJldHVybiBhbGxDb2xsZWN0aWJsZXM/LltzZWxlY3RlZEFkZHJlc3NdPy5bY2hhaW5JZF0gPz8gW107XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q29sbGVjdGlibGVDb250cmFjdHMgPSAoc3RhdGUpID0+IHtcbiAgY29uc3Qge1xuICAgIG1ldGFtYXNrOiB7XG4gICAgICBhbGxDb2xsZWN0aWJsZUNvbnRyYWN0cyxcbiAgICAgIHByb3ZpZGVyOiB7IGNoYWluSWQgfSxcbiAgICAgIHNlbGVjdGVkQWRkcmVzcyxcbiAgICB9LFxuICB9ID0gc3RhdGU7XG5cbiAgcmV0dXJuIGFsbENvbGxlY3RpYmxlQ29udHJhY3RzPy5bc2VsZWN0ZWRBZGRyZXNzXT8uW2NoYWluSWRdID8/IFtdO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJsb2NrR2FzTGltaXQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLmN1cnJlbnRCbG9ja0dhc0xpbWl0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udmVyc2lvblJhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLmNvbnZlcnNpb25SYXRlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmF0aXZlQ3VycmVuY3koc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLm5hdGl2ZUN1cnJlbmN5O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VuZEhleERhdGFGZWF0dXJlRmxhZ1N0YXRlKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5mZWF0dXJlRmxhZ3Muc2VuZEhleERhdGE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kVG9BY2NvdW50cyhzdGF0ZSkge1xuICBjb25zdCBmcm9tQWNjb3VudHMgPSBhY2NvdW50c1dpdGhTZW5kRXRoZXJJbmZvU2VsZWN0b3Ioc3RhdGUpO1xuICBjb25zdCBhZGRyZXNzQm9va0FjY291bnRzID0gZ2V0QWRkcmVzc0Jvb2soc3RhdGUpO1xuICByZXR1cm4gWy4uLmZyb21BY2NvdW50cywgLi4uYWRkcmVzc0Jvb2tBY2NvdW50c107XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmFwcHJvdmVkVHhzKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay51bmFwcHJvdmVkVHhzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybnMgdHJ1ZSBpZiBuZXR3b3JrIGRldGFpbHMgYXJlIGZldGNoZWQgYW5kIGl0IGlzIGZvdW5kIHRvIG5vdCBzdXBwb3J0IEVJUC0xNTU5XG4gKlxuICogQHBhcmFtIHN0YXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc05vdEVJUDE1NTlOZXR3b3JrKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5uZXR3b3JrRGV0YWlscz8uRUlQU1sxNTU5XSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJucyB0cnVlIGlmIG5ldHdvcmsgZGV0YWlscyBhcmUgZmV0Y2hlZCBhbmQgaXQgaXMgZm91bmQgdG8gc3VwcG9ydCBFSVAtMTU1OVxuICpcbiAqIEBwYXJhbSBzdGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFSVAxNTU5TmV0d29yayhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2submV0d29ya0RldGFpbHM/LkVJUFNbMTU1OV0gPT09IHRydWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRHYXNFc3RpbWF0ZVR5cGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLm1ldGFtYXNrLmdhc0VzdGltYXRlVHlwZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEdhc0ZlZUVzdGltYXRlcyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suZ2FzRmVlRXN0aW1hdGVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suZXN0aW1hdGVkR2FzRmVlVGltZUJvdW5kcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldElzR2FzRXN0aW1hdGVzTG9hZGluZyhzdGF0ZSkge1xuICBjb25zdCBuZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OSA9XG4gICAgY2hlY2tOZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OShzdGF0ZSk7XG4gIGNvbnN0IGdhc0VzdGltYXRlVHlwZSA9IGdldEdhc0VzdGltYXRlVHlwZShzdGF0ZSk7XG5cbiAgLy8gV2UgY29uc2lkZXIgdGhlIGdhcyBlc3RpbWF0ZSB0byBiZSBsb2FkaW5nIGlmIHRoZSBnYXNFc3RpbWF0ZVR5cGUgaXNcbiAgLy8gJ05PTkUnIG9yIGlmIHRoZSBjdXJyZW50IGdhc0VzdGltYXRlVHlwZSBjYW5ub3QgYmUgc3VwcG9ydGVkIGJ5IHRoZSBjdXJyZW50XG4gIC8vIG5ldHdvcmtcbiAgY29uc3QgaXNFSVAxNTU5VG9sZXJhYmxlRXN0aW1hdGVUeXBlID1cbiAgICBnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VUIHx8XG4gICAgZ2FzRXN0aW1hdGVUeXBlID09PSBHQVNfRVNUSU1BVEVfVFlQRVMuRVRIX0dBU1BSSUNFO1xuICBjb25zdCBpc0dhc0VzdGltYXRlc0xvYWRpbmcgPVxuICAgIGdhc0VzdGltYXRlVHlwZSA9PT0gR0FTX0VTVElNQVRFX1RZUEVTLk5PTkUgfHxcbiAgICAobmV0d29ya0FuZEFjY291bnRTdXBwb3J0czE1NTkgJiYgIWlzRUlQMTU1OVRvbGVyYWJsZUVzdGltYXRlVHlwZSkgfHxcbiAgICAoIW5ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5ICYmXG4gICAgICBnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5GRUVfTUFSS0VUKTtcblxuICByZXR1cm4gaXNHYXNFc3RpbWF0ZXNMb2FkaW5nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNOZXR3b3JrQnVzeShzdGF0ZSkge1xuICBjb25zdCBnYXNGZWVFc3RpbWF0ZXMgPSBnZXRHYXNGZWVFc3RpbWF0ZXMoc3RhdGUpO1xuICByZXR1cm4gKFxuICAgIGdhc0ZlZUVzdGltYXRlcz8ubmV0d29ya0Nvbmdlc3Rpb24gPj0gTkVUV09SS19DT05HRVNUSU9OX1RIUkVTSE9MRFMuQlVTWVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcGxldGVkT25ib2FyZGluZyhzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suY29tcGxldGVkT25ib2FyZGluZztcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc0luaXRpYWxpemVkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5pc0luaXRpYWxpemVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNVbmxvY2tlZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suaXNVbmxvY2tlZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlZWRQaHJhc2VCYWNrZWRVcChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2suc2VlZFBocmFzZUJhY2tlZFVwO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSByZWR1eCBzdGF0ZSBvYmplY3QgYW5kIGFuIGFkZHJlc3MsIGZpbmRzIGEga2V5cmluZyB0aGF0IGNvbnRhaW5zIHRoYXQgYWRkcmVzcywgaWYgb25lIGV4aXN0c1xuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIHRoZSByZWR1eCBzdGF0ZSBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gdGhlIGFkZHJlc3MgdG8gc2VhcmNoIGZvciBhbW9uZyB0aGUga2V5cmluZyBhZGRyZXNzZXNcbiAqIEByZXR1cm5zIHtvYmplY3QgfCB1bmRlZmluZWR9IFRoZSBrZXlyaW5nIHdoaWNoIGNvbnRhaW5zIHRoZSBwYXNzZWQgYWRkcmVzcywgb3IgdW5kZWZpbmVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kS2V5cmluZ0ZvckFkZHJlc3Moc3RhdGUsIGFkZHJlc3MpIHtcbiAgY29uc3Qga2V5cmluZyA9IHN0YXRlLm1ldGFtYXNrLmtleXJpbmdzLmZpbmQoKGtyKSA9PiB7XG4gICAgcmV0dXJuIGtyLmFjY291bnRzLnNvbWUoKGFjY291bnQpID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGlzRXF1YWxDYXNlSW5zZW5zaXRpdmUoYWNjb3VudCwgYWRkSGV4UHJlZml4KGFkZHJlc3MpKSB8fFxuICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGFjY291bnQsIHN0cmlwSGV4UHJlZml4KGFkZHJlc3MpKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGtleXJpbmc7XG59XG5cbi8qKlxuICogR2l2ZW4gdGhlIHJlZHV4IHN0YXRlIG9iamVjdCwgcmV0dXJucyB0aGUgdXNlcnMgcHJlZmVycmVkIGxlZGdlciB0cmFuc3BvcnQgdHlwZVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIHRoZSByZWR1eCBzdGF0ZSBvYmplY3RcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB1c2VycyBwcmVmZXJyZWQgbGVkZ2VyIHRyYW5zcG9ydCB0eXBlLiBPbmUgb2YnbGVkZ2VyTGl2ZScsICd3ZWJoaWQnIG9yICd1MmYnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZWRnZXJUcmFuc3BvcnRUeXBlKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5tZXRhbWFzay5sZWRnZXJUcmFuc3BvcnRUeXBlO1xufVxuXG4vKipcbiAqIEdpdmVuIHRoZSByZWR1eCBzdGF0ZSBvYmplY3QgYW5kIGFuIGFkZHJlc3MsIHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFzc2VkIGFkZHJlc3MgaXMgcGFydCBvZiBhIExlZGdlciBrZXlyaW5nXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gdGhlIHJlZHV4IHN0YXRlIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IGFkZHJlc3MgLSB0aGUgYWRkcmVzcyB0byBzZWFyY2ggZm9yIGFtb25nIGFsbCBrZXlyaW5nIGFkZHJlc3Nlc1xuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgdGhlIHBhc3NlZCBhZGRyZXNzIGlzIHBhcnQgb2YgYSBsZWRnZXIga2V5cmluZywgYW5kIGZhbHNlIG90aGVyd2lzZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzTGVkZ2VyKHN0YXRlLCBhZGRyZXNzKSB7XG4gIGNvbnN0IGtleXJpbmcgPSBmaW5kS2V5cmluZ0ZvckFkZHJlc3Moc3RhdGUsIGFkZHJlc3MpO1xuXG4gIHJldHVybiBrZXlyaW5nPy50eXBlID09PSBLRVlSSU5HX1RZUEVTLkxFREdFUjtcbn1cblxuLyoqXG4gKiBHaXZlbiB0aGUgcmVkdXggc3RhdGUgb2JqZWN0LCByZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIHVzZXIgaGFzIGFueSBMZWRnZXIgYWNjb3VudHMgYWRkZWQgdG8gTWV0YU1hc2sgKGkuZS4gTGVkZ2VyIGtleXJpbmdzXG4gKiBpbiBzdGF0ZSlcbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSB0aGUgcmVkdXggc3RhdGUgb2JqZWN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgdXNlciBoYXMgYSBMZWRnZXIgYWNjb3VudCBhbmQgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb2VzVXNlckhhdmVBTGVkZ2VyQWNjb3VudChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUubWV0YW1hc2sua2V5cmluZ3Muc29tZSgoa3IpID0+IHtcbiAgICByZXR1cm4ga3IudHlwZSA9PT0gS0VZUklOR19UWVBFUy5MRURHRVI7XG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgYWRkSGV4UHJlZml4IH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCBhYmkgZnJvbSAnaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpJztcbmltcG9ydCB7IEdBU19MSU1JVFMsIE1JTl9HQVNfTElNSVRfSEVYIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xuaW1wb3J0IHsgY2FsY1Rva2VuQW1vdW50IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi90cmFuc2FjdGlvbnMtY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQgeyBDSEFJTl9JRF9UT19HQVNfTElNSVRfQlVGRkVSX01BUCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICBBU1NFVF9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgcmVhZEFkZHJlc3NBc0NvbnRyYWN0IH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udHJhY3QtdXRpbHMnO1xuaW1wb3J0IHtcbiAgY29udmVyc2lvblV0aWwsXG4gIG11bHRpcGx5Q3VycmVuY2llcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBFVEgsIEdXRUkgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2NvbnN0YW50cy9jb21tb24nO1xuaW1wb3J0IHtcbiAgYWRkR2FzQnVmZmVyLFxuICBnZW5lcmF0ZUVSQzIwVHJhbnNmZXJEYXRhLFxuICBnZW5lcmF0ZUVSQzcyMVRyYW5zZmVyRGF0YSxcbiAgZ2V0QXNzZXRUcmFuc2ZlckRhdGEsXG59IGZyb20gJy4uLy4uL3BhZ2VzL3NlbmQvc2VuZC51dGlscyc7XG5pbXBvcnQgeyBnZXRHYXNQcmljZUluSGV4V2VpIH0gZnJvbSAnLi4vLi4vc2VsZWN0b3JzJztcbmltcG9ydCB7IGVzdGltYXRlR2FzIH0gZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9ucyc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBlc3RpbWF0ZUdhc0xpbWl0Rm9yU2VuZCh7XG4gIHNlbGVjdGVkQWRkcmVzcyxcbiAgdmFsdWUsXG4gIGdhc1ByaWNlLFxuICBzZW5kVG9rZW4sXG4gIHRvLFxuICBkYXRhLFxuICBpc05vblN0YW5kYXJkRXRoQ2hhaW4sXG4gIGNoYWluSWQsXG4gIGdhc0xpbWl0LFxuICAuLi5vcHRpb25zXG59KSB7XG4gIGxldCBpc1NpbXBsZVNlbmRPbk5vblN0YW5kYXJkTmV0d29yayA9IGZhbHNlO1xuXG4gIC8vIGJsb2NrR2FzTGltaXQgbWF5IGJlIGEgZmFsc3ksIGJ1dCBkZWZpbmVkLCB2YWx1ZSB3aGVuIHdlIHJlY2VpdmUgaXQgZnJvbVxuICAvLyBzdGF0ZSwgc28gd2UgdXNlIGxvZ2ljYWwgb3IgdG8gZmFsbCBiYWNrIHRvIE1JTl9HQVNfTElNSVRfSEVYLiBTb21lXG4gIC8vIG5ldHdvcmsgaW1wbGVtZW50YXRpb25zIGNoZWNrIHRoZSBnYXMgcGFyYW1ldGVyIHN1cHBsaWVkIHRvXG4gIC8vIGV0aF9lc3RpbWF0ZUdhcyBmb3IgdmFsaWRpdHkuIEZvciB0aGlzIHJlYXNvbiwgd2Ugc2V0IHRva2VuIHNlbmRzXG4gIC8vIGJsb2NrR2FzTGltaXQgZGVmYXVsdCB0byBhIGhpZ2hlciBudW1iZXIuIE5vdGUgdGhhdCB0aGUgY3VycmVudCBnYXNMaW1pdFxuICAvLyBvbiBhIEJMT0NLIGlzIDE1LDAwMCwwMDAgYW5kIHdpbGwgYmUgMzAsMDAwLDAwMCBvbiBtYWlubmV0IGFmdGVyIExvbmRvbi5cbiAgLy8gTWVhbndoaWxlLCBNSU5fR0FTX0xJTUlUX0hFWCBpcyAweDUyMDguXG4gIGxldCBibG9ja0dhc0xpbWl0ID0gTUlOX0dBU19MSU1JVF9IRVg7XG4gIGlmIChvcHRpb25zLmJsb2NrR2FzTGltaXQpIHtcbiAgICBibG9ja0dhc0xpbWl0ID0gb3B0aW9ucy5ibG9ja0dhc0xpbWl0O1xuICB9IGVsc2UgaWYgKHNlbmRUb2tlbikge1xuICAgIGJsb2NrR2FzTGltaXQgPSBHQVNfTElNSVRTLkJBU0VfVE9LRU5fRVNUSU1BVEU7XG4gIH1cblxuICAvLyBUaGUgcGFyYW1ldGVycyBiZWxvdyB3aWxsIGJlIHNlbnQgdG8gb3VyIGJhY2tncm91bmQgcHJvY2VzcyB0byBlc3RpbWF0ZVxuICAvLyBob3cgbXVjaCBnYXMgd2lsbCBiZSB1c2VkIGZvciBhIHRyYW5zYWN0aW9uLiBUaGF0IGJhY2tncm91bmQgcHJvY2VzcyBpc1xuICAvLyBsb2NhdGVkIGluIHR4LWdhcy11dGlscy5qcyBpbiB0aGUgdHJhbnNhY3Rpb24gY29udHJvbGxlciBmb2xkZXIuXG4gIGNvbnN0IHBhcmFtc0Zvckdhc0VzdGltYXRlID0geyBmcm9tOiBzZWxlY3RlZEFkZHJlc3MsIHZhbHVlLCBnYXNQcmljZSB9O1xuXG4gIGlmIChzZW5kVG9rZW4pIHtcbiAgICBpZiAoIXRvKSB7XG4gICAgICAvLyBJZiBubyB0byBhZGRyZXNzIGlzIHByb3ZpZGVkLCB3ZSBjYW5ub3QgZ2VuZXJhdGUgdGhlIHRva2VuIHRyYW5zZmVyXG4gICAgICAvLyBoZXhEYXRhLiBoZXhEYXRhIGluIGEgdHJhbnNhY3Rpb24gbGFyZ2VseSBkaWN0YXRlcyBob3cgbXVjaCBnYXMgd2lsbFxuICAgICAgLy8gYmUgY29uc3VtZWQgYnkgYSB0cmFuc2FjdGlvbi4gV2UgbXVzdCB1c2Ugb3VyIGJlc3QgZ3Vlc3MsIHdoaWNoIGlzXG4gICAgICAvLyByZXByZXNlbnRlZCBpbiB0aGUgZ2FzIHNoYXJlZCBjb25zdGFudHMuXG4gICAgICByZXR1cm4gR0FTX0xJTUlUUy5CQVNFX1RPS0VOX0VTVElNQVRFO1xuICAgIH1cbiAgICBwYXJhbXNGb3JHYXNFc3RpbWF0ZS52YWx1ZSA9ICcweDAnO1xuXG4gICAgLy8gV2UgaGF2ZSB0byBnZW5lcmF0ZSB0aGUgZXJjMjAvZXJjNzIxIGNvbnRyYWN0IGNhbGwgdG8gdHJhbnNmZXIgdG9rZW5zIGluXG4gICAgLy8gb3JkZXIgdG8gZ2V0IGEgcHJvcGVyIGVzdGltYXRlIGZvciBnYXNMaW1pdC5cbiAgICBwYXJhbXNGb3JHYXNFc3RpbWF0ZS5kYXRhID0gZ2V0QXNzZXRUcmFuc2ZlckRhdGEoe1xuICAgICAgc2VuZFRva2VuLFxuICAgICAgZnJvbUFkZHJlc3M6IHNlbGVjdGVkQWRkcmVzcyxcbiAgICAgIHRvQWRkcmVzczogdG8sXG4gICAgICBhbW91bnQ6IHZhbHVlLFxuICAgIH0pO1xuXG4gICAgcGFyYW1zRm9yR2FzRXN0aW1hdGUudG8gPSBzZW5kVG9rZW4uYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIC8vIGV0aC5nZXRDb2RlIHdpbGwgcmV0dXJuIHRoZSBjb21waWxlZCBzbWFydCBjb250cmFjdCBjb2RlIGF0IHRoZVxuICAgICAgLy8gYWRkcmVzcy4gSWYgdGhpcyByZXR1cm5zIDB4LCAweDAgb3IgYSBudWxsaXNoIHZhbHVlIHRoZW4gdGhlIGFkZHJlc3NcbiAgICAgIC8vIGlzIGFuIGV4dGVybmFsbHkgb3duZWQgYWNjb3VudCAoTk9UIGEgY29udHJhY3QgYWNjb3VudCkuIEZvciB0aGVzZVxuICAgICAgLy8gdHlwZXMgb2YgdHJhbnNhY3Rpb25zIHRoZSBnYXNMaW1pdCB3aWxsIGFsd2F5cyBiZSAyMSwwMDAgb3IgMHg1MjA4XG4gICAgICBjb25zdCB7IGlzQ29udHJhY3RBZGRyZXNzIH0gPSB0b1xuICAgICAgICA/IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChnbG9iYWwuZXRoLCB0bylcbiAgICAgICAgOiB7fTtcbiAgICAgIGlmICghaXNDb250cmFjdEFkZHJlc3MgJiYgIWlzTm9uU3RhbmRhcmRFdGhDaGFpbikge1xuICAgICAgICByZXR1cm4gR0FTX0xJTUlUUy5TSU1QTEU7XG4gICAgICB9IGVsc2UgaWYgKCFpc0NvbnRyYWN0QWRkcmVzcyAmJiBpc05vblN0YW5kYXJkRXRoQ2hhaW4pIHtcbiAgICAgICAgaXNTaW1wbGVTZW5kT25Ob25TdGFuZGFyZE5ldHdvcmsgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlLmRhdGEgPSBkYXRhO1xuXG4gICAgaWYgKHRvKSB7XG4gICAgICBwYXJhbXNGb3JHYXNFc3RpbWF0ZS50byA9IHRvO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUgfHwgdmFsdWUgPT09ICcwJykge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aGF0J3MgZ29pbmcgb24gaGVyZS4gQWNjb3JkaW5nIHRvIGV0aF9lc3RpbWF0ZUdhc1xuICAgICAgLy8gZG9jcyB0aGlzIHZhbHVlIGNhbiBiZSB6ZXJvLCBvciB1bmRlZmluZWQsIHlldCB3ZSBhcmUgc2V0dGluZyBpdCB0byBhXG4gICAgICAvLyB2YWx1ZSBoZXJlIHdoZW4gdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCBvciB6ZXJvLiBGb3IgbW9yZSBjb250ZXh0OlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL01ldGFNYXNrL21ldGFtYXNrLWV4dGVuc2lvbi9wdWxsLzYxOTVcbiAgICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlLnZhbHVlID0gJzB4ZmYnO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaXNTaW1wbGVTZW5kT25Ob25TdGFuZGFyZE5ldHdvcmspIHtcbiAgICAvLyBJZiB3ZSBkbyBub3QgeWV0IGhhdmUgYSBnYXNMaW1pdCwgd2UgbXVzdCBjYWxsIGludG8gb3VyIGJhY2tncm91bmRcbiAgICAvLyBwcm9jZXNzIHRvIGdldCBhbiBlc3RpbWF0ZSBmb3IgZ2FzTGltaXQgYmFzZWQgb24ga25vd24gcGFyYW1ldGVycy5cblxuICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlLmdhcyA9IGFkZEhleFByZWZpeChcbiAgICAgIG11bHRpcGx5Q3VycmVuY2llcyhibG9ja0dhc0xpbWl0LCAwLjk1LCB7XG4gICAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxuICAgICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgICAgIHJvdW5kRG93bjogJzAnLFxuICAgICAgICB0b051bWVyaWNCYXNlOiAnaGV4JyxcbiAgICAgIH0pLFxuICAgICk7XG4gIH1cblxuICAvLyBUaGUgYnVmZmVyIG11bHRpcGxlciByZWR1Y2VzIHRyYW5zYWN0aW9uIGZhaWx1cmVzIGJ5IGVuc3VyaW5nIHRoYXQgdGhlXG4gIC8vIGVzdGltYXRlZCBnYXMgaXMgYWx3YXlzIHN1ZmZpY2llbnQuIFdpdGhvdXQgdGhlIG11bHRpcGxpZXIsIGVzdGltYXRlc1xuICAvLyBmb3IgY29udHJhY3QgaW50ZXJhY3Rpb25zIGNhbiBiZWNvbWUgaW5hY2N1cmF0ZSBvdmVyIHRpbWUuIFRoaXMgaXMgYmVjYXVzZVxuICAvLyBnYXMgZXN0aW1hdGlvbiBpcyBub24tZGV0ZXJtaW5pc3RpYy4gVGhlIGdhcyByZXF1aXJlZCBmb3IgdGhlIGV4YWN0IHNhbWVcbiAgLy8gdHJhbnNhY3Rpb24gY2FsbCBjYW4gY2hhbmdlIGJhc2VkIG9uIHN0YXRlIG9mIGEgY29udHJhY3Qgb3IgY2hhbmdlcyBpbiB0aGVcbiAgLy8gY29udHJhY3RzIGVudmlyb25tZW50IChibG9ja2NoYWluIGRhdGEgb3IgY29udHJhY3RzIGl0IGludGVyYWN0cyB3aXRoKS5cbiAgLy8gQXBwbHlpbmcgdGhlIDEuNSBidWZmZXIgaGFzIHByb3ZlbiB0byBiZSBhIHVzZWZ1bCBndWFyZCBhZ2FpbnN0IHRoaXMgbm9uLVxuICAvLyBkZXRlcm1pbmlzdGljIGJlaGF2aW91ci5cbiAgLy9cbiAgLy8gR2FzIGVzdGltYXRpb24gb2Ygc2ltcGxlIHNlbmRzIHNob3VsZCwgaG93ZXZlciwgYmUgZGV0ZXJtaW5pc3RpYy4gQXMgc3VjaFxuICAvLyBubyBidWZmZXIgaXMgbmVlZGVkIGluIHRob3NlIGNhc2VzLlxuICBsZXQgYnVmZmVyTXVsdGlwbGllciA9IDEuNTtcbiAgaWYgKGlzU2ltcGxlU2VuZE9uTm9uU3RhbmRhcmROZXR3b3JrKSB7XG4gICAgYnVmZmVyTXVsdGlwbGllciA9IDE7XG4gIH0gZWxzZSBpZiAoQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF0pIHtcbiAgICBidWZmZXJNdWx0aXBsaWVyID0gQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF07XG4gIH1cblxuICB0cnkge1xuICAgIC8vIENhbGwgaW50byB0aGUgYmFja2dyb3VuZCBwcm9jZXNzIHRoYXQgd2lsbCBzaW11bGF0ZSB0cmFuc2FjdGlvblxuICAgIC8vIGV4ZWN1dGlvbiBvbiB0aGUgbm9kZSBhbmQgcmV0dXJuIGFuIGVzdGltYXRlIG9mIGdhc0xpbWl0XG4gICAgY29uc3QgZXN0aW1hdGVkR2FzTGltaXQgPSBhd2FpdCBlc3RpbWF0ZUdhcyhwYXJhbXNGb3JHYXNFc3RpbWF0ZSk7XG4gICAgY29uc3QgZXN0aW1hdGVXaXRoQnVmZmVyID0gYWRkR2FzQnVmZmVyKFxuICAgICAgZXN0aW1hdGVkR2FzTGltaXQsXG4gICAgICBibG9ja0dhc0xpbWl0LFxuICAgICAgYnVmZmVyTXVsdGlwbGllcixcbiAgICApO1xuICAgIHJldHVybiBhZGRIZXhQcmVmaXgoZXN0aW1hdGVXaXRoQnVmZmVyKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBzaW11bGF0aW9uRmFpbGVkID1cbiAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ1RyYW5zYWN0aW9uIGV4ZWN1dGlvbiBlcnJvci4nKSB8fFxuICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcyhcbiAgICAgICAgJ2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZSBvciBhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbicsXG4gICAgICApIHx8XG4gICAgICAoQ0hBSU5fSURfVE9fR0FTX0xJTUlUX0JVRkZFUl9NQVBbY2hhaW5JZF0gJiZcbiAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZ2FzIHJlcXVpcmVkIGV4Y2VlZHMgYWxsb3dhbmNlJykpO1xuICAgIGlmIChzaW11bGF0aW9uRmFpbGVkKSB7XG4gICAgICBjb25zdCBlc3RpbWF0ZVdpdGhCdWZmZXIgPSBhZGRHYXNCdWZmZXIoXG4gICAgICAgIHBhcmFtc0Zvckdhc0VzdGltYXRlPy5nYXMgPz8gZ2FzTGltaXQsXG4gICAgICAgIGJsb2NrR2FzTGltaXQsXG4gICAgICAgIGJ1ZmZlck11bHRpcGxpZXIsXG4gICAgICApO1xuICAgICAgcmV0dXJuIGFkZEhleFByZWZpeChlc3RpbWF0ZVdpdGhCdWZmZXIpO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHR4UGFyYW1zIGZyb20gdGhlIHNlbmQgc2xpY2UuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4nKS5TZW5kU3RhdGV9IHNlbmRTdGF0ZSAtIHRoZSBzdGF0ZSBvZiB0aGUgc2VuZCBzbGljZVxuICogQHJldHVybnMge2ltcG9ydChcbiAqICAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbidcbiAqICkuVHhQYXJhbXN9IEEgdHhQYXJhbXMgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIGEgdHJhbnNhY3Rpb24gb3JcbiAqICB1cGRhdGUgYW4gZXhpc3RpbmcgdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRyYW5zYWN0aW9uUGFyYW1zKHNlbmRTdGF0ZSkge1xuICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICBzZW5kU3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc2VuZFN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICBjb25zdCB0eFBhcmFtcyA9IHtcbiAgICAvLyBJZiB0aGUgZnJvbUFjY291bnQgaGFzIGJlZW4gc3BlY2lmaWVkIHdlIHVzZSB0aGF0LCBpZiBub3Qgd2UgdXNlIHRoZVxuICAgIC8vIHNlbGVjdGVkIGFjY291bnQuXG4gICAgZnJvbTpcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZnJvbUFjY291bnQ/LmFkZHJlc3MgfHxcbiAgICAgIHNlbmRTdGF0ZS5zZWxlY3RlZEFjY291bnQuYWRkcmVzcyxcbiAgICAvLyBnYXNMaW1pdCBhbHdheXMgbmVlZHMgdG8gYmUgc2V0IHJlZ2FyZGxlc3Mgb2YgdGhlIGFzc2V0IGJlaW5nIHNlbnRcbiAgICAvLyBvciB0aGUgdHlwZSBvZiB0cmFuc2FjdGlvbi5cbiAgICBnYXM6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0LFxuICB9O1xuICBzd2l0Y2ggKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSkge1xuICAgIGNhc2UgQVNTRVRfVFlQRVMuVE9LRU46XG4gICAgICAvLyBXaGVuIHNlbmRpbmcgYSB0b2tlbiB0aGUgdG8gYWRkcmVzcyBpcyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZlxuICAgICAgLy8gdGhlIHRva2VuIGJlaW5nIHNlbnQuIFRoZSB2YWx1ZSBpcyBzZXQgdG8gJzB4MCcgYW5kIHRoZSBkYXRhXG4gICAgICAvLyBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVjaXBpZW50IGFkZHJlc3MsIHRva2VuIGJlaW5nIHNlbnQgYW5kXG4gICAgICAvLyBhbW91bnQuXG4gICAgICB0eFBhcmFtcy50byA9IGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscy5hZGRyZXNzO1xuICAgICAgdHhQYXJhbXMudmFsdWUgPSAnMHgwJztcbiAgICAgIHR4UGFyYW1zLmRhdGEgPSBnZW5lcmF0ZUVSQzIwVHJhbnNmZXJEYXRhKHtcbiAgICAgICAgdG9BZGRyZXNzOiBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzLFxuICAgICAgICBhbW91bnQ6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICBzZW5kVG9rZW46IGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscyxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRTpcbiAgICAgIC8vIFdoZW4gc2VuZGluZyBhIHRva2VuIHRoZSB0byBhZGRyZXNzIGlzIHRoZSBjb250cmFjdCBhZGRyZXNzIG9mXG4gICAgICAvLyB0aGUgdG9rZW4gYmVpbmcgc2VudC4gVGhlIHZhbHVlIGlzIHNldCB0byAnMHgwJyBhbmQgdGhlIGRhdGFcbiAgICAgIC8vIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZWNpcGllbnQgYWRkcmVzcywgdG9rZW4gYmVpbmcgc2VudCBhbmRcbiAgICAgIC8vIGFtb3VudC5cbiAgICAgIHR4UGFyYW1zLnRvID0gZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5kZXRhaWxzLmFkZHJlc3M7XG4gICAgICB0eFBhcmFtcy52YWx1ZSA9ICcweDAnO1xuICAgICAgdHhQYXJhbXMuZGF0YSA9IGdlbmVyYXRlRVJDNzIxVHJhbnNmZXJEYXRhKHtcbiAgICAgICAgdG9BZGRyZXNzOiBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzLFxuICAgICAgICBmcm9tQWRkcmVzczpcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50Py5hZGRyZXNzID8/XG4gICAgICAgICAgc2VuZFN0YXRlLnNlbGVjdGVkQWNjb3VudC5hZGRyZXNzLFxuICAgICAgICB0b2tlbklkOiBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHMudG9rZW5JZCxcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBU1NFVF9UWVBFUy5OQVRJVkU6XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFdoZW4gc2VuZGluZyBuYXRpdmUgY3VycmVuY3kgdGhlIHRvIGFuZCB2YWx1ZSBmaWVsZHMgdXNlIHRoZVxuICAgICAgLy8gcmVjaXBpZW50IGFuZCBhbW91bnQgdmFsdWVzIGFuZCB0aGUgZGF0YSBrZXkgaXMgZWl0aGVyIG51bGwgb3JcbiAgICAgIC8vIHBvcHVsYXRlZCB3aXRoIHRoZSB1c2VyIGlucHV0IHByb3ZpZGVkIGluIGhleCBmaWVsZC5cbiAgICAgIHR4UGFyYW1zLnRvID0gZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcztcbiAgICAgIHR4UGFyYW1zLnZhbHVlID0gZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQudmFsdWU7XG4gICAgICB0eFBhcmFtcy5kYXRhID0gZHJhZnRUcmFuc2FjdGlvbi51c2VySW5wdXRIZXhEYXRhID8/IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgd2Ugb25seSBpbmNsdWRlIHRoZSByaWdodCBnYXMgZmVlIGZpZWxkc1xuICAvLyBiYXNlZCBvbiB0aGUgdHlwZSBvZiB0cmFuc2FjdGlvbiB0aGUgbmV0d29yayBzdXBwb3J0cy4gV2Ugd2lsbCBhbHNvIHNldFxuICAvLyB0aGUgdHlwZSBwYXJhbSBoZXJlLlxuICBpZiAoc2VuZFN0YXRlLmVpcDE1NTlzdXBwb3J0KSB7XG4gICAgdHhQYXJhbXMudHlwZSA9IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkZFRV9NQVJLRVQ7XG5cbiAgICB0eFBhcmFtcy5tYXhGZWVQZXJHYXMgPSBkcmFmdFRyYW5zYWN0aW9uLmdhcy5tYXhGZWVQZXJHYXM7XG4gICAgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBkcmFmdFRyYW5zYWN0aW9uLmdhcy5tYXhQcmlvcml0eUZlZVBlckdhcztcblxuICAgIGlmICghdHhQYXJhbXMubWF4RmVlUGVyR2FzIHx8IHR4UGFyYW1zLm1heEZlZVBlckdhcyA9PT0gJzB4MCcpIHtcbiAgICAgIHR4UGFyYW1zLm1heEZlZVBlckdhcyA9IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICF0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyB8fFxuICAgICAgdHhQYXJhbXMubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICcweDAnXG4gICAgKSB7XG4gICAgICB0eFBhcmFtcy5tYXhQcmlvcml0eUZlZVBlckdhcyA9IHR4UGFyYW1zLm1heEZlZVBlckdhcztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdHhQYXJhbXMuZ2FzUHJpY2UgPSBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNQcmljZTtcbiAgICB0eFBhcmFtcy50eXBlID0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuTEVHQUNZO1xuICB9XG5cbiAgcmV0dXJuIHR4UGFyYW1zO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8ga2VlcCB0aGUgb3JpZ2luYWwgbG9naWMgZnJvbSB0aGUgZ2FzLmR1Y2suanMgZmlsZVxuICogYWZ0ZXIgcmVjZWl2aW5nIGEgZ2FzUHJpY2UgZnJvbSBldGhfZ2FzUHJpY2UuIEZpcnN0LCB0aGUgcmV0dXJuZWQgZ2FzUHJpY2VcbiAqIHdhcyBjb252ZXJ0ZWQgdG8gR1dFSSwgdGhlbiBpdCB3YXMgY29udmVydGVkIHRvIGEgTnVtYmVyLCB0aGVuIGluIHRoZSBzZW5kXG4gKiBkdWNrIChoZXJlKSB3ZSB3b3VsZCB1c2UgZ2V0R2FzUHJpY2VJbkhleFdlaSB0byBnZXQgYmFjayB0byBoZXhXZWkuIE5vdyB0aGF0XG4gKiB3ZSByZWNlaXZlIGEgR1dFSSBlc3RpbWF0ZSBmcm9tIHRoZSBjb250cm9sbGVyLCB3ZSBzdGlsbCBuZWVkIHRvIGRvIHRoaXNcbiAqIHdlaXJkIGNvbnZlcnNpb24gdG8gZ2V0IHRoZSBwcm9wZXIgcm91bmRpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGdhc1ByaWNlRXN0aW1hdGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSb3VuZGVkR2FzUHJpY2UoZ2FzUHJpY2VFc3RpbWF0ZSkge1xuICBjb25zdCBnYXNQcmljZUluRGVjR3dlaSA9IGNvbnZlcnNpb25VdGlsKGdhc1ByaWNlRXN0aW1hdGUsIHtcbiAgICBudW1iZXJPZkRlY2ltYWxzOiA5LFxuICAgIHRvRGVub21pbmF0aW9uOiBHV0VJLFxuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgZnJvbUN1cnJlbmN5OiBFVEgsXG4gICAgZnJvbURlbm9taW5hdGlvbjogR1dFSSxcbiAgfSk7XG4gIGNvbnN0IGdhc1ByaWNlQXNOdW1iZXIgPSBOdW1iZXIoZ2FzUHJpY2VJbkRlY0d3ZWkpO1xuICByZXR1cm4gZ2V0R2FzUHJpY2VJbkhleFdlaShnYXNQcmljZUFzTnVtYmVyKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVSQzIwQmFsYW5jZSh0b2tlbiwgYWNjb3VudEFkZHJlc3MpIHtcbiAgY29uc3QgY29udHJhY3QgPSBnbG9iYWwuZXRoLmNvbnRyYWN0KGFiaSkuYXQodG9rZW4uYWRkcmVzcyk7XG4gIGNvbnN0IHVzZXJzVG9rZW4gPSAoYXdhaXQgY29udHJhY3QuYmFsYW5jZU9mKGFjY291bnRBZGRyZXNzKSkgPz8gbnVsbDtcbiAgaWYgKCF1c2Vyc1Rva2VuKSB7XG4gICAgcmV0dXJuICcweDAnO1xuICB9XG4gIGNvbnN0IGFtb3VudCA9IGNhbGNUb2tlbkFtb3VudChcbiAgICB1c2Vyc1Rva2VuLmJhbGFuY2UudG9TdHJpbmcoKSxcbiAgICB0b2tlbi5kZWNpbWFscyxcbiAgKS50b1N0cmluZygxNik7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoYW1vdW50KTtcbn1cbiIsImV4cG9ydCAqIGZyb20gJy4vc2VuZCc7XHJcbiIsImltcG9ydCB7IGNyZWF0ZUFzeW5jVGh1bmssIGNyZWF0ZVNsaWNlIH0gZnJvbSAnQHJlZHV4anMvdG9vbGtpdCc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICdldGhlcmV1bWpzLXV0aWwnO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQge1xuICBjb252ZXJzaW9uR3JlYXRlclRoYW4sXG4gIGNvbnZlcnNpb25VdGlsLFxuICBtdWx0aXBseUN1cnJlbmNpZXMsXG4gIHN1YnRyYWN0Q3VycmVuY2llcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBHQVNfRVNUSU1BVEVfVFlQRVMsIEdBU19MSU1JVFMgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2dhcyc7XG5pbXBvcnQge1xuICBDT05UUkFDVF9BRERSRVNTX0VSUk9SLFxuICBJTlNVRkZJQ0lFTlRfRlVORFNfRVJST1IsXG4gIElOU1VGRklDSUVOVF9UT0tFTlNfRVJST1IsXG4gIElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfRVJST1IsXG4gIElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfTk9UX0VUSF9ORVRXT1JLX0VSUk9SLFxuICBLTk9XTl9SRUNJUElFTlRfQUREUkVTU19XQVJOSU5HLFxuICBORUdBVElWRV9FVEhfRVJST1IsXG4gIFJFQ0lQSUVOVF9UWVBFUyxcbn0gZnJvbSAnLi4vLi4vcGFnZXMvc2VuZC9zZW5kLmNvbnN0YW50cyc7XG5cbmltcG9ydCB7XG4gIGlzQmFsYW5jZVN1ZmZpY2llbnQsXG4gIGlzVG9rZW5CYWxhbmNlU3VmZmljaWVudCxcbn0gZnJvbSAnLi4vLi4vcGFnZXMvc2VuZC9zZW5kLnV0aWxzJztcbmltcG9ydCB7XG4gIGdldEFkdmFuY2VkSW5saW5lR2FzU2hvd24sXG4gIGdldEN1cnJlbnRDaGFpbklkLFxuICBnZXRHYXNQcmljZUluSGV4V2VpLFxuICBnZXRJc01haW5uZXQsXG4gIGdldFRhcmdldEFjY291bnQsXG4gIGdldElzTm9uU3RhbmRhcmRFdGhDaGFpbixcbiAgY2hlY2tOZXR3b3JrQW5kQWNjb3VudFN1cHBvcnRzMTU1OSxcbiAgZ2V0VXNlVG9rZW5EZXRlY3Rpb24sXG4gIGdldFRva2VuTGlzdCxcbiAgZ2V0QWRkcmVzc0Jvb2tFbnRyeU9yQWNjb3VudE5hbWUsXG4gIGdldElzTXVsdGlMYXllckZlZU5ldHdvcmssXG4gIGdldEVuc1Jlc29sdXRpb25CeUFkZHJlc3MsXG4gIGdldFNlbGVjdGVkQWNjb3VudCxcbiAgZ2V0U2VsZWN0ZWRBZGRyZXNzLFxufSBmcm9tICcuLi8uLi9zZWxlY3RvcnMnO1xuaW1wb3J0IHtcbiAgZGlzY29ubmVjdEdhc0ZlZUVzdGltYXRlUG9sbGVyLFxuICBkaXNwbGF5V2FybmluZyxcbiAgZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nLFxuICBoaWRlTG9hZGluZ0luZGljYXRpb24sXG4gIHNob3dMb2FkaW5nSW5kaWNhdGlvbixcbiAgdXBkYXRlRWRpdGFibGVQYXJhbXMsXG4gIHVwZGF0ZVRyYW5zYWN0aW9uR2FzRmVlcyxcbiAgYWRkUG9sbGluZ1Rva2VuVG9BcHBTdGF0ZSxcbiAgcmVtb3ZlUG9sbGluZ1Rva2VuRnJvbUFwcFN0YXRlLFxuICBpc0NvbGxlY3RpYmxlT3duZXIsXG4gIGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzLFxuICBzaG93TW9kYWwsXG4gIGFkZFVuYXBwcm92ZWRUcmFuc2FjdGlvbkFuZFJvdXRlVG9Db25maXJtYXRpb25QYWdlLFxuICB1cGRhdGVUcmFuc2FjdGlvblNlbmRGbG93SGlzdG9yeSxcbn0gZnJvbSAnLi4vLi4vc3RvcmUvYWN0aW9ucyc7XG5pbXBvcnQgeyBzZXRDdXN0b21HYXNMaW1pdCB9IGZyb20gJy4uL2dhcy9nYXMuZHVjayc7XG5pbXBvcnQge1xuICBRUl9DT0RFX0RFVEVDVEVELFxuICBTRUxFQ1RFRF9BQ0NPVU5UX0NIQU5HRUQsXG4gIEFDQ09VTlRfQ0hBTkdFRCxcbiAgQUREUkVTU19CT09LX1VQREFURUQsXG4gIEdBU19GRUVfRVNUSU1BVEVTX1VQREFURUQsXG59IGZyb20gJy4uLy4uL3N0b3JlL2FjdGlvbkNvbnN0YW50cyc7XG5pbXBvcnQge1xuICBnZXRUb2tlbkFkZHJlc3NQYXJhbSxcbiAgZ2V0VG9rZW5NZXRhZGF0YSxcbiAgZ2V0VG9rZW5JZFBhcmFtLFxufSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzL3Rva2VuLXV0aWwnO1xuaW1wb3J0IHtcbiAgY2hlY2tFeGlzdGluZ0FkZHJlc3NlcyxcbiAgaXNEZWZhdWx0TWV0YU1hc2tDaGFpbixcbiAgaXNPcmlnaW5Db250cmFjdEFkZHJlc3MsXG4gIGlzVmFsaWREb21haW5OYW1lLFxufSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzL3V0aWwnO1xuaW1wb3J0IHtcbiAgZ2V0R2FzRXN0aW1hdGVUeXBlLFxuICBnZXRUb2tlbnMsXG4gIGdldFVuYXBwcm92ZWRUeHMsXG59IGZyb20gJy4uL21ldGFtYXNrL21ldGFtYXNrJztcblxuaW1wb3J0IHsgcmVzZXRFbnNSZXNvbHV0aW9uIH0gZnJvbSAnLi4vZW5zJztcbmltcG9ydCB7XG4gIGlzQnVybkFkZHJlc3MsXG4gIGlzVmFsaWRIZXhBZGRyZXNzLFxuICB0b0NoZWNrc3VtSGV4QWRkcmVzcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcbmltcG9ydCB7XG4gIGlzU21hcnRDb250cmFjdEFkZHJlc3MsXG4gIHN1bUhleGVzLFxufSBmcm9tICcuLi8uLi9oZWxwZXJzL3V0aWxzL3RyYW5zYWN0aW9ucy51dGlsJztcbmltcG9ydCBmZXRjaEVzdGltYXRlZEwxRmVlIGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMvb3B0aW1pc20vZmV0Y2hFc3RpbWF0ZWRMMUZlZSc7XG5cbmltcG9ydCB7IEVUSCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvY29uc3RhbnRzL2NvbW1vbic7XG5pbXBvcnQge1xuICBBU1NFVF9UWVBFUyxcbiAgVE9LRU5fU1RBTkRBUkRTLFxuICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgSU5WQUxJRF9BU1NFVF9UWVBFIH0gZnJvbSAnLi4vLi4vaGVscGVycy9jb25zdGFudHMvZXJyb3Ita2V5cyc7XG5pbXBvcnQgeyBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvc3RyaW5nLXV0aWxzJztcbmltcG9ydCB7IGdldFZhbHVlRnJvbVdlaUhleCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvdXRpbHMvY29uZmlybS10eC51dGlsJztcbmltcG9ydCB7IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3RyYW5zYWN0aW9uLnV0aWxzJztcbmltcG9ydCB7IGdldFRva2VuVmFsdWVQYXJhbSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvbWV0YW1hc2stY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQge1xuICBjYWxjR2FzVG90YWwsXG4gIGNhbGNUb2tlbkFtb3VudCxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi90cmFuc2FjdGlvbnMtY29udHJvbGxlci11dGlscyc7XG5pbXBvcnQge1xuICBlc3RpbWF0ZUdhc0xpbWl0Rm9yU2VuZCxcbiAgZ2VuZXJhdGVUcmFuc2FjdGlvblBhcmFtcyxcbiAgZ2V0Um91bmRlZEdhc1ByaWNlLFxufSBmcm9tICcuL2hlbHBlcnMnO1xuLy8gdHlwZWRlZiBpbXBvcnQgc3RhdGVtZW50c1xuLyoqXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnaW1tZXIvZGlzdC9pbnRlcm5hbCcpLldyaXRhYmxlRHJhZnQ8U2VuZFN0YXRlPlxuICogKX0gU2VuZFN0YXRlRHJhZnRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJykuQXNzZXRUeXBlc1N0cmluZ1xuICogKX0gQXNzZXRUeXBlc1N0cmluZ1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoICcuLi8uLi9oZWxwZXJzL2NvbnN0YW50cy9jb21tb24nKS5Ub2tlblN0YW5kYXJkU3RyaW5nc1xuICogKX0gVG9rZW5TdGFuZGFyZFN0cmluZ3NcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90b2tlbnMnKS5Ub2tlbkRldGFpbHNcbiAqICl9IFRva2VuRGV0YWlsc1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nKS5UcmFuc2FjdGlvblR5cGVTdHJpbmdcbiAqICl9IFRyYW5zYWN0aW9uVHlwZVN0cmluZ1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0BtZXRhbWFzay9jb250cm9sbGVycycpLkxlZ2FjeUdhc1ByaWNlRXN0aW1hdGVcbiAqICl9IExlZ2FjeUdhc1ByaWNlRXN0aW1hdGVcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAbWV0YW1hc2svY29udHJvbGxlcnMnKS5HYXNGZWVFc3RpbWF0ZXNcbiAqICl9IEdhc0ZlZUVzdGltYXRlc1xuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0BtZXRhbWFzay9jb250cm9sbGVycycpLkV0aEdhc1ByaWNlRXN0aW1hdGVcbiAqICl9IEV0aEdhc1ByaWNlRXN0aW1hdGVcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAbWV0YW1hc2svY29udHJvbGxlcnMnKS5HYXNFc3RpbWF0ZVR5cGVcbiAqICl9IEdhc0VzdGltYXRlVHlwZVxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ3JlZHV4JykuQW55QWN0aW9uXG4gKiApfSBBbnlBY3Rpb25cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBSIC0gUmV0dXJuIHR5cGUgb2YgdGhlIGFzeW5jIGZ1bmN0aW9uXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgncmVkdXgtdGh1bmsnKS5UaHVua0FjdGlvbjxSLCBNZXRhTWFza1N0YXRlLCB1bmtub3duLCBBbnlBY3Rpb24+XG4gKiApfSBUaHVua0FjdGlvbjxSPlxuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHdpbGwgdGFrZSBhIHR5cGljYWwgY29uc3RhbnQgc3RyaW5nIG1hcHBlZCBvYmplY3QgYW5kIHR1cm4gaXQgaW50b1xuICogYSB1bmlvbiB0eXBlIG9mIHRoZSB2YWx1ZXMuXG4gKlxuICogQHRlbXBsYXRlIE8gLSBUaGUgb2JqZWN0IHRvIG1ha2Ugc3RyaW5ncyBvdXQgb2ZcbiAqIEB0eXBlZGVmIHtPW2tleW9mIE9dfSBNYXBWYWx1ZXNUb1VuaW9uPE8+XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTZW5kU3RhdGVTdGFnZXNcbiAqIEBwcm9wZXJ0eSB7J0FERF9SRUNJUElFTlQnfSBBRERfUkVDSVBJRU5UIC0gVGhlIHVzZXIgaXMgc2VsZWN0aW5nIHdoaWNoXG4gKiAgYWRkcmVzcyB0byBzZW5kIGFuIGFzc2V0IHRvLlxuICogQHByb3BlcnR5IHsnRFJBRlQnfSBEUkFGVCAtIFRoZSBzZW5kIGZvcm0gaXMgc2hvd24gZm9yIGEgdHJhbnNhY3Rpb24geWV0IHRvXG4gKiAgYmUgc2VudCB0byB0aGUgVHJhbnNhY3Rpb24gQ29udHJvbGxlci5cbiAqIEBwcm9wZXJ0eSB7J0VESVQnfSBFRElUIC0gVGhlIHNlbmQgZm9ybSBpcyBzaG93biBmb3IgYSB0cmFuc2FjdGlvbiBhbHJlYWR5XG4gKiAgc3VibWl0dGVkIHRvIHRoZSBUcmFuc2FjdGlvbiBDb250cm9sbGVyIGJ1dCBub3QgeWV0IGNvbmZpcm1lZC4gVGhpcyBoYXBwZW5zXG4gKiAgd2hlbiBhIGNvbmZpcm1hdGlvbiBpcyBzaG93biBmb3IgYSB0cmFuc2FjdGlvbiBhbmQgdGhlICdlZGl0JyBidXR0b24gaW4gdGhlXG4gKiAgaGVhZGVyIGlzIGNsaWNrZWQuXG4gKiBAcHJvcGVydHkgeydJTkFDVElWRSd9IElOQUNUSVZFIC0gVGhlIHNlbmQgc3RhdGUgaXMgaWRsZSwgYW5kIGhhc24ndCB5ZXRcbiAqICBmZXRjaGVkIHJlcXVpcmVkIGRhdGEgZm9yIGdhc1ByaWNlIGFuZCBnYXNMaW1pdCBlc3RpbWF0aW9ucywgZXRjLlxuICovXG5cbi8qKlxuICogVGhlIFN0YWdlcyB0aGF0IHRoZSBzZW5kIHNsaWNlIGNhbiBiZSBpblxuICpcbiAqIEB0eXBlIHtTZW5kU3RhdGVTdGFnZXN9XG4gKi9cbmV4cG9ydCBjb25zdCBTRU5EX1NUQUdFUyA9IHtcbiAgQUREX1JFQ0lQSUVOVDogJ0FERF9SRUNJUElFTlQnLFxuICBEUkFGVDogJ0RSQUZUJyxcbiAgRURJVDogJ0VESVQnLFxuICBJTkFDVElWRTogJ0lOQUNUSVZFJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRHJhZnRUeFN0YXR1c1xuICogQHByb3BlcnR5IHsnSU5WQUxJRCd9IElOVkFMSUQgLSBUaGUgdHJhbnNhY3Rpb24gaXMgaW52YWxpZCBhbmQgY2Fubm90IGJlXG4gKiAgc3VibWl0dGVkLiBUaGVyZSBhcmUgYSBudW1iZXIgb2YgY2FzZXMgdGhhdCB3b3VsZCByZXN1bHQgaW4gYW4gaW52YWxpZFxuICogIHNlbmQgc3RhdGU6XG4gKiAgMS4gVGhlIHJlY2lwaWVudCBpcyBub3QgeWV0IGRlZmluZWRcbiAqICAyLiBUaGUgYW1vdW50ICsgZ2FzVG90YWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB1c2VyJ3MgYmFsYW5jZSB3aGVuIHNlbmRpbmdcbiAqICAgICBuYXRpdmUgY3VycmVuY3lcbiAqICAzLiBUaGUgZ2FzVG90YWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB1c2VyJ3MgKm5hdGl2ZSogYmFsYW5jZVxuICogIDQuIFRoZSBhbW91bnQgb2Ygc2VudCBhc3NldCBpcyBncmVhdGVyIHRoYW4gdGhlIHVzZXIncyAqYXNzZXQqIGJhbGFuY2VcbiAqICA1LiBHYXMgcHJpY2UgZXN0aW1hdGVzIGZhaWxlZCB0byBsb2FkIGVudGlyZWx5XG4gKiAgNi4gVGhlIGdhc0xpbWl0IGlzIGxlc3MgdGhhbiAyMTAwMCAoMHg1MjA4KVxuICogQHByb3BlcnR5IHsnVkFMSUQnfSBWQUxJRCAtIFRoZSB0cmFuc2FjdGlvbiBpcyB2YWxpZCBhbmQgY2FuIGJlIHN1Ym1pdHRlZC5cbiAqL1xuXG4vKipcbiAqIFRoZSBzdGF0dXMgb2YgdGhlIHNlbmQgc2xpY2VcbiAqXG4gKiBAdHlwZSB7RHJhZnRUeFN0YXR1c31cbiAqL1xuZXhwb3J0IGNvbnN0IFNFTkRfU1RBVFVTRVMgPSB7XG4gIElOVkFMSUQ6ICdJTlZBTElEJyxcbiAgVkFMSUQ6ICdWQUxJRCcsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlbmRTdGF0ZUdhc01vZGVzXG4gKiBAcHJvcGVydHkgeydCQVNJQyd9IEJBU0lDIC0gU2hvd3MgdGhlIGJhc2ljIGVzdGltYXRlIHNsb3cvYXZnL2Zhc3QgYnV0dG9uc1xuICogIHdoZW4gb24gbWFpbm5ldCBhbmQgdGhlIG1ldGFzd2FwcyBBUEkgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICogQHByb3BlcnR5IHsnQ1VTVE9NJ30gQ1VTVE9NIC0gU2hvd3MgR2FzRmVlRGlzcGxheSBjb21wb25lbnQgdGhhdCBpcyBhIHJlYWRcbiAqICBvbmx5IGRpc3BsYXkgb2YgdGhlIHZhbHVlcyB0aGUgdXNlciBoYXMgc2V0IGluIHRoZSBhZHZhbmNlZCBnYXMgbW9kYWxcbiAqICAoc3RvcmVkIGluIHRoZSBnYXMgZHVjayB1bmRlciB0aGUgY3VzdG9tRGF0YSBrZXkpLlxuICogQHByb3BlcnR5IHsnSU5MSU5FJ30gSU5MSU5FIC0gU2hvd3MgaW5saW5lIGdhc0xpbWl0L2dhc1ByaWNlIGZpZWxkcyB3aGVuIG9uXG4gKiAgYW55IG90aGVyIG5ldHdvcmsgb3IgbWV0YXN3YXBzIEFQSSBmYWlscyBhbmQgd2UgdXNlIGV0aF9nYXNQcmljZS5cbiAqL1xuXG4vKipcbiAqIENvbnRyb2xzIHdoYXQgaXMgZGlzcGxheWVkIGluIHRoZSBzZW5kLWdhcy1yb3cgY29tcG9uZW50LlxuICpcbiAqIEB0eXBlIHtTZW5kU3RhdGVHYXNNb2Rlc31cbiAqL1xuZXhwb3J0IGNvbnN0IEdBU19JTlBVVF9NT0RFUyA9IHtcbiAgQkFTSUM6ICdCQVNJQycsXG4gIENVU1RPTTogJ0NVU1RPTScsXG4gIElOTElORTogJ0lOTElORScsXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFNlbmRTdGF0ZUFtb3VudE1vZGVzXG4gKiBAcHJvcGVydHkgeydJTlBVVCd9IElOUFVUIC0gdGhlIHVzZXIgcHJvdmlkZXMgdGhlIGFtb3VudCBieSB0eXBpbmcgaW4gdGhlXG4gKiAgZmllbGQuXG4gKiBAcHJvcGVydHkgeydNQVgnfSBNQVggLSBUaGUgdXNlciBzZWxlY3RzIHRoZSBNQVggYnV0dG9uIGFuZCBhbW91bnQgaXNcbiAqICBjYWxjdWxhdGVkIGJhc2VkIG9uIGJhbGFuY2UgLSAoYW1vdW50ICsgZ2FzVG90YWwpLlxuICovXG5cbi8qKlxuICogVGhlIG1vZGVzIHRoYXQgdGhlIGFtb3VudCBmaWVsZCBjYW4gYmUgc2V0IGJ5XG4gKlxuICogQHR5cGUge1NlbmRTdGF0ZUFtb3VudE1vZGVzfVxuICovXG5leHBvcnQgY29uc3QgQU1PVU5UX01PREVTID0ge1xuICBJTlBVVDogJ0lOUFVUJyxcbiAgTUFYOiAnTUFYJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU2VuZFN0YXRlUmVjaXBpZW50TW9kZXNcbiAqIEBwcm9wZXJ0eSB7J0NPTlRBQ1RfTElTVCd9IENPTlRBQ1RfTElTVCAtIFRoZSB1c2VyIGlzIGRpc3BsYXllZCBhIGxpc3Qgb2ZcbiAqICB0aGVpciBjb250YWN0cyBhbmQgYWRkcmVzc2VzIHRoZXkgaGF2ZSByZWNlbnRseSBzZW5kIHRvLlxuICogQHByb3BlcnR5IHsnTVlfQUNDT1VOVFMnfSBNWV9BQ0NPVU5UUyAtIHRoZSB1c2VyIGlzIGRpc3BsYXllZCBhIGxpc3Qgb2ZcbiAqICB0aGVpciBvd24gYWNjb3VudHMgdG8gc2VuZCB0by5cbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHJlY2lwaWVudCBsaXN0IHRoYXQgaXMgZGlzcGxheWVkIHRvIHVzZXJcbiAqXG4gKiBAdHlwZSB7U2VuZFN0YXRlUmVjaXBpZW50TW9kZXN9XG4gKi9cbmV4cG9ydCBjb25zdCBSRUNJUElFTlRfU0VBUkNIX01PREVTID0ge1xuICBDT05UQUNUX0xJU1Q6ICdDT05UQUNUX0xJU1QnLFxuICBNWV9BQ0NPVU5UUzogJ01ZX0FDQ09VTlRTJyxcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQWNjb3VudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgaGV4IGFkZHJlc3Mgb2YgdGhlIGFjY291bnQuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYmFsYW5jZSAtIEhleCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBuYXRpdmUgYXNzZXRcbiAqICBiYWxhbmNlIG9mIHRoZSBhY2NvdW50IHRoZSB0cmFuc2FjdGlvbiB3aWxsIGJlIHNlbnQgZnJvbS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEFtb3VudFxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvcl0gLSBFcnJvciB0byBkaXNwbGF5IGZvciB0aGUgYW1vdW50IGZpZWxkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHZhbHVlIC0gQSBoZXggc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYW1vdW50IG9mIHRoZVxuICogIHNlbGVjdGVkIGN1cnJlbmN5IHRvIHNlbmQuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBBc3NldFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGJhbGFuY2UgLSBBIGhleCBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBiYWxhbmNlXG4gKiAgdGhhdCB0aGUgdXNlciBob2xkcyBvZiB0aGUgYXNzZXQgdGhhdCB0aGV5IGFyZSBhdHRlbXB0aW5nIHRvIHNlbmQuXG4gKiBAcHJvcGVydHkge1Rva2VuRGV0YWlsc30gW2RldGFpbHNdIC0gQW4gb2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZVxuICogIHNlbGVjdGVkIGFzc2V0IGluIHRoZSBjYXNlIHRoYXQgdGhlIHVzZXIgaXMgc2VuZGluZyBhIHRva2VuIG9yIGNvbGxlY3RpYmUuXG4gKiAgV2lsbCBiZSBudWxsIHdoZW4gYXNzZXQudHlwZSBpcyAnTkFUSVZFJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JdIC0gRXJyb3IgdG8gZGlzcGxheSB3aGVuIHRoZXJlIGlzIGFuIGlzc3VlXG4gKiAgd2l0aCB0aGUgYXNzZXQuXG4gKiBAcHJvcGVydHkge0Fzc2V0VHlwZXNTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBhc3NldCB0aGF0IHRoZSB1c2VyXG4gKiAgaXMgYXR0ZW1wdGluZyB0byBzZW5kLiBEZWZhdWx0cyB0byAnTkFUSVZFJyB3aGljaCByZXByZXNlbnRzIHRoZSBuYXRpdmVcbiAqICBhc3NldCBvZiB0aGUgY2hhaW4uIENhbiBhbHNvIGJlICdUT0tFTicgb3IgJ0NPTExFQ1RJQkxFJy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEdhc0ZlZXNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXJyb3JdIC0gZXJyb3IgdG8gZGlzcGxheSBmb3IgZ2FzIGZpZWxkcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnYXNMaW1pdCAtIG1heGltdW0gZ2FzIG5lZWRlZCBmb3IgdHguXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzUHJpY2UgLSBwcmljZSBpbiB3ZWkgdG8gcGF5IHBlciBnYXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzVG90YWwgLSBtYXhpbXVtIHRvdGFsIHByaWNlIGluIHdlaSB0byBwYXkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWF4RmVlUGVyR2FzIC0gTWF4aW11bSBwcmljZSBpbiB3ZWkgdG8gcGF5IHBlciBnYXMuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWF4UHJpb3JpdHlGZWVQZXJHYXMgLSBNYXhpbXVtIHByaW9yaXR5IGZlZSBpbiB3ZWkgdG8gcGF5XG4gKiAgcGVyIGdhcy5cbiAqL1xuXG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgaW50ZW5kZWQgcmVjaXBpZW50IG9mIGEgdHJhbnNhY3Rpb24uXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gUmVjaXBpZW50XG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBmdWxseSBxdWFsaWZpZWQgYWRkcmVzcyBvZiB0aGUgcmVjaXBpZW50LlxuICogIFRoaXMgaXMgc2V0IGFmdGVyIHRoZSByZWNpcGllbnQudXNlcklucHV0IGlzIHZhbGlkYXRlZCwgdGhlIHVzZXJJbnB1dCBmaWVsZFxuICogIGlzIHF1aWNrbHkgdXBkYXRlZCB0byBhdm9pZCBkZWxheSBiZXR3ZWVuIGtleXN0cm9rZXMgYW5kIHNlZWluZyB0aGUgaW5wdXRcbiAqICBmaWVsZCB1cGRhdGVkLiBBZnRlciBhIGRlYm91bmNlIHRoZSBhZGRyZXNzIHR5cGVkIGlzIHZhbGlkYXRlZCBhbmQgdGhlbiB0aGVcbiAqICBhZGRyZXNzIGZpZWxkIGlzIHVwZGF0ZWQuIFRoZSBhZGRyZXNzIGZpZWxkIGlzIGFsc28gc2V0IHdoZW4gdGhlIHVzZXJcbiAqICBzZWxlY3RzIGEgY29udGFjdCBvciBhY2NvdW50IGZyb20gdGhlIGxpc3QsIG9yIGFuIEVOUyByZXNvbHV0aW9uIHdoZW5cbiAqICB0eXBpbmcgRU5TIG5hbWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlcnJvcl0gLSBFcnJvciB0byBkaXNwbGF5IG9uIHRoZSBhZGRyZXNzIGZpZWxkLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG5pY2tuYW1lIC0gVGhlIG5pY2tuYW1lIHRoYXQgdGhlIHVzZXIgaGFzIGFkZGVkIHRvIHRoZWlyXG4gKiAgYWRkcmVzcyBib29rIGZvciB0aGUgcmVjaXBpZW50LmFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3dhcm5pbmddIC0gV2FybmluZyB0byBkaXNwbGF5IG9uIHRoZSBhZGRyZXNzIGZpZWxkLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gRHJhZnRUcmFuc2FjdGlvblxuICogQHByb3BlcnR5IHtBbW91bnR9IGFtb3VudCAtIEFuIG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZVxuICogIGFtb3VudCBvZiBjdXJyZW5jeSB0byBzZW5kLlxuICogQHByb3BlcnR5IHtBc3NldH0gYXNzZXQgLSBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGFzc2V0IHRoYXQgdGhlIHVzZXJcbiAqICBoYXMgc2VsZWN0ZWQgdG8gc2VuZC5cbiAqIEBwcm9wZXJ0eSB7QWNjb3VudH0gW2Zyb21BY2NvdW50XSAtIFRoZSBzZW5kIGZsb3cgaXMgdXN1YWxseSBvbmx5IHJlbGF0aXZlIHRvXG4gKiAgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBhY2NvdW50LiBXaGVuIGVkaXRpbmcgYSB0cmFuc2FjdGlvbiwgaG93ZXZlciwgdGhlXG4gKiAgYWNjb3VudCBtYXkgZGlmZmVyLiBJbiB0aGF0IGNhc2UsIHRoZSBkZXRhaWxzIG9mIHRoYXQgYWNjb3VudCB3aWxsIGJlXG4gKiAgc3RvcmVkIGluIHRoaXMgb2JqZWN0IHdpdGhpbiB0aGUgZHJhZnRUcmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7R2FzRmVlc30gZ2FzIC0gRGV0YWlscyBhYm91dCB0aGUgY3VycmVudCBnYXMgc2V0dGluZ3NcbiAqIEBwcm9wZXJ0eSB7QXJyYXk8e2V2ZW50OiBzdHJpbmcsIHRpbWVzdGFtcDogbnVtYmVyfT59IGhpc3RvcnkgLSBBbiBhcnJheSBvZlxuICogIGVudHJpZXMgdGhhdCBkZXNjcmliZSB0aGUgdXNlcidzIGpvdXJuZXkgdGhyb3VnaCB0aGUgc2VuZCBmbG93LiBUaGlzIGlzXG4gKiAgc2VudCB0byB0aGUgY29udHJvbGxlciBmb3IgYXR0YWNoaW5nIHRvIHN0YXRlIGxvZ3MgZm9yIHRyb3VibGVzaG9vdGluZyBhbmRcbiAqICBzdXBwb3J0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtpZF0gLSBJZiB0aGUgdHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGVcbiAqICBUcmFuc2FjdGlvbkNvbnRyb2xsZXIgdGhpcyBmaWVsZCB3aWxsIGJlIHBvcHVsYXRlZCB3aXRoIGl0cyBpZCBmcm9tIHRoZVxuICogIFRyYW5zYWN0aW9uQ29udHJvbGxlciBzdGF0ZS4gVGhpcyBpcyByZXF1aXJlZCB0byBiZSBhYmxlIHRvIHVwZGF0ZSB0aGVcbiAqICB0cmFuc2FjdGlvbiBpbiB0aGUgY29udHJvbGxlci5cbiAqIEBwcm9wZXJ0eSB7UmVjaXBpZW50fSByZWNpcGllbnQgLSBBbiBvYmplY3QgdGhhdCBkZXNjcmliZXMgdGhlIGludGVuZGVkXG4gKiAgcmVjaXBpZW50IG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7TWFwVmFsdWVzVG9VbmlvbjxEcmFmdFR4U3RhdHVzPn0gc3RhdHVzIC0gRGVzY3JpYmVzIHRoZVxuICogIHZhbGlkaXR5IG9mIHRoZSBkcmFmdCB0cmFuc2FjdGlvbiwgd2hpY2ggd2lsbCBiZSBlaXRoZXIgJ1ZBTElEJyBvclxuICogICdJTlZBTElEJywgZGVwZW5kaW5nIG9uIG91ciBhYmlsaXR5IHRvIGdlbmVyYXRlIGEgdmFsaWQgdHhQYXJhbXMgb2JqZWN0IGZvclxuICogIHN1Ym1pc3Npb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdHJhbnNhY3Rpb25UeXBlIC0gRGV0ZXJtaW5lcyB0eXBlIG9mIHRyYW5zYWN0aW9uIGJlaW5nXG4gKiAgc2VudCwgZGVmYXVsdGVkIHRvIDB4MCAobGVnYWN5KS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbdXNlcklucHV0SGV4RGF0YV0gLSBXaGVuIGEgdXNlciBoYXMgZW5hYmxlZCBjdXN0b20gaGV4XG4gKiAgZGF0YSBmaWVsZCBpbiBhZHZhbmNlZCBvcHRpb25zLCB0aGV5IGNhbiBzdXBwbHkgZGF0YSB0byB0aGUgZmllbGQgd2hpY2ggaXNcbiAqICBzdG9yZWQgdW5kZXIgdGhpcyBrZXkuXG4gKi9cblxuLyoqXG4gKiBAdHlwZSB7RHJhZnRUcmFuc2FjdGlvbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUgPSB7XG4gIGFtb3VudDoge1xuICAgIGVycm9yOiBudWxsLFxuICAgIHZhbHVlOiAnMHgwJyxcbiAgfSxcbiAgYXNzZXQ6IHtcbiAgICBiYWxhbmNlOiAnMHgwJyxcbiAgICBkZXRhaWxzOiBudWxsLFxuICAgIGVycm9yOiBudWxsLFxuICAgIHR5cGU6IEFTU0VUX1RZUEVTLk5BVElWRSxcbiAgfSxcbiAgZnJvbUFjY291bnQ6IG51bGwsXG4gIGdhczoge1xuICAgIGVycm9yOiBudWxsLFxuICAgIGdhc0xpbWl0OiAnMHgwJyxcbiAgICBnYXNQcmljZTogJzB4MCcsXG4gICAgZ2FzVG90YWw6ICcweDAnLFxuICAgIG1heEZlZVBlckdhczogJzB4MCcsXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6ICcweDAnLFxuICAgIHdhc01hbnVhbGx5RWRpdGVkOiBmYWxzZSxcbiAgfSxcbiAgaGlzdG9yeTogW10sXG4gIGlkOiBudWxsLFxuICByZWNpcGllbnQ6IHtcbiAgICBhZGRyZXNzOiAnJyxcbiAgICBlcnJvcjogbnVsbCxcbiAgICBuaWNrbmFtZTogJycsXG4gICAgd2FybmluZzogbnVsbCxcbiAgICB0eXBlOiAnJyxcbiAgICByZWNpcGllbnRXYXJuaW5nQWNrbm93bGVkZ2VkOiBmYWxzZSxcbiAgfSxcbiAgc3RhdHVzOiBTRU5EX1NUQVRVU0VTLlZBTElELFxuICB0cmFuc2FjdGlvblR5cGU6IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkxFR0FDWSxcbiAgdXNlcklucHV0SGV4RGF0YTogbnVsbCxcbn07XG5cbi8qKlxuICogRGVzY3JpYmVzIHRoZSBzdGF0ZSB0cmVlIG9mIHRoZSBzZW5kIHNsaWNlXG4gKlxuICogQHR5cGVkZWYge29iamVjdH0gU2VuZFN0YXRlXG4gKiBAcHJvcGVydHkge01hcFZhbHVlc1RvVW5pb248U2VuZFN0YXRlQW1vdW50TW9kZXM+fSBhbW91bnRNb2RlIC0gRGVzY3JpYmVcbiAqICB3aGV0aGVyIHRoZSB1c2VyIGhhcyBtYW51YWxseSBpbnB1dCBhbiBhbW91bnQgb3IgaWYgdGhleSBoYXZlIHNlbGVjdGVkIG1heFxuICogIHRvIHNlbmQgdGhlIG1heGltdW0gYW1vdW50IG9mIHRoZSBzZWxlY3RlZCBjdXJyZW5jeS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjdXJyZW50VHJhbnNhY3Rpb25VVUlEIC0gVGhlIFVVSUQgb2YgdGhlIHRyYW5zYWN0aW9uXG4gKiAgY3VycmVudGx5IGJlaW5nIG1vZGlmaWVkIGJ5IHRoZSBzZW5kIGZsb3cuIFRoaXMgVVVJRCBpcyBnZW5lcmF0ZWQgdXBvblxuICogIGluaXRpYWxpemF0aW9uIG9mIHRoZSBzZW5kIGZsb3csIGFueSBwcmV2aW91cyBVVUlEcyBhcmUgZGlzY2FyZGVkIGF0XG4gKiAgY2xlYW4gdXAgQU5EIGR1cmluZyBpbml0aWFsaXphdGlvbi4gV2hlbiBhIHRyYW5zYWN0aW9uIGlzIGVkaXRlZCBhIG5ldyBVVUlEXG4gKiAgaXMgZ2VuZXJhdGVkIGZvciBpdCBhbmQgdGhlIHN0YXRlIG9mIHRoYXQgdHJhbnNhY3Rpb24gaXMgY29waWVkIGludG8gYSBuZXdcbiAqICBlbnRyeSBpbiB0aGUgZHJhZnRUcmFuc2FjdGlvbnMgb2JqZWN0LlxuICogQHByb3BlcnR5IHtPYmplY3Q8c3RyaW5nLCBEcmFmdFRyYW5zYWN0aW9uPn0gZHJhZnRUcmFuc2FjdGlvbnMgLSBBbiBvYmplY3Qga2V5ZWRcbiAqICBieSBVVUlEIHdpdGggZHJhZnRUcmFuc2FjdGlvbnMgYXMgdGhlIHZhbHVlcy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZWlwMTU1OXN1cHBvcnQgLSB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCBuZXR3b3JrXG4gKiAgc3VwcG9ydHMgRUlQIDE1NTkgdHJhbnNhY3Rpb25zLlxuICogQHByb3BlcnR5IHtib29sZWFufSBnYXNFc3RpbWF0ZUlzTG9hZGluZyAtIEluZGljYXRlcyB3aGV0aGVyIHRoZSBnYXNcbiAqICBlc3RpbWF0ZSBpcyBsb2FkaW5nLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtnYXNFc3RpbWF0ZVBvbGxUb2tlbl0gLSBTdHJpbmcgdG9rZW4gaWRlbnRpZnlpbmcgYVxuICogIGxpc3RlbmVyIGZvciBwb2xsaW5nIG9uIHRoZSBnYXNGZWVDb250cm9sbGVyXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGdhc0lzU2V0SW5Nb2RhbCAtIHRydWUgaWYgdGhlIHVzZXIgc2V0IGN1c3RvbSBnYXMgaW4gdGhlXG4gKiAgY3VzdG9tIGdhcyBtb2RhbFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdhc0xpbWl0TWluaW11bSAtIG1pbmltdW0gc3VwcG9ydGVkIGdhc0xpbWl0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGdhc1ByaWNlRXN0aW1hdGUgLSBFeHBlY3RlZCBwcmljZSBpbiB3ZWkgbmVjZXNzYXJ5IHRvXG4gKiAgcGF5IHBlciBnYXMgdXNlZCBmb3IgYSB0cmFuc2FjdGlvbiB0byBiZSBpbmNsdWRlZCBpbiBhIHJlYXNvbmFibGUgdGltZWZyYW1lLlxuICogIENvbWVzIGZyb20gdGhlIEdhc0ZlZUNvbnRyb2xsZXIuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gZ2FzVG90YWxGb3JMYXllcjEgLSAgTGF5ZXIgMSBnYXMgZmVlIHRvdGFsIG9uIG11bHRpLWxheWVyXG4gKiAgZmVlIG5ldHdvcmtzXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcmVjaXBpZW50SW5wdXQgLSBUaGUgdXNlciBpbnB1dCBvZiB0aGUgcmVjaXBpZW50XG4gKiAgd2hpY2ggaXMgdXBkYXRlZCBxdWlja2x5IHRvIGF2b2lkIGRlbGF5cyBpbiB0aGUgVUkgcmVmbGVjdGluZyBtYW51YWwgZW50cnlcbiAqICBvZiBhZGRyZXNzZXMuXG4gKiBAcHJvcGVydHkge01hcFZhbHVlc1RvVW5pb248U2VuZFN0YXRlUmVjaXBpZW50TW9kZXM+fSByZWNpcGllbnRNb2RlIC1cbiAqICBEZXNjcmliZXMgd2hpY2ggbGlzdCBvZiByZWNpcGllbnRzIHRoZSB1c2VyIGlzIHNob3duIG9uIHRoZSBhZGQgcmVjaXBpZW50XG4gKiAgc2NyZWVuLiBXaGVuIHRoaXMga2V5IGlzIHNldCB0byAnTVlfQUNDT1VOVFMnIHRoZSB1c2VyIGlzIHNob3duIHRoZSBsaXN0IG9mXG4gKiAgYWNjb3VudHMgdGhleSBvd24uIFdoZW4gaXQgaXMgJ0NPTlRBQ1RfTElTVCcgdGhlIHVzZXIgaXMgc2hvd24gdGhlIGxpc3Qgb2ZcbiAqICBjb250YWN0cyB0aGV5IGhhdmUgc2F2ZWQgaW4gTWV0YU1hc2sgYW5kIGFueSBhZGRyZXNzZXMgdGhleSBoYXZlIHJlY2VudGx5XG4gKiAgc2VudCB0by5cbiAqIEBwcm9wZXJ0eSB7QWNjb3VudH0gc2VsZWN0ZWRBY2NvdW50IC0gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBhY2NvdW50IGluXG4gKiAgTWV0YU1hc2suIE5hdGl2ZSBiYWxhbmNlIGFuZCBhZGRyZXNzIHdpbGwgYmUgcHVsbGVkIGZyb20gdGhpcyBhY2NvdW50IGlmIGFcbiAqICBmcm9tQWNjb3VudCBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBkcmFmdFRyYW5zYWN0aW9uIG9iamVjdC4gRHVyaW5nIGFuIGVkaXRcbiAqICB0aGUgZnJvbUFjY291bnQgaXMgc3BlY2lmaWVkLlxuICogQHByb3BlcnR5IHtNYXBWYWx1ZXNUb1VuaW9uPFNlbmRTdGF0ZVN0YWdlcz59IHN0YWdlIC0gVGhlIHN0YWdlIG9mIHRoZVxuICogIHNlbmQgZmxvdyB0aGF0IHRoZSB1c2VyIGhhcyBwcm9ncmVzc2VkIHRvLiBEZWZhdWx0cyB0byAnSU5BQ1RJVkUnIHdoaWNoXG4gKiAgcmVzdWx0cyBpbiB0aGUgc2VuZCBzY3JlZW4gbm90IGJlaW5nIHNob3duLlxuICovXG5cbi8qKlxuICogQHR5cGUge1NlbmRTdGF0ZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRpYWxTdGF0ZSA9IHtcbiAgYW1vdW50TW9kZTogQU1PVU5UX01PREVTLklOUFVULFxuICBjdXJyZW50VHJhbnNhY3Rpb25VVUlEOiBudWxsLFxuICBkcmFmdFRyYW5zYWN0aW9uczoge30sXG4gIGVpcDE1NTlzdXBwb3J0OiBmYWxzZSxcbiAgZ2FzRXN0aW1hdGVJc0xvYWRpbmc6IHRydWUsXG4gIGdhc0VzdGltYXRlUG9sbFRva2VuOiBudWxsLFxuICBnYXNJc1NldEluTW9kYWw6IGZhbHNlLFxuICBnYXNQcmljZUVzdGltYXRlOiAnMHgwJyxcbiAgZ2FzTGltaXRNaW5pbXVtOiBHQVNfTElNSVRTLlNJTVBMRSxcbiAgZ2FzVG90YWxGb3JMYXllcjE6ICcweDAnLFxuICByZWNpcGllbnRNb2RlOiBSRUNJUElFTlRfU0VBUkNIX01PREVTLkNPTlRBQ1RfTElTVCxcbiAgcmVjaXBpZW50SW5wdXQ6ICcnLFxuICBzZWxlY3RlZEFjY291bnQ6IHtcbiAgICBhZGRyZXNzOiBudWxsLFxuICAgIGJhbGFuY2U6ICcweDAnLFxuICB9LFxuICBzdGFnZTogU0VORF9TVEFHRVMuSU5BQ1RJVkUsXG59O1xuXG4vKipcbiAqIFRPRE86IFdlIHJlYWxseSBuZWVkIHRvIHN0YXJ0IGNyZWF0aW5nIHRoZSBtZXRhbWFzayBzdGF0ZSB0eXBlLCBhbmQgdGhlXG4gKiBlbnRpcmUgc3RhdGUgdHJlZSBvZiByZWR1eC4gV291bGQgYmUgKmV4dHJlbWVseSogdmFsdWFibGUgaW4gZnV0dXJlXG4gKiB0eXBlc2NyaXB0IGNvbnZlcnNpb25zLiBUaGUgbWV0YW1hc2sga2V5IGlzIHR5cGVkIGFzIGFuIG9iamVjdCBvbiBwdXJwb3NlXG4gKiBoZXJlIGJlY2F1c2UgSSBjYW5ub3QgZ28gc28gZmFyIGluIHRoaXMgd29yayBhcyB0byB0eXBlIHRoYXQgZW50aXJlIG9iamVjdC5cbiAqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBNZXRhTWFza1N0YXRlXG4gKiBAcHJvcGVydHkge1NlbmRTdGF0ZX0gc2VuZCAtIFRoZSBzdGF0ZSBvZiB0aGUgc2VuZCBmbG93LlxuICogQHByb3BlcnR5IHtvYmplY3R9IG1ldGFtYXNrIC0gVGhlIHN0YXRlIG9mIHRoZSBtZXRhbWFzayBzdG9yZS5cbiAqL1xuXG5jb25zdCBuYW1lID0gJ3NlbmQnO1xuXG4vLyBBZnRlciBtb2RpZmljYXRpb24gb2Ygc3BlY2lmaWMgZmllbGRzIGluIHNwZWNpZmljIGNpcmN1bXN0YW5jZXMgd2UgbXVzdFxuLy8gcmVjb21wdXRlIHRoZSBnYXNMaW1pdCBlc3RpbWF0ZSB0byBiZSBhcyBhY2N1cmF0ZSBhcyBwb3NzaWJsZS4gdGhlIGNhc2VzXG4vLyB0aGF0IG5lY2Vzc2l0YXRlIHRoaXMgbG9naWMgYXJlIGxpc3RlZCBiZWxvdzpcbi8vIDEuIHdoZW4gdGhlIGFtb3VudCBzZW50IGNoYW5nZXMgd2hlbiBzZW5kaW5nIGEgdG9rZW4gZHVlIHRvIHRoZSBhbW91bnQgYmVpbmdcbi8vICAgIHBhcnQgb2YgdGhlIGhleCBlbmNvZGVkIGRhdGEgcHJvcGVydHkgb2YgdGhlIHRyYW5zYWN0aW9uLlxuLy8gMi4gd2hlbiB1cGRhdGluZyB0aGUgZGF0YSBwcm9wZXJ0eSB3aGlsZSBzZW5kaW5nIE5BVElWRSBjdXJyZW5jeSAoZXg6IEVUSClcbi8vICAgIGJlY2F1c2UgdGhlIGRhdGEgcGFyYW1ldGVyIGRlZmluZXMgZnVuY3Rpb24gY2FsbHMgdGhhdCB0aGUgRVZNIHdpbGwgaGF2ZVxuLy8gICAgdG8gZXhlY3V0ZSB3aGljaCBpcyB3aGVyZSBhIGxhcmdlIGNodW5rIG9mIGdhcyBpcyBwb3RlbnRpYWxseSBjb25zdW1lZC5cbi8vIDMuIHdoZW4gdGhlIHJlY2lwaWVudCBjaGFuZ2VzIHdoaWxlIHNlbmRpbmcgYSB0b2tlbiBkdWUgdG8gdGhlIHJlY2lwaWVudCdzXG4vLyAgICBhZGRyZXNzIGJlaW5nIGluY2x1ZGVkIGluIHRoZSBoZXggZW5jb2RlZCBkYXRhIHByb3BlcnR5IG9mIHRoZVxuLy8gICAgdHJhbnNhY3Rpb25cbi8vIDQuIHdoZW4gdGhlIGFzc2V0IGJlaW5nIHNlbnQgY2hhbmdlcyBkdWUgdG8gdGhlIGNvbnRyYWN0IGFkZHJlc3MgYW5kIGRldGFpbHNcbi8vICAgIG9mIHRoZSB0b2tlbiBiZWluZyBpbmNsdWRlZCBpbiB0aGUgaGV4IGVuY29kZWQgZGF0YSBwcm9wZXJ0eSBvZiB0aGVcbi8vICAgIHRyYW5zYWN0aW9uLiBJZiBzd2l0Y2hpbmcgdG8gTkFUSVZFIGN1cnJlbmN5IChleDogRVRIKSwgdGhlIGdhc0xpbWl0IHdpbGxcbi8vICAgIGNoYW5nZSBkdWUgdG8gaGV4IGRhdGEgYmVpbmcgcmVtb3ZlZCAodW5sZXNzIHN1cHBsaWVkIGJ5IHVzZXIpLlxuLy8gVGhpcyBtZXRob2QgY29tcHV0ZXMgdGhlIGdhc0xpbWl0IGVzdGltYXRlIHdoaWNoIGlzIHdyaXR0ZW4gdG8gc3RhdGUgaW4gYW5cbi8vIGFjdGlvbiBoYW5kbGVyIGluIGV4dHJhUmVkdWNlcnMuXG5leHBvcnQgY29uc3QgY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0ID0gY3JlYXRlQXN5bmNUaHVuayhcbiAgJ3NlbmQvY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0JyxcbiAgYXN5bmMgKF8sIHRodW5rQXBpKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aHVua0FwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHsgc2VuZCwgbWV0YW1hc2sgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc2VuZC5kcmFmdFRyYW5zYWN0aW9uc1tzZW5kLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgIGNvbnN0IHVuYXBwcm92ZWRUeHMgPSBnZXRVbmFwcHJvdmVkVHhzKHN0YXRlKTtcbiAgICBjb25zdCBpc011bHRpTGF5ZXJGZWVOZXR3b3JrID0gZ2V0SXNNdWx0aUxheWVyRmVlTmV0d29yayhzdGF0ZSk7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB1bmFwcHJvdmVkVHhzW2RyYWZ0VHJhbnNhY3Rpb24uaWRdO1xuICAgIGNvbnN0IGlzTm9uU3RhbmRhcmRFdGhDaGFpbiA9IGdldElzTm9uU3RhbmRhcmRFdGhDaGFpbihzdGF0ZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKHN0YXRlKTtcblxuICAgIGxldCBnYXNUb3RhbEZvckxheWVyMTtcbiAgICBpZiAoaXNNdWx0aUxheWVyRmVlTmV0d29yaykge1xuICAgICAgZ2FzVG90YWxGb3JMYXllcjEgPSBhd2FpdCBmZXRjaEVzdGltYXRlZEwxRmVlKGdsb2JhbC5ldGgsIHtcbiAgICAgICAgdHhQYXJhbXM6IHtcbiAgICAgICAgICBnYXNQcmljZTogZHJhZnRUcmFuc2FjdGlvbi5nYXMuZ2FzUHJpY2UsXG4gICAgICAgICAgZ2FzOiBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCxcbiAgICAgICAgICB0bzogZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcz8udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICB2YWx1ZTpcbiAgICAgICAgICAgIHNlbmQuYW1vdW50TW9kZSA9PT0gQU1PVU5UX01PREVTLk1BWFxuICAgICAgICAgICAgICA/IHNlbmQuc2VsZWN0ZWRBY2NvdW50LmJhbGFuY2VcbiAgICAgICAgICAgICAgOiBkcmFmdFRyYW5zYWN0aW9uLmFtb3VudC52YWx1ZSxcbiAgICAgICAgICBmcm9tOiBzZW5kLnNlbGVjdGVkQWNjb3VudC5hZGRyZXNzLFxuICAgICAgICAgIGRhdGE6IGRyYWZ0VHJhbnNhY3Rpb24udXNlcklucHV0SGV4RGF0YSxcbiAgICAgICAgICB0eXBlOiAnMHgwJyxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHNlbmQuc3RhZ2UgIT09IFNFTkRfU1RBR0VTLkVESVQgfHxcbiAgICAgICF0cmFuc2FjdGlvbi5kYXBwU3VnZ2VzdGVkR2FzRmVlcz8uZ2FzIHx8XG4gICAgICAhdHJhbnNhY3Rpb24udXNlckVkaXRlZEdhc0xpbWl0XG4gICAgKSB7XG4gICAgICBjb25zdCBnYXNMaW1pdCA9IGF3YWl0IGVzdGltYXRlR2FzTGltaXRGb3JTZW5kKHtcbiAgICAgICAgZ2FzUHJpY2U6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlLFxuICAgICAgICBibG9ja0dhc0xpbWl0OiBtZXRhbWFzay5jdXJyZW50QmxvY2tHYXNMaW1pdCxcbiAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOiBtZXRhbWFzay5zZWxlY3RlZEFkZHJlc3MsXG4gICAgICAgIHNlbmRUb2tlbjogZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5kZXRhaWxzLFxuICAgICAgICB0bzogZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcz8udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgdmFsdWU6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICBkYXRhOiBkcmFmdFRyYW5zYWN0aW9uLnVzZXJJbnB1dEhleERhdGEsXG4gICAgICAgIGlzTm9uU3RhbmRhcmRFdGhDaGFpbixcbiAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgZ2FzTGltaXQ6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0LFxuICAgICAgfSk7XG4gICAgICBhd2FpdCB0aHVua0FwaS5kaXNwYXRjaChzZXRDdXN0b21HYXNMaW1pdChnYXNMaW1pdCkpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgIGdhc1RvdGFsRm9yTGF5ZXIxLFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4pO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEFzc2V0XG4gKiBAcHJvcGVydHkge0Fzc2V0VHlwZXNTdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBhc3NldCB0aGF0IHRoZSB1c2VyXG4gKiAgaXMgYXR0ZW1wdGluZyB0byBzZW5kLiBEZWZhdWx0cyB0byAnTkFUSVZFJyB3aGljaCByZXByZXNlbnRzIHRoZSBuYXRpdmVcbiAqICBhc3NldCBvZiB0aGUgY2hhaW4uIENhbiBhbHNvIGJlICdUT0tFTicgb3IgJ0NPTExFQ1RJQkxFJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBiYWxhbmNlIC0gQSBoZXggc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgYmFsYW5jZVxuICogIHRoYXQgdGhlIHVzZXIgaG9sZHMgb2YgdGhlIGFzc2V0IHRoYXQgdGhleSBhcmUgYXR0ZW1wdGluZyB0byBzZW5kLlxuICogQHByb3BlcnR5IHtUb2tlbkRldGFpbHN9IFtkZXRhaWxzXSAtIEFuIG9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGVcbiAqICBzZWxlY3RlZCBhc3NldCBpbiB0aGUgY2FzZSB0aGF0IHRoZSB1c2VyIGlzIHNlbmRpbmcgYSB0b2tlbiBvciBjb2xsZWN0aWJlLlxuICogIFdpbGwgYmUgbnVsbCB3aGVuIGFzc2V0LnR5cGUgaXMgJ05BVElWRScuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2Vycm9yXSAtIEVycm9yIHRvIGRpc3BsYXkgd2hlbiB0aGVyZSBpcyBhbiBpc3N1ZVxuICogIHdpdGggdGhlIGFzc2V0LlxuICovXG5cbi8qKlxuICogUmVzcG9uc2libGUgZm9yIGluaXRpYWxpemluZyByZXF1aXJlZCBzdGF0ZSBmb3IgdGhlIHNlbmQgc2xpY2UuXG4gKiBUaGlzIG1ldGhvZCBpcyBkaXNwYXRjaGVkIGZyb20gdGhlIHNlbmQgcGFnZSBpbiB0aGUgY29tcG9uZW50RGlkTW91bnRcbiAqIG1ldGhvZC4gSXQgaXMgYWxzbyBkaXNwYXRjaGVkIGFueXRpbWUgdGhlIG5ldHdvcmsgY2hhbmdlcyB0byBlbnN1cmUgdGhhdFxuICogdGhlIHNsaWNlIHJlbWFpbnMgdmFsaWQgd2l0aCBjaGFuZ2luZyB0b2tlbiBhbmQgYWNjb3VudCBiYWxhbmNlcy4gVG8gZG8gc29cbiAqIGl0IGtleXMgaW50byBzdGF0ZSB0byBnZXQgbmVjZXNzYXJ5IHZhbHVlcyBhbmQgY29tcHV0ZXMgYSBzdGFydGluZyBwb2ludCBmb3JcbiAqIHRoZSBzZW5kIHNsaWNlLiBJdCByZXR1cm5zIHRoZSB2YWx1ZXMgdGhhdCBtaWdodCBjaGFuZ2UgZnJvbSB0aGlzIGFjdGlvbiBhbmRcbiAqIHRob3NlIHZhbHVlcyBhcmUgd3JpdHRlbiB0byB0aGUgc2xpY2UgaW4gdGhlIGBpbml0aWFsaXplU2VuZFN0YXRlLmZ1bGZpbGxlZGBcbiAqIGFjdGlvbiBoYW5kbGVyLlxuICovXG5leHBvcnQgY29uc3QgaW5pdGlhbGl6ZVNlbmRTdGF0ZSA9IGNyZWF0ZUFzeW5jVGh1bmsoXG4gICdzZW5kL2luaXRpYWxpemVTZW5kU3RhdGUnLFxuICBhc3luYyAoeyBjaGFpbkhhc0NoYW5nZWQgPSBmYWxzZSB9ID0ge30sIHRodW5rQXBpKSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGVkZWYge29iamVjdH0gUmVkdXhTdGF0ZVxuICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBtZXRhbWFzayAtIEhhbGYgYmFrZWQgdHlwZSBmb3IgdGhlIE1ldGFNYXNrIG9iamVjdFxuICAgICAqIEBwcm9wZXJ0eSB7U2VuZFN0YXRlfSBzZW5kIC0gdGhlIHNlbmQgc3RhdGVcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtSZWR1eFN0YXRlfVxuICAgICAqL1xuICAgIGNvbnN0IHN0YXRlID0gdGh1bmtBcGkuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBpc05vblN0YW5kYXJkRXRoQ2hhaW4gPSBnZXRJc05vblN0YW5kYXJkRXRoQ2hhaW4oc3RhdGUpO1xuICAgIGNvbnN0IGNoYWluSWQgPSBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSk7XG4gICAgY29uc3QgZWlwMTU1OXN1cHBvcnQgPSBjaGVja05ldHdvcmtBbmRBY2NvdW50U3VwcG9ydHMxNTU5KHN0YXRlKTtcbiAgICBjb25zdCBhY2NvdW50ID0gZ2V0U2VsZWN0ZWRBY2NvdW50KHN0YXRlKTtcbiAgICBjb25zdCB7IHNlbmQ6IHNlbmRTdGF0ZSwgbWV0YW1hc2sgfSA9IHN0YXRlO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc2VuZFN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3NlbmRTdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcblxuICAgIC8vIElmIHRoZSBkcmFmdCB0cmFuc2FjdGlvbiBpcyBub3QgcHJlc2VudCwgdGhlbiB0aGlzIGFjdGlvbiBoYXMgYmVlblxuICAgIC8vIGRpc3BhdGNoZWQgb3V0IG9mIHN5bmMgd2l0aCB0aGUgaW50ZW5kZWQgZmxvdy4gVGhpcyBpcyBub3QgYWx3YXlzIGEgYnVnLlxuICAgIC8vIEZvciBpbnN0YW5jZSwgaW4gdGhlIGFjdGlvbnMuanMgZmlsZSB3ZSBkaXNwYXRjaCB0aGlzIGFjdGlvbiBhbnl0aW1lIHRoZVxuICAgIC8vIGNoYWluIGNoYW5nZXMuXG4gICAgaWYgKCFkcmFmdFRyYW5zYWN0aW9uKSB7XG4gICAgICByZXR1cm4gdGh1bmtBcGkucmVqZWN0V2l0aFZhbHVlKFxuICAgICAgICAnZHJhZnRUcmFuc2FjdGlvbiBub3QgZm91bmQsIHBvc3NpYmx5IG5vdCBvbiBzZW5kIGZsb3cnLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IGdhc1ByaWNlIHRvIDEgZ3dlaSBpZiBhbGwgZXN0aW1hdGlvbiBmYWlscywgdGhpcyBpcyBvbmx5IHVzZWRcbiAgICAvLyBmb3IgZ2FzTGltaXQgZXN0aW1hdGlvbiBhbmQgd29uJ3QgYmUgc2V0IGRpcmVjdGx5IGluIHN0YXRlLiBJbnN0ZWFkLCB3ZVxuICAgIC8vIHdpbGwgcmV0dXJuIHRoZSBnYXNGZWVFc3RpbWF0ZXMgYW5kIGdhc0VzdGltYXRlVHlwZSBzbyB0aGF0IHRoZSByZWR1Y2VyXG4gICAgLy8gY2FuIHNldCB0aGUgYXBwcm9wcmlhdGUgZ2FzIGZlZXMgaW4gc3RhdGUuXG4gICAgbGV0IGdhc1ByaWNlID1cbiAgICAgIHNlbmRTdGF0ZS5zdGFnZSA9PT0gU0VORF9TVEFHRVMuRURJVFxuICAgICAgICA/IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlXG4gICAgICAgIDogJzB4MSc7XG4gICAgbGV0IGdhc0VzdGltYXRlUG9sbFRva2VuID0gbnVsbDtcblxuICAgIC8vIEluc3RydWN0IHRoZSBiYWNrZ3JvdW5kIHByb2Nlc3MgdGhhdCBwb2xsaW5nIGZvciBnYXMgcHJpY2VzIHNob3VsZCBiZWdpblxuICAgIGdhc0VzdGltYXRlUG9sbFRva2VuID0gYXdhaXQgZ2V0R2FzRmVlRXN0aW1hdGVzQW5kU3RhcnRQb2xsaW5nKCk7XG5cbiAgICBhZGRQb2xsaW5nVG9rZW5Ub0FwcFN0YXRlKGdhc0VzdGltYXRlUG9sbFRva2VuKTtcblxuICAgIGNvbnN0IHtcbiAgICAgIG1ldGFtYXNrOiB7IGdhc0ZlZUVzdGltYXRlcywgZ2FzRXN0aW1hdGVUeXBlIH0sXG4gICAgfSA9IHRodW5rQXBpLmdldFN0YXRlKCk7XG5cbiAgICBpZiAoc2VuZFN0YXRlLnN0YWdlICE9PSBTRU5EX1NUQUdFUy5FRElUKSB7XG4gICAgICAvLyBCZWNhdXNlIHdlIGFyZSBvbmx5IGludGVyZXN0ZWQgaW4gZ2V0dGluZyBhIGdhc0xpbWl0IGVzdGltYXRpb24gd2Ugb25seVxuICAgICAgLy8gbmVlZCB0byB3b3JyeSBhYm91dCBnYXNQcmljZS4gU28gd2UgdXNlIG1heEZlZVBlckdhcyBhcyBnYXNQcmljZSBpZiB3ZVxuICAgICAgLy8gaGF2ZSBhIGZlZSBtYXJrZXQgZXN0aW1hdGlvbi5cbiAgICAgIGlmIChnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5MRUdBQ1kpIHtcbiAgICAgICAgZ2FzUHJpY2UgPSBnZXRHYXNQcmljZUluSGV4V2VpKGdhc0ZlZUVzdGltYXRlcy5tZWRpdW0pO1xuICAgICAgfSBlbHNlIGlmIChnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5FVEhfR0FTUFJJQ0UpIHtcbiAgICAgICAgZ2FzUHJpY2UgPSBnZXRSb3VuZGVkR2FzUHJpY2UoZ2FzRmVlRXN0aW1hdGVzLmdhc1ByaWNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZ2FzRXN0aW1hdGVUeXBlID09PSBHQVNfRVNUSU1BVEVfVFlQRVMuRkVFX01BUktFVCkge1xuICAgICAgICBnYXNQcmljZSA9IGdldEdhc1ByaWNlSW5IZXhXZWkoXG4gICAgICAgICAgZ2FzRmVlRXN0aW1hdGVzLm1lZGl1bS5zdWdnZXN0ZWRNYXhGZWVQZXJHYXMsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnYXNQcmljZSA9IGdhc0ZlZUVzdGltYXRlcy5nYXNQcmljZVxuICAgICAgICAgID8gZ2V0Um91bmRlZEdhc1ByaWNlKGdhc0ZlZUVzdGltYXRlcy5nYXNQcmljZSlcbiAgICAgICAgICA6ICcweDAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCBhIGJhc2ljIGdhc0xpbWl0IGluIHRoZSBldmVudCB0aGF0IG90aGVyIGVzdGltYXRpb24gZmFpbHNcbiAgICBsZXQgeyBnYXNMaW1pdCB9ID0gZHJhZnRUcmFuc2FjdGlvbi5nYXM7XG4gICAgaWYgKFxuICAgICAgZ2FzRXN0aW1hdGVUeXBlICE9PSBHQVNfRVNUSU1BVEVfVFlQRVMuTk9ORSAmJlxuICAgICAgc2VuZFN0YXRlLnN0YWdlICE9PSBTRU5EX1NUQUdFUy5FRElUICYmXG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzXG4gICAgKSB7XG4gICAgICBnYXNMaW1pdCA9XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4gfHxcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgICAgID8gR0FTX0xJTUlUUy5CQVNFX1RPS0VOX0VTVElNQVRFXG4gICAgICAgICAgOiBHQVNfTElNSVRTLlNJTVBMRTtcbiAgICAgIC8vIFJ1biBvdXIgZXN0aW1hdGVHYXNMaW1pdCBsb2dpYyB0byBnZXQgYSBtb3JlIGFjY3VyYXRlIGVzdGltYXRpb24gb2ZcbiAgICAgIC8vIHJlcXVpcmVkIGdhcy4gSWYgdGhpcyB2YWx1ZSBpc24ndCBudWxsaXNoLCBzZXQgaXQgYXMgdGhlIG5ldyBnYXNMaW1pdFxuICAgICAgY29uc3QgZXN0aW1hdGVkR2FzTGltaXQgPSBhd2FpdCBlc3RpbWF0ZUdhc0xpbWl0Rm9yU2VuZCh7XG4gICAgICAgIGdhc1ByaWNlLFxuICAgICAgICBibG9ja0dhc0xpbWl0OiBtZXRhbWFzay5jdXJyZW50QmxvY2tHYXNMaW1pdCxcbiAgICAgICAgc2VsZWN0ZWRBZGRyZXNzOlxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZnJvbUFjY291bnQ/LmFkZHJlc3MgPz9cbiAgICAgICAgICBzZW5kU3RhdGUuc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MsXG4gICAgICAgIHNlbmRUb2tlbjogZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5kZXRhaWxzLFxuICAgICAgICB0bzogZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICB2YWx1ZTogZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQudmFsdWUsXG4gICAgICAgIGRhdGE6IGRyYWZ0VHJhbnNhY3Rpb24udXNlcklucHV0SGV4RGF0YSxcbiAgICAgICAgaXNOb25TdGFuZGFyZEV0aENoYWluLFxuICAgICAgICBjaGFpbklkLFxuICAgICAgfSk7XG4gICAgICBnYXNMaW1pdCA9IGVzdGltYXRlZEdhc0xpbWl0IHx8IGdhc0xpbWl0O1xuICAgIH1cbiAgICAvLyBXZSBoYXZlIHRvIGtlZXAgdGhlIGdhcyBzbGljZSBpbiBzeW5jIHdpdGggdGhlIHNlbmQgc2xpY2Ugc3RhdGVcbiAgICAvLyBzbyB0aGF0IGl0J2xsIGJlIGluaXRpYWxpemVkIGNvcnJlY3RseSBpZiB0aGUgZ2FzIG1vZGFsIGlzIG9wZW5lZC5cbiAgICBhd2FpdCB0aHVua0FwaS5kaXNwYXRjaChzZXRDdXN0b21HYXNMaW1pdChnYXNMaW1pdCkpO1xuXG4gICAgLy8gVGhlcmUgbWF5IGJlIGEgY2FzZSB3aGVyZSB0aGUgc2VuZCBoYXMgYmVlbiBjYW5jZWxlZCBieSB0aGUgdXNlciB3aGlsZVxuICAgIC8vIHRoZSBnYXMgZXN0aW1hdGUgaXMgYmVpbmcgY29tcHV0ZWQuIFNvIHdlIGNoZWNrIGFnYWluIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgLy8gYSBjdXJyZW50VHJhbnNhY3Rpb25VVUlEIGV4aXN0cyBhbmQgbWF0Y2hlcyB0aGUgcHJldmlvdXMgdHguXG4gICAgY29uc3QgbmV3U3RhdGUgPSB0aHVua0FwaS5nZXRTdGF0ZSgpO1xuICAgIGlmIChcbiAgICAgIG5ld1N0YXRlLnNlbmQuY3VycmVudFRyYW5zYWN0aW9uVVVJRCAhPT0gc2VuZFN0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURcbiAgICApIHtcbiAgICAgIHJldHVybiB0aHVua0FwaS5yZWplY3RXaXRoVmFsdWUoXG4gICAgICAgIGBkcmFmdFRyYW5zYWN0aW9uIGNoYW5nZWQgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgICAgICBBIG5ldyBpbml0aWFsaXplU2VuZFN0YXRlIGFjdGlvbiBtdXN0IGJlIGRpc3BhdGNoZWQuYCxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFjY291bnQsXG4gICAgICBjaGFpbklkOiBnZXRDdXJyZW50Q2hhaW5JZChzdGF0ZSksXG4gICAgICB0b2tlbnM6IGdldFRva2VucyhzdGF0ZSksXG4gICAgICBjaGFpbkhhc0NoYW5nZWQsXG4gICAgICBnYXNGZWVFc3RpbWF0ZXMsXG4gICAgICBnYXNFc3RpbWF0ZVR5cGUsXG4gICAgICBnYXNMaW1pdCxcbiAgICAgIGdhc1RvdGFsOiBhZGRIZXhQcmVmaXgoY2FsY0dhc1RvdGFsKGdhc0xpbWl0LCBnYXNQcmljZSkpLFxuICAgICAgZ2FzRXN0aW1hdGVQb2xsVG9rZW4sXG4gICAgICBlaXAxNTU5c3VwcG9ydCxcbiAgICAgIHVzZVRva2VuRGV0ZWN0aW9uOiBnZXRVc2VUb2tlbkRldGVjdGlvbihzdGF0ZSksXG4gICAgICB0b2tlbkFkZHJlc3NMaXN0OiBPYmplY3Qua2V5cyhnZXRUb2tlbkxpc3Qoc3RhdGUpKSxcbiAgICB9O1xuICB9LFxuKTtcblxuLy8gQWN0aW9uIFBheWxvYWQgVHlwZWRlZnNcbi8qKlxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0ByZWR1eGpzL3Rvb2xraXQnKS5QYXlsb2FkQWN0aW9uPHN0cmluZz5cbiAqICl9IFNpbXBsZVN0cmluZ1BheWxvYWRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAcmVkdXhqcy90b29sa2l0JykuUGF5bG9hZEFjdGlvbjxNYXBWYWx1ZXNUb1VuaW9uPFNlbmRTdGF0ZUFtb3VudE1vZGVzPj5cbiAqICl9IFNlbmRTdGF0ZUFtb3VudE1vZGVQYXlsb2FkXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnQHJlZHV4anMvdG9vbGtpdCcpLlBheWxvYWRBY3Rpb248RHJhZnRUcmFuc2FjdGlvblsnYXNzZXQnXT5cbiAqICl9IFVwZGF0ZUFzc2V0UGF5bG9hZFxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0ByZWR1eGpzL3Rvb2xraXQnKS5QYXlsb2FkQWN0aW9uPFBhcnRpYWw8XG4gKiAgIFBpY2s8RHJhZnRUcmFuc2FjdGlvblsncmVjaXBpZW50J10sICdhZGRyZXNzJyB8ICduaWNrbmFtZSc+PlxuICogID5cbiAqICl9IHVwZGF0ZVJlY2lwaWVudFBheWxvYWRcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAcmVkdXhqcy90b29sa2l0JykuUGF5bG9hZEFjdGlvbjxTZW5kU3RhdGVbJ3JlY2lwaWVudE1vZGUnXT5cbiAqICl9IFVwZGF0ZVJlY2lwaWVudE1vZGVQYXlsb2FkXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBHYXNGZWVVcGRhdGVQYXJhbXNcbiAqIEBwcm9wZXJ0eSB7VHJhbnNhY3Rpb25UeXBlU3RyaW5nfSB0cmFuc2FjdGlvblR5cGUgLSBUaGUgdHJhbnNhY3Rpb24gdHlwZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFttYXhGZWVQZXJHYXNdIC0gVGhlIG1heGltdW0gYW1vdW50IGluIGhleCB3ZWkgdG8gcGF5XG4gKiAgcGVyIGdhcyBvbiBhIEZFRV9NQVJLRVQgdHJhbnNhY3Rpb24uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW21heFByaW9yaXR5RmVlUGVyR2FzXSAtIFRoZSBtYXhpbXVtIGFtb3VudCBpbiBoZXhcbiAqICB3ZWkgdG8gcGF5IHBlciBnYXMgYXMgYW4gaW5jZW50aXZlIHRvIG1pbmVycyBvbiBhIEZFRV9NQVJLRVRcbiAqICB0cmFuc2FjdGlvbi5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZ2FzUHJpY2VdIC0gVGhlIGFtb3VudCBpbiBoZXggd2VpIHRvIHBheSBwZXIgZ2FzIG9uXG4gKiAgYSBMRUdBQ1kgdHJhbnNhY3Rpb24uXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpc0F1dG9tYXRpY1VwZGF0ZV0gLSB0cnVlIGlmIHRoZSB1cGRhdGUgaXMgdGhlXG4gKiAgcmVzdWx0IG9mIGEgZ2FzIGVzdGltYXRlIHVwZGF0ZSBmcm9tIHRoZSBjb250cm9sbGVyLlxuICogQHR5cGVkZWYgeyhcbiAqICBpbXBvcnQoJ0ByZWR1eGpzL3Rvb2xraXQnKS5QYXlsb2FkQWN0aW9uPEdhc0ZlZVVwZGF0ZVBhcmFtcz5cbiAqICl9IEdhc0ZlZVVwZGF0ZVBheWxvYWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEdhc0VzdGltYXRlVXBkYXRlUGFyYW1zXG4gKiBAcHJvcGVydHkge0dhc0VzdGltYXRlVHlwZX0gZ2FzRXN0aW1hdGVUeXBlIC0gVGhlIHR5cGUgb2YgZ2FzIGVzdGltYXRpb25cbiAqICBwcm92aWRlZCBieSB0aGUgY29udHJvbGxlci5cbiAqIEBwcm9wZXJ0eSB7KFxuICogIEV0aEdhc1ByaWNlRXN0aW1hdGUgfCBMZWdhY3lHYXNQcmljZUVzdGltYXRlIHwgR2FzRmVlRXN0aW1hdGVzXG4gKiApfSBnYXNGZWVFc3RpbWF0ZXMgLSBUaGUgZ2FzIGZlZSBlc3RpbWF0ZXMgcHJvdmlkZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnQHJlZHV4anMvdG9vbGtpdCcpLlBheWxvYWRBY3Rpb248R2FzRXN0aW1hdGVVcGRhdGVQYXJhbXM+XG4gKiApfSBHYXNFc3RpbWF0ZVVwZGF0ZVBheWxvYWRcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHsoXG4gKiAgaW1wb3J0KCdAcmVkdXhqcy90b29sa2l0JykuUGF5bG9hZEFjdGlvbjxEcmFmdFRyYW5zYWN0aW9uWydhc3NldCddPlxuICogKX0gVXBkYXRlQXNzZXRQYXlsb2FkXG4gKiBAdHlwZWRlZiB7KFxuICogIGltcG9ydCgnQHJlZHV4anMvdG9vbGtpdCcpLlBheWxvYWRBY3Rpb248RHJhZnRUcmFuc2FjdGlvbj5cbiAqICl9IERyYWZ0VHJhbnNhY3Rpb25QYXlsb2FkXG4gKi9cblxuY29uc3Qgc2xpY2UgPSBjcmVhdGVTbGljZSh7XG4gIG5hbWUsXG4gIGluaXRpYWxTdGF0ZSxcbiAgcmVkdWNlcnM6IHtcbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGRyYWZ0IHRyYW5zYWN0aW9uIHRvIHN0YXRlLCBmaXJzdCBnZW5lcmF0aW5nIGEgbmV3IFVVSUQgZm9yXG4gICAgICogdGhlIHRyYW5zYWN0aW9uIGFuZCBzZXR0aW5nIHRoYXQgYXMgdGhlIGN1cnJlbnRUcmFuc2FjdGlvblVVSUQuIElmIHRoZVxuICAgICAqIGRyYWZ0IGhhcyBhbiBpZCBwcm9wZXJ0eSBzZXQsIHRoZSBzdGFnZSBpcyBzZXQgdG8gRURJVC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7RHJhZnRUcmFuc2FjdGlvblBheWxvYWR9IGFjdGlvbiAtIEFuIGFjdGlvbiB3aXRoIHBheWxvYWQgdGhhdCBpc1xuICAgICAqICBhIG5ldyBkcmFmdCB0cmFuc2FjdGlvbiB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gc3RhdGUuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgYWRkTmV3RHJhZnQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEID0gdXVpZHY0KCk7XG4gICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkLmlkKSB7XG4gICAgICAgIHN0YXRlLnN0YWdlID0gU0VORF9TVEFHRVMuRURJVDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnN0YWdlID0gU0VORF9TVEFHRVMuQUREX1JFQ0lQSUVOVDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZW50cnksIHdpdGggdGltZXN0YW1wLCB0byB0aGUgZHJhZnRUcmFuc2FjdGlvbiBoaXN0b3J5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtTaW1wbGVTdHJpbmdQYXlsb2FkfSBhY3Rpb24gLSBBbiBhY3Rpb24gd2l0aCBwYXlsb2FkIHRoYXQgaXNcbiAgICAgKiAgYSBzdHJpbmcgdG8gYmUgYWRkZWQgdG8gdGhlIGhpc3Rvcnkgb2YgdGhlIGRyYWZ0VHJhbnNhY3Rpb25cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICBhZGRIaXN0b3J5RW50cnk6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbikge1xuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgZW50cnk6IGFjdGlvbi5wYXlsb2FkLFxuICAgICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBnYXNUb3RhbCBpcyBjb21wdXRlZCBiYXNlZCBvbiBnYXNQcmljZSBhbmQgZ2FzTGltaXQgYW5kIHNldCBpbiBzdGF0ZVxuICAgICAqIHJlY29tcHV0ZXMgdGhlIG1heGltdW0gYW1vdW50IGlmIHRoZSBjdXJyZW50IGFtb3VudCBtb2RlIGlzICdNQVgnIGFuZFxuICAgICAqIHNlbmRpbmcgdGhlIG5hdGl2ZSB0b2tlbi4gRVJDMjAgYXNzZXRzIG1heCBhbW91bnQgaXMgdW5hZmZlY3RlZCBieVxuICAgICAqIGdhc1RvdGFsIHNvIGRvZXMgbm90IG5lZWQgdG8gYmUgcmVjb21wdXRlZC4gRmluYWxseSwgdmFsaWRhdGVzIHRoZSBnYXNcbiAgICAgKiBmaWVsZCBhbmQgc2VuZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIGNhbGN1bGF0ZUdhc1RvdGFsOiAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIC8vIHVzZSBtYXhGZWVQZXJHYXMgYXMgdGhlIG11bHRpcGxpZXIgaWYgd29ya2luZyB3aXRoIGEgRkVFX01BUktFVCB0cmFuc2FjdGlvblxuICAgICAgLy8gb3RoZXJ3aXNlIHVzZSBnYXNQcmljZVxuICAgICAgaWYgKFxuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uVHlwZSA9PT1cbiAgICAgICAgVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuRkVFX01BUktFVFxuICAgICAgKSB7XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1RvdGFsID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgIGNhbGNHYXNUb3RhbChcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0LFxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMubWF4RmVlUGVyR2FzLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNUb3RhbCA9IGFkZEhleFByZWZpeChcbiAgICAgICAgICBjYWxjR2FzVG90YWwoXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCxcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVggJiZcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICkge1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlQW1vdW50VG9NYXgoc3RhdGUpO1xuICAgICAgfVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlQW1vdW50RmllbGQoc3RhdGUpO1xuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgLy8gdmFsaWRhdGUgc2VuZCBzdGF0ZVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgZHJhZnRzIGZyb20gc2VuZCBzdGF0ZSBhbmQgZHJvcHMgdGhlIGN1cnJlbnRUcmFuc2FjdGlvblVVSUQuXG4gICAgICogVGhpcyBpcyBhbiBpbXBvcnRhbnQgZmlyc3Qgc3RlcCBiZWZvcmUgYWRkaW5nIGEgbmV3IGRyYWZ0IHRyYW5zYWN0aW9uIHRvXG4gICAgICogYXZvaWQgcG9zc2libGUgY29sbGlzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgY2xlYXJQcmV2aW91c0RyYWZ0czogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEID0gbnVsbDtcbiAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zID0ge307XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIHNlbmQgc3RhdGUgYnkgc2V0dGluZyBpdCB0byB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1NlbmRTdGF0ZX1cbiAgICAgKi9cbiAgICByZXNldFNlbmRTdGF0ZTogKCkgPT4gaW5pdGlhbFN0YXRlLFxuICAgIC8qKlxuICAgICAqIHNldHMgdGhlIGFtb3VudCBtb2RlIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSBhcyBsb25nIGFzIGl0IGlzIG9uZSBvZiB0aGVcbiAgICAgKiBzdXBwb3J0ZWQgbW9kZXMgKE1BWHxJTlBVVClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlQW1vdW50TW9kZVBheWxvYWR9IGFjdGlvbiAtIFRoZSBhbW91bnQgbW9kZVxuICAgICAqICB0byBzZXQgdGhlIHN0YXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHVwZGF0ZUFtb3VudE1vZGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoT2JqZWN0LnZhbHVlcyhBTU9VTlRfTU9ERVMpLmluY2x1ZGVzKGFjdGlvbi5wYXlsb2FkKSkge1xuICAgICAgICBzdGF0ZS5hbW91bnRNb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBjb21wdXRlcyB0aGUgbWF4aW11bSBhbW91bnQgb2YgYXNzZXQgdGhhdCBjYW4gYmUgc2VudCBhbmQgdGhlbiBjYWxsc1xuICAgICAqIHRoZSB1cGRhdGVTZW5kQW1vdW50IGFjdGlvbiBhYm92ZSB3aXRoIHRoZSBjb21wdXRlZCB2YWx1ZSwgd2hpY2ggd2lsbFxuICAgICAqIHJldmFsaWRhdGUgdGhlIGZpZWxkIGFuZCBmb3JtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlQW1vdW50VG9NYXg6IChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgbGV0IGFtb3VudCA9ICcweDAnO1xuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4pIHtcbiAgICAgICAgY29uc3QgZGVjaW1hbHMgPSBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHM/LmRlY2ltYWxzID8/IDA7XG4gICAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgTnVtYmVyKGRlY2ltYWxzKSk7XG5cbiAgICAgICAgYW1vdW50ID0gbXVsdGlwbHlDdXJyZW5jaWVzKFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuYmFsYW5jZSxcbiAgICAgICAgICBtdWx0aXBsaWVyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgICAgICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTYsXG4gICAgICAgICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IF9nYXNUb3RhbCA9IHN1bUhleGVzKFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1RvdGFsIHx8ICcweDAnLFxuICAgICAgICAgIHN0YXRlLmdhc1RvdGFsRm9yTGF5ZXIxIHx8ICcweDAnLFxuICAgICAgICApO1xuICAgICAgICBhbW91bnQgPSBzdWJ0cmFjdEN1cnJlbmNpZXMoXG4gICAgICAgICAgYWRkSGV4UHJlZml4KGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuYmFsYW5jZSksXG4gICAgICAgICAgYWRkSGV4UHJlZml4KF9nYXNUb3RhbCksXG4gICAgICAgICAge1xuICAgICAgICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICAgICAgICBhQmFzZTogMTYsXG4gICAgICAgICAgICBiQmFzZTogMTYsXG4gICAgICAgICAgfSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVTZW5kQW1vdW50KHN0YXRlLCB7XG4gICAgICAgIHBheWxvYWQ6IGFtb3VudCxcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGFzc2V0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge1VwZGF0ZUFzc2V0UGF5bG9hZH0gYWN0aW9uIC0gVGhlIGFzc2V0IHRvIHNldCBpbiB0aGVcbiAgICAgKiAgZHJhZnRUcmFuc2FjdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVBc3NldDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IHsgYXNzZXQsIGluaXRpYWxBc3NldFNldCB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG5cbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9IGFzc2V0LnR5cGU7XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmJhbGFuY2UgPSBhc3NldC5iYWxhbmNlO1xuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5lcnJvciA9IGFzc2V0LmVycm9yO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4gfHxcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgKSB7XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscyA9IGFzc2V0LmRldGFpbHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjbGVhciB0aGUgZGV0YWlscyBvYmplY3Qgd2hlbiBzZW5kaW5nIG5hdGl2ZSBjdXJyZW5jeVxuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHMgPSBudWxsO1xuICAgICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuZXJyb3IgPT09IENPTlRSQUNUX0FERFJFU1NfRVJST1IpIHtcbiAgICAgICAgICAvLyBFcnJvcnMgcmVsYXRlZCB0byBzZW5kaW5nIHRva2VucyB0byB0aGVpciBvd24gY29udHJhY3QgYWRkcmVzc1xuICAgICAgICAgIC8vIGFyZSBubyBsb25nZXIgdmFsaWQgd2hlbiBzZW5kaW5nIG5hdGl2ZSBjdXJyZW5jeS5cbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5lcnJvciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGlmIGFtb3VudCBtb2RlIGlzIE1BWCB1cGRhdGUgYW1vdW50IHRvIG1heCBvZiBuZXcgYXNzZXQsIG90aGVyd2lzZSBzZXRcbiAgICAgIC8vIHRvIHplcm8uIFRoaXMgd2lsbCByZXZhbGlkYXRlIHRoZSBzZW5kIGFtb3VudCBmaWVsZC5cbiAgICAgIGlmIChzdGF0ZS5hbW91bnRNb2RlID09PSBBTU9VTlRfTU9ERVMuTUFYKSB7XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVBbW91bnRUb01heChzdGF0ZSk7XG4gICAgICB9IGVsc2UgaWYgKGluaXRpYWxBc3NldFNldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnVwZGF0ZVNlbmRBbW91bnQoc3RhdGUsIHsgcGF5bG9hZDogJzB4MCcgfSk7XG4gICAgICB9XG4gICAgICAvLyB2YWxpZGF0ZSBzZW5kIHN0YXRlXG4gICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXBwcm9wcmlhdGUgZ2FzIGZlZXMgaW4gc3RhdGUgYWZ0ZXIgcmVjZWl2aW5nIG5ldyBlc3RpbWF0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge0dhc0VzdGltYXRlVXBkYXRlUGF5bG9hZCl9IGFjdGlvbiAtIFRoZSBnYXMgZmVlIHVwZGF0ZSBwYXlsb2FkXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlR2FzRmVlRXN0aW1hdGVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgeyBnYXNGZWVFc3RpbWF0ZXMsIGdhc0VzdGltYXRlVHlwZSB9ID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBsZXQgZ2FzUHJpY2VFc3RpbWF0ZSA9ICcweDAnO1xuICAgICAgc3dpdGNoIChnYXNFc3RpbWF0ZVR5cGUpIHtcbiAgICAgICAgY2FzZSBHQVNfRVNUSU1BVEVfVFlQRVMuRkVFX01BUktFVDpcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlR2FzRmVlcyhzdGF0ZSwge1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvblR5cGU6IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkZFRV9NQVJLRVQsXG4gICAgICAgICAgICAgIG1heEZlZVBlckdhczogZ2V0R2FzUHJpY2VJbkhleFdlaShcbiAgICAgICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXMubWVkaXVtLnN1Z2dlc3RlZE1heEZlZVBlckdhcyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGdldEdhc1ByaWNlSW5IZXhXZWkoXG4gICAgICAgICAgICAgICAgZ2FzRmVlRXN0aW1hdGVzLm1lZGl1bS5zdWdnZXN0ZWRNYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0FTX0VTVElNQVRFX1RZUEVTLkxFR0FDWTpcbiAgICAgICAgICBnYXNQcmljZUVzdGltYXRlID0gZ2V0Um91bmRlZEdhc1ByaWNlKGdhc0ZlZUVzdGltYXRlcy5tZWRpdW0pO1xuICAgICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVHYXNGZWVzKHN0YXRlLCB7XG4gICAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICAgIGdhc1ByaWNlOiBnYXNQcmljZUVzdGltYXRlLFxuICAgICAgICAgICAgICB0eXBlOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1ksXG4gICAgICAgICAgICAgIGlzQXV0b21hdGljVXBkYXRlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHQVNfRVNUSU1BVEVfVFlQRVMuRVRIX0dBU1BSSUNFOlxuICAgICAgICAgIGdhc1ByaWNlRXN0aW1hdGUgPSBnZXRSb3VuZGVkR2FzUHJpY2UoZ2FzRmVlRXN0aW1hdGVzLmdhc1ByaWNlKTtcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlR2FzRmVlcyhzdGF0ZSwge1xuICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICBnYXNQcmljZTogZ2V0Um91bmRlZEdhc1ByaWNlKGdhc0ZlZUVzdGltYXRlcy5nYXNQcmljZSksXG4gICAgICAgICAgICAgIHR5cGU6IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkxFR0FDWSxcbiAgICAgICAgICAgICAgaXNBdXRvbWF0aWNVcGRhdGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdBU19FU1RJTUFURV9UWVBFUy5OT05FOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gUmVjb3JkIHRoZSBsYXRlc3QgZ2FzUHJpY2VFc3RpbWF0ZSBmb3IgZnV0dXJlIGNvbXBhcmlzb25zXG4gICAgICBzdGF0ZS5nYXNQcmljZUVzdGltYXRlID0gYWRkSGV4UHJlZml4KGdhc1ByaWNlRXN0aW1hdGUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgYXBwcm9wcmlhdGUgZ2FzIGZlZXMgaW4gc3RhdGUgYW5kIGRldGVybWluZXMgYW5kIHNldHMgdGhlXG4gICAgICogYXBwcm9wcmlhdGUgdHJhbnNhY3Rpb25UeXBlIGJhc2VkIG9uIGdhcyBmZWUgZmllbGRzIHJlY2VpdmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtHYXNGZWVVcGRhdGVQYXlsb2FkfSBhY3Rpb24gLSBUaGUgZ2FzIGZlZXMgdG8gdXBkYXRlIHdpdGhcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVHYXNGZWVzOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGFjdGlvbi5wYXlsb2FkLnRyYW5zYWN0aW9uVHlwZSA9PT1cbiAgICAgICAgICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUXG4gICAgICAgICkge1xuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLm1heEZlZVBlckdhcyA9IGFkZEhleFByZWZpeChcbiAgICAgICAgICAgIGFjdGlvbi5wYXlsb2FkLm1heEZlZVBlckdhcyxcbiAgICAgICAgICApO1xuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLm1heFByaW9yaXR5RmVlUGVyR2FzID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgICAgYWN0aW9uLnBheWxvYWQubWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnRyYW5zYWN0aW9uVHlwZSA9XG4gICAgICAgICAgICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5GRUVfTUFSS0VUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhY3Rpb24ucGF5bG9hZC5tYW51YWxseUVkaXRlZCkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMud2FzTWFudWFsbHlFZGl0ZWQgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZ2FzIHByaWNlIGlmIGl0IGhhcyBub3QgYmVlbiBtYW51YWxseSBlZGl0ZWQsXG4gICAgICAgICAgLy8gb3IgaWYgdGhpcyBjdXJyZW50IGFjdGlvbiBpcyBhIG1hbnVhbCBlZGl0LlxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFkcmFmdFRyYW5zYWN0aW9uLmdhcy53YXNNYW51YWxseUVkaXRlZCB8fFxuICAgICAgICAgICAgYWN0aW9uLnBheWxvYWQubWFudWFsbHlFZGl0ZWRcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1ByaWNlID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgICAgICBhY3Rpb24ucGF5bG9hZC5nYXNQcmljZSxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24udHJhbnNhY3Rpb25UeXBlID0gVFJBTlNBQ1RJT05fRU5WRUxPUEVfVFlQRVMuTEVHQUNZO1xuICAgICAgICB9XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy5jYWxjdWxhdGVHYXNUb3RhbChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBwcm92aWRlZCBnYXNMaW1pdCBpbiBzdGF0ZSBhbmQgdGhlbiByZWNvbXB1dGVzIHRoZSBnYXNUb3RhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7U2ltcGxlU3RyaW5nUGF5bG9hZH0gYWN0aW9uIC0gVGhlXG4gICAgICogIGdhc0xpbWl0IGluIGhleCB0byBzZXQgaW4gc3RhdGUuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlR2FzTGltaXQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbikge1xuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCA9IGFkZEhleFByZWZpeChhY3Rpb24ucGF5bG9hZCk7XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy5jYWxjdWxhdGVHYXNUb3RhbChzdGF0ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBzZXRzIHRoZSBsYXllciAxIGZlZXMgdG90YWwgKGZvciBhIG11bHRpLWxheWVyIGZlZSBuZXR3b3JrKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtTaW1wbGVTdHJpbmdQYXlsb2FkfSBhY3Rpb24gLSB0aGVcbiAgICAgKiAgZ2FzVG90YWxGb3JMYXllcjEgdG8gc2V0IGluIGhleCB3ZWkuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlTGF5ZXIxRmVlczogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIHN0YXRlLmdhc1RvdGFsRm9yTGF5ZXIxID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgICBpZiAoXG4gICAgICAgIHN0YXRlLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVggJiZcbiAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICkge1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlQW1vdW50VG9NYXgoc3RhdGUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcmVjaXBpZW50IG9mIHRoZSBkcmFmdFRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge3VwZGF0ZVJlY2lwaWVudFBheWxvYWR9IGFjdGlvbiAtIFRoZSByZWNpcGllbnQgdG8gc2V0IGluIHRoZVxuICAgICAqICBkcmFmdFRyYW5zYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHVwZGF0ZVJlY2lwaWVudDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LmVycm9yID0gbnVsbDtcbiAgICAgIHN0YXRlLnJlY2lwaWVudElucHV0ID0gJyc7XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzID0gYWN0aW9uLnBheWxvYWQuYWRkcmVzcyA/PyAnJztcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50Lm5pY2tuYW1lID0gYWN0aW9uLnBheWxvYWQubmlja25hbWUgPz8gJyc7XG5cbiAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzID09PSAnJykge1xuICAgICAgICAvLyBJZiBhZGRyZXNzIGlzIG51bGwgd2UgYXJlIGNsZWFyaW5nIHRoZSByZWNpcGllbnQgYW5kIG11c3QgcmV0dXJuXG4gICAgICAgIC8vIHRvIHRoZSBBRERfUkVDSVBJRU5UIHN0YWdlLlxuICAgICAgICBzdGF0ZS5zdGFnZSA9IFNFTkRfU1RBR0VTLkFERF9SRUNJUElFTlQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBhbiBhZGRyZXNzIGlzIHByb3ZpZGVkIGFuZCBhbiBpZCBleGlzdHMsIHdlIHByb2dyZXNzIHRvIHRoZSBFRElUXG4gICAgICAgIC8vIHN0YWdlLCBvdGhlcndpc2Ugd2UgcHJvZ3Jlc3MgdG8gdGhlIERSQUZUIHN0YWdlLiBXZSBhbHNvIHJlc2V0IHRoZVxuICAgICAgICAvLyBzZWFyY2ggbW9kZSBmb3IgcmVjaXBpZW50IHNlYXJjaC5cbiAgICAgICAgc3RhdGUuc3RhZ2UgPVxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uaWQgPT09IG51bGwgPyBTRU5EX1NUQUdFUy5EUkFGVCA6IFNFTkRfU1RBR0VTLkVESVQ7XG4gICAgICAgIHN0YXRlLnJlY2lwaWVudE1vZGUgPSBSRUNJUElFTlRfU0VBUkNIX01PREVTLkNPTlRBQ1RfTElTVDtcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWRhdGUgc2VuZCBzdGF0ZVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgdXNlciBpbnB1dCBhbmQgY2hhbmdlcyB0aGUgcmVjaXBpZW50IHNlYXJjaCBtb2RlIHRvIHRoZVxuICAgICAqIHNwZWNpZmllZCB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtVcGRhdGVSZWNpcGllbnRNb2RlUGF5bG9hZH0gYWN0aW9uIC0gVGhlIG1vZGUgdG8gc2V0IHRoZVxuICAgICAqICByZWNpcGllbnQgc2VhcmNoIHRvXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlUmVjaXBpZW50U2VhcmNoTW9kZTogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIHN0YXRlLnJlY2lwaWVudElucHV0ID0gJyc7XG4gICAgICBzdGF0ZS5yZWNpcGllbnRNb2RlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlY2lwaWVudFdhcm5pbmc6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC53YXJuaW5nID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHVwZGF0ZVJlY2lwaWVudFR5cGU6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC50eXBlID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcblxuICAgIHVwZGF0ZURyYWZ0VHJhbnNhY3Rpb25TdGF0dXM6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLnN0YXR1cyA9IGFjdGlvbi5wYXlsb2FkO1xuICAgIH0sXG5cbiAgICBhY2tub3dsZWRnZVJlY2lwaWVudFdhcm5pbmc6IChzdGF0ZSkgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQucmVjaXBpZW50V2FybmluZ0Fja25vd2xlZGdlZCA9IHRydWU7XG4gICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgcmVjaXBpZW50SW5wdXQga2V5IHdpdGggd2hhdCB0aGUgdXNlciBoYXNcbiAgICAgKiB0eXBlZCBpbnRvIHRoZSByZWNpcGllbnQgaW5wdXQgZmllbGQgaW4gdGhlIFVJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHBhcmFtIHtTaW1wbGVTdHJpbmdQYXlsb2FkfSBhY3Rpb24gLSB0aGUgdmFsdWUgdGhlIHVzZXIgaGFzIHR5cGVkIGludG9cbiAgICAgKiAgdGhlIHJlY2lwaWVudCBmaWVsZC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVSZWNpcGllbnRVc2VySW5wdXQ6IChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGluIHN0YXRlIHRvIG1hdGNoIHdoYXQgdGhlIHVzZXIgaXMgdHlwaW5nIGludG8gdGhlXG4gICAgICAvLyBpbnB1dCBmaWVsZFxuICAgICAgc3RhdGUucmVjaXBpZW50SW5wdXQgPSBhY3Rpb24ucGF5bG9hZDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBjdXJyZW50IGFtb3VudC52YWx1ZSBpbiBzdGF0ZSBhbmQgcnVuIHBvc3QgdXBkYXRlIHZhbGlkYXRpb24gb2ZcbiAgICAgKiB0aGUgYW1vdW50IGZpZWxkIGFuZCB0aGUgc2VuZCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEBwYXJhbSB7U2ltcGxlU3RyaW5nUGF5bG9hZH0gYWN0aW9uIC0gVGhlIGhleCBzdHJpbmcgdG8gYmUgc2V0IGFzIHRoZVxuICAgICAqICBhbW91bnQgdmFsdWUuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXBkYXRlU2VuZEFtb3VudDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlID0gYWRkSGV4UHJlZml4KGFjdGlvbi5wYXlsb2FkKTtcbiAgICAgIC8vIE9uY2UgYW1vdW50IGhhcyBjaGFuZ2VkLCB2YWxpZGF0ZSB0aGUgZmllbGRcbiAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy52YWxpZGF0ZUFtb3VudEZpZWxkKHN0YXRlKTtcbiAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LnR5cGUgPT09IEFTU0VUX1RZUEVTLk5BVElWRSkge1xuICAgICAgICAvLyBpZiBzZW5kaW5nIHRoZSBuYXRpdmUgYXNzZXQgdGhlIGFtb3VudCBiZWluZyBzZW50IHdpbGwgaW1wYWN0IHRoZVxuICAgICAgICAvLyBnYXMgZmllbGQgYXMgd2VsbCBiZWNhdXNlIHRoZSBnYXMgdmFsaWRhdGlvbiB0YWtlcyBpbnRvXG4gICAgICAgIC8vIGNvbnNpZGVyYXRpb24gdGhlIGF2YWlsYWJsZSBiYWxhbmNlIG1pbnVzIGFtb3VudCBzZW50IGJlZm9yZVxuICAgICAgICAvLyBjaGVja2luZyBpZiB0aGVyZSBpcyBlbm91Z2ggbGVmdCB0byBjb3ZlciB0aGUgZ2FzIGZlZS5cbiAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgfVxuICAgICAgLy8gdmFsaWRhdGUgc2VuZCBzdGF0ZVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIHVwZGF0ZXMgdGhlIHVzZXJJbnB1dEhleERhdGEgc3RhdGUga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcGFyYW0ge1NpbXBsZVN0cmluZ1BheWxvYWR9IGFjdGlvbiAtIFRoZSBoZXggc3RyaW5nIHRvIGJlIHNldCBhcyB0aGVcbiAgICAgKiAgdXNlcklucHV0SGV4RGF0YSB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB1cGRhdGVVc2VySW5wdXRIZXhEYXRhOiAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgZHJhZnRUcmFuc2FjdGlvbi51c2VySW5wdXRIZXhEYXRhID0gYWN0aW9uLnBheWxvYWQ7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnYXNJc1NldEluTW9kYWwgcHJvcGVydHkgdG8gdHJ1ZSB3aGljaCByZXN1bHRzIGluIHNob3dpbmdcbiAgICAgKiB0aGUgZ2FzIGZlZXMgZnJvbSB0aGUgY3VzdG9tIGdhcyBtb2RhbCBpbiB0aGUgc2VuZCBwYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXNlQ3VzdG9tR2FzOiAoc3RhdGUpID0+IHtcbiAgICAgIHN0YXRlLmdhc0lzU2V0SW5Nb2RhbCA9IHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBnYXNJc1NldEluTW9kYWwgcHJvcGVydHkgdG8gZmFsc2Ugd2hpY2ggcmVzdWx0cyBpbiBzaG93aW5nXG4gICAgICogdGhlIGRlZmF1bHQgZ2FzIHByaWNlL2xpbWl0IGZpZWxkcyBpbiB0aGUgc2VuZCBwYWdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdXNlRGVmYXVsdEdhczogKHN0YXRlKSA9PiB7XG4gICAgICBzdGF0ZS5nYXNJc1NldEluTW9kYWwgPSBmYWxzZTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrcyBmb3IgdGhlIHZhbGlkaXR5IG9mIHRoZSBkcmFmdFRyYW5zYWN0aW9ucyBzZWxlY3RlZCBhbW91bnQgdG8gc2VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZW5kU3RhdGVEcmFmdH0gc3RhdGUgLSBBIHdyaXRhYmxlIGRyYWZ0IG9mIHRoZSBzZW5kIHN0YXRlIHRvIGJlXG4gICAgICogIHVwZGF0ZWQuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdmFsaWRhdGVBbW91bnRGaWVsZDogKHN0YXRlKSA9PiB7XG4gICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgc3RhdGUuZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGUuY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgLy8gc2V0IGVycm9yIHRvIElOU1VGRklDSUVOVF9GVU5EU19FUlJPUiBpZiB0aGUgYWNjb3VudCBiYWxhbmNlIGlzIGxvd2VyXG4gICAgICAgIC8vIHRoYW4gdGhlIHRvdGFsIHByaWNlIG9mIHRoZSB0cmFuc2FjdGlvbiBpbmNsdXNpdmUgb2YgZ2FzIGZlZXMuXG4gICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUgJiZcbiAgICAgICAgICAhaXNCYWxhbmNlU3VmZmljaWVudCh7XG4gICAgICAgICAgICBhbW91bnQ6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICAgICAgYmFsYW5jZTogZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5iYWxhbmNlLFxuICAgICAgICAgICAgZ2FzVG90YWw6IGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc1RvdGFsID8/ICcweDAnLFxuICAgICAgICAgIH0pOlxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LmVycm9yID0gSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBzZXQgZXJyb3IgdG8gSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SIGlmIHRoZSB0b2tlbiBiYWxhbmNlIGlzIGxvd2VyXG4gICAgICAgIC8vIHRoYW4gdGhlIGFtb3VudCBvZiB0b2tlbiB0aGUgdXNlciBpcyBhdHRlbXB0aW5nIHRvIHNlbmQuXG4gICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5UT0tFTiAmJlxuICAgICAgICAgICFpc1Rva2VuQmFsYW5jZVN1ZmZpY2llbnQoe1xuICAgICAgICAgICAgdG9rZW5CYWxhbmNlOiBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmJhbGFuY2UgPz8gJzB4MCcsXG4gICAgICAgICAgICBhbW91bnQ6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLFxuICAgICAgICAgICAgZGVjaW1hbHM6IGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscy5kZWNpbWFscyxcbiAgICAgICAgICB9KTpcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFtb3VudC5lcnJvciA9IElOU1VGRklDSUVOVF9UT0tFTlNfRVJST1I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGlmIHRoZSBhbW91bnQgaXMgbmVnYXRpdmUsIHNldCBlcnJvciB0byBORUdBVElWRV9FVEhfRVJST1JcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRoaXMgdG8gTkVHQVRJVkVfRVJST1IgYW5kIHJlbW92ZSB0aGUgY3VycmVuY3kgYmlhcy5cbiAgICAgICAgY2FzZSBjb252ZXJzaW9uR3JlYXRlclRoYW4oXG4gICAgICAgICAgeyB2YWx1ZTogMCwgZnJvbU51bWVyaWNCYXNlOiAnZGVjJyB9LFxuICAgICAgICAgIHsgdmFsdWU6IGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LnZhbHVlLCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgICAgICk6XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQuZXJyb3IgPSBORUdBVElWRV9FVEhfRVJST1I7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGFib3ZlIGFyZSB0cnVlLCBzZXQgZXJyb3IgdG8gbnVsbFxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYW1vdW50LmVycm9yID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgdXNlciBoYXMgZW5vdWdoIGZ1bmRzIHRvIGNvdmVyIHRoZSBjb3N0IG9mIGdhcywgYWx3YXlzXG4gICAgICogdXNlcyB0aGUgbmF0aXZlIGN1cnJlbmN5IGFuZCBkb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCB0aGUgYW1vdW50XG4gICAgICogYmVpbmcgc2VudC4gSWYgdGhlIHVzZXIgaGFzIGVub3VnaCB0byBjb3ZlciBjb3N0IG9mIGdhcyBidXQgbm90IGdhc1xuICAgICAqICsgYW1vdW50IHRoZW4gdGhlIGVycm9yIHdpbGwgYmUgZGlzcGxheWVkIG9uIHRoZSBhbW91bnQgZmllbGQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NlbmRTdGF0ZURyYWZ0fSBzdGF0ZSAtIEEgd3JpdGFibGUgZHJhZnQgb2YgdGhlIHNlbmQgc3RhdGUgdG8gYmVcbiAgICAgKiAgdXBkYXRlZC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUdhc0ZpZWxkOiAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGNvbnN0IGluc3VmZmljaWVudEZ1bmRzID0gIWlzQmFsYW5jZVN1ZmZpY2llbnQoe1xuICAgICAgICBhbW91bnQ6XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICAgICAgID8gZHJhZnRUcmFuc2FjdGlvbi5hbW91bnQudmFsdWVcbiAgICAgICAgICAgIDogJzB4MCcsXG4gICAgICAgIGJhbGFuY2U6XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudD8uYmFsYW5jZSA/P1xuICAgICAgICAgIHN0YXRlLnNlbGVjdGVkQWNjb3VudC5iYWxhbmNlLFxuICAgICAgICBnYXNUb3RhbDogZHJhZnRUcmFuc2FjdGlvbi5nYXMuZ2FzVG90YWwgPz8gJzB4MCcsXG4gICAgICB9KTtcblxuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMuZXJyb3IgPSBpbnN1ZmZpY2llbnRGdW5kc1xuICAgICAgICA/IElOU1VGRklDSUVOVF9GVU5EU19FUlJPUlxuICAgICAgICA6IG51bGw7XG4gICAgfSxcbiAgICB2YWxpZGF0ZVJlY2lwaWVudFVzZXJJbnB1dDogKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcblxuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0YXRlLnJlY2lwaWVudE1vZGUgPT09IFJFQ0lQSUVOVF9TRUFSQ0hfTU9ERVMuTVlfQUNDT1VOVFMgfHxcbiAgICAgICAgICBzdGF0ZS5yZWNpcGllbnRJbnB1dCA9PT0gJycgfHxcbiAgICAgICAgICBzdGF0ZS5yZWNpcGllbnRJbnB1dCA9PT0gbnVsbFxuICAgICAgICApIHtcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5lcnJvciA9IG51bGw7XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICAgIHRva2VuQWRkcmVzc0xpc3QsXG4gICAgICAgICAgICBpc1Byb2JhYmx5QW5Bc3NldENvbnRyYWN0LFxuICAgICAgICAgIH0gPSBhY3Rpb24ucGF5bG9hZDtcblxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGlzQnVybkFkZHJlc3Moc3RhdGUucmVjaXBpZW50SW5wdXQpIHx8XG4gICAgICAgICAgICAoIWlzVmFsaWRIZXhBZGRyZXNzKHN0YXRlLnJlY2lwaWVudElucHV0LCB7XG4gICAgICAgICAgICAgIG1peGVkQ2FzZVVzZUNoZWNrc3VtOiB0cnVlLFxuICAgICAgICAgICAgfSkgJiZcbiAgICAgICAgICAgICAgIWlzVmFsaWREb21haW5OYW1lKHN0YXRlLnJlY2lwaWVudElucHV0KSlcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LmVycm9yID0gaXNEZWZhdWx0TWV0YU1hc2tDaGFpbihjaGFpbklkKVxuICAgICAgICAgICAgICA/IElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfRVJST1JcbiAgICAgICAgICAgICAgOiBJTlZBTElEX1JFQ0lQSUVOVF9BRERSRVNTX05PVF9FVEhfTkVUV09SS19FUlJPUjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgaXNPcmlnaW5Db250cmFjdEFkZHJlc3MoXG4gICAgICAgICAgICAgIHN0YXRlLnJlY2lwaWVudElucHV0LFxuICAgICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0Py5kZXRhaWxzPy5hZGRyZXNzLFxuICAgICAgICAgICAgKVxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuZXJyb3IgPSBDT05UUkFDVF9BRERSRVNTX0VSUk9SO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5lcnJvciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChpc1ZhbGlkSGV4QWRkcmVzcyhzdGF0ZS5yZWNpcGllbnRJbnB1dCkgJiZcbiAgICAgICAgICAgICAgKHRva2VuQWRkcmVzc0xpc3QuZmluZCgoYWRkcmVzcykgPT5cbiAgICAgICAgICAgICAgICBpc0VxdWFsQ2FzZUluc2Vuc2l0aXZlKGFkZHJlc3MsIHN0YXRlLnJlY2lwaWVudElucHV0KSxcbiAgICAgICAgICAgICAgKSB8fFxuICAgICAgICAgICAgICAgIGNoZWNrRXhpc3RpbmdBZGRyZXNzZXMoc3RhdGUucmVjaXBpZW50SW5wdXQsIHRva2VucykpKSB8fFxuICAgICAgICAgICAgaXNQcm9iYWJseUFuQXNzZXRDb250cmFjdFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9XG4gICAgICAgICAgICAgIEtOT1dOX1JFQ0lQSUVOVF9BRERSRVNTX1dBUk5JTkc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50Lndhcm5pbmcgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZHJhZnRUcmFuc2FjdGlvbiBpcyBjdXJyZW50bHkgdmFsaWQuIFRoZSBmb2xsb3dpbmcgbGlzdCBvZlxuICAgICAqIGNhc2VzIGZyb20gdGhlIHN3aXRjaCBzdGF0ZW1lbnQgaW4gdGhpcyBmdW5jdGlvbiBkZXNjcmliZSB3aGVuIHRoZVxuICAgICAqIHRyYW5zYWN0aW9uIGlzIGludmFsaWQuIFBsZWFzZSBrZWVwIHRoaXMgY29tbWVudCB1cGRhdGVkLlxuICAgICAqXG4gICAgICogY2FzZSAxOiBTdGF0ZSBpcyBpbnZhbGlkIHdoZW4gYW1vdW50IGZpZWxkIGhhcyBhbiBlcnJvci5cbiAgICAgKiBjYXNlIDI6IFN0YXRlIGlzIGludmFsaWQgd2hlbiBnYXMgZmllbGQgaGFzIGFuIGVycm9yLlxuICAgICAqIGNhc2UgMzogU3RhdGUgaXMgaW52YWxpZCB3aGVuIGFzc2V0IGZpZWxkIGhhcyBhbiBlcnJvci5cbiAgICAgKiBjYXNlIDQ6IFN0YXRlIGlzIGludmFsaWQgaWYgYXNzZXQgdHlwZSBpcyBhIHRva2VuIGFuZCB0aGUgdG9rZW4gZGV0YWlsc1xuICAgICAqICBhcmUgdW5rbm93bi5cbiAgICAgKiBjYXNlIDU6IFN0YXRlIGlzIGludmFsaWQgaWYgbm8gcmVjaXBpZW50IGhhcyBiZWVuIGFkZGVkLlxuICAgICAqIGNhc2UgNjogU3RhdGUgaXMgaW52YWxpZCBpZiB0aGUgc2VuZCBzdGF0ZSBpcyB1bmluaXRpYWxpemVkLlxuICAgICAqIGNhc2UgNzogU3RhdGUgaXMgaW52YWxpZCBpZiBnYXMgZXN0aW1hdGVzIGFyZSBsb2FkaW5nLlxuICAgICAqIGNhc2UgODogU3RhdGUgaXMgaW52YWxpZCBpZiBnYXNMaW1pdCBpcyBsZXNzIHRoYW4gdGhlIGdhc0xpbWl0TWluaW11bS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2VuZFN0YXRlRHJhZnR9IHN0YXRlIC0gQSB3cml0YWJsZSBkcmFmdCBvZiB0aGUgc2VuZCBzdGF0ZSB0byBiZVxuICAgICAqICB1cGRhdGVkLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHZhbGlkYXRlU2VuZFN0YXRlOiAoc3RhdGUpID0+IHtcbiAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHN3aXRjaCAodHJ1ZSkge1xuICAgICAgICAgIGNhc2UgQm9vbGVhbihkcmFmdFRyYW5zYWN0aW9uLmFtb3VudC5lcnJvcik6XG4gICAgICAgICAgY2FzZSBCb29sZWFuKGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmVycm9yKTpcbiAgICAgICAgICBjYXNlIEJvb2xlYW4oZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5lcnJvcik6XG4gICAgICAgICAgY2FzZSBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LnR5cGUgPT09IEFTU0VUX1RZUEVTLlRPS0VOICYmXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHMgPT09IG51bGw6XG4gICAgICAgICAgY2FzZSBzdGF0ZS5zdGFnZSA9PT0gU0VORF9TVEFHRVMuQUREX1JFQ0lQSUVOVDpcbiAgICAgICAgICBjYXNlIHN0YXRlLnN0YWdlID09PSBTRU5EX1NUQUdFUy5JTkFDVElWRTpcbiAgICAgICAgICBjYXNlIHN0YXRlLmdhc0VzdGltYXRlSXNMb2FkaW5nOlxuICAgICAgICAgIGNhc2UgbmV3IEJpZ051bWJlcihkcmFmdFRyYW5zYWN0aW9uLmdhcy5nYXNMaW1pdCwgMTYpLmxlc3NUaGFuKFxuICAgICAgICAgICAgbmV3IEJpZ051bWJlcihzdGF0ZS5nYXNMaW1pdE1pbmltdW0pLFxuICAgICAgICAgICk6XG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnN0YXR1cyA9IFNFTkRfU1RBVFVTRVMuSU5WQUxJRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9PT0gJ2xvYWRpbmcnOlxuICAgICAgICAgIGNhc2UgZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQud2FybmluZyA9PT1cbiAgICAgICAgICAgIEtOT1dOX1JFQ0lQSUVOVF9BRERSRVNTX1dBUk5JTkcgJiZcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LnJlY2lwaWVudFdhcm5pbmdBY2tub3dsZWRnZWQgPT09IGZhbHNlOlxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5zdGF0dXMgPSBTRU5EX1NUQVRVU0VTLklOVkFMSUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5zdGF0dXMgPSBTRU5EX1NUQVRVU0VTLlZBTElEO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgfSxcbiAgZXh0cmFSZWR1Y2VyczogKGJ1aWxkZXIpID0+IHtcbiAgICBidWlsZGVyXG4gICAgICAuYWRkQ2FzZShBQ0NPVU5UX0NIQU5HRUQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIC8vIFRoaXMgZXZlbnQgb2NjdXJzIHdoZW4gdGhlIHVzZXIncyBhY2NvdW50IGRldGFpbHMgdXBkYXRlIGR1ZSB0b1xuICAgICAgICAvLyBiYWNrZ3JvdW5kIHN0YXRlIGNoYW5nZXMuIElmIHRoZSBhY2NvdW50IHRoYXQgaXMgYmVpbmcgdXBkYXRlZCBpc1xuICAgICAgICAvLyB0aGUgY3VycmVudCBmcm9tIGFjY291bnQgb24gdGhlIGVkaXQgZmxvdyB3ZSBuZWVkIHRvIHVwZGF0ZVxuICAgICAgICAvLyB0aGUgYmFsYW5jZSBmb3IgdGhlIGFjY291bnQgYW5kIHJldmFsaWRhdGUgdGhlIHNlbmQgc3RhdGUuXG4gICAgICAgIGlmIChzdGF0ZS5zdGFnZSA9PT0gU0VORF9TVEFHRVMuRURJVCAmJiBhY3Rpb24ucGF5bG9hZC5hY2NvdW50KSB7XG4gICAgICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uICYmXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50ICYmXG4gICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50LmFkZHJlc3MgPT09XG4gICAgICAgICAgICAgIGFjdGlvbi5wYXlsb2FkLmFjY291bnQuYWRkcmVzc1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudC5iYWxhbmNlID1cbiAgICAgICAgICAgICAgYWN0aW9uLnBheWxvYWQuYWNjb3VudC5iYWxhbmNlO1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIGFzc2V0IGJhbGFuY2UgaWYgdGhlIGFzc2V0IGlzIHRoZSBuYXRpdmVcbiAgICAgICAgICAgIC8vIG5ldHdvcmsgYXNzZXQuIE9uY2Ugd2UgdXBkYXRlIHRoZSBiYWxhbmNlIHdlIHJlY29tcHV0ZSBlcnJvciBzdGF0ZS5cbiAgICAgICAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LnR5cGUgPT09IEFTU0VUX1RZUEVTLk5BVElWRSkge1xuICAgICAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmJhbGFuY2UgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmJhbGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVBbW91bnRGaWVsZChzdGF0ZSk7XG4gICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVHYXNGaWVsZChzdGF0ZSk7XG4gICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKEFERFJFU1NfQk9PS19VUERBVEVELCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAvLyBXaGVuIHRoZSBhZGRyZXNzIGJvb2sgdXBkYXRlcyBmcm9tIGJhY2tncm91bmQgc3RhdGUgY2hhbmdlcyB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGNoZWNrIHRvIHNlZSBpZiBhbiBlbnRyeSBleGlzdHMgZm9yIHRoZSBjdXJyZW50IGFkZHJlc3Mgb3IgaWYgdGhlXG4gICAgICAgIC8vIGVudHJ5IGNoYW5nZWQuXG4gICAgICAgIGNvbnN0IHsgYWRkcmVzc0Jvb2sgfSA9IGFjdGlvbi5wYXlsb2FkO1xuICAgICAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24gJiZcbiAgICAgICAgICBhZGRyZXNzQm9va1tkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzXT8ubmFtZVxuICAgICAgICApIHtcbiAgICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5uaWNrbmFtZSA9XG4gICAgICAgICAgICBhZGRyZXNzQm9va1tkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC5hZGRyZXNzXS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UoY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0LnBlbmRpbmcsIChzdGF0ZSkgPT4ge1xuICAgICAgICAvLyBXaGVuIHdlIGJlZ2luIHRvIGZldGNoIGdhc0xpbWl0IHdlIHNob3VsZCBpbmRpY2F0ZSB3ZSBhcmUgbG9hZGluZ1xuICAgICAgICAvLyBhIGdhcyBlc3RpbWF0ZS5cbiAgICAgICAgc3RhdGUuZ2FzRXN0aW1hdGVJc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGNvbXB1dGVFc3RpbWF0ZWRHYXNMaW1pdC5mdWxmaWxsZWQsIChzdGF0ZSwgYWN0aW9uKSA9PiB7XG4gICAgICAgIC8vIFdoZW4gd2UgcmVjZWl2ZSBhIG5ldyBnYXNMaW1pdCBmcm9tIHRoZSBjb21wdXRlRXN0aW1hdGVkR2FzTGltaXRcbiAgICAgICAgLy8gdGh1bmsgd2UgbmVlZCB0byB1cGRhdGUgb3VyIGdhc0xpbWl0IGluIHRoZSBzbGljZS4gV2UgY2FsbCBpbnRvIHRoZVxuICAgICAgICAvLyBjYXNlUmVkdWNlciB1cGRhdGVHYXNMaW1pdCB0byB0YXAgaW50byB0aGUgYXBwcm9wcmlhdGUgZm9sbG93IHVwXG4gICAgICAgIC8vIGNoZWNrcyBhbmQgZ2FzVG90YWwgY2FsY3VsYXRpb24uIEZpcnN0IHNldCBnYXNFc3RpbWF0ZUlzTG9hZGluZyB0b1xuICAgICAgICAvLyBmYWxzZS5cbiAgICAgICAgc3RhdGUuZ2FzRXN0aW1hdGVJc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkPy5nYXNMaW1pdCkge1xuICAgICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVHYXNMaW1pdChzdGF0ZSwge1xuICAgICAgICAgICAgcGF5bG9hZDogYWN0aW9uLnBheWxvYWQuZ2FzTGltaXQsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbi5wYXlsb2FkPy5nYXNUb3RhbEZvckxheWVyMSkge1xuICAgICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVMYXllcjFGZWVzKHN0YXRlLCB7XG4gICAgICAgICAgICBwYXlsb2FkOiBhY3Rpb24ucGF5bG9hZC5nYXNUb3RhbEZvckxheWVyMSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGNvbXB1dGVFc3RpbWF0ZWRHYXNMaW1pdC5yZWplY3RlZCwgKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIElmIGdhcyBlc3RpbWF0aW9uIGZhaWxzLCB3ZSBzaG91bGQgc2V0IHRoZSBsb2FkaW5nIHN0YXRlIHRvIGZhbHNlLFxuICAgICAgICAvLyBiZWNhdXNlIGl0IGlzIG5vIGxvbmdlciBsb2FkaW5nXG4gICAgICAgIHN0YXRlLmdhc0VzdGltYXRlSXNMb2FkaW5nID0gZmFsc2U7XG4gICAgICB9KVxuICAgICAgLmFkZENhc2UoR0FTX0ZFRV9FU1RJTUFURVNfVVBEQVRFRCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgZ2FzRmVlQ29udHJvbGxlciB1cGRhdGVzIGl0cyBnYXMgZmVlIGVzdGltYXRlcyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIHVwZGF0ZSBhbmQgdmFsaWRhdGUgc3RhdGUgYmFzZWQgb24gdGhvc2UgbmV3IHZhbHVlc1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlR2FzRmVlRXN0aW1hdGVzKHN0YXRlLCB7XG4gICAgICAgICAgcGF5bG9hZDogYWN0aW9uLnBheWxvYWQsXG4gICAgICAgIH0pO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKGluaXRpYWxpemVTZW5kU3RhdGUucGVuZGluZywgKHN0YXRlKSA9PiB7XG4gICAgICAgIC8vIHdoZW4gd2UgYmVnaW4gaW5pdGlhbGl6aW5nIHN0YXRlLCB3aGljaCBjYW4gaGFwcGVuIHdoZW4gc3dpdGNoaW5nXG4gICAgICAgIC8vIGNoYWlucyBldmVuIGFmdGVyIGxvYWRpbmcgdGhlIHNlbmQgZmxvdywgd2Ugc2V0IGdhc0VzdGltYXRlSXNMb2FkaW5nXG4gICAgICAgIC8vIGFzIGluaXRpYWxpemF0aW9uIHdpbGwgdHJpZ2dlciBhIGZldGNoIGZvciBnYXNQcmljZSBlc3RpbWF0ZXMuXG4gICAgICAgIHN0YXRlLmdhc0VzdGltYXRlSXNMb2FkaW5nID0gdHJ1ZTtcbiAgICAgIH0pXG4gICAgICAuYWRkQ2FzZShpbml0aWFsaXplU2VuZFN0YXRlLmZ1bGZpbGxlZCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gd3JpdGVzIHRoZSBjb21wdXRlZCBpbml0aWFsaXplZCBzdGF0ZSB2YWx1ZXMgaW50byB0aGUgc2xpY2UgYW5kIHRoZW5cbiAgICAgICAgLy8gY2FsY3VsYXRlcyBzbGljZSB2YWxpZGl0eSB1c2luZyB0aGUgY2FzZVJlZHVjZXJzLlxuICAgICAgICBzdGF0ZS5laXAxNTU5c3VwcG9ydCA9IGFjdGlvbi5wYXlsb2FkLmVpcDE1NTlzdXBwb3J0O1xuICAgICAgICBzdGF0ZS5zZWxlY3RlZEFjY291bnQuYWRkcmVzcyA9IGFjdGlvbi5wYXlsb2FkLmFjY291bnQuYWRkcmVzcztcbiAgICAgICAgc3RhdGUuc2VsZWN0ZWRBY2NvdW50LmJhbGFuY2UgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmJhbGFuY2U7XG4gICAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbikge1xuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uZ2FzLmdhc0xpbWl0ID0gYWN0aW9uLnBheWxvYWQuZ2FzTGltaXQ7XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5nYXMuZ2FzVG90YWwgPSBhY3Rpb24ucGF5bG9hZC5nYXNUb3RhbDtcbiAgICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQuY2hhaW5IYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3RhdGUgd2FzIHJlaW5pdGlhbGl6ZWQgYXMgYSByZXN1bHQgb2YgdGhlIHVzZXIgY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBuZXR3b3JrIGZyb20gdGhlIG5ldHdvcmsgZHJvcGRvd24sIHRoZW4gdGhlIHNlbGVjdGVkIGFzc2V0IGlzXG4gICAgICAgICAgICAvLyBubyBsb25nZXIgdmFsaWQgYW5kIHNob3VsZCBiZSBzZXQgdG8gdGhlIG5hdGl2ZSBhc3NldCBmb3IgdGhlXG4gICAgICAgICAgICAvLyBuZXR3b3JrLlxuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID0gQVNTRVRfVFlQRVMuTkFUSVZFO1xuICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5iYWxhbmNlID1cbiAgICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudD8uYmFsYW5jZSA/P1xuICAgICAgICAgICAgICBzdGF0ZS5zZWxlY3RlZEFjY291bnQuYmFsYW5jZTtcbiAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscyA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy51cGRhdGVHYXNGZWVFc3RpbWF0ZXMoc3RhdGUsIHtcbiAgICAgICAgICBwYXlsb2FkOiB7XG4gICAgICAgICAgICBnYXNGZWVFc3RpbWF0ZXM6IGFjdGlvbi5wYXlsb2FkLmdhc0ZlZUVzdGltYXRlcyxcbiAgICAgICAgICAgIGdhc0VzdGltYXRlVHlwZTogYWN0aW9uLnBheWxvYWQuZ2FzRXN0aW1hdGVUeXBlLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBzdGF0ZS5nYXNFc3RpbWF0ZVBvbGxUb2tlbiA9IGFjdGlvbi5wYXlsb2FkLmdhc0VzdGltYXRlUG9sbFRva2VuO1xuICAgICAgICBpZiAoYWN0aW9uLnBheWxvYWQuZ2FzRXN0aW1hdGVQb2xsVG9rZW4pIHtcbiAgICAgICAgICBzdGF0ZS5nYXNFc3RpbWF0ZUlzTG9hZGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5zdGFnZSAhPT0gU0VORF9TVEFHRVMuSU5BQ1RJVkUpIHtcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVSZWNpcGllbnRVc2VySW5wdXQoc3RhdGUsIHtcbiAgICAgICAgICAgIHBheWxvYWQ6IHtcbiAgICAgICAgICAgICAgY2hhaW5JZDogYWN0aW9uLnBheWxvYWQuY2hhaW5JZCxcbiAgICAgICAgICAgICAgdG9rZW5zOiBhY3Rpb24ucGF5bG9hZC50b2tlbnMsXG4gICAgICAgICAgICAgIHVzZVRva2VuRGV0ZWN0aW9uOiBhY3Rpb24ucGF5bG9hZC51c2VUb2tlbkRldGVjdGlvbixcbiAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzTGlzdDogYWN0aW9uLnBheWxvYWQudG9rZW5BZGRyZXNzTGlzdCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVgpIHtcbiAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlQW1vdW50VG9NYXgoc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHNsaWNlLmNhc2VSZWR1Y2Vycy52YWxpZGF0ZUFtb3VudEZpZWxkKHN0YXRlKTtcbiAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudmFsaWRhdGVTZW5kU3RhdGUoc3RhdGUpO1xuICAgICAgfSlcbiAgICAgIC5hZGRDYXNlKFNFTEVDVEVEX0FDQ09VTlRfQ0hBTkdFRCwgKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgLy8gVGhpcyBldmVudCBvY2N1cnMgd2hlbiB0aGUgdXNlciBzZWxlY3RzIGEgbmV3IGFjY291bnQgZnJvbSB0aGVcbiAgICAgICAgLy8gYWNjb3VudCBtZW51LCBvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBhY2NvdW50J3MgYmFsYW5jZSB1cGRhdGVzLlxuICAgICAgICAvLyBXZSBvbmx5IGNhcmUgYWJvdXQgbmV3IHRyYW5zYWN0aW9ucywgbm90IGVkaXRzLCBoZXJlLCBiZWNhdXNlIHdlIHVzZVxuICAgICAgICAvLyB0aGUgZnJvbUFjY291bnQgYW5kIEFDQ09VTlRfQ0hBTkdFRCBhY3Rpb24gZm9yIHRoYXQuXG4gICAgICAgIGlmIChzdGF0ZS5zdGFnZSAhPT0gU0VORF9TVEFHRVMuRURJVCAmJiBhY3Rpb24ucGF5bG9hZC5hY2NvdW50KSB7XG4gICAgICAgICAgc3RhdGUuc2VsZWN0ZWRBY2NvdW50LmJhbGFuY2UgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmJhbGFuY2U7XG4gICAgICAgICAgc3RhdGUuc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MgPSBhY3Rpb24ucGF5bG9hZC5hY2NvdW50LmFkZHJlc3M7XG4gICAgICAgICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICAgICAgICBzdGF0ZS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICAgICAgICAvLyBUaGlzIGFjdGlvbiB3aWxsIG9jY3VyIGV2ZW4gd2hlbiB3ZSBhcmVuJ3Qgb24gdGhlIHNlbmQgZmxvdywgd2hpY2hcbiAgICAgICAgICAvLyBpcyBva2F5IGFzIGl0IGtlZXBzIHRoZSBzZWxlY3RlZEFjY291bnQgZGV0YWlscyB1cCB0byBkYXRlLiBXZSBkb1xuICAgICAgICAgIC8vIG5vdCBuZWVkIHRvIHZhbGlkYXRlIGFueXRoaW5nIGlmIHRoZXJlIGlzbid0IGEgY3VycmVudCBkcmFmdFxuICAgICAgICAgIC8vIHRyYW5zYWN0aW9uLiBJZiB0aGVyZSBpcywgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGFzc2V0IGJhbGFuY2UgaWZcbiAgICAgICAgICAvLyB0aGUgYXNzZXQgaXMgc2V0IHRvIHRoZSBuYXRpdmUgbmV0d29yayBhc3NldCwgYW5kIHRoZW4gdmFsaWRhdGVcbiAgICAgICAgICAvLyB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChkcmFmdFRyYW5zYWN0aW9uPy5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUpIHtcbiAgICAgICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC5iYWxhbmNlID0gYWN0aW9uLnBheWxvYWQuYWNjb3VudC5iYWxhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlQW1vdW50RmllbGQoc3RhdGUpO1xuICAgICAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlR2FzRmllbGQoc3RhdGUpO1xuICAgICAgICAgICAgc2xpY2UuY2FzZVJlZHVjZXJzLnZhbGlkYXRlU2VuZFN0YXRlKHN0YXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuYWRkQ2FzZShRUl9DT0RFX0RFVEVDVEVELCAoc3RhdGUsIGFjdGlvbikgPT4ge1xuICAgICAgICAvLyBXaGVuIGRhdGEgaXMgcmVjZWl2ZWQgZnJvbSB0aGUgUVIgQ29kZSBTY2FubmVyIHdlIHNldCB0aGUgcmVjaXBpZW50XG4gICAgICAgIC8vIGFzIGxvbmcgYXMgYSB2YWxpZCBhZGRyZXNzIGNhbiBiZSBwdWxsZWQgZnJvbSB0aGUgZGF0YS4gSWYgYW5cbiAgICAgICAgLy8gYWRkcmVzcyBpcyBwdWxsZWQgYnV0IGl0IGlzIGludmFsaWQsIHdlIGRpc3BsYXkgYW4gZXJyb3IuXG4gICAgICAgIGNvbnN0IHFyQ29kZURhdGEgPSBhY3Rpb24udmFsdWU7XG4gICAgICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgICAgIHN0YXRlLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgICAgICBpZiAocXJDb2RlRGF0YSAmJiBkcmFmdFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgaWYgKHFyQ29kZURhdGEudHlwZSA9PT0gJ2FkZHJlc3MnKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FubmVkQWRkcmVzcyA9IHFyQ29kZURhdGEudmFsdWVzLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgaXNWYWxpZEhleEFkZHJlc3Moc2Nhbm5lZEFkZHJlc3MsIHsgYWxsb3dOb25QcmVmaXhlZDogZmFsc2UgfSlcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICBpZiAoZHJhZnRUcmFuc2FjdGlvbi5yZWNpcGllbnQuYWRkcmVzcyAhPT0gc2Nhbm5lZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICBzbGljZS5jYXNlUmVkdWNlcnMudXBkYXRlUmVjaXBpZW50KHN0YXRlLCB7XG4gICAgICAgICAgICAgICAgICBwYXlsb2FkOiB7IGFkZHJlc3M6IHNjYW5uZWRBZGRyZXNzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24ucmVjaXBpZW50LmVycm9yID1cbiAgICAgICAgICAgICAgICBJTlZBTElEX1JFQ0lQSUVOVF9BRERSRVNTX0VSUk9SO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH0sXG59KTtcblxuY29uc3QgeyBhY3Rpb25zLCByZWR1Y2VyIH0gPSBzbGljZTtcblxuZXhwb3J0IGRlZmF1bHQgcmVkdWNlcjtcblxuY29uc3Qge1xuICB1c2VEZWZhdWx0R2FzLFxuICB1c2VDdXN0b21HYXMsXG4gIHVwZGF0ZUdhc0xpbWl0LFxuICB2YWxpZGF0ZVJlY2lwaWVudFVzZXJJbnB1dCxcbiAgdXBkYXRlUmVjaXBpZW50U2VhcmNoTW9kZSxcbiAgYWRkSGlzdG9yeUVudHJ5LFxuICBhY2tub3dsZWRnZVJlY2lwaWVudFdhcm5pbmcsXG59ID0gYWN0aW9ucztcblxuZXhwb3J0IHtcbiAgdXNlRGVmYXVsdEdhcyxcbiAgdXNlQ3VzdG9tR2FzLFxuICB1cGRhdGVHYXNMaW1pdCxcbiAgYWRkSGlzdG9yeUVudHJ5LFxuICBhY2tub3dsZWRnZVJlY2lwaWVudFdhcm5pbmcsXG59O1xuXG4vLyBBY3Rpb24gQ3JlYXRvcnNcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBmb3IgdXNhZ2Ugd2hlbiB2YWxpZGF0aW5nIHVzZXIgaW5wdXQgc28gdGhhdCB2YWxpZGF0aW9uXG4gKiBpcyBvbmx5IHJ1biBhZnRlciBhIGRlbGF5IGluIHR5cGluZyBvZiAzMDBtcy4gVXNhZ2UgYXQgY2FsbHNpdGVzIHJlcXVpcmVzXG4gKiBwYXNzaW5nIGluIGJvdGggdGhlIGRpc3BhdGNoIG1ldGhvZCBhbmQgdGhlIHBheWxvYWQgdG8gZGlzcGF0Y2gsIHdoaWNoIG1ha2VzXG4gKiBpdCBvbmx5IGFwcGxpY2FibGUgZm9yIHVzZSB3aXRoaW4gYWN0aW9uIGNyZWF0b3JzLlxuICovXG5jb25zdCBkZWJvdW5jZWRWYWxpZGF0ZVJlY2lwaWVudFVzZXJJbnB1dCA9IGRlYm91bmNlKFxuICAoZGlzcGF0Y2gsIHBheWxvYWQsIHJlc29sdmUpID0+IHtcbiAgICBkaXNwYXRjaChcbiAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgYHNlbmRGbG93IC0gdXNlciB0eXBlZCAke3BheWxvYWQudXNlcklucHV0fSBpbnRvIHJlY2lwaWVudCBpbnB1dCBmaWVsZGAsXG4gICAgICApLFxuICAgICk7XG4gICAgZGlzcGF0Y2godmFsaWRhdGVSZWNpcGllbnRVc2VySW5wdXQocGF5bG9hZCkpO1xuICAgIHJlc29sdmUoKTtcbiAgfSxcbiAgMzAwLFxuKTtcblxuLyoqXG4gKiBCZWdpbnMgYSBuZXcgZHJhZnQgdHJhbnNhY3Rpb24sIGRlcml2ZWQgZnJvbSB0aGUgdHhQYXJhbXMgb2YgYW4gZXhpc3RpbmdcbiAqIHRyYW5zYWN0aW9uIGluIHRoZSBUcmFuc2FjdGlvbkNvbnRyb2xsZXIuIFRoaXMgYWN0aW9uIHdpbGwgZmlyc3QgY2xlYXIgb3V0XG4gKiB0aGUgcHJldmlvdXMgZHJhZnQgdHJhbnNhY3Rpb25zIGFuZCBjdXJyZW50VHJhbnNhY3Rpb25VVUlEIGZyb20gc3RhdGUuIFRoaXNcbiAqIGFjdGlvbiBpcyBvbmUgb2YgdGhlIHR3byBlbnRyeSBwb2ludHMgaW50byB0aGUgc2VuZCBmbG93LiBOT1RFOiBZb3UgbXVzdFxuICogcm91dGUgdG8gdGhlIHNlbmQgcGFnZSAqYWZ0ZXIqIGRpc3BhdGNoaW5nIHRoaXMgYWN0aW9uIHJlc29sdmVzIHRvIGVuc3VyZVxuICogdGhhdCB0aGUgZHJhZnRUcmFuc2FjdGlvbiBpcyBwcm9wZXJseSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7QXNzZXRUeXBlc1N0cmluZ30gYXNzZXRUeXBlIC0gVGhlIHR5cGUgb2YgYXNzZXQgdGhlIHRyYW5zYWN0aW9uXG4gKiAgYmVpbmcgZWRpdGVkIHdhcyBzZW5kaW5nLiBUaGUgZGV0YWlscyBvZiB0aGUgYXNzZXQgd2lsbCBiZSByZXRyaWV2ZWQgZnJvbVxuICogIHRoZSB0cmFuc2FjdGlvbiBkYXRhIGluIHN0YXRlLlxuICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zYWN0aW9uSWQgLSBUaGUgaWQgb2YgdGhlIHRyYW5zYWN0aW9uIGJlaW5nIGVkaXRlZC5cbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkaXRFeGlzdGluZ1RyYW5zYWN0aW9uKGFzc2V0VHlwZSwgdHJhbnNhY3Rpb25JZCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGF3YWl0IGRpc3BhdGNoKGFjdGlvbnMuY2xlYXJQcmV2aW91c0RyYWZ0cygpKTtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgdW5hcHByb3ZlZFRyYW5zYWN0aW9ucyA9IGdldFVuYXBwcm92ZWRUeHMoc3RhdGUpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdW5hcHByb3ZlZFRyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkXTtcbiAgICBjb25zdCBhY2NvdW50ID0gZ2V0VGFyZ2V0QWNjb3VudChzdGF0ZSwgdHJhbnNhY3Rpb24udHhQYXJhbXMuZnJvbSk7XG5cbiAgICBpZiAoYXNzZXRUeXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUpIHtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKFxuICAgICAgICBhY3Rpb25zLmFkZE5ld0RyYWZ0KHtcbiAgICAgICAgICAuLi5kcmFmdFRyYW5zYWN0aW9uSW5pdGlhbFN0YXRlLFxuICAgICAgICAgIGlkOiB0cmFuc2FjdGlvbklkLFxuICAgICAgICAgIGZyb21BY2NvdW50OiBhY2NvdW50LFxuICAgICAgICAgIGdhczoge1xuICAgICAgICAgICAgLi4uZHJhZnRUcmFuc2FjdGlvbkluaXRpYWxTdGF0ZS5nYXMsXG4gICAgICAgICAgICBnYXNMaW1pdDogdHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzLFxuICAgICAgICAgICAgZ2FzUHJpY2U6IHRyYW5zYWN0aW9uLnR4UGFyYW1zLmdhc1ByaWNlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXNlcklucHV0SGV4RGF0YTogdHJhbnNhY3Rpb24udHhQYXJhbXMuZGF0YSxcbiAgICAgICAgICByZWNpcGllbnQ6IHtcbiAgICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUucmVjaXBpZW50LFxuICAgICAgICAgICAgYWRkcmVzczogdHJhbnNhY3Rpb24udHhQYXJhbXMudG8sXG4gICAgICAgICAgICBuaWNrbmFtZTpcbiAgICAgICAgICAgICAgZ2V0QWRkcmVzc0Jvb2tFbnRyeU9yQWNjb3VudE5hbWUoXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24udHhQYXJhbXMudG8sXG4gICAgICAgICAgICAgICkgPz8gJycsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUuYW1vdW50LFxuICAgICAgICAgICAgdmFsdWU6IHRyYW5zYWN0aW9uLnR4UGFyYW1zLnZhbHVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGlzdG9yeTogW1xuICAgICAgICAgICAgYHNlbmRGbG93IC0gdXNlciBjbGlja2VkIGVkaXQgb24gdHJhbnNhY3Rpb24gd2l0aCBpZCAke3RyYW5zYWN0aW9uSWR9YCxcbiAgICAgICAgICBdLFxuICAgICAgICB9KSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgdXBkYXRlU2VuZEFzc2V0KFxuICAgICAgICAgIHsgdHlwZTogQVNTRVRfVFlQRVMuTkFUSVZFIH0sXG4gICAgICAgICAgeyBpbml0aWFsQXNzZXRTZXQ6IHRydWUgfSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRva2VuRGF0YSA9IHBhcnNlU3RhbmRhcmRUb2tlblRyYW5zYWN0aW9uRGF0YShcbiAgICAgICAgdHJhbnNhY3Rpb24udHhQYXJhbXMuZGF0YSxcbiAgICAgICk7XG4gICAgICBjb25zdCB0b2tlbkFtb3VudEluRGVjID1cbiAgICAgICAgYXNzZXRUeXBlID09PSBBU1NFVF9UWVBFUy5UT0tFTiA/IGdldFRva2VuVmFsdWVQYXJhbSh0b2tlbkRhdGEpIDogJzEnO1xuICAgICAgY29uc3QgYWRkcmVzcyA9IGdldFRva2VuQWRkcmVzc1BhcmFtKHRva2VuRGF0YSk7XG4gICAgICBjb25zdCBuaWNrbmFtZSA9IGdldEFkZHJlc3NCb29rRW50cnlPckFjY291bnROYW1lKHN0YXRlLCBhZGRyZXNzKSA/PyAnJztcblxuICAgICAgY29uc3QgdG9rZW5BbW91bnRJbkhleCA9IGFkZEhleFByZWZpeChcbiAgICAgICAgY29udmVyc2lvblV0aWwodG9rZW5BbW91bnRJbkRlYywge1xuICAgICAgICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIGFjdGlvbnMuYWRkTmV3RHJhZnQoe1xuICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUsXG4gICAgICAgICAgaWQ6IHRyYW5zYWN0aW9uSWQsXG4gICAgICAgICAgZnJvbUFjY291bnQ6IGFjY291bnQsXG4gICAgICAgICAgZ2FzOiB7XG4gICAgICAgICAgICAuLi5kcmFmdFRyYW5zYWN0aW9uSW5pdGlhbFN0YXRlLmdhcyxcbiAgICAgICAgICAgIGdhc0xpbWl0OiB0cmFuc2FjdGlvbi50eFBhcmFtcy5nYXMsXG4gICAgICAgICAgICBnYXNQcmljZTogdHJhbnNhY3Rpb24udHhQYXJhbXMuZ2FzUHJpY2UsXG4gICAgICAgICAgfSxcbiAgICAgICAgICB1c2VySW5wdXRIZXhEYXRhOiB0cmFuc2FjdGlvbi50eFBhcmFtcy5kYXRhLFxuICAgICAgICAgIHJlY2lwaWVudDoge1xuICAgICAgICAgICAgLi4uZHJhZnRUcmFuc2FjdGlvbkluaXRpYWxTdGF0ZS5yZWNpcGllbnQsXG4gICAgICAgICAgICBhZGRyZXNzLFxuICAgICAgICAgICAgbmlja25hbWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICAgIC4uLmRyYWZ0VHJhbnNhY3Rpb25Jbml0aWFsU3RhdGUuYW1vdW50LFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuQW1vdW50SW5IZXgsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBoaXN0b3J5OiBbXG4gICAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIGNsaWNrZWQgZWRpdCBvbiB0cmFuc2FjdGlvbiB3aXRoIGlkICR7dHJhbnNhY3Rpb25JZH1gLFxuICAgICAgICAgIF0sXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIHVwZGF0ZVNlbmRBc3NldChcbiAgICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBhc3NldFR5cGUsXG4gICAgICAgICAgICBkZXRhaWxzOiB7XG4gICAgICAgICAgICAgIGFkZHJlc3M6IHRyYW5zYWN0aW9uLnR4UGFyYW1zLnRvLFxuICAgICAgICAgICAgICAuLi4oYXNzZXRUeXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbklkOlxuICAgICAgICAgICAgICAgICAgICAgIGdldFRva2VuSWRQYXJhbSh0b2tlbkRhdGEpID8/XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0VG9rZW5WYWx1ZVBhcmFtKHRva2VuRGF0YSksXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyBpbml0aWFsQXNzZXRTZXQ6IHRydWUgfSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYXdhaXQgZGlzcGF0Y2goaW5pdGlhbGl6ZVNlbmRTdGF0ZSgpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlciB0byBzdXBwb3J0IHRoZSBvbGQgVUkgaW4gYm90aCB0aGVcbiAqIGdhcyBtb2RhbCBhbmQgdGhlIHNlbmQgZmxvdy4gU29vbiB3ZSB3b24ndCBuZWVkIHRvIG1vZGlmeSBnYXNQcmljZSBmcm9tIHRoZVxuICogc2VuZCBmbG93IGJhc2VkIG9uIHVzZXIgaW5wdXQsIGl0J2xsIGp1c3QgYmUgYSBzaGFsbG93IGNvcHkgb2YgdGhlIGN1cnJlbnRcbiAqIGVzdGltYXRlLiBUaGlzIG1ldGhvZCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgaW50ZXJuYWwgc3RydWN0dXJlIG9mIHRoaXNcbiAqIHNsaWNlIGhhcyBiZWVuIGNoYW5nZWQgc3VjaCB0aGF0IGl0IGlzIGFnbm9zdGljIHRvIHRyYW5zYWN0aW9uIGVudmVsb3BlXG4gKiB0eXBlLCBhbmQgdGhpcyBtZXRob2QgY2FsbHMgaW50byB0aGUgbmV3IHN0cnVjdHVyZSBpbiB0aGUgYXBwcm9wcmlhdGUgd2F5LlxuICpcbiAqIEBkZXByZWNhdGVkIC0gZG9uJ3QgZXh0ZW5kIHRoZSB1c2FnZSBvZiB0aGlzIHRlbXBvcmFyeSBtZXRob2RcbiAqIEBwYXJhbSB7c3RyaW5nfSBnYXNQcmljZSAtIG5ldyBnYXMgcHJpY2UgaW4gaGV4IHdlaVxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlR2FzUHJpY2UoZ2FzUHJpY2UpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIGRpc3BhdGNoKFxuICAgICAgYWRkSGlzdG9yeUVudHJ5KGBzZW5kRmxvdyAtIHVzZXIgc2V0IGxlZ2FjeSBnYXNQcmljZSB0byAke2dhc1ByaWNlfWApLFxuICAgICk7XG4gICAgZGlzcGF0Y2goXG4gICAgICBhY3Rpb25zLnVwZGF0ZUdhc0ZlZXMoe1xuICAgICAgICBnYXNQcmljZSxcbiAgICAgICAgdHJhbnNhY3Rpb25UeXBlOiBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUy5MRUdBQ1ksXG4gICAgICAgIG1hbnVhbGx5RWRpdGVkOiB0cnVlLFxuICAgICAgfSksXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVcGRhdGVzIHRoZSByZWNpcGllbnQgaW4gc3RhdGUgYmFzZWQgb24gdGhlIGlucHV0IHByb3ZpZGVkLCBhbmQgdGhlbiB3aWxsXG4gKiByZWNvbXB1dGUgZ2FzIGxpbWl0IHdoZW4gc2VuZGluZyBhIFRPS0VOIGFzc2V0IHR5cGUuIENoYW5naW5nIHRoZSByZWNpcGllbnRcbiAqIGFkZHJlc3MgcmVzdWx0cyBpbiBoZXggZGF0YSBjaGFuZ2luZyBiZWNhdXNlIHRoZSByZWNpcGllbnQgYWRkcmVzcyBpc1xuICogZW5jb2RlZCBpbiB0aGUgZGF0YSBpbnN0ZWFkIG9mIGJlaW5nIGluIHRoZSAndG8nIGZpZWxkLiBUaGUgdG8gZmllbGQgaW4gYVxuICogdG9rZW4gc2VuZCB3aWxsIGFsd2F5cyBiZSB0aGUgdG9rZW4gY29udHJhY3QgYWRkcmVzcy5cbiAqIElmIG5vIG5pY2tuYW1lIGlzIHByb3ZpZGVkLCB0aGUgYWRkcmVzcyBib29rIHN0YXRlIHdpbGwgYmUgY2hlY2tlZCB0byBzZWUgaWZcbiAqIGEgbmlja25hbWUgZm9yIHRoZSBwYXNzZWQgYWRkcmVzcyBoYXMgYWxyZWFkeSBiZWVuIHNhdmVkLiBUaGlzIGVuc3VyZXMgdGhlXG4gKiAodGVtcG9yYXJ5KSBzZW5kIHN0YXRlIHJlY2lwaWVudCBuaWNrbmFtZSBpcyBjb25zaXN0ZW50IHdpdGggdGhlIGFkZHJlc3MgYm9va1xuICogbmlja25hbWUgd2hpY2ggaGFzIGFscmVhZHkgYmVlbiBwZXJzaXN0ZWQgdG8gc3RhdGUuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHJlY2lwaWVudCAtIFJlY2lwaWVudCBpbmZvcm1hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IHJlY2lwaWVudC5hZGRyZXNzIC0gaGV4IGFkZHJlc3MgdG8gc2VuZCB0aGUgdHJhbnNhY3Rpb24gdG9cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcmVjaXBpZW50Lm5pY2tuYW1lXSAtIEFsaWFzIGZvciB0aGUgYWRkcmVzcyB0byBkaXNwbGF5XG4gKiAgdG8gdGhlIHVzZXJcbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVJlY2lwaWVudCh7IGFkZHJlc3MsIG5pY2tuYW1lIH0pIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICAvLyBEbyBub3QgYWRkSGlzdG9yeUVudHJ5IGhlcmUgYXMgdGhpcyBpcyBjYWxsZWQgZnJvbSBhIG51bWJlciBvZiBwbGFjZXNcbiAgICAvLyBlYWNoIHdpdGggc2lnbmlmaWNhbmNlIHRvIHRoZSB1c2VyIGFuZCB0cmFuc2FjdGlvbiBoaXN0b3J5LlxuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBuaWNrbmFtZUZyb21BZGRyZXNzQm9va0VudHJ5T3JBY2NvdW50TmFtZSA9XG4gICAgICBnZXRBZGRyZXNzQm9va0VudHJ5T3JBY2NvdW50TmFtZShzdGF0ZSwgYWRkcmVzcykgPz8gJyc7XG4gICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICBhY3Rpb25zLnVwZGF0ZVJlY2lwaWVudCh7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIG5pY2tuYW1lOiBuaWNrbmFtZSB8fCBuaWNrbmFtZUZyb21BZGRyZXNzQm9va0VudHJ5T3JBY2NvdW50TmFtZSxcbiAgICAgIH0pLFxuICAgICk7XG4gICAgYXdhaXQgZGlzcGF0Y2goY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0KCkpO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0byB1cGRhdGUgdGhlIHVzZXIncyBpbnB1dCBpbnRvIHRoZSBFTlMgaW5wdXQgZmllbGQuXG4gKiBPbmNlIHRoZSBmaWVsZCBpcyB1cGRhdGVkLCB0aGUgZmllbGQgd2lsbCBiZSB2YWxpZGF0ZWQgdXNpbmcgYSBkZWJvdW5jZWRcbiAqIHZlcnNpb24gb2YgdGhlIHZhbGlkYXRlUmVjaXBpZW50VXNlcklucHV0IGFjdGlvbi4gVGhpcyB3YXkgdmFsaWRhdGlvbiBvbmx5XG4gKiBvY2N1cnMgb25jZSB0aGUgdXNlciBoYXMgc3RvcHBlZCB0eXBpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVzZXJJbnB1dCAtIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIGlzIHR5cGluZyBpbnRvIHRoZSBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUmVjaXBpZW50VXNlcklucHV0KHVzZXJJbnB1dCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGRpc3BhdGNoKGFjdGlvbnMudXBkYXRlUmVjaXBpZW50V2FybmluZygnbG9hZGluZycpKTtcbiAgICBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZURyYWZ0VHJhbnNhY3Rpb25TdGF0dXMoU0VORF9TVEFUVVNFUy5JTlZBTElEKSk7XG4gICAgYXdhaXQgZGlzcGF0Y2goYWN0aW9ucy51cGRhdGVSZWNpcGllbnRVc2VySW5wdXQodXNlcklucHV0KSk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc3RhdGVbbmFtZV0uZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGVbbmFtZV0uY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgY29uc3Qgc2VuZGluZ0FkZHJlc3MgPVxuICAgICAgZHJhZnRUcmFuc2FjdGlvbi5mcm9tQWNjb3VudD8uYWRkcmVzcyA/P1xuICAgICAgc3RhdGVbbmFtZV0uc2VsZWN0ZWRBY2NvdW50LmFkZHJlc3MgPz9cbiAgICAgIGdldFNlbGVjdGVkQWRkcmVzcyhzdGF0ZSk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKHN0YXRlKTtcbiAgICBjb25zdCB0b2tlbnMgPSBnZXRUb2tlbnMoc3RhdGUpO1xuICAgIGNvbnN0IHVzZVRva2VuRGV0ZWN0aW9uID0gZ2V0VXNlVG9rZW5EZXRlY3Rpb24oc3RhdGUpO1xuICAgIGNvbnN0IHRva2VuTWFwID0gZ2V0VG9rZW5MaXN0KHN0YXRlKTtcbiAgICBjb25zdCB0b2tlbkFkZHJlc3NMaXN0ID0gT2JqZWN0LmtleXModG9rZW5NYXApO1xuXG4gICAgY29uc3QgaW5wdXRJc1ZhbGlkSGV4QWRkcmVzcyA9IGlzVmFsaWRIZXhBZGRyZXNzKHVzZXJJbnB1dCk7XG4gICAgbGV0IGlzUHJvYmFibHlBbkFzc2V0Q29udHJhY3QgPSBmYWxzZTtcbiAgICBpZiAoaW5wdXRJc1ZhbGlkSGV4QWRkcmVzcykge1xuICAgICAgY29uc3Qgc21hcnRDb250cmFjdEFkZHJlc3MgPSBhd2FpdCBpc1NtYXJ0Q29udHJhY3RBZGRyZXNzKHVzZXJJbnB1dCk7XG4gICAgICBpZiAoc21hcnRDb250cmFjdEFkZHJlc3MpIHtcbiAgICAgICAgZGlzcGF0Y2goYWN0aW9ucy51cGRhdGVSZWNpcGllbnRUeXBlKFJFQ0lQSUVOVF9UWVBFUy5TTUFSVF9DT05UUkFDVCkpO1xuICAgICAgICBjb25zdCB7IHN5bWJvbCwgZGVjaW1hbHMgfSA9XG4gICAgICAgICAgZ2V0VG9rZW5NZXRhZGF0YSh1c2VySW5wdXQsIHRva2VuTWFwKSB8fCB7fTtcblxuICAgICAgICBpc1Byb2JhYmx5QW5Bc3NldENvbnRyYWN0ID0gc3ltYm9sICYmIGRlY2ltYWxzICE9PSB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKCFpc1Byb2JhYmx5QW5Bc3NldENvbnRyYWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhbmRhcmQgfSA9IGF3YWl0IGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKFxuICAgICAgICAgICAgICB1c2VySW5wdXQsXG4gICAgICAgICAgICAgIHNlbmRpbmdBZGRyZXNzLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlzUHJvYmFibHlBbkFzc2V0Q29udHJhY3QgPSBCb29sZWFuKHN0YW5kYXJkKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgIGRlYm91bmNlZFZhbGlkYXRlUmVjaXBpZW50VXNlcklucHV0KFxuICAgICAgICBkaXNwYXRjaCxcbiAgICAgICAge1xuICAgICAgICAgIHVzZXJJbnB1dCxcbiAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgIHRva2VucyxcbiAgICAgICAgICB1c2VUb2tlbkRldGVjdGlvbixcbiAgICAgICAgICB0b2tlbkFkZHJlc3NMaXN0LFxuICAgICAgICAgIGlzUHJvYmFibHlBbkFzc2V0Q29udHJhY3QsXG4gICAgICAgIH0sXG4gICAgICAgIHJlc29sdmUsXG4gICAgICApO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIGFtb3VudCB0aGUgdXNlciBpbnRlbmRzIHRvIHNlbmQgYW5kIHBlcmZvcm1zIHNpZGUgZWZmZWN0cy5cbiAqIDEuIElmIHRoZSBjdXJyZW50IG1vZGUgaXMgTUFYIGNoYW5nZSB0byBJTlBVVFxuICogMi4gSWYgc2VuZGluZyBhIHRva2VuLCByZWNvbXB1dGUgdGhlIGdhc0xpbWl0IGVzdGltYXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFtb3VudCAtIGhleCBzdHJpbmcgcmVwcmVzZW50aW5nIHZhbHVlXG4gKiBAcmV0dXJucyB7VGh1bmtBY3Rpb248dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTZW5kQW1vdW50KGFtb3VudCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IG1ldGFtYXNrIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgIHN0YXRlW25hbWVdLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlW25hbWVdLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgIGxldCBsb2dBbW91bnQgPSBhbW91bnQ7XG4gICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuVE9LRU4pIHtcbiAgICAgIGNvbnN0IG11bHRpcGxpZXIgPSBNYXRoLnBvdyhcbiAgICAgICAgMTAsXG4gICAgICAgIE51bWJlcihkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHM/LmRlY2ltYWxzIHx8IDApLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGRlY2ltYWxWYWx1ZVN0cmluZyA9IGNvbnZlcnNpb25VdGlsKGFkZEhleFByZWZpeChhbW91bnQpLCB7XG4gICAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgICAgICB0b0N1cnJlbmN5OiBkcmFmdFRyYW5zYWN0aW9uLmFzc2V0LmRldGFpbHM/LnN5bWJvbCxcbiAgICAgICAgY29udmVyc2lvblJhdGU6IG11bHRpcGxpZXIsXG4gICAgICAgIGludmVydENvbnZlcnNpb25SYXRlOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGxvZ0Ftb3VudCA9IGAke051bWJlcihkZWNpbWFsVmFsdWVTdHJpbmcpID8gZGVjaW1hbFZhbHVlU3RyaW5nIDogJyd9ICR7XG4gICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQuZGV0YWlscz8uc3ltYm9sXG4gICAgICB9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZXRoVmFsdWUgPSBnZXRWYWx1ZUZyb21XZWlIZXgoe1xuICAgICAgICB2YWx1ZTogYW1vdW50LFxuICAgICAgICB0b0N1cnJlbmN5OiBFVEgsXG4gICAgICAgIG51bWJlck9mRGVjaW1hbHM6IDgsXG4gICAgICB9KTtcbiAgICAgIGxvZ0Ftb3VudCA9IGAke2V0aFZhbHVlfSAke21ldGFtYXNrPy5wcm92aWRlcj8udGlja2VyIHx8IEVUSH1gO1xuICAgIH1cbiAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgIGFkZEhpc3RvcnlFbnRyeShgc2VuZEZsb3cgLSB1c2VyIHNldCBhbW91bnQgdG8gJHtsb2dBbW91bnR9YCksXG4gICAgKTtcbiAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZVNlbmRBbW91bnQoYW1vdW50KSk7XG4gICAgaWYgKHN0YXRlW25hbWVdLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVgpIHtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGFjdGlvbnMudXBkYXRlQW1vdW50TW9kZShBTU9VTlRfTU9ERVMuSU5QVVQpKTtcbiAgICB9XG4gICAgYXdhaXQgZGlzcGF0Y2goY29tcHV0ZUVzdGltYXRlZEdhc0xpbWl0KCkpO1xuICB9O1xufVxuXG4vKipcbiAqIHVwZGF0ZXMgdGhlIGFzc2V0IHRvIHNlbmQgdG8gb25lIG9mIE5BVElWRSBvciBUT0tFTiBhbmQgZW5zdXJlcyB0aGF0IHRoZVxuICogYXNzZXQgYmFsYW5jZSBpcyBzZXQuIElmIHNlbmRpbmcgYSBUT0tFTiBhbHNvIHVwZGF0ZXMgdGhlIGFzc2V0IGRldGFpbHNcbiAqIG9iamVjdCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBFUkMyMCBkZXRhaWxzIGluY2x1ZGluZyBhZGRyZXNzLCBzeW1ib2wgYW5kXG4gKiBkZWNpbWFscy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZCAtIGFjdGlvbiBwYXlsb2FkXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF5bG9hZC50eXBlIC0gdHlwZSBvZiBhc3NldCB0byBzZW5kXG4gKiBAcGFyYW0ge1Rva2VuRGV0YWlsc30gW3BheWxvYWQuZGV0YWlsc10gLSBFUkMyMCBkZXRhaWxzIGlmIHNlbmRpbmcgVE9LRU4gYXNzZXRcbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVNlbmRBc3NldChcbiAgeyB0eXBlLCBkZXRhaWxzOiBwcm92aWRlZERldGFpbHMgfSxcbiAgeyBpbml0aWFsQXNzZXRTZXQgPSBmYWxzZSB9ID0ge30sXG4pIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgZHJhZnRUcmFuc2FjdGlvbiA9XG4gICAgICBzdGF0ZVtuYW1lXS5kcmFmdFRyYW5zYWN0aW9uc1tzdGF0ZVtuYW1lXS5jdXJyZW50VHJhbnNhY3Rpb25VVUlEXTtcbiAgICBjb25zdCBzZW5kaW5nQWRkcmVzcyA9XG4gICAgICBkcmFmdFRyYW5zYWN0aW9uLmZyb21BY2NvdW50Py5hZGRyZXNzID8/XG4gICAgICBzdGF0ZVtuYW1lXS5zZWxlY3RlZEFjY291bnQuYWRkcmVzcyA/P1xuICAgICAgZ2V0U2VsZWN0ZWRBZGRyZXNzKHN0YXRlKTtcbiAgICBjb25zdCBhY2NvdW50ID0gZ2V0VGFyZ2V0QWNjb3VudChzdGF0ZSwgc2VuZGluZ0FkZHJlc3MpO1xuICAgIGlmICh0eXBlID09PSBBU1NFVF9UWVBFUy5OQVRJVkUpIHtcbiAgICAgIGNvbnN0IHVuYXBwcm92ZWRUeHMgPSBnZXRVbmFwcHJvdmVkVHhzKHN0YXRlKTtcbiAgICAgIGNvbnN0IHVuYXBwcm92ZWRUeCA9IHVuYXBwcm92ZWRUeHM/LltkcmFmdFRyYW5zYWN0aW9uLmlkXTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNldCBhc3NldCBvZiB0eXBlICR7XG4gICAgICAgICAgICBBU1NFVF9UWVBFUy5OQVRJVkVcbiAgICAgICAgICB9IHdpdGggc3ltYm9sICR7c3RhdGUubWV0YW1hc2sucHJvdmlkZXI/LnRpY2tlciA/PyBFVEh9YCxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgYWN0aW9ucy51cGRhdGVBc3NldCh7XG4gICAgICAgICAgYXNzZXQ6IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBkZXRhaWxzOiBudWxsLFxuICAgICAgICAgICAgYmFsYW5jZTogYWNjb3VudC5iYWxhbmNlLFxuICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbml0aWFsQXNzZXRTZXQsXG4gICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgICAgLy8gVGhpcyBpcyBtZWFudCB0byBoYW5kbGUgY2FzZXMgd2hlcmUgd2UgYXJlIGVkaXRpbmcgYW4gdW5hcHByb3ZlZFR4IGZyb20gdGhlIGJhY2tncm91bmQgc3RhdGVcbiAgICAgIC8vIGFuZCBpdHMgdHlwZSBpcyBhIHRva2VuIG1ldGhvZC4gSW4gc3VjaCBhIGNhc2UsIHRoZSBoZXggZGF0YSB3aWxsIGJlIHRoZSBuZWNlc3NhcnkgaGV4IGRhdGFcbiAgICAgIC8vIGZvciBjYWxsaW5nIHRoZSBjb250cmFjdCB0cmFuc2ZlciBtZXRob2QuXG4gICAgICAvLyBOb3cgdGhhdCB3ZSBhcmUgdXBkYXRpbmcgdGhlIHRyYW5zYWN0aW9uIHRvIGJlIGEgc2VuZCBvZiBhIG5hdGl2ZSBhc3NldCB0eXBlLCB3ZSBzaG91bGRcbiAgICAgIC8vIHNldCB0aGUgaGV4IGRhdGEgb2YgdGhlIHRyYW5zYWN0aW9uIGJlaW5nIGVkaXRpbmcgdG8gYmUgZW1wdHkuXG4gICAgICAvLyB0aGVuIHRoZSB1c2VyIHdpbGwgbm90IHdhbnQgdG8gc2VuZCBhbnkgaGV4IGRhdGEgbm93IHRoYXQgdGhleSBoYXZlIGNoYW5nZSB0aGVcbiAgICAgIGlmIChcbiAgICAgICAgdW5hcHByb3ZlZFR4Py50eXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSB8fFxuICAgICAgICB1bmFwcHJvdmVkVHg/LnR5cGUgPT09IFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUiB8fFxuICAgICAgICB1bmFwcHJvdmVkVHg/LnR5cGUgPT09IFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TQUZFX1RSQU5TRkVSX0ZST01cbiAgICAgICkge1xuICAgICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZVVzZXJJbnB1dEhleERhdGEoJycpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXdhaXQgZGlzcGF0Y2goc2hvd0xvYWRpbmdJbmRpY2F0aW9uKCkpO1xuICAgICAgY29uc3QgZGV0YWlscyA9IHtcbiAgICAgICAgLi4ucHJvdmlkZWREZXRhaWxzLFxuICAgICAgICAuLi4oYXdhaXQgZ2V0VG9rZW5TdGFuZGFyZEFuZERldGFpbHMoXG4gICAgICAgICAgcHJvdmlkZWREZXRhaWxzLmFkZHJlc3MsXG4gICAgICAgICAgc2VuZGluZ0FkZHJlc3MsXG4gICAgICAgICAgcHJvdmlkZWREZXRhaWxzLnRva2VuSWQsXG4gICAgICAgICkpLFxuICAgICAgfTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGhpZGVMb2FkaW5nSW5kaWNhdGlvbigpKTtcblxuICAgICAgY29uc3QgYXNzZXQgPSB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIGRldGFpbHMsXG4gICAgICAgIGVycm9yOiBudWxsLFxuICAgICAgfTtcblxuICAgICAgaWYgKGRldGFpbHMuc3RhbmRhcmQgPT09IFRPS0VOX1NUQU5EQVJEUy5FUkMyMCkge1xuICAgICAgICBhc3NldC5iYWxhbmNlID0gYWRkSGV4UHJlZml4KFxuICAgICAgICAgIGNhbGNUb2tlbkFtb3VudChkZXRhaWxzLmJhbGFuY2UsIGRldGFpbHMuZGVjaW1hbHMpLnRvU3RyaW5nKDE2KSxcbiAgICAgICAgKTtcblxuICAgICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgICBhZGRIaXN0b3J5RW50cnkoXG4gICAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNldCBhc3NldCB0byBFUkMyMCB0b2tlbiB3aXRoIHN5bWJvbCAke2RldGFpbHMuc3ltYm9sfSBhbmQgYWRkcmVzcyAke2RldGFpbHMuYWRkcmVzc31gLFxuICAgICAgICAgICksXG4gICAgICAgICk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBkZXRhaWxzLnN0YW5kYXJkID09PSBUT0tFTl9TVEFOREFSRFMuRVJDMTE1NSAmJlxuICAgICAgICB0eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2VuZHMgb2YgRVJDMTE1NSB0b2tlbnMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkJyk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBkZXRhaWxzLnN0YW5kYXJkID09PSBUT0tFTl9TVEFOREFSRFMuRVJDMTE1NSB8fFxuICAgICAgICBkZXRhaWxzLnN0YW5kYXJkID09PSBUT0tFTl9TVEFOREFSRFMuRVJDNzIxXG4gICAgICApIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IEFTU0VUX1RZUEVTLlRPS0VOICYmIHByb2Nlc3MuZW52LkNPTExFQ1RJQkxFU19WMSkge1xuICAgICAgICAgIGRpc3BhdGNoKFxuICAgICAgICAgICAgc2hvd01vZGFsKHtcbiAgICAgICAgICAgICAgbmFtZTogJ0NPTlZFUlRfVE9LRU5fVE9fTkZUJyxcbiAgICAgICAgICAgICAgdG9rZW5BZGRyZXNzOiBkZXRhaWxzLmFkZHJlc3MsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICApO1xuICAgICAgICAgIGFzc2V0LmVycm9yID0gSU5WQUxJRF9BU1NFVF9UWVBFO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlZBTElEX0FTU0VUX1RZUEUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBpc0N1cnJlbnRPd25lciA9IHRydWU7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlzQ3VycmVudE93bmVyID0gYXdhaXQgaXNDb2xsZWN0aWJsZU93bmVyKFxuICAgICAgICAgICAgICBzZW5kaW5nQWRkcmVzcyxcbiAgICAgICAgICAgICAgZGV0YWlscy5hZGRyZXNzLFxuICAgICAgICAgICAgICBkZXRhaWxzLnRva2VuSWQsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdVbmFibGUgdG8gdmVyaWZ5IG93bmVyc2hpcC4nKSkge1xuICAgICAgICAgICAgICAvLyB0aGlzIHdvdWxkIGluZGljYXRlIHRoYXQgZWl0aGVyIG91ciBhdHRlbXB0cyB0byB2ZXJpZnkgb3duZXJzaGlwIGZhaWxlZCBiZWNhdXNlIG9mIG5ldHdvcmsgaXNzdWVzLFxuICAgICAgICAgICAgICAvLyBvciwgc29tZWhvdyBhIHRva2VuIGhhcyBiZWVuIGFkZGVkIHRvIGNvbGxlY3RpYmxlcyBzdGF0ZSB3aXRoIGFuIGluY29ycmVjdCBjaGFpbklkLlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQW55IG90aGVyIGVycm9yIGlzIHVuZXhwZWN0ZWQgYW5kIHNob3VsZCBiZSBzdXJmYWNlZC5cbiAgICAgICAgICAgICAgZGlzcGF0Y2goZGlzcGxheVdhcm5pbmcoZXJyLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNDdXJyZW50T3duZXIpIHtcbiAgICAgICAgICAgIGFzc2V0LmVycm9yID0gbnVsbDtcbiAgICAgICAgICAgIGFzc2V0LmJhbGFuY2UgPSAnMHgxJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAnU2VuZCBzbGljZSBpbml0aWFsaXplZCBhcyBjb2xsZWN0aWJsZSBzZW5kIHdpdGggYSBjb2xsZWN0aWJsZSBub3QgY3VycmVudGx5IG93bmVkIGJ5IHRoZSBzZWxlY3QgYWNjb3VudCcsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgICAgICAgYHNlbmRGbG93IC0gdXNlciBzZXQgYXNzZXQgdG8gTkZUIHdpdGggdG9rZW5JZCAke2RldGFpbHMudG9rZW5JZH0gYW5kIGFkZHJlc3MgJHtkZXRhaWxzLmFkZHJlc3N9YCxcbiAgICAgICAgICAgICksXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZUFzc2V0KHsgYXNzZXQsIGluaXRpYWxBc3NldFNldCB9KSk7XG4gICAgfVxuICAgIGlmIChpbml0aWFsQXNzZXRTZXQgPT09IGZhbHNlKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChjb21wdXRlRXN0aW1hdGVkR2FzTGltaXQoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFdoZW4gYSB1c2VyIGhhcyBlbmFibGVkIGhleCBkYXRhIGZpZWxkIGluIGFkdmFuY2VkIHNldHRpbmdzIHRoZXkgd2lsbCBiZVxuICogYWJsZSB0byBzdXBwbHkgaGV4IGRhdGEgb24gYSB0cmFuc2FjdGlvbi4gVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgdXNlclxuICogc3VwcGxpZWQgZGF0YS4gTm90ZSwgd2hlbiBzZW5kaW5nIG5hdGl2ZSBhc3NldHMgdGhpcyB3aWxsIHJlc3VsdCBpblxuICogcmVjb21wdXRpbmcgZXN0aW1hdGVkIGdhc0xpbWl0LiBXaGVuIHNlbmRpbmcgYSBFUkMyMCBhc3NldCB0aGlzIGlzIG5vdCBkb25lXG4gKiBiZWNhdXNlIHRoZSBkYXRhIHNlbnQgaW4gdGhlIHRyYW5zYWN0aW9uIHdpbGwgYmUgZGV0ZXJtaW5lZCBieSB0aGUgYXNzZXQsXG4gKiByZWNpcGllbnQgYW5kIHZhbHVlLCBOT1Qgd2hhdCB0aGUgdXNlciBoYXMgc3VwcGxpZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhleERhdGEgLSBoZXggZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50aW5nIHRyYW5zYWN0aW9uIGRhdGEuXG4gKiBAcmV0dXJucyB7VGh1bmtBY3Rpb248dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTZW5kSGV4RGF0YShoZXhEYXRhKSB7XG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICBhZGRIaXN0b3J5RW50cnkoYHNlbmRGbG93IC0gdXNlciBhZGRlZCBjdXN0b20gaGV4RGF0YSAke2hleERhdGF9YCksXG4gICAgKTtcblxuICAgIGF3YWl0IGRpc3BhdGNoKGFjdGlvbnMudXBkYXRlVXNlcklucHV0SGV4RGF0YShoZXhEYXRhKSk7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPVxuICAgICAgc3RhdGVbbmFtZV0uZHJhZnRUcmFuc2FjdGlvbnNbc3RhdGVbbmFtZV0uY3VycmVudFRyYW5zYWN0aW9uVVVJRF07XG4gICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSA9PT0gQVNTRVRfVFlQRVMuTkFUSVZFKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChjb21wdXRlRXN0aW1hdGVkR2FzTGltaXQoKSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHJlY2lwaWVudCBzZWFyY2ggbW9kZSB0byBzaG93IGEgbGlzdCBvZiB0aGUgdXNlcidzIGNvbnRhY3RzIGFuZFxuICogcmVjZW50bHkgaW50ZXJhY3RlZCB3aXRoIGFkZHJlc3Nlcy5cbiAqXG4gKiBAcmV0dXJucyB7VGh1bmtBY3Rpb248dm9pZD59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb250YWN0TGlzdEZvclJlY2lwaWVudFNlYXJjaCgpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIGRpc3BhdGNoKFxuICAgICAgYWRkSGlzdG9yeUVudHJ5KFxuICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNlbGVjdGVkIGJhY2sgdG8gYWxsIG9uIHJlY2lwaWVudCBzY3JlZW5gLFxuICAgICAgKSxcbiAgICApO1xuICAgIGRpc3BhdGNoKHVwZGF0ZVJlY2lwaWVudFNlYXJjaE1vZGUoUkVDSVBJRU5UX1NFQVJDSF9NT0RFUy5DT05UQUNUX0xJU1QpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSByZWNpcGllbnQgc2VhcmNoIG1vZGUgdG8gc2hvdyBhIGxpc3Qgb2YgdGhlIHVzZXIncyBvd24gYWNjb3VudHMuXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTXlBY2NvdW50c0ZvclJlY2lwaWVudFNlYXJjaCgpIHtcbiAgcmV0dXJuIChkaXNwYXRjaCkgPT4ge1xuICAgIGRpc3BhdGNoKFxuICAgICAgYWRkSGlzdG9yeUVudHJ5KFxuICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIHNlbGVjdGVkIHRyYW5zZmVyIHRvIG15IGFjY291bnRzIG9uIHJlY2lwaWVudCBzY3JlZW5gLFxuICAgICAgKSxcbiAgICApO1xuICAgIGRpc3BhdGNoKHVwZGF0ZVJlY2lwaWVudFNlYXJjaE1vZGUoUkVDSVBJRU5UX1NFQVJDSF9NT0RFUy5NWV9BQ0NPVU5UUykpO1xuICB9O1xufVxuXG4vKipcbiAqIENsZWFycyBvdXQgdGhlIHJlY2lwaWVudCB1c2VyIGlucHV0LCBFTlMgcmVzb2x1dGlvbiBhbmQgcmVjaXBpZW50IHZhbGlkYXRpb24uXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRSZWNpcGllbnRJbnB1dCgpIHtcbiAgcmV0dXJuIGFzeW5jIChkaXNwYXRjaCwgZ2V0U3RhdGUpID0+IHtcbiAgICBjb25zdCBzdGF0ZSA9IGdldFN0YXRlKCk7XG4gICAgY29uc3QgY2hhaW5JZCA9IGdldEN1cnJlbnRDaGFpbklkKHN0YXRlKTtcbiAgICBhd2FpdCBkaXNwYXRjaChhZGRIaXN0b3J5RW50cnkoYHNlbmRGbG93IC0gdXNlciBjbGVhcmVkIHJlY2lwaWVudCBpbnB1dGApKTtcbiAgICBhd2FpdCBkaXNwYXRjaCh1cGRhdGVSZWNpcGllbnRVc2VySW5wdXQoJycpKTtcbiAgICBhd2FpdCBkaXNwYXRjaCh1cGRhdGVSZWNpcGllbnQoeyBhZGRyZXNzOiAnJywgbmlja25hbWU6ICcnIH0pKTtcbiAgICBhd2FpdCBkaXNwYXRjaChyZXNldEVuc1Jlc29sdXRpb24oKSk7XG4gICAgYXdhaXQgZGlzcGF0Y2godmFsaWRhdGVSZWNpcGllbnRVc2VySW5wdXQoeyBjaGFpbklkIH0pKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBSZXNldHMgdGhlIGVudGlyZSBzZW5kIHN0YXRlIHRyZWUgdG8gdGhlIGluaXRpYWwgc3RhdGUuIEl0IGFsc28gZGlzY29ubmVjdHNcbiAqIHBvbGxpbmcgZnJvbSB0aGUgZ2FzIGNvbnRyb2xsZXIgaWYgdGhlIHRva2VuIGlzIHByZXNlbnQgaW4gc3RhdGUuXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRTZW5kU3RhdGUoKSB7XG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGRpc3BhdGNoKGFjdGlvbnMucmVzZXRTZW5kU3RhdGUoKSk7XG5cbiAgICBpZiAoc3RhdGVbbmFtZV0uZ2FzRXN0aW1hdGVQb2xsVG9rZW4pIHtcbiAgICAgIGF3YWl0IGRpc2Nvbm5lY3RHYXNGZWVFc3RpbWF0ZVBvbGxlcihzdGF0ZVtuYW1lXS5nYXNFc3RpbWF0ZVBvbGxUb2tlbik7XG4gICAgICByZW1vdmVQb2xsaW5nVG9rZW5Gcm9tQXBwU3RhdGUoc3RhdGVbbmFtZV0uZ2FzRXN0aW1hdGVQb2xsVG9rZW4pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBTaWducyBhIHRyYW5zYWN0aW9uIG9yIHVwZGF0ZXMgYSB0cmFuc2FjdGlvbiBpbiBzdGF0ZSBpZiBlZGl0aW5nLlxuICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gYSB1c2VyIGNsaWNrcyB0aGUgbmV4dCBidXR0b24gaW4gdGhlIGZvb3RlciBvZlxuICogdGhlIHNlbmQgcGFnZSwgc2lnbmFsaW5nIHRoYXQgYSB0cmFuc2FjdGlvbiBzaG91bGQgYmUgZXhlY3V0ZWQuIFRoaXMgbWV0aG9kXG4gKiB3aWxsIGNyZWF0ZSB0aGUgdHJhbnNhY3Rpb24gaW4gc3RhdGUgKGJ5IHdheSBvZiB0aGUgdmFyaW91cyBnbG9iYWwgcHJvdmlkZXJcbiAqIGNvbnN0cnVjdHMpIHdoaWNoIHdpbGwgZXZlbnR1YWxseSAoYW5kIGZhaXJseSBxdWlja2x5IGZyb20gdXNlciBwZXJzcGVjdGl2ZSlcbiAqIHJlc3VsdCBpbiBhIGNvbmZpcm1hdGlvbiB3aW5kb3cgYmVpbmcgZGlzcGxheWVkIGZvciB0aGUgdHJhbnNhY3Rpb24uXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnblRyYW5zYWN0aW9uKCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoLCBnZXRTdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoKTtcbiAgICBjb25zdCB7IHN0YWdlLCBlaXAxNTU5c3VwcG9ydCB9ID0gc3RhdGVbbmFtZV07XG4gICAgY29uc3QgdHhQYXJhbXMgPSBnZW5lcmF0ZVRyYW5zYWN0aW9uUGFyYW1zKHN0YXRlW25hbWVdKTtcbiAgICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID1cbiAgICAgIHN0YXRlW25hbWVdLmRyYWZ0VHJhbnNhY3Rpb25zW3N0YXRlW25hbWVdLmN1cnJlbnRUcmFuc2FjdGlvblVVSURdO1xuICAgIGlmIChzdGFnZSA9PT0gU0VORF9TVEFHRVMuRURJVCkge1xuICAgICAgLy8gV2hlbiBkZWFsaW5nIHdpdGggdGhlIGVkaXQgZmxvdyB0aGVyZSBpcyBhbHJlYWR5IGEgdHJhbnNhY3Rpb24gaW5cbiAgICAgIC8vIHN0YXRlIHRoYXQgd2UgbXVzdCB1cGRhdGUsIHRoaXMgYnJhbmNoIGlzIHJlc3BvbnNpYmxlIGZvciB0aGF0IGxvZ2ljLlxuICAgICAgLy8gV2UgZmlyc3QgbXVzdCBncmFiIHRoZSBwcmV2aW91cyB0cmFuc2FjdGlvbiBvYmplY3QgZnJvbSBzdGF0ZSBhbmQgdGhlblxuICAgICAgLy8gbWVyZ2UgaW4gdGhlIG1vZGlmaWVkIHR4UGFyYW1zLiBPbmNlIHRoZSB0cmFuc2FjdGlvbiBoYXMgYmVlbiBtb2RpZmllZFxuICAgICAgLy8gd2UgY2FuIHNlbmQgdGhhdCB0byB0aGUgYmFja2dyb3VuZCB0byB1cGRhdGUgdGhlIHRyYW5zYWN0aW9uIGluIHN0YXRlLlxuICAgICAgY29uc3QgdW5hcHByb3ZlZFR4cyA9IGdldFVuYXBwcm92ZWRUeHMoc3RhdGUpO1xuICAgICAgY29uc3QgdW5hcHByb3ZlZFR4ID0gdW5hcHByb3ZlZFR4c1tkcmFmdFRyYW5zYWN0aW9uLmlkXTtcbiAgICAgIC8vIFdlIG9ubHkgdXBkYXRlIHRoZSB0eCBwYXJhbXMgdGhhdCBjYW4gYmUgY2hhbmdlZCB2aWEgdGhlIGVkaXQgZmxvdyBVWFxuICAgICAgY29uc3QgZWlwMTU1OU9ubHlUeFBhcmFtc1RvVXBkYXRlID0ge1xuICAgICAgICBkYXRhOiB0eFBhcmFtcy5kYXRhLFxuICAgICAgICBmcm9tOiB0eFBhcmFtcy5mcm9tLFxuICAgICAgICB0bzogdHhQYXJhbXMudG8sXG4gICAgICAgIHZhbHVlOiB0eFBhcmFtcy52YWx1ZSxcbiAgICAgICAgZ2FzOiB1bmFwcHJvdmVkVHgudXNlckVkaXRlZEdhc0xpbWl0XG4gICAgICAgICAgPyB1bmFwcHJvdmVkVHgudHhQYXJhbXMuZ2FzXG4gICAgICAgICAgOiB0eFBhcmFtcy5nYXMsXG4gICAgICB9O1xuICAgICAgdW5hcHByb3ZlZFR4Lm9yaWdpbmFsR2FzRXN0aW1hdGUgPSBlaXAxNTU5T25seVR4UGFyYW1zVG9VcGRhdGUuZ2FzO1xuICAgICAgY29uc3QgZWRpdGluZ1R4ID0ge1xuICAgICAgICAuLi51bmFwcHJvdmVkVHgsXG4gICAgICAgIHR4UGFyYW1zOiBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIHVuYXBwcm92ZWRUeC50eFBhcmFtcyxcbiAgICAgICAgICBlaXAxNTU5c3VwcG9ydCA/IGVpcDE1NTlPbmx5VHhQYXJhbXNUb1VwZGF0ZSA6IHR4UGFyYW1zLFxuICAgICAgICApLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIGFkZEhpc3RvcnlFbnRyeShcbiAgICAgICAgICBgc2VuZEZsb3cgLSB1c2VyIGNsaWNrZWQgbmV4dCBhbmQgdHJhbnNhY3Rpb24gc2hvdWxkIGJlIHVwZGF0ZWQgaW4gY29udHJvbGxlcmAsXG4gICAgICAgICksXG4gICAgICApO1xuICAgICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICAgIHVwZGF0ZVRyYW5zYWN0aW9uU2VuZEZsb3dIaXN0b3J5KFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uaWQsXG4gICAgICAgICAgdW5hcHByb3ZlZFR4LnNlbmRGbG93SGlzdG9yeT8ubGVuZ3RoIHx8IDAsXG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5oaXN0b3J5LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKFxuICAgICAgICB1cGRhdGVFZGl0YWJsZVBhcmFtcyhkcmFmdFRyYW5zYWN0aW9uLmlkLCBlZGl0aW5nVHgudHhQYXJhbXMpLFxuICAgICAgKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKFxuICAgICAgICB1cGRhdGVUcmFuc2FjdGlvbkdhc0ZlZXMoZHJhZnRUcmFuc2FjdGlvbi5pZCwgZWRpdGluZ1R4LnR4UGFyYW1zKSxcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB0cmFuc2FjdGlvblR5cGUgPVxuICAgICAgICBkcmFmdFRyYW5zYWN0aW9uLnJlY2lwaWVudC50eXBlID09PSBSRUNJUElFTlRfVFlQRVMuU01BUlRfQ09OVFJBQ1RcbiAgICAgICAgICA/IFRSQU5TQUNUSU9OX1RZUEVTLkNPTlRSQUNUX0lOVEVSQUNUSU9OXG4gICAgICAgICAgOiBUUkFOU0FDVElPTl9UWVBFUy5TSU1QTEVfU0VORDtcblxuICAgICAgaWYgKGRyYWZ0VHJhbnNhY3Rpb24uYXNzZXQudHlwZSAhPT0gQVNTRVRfVFlQRVMuTkFUSVZFKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uVHlwZSA9XG4gICAgICAgICAgZHJhZnRUcmFuc2FjdGlvbi5hc3NldC50eXBlID09PSBBU1NFVF9UWVBFUy5DT0xMRUNUSUJMRVxuICAgICAgICAgICAgPyBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTVxuICAgICAgICAgICAgOiBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVI7XG4gICAgICB9XG4gICAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgICAgYWRkSGlzdG9yeUVudHJ5KFxuICAgICAgICAgIGBzZW5kRmxvdyAtIHVzZXIgY2xpY2tlZCBuZXh0IGFuZCB0cmFuc2FjdGlvbiBzaG91bGQgYmUgYWRkZWQgdG8gY29udHJvbGxlcmAsXG4gICAgICAgICksXG4gICAgICApO1xuXG4gICAgICBkaXNwYXRjaChcbiAgICAgICAgYWRkVW5hcHByb3ZlZFRyYW5zYWN0aW9uQW5kUm91dGVUb0NvbmZpcm1hdGlvblBhZ2UoXG4gICAgICAgICAgdHhQYXJhbXMsXG4gICAgICAgICAgdHJhbnNhY3Rpb25UeXBlLFxuICAgICAgICAgIGRyYWZ0VHJhbnNhY3Rpb24uaGlzdG9yeSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFRvZ2dsZXMgdGhlIGFtb3VudC5tb2RlIGJldHdlZW4gSU5QVVQgYW5kIE1BWCBtb2Rlcy5cbiAqIEFzIGEgcmVzdWx0LCB0aGUgYW1vdW50LnZhbHVlIHdpbGwgY2hhbmdlIHRvIGVpdGhlciAnMHgwJyB3aGVuIG1vdmluZyBmcm9tXG4gKiBNQVggdG8gSU5QVVQsIG9yIHRvIHRoZSBtYXhpbXVtIGFsbG93YWJsZSBhbW91bnQgYmFzZWQgb24gY3VycmVudCBhc3NldCB3aGVuXG4gKiBtb3ZpbmcgZnJvbSBJTlBVVCB0byBNQVguXG4gKlxuICogQHJldHVybnMge1RodW5rQWN0aW9uPHZvaWQ+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9nZ2xlU2VuZE1heE1vZGUoKSB7XG4gIHJldHVybiBhc3luYyAoZGlzcGF0Y2gsIGdldFN0YXRlKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBnZXRTdGF0ZSgpO1xuICAgIGlmIChzdGF0ZVtuYW1lXS5hbW91bnRNb2RlID09PSBBTU9VTlRfTU9ERVMuTUFYKSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZUFtb3VudE1vZGUoQU1PVU5UX01PREVTLklOUFVUKSk7XG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZVNlbmRBbW91bnQoJzB4MCcpKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGFkZEhpc3RvcnlFbnRyeShgc2VuZEZsb3cgLSB1c2VyIHRvZ2dsZWQgbWF4IG1vZGUgb2ZmYCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhd2FpdCBkaXNwYXRjaChhY3Rpb25zLnVwZGF0ZUFtb3VudE1vZGUoQU1PVU5UX01PREVTLk1BWCkpO1xuICAgICAgYXdhaXQgZGlzcGF0Y2goYWN0aW9ucy51cGRhdGVBbW91bnRUb01heCgpKTtcbiAgICAgIGF3YWl0IGRpc3BhdGNoKGFkZEhpc3RvcnlFbnRyeShgc2VuZEZsb3cgLSB1c2VyIHRvZ2dsZWQgbWF4IG1vZGUgb25gKSk7XG4gICAgfVxuICAgIGF3YWl0IGRpc3BhdGNoKGNvbXB1dGVFc3RpbWF0ZWRHYXNMaW1pdCgpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBCZWdpbnMgYSBuZXcgZHJhZnQgdHJhbnNhY3Rpb24sIGNsZWFyaW5nIG91dCB0aGUgcHJldmlvdXMgZHJhZnQgdHJhbnNhY3Rpb25zXG4gKiBmcm9tIHN0YXRlLCBhbmQgY2xlYXJpbmcgdGhlIGN1cnJlbnRUcmFuc2FjdGlvblVVSUQuIFRoaXMgYWN0aW9uIGlzIG9uZSBvZlxuICogdGhlIHR3byBlbnRyeSBwb2ludHMgaW50byB0aGUgc2VuZCBmbG93LiBOT1RFOiBZb3UgbXVzdCByb3V0ZSB0byB0aGUgc2VuZFxuICogcGFnZSAqYWZ0ZXIqIGRpc3BhdGNoaW5nIHRoaXMgYWN0aW9uIHJlc29sdmVzIHRvIGVuc3VyZSB0aGF0IHRoZVxuICogZHJhZnRUcmFuc2FjdGlvbiBpcyBwcm9wZXJseSBjcmVhdGVkLlxuICpcbiAqIEBwYXJhbSB7UGljazxBc3NldCwgJ3R5cGUnIHwgJ2RldGFpbHMnPn0gYXNzZXQgLSBBIHBhcnRpYWwgYXNzZXRcbiAqICBvYmplY3QgY29udGFpbmluZyBhdCBsZWFzdCB0aGUgYXNzZXQgdHlwZS4gSWYgc3BlY2lmeWluZyBhIG5vbi1uYXRpdmUgYXNzZXRcbiAqICB0aGVuIHRoZSBhc3NldCBkZXRhaWxzIG11c3QgYmUgaW5jbHVkZWQgd2l0aCBhdCBsZWFzdCB0aGUgYWRkcmVzcy5cbiAqIEByZXR1cm5zIHtUaHVua0FjdGlvbjx2b2lkPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0TmV3RHJhZnRUcmFuc2FjdGlvbihhc3NldCkge1xuICByZXR1cm4gYXN5bmMgKGRpc3BhdGNoKSA9PiB7XG4gICAgYXdhaXQgZGlzcGF0Y2goYWN0aW9ucy5jbGVhclByZXZpb3VzRHJhZnRzKCkpO1xuXG4gICAgYXdhaXQgZGlzcGF0Y2goXG4gICAgICBhY3Rpb25zLmFkZE5ld0RyYWZ0KHtcbiAgICAgICAgLi4uZHJhZnRUcmFuc2FjdGlvbkluaXRpYWxTdGF0ZSxcbiAgICAgICAgaGlzdG9yeTogW2BzZW5kRmxvdyAtIFVzZXIgc3RhcnRlZCBuZXcgZHJhZnQgdHJhbnNhY3Rpb25gXSxcbiAgICAgIH0pLFxuICAgICk7XG5cbiAgICBhd2FpdCBkaXNwYXRjaChcbiAgICAgIHVwZGF0ZVNlbmRBc3NldCh7XG4gICAgICAgIHR5cGU6IGFzc2V0LnR5cGUgPz8gQVNTRVRfVFlQRVMuTkFUSVZFLFxuICAgICAgICBkZXRhaWxzOiBhc3NldC5kZXRhaWxzLFxuICAgICAgfSksXG4gICAgKTtcblxuICAgIGF3YWl0IGRpc3BhdGNoKGluaXRpYWxpemVTZW5kU3RhdGUoKSk7XG4gIH07XG59XG5cbi8vIFNlbGVjdG9yc1xuLyoqXG4gKiBUaGUgZm9sbG93aW5nIHR5cGVkZWYgaXMgYSBzaG9ydGN1dCBmb3IgdHlwaW5nIHNlbGVjdG9ycyBiZWxvdy4gSXQgdXNlcyBhXG4gKiBnZW5lcmljIHR5cGUsIFQsIHNvIHRoYXQgZWFjaCBzZWxlY3RvciBjYW4gc3BlY2lmeSBpdCdzIHJldHVybiB0eXBlLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAdHlwZWRlZiB7KHN0YXRlOiBNZXRhTWFza1N0YXRlKSA9PiBUfSBTZWxlY3RvclxuICovXG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgVVVJRC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2FjdGlvblVVSUQoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLmN1cnJlbnRUcmFuc2FjdGlvblVVSUQ7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uLlxuICpcbiAqIEB0eXBlIHtTZWxlY3RvcjxEcmFmdFRyYW5zYWN0aW9uPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZVtuYW1lXS5kcmFmdFRyYW5zYWN0aW9uc1tnZXRDdXJyZW50VHJhbnNhY3Rpb25VVUlEKHN0YXRlKV0gPz8ge307XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgYSBkcmFmdCB0cmFuc2FjdGlvbiBleGlzdHMuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPGJvb2xlYW4+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHJhZnRUcmFuc2FjdGlvbkV4aXN0cyhzdGF0ZSkge1xuICBjb25zdCBkcmFmdFRyYW5zYWN0aW9uID0gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpO1xuICBpZiAoT2JqZWN0LmtleXMoZHJhZnRUcmFuc2FjdGlvbikubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBHYXMgc2VsZWN0b3JzXG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgZ2FzTGltaXQuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPD9zdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0R2FzTGltaXQoc3RhdGUpIHtcbiAgcmV0dXJuIGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5nYXM/Lmdhc0xpbWl0O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBkcmFmdCB0cmFuc2FjdGlvbidzIGdhc1ByaWNlLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdhc1ByaWNlKHN0YXRlKSB7XG4gIHJldHVybiBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5nYXNQcmljZTtcbn1cblxuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24ncyBnYXNUb3RhbC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHYXNUb3RhbChzdGF0ZSkge1xuICByZXR1cm4gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLmdhcz8uZ2FzVG90YWw7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBlcnJvciwgaWYgcHJlc2VudCwgZm9yIHRoZSBnYXMgZmllbGRzLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdhc0ZlZUlzSW5FcnJvcihzdGF0ZSkge1xuICByZXR1cm4gQm9vbGVhbihnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5lcnJvcik7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBtaW5pbXVtIGdhc0xpbWl0IGZvciB0aGUgY3VycmVudCBuZXR3b3JrLlxuICpcbiAqIEB0eXBlIHtTZWxlY3RvcjxzdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWluaW11bUdhc0xpbWl0Rm9yU2VuZChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGVbbmFtZV0uZ2FzTGltaXRNaW5pbXVtO1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBkcmFmdCB0cmFuc2FjdGlvbidzIGdhc0xpbWl0LlxuICpcbiAqIEB0eXBlIHtTZWxlY3RvcjxNYXBWYWx1ZXNUb1VuaW9uPFNlbmRTdGF0ZUdhc01vZGVzPj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRHYXNJbnB1dE1vZGUoc3RhdGUpIHtcbiAgY29uc3QgaXNNYWlubmV0ID0gZ2V0SXNNYWlubmV0KHN0YXRlKTtcbiAgY29uc3QgZ2FzRXN0aW1hdGVUeXBlID0gZ2V0R2FzRXN0aW1hdGVUeXBlKHN0YXRlKTtcbiAgY29uc3Qgc2hvd0FkdmFuY2VkR2FzRmllbGRzID0gZ2V0QWR2YW5jZWRJbmxpbmVHYXNTaG93bihzdGF0ZSk7XG4gIGlmIChzdGF0ZVtuYW1lXS5nYXNJc1NldEluTW9kYWwpIHtcbiAgICByZXR1cm4gR0FTX0lOUFVUX01PREVTLkNVU1RPTTtcbiAgfVxuICBpZiAoKCFpc01haW5uZXQgJiYgIXByb2Nlc3MuZW52LklOX1RFU1QpIHx8IHNob3dBZHZhbmNlZEdhc0ZpZWxkcykge1xuICAgIHJldHVybiBHQVNfSU5QVVRfTU9ERVMuSU5MSU5FO1xuICB9XG5cbiAgLy8gV2UgZ2V0IGV0aF9nYXNQcmljZSBlc3RpbWF0aW9uIGlmIHRoZSBsZWdhY3kgQVBJIGZhaWxzIGJ1dCB3ZSBuZWVkIHRvXG4gIC8vIGluc3RydWN0IHRoZSBVSSB0byByZW5kZXIgdGhlIElOTElORSBpbnB1dHMgaW4gdGhpcyBjYXNlLCBvbmx5IG9uXG4gIC8vIG1haW5uZXQgb3IgSU5fVEVTVC5cbiAgaWYgKFxuICAgIChpc01haW5uZXQgfHwgcHJvY2Vzcy5lbnYuSU5fVEVTVCkgJiZcbiAgICBnYXNFc3RpbWF0ZVR5cGUgPT09IEdBU19FU1RJTUFURV9UWVBFUy5FVEhfR0FTUFJJQ0VcbiAgKSB7XG4gICAgcmV0dXJuIEdBU19JTlBVVF9NT0RFUy5JTkxJTkU7XG4gIH1cbiAgcmV0dXJuIEdBU19JTlBVVF9NT0RFUy5CQVNJQztcbn1cblxuLy8gQXNzZXQgU2VsZWN0b3JzXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgYXNzZXQgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24gaXMgc2VuZGluZy5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P0Fzc2V0Pn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbmRBc3NldChzdGF0ZSkge1xuICByZXR1cm4gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLmFzc2V0O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgbm9uLW5hdGl2ZSBhc3NldCB0aGF0XG4gKiB0aGUgY3VycmVudCB0cmFuc2FjdGlvbiBpcyBzZW5kaW5nLCBpZiBpdCBleGlzdHMuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPD9zdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2VuZEFzc2V0QWRkcmVzcyhzdGF0ZSkge1xuICByZXR1cm4gZ2V0U2VuZEFzc2V0KHN0YXRlKT8uZGV0YWlscz8uYWRkcmVzcztcbn1cblxuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgYSBib29sZWFuIHZhbHVlIGRlc2NyaWJpbmcgd2hldGhlciB0aGUgY3VycmVudGx5XG4gKiBzZWxlY3RlZCBhc3NldCBpcyBzZW5kYWJsZSwgYmFzZWQgdXBvbiB0aGUgc3RhbmRhcmQgb2YgdGhlIHRva2VuLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElzQXNzZXRTZW5kYWJsZShzdGF0ZSkge1xuICBpZiAoZ2V0U2VuZEFzc2V0KHN0YXRlKT8udHlwZSA9PT0gQVNTRVRfVFlQRVMuTkFUSVZFKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGdldFNlbmRBc3NldChzdGF0ZSk/LmRldGFpbHM/LmlzRVJDNzIxID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgdGhlIGFzc2V0IGVycm9yIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NldEVycm9yKHN0YXRlKSB7XG4gIHJldHVybiBnZXRTZW5kQXNzZXQoc3RhdGUpLmVycm9yO1xufVxuXG4vLyBBbW91bnQgU2VsZWN0b3JzXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgYW1vdW50IHRoYXQgY3VycmVudCBkcmFmdCB0cmFuc2FjdGlvbiBpcyBzZW5kaW5nLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbmRBbW91bnQoc3RhdGUpIHtcbiAgcmV0dXJuIGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5hbW91bnQ/LnZhbHVlO1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSB1c2VyIGhhcyBlbm91Z2ggbmF0aXZlIGFzc2V0IGJhbGFuY2UgdG9cbiAqIGNvdmVyIHRoZSBjb3N0IG9mIHRoZSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc0JhbGFuY2VJbnN1ZmZpY2llbnQoc3RhdGUpIHtcbiAgcmV0dXJuIChcbiAgICBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5lcnJvciA9PT0gSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SXG4gICk7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBhbW91bmcgc2VuZCBtb2RlLCBlaXRoZXIgTUFYIG9yIElOUFVULlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNlbmRNYXhNb2RlU3RhdGUoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLmFtb3VudE1vZGUgPT09IEFNT1VOVF9NT0RFUy5NQVg7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgZGF0YSBmaWVsZC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kSGV4RGF0YShzdGF0ZSkge1xuICByZXR1cm4gZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLnVzZXJJbnB1dEhleERhdGE7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3MgaWQsIGlmIHByZXNlbnQuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPD9zdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RHJhZnRUcmFuc2FjdGlvbklEKHN0YXRlKSB7XG4gIHJldHVybiBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuaWQ7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgaXMgYW4gZXJyb3Igb24gdGhlIGFtb3VudCBmaWVsZC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZW5kQW1vdW50SXNJbkVycm9yKHN0YXRlKSB7XG4gIHJldHVybiBCb29sZWFuKGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5hbW91bnQ/LmVycm9yKTtcbn1cblxuLy8gUmVjaXBpZW50IFNlbGVjdG9yc1xuLyoqXG4gKiBTZWxlY3RvciB0aGF0IHJldHVybnMgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24ncyByZWNpcGllbnQuXG4gKlxuICogQHR5cGUge1NlbGVjdG9yPERyYWZ0VHJhbnNhY3Rpb25bJ3JlY2lwaWVudCddPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY2lwaWVudChzdGF0ZSkge1xuICBjb25zdCBkcmFmdCA9IGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKTtcbiAgaWYgKCFkcmFmdC5yZWNpcGllbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogJycsXG4gICAgICBuaWNrbmFtZTogJycsXG4gICAgICBlcnJvcjogbnVsbCxcbiAgICAgIHdhcm5pbmc6IG51bGwsXG4gICAgfTtcbiAgfVxuICBjb25zdCBjaGVja3N1bW1lZEFkZHJlc3MgPSB0b0NoZWNrc3VtSGV4QWRkcmVzcyhkcmFmdC5yZWNpcGllbnQuYWRkcmVzcyk7XG4gIGlmIChzdGF0ZS5tZXRhbWFzay5lbnNSZXNvbHV0aW9uc0J5QWRkcmVzcykge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5kcmFmdC5yZWNpcGllbnQsXG4gICAgICBuaWNrbmFtZTpcbiAgICAgICAgZHJhZnQucmVjaXBpZW50Lm5pY2tuYW1lIHx8XG4gICAgICAgIGdldEVuc1Jlc29sdXRpb25CeUFkZHJlc3Moc3RhdGUsIGNoZWNrc3VtbWVkQWRkcmVzcyksXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZHJhZnQucmVjaXBpZW50O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgYWRkcmVzIG9mIHRoZSBjdXJyZW50IGRyYWZ0IHRyYW5zYWN0aW9uJ3NcbiAqIHJlY2lwaWVudC5cbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8P3N0cmluZz59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kVG8oc3RhdGUpIHtcbiAgcmV0dXJuIGdldFJlY2lwaWVudChzdGF0ZSk/LmFkZHJlc3M7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcmVjaXBpZW50TW9kZSBpcyBNWV9BQ0NPVU5UU1xuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElzVXNpbmdNeUFjY291bnRGb3JSZWNpcGllbnRTZWFyY2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLnJlY2lwaWVudE1vZGUgPT09IFJFQ0lQSUVOVF9TRUFSQ0hfTU9ERVMuTVlfQUNDT1VOVFM7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSB0aGF0IHRoZSB1c2VyIGhhcyB0eXBlZCBpbnRvIHRoZSByZWNpcGllbnRcbiAqIGlucHV0IGZpZWxkLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjw/c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlY2lwaWVudFVzZXJJbnB1dChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGVbbmFtZV0ucmVjaXBpZW50SW5wdXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSZWNpcGllbnRXYXJuaW5nQWNrbm93bGVkZ2VtZW50KHN0YXRlKSB7XG4gIHJldHVybiAoXG4gICAgZ2V0Q3VycmVudERyYWZ0VHJhbnNhY3Rpb24oc3RhdGUpLnJlY2lwaWVudD8ucmVjaXBpZW50V2FybmluZ0Fja25vd2xlZGdlZCA/P1xuICAgIGZhbHNlXG4gICk7XG59XG5cbi8vIE92ZXJhbGwgdmFsaWRpdHkgYW5kIHN0YWdlIHNlbGVjdG9yc1xuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgZ2FzRmVlIGFuZCBhbW91bnQgZXJyb3JzLCBpZiB0aGV5IGV4aXN0LlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjx7IGdhc0ZlZT86IHN0cmluZywgYW1vdW50Pzogc3RyaW5nfT59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kRXJyb3JzKHN0YXRlKSB7XG4gIHJldHVybiB7XG4gICAgZ2FzRmVlOiBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSkuZ2FzPy5lcnJvcixcbiAgICBhbW91bnQ6IGdldEN1cnJlbnREcmFmdFRyYW5zYWN0aW9uKHN0YXRlKS5hbW91bnQ/LmVycm9yLFxuICB9O1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZSBzdGFnZSBpcyBhbnl0aGluZyBleGNlcHQgSU5BQ1RJVkVcbiAqXG4gKiBAdHlwZSB7U2VsZWN0b3I8Ym9vbGVhbj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1NlbmRTdGF0ZUluaXRpYWxpemVkKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZVtuYW1lXS5zdGFnZSAhPT0gU0VORF9TVEFHRVMuSU5BQ1RJVkU7XG59XG5cbi8qKlxuICogU2VsZWN0b3IgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgZHJhZnQgdHJhbnNhY3Rpb24gaXMgdmFsaWQgYW5kIGluXG4gKiBhIHNlbmRhYmxlIHN0YXRlLlxuICpcbiAqIEB0eXBlIHtTZWxlY3Rvcjxib29sZWFuPn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2VuZEZvcm1JbnZhbGlkKHN0YXRlKSB7XG4gIGNvbnN0IGRyYWZ0VHJhbnNhY3Rpb24gPSBnZXRDdXJyZW50RHJhZnRUcmFuc2FjdGlvbihzdGF0ZSk7XG4gIGlmICghZHJhZnRUcmFuc2FjdGlvbikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBkcmFmdFRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gU0VORF9TVEFUVVNFUy5JTlZBTElEO1xufVxuXG4vKipcbiAqIFNlbGVjdG9yIHRoYXQgcmV0dXJucyB0aGUgY3VycmVudCBzdGFnZSBvZiB0aGUgc2VuZCBmbG93XG4gKlxuICogQHR5cGUge1NlbGVjdG9yPE1hcFZhbHVlc1RvVW5pb248U2VuZFN0YXRlU3RhZ2VzPj59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW5kU3RhZ2Uoc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlW25hbWVdLnN0YWdlO1xufVxuIiwiZXhwb3J0IGNvbnN0IEVUSCA9ICdFVEgnO1xuZXhwb3J0IGNvbnN0IEdXRUkgPSAnR1dFSSc7XG5leHBvcnQgY29uc3QgV0VJID0gJ1dFSSc7XG5cbmV4cG9ydCBjb25zdCBQUklNQVJZID0gJ1BSSU1BUlknO1xuZXhwb3J0IGNvbnN0IFNFQ09OREFSWSA9ICdTRUNPTkRBUlknO1xuXG5leHBvcnQgY29uc3QgR0FTX0VTVElNQVRFX1RZUEVTID0ge1xuICBTTE9XOiAnU0xPVycsXG4gIEFWRVJBR0U6ICdBVkVSQUdFJyxcbiAgRkFTVDogJ0ZBU1QnLFxuICBGQVNURVNUOiAnRkFTVEVTVCcsXG59O1xuXG5sZXQgX3N1cHBvcnRSZXF1ZXN0TGluayA9ICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzJztcbmNvbnN0IF9jb250cmFjdEFkZHJlc3NMaW5rID1cbiAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDIwMDI4MDkyLVdoYXQtaXMtdGhlLWtub3duLWNvbnRyYWN0LWFkZHJlc3Mtd2FybmluZy0nO1xuXG5cbmV4cG9ydCBjb25zdCBTVVBQT1JUX1JFUVVFU1RfTElOSyA9IF9zdXBwb3J0UmVxdWVzdExpbms7XG5leHBvcnQgY29uc3QgQ09OVFJBQ1RfQUREUkVTU19MSU5LID0gX2NvbnRyYWN0QWRkcmVzc0xpbms7XG4iLCIvKipcbiAqIEEgbm90ZSBhYm91dCB0aGUgZXhpc3RlbmNlIG9mIGJvdGggc2luZ3VsYXIgYW5kIHBsdXJhbCB2YXJpYWJsZSBuYW1lcyBoZXJlOlxuICogV2hlbiBkZWFsaW5nIHdpdGggYSBsaXRlcmFsIHByb3BlcnR5IG5hbWUsIGUuZy4gQUxJR05fSVRFTVMsIHRoZSBjb25zdGFudFxuICogc2hvdWxkIG1hdGNoIHRoZSBwcm9wZXJ0eS4gV2hlbiBkZXRhaWxpbmcgYSBjb2xsZWN0aW9uIG9mIHRoaW5ncywgaXQgc2hvdWxkXG4gKiBtYXRjaCB0aGUgcGx1cmFsIGZvcm0gb2YgdGhlIHRoaW5nLiBlLmcuIENPTE9SUywgVFlQT0dSQVBIWVxuICovXG5cbmltcG9ydCB7IHBpY2sgfSBmcm9tICdsb2Rhc2gnO1xuXG5leHBvcnQgY29uc3QgQ09MT1JTID0ge1xuICBCQUNLR1JPVU5EX0RFRkFVTFQ6ICdiYWNrZ3JvdW5kLWRlZmF1bHQnLFxuICBCQUNLR1JPVU5EX0FMVEVSTkFUSVZFOiAnYmFja2dyb3VuZC1hbHRlcm5hdGl2ZScsXG4gIFRFWFRfREVGQVVMVDogJ3RleHQtZGVmYXVsdCcsXG4gIFRFWFRfQUxURVJOQVRJVkU6ICd0ZXh0LWFsdGVybmF0aXZlJyxcbiAgVEVYVF9NVVRFRDogJ3RleHQtbXV0ZWQnLFxuICBJQ09OX0RFRkFVTFQ6ICdpY29uLWRlZmF1bHQnLFxuICBJQ09OX0FMVEVSTkFUSVZFOiAnaWNvbi1hbHRlcm5hdGl2ZScsXG4gIElDT05fTVVURUQ6ICdpY29uLW11dGVkJyxcbiAgQk9SREVSX0RFRkFVTFQ6ICdib3JkZXItZGVmYXVsdCcsXG4gIEJPUkRFUl9NVVRFRDogJ2JvcmRlci1tdXRlZCcsXG4gIE9WRVJMQVlfREVGQVVMVDogJ292ZXJsYXktZGVmYXVsdCcsXG4gIE9WRVJMQVlfSU5WRVJTRTogJ292ZXJsYXktaW52ZXJzZScsXG4gIFBSSU1BUllfREVGQVVMVDogJ3ByaW1hcnktZGVmYXVsdCcsXG4gIFBSSU1BUllfQUxURVJOQVRJVkU6ICdwcmltYXJ5LWFsdGVybmF0aXZlJyxcbiAgUFJJTUFSWV9NVVRFRDogJ3ByaW1hcnktbXV0ZWQnLFxuICBQUklNQVJZX0lOVkVSU0U6ICdwcmltYXJ5LWludmVyc2UnLFxuICBQUklNQVJZX0RJU0FCTEVEOiAncHJpbWFyeS1kaXNhYmxlZCcsXG4gIEVSUk9SX0RFRkFVTFQ6ICdlcnJvci1kZWZhdWx0JyxcbiAgRVJST1JfQUxURVJOQVRJVkU6ICdlcnJvci1hbHRlcm5hdGl2ZScsXG4gIEVSUk9SX01VVEVEOiAnZXJyb3ItbXV0ZWQnLFxuICBFUlJPUl9JTlZFUlNFOiAnZXJyb3ItaW52ZXJzZScsXG4gIEVSUk9SX0RJU0FCTEVEOiAnZXJyb3ItZGlzYWJsZWQnLFxuICBXQVJOSU5HX0RFRkFVTFQ6ICd3YXJuaW5nLWRlZmF1bHQnLFxuICBXQVJOSU5HX0FMVEVSTkFUSVZFOiAnd2FybmluZy1hbHRlcm5hdGl2ZScsXG4gIFdBUk5JTkdfTVVURUQ6ICd3YXJuaW5nLW11dGVkJyxcbiAgV0FSTklOR19JTlZFUlNFOiAnd2FybmluZy1pbnZlcnNlJyxcbiAgV0FSTklOR19ESVNBQkxFRDogJ3dhcm5pbmctZGlzYWJsZWQnLFxuICBTVUNDRVNTX0RFRkFVTFQ6ICdzdWNjZXNzLWRlZmF1bHQnLFxuICBTVUNDRVNTX0FMVEVSTkFUSVZFOiAnc3VjY2Vzcy1hbHRlcm5hdGl2ZScsXG4gIFNVQ0NFU1NfTVVURUQ6ICdzdWNjZXNzLW11dGVkJyxcbiAgU1VDQ0VTU19JTlZFUlNFOiAnc3VjY2Vzcy1pbnZlcnNlJyxcbiAgU1VDQ0VTU19ESVNBQkxFRDogJ3N1Y2Nlc3MtZGlzYWJsZWQnLFxuICBJTkZPX0RFRkFVTFQ6ICdpbmZvLWRlZmF1bHQnLFxuICBJTkZPX0FMVEVSTkFUSVZFOiAnaW5mby1hbHRlcm5hdGl2ZScsXG4gIElORk9fTVVURUQ6ICdpbmZvLW11dGVkJyxcbiAgSU5GT19JTlZFUlNFOiAnaW5mby1pbnZlcnNlJyxcbiAgSU5GT19ESVNBQkxFRDogJ2luZm8tZGlzYWJsZWQnLFxuICBNQUlOTkVUOiAnbWFpbm5ldCcsXG4gIEdPRVJMSTogJ2dvZXJsaScsXG4gIFNFUE9MSUE6ICdzZXBvbGlhJyxcbiAgTE9DQUxIT1NUOiAnbG9jYWxob3N0JyxcbiAgVFJBTlNQQVJFTlQ6ICd0cmFuc3BhcmVudCcsXG4gIElOSEVSSVQ6ICdpbmhlcml0Jyxcbn07XG5leHBvcnQgY29uc3QgQkFDS0dST1VORF9DT0xPUlMgPSBwaWNrKENPTE9SUywgW1xuICAnQkFDS0dST1VORF9ERUZBVUxUJyxcbiAgJ0JBQ0tHUk9VTkRfQUxURVJOQVRJVkUnLFxuICAnT1ZFUkxBWV9ERUZBVUxUJyxcbiAgJ1BSSU1BUllfREVGQVVMVCcsXG4gICdQUklNQVJZX0FMVEVSTkFUSVZFJyxcbiAgJ1BSSU1BUllfTVVURUQnLFxuICAnRVJST1JfREVGQVVMVCcsXG4gICdFUlJPUl9BTFRFUk5BVElWRScsXG4gICdFUlJPUl9NVVRFRCcsXG4gICdXQVJOSU5HX0RFRkFVTFQnLFxuICAnV0FSTklOR19BTFRFUk5BVElWRScsXG4gICdXQVJOSU5HX01VVEVEJyxcbiAgJ1NVQ0NFU1NfREVGQVVMVCcsXG4gICdTVUNDRVNTX0FMVEVSTkFUSVZFJyxcbiAgJ1NVQ0NFU1NfTVVURUQnLFxuICAnSU5GT19ERUZBVUxUJyxcbiAgJ0lORk9fQUxURVJOQVRJVkUnLFxuICAnSU5GT19NVVRFRCcsXG4gICdNQUlOTkVUJyxcbiAgJ0dPRVJMSScsXG4gICdTRVBPTElBJyxcbiAgJ1RSQU5TUEFSRU5UJyxcbiAgJ0xPQ0FMSE9TVCcsXG5dKTtcblxuZXhwb3J0IGNvbnN0IEJPUkRFUl9DT0xPUlMgPSBwaWNrKENPTE9SUywgW1xuICAnQk9SREVSX0RFRkFVTFQnLFxuICAnQk9SREVSX01VVEVEJyxcbiAgJ1BSSU1BUllfREVGQVVMVCcsXG4gICdQUklNQVJZX0FMVEVSTkFUSVZFJyxcbiAgJ1BSSU1BUllfTVVURUQnLFxuICAnRVJST1JfREVGQVVMVCcsXG4gICdFUlJPUl9BTFRFUk5BVElWRScsXG4gICdFUlJPUl9NVVRFRCcsXG4gICdXQVJOSU5HX0RFRkFVTFQnLFxuICAnV0FSTklOR19BTFRFUk5BVElWRScsXG4gICdXQVJOSU5HX01VVEVEJyxcbiAgJ1NVQ0NFU1NfREVGQVVMVCcsXG4gICdTVUNDRVNTX0FMVEVSTkFUSVZFJyxcbiAgJ1NVQ0NFU1NfTVVURUQnLFxuICAnSU5GT19ERUZBVUxUJyxcbiAgJ0lORk9fQUxURVJOQVRJVkUnLFxuICAnSU5GT19NVVRFRCcsXG4gICdNQUlOTkVUJyxcbiAgJ0dPRVJMSScsXG4gICdTRVBPTElBJyxcbiAgJ1RSQU5TUEFSRU5UJyxcbiAgJ0xPQ0FMSE9TVCcsXG5dKTtcblxuZXhwb3J0IGNvbnN0IFRFWFRfQ09MT1JTID0gcGljayhDT0xPUlMsIFtcbiAgJ1RFWFRfREVGQVVMVCcsXG4gICdURVhUX0FMVEVSTkFUSVZFJyxcbiAgJ1RFWFRfTVVURUQnLFxuICAnT1ZFUkxBWV9JTlZFUlNFJyxcbiAgJ1BSSU1BUllfREVGQVVMVCcsXG4gICdQUklNQVJZX0lOVkVSU0UnLFxuICAnRVJST1JfREVGQVVMVCcsXG4gICdFUlJPUl9JTlZFUlNFJyxcbiAgJ1NVQ0NFU1NfREVGQVVMVCcsXG4gICdTVUNDRVNTX0lOVkVSU0UnLFxuICAnV0FSTklOR19ERUZBVUxUJyxcbiAgJ1dBUk5JTkdfSU5WRVJTRScsXG4gICdJTkZPX0RFRkFVTFQnLFxuICAnSU5GT19JTlZFUlNFJyxcbiAgJ0lOSEVSSVQnLFxuXSk7XG5cbmV4cG9ydCBjb25zdCBJQ09OX0NPTE9SUyA9IHBpY2soQ09MT1JTLCBbXG4gICdJQ09OX0RFRkFVTFQnLFxuICAnSUNPTl9BTFRFUk5BVElWRScsXG4gICdJQ09OX01VVEVEJyxcbiAgJ09WRVJMQVlfSU5WRVJTRScsXG4gICdQUklNQVJZX0RFRkFVTFQnLFxuICAnUFJJTUFSWV9JTlZFUlNFJyxcbiAgJ0VSUk9SX0RFRkFVTFQnLFxuICAnRVJST1JfSU5WRVJTRScsXG4gICdTVUNDRVNTX0RFRkFVTFQnLFxuICAnU1VDQ0VTU19JTlZFUlNFJyxcbiAgJ1dBUk5JTkdfREVGQVVMVCcsXG4gICdXQVJOSU5HX0lOVkVSU0UnLFxuICAnSU5GT19ERUZBVUxUJyxcbiAgJ0lORk9fSU5WRVJTRScsXG4gICdJTkhFUklUJyxcbl0pO1xuXG5leHBvcnQgY29uc3QgVFlQT0dSQVBIWSA9IHtcbiAgSDE6ICdoMScsXG4gIEgyOiAnaDInLFxuICBIMzogJ2gzJyxcbiAgSDQ6ICdoNCcsXG4gIEg1OiAnaDUnLFxuICBINjogJ2g2JyxcbiAgSDc6ICdoNycsXG4gIEg4OiAnaDgnLFxuICBIOTogJ2g5JyxcbiAgUGFyYWdyYXBoOiAncCcsXG59O1xuXG5leHBvcnQgY29uc3QgVEVYVCA9IHtcbiAgRElTUExBWV9NRDogJ2Rpc3BsYXktbWQnLFxuICBIRUFESU5HX0xHOiAnaGVhZGluZy1sZycsXG4gIEhFQURJTkdfTUQ6ICdoZWFkaW5nLW1kJyxcbiAgSEVBRElOR19TTTogJ2hlYWRpbmctc20nLFxuICBCT0RZX0xHOiAnYm9keS1sZy1tZWRpdW0nLFxuICBCT0RZX01EOiAnYm9keS1tZCcsXG4gIEJPRFlfU006ICdib2R5LXNtJyxcbiAgQk9EWV9YUzogJ2JvZHkteHMnLFxuICBJTkhFUklUOiAnaW5oZXJpdCcsXG59O1xuXG5jb25zdCBOT05FID0gJ25vbmUnO1xuXG5leHBvcnQgY29uc3QgU0laRVMgPSB7XG4gIFhYUzogJ3h4cycsXG4gIFhTOiAneHMnLFxuICBTTTogJ3NtJyxcbiAgTUQ6ICdtZCcsXG4gIExHOiAnbGcnLFxuICBYTDogJ3hsJyxcbiAgQVVUTzogJ2F1dG8nLCAvLyBVc2VkIGZvciBUZXh0LCBJY29uLCBhbmQgQnV0dG9uIGNvbXBvbmVudHMgdG8gaW5oZXJpdCB0aGUgcGFyZW50IGVsZW1lbnRzIGZvbnQtc2l6ZVxuICBOT05FLFxufTtcblxuZXhwb3J0IGNvbnN0IEJPUkRFUl9TVFlMRSA9IHtcbiAgREFTSEVEOiAnZGFzaGVkJyxcbiAgU09MSUQ6ICdzb2xpZCcsXG4gIERPVFRFRDogJ2RvdHRlZCcsXG4gIERPVUJMRTogJ2RvdWJsZScsXG4gIE5PTkUsXG59O1xuXG5leHBvcnQgY29uc3QgQk9SREVSX1JBRElVUyA9IHtcbiAgWFM6IFNJWkVTLlhTLFxuICBTTTogU0laRVMuU00sXG4gIE1EOiBTSVpFUy5NRCxcbiAgTEc6IFNJWkVTLkxHLFxuICBYTDogU0laRVMuWEwsXG4gIE5PTkUsXG4gIFBJTEw6ICdwaWxsJyxcbn07XG5cbmNvbnN0IEZMRVhfRU5EID0gJ2ZsZXgtZW5kJztcbmNvbnN0IEZMRVhfU1RBUlQgPSAnZmxleC1zdGFydCc7XG5jb25zdCBDRU5URVIgPSAnY2VudGVyJztcblxuZXhwb3J0IGNvbnN0IEFMSUdOX0lURU1TID0ge1xuICBGTEVYX1NUQVJULFxuICBGTEVYX0VORCxcbiAgQ0VOVEVSLFxuICBCQVNFTElORTogJ2Jhc2VsaW5lJyxcbiAgU1RSRVRDSDogJ3N0cmV0Y2gnLFxufTtcblxuZXhwb3J0IGNvbnN0IEpVU1RJRllfQ09OVEVOVCA9IHtcbiAgRkxFWF9TVEFSVCxcbiAgRkxFWF9FTkQsXG4gIENFTlRFUixcbiAgU1BBQ0VfQVJPVU5EOiAnc3BhY2UtYXJvdW5kJyxcbiAgU1BBQ0VfQkVUV0VFTjogJ3NwYWNlLWJldHdlZW4nLFxuICBTUEFDRV9FVkVOTFk6ICdzcGFjZS1ldmVubHknLFxufTtcblxuZXhwb3J0IGNvbnN0IEZMRVhfRElSRUNUSU9OID0ge1xuICBST1c6ICdyb3cnLFxuICBST1dfUkVWRVJTRTogJ3Jvdy1yZXZlcnNlJyxcbiAgQ09MVU1OOiAnY29sdW1uJyxcbiAgQ09MVU1OX1JFVkVSU0U6ICdjb2x1bW4tcmV2ZXJzZScsXG59O1xuXG5leHBvcnQgY29uc3QgRkxFWF9XUkFQID0ge1xuICBXUkFQOiAnd3JhcCcsXG4gIFdSQVBfUkVWRVJTRTogJ3dyYXAtcmV2ZXJzZScsXG4gIE5PX1dSQVA6ICdub3dyYXAnLFxufTtcblxuZXhwb3J0IGNvbnN0IERJU1BMQVkgPSB7XG4gIEJMT0NLOiAnYmxvY2snLFxuICBGTEVYOiAnZmxleCcsXG4gIEdSSUQ6ICdncmlkJyxcbiAgSU5MSU5FX0JMT0NLOiAnaW5saW5lLWJsb2NrJyxcbiAgSU5MSU5FOiAnaW5saW5lJyxcbiAgSU5MSU5FX0ZMRVg6ICdpbmxpbmUtZmxleCcsXG4gIElOTElORV9HUklEOiAnaW5saW5lLWdyaWQnLFxuICBMSVNUX0lURU06ICdsaXN0LWl0ZW0nLFxuICBOT05FOiAnbm9uZScsXG59O1xuXG5leHBvcnQgY29uc3QgRlJBQ1RJT05TID0ge1xuICBIQUxGOiAnMS8yJyxcbiAgT05FX1RISVJEOiAnMS8zJyxcbiAgVFdPX1RISVJEUzogJzIvMycsXG4gIE9ORV9GT1VSVEg6ICcxLzQnLFxuICBUV09fRk9VUlRIUzogJzIvNCcsXG4gIFRIUkVFX0ZPVVJUSFM6ICczLzQnLFxuICBPTkVfRklGVEg6ICcxLzUnLFxuICBUV09fRklGVEhTOiAnMi81JyxcbiAgVEhSRUVfRklGVEhTOiAnMy81JyxcbiAgRk9VUl9GSUZUSFM6ICc0LzUnLFxuICBPTkVfU0lYVEg6ICcxLzYnLFxuICBUV09fU0lYVEhTOiAnMi82JyxcbiAgVEhSRUVfU0lYVEhTOiAnMy82JyxcbiAgRk9VUl9TSVhUSFM6ICc0LzYnLFxuICBGSVZFX1NJWFRIUzogJzUvNicsXG4gIE9ORV9UV0VMRlRIOiAnMS8xMicsXG4gIFRXT19UV0VMRlRIUzogJzIvMTInLFxuICBUSFJFRV9UV0VMRlRIUzogJzMvMTInLFxuICBGT1VSX1RXRUxGVEhTOiAnNC8xMicsXG4gIEZJVkVfVFdFTEZUSFM6ICc1LzEyJyxcbiAgU0lYX1RXRUxGVEhTOiAnNi8xMicsXG4gIFNFVkVOX1RXRUxGVEhTOiAnNy8xMicsXG4gIEVJR0hUX1RXRUxGVEhTOiAnOC8xMicsXG4gIE5JTkVfVFdFTEZUSFM6ICc5LzEyJyxcbiAgVEVOX1RXRUxGVEhTOiAnMTAvMTInLFxuICBFTEVWRU5fVFdFTEZUSFM6ICcxMS8xMicsXG59O1xuXG5leHBvcnQgY29uc3QgQkxPQ0tfU0laRVMgPSB7XG4gIC4uLkZSQUNUSU9OUyxcbiAgU0NSRUVOOiAnc2NyZWVuJyxcbiAgTUFYOiAnbWF4JyxcbiAgTUlOOiAnbWluJyxcbiAgRlVMTDogJ2Z1bGwnLFxufTtcblxuZXhwb3J0IGNvbnN0IFRFWFRfQUxJR04gPSB7XG4gIExFRlQ6ICdsZWZ0JyxcbiAgQ0VOVEVSOiAnY2VudGVyJyxcbiAgUklHSFQ6ICdyaWdodCcsXG4gIEpVU1RJRlk6ICdqdXN0aWZ5JyxcbiAgRU5EOiAnZW5kJyxcbn07XG5cbmV4cG9ydCBjb25zdCBURVhUX1RSQU5TRk9STSA9IHtcbiAgVVBQRVJDQVNFOiAndXBwZXJjYXNlJyxcbiAgTE9XRVJDQVNFOiAnbG93ZXJjYXNlJyxcbiAgQ0FQSVRBTElaRTogJ2NhcGl0YWxpemUnLFxufTtcblxuZXhwb3J0IGNvbnN0IEZPTlRfV0VJR0hUID0ge1xuICBCT0xEOiAnYm9sZCcsXG4gIE1FRElVTTogJ21lZGl1bScsXG4gIE5PUk1BTDogJ25vcm1hbCcsXG59O1xuXG5leHBvcnQgY29uc3QgT1ZFUkZMT1dfV1JBUCA9IHtcbiAgQlJFQUtfV09SRDogJ2JyZWFrLXdvcmQnLFxuICBOT1JNQUw6ICdub3JtYWwnLFxufTtcblxuZXhwb3J0IGNvbnN0IEZPTlRfU1RZTEUgPSB7XG4gIElUQUxJQzogJ2l0YWxpYycsXG4gIE5PUk1BTDogJ25vcm1hbCcsXG59O1xuXG5leHBvcnQgY29uc3QgU0VWRVJJVElFUyA9IHtcbiAgREFOR0VSOiAnZGFuZ2VyJyxcbiAgV0FSTklORzogJ3dhcm5pbmcnLFxuICBJTkZPOiAnaW5mbycsXG4gIFNVQ0NFU1M6ICdzdWNjZXNzJyxcbn07XG5cbmV4cG9ydCBjb25zdCBSRVNJWkUgPSB7XG4gIE5PTkU6ICdub25lJyxcbiAgQk9USDogJ2JvdGgnLFxuICBIT1JJWk9OVEFMOiAnaG9yaXpvbnRhbCcsXG4gIFZFUlRJQ0FMOiAndmVydGljYWwnLFxuICBJTklUSUFMOiAnaW5pdGlhbCcsXG4gIElOSEVSSVQ6ICdpbmhlcml0Jyxcbn07XG5cbmV4cG9ydCBjb25zdCBCUkVBS1BPSU5UUyA9IFsnYmFzZScsICdzbScsICdtZCcsICdsZyddO1xuIiwiZXhwb3J0IGNvbnN0IElOU1VGRklDSUVOVF9GVU5EU19FUlJPUl9LRVkgPSAnaW5zdWZmaWNpZW50RnVuZHMnO1xuZXhwb3J0IGNvbnN0IEdBU19MSU1JVF9UT09fTE9XX0VSUk9SX0tFWSA9ICdnYXNMaW1pdFRvb0xvdyc7XG5leHBvcnQgY29uc3QgVFJBTlNBQ1RJT05fRVJST1JfS0VZID0gJ3RyYW5zYWN0aW9uRXJyb3InO1xuZXhwb3J0IGNvbnN0IEVUSF9HQVNfUFJJQ0VfRkVUQ0hfV0FSTklOR19LRVkgPSAnZXRoR2FzUHJpY2VGZXRjaFdhcm5pbmcnO1xuZXhwb3J0IGNvbnN0IEdBU19QUklDRV9GRVRDSF9GQUlMVVJFX0VSUk9SX0tFWSA9ICdnYXNQcmljZUZldGNoRmFpbGVkJztcbmV4cG9ydCBjb25zdCBHQVNfUFJJQ0VfRVhDRVNTSVZFX0VSUk9SX0tFWSA9ICdnYXNQcmljZUV4Y2Vzc2l2ZSc7XG5leHBvcnQgY29uc3QgVU5TRU5EQUJMRV9BU1NFVF9FUlJPUl9LRVkgPSAndW5zZW5kYWJsZUFzc2V0JztcbmV4cG9ydCBjb25zdCBJTlNVRkZJQ0lFTlRfRlVORFNfRk9SX0dBU19FUlJPUl9LRVkgPSAnaW5zdWZmaWNpZW50RnVuZHNGb3JHYXMnO1xuZXhwb3J0IGNvbnN0IElOVkFMSURfQVNTRVRfVFlQRSA9ICdpbnZhbGlkQXNzZXRUeXBlJztcbiIsImNvbnN0IERFRkFVTFRfUk9VVEUgPSAnLyc7XHJcbmNvbnN0IFVOTE9DS19ST1VURSA9ICcvdW5sb2NrJztcclxuY29uc3QgTE9DS19ST1VURSA9ICcvbG9jayc7XHJcbmNvbnN0IEFTU0VUX1JPVVRFID0gJy9hc3NldCc7XHJcbmNvbnN0IFNFVFRJTkdTX1JPVVRFID0gJy9zZXR0aW5ncyc7XHJcbmNvbnN0IEdFTkVSQUxfUk9VVEUgPSAnL3NldHRpbmdzL2dlbmVyYWwnO1xyXG5jb25zdCBBRFZBTkNFRF9ST1VURSA9ICcvc2V0dGluZ3MvYWR2YW5jZWQnO1xyXG5jb25zdCBFWFBFUklNRU5UQUxfUk9VVEUgPSAnL3NldHRpbmdzL2V4cGVyaW1lbnRhbCc7XHJcbmNvbnN0IFNFQ1VSSVRZX1JPVVRFID0gJy9zZXR0aW5ncy9zZWN1cml0eSc7XHJcbmNvbnN0IEFCT1VUX1VTX1JPVVRFID0gJy9zZXR0aW5ncy9hYm91dC11cyc7XHJcbmNvbnN0IEFMRVJUU19ST1VURSA9ICcvc2V0dGluZ3MvYWxlcnRzJztcclxuY29uc3QgTkVUV09SS1NfUk9VVEUgPSAnL3NldHRpbmdzL25ldHdvcmtzJztcclxuY29uc3QgTkVUV09SS1NfRk9STV9ST1VURSA9ICcvc2V0dGluZ3MvbmV0d29ya3MvZm9ybSc7XHJcbmNvbnN0IEFERF9ORVRXT1JLX1JPVVRFID0gJy9zZXR0aW5ncy9uZXR3b3Jrcy9hZGQtbmV0d29yayc7XHJcbmNvbnN0IEFERF9QT1BVTEFSX0NVU1RPTV9ORVRXT1JLID1cclxuICAnL3NldHRpbmdzL25ldHdvcmtzL2FkZC1wb3B1bGFyLWN1c3RvbS1uZXR3b3JrJztcclxuY29uc3QgU05BUFNfTElTVF9ST1VURSA9ICcvc2V0dGluZ3Mvc25hcHMtbGlzdCc7XHJcbmNvbnN0IFNOQVBTX1ZJRVdfUk9VVEUgPSAnL3NldHRpbmdzL3NuYXBzLXZpZXcnO1xyXG5jb25zdCBDT05UQUNUX0xJU1RfUk9VVEUgPSAnL3NldHRpbmdzL2NvbnRhY3QtbGlzdCc7XHJcbmNvbnN0IENPTlRBQ1RfRURJVF9ST1VURSA9ICcvc2V0dGluZ3MvY29udGFjdC1saXN0L2VkaXQtY29udGFjdCc7XHJcbmNvbnN0IENPTlRBQ1RfQUREX1JPVVRFID0gJy9zZXR0aW5ncy9jb250YWN0LWxpc3QvYWRkLWNvbnRhY3QnO1xyXG5jb25zdCBDT05UQUNUX1ZJRVdfUk9VVEUgPSAnL3NldHRpbmdzL2NvbnRhY3QtbGlzdC92aWV3LWNvbnRhY3QnO1xyXG5jb25zdCBSRVZFQUxfU0VFRF9ST1VURSA9ICcvc2VlZCc7XHJcbmNvbnN0IE1PQklMRV9TWU5DX1JPVVRFID0gJy9tb2JpbGUtc3luYyc7XHJcbmNvbnN0IFJFU1RPUkVfVkFVTFRfUk9VVEUgPSAnL3Jlc3RvcmUtdmF1bHQnO1xyXG5jb25zdCBJTVBPUlRfVE9LRU5fUk9VVEUgPSAnL2ltcG9ydC10b2tlbic7XHJcbmNvbnN0IENPTkZJUk1fSU1QT1JUX1RPS0VOX1JPVVRFID0gJy9jb25maXJtLWltcG9ydC10b2tlbic7XHJcbmNvbnN0IENPTkZJUk1fQUREX1NVR0dFU1RFRF9UT0tFTl9ST1VURSA9ICcvY29uZmlybS1hZGQtc3VnZ2VzdGVkLXRva2VuJztcclxuY29uc3QgTkVXX0FDQ09VTlRfUk9VVEUgPSAnL25ldy1hY2NvdW50JztcclxuY29uc3QgSU1QT1JUX0FDQ09VTlRfUk9VVEUgPSAnL25ldy1hY2NvdW50L2ltcG9ydCc7XHJcbmNvbnN0IENPTk5FQ1RfSEFSRFdBUkVfUk9VVEUgPSAnL25ldy1hY2NvdW50L2Nvbm5lY3QnO1xyXG5jb25zdCBTRU5EX1JPVVRFID0gJy9zZW5kJztcclxuY29uc3QgVE9LRU5fREVUQUlMUyA9ICcvdG9rZW4tZGV0YWlscyc7XHJcbmNvbnN0IENPTk5FQ1RfUk9VVEUgPSAnL2Nvbm5lY3QnO1xyXG5jb25zdCBDT05ORUNUX0NPTkZJUk1fUEVSTUlTU0lPTlNfUk9VVEUgPSAnL2NvbmZpcm0tcGVybWlzc2lvbnMnO1xyXG5cbmNvbnN0IENPTk5FQ1RFRF9ST1VURSA9ICcvY29ubmVjdGVkJztcclxuY29uc3QgQ09OTkVDVEVEX0FDQ09VTlRTX1JPVVRFID0gJy9jb25uZWN0ZWQvYWNjb3VudHMnO1xyXG5jb25zdCBTV0FQU19ST1VURSA9ICcvc3dhcHMnO1xyXG5jb25zdCBCVUlMRF9RVU9URV9ST1VURSA9ICcvc3dhcHMvYnVpbGQtcXVvdGUnO1xyXG5jb25zdCBWSUVXX1FVT1RFX1JPVVRFID0gJy9zd2Fwcy92aWV3LXF1b3RlJztcclxuY29uc3QgTE9BRElOR19RVU9URVNfUk9VVEUgPSAnL3N3YXBzL2xvYWRpbmctcXVvdGVzJztcclxuY29uc3QgQVdBSVRJTkdfU0lHTkFUVVJFU19ST1VURSA9ICcvc3dhcHMvYXdhaXRpbmctc2lnbmF0dXJlcyc7XHJcbmNvbnN0IFNNQVJUX1RSQU5TQUNUSU9OX1NUQVRVU19ST1VURSA9ICcvc3dhcHMvc21hcnQtdHJhbnNhY3Rpb24tc3RhdHVzJztcclxuY29uc3QgQVdBSVRJTkdfU1dBUF9ST1VURSA9ICcvc3dhcHMvYXdhaXRpbmctc3dhcCc7XHJcbmNvbnN0IFNXQVBTX0VSUk9SX1JPVVRFID0gJy9zd2Fwcy9zd2Fwcy1lcnJvcic7XHJcbmNvbnN0IFNXQVBTX01BSU5URU5BTkNFX1JPVVRFID0gJy9zd2Fwcy9tYWludGVuYW5jZSc7XHJcbmNvbnN0IEFERF9DT0xMRUNUSUJMRV9ST1VURSA9ICcvYWRkLWNvbGxlY3RpYmxlJztcclxuXHJcbmNvbnN0IElOSVRJQUxJWkVfUk9VVEUgPSAnL2luaXRpYWxpemUnO1xyXG5jb25zdCBJTklUSUFMSVpFX1dFTENPTUVfUk9VVEUgPSAnL2luaXRpYWxpemUvd2VsY29tZSc7XHJcbmNvbnN0IElOSVRJQUxJWkVfVU5MT0NLX1JPVVRFID0gJy9pbml0aWFsaXplL3VubG9jayc7XHJcbmNvbnN0IElOSVRJQUxJWkVfQ1JFQVRFX1BBU1NXT1JEX1JPVVRFID0gJy9pbml0aWFsaXplL2NyZWF0ZS1wYXNzd29yZCc7XHJcbmNvbnN0IElOSVRJQUxJWkVfSU1QT1JUX1dJVEhfU0VFRF9QSFJBU0VfUk9VVEUgPVxyXG4gICcvaW5pdGlhbGl6ZS9jcmVhdGUtcGFzc3dvcmQvaW1wb3J0LXdpdGgtc2VlZC1waHJhc2UnO1xyXG5jb25zdCBJTklUSUFMSVpFX1NFTEVDVF9BQ1RJT05fUk9VVEUgPSAnL2luaXRpYWxpemUvc2VsZWN0LWFjdGlvbic7XHJcbmNvbnN0IElOSVRJQUxJWkVfU0VFRF9QSFJBU0VfUk9VVEUgPSAnL2luaXRpYWxpemUvc2VlZC1waHJhc2UnO1xyXG5jb25zdCBJTklUSUFMSVpFX0JBQ0tVUF9TRUVEX1BIUkFTRV9ST1VURSA9ICcvaW5pdGlhbGl6ZS9iYWNrdXAtc2VlZC1waHJhc2UnO1xyXG5jb25zdCBJTklUSUFMSVpFX1NFRURfUEhSQVNFX0lOVFJPX1JPVVRFID0gJy9pbml0aWFsaXplL3NlZWQtcGhyYXNlLWludHJvJztcclxuY29uc3QgSU5JVElBTElaRV9FTkRfT0ZfRkxPV19ST1VURSA9ICcvaW5pdGlhbGl6ZS9lbmQtb2YtZmxvdyc7XHJcbmNvbnN0IElOSVRJQUxJWkVfQ09ORklSTV9TRUVEX1BIUkFTRV9ST1VURSA9ICcvaW5pdGlhbGl6ZS9zZWVkLXBocmFzZS9jb25maXJtJztcclxuY29uc3QgSU5JVElBTElaRV9NRVRBTUVUUklDU19PUFRfSU5fUk9VVEUgPSAnL2luaXRpYWxpemUvbWV0YW1ldHJpY3Mtb3B0LWluJztcclxuXHJcbmNvbnN0IE9OQk9BUkRJTkdfUk9VVEUgPSAnL29uYm9hcmRpbmcnO1xyXG5jb25zdCBPTkJPQVJESU5HX1JFVklFV19TUlBfUk9VVEUgPSAnL29uYm9hcmRpbmcvcmV2aWV3LXJlY292ZXJ5LXBocmFzZSc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfQ09ORklSTV9TUlBfUk9VVEUgPSAnL29uYm9hcmRpbmcvY29uZmlybS1yZWNvdmVyeS1waHJhc2UnO1xyXG5jb25zdCBPTkJPQVJESU5HX0NSRUFURV9QQVNTV09SRF9ST1VURSA9ICcvb25ib2FyZGluZy9jcmVhdGUtcGFzc3dvcmQnO1xyXG5jb25zdCBPTkJPQVJESU5HX0NPTVBMRVRJT05fUk9VVEUgPSAnL29uYm9hcmRpbmcvY29tcGxldGlvbic7XHJcbmNvbnN0IE9OQk9BUkRJTkdfVU5MT0NLX1JPVVRFID0gJy9vbmJvYXJkaW5nL3VubG9jayc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfSEVMUF9VU19JTVBST1ZFX1JPVVRFID0gJy9vbmJvYXJkaW5nL2hlbHAtdXMtaW1wcm92ZSc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfSU1QT1JUX1dJVEhfU1JQX1JPVVRFID1cclxuICAnL29uYm9hcmRpbmcvaW1wb3J0LXdpdGgtcmVjb3ZlcnktcGhyYXNlJztcclxuY29uc3QgT05CT0FSRElOR19JTVBPUlRfTU9CSUxFX1JPVVRFID0gJy9vbmJvYXJkaW5nL2ltcG9ydC1tb2JpbGUnO1xyXG5jb25zdCBPTkJPQVJESU5HX1NFQ1VSRV9ZT1VSX1dBTExFVF9ST1VURSA9ICcvb25ib2FyZGluZy9zZWN1cmUteW91ci13YWxsZXQnO1xyXG5jb25zdCBPTkJPQVJESU5HX1BSSVZBQ1lfU0VUVElOR1NfUk9VVEUgPSAnL29uYm9hcmRpbmcvcHJpdmFjeS1zZXR0aW5ncyc7XHJcbmNvbnN0IE9OQk9BUkRJTkdfUElOX0VYVEVOU0lPTl9ST1VURSA9ICcvb25ib2FyZGluZy9waW4tZXh0ZW5zaW9uJztcclxuY29uc3QgT05CT0FSRElOR19XRUxDT01FX1JPVVRFID0gJy9vbmJvYXJkaW5nL3dlbGNvbWUnO1xyXG5jb25zdCBPTkJPQVJESU5HX01FVEFNRVRSSUNTID0gJy9vbmJvYXJkaW5nL21ldGFtZXRyaWNzJztcclxuXHJcblxuXHJcbmNvbnN0IENPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEUgPSAnL2NvbmZpcm0tdHJhbnNhY3Rpb24nO1xyXG5jb25zdCBDT05GSVJNX1NFTkRfRVRIRVJfUEFUSCA9ICcvc2VuZC1ldGhlcic7XHJcbmNvbnN0IENPTkZJUk1fU0VORF9UT0tFTl9QQVRIID0gJy9zZW5kLXRva2VuJztcclxuY29uc3QgQ09ORklSTV9ERVBMT1lfQ09OVFJBQ1RfUEFUSCA9ICcvZGVwbG95LWNvbnRyYWN0JztcclxuY29uc3QgQ09ORklSTV9BUFBST1ZFX1BBVEggPSAnL2FwcHJvdmUnO1xyXG5jb25zdCBDT05GSVJNX1NFVF9BUFBST1ZBTF9GT1JfQUxMX1BBVEggPSAnL3NldC1hcHByb3ZhbC1mb3ItYWxsJztcclxuY29uc3QgQ09ORklSTV9UUkFOU0ZFUl9GUk9NX1BBVEggPSAnL3RyYW5zZmVyLWZyb20nO1xyXG5jb25zdCBDT05GSVJNX1NBRkVfVFJBTlNGRVJfRlJPTV9QQVRIID0gJy9zYWZlLXRyYW5zZmVyLWZyb20nO1xyXG5jb25zdCBDT05GSVJNX1RPS0VOX01FVEhPRF9QQVRIID0gJy90b2tlbi1tZXRob2QnO1xyXG5jb25zdCBTSUdOQVRVUkVfUkVRVUVTVF9QQVRIID0gJy9zaWduYXR1cmUtcmVxdWVzdCc7XHJcbmNvbnN0IERFQ1JZUFRfTUVTU0FHRV9SRVFVRVNUX1BBVEggPSAnL2RlY3J5cHQtbWVzc2FnZS1yZXF1ZXN0JztcclxuY29uc3QgRU5DUllQVElPTl9QVUJMSUNfS0VZX1JFUVVFU1RfUEFUSCA9ICcvZW5jcnlwdGlvbi1wdWJsaWMta2V5LXJlcXVlc3QnO1xyXG5jb25zdCBDT05GSVJNQVRJT05fVl9ORVhUX1JPVVRFID0gJy9jb25maXJtYXRpb24nO1xyXG5cclxuLy8gVXNlZCB0byBwdWxsIGEgY29udmVuaWVudCBuYW1lIGZvciBhbmFseXRpY3MgdHJhY2tpbmcgZXZlbnRzLiBUaGUga2V5IG11c3RcclxuLy8gYmUgcmVhY3Qtcm91dGVyIHJlYWR5IHBhdGgsIGFuZCBjYW4gaW5jbHVkZSBwYXJhbXMgc3VjaCBhcyA6aWQgZm9yIHBvcHVwIHdpbmRvd3NcclxuY29uc3QgUEFUSF9OQU1FX01BUCA9IHtcclxuICBbREVGQVVMVF9ST1VURV06ICdIb21lJyxcclxuICBbVU5MT0NLX1JPVVRFXTogJ1VubG9jayBQYWdlJyxcclxuICBbTE9DS19ST1VURV06ICdMb2NrIFBhZ2UnLFxyXG4gIFtgJHtBU1NFVF9ST1VURX0vOmFzc2V0LzppZGBdOiBgQXNzZXQgUGFnZWAsXHJcbiAgW1NFVFRJTkdTX1JPVVRFXTogJ1NldHRpbmdzIFBhZ2UnLFxyXG4gIFtHRU5FUkFMX1JPVVRFXTogJ0dlbmVyYWwgU2V0dGluZ3MgUGFnZScsXHJcbiAgW0FEVkFOQ0VEX1JPVVRFXTogJ0FkdmFuY2VkIFNldHRpbmdzIFBhZ2UnLFxyXG4gIFtFWFBFUklNRU5UQUxfUk9VVEVdOiAnRXhwZXJpbWVudGFsIFNldHRpbmdzIFBhZ2UnLFxyXG4gIFtTRUNVUklUWV9ST1VURV06ICdTZWN1cml0eSBTZXR0aW5ncyBQYWdlJyxcclxuICBbQUJPVVRfVVNfUk9VVEVdOiAnQWJvdXQgVXMgUGFnZScsXHJcbiAgW0FMRVJUU19ST1VURV06ICdBbGVydHMgU2V0dGluZ3MgUGFnZScsXHJcbiAgW05FVFdPUktTX1JPVVRFXTogJ05ldHdvcmsgU2V0dGluZ3MgUGFnZScsXHJcbiAgW05FVFdPUktTX0ZPUk1fUk9VVEVdOiAnTmV0d29yayBTZXR0aW5ncyBQYWdlIEZvcm0nLFxyXG4gIFtBRERfTkVUV09SS19ST1VURV06ICdBZGQgTmV0d29yayBGcm9tIFNldHRpbmdzIFBhZ2UgRm9ybScsXHJcbiAgW0FERF9QT1BVTEFSX0NVU1RPTV9ORVRXT1JLXTpcclxuICAgICdBZGQgTmV0d29yayBGcm9tIEEgTGlzdCBPZiBQb3B1bGFyIEN1c3RvbSBOZXR3b3JrcycsXHJcbiAgW0NPTlRBQ1RfTElTVF9ST1VURV06ICdDb250YWN0IExpc3QgU2V0dGluZ3MgUGFnZScsXHJcbiAgW2Ake0NPTlRBQ1RfRURJVF9ST1VURX0vOmFkZHJlc3NgXTogJ0VkaXQgQ29udGFjdCBTZXR0aW5ncyBQYWdlJyxcclxuICBbQ09OVEFDVF9BRERfUk9VVEVdOiAnQWRkIENvbnRhY3QgU2V0dGluZ3MgUGFnZScsXHJcbiAgW2Ake0NPTlRBQ1RfVklFV19ST1VURX0vOmFkZHJlc3NgXTogJ1ZpZXcgQ29udGFjdCBTZXR0aW5ncyBQYWdlJyxcclxuICBbUkVWRUFMX1NFRURfUk9VVEVdOiAnUmV2ZWFsIFNlY3JldCBSZWNvdmVyeSBQaHJhc2UgUGFnZScsXHJcbiAgW01PQklMRV9TWU5DX1JPVVRFXTogJ1N5bmMgV2l0aCBNb2JpbGUgUGFnZScsXHJcbiAgW1JFU1RPUkVfVkFVTFRfUk9VVEVdOiAnUmVzdG9yZSBWYXVsdCBQYWdlJyxcclxuICBbSU1QT1JUX1RPS0VOX1JPVVRFXTogJ0ltcG9ydCBUb2tlbiBQYWdlJyxcclxuICBbQ09ORklSTV9JTVBPUlRfVE9LRU5fUk9VVEVdOiAnQ29uZmlybSBJbXBvcnQgVG9rZW4gUGFnZScsXHJcbiAgW0NPTkZJUk1fQUREX1NVR0dFU1RFRF9UT0tFTl9ST1VURV06ICdDb25maXJtIEFkZCBTdWdnZXN0ZWQgVG9rZW4gUGFnZScsXHJcbiAgW05FV19BQ0NPVU5UX1JPVVRFXTogJ05ldyBBY2NvdW50IFBhZ2UnLFxyXG4gIFtJTVBPUlRfQUNDT1VOVF9ST1VURV06ICdJbXBvcnQgQWNjb3VudCBQYWdlJyxcclxuICBbQ09OTkVDVF9IQVJEV0FSRV9ST1VURV06ICdDb25uZWN0IEhhcmR3YXJlIFdhbGxldCBQYWdlJyxcclxuICBbU0VORF9ST1VURV06ICdTZW5kIFBhZ2UnLFxyXG4gIFtgJHtUT0tFTl9ERVRBSUxTfS86YWRkcmVzc2BdOiAnVG9rZW4gRGV0YWlscyBQYWdlJyxcclxuICBbYCR7Q09OTkVDVF9ST1VURX0vOmlkYF06ICdDb25uZWN0IFRvIFNpdGUgQ29uZmlybWF0aW9uIFBhZ2UnLFxyXG4gIFtgJHtDT05ORUNUX1JPVVRFfS86aWQke0NPTk5FQ1RfQ09ORklSTV9QRVJNSVNTSU9OU19ST1VURX1gXTpcclxuICAgICdHcmFudCBDb25uZWN0ZWQgU2l0ZSBQZXJtaXNzaW9ucyBDb25maXJtYXRpb24gUGFnZScsXHJcbiAgW0NPTk5FQ1RFRF9ST1VURV06ICdTaXRlcyBDb25uZWN0ZWQgVG8gVGhpcyBBY2NvdW50IFBhZ2UnLFxyXG4gIFtDT05ORUNURURfQUNDT1VOVFNfUk9VVEVdOiAnQWNjb3VudHMgQ29ubmVjdGVkIFRvIFRoaXMgU2l0ZSBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkYF06ICdDb25maXJtYXRpb24gUm9vdCBQYWdlJyxcclxuICBbQ09ORklSTV9UUkFOU0FDVElPTl9ST1VURV06ICdDb25maXJtYXRpb24gUm9vdCBQYWdlJyxcclxuICAvLyBUT0RPOiByZW5hbWUgd2hlbiB0aGlzIGlzIHRoZSBvbmx5IGNvbmZpcm1hdGlvbiBwYWdlXHJcbiAgW0NPTkZJUk1BVElPTl9WX05FWFRfUk9VVEVdOiAnTmV3IENvbmZpcm1hdGlvbiBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtDT05GSVJNX1RPS0VOX01FVEhPRF9QQVRIfWBdOlxyXG4gICAgJ0NvbmZpcm0gVG9rZW4gTWV0aG9kIFRyYW5zYWN0aW9uIFBhZ2UnLFxyXG4gIFtgJHtDT05GSVJNX1RSQU5TQUNUSU9OX1JPVVRFfS86aWQke0NPTkZJUk1fU0VORF9FVEhFUl9QQVRIfWBdOlxyXG4gICAgJ0NvbmZpcm0gU2VuZCBFdGhlciBUcmFuc2FjdGlvbiBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtDT05GSVJNX1NFTkRfVE9LRU5fUEFUSH1gXTpcclxuICAgICdDb25maXJtIFNlbmQgVG9rZW4gVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7Q09ORklSTV9ERVBMT1lfQ09OVFJBQ1RfUEFUSH1gXTpcclxuICAgICdDb25maXJtIERlcGxveSBDb250cmFjdCBUcmFuc2FjdGlvbiBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtDT05GSVJNX0FQUFJPVkVfUEFUSH1gXTpcclxuICAgICdDb25maXJtIEFwcHJvdmUgVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7Q09ORklSTV9TRVRfQVBQUk9WQUxfRk9SX0FMTF9QQVRIfWBdOlxyXG4gICAgJ0NvbmZpcm0gU2V0IEFwcHJvdmFsIEZvciBBbGwgVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7Q09ORklSTV9UUkFOU0ZFUl9GUk9NX1BBVEh9YF06XHJcbiAgICAnQ29uZmlybSBUcmFuc2ZlciBGcm9tIFRyYW5zYWN0aW9uIFBhZ2UnLFxyXG4gIFtgJHtDT05GSVJNX1RSQU5TQUNUSU9OX1JPVVRFfS86aWQke0NPTkZJUk1fU0FGRV9UUkFOU0ZFUl9GUk9NX1BBVEh9YF06XHJcbiAgICAnQ29uZmlybSBTYWZlIFRyYW5zZmVyIEZyb20gVHJhbnNhY3Rpb24gUGFnZScsXHJcbiAgW2Ake0NPTkZJUk1fVFJBTlNBQ1RJT05fUk9VVEV9LzppZCR7U0lHTkFUVVJFX1JFUVVFU1RfUEFUSH1gXTpcclxuICAgICdTaWduYXR1cmUgUmVxdWVzdCBQYWdlJyxcclxuICBbYCR7Q09ORklSTV9UUkFOU0FDVElPTl9ST1VURX0vOmlkJHtERUNSWVBUX01FU1NBR0VfUkVRVUVTVF9QQVRIfWBdOlxyXG4gICAgJ0RlY3J5cHQgTWVzc2FnZSBSZXF1ZXN0IFBhZ2UnLFxyXG4gIFtgJHtDT05GSVJNX1RSQU5TQUNUSU9OX1JPVVRFfS86aWQke0VOQ1JZUFRJT05fUFVCTElDX0tFWV9SRVFVRVNUX1BBVEh9YF06XHJcbiAgICAnRW5jcnlwdGlvbiBQdWJsaWMgS2V5IFJlcXVlc3QgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfUk9VVEVdOiAnSW5pdGlhbGl6YXRpb24gUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfV0VMQ09NRV9ST1VURV06ICdJbnN0YWxsIFdlbGNvbWUgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfVU5MT0NLX1JPVVRFXTogJ0luaXRpYWxpemF0aW9uIFVubG9jayBwYWdlJyxcclxuICBbSU5JVElBTElaRV9DUkVBVEVfUEFTU1dPUkRfUk9VVEVdOiAnSW5pdGlhbGl6YXRpb24gQ3JlYXRlIFBhc3N3b3JkIFBhZ2UnLFxyXG4gIFtJTklUSUFMSVpFX0lNUE9SVF9XSVRIX1NFRURfUEhSQVNFX1JPVVRFXTpcclxuICAgICdJbml0aWFsaXphdGlvbiBJbXBvcnQgQWNjb3VudCBXaXRoIFNlY3JldCBSZWNvdmVyeSBQaHJhc2UgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfU0VMRUNUX0FDVElPTl9ST1VURV06XHJcbiAgICAnSW5pdGlhbGl6YXRpb24gQ2hvb3NlIFJlc3RvcmUgb3IgTmV3IEFjY291bnQgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfU0VFRF9QSFJBU0VfUk9VVEVdOiAnSW5pdGlhbGl6YXRpb24gU2VjcmV0IFJlY292ZXJ5IFBocmFzZSBQYWdlJyxcclxuICBbSU5JVElBTElaRV9CQUNLVVBfU0VFRF9QSFJBU0VfUk9VVEVdOlxyXG4gICAgJ0luaXRpYWxpemF0aW9uIEJhY2t1cCBTZWNyZXQgUmVjb3ZlcnkgUGhyYXNlIFBhZ2UnLFxyXG4gIFtJTklUSUFMSVpFX1NFRURfUEhSQVNFX0lOVFJPX1JPVVRFXTpcclxuICAgICdJbml0aWFsaXphdGlvbiBTZWNyZXQgUmVjb3ZlcnkgUGhyYXNlIEludHJvIFBhZ2UnLFxyXG4gIFtJTklUSUFMSVpFX0VORF9PRl9GTE9XX1JPVVRFXTogJ0VuZCBvZiBJbml0aWFsaXphdGlvbiBQYWdlJyxcclxuICBbSU5JVElBTElaRV9DT05GSVJNX1NFRURfUEhSQVNFX1JPVVRFXTpcclxuICAgICdJbml0aWFsaXphdGlvbiBDb25maXJtIFNlY3JldCBSZWNvdmVyeSBQaHJhc2UgUGFnZScsXHJcbiAgW0lOSVRJQUxJWkVfTUVUQU1FVFJJQ1NfT1BUX0lOX1JPVVRFXTogJ01ldGFNZXRyaWNzIE9wdCBJbiBQYWdlJyxcclxuICBbQlVJTERfUVVPVEVfUk9VVEVdOiAnU3dhcHMgQnVpbGQgUXVvdGUgUGFnZScsXHJcbiAgW1ZJRVdfUVVPVEVfUk9VVEVdOiAnU3dhcHMgVmlldyBRdW90ZXMgUGFnZScsXHJcbiAgW0xPQURJTkdfUVVPVEVTX1JPVVRFXTogJ1N3YXBzIExvYWRpbmcgUXVvdGVzIFBhZ2UnLFxyXG4gIFtBV0FJVElOR19TV0FQX1JPVVRFXTogJ1N3YXBzIEF3YWl0aW5nIFN3YXBzIFBhZ2UnLFxyXG4gIFtTV0FQU19FUlJPUl9ST1VURV06ICdTd2FwcyBFcnJvciBQYWdlJyxcclxufTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgREVGQVVMVF9ST1VURSxcclxuICBBTEVSVFNfUk9VVEUsXHJcbiAgQVNTRVRfUk9VVEUsXHJcbiAgVU5MT0NLX1JPVVRFLFxyXG4gIExPQ0tfUk9VVEUsXHJcbiAgU0VUVElOR1NfUk9VVEUsXHJcbiAgUkVWRUFMX1NFRURfUk9VVEUsXHJcbiAgTU9CSUxFX1NZTkNfUk9VVEUsXHJcbiAgUkVTVE9SRV9WQVVMVF9ST1VURSxcclxuICBJTVBPUlRfVE9LRU5fUk9VVEUsXHJcbiAgQ09ORklSTV9JTVBPUlRfVE9LRU5fUk9VVEUsXHJcbiAgQ09ORklSTV9BRERfU1VHR0VTVEVEX1RPS0VOX1JPVVRFLFxyXG4gIE5FV19BQ0NPVU5UX1JPVVRFLFxyXG4gIElNUE9SVF9BQ0NPVU5UX1JPVVRFLFxyXG4gIENPTk5FQ1RfSEFSRFdBUkVfUk9VVEUsXHJcbiAgU0VORF9ST1VURSxcclxuICBUT0tFTl9ERVRBSUxTLFxyXG4gIElOSVRJQUxJWkVfUk9VVEUsXHJcbiAgSU5JVElBTElaRV9XRUxDT01FX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfVU5MT0NLX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfQ1JFQVRFX1BBU1NXT1JEX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfSU1QT1JUX1dJVEhfU0VFRF9QSFJBU0VfUk9VVEUsXHJcbiAgSU5JVElBTElaRV9TRUxFQ1RfQUNUSU9OX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfU0VFRF9QSFJBU0VfUk9VVEUsXHJcbiAgSU5JVElBTElaRV9DT05GSVJNX1NFRURfUEhSQVNFX1JPVVRFLFxyXG4gIElOSVRJQUxJWkVfRU5EX09GX0ZMT1dfUk9VVEUsXHJcbiAgQ09ORklSTV9UUkFOU0FDVElPTl9ST1VURSxcclxuICBDT05GSVJNX1NFTkRfRVRIRVJfUEFUSCxcclxuICBDT05GSVJNX1NFTkRfVE9LRU5fUEFUSCxcclxuICBDT05GSVJNX0RFUExPWV9DT05UUkFDVF9QQVRILFxyXG4gIENPTkZJUk1fQVBQUk9WRV9QQVRILFxyXG4gIENPTkZJUk1fU0VUX0FQUFJPVkFMX0ZPUl9BTExfUEFUSCxcclxuICBDT05GSVJNX1RSQU5TRkVSX0ZST01fUEFUSCxcclxuICBDT05GSVJNX1NBRkVfVFJBTlNGRVJfRlJPTV9QQVRILFxyXG4gIENPTkZJUk1fVE9LRU5fTUVUSE9EX1BBVEgsXHJcbiAgU0lHTkFUVVJFX1JFUVVFU1RfUEFUSCxcclxuICBERUNSWVBUX01FU1NBR0VfUkVRVUVTVF9QQVRILFxyXG4gIEVOQ1JZUFRJT05fUFVCTElDX0tFWV9SRVFVRVNUX1BBVEgsXHJcbiAgQ09ORklSTUFUSU9OX1ZfTkVYVF9ST1VURSxcclxuICBJTklUSUFMSVpFX01FVEFNRVRSSUNTX09QVF9JTl9ST1VURSxcclxuICBBRFZBTkNFRF9ST1VURSxcclxuICBFWFBFUklNRU5UQUxfUk9VVEUsXHJcbiAgU0VDVVJJVFlfUk9VVEUsXHJcbiAgR0VORVJBTF9ST1VURSxcclxuICBBQk9VVF9VU19ST1VURSxcclxuICBTTkFQU19MSVNUX1JPVVRFLFxyXG4gIFNOQVBTX1ZJRVdfUk9VVEUsXHJcbiAgQ09OVEFDVF9MSVNUX1JPVVRFLFxyXG4gIENPTlRBQ1RfRURJVF9ST1VURSxcclxuICBDT05UQUNUX0FERF9ST1VURSxcclxuICBDT05UQUNUX1ZJRVdfUk9VVEUsXHJcbiAgTkVUV09SS1NfUk9VVEUsXHJcbiAgTkVUV09SS1NfRk9STV9ST1VURSxcclxuICBBRERfTkVUV09SS19ST1VURSxcclxuICBBRERfUE9QVUxBUl9DVVNUT01fTkVUV09SSyxcclxuICBJTklUSUFMSVpFX0JBQ0tVUF9TRUVEX1BIUkFTRV9ST1VURSxcclxuICBJTklUSUFMSVpFX1NFRURfUEhSQVNFX0lOVFJPX1JPVVRFLFxyXG4gIENPTk5FQ1RfUk9VVEUsXHJcbiAgQ09OTkVDVF9DT05GSVJNX1BFUk1JU1NJT05TX1JPVVRFLFxyXG5cbiAgQ09OTkVDVEVEX1JPVVRFLFxyXG4gIENPTk5FQ1RFRF9BQ0NPVU5UU19ST1VURSxcclxuICBQQVRIX05BTUVfTUFQLFxyXG4gIFNXQVBTX1JPVVRFLFxyXG4gIEJVSUxEX1FVT1RFX1JPVVRFLFxyXG4gIFZJRVdfUVVPVEVfUk9VVEUsXHJcbiAgTE9BRElOR19RVU9URVNfUk9VVEUsXHJcbiAgQVdBSVRJTkdfU1dBUF9ST1VURSxcclxuICBBV0FJVElOR19TSUdOQVRVUkVTX1JPVVRFLFxyXG4gIFNXQVBTX0VSUk9SX1JPVVRFLFxyXG4gIFNXQVBTX01BSU5URU5BTkNFX1JPVVRFLFxyXG4gIFNNQVJUX1RSQU5TQUNUSU9OX1NUQVRVU19ST1VURSxcclxuICBBRERfQ09MTEVDVElCTEVfUk9VVEUsXHJcbiAgT05CT0FSRElOR19ST1VURSxcclxuICBPTkJPQVJESU5HX0hFTFBfVVNfSU1QUk9WRV9ST1VURSxcclxuICBPTkJPQVJESU5HX0NSRUFURV9QQVNTV09SRF9ST1VURSxcclxuICBPTkJPQVJESU5HX0lNUE9SVF9XSVRIX1NSUF9ST1VURSxcclxuICBPTkJPQVJESU5HX0lNUE9SVF9NT0JJTEVfUk9VVEUsXHJcbiAgT05CT0FSRElOR19TRUNVUkVfWU9VUl9XQUxMRVRfUk9VVEUsXHJcbiAgT05CT0FSRElOR19SRVZJRVdfU1JQX1JPVVRFLFxyXG4gIE9OQk9BUkRJTkdfQ09ORklSTV9TUlBfUk9VVEUsXHJcbiAgT05CT0FSRElOR19QUklWQUNZX1NFVFRJTkdTX1JPVVRFLFxyXG4gIE9OQk9BUkRJTkdfQ09NUExFVElPTl9ST1VURSxcclxuICBPTkJPQVJESU5HX1VOTE9DS19ST1VURSxcclxuICBPTkJPQVJESU5HX1BJTl9FWFRFTlNJT05fUk9VVEUsXHJcbiAgT05CT0FSRElOR19XRUxDT01FX1JPVVRFLFxyXG4gIE9OQk9BUkRJTkdfTUVUQU1FVFJJQ1MsXHJcblxufTtcclxuIiwiaW1wb3J0IHtcbiAgVFJBTlNBQ1RJT05fVFlQRVMsXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcblxuZXhwb3J0IGNvbnN0IFBFTkRJTkdfU1RBVFVTX0hBU0ggPSB7XG4gIFtUUkFOU0FDVElPTl9TVEFUVVNFUy5VTkFQUFJPVkVEXTogdHJ1ZSxcbiAgW1RSQU5TQUNUSU9OX1NUQVRVU0VTLkFQUFJPVkVEXTogdHJ1ZSxcbiAgW1RSQU5TQUNUSU9OX1NUQVRVU0VTLlNVQk1JVFRFRF06IHRydWUsXG4gIFtUUkFOU0FDVElPTl9TVEFUVVNFUy5QRU5ESU5HXTogdHJ1ZSxcbn07XG5cbmV4cG9ydCBjb25zdCBQUklPUklUWV9TVEFUVVNfSEFTSCA9IHtcbiAgLi4uUEVORElOR19TVEFUVVNfSEFTSCxcbiAgW1RSQU5TQUNUSU9OX1NUQVRVU0VTLkNPTkZJUk1FRF06IHRydWUsXG59O1xuXG5leHBvcnQgY29uc3QgVE9LRU5fQ0FURUdPUllfSEFTSCA9IHtcbiAgW1RSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFXTogdHJ1ZSxcbiAgW1RSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTF06IHRydWUsXG4gIFtUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJdOiB0cnVlLFxuICBbVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST01dOiB0cnVlLFxufTtcbiIsImNvbnN0IFpFTkRFU0tfVVJMUyA9IHtcclxuICBBRERfQ1VTVE9NX1RPS0VOUzpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAxNTQ4OTAzMScsXHJcbiAgQUREX01JU1NJTkdfQUNDT1VOVFM6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMTU0ODkyNzEnLFxyXG4gIEJBU0lDX1NBRkVUWTpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAxNTQ4OTU5MS1CYXNpYy1TYWZldHktVGlwcycsXHJcbiAgQ1VTVE9NSVpFX05PTkNFOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvNzQxNzQ5OTMzMzUzMS1Ib3ctdG8tY3VzdG9taXplLWEtdHJhbnNhY3Rpb24tbm9uY2UnLFxyXG4gIEhBUkRXQVJFX0NPTk5FQ1RJT046XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMjAzOTQ2MTItSG93LXRvLWNvbm5lY3QtYS1UcmV6b3Itb3ItTGVkZ2VyLUhhcmR3YXJlLVdhbGxldCcsXHJcbiAgSU1QT1JUX0FDQ09VTlRTOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDE1NDg5MzMxJyxcclxuICBJTVBPUlRFRF9BQ0NPVU5UUzpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDAxNTI4OTkzMicsXHJcbiAgSU5GVVJBX0JMT0NLQUdFOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDU5Mzg2NzEyJyxcclxuICBMRUdBQ1lfV0VCMzogJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDUzMTQ3MDEyJyxcclxuICBORlRfVE9LRU5TOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDU4MjM4NTkxLU5GVC10b2tlbnMtaW4tTWV0YU1hc2std2FsbGV0JyxcclxuICBQQVNTV09SRF9BUlRJQ0xFOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvNDQwNDcyMjc4MjEwNycsXHJcbiAgU0VDUkVUX1JFQ09WRVJZX1BIUkFTRTpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzM2MDA2MDgyNjQzMi1XaGF0LWlzLWEtU2VjcmV0LVJlY292ZXJ5LVBocmFzZS1hbmQtaG93LXRvLWtlZXAteW91ci1jcnlwdG8td2FsbGV0LXNlY3VyZScsXHJcbiAgU1BFRURVUF9DQU5DRUw6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy8zNjAwMTU0ODkyNTEtSG93LXRvLXNwZWVkLXVwLW9yLWNhbmNlbC1hLXBlbmRpbmctdHJhbnNhY3Rpb24nLFxyXG4gIFRPS0VOX1NBRkVUWV9QUkFDVElDRVM6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDAzOTg4ODM5NDUxJyxcclxuICBVTktOT1dOX05FVFdPUks6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDE3NTAwNDY2OTcxJyxcclxuICBVU0VSX0dVSURFX0NVU1RPTV9ORVRXT1JLUzpcclxuICAgICdodHRwczovL21ldGFtYXNrLnplbmRlc2suY29tL2hjL2VuLXVzL2FydGljbGVzLzQ0MDQ0MjQ2NTk5OTUnLFxyXG4gIFVTRVJfR1VJREVfREFQUFM6XHJcbiAgICAnaHR0cHM6Ly9tZXRhbWFzay56ZW5kZXNrLmNvbS9oYy9lbi11cy9hcnRpY2xlcy80NDA1NTA2MDY2MzMxLVVzZXItZ3VpZGUtRGFwcHMnLFxyXG4gIFVTRVJfR1VJREVfR0FTOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvNDQwNDYwMDE3OTIyNy1Vc2VyLUd1aWRlLUdhcycsXHJcbiAgVkVSSUZZX0NVU1RPTV9ORVRXT1JLOlxyXG4gICAgJ2h0dHBzOi8vbWV0YW1hc2suemVuZGVzay5jb20vaGMvZW4tdXMvYXJ0aWNsZXMvMzYwMDU3MTQyMzkyJyxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IFpFTkRFU0tfVVJMUztcclxuIiwiaW1wb3J0IGN1cnJlbmN5Rm9ybWF0dGVyIGZyb20gJ2N1cnJlbmN5LWZvcm1hdHRlcic7XHJcbmltcG9ydCBjdXJyZW5jaWVzIGZyb20gJ2N1cnJlbmN5LWZvcm1hdHRlci9jdXJyZW5jaWVzJztcclxuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xyXG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XHJcblxyXG5pbXBvcnQgeyB1bmNvbmZpcm1lZFRyYW5zYWN0aW9uc0NvdW50U2VsZWN0b3IgfSBmcm9tICcuLi8uLi9zZWxlY3RvcnMnO1xyXG5pbXBvcnQge1xyXG4gIGNvbnZlcnNpb25VdGlsLFxyXG4gIGFkZEN1cnJlbmNpZXMsXHJcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxyXG4gIGNvbnZlcnNpb25HcmVhdGVyVGhhbixcclxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpbmNyZWFzZUxhc3RHYXNQcmljZShsYXN0R2FzUHJpY2UpIHtcclxuICByZXR1cm4gYWRkSGV4UHJlZml4KFxyXG4gICAgbXVsdGlwbHlDdXJyZW5jaWVzKGxhc3RHYXNQcmljZSB8fCAnMHgwJywgMS4xLCB7XHJcbiAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxyXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXHJcbiAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgfSksXHJcbiAgKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGhleEdyZWF0ZXJUaGFuKGEsIGIpIHtcclxuICByZXR1cm4gY29udmVyc2lvbkdyZWF0ZXJUaGFuKFxyXG4gICAgeyB2YWx1ZTogYSwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxyXG4gICAgeyB2YWx1ZTogYiwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxyXG4gICk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRIZXhHYXNUb3RhbCh7IGdhc0xpbWl0LCBnYXNQcmljZSB9KSB7XHJcbiAgcmV0dXJuIGFkZEhleFByZWZpeChcclxuICAgIG11bHRpcGx5Q3VycmVuY2llcyhnYXNMaW1pdCB8fCAnMHgwJywgZ2FzUHJpY2UgfHwgJzB4MCcsIHtcclxuICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXHJcbiAgICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxyXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTYsXHJcbiAgICB9KSxcclxuICApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gYWRkRXRoKC4uLmFyZ3MpIHtcclxuICByZXR1cm4gYXJncy5yZWR1Y2UoKGFjYywgZXRoQW1vdW50KSA9PiB7XHJcbiAgICByZXR1cm4gYWRkQ3VycmVuY2llcyhhY2MsIGV0aEFtb3VudCwge1xyXG4gICAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcclxuICAgICAgbnVtYmVyT2ZEZWNpbWFsczogNixcclxuICAgICAgYUJhc2U6IDEwLFxyXG4gICAgICBiQmFzZTogMTAsXHJcbiAgICB9KTtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZEZpYXQoLi4uYXJncykge1xyXG4gIHJldHVybiBhcmdzLnJlZHVjZSgoYWNjLCBmaWF0QW1vdW50KSA9PiB7XHJcbiAgICByZXR1cm4gYWRkQ3VycmVuY2llcyhhY2MsIGZpYXRBbW91bnQsIHtcclxuICAgICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXHJcbiAgICAgIG51bWJlck9mRGVjaW1hbHM6IDIsXHJcbiAgICAgIGFCYXNlOiAxMCxcclxuICAgICAgYkJhc2U6IDEwLFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWx1ZUZyb21XZWlIZXgoe1xyXG4gIHZhbHVlLFxyXG4gIGZyb21DdXJyZW5jeSA9ICdFVEgnLFxyXG4gIHRvQ3VycmVuY3ksXHJcbiAgY29udmVyc2lvblJhdGUsXHJcbiAgbnVtYmVyT2ZEZWNpbWFscyxcclxuICB0b0Rlbm9taW5hdGlvbixcclxufSkge1xyXG4gIHJldHVybiBjb252ZXJzaW9uVXRpbCh2YWx1ZSwge1xyXG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcclxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxyXG4gICAgZnJvbUN1cnJlbmN5LFxyXG4gICAgdG9DdXJyZW5jeSxcclxuICAgIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcclxuICAgIHRvRGVub21pbmF0aW9uLFxyXG4gICAgY29udmVyc2lvblJhdGUsXHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkZlZSh7XHJcbiAgdmFsdWUsXHJcbiAgZnJvbUN1cnJlbmN5ID0gJ0VUSCcsXHJcbiAgdG9DdXJyZW5jeSxcclxuICBjb252ZXJzaW9uUmF0ZSxcclxuICBudW1iZXJPZkRlY2ltYWxzLFxyXG59KSB7XHJcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKHZhbHVlLCB7XHJcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdCTicsXHJcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcclxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxyXG4gICAgZnJvbUN1cnJlbmN5LFxyXG4gICAgdG9DdXJyZW5jeSxcclxuICAgIG51bWJlck9mRGVjaW1hbHMsXHJcbiAgICBjb252ZXJzaW9uUmF0ZSxcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEN1cnJlbmN5KHZhbHVlLCBjdXJyZW5jeUNvZGUpIHtcclxuICBjb25zdCB1cHBlckNhc2VDdXJyZW5jeUNvZGUgPSBjdXJyZW5jeUNvZGUudG9VcHBlckNhc2UoKTtcclxuXHJcbiAgcmV0dXJuIGN1cnJlbmNpZXMuZmluZCgoY3VycmVuY3kpID0+IGN1cnJlbmN5LmNvZGUgPT09IHVwcGVyQ2FzZUN1cnJlbmN5Q29kZSlcclxuICAgID8gY3VycmVuY3lGb3JtYXR0ZXIuZm9ybWF0KE51bWJlcih2YWx1ZSksIHtcclxuICAgICAgICBjb2RlOiB1cHBlckNhc2VDdXJyZW5jeUNvZGUsXHJcbiAgICAgICAgc3R5bGU6ICdjdXJyZW5jeScsXHJcbiAgICAgIH0pXHJcbiAgICA6IHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRva2VuVG9GaWF0KHtcclxuICB2YWx1ZSxcclxuICBmcm9tQ3VycmVuY3kgPSAnRVRIJyxcclxuICB0b0N1cnJlbmN5LFxyXG4gIGNvbnZlcnNpb25SYXRlLFxyXG4gIGNvbnRyYWN0RXhjaGFuZ2VSYXRlLFxyXG59KSB7XHJcbiAgY29uc3QgdG90YWxFeGNoYW5nZVJhdGUgPSBjb252ZXJzaW9uUmF0ZSAqIGNvbnRyYWN0RXhjaGFuZ2VSYXRlO1xyXG5cclxuICByZXR1cm4gY29udmVyc2lvblV0aWwodmFsdWUsIHtcclxuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXHJcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcclxuICAgIGZyb21DdXJyZW5jeSxcclxuICAgIHRvQ3VycmVuY3ksXHJcbiAgICBudW1iZXJPZkRlY2ltYWxzOiAyLFxyXG4gICAgY29udmVyc2lvblJhdGU6IHRvdGFsRXhjaGFuZ2VSYXRlLFxyXG4gIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaGFzVW5jb25maXJtZWRUcmFuc2FjdGlvbnMoc3RhdGUpIHtcclxuICByZXR1cm4gdW5jb25maXJtZWRUcmFuc2FjdGlvbnNDb3VudFNlbGVjdG9yKHN0YXRlKSA+IDA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSb3VuZHMgdGhlIGdpdmVuIGRlY2ltYWwgc3RyaW5nIHRvIDQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVjaW1hbFN0cmluZyAtIFRoZSBiYXNlLXRlbiBudW1iZXIgdG8gcm91bmQuXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByb3VuZGVkIG51bWJlciwgb3IgdGhlIG9yaWdpbmFsIG51bWJlciBpZiBub1xyXG4gKiByb3VuZGluZyB3YXMgbmVjZXNzYXJ5LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kRXhwb25lbnRpYWwoZGVjaW1hbFN0cmluZykge1xyXG4gIGNvbnN0IFBSRUNJU0lPTiA9IDQ7XHJcbiAgY29uc3QgYmlnTnVtYmVyVmFsdWUgPSBuZXcgQmlnTnVtYmVyKGRlY2ltYWxTdHJpbmcpO1xyXG5cclxuICAvLyBJbiBKUywgbnVtYmVycyB3aXRoIGV4cG9uZW50aWFscyBncmVhdGVyIHRoYW4gMjAgZ2V0IGRpc3BsYXllZCBhcyBhbiBleHBvbmVudGlhbC5cclxuICByZXR1cm4gYmlnTnVtYmVyVmFsdWUuZSA+IDIwXHJcbiAgICA/IGJpZ051bWJlclZhbHVlLnRvUHJlY2lzaW9uKFBSRUNJU0lPTilcclxuICAgIDogZGVjaW1hbFN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGFyZURhcHBTdWdnZXN0ZWRBbmRUeFBhcmFtR2FzRmVlc1RoZVNhbWUodHhEYXRhID0ge30pIHtcclxuICBjb25zdCB7IHR4UGFyYW1zLCBkYXBwU3VnZ2VzdGVkR2FzRmVlcyB9ID0gdHhEYXRhO1xyXG4gIGNvbnN0IHtcclxuICAgIGdhc1ByaWNlOiB0eFBhcmFtc0dhc1ByaWNlLFxyXG4gICAgbWF4RmVlUGVyR2FzOiB0eFBhcmFtc01heEZlZVBlckdhcyxcclxuICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiB0eFBhcmFtc01heFByaW9yaXR5RmVlUGVyR2FzLFxyXG4gIH0gPSB0eFBhcmFtcyB8fCB7fTtcclxuICBjb25zdCB7XHJcbiAgICBnYXNQcmljZTogZGFwcEdhc1ByaWNlLFxyXG4gICAgbWF4RmVlUGVyR2FzOiBkYXBwTWF4RmVlUGVyR2FzLFxyXG4gICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IGRhcHBNYXhQcmlvcml0eUZlZVBlckdhcyxcclxuICB9ID0gZGFwcFN1Z2dlc3RlZEdhc0ZlZXMgfHwge307XHJcblxyXG4gIGNvbnN0IHR4UGFyYW1zRG9lc05vdEhhdmVGZWVQcm9wZXJ0aWVzID1cclxuICAgICF0eFBhcmFtc0dhc1ByaWNlICYmICF0eFBhcmFtc01heEZlZVBlckdhcyAmJiAhdHhQYXJhbXNNYXhQcmlvcml0eUZlZVBlckdhcztcclxuICBjb25zdCBkYXBwRGlkTm90U3VnZ2VzdEZlZVByb3BlcnRpZXMgPVxyXG4gICAgIWRhcHBHYXNQcmljZSAmJiAhZGFwcE1heEZlZVBlckdhcyAmJiAhZGFwcE1heFByaW9yaXR5RmVlUGVyR2FzO1xyXG4gIGlmICh0eFBhcmFtc0RvZXNOb3RIYXZlRmVlUHJvcGVydGllcyB8fCBkYXBwRGlkTm90U3VnZ2VzdEZlZVByb3BlcnRpZXMpIHtcclxuICAgIHJldHVybiBmYWxzZTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHR4UGFyYW1zR2FzUHJpY2VNYXRjaGVzRGFwcFN1Z2dlc3RlZEdhc1ByaWNlID1cclxuICAgIHR4UGFyYW1zR2FzUHJpY2UgJiYgdHhQYXJhbXNHYXNQcmljZSA9PT0gZGFwcEdhc1ByaWNlO1xyXG4gIGNvbnN0IHR4UGFyYW1zRUlQMTU1OUZlZXNNYXRjaERhcHBTdWdnZXN0ZWRHYXNQcmljZSA9IFtcclxuICAgIHR4UGFyYW1zTWF4RmVlUGVyR2FzLFxyXG4gICAgdHhQYXJhbXNNYXhQcmlvcml0eUZlZVBlckdhcyxcclxuICBdLmV2ZXJ5KChmZWUpID0+IGZlZSA9PT0gZGFwcEdhc1ByaWNlKTtcclxuICBjb25zdCB0eFBhcmFtc0VJUDE1NTlGZWVzTWF0Y2hEYXBwU3VnZ2VzdGVkRUlQMTU1OUZlZXMgPVxyXG4gICAgdHhQYXJhbXNNYXhGZWVQZXJHYXMgJiZcclxuICAgIHR4UGFyYW1zTWF4RmVlUGVyR2FzID09PSBkYXBwTWF4RmVlUGVyR2FzICYmXHJcbiAgICB0eFBhcmFtc01heFByaW9yaXR5RmVlUGVyR2FzID09PSBkYXBwTWF4UHJpb3JpdHlGZWVQZXJHYXM7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICB0eFBhcmFtc0dhc1ByaWNlTWF0Y2hlc0RhcHBTdWdnZXN0ZWRHYXNQcmljZSB8fFxyXG4gICAgdHhQYXJhbXNFSVAxNTU5RmVlc01hdGNoRGFwcFN1Z2dlc3RlZEdhc1ByaWNlIHx8XHJcbiAgICB0eFBhcmFtc0VJUDE1NTlGZWVzTWF0Y2hEYXBwU3VnZ2VzdGVkRUlQMTU1OUZlZXNcclxuICApO1xyXG59XHJcbiIsImltcG9ydCB7IEVUSCwgR1dFSSwgV0VJIH0gZnJvbSAnLi4vY29uc3RhbnRzL2NvbW1vbic7XG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XG5pbXBvcnQge1xuICBjb252ZXJzaW9uVXRpbCxcbiAgYWRkQ3VycmVuY2llcyxcbiAgc3VidHJhY3RDdXJyZW5jaWVzLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb252ZXJzaW9uLnV0aWxzJztcbmltcG9ydCB7IGZvcm1hdEN1cnJlbmN5IH0gZnJvbSAnLi9jb25maXJtLXR4LnV0aWwnO1xuXG5leHBvcnQgZnVuY3Rpb24gYm5Ub0hleChpbnB1dEJuKSB7XG4gIHJldHVybiBhZGRIZXhQcmVmaXgoaW5wdXRCbi50b1N0cmluZygxNikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXRoQ29udmVyc2lvbkZyb21XZWlIZXgoe1xuICB2YWx1ZSxcbiAgZnJvbUN1cnJlbmN5ID0gRVRILFxuICBjb252ZXJzaW9uUmF0ZSxcbiAgbnVtYmVyT2ZEZWNpbWFscyA9IDYsXG59KSB7XG4gIGNvbnN0IGRlbm9taW5hdGlvbnMgPSBbZnJvbUN1cnJlbmN5LCBHV0VJLCBXRUldO1xuXG4gIGxldCBub25aZXJvRGVub21pbmF0aW9uO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVub21pbmF0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gZ2V0VmFsdWVGcm9tV2VpSGV4KHtcbiAgICAgIHZhbHVlLFxuICAgICAgY29udmVyc2lvblJhdGUsXG4gICAgICBmcm9tQ3VycmVuY3ksXG4gICAgICB0b0N1cnJlbmN5OiBmcm9tQ3VycmVuY3ksXG4gICAgICBudW1iZXJPZkRlY2ltYWxzLFxuICAgICAgdG9EZW5vbWluYXRpb246IGRlbm9taW5hdGlvbnNbaV0sXG4gICAgfSk7XG5cbiAgICBpZiAoY29udmVydGVkVmFsdWUgIT09ICcwJyB8fCBpID09PSBkZW5vbWluYXRpb25zLmxlbmd0aCAtIDEpIHtcbiAgICAgIG5vblplcm9EZW5vbWluYXRpb24gPSBgJHtjb252ZXJ0ZWRWYWx1ZX0gJHtkZW5vbWluYXRpb25zW2ldfWA7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9uWmVyb0Rlbm9taW5hdGlvbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbHVlRnJvbVdlaUhleCh7XG4gIHZhbHVlLFxuICBmcm9tQ3VycmVuY3kgPSBFVEgsXG4gIHRvQ3VycmVuY3ksXG4gIGNvbnZlcnNpb25SYXRlLFxuICBudW1iZXJPZkRlY2ltYWxzLFxuICB0b0Rlbm9taW5hdGlvbixcbn0pIHtcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKHZhbHVlLCB7XG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcbiAgICBmcm9tQ3VycmVuY3ksXG4gICAgdG9DdXJyZW5jeSxcbiAgICBudW1iZXJPZkRlY2ltYWxzLFxuICAgIGZyb21EZW5vbWluYXRpb246IFdFSSxcbiAgICB0b0Rlbm9taW5hdGlvbixcbiAgICBjb252ZXJzaW9uUmF0ZSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWlIZXhGcm9tRGVjaW1hbFZhbHVlKHtcbiAgdmFsdWUsXG4gIGZyb21DdXJyZW5jeSxcbiAgY29udmVyc2lvblJhdGUsXG4gIGZyb21EZW5vbWluYXRpb24sXG4gIGludmVydENvbnZlcnNpb25SYXRlLFxufSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwodmFsdWUsIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIHRvQ3VycmVuY3k6IEVUSCxcbiAgICBmcm9tQ3VycmVuY3ksXG4gICAgY29udmVyc2lvblJhdGUsXG4gICAgaW52ZXJ0Q29udmVyc2lvblJhdGUsXG4gICAgZnJvbURlbm9taW5hdGlvbixcbiAgICB0b0Rlbm9taW5hdGlvbjogV0VJLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEhleFdFSXNUb0RlYyhhSGV4V0VJLCBiSGV4V0VJKSB7XG4gIHJldHVybiBhZGRDdXJyZW5jaWVzKGFIZXhXRUksIGJIZXhXRUksIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3RIZXhXRUlzVG9EZWMoYUhleFdFSSwgYkhleFdFSSkge1xuICByZXR1cm4gc3VidHJhY3RDdXJyZW5jaWVzKGFIZXhXRUksIGJIZXhXRUksIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjRXRoVG9Db252ZXJ0ZWRDdXJyZW5jeShcbiAgZXRoVG90YWwsXG4gIGNvbnZlcnRlZEN1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbikge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoZXRoVG90YWwsIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIGZyb21DdXJyZW5jeTogJ0VUSCcsXG4gICAgdG9DdXJyZW5jeTogY29udmVydGVkQ3VycmVuY3ksXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogMixcbiAgICBjb252ZXJzaW9uUmF0ZSxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNHV0VJVG9IZXhXRUkoZGVjR1dFSSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoZGVjR1dFSSwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ0dXRUknLFxuICAgIHRvRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNFVEhUb0RlY1dFSShkZWNFdGgpIHtcbiAgcmV0dXJuIGNvbnZlcnNpb25VdGlsKGRlY0V0aCwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgdG9OdW1lcmljQmFzZTogJ2RlYycsXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ0VUSCcsXG4gICAgdG9EZW5vbWluYXRpb246ICdXRUknLFxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhleFdFSVRvRGVjRVRIKGhleFdFSSkge1xuICByZXR1cm4gY29udmVyc2lvblV0aWwoaGV4V0VJLCB7XG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICB0b051bWVyaWNCYXNlOiAnZGVjJyxcbiAgICBmcm9tRGVub21pbmF0aW9uOiAnV0VJJyxcbiAgICB0b0Rlbm9taW5hdGlvbjogJ0VUSCcsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjV0VJVG9EZWNFVEgoaGV4V0VJKSB7XG4gIHJldHVybiBjb252ZXJzaW9uVXRpbChoZXhXRUksIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIGZyb21EZW5vbWluYXRpb246ICdXRUknLFxuICAgIHRvRGVub21pbmF0aW9uOiAnRVRIJyxcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRIZXhlcyhhSGV4V0VJLCBiSGV4V0VJKSB7XG4gIHJldHVybiBhZGRDdXJyZW5jaWVzKGFIZXhXRUksIGJIZXhXRUksIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIG51bWJlck9mRGVjaW1hbHM6IDYsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VidHJhY3RIZXhlcyhhSGV4V0VJLCBiSGV4V0VJKSB7XG4gIHJldHVybiBzdWJ0cmFjdEN1cnJlbmNpZXMoYUhleFdFSSwgYkhleFdFSSwge1xuICAgIGFCYXNlOiAxNixcbiAgICBiQmFzZTogMTYsXG4gICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogNixcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1IZXhXRUlzKGhleFdFSXMpIHtcbiAgcmV0dXJuIGhleFdFSXMuZmlsdGVyKEJvb2xlYW4pLnJlZHVjZShhZGRIZXhlcyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdW1IZXhXRUlzVG9VbmZvcm1hdHRlZEZpYXQoXG4gIGhleFdFSXMsXG4gIGNvbnZlcnRlZEN1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbikge1xuICBjb25zdCBoZXhXRUlzU3VtID0gc3VtSGV4V0VJcyhoZXhXRUlzKTtcbiAgY29uc3QgY29udmVydGVkVG90YWwgPSBkZWNFdGhUb0NvbnZlcnRlZEN1cnJlbmN5KFxuICAgIGdldFZhbHVlRnJvbVdlaUhleCh7XG4gICAgICB2YWx1ZTogaGV4V0VJc1N1bSxcbiAgICAgIHRvQ3VycmVuY3k6ICdFVEgnLFxuICAgICAgbnVtYmVyT2ZEZWNpbWFsczogNCxcbiAgICB9KSxcbiAgICBjb252ZXJ0ZWRDdXJyZW5jeSxcbiAgICBjb252ZXJzaW9uUmF0ZSxcbiAgKTtcbiAgcmV0dXJuIGNvbnZlcnRlZFRvdGFsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3VtSGV4V0VJc1RvUmVuZGVyYWJsZUZpYXQoXG4gIGhleFdFSXMsXG4gIGNvbnZlcnRlZEN1cnJlbmN5LFxuICBjb252ZXJzaW9uUmF0ZSxcbikge1xuICBjb25zdCBjb252ZXJ0ZWRUb3RhbCA9IHN1bUhleFdFSXNUb1VuZm9ybWF0dGVkRmlhdChcbiAgICBoZXhXRUlzLFxuICAgIGNvbnZlcnRlZEN1cnJlbmN5LFxuICAgIGNvbnZlcnNpb25SYXRlLFxuICApO1xuICByZXR1cm4gZm9ybWF0Q3VycmVuY3koY29udmVydGVkVG90YWwsIGNvbnZlcnRlZEN1cnJlbmN5KTtcbn1cbiIsIi8vIFRPRE86IFJlbmFtZSB0byByZWZsZWN0IHRoYXQgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIGZvciBtb3JlIGNhc2VzIHRoYW4gRVRILCBhbmQgdXBkYXRlIGFsbCB1c2VzLlxyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RVRIRmVlKGV0aEZlZSwgY3VycmVuY3lTeW1ib2wgPSAnRVRIJykge1xyXG4gIHJldHVybiBgJHtldGhGZWV9ICR7Y3VycmVuY3lTeW1ib2x9YDtcclxufVxyXG4iLCIvLyBjcm9zcy1icm93c2VyIGNvbm5lY3Rpb24gdG8gZXh0ZW5zaW9uIGkxOG4gQVBJXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XG5pbXBvcnQgKiBhcyBTZW50cnkgZnJvbSAnQHNlbnRyeS9icm93c2VyJztcbmltcG9ydCBnZXRGZXRjaFdpdGhUaW1lb3V0IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2ZldGNoLXdpdGgtdGltZW91dCc7XG5cbmNvbnN0IGZldGNoV2l0aFRpbWVvdXQgPSBnZXRGZXRjaFdpdGhUaW1lb3V0KCk7XG5cbmNvbnN0IHdhcm5lZCA9IHt9O1xuY29uc3QgbWlzc2luZ01lc3NhZ2VFcnJvcnMgPSB7fTtcbmNvbnN0IG1pc3NpbmdTdWJzdGl0dXRpb25FcnJvcnMgPSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgbG9jYWxpemVkIG1lc3NhZ2UgZm9yIHRoZSBnaXZlbiBrZXlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxlQ29kZSAtIFRoZSBjb2RlIGZvciB0aGUgY3VycmVudCBsb2NhbGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBsb2NhbGVNZXNzYWdlcyAtIFRoZSBtYXAgb2YgbWVzc2FnZXMgZm9yIHRoZSBjdXJyZW50IGxvY2FsZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIFRoZSBtZXNzYWdlIGtleVxuICogQHBhcmFtIHtzdHJpbmdbXX0gc3Vic3RpdHV0aW9ucyAtIEEgbGlzdCBvZiBtZXNzYWdlIHN1YnN0aXR1dGlvbiByZXBsYWNlbWVudHNcbiAqIEByZXR1cm5zIHtudWxsfHN0cmluZ30gVGhlIGxvY2FsaXplZCBtZXNzYWdlXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRNZXNzYWdlID0gKGxvY2FsZUNvZGUsIGxvY2FsZU1lc3NhZ2VzLCBrZXksIHN1YnN0aXR1dGlvbnMpID0+IHtcbiAgaWYgKCFsb2NhbGVNZXNzYWdlcykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghbG9jYWxlTWVzc2FnZXNba2V5XSkge1xuICAgIGlmIChsb2NhbGVDb2RlID09PSAnZW4nKSB7XG4gICAgICBpZiAoIW1pc3NpbmdNZXNzYWdlRXJyb3JzW2tleV0pIHtcbiAgICAgICAgbWlzc2luZ01lc3NhZ2VFcnJvcnNba2V5XSA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5hYmxlIHRvIGZpbmQgdmFsdWUgb2Yga2V5IFwiJHtrZXl9XCIgZm9yIGxvY2FsZSBcIiR7bG9jYWxlQ29kZX1cImAsXG4gICAgICAgICk7XG4gICAgICAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKG1pc3NpbmdNZXNzYWdlRXJyb3JzW2tleV0pO1xuICAgICAgICBsb2cuZXJyb3IobWlzc2luZ01lc3NhZ2VFcnJvcnNba2V5XSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5JTl9URVNUKSB7XG4gICAgICAgICAgdGhyb3cgbWlzc2luZ01lc3NhZ2VFcnJvcnNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXdhcm5lZFtsb2NhbGVDb2RlXSB8fCAhd2FybmVkW2xvY2FsZUNvZGVdW2tleV0pIHtcbiAgICAgIGlmICghd2FybmVkW2xvY2FsZUNvZGVdKSB7XG4gICAgICAgIHdhcm5lZFtsb2NhbGVDb2RlXSA9IHt9O1xuICAgICAgfVxuICAgICAgd2FybmVkW2xvY2FsZUNvZGVdW2tleV0gPSB0cnVlO1xuICAgICAgbG9nLndhcm4oXG4gICAgICAgIGBUcmFuc2xhdG9yIC0gVW5hYmxlIHRvIGZpbmQgdmFsdWUgb2Yga2V5IFwiJHtrZXl9XCIgZm9yIGxvY2FsZSBcIiR7bG9jYWxlQ29kZX1cImAsXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBlbnRyeSA9IGxvY2FsZU1lc3NhZ2VzW2tleV07XG4gIGxldCBwaHJhc2UgPSBlbnRyeS5tZXNzYWdlO1xuXG4gIGNvbnN0IGhhc1N1YnN0aXR1dGlvbnMgPSBCb29sZWFuKHN1YnN0aXR1dGlvbnMgJiYgc3Vic3RpdHV0aW9ucy5sZW5ndGgpO1xuICBjb25zdCBoYXNSZWFjdFN1YnN0aXR1dGlvbnMgPVxuICAgIGhhc1N1YnN0aXR1dGlvbnMgJiZcbiAgICBzdWJzdGl0dXRpb25zLnNvbWUoXG4gICAgICAoZWxlbWVudCkgPT5cbiAgICAgICAgZWxlbWVudCAhPT0gbnVsbCAmJlxuICAgICAgICAodHlwZW9mIGVsZW1lbnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdvYmplY3QnKSxcbiAgICApO1xuXG4gIC8vIHBlcmZvcm0gc3Vic3RpdHV0aW9uc1xuICBpZiAoaGFzU3Vic3RpdHV0aW9ucykge1xuICAgIGNvbnN0IHBhcnRzID0gcGhyYXNlLnNwbGl0KC8oXFwkXFxkKS9ndSk7XG5cbiAgICBjb25zdCBzdWJzdGl0dXRlZFBhcnRzID0gcGFydHMubWFwKChwYXJ0KSA9PiB7XG4gICAgICBjb25zdCBzdWJNYXRjaCA9IHBhcnQubWF0Y2goL1xcJChcXGQpL3UpO1xuICAgICAgaWYgKCFzdWJNYXRjaCkge1xuICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN1YnN0aXR1dGVJbmRleCA9IE51bWJlcihzdWJNYXRjaFsxXSkgLSAxO1xuICAgICAgaWYgKFxuICAgICAgICAoc3Vic3RpdHV0aW9uc1tzdWJzdGl0dXRlSW5kZXhdID09PSBudWxsIHx8XG4gICAgICAgICAgc3Vic3RpdHV0aW9uc1tzdWJzdGl0dXRlSW5kZXhdID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICFtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3JzW2xvY2FsZUNvZGVdPy5ba2V5XVxuICAgICAgKSB7XG4gICAgICAgIGlmICghbWlzc2luZ1N1YnN0aXR1dGlvbkVycm9yc1tsb2NhbGVDb2RlXSkge1xuICAgICAgICAgIG1pc3NpbmdTdWJzdGl0dXRpb25FcnJvcnNbbG9jYWxlQ29kZV0gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBtaXNzaW5nU3Vic3RpdHV0aW9uRXJyb3JzW2xvY2FsZUNvZGVdW2tleV0gPSB0cnVlO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcbiAgICAgICAgICBgSW5zdWZmaWNpZW50IG51bWJlciBvZiBzdWJzdGl0dXRpb25zIGZvciBrZXkgXCIke2tleX1cIiB3aXRoIGxvY2FsZSBcIiR7bG9jYWxlQ29kZX1cImAsXG4gICAgICAgICk7XG4gICAgICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgICAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKGVycm9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdWJzdGl0dXRpb25zW3N1YnN0aXR1dGVJbmRleF07XG4gICAgfSk7XG5cbiAgICBwaHJhc2UgPSBoYXNSZWFjdFN1YnN0aXR1dGlvbnMgPyAoXG4gICAgICA8c3Bhbj4ge3N1YnN0aXR1dGVkUGFydHN9IDwvc3Bhbj5cbiAgICApIDogKFxuICAgICAgc3Vic3RpdHV0ZWRQYXJ0cy5qb2luKCcnKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gcGhyYXNlO1xufTtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoTG9jYWxlKGxvY2FsZUNvZGUpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoV2l0aFRpbWVvdXQoXG4gICAgICBgLi9fbG9jYWxlcy8ke2xvY2FsZUNvZGV9L21lc3NhZ2VzLmpzb25gLFxuICAgICk7XG4gICAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cuZXJyb3IoYGZhaWxlZCB0byBmZXRjaCAke2xvY2FsZUNvZGV9IGxvY2FsZSBiZWNhdXNlIG9mICR7ZXJyb3J9YCk7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbmNvbnN0IHJlbGF0aXZlVGltZUZvcm1hdExvY2FsZURhdGEgPSBuZXcgU2V0KCk7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkUmVsYXRpdmVUaW1lRm9ybWF0TG9jYWxlRGF0YShsb2NhbGVDb2RlKSB7XG4gIGNvbnN0IGxhbmd1YWdlVGFnID0gbG9jYWxlQ29kZS5zcGxpdCgnXycpWzBdO1xuICBpZiAoXG4gICAgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQgJiZcbiAgICB0eXBlb2YgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXQuX19hZGRMb2NhbGVEYXRhID09PSAnZnVuY3Rpb24nICYmXG4gICAgIXJlbGF0aXZlVGltZUZvcm1hdExvY2FsZURhdGEuaGFzKGxhbmd1YWdlVGFnKVxuICApIHtcbiAgICBjb25zdCBsb2NhbGVEYXRhID0gYXdhaXQgZmV0Y2hSZWxhdGl2ZVRpbWVGb3JtYXREYXRhKGxhbmd1YWdlVGFnKTtcbiAgICBJbnRsLlJlbGF0aXZlVGltZUZvcm1hdC5fX2FkZExvY2FsZURhdGEobG9jYWxlRGF0YSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hSZWxhdGl2ZVRpbWVGb3JtYXREYXRhKGxhbmd1YWdlVGFnKSB7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoVGltZW91dChcbiAgICBgLi9pbnRsLyR7bGFuZ3VhZ2VUYWd9L3JlbGF0aXZlLXRpbWUtZm9ybWF0LWRhdGEuanNvbmAsXG4gICk7XG4gIHJldHVybiBhd2FpdCByZXNwb25zZS5qc29uKCk7XG59XG4iLCJpbXBvcnQge1xuICBCVVlBQkxFX0NIQUlOU19NQVAsXG4gIENIQUlOX0lEUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9uZXR3b3JrJztcblxuZXhwb3J0IGNvbnN0IGZvcm1hdE1vb25wYXlTeW1ib2wgPSAoc3ltYm9sLCBjaGFpbklkID0gQ0hBSU5fSURTLk1BSU5ORVQpID0+IHtcbiAgaWYgKCFzeW1ib2wpIHtcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9XG4gIGxldCBfc3ltYm9sID0gc3ltYm9sO1xuICBpZiAoY2hhaW5JZCA9PT0gQ0hBSU5fSURTLlBPTFlHT04gfHwgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLkJTQykge1xuICAgIF9zeW1ib2wgPSBgJHtfc3ltYm9sfV8ke0JVWUFCTEVfQ0hBSU5TX01BUD8uW1xuICAgICAgY2hhaW5JZFxuICAgIF0/Lm5ldHdvcmsudG9VcHBlckNhc2UoKX1gO1xuICB9IGVsc2UgaWYgKGNoYWluSWQgPT09IENIQUlOX0lEUy5BVkFMQU5DSEUpIHtcbiAgICBfc3ltYm9sID0gYCR7X3N5bWJvbH1fQ0NIQUlOYDtcbiAgfVxuICByZXR1cm4gX3N5bWJvbDtcbn07XG4iLCJpbXBvcnQgeyBvbWl0IH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCB7IEJOIH0gZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCBDb21tb24sIHsgQ2hhaW4sIEhhcmRmb3JrIH0gZnJvbSAnQGV0aGVyZXVtanMvY29tbW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uRmFjdG9yeSB9IGZyb20gJ0BldGhlcmV1bWpzL3R4JztcbmltcG9ydCB7IHN0cmlwSGV4UHJlZml4IH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvaGV4c3RyaW5nLXV0aWxzJztcblxuZnVuY3Rpb24gYnVpbGRUeFBhcmFtcyh0eE1ldGEpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5vbWl0KHR4TWV0YS50eFBhcmFtcywgJ2dhcycpLFxuICAgIGdhc0xpbWl0OiB0eE1ldGEudHhQYXJhbXMuZ2FzLFxuICB9O1xufVxuXG5mdW5jdGlvbiBidWlsZFRyYW5zYWN0aW9uQ29tbW9uKHR4TWV0YSkge1xuICAvLyBUaGlzIHByb2R1Y2VzIGEgdHJhbnNhY3Rpb24gd2hvc2UgaW5mb3JtYXRpb24gZG9lcyBub3QgY29tcGxldGVseSBtYXRjaCBhblxuICAvLyBPcHRpbWlzbSB0cmFuc2FjdGlvbiDigJQgZm9yIGluc3RhbmNlLCBERUZBVUxUX0NIQUlOIGlzIHN0aWxsICdtYWlubmV0JyBhbmRcbiAgLy8gZ2VuZXNpcyBwb2ludHMgdG8gdGhlIG1haW5uZXQgZ2VuZXNpcywgbm90IHRoZSBPcHRpbWlzbSBnZW5lc2lzIOKAlCBidXRcbiAgLy8gY29uc2lkZXJpbmcgdGhhdCBhbGwgd2Ugd2FudCB0byBkbyBpcyBzZXJpYWxpemUgYSB0cmFuc2FjdGlvbiwgdGhpcyB3b3Jrc1xuICAvLyBmaW5lIGZvciBvdXIgdXNlIGNhc2UuXG4gIHJldHVybiBDb21tb24uZm9yQ3VzdG9tQ2hhaW4oQ2hhaW4uTWFpbm5ldCwge1xuICAgIGNoYWluSWQ6IG5ldyBCTihzdHJpcEhleFByZWZpeCh0eE1ldGEuY2hhaW5JZCksIDE2KSxcbiAgICBuZXR3b3JrSWQ6IG5ldyBCTih0eE1ldGEubWV0YW1hc2tOZXR3b3JrSWQsIDEwKSxcbiAgICAvLyBPcHRpbWlzbSBvbmx5IHN1cHBvcnRzIHR5cGUtMCB0cmFuc2FjdGlvbnM7IGl0IGRvZXMgbm90IHN1cHBvcnQgYW55IG9mXG4gICAgLy8gdGhlIG5ld2VyIEVJUHMgc2luY2UgRUlQLTE1NS4gU291cmNlOlxuICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0tb3B0aW1pc20vb3B0aW1pc20vYmxvYi9kZXZlbG9wL3NwZWNzL2wyZ2V0aC90cmFuc2FjdGlvbi10eXBlcy5tZD5cbiAgICBkZWZhdWx0SGFyZGZvcms6IEhhcmRmb3JrLlNwdXJpb3VzRHJhZ29uLFxuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYnVpbGRVbnNlcmlhbGl6ZWRUcmFuc2FjdGlvbih0eE1ldGEpIHtcbiAgY29uc3QgdHhQYXJhbXMgPSBidWlsZFR4UGFyYW1zKHR4TWV0YSk7XG4gIGNvbnN0IGNvbW1vbiA9IGJ1aWxkVHJhbnNhY3Rpb25Db21tb24odHhNZXRhKTtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uRmFjdG9yeS5mcm9tVHhEYXRhKHR4UGFyYW1zLCB7IGNvbW1vbiB9KTtcbn1cbiIsImltcG9ydCAqIGFzIGV0aGVycyBmcm9tICdldGhlcnMnO1xyXG5pbXBvcnQgeyBnZXRDb250cmFjdEZhY3RvcnkgfSBmcm9tICdAZXRoLW9wdGltaXNtL2NvbnRyYWN0cy9kaXN0L2NvbnRyYWN0LWRlZnMnO1xyXG5pbXBvcnQgeyBwcmVkZXBsb3lzIH0gZnJvbSAnQGV0aC1vcHRpbWlzbS9jb250cmFjdHMvZGlzdC9wcmVkZXBsb3lzJztcclxuaW1wb3J0IGJ1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24gZnJvbSAnLi9idWlsZFVuc2VyaWFsaXplZFRyYW5zYWN0aW9uJztcclxuXHJcbi8vIFRoZSBjb2RlIGluIHRoaXMgZmlsZSBpcyBsYXJnZWx5IGRyYXduIGZyb20gaHR0cHM6Ly9jb21tdW5pdHkub3B0aW1pc20uaW8vZG9jcy9kZXZlbG9wZXJzL2wyL25ldy1mZWVzLmh0bWwjZm9yLWZyb250ZW5kLWFuZC13YWxsZXQtZGV2ZWxvcGVyc1xyXG5cclxuZnVuY3Rpb24gYnVpbGRPVk1HYXNQcmljZU9yYWNsZUNvbnRyYWN0KGV0aCkge1xyXG4gIGNvbnN0IE9WTUdhc1ByaWNlT3JhY2xlID0gZ2V0Q29udHJhY3RGYWN0b3J5KCdPVk1fR2FzUHJpY2VPcmFjbGUnKS5hdHRhY2goXHJcbiAgICBwcmVkZXBsb3lzLk9WTV9HYXNQcmljZU9yYWNsZSxcclxuICApO1xyXG4gIGNvbnN0IGFiaSA9IEpTT04ucGFyc2UoXHJcbiAgICBPVk1HYXNQcmljZU9yYWNsZS5pbnRlcmZhY2UuZm9ybWF0KGV0aGVycy51dGlscy5Gb3JtYXRUeXBlcy5qc29uKSxcclxuICApO1xyXG4gIHJldHVybiBldGguY29udHJhY3QoYWJpKS5hdChPVk1HYXNQcmljZU9yYWNsZS5hZGRyZXNzKTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hFc3RpbWF0ZWRMMUZlZShldGgsIHR4TWV0YSkge1xyXG4gIGNvbnN0IGNvbnRyYWN0ID0gYnVpbGRPVk1HYXNQcmljZU9yYWNsZUNvbnRyYWN0KGV0aCk7XHJcbiAgY29uc3Qgc2VyaWFsaXplZFRyYW5zYWN0aW9uID1cclxuICAgIGJ1aWxkVW5zZXJpYWxpemVkVHJhbnNhY3Rpb24odHhNZXRhKS5zZXJpYWxpemUoKTtcclxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBjb250cmFjdC5nZXRMMUZlZShzZXJpYWxpemVkVHJhbnNhY3Rpb24pO1xyXG4gIHJldHVybiByZXN1bHQ/LlswXT8udG9TdHJpbmcoMTYpO1xyXG59XHJcbiIsImltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuaW1wb3J0IHtcbiAgY29udmVyc2lvblV0aWwsXG4gIG11bHRpcGx5Q3VycmVuY2llcyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyBnZXRUb2tlblN0YW5kYXJkQW5kRGV0YWlscyB9IGZyb20gJy4uLy4uL3N0b3JlL2FjdGlvbnMnO1xuaW1wb3J0IHsgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL3N0cmluZy11dGlscyc7XG5pbXBvcnQgeyBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XG5pbXBvcnQgeyBFUkMyMCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgZ2V0VG9rZW5WYWx1ZVBhcmFtIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9tZXRhbWFzay1jb250cm9sbGVyLXV0aWxzJztcbmltcG9ydCB7IGNhbGNUb2tlbkFtb3VudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZm9ybWF0Q3VycmVuY3kgfSBmcm9tICcuL2NvbmZpcm0tdHgudXRpbCc7XG5cbmNvbnN0IERFRkFVTFRfU1lNQk9MID0gJyc7XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN5bWJvbEZyb21Db250cmFjdCh0b2tlbkFkZHJlc3MpIHtcbiAgY29uc3QgdG9rZW4gPSB1dGlsLmdldENvbnRyYWN0QXRBZGRyZXNzKHRva2VuQWRkcmVzcyk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9rZW4uc3ltYm9sKCk7XG4gICAgcmV0dXJuIHJlc3VsdFswXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cud2FybihcbiAgICAgIGBzeW1ib2woKSBjYWxsIGZvciB0b2tlbiBhdCBhZGRyZXNzICR7dG9rZW5BZGRyZXNzfSByZXN1bHRlZCBpbiBlcnJvcjpgLFxuICAgICAgZXJyb3IsXG4gICAgKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldERlY2ltYWxzRnJvbUNvbnRyYWN0KHRva2VuQWRkcmVzcykge1xuICBjb25zdCB0b2tlbiA9IHV0aWwuZ2V0Q29udHJhY3RBdEFkZHJlc3ModG9rZW5BZGRyZXNzKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRva2VuLmRlY2ltYWxzKCk7XG4gICAgY29uc3QgZGVjaW1hbHNCTiA9IHJlc3VsdFswXTtcbiAgICByZXR1cm4gZGVjaW1hbHNCTj8udG9TdHJpbmcoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2cud2FybihcbiAgICAgIGBkZWNpbWFscygpIGNhbGwgZm9yIHRva2VuIGF0IGFkZHJlc3MgJHt0b2tlbkFkZHJlc3N9IHJlc3VsdGVkIGluIGVycm9yOmAsXG4gICAgICBlcnJvcixcbiAgICApO1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuTWV0YWRhdGEodG9rZW5BZGRyZXNzLCB0b2tlbkxpc3QpIHtcbiAgcmV0dXJuIHRva2VuQWRkcmVzcyAmJiB0b2tlbkxpc3RbdG9rZW5BZGRyZXNzLnRvTG93ZXJDYXNlKCldO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRTeW1ib2wodG9rZW5BZGRyZXNzLCB0b2tlbkxpc3QpIHtcbiAgbGV0IHN5bWJvbCA9IGF3YWl0IGdldFN5bWJvbEZyb21Db250cmFjdCh0b2tlbkFkZHJlc3MpO1xuXG4gIGlmICghc3ltYm9sKSB7XG4gICAgY29uc3QgY29udHJhY3RNZXRhZGF0YUluZm8gPSBnZXRUb2tlbk1ldGFkYXRhKHRva2VuQWRkcmVzcywgdG9rZW5MaXN0KTtcblxuICAgIGlmIChjb250cmFjdE1ldGFkYXRhSW5mbykge1xuICAgICAgc3ltYm9sID0gY29udHJhY3RNZXRhZGF0YUluZm8uc3ltYm9sO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW1ib2w7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldERlY2ltYWxzKHRva2VuQWRkcmVzcywgdG9rZW5MaXN0KSB7XG4gIGxldCBkZWNpbWFscyA9IGF3YWl0IGdldERlY2ltYWxzRnJvbUNvbnRyYWN0KHRva2VuQWRkcmVzcyk7XG5cbiAgaWYgKCFkZWNpbWFscyB8fCBkZWNpbWFscyA9PT0gJzAnKSB7XG4gICAgY29uc3QgY29udHJhY3RNZXRhZGF0YUluZm8gPSBnZXRUb2tlbk1ldGFkYXRhKHRva2VuQWRkcmVzcywgdG9rZW5MaXN0KTtcblxuICAgIGlmIChjb250cmFjdE1ldGFkYXRhSW5mbykge1xuICAgICAgZGVjaW1hbHMgPSBjb250cmFjdE1ldGFkYXRhSW5mby5kZWNpbWFscz8udG9TdHJpbmcoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGVjaW1hbHM7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRTeW1ib2xBbmREZWNpbWFscyh0b2tlbkFkZHJlc3MsIHRva2VuTGlzdCkge1xuICBsZXQgc3ltYm9sLCBkZWNpbWFscztcblxuICB0cnkge1xuICAgIHN5bWJvbCA9IGF3YWl0IGdldFN5bWJvbCh0b2tlbkFkZHJlc3MsIHRva2VuTGlzdCk7XG4gICAgZGVjaW1hbHMgPSBhd2FpdCBnZXREZWNpbWFscyh0b2tlbkFkZHJlc3MsIHRva2VuTGlzdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgbG9nLndhcm4oXG4gICAgICBgc3ltYm9sKCkgYW5kIGRlY2ltYWwoKSBjYWxscyBmb3IgdG9rZW4gYXQgYWRkcmVzcyAke3Rva2VuQWRkcmVzc30gcmVzdWx0ZWQgaW4gZXJyb3I6YCxcbiAgICAgIGVycm9yLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHN5bWJvbDogc3ltYm9sIHx8IERFRkFVTFRfU1lNQk9MLFxuICAgIGRlY2ltYWxzLFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9rZW5JbmZvR2V0dGVyKCkge1xuICBjb25zdCB0b2tlbnMgPSB7fTtcblxuICByZXR1cm4gYXN5bmMgKGFkZHJlc3MsIHRva2VuTGlzdCkgPT4ge1xuICAgIGlmICh0b2tlbnNbYWRkcmVzc10pIHtcbiAgICAgIHJldHVybiB0b2tlbnNbYWRkcmVzc107XG4gICAgfVxuXG4gICAgdG9rZW5zW2FkZHJlc3NdID0gYXdhaXQgZ2V0U3ltYm9sQW5kRGVjaW1hbHMoYWRkcmVzcywgdG9rZW5MaXN0KTtcblxuICAgIHJldHVybiB0b2tlbnNbYWRkcmVzc107XG4gIH07XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZ2V0IHRoZSBhZGRyZXNzIHBhcmFtZXRlciBvZiB0aGUgZ2l2ZW4gdG9rZW4gdHJhbnNhY3Rpb24gZGF0YVxuICogKGkuZS4gZnVuY3Rpb24gY2FsbCkgcGVyIHRoZSBIdW1hbiBTdGFuZGFyZCBUb2tlbiBBQkksIGluIHRoZSBmb2xsb3dpbmdcbiAqIG9yZGVyOlxuICogICAtIFRoZSAnX3RvJyBwYXJhbWV0ZXIsIGlmIHByZXNlbnRcbiAqICAgLSBUaGUgZmlyc3QgcGFyYW1ldGVyLCBpZiBwcmVzZW50XG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRva2VuRGF0YSAtIGV0aGVycyBJbnRlcmZhY2UgdG9rZW4gZGF0YS5cbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9IEEgbG93ZXJjYXNlIGFkZHJlc3Mgc3RyaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5BZGRyZXNzUGFyYW0odG9rZW5EYXRhID0ge30pIHtcbiAgY29uc3QgdmFsdWUgPVxuICAgIHRva2VuRGF0YT8uYXJncz8uX3RvIHx8IHRva2VuRGF0YT8uYXJncz8udG8gfHwgdG9rZW5EYXRhPy5hcmdzPy5bMF07XG4gIHJldHVybiB2YWx1ZT8udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlICdfdmFsdWUnIHBhcmFtZXRlciBvZiB0aGUgZ2l2ZW4gdG9rZW4gdHJhbnNhY3Rpb24gZGF0YVxuICogKGkuZSBmdW5jdGlvbiBjYWxsKSBwZXIgdGhlIEh1bWFuIFN0YW5kYXJkIFRva2VuIEFCSSwgaWYgcHJlc2VudC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdG9rZW5EYXRhIC0gZXRoZXJzIEludGVyZmFjZSB0b2tlbiBkYXRhLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gQSBkZWNpbWFsIHN0cmluZyB2YWx1ZS5cbiAqL1xuLyoqXG4gKiBHZXRzIGVpdGhlciB0aGUgJ190b2tlbklkJyBwYXJhbWV0ZXIgb3IgdGhlICdpZCcgcGFyYW0gb2YgdGhlIHBhc3NlZCB0b2tlbiB0cmFuc2FjdGlvbiBkYXRhLixcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2VkIHRva2VuSWQgdmFsdWVzIHJldHVybmVkIGJ5IGBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGFgIGFzIGRlZmluZWRcbiAqIGluIHRoZSBFUkM3MjEgYW5kIEVSQzExNTUgQUJJcyBmcm9tIG1ldGFtYXNrLWV0aC1hYmlzIChodHRwczovL2dpdGh1Yi5jb20vTWV0YU1hc2svbWV0YW1hc2stZXRoLWFiaXMvdHJlZS9tYWluL3NyYy9hYmlzKVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbkRhdGEgLSBldGhlcnMgSW50ZXJmYWNlIHRva2VuIGRhdGEuXG4gKiBAcmV0dXJucyB7c3RyaW5nIHwgdW5kZWZpbmVkfSBBIGRlY2ltYWwgc3RyaW5nIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5JZFBhcmFtKHRva2VuRGF0YSA9IHt9KSB7XG4gIHJldHVybiAoXG4gICAgdG9rZW5EYXRhPy5hcmdzPy5fdG9rZW5JZD8udG9TdHJpbmcoKSA/PyB0b2tlbkRhdGE/LmFyZ3M/LmlkPy50b1N0cmluZygpXG4gICk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgJ19hcHByb3ZlZCcgcGFyYW1ldGVyIG9mIHRoZSBnaXZlbiB0b2tlbiB0cmFuc2FjdGlvbiBkYXRhXG4gKiAoaS5lIGZ1bmN0aW9uIGNhbGwpIHBlciB0aGUgSHVtYW4gU3RhbmRhcmQgVG9rZW4gQUJJLCBpZiBwcmVzZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0b2tlbkRhdGEgLSBldGhlcnMgSW50ZXJmYWNlIHRva2VuIGRhdGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkIHRvIGFwcHJvdmUgb3IgcmV2b2tlIGFjY2Vzcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRva2VuQXBwcm92ZWRQYXJhbSh0b2tlbkRhdGEgPSB7fSkge1xuICByZXR1cm4gdG9rZW5EYXRhPy5hcmdzPy5fYXBwcm92ZWQ7XG59XG5cbi8qKlxuICogR2V0IHRoZSB0b2tlbiBiYWxhbmNlIGNvbnZlcnRlZCB0byBmaWF0IGFuZCBvcHRpb25hbGx5IGZvcm1hdHRlZCBmb3IgZGlzcGxheVxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29udHJhY3RFeGNoYW5nZVJhdGVdIC0gVGhlIGV4Y2hhbmdlIHJhdGUgYmV0d2VlbiB0aGUgY3VycmVudCB0b2tlbiBhbmQgdGhlIG5hdGl2ZSBjdXJyZW5jeVxuICogQHBhcmFtIHtudW1iZXJ9IGNvbnZlcnNpb25SYXRlIC0gVGhlIGV4Y2hhbmdlIHJhdGUgYmV0d2VlbiB0aGUgY3VycmVudCBmaWF0IGN1cnJlbmN5IGFuZCB0aGUgbmF0aXZlIGN1cnJlbmN5XG4gKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudEN1cnJlbmN5IC0gVGhlIGN1cnJlbmN5IGNvZGUgZm9yIHRoZSB1c2VyJ3MgY2hvc2VuIGZpYXQgY3VycmVuY3lcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdG9rZW5BbW91bnRdIC0gVGhlIGN1cnJlbnQgdG9rZW4gYmFsYW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IFt0b2tlblN5bWJvbF0gLSBUaGUgdG9rZW4gc3ltYm9sXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JtYXR0ZWRdIC0gV2hldGhlciB0aGUgcmV0dXJuIHZhbHVlIHNob3VsZCBiZSBmb3JtYXR0ZWQgb3Igbm90XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtoaWRlQ3VycmVuY3lTeW1ib2xdIC0gZXhjbHVkZXMgdGhlIGN1cnJlbmN5IHN5bWJvbCBpbiB0aGUgcmVzdWx0IGlmIHRydWVcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBUaGUgdG9rZW4gYW1vdW50IGluIHRoZSB1c2VyJ3MgY2hvc2VuIGZpYXQgY3VycmVuY3ksIG9wdGlvbmFsbHkgZm9ybWF0dGVkIGFuZCBsb2NhbGl6ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9rZW5GaWF0QW1vdW50KFxuICBjb250cmFjdEV4Y2hhbmdlUmF0ZSxcbiAgY29udmVyc2lvblJhdGUsXG4gIGN1cnJlbnRDdXJyZW5jeSxcbiAgdG9rZW5BbW91bnQsXG4gIHRva2VuU3ltYm9sLFxuICBmb3JtYXR0ZWQgPSB0cnVlLFxuICBoaWRlQ3VycmVuY3lTeW1ib2wgPSBmYWxzZSxcbikge1xuICAvLyBJZiB0aGUgY29udmVyc2lvblJhdGUgaXMgMCAoaS5lLiB1bmtub3duKSBvciB0aGUgY29udHJhY3QgZXhjaGFuZ2UgcmF0ZVxuICAvLyBpcyBjdXJyZW50bHkgdW5rbm93biwgdGhlIGZpYXQgYW1vdW50IGNhbm5vdCBiZSBjYWxjdWxhdGVkIHNvIGl0IGlzIG5vdFxuICAvLyBzaG93biB0byB0aGUgdXNlclxuICBpZiAoXG4gICAgY29udmVyc2lvblJhdGUgPD0gMCB8fFxuICAgICFjb250cmFjdEV4Y2hhbmdlUmF0ZSB8fFxuICAgIHRva2VuQW1vdW50ID09PSB1bmRlZmluZWRcbiAgKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIGNvbnN0IGN1cnJlbnRUb2tlblRvRmlhdFJhdGUgPSBtdWx0aXBseUN1cnJlbmNpZXMoXG4gICAgY29udHJhY3RFeGNoYW5nZVJhdGUsXG4gICAgY29udmVyc2lvblJhdGUsXG4gICAge1xuICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTAsXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgfSxcbiAgKTtcbiAgY29uc3QgY3VycmVudFRva2VuSW5GaWF0ID0gY29udmVyc2lvblV0aWwodG9rZW5BbW91bnQsIHtcbiAgICBmcm9tTnVtZXJpY0Jhc2U6ICdkZWMnLFxuICAgIGZyb21DdXJyZW5jeTogdG9rZW5TeW1ib2wsXG4gICAgdG9DdXJyZW5jeTogY3VycmVudEN1cnJlbmN5LnRvVXBwZXJDYXNlKCksXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogMixcbiAgICBjb252ZXJzaW9uUmF0ZTogY3VycmVudFRva2VuVG9GaWF0UmF0ZSxcbiAgfSk7XG4gIGxldCByZXN1bHQ7XG4gIGlmIChoaWRlQ3VycmVuY3lTeW1ib2wpIHtcbiAgICByZXN1bHQgPSBmb3JtYXRDdXJyZW5jeShjdXJyZW50VG9rZW5JbkZpYXQsIGN1cnJlbnRDdXJyZW5jeSk7XG4gIH0gZWxzZSBpZiAoZm9ybWF0dGVkKSB7XG4gICAgcmVzdWx0ID0gYCR7Zm9ybWF0Q3VycmVuY3koXG4gICAgICBjdXJyZW50VG9rZW5JbkZpYXQsXG4gICAgICBjdXJyZW50Q3VycmVuY3ksXG4gICAgKX0gJHtjdXJyZW50Q3VycmVuY3kudG9VcHBlckNhc2UoKX1gO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IGN1cnJlbnRUb2tlbkluRmlhdDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXNzZXREZXRhaWxzKFxuICB0b2tlbkFkZHJlc3MsXG4gIGN1cnJlbnRVc2VyQWRkcmVzcyxcbiAgdHJhbnNhY3Rpb25EYXRhLFxuICBleGlzdGluZ0NvbGxlY3RpYmxlcyxcbikge1xuICBjb25zdCB0b2tlbkRhdGEgPSBwYXJzZVN0YW5kYXJkVG9rZW5UcmFuc2FjdGlvbkRhdGEodHJhbnNhY3Rpb25EYXRhKTtcbiAgaWYgKCF0b2tlbkRhdGEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZXRlY3QgdmFsaWQgdG9rZW4gZGF0YScpO1xuICB9XG5cbiAgLy8gU29tZXRpbWVzIHRoZSB0b2tlbklkIHZhbHVlIGlzIHBhcnNlZCBhcyBcIl92YWx1ZVwiIHBhcmFtLiBOb3Qgc2VlaW5nIHRoaXMgb2Z0ZW4gYW55IG1vcmUsIGJ1dCBzdGlsbCBvY2Nhc2lvbmFsbHk6XG4gIC8vIGkuZS4gY2FsbCBhcHByb3ZlKCkgb24gQkFZQyBjb250cmFjdCAtIGh0dHBzOi8vZXRoZXJzY2FuLmlvL3Rva2VuLzB4YmM0Y2EwZWRhNzY0N2E4YWI3YzIwNjFjMmUxMThhMThhOTM2ZjEzZCN3cml0ZUNvbnRyYWN0LCBhbmQgdG9rZW5JZCBzaG93cyB1cCBhcyBfdmFsdWUsXG4gIC8vIG5vdCBzdXJlIHdoeSBzaW5jZSBpdCBkb2Vzbid0IG1hdGNoIHRoZSBFUkM3MjEgQUJJIHNwZWMgd2UgdXNlIHRvIHBhcnNlIHRoZXNlIHRyYW5zYWN0aW9ucyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9NZXRhTWFzay9tZXRhbWFzay1ldGgtYWJpcy9ibG9iL2QwNDc0MzA4YTI4OGY5MjUyNTk3YjdjOTNhM2E4ZGVhYWQxOWUxYjIvc3JjL2FiaXMvYWJpRVJDNzIxLnRzI0w2Mi5cbiAgbGV0IHRva2VuSWQgPVxuICAgIGdldFRva2VuSWRQYXJhbSh0b2tlbkRhdGEpPy50b1N0cmluZygpID8/IGdldFRva2VuVmFsdWVQYXJhbSh0b2tlbkRhdGEpO1xuXG4gIGNvbnN0IHRvQWRkcmVzcyA9IGdldFRva2VuQWRkcmVzc1BhcmFtKHRva2VuRGF0YSk7XG5cbiAgbGV0IHRva2VuRGV0YWlscztcblxuICAvLyBpZiBhIHRva2VuSWQgaXMgcHJlc2VudCBjaGVjayBpZiB0aGVyZSBpcyBhIGNvbGxlY3RpYmxlIGluIHN0YXRlIG1hdGNoaW5nIHRoZSBhZGRyZXNzL3Rva2VuSWRcbiAgLy8gYW5kIGF2b2lkIHVubmVjZXNzYXJ5IG5ldHdvcmsgcmVxdWVzdHMgdG8gcXVlcnkgdG9rZW4gZGV0YWlscyB3ZSBhbHJlYWR5IGhhdmVcbiAgaWYgKGV4aXN0aW5nQ29sbGVjdGlibGVzPy5sZW5ndGggJiYgdG9rZW5JZCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ29sbGVjdGlibGUgPSBleGlzdGluZ0NvbGxlY3RpYmxlcy5maW5kKFxuICAgICAgKHsgYWRkcmVzcywgdG9rZW5JZDogX3Rva2VuSWQgfSkgPT5cbiAgICAgICAgaXNFcXVhbENhc2VJbnNlbnNpdGl2ZSh0b2tlbkFkZHJlc3MsIGFkZHJlc3MpICYmIF90b2tlbklkID09PSB0b2tlbklkLFxuICAgICk7XG5cbiAgICBpZiAoZXhpc3RpbmdDb2xsZWN0aWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9BZGRyZXNzLFxuICAgICAgICAuLi5leGlzdGluZ0NvbGxlY3RpYmxlLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHRva2VuRGV0YWlscyA9IGF3YWl0IGdldFRva2VuU3RhbmRhcmRBbmREZXRhaWxzKFxuICAgICAgdG9rZW5BZGRyZXNzLFxuICAgICAgY3VycmVudFVzZXJBZGRyZXNzLFxuICAgICAgdG9rZW5JZCxcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy53YXJuKGVycm9yKTtcbiAgICAvLyBpZiB3ZSBjYW4ndCBkZXRlcm1pbmUgYW55IHRva2VuIHN0YW5kYXJkIG9yIGRldGFpbHMgcmV0dXJuIHRoZSBkYXRhIHdlIGNhbiBleHRyYWN0IHB1cmVseSBmcm9tIHRoZSBwYXJzZWQgdHJhbnNhY3Rpb24gZGF0YVxuICAgIHJldHVybiB7IHRvQWRkcmVzcywgdG9rZW5JZCB9O1xuICB9XG5cbiAgY29uc3QgdG9rZW5BbW91bnQgPVxuICAgIHRva2VuRGF0YSAmJlxuICAgIHRva2VuRGV0YWlscz8uZGVjaW1hbHMgJiZcbiAgICBjYWxjVG9rZW5BbW91bnQoXG4gICAgICBnZXRUb2tlblZhbHVlUGFyYW0odG9rZW5EYXRhKSxcbiAgICAgIHRva2VuRGV0YWlscz8uZGVjaW1hbHMsXG4gICAgKS50b1N0cmluZygxMCk7XG5cbiAgY29uc3QgZGVjaW1hbHMgPVxuICAgIHRva2VuRGV0YWlscz8uZGVjaW1hbHMgJiYgTnVtYmVyKHRva2VuRGV0YWlscy5kZWNpbWFscz8udG9TdHJpbmcoMTApKTtcblxuICBpZiAodG9rZW5EZXRhaWxzPy5zdGFuZGFyZCA9PT0gRVJDMjApIHtcbiAgICB0b2tlbklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gZWxzZSBpZiBub3QgYSBjb2xsZWN0aWJsZSBhbHJlYWR5IGluIHN0YXRlIG9yIHN0YW5kYXJkID09PSBFUkMyMCByZXR1cm4gdG9rZW5EZXRhaWxzIGFuZCB0b2tlbklkXG4gIHJldHVybiB7XG4gICAgdG9rZW5BbW91bnQsXG4gICAgdG9BZGRyZXNzLFxuICAgIGRlY2ltYWxzLFxuICAgIHRva2VuSWQsXG4gICAgLi4udG9rZW5EZXRhaWxzLFxuICB9O1xufVxuIiwiaW1wb3J0IHsgTWV0aG9kUmVnaXN0cnkgfSBmcm9tICdldGgtbWV0aG9kLXJlZ2lzdHJ5JztcbmltcG9ydCBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XG5pbXBvcnQge1xuICBUUkFOU0FDVElPTl9UWVBFUyxcbiAgVFJBTlNBQ1RJT05fR1JPVVBfU1RBVFVTRVMsXG4gIFRSQU5TQUNUSU9OX1NUQVRVU0VTLFxuICBUUkFOU0FDVElPTl9FTlZFTE9QRV9UWVBFUyxcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBhZGRDdXJyZW5jaWVzIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5pbXBvcnQgeyByZWFkQWRkcmVzc0FzQ29udHJhY3QgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy9jb250cmFjdC11dGlscyc7XG5pbXBvcnQgZmV0Y2hXaXRoQ2FjaGUgZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2xpYi9mZXRjaC13aXRoLWNhY2hlJztcblxuLyoqXG4gKiBAdHlwZWRlZiBFdGhlcnNDb250cmFjdENhbGxcbiAqIEB0eXBlIG9iamVjdFxuICogQHByb3BlcnR5IHthbnlbXX0gYXJncyAtIFRoZSBhcmdzL3BhcmFtcyB0byB0aGUgZnVuY3Rpb24gY2FsbC5cbiAqIEFuIGFycmF5LWxpa2Ugb2JqZWN0IHdpdGggbnVtZXJpY2FsIGFuZCBzdHJpbmcgaW5kaWNlcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHNpZ25hdHVyZSAtIFRoZSBmdW5jdGlvbiBzaWduYXR1cmUuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gc2lnaGFzaCAtIFRoZSBmdW5jdGlvbiBzaWduYXR1cmUgaGFzaC5cbiAqIEBwcm9wZXJ0eSB7RXRoZXJzQmlnTnVtYmVyfSB2YWx1ZSAtIFRoZSBFVEggdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjYWxsLlxuICogQHByb3BlcnR5IHtGdW5jdGlvbkZyYWdtZW50fSBmdW5jdGlvbkZyYWdtZW50IC0gVGhlIEV0aGVycyBmdW5jdGlvbiBmcmFnbWVudFxuICogcmVwcmVzZW50YXRpb24gb2YgdGhlIGZ1bmN0aW9uLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGdldE1ldGhvZEZyb200Qnl0ZShmb3VyQnl0ZVByZWZpeCkge1xuICBjb25zdCBmb3VyQnl0ZVJlc3BvbnNlID0gYXdhaXQgZmV0Y2hXaXRoQ2FjaGUoXG4gICAgYGh0dHBzOi8vd3d3LjRieXRlLmRpcmVjdG9yeS9hcGkvdjEvc2lnbmF0dXJlcy8/aGV4X3NpZ25hdHVyZT0ke2ZvdXJCeXRlUHJlZml4fWAsXG4gICAge1xuICAgICAgcmVmZXJyZXJQb2xpY3k6ICduby1yZWZlcnJlci13aGVuLWRvd25ncmFkZScsXG4gICAgICBib2R5OiBudWxsLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIG1vZGU6ICdjb3JzJyxcbiAgICB9LFxuICApO1xuICBmb3VyQnl0ZVJlc3BvbnNlLnJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgIHJldHVybiBuZXcgRGF0ZShhLmNyZWF0ZWRfYXQpLmdldFRpbWUoKSA8IG5ldyBEYXRlKGIuY3JlYXRlZF9hdCkuZ2V0VGltZSgpXG4gICAgICA/IC0xXG4gICAgICA6IDE7XG4gIH0pO1xuICByZXR1cm4gZm91ckJ5dGVSZXNwb25zZS5yZXN1bHRzWzBdLnRleHRfc2lnbmF0dXJlO1xufVxuXG5sZXQgcmVnaXN0cnk7XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBtZXRob2QgZGF0YSBmcm9tIHRoZSBNZXRob2RSZWdpc3RyeSBsaWJyYXJ5LCB0aGUgbWVzc2FnZSByZWdpc3RyeSBsaWJyYXJ5IGFuZCB0aGUgdG9rZW4gYWJpLCBpbiB0aGF0IG9yZGVyIG9mIHByZWZlcmVuY2VcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm91ckJ5dGVQcmVmaXggLSBUaGUgcHJlZml4IGZyb20gdGhlIG1ldGhvZCBjb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGF0YVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1ldGhvZERhdGFBc3luYyhmb3VyQnl0ZVByZWZpeCkge1xuICB0cnkge1xuICAgIGNvbnN0IGZvdXJCeXRlU2lnID0gYXdhaXQgZ2V0TWV0aG9kRnJvbTRCeXRlKGZvdXJCeXRlUHJlZml4KS5jYXRjaCgoZSkgPT4ge1xuICAgICAgbG9nLmVycm9yKGUpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG5cbiAgICBpZiAoIXJlZ2lzdHJ5KSB7XG4gICAgICByZWdpc3RyeSA9IG5ldyBNZXRob2RSZWdpc3RyeSh7IHByb3ZpZGVyOiBnbG9iYWwuZXRoZXJldW1Qcm92aWRlciB9KTtcbiAgICB9XG5cbiAgICBpZiAoIWZvdXJCeXRlU2lnKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkUmVzdWx0ID0gcmVnaXN0cnkucGFyc2UoZm91ckJ5dGVTaWcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHBhcnNlZFJlc3VsdC5uYW1lLFxuICAgICAgcGFyYW1zOiBwYXJzZWRSZXN1bHQuYXJncyxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZy5lcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBmb3VyLWJ5dGUgbWV0aG9kIHNpZ25hdHVyZSBmcm9tIGRhdGFcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIFRoZSBoZXggZGF0YSAoQGNvZGUgdHhQYXJhbXMuZGF0YSkgb2YgYSB0cmFuc2FjdGlvblxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvdXItYnl0ZSBtZXRob2Qgc2lnbmF0dXJlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRGb3VyQnl0ZVByZWZpeChkYXRhID0gJycpIHtcbiAgY29uc3QgcHJlZml4ZWREYXRhID0gYWRkSGV4UHJlZml4KGRhdGEpO1xuICBjb25zdCBmb3VyQnl0ZVByZWZpeCA9IHByZWZpeGVkRGF0YS5zbGljZSgwLCAxMCk7XG4gIHJldHVybiBmb3VyQnl0ZVByZWZpeDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbiB0cmFuc2FjdGlvbiBjYXRlZ29yeSwgcmV0dXJucyBhIGJvb2xlYW4gd2hpY2ggaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHRyYW5zYWN0aW9uIGlzIGNhbGxpbmcgYW4gZXJjMjAgdG9rZW4gbWV0aG9kXG4gKlxuICogQHBhcmFtIHtUUkFOU0FDVElPTl9UWVBFU1trZXlvZiBUUkFOU0FDVElPTl9UWVBFU119IHR5cGUgLSBUaGUgdHlwZSBvZiB0cmFuc2FjdGlvbiBiZWluZyBldmFsdWF0ZWRcbiAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSB0cmFuc2FjdGlvbiBpcyBjYWxsaW5nIGFuIGVyYzIwIHRva2VuIG1ldGhvZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlbk1ldGhvZEFjdGlvbih0eXBlKSB7XG4gIHJldHVybiBbXG4gICAgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSLFxuICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFLFxuICAgIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTCxcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfVFJBTlNGRVJfRlJPTSxcbiAgICBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NLFxuICBdLmluY2x1ZGVzKHR5cGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGF0ZXN0U3VibWl0dGVkVHhXaXRoTm9uY2UoXG4gIHRyYW5zYWN0aW9ucyA9IFtdLFxuICBub25jZSA9ICcweDAnLFxuKSB7XG4gIGlmICghdHJhbnNhY3Rpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdGlvbnMucmVkdWNlKChhY2MsIGN1cnJlbnQpID0+IHtcbiAgICBjb25zdCB7IHN1Ym1pdHRlZFRpbWUsIHR4UGFyYW1zOiB7IG5vbmNlOiBjdXJyZW50Tm9uY2UgfSA9IHt9IH0gPSBjdXJyZW50O1xuXG4gICAgaWYgKGN1cnJlbnROb25jZSA9PT0gbm9uY2UpIHtcbiAgICAgIGlmICghYWNjLnN1Ym1pdHRlZFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3VibWl0dGVkVGltZSA+IGFjYy5zdWJtaXR0ZWRUaW1lID8gY3VycmVudCA6IGFjYztcbiAgICB9XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaXNTbWFydENvbnRyYWN0QWRkcmVzcyhhZGRyZXNzKSB7XG4gIGNvbnN0IHsgaXNDb250cmFjdEFkZHJlc3MgfSA9IGF3YWl0IHJlYWRBZGRyZXNzQXNDb250cmFjdChcbiAgICBnbG9iYWwuZXRoLFxuICAgIGFkZHJlc3MsXG4gICk7XG4gIHJldHVybiBpc0NvbnRyYWN0QWRkcmVzcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN1bUhleGVzKC4uLmFyZ3MpIHtcbiAgY29uc3QgdG90YWwgPSBhcmdzLnJlZHVjZSgoYWNjLCBoZXhBbW91bnQpID0+IHtcbiAgICByZXR1cm4gYWRkQ3VycmVuY2llcyhhY2MsIGhleEFtb3VudCwge1xuICAgICAgdG9OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICBhQmFzZTogMTYsXG4gICAgICBiQmFzZTogMTYsXG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBhZGRIZXhQcmVmaXgodG90YWwpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNMZWdhY3lUcmFuc2FjdGlvbih0eFBhcmFtcykge1xuICByZXR1cm4gdHhQYXJhbXM/LnR5cGUgPT09IFRSQU5TQUNUSU9OX0VOVkVMT1BFX1RZUEVTLkxFR0FDWTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RhdHVzIGtleSBmb3IgYSB0cmFuc2FjdGlvbi4gUmVxdWlyZXMgcGFyc2luZyB0aGUgdHhNZXRhLnR4UmVjZWlwdCBvbiB0b3Agb2ZcbiAqIHR4TWV0YS5zdGF0dXMgYmVjYXVzZSB0eE1ldGEuc3RhdHVzIGRvZXMgbm90IHJlZmxlY3Qgb24tY2hhaW4gZXJyb3JzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0cmFuc2FjdGlvbiAtIFRoZSB0eE1ldGEgb2JqZWN0IG9mIGEgdHJhbnNhY3Rpb24uXG4gKiBAcGFyYW0ge29iamVjdH0gdHJhbnNhY3Rpb24udHhSZWNlaXB0IC0gVGhlIHRyYW5zYWN0aW9uIHJlY2VpcHQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdHVzS2V5KHRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IHtcbiAgICB0eFJlY2VpcHQ6IHsgc3RhdHVzOiByZWNlaXB0U3RhdHVzIH0gPSB7fSxcbiAgICB0eXBlLFxuICAgIHN0YXR1cyxcbiAgfSA9IHRyYW5zYWN0aW9uO1xuXG4gIC8vIFRoZXJlIHdhcyBhbiBvbi1jaGFpbiBmYWlsdXJlXG4gIGlmIChyZWNlaXB0U3RhdHVzID09PSAnMHgwJykge1xuICAgIHJldHVybiBUUkFOU0FDVElPTl9TVEFUVVNFUy5GQUlMRUQ7XG4gIH1cblxuICBpZiAoXG4gICAgc3RhdHVzID09PSBUUkFOU0FDVElPTl9TVEFUVVNFUy5DT05GSVJNRUQgJiZcbiAgICB0eXBlID09PSBUUkFOU0FDVElPTl9UWVBFUy5DQU5DRUxcbiAgKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX0dST1VQX1NUQVRVU0VTLkNBTkNFTExFRDtcbiAgfVxuXG4gIHJldHVybiB0cmFuc2FjdGlvbi5zdGF0dXM7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHRpdGxlIGZvciB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gY2F0ZWdvcnkuXG4gKlxuICogVGhpcyB3aWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSB0cmFuc2FjdGlvbiBjYXRlZ29yeSBpcyB1bnJlY29nbml6ZWQgYW5kIG5vIGRlZmF1bHQgaXMgcHJvdmlkZWQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdCAtIFRoZSB0cmFuc2xhdGlvbiBmdW5jdGlvblxuICogQHBhcmFtIHtUUkFOU0FDVElPTl9UWVBFU1trZXlvZiBUUkFOU0FDVElPTl9UWVBFU119IHR5cGUgLSBUaGUgdHJhbnNhY3Rpb24gdHlwZSBjb25zdGFudFxuICogQHBhcmFtIHtzdHJpbmd9IG5hdGl2ZUN1cnJlbmN5IC0gVGhlIG5hdGl2ZSBjdXJyZW5jeSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG5ldHdvcmtcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSB0cmFuc2FjdGlvbiBjYXRlZ29yeSB0aXRsZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25UeXBlVGl0bGUodCwgdHlwZSwgbmF0aXZlQ3VycmVuY3kgPSAnRVRIJykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9UUkFOU0ZFUjoge1xuICAgICAgcmV0dXJuIHQoJ3RyYW5zZmVyJyk7XG4gICAgfVxuICAgIGNhc2UgVFJBTlNBQ1RJT05fVFlQRVMuVE9LRU5fTUVUSE9EX1RSQU5TRkVSX0ZST006IHtcbiAgICAgIHJldHVybiB0KCd0cmFuc2ZlckZyb20nKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5UT0tFTl9NRVRIT0RfU0FGRV9UUkFOU0ZFUl9GUk9NOiB7XG4gICAgICByZXR1cm4gdCgnc2FmZVRyYW5zZmVyRnJvbScpO1xuICAgIH1cbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9BUFBST1ZFOiB7XG4gICAgICByZXR1cm4gdCgnYXBwcm92ZScpO1xuICAgIH1cbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlRPS0VOX01FVEhPRF9TRVRfQVBQUk9WQUxfRk9SX0FMTDoge1xuICAgICAgcmV0dXJuIHQoJ3NldEFwcHJvdmFsRm9yQWxsJyk7XG4gICAgfVxuICAgIGNhc2UgVFJBTlNBQ1RJT05fVFlQRVMuU0lNUExFX1NFTkQ6IHtcbiAgICAgIHJldHVybiB0KCdzZW5kaW5nTmF0aXZlQXNzZXQnLCBbbmF0aXZlQ3VycmVuY3ldKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5DT05UUkFDVF9JTlRFUkFDVElPTjoge1xuICAgICAgcmV0dXJuIHQoJ2NvbnRyYWN0SW50ZXJhY3Rpb24nKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5ERVBMT1lfQ09OVFJBQ1Q6IHtcbiAgICAgIHJldHVybiB0KCdjb250cmFjdERlcGxveW1lbnQnKTtcbiAgICB9XG4gICAgY2FzZSBUUkFOU0FDVElPTl9UWVBFUy5TV0FQOiB7XG4gICAgICByZXR1cm4gdCgnc3dhcCcpO1xuICAgIH1cbiAgICBjYXNlIFRSQU5TQUNUSU9OX1RZUEVTLlNXQVBfQVBQUk9WQUw6IHtcbiAgICAgIHJldHVybiB0KCdzd2FwQXBwcm92YWwnKTtcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgdHJhbnNhY3Rpb24gdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IGxvZyBmcm9tICdsb2dsZXZlbCc7XHJcbmltcG9ydCB7IHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvbW9kdWxlcy90cmFuc2FjdGlvbi51dGlscyc7XHJcbmltcG9ydCB7IHZhbHVlc0ZvciB9IGZyb20gJy4vdXRpbCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB0eEhlbHBlcihcclxuICB1bmFwcHJvdmVkVHhzLFxyXG4gIHVuYXBwcm92ZWRNc2dzLFxyXG4gIHBlcnNvbmFsTXNncyxcclxuICBkZWNyeXB0TXNncyxcclxuICBlbmNyeXB0aW9uUHVibGljS2V5TXNncyxcclxuICB0eXBlZE1lc3NhZ2VzLFxyXG4gIG5ldHdvcmssXHJcbiAgY2hhaW5JZCxcclxuKSB7XHJcbiAgbG9nLmRlYnVnKCd0eC1oZWxwZXIgY2FsbGVkIHdpdGggcGFyYW1zOicpO1xyXG4gIGxvZy5kZWJ1Zyh7XHJcbiAgICB1bmFwcHJvdmVkVHhzLFxyXG4gICAgdW5hcHByb3ZlZE1zZ3MsXHJcbiAgICBwZXJzb25hbE1zZ3MsXHJcbiAgICBkZWNyeXB0TXNncyxcclxuICAgIGVuY3J5cHRpb25QdWJsaWNLZXlNc2dzLFxyXG4gICAgdHlwZWRNZXNzYWdlcyxcclxuICAgIG5ldHdvcmssXHJcbiAgICBjaGFpbklkLFxyXG4gIH0pO1xyXG5cclxuICBjb25zdCB0eFZhbHVlcyA9IG5ldHdvcmtcclxuICAgID8gdmFsdWVzRm9yKHVuYXBwcm92ZWRUeHMpLmZpbHRlcigodHhNZXRhKSA9PlxyXG4gICAgICAgIHRyYW5zYWN0aW9uTWF0Y2hlc05ldHdvcmsodHhNZXRhLCBjaGFpbklkLCBuZXR3b3JrKSxcclxuICAgICAgKVxyXG4gICAgOiB2YWx1ZXNGb3IodW5hcHByb3ZlZFR4cyk7XHJcbiAgbG9nLmRlYnVnKGB0eCBoZWxwZXIgZm91bmQgJHt0eFZhbHVlcy5sZW5ndGh9IHVuYXBwcm92ZWQgdHhzYCk7XHJcblxyXG4gIGNvbnN0IG1zZ1ZhbHVlcyA9IHZhbHVlc0Zvcih1bmFwcHJvdmVkTXNncyk7XHJcbiAgbG9nLmRlYnVnKGB0eCBoZWxwZXIgZm91bmQgJHttc2dWYWx1ZXMubGVuZ3RofSB1bnNpZ25lZCBtZXNzYWdlc2ApO1xyXG4gIGxldCBhbGxWYWx1ZXMgPSB0eFZhbHVlcy5jb25jYXQobXNnVmFsdWVzKTtcclxuXHJcbiAgY29uc3QgcGVyc29uYWxWYWx1ZXMgPSB2YWx1ZXNGb3IocGVyc29uYWxNc2dzKTtcclxuICBsb2cuZGVidWcoXHJcbiAgICBgdHggaGVscGVyIGZvdW5kICR7cGVyc29uYWxWYWx1ZXMubGVuZ3RofSB1bnNpZ25lZCBwZXJzb25hbCBtZXNzYWdlc2AsXHJcbiAgKTtcclxuICBhbGxWYWx1ZXMgPSBhbGxWYWx1ZXMuY29uY2F0KHBlcnNvbmFsVmFsdWVzKTtcclxuXHJcbiAgY29uc3QgZGVjcnlwdFZhbHVlcyA9IHZhbHVlc0ZvcihkZWNyeXB0TXNncyk7XHJcbiAgbG9nLmRlYnVnKGB0eCBoZWxwZXIgZm91bmQgJHtkZWNyeXB0VmFsdWVzLmxlbmd0aH0gZGVjcnlwdCByZXF1ZXN0c2ApO1xyXG4gIGFsbFZhbHVlcyA9IGFsbFZhbHVlcy5jb25jYXQoZGVjcnlwdFZhbHVlcyk7XHJcblxyXG4gIGNvbnN0IGVuY3J5cHRpb25QdWJsaWNLZXlWYWx1ZXMgPSB2YWx1ZXNGb3IoZW5jcnlwdGlvblB1YmxpY0tleU1zZ3MpO1xyXG4gIGxvZy5kZWJ1ZyhcclxuICAgIGB0eCBoZWxwZXIgZm91bmQgJHtlbmNyeXB0aW9uUHVibGljS2V5VmFsdWVzLmxlbmd0aH0gZW5jcnlwdGlvblB1YmxpY0tleSByZXF1ZXN0c2AsXHJcbiAgKTtcclxuICBhbGxWYWx1ZXMgPSBhbGxWYWx1ZXMuY29uY2F0KGVuY3J5cHRpb25QdWJsaWNLZXlWYWx1ZXMpO1xyXG5cclxuICBjb25zdCB0eXBlZFZhbHVlcyA9IHZhbHVlc0Zvcih0eXBlZE1lc3NhZ2VzKTtcclxuICBsb2cuZGVidWcoYHR4IGhlbHBlciBmb3VuZCAke3R5cGVkVmFsdWVzLmxlbmd0aH0gdW5zaWduZWQgdHlwZWQgbWVzc2FnZXNgKTtcclxuICBhbGxWYWx1ZXMgPSBhbGxWYWx1ZXMuY29uY2F0KHR5cGVkVmFsdWVzKTtcclxuXHJcbiAgYWxsVmFsdWVzID0gYWxsVmFsdWVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBhbGxWYWx1ZXM7XHJcbn1cclxuIiwiaW1wb3J0IHB1bnljb2RlIGZyb20gJ3B1bnljb2RlL3B1bnljb2RlJztcbmltcG9ydCBhYmkgZnJvbSAnaHVtYW4tc3RhbmRhcmQtdG9rZW4tYWJpJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAqIGFzIGV0aFV0aWwgZnJvbSAnZXRoZXJldW1qcy11dGlsJztcbmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSAnbHV4b24nO1xuaW1wb3J0IHsgZ2V0Rm9ybWF0dGVkSXBmc1VybCB9IGZyb20gJ0BtZXRhbWFzay9jb250cm9sbGVycy9kaXN0L3V0aWwnO1xuaW1wb3J0IHNsaXA0NCBmcm9tICdAbWV0YW1hc2svc2xpcDQ0JztcbmltcG9ydCB7IENIQUlOX0lEUyB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9jb25zdGFudHMvbmV0d29yayc7XG5pbXBvcnQge1xuICB0b0NoZWNrc3VtSGV4QWRkcmVzcyxcbiAgc3RyaXBIZXhQcmVmaXgsXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2hleHN0cmluZy11dGlscyc7XG5pbXBvcnQge1xuICBUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSUyxcbiAgVFJVTkNBVEVEX05BTUVfQ0hBUl9MSU1JVCxcbiAgVFJVTkNBVEVEX0FERFJFU1NfRU5EX0NIQVJTLFxufSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL2xhYmVscyc7XG5pbXBvcnQgeyB0b0JpZ051bWJlciB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMnO1xuXG4vLyBmb3JtYXREYXRhIDo6ICggZGF0ZTogPFVuaXggVGltZXN0YW1wPiApIC0+IFN0cmluZ1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSwgZm9ybWF0ID0gXCJNL2QveSAnYXQnIFRcIikge1xuICBpZiAoIWRhdGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSkudG9Gb3JtYXQoZm9ybWF0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGVXaXRoWWVhckNvbnRleHQoXG4gIGRhdGUsXG4gIGZvcm1hdFRoaXNZZWFyID0gJ01NTSBkJyxcbiAgZmFsbGJhY2sgPSAnTU1NIGQsIHknLFxuKSB7XG4gIGlmICghZGF0ZSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBkYXRlVGltZSA9IERhdGVUaW1lLmZyb21NaWxsaXMoZGF0ZSk7XG4gIGNvbnN0IG5vdyA9IERhdGVUaW1lLmxvY2FsKCk7XG4gIHJldHVybiBkYXRlVGltZS50b0Zvcm1hdChcbiAgICBub3cueWVhciA9PT0gZGF0ZVRpbWUueWVhciA/IGZvcm1hdFRoaXNZZWFyIDogZmFsbGJhY2ssXG4gICk7XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHByb3ZpZGVkIGNoYWluSWQgaXMgYSBkZWZhdWx0IE1ldGFNYXNrIGNoYWluXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNoYWluSWQgLSBjaGFpbklkIHRvIGNoZWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RlZmF1bHRNZXRhTWFza0NoYWluKGNoYWluSWQpIHtcbiAgaWYgKFxuICAgICFjaGFpbklkIHx8XG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLk1BSU5ORVQgfHxcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuR09FUkxJIHx8XG4gICAgY2hhaW5JZCA9PT0gQ0hBSU5fSURTLlNFUE9MSUEgfHxcbiAgICBjaGFpbklkID09PSBDSEFJTl9JRFMuTE9DQUxIT1NUXG4gICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzRm9yKG9iaikge1xuICBpZiAoIW9iaikge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRyZXNzU3VtbWFyeShcbiAgYWRkcmVzcyxcbiAgZmlyc3RTZWdMZW5ndGggPSAxMCxcbiAgbGFzdFNlZ0xlbmd0aCA9IDQsXG4gIGluY2x1ZGVIZXggPSB0cnVlLFxuKSB7XG4gIGlmICghYWRkcmVzcykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBsZXQgY2hlY2tlZCA9IHRvQ2hlY2tzdW1IZXhBZGRyZXNzKGFkZHJlc3MpO1xuICBpZiAoIWluY2x1ZGVIZXgpIHtcbiAgICBjaGVja2VkID0gc3RyaXBIZXhQcmVmaXgoY2hlY2tlZCk7XG4gIH1cbiAgcmV0dXJuIGNoZWNrZWRcbiAgICA/IGAke2NoZWNrZWQuc2xpY2UoMCwgZmlyc3RTZWdMZW5ndGgpfS4uLiR7Y2hlY2tlZC5zbGljZShcbiAgICAgICAgY2hlY2tlZC5sZW5ndGggLSBsYXN0U2VnTGVuZ3RoLFxuICAgICAgKX1gXG4gICAgOiAnLi4uJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWREb21haW5OYW1lKGFkZHJlc3MpIHtcbiAgY29uc3QgbWF0Y2ggPSBwdW55Y29kZVxuICAgIC50b0FTQ0lJKGFkZHJlc3MpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAvLyBDaGVja3MgdGhhdCB0aGUgZG9tYWluIGNvbnNpc3RzIG9mIGF0IGxlYXN0IG9uZSB2YWxpZCBkb21haW4gcGllY2VzIHNlcGFyYXRlZCBieSBwZXJpb2RzLCBmb2xsb3dlZCBieSBhIHRsZFxuICAgIC8vIEVhY2ggcGllY2Ugb2YgZG9tYWluIG5hbWUgaGFzIG9ubHkgdGhlIGNoYXJhY3RlcnMgYS16LCAwLTksIGFuZCBhIGh5cGhlbiAoYnV0IG5vdCBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIGNodW5rKVxuICAgIC8vIEEgY2h1bmsgaGFzIG1pbmltdW0gbGVuZ3RoIG9mIDEsIGJ1dCBtaW5pbXVtIHRsZCBpcyBzZXQgdG8gMiBmb3Igbm93IChubyAxLWNoYXJhY3RlciB0bGRzIGV4aXN0IHlldClcbiAgICAubWF0Y2goXG4gICAgICAvXig/OlthLXowLTldKD86Wy1hLXowLTldKlthLXowLTldKT9cXC4pK1thLXowLTldWy1hLXowLTldKlthLXowLTldJC91LFxuICAgICk7XG4gIHJldHVybiBtYXRjaCAhPT0gbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3JpZ2luQ29udHJhY3RBZGRyZXNzKHRvLCBzZW5kVG9rZW5BZGRyZXNzKSB7XG4gIGlmICghdG8gfHwgIXNlbmRUb2tlbkFkZHJlc3MpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRvLnRvTG93ZXJDYXNlKCkgPT09IHNlbmRUb2tlbkFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbn1cblxuLy8gVGFrZXMgd2VpIEhleCwgcmV0dXJucyB3ZWkgQk4sIGV2ZW4gaWYgaW5wdXQgaXMgbnVsbFxuZXhwb3J0IGZ1bmN0aW9uIG51bWVyaWNCYWxhbmNlKGJhbGFuY2UpIHtcbiAgaWYgKCFiYWxhbmNlKSB7XG4gICAgcmV0dXJuIG5ldyBldGhVdGlsLkJOKDAsIDE2KTtcbiAgfVxuICBjb25zdCBzdHJpcHBlZCA9IHN0cmlwSGV4UHJlZml4KGJhbGFuY2UpO1xuICByZXR1cm4gbmV3IGV0aFV0aWwuQk4oc3RyaXBwZWQsIDE2KTtcbn1cblxuLy8gVGFrZXMgIGhleCwgcmV0dXJucyBbYmVmb3JlRGVjaW1hbCwgYWZ0ZXJEZWNpbWFsXVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQmFsYW5jZShiYWxhbmNlKSB7XG4gIGxldCBhZnRlckRlY2ltYWw7XG4gIGNvbnN0IHdlaSA9IG51bWVyaWNCYWxhbmNlKGJhbGFuY2UpO1xuICBjb25zdCB3ZWlTdHJpbmcgPSB3ZWkudG9TdHJpbmcoKTtcbiAgY29uc3QgdHJhaWxpbmdaZXJvcyA9IC8wKyQvdTtcblxuICBjb25zdCBiZWZvcmVEZWNpbWFsID1cbiAgICB3ZWlTdHJpbmcubGVuZ3RoID4gMTggPyB3ZWlTdHJpbmcuc2xpY2UoMCwgd2VpU3RyaW5nLmxlbmd0aCAtIDE4KSA6ICcwJztcbiAgYWZ0ZXJEZWNpbWFsID0gYDAwMDAwMDAwMDAwMDAwMDAwMCR7d2VpfWBcbiAgICAuc2xpY2UoLTE4KVxuICAgIC5yZXBsYWNlKHRyYWlsaW5nWmVyb3MsICcnKTtcbiAgaWYgKGFmdGVyRGVjaW1hbCA9PT0gJycpIHtcbiAgICBhZnRlckRlY2ltYWwgPSAnMCc7XG4gIH1cbiAgcmV0dXJuIFtiZWZvcmVEZWNpbWFsLCBhZnRlckRlY2ltYWxdO1xufVxuXG4vLyBUYWtlcyB3ZWkgaGV4LCByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHRocmVlIHByb3BlcnRpZXMuXG4vLyBJdHMgXCJmb3JtYXR0ZWRcIiBwcm9wZXJ0eSBpcyB3aGF0IHdlIGdlbmVyYWxseSB1c2UgdG8gcmVuZGVyIHZhbHVlcy5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRCYWxhbmNlKFxuICBiYWxhbmNlLFxuICBkZWNpbWFsc1RvS2VlcCxcbiAgbmVlZHNQYXJzZSA9IHRydWUsXG4gIHRpY2tlciA9ICdFVEgnLFxuKSB7XG4gIGNvbnN0IHBhcnNlZCA9IG5lZWRzUGFyc2UgPyBwYXJzZUJhbGFuY2UoYmFsYW5jZSkgOiBiYWxhbmNlLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGJlZm9yZURlY2ltYWwgPSBwYXJzZWRbMF07XG4gIGxldCBhZnRlckRlY2ltYWwgPSBwYXJzZWRbMV07XG4gIGxldCBmb3JtYXR0ZWQgPSAnTm9uZSc7XG4gIGlmIChkZWNpbWFsc1RvS2VlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGJlZm9yZURlY2ltYWwgPT09ICcwJykge1xuICAgICAgaWYgKGFmdGVyRGVjaW1hbCAhPT0gJzAnKSB7XG4gICAgICAgIGNvbnN0IHNpZ0ZpZ3MgPSBhZnRlckRlY2ltYWwubWF0Y2goL14wKiguezJ9KS91KTsgLy8gZGVmYXVsdDogZ3JhYnMgMiBtb3N0IHNpZ25pZmljYW50IGRpZ2l0c1xuICAgICAgICBpZiAoc2lnRmlncykge1xuICAgICAgICAgIGFmdGVyRGVjaW1hbCA9IHNpZ0ZpZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgZm9ybWF0dGVkID0gYDAuJHthZnRlckRlY2ltYWx9ICR7dGlja2VyfWA7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcm1hdHRlZCA9IGAke2JlZm9yZURlY2ltYWx9LiR7YWZ0ZXJEZWNpbWFsLnNsaWNlKDAsIDMpfSAke3RpY2tlcn1gO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhZnRlckRlY2ltYWwgKz0gQXJyYXkoZGVjaW1hbHNUb0tlZXApLmpvaW4oJzAnKTtcbiAgICBmb3JtYXR0ZWQgPSBgJHtiZWZvcmVEZWNpbWFsfS4ke2FmdGVyRGVjaW1hbC5zbGljZShcbiAgICAgIDAsXG4gICAgICBkZWNpbWFsc1RvS2VlcCxcbiAgICApfSAke3RpY2tlcn1gO1xuICB9XG4gIHJldHVybiBmb3JtYXR0ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb250cmFjdEF0QWRkcmVzcyh0b2tlbkFkZHJlc3MpIHtcbiAgcmV0dXJuIGdsb2JhbC5ldGguY29udHJhY3QoYWJpKS5hdCh0b2tlbkFkZHJlc3MpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmFuZG9tRmlsZU5hbWUoKSB7XG4gIGxldCBmaWxlTmFtZSA9ICcnO1xuICBjb25zdCBjaGFyQmFuayA9IFtcbiAgICAuLi4nYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWjAxMjM0NTY3ODknLFxuICBdO1xuICBjb25zdCBmaWxlTmFtZUxlbmd0aCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDcgKyA2KTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpbGVOYW1lTGVuZ3RoOyBpKyspIHtcbiAgICBmaWxlTmFtZSArPSBjaGFyQmFua1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFyQmFuay5sZW5ndGgpXTtcbiAgfVxuXG4gIHJldHVybiBmaWxlTmFtZTtcbn1cblxuLyoqXG4gKiBTaG9ydGVucyBhbiBFdGhlcmV1bSBhZGRyZXNzIGZvciBkaXNwbGF5LCBwcmVzZXJ2aW5nIHRoZSBiZWdpbm5pbmcgYW5kIGVuZC5cbiAqIFJldHVybnMgdGhlIGdpdmVuIGFkZHJlc3MgaWYgaXQgaXMgbm8gbG9uZ2VyIHRoYW4gMTAgY2hhcmFjdGVycy5cbiAqIFNob3J0ZW5lZCBhZGRyZXNzZXMgYXJlIDEzIGNoYXJhY3RlcnMgbG9uZy5cbiAqXG4gKiBFeGFtcGxlIG91dHB1dDogMHhhYmNkLi4uMTIzNFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGFkZHJlc3MgdG8gc2hvcnRlbi5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBzaG9ydGVuZWQgYWRkcmVzcywgb3IgdGhlIG9yaWdpbmFsIGlmIGl0IHdhcyBubyBsb25nZXJcbiAqIHRoYW4gMTAgY2hhcmFjdGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNob3J0ZW5BZGRyZXNzKGFkZHJlc3MgPSAnJykge1xuICBpZiAoYWRkcmVzcy5sZW5ndGggPCBUUlVOQ0FURURfTkFNRV9DSEFSX0xJTUlUKSB7XG4gICAgcmV0dXJuIGFkZHJlc3M7XG4gIH1cblxuICByZXR1cm4gYCR7YWRkcmVzcy5zbGljZSgwLCBUUlVOQ0FURURfQUREUkVTU19TVEFSVF9DSEFSUyl9Li4uJHthZGRyZXNzLnNsaWNlKFxuICAgIC1UUlVOQ0FURURfQUREUkVTU19FTkRfQ0hBUlMsXG4gICl9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjY291bnRCeUFkZHJlc3MoYWNjb3VudHMgPSBbXSwgdGFyZ2V0QWRkcmVzcykge1xuICByZXR1cm4gYWNjb3VudHMuZmluZCgoeyBhZGRyZXNzIH0pID0+IGFkZHJlc3MgPT09IHRhcmdldEFkZHJlc3MpO1xufVxuXG4vKipcbiAqIFN0cmlwcyB0aGUgZm9sbG93aW5nIHNjaGVtZXMgZnJvbSBVUkwgc3RyaW5nczpcbiAqIC0gaHR0cFxuICogLSBodHRwc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmxTdHJpbmcgLSBUaGUgVVJMIHN0cmluZyB0byBzdHJpcCB0aGUgc2NoZW1lIGZyb20uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgVVJMIHN0cmluZywgd2l0aG91dCB0aGUgc2NoZW1lLCBpZiBpdCB3YXMgc3RyaXBwZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpcEh0dHBTY2hlbWVzKHVybFN0cmluZykge1xuICByZXR1cm4gdXJsU3RyaW5nLnJlcGxhY2UoL15odHRwcz86XFwvXFwvL3UsICcnKTtcbn1cblxuLyoqXG4gKiBTdHJpcHMgdGhlIGZvbGxvd2luZyBzY2hlbWVzIGZyb20gVVJMIHN0cmluZ3M6XG4gKiAtIGh0dHBzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybFN0cmluZyAtIFRoZSBVUkwgc3RyaW5nIHRvIHN0cmlwIHRoZSBzY2hlbWUgZnJvbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBVUkwgc3RyaW5nLCB3aXRob3V0IHRoZSBzY2hlbWUsIGlmIGl0IHdhcyBzdHJpcHBlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSHR0cHNTY2hlbWUodXJsU3RyaW5nKSB7XG4gIHJldHVybiB1cmxTdHJpbmcucmVwbGFjZSgvXmh0dHBzOlxcL1xcLy91LCAnJyk7XG59XG5cbi8qKlxuICogU3RyaXBzIGBodHRwc2Agc2NoZW1lcyBmcm9tIFVSTCBzdHJpbmdzLCBpZiB0aGUgVVJMIGRvZXMgbm90IGhhdmUgYSBwb3J0LlxuICogVGhpcyBpcyB1c2VmdWxcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsU3RyaW5nIC0gVGhlIFVSTCBzdHJpbmcgdG8gc3RyaXAgdGhlIHNjaGVtZSBmcm9tLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIFVSTCBzdHJpbmcsIHdpdGhvdXQgdGhlIHNjaGVtZSwgaWYgaXQgd2FzIHN0cmlwcGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaXBIdHRwc1NjaGVtZVdpdGhvdXRQb3J0KHVybFN0cmluZykge1xuICBpZiAoZ2V0VVJMKHVybFN0cmluZykucG9ydCkge1xuICAgIHJldHVybiB1cmxTdHJpbmc7XG4gIH1cblxuICByZXR1cm4gc3RyaXBIdHRwc1NjaGVtZSh1cmxTdHJpbmcpO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgVVJMLWxpa2UgdmFsdWUgKG9iamVjdCBvciBzdHJpbmcpIGlzIGFuIGV4dGVuc2lvbiBVUkwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmcgfCBVUkwgfCBvYmplY3R9IHVybExpa2UgLSBUaGUgVVJMLWxpa2UgdmFsdWUgdG8gdGVzdC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIHRoZSBVUkwtbGlrZSB2YWx1ZSBpcyBhbiBleHRlbnNpb24gVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlbnNpb25VcmwodXJsTGlrZSkge1xuICBjb25zdCBFWFRfUFJPVE9DT0xTID0gWydjaHJvbWUtZXh0ZW5zaW9uOicsICdtb3otZXh0ZW5zaW9uOiddO1xuXG4gIGlmICh0eXBlb2YgdXJsTGlrZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIEVYVF9QUk9UT0NPTFMpIHtcbiAgICAgIGlmICh1cmxMaWtlLnN0YXJ0c1dpdGgocHJvdG9jb2wpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh1cmxMaWtlPy5wcm90b2NvbCkge1xuICAgIHJldHVybiBFWFRfUFJPVE9DT0xTLmluY2x1ZGVzKHVybExpa2UucHJvdG9jb2wpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhbiBhZGRyZXNzIGlzIGluIGEgcGFzc2VkIGxpc3Qgb2Ygb2JqZWN0cyB3aXRoIGFkZHJlc3MgcHJvcGVydGllcy4gVGhlIGNoZWNrIGlzIHBlcmZvcm1lZCBvbiB0aGVcbiAqIGxvd2VyY2FzZWQgdmVyc2lvbiBvZiB0aGUgYWRkcmVzc2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIGhleCBhZGRyZXNzIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0FycmF5fSBsaXN0IC0gVGhlIGFycmF5IG9mIG9iamVjdHMgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgYWRkcmVzcyBpcyBpbiB0aGUgbGlzdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tFeGlzdGluZ0FkZHJlc3NlcyhhZGRyZXNzLCBsaXN0ID0gW10pIHtcbiAgaWYgKCFhZGRyZXNzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgbWF0Y2hlc0FkZHJlc3MgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIG9iai5hZGRyZXNzLnRvTG93ZXJDYXNlKCkgPT09IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICByZXR1cm4gbGlzdC5zb21lKG1hdGNoZXNBZGRyZXNzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJuR3JlYXRlclRoYW4oYSwgYikge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV3IEJpZ051bWJlcihhLCAxMCkuZ3QoYiwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm5MZXNzVGhhbihhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5sdChiLCAxMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibkdyZWF0ZXJUaGFuRXF1YWxUbyhhLCBiKSB7XG4gIGlmIChhID09PSBudWxsIHx8IGEgPT09IHVuZGVmaW5lZCB8fCBiID09PSBudWxsIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBuZXcgQmlnTnVtYmVyKGEsIDEwKS5ndGUoYiwgMTApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYm5MZXNzVGhhbkVxdWFsVG8oYSwgYikge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gbmV3IEJpZ051bWJlcihhLCAxMCkubHRlKGIsIDEwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTCh1cmwpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IFVSTCh1cmwpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3QodXJsKSB7XG4gIHJldHVybiBnZXRVUkwodXJsKT8uaG9zdCB8fCAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFVSTEhvc3ROYW1lKHVybCkge1xuICByZXR1cm4gZ2V0VVJMKHVybCk/Lmhvc3RuYW1lIHx8ICcnO1xufVxuXG4vLyBPbmNlIHdlIHJlYWNoIHRoaXMgdGhyZXNob2xkLCB3ZSBzd2l0Y2ggdG8gaGlnaGVyIHVuaXRcbmNvbnN0IE1JTlVURV9DVVRPRkYgPSA5MCAqIDYwO1xuY29uc3QgU0VDT05EX0NVVE9GRiA9IDkwO1xuXG5leHBvcnQgY29uc3QgdG9IdW1hblJlYWRhYmxlVGltZSA9ICh0LCBtaWxsaXNlY29uZHMpID0+IHtcbiAgaWYgKG1pbGxpc2Vjb25kcyA9PT0gdW5kZWZpbmVkIHx8IG1pbGxpc2Vjb25kcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBzZWNvbmRzID0gTWF0aC5jZWlsKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICBpZiAoc2Vjb25kcyA8PSBTRUNPTkRfQ1VUT0ZGKSB7XG4gICAgcmV0dXJuIHQoJ2dhc1RpbWluZ1NlY29uZHNTaG9ydCcsIFtzZWNvbmRzXSk7XG4gIH1cbiAgaWYgKHNlY29uZHMgPD0gTUlOVVRFX0NVVE9GRikge1xuICAgIHJldHVybiB0KCdnYXNUaW1pbmdNaW51dGVzU2hvcnQnLCBbTWF0aC5jZWlsKHNlY29uZHMgLyA2MCldKTtcbiAgfVxuICByZXR1cm4gdCgnZ2FzVGltaW5nSG91cnNTaG9ydCcsIFtNYXRoLmNlaWwoc2Vjb25kcyAvIDM2MDApXSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJDbGlwYm9hcmQoKSB7XG4gIHdpbmRvdy5uYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCgnJyk7XG59XG5cbmNvbnN0IHNvbGlkaXR5VHlwZXMgPSAoKSA9PiB7XG4gIGNvbnN0IHR5cGVzID0gW1xuICAgICdib29sJyxcbiAgICAnYWRkcmVzcycsXG4gICAgJ3N0cmluZycsXG4gICAgJ2J5dGVzJyxcbiAgICAnaW50JyxcbiAgICAndWludCcsXG4gICAgJ2ZpeGVkJyxcbiAgICAndWZpeGVkJyxcbiAgXTtcblxuICBjb25zdCBpbnRzID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoMzIpKS5tYXAoXG4gICAgKF8sIGluZGV4KSA9PiBgaW50JHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgdWludHMgPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcbiAgICAoXywgaW5kZXgpID0+IGB1aW50JHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgYnl0ZXMgPSBBcnJheS5mcm9tKG5ldyBBcnJheSgzMikpLm1hcChcbiAgICAoXywgaW5kZXgpID0+IGBieXRlcyR7aW5kZXggKyAxfWAsXG4gICk7XG5cbiAgLyoqXG4gICAqIGZpeGVkIGFuZCB1Zml4ZWRcbiAgICogVGhpcyB2YWx1ZSB0eXBlIGFsc28gY2FuIGJlIGRlY2xhcmVkIGtleXdvcmRzIHN1Y2ggYXMgdWZpeGVkTXhOIGFuZCBmaXhlZE14Ti5cbiAgICogVGhlIE0gcmVwcmVzZW50cyB0aGUgYW1vdW50IG9mIGJpdHMgdGhhdCB0aGUgdHlwZSB0YWtlcyxcbiAgICogd2l0aCBOIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcG9pbnRzIHRoYXQgYXJlIGF2YWlsYWJsZS5cbiAgICogIE0gaGFzIHRvIGJlIGRpdmlzaWJsZSBieSA4LCBhbmQgYSBudW1iZXIgZnJvbSA4IHRvIDI1Ni5cbiAgICogTiBoYXMgdG8gYmUgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDgwLCBhbHNvIGJlaW5nIGluY2x1c2l2ZS5cbiAgICovXG4gIGNvbnN0IGZpeGVkTSA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxuICAgIChfLCBpbmRleCkgPT4gYGZpeGVkJHsoaW5kZXggKyAxKSAqIDh9YCxcbiAgKTtcbiAgY29uc3QgdWZpeGVkTSA9IEFycmF5LmZyb20obmV3IEFycmF5KDMyKSkubWFwKFxuICAgIChfLCBpbmRleCkgPT4gYHVmaXhlZCR7KGluZGV4ICsgMSkgKiA4fWAsXG4gICk7XG4gIGNvbnN0IGZpeGVkID0gQXJyYXkuZnJvbShuZXcgQXJyYXkoODApKS5tYXAoKF8sIGluZGV4KSA9PlxuICAgIGZpeGVkTS5tYXAoKGFGaXhlZE0pID0+IGAke2FGaXhlZE19eCR7aW5kZXggKyAxfWApLFxuICApO1xuICBjb25zdCB1Zml4ZWQgPSBBcnJheS5mcm9tKG5ldyBBcnJheSg4MCkpLm1hcCgoXywgaW5kZXgpID0+XG4gICAgdWZpeGVkTS5tYXAoKGF1Rml4ZWRNKSA9PiBgJHthdUZpeGVkTX14JHtpbmRleCArIDF9YCksXG4gICk7XG5cbiAgcmV0dXJuIFtcbiAgICAuLi50eXBlcyxcbiAgICAuLi5pbnRzLFxuICAgIC4uLnVpbnRzLFxuICAgIC4uLmJ5dGVzLFxuICAgIC4uLmZpeGVkLmZsYXQoKSxcbiAgICAuLi51Zml4ZWQuZmxhdCgpLFxuICBdO1xufTtcblxuZXhwb3J0IGNvbnN0IHNhbml0aXplTWVzc2FnZSA9IChtc2csIGJhc2VUeXBlLCB0eXBlcykgPT4ge1xuICBpZiAoIXR5cGVzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHR5cGVzIGRlZmluaXRpb25gKTtcbiAgfVxuXG4gIGNvbnN0IGJhc2VUeXBlRGVmaW5pdGlvbnMgPSB0eXBlc1tiYXNlVHlwZV07XG4gIGlmICghYmFzZVR5cGVEZWZpbml0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwcmltYXJ5IHR5cGUgZGVmaW5pdGlvbmApO1xuICB9XG5cbiAgY29uc3Qgc2FuaXRpemVkTWVzc2FnZSA9IHt9O1xuICBjb25zdCBtc2dLZXlzID0gT2JqZWN0LmtleXMobXNnKTtcbiAgbXNnS2V5cy5mb3JFYWNoKChtc2dLZXkpID0+IHtcbiAgICBjb25zdCBkZWZpbmVkVHlwZSA9IE9iamVjdC52YWx1ZXMoYmFzZVR5cGVEZWZpbml0aW9ucykuZmluZChcbiAgICAgIChiYXNlVHlwZURlZmluaXRpb24pID0+IGJhc2VUeXBlRGVmaW5pdGlvbi5uYW1lID09PSBtc2dLZXksXG4gICAgKTtcblxuICAgIGlmICghZGVmaW5lZFR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBrZXkgaGFzIGEgdHlwZS4gY2hlY2sgaWYgdGhlIGRlZmluZWRUeXBlIGlzIGFsc28gYSB0eXBlXG4gICAgY29uc3QgbmVzdGVkVHlwZSA9IGRlZmluZWRUeXBlLnR5cGUucmVwbGFjZSgvXFxbXFxdJC91LCAnJyk7XG4gICAgY29uc3QgbmVzdGVkVHlwZURlZmluaXRpb24gPSB0eXBlc1tuZXN0ZWRUeXBlXTtcblxuICAgIGlmIChuZXN0ZWRUeXBlRGVmaW5pdGlvbikge1xuICAgICAgaWYgKGRlZmluZWRUeXBlLnR5cGUuZW5kc1dpdGgoJ1tdJykgPiAwKSB7XG4gICAgICAgIC8vIG5lc3RlZCBhcnJheVxuICAgICAgICBzYW5pdGl6ZWRNZXNzYWdlW21zZ0tleV0gPSBtc2dbbXNnS2V5XS5tYXAoKHZhbHVlKSA9PlxuICAgICAgICAgIHNhbml0aXplTWVzc2FnZSh2YWx1ZSwgbmVzdGVkVHlwZSwgdHlwZXMpLFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbmVzdGVkIG9iamVjdFxuICAgICAgICBzYW5pdGl6ZWRNZXNzYWdlW21zZ0tleV0gPSBzYW5pdGl6ZU1lc3NhZ2UoXG4gICAgICAgICAgbXNnW21zZ0tleV0sXG4gICAgICAgICAgZGVmaW5lZFR5cGUudHlwZSxcbiAgICAgICAgICB0eXBlcyxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgaWYgaXQncyBhIHZhbGlkIHNvbGlkaXR5IHR5cGVcbiAgICAgIGNvbnN0IGlzU29saWRpdHlUeXBlID0gc29saWRpdHlUeXBlcygpLmluY2x1ZGVzKG5lc3RlZFR5cGUpO1xuICAgICAgaWYgKGlzU29saWRpdHlUeXBlKSB7XG4gICAgICAgIHNhbml0aXplZE1lc3NhZ2VbbXNnS2V5XSA9IG1zZ1ttc2dLZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzYW5pdGl6ZWRNZXNzYWdlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFzc2V0SW1hZ2VVUkwoaW1hZ2UsIGlwZnNHYXRld2F5KSB7XG4gIGlmICghaW1hZ2UgfHwgIWlwZnNHYXRld2F5IHx8IHR5cGVvZiBpbWFnZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoaW1hZ2Uuc3RhcnRzV2l0aCgnaXBmczovLycpKSB7XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZElwZnNVcmwoaXBmc0dhdGV3YXksIGltYWdlLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFRvRGVjaW1hbFBsYWNlc1JlbW92aW5nRXh0cmFaZXJvZXMoXG4gIG51bWJlcmlzaCxcbiAgbnVtYmVyT2ZEZWNpbWFsUGxhY2VzLFxuKSB7XG4gIGlmIChudW1iZXJpc2ggPT09IHVuZGVmaW5lZCB8fCBudW1iZXJpc2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHRvQmlnTnVtYmVyXG4gICAgLmRlYyh0b0JpZ051bWJlci5kZWMobnVtYmVyaXNoKS50b0ZpeGVkKG51bWJlck9mRGVjaW1hbFBsYWNlcykpXG4gICAgLnRvTnVtYmVyKCk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgU0xJUC00NCBwcm90b2NvbCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzcGVjaWZpZWRcbiAqIGBjb2luX3R5cGVgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBjb2luVHlwZSAtIFRoZSBTTElQLTQ0IGBjb2luX3R5cGVgIHZhbHVlIHdob3NlIG5hbWVcbiAqIHRvIHJldHJpZXZlLlxuICogQHJldHVybnMge3N0cmluZyB8IHVuZGVmaW5lZH0gVGhlIG5hbWUgb2YgdGhlIHByb3RvY29sIGlmIGZvdW5kLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29pblR5cGVUb1Byb3RvY29sTmFtZShjb2luVHlwZSkge1xuICBpZiAoU3RyaW5nKGNvaW5UeXBlKSA9PT0gJzEnKSB7XG4gICAgcmV0dXJuICdUZXN0IE5ldHdvcmtzJztcbiAgfVxuICByZXR1cm4gc2xpcDQ0W2NvaW5UeXBlXT8ubmFtZSB8fCB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogVGVzdHMgXCJudWxsaXNobmVzc1wiLiBVc2VkIHRvIGd1YXJkIGEgc2VjdGlvbiBvZiBhIGNvbXBvbmVudCBmcm9tIGJlaW5nXG4gKiByZW5kZXJlZCBiYXNlZCBvbiBhIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZSAtIEEgdmFsdWUgKGxpdGVyYWxseSBhbnl0aGluZykuXG4gKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgdW5kZWZpbmVkLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVsbGlzaCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbiIsImltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpbmZ1cmFQcm9qZWN0SWQgfSBmcm9tICcuLi8uLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL25ldHdvcmsnO1xuaW1wb3J0IHtcbiAgU0VWRVJJVElFUyxcbiAgVFlQT0dSQVBIWSxcbiAgVEVYVF9BTElHTixcbiAgSlVTVElGWV9DT05URU5ULFxuICBESVNQTEFZLFxuICBDT0xPUlMsXG4gIEZMRVhfRElSRUNUSU9OLFxuICBBTElHTl9JVEVNUyxcbn0gZnJvbSAnLi4vLi4vLi4vaGVscGVycy9jb25zdGFudHMvZGVzaWduLXN5c3RlbSc7XG5pbXBvcnQgeyBERUZBVUxUX1JPVVRFIH0gZnJvbSAnLi4vLi4vLi4vaGVscGVycy9jb25zdGFudHMvcm91dGVzJztcbmltcG9ydCBaRU5ERVNLX1VSTFMgZnJvbSAnLi4vLi4vLi4vaGVscGVycy9jb25zdGFudHMvemVuZGVzay11cmwnO1xuaW1wb3J0IGZldGNoV2l0aENhY2hlIGZyb20gJy4uLy4uLy4uLy4uL3NoYXJlZC9saWIvZmV0Y2gtd2l0aC1jYWNoZSc7XG5cbmNvbnN0IFVOUkVDT0dOSVpFRF9DSEFJTiA9IHtcbiAgaWQ6ICdVTlJFQ09HTklaRURfQ0hBSU4nLFxuICBzZXZlcml0eTogU0VWRVJJVElFUy5XQVJOSU5HLFxuICBjb250ZW50OiB7XG4gICAgZWxlbWVudDogJ3NwYW4nLFxuICAgIGNoaWxkcmVuOiB7XG4gICAgICBlbGVtZW50OiAnTWV0YU1hc2tUcmFuc2xhdGlvbicsXG4gICAgICBwcm9wczoge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogJ3VucmVjb2duaXplZENoYWluJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IE1JU01BVENIRURfQ0hBSU5fUkVDT01NRU5EQVRJT04gPSB7XG4gIGlkOiAnTUlTTUFUQ0hFRF9DSEFJTl9SRUNPTU1FTkRBVElPTicsXG4gIGNvbnRlbnQ6IHtcbiAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiAnbWlzbWF0Y2hlZENoYWluUmVjb21tZW5kYXRpb24nLFxuICAgICAgICB2YXJpYWJsZXM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbGVtZW50OiAnYScsXG4gICAgICAgICAgICBrZXk6ICdtaXNtYXRjaGVkQ2hhaW5MaW5rJyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIGhyZWY6IFpFTkRFU0tfVVJMUy5WRVJJRllfQ1VTVE9NX05FVFdPUkssXG4gICAgICAgICAgICAgIHRhcmdldDogJ19fYmxhbmsnLFxuICAgICAgICAgICAgICB0YWJJbmRleDogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGlsZHJlbjoge1xuICAgICAgICAgICAgICBlbGVtZW50OiAnTWV0YU1hc2tUcmFuc2xhdGlvbicsXG4gICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6ICdtaXNtYXRjaGVkQ2hhaW5MaW5rVGV4dCcsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBNSVNNQVRDSEVEX05FVFdPUktfTkFNRSA9IHtcbiAgaWQ6ICdNSVNNQVRDSEVEX05FVFdPUktfTkFNRScsXG4gIHNldmVyaXR5OiBTRVZFUklUSUVTLldBUk5JTkcsXG4gIGNvbnRlbnQ6IHtcbiAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiAnbWlzbWF0Y2hlZE5ldHdvcmtOYW1lJyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSxcbn07XG5cbmNvbnN0IE1JU01BVENIRURfTkVUV09SS19TWU1CT0wgPSB7XG4gIGlkOiAnTUlTTUFUQ0hFRF9ORVRXT1JLX1NZTUJPTCcsXG4gIHNldmVyaXR5OiBTRVZFUklUSUVTLkRBTkdFUixcbiAgY29udGVudDoge1xuICAgIGVsZW1lbnQ6ICdzcGFuJyxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgZWxlbWVudDogJ01ldGFNYXNrVHJhbnNsYXRpb24nLFxuICAgICAgcHJvcHM6IHtcbiAgICAgICAgdHJhbnNsYXRpb25LZXk6ICdtaXNtYXRjaGVkTmV0d29ya1N5bWJvbCcsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59O1xuXG5jb25zdCBNSVNNQVRDSEVEX05FVFdPUktfUlBDID0ge1xuICBpZDogJ01JU01BVENIRURfTkVUV09SS19SUEMnLFxuICBzZXZlcml0eTogU0VWRVJJVElFUy5EQU5HRVIsXG4gIGNvbnRlbnQ6IHtcbiAgICBlbGVtZW50OiAnc3BhbicsXG4gICAgY2hpbGRyZW46IHtcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcbiAgICAgIHByb3BzOiB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiAnbWlzbWF0Y2hlZFJwY1VybCcsXG4gICAgICB9LFxuICAgIH0sXG4gIH0sXG59O1xuXG5hc3luYyBmdW5jdGlvbiBnZXRBbGVydHMocGVuZGluZ0FwcHJvdmFsKSB7XG4gIGNvbnN0IGFsZXJ0cyA9IFtdO1xuICBjb25zdCBzYWZlQ2hhaW5zTGlzdCA9XG4gICAgKGF3YWl0IGZldGNoV2l0aENhY2hlKCdodHRwczovL2NoYWluaWQubmV0d29yay9jaGFpbnMuanNvbicpKSB8fCBbXTtcbiAgY29uc3QgbWF0Y2hlZENoYWluID0gc2FmZUNoYWluc0xpc3QuZmluZChcbiAgICAoY2hhaW4pID0+XG4gICAgICBjaGFpbi5jaGFpbklkID09PSBwYXJzZUludChwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuY2hhaW5JZCwgMTYpLFxuICApO1xuXG4gIGNvbnN0IG9yaWdpbklzTWV0YU1hc2sgPSBwZW5kaW5nQXBwcm92YWwub3JpZ2luID09PSAnbWV0YW1hc2snO1xuICBpZiAob3JpZ2luSXNNZXRhTWFzayAmJiBCb29sZWFuKG1hdGNoZWRDaGFpbikpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBpZiAobWF0Y2hlZENoYWluKSB7XG4gICAgaWYgKFxuICAgICAgbWF0Y2hlZENoYWluLm5hbWUudG9Mb3dlckNhc2UoKSAhPT1cbiAgICAgIHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5jaGFpbk5hbWUudG9Mb3dlckNhc2UoKVxuICAgICkge1xuICAgICAgYWxlcnRzLnB1c2goTUlTTUFUQ0hFRF9ORVRXT1JLX05BTUUpO1xuICAgIH1cbiAgICBpZiAoXG4gICAgICBtYXRjaGVkQ2hhaW4ubmF0aXZlQ3VycmVuY3k/LnN5bWJvbCAhPT0gcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnRpY2tlclxuICAgICkge1xuICAgICAgYWxlcnRzLnB1c2goTUlTTUFUQ0hFRF9ORVRXT1JLX1NZTUJPTCk7XG4gICAgfVxuXG4gICAgY29uc3QgeyBvcmlnaW4gfSA9IG5ldyBVUkwocGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnJwY1VybCk7XG4gICAgaWYgKCFtYXRjaGVkQ2hhaW4ucnBjLm1hcCgocnBjKSA9PiBuZXcgVVJMKHJwYykub3JpZ2luKS5pbmNsdWRlcyhvcmlnaW4pKSB7XG4gICAgICBhbGVydHMucHVzaChNSVNNQVRDSEVEX05FVFdPUktfUlBDKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIW1hdGNoZWRDaGFpbikge1xuICAgIGFsZXJ0cy5wdXNoKFVOUkVDT0dOSVpFRF9DSEFJTik7XG4gIH1cblxuICBpZiAoYWxlcnRzLmxlbmd0aCkge1xuICAgIGFsZXJ0cy5wdXNoKE1JU01BVENIRURfQ0hBSU5fUkVDT01NRU5EQVRJT04pO1xuICB9XG5cbiAgcmV0dXJuIGFsZXJ0cztcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVzKHBlbmRpbmdBcHByb3ZhbCwgdCwgYWN0aW9ucywgaGlzdG9yeSkge1xuICBjb25zdCBvcmlnaW5Jc01ldGFNYXNrID0gcGVuZGluZ0FwcHJvdmFsLm9yaWdpbiA9PT0gJ21ldGFtYXNrJztcblxuICByZXR1cm4ge1xuICAgIGNvbnRlbnQ6IFtcbiAgICAgIHtcbiAgICAgICAgaGlkZTogIW9yaWdpbklzTWV0YU1hc2ssXG4gICAgICAgIGVsZW1lbnQ6ICdCb3gnLFxuICAgICAgICBrZXk6ICduZXR3b3JrLWJveCcsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdGV4dEFsaWduOiBURVhUX0FMSUdOLkNFTlRFUixcbiAgICAgICAgICBkaXNwbGF5OiBESVNQTEFZLkZMRVgsXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6IEpVU1RJRllfQ09OVEVOVC5DRU5URVIsXG4gICAgICAgICAgbWFyZ2luVG9wOiA0LFxuICAgICAgICAgIG1hcmdpbkJvdHRvbTogMixcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlbGVtZW50OiAnQ2hpcCcsXG4gICAgICAgICAgICBrZXk6ICduZXR3b3JrLWNoaXAnLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgbGFiZWw6IHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5jaGFpbk5hbWUsXG4gICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogQ09MT1JTLkJBQ0tHUk9VTkRfQUxURVJOQVRJVkUsXG4gICAgICAgICAgICAgIGxlZnRJY29uVXJsOiBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuaW1hZ2VVcmwsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBlbGVtZW50OiAnVHlwb2dyYXBoeScsXG4gICAgICAgIGtleTogJ3RpdGxlJyxcbiAgICAgICAgY2hpbGRyZW46IG9yaWdpbklzTWV0YU1hc2tcbiAgICAgICAgICA/IHQoJ3dhbnRUb0FkZFRoaXNOZXR3b3JrJylcbiAgICAgICAgICA6IHQoJ2FkZEV0aGVyZXVtQ2hhaW5Db25maXJtYXRpb25UaXRsZScpLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHZhcmlhbnQ6IFRZUE9HUkFQSFkuSDMsXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICBib3hQcm9wczoge1xuICAgICAgICAgICAgbWFyZ2luOiBbMCwgMCwgNF0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGVsZW1lbnQ6ICdUeXBvZ3JhcGh5JyxcbiAgICAgICAga2V5OiAnZGVzY3JpcHRpb24nLFxuICAgICAgICBjaGlsZHJlbjogdCgnYWRkRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvbkRlc2NyaXB0aW9uJyksXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdmFyaWFudDogVFlQT0dSQVBIWS5INyxcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgYm94UHJvcHM6IHtcbiAgICAgICAgICAgIG1hcmdpbjogb3JpZ2luSXNNZXRhTWFzayA/IFswLCA4LCA0XSA6IFswLCAwLCA0XSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZWxlbWVudDogJ1R5cG9ncmFwaHknLFxuICAgICAgICBrZXk6ICdvbmx5LWFkZC1uZXR3b3Jrcy15b3UtdHJ1c3QnLFxuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6ICdiJyxcbiAgICAgICAgICAgIGtleTogJ2JvbGRlZC10ZXh0JyxcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgIHN0eWxlOiB7IGRpc3BsYXk6IG9yaWdpbklzTWV0YU1hc2sgJiYgJy13ZWJraXQtYm94JyB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgIGAke3QoJ2FkZEV0aGVyZXVtQ2hhaW5Db25maXJtYXRpb25SaXNrcycpfSBgLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaGlkZTogIW9yaWdpbklzTWV0YU1hc2ssXG4gICAgICAgICAgICAgICAgZWxlbWVudDogJ1Rvb2x0aXAnLFxuICAgICAgICAgICAgICAgIGtleTogJ3Rvb2x0aXAtaW5mbycsXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgIGludGVyYWN0aXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogJ21vdXNlZW50ZXInLFxuICAgICAgICAgICAgICAgICAgaHRtbDogKFxuICAgICAgICAgICAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiAnMTgwcHgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMTZweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcbiAgICAgICAgICAgICAgICAgICAgICB9fVxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAge3QoJ3NvbWVOZXR3b3Jrc01heVBvc2VTZWN1cml0eScpfXsnICd9XG4gICAgICAgICAgICAgICAgICAgICAgPGFcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleT1cInplbmRlc2tfcGFnZV9saW5rXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY9e1pFTkRFU0tfVVJMUy5VTktOT1dOX05FVFdPUkt9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWw9XCJub3JlZmVycmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldD1cIl9ibGFua1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZT17eyBjb2xvcjogJ3ZhcigtLWNvbG9yLXByaW1hcnktZGVmYXVsdCknIH19XG4gICAgICAgICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgICAgICAgICAge3QoJ2xlYXJuTW9yZVVwcGVyQ2FzZScpfVxuICAgICAgICAgICAgICAgICAgICAgIDwvYT5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogJ2knLFxuICAgICAgICAgICAgICAgICAgICBrZXk6ICdpbmZvLWNpcmNsZScsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnZmFzIGZhLWluZm8tY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luTGVmdDogJzRweCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3ZhcigtLWNvbG9yLWljb24tZGVmYXVsdCknLFxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgZWxlbWVudDogJ01ldGFNYXNrVHJhbnNsYXRpb24nLFxuICAgICAgICAgICAga2V5OiAnbGVhcm4tYWJvdXQtcmlza3MnLFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6ICdhZGRFdGhlcmV1bUNoYWluQ29uZmlybWF0aW9uUmlza3NMZWFybk1vcmUnLFxuICAgICAgICAgICAgICB2YXJpYWJsZXM6IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBlbGVtZW50OiAnYScsXG4gICAgICAgICAgICAgICAgICBjaGlsZHJlbjogdCgnYWRkRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvblJpc2tzTGVhcm5Nb3JlTGluaycpLFxuICAgICAgICAgICAgICAgICAga2V5OiAnYWRkRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvblJpc2tzTGVhcm5Nb3JlTGluaycsXG4gICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBocmVmOiBaRU5ERVNLX1VSTFMuVVNFUl9HVUlERV9DVVNUT01fTkVUV09SS1MsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogJ19fYmxhbmsnLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgICBwcm9wczoge1xuICAgICAgICAgIHZhcmlhbnQ6IFRZUE9HUkFQSFkuSDcsXG4gICAgICAgICAgYm94UHJvcHM6IHtcbiAgICAgICAgICAgIG1hcmdpbjogb3JpZ2luSXNNZXRhTWFzayA/IFswLCA4XSA6IDAsXG4gICAgICAgICAgICBkaXNwbGF5OiBESVNQTEFZLkZMRVgsXG4gICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiBGTEVYX0RJUkVDVElPTi5DT0xVTU4sXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBBTElHTl9JVEVNUy5DRU5URVIsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGVsZW1lbnQ6ICdUcnVuY2F0ZWREZWZpbml0aW9uTGlzdCcsXG4gICAgICAgIGtleTogJ25ldHdvcmstZGV0YWlscycsXG4gICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgdGl0bGU6IHQoJ25ldHdvcmtEZXRhaWxzJyksXG4gICAgICAgICAgdG9vbHRpcHM6IHtcbiAgICAgICAgICAgIFt0KCduZXR3b3JrTmFtZScpXTogdCgnbmV0d29ya05hbWVEZWZpbml0aW9uJyksXG4gICAgICAgICAgICBbdCgnbmV0d29ya1VSTCcpXTogdCgnbmV0d29ya1VSTERlZmluaXRpb24nKSxcbiAgICAgICAgICAgIFt0KCdjaGFpbklkJyldOiB0KCdjaGFpbklkRGVmaW5pdGlvbicpLFxuICAgICAgICAgICAgW3QoJ2N1cnJlbmN5U3ltYm9sJyldOiB0KCdjdXJyZW5jeVN5bWJvbERlZmluaXRpb24nKSxcbiAgICAgICAgICAgIFt0KCdibG9ja0V4cGxvcmVyVXJsJyldOiB0KCdibG9ja0V4cGxvcmVyVXJsRGVmaW5pdGlvbicpLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGljdGlvbmFyeToge1xuICAgICAgICAgICAgW3QoJ25ldHdvcmtOYW1lJyldOiBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuY2hhaW5OYW1lLFxuICAgICAgICAgICAgW3QoJ25ldHdvcmtVUkwnKV06IHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5ycGNVcmw/LmluY2x1ZGVzKFxuICAgICAgICAgICAgICBgL3YzLyR7aW5mdXJhUHJvamVjdElkfWAsXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgID8gcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnJwY1VybC5yZXBsYWNlKFxuICAgICAgICAgICAgICAgICAgYC92My8ke2luZnVyYVByb2plY3RJZH1gLFxuICAgICAgICAgICAgICAgICAgJycsXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YS5ycGNVcmwsXG4gICAgICAgICAgICBbdCgnY2hhaW5JZCcpXTogcGFyc2VJbnQocGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLmNoYWluSWQsIDE2KSxcbiAgICAgICAgICAgIFt0KCdjdXJyZW5jeVN5bWJvbCcpXTogcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLnRpY2tlcixcbiAgICAgICAgICAgIFt0KCdibG9ja0V4cGxvcmVyVXJsJyldOlxuICAgICAgICAgICAgICBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEuYmxvY2tFeHBsb3JlclVybCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHByZWZhY2VLZXlzOiBbXG4gICAgICAgICAgICB0KCduZXR3b3JrTmFtZScpLFxuICAgICAgICAgICAgdCgnbmV0d29ya1VSTCcpLFxuICAgICAgICAgICAgdCgnY2hhaW5JZCcpLFxuICAgICAgICAgICAgdCgnY3VycmVuY3lTeW1ib2wnKSxcbiAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICBdLFxuICAgIGFwcHJvdmFsVGV4dDogdCgnYXBwcm92ZUJ1dHRvblRleHQnKSxcbiAgICBjYW5jZWxUZXh0OiB0KCdjYW5jZWwnKSxcbiAgICBvbkFwcHJvdmU6IGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGFjdGlvbnMucmVzb2x2ZVBlbmRpbmdBcHByb3ZhbChcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsLmlkLFxuICAgICAgICBwZW5kaW5nQXBwcm92YWwucmVxdWVzdERhdGEsXG4gICAgICApO1xuICAgICAgaWYgKG9yaWdpbklzTWV0YU1hc2spIHtcbiAgICAgICAgYWN0aW9ucy5hZGRDdXN0b21OZXR3b3JrKHBlbmRpbmdBcHByb3ZhbC5yZXF1ZXN0RGF0YSk7XG4gICAgICAgIGhpc3RvcnkucHVzaChERUZBVUxUX1JPVVRFKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG9uQ2FuY2VsOiAoKSA9PlxuICAgICAgYWN0aW9ucy5yZWplY3RQZW5kaW5nQXBwcm92YWwoXG4gICAgICAgIHBlbmRpbmdBcHByb3ZhbC5pZCxcbiAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoKS5zZXJpYWxpemUoKSxcbiAgICAgICksXG4gICAgbmV0d29ya0Rpc3BsYXk6ICFvcmlnaW5Jc01ldGFNYXNrLFxuICB9O1xufVxuXG5jb25zdCBhZGRFdGhlcmV1bUNoYWluID0ge1xuICBnZXRBbGVydHMsXG4gIGdldFZhbHVlcyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFkZEV0aGVyZXVtQ2hhaW47XG4iLCJpbXBvcnQgeyBvbWl0LCBwaWNrIH0gZnJvbSAnbG9kYXNoJztcclxuaW1wb3J0IHsgTUVTU0FHRV9UWVBFIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9hcHAnO1xyXG5pbXBvcnQge1xyXG4gIHJlamVjdFBlbmRpbmdBcHByb3ZhbCxcclxuICByZXNvbHZlUGVuZGluZ0FwcHJvdmFsLFxyXG4gIGFkZEN1c3RvbU5ldHdvcmssXHJcbn0gZnJvbSAnLi4vLi4vLi4vc3RvcmUvYWN0aW9ucyc7XHJcbmltcG9ydCBhZGRFdGhlcmV1bUNoYWluIGZyb20gJy4vYWRkLWV0aGVyZXVtLWNoYWluJztcclxuaW1wb3J0IHN3aXRjaEV0aGVyZXVtQ2hhaW4gZnJvbSAnLi9zd2l0Y2gtZXRoZXJldW0tY2hhaW4nO1xyXG5cblxyXG5jb25zdCBBUFBST1ZBTF9URU1QTEFURVMgPSB7XHJcbiAgW01FU1NBR0VfVFlQRS5BRERfRVRIRVJFVU1fQ0hBSU5dOiBhZGRFdGhlcmV1bUNoYWluLFxyXG4gIFtNRVNTQUdFX1RZUEUuU1dJVENIX0VUSEVSRVVNX0NIQUlOXTogc3dpdGNoRXRoZXJldW1DaGFpbixcclxuXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IFRFTVBMQVRFRF9DT05GSVJNQVRJT05fTUVTU0FHRV9UWVBFUyA9XHJcbiAgT2JqZWN0LmtleXMoQVBQUk9WQUxfVEVNUExBVEVTKTtcclxuXHJcbmNvbnN0IEFMTE9XRURfVEVNUExBVEVfS0VZUyA9IFtcclxuICAnY29udGVudCcsXHJcbiAgJ2FwcHJvdmFsVGV4dCcsXHJcbiAgJ2NhbmNlbFRleHQnLFxyXG4gICdvbkFwcHJvdmUnLFxyXG4gICdvbkNhbmNlbCcsXHJcbiAgJ25ldHdvcmtEaXNwbGF5JyxcclxuXTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBQZW5kaW5nQXBwcm92YWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IGlkIC0gVGhlIHJhbmRvbWx5IGdlbmVyYXRlZCBpZCBvZiB0aGUgYXBwcm92YWxcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIHNpdGUgcmVxdWVzdGluZyB0aGlzIGFwcHJvdmFsXHJcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB0aW1lIC0gVGhlIHRpbWUgdGhlIGFwcHJvdmFsIHdhcyByZXF1ZXN0ZWRcclxuICogQHByb3BlcnR5IHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBhcHByb3ZhbCBiZWluZyByZXF1ZXN0ZWRcclxuICogQHByb3BlcnR5IHtvYmplY3R9IHJlcXVlc3REYXRhIC0gVGhlIGRhdGEgc3VibWl0dGVkIHdpdGggdGhlIHJlcXVlc3RcclxuICovXHJcblxyXG4vKipcclxuICogZ2V0VGVtcGxhdGVBbGVydHMgY2FsbHMgdGhlIGdldEFsZXJ0cyBmdW5jdGlvbiBleHBvcnRlZCBieSB0aGUgdGVtcGxhdGUgaWZcclxuICogaXQgZXhpc3RzLCBhbmQgdGhlbiByZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhhdCBmdW5jdGlvbi4gSW4gdGhlIGNvbmZpcm1hdGlvblxyXG4gKiBwYWdlIHRoZSBhbGVydHMgcmV0dXJuZWQgZnJvbSB0aGUgZ2V0QWxlcnRzIG1ldGhvZCB3aWxsIGJlIHNldCBpbnRvIHRoZVxyXG4gKiBhbGVydFN0YXRlIHN0YXRlIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIHtvYmplY3R9IHBlbmRpbmdBcHByb3ZhbCAtIHRoZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb25maXJtYXRpb25cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUZW1wbGF0ZUFsZXJ0cyhwZW5kaW5nQXBwcm92YWwpIHtcclxuICBjb25zdCBmbiA9IEFQUFJPVkFMX1RFTVBMQVRFU1twZW5kaW5nQXBwcm92YWwudHlwZV0/LmdldEFsZXJ0cztcclxuICBjb25zdCByZXN1bHRzID0gZm4gPyBhd2FpdCBmbihwZW5kaW5nQXBwcm92YWwpIDogW107XHJcbiAgaWYgKCFBcnJheS5pc0FycmF5KHJlc3VsdHMpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIGFsZXJ0cyBtdXN0IGJlIGFuIGFycmF5LCByZWNlaXZlZDogJHtyZXN1bHRzfWApO1xyXG4gIH1cclxuICBpZiAocmVzdWx0cy5zb21lKChyZXN1bHQpID0+IHJlc3VsdD8uaWQgPT09IHVuZGVmaW5lZCkpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYFRlbXBsYXRlIGFsZXJ0IGVudHJpZXMgbXVzdCBiZSBvYmplY3RzIHdpdGggYW4gaWQga2V5LiBSZWNlaXZlZDogJHtyZXN1bHRzfWAsXHJcbiAgICApO1xyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0cztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBmdW5jdGlvbiBjYWxsIHRvIHJldHVybiBzdGF0ZSBtdXN0IGJlIGEgcHJvbWlzZSByZXR1cm5pbmcgZnVuY3Rpb25cclxuICogdGhpcyBcIk5PT1BcIiBpcyBoZXJlIHRvIGNvbmZvcm0gdG8gdGhlIHJlcXVpcmVtZW50cyBmb3IgdGVtcGxhdGVzIHdpdGhvdXRcclxuICogc3RhdGUuXHJcbiAqL1xyXG5hc3luYyBmdW5jdGlvbiBlbXB0eVN0YXRlKCkge1xyXG4gIHJldHVybiB7fTtcclxufVxyXG5cclxuLyoqXHJcbiAqIGdldFRlbXBsYXRlU3RhdGUgY2FsbHMgdGhlIGdldFN0YXRlIGZ1bmN0aW9uIGV4cG9ydGVkIGJ5IHRoZSB0ZW1wbGF0ZSBpZlxyXG4gKiBpdCBleGlzdHMsIGFuZCB0aGVuIHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGF0IGZ1bmN0aW9uLiBJbiB0aGUgY29uZmlybWF0aW9uXHJcbiAqIHBhZ2UgdGhlIG9iamVjdCByZXR1cm5lZCBmcm9tIHRoZSBnZXRTdGF0ZSBtZXRob2Qgd2lsbCBiZSBzZXQgaW50byB0aGVcclxuICogY29uZmlybWF0aW9uU3RhdGUgc3RhdGUgb2JqZWN0LiBOb3RlLCB0aGlzIHN0YXRlIGlzIG5vdCBjb25zdW1lZCBieSB0aGUgcGFnZVxyXG4gKiBpdHNlbGYuXHJcbiAqXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBwZW5kaW5nQXBwcm92YWwgLSB0aGUgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY29uZmlybWF0aW9uXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0VGVtcGxhdGVTdGF0ZShwZW5kaW5nQXBwcm92YWwpIHtcclxuICBjb25zdCBmbiA9IEFQUFJPVkFMX1RFTVBMQVRFU1twZW5kaW5nQXBwcm92YWwudHlwZV0/LmdldFN0YXRlID8/IGVtcHR5U3RhdGU7XHJcbiAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZm4ocGVuZGluZ0FwcHJvdmFsKTtcclxuICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRlbXBsYXRlIHN0YXRlIG11c3QgYmUgYW4gb2JqZWN0LCByZWNlaXZlZDogJHtyZXN1bHR9YCk7XHJcbiAgfSBlbHNlIGlmIChyZXN1bHQgPT09IG51bGwgfHwgcmVzdWx0ID09PSB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiB7fTtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdlIGRvIG5vdCB3YW50IHRvIHBhc3MgdGhlIGVudGlyZSBkaXNwYXRjaCBmdW5jdGlvbiB0byB0aGUgdGVtcGxhdGUuXHJcbiAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIHJldHVybiBhbiBvYmplY3Qgb2YgYWN0aW9ucyB0aGF0IHdlIGdlbmVyYWxseSBjb25zaWRlclxyXG4gKiB0byBiZSBzYWZlIGZvciB0ZW1wbGF0ZXMgdG8gaW52b2tlLiBJbiB0aGUgZnV0dXJlIHdlIGNvdWxkIHB1dCB0aGVzZSBiZWhpbmRcclxuICogcGVybWlzc2lvbiBzZXRzIHNvIHRoYXQgc25hcHMgdGhhdCB3aXNoIHRvIG1hbmlwdWxhdGUgc3RhdGUgbXVzdCBhc2sgZm9yXHJcbiAqIGV4cGxpY2l0IHBlcm1pc3Npb24gdG8gZG8gc28uXHJcbiAqXHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRpc3BhdGNoIC0gUmVkdXggZGlzcGF0Y2ggZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGdldEF0dGVudWF0ZWREaXNwYXRjaChkaXNwYXRjaCkge1xyXG4gIHJldHVybiB7XHJcbiAgICByZWplY3RQZW5kaW5nQXBwcm92YWw6ICguLi5hcmdzKSA9PlxyXG4gICAgICBkaXNwYXRjaChyZWplY3RQZW5kaW5nQXBwcm92YWwoLi4uYXJncykpLFxyXG4gICAgcmVzb2x2ZVBlbmRpbmdBcHByb3ZhbDogKC4uLmFyZ3MpID0+XHJcbiAgICAgIGRpc3BhdGNoKHJlc29sdmVQZW5kaW5nQXBwcm92YWwoLi4uYXJncykpLFxyXG4gICAgYWRkQ3VzdG9tTmV0d29yazogKC4uLmFyZ3MpID0+IGRpc3BhdGNoKGFkZEN1c3RvbU5ldHdvcmsoLi4uYXJncykpLFxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZWQgdmFsdWVzIHRvIGJlIGNvbnN1bWVkIGluIHRoZSBjb25maXJtYXRpb24gcGFnZVxyXG4gKlxyXG4gKiBAcGFyYW0ge29iamVjdH0gcGVuZGluZ0FwcHJvdmFsIC0gVGhlIHBlbmRpbmcgY29uZmlybWF0aW9uIG9iamVjdFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0IC0gVHJhbnNsYXRpb24gZnVuY3Rpb25cclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZGlzcGF0Y2ggLSBSZWR1eCBkaXNwYXRjaCBmdW5jdGlvblxyXG4gKiBAcGFyYW0gaGlzdG9yeVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFRlbXBsYXRlVmFsdWVzKHBlbmRpbmdBcHByb3ZhbCwgdCwgZGlzcGF0Y2gsIGhpc3RvcnkpIHtcclxuICBjb25zdCBmbiA9IEFQUFJPVkFMX1RFTVBMQVRFU1twZW5kaW5nQXBwcm92YWwudHlwZV0/LmdldFZhbHVlcztcclxuICBpZiAoIWZuKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgIGBNRVNTQUdFX1RZUEU6ICcke3BlbmRpbmdBcHByb3ZhbC50eXBlfScgaXMgbm90IHNwZWNpZmllZCBpbiBhcHByb3ZhbCB0ZW1wbGF0ZXNgLFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGNvbnN0IHNhZmVBY3Rpb25zID0gZ2V0QXR0ZW51YXRlZERpc3BhdGNoKGRpc3BhdGNoKTtcclxuICBjb25zdCB2YWx1ZXMgPSBmbihwZW5kaW5nQXBwcm92YWwsIHQsIHNhZmVBY3Rpb25zLCBoaXN0b3J5KTtcclxuICBjb25zdCBleHRyYW5lb3VzS2V5cyA9IG9taXQodmFsdWVzLCBBTExPV0VEX1RFTVBMQVRFX0tFWVMpO1xyXG4gIGNvbnN0IHNhZmVWYWx1ZXMgPSBwaWNrKHZhbHVlcywgQUxMT1dFRF9URU1QTEFURV9LRVlTKTtcclxuICBpZiAoZXh0cmFuZW91c0tleXMubGVuZ3RoID4gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgUmVjZWl2ZWQgZXh0cmFuZW91cyBrZXlzIGZyb20gJHtcclxuICAgICAgICBwZW5kaW5nQXBwcm92YWwudHlwZVxyXG4gICAgICB9LmdldFZhbHVlcy4gVGhlc2Uga2V5cyBhcmUgbm90IHBhc3NlZCB0byB0aGUgY29uZmlybWF0aW9uIHBhZ2U6ICR7T2JqZWN0LmtleXMoXHJcbiAgICAgICAgZXh0cmFuZW91c0tleXMsXHJcbiAgICAgICl9YCxcclxuICAgICk7XHJcbiAgfVxyXG4gIHJldHVybiBzYWZlVmFsdWVzO1xyXG59XHJcbiIsImltcG9ydCB7IGV0aEVycm9ycyB9IGZyb20gJ2V0aC1ycGMtZXJyb3JzJztcclxuaW1wb3J0IHtcclxuICBDT0xPUlMsXHJcbiAgSlVTVElGWV9DT05URU5ULFxyXG4gIFNFVkVSSVRJRVMsXHJcbiAgVFlQT0dSQVBIWSxcclxufSBmcm9tICcuLi8uLi8uLi9oZWxwZXJzL2NvbnN0YW50cy9kZXNpZ24tc3lzdGVtJztcclxuXHJcbmNvbnN0IFBFTkRJTkdfVFhfRFJPUF9OT1RJQ0UgPSB7XHJcbiAgaWQ6ICdQRU5ESU5HX1RYX0RST1BfTk9USUNFJyxcclxuICBzZXZlcml0eTogU0VWRVJJVElFUy5XQVJOSU5HLFxyXG4gIGNvbnRlbnQ6IHtcclxuICAgIGVsZW1lbnQ6ICdzcGFuJyxcclxuICAgIGNoaWxkcmVuOiB7XHJcbiAgICAgIGVsZW1lbnQ6ICdNZXRhTWFza1RyYW5zbGF0aW9uJyxcclxuICAgICAgcHJvcHM6IHtcclxuICAgICAgICB0cmFuc2xhdGlvbktleTogJ3N3aXRjaGluZ05ldHdvcmtzQ2FuY2Vsc1BlbmRpbmdDb25maXJtYXRpb25zJyxcclxuICAgICAgfSxcclxuICAgIH0sXHJcbiAgfSxcclxufTtcclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEFsZXJ0cygpIHtcclxuICByZXR1cm4gW1BFTkRJTkdfVFhfRFJPUF9OT1RJQ0VdO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZXRWYWx1ZXMocGVuZGluZ0FwcHJvdmFsLCB0LCBhY3Rpb25zKSB7XHJcbiAgcmV0dXJuIHtcclxuICAgIGNvbnRlbnQ6IFtcclxuICAgICAge1xyXG4gICAgICAgIGVsZW1lbnQ6ICdUeXBvZ3JhcGh5JyxcclxuICAgICAgICBrZXk6ICd0aXRsZScsXHJcbiAgICAgICAgY2hpbGRyZW46IHQoJ3N3aXRjaEV0aGVyZXVtQ2hhaW5Db25maXJtYXRpb25UaXRsZScpLFxyXG4gICAgICAgIHByb3BzOiB7XHJcbiAgICAgICAgICB2YXJpYW50OiBUWVBPR1JBUEhZLkgzLFxyXG4gICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXHJcbiAgICAgICAgICBib3hQcm9wczoge1xyXG4gICAgICAgICAgICBtYXJnaW46IFswLCAwLCAyXSxcclxuICAgICAgICAgICAgcGFkZGluZzogWzAsIDQsIDAsIDRdLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgZWxlbWVudDogJ1R5cG9ncmFwaHknLFxyXG4gICAgICAgIGtleTogJ2Rlc2NyaXB0aW9uJyxcclxuICAgICAgICBjaGlsZHJlbjogdCgnc3dpdGNoRXRoZXJldW1DaGFpbkNvbmZpcm1hdGlvbkRlc2NyaXB0aW9uJyksXHJcbiAgICAgICAgcHJvcHM6IHtcclxuICAgICAgICAgIHZhcmlhbnQ6IFRZUE9HUkFQSFkuSDcsXHJcbiAgICAgICAgICBjb2xvcjogQ09MT1JTLlRFWFRfQUxURVJOQVRJVkUsXHJcbiAgICAgICAgICBhbGlnbjogJ2NlbnRlcicsXHJcbiAgICAgICAgICBib3hQcm9wczoge1xyXG4gICAgICAgICAgICBwYWRkaW5nOiBbMCwgNCwgMCwgNF0sXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBlbGVtZW50OiAnQm94JyxcclxuICAgICAgICBrZXk6ICdzdGF0dXMtYm94JyxcclxuICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAganVzdGlmeUNvbnRlbnQ6IEpVU1RJRllfQ09OVEVOVC5DRU5URVIsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjaGlsZHJlbjoge1xyXG4gICAgICAgICAgZWxlbWVudDogJ0NvbmZpcm1hdGlvbk5ldHdvcmtTd2l0Y2gnLFxyXG4gICAgICAgICAga2V5OiAnbmV0d29yay1iZWluZy1zd2l0Y2hlZCcsXHJcbiAgICAgICAgICBwcm9wczoge1xyXG4gICAgICAgICAgICBuZXdOZXR3b3JrOiB7XHJcbiAgICAgICAgICAgICAgY2hhaW5JZDogcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLmNoYWluSWQsXHJcbiAgICAgICAgICAgICAgbmFtZTogcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLm5pY2tuYW1lLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICB9LFxyXG4gICAgXSxcclxuICAgIGFwcHJvdmFsVGV4dDogdCgnc3dpdGNoTmV0d29yaycpLFxyXG4gICAgY2FuY2VsVGV4dDogdCgnY2FuY2VsJyksXHJcbiAgICBvbkFwcHJvdmU6ICgpID0+XHJcbiAgICAgIGFjdGlvbnMucmVzb2x2ZVBlbmRpbmdBcHByb3ZhbChcclxuICAgICAgICBwZW5kaW5nQXBwcm92YWwuaWQsXHJcbiAgICAgICAgcGVuZGluZ0FwcHJvdmFsLnJlcXVlc3REYXRhLFxyXG4gICAgICApLFxyXG5cclxuICAgIG9uQ2FuY2VsOiAoKSA9PlxyXG4gICAgICBhY3Rpb25zLnJlamVjdFBlbmRpbmdBcHByb3ZhbChcclxuICAgICAgICBwZW5kaW5nQXBwcm92YWwuaWQsXHJcbiAgICAgICAgZXRoRXJyb3JzLnByb3ZpZGVyLnVzZXJSZWplY3RlZFJlcXVlc3QoKS5zZXJpYWxpemUoKSxcclxuICAgICAgKSxcclxuICAgIG5ldHdvcmtEaXNwbGF5OiB0cnVlLFxyXG4gIH07XHJcbn1cclxuXHJcbmNvbnN0IHN3aXRjaEV0aGVyZXVtQ2hhaW4gPSB7XHJcbiAgZ2V0QWxlcnRzLFxyXG4gIGdldFZhbHVlcyxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHN3aXRjaEV0aGVyZXVtQ2hhaW47XHJcbiIsImltcG9ydCB7XHJcbiAgY29udmVyc2lvblV0aWwsXHJcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxyXG59IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9tb2R1bGVzL2NvbnZlcnNpb24udXRpbHMnO1xyXG5pbXBvcnQgeyBhZGRIZXhQcmVmaXggfSBmcm9tICcuLi8uLi8uLi9hcHAvc2NyaXB0cy9saWIvdXRpbCc7XHJcbmltcG9ydCB7IE1JTl9HQVNfTElNSVRfSEVYIH0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL2NvbnN0YW50cy9nYXMnO1xyXG5cclxuY29uc3QgTUlOX0dBU19QUklDRV9ERUMgPSAnMCc7XHJcbmNvbnN0IE1JTl9HQVNfUFJJQ0VfSEVYID0gcGFyc2VJbnQoTUlOX0dBU19QUklDRV9ERUMsIDEwKS50b1N0cmluZygxNik7XHJcbmNvbnN0IE1JTl9HQVNfTElNSVRfREVDID0gJzIxMDAwJztcclxuY29uc3QgTUFYX0dBU19MSU1JVF9ERUMgPSAnNzkyMDAyNyc7XHJcblxyXG5jb25zdCBISUdIX0ZFRV9XQVJOSU5HX01VTFRJUExJRVIgPSAxLjU7XHJcbmNvbnN0IE1JTl9HQVNfUFJJQ0VfR1dFSSA9IGFkZEhleFByZWZpeChcclxuICBjb252ZXJzaW9uVXRpbChNSU5fR0FTX1BSSUNFX0hFWCwge1xyXG4gICAgZnJvbURlbm9taW5hdGlvbjogJ1dFSScsXHJcbiAgICB0b0Rlbm9taW5hdGlvbjogJ0dXRUknLFxyXG4gICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcclxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxyXG4gICAgbnVtYmVyT2ZEZWNpbWFsczogMSxcclxuICB9KSxcclxuKTtcclxuXHJcbmNvbnN0IE1JTl9HQVNfVE9UQUwgPSBtdWx0aXBseUN1cnJlbmNpZXMoTUlOX0dBU19MSU1JVF9IRVgsIE1JTl9HQVNfUFJJQ0VfSEVYLCB7XHJcbiAgdG9OdW1lcmljQmFzZTogJ2hleCcsXHJcbiAgbXVsdGlwbGljYW5kQmFzZTogMTYsXHJcbiAgbXVsdGlwbGllckJhc2U6IDE2LFxyXG59KTtcclxuXHJcbmNvbnN0IFRPS0VOX1RSQU5TRkVSX0ZVTkNUSU9OX1NJR05BVFVSRSA9ICcweGE5MDU5Y2JiJztcclxuY29uc3QgQ09MTEVDVElCTEVfVFJBTlNGRVJfRlJPTV9GVU5DVElPTl9TSUdOQVRVUkUgPSAnMHgyM2I4NzJkZCc7XHJcblxyXG5jb25zdCBJTlNVRkZJQ0lFTlRfRlVORFNfRVJST1IgPSAnaW5zdWZmaWNpZW50RnVuZHMnO1xyXG5jb25zdCBJTlNVRkZJQ0lFTlRfVE9LRU5TX0VSUk9SID0gJ2luc3VmZmljaWVudFRva2Vucyc7XHJcbmNvbnN0IE5FR0FUSVZFX0VUSF9FUlJPUiA9ICduZWdhdGl2ZUVUSCc7XHJcbmNvbnN0IElOVkFMSURfUkVDSVBJRU5UX0FERFJFU1NfRVJST1IgPSAnaW52YWxpZEFkZHJlc3NSZWNpcGllbnQnO1xyXG5jb25zdCBJTlZBTElEX1JFQ0lQSUVOVF9BRERSRVNTX05PVF9FVEhfTkVUV09SS19FUlJPUiA9XHJcbiAgJ2ludmFsaWRBZGRyZXNzUmVjaXBpZW50Tm90RXRoTmV0d29yayc7XHJcbmNvbnN0IFJFUVVJUkVEX0VSUk9SID0gJ3JlcXVpcmVkJztcclxuY29uc3QgS05PV05fUkVDSVBJRU5UX0FERFJFU1NfV0FSTklORyA9ICdrbm93bkFkZHJlc3NSZWNpcGllbnQnO1xyXG5jb25zdCBDT05UUkFDVF9BRERSRVNTX0VSUk9SID0gJ2NvbnRyYWN0QWRkcmVzc0Vycm9yJztcclxuY29uc3QgQ09ORlVTSU5HX0VOU19FUlJPUiA9ICdjb25mdXNpbmdFbnNEb21haW4nO1xyXG5jb25zdCBFTlNfTk9fQUREUkVTU19GT1JfTkFNRSA9ICdub0FkZHJlc3NGb3JOYW1lJztcclxuY29uc3QgRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLID0gJ2Vuc05vdEZvdW5kT25DdXJyZW50TmV0d29yayc7XHJcbmNvbnN0IEVOU19OT1RfU1VQUE9SVEVEX09OX05FVFdPUksgPSAnZW5zTm90U3VwcG9ydGVkT25OZXR3b3JrJztcclxuY29uc3QgRU5TX0lMTEVHQUxfQ0hBUkFDVEVSID0gJ2Vuc0lsbGVnYWxDaGFyYWN0ZXInO1xyXG5jb25zdCBFTlNfVU5LTk9XTl9FUlJPUiA9ICdlbnNVbmtub3duRXJyb3InO1xyXG5jb25zdCBFTlNfUkVHSVNUUkFUSU9OX0VSUk9SID0gJ2Vuc1JlZ2lzdHJhdGlvbkVycm9yJztcclxuXHJcbmNvbnN0IFJFQ0lQSUVOVF9UWVBFUyA9IHtcclxuICBTTUFSVF9DT05UUkFDVDogJ1NNQVJUX0NPTlRSQUNUJyxcclxuICBOT05fQ09OVFJBQ1Q6ICdOT05fQ09OVFJBQ1QnLFxyXG59O1xyXG5cclxuZXhwb3J0IHtcclxuICBNQVhfR0FTX0xJTUlUX0RFQyxcclxuICBISUdIX0ZFRV9XQVJOSU5HX01VTFRJUExJRVIsXHJcbiAgSU5TVUZGSUNJRU5UX0ZVTkRTX0VSUk9SLFxyXG4gIElOU1VGRklDSUVOVF9UT0tFTlNfRVJST1IsXHJcbiAgSU5WQUxJRF9SRUNJUElFTlRfQUREUkVTU19FUlJPUixcclxuICBLTk9XTl9SRUNJUElFTlRfQUREUkVTU19XQVJOSU5HLFxyXG4gIENPTlRSQUNUX0FERFJFU1NfRVJST1IsXHJcbiAgSU5WQUxJRF9SRUNJUElFTlRfQUREUkVTU19OT1RfRVRIX05FVFdPUktfRVJST1IsXHJcbiAgRU5TX05PX0FERFJFU1NfRk9SX05BTUUsXHJcbiAgRU5TX05PVF9GT1VORF9PTl9ORVRXT1JLLFxyXG4gIEVOU19OT1RfU1VQUE9SVEVEX09OX05FVFdPUkssXHJcbiAgRU5TX0lMTEVHQUxfQ0hBUkFDVEVSLFxyXG4gIEVOU19VTktOT1dOX0VSUk9SLFxyXG4gIEVOU19SRUdJU1RSQVRJT05fRVJST1IsXHJcbiAgTUlOX0dBU19MSU1JVF9ERUMsXHJcbiAgTUlOX0dBU19QUklDRV9ERUMsXHJcbiAgTUlOX0dBU19QUklDRV9HV0VJLFxyXG4gIE1JTl9HQVNfUFJJQ0VfSEVYLFxyXG4gIE1JTl9HQVNfVE9UQUwsXHJcbiAgTkVHQVRJVkVfRVRIX0VSUk9SLFxyXG4gIFJFUVVJUkVEX0VSUk9SLFxyXG4gIENPTkZVU0lOR19FTlNfRVJST1IsXHJcbiAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFLFxyXG4gIENPTExFQ1RJQkxFX1RSQU5TRkVSX0ZST01fRlVOQ1RJT05fU0lHTkFUVVJFLFxyXG4gIFJFQ0lQSUVOVF9UWVBFUyxcclxufTtcclxuIiwiaW1wb3J0IGFiaSBmcm9tICdldGhlcmV1bWpzLWFiaSc7XG5pbXBvcnQge1xuICBhZGRDdXJyZW5jaWVzLFxuICBjb252ZXJzaW9uVXRpbCxcbiAgY29udmVyc2lvbkdURSxcbiAgbXVsdGlwbHlDdXJyZW5jaWVzLFxuICBjb252ZXJzaW9uR3JlYXRlclRoYW4sXG4gIGNvbnZlcnNpb25MZXNzVGhhbixcbn0gZnJvbSAnLi4vLi4vLi4vc2hhcmVkL21vZHVsZXMvY29udmVyc2lvbi51dGlscyc7XG5cbmltcG9ydCB7IGFkZEhleFByZWZpeCB9IGZyb20gJy4uLy4uLy4uL2FwcC9zY3JpcHRzL2xpYi91dGlsJztcbmltcG9ydCB7IEVSQzIwLCBFUkM3MjEgfSBmcm9tICcuLi8uLi8uLi9zaGFyZWQvY29uc3RhbnRzL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGNhbGNUb2tlbkFtb3VudCB9IGZyb20gJy4uLy4uLy4uL3NoYXJlZC9saWIvdHJhbnNhY3Rpb25zLWNvbnRyb2xsZXItdXRpbHMnO1xuaW1wb3J0IHtcbiAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFLFxuICBDT0xMRUNUSUJMRV9UUkFOU0ZFUl9GUk9NX0ZVTkNUSU9OX1NJR05BVFVSRSxcbn0gZnJvbSAnLi9zZW5kLmNvbnN0YW50cyc7XG5cbmV4cG9ydCB7XG4gIGFkZEdhc0J1ZmZlcixcbiAgZ2V0QXNzZXRUcmFuc2ZlckRhdGEsXG4gIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEsXG4gIGdlbmVyYXRlRVJDNzIxVHJhbnNmZXJEYXRhLFxuICBpc0JhbGFuY2VTdWZmaWNpZW50LFxuICBpc1Rva2VuQmFsYW5jZVN1ZmZpY2llbnQsXG4gIGVsbGlwc2lmeSxcbn07XG5cbmZ1bmN0aW9uIGlzQmFsYW5jZVN1ZmZpY2llbnQoe1xuICBhbW91bnQgPSAnMHgwJyxcbiAgYmFsYW5jZSA9ICcweDAnLFxuICBjb252ZXJzaW9uUmF0ZSA9IDEsXG4gIGdhc1RvdGFsID0gJzB4MCcsXG4gIHByaW1hcnlDdXJyZW5jeSxcbn0pIHtcbiAgY29uc3QgdG90YWxBbW91bnQgPSBhZGRDdXJyZW5jaWVzKGFtb3VudCwgZ2FzVG90YWwsIHtcbiAgICBhQmFzZTogMTYsXG4gICAgYkJhc2U6IDE2LFxuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICB9KTtcblxuICBjb25zdCBiYWxhbmNlSXNTdWZmaWNpZW50ID0gY29udmVyc2lvbkdURShcbiAgICB7XG4gICAgICB2YWx1ZTogYmFsYW5jZSxcbiAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgICBmcm9tQ3VycmVuY3k6IHByaW1hcnlDdXJyZW5jeSxcbiAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgIH0sXG4gICAge1xuICAgICAgdmFsdWU6IHRvdGFsQW1vdW50LFxuICAgICAgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyxcbiAgICAgIGNvbnZlcnNpb25SYXRlLFxuICAgICAgZnJvbUN1cnJlbmN5OiBwcmltYXJ5Q3VycmVuY3ksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4gYmFsYW5jZUlzU3VmZmljaWVudDtcbn1cblxuZnVuY3Rpb24gaXNUb2tlbkJhbGFuY2VTdWZmaWNpZW50KHsgYW1vdW50ID0gJzB4MCcsIHRva2VuQmFsYW5jZSwgZGVjaW1hbHMgfSkge1xuICBjb25zdCBhbW91bnRJbkRlYyA9IGNvbnZlcnNpb25VdGlsKGFtb3VudCwge1xuICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gIH0pO1xuXG4gIGNvbnN0IHRva2VuQmFsYW5jZUlzU3VmZmljaWVudCA9IGNvbnZlcnNpb25HVEUoXG4gICAge1xuICAgICAgdmFsdWU6IHRva2VuQmFsYW5jZSxcbiAgICAgIGZyb21OdW1lcmljQmFzZTogJ2hleCcsXG4gICAgfSxcbiAgICB7XG4gICAgICB2YWx1ZTogY2FsY1Rva2VuQW1vdW50KGFtb3VudEluRGVjLCBkZWNpbWFscyksXG4gICAgfSxcbiAgKTtcblxuICByZXR1cm4gdG9rZW5CYWxhbmNlSXNTdWZmaWNpZW50O1xufVxuXG5mdW5jdGlvbiBhZGRHYXNCdWZmZXIoXG4gIGluaXRpYWxHYXNMaW1pdEhleCxcbiAgYmxvY2tHYXNMaW1pdEhleCxcbiAgYnVmZmVyTXVsdGlwbGllciA9IDEuNSxcbikge1xuICBjb25zdCB1cHBlckdhc0xpbWl0ID0gbXVsdGlwbHlDdXJyZW5jaWVzKGJsb2NrR2FzTGltaXRIZXgsIDAuOSwge1xuICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgIG11bHRpcGxpY2FuZEJhc2U6IDE2LFxuICAgIG11bHRpcGxpZXJCYXNlOiAxMCxcbiAgICBudW1iZXJPZkRlY2ltYWxzOiAnMCcsXG4gIH0pO1xuICBjb25zdCBidWZmZXJlZEdhc0xpbWl0ID0gbXVsdGlwbHlDdXJyZW5jaWVzKFxuICAgIGluaXRpYWxHYXNMaW1pdEhleCxcbiAgICBidWZmZXJNdWx0aXBsaWVyLFxuICAgIHtcbiAgICAgIHRvTnVtZXJpY0Jhc2U6ICdoZXgnLFxuICAgICAgbXVsdGlwbGljYW5kQmFzZTogMTYsXG4gICAgICBtdWx0aXBsaWVyQmFzZTogMTAsXG4gICAgICBudW1iZXJPZkRlY2ltYWxzOiAnMCcsXG4gICAgfSxcbiAgKTtcblxuICAvLyBpZiBpbml0aWFsR2FzTGltaXQgaXMgYWJvdmUgYmxvY2tHYXNMaW1pdCwgZG9udCBtb2RpZnkgaXRcbiAgaWYgKFxuICAgIGNvbnZlcnNpb25HcmVhdGVyVGhhbihcbiAgICAgIHsgdmFsdWU6IGluaXRpYWxHYXNMaW1pdEhleCwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxuICAgICAgeyB2YWx1ZTogdXBwZXJHYXNMaW1pdCwgZnJvbU51bWVyaWNCYXNlOiAnaGV4JyB9LFxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuIGluaXRpYWxHYXNMaW1pdEhleDtcbiAgfVxuICAvLyBpZiBidWZmZXJlZEdhc0xpbWl0IGlzIGJlbG93IGJsb2NrR2FzTGltaXQsIHVzZSBidWZmZXJlZEdhc0xpbWl0XG4gIGlmIChcbiAgICBjb252ZXJzaW9uTGVzc1RoYW4oXG4gICAgICB7IHZhbHVlOiBidWZmZXJlZEdhc0xpbWl0LCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgICB7IHZhbHVlOiB1cHBlckdhc0xpbWl0LCBmcm9tTnVtZXJpY0Jhc2U6ICdoZXgnIH0sXG4gICAgKVxuICApIHtcbiAgICByZXR1cm4gYnVmZmVyZWRHYXNMaW1pdDtcbiAgfVxuICAvLyBvdGhlcndpc2UgdXNlIGJsb2NrR2FzTGltaXRcbiAgcmV0dXJuIHVwcGVyR2FzTGltaXQ7XG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEoe1xuICB0b0FkZHJlc3MgPSAnMHgwJyxcbiAgYW1vdW50ID0gJzB4MCcsXG4gIHNlbmRUb2tlbixcbn0pIHtcbiAgaWYgKCFzZW5kVG9rZW4pIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAoXG4gICAgVE9LRU5fVFJBTlNGRVJfRlVOQ1RJT05fU0lHTkFUVVJFICtcbiAgICBBcnJheS5wcm90b3R5cGUubWFwXG4gICAgICAuY2FsbChcbiAgICAgICAgYWJpLnJhd0VuY29kZShcbiAgICAgICAgICBbJ2FkZHJlc3MnLCAndWludDI1NiddLFxuICAgICAgICAgIFthZGRIZXhQcmVmaXgodG9BZGRyZXNzKSwgYWRkSGV4UHJlZml4KGFtb3VudCldLFxuICAgICAgICApLFxuICAgICAgICAoeCkgPT4gYDAwJHt4LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxcbiAgICAgIClcbiAgICAgIC5qb2luKCcnKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVSQzcyMVRyYW5zZmVyRGF0YSh7XG4gIHRvQWRkcmVzcyA9ICcweDAnLFxuICBmcm9tQWRkcmVzcyA9ICcweDAnLFxuICB0b2tlbklkLFxufSkge1xuICBpZiAoIXRva2VuSWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAoXG4gICAgQ09MTEVDVElCTEVfVFJBTlNGRVJfRlJPTV9GVU5DVElPTl9TSUdOQVRVUkUgK1xuICAgIEFycmF5LnByb3RvdHlwZS5tYXBcbiAgICAgIC5jYWxsKFxuICAgICAgICBhYmkucmF3RW5jb2RlKFxuICAgICAgICAgIFsnYWRkcmVzcycsICdhZGRyZXNzJywgJ3VpbnQyNTYnXSxcbiAgICAgICAgICBbYWRkSGV4UHJlZml4KGZyb21BZGRyZXNzKSwgYWRkSGV4UHJlZml4KHRvQWRkcmVzcyksIHRva2VuSWRdLFxuICAgICAgICApLFxuICAgICAgICAoeCkgPT4gYDAwJHt4LnRvU3RyaW5nKDE2KX1gLnNsaWNlKC0yKSxcbiAgICAgIClcbiAgICAgIC5qb2luKCcnKVxuICApO1xufVxuXG5mdW5jdGlvbiBnZXRBc3NldFRyYW5zZmVyRGF0YSh7IHNlbmRUb2tlbiwgZnJvbUFkZHJlc3MsIHRvQWRkcmVzcywgYW1vdW50IH0pIHtcbiAgc3dpdGNoIChzZW5kVG9rZW4uc3RhbmRhcmQpIHtcbiAgICBjYXNlIEVSQzcyMTpcbiAgICAgIHJldHVybiBnZW5lcmF0ZUVSQzcyMVRyYW5zZmVyRGF0YSh7XG4gICAgICAgIHRvQWRkcmVzcyxcbiAgICAgICAgZnJvbUFkZHJlc3MsXG4gICAgICAgIHRva2VuSWQ6IHNlbmRUb2tlbi50b2tlbklkLFxuICAgICAgfSk7XG4gICAgY2FzZSBFUkMyMDpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGdlbmVyYXRlRVJDMjBUcmFuc2ZlckRhdGEoe1xuICAgICAgICB0b0FkZHJlc3MsXG4gICAgICAgIGFtb3VudCxcbiAgICAgICAgc2VuZFRva2VuLFxuICAgICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZWxsaXBzaWZ5KHRleHQsIGZpcnN0ID0gNiwgbGFzdCA9IDQpIHtcbiAgcmV0dXJuIGAke3RleHQuc2xpY2UoMCwgZmlyc3QpfS4uLiR7dGV4dC5zbGljZSgtbGFzdCl9YDtcbn1cbiJdLCJwcmVFeGlzdGluZ0NvbW1lbnQiOiIvLyMgc291cmNlTWFwcGluZ1VSTD1icm93c2VyLXBvbHlmaWxsLmpzLm1hcCJ9
